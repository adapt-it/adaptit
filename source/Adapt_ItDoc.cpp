/////////////////////////////////////////////////////////////////////////////
/// \project		adaptit
/// \file			Adapt_ItDoc.cpp
/// \author			Bill Martin
/// \date_created	05 January 2004
/// \rcs_id $Id$
/// \copyright		2008 Bruce Waters, Bill Martin, SIL International
/// \license		The Common Public License or The GNU Lesser General Public License (see license directory)
/// \description	This is the implementation file for the CAdapt_ItDoc class.
/// The CAdapt_ItDoc class implements the storage structures and methods
/// for the Adapt It application's persistent data. Adapt It's document
/// consists mainly of a list of CSourcePhrases stored in order of occurrence
/// of source text words. The document's data structures are kept logically
/// separate from and independent of the view class's in-memory data structures.
/// This schema is an implementation of the document/view framework.
/// \derivation		The CAdapt_ItDoc class is derived from wxDocument.
/////////////////////////////////////////////////////////////////////////////

//#define _debugLayout
// comment out next line to turn of the wxLogDebug calls in this file
//#define LOG_USFM3
#define maxLen 60
//#define _AT_PTR
//#define FIXORDER
//#define LOGMKRS
//#define WHERE
const int logStart = 2;
const int logEnd = 5;
//#define SEEPTR
#define NOLOGS
//#define NOPAREN

#if defined(__GNUG__) && !defined(__APPLE__)
#pragma implementation "Adapt_ItDoc.h"
#endif

// For compilers that support precompilation, includes "wx.h".
#include <wx/wxprec.h>

// BEW 29Jun16, for debugging support
//#define TOKENIZE_BUG
size_t aSequNum; // use with TOKENIZE_BUG



#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
// Include your minimal set of headers here, or wx.h
#include <wx/wx.h>
#endif

#include <wx/docview.h>	// includes wxWidgets doc/view framework
#include "Adapt_ItCanvas.h"
#include "Adapt_It_Resources.h"
#include <wx/filesys.h>
#include <wx/file.h>
#include <wx/wfstream.h>
#include <wx/zipstrm.h> // for wxZipInputStream & wxZipOutputStream
#include <wx/datstrm.h> // permanent
#include <wx/txtstrm.h> // temporary
#include <wx/mstream.h> // for wxMemoryInputStream
#include <wx/font.h> // temporary
#include <wx/fontmap.h> // temporary
#include <wx/fontenum.h> // temporary
#include <wx/list.h>
#include <wx/tokenzr.h>
#include <wx/progdlg.h>
#include <wx/busyinfo.h>
#include <wx/dir.h> // for wxDir
#include <wx/textfile.h>

#if !defined(__APPLE__)
#include <malloc.h>
#else
#include <malloc/malloc.h>
#endif

// The following are from IBM's International Components for Unicode (icu) used under the LGPL license.
//#include "csdetect.h" // used in GetNewFile().
//#include "csmatch.h" // " "

// Other includes uncomment as implemented

#include "Adapt_It.h"
#include "OutputFilenameDlg.h"
#include "helpers.h"
#include "CollabUtilities.h"
#include "MainFrm.h"
#include "SourcePhrase.h"
#include "KB.h"
#include "AdaptitConstants.h"
#include "TargetUnit.h"
#include "Adapt_ItDoc.h"
#include "Adapt_ItView.h"
#include "Strip.h"
#include "Pile.h" // must precede the include for the document
#include "Cell.h"
#include "Layout.h"
#include "BookNameDlg.h" // BEW added 7Aug12
#include "RefString.h"
#include "RefStringMetadata.h"
//#include "ProgressDlg.h" // removed in svn revision #562
#include "WaitDlg.h"
#include "XML.h"
#include "MoveDialog.h"
#include "SplitDialog.h"
#include "JoinDialog.h"
#include "UnpackWarningDlg.h"
#include "FreeTrans.h"
#include "Notes.h"
#include "ExportFunctions.h"
#include "ReadOnlyProtection.h"
#include "ConsistencyCheckDlg.h"
#include "ChooseConsistencyCheckTypeDlg.h" //whm added 9Feb04
#include "NavProtectNewDoc.h"
#include "ConsChk_Empty_noTU_Dlg.h"
#include "conschk_exists_notu_dlg.h"
#include "DVCS.h"
#include "DVCSNavDlg.h"
#include "DVCSLogDlg.h"
#include "StatusBar.h"
#include "ChooseTranslation.h"
#include "BString.h"


// GDLC Removed conditionals for PPC Mac (with gcc4.0 they are no longer needed)
void init_utf8_char_table();
const char* tellenc(const char* const buffer, const size_t len);

// Define type safe pointer lists
#include "wx/listimpl.cpp"

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called AFList.
WX_DEFINE_LIST(AFList);
WX_DEFINE_LIST(AFGList);

// BEW 11Jul23 added
//WX_DEFINE_LIST(mySPList);

/// This global is defined in Adapt_ItView.cpp.
extern bool gbVerticalEditInProgress;

/// This global is defined in Adapt_ItView.cpp.
extern EditRecord gEditRecord; // defined at start of Adapt_ItView.cpp

/// This global is defined in Adapt_It.cpp.
extern enum TextType gPreviousTextType; // moved to global space in the App, made extern here

// Other declarations from MFC version below

/// Length of the byte-order-mark (BOM) which consists of the three bytes 0xEF, 0xBB and 0xBF
/// in UTF-8 encoding.
#define nBOMLen 3

extern wxMutex s_AutoSaveMutex;

/// Length of the byte-order-mark (BOM) which consists of the two bytes 0xFF and 0xFE in
/// in UTF-16 encoding.
#define nU16BOMLen 2

//#define LOG_CREATES

//#define SETH_16OCT15

#ifdef _UNICODE

/// The UTF-8 byte-order-mark (BOM) consists of the three bytes 0xEF, 0xBB and 0xBF
/// in UTF-8 encoding. Some applications like Notepad prefix UTF-8 files with
/// this BOM.
//static wxUint8 szBOM[nBOMLen] = {0xEF, 0xBB, 0xBF}; // MFC uses BYTE

/// The UTF-16 byte-order-mark (BOM) which consists of the two bytes 0xFF and 0xFE in
/// in UTF-16 encoding.
//static wxUint8 szU16BOM[nU16BOMLen] = {0xFF, 0xFE}; // MFC uses BYTE

#endif

/// This global boolean informs the Doc's BackupDocument() function whether a split or
/// join operation is in progress. If gbDoingSplitOrJoin is TRUE BackupDocument() exits
/// immediately without performing any backup operations. Split operations especially
/// could produce a plethora of backup docs, especially for a single-chapters document split.
bool gbDoingSplitOrJoin = FALSE; // TRUE during one of these 3 operations

/// This global is defined in DocPage.cpp.
extern bool gbMismatchedBookCode; // BEW added 21Mar07

// This global is defined in Adapt_It.cpp.
//extern bool	gbTryingMRUOpen; // whm 1Oct12 removed

/// This global is defined in MainFrm.cpp.
extern bool gbIgnoreScriptureReference_Receive;

/// This global is used only in RetokenizeText() to increment the number n associated with
/// the final number n composing the "Rebuild Logn.txt" files, which inform the user of
/// any problems encountered during document rebuilding.
int gnFileNumber = 0; // used for output of Rebuild Logn.txt file, to increment n each time

/// This global is defined in TransferMarkersDlg.cpp.
extern bool gbPropagationNeeded;

/// This global is defined in TransferMarkersDlg.cpp.
extern TextType gPropagationType;

/// This global is defined in Adapt_ItView.cpp.
extern bool gbIsUnstructuredData;

// next four are for version 2.0 which includes the option of a 3rd line for glossing

/// This global is defined in Adapt_ItView.cpp.
extern bool	gbIsGlossing; // when TRUE, the phrase box and its line have glossing text

/// This global is defined in Adapt_ItView.cpp.
extern bool	gbGlossingVisible; // TRUE makes Adapt It revert to Shoebox functionality only

/// This global is defined in Adapt_ItView.cpp.
extern bool gbGlossingUsesNavFont;

// This global is defined in DocPage.cpp.
//extern bool  gbForceUTF8; // defined in CDocPage // not used within Adapt_ItDoc.cpp

/// This global is defined in Adapt_It.cpp.
extern wxChar gSFescapechar; // the escape char used for start of a standard format marker

// BEW 8Jun10, removed support for checkbox "Recognise standard format
// markers only following newlines"
// This global is defined in Adapt_It.cpp.
//extern bool  gbSfmOnlyAfterNewlines;

/// This global is defined in Adapt_It.cpp.
extern bool  gbDoingInitialSetup;

/// This global is defined in Adapt_It.cpp.
extern CAdapt_ItApp* gpApp; // if we want to access it fast

/// Indicates if a source word or phrase is to be considered special text when the propagation
/// of text attributes needs to be considered as after editing the source text or after rebuilding
/// the source text subsequent to filtering changes. Normally used to set or store the m_bSpecialText
/// attribute of a source phrase instance.
bool   gbSpecialText = FALSE;

/// This global is defined in Adapt_ItView.cpp.
extern CSourcePhrase* gpPrecSrcPhrase;

/// This global is defined in Adapt_ItView.cpp.
extern CSourcePhrase* gpFollSrcPhrase;

/// This global is defined in Adapt_ItView.cpp.
extern	bool	gbShowTargetOnly;

/// This global is defined in Adapt_ItView.cpp.
extern	int		gnSaveLeading;

/// Indicates if the user has cancelled an operation.
bool	bUserCancelled = FALSE;

// This global is defined in Adapt_It.cpp.
//extern	bool	gbViaMostRecentFileList; // whm removed 1Oct12

/// This global is defined in Adapt_ItView.cpp.
extern	bool	gbConsistencyCheckCurrent;

// This global is defined in Adapt_It.cpp.
//extern	bool	gbAbortMRUOpen; // whm 1Oct12 removed

/// This global is defined in Adapt_It.cpp.
extern wxString szProjectConfiguration;

/// This global is defined in Adapt_It.cpp.
extern wxString szAdminProjectConfiguration;

/// This global is defined in Adapt_It.cpp.
extern bool gbHackedDataCharWarningGiven;

// next group for auto-capitalization support; defined in Adapt_It.cpp around line 660+/-
extern bool	gbAutoCaps;
extern bool	gbSourceIsUpperCase;
extern bool	gbNonSourceIsUpperCase;
extern bool	gbNoSourceCaseEquivalents;
extern bool	gbNoTargetCaseEquivalents;
extern bool	gbNoGlossCaseEquivalents;
extern wxChar gcharNonSrcLC;
extern wxChar gcharNonSrcUC;
extern wxChar gcharSrcLC;
extern wxChar gcharSrcUC;
extern bool   gbUCSrcCapitalAnywhere; // TRUE if searching for captial at non-initial position
							   // is enabled, FALSE is legacy initial position only
extern int    gnOffsetToUCcharSrc; // offset to source text location where the upper case
							// character was found to be located, wxNOT_FOUND if not located

//bool	gbIgnoreIt = FALSE; // used when "Ignore it (do nothing)" button was hit
							// in consistency check dlg

// whm added 6Apr05 for support of export filtering of sfms and RTF output of the same in
// the appropriate functions in the Export-Import file, etc. These globals are defined
// in ExportSaveAsDlg.cpp
extern wxArrayString m_exportMarkerAndDescriptions;
extern wxArrayString m_exportBareMarkers;
extern wxArrayInt m_exportFilterFlags;
extern wxArrayInt m_exportFilterFlagsBeforeEdit;

extern bool gbIsUnstructuredData;
// BEW 12Sep22 earlier, I had the comment for each of \w and \w*: " \w removed, it's a special case "  but removal of \w and \w*
// led to a parsing failure for source text \w ensel\\w*  (indicating ensel 'angel') was to be in the glossary. The failure crashed
// the TokenizeText() parse, and so Steve White could not create a perfectly normal source text with that data in it. So I've
// refactored, so that there is a new function in the Doc class  bool IsWmkrWithBar(wxChar* ptr) where ptr points to where the
// parsing has gotten to in the input source text's buffer. If there is a bar following a \w marker's text, then return TRUE, all
// other possibilities return FALSE. (and flag bit 22, m_bUnused in CSourcePhrase is set to 1 if pupat has cacheable content).
// Now it's no longer necessary to remove \w from the fast access string, as the choice of control's path can now be controlled
// by the value returned by IsWmkrWithBar(wxChar* ptr).
// 
// whm 24Oct2023 comment update: The IsWmkrWithBar() function mentioned above is not used anywhere in code.
//	Note: The USFM docs define \\qt-s,  \\qt-e, \\qt-s\\*, \\qt-e\\*, and \\* as starting and ending "milestones" usually 
//	marking the beginning and ending of a quotation/speaker. They can also employ a bar | character to separate the attribute 
//	parts, usually with no text to left of the bar except for the begin marker.
// 
// whm 24Oct2023 TODO: Shouldn't the charAttributeMkrs sets defined below include the \xt and \xt* markers? USFM 3 defines 
//	the \xt marker as a character attribute marker, which can have the bar | character within its associated text to 
//	separate linking attributes.
wxString charAttributeMkrs = _T("\\fig \\jmp \\+jmp \\w \\rb \\qt-s \\qt-e "); // include \xt here???
// and the end marker forms
wxString charAttributeEndMkrs = _T("\\fig* \\jmp* \\+jmp* \\w* \\rb* \\qt-s\\* \\qt-e\\* \\* ");


// support for USFM and SFM Filtering
// Since these special filter markers will be visible to the user in certain dialog
// controls, I've opted to use marker labels that should be unique (starting with \~) and
// yet still recognizable by containing the word 'FILTER' as part of their names.

/// A marker string used to signal the beginning of filtered material stored in a source
/// phrase's m_filteredInfo member.
wxString filterMkr = _T("\\~FILTER"); //const wxString filterMkr = _T("\\~FILTER"); // whm 9Jun12 removed const

/// A marker string used to signal the end of filtered material stored in a source phrase's
/// m_filteredInfo member.
wxString filterMkrEnd = _T("\\~FILTER*"); //const wxString filterMkrEnd = _T("\\~FILTER*"); // whm 9Jun12 removed const

/////////////////////////////////////////////////////////////////////////////
// CAdapt_ItDoc

IMPLEMENT_DYNAMIC_CLASS(CAdapt_ItDoc, wxDocument)

BEGIN_EVENT_TABLE(CAdapt_ItDoc, wxDocument)

// The events that are normally handled by the doc/view framework use predefined
// event identifiers, i.e., wxID_NEW, wxID_SAVE, wxID_CLOSE, wxID_OPEN, etc.
EVT_MENU(wxID_NEW, CAdapt_ItDoc::OnFileNew)
EVT_MENU(wxID_SAVE, CAdapt_ItDoc::OnFileSave)
EVT_UPDATE_UI(wxID_SAVE, CAdapt_ItDoc::OnUpdateFileSave)

EVT_MENU(ID_FILE_SAVE_COMMIT, CAdapt_ItDoc::OnSaveAndCommit)
EVT_UPDATE_UI(ID_FILE_SAVE_COMMIT, CAdapt_ItDoc::OnUpdateDVCS_item)
EVT_MENU(ID_FILE_REVERT_FILE, CAdapt_ItDoc::OnShowPreviousVersions)
EVT_UPDATE_UI(ID_FILE_REVERT_FILE, CAdapt_ItDoc::OnUpdateDVCS_item)
EVT_MENU(ID_FILE_LIST_VERSIONS, CAdapt_ItDoc::OnShowFileLog)
EVT_UPDATE_UI(ID_FILE_LIST_VERSIONS, CAdapt_ItDoc::OnUpdateDVCS_item)
EVT_MENU(ID_FILE_TAKE_OWNERSHIP, CAdapt_ItDoc::OnTakeOwnership)
EVT_UPDATE_UI(ID_FILE_TAKE_OWNERSHIP, CAdapt_ItDoc::OnUpdateTakeOwnership)
EVT_MENU(ID_DVCS_VERSION, CAdapt_ItDoc::OnDVCS_Version)
//    EVT_UPDATE_UI(ID_DVCS_VERSION, CAdapt_ItDoc::OnUpdateDVCS_item) - now leaving this one always enabled.

EVT_MENU(wxID_CLOSE, CAdapt_ItDoc::OnFileClose)
EVT_UPDATE_UI(wxID_CLOSE, CAdapt_ItDoc::OnUpdateFileClose)
EVT_MENU(ID_SAVE_AS, CAdapt_ItDoc::OnFileSaveAs)
EVT_UPDATE_UI(ID_SAVE_AS, CAdapt_ItDoc::OnUpdateFileSaveAs)
EVT_MENU(wxID_OPEN, CAdapt_ItDoc::OnFileOpen)
EVT_MENU(ID_TOOLS_SPLIT_DOC, CAdapt_ItDoc::OnSplitDocument)
EVT_UPDATE_UI(ID_TOOLS_SPLIT_DOC, CAdapt_ItDoc::OnUpdateSplitDocument)
EVT_MENU(ID_TOOLS_JOIN_DOCS, CAdapt_ItDoc::OnJoinDocuments)
EVT_UPDATE_UI(ID_TOOLS_JOIN_DOCS, CAdapt_ItDoc::OnUpdateJoinDocuments)
EVT_MENU(ID_TOOLS_MOVE_DOC, CAdapt_ItDoc::OnMoveDocument)
EVT_UPDATE_UI(ID_TOOLS_MOVE_DOC, CAdapt_ItDoc::OnUpdateMoveDocument)
EVT_UPDATE_UI(ID_FILE_PACK_DOC, CAdapt_ItDoc::OnUpdateFilePackDoc)
EVT_UPDATE_UI(ID_FILE_UNPACK_DOC, CAdapt_ItDoc::OnUpdateFileUnpackDoc)
EVT_MENU(ID_FILE_PACK_DOC, CAdapt_ItDoc::OnFilePackDoc)
EVT_MENU(ID_FILE_UNPACK_DOC, CAdapt_ItDoc::OnFileUnpackDoc)
EVT_MENU(ID_EDIT_CONSISTENCY_CHECK, CAdapt_ItDoc::OnEditConsistencyCheck)
EVT_MENU(ID_EDITMENU_CHANGE_PUNCTS_MKRS_PLACE, CAdapt_ItDoc::OnChangePunctsOrMarkersPlacement)
EVT_UPDATE_UI(ID_EDIT_CONSISTENCY_CHECK, CAdapt_ItDoc::OnUpdateEditConsistencyCheck)
EVT_UPDATE_UI(ID_EDITMENU_CHANGE_PUNCTS_MKRS_PLACE, CAdapt_ItDoc::OnUpdateChangePunctsOrMarkersPlacement)
EVT_MENU(ID_ADVANCED_RECEIVESYNCHRONIZEDSCROLLINGMESSAGES, CAdapt_ItDoc::OnAdvancedReceiveSynchronizedScrollingMessages)
EVT_UPDATE_UI(ID_ADVANCED_RECEIVESYNCHRONIZEDSCROLLINGMESSAGES, CAdapt_ItDoc::OnUpdateAdvancedReceiveSynchronizedScrollingMessages)
EVT_MENU(ID_ADVANCED_SENDSYNCHRONIZEDSCROLLINGMESSAGES, CAdapt_ItDoc::OnAdvancedSendSynchronizedScrollingMessages)
EVT_UPDATE_UI(ID_ADVANCED_SENDSYNCHRONIZEDSCROLLINGMESSAGES, CAdapt_ItDoc::OnUpdateAdvancedSendSynchronizedScrollingMessages)

// whm added 10Jul2015 for temporary testing of the CCollabVerseConflictDlg dialog
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//	EVT_MENU(ID_VERSE_CONFLICT_DLG, CAdapt_ItDoc::OnVerseConflictDlg)
//	EVT_UPDATE_UI(ID_VERSE_CONFLICT_DLG, CAdapt_ItDoc::OnUpdateVerseConflictDlg)
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

END_EVENT_TABLE()


/////////////////////////////////////////////////////////////////////////////
// CAdapt_ItDoc construction/destruction

/// **** DO NOT PUT INITIALIZATIONS IN THE DOCUMENT'S CONSTRUCTOR *****
/// **** ONLY INITIALIZATIONS OF DOCUMENT'S PRIVATE MEMBERS SHOULD ****
/// **** BE DONE HERE; DO OTHER INITIALIZATIONS IN THE APP'S      *****
/// **** OnInit() METHOD                                          *****
CAdapt_ItDoc::CAdapt_ItDoc()
{
	m_bHasPrecedingStraightQuote = FALSE;   // this one needs to be initialized to
											// FALSE every time a doc is recreated
	m_bLegacyDocVersionForSaveAs = FALSE;   // whm added 14Jan11
	m_bReopeningAfterClosing = FALSE;       // mrh Oct12 - normal default

	m_bIsWithinUnfilteredInlineSpan = FALSE; // initialization, for things like
											 // \xt embedded within unfiltered footnote
	m_strUnfilteredInlineBeginMarker = wxEmptyString; // for temporary store of, say,
							// \f awaiting ptr coming to \f* where the above bool
							// needs to be made FALSE if it was TRUE
	m_bWithinMkrAttributeSpan = FALSE; // FOR USFM3 support, should start off FALSE

	// whm 5Jan2024 added. We will assume the SetupUsfmStructArrayAndFile() succeeded
	// in has access to the <filename>.usfmstruct file and its m_UsfmStructArr structure
	// here on the Doc. If the SetupUsfmStructArrayAndFile() returns FALSE, the code
	// sets this flag to FALSE, and the assistance that the usfm structure will be
	// unavailble for usfm ordering during usfm filtering operations.
	m_bUsfmStructEnabled = TRUE; 

	// whm 24Dec2019 moved the following initialization here from Adapt_ItDoc.h
	// using _T('°') to represent the degree character \u00B0 causes a compiler warning 
	// "warning C4066: characters beyond first in wide-character constant ignored", so
	// I've changed the representation to _T('\u00B0').
	uselessDegreeChar = _T('\u00B0'); //uselessDegreeChar = _T('°');
	m_strBar = _T("|");
	m_strSpace = _T(" ");
	m_asterisk = _T('*');
	m_barChar = _T('|');
	m_strInitialPuncts = wxString::FromUTF8("“‘\"[(<{«¿¡—"); // 11 of them

	// whm 28Sep2023 added initialization of following here in the Doc's constructor
	// See comments in the PlacePhraseBox() function 
	m_bWithinEmptyMkrsLoop = FALSE; // set TRUE when entering, FALSE when exiting

	// WX Note: Nearly all Doc constructor initializations moved to the App
	// **** DO NOT PUT INITIALIZATIONS HERE IN THE DOCUMENT'S CONSTRUCTOR *****
	// **** ONLY INITIALIZATIONS OF DOCUMENT'S PRIVATE MEMBERS SHOULD     *****
	// **** BE DONE HERE; DO OTHER INITIALIZATIONS IN THE APP'S           *****
	// **** OnInit() METHOD  - but some exceptions are permitted          *****
}


/// **** ALL CLEANUP SHOULD BE DONE IN THE APP'S OnExit() METHOD ****
CAdapt_ItDoc::~CAdapt_ItDoc() // from MFC version
{
	// **** ALL CLEANUP SHOULD BE DONE IN THE APP'S OnExit() METHOD ****
}

///////////////////////////////////////////////////////////////////////////////
/// \return TRUE if new document was created successfully, FALSE otherwise
/// \remarks
/// Called from: the DocPage's OnWizardFinish() function.
/// In OnNewDocument, we aren't creating the document via serialization
/// of data from persistent storage (as does OnOpenDocument()), rather
/// we are creating the new document from scratch, by doing the following:
/// 1. Making sure our working directory is set properly.
/// 2. Calling parts of the virtual base class wxDocument::OnNewDocument() method
/// 3. Create the buffer and list structures that will hold our data
/// 4. Providing KB strm_bIsWithinUnfilteredInlineSpanuctures are ready, call GetNewFile() to get
///    the sfm file for import into our app.
/// 5. Get an output file name from the user.
/// 6. Tidy up the frame's window title.
/// 7. Create/Recreate the list of paired source and target punctuation
///    correspondences, updating also the View's punctuation settings
/// 8. Remove any Ventura Publisher optional hyphens from the text buffer.
/// 9. Call TokenizeText, which separates the text into words, stores them
///    in m_pSourcePhrases list and returns the number
/// 10. Calculate the App's text heights, and get the View to calculate
///     its initial indices and do its RecalcLayout()
/// 11. Show/place the initial phrasebox at first empty target slot
/// 12. Keep track of sequence numbers and set initial global src phrase
///     node position.
/// 13. [added] call OnInitialUpdate() which needs to be called before the
///     view is shown.
/// BEW added 13Nov09: call of m_bReadOnlyAccess = SetReadOnlyProtection(), in order to give
/// the local user in the project ownership for writing permission (if FALSE is returned)
/// or READ-ONLY access (if TRUE is returned). (Also added to LoadKB() and OnOpenDocument()
/// and OnCreate() for the view class.)
///////////////////////////////////////////////////////////////////////////////

//void CAdapt_ItDoc::OnUpdateVerseConflictDlg(wxUpdateUIEvent& event)
//{
//	event.Enable(TRUE);
//}
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


bool CAdapt_ItDoc::OnNewDocument()
// amended for support of glossing or adapting
{
	// BEW 30May17 next two initializations, also in CAdapt_ItDoc creator
	m_bIsWithinUnfilteredInlineSpan = FALSE; // initialization, for things like
											 // \xt embedded within unfiltered footnote
	m_strUnfilteredInlineBeginMarker = wxEmptyString; // for temporary store of, say,
													  // \f awaiting ptr coming to \f* where the above bool
													  // needs to be made FALSE if it was TRUE
	// refactored 10Mar09
	CAdapt_ItApp* pApp = GetApp();
	pApp->m_nSaveActiveSequNum = 0; // reset to a default initial value, safe for any length of doc

#if defined (_DEBUG)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
	wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

	// Initialize m_bTokenizingTargetText to FALSE
	m_bTokenizingTargetText = FALSE; // assumes will be parsing source text

#if defined(_DEBUG) && defined (FIXORDER)
	wxLogDebug(_T("OnNewDocument line %d  m_bTokenizingTargetText = %d"),
		__LINE__, (int)m_bTokenizingTargetText);
#endif
	// BEW 16Aug16, Restore the default, which is Shift_Launch no longer on, if it was on
	pApp->m_bDoNormalProjectOpening = TRUE;

	pApp->m_owner = pApp->m_strUserID;  // this is our doc
	pApp->m_trialVersionNum = -1;		// negative means no trial going on - the normal case

	// BEW changed 9Apr12, support discontinuous auto-inserted spans highlighting
	gpApp->m_pLayout->ClearAutoInsertionsHighlighting();

	// get a pointer to the view
	CAdapt_ItView* pView = (CAdapt_ItView*)pApp->GetView();
	wxASSERT(pView->IsKindOf(CLASSINFO(CAdapt_ItView)));

	// BEW comment 6May09 -- this OnInitialUpdate() call contains a RecalcLayout() call
	// within its call of OnSize() call. If the RecalcLayout() call is late enough, it can
	// try the recalculation while piles do not exist, leading to a crash. So I've moved
	// OnInitialUpdate() to be early in OnNewDocument() and protected from a crash by
	// having the recalculation do nothing at all with the layout until all the layout
	// components are in place... (moved here from end of function)
	//
	// whm added OnInitialUpdate(), since in WX the doc/view framework doesn't call it
	// automatically we need to call it manually here. MFC calls its OnInitialUpdate()
	// method sometime after exiting its OnNewDocument() and before showing the View. See
	// Notes at OnInitialUpdate() for more info.
	pView->OnInitialUpdate(); // need to call it here because wx's doc/view doesn't
								// automatically call it

	// force m_bookName_Current to be empty -- it will stay empty unless set from what is
	// stored in a document just loaded; or in collaboration mode by copying to it the
	// value of the m_CollabBookSelected member; or doing an export of xhtml or for
	// Pathway export, no book name is current and the user fills one out using the
	// CBookName dialog which opens for that purpose
	gpApp->m_bookName_Current.Empty();

	// whm 26Jul11 revised. When m_lastSourceInputPath is empty, use the special folder
	// __SOURCE_INPUTS. See similar code in DocPage.cpp::OnWizardFinish().
	wxString dirPath;
	if (pApp->m_lastSourceInputPath.IsEmpty())
	{
		if (!pApp->m_curProjectPath.IsEmpty())
			dirPath = pApp->m_curProjectPath + pApp->PathSeparator + pApp->m_sourceInputsFolderName; // __SOURCE_INPUTS
		else
			dirPath = pApp->m_workFolderPath; // typically, C:\Users\<userName>\Documents\Adapt It <Unicode> Work

	}
	else
	{
		dirPath = pApp->m_lastSourceInputPath; // from the path that was last used
	}
	bool bOK;
	// whm 8Apr2021 added wxLogNull block below
	{
		wxLogNull logNo;	// eliminates any spurious messages from the system if the wxSetWorkingDirectory() call returns FALSE
		bOK = ::wxSetWorkingDirectory(dirPath);
	} // end of wxLogNull scope

	// the above may have failed, so if so use m_workFolderPath as the folder,
	// so we can proceed to the file dialog safely
	if (!bOK)
	{
		dirPath = pApp->m_workFolderPath;
		pApp->m_lastSourceInputPath = dirPath;
		// whm 8Apr2021 added wxLogNull block below
		{
			wxLogNull logNo;	// eliminates any spurious messages from the system if the wxSetWorkingDirectory() call returns FALSE
			bOK = ::wxSetWorkingDirectory(dirPath); // this should work, since m_workFolderPath can hardly be wrong!
		} // end of wxLogNull scope
		if (!bOK)
		{
			if (!bOK)
			{
				// we should never get a failure for the above, so just an English message will do
				wxString msg = _T("OnNewDocument() failed, when setting current directory to:\n%s");
				msg = msg.Format(msg, dirPath.c_str());
				wxMessageBox(msg, _T(""), wxICON_ERROR | wxOK);
				pApp->LogUserAction(msg);

				pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
				
				return TRUE; // BEW 25Aug10, never return FALSE from OnNewDocument() if
							 // you want the doc/view framework to keep working right
			}
		}
	}

	//if (!wxDocument::OnNewDocument()) // don't use this because it calls OnCloseDocument()
	//	return FALSE;
	// whm NOTES: The wxWidgets base class OnNewDocument() calls OnCloseDocument()
	// which fouls up the KB structures due to the OnCloseDocument() calls to
	// EraseKB(), etc. To get around this problem which arises because of
	// different calling orders in the two doc/view frameworks, we'll not
	// call the base class wxDocument::OnNewDocument() method in wxWidgets,
	// but instead we call the remainder of its contents here:
	// whm verified the need for this 20July2006
	DeleteContents();
	Modify(FALSE);
	SetDocumentSaved(FALSE);
	wxString name;
	// whm 13May12 modified for wxWidgets-2.9.3
	//GetDocumentManager()->MakeDefaultName(name);
	name = GetDocumentManager()->MakeNewDocumentName();
	SetTitle(name);
	SetFilename(name, TRUE);
	// above calls come from wxDocument::OnNewDocument()
	// Note: The OnSaveModified() call is handled when needed in
	// the Doc's Close() and/or OnOpenDocument()

   // (SDI documents will reuse this document)
	if (pApp->m_pBuffer != NULL)
	{
		delete pApp->m_pBuffer; // make sure wxString is not in existence
		pApp->m_pBuffer = (wxString*)NULL; // MFC had = 0
	}

	// BEW added 21Apr08; clean out the global struct gEditRecord & clear its deletion lists,
	// because each document, on opening it, it must start with a truly empty EditRecord; and
	// on doc closure and app closure, it likewise must be cleaned out entirely (the deletion
	// lists in it have content which persists only for the life of the document currently open)
	pView->InitializeEditRecord(gEditRecord);
	if (!gEditRecord.deletedAdaptationsList.IsEmpty())
		gEditRecord.deletedAdaptationsList.Clear(); // remove any stored deleted adaptation strings
	if (!gEditRecord.deletedGlossesList.IsEmpty())
		gEditRecord.deletedGlossesList.Clear(); // remove any stored deleted gloss strings
	if (!gEditRecord.deletedFreeTranslationsList.IsEmpty())
		gEditRecord.deletedFreeTranslationsList.Clear(); // remove any stored deleted free translations


	int width = wxSystemSettings::GetMetric(wxSYS_SCREEN_X);
#ifdef _RTL_FLAGS
	pApp->m_docSize = wxSize(width - 40, 600); // a safe default width, the length doesn't matter
											  // (it will change shortly)
#else
	pApp->m_docSize = wxSize(width - 80, 600); // ditto
#endif

	// need a SPList to store the source phrases
	if (pApp->m_pSourcePhrases == NULL)
		pApp->m_pSourcePhrases = new SPList;
	wxASSERT(pApp->m_pSourcePhrases != NULL);


	bool bKBReady = FALSE;
	if (gbIsGlossing)
		bKBReady = pApp->m_bGlossingKBReady;
	else
		bKBReady = pApp->m_bKBReady;
	if (bKBReady)
	{
		pApp->m_nActiveSequNum = -1; // default, till positive value on layout of file

		pApp->m_pBuffer = new wxString; // on the heap, because this could be a large block of source text
		wxASSERT(pApp->m_pBuffer != NULL);
		pApp->m_nInputFileLength = 0;
		wxString filter = _T("*.*");
		wxString fileTitle = _T(""); // stores name (including extension) of user's
				// chosen source file; however, when taken into the COutFilenameDlg
				// dialog below, the latter's InitDialog() call strips off any
				// filename extension before showing what's left to the user
		wxString pathName; // stores the path (including filename & extension) to the
						   // chosen input source text file to be used for doc create

		// The following wxFileDialog part was originally in GetNewFile(), but moved here
		// 19Jun09 to consolidate file error message processing.
		wxString defaultDir;
		if (gpApp->m_lastSourceInputPath.IsEmpty())
		{
			defaultDir = gpApp->m_workFolderPath;
		}
		else
		{
			defaultDir = gpApp->m_lastSourceInputPath;
		}

		// BEW addition, 15Aug10, test for user navigation protection feature turned on,
		// and if so, show the monocline list of files in the __SOURCE_INPUTS folder only,
		// otherwise, show the standard File Open dialog, wxFileDialog, supplied by
		// wxWidgets which allows the user to navigate the hierarchical file/folder system
		// BEW 22Aug10, included m_bShowAdministratorMenu in the test, so that we don't
		// make the administrator have the __SOURCE_INPUTS folder restriction and
		// navigation-protection feature be forced on him when the Administrator menu is
		// visible. I've also put a conditional compile here so that when the developer is
		// debugging, he can choose which behaviour he wants for testing purposes
		//
		// whm modified 16Aug11. When the __SOURCE_INPUTS folder is NOT protected we need
		// to bypass the call to UseSourceDataFolderOnlyForInputFiles()
		bool bUseSourceDataFolderOnly;
		if (gpApp->m_bProtectSourceInputsFolder)
		{
			bUseSourceDataFolderOnly = gpApp->UseSourceDataFolderOnlyForInputFiles();
		}
		else
		{
			bUseSourceDataFolderOnly = FALSE;
		}
		bool bUserNavProtectionInForce = FALSE;
#ifdef _DEBUG
		// un-comment out the next line to have navigation protection for loading source
		// text files turned on when debugging only provided the administrator menu is not
		// showing - this is the way it is in the distributed application, that is, even
		// if user navigation protection is on, making the administrator menu visible will
		// override the 'on' setting so that the legacy File Open dialog is used; and
		// making the administrator menu invisible again automatically restores user
		// navigation protection to being 'on'

		//if (bUseSourceDataFolderOnly && !gpApp->m_bShowAdministratorMenu)

		// un-comment out the next line to have navigation protection for loading source
		// text files turned on when debugging, whether or not administrator menu is
		// visible; and comment out the line above
		bUserNavProtectionInForce = FALSE; // use this for allowing or suppressing
		// the COutputFilenameDlg further below, depending on whether the legacy
		// File New dialog is used, or the NavProtectNewDoc's dialog, respectively

		if (bUseSourceDataFolderOnly)
#else
		if (bUseSourceDataFolderOnly && !gpApp->m_bShowAdministratorMenu)
#endif
		{
			// This block encapsulates user file/folder navigation protection, by showing
			// to the user only all, or a subset of, the files in the monocline list of
			// files in the folder named "__SOURCE_INPUTS" within the current project's folder.
			// All the user can do is either Cancel, or select a single file to be loaded
			// as a new adaptation document, no navigation functionality is provided here
			bUserNavProtectionInForce = TRUE;

			gpApp->m_sortedLoadableFiles.Clear(); // we always recompute the array every
				// time the user tries to create a new document, because the administrator
				// may have added new source text files to the '__SOURCE_INPUTS' folder since
				// the time of the last document creation attempt
			gpApp->EnumerateLoadableSourceTextFiles(gpApp->m_sortedLoadableFiles,
				gpApp->m_sourceInputsFolderPath, filterOutUnloadableFiles);

			// now remove any array entries which have their filename title part
			// clashing with a document filename's title part (and book mode may be
			// currently on, so if it is we get the list of doc filenames from the
			// currently active bible book folder); to do this, first calculate the path
			// to the storage folder for the documents, and enumerate their filenames to a
			// wxArrayString local array, then call RemoveNameDuplicatesFromArray() to
			// compare the file titles and remove the duplicates
			wxString docsPath;
			if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
			{
				docsPath = gpApp->m_bibleBooksFolderPath; // path to a book folder within
														  // the "Adaptations" folder
			}
			else
			{
				docsPath = gpApp->m_curAdaptationsPath; // path to the "Adaptations"
													  // folder of the project
			}
			wxArrayString arrDocFilenames;
			gpApp->EnumerateDocFiles_ParametizedStore(arrDocFilenames, docsPath);
			// the following call removes any items from the first param's array which
			// have a duplicate file title for a filename in the second param's array;
			// the TRUE parameter is bSorted, we want the final list which the user sees
			// to be in alphabetical order (for Windows, a caseless compare is done, for
			// other operating systems, a case-sensitive compare is done - see the
			// sortCompareFunc() in helpers.cpp)
			RemoveNameDuplicatesFromArray(gpApp->m_sortedLoadableFiles, arrDocFilenames,
				TRUE, excludeExtensionsFromComparison);
			wxString strSelectedFilename;
			strSelectedFilename.Empty();
			// whm modified 1Feb2018. The NavProtectNewDoc dialog is a modal dialog and as
			// such it should not be created with a call to new and its heap pointer kept
			// on the App. As a modal dialog it should be just created on the stack here in
			// OnNewDocument(). On the GTK/Linux version we sometimes get a crash if a modal
			// dialog is created with the new command. Bruce's comment below about re "we
			// want the dialog handler's InitDialog() function called each time the dialog
			// it to be shown using ShowModal() so that the two buttons will be initialized
			// correctly" is not really applicable to this dialog. Therefore, to prevent
			// crashes in the GTK/Linux version, I've refactored the NavProtectNewDoc dialog
			// creation to be done the normal way, and removed the m_pNavProtectDlg pointers
			// from the app.

			// BEW 16Aug10, Note: we create the one and only instance of m_pNavProtectDlg here
			// rather than in the app's OnInit() function, because we want the dialog
			// handler's InitDialog() function called each time the dialog is to be shown using
			// ShowModal() so that the two buttons will be initialized correctly
			//wxWindow* docWindow = GetDocumentWindow();
			//gpApp->m_pNavProtectDlg = new NavProtectNewDoc(docWindow);
			NavProtectNewDoc navProtectDlg(gpApp->GetMainFrame());

#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			// display the dialog, it's list of filenames is monocline & no navigation
			// capability is provided
			//if (gpApp->m_pNavProtectDlg->ShowModal() == wxID_CANCEL)
			if (navProtectDlg.ShowModal() == wxID_CANCEL)
			{
				// the user has hit the Cancel button
				wxASSERT(strSelectedFilename.IsEmpty());
				wxMessageBox(_(
					"Adapt It cannot do any useful work unless you select a source file to adapt. Please try again."),
					_T(""), wxICON_INFORMATION | wxOK);

				pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

				// check if there was a document current, and if so, reinitialize everything
				if (pView != 0)
				{
					//if (gpApp->m_pNavProtectDlg != NULL) // whm 11Jun12 added NULL test
					//	delete gpApp->m_pNavProtectDlg;
					//gpApp->m_pNavProtectDlg = NULL;
					pApp->m_pTargetBox->GetTextCtrl()->SetValue(_T("")); // whm 12Jul2018 added GetTextCtrl()-> part
					if (pApp->m_pBuffer != NULL) // whm 11Jun12 added NULL test
						delete pApp->m_pBuffer;
					pApp->m_pBuffer = (wxString*)NULL; // MFC had = 0

					pView->Invalidate();
					GetLayout()->PlaceBox();
				}
				//return FALSE; BEW removed 24Aug10 as it clobbers part of the wxWidgets
				//doc/view black box on which we rely, leading to our event handlers
				//failing to be called, so return TRUE instead
				pApp->LogUserAction(_T("User cancelled OnNewDocument() while bUseSourceDataFolderOnly"));

				pApp->m_bZWSPinDoc = FALSE; // BEW 7Oct14, restore default

#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
				wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
				return TRUE;
			}
			else
			{
				// the user has hit the "Input file" button
				//strSelectedFilename = gpApp->m_pNavProtectDlg->GetUserFileName();
				strSelectedFilename = navProtectDlg.GetUserFileName();
				wxASSERT(!strSelectedFilename.IsEmpty());

				// the dialog handler can now be deleted and its point set to NULL
				//if (pApp->m_pNavProtectDlg != NULL) // whm 11Jun12 added NULL test
				//	delete gpApp->m_pNavProtectDlg;
				//pApp->m_pNavProtectDlg = NULL;

				// create the path to the selected file (m_sourceInputsFolderPath is always
				// defined when the app enters a project, as a folder "__SOURCE_INPUTS" which
				// is a direct child of the folder m_curProjectPath)
				pathName = gpApp->m_sourceInputsFolderPath + gpApp->PathSeparator + strSelectedFilename;
				wxASSERT(::wxFileExists(pathName));

				// set fileTitle to the selected file's name (including extension, as the
				// latter will be removed later below)
				fileTitle = strSelectedFilename;
			}
		} // end of TRUE block for test: if (bUseSourceDataFolderOnly)
		else
		{
			bool bGotLoadableFile = FALSE;
			int returnValue = -1;
			while (!bGotLoadableFile && returnValue != wxID_CANCEL)
			{
				// This block uses the legacy wxFileDialog call, which allows the user to
				// navigate the folder hierarchy to find loadable source text files anywhere
				// within any volume accessible to the system, there is no user navigation
				// protection in force if control enters this block
				wxFileDialog fileDlg(
					(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
					_("Input Text File For Adaptation"),
					defaultDir,	// default dir (either m_workFolderPath, or m_lastSourceInputPath)
					_T(""),		// default filename
					filter,
					wxFD_OPEN); // | wxHIDE_READONLY); wxHIDE_READONLY deprecated in 2.6 - the checkbox is never shown
								// GDLC wxOPEN deprecated in 2.8
				fileDlg.Centre();
				// open as modal dialog
				int returnValue = fileDlg.ShowModal(); // MFC has DoModal()
				if (returnValue == wxID_CANCEL)
				{
					// user cancelled, so cancel the New... command, or <New Document> choice,
					// as the case may be -- either user choice will have caused
					// OnNewDocument() to be called
					wxMessageBox(_(
						"Adapt It cannot do any useful work unless you select a source file to adapt. Please try again."),
						_T(""), wxICON_INFORMATION | wxOK);

					pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
														// check if there was a document current, and if so, reinitialize everything
					if (pView != 0)
					{
						pApp->m_pTargetBox->GetTextCtrl()->SetValue(_T("")); // whm 12Jul2018 added GetTextCtrl()-> part
						if (pApp->m_pBuffer != NULL) // whm 11Jun12 added NULL test
							delete pApp->m_pBuffer;

						pApp->m_pBuffer = (wxString*)NULL; // MFC had = 0
						pView->Invalidate();
						GetLayout()->PlaceBox();
					}
					//return FALSE; BEW removed 24Aug10 as it clobbers part of the wxWidgets
					//doc/view black box on which we rely, leading to our event handlers
					//failing to be called, so return TRUE instead
					pApp->LogUserAction(_T("User cancelled OnNewDocument() from wxFileDialog"));

					// BEW 7Oct14, restore default
					pApp->m_bZWSPinDoc = FALSE;
#if defined (_DEBUG) && !defined(NOLOGS)
					// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
					wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
					return TRUE;
				}
				else // must be wxID_OK
				{
					pathName = fileDlg.GetPath(); //MFC's GetPathName() and wxFileDialog.GetPath both get whole dir + file name.
					fileTitle = fileDlg.GetFilename(); // just the file name (including any extension)
					if (!IsLoadableFile(pathName))
					{
						wxFileName fn(pathName);
						wxString msg, title;
						title = _("Adapt It requires plain text files for input"); //
						msg = _("The following file:\n\n%s\n\nhas a %s extension which indicates that it is not loadable as an input file for Adapt It.\n\nPlease try again or click Cancel at the file selection dialog.");
						msg = msg.Format(msg, pathName.c_str(), fn.GetExt().c_str());
						wxMessageBox(msg, title, wxICON_EXCLAMATION | wxOK);
						pApp->LogUserAction(msg);
						bGotLoadableFile = FALSE;
					}
					else
					{
						bGotLoadableFile = TRUE;
					}

					pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

				} // end of else wxID_OK
				  // & fileDlg goes out of scope here
			} // end of while
		} // end of else block for test: if (bUseSourceDataFolderOnly)

		// If control gets to here, (and it cannot do so if the user hit the Cancel
		// button), we've pathName and fileTitle wxString variables set ready for creating
		// the new document and getting an output document name from the user (the latter
		// calls COutFilenameDlg class, and it includes built-in invalid character
		// protection, and protection from a name conflict)
		wxFileName fn(pathName);
		wxString fnExtensionOnly = fn.GetExt(); // GetExt() returns the extension NOT including the dot
#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
		wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
		// BEW 24Oct22 !!! Prior to this date, gpApp->m_bParsingSource was nowhere set TRUE.
		// This should be a good place to rectify that omission
		pApp->m_bParsingSource = TRUE;
		 
		// get the file, and it's length (which includes null termination byte/s) whm
		// modified 18Jun09 GetNewFile() now returns an enum getNewFileState (see
		// Adapt_It.h) which more specifically reports the success or error state
		// encountered in getting the file for input. It now uses a switch() structure.
		switch (GetNewFile(pApp->m_pBuffer, pApp->m_nInputFileLength, pathName))
		{
		case getNewFile_success:
		{
			//wxString tempSelectedFullPath = fileDlg.GetPath(); BEW changed 15Aug10 to
			// remove the second call to fileDlg.GetPath() here, as pathName has the path
			wxString tempSelectedFullPath = pathName;

			// wxFileDialog.GetPath() returns the full path with directory and filename. We
			// only want the path part, so we also call ::wxPathOnly() on the full path to
			// get only the directory part.
			gpApp->m_lastSourceInputPath = ::wxPathOnly(tempSelectedFullPath);

			// Check if it has an \id line. If it does, get the 3-letter book code. If
			// a valid code is present, check that it is a match for the currently
			// active book folder. If it isn't tell the user and abort the <New
			// Document> operation, leaving control in the Document page of the wizard
			// for a new attempt with a different source text file, or a change of book
			// folder to be done and the same file reattempted after that. If it is a
			// matching book code, continue with setting up the new document.
			if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
			{
				// do the test only if Book Mode is turned on
				wxString strIDMarker = _T("\\id");
				int nPos = (*gpApp->m_pBuffer).Find(strIDMarker);
				if (nPos != -1)
				{
					// the marker is in the file, so we need to go ahead with the check, but first
					// work out what the current book folder is and then what its associated code is
					wxString aBookCode = ((BookNamePair*)(*gpApp->m_pBibleBooks)[gpApp->m_nBookIndex])->bookCode;
					wxString seeNameStr = ((BookNamePair*)(*gpApp->m_pBibleBooks)[gpApp->m_nBookIndex])->seeName;
					gbMismatchedBookCode = FALSE;

					// get the code by advancing over the white space after the \id marker, and then taking
					// the next 3 characters as the code
					const wxChar* pStr = gpApp->m_pBuffer->GetData();
					wxChar* ptr = (wxChar*)pStr;
					ptr += nPos;
					ptr += 4; // advance beyond \id and whatever white space character is next
					while (*ptr == _T(' ') || *ptr == _T('\n') || *ptr == _T('\r') || *ptr == _T('\t'))
					{
						// advance over any additional space, newline, carriage return or tab
						ptr++;
					}
					wxString theCode(ptr, 3);	// make a 3-letter code, but it may be rubbish as we can't be
												// sure there is actually a valid one there

					// test to see if the string contains a valid 3-letter code
					bool bMatchedBookCode = CheckBibleBookCode(gpApp->m_pBibleBooks, theCode);
					if (bMatchedBookCode)
					{
						// it matches one of the 67 codes known to Adapt It, so we need to check if it
						// is the correct code for the active folder; if it's not, tell the user and
						// go back to the Documents page of the wizard; if it is, just let processing
						// continue (the Title of a message box is just "Adapt It", only Palm OS permits naming)
						if (theCode != aBookCode)
						{
							// the codes are different, so the document does not belong in the active folder
							wxString aTitle;
							// IDS_INVALID_DATA_BOX_TITLE
							aTitle = _("Invalid Data For Current Book Folder");
							wxString msg1;
							// IDS_WRONG_THREELETTER_CODE_A
							msg1 = msg1.Format(_(
								"The source text file's \\id line contains the 3-letter code %s which does not match the 3-letter \ncode required for storing the document in the currently active %s book folder.\n"),
								theCode.c_str(), seeNameStr.c_str());
							wxString msg2;
							//IDS_WRONG_THREELETTER_CODE_B
							msg2 = _(
								"\nChange to the correct book folder and try again, or try inputting a different source text file \nwhich contains the correct code.");
							msg1 += msg2; // concatenate the messages
							wxMessageBox(msg1, aTitle, wxICON_EXCLAMATION | wxOK); // I want a title on this other than "Adapt It"
							gbMismatchedBookCode = TRUE;// tell the caller about the mismatch

							pApp->LogUserAction(msg1);

							pApp->m_bZWSPinDoc = FALSE; // BEW 6Oct14 restore default

							pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
							wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
							return TRUE; // returns to OnWizardFinish() in DocPage.cpp (BEW 24Aug10, if
										// that claim always is true, then no harm will be done;
										// but if it returns FALSE to the wxWidgets doc/view
										// framework, it partially clobbers the latter -- this can be
										// tested by returning FALSE here and then clicking the Open
										// icon button on the toolbar -- if that bypasses our event
										// handlers and just directly opens the "Select a file"
										// wxWidgets dialog, then the app is unstable and New and Open
										// whether on the File menu or as toolbar buttons will not
										// work right. In that case, we would need to return TRUE
										// here, not FALSE. BEW 22Jul16 made it TRUE)
						}
					}
					else
					{
						// not a known code, so we'll assume we accessed random text after the \id marker,
						// and so we just let processing proceed & the user can live with whatever happens
						;
					}
				}
				else
				{
					// if the \id marker is not in the source text file, then it is up to the user
					// to keep the wrong data from being stored in the current book folder, so all
					// we can do for that situation is to let processing proceed
					;
				}
			}

			pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

			// get a suitable output filename for use with the auto-save feature
			// BEW 23Aug10, changed so that if user navigation protection is in force,
			// this dialog is not put up, and so the user will have no chance to change
			// the filename title to anything different that the filename title of the
			// input source text file used to create the dialog. This inability to change
			// the filename makes the filename list's bleeding behaviour work reliably as
			// the user successively creates documents - until when all docs have been
			// created that can be created from the files in the __SOURCE_INPUTS folder, the
			// list will be empty
			wxString strUserTyped;
			if (bUserNavProtectionInForce)
			{
				// don't let the user have any chance to alter the filename
				strUserTyped = fileTitle; // while the RHS suggests it's a fileTitle, it's
						// actually still got the filename extension on it (if there was
						// one there originally); it doesn't get removed until
						// SetDocumentWindowTitle() is called below
				// remove any extension user may have typed -- we'll keep control ourselves
				SetDocumentWindowTitle(strUserTyped, strUserTyped); // extensionless name is
											// returned as the last parameter in the signature
				// for XML output
				pApp->m_curOutputFilename = strUserTyped + _T(".xml");
				pApp->m_curOutputBackupFilename = strUserTyped + _T(".BAK");
			}
			else
			{
				// legacy behaviour, the file title can be user-edited or typed to be
				// anything he wants
				COutputFilenameDlg dlg(GetDocumentWindow());
				dlg.Centre();
				dlg.m_strFilename = fileTitle;
				if (dlg.ShowModal() == wxID_OK)
				{
					// get the filename
					strUserTyped = dlg.m_strFilename;

					// The COutputFilenameDlg::OnOK() handler checks for duplicate file
					// name or a file name with bad characters in it.
					// abort the operation if user gave no explicit or bad output filename
					if (strUserTyped.IsEmpty())
					{
						// warn user to specify a non-null document name with valid chars
						if (strUserTyped.IsEmpty())
							wxMessageBox(_(
								"Sorry, Adapt It needs an output document name. (An .xml extension will be automatically added.) Please try the New... command again."),
								_T(""), wxICON_INFORMATION | wxOK);

						// reinitialize everything
						pApp->m_pTargetBox->GetTextCtrl()->ChangeValue(_T(""));
						if (pApp->m_pBuffer != NULL) // whm 11Jun12 added NULL test
							delete pApp->m_pBuffer;
						pApp->m_pBuffer = (wxString*)NULL; // MFC had = 0
						pApp->m_curOutputFilename = _T("");
						pApp->m_curOutputPath = _T("");
						pApp->m_curOutputBackupFilename = _T("");
						pView->Invalidate(); // our own

						GetLayout()->PlaceBox();
						//return FALSE; BEW removed 24Aug10 as it clobbers part of the wxWidgets
						//doc/view black box on which we rely, leading to our event handlers
						//failing to be called, so return TRUE instead

#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
						wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
						pApp->m_bZWSPinDoc = FALSE; // BEW 7Oct14 restore default

						return TRUE;
					}

					// remove any extension user may have typed -- we'll keep control
					// ourselves
					SetDocumentWindowTitle(strUserTyped, strUserTyped); // extensionless name
										// is returned as the last parameter in the signature

					// for XML output
					pApp->m_curOutputFilename = strUserTyped + _T(".xml");
					pApp->m_curOutputBackupFilename = strUserTyped + _T(".BAK");
				} // end of true block for test: if (dlg.ShowModal() == wxID_OK)
				else
				{
					// user cancelled, so cancel the New... command too
					wxMessageBox(_(
						"Sorry, Adapt It will not work correctly unless you specify an output document name. Please try again."),
						_T(""), wxICON_INFORMATION | wxOK);

					// reinitialize everything
					pApp->m_pTargetBox->GetTextCtrl()->ChangeValue(_T(""));
					if (pApp->m_pBuffer != NULL) // whm 11Jun12 added NULL test
						delete pApp->m_pBuffer;
					pApp->m_pBuffer = (wxString*)NULL; // MFC had = 0
					pApp->m_curOutputFilename = _T("");
					pApp->m_curOutputPath = _T("");
					pApp->m_curOutputBackupFilename = _T("");

					pView->Invalidate();
					GetLayout()->PlaceBox();
					//return FALSE; BEW removed 24Aug10 as it clobbers part of the wxWidgets
					//doc/view black box on which we rely, leading to our event handlers
					//failing to be called, so return TRUE instead
					pApp->LogUserAction(_T("User canceled in OnNewDocument()"));

					pApp->m_bZWSPinDoc = FALSE; // BEW 7Oct14 restore default
#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
					wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

					return TRUE;
				} // end of else block for test: if (dlg.ShowModal() == wxID_OK)
			} // end of else block for test: if (bUserNavProtectionInForce)

			// BEW modified 11Nov05, because the SetDocumentWindowTitle() call now updates
			// the window title
			// Set the document's path to reflect user input; the destination folder will
			// depend on whether book mode is ON or OFF; likewise for backups if turned on
			if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
			{
				pApp->m_curOutputPath = pApp->m_bibleBooksFolderPath + pApp->PathSeparator
					+ pApp->m_curOutputFilename; // to send to the app when saving
												 // m_lastDocPath to config files
			}
			else
			{
				pApp->m_curOutputPath = pApp->m_curAdaptationsPath + pApp->PathSeparator
					+ pApp->m_curOutputFilename; // to send to the app when saving
												 // m_lastDocPath to config files
			}

			// Write the first couple log lines of our logging file to log the filename and 
			// date-time. Also write a line telling what function we are calling from.
			// See comments above the LogDocCreationData() function in the App for more details.
			// If there is a parse failure, it happened after the last m_srcPhrase in
			// this file. It is stored in the folder _LOGS_EMAIL_REPORTS in work folder
			// when "Make diagnostic logfile during document creation and opening" check box
			// is ticked in the docPage or the GetSourceTextFromEditor dialog.
			if (gpApp->m_bMakeDocCreationLogfile) // turn this ON in docPage of the Wizard or in GetSourceTextFromEditor dialog; it is OFF by default
			{
				// Construct the parameter string composed of the current output filename + date-time stamp for Now().
				wxString fileNameLine;
				wxDateTime theTime = wxDateTime::Now(); //initialize to the current time
				wxString timeStr;
				timeStr = theTime.Format();
				// whm 13Apr2020 changed to log whole path/name of doc being created/opened + date-time stamp
				fileNameLine = pApp->m_curOutputPath + _T(" ") + timeStr;
				gpApp->LogDocCreationData(fileNameLine);
				// whm 6Apr2020 the following m_bParsingSource is set TRUE during logging 
				// to prevent TokenizeText() from doing unwanted logging in other operations
				// where TokenizeText is used.
				gpApp->m_bParsingSource = TRUE;
				// whm 14Apr2020 added following log line to indicate source of Data
				gpApp->LogDocCreationData(_T("In OnNewDocument() logging Data via TokenizeText() below:"));
			}

			SetFilename(pApp->m_curOutputPath, TRUE);// TRUE notify all views
			Modify(FALSE);

			// BEW added 26Aug10. In case we are loading a marked up file we earlier
			// exported, our custom markers in the exported output would have been changed
			// to \z-prefixed forms, \zfree, \zfree*, \znote, etc. Here we must convert
			// back to our internal marker forms, which lack the 'z'. (The z was to support
			// Paratext import of data containing 3rd party markers unknown to
			// Paratext/USFM.)
			ChangeParatextPrivatesToCustomMarkers(*pApp->m_pBuffer);

			// remove any optional hyphens in the source text for use by Ventura Publisher
			 // (skips over any <-> sequences, and gives new m_pBuffer contents & new
			 // m_nInputFileLength value)
			RemoveVenturaOptionalHyphens(pApp->m_pBuffer);

			// whm wx version: moved the following OverwriteUSFMFixedSpaces and
			// OverwriteUSFMDiscretionaryLineBreaks calls here from within TokenizeText if
			// user requires, change USFM fixed spaces (marked by the ~ character) to a
			// space - this does not change the length of the data in the buffer
			if (gpApp->m_bChangeFixedSpaceToRegularSpace)
				OverwriteUSFMFixedSpaces(pApp->m_pBuffer);

			// Change USFM discretionary line breaks // to a pair of spaces. We do this
			// unconditionally because these types of breaks are not likely to be
			// located in the same place if allowed to pass through to the target text,
			// and are usually placed in the translation in the final typesetting
			// stage. This does not change the length of the data in the buffer.
			OverwriteUSFMDiscretionaryLineBreaks(pApp->m_pBuffer);

			// whm 1Sep2023 testing of function to normalize all EOLs to CRLF for non-collab
			// input of usfm text for parsing.
			NormalizeTextEOLsToCRLF(*pApp->m_pBuffer, TRUE);

#ifndef __WXMSW__
#ifndef _UNICODE
			// whm added 12Apr2007
			OverwriteSmartQuotesWithRegularQuotes(pApp->m_pBuffer);
#endif
#endif
			// BEW 16Dec10, added needed code to set gCurrentSfmSet to the current value
			// of the project's SfmSet. This code has been lacking from version 3 onwards
			// to 5.2.3 at least
			if (gpApp->gCurrentSfmSet != gpApp->gProjectSfmSetForConfig)
			{
				// the project's setting is not the same as the current setting for the
				// doc (the latter is either UsfmOnly if the app has just been launched,
				// as that is the default; or if there was some previous doc open, it has
				// the same value as that previous doc had)
				gpApp->gCurrentSfmSet = gpApp->gProjectSfmSetForConfig;
			}

			// whm 24Aug2018 added. A new document should initially adopt the App's gProjectFilterMarkersForConfig
			// as the document's gCurrentFilterMarkers for the new document. The user can change the
			// filter markers after document creation as desired, but the filter markers as set in the
			// project's filter marker list should be the initial default.
			gpApp->gCurrentFilterMarkers = gpApp->gProjectFilterMarkersForConfig;

			//#if defined(FWD_SLASH_DELIM)
			// BEW 23Apr15, if supporting / as a whitespace word-breaking character, preprocess
			// the input text to have no ZWSP in it, and to insert / at the correct places where
			// there is punctuation (since the users do not type it in such locations, so we do
			// it using CC table processing)
			*pApp->m_pBuffer = ZWSPtoFwdSlash(*pApp->m_pBuffer);
			*pApp->m_pBuffer = DoFwdSlashConsistentChanges(insertAtPunctuation, *pApp->m_pBuffer);
			//#endif
			
			// whm 15Nov2023 added. Here is where we should create the original .usfmstruct file
			// for a non-collab document that is being created from *pApp->m_pBuffer input text.
			// Note: This SetupUsfmStructArrayAndFile() should be called BEFORE the TokenizeText[String]()
			// call below. Then, there should be a call to UpdateCurrentFilterStatusOfUsfmStructFileAndArray()
			// AFTER the TokenizeText[String]() call below.
			bool bSetupOK;
			bSetupOK = SetupUsfmStructArrayAndFile(createNewFile, *pApp->m_pBuffer);
			if (!bSetupOK)
			{
				// Not likely to happen so an English message is OK.
				wxString msg = _T("Adapt It could not set up the Usfm Struct Array or the .usfmstruct file.\n\nThis may affect the ability of Adapt It to filter or unfilter adjacent markers in correct sequence.");
				wxMessageBox(msg, _T(""), wxICON_WARNING | wxOK);
				pApp->LogUserAction(msg);
				m_bUsfmStructEnabled = FALSE; // the usfm struct routines are disabled
			}

			/*
			// whm 13Nov2023 added the following code to create a wxArrayString UsfmStructArr from 
			// the source input *pApp->m_pBuffer text, then save that array of strings to a file 
			// named <filename>.usfmstruct that is saved to a hidden sub-directory at the following 
			// path:
			// /Adapt It Unicode Work/<project-directory/Adaptations/.usfmstruct/<filename>.usfmstruct
			// where <filename> is the name of the document file being created via gpApp->m_curOutputPath
			// which already has an .xml extension. We add the additional extension .usfmstruct to 
			// the usfm struct file we're creating.
			// This usfm struct file will get updated with filter status fields in the 
			// UpdateCurrentFilterStatusOfUsfmStructFileAndArray() function call made after TokenizeText() is
			// called later below.
			m_usfmStructDirName = _T(".usfmstruct");
			wxFileName structFn(gpApp->m_curOutputPath);
			m_usfmStructFilePath = structFn.GetPath();
			m_usfmStructFileName = structFn.GetFullName(); // gets full name including extension, but excluding directories
			m_usfmStructDirPath = m_usfmStructFilePath + gpApp->PathSeparator + m_usfmStructDirName;
			if (!::wxDirExists(m_usfmStructDirPath))
			{
				// The hidden dir .usfmstruct doesn't exist yet so create it.
				bool bOK;
				bOK = ::wxMkdir(m_usfmStructDirPath);
				if (!bOK)
				{
					// failure to make the directory not expected so English message to the user log is sufficient
					wxString msg = _T("In OnNewDocument() - Failed to Create hidden directory at %s");
					msg = msg.Format(msg, m_usfmStructDirPath.c_str());
					gpApp->LogUserAction(msg);
				}
			}

			m_usfmStructFilePathAndName = m_usfmStructDirPath + gpApp->PathSeparator + m_usfmStructFileName + m_usfmStructDirName;
			// The wxArrayString m_UsfmStructArr array is on the Doc class, and its contents persist while a doc is open.
			m_UsfmStructArr = GetUsfmStructureAndExtent(*gpApp->m_pBuffer, TRUE);
			// Get the wxArrayString's lines and save them in the <filename>.usfmstruct file at:
			// .../Adapt It Unicode Work/<project-directory/Adaptations/.usfmstruct/<filename>.usfmstruct
			m_UsfmStructStringBuffer.Empty();
			size_t len = 0;
			// scan our array and determine its required character length including EOL chars
			int totCt = (int)m_UsfmStructArr.GetCount();
			for (int i = 0; i < totCt; i++)
			{
				m_UsfmStructStringBuffer = m_UsfmStructStringBuffer + m_UsfmStructArr.Item(i) + _T("\r\n");
				len += m_UsfmStructArr.Item(i).Length();
				len += 2; // for the EOLs _T("\r\n") to be added
			}

			// We should ensure it doesn't exist because we want to start afresh for a new usfmstruct file.
			if (::wxFileExists(m_usfmStructFilePathAndName))
			{
				bool bRemoved = FALSE;
				bRemoved = ::wxRemoveFile(m_usfmStructFilePathAndName);
				if (!bRemoved)
				{
					// Not likely to happen, so an English message will suffice.
					wxString msg = _T("Unable to remove existing usfmstruct file at:\n%s");
					msg = msg.Format(msg, m_usfmStructFilePathAndName.c_str());
					gpApp->LogUserAction(msg);
				}
			}
			
			// Write the usfmstruct string to the .usfmstruct file
			wxFile f;
			if (!f.Open(m_usfmStructFilePathAndName, wxFile::write))
			{
				wxString msg = _T("Failed f.Open() for writing usfmstruct info to %s");
				msg = msg.Format(msg, m_usfmStructFilePathAndName.c_str());
				gpApp->LogUserAction(msg);
			}
			else
			{
				f.Write(m_UsfmStructStringBuffer, len);
			}

			f.Close();
			*/

			// parse the input file
			// whm 6Apr2020 Note: If the parsing routine in TokenizeText() below crashes, is is NOT likely 
			// that the warning message below would ever be show to the user since the wxMessageBox that
			// displays the message below TokenizeText().
			int nHowMany;
			wxString msg = _("Aborting document creation. A significant parsing error occurred.\n\nThe most recent diagnostic log file named %s is in the __LOGS_EMAIL_REPORTS folder.\n\nThe last line in that diagnostic file shows the last source word/phrase processed before the error. Please send that diagnostic file to the developers.");
			msg = msg.Format(msg, gpApp->m_docCreationFilePathAndName);
			wxString msgEnglish = _T("Aborting document creation. A significant parsing error occurred.\n\nThe most recent diagnostic log file named %s is in the __LOGS_EMAIL_REPORTS folder.\n\nThe last line in that diagnostic file shows the last source word/phrase processed before the error. Please send that diagnostic file to the developers.");
			msgEnglish = msgEnglish.Format(msgEnglish, gpApp->m_docCreationFilePathAndName);
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			if (pApp->m_bMakeDocCreationLogfile)
			{
				// whm 6Apr2020 modified the CWaitDlg routine below. The TokenizeText() routine
				// takes more time now making it desirable to have a wait dialog show while the document
				// is being created. Logging the doc creation also takes time, so I've re-instituted the 
				// wait dialog to the outer block so that it will be visible during doc creation here - 
				// both for when logging and when not logging the doc creation.
#if defined(__WXMSW__)
				CWaitDlg waitDlg(pApp->GetMainFrame());
				// indicate we want the follwoing wait wait message
				waitDlg.m_nWaitMsgNum = 29;	// 29 has "Please wait while creating a new document - and creating a diagnostic log in folder _LOGS_EMAIL_REPORTS..."
				waitDlg.Centre();
				waitDlg.Show(TRUE);
				waitDlg.Update();
				// the wait dialog is automatically destroyed when it goes out of scope below
#endif
#if defined(_DEBUG) && defined (FIXORDER)
				wxLogDebug(_T("OnNewDocument line %d  m_bTokenizingTargetText = %d"),
					__LINE__, (int)m_bTokenizingTargetText);
#endif

#ifdef SHOW_DOC_I_O_BENCHMARKS
				wxDateTime dt1 = wxDateTime::Now(),
					dt2 = wxDateTime::UNow();
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
				// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
				wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

				nHowMany = TokenizeText(0, pApp->m_pSourcePhrases, *pApp->m_pBuffer,
					(int)pApp->m_nInputFileLength);

				// whm 2Sep2023 testing below 
				// Add a call of the  DoMarkerHousekeeping() function here after TokenizeText()
				// code here directly copied from in the SetupLayoutAndView() function that gets
				// called when collaborating. This is to see if it removes the differences between
				// the xml docs created here in the non-collaboration scenario and the collaboration
				// scenario. The collaboration scenario had more correct xml encoding for certain
				// pSrcPhrase members including m_curTextType and m_inform.
				int unusedInt = 0;
				TextType dummyType = verse;
				bool bPropagationRequired = FALSE;
				pApp->GetDocument()->DoMarkerHousekeeping(pApp->m_pSourcePhrases, unusedInt,
					dummyType, bPropagationRequired);
				pApp->GetDocument()->GetUnknownMarkersFromDoc(pApp->gCurrentSfmSet,
					&pApp->m_unknownMarkers,
					&pApp->m_filterFlagsUnkMkrs,
					pApp->m_currentUnknownMarkersStr,
					useCurrentUnkMkrFilterStatus);
				// whm 2Sep2023 testing above

#ifdef SHOW_DOC_I_O_BENCHMARKS
				dt1 = dt2;
				dt2 = wxDateTime::UNow();
				wxLogDebug(_T("OnNewDocument-with-logging TokenizeText() executed in %s ms"),
					(dt2 - dt1).Format(_T("%l")).c_str());
#endif
				if (nHowMany == -1)
				{
					// whm 6Apr2020 Note: If the parsing routine in TokenizeText() below crashes, is is NOT likely 
					// that the warning message below would ever be show to the user since the wxMessageBox that
					// displays the message below TokenizeText().
					// Abort the document creation, there has been a significant parsing error.
					// Do a diagnostic run (see View page of Preferences)
					pApp->LogUserAction(msgEnglish);
					wxMessageBox(msg, _T(""), wxICON_WARNING | wxOK);

#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
					wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
					return TRUE;
				}
			}
			else
			{
				// No logfile is to be created
#if defined(__WXMSW__)
				CWaitDlg waitDlg(pApp->GetMainFrame());
				// indicate we want the following wait message
				waitDlg.m_nWaitMsgNum = 27;	// 27 has "Please wait while creating a new document..."
				waitDlg.Centre();
				waitDlg.Show(TRUE);
				waitDlg.Update();
				// the wait dialog is automatically destroyed when it goes out of scope below
#endif

#if defined(_DEBUG) && defined (FIXORDER)
				wxLogDebug(_T("OnNewDocument line %d  m_bTokenizingTargetText = %d"),
					__LINE__, (int)m_bTokenizingTargetText);
#endif
#ifdef SHOW_DOC_I_O_BENCHMARKS
				wxDateTime dt1 = wxDateTime::Now(),
					dt2 = wxDateTime::UNow();
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
				// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
				wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
				nHowMany = TokenizeText(0, pApp->m_pSourcePhrases, *pApp->m_pBuffer,
					(int)pApp->m_nInputFileLength);

				// whm 2Sep2023 testing below 
				// Add a call of the  DoMarkerHousekeeping() function here after TokenizeText()
				// code here directly copied from in the SetupLayoutAndView() function that gets
				// called when collaborating. This is to see if it removes the differences between
				// the xml docs created here in the non-collaboration scenario and the collaboration
				// scenario. The collaboration scenario had more correct xml encoding for certain
				// pSrcPhrase members including m_curTextType and m_inform.
				int unusedInt = 0;
				TextType dummyType = verse;
				bool bPropagationRequired = FALSE;
				pApp->GetDocument()->DoMarkerHousekeeping(pApp->m_pSourcePhrases, unusedInt,
					dummyType, bPropagationRequired);
				pApp->GetDocument()->GetUnknownMarkersFromDoc(pApp->gCurrentSfmSet,
					&pApp->m_unknownMarkers,
					&pApp->m_filterFlagsUnkMkrs,
					pApp->m_currentUnknownMarkersStr,
					useCurrentUnkMkrFilterStatus);
				// whm 2Sep2023 testing above

#ifdef SHOW_DOC_I_O_BENCHMARKS
				dt1 = dt2;
				dt2 = wxDateTime::UNow();
				wxLogDebug(_T("OnNewDocument-without-logging TokenizeText() executed in %s ms"),
					(dt2 - dt1).Format(_T("%l")).c_str());
#endif
				if (nHowMany == -1)
				{
					// whm 6Apr2020 Note: If the parsing routine in TokenizeText() below crashes, is is NOT likely 
					// that the warning message below would ever be shown to the user since the wxMessageBox that
					// displays the message below is below the code execution point in TokenizeText() where crash 
					// would likely happen.
					//
					// Abort the document creation, there has been a significant parsing error.
					// Do a diagnostic run (see View page of Preferences)
					pApp->LogUserAction(msgEnglish);
					pApp->m_bParsingSource = FALSE;
					pApp->m_bMakeDocCreationLogfile = FALSE;
					wxMessageBox(msg, _T(""), wxICON_WARNING | wxOK);

#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
					wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

					return TRUE;
				}
			}

			// whm 13Nov2023 added the following function call to update the filter status fields in the 
			// .usfmstruct file that was created for the newly created document from the input source text
			// file before the TokenizeText() call above.
			// The following function uses the gCurrentFilterMarkers string to add or update the last colon
			// delimited field in the .sfmstruct file, making the field ":1" if the marker is present in
			// gCurrentFilterMarkers, or making it ":0" if the marker is NOT present in gCurrentFilterMarkers.
			// Note: SetupUsfmStructArrayAndFile() should be called BEFORE the TokenizeText[String]()
			// call above. Then, then a call to UpdateCurrentFilterStatusOfUsfmStructFileAndArray()
			// AFTER the TokenizeText[String]() call is made here below.
			if (m_bUsfmStructEnabled)
			{
				UpdateCurrentFilterStatusOfUsfmStructFileAndArray(m_usfmStructFilePathAndName);
			}

			// whm 13Apr2020 added line at end of document creation log to indicate we reached end of the document
			// This essentially signals within the log file that the document creation was successful.
			if (pApp->m_bMakeDocCreationLogfile)
			{
				pApp->LogDocCreationData(_T("***End-of-Document***"));
			}
			pApp->m_bParsingSource = FALSE; // make sure doc creation logging stays OFF
											 // until explicitly turned on at another time
			pApp->m_bMakeDocCreationLogfile = FALSE; // turn this OFF to prevent user
				// leaving it turned on, and wondering why doc creation takes minutes to complete

#if defined(_DEBUG) && !defined(NOLOGS) //&& defined(FWD_SLASH_DELIM)
			if (pApp->m_bFwdSlashDelimiter)
			{
				SPList::Node* pos_pSP = gpApp->m_pSourcePhrases->GetFirst();
				CSourcePhrase* pSP;
				do
				{
					pSP = pos_pSP->GetData();
					wxString bracketed = _T('[');
					bracketed += pSP->GetSrcWordBreak();
					bracketed += _T(']');
					wxLogDebug(_T("SrcPhrase: %s  sequnum  %d   [m_srcWordBreak] =  %s"),
						pSP->m_srcPhrase.c_str(), pSP->m_nSequNumber, bracketed.c_str());
					pos_pSP = pos_pSP->GetNext();
				} while (pos_pSP != NULL);
			}
#endif
			// Get any unknown markers stored in the m_markers member of the Doc's
			// source phrases whm ammended 29May06: Bruce desired that the filter
			// status of unk markers be preserved for new documents created within the
			// same project within the same session, so I've changed the last parameter
			// of GetUnknownMarkersFromDoc from setAllUnfiltered to
			// useCurrentUnkMkrFilterStatus.
			GetUnknownMarkersFromDoc(gpApp->gCurrentSfmSet, &gpApp->m_unknownMarkers,
				&gpApp->m_filterFlagsUnkMkrs,
				gpApp->m_currentUnknownMarkersStr,
				useCurrentUnkMkrFilterStatus);

#ifdef _Trace_UnknownMarkers
			TRACE0("In OnNewDocument AFTER GetUnknownMarkersFromDoc (setAllUnfiltered) call:\n");
			TRACE1(" Doc's unk mrs from arrays  = %s\n", GetUnknownMarkerStrFromArrays(&m_unknownMarkers, &m_filterFlagsUnkMkrs));
			TRACE1(" m_currentUnknownMarkersStr = %s\n", m_currentUnknownMarkersStr);
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			// calculate the layout in the view
			int srcCount;
			srcCount = pApp->m_pSourcePhrases->GetCount();
			srcCount = srcCount; // unused  (retain to avoid compiler warning)
			if (pApp->m_pSourcePhrases->IsEmpty())
			{
				// IDS_NO_SOURCE_DATA
				wxMessageBox(_(
					"Sorry, but there was no source language data in the file you input, so there is nothing to be displayed. Try a different file."),
					_T(""), wxICON_EXCLAMATION | wxOK);

				// restore everything
				pApp->m_pTargetBox->GetTextCtrl()->ChangeValue(_T(""));
				if (pApp->m_pBuffer != NULL) // whm 11Jun12 added NULL test
					delete pApp->m_pBuffer;
				pApp->m_pBuffer = (wxString*)NULL; // MFC had = 0
				pView->Invalidate();
				GetLayout()->PlaceBox();
				pApp->LogUserAction(_T("No source language data in input file in OnNewDocument()"));

				pApp->m_bZWSPinDoc = FALSE; // BEW 7Oct14 restore default

#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
				wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

				return TRUE; // BEW 25Aug10, never return FALSE from OnNewDocument() if
							 // you want the doc/view framework to keep working right
			}

			// try this for the refactored layout design....
			CLayout* pLayout = GetLayout();

			pLayout->SetLayoutParameters(); // calls InitializeCLayout() and
						// UpdateTextHeights() and calls other relevant setters
#ifdef _NEW_LAYOUT
			bool bIsOK = pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#else
			bool bIsOK = pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#endif
			if (!bIsOK)
			{
				// unlikely to fail, so just have something for the developer here
				wxMessageBox(_T("Error. RecalcLayout(TRUE) failed in OnNewDocument()"),
					_T(""), wxICON_STOP);
				wxASSERT(FALSE);
				pApp->LogUserAction(_T("Error. RecalcLayout(TRUE) failed in OnNewDocument()"));
				wxExit();
			}
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			// mark document as modified
			Modify(TRUE);

			// show the initial phraseBox - place it at the first empty target slot
			pApp->m_pActivePile = GetPile(0);

			pApp->m_nActiveSequNum = 0;
			bool bTestForKBEntry = FALSE;
			CKB* pKB;
			if (gbIsGlossing) // should not be allowed to be TRUE when OnNewDocument is called,
							  // but I will code for safety, since it can be handled okay
			{
				bTestForKBEntry = pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry;
				pKB = pApp->m_pGlossingKB;
			}
			else
			{
				bTestForKBEntry = pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry;
				pKB = pApp->m_pKB;
			}
			pKB = pKB; // avoid warning
			if (bTestForKBEntry)
			{
				// it's not an empty slot, so search for the first empty one & do it there; but if
				// there are no empty ones, then revert to the first pile
				CPile* pPile = pApp->m_pActivePile;
				pPile = pView->GetNextEmptyPile(pPile);
				if (pPile == NULL)
				{
					// there was none, so we must place the box at the first pile
					pApp->m_pTargetBox->m_textColor = pApp->m_targetColor;
					pView->PlacePhraseBox(pApp->m_pActivePile->GetCell(1));
					pView->Invalidate();
					pApp->m_nActiveSequNum = 0;

					pApp->m_nOldSequNum = -1; // no previous location exists yet
					// get rid of the stored rebuilt source text, leave a space there instead
					if (pApp->m_pBuffer)
						*pApp->m_pBuffer = _T(' ');

					pApp->m_bZWSPinDoc = FALSE; // BEW 7Oct14 restore default

					return TRUE;
				}
				else
				{
					pApp->m_pActivePile = pPile;
					pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber;
				}
			}
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			// BEW added 10Jun09, support phrase box matching of the text colour chosen
			if (gbIsGlossing && gbGlossingUsesNavFont)
			{
				pApp->m_pTargetBox->GetTextCtrl()->SetOwnForegroundColour(pLayout->GetNavTextColor());// whm 12Jul2018 added ->GetTextCtrl() part
			}
			else
			{
				pApp->m_pTargetBox->GetTextCtrl()->SetOwnForegroundColour(pLayout->GetTgtColor());// whm 12Jul2018 added ->GetTextCtrl() part
			}

			// set initial location of the targetBox
			pApp->m_targetPhrase = pView->CopySourceKey(pApp->m_pActivePile->GetSrcPhrase(), FALSE);
			pApp->m_pTargetBox->m_Translation = pApp->m_targetPhrase;
			pApp->m_pTargetBox->m_textColor = pApp->m_targetColor;
			pView->PlacePhraseBox(pApp->m_pActivePile->GetCell(1), 2); // calls RecalcLayout()

			// save old sequ number in case required for toolbar's Back button - in this case
			// there is no earlier location, so set it to -1
			pApp->m_nOldSequNum = -1;
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			// set the initial global position variable
			break;
		}// end of case getNewFile_success
		case getNewFile_error_at_open:
		{
			wxString strMessage;
			strMessage = strMessage.Format(_("Error opening file %s."), pathName.c_str());
			wxMessageBox(strMessage, _T(""), wxICON_ERROR | wxOK);
			gpApp->m_lastSourceInputPath = gpApp->m_workFolderPath;
			pApp->LogUserAction(strMessage);
			pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
			break;
		} // end of case getNewFile_error_at_open:
		case getNewFile_error_opening_binary:
		{
			// A binary file - probably not a valid input file such as a MS Word doc.
			// Notify user that Adapt It cannot read binary input files, and abort the
			// loading of the file.
			wxString strMessage = _(
				"The file you selected for input appears to be a binary file.");
			if (fnExtensionOnly.MakeUpper() == _T("DOC"))
			{
				strMessage += _T("\n");
				strMessage += _(
					"Adapt It cannot use Microsoft Word Document (doc) files as input files.");
			}
			else if (fnExtensionOnly.MakeUpper() == _T("ODT"))
			{
				strMessage += _T("\n");
				strMessage += _(
					"Adapt It cannot use OpenOffice's Open Document Text (odt) files as input files.");
			}
			strMessage += _T("\n");
			strMessage += _("Adapt It input files must be plain text files.");
			wxString strMessage2;
			strMessage2 = strMessage2.Format(_("Error opening file %s."), pathName.c_str());
			strMessage2 += _T("\n");
			strMessage2 += strMessage;
			wxMessageBox(strMessage2, _T(""), wxICON_ERROR | wxOK);
			gpApp->m_lastSourceInputPath = gpApp->m_workFolderPath;
			pApp->LogUserAction(strMessage2);
			pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
			break;
		} // end of case getNewFile_error_opening_binary:
		case getNewFile_error_ansi_CRLF_not_in_sequence:
		{
			// this error cannot occur, because the code where it may be generated is
			// never entered for a GetNewFile() call made in OnNewDocument, but the
			// compiler needs a case for this enum value otherwise there is a warning
			// generated
			wxMessageBox(_T("Input data malformed: CR and LF not in sequence"),
				_T(""), wxICON_ERROR | wxOK);
			pApp->LogUserAction(_T("Input data malformed: CR and LF not in sequence"));
			pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
			break;
		} // end of case getNewFile_error_ansi_CRLF_not_in_sequence:
		case getNewFile_error_no_data_read:
		{
			// we got no data, so this constitutes a read failure
			wxMessageBox(_("File read error: no data was read in"), _T(""), wxICON_ERROR | wxOK);
			pApp->LogUserAction(_T("File read error: no data was read in"));
			pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
			break;
		} // end of case getNewFile_error_no_data_read:
		case getNewFile_error_unicode_in_ansi:
		{
			// The file is a type of Unicode, which is an error since this is the ANSI build. Notify
			// user that Adapt It Regular cannot read Unicode input files, and abort the loading of the
			// file.
			wxString strMessage = _("The file you selected for input is a Unicode file.");
			strMessage += _T("\n");
			strMessage += _("This Regular version of Adapt It cannot process Unicode text files.");
			strMessage += _T("\n");
			strMessage += _(
				"You should install and use the Unicode version of Adapt It to process Unicode text files.");
			wxString strMessage2;
			strMessage2 = strMessage2.Format(_("Error opening file %s."), pathName.c_str());
			strMessage2 += _T("\n");
			strMessage2 += strMessage;
			wxMessageBox(strMessage2, _T(""), wxICON_ERROR | wxOK);
			gpApp->m_lastSourceInputPath = gpApp->m_workFolderPath;
			pApp->LogUserAction(strMessage2);
			pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
			break;
		} // end of case getNewFile_error_unicode_in_ansi:

		}// end of switch (GetNewFile(pApp->m_pBuffer, pApp->m_nInputFileLength, pathName))

	} // end of if (bKBReady)

	// get rid of the stored rebuilt source text, leave a space there instead (the value of
	// m_nInputFileLength can be left unchanged)
	if (pApp->m_pBuffer)
		*pApp->m_pBuffer = _T(' ');
	gbDoingInitialSetup = FALSE; // turn it back off, the pApp->m_targetBox now exists, etc

	// BEW added 01Oct06: to get an up-to-date project config file saved (in case user
	// turned on or off the book mode in the wizard) so that if the app subsequently
	// crashes, at least the next launch will be in the expected mode
	if (pApp->m_bPassedAppInitialization && !pApp->m_curProjectPath.IsEmpty())
	{
		bool bOK;
		if (pApp->m_bUseCustomWorkFolderPath && !pApp->m_customWorkFolderPath.IsEmpty())
		{
			// whm 10Mar10, must save using what paths are current, but when the custom
			// location has been locked in, the filename lacks "Admin" in it, so that it
			// becomes a "normal" project configuration file in m_curProjectPath at the
			// custom location.
			if (pApp->m_bLockedCustomWorkFolderPath)
			{
				pApp->LogUserAction(_T("In OnNewDocument with custom work folder locked: writing proj config file"));
				bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
			}
			else
			{
				pApp->LogUserAction(_T("In OnNewDocument with custom work folder not locked: writing proj config file"));
				bOK = pApp->WriteConfigurationFile(szAdminProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
			}
		}
		else
		{
			pApp->LogUserAction(_T("In OnNewDocument with normal work folder: writing proj config file"));
			bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
		}
		// we don't expect a write error, but tell the developer or user if the write
		// fails, and keep on processing
		if (!bOK)
		{
			pApp->LogUserAction(_T("In OnNewDocument WriteConfigurationFile() failed"));
			wxMessageBox(_T("Adapt_ItDoc.cpp, WriteConfigurationFile() failed, for project config file or admin project config file, in OnNewDocument() at lines 1393+"));
		}
		pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
	}

	// whm 1Oct12 removed MRU code
	/*
	// Note: On initial program startup OnNewDocument() is executed from OnInit()
	// to get a temporary doc and view. pApp->m_curOutputPath will be empty in
	// that case, so only call AddFileToHistory() when it's not empty.
	if (!pApp->m_curOutputPath.IsEmpty())
	{
		wxFileHistory* fileHistory = pApp->m_pDocManager->GetFileHistory();
		fileHistory->AddFileToHistory(pApp->m_curOutputPath);
		// The next two lines are a trick to get past AddFileToHistory()'s behavior of
		// extracting the directory of the file you supply and stripping the path of all
		// files in history that are in this directoy. RemoveFileFromHistory() doesn't do
		// any tricks with the path, so the following is a dirty fix to keep the full
		// paths.
		fileHistory->AddFileToHistory(wxT("[tempDummyEntry]"));
		fileHistory->RemoveFileFromHistory(0); //
	}
	*/

	// BEW added 13Nov09, for setting or denying ownership for writing permission. This is
	// something we want to do each time a doc is created (or opened) - if the local user
	// already has ownership for writing, no change is done and he retains it; but if he
	// had read only access, and the other person has relinquished the project, then the
	// local user will now get ownership. BEW modified 18Nov09: there is an OnFileNew()
	// call made in OnInit() at application initialization time, and control goes to
	// wxWidgets CreateDocument() which internally calls its OnNewDocument() function which
	// then calls Adapt_ItDoc::OnNewDocument(). If, therefore, we here allow
	// SetReadOnlyProtection() to be called while control is within OnInit(), we'll end up
	// setting read-only access off when the application is the only instance running and
	// accessing the last used project folder (and OnInit() then has to be given code to
	// RemoveReadOnlyProtection() immediately after the OnFileNew() call, because the
	// latter is bogus, it is just to get the wxWidgets doc/view framework set up, and the
	// "real" access of a project folder comes later, after OnInit() ends and OnIdle() runs
	// and so the start working wizard runs, etc. All that is fine until the user does the
	// following: the user starts Adapt It and opens a certain project; then the user
	// starts a second instance of Adapt It and opens the same project -- when this second
	// process runs, and while still within the OnInit() function, it detects that the
	// read-only protection file is currently open - and it is unable to remove it because
	// this is not the original process (although a 'bogus' one) that obtained ownership of
	// the project - and our code then aborts the second running Adapt It instance giving a
	// message that it is going to abort. This is unsatisfactory because we want anyone,
	// whether the same user or another, to be able to open a second instance of Adapt It
	// in read-only mode to look at what is being done, safely, in the first running
	// instance. Removing another process's open file is forbidden, so the only recourse is
	// to prevent the 'bogus' OnFileNew() call within OnInit() from creating a read-only
	// protection file here in OnNewDocument() if the call of the latter is caused from
	// within OnInit(). We can do this by having an app boolean which is TRUE during
	// OnInit() and FALSE thereafter. We'll call it:   m_bControlIsWithinOnInit
	if (!pApp->m_bControlIsWithinOnInit)
	{
		// whm added 7Mar12 code for fictitious read only access. If the m_bFictitiousReadOnlyAccess
		// flag is set, ForceFictitiousReadOnlyProtection() should be called before the call to
		// SetReadOnlyProtection().
		if (pApp->m_bFictitiousReadOnlyAccess)
		{
			pApp->m_pROP->ForceFictitiousReadOnlyProtection(pApp->m_curProjectPath);
		}

		pApp->m_bReadOnlyAccess = pApp->m_pROP->SetReadOnlyProtection(pApp->m_curProjectPath);

		if (pApp->m_bReadOnlyAccess)
		{
			// if read only access is turned on, force the background colour change to show
			// now, instead of waiting for a user action requiring a canvas redraw
			pApp->GetView()->canvas->Refresh(); // needed? the call in OnIdle() is more efffective
		}
		pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
	}
	pApp->LogUserAction(_T("Return TRUE from OnNewDocument()"));

	// BEW added 7Oct14
	pApp->m_bZWSPinDoc = pApp->IsZWSPinDoc(pApp->m_pSourcePhrases);

	pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
	wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

	return TRUE;
}

/*
void CAdapt_ItDoc::UpdateDocCreationLog(CSourcePhrase* pSrcPhrase, wxString& chapter, wxString& verse)
{
	wxString myLine;
	size_t count;
	wxString logsPath = gpApp->m_logsEmailReportsFolderPath;
	wxString logFilename = gpApp->m_filename_for_ParsingSource; // OnInit() sets it to "Log_For_Document_Creation.txt"
					// ReadDoc_XML() temporarily sets it to "Log_Doc_XML_Load_Attempt", and restores the above after the load
	wxString path = logsPath + gpApp->PathSeparator + logFilename;
	wxTextFile f(path);
	myLine = myLine.Format(_T("%s  %d  %s:%s"),
			pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_nSequNumber, chapter.c_str(), verse.c_str());
	if (!f.IsOpened())
	{
		if (f.Open())
		{
			count = f.GetLineCount();

			if (count < 6)
			{
				f.AddLine(myLine);
				f.Write();
			}
			else
			{
				f.RemoveLine((size_t)1);
				f.AddLine(myLine);
				f.Write();
			}
			f.Close();
		}
	}
}
*/

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param	event	-> wxCommandEvent (unused)
/// \remarks
/// Called from: the doc/view framework when wxID_SAVE event is generated. Also called from
/// CMainFrame's SyncScrollReceive() when it is necessary to save the current document before
/// opening another document when sync scrolling is on.
/// OnFileSave simply calls DoFileSave() and the latter sets an enum value of normal_save
///
/// BEW changed 28Apr10 A failure might be due to the Open call failing, in which case the
/// document's file is probably unchanged, or an unknown error, in which case the
/// document's file may have been truncated to zero length by the f.Open call done
/// beforehand. So we need code added in order to recover the document; also we have to
/// handle the possibility that the document may not yet have ever been saved, which
/// changes what we need to do in the event of failure.
/// BEW 29Apr10, added a public DoFileSave_Protected() file which returns boolean, because
/// the DoFileSave() function was called in a number of places and it was dangerous if it
/// failed (data would be lost), so I wrapped it with data protection code and called the
/// new function DoFileSave_Protected(), and put that in place of the other throughout the
/// app.
/// BEW 16Apr10, added enum, for support of Save As... menu item as well as Save
/// BEW 28Jul11, added some initial support for collaboration scenario's tranfer of data to
/// external editor
///////////////////////////////////////////////////////////////////////////////

void CAdapt_ItDoc::OnFileSave(wxCommandEvent& WXUNUSED(event))
{
	// whm 26Aug11 Open a wxProgressDialog instance here for save operations.
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).

	wxString msgDisplayed;
	const int nTotal = gpApp->GetMaxRangeForProgressDialog(App_SourcePhrases_Count) + 1;
	wxString progMsg = _("Saving File %s  - %d of %d Total words and phrases");
	wxFileName fn(gpApp->m_curOutputFilename);
	msgDisplayed = progMsg.Format(progMsg, fn.GetFullName().c_str(), 1, nTotal);
	CStatusBar* pStatusBar = NULL;
	pStatusBar = (CStatusBar*)gpApp->GetMainFrame()->m_pStatusBar;
	if (gpApp->m_bShowProgress)
	{
		pStatusBar->StartProgress(_("Saving File"), msgDisplayed, nTotal);
	}

	if (gpApp->m_bCollaboratingWithParatext || gpApp->m_bCollaboratingWithBibledit)
	{
		// whm modified 17Jan12 consolidated the code for collab mode file saves
		// in a DoCollabFileSave() function as it needs to also be called from
		// OnSaveModified(), otherwise saves can be lost if user closes the main
		// frame window - which triggers OnSaveModified() but not OnFileSave().
		// Notes:
		// 1. DoCollabFileSave() returns a bool as does DoFileSave_Protected()
		// and DoFileSave(), but they (and hence DoCollabFileSave() too) make
		// no use of the bool value that is returned - although the code probably
		// should.
		// 2. DoCollabFilesave() also calls DoFileSave_Protected(TRUE,pProgDlg)
		DoCollabFileSave((gpApp->m_bShowProgress) ? _("Saving File") : _T(""), msgDisplayed);
	}
	else
	{
		// no collaboration - do a normal protected save

		// we are not interested in the returned boolean from the following call
		DoFileSave_Protected(gpApp->m_bShowProgress, (gpApp->m_bShowProgress) ? _("Saving File") : _T("")); // only show wait/progress dialog if flag is TRUE
	}
	if (gpApp->m_bShowProgress)
	{
		pStatusBar->FinishProgress(_("Saving File"));
	}
}


void CAdapt_ItDoc::OnTakeOwnership(wxCommandEvent& WXUNUSED(event))
{
	wxCommandEvent	dummy;

	// BEW comment 3Jun13. This function works to support NOOWNER (#defined as the string
	// ****) as a default owner so long as KB Sharing, or DVCS, is not invoked. Once one of
	// those is invoked, a unique owner (e.g. a full email address, or other unique name
	// string) and an informal username (such as "John Doe") need to be supplied - and the
	// dialog for doing that won't allow dismissal of itself without something other than
	// **** being typed in each of its two wxTextCtl widgets. The function which checks for
	// empty string or **** is CheckUsername() - it's in helpers.cpp.

	gpApp->LogUserAction(_T("OnTakeOwnership() called - m_owner = ") + gpApp->m_owner + _T(" m_strUserID = ") + gpApp->m_strUserID);

	if (gpApp->m_strUserID.IsEmpty() || gpApp->m_strFullname.IsEmpty())   // this can happen if AI is launched with shift down
	{
		wxCommandEvent	dummy;

		gpApp->OnEditChangeUsername(dummy);

		// BEW 4Nov13, added 2nd test for empty m_strUserID
		if (gpApp->m_strUserID == NOOWNER || gpApp->m_strUserID.IsEmpty()) // did we get a username?
		{                                               // nope - whinge and bail out.
			wxMessageBox(_("No username entered -- owner not changed."));
			gpApp->LogUserAction(_T("No username entered -- owner not changed."));
			return;
		}
	}

	// BEW 4Nov13 added outer test. It was possible to get here with m_bReadOnlyAccess
	// TRUE, but no username in the config file -- by running 6.4.3 for instance, which
	// shows doc read only, but my username was already in the doc from earlier runs with
	// the 6.5.0 code, so after the Username Input dialog allowed me to reset username and
	// informal name, the unprotected inner test would return control to the caller without
	// read-only status being removed, hence the need for the outer test
	if (!gpApp->m_bReadOnlyAccess)
	{
		if (gpApp->m_owner == gpApp->m_strUserID)
			return;                             // if we're already the owner, there's nothing to do
	}

	gpApp->m_owner = gpApp->m_strUserID;	// force doc's owner to be logged-in user, no matter what
	gpApp->m_bReadOnlyAccess = FALSE;		// make doc editable
	Modify(TRUE);							// mark doc dirty, to ensure new owner gets saved

	gpApp->GetView()->UpdateAppearance();   // get rid of the pink
}

/*	mrh - May 2012.
	This function is needed for the version control stuff, but might be more generally useful
	as well.  It's called when something external to AdaptIt has modified the current document.
	We need to re-read it, and refresh the screen display.  The code below is largely lifted from
	OnEditConsistencyCheck().
*/

void CAdapt_ItDoc::DocChangedExternally()
{
	bool			bOK;

	wxString		savedCurOutputPath = gpApp->m_curOutputPath;			// includes filename
	wxString		savedCurOutputFilename = gpApp->m_curOutputFilename;
	//	int				savedCurSequNum = gpApp->m_nActiveSequNum;				// for resetting the box location
	bool			savedBookmodeFlag = gpApp->m_bBookMode;					// for ensuring correct mode
	bool			savedDisableBookmodeFlag = gpApp->m_bDisableBookMode;	// ditto
	int				savedBookIndex = gpApp->m_nBookIndex;
	BookNamePair* pSavedCurBookNamePair = gpApp->m_pCurrBookNamePair;
	int				savedCommitCount = gpApp->m_commitCount;				// We'll have this count up monotonically, not
																			//  use the value we read in.  Change if necessary.
	int				savedTrialVersionNum = gpApp->m_trialVersionNum;
	wxString		dirPath;

	gpApp->LogUserAction(_T("Entering DocChangedExternally()"));

	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
		dirPath = gpApp->m_bibleBooksFolderPath;
	else
		dirPath = gpApp->m_curAdaptationsPath;

	wxString		strSaveCurrentDirectoryFullPath = dirPath;

	// whm 8Apr2021 added wxLogNull block below
	{
		wxLogNull logNo;	// eliminates any spurious messages from the system if the wxSetWorkingDirectory() call returns FALSE
		bOK = ::wxSetWorkingDirectory(dirPath); // ignore failures
	} // end of wxLogNull scope
	bOK = bOK; // whm added 13Aug12 to suppress gcc warning "set but not used"

	m_bReopeningAfterClosing = TRUE;	// to prevent KB being clobbered -- we want only the doc closed
	OnCloseDocument();
	m_bReopeningAfterClosing = FALSE;	// restore normal default

	gpApp->m_bDocReopeningInProgress = TRUE;	// suppresses warning message about project folder with same name

	bOK = ReOpenDocument(gpApp,
		strSaveCurrentDirectoryFullPath,
		savedCurOutputPath,
		savedCurOutputFilename,
		//							savedCurSequNum,
		savedBookmodeFlag,
		savedDisableBookmodeFlag,
		pSavedCurBookNamePair,
		savedBookIndex,
		FALSE					// don't mark as dirty
	);

	gpApp->m_bDocReopeningInProgress = FALSE;
	gpApp->m_commitCount = savedCommitCount;
	gpApp->m_trialVersionNum = savedTrialVersionNum;

	// BEW added 3June14 Since in general the phrasebox position in the restored
	// document will be different than its position in the former current document, in
	// free translation mode this would lead to the free translation (if one has been
	// typed) in the ComposeBar's editbox being left there - and of course it would be
	// wrong, because the restored doc would still be in free translation mode and the
	// new box location would, if in no former free trans section, become the new anchor
	// location for a newly created section - and it would be a bogus meaning; but if
	// the phrasebox was within a free trans section, AI's code would move it automatically
	// back to the section's anchor - which is fine, and that should have the bogus free
	// translation replaced by that section's correct one. So this would be okay. It's when
	// the box is put at a location with no section that we get a problem. The safest thing
	// to do is to check for free translation mode, and if turned ON, then clear the
	// compose bar so that at least the user won't start out with a confusing wrong free
	// translation string
	if (gpApp->m_bFreeTranslationMode)
	{
		CMainFrame* pFrame = gpApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxPanel* pBar = pFrame->m_pComposeBar;
		if (pBar != NULL && pBar->IsShown())
		{
			wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
			if (pEdit != 0)
			{
				wxString tempStr;
				// clear the Compose Bar's edit box
				tempStr.Empty();
				pEdit->ChangeValue(tempStr);
			}
		}
	}
}


bool  CAdapt_ItDoc::Git_installed()
{
	if (!gpApp->m_DVCS_installed)
	{
		wxString msg = _("Adapt It cannot maintain a history of its documents because the Git program is not installed on this computer. Git can be installed by selecting the 'Install the Git program...' item on the Tools menu. If you just installed Git using the Tools menu item, you need to quit Adapt It and restart the computer for Git to work.");
		wxMessageBox(msg, _("Git program is not available for use by Adapt It"), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(msg);

		return FALSE;
	}
	return TRUE;
}


/*  mrh - 5Jun14.
	CollaborationEditorAcceptsDataTransfers() checks if safe to Save with regard to collaboration.

	If we're collaborating with Paratext or BibleEdit, and if the one we're collaborating with is currently running,
	it would be unsafe to do a Save which would involve transferring data to the other application, as it might
	cause VCS conflicts when the user of that application next does a Save there.
	In this situation, we warn the user to close the other application now and then try again, and we return
	false from here which will block any Save or DVCS operation.

	If we're not collaborating or the collaboration application isn't running, a Save is safe and we return true.
*/

/* app member variables
 bool m_bCollaboratingWithParatext;
 bool m_bCollaboratingWithBibledit;
 bool m_bCollaborationExpectsFreeTrans;
 bool m_bCollaborationDocHasFreeTrans;
 wxString m_collaborationEditor;
 */

 // whm 11May2017 changed name of function from CollaborationAllowsSaving() to CollaborationEditorAcceptsDataTransfers()
bool  CAdapt_ItDoc::CollaborationEditorAcceptsDataTransfers()
{
#ifndef __WXMAC__       // collaboration doesn't happen on the Mac, so we just return true.
	//wxASSERT(!gpApp->m_collaborationEditor.IsEmpty());

	if ((gpApp->m_bCollaboratingWithParatext && gpApp->ParatextIsRunning()) || (gpApp->m_bCollaboratingWithBibledit && gpApp->BibleditIsRunning()))
	{
		// No, it's unsafe to Save.  Put up a message and return false.

			//wxString msg;
			//msg = msg.Format(_("Adapt It cannot transfer your work to %s while %s is running.\nClick on OK to close this dialog. Leave Adapt It running, switch to %s and shut it down. Then switch back to Adapt It and do the save operation again."),
			//                 gpApp->m_collaborationEditor.c_str(), gpApp->m_collaborationEditor.c_str(), gpApp->m_collaborationEditor.c_str());

			//wxMessageBox(msg, _("Collaboration editor is running"), wxOK);
		return false;
	}

	// All OK.
#endif
	return true;
}

// whm added 11May2017 a function that returns TRUE if the currently open collaboration
// document is designated as 'protected' from transferring data to the external editor,
// FALSE if the collaboration document is not designated as 'protected'.
// Assumes that the caller will only call the function when the document is a collaboration
// document and is open within Adapt It's main window, so that the App's collab values
// are current for the open document.
bool CAdapt_ItDoc::DocumentIsProtectedFromTransferringDataToEditor()
{
	// whm added 17April2017 code to allow collab books/chapters to be protected from
	// writing changes to PT/BE during collaboration saves. These books/chapters would
	// still be saved normally as AI documents in the Adaptations folder - just not to PT/BE.
	// Here is where we should interrupt the transfer of information to PT/BE when the
	// current document is marked as "protected from making changes to PT/BE".
	// We call a new function named IsCollabDocProtectedFromSaving(). If it returns TRUE,
	// DoCollabFileSave() return's FALSE immediately. If IsCollabDocProtectedFromSaving()
	// returns FALSE the book/chapter currently open in collaboration is not marked
	// as protected in the AI-ProjectConfiguration.aic's CollabBooksProtectedFromSavingToEditor
	// field.
	bool bProtectedFromSavingChangesToExternalEditor = FALSE;
	wxString bookCode = gpApp->m_Collab_BookCode;
	bool bCollabByChapterOnly = gpApp->m_bCollabByChapterOnly;
	wxString collabChapterSelected = gpApp->m_CollabChapterSelected; // a wxString represengin a chapter number if collabByChapterOnly is "1"
	wxASSERT(!bookCode.IsEmpty());
	bProtectedFromSavingChangesToExternalEditor = IsCollabDocProtectedFromSavingToEditor(bookCode, bCollabByChapterOnly, collabChapterSelected);

	return bProtectedFromSavingChangesToExternalEditor;
}


bool  CAdapt_ItDoc::Commit_valid()
{
	wxCommandEvent	dummy;

	if (!CollaborationEditorAcceptsDataTransfers())
	{
		wxString msg;
		msg = msg.Format(_("Adapt It cannot transfer your work to %s while %s is running.\nClick on OK to close this dialog. Leave Adapt It running, switch to %s and shut it down. Then switch back to Adapt It and do the save operation again."),
			gpApp->m_collaborationEditor.c_str(), gpApp->m_collaborationEditor.c_str(), gpApp->m_collaborationEditor.c_str());
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;

		wxMessageBox(msg, _("Collaboration editor is running"), wxOK);
		return false;    // Bail out on an unsafe collaboration situation
	}

	if (gpApp->m_strUserID == NOOWNER)
	{
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("Before saving in the document history, you must enter a username for yourself."));
		gpApp->LogUserAction(_T("Before saving in the document history, you must enter a username for yourself."));
		gpApp->OnEditChangeUsername(dummy);

		if (gpApp->m_strUserID == NOOWNER)           // did we get a username?
		{                                              // nope - whinge and bail out.
													   // whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
			gpApp->m_bUserDlgOrMessageRequested = TRUE;
			wxMessageBox(_("No username entered -- document not saved."));
			gpApp->LogUserAction(_T("No username entered -- document not saved."));
			return false;
		}
	}

	if (gpApp->m_owner == NOOWNER)  return true;        // if the doc doesn't have an owner, it's always OK to commit it

	if (gpApp->m_strUserID != gpApp->m_owner)
	{
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("Sorry, it appears the owner of this document is ") + gpApp->m_owner
			+ _(" but the currently logged in user is ") + gpApp->m_strUserID
			+ _(".  Only the document's owner can save in the document history."));
		gpApp->LogUserAction(_T("Sorry, it appears the owner of this document is ") + gpApp->m_owner
			+ _T(" but the currently logged in user is ") + gpApp->m_strUserID
			+ _T(".  Only the document's owner can save in the document history."));
		return false;
	}

	// All OK!
	return true;
}


//  (Feb 2013) - similarly to what Paratext does, if the doc isn't under version control yet, we add it silently.
//  (Mar 2013) - added a parameter "blurb" which gives the informative text that appears in the "save and commit"
//      dialog.  If left empty, the default text appears.mac

int CAdapt_ItDoc::DoSaveAndCommit(wxString blurb)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	int				resultCode;
	wxCommandEvent	dummy;
	wxDateTime		localDate,
		origDate = gpApp->m_versionDate;
	wxString		origOwner = gpApp->m_owner;
	int             origCommitCnt = gpApp->m_commitCount;

	pApp->LogUserAction(_T("Entering DoSaveAndCommit()"));

	if (pApp->m_trialVersionNum >= 0)
	{
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("Before saving in the document history, you must either ACCEPT the revision or RETURN to the latest one."));
		pApp->LogUserAction(_T("Before saving in the document history, you must either ACCEPT the revision or RETURN to the latest one."));
		return -1;
	}

	if (!Commit_valid())
		return -1;              // bail out if the ownership etc. isn't right

	if (!pApp->m_pDVCS->AskSaveAndCommit(blurb))
		return -1;              // or if user cancelled dialog

// Now we find the date/time and the commit count, which we'll save in the file before we do the commit.
// We use UTC for the date/time, which may avoid problems when we're pushing/pulling to a remote location.

	localDate = wxDateTime::Now();
	pApp->m_versionDate = localDate.ToUTC(FALSE);

	if (pApp->m_commitCount < 0)
		pApp->m_commitCount = 0;

	pApp->m_commitCount += 1;					// bump the commit count

	pApp->m_owner = gpApp->m_strUserID;		// owner may have been NOOWNER, but must be assigned on a commit

	pApp->m_bShowProgress = true;	// edb 16Oct12: explicitly set m_bShowProgress before OnFileSave()
	OnFileSave(dummy);							// save the file, ready to commit

	resultCode = pApp->m_pDVCS->DoDVCS(DVCS_COMMIT_FILE, 0);

	if (resultCode)
	{
		// What do we do here??  We've already saved the document with the above info updated.  I think we
		//  should roll everything back and re-save.  The DVCS code will already have given a message.

		pApp->LogUserAction(_T("Rolling back and re-saving"));

		pApp->m_versionDate = origDate;
		pApp->m_commitCount = origCommitCnt;
		pApp->m_owner = origOwner;

		pApp->m_bShowProgress = true;	// edb 16Oct12: explicitly set m_bShowProgress before OnFileSave()
		OnFileSave(dummy);
		return -2;
	}

	// all OK
	return 0;
}

void CAdapt_ItDoc::OnSaveAndCommit(wxCommandEvent& WXUNUSED(event))
{
	if (!Git_installed())
		return;                     // Shows message if git not installed

	// BEW added 3Feb14, If the user has finished adapting to the end of the document, and
	// the phrasebox is no longer visible, and he chooses to save & commit, then the
	// DoSaveAndCommit() call below crashes if the phrasebox is not at some pile - thereby
	// making the pile active. So check and if not visible, put it at the end of the
	// document first.
	if (gpApp->m_pActivePile == NULL || gpApp->m_nActiveSequNum == -1)
	{
		//gpApp->m_bSuppressPseudoDeleteWhenClosingDoc = TRUE;
		PutPhraseBoxAtDocEnd();
		//gpApp->m_bSuppressPseudoDeleteWhenClosingDoc = FALSE;
	}
	DoSaveAndCommit(_T(""));        // Ignore returned result - if an error occurred, a message will have been shown.
}

void CAdapt_ItDoc::EndTrial(bool restoreBackup)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	bool            backupExists = pApp->m_bBackedUpForTrial;

	pApp->m_pDVCSNavDlg->Destroy();         // take down the dialog
	pApp->m_pDVCSNavDlg = NULL;
	pApp->m_trialVersionNum = -1;           // no trial now
	pApp->m_bBackedUpForTrial = FALSE;      // restore normal default here at the start

// now if we did a backup because of uncommitted changes when we started the trial, we may need to restore from the backup:
	if (backupExists)
	{
		wxString    backupPath = pApp->m_curOutputPath + _T("__bak");

		if (restoreBackup)
		{
			pApp->m_bBackedUpForTrial = FALSE;

			bool        bCopiedSuccessfully = ::wxCopyFile(backupPath, pApp->m_curOutputPath, TRUE);   // summarily overwrite!
			wxASSERT(bCopiedSuccessfully);
			bCopiedSuccessfully = bCopiedSuccessfully; // prevent compiler warning in release build
		}

		// so far so good, so we remove the backup:
		bool        bRemovedSuccessfully = ::wxRemoveFile(backupPath);
		if (!bRemovedSuccessfully)
		{
			// tell developer or user, if the removal failed.  This isn't critical - just a warning.
			wxMessageBox(_T("Adapt_ItDoc.cpp, EndTrial()'s call of wxRemoveFile() failed, at line 1709."));
			gpApp->LogUserAction(_T("Adapt_ItDoc.cpp, EndTrial()'s call of wxRemoveFile() failed, at line 1709."));
		}

	}
	DocChangedExternally();                     // Even if we didn't restore from the backup, the read-only status
												//  has changed, so we need this.
	pApp->GetView()->UpdateAppearance();        // whatever happened, the on-screen appearance will have changed
}

void CAdapt_ItDoc::DoChangeVersion(int revNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	int             returnCode;
	wxString        temp;

	temp = temp.Format(_T("DoChangeVersion() called with revNum = %d"), revNum);
	pApp->LogUserAction(temp);

	wxASSERT(revNum >= -2);

	if (revNum == -2)       // "return to latest" was clicked in the dialog.  Whatever we do, we first need to go to the
							// latest committed version.
	{
		returnCode = pApp->m_pDVCS->DoDVCS(DVCS_GET_VERSION, 0);			// get the latest committed revision

		wxASSERT(returnCode >= 0);      // a negative returnCode means a bug
		if (returnCode)  return;        // positive nonzero returnCode means git returned an error -- an error
										//  message should have been displayed already.

		EndTrial(TRUE);                 // end the trial, restoring the backup
		return;
	}

	if (revNum < 0)
	{                   // bail out if no more, coming forward
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("There are no more recent versions in the history!"));
		return;
	}

	if (revNum >= gpApp->m_versionCount)
	{                   // bail out if no more, going back
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("We're already back at the earliest version saved!"));
		return;
	}

	returnCode = pApp->m_pDVCS->DoDVCS(DVCS_GET_VERSION, revNum);			// get the requested revision

	wxASSERT(returnCode >= 0);      // a negative returnCode means a bug
	if (returnCode)  return;        // positive nonzero returnCode means git returned an error -- an error
									//  message should have been displayed already.

// So far so good.  But we need to re-read the doc.  If we're not at the latest revision,
// the doc becomes read-only since ReadOnlyProtection sees that m_trialVersionNum is non-negative.
// If an error has come up, we've already bailed out, leaving the trial status alone.

	pApp->LogUserAction(_T("Successfully got the version - now calling EndTrial() or DocChangedExternally()"));
	pApp->m_trialVersionNum = revNum;           // successfully got to requested revision

	DocChangedExternally();

	if (revNum == 0 && !pApp->m_bBackedUpForTrial)
		EndTrial(TRUE);                        // we're at the latest committed version, and that's really the latest.  The trial's over.
	else
		pApp->GetView()->UpdateAppearance();    // still going, but we have to update the on-screen appearance
}

// IsLatestVersionChanged() calls DVCS to check if the current version on disk is the same as the latest version
//  committed.  It returns TRUE if there are any changes.

bool CAdapt_ItDoc::IsLatestVersionChanged(void)
{
	int  returnCode = gpApp->m_pDVCS->DoDVCS(DVCS_ANY_CHANGES, 0);		// returns 0 if no changes, nonzero otherwise
	return (returnCode != 0);
}

/*
	DoShowPreviousVersions() does the main work for setting up a "trial" of looking at earlier versions and
	deciding what to do.  It's either called directly from the menu choice, or via the "show history" dialog
	where we can select any earlier version and look at it.  In this case we pass TRUE for fromLogDialog.
	If we haven't just done a commit, we need to do one so that we can come back to the latest version if we
	need to.  In this case, and always if we're called directly, we need to call DVCS to (re-)read the version log.
	If we're called from the dialog, OnShowFileLog() below has already read the log, so we don't need to do it
	again unless we do another commit.
	startHere gives the version number we're to show initially, with zero as the latest.  If we're called
	directly, we'll always start with version 1.  If called from the dialog, any version can be asked for,
	but if we do another commit and re-read the log, all the numbers will go up by 1 so we also increment
	startHere.
*/
void CAdapt_ItDoc::DoShowPreviousVersions(bool fromLogDialog, int startHere)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	int				returnCode;
	wxCommandEvent	dummy;
	int				trialRevNum = gpApp->m_trialVersionNum;
	DVCSNavDlg* pNavDlg;
	bool            needBackup = FALSE;
	wxString        temp;

	temp = temp.Format(_T("DoShowPreviousVersions() called with startHere = %d"), startHere);
	pApp->LogUserAction(temp);

	wxASSERT(startHere >= 0);          // 0 is the latest version committed, 1 the next previous, and so on.

	if (pApp->m_commitCount <= 0)
	{
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("There are no earlier versions saved!"));
		return;
	}

	if (trialRevNum == 0)
	{
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("We're already back at the earliest version saved!"));
		return;
	}

	if (trialRevNum > 0)
	{
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_T("We shouldn't have got here!"));
		return;
	}

	// We're initiating a trial review of previous versions.  The current version needs to be backed up so we can come
	// back to it if necessary, so we copy it to a file with the same name with "__bak" appended, in the same folder.
	// But we don't need to do this if the doc has just been committed with no subsequent changes.

#if defined(_DEBUG) && !defined(NOLOGS)
	// BEW 3Jun14 added cast (void*) because without it, on Windows I got an assert trip saying that there was
	// a format specifier which did not match its argument; %d is certainlyl save for the sequ num, so must have been
	// the CPile pointer. The cast should fix it.
	// whm 18Mar2019 removed the (size_t) cast and changed the %x to %p which eliminate the assert. %p is the format specifier for a pointer address.
	wxLogDebug(_T("m_pActivePile = %p  , m_nActiveSequNum =  %d"), pApp->m_pActivePile, pApp->m_nActiveSequNum);
#endif
	pApp->m_bBackedUpForTrial = FALSE;
	if (IsModified())
	{
		pApp->DoAutoSaveDoc();       // if the doc is modified, we have to save it, so it's just like an autosave, and we'll need a backup
#if defined(_DEBUG) && !defined(NOLOGS)
	// BEW 3Jun14 added cast (void*) because without it, on Windows I got an assert trip saying that there was
	// a format specifier which did not match its argument; %d is certainlyl save for the sequ num, so must have been
	// the CPile pointer. The cast should fix it.
	// whm 18Mar2019 removed the (size_t) cast and changed the %x to %p which eliminate the assert. %p is the format specifier for a pointer address.
		wxLogDebug(_T("m_pActivePile = %p  , m_nActiveSequNum =  %d"), pApp->m_pActivePile, pApp->m_nActiveSequNum);
#endif
		needBackup = TRUE;
	}
	else
		needBackup = IsLatestVersionChanged();      // if not modified, but the latest version isn't the same as the latest committed, we need a backup.

// (Oct 13 -- we're now always doing the backup, no matter what, so "return to latest" will always have the expected result of returning to exactly where
//  we started.
//    if (needBackup)
	needBackup = needBackup; // whm added to prevent GCC warning about variable set but not used
	{
		wxString    backupPath = pApp->m_curOutputPath + _T("__bak");
		bool        bCopiedSuccessfully = ::wxCopyFile(pApp->m_curOutputPath, backupPath, TRUE);   // overwrite any previous copy
		wxASSERT(bCopiedSuccessfully);
		bCopiedSuccessfully = bCopiedSuccessfully; // prevent compiler warning in release build
		pApp->m_bBackedUpForTrial = TRUE;
		if (!fromLogDialog)  startHere--;       // if we've been called sraight from the menu, the "previous version" is actually the
												//  last committed, since subsequent changes have been made to the doc.  So we need to
												//  adjust where we start from.  But if we were called from the dialog, the actual version
												//  has been specified, so we mustn't change it.
	}

	if (!fromLogDialog)
	{
		returnCode = pApp->m_pDVCS->DoDVCS(DVCS_SETUP_VERSIONS, 0);		// (re-)reads the log, and hangs on to it
		if (returnCode < 0)
			return;                             // bail out on error

		pApp->m_versionCount = returnCode;      // success - now we have the current total number of log entries
	}

	if (startHere == 0 && !pApp->m_bBackedUpForTrial)  return;
	// presumably the latest version was chosen in the log dialog,
	// and we didn't backup a later one, so there's nothing more to do!

	gpApp->m_trialVersionNum = startHere;                       // and here's where we'll start from

	pApp->LogUserAction(_T("Bringing up the DVCSNavDlg"));

	pNavDlg = new (DVCSNavDlg) (gpApp->GetMainFrame());		// create the version navigation dialog
	pNavDlg->Move(100, 100);                                    // put it near the top left corner initially
	pNavDlg->ChooseVersion(startHere);                         // changes the doc version, and sets fields in the dialog
	DoChangeVersion(startHere);								// we seem to need this on Windows, and is harmless otherwise
	pNavDlg->Show();                                            // show it, non-modally.  By showing it after changing the
																// doc version, it appears on top so we avoid having to Raise()
																//  it which would look uglier.
	pNavDlg->AcceptsFocus();
	pNavDlg->InitDialog();
	pApp->m_pDVCSNavDlg = pNavDlg;
}

// The "look at previous version" menu item takes us to the last one saved, which is item 1 in the log.

void CAdapt_ItDoc::OnShowPreviousVersions(wxCommandEvent& WXUNUSED(event))
{
	if (!Git_installed())
		return;                     // Shows message if git not installed

	DoShowPreviousVersions(FALSE, 1);
}


void CAdapt_ItDoc::DoAcceptVersion(void)
{
	gpApp->LogUserAction(_T("Entering DoAcceptVersion()"));

	if (gpApp->m_trialVersionNum < 0)
	{
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("We're not looking at earlier revisions!"));
		gpApp->LogUserAction(_T("We're not looking at earlier revisions!"));
		return;
	}
	EndTrial(FALSE);           // the trial's over, but we don't restore from any backup.
}


bool  CallOpenDocument(wxString path)
{
	return gpApp->GetDocument()->OnOpenDocument(path, false);
}

#if defined(_DEBUG) && defined(DEBUG_ZWSP)
// copied from PunctCorrespPage.cpp for use here while debugging
wxString MakeUNNNN(wxString& chStr)
{
	wxString prefix = _T(""); // some people said U+ makes the strings too wide, so leave
							 // it off_T("U+");
	// whm 11Jun12 Note: I think chStr will always have at least a value of T('\0'), so
	// GetChar(0) won't ever be called on an empty string, but to be safe test for empty
	// string.
	wxChar theChar;
	if (!chStr.IsEmpty())
		theChar = chStr.GetChar(0);
	else
		theChar = _T('\0');
	wxChar str[6] = { _T('\0'),_T('\0'),_T('\0'),_T('\0'),_T('\0'),_T('\0') };
	wxChar* pStr = str;
	wxSnprintf(pStr, 6, _T("%x"), (int)theChar);
	wxString s = pStr;
	if (s == _T("0"))
	{
		s.Empty();
		return s;
	}
	int len = s.Length();
	if (len == 2)
		s = _T("00") + s;
	else if (len == 3)
		s = _T("0") + s;
	return prefix + s;
}
#endif


// RecoverLatestVersion() is called when an xml error comes up while reading a document.  If we can, we
// revert to the latest committed version.  We return TRUE on success, FALSE otherwise.

bool CAdapt_ItDoc::RecoverLatestVersion(void)
{
	int             returnCode;
	wxCommandEvent  dummyEvent;
	wxString        docPath, docName;
	CAdapt_ItApp* pApp = gpApp;

	pApp->LogUserAction(_T("Entering RecoverLatestVersion()"));

	pApp->m_recovery_pending = FALSE;                  // restore normal default, so opening the doc after recovery works properly

	if (!pApp->m_DVCS_installed)  return FALSE;        // can't do it if git not installed -- don't want a message

	if (pApp->m_commitCount <= 0)  return FALSE;       // can't do it if there are no saved versions

	returnCode = gpApp->m_pDVCS->DoDVCS(DVCS_SETUP_VERSIONS, 0);		// (re-)reads the log, and hangs on to it
	if (returnCode < 0)  return FALSE;                  // can't do it if an error came up here

// OK, so far so good...
	returnCode = gpApp->m_pDVCS->DoDVCS(DVCS_GET_VERSION, 0);		// get the latest revision (zero is the latest)

//  a negative returnCode would normally be a bug, but it can come up here if the corrupted
//  doc has a wrong name. So on any nonzero returnCode we return FALSE since we can't
//  recover the doc.

	if (returnCode)
	{
		wxString    temp;
		temp = temp.Format(_T("Returning FALSE from RecoverLatestVersion() - returnCode = %d"), returnCode);
		pApp->LogUserAction(temp);

		return FALSE;
	}

	/*  OK, the doc's recovered!  What we do now depends on what was happening when the doc was opened.  The normal situation
		is a simple doc opening, and in this case m_reopen_recovered_doc will be TRUE.  In this situation we'd like to
		call DocChangedExternally() and display the doc, but since the opening process has been partly started, and the doc's
		probably corrupt, this doesn't work.  What works is to completely close the doc (which we've already done)
		and re-open it by calling OnOpenDocument().  We also include some code from CDocPage::OnWizardFinish()
		that looks like  it might be doing something useful.

		There are currently two other places where we read a document.  We don't attempt to continue these ops from partway
		through, but just ask the user to re-attempt what they were doing.
	*/

	if (!pApp->m_reopen_recovered_doc)          // here the caller will display a message, so we don't do it here.
		return TRUE;

	pApp->m_reopen_recovered_doc = FALSE;       // restore normal default

												// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
	gpApp->m_bUserDlgOrMessageRequested = TRUE;
	wxMessageBox(_("This document was corrupt, but we have restored the latest version saved in the document history."));
	pApp->LogUserAction(_T("This document was corrupt, but we have restored the latest version saved in the document history."));

	CAdapt_ItView* pView = pApp->GetView();

	docName = pApp->m_curOutputFilename;
	docPath = pApp->m_curOutputPath;

	//bool bOK = OnOpenDocument (docPath, false);  -- for some reason this bounces back without doing anything.  But calling it
	//indirectly seems to work...

	if (!CallOpenDocument(docPath))  return FALSE;

	// put the focus in the phrase box, after any text
	if (pApp->m_pTargetBox->GetHandle() != NULL && !pApp->m_targetPhrase.IsEmpty()
		&& (pApp->m_pTargetBox->IsShown()))
	{
		int len = pApp->m_pTargetBox->GetTextCtrl()->GetLineLength(0); // line number zero
		// for our phrasebox
		pApp->m_nStartChar = len;
		pApp->m_nEndChar = len;
		pApp->m_pTargetBox->SetFocusAndSetSelectionAtLanding();// whm 13Aug2018 modified
	}
	else
	{
		if (pApp->m_pTargetBox->GetHandle() != NULL && (pApp->m_pTargetBox->IsShown()))
		{
			pApp->m_nStartChar = 0;
			pApp->m_nEndChar = 0;
			pApp->m_pTargetBox->SetFocusAndSetSelectionAtLanding();// whm 13Aug2018 modified
		}
	}

	CMainFrame* pFrame = (CMainFrame*)pView->GetFrame();
	pFrame->Raise();
	if (pApp->m_bZoomed)
		pFrame->SetWindowStyle(wxDEFAULT_FRAME_STYLE
			| wxFRAME_NO_WINDOW_MENU | wxMAXIMIZE);
	else
		pFrame->SetWindowStyle(wxDEFAULT_FRAME_STYLE
			| wxFRAME_NO_WINDOW_MENU);

	gbDoingInitialSetup = FALSE;

	// make sure the menu command is checked or unchecked as necessary
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem* pAdvBookMode = pMenuBar->FindItem(ID_ADVANCED_BOOKMODE);
	//wxASSERT(pAdvBookMode != NULL);
	if (pApp->m_bBookMode && !pApp->m_bDisableBookMode)
	{
		// mark it checked
		if (pAdvBookMode != NULL)
		{
			pAdvBookMode->Check(TRUE);
		}
	}
	else
	{
		// mark it unchecked
		if (pAdvBookMode != NULL)
		{
			pAdvBookMode->Check(FALSE);
		}
	}

	if (pApp->m_bReadOnlyAccess)
	{
		// try get an extra paint job done, so background will show all pink from the
		// outset.  Yes, we really DO need this here!!!
		pView->canvas->Refresh();
	}
	return TRUE;                            // success!
}

void CAdapt_ItDoc::OnShowFileLog(wxCommandEvent& WXUNUSED(event))
{
	int     returnCode;
	long    itemIndex = -1;

	gpApp->m_pDVCS->m_version_to_open = -1;     // ensure this is initialized to something

	if (!Git_installed())
		return;                    // Shows message if git not installed

// need to check if a trial is already under way, and if so, bail out

	returnCode = gpApp->m_pDVCS->DoDVCS(DVCS_SETUP_VERSIONS, 0);		// reads the log, and hangs on to it
	if (returnCode < 0)
	{                                           // an error probably means this is a new repository so there's nothing there yet.
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("There are no previous versions in the history!"));
		return;                                 // in this case we don't show the dialog
	}

	gpApp->m_versionCount = returnCode;         // this is the total number of log entries

	if (returnCode == 0)
	{                                           // there's a repository, but no versions saved yet
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("There are no previous versions in the history!"));
		return;                                 // in this case we don't show the dialog either
	}

	DVCSLogDlg  logDlg(gpApp->GetMainFrame());
	logDlg.InitDialog();
	returnCode = logDlg.ShowModal();

	// now, which button was hit?
	if (returnCode == wxID_OK)
	{                   // Show selected version
		wxCommandEvent      eventCustom(wxEVT_Show_version);

		itemIndex = logDlg.m_pList->GetNextItem(itemIndex, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED);
		if (itemIndex == -1) return;

		// We've found that if we just open the nav dialog from here, it doesn't appear as properly in focus on Windows.  So instead
		// we'll post a custom event to do it.

		gpApp->LogUserAction(_T("Posting custom event to open the DVCSNavDlg"));
		gpApp->m_pDVCS->m_version_to_open = (int)itemIndex;     // put the version we want in our DVCS object for the
																// event to pick up
		wxPostEvent(gpApp->GetMainFrame(), eventCustom);       // Custom event handlers are in CMainFrame
	}
}

void CAdapt_ItDoc::OnShowProjectLog(wxCommandEvent& WXUNUSED(event))
{
	if (!Git_installed())
		return;                    // Shows message if git not installed

// We might be going to deprecate this one...
//    gpApp->m_pDVCS->DoDVCS (DVCS_LOG_PROJECT, 0);
}

void CAdapt_ItDoc::OnDVCS_Version(wxCommandEvent& WXUNUSED(event))
{
	if (!gpApp->m_DVCS_installed)
	{
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_T("Git is apparently not yet installed on this computer."));
		return;
	}
	gpApp->m_pDVCS->DoDVCS(DVCS_CHECK, 1);     // nonzero parm means display the returned result in a wxMessageBox.
}

// Update handler for DVCS-related menu items -- these used to be disabled if git wasn't installed, but now they're
//  always enabled, and we give a message if git isn't installed.  We just disable the items if a trial is current,
//  and just have one handler for all the items.

void CAdapt_ItDoc::OnUpdateDVCS_item(wxUpdateUIEvent& event)
{
	if (gpApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	int	 trialRevNum = gpApp->m_trialVersionNum;

	event.Enable((trialRevNum < 0) && (gpApp->m_pKB != NULL) && (gpApp->IsDocumentOpen()));
}

void CAdapt_ItDoc::OnUpdateTakeOwnership(wxUpdateUIEvent& event)
{
	if (gpApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable((gpApp->m_owner != gpApp->m_strUserID) && (gpApp->m_trialVersionNum == -1) && (gpApp->m_pKB != NULL) && (gpApp->IsDocumentOpen()));
	// enable only if user isn't the owner, and a trial is not under way
}

void CAdapt_ItDoc::PutPhraseBoxAtDocEnd()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	int sequNumAtEnd = pApp->GetMaxIndex();
	pApp->m_pActivePile = GetPile(sequNumAtEnd); // this may return NULL
	if (pApp->m_pActivePile != NULL)
	{
		pApp->m_nActiveSequNum = sequNumAtEnd;
		wxString boxValue;
		if (gbIsGlossing)
		{
			boxValue = pApp->m_pActivePile->GetSrcPhrase()->m_gloss;
		}
		else
		{
			boxValue = pApp->m_pActivePile->GetSrcPhrase()->m_adaption;
			pApp->m_pTargetBox->m_Translation = boxValue;
		}
		pApp->m_targetPhrase = boxValue;
		pApp->m_pTargetBox->GetTextCtrl()->ChangeValue(boxValue);
		pApp->GetView()->PlacePhraseBox(pApp->m_pActivePile->GetCell(1), 2);
		pApp->GetView()->Invalidate();
	}
}

// a smarter wrapper for DoFileSave(), to replace where that is called in various places
// Is called from the following 8 functions: the App's DoAutoSaveDoc(), OnFileSave(),
// OnSaveModified() and OnFilePackDoc(), the Doc's OnEditConsistencyCheck() and
// DoConsistencyCheck(), and SplitDialog's SplitAtPhraseBoxLocation_Interactive() and
// DoSplitIntoChapters(). Created 29Apr10.
// whm added pProgDlg 24Aug11

bool CAdapt_ItDoc::DoFileSave_Protected(bool bShowWaitDlg, const wxString& progressItem)
{
	wxString pathToSaveFolder;
	wxULongLong originalSize = 0;
	wxULongLong copiedSize = 0;
	bool bRemovedSuccessfully = TRUE;
	ValidateFilenameAndPath(gpApp->m_curOutputFilename, gpApp->m_curOutputPath, pathToSaveFolder);
	bool bOutputFileExists = ::wxFileExists(gpApp->m_curOutputPath);
	wxString prefixStr = _T("tempSave_"); // don't localize this, it's never seen
	wxString newNameStr = prefixStr + gpApp->m_curOutputFilename;
	wxString newFileAbsPath = pathToSaveFolder + gpApp->PathSeparator + newNameStr;
	bool bCopiedSuccessfully = TRUE;
	if (bOutputFileExists)
	{
		// make a unique renamed copy which acts as a temporary backup in case of failure
		// in the call of DoFileSave()
		bCopiedSuccessfully = ::wxCopyFile(gpApp->m_curOutputPath, newFileAbsPath);
		wxASSERT(bCopiedSuccessfully);
		wxFileName fn(gpApp->m_curOutputPath);
		originalSize = fn.GetSize();
		if (bCopiedSuccessfully)
		{
			wxFileName fnNew(newFileAbsPath);
			copiedSize = fnNew.GetSize();
			wxASSERT(copiedSize == originalSize);
		}
	}
	// the call below to DoFileSave() requires that there be an active location - check,
	// and and if the box is at the doc end and not visible, then put it at the end of
	// the document before going on
	if (gpApp->m_pActivePile == NULL || gpApp->m_nActiveSequNum == -1)
	{
		if (gpApp->m_pActivePile != NULL)
		{
			// No use trying if the active pile is NULL - we may be processing a doc
			// which has no visible phrasebox, or the normal GUI isn't being used
			//gpApp->m_bSuppressPseudoDeleteWhenClosingDoc = TRUE;
			PutPhraseBoxAtDocEnd();
			//gpApp->m_bSuppressPseudoDeleteWhenClosingDoc = FALSE;
#if defined(_DEBUG) && !defined(NOLOGS)
			wxLogDebug(_T("DoFileSave_Protected() relocation codeblock: translation = %s , m_pTargetBox has: %s"),
				gpApp->m_pTargetBox->m_Translation.c_str(), gpApp->m_pTargetBox->GetTextCtrl()->GetValue().c_str());
#endif
		}
	}

	// SaveType enum value (2nd param) for the following call is default: normal_save BEW
	// added type, renamed filename, and bUserCancelled params 20Aug10, because they are
	// needed for when this DoFileSave() function is called in OnFileSaveAs(), however
	// other than the normal_save 2nd param, they are not needed when the call is here,
	// within DoFileSave_Protected() and so here we make no use here of the last two
	// returned values
	wxString renamedFilename; renamedFilename.Empty();
	bool bUserCancelled = FALSE;
	bool bSuccess = DoFileSave(bShowWaitDlg, normal_save, &renamedFilename, bUserCancelled, progressItem);
	if (bSuccess)
	{
		if (bOutputFileExists && bCopiedSuccessfully)
		{
			// remove the temporary backup, the original was saved successfully
			bRemovedSuccessfully = wxRemoveFile(newFileAbsPath);
			if (!bRemovedSuccessfully)
			{
				// tell developer or user, if the removal failed
				wxMessageBox(_T("Adapt_ItDoc.cpp, DoFileSave_Protected()'s call of wxRemoveFile() failed, at line 2904. Processing continues, but you should immediately shut down WITHOUT saving, manually remove the old file copy, and then relaunch the application"));
				gpApp->LogUserAction(_T("Adapt_ItDoc.cpp, DoFileSave_Protected()'s call of wxRemoveFile() failed, at line 2904. Processing continues, but you should immediately shut down WITHOUT saving, manually remove the old file copy, and then relaunch the application"));
				return TRUE;
			}
		}
		//#if defined(_DEBUG)
		//		CPile* myPilePtr = gpApp->m_pActivePile;
		//		CSourcePhrase* mySrcPhrasePtr = myPilePtr->GetSrcPhrase();
		//		wxLogDebug(_T("DoFileSave_Protected() before returns TRUE: sn = %d , src key = %s , m_adaption = %s , m_targetStr = %s , m_targetPhrase = %s"),
		//			mySrcPhrasePtr->m_nSequNumber, mySrcPhrasePtr->m_key.c_str(), mySrcPhrasePtr->m_adaption.c_str(),
		//			mySrcPhrasePtr->m_targetStr.c_str(), gpApp->m_targetPhrase.c_str());
		//#endif
		return TRUE;
	}
	else // handle failure
	{
		wxASSERT(!bUserCancelled); // DoFileSave_Protected shows no GUI,
								   // so bUserCancelled should be FALSE
		if (bOutputFileExists)
		{
			if (bCopiedSuccessfully)
			{
				// something failed, but we have a backup to fall back on. Determine if the
				// original remains untruncated, if so, retain it and remove the backup; if
				// not, remove the original and rename the backup to be the original
				bool bSomethingOfThatNameExists = ::wxFileExists(gpApp->m_curOutputPath);
				if (bSomethingOfThatNameExists)
				{
					wxULongLong thatSomethingsSize = 0;
					wxFileName fn(gpApp->m_curOutputPath);
					thatSomethingsSize = fn.GetSize();
					if (thatSomethingsSize == originalSize)
					{
						// we are in luck, the original is still good, so remove the backup
						bRemovedSuccessfully = wxRemoveFile(newFileAbsPath);
						wxASSERT(bRemovedSuccessfully);
					}
					else
					{
						// the size is different, therefore the original was truncated, so
						// restore the document file using the backup renamed
						bRemovedSuccessfully = wxRemoveFile(gpApp->m_curOutputPath);
						wxASSERT(bRemovedSuccessfully);
						bool bRenamedSuccessfully;
						bRenamedSuccessfully = ::wxRenameFile(newFileAbsPath, gpApp->m_curOutputPath);
						if (!bRenamedSuccessfully)
						{
							// tell developer or user, if the rename failed
							wxMessageBox(_T("Adapt_ItDoc.cpp, DoFileSave_Protected()'s call of ::wxRenameFile() failed, at line 2952. Processing continues, but you should immediately shut down WITHOUT saving, manually remove the truncated old file, and then relaunch the application"));
							return TRUE;
						}
					}
				}
				// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
				gpApp->m_bUserDlgOrMessageRequested = TRUE;
				wxMessageBox(_("Warning: document save failed for some reason.\n"), _T(""), wxICON_EXCLAMATION | wxOK);
				gpApp->LogUserAction(_T("Warning: document save failed for some reason."));
			}
			else // the original was not copied
			{
				// with no backup copy to fall back on, we have to do the best we can;
				// check if the original is still on disk: it may be, and untouched, or it
				// may be, but truncated; in the former case, if its size is unchanged, the
				// just retain it; but if the size is less, we must remove the truncated
				// fragment and tell the user to do an immediate File / Save
				bool bSomethingOfThatNameExists = ::wxFileExists(gpApp->m_curOutputPath);
				bool bOutOfLuck = FALSE;
				if (bSomethingOfThatNameExists)
				{
					wxULongLong thatSomethingsSize = 0;
					wxFileName fn(gpApp->m_curOutputPath);
					thatSomethingsSize = fn.GetSize();
					if (thatSomethingsSize < originalSize)
					{
						// we are out of luck, the original is truncated
						bOutOfLuck = TRUE;
						bRemovedSuccessfully = wxRemoveFile(gpApp->m_curOutputPath);
						if (!bRemovedSuccessfully)
						{
							// tell developer or user, if the removal failed
							wxMessageBox(_T("Adapt_ItDoc.cpp, DoFileSave_Protected()'s call of wxRemoveFile() failed, at line 2984. Processing continues, but you should immediately attempt a re-save of the document, shut down Adapt It, and then relaunch"));
							return TRUE;
						}
					}
				}
				if (bOutOfLuck || !bSomethingOfThatNameExists)
				{
					// warn user to do a file save now while the doc is still in memory
					wxString msg;
					msg = msg.Format(_("Something went wrong. The adaptation document's file on disk was lost or destroyed. If the document is still visible, please click the Save command on the File menu immediately."));
					// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
					gpApp->m_bUserDlgOrMessageRequested = TRUE;
					wxMessageBox(msg, _("Immediate Save Is Recommended"), wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(_T("Something went wrong. The adaptation document's file on disk was lost or destroyed. If the document is still visible, please click the Save command on the File menu immediately."));
				}
			}
		}
		else // there was no original already saved to disk when OnFileSaveAs() was invoked
		{
			// either there is no original on disk still, or, there may be a truncated
			// save, either way, we must remove anything there..
			bool bTruncatedFragmentExists = ::wxFileExists(gpApp->m_curOutputPath);
			if (bTruncatedFragmentExists)
			{
				bRemovedSuccessfully = wxRemoveFile(gpApp->m_curOutputPath);
				wxASSERT(bRemovedSuccessfully);
				// warn user to do a file save now while the doc is still in memory
				wxString msg;
				msg = msg.Format(_("Something went wrong. The adaptation document was not saved to disk. Please click the Save command on the File menu immediately, and if the error persists, try the Save As... command instead - if that does not work, you are out of luck and the open document will not be saved, so shut down and start again."));
				gpApp->LogUserAction(msg);
				// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
				gpApp->m_bUserDlgOrMessageRequested = TRUE;
				wxMessageBox(msg, _("Immediate Save Is Recommended"), wxICON_EXCLAMATION | wxOK);
			}
		}
	}
	return FALSE;
}

bool CAdapt_ItDoc::DoCollabFileSave(const wxString& progressItem, wxString msgDisplayed) // whm added 17Jan12
{
	// we want the phrase box's contents put into the document, so that the export of
	// the pre-user-editing-happens adaptation text will have the box contents in it -
	// so get it done here, but don't bother about the save to KB because the
	// DoFileSave_Protected(TRUE) call later below will get that job done
	bool bAttemptStoreToKB = FALSE;
	bool bNoStore = FALSE; // default, it's initialized to FALSE internally anyway
	bool bSuppressWarningOnStoreKBFailure = TRUE; // we don't want a warning (we won't try

	// If this document is "protected" just save the changes locally by calling the
	// DoFileSave_Protected() function, then return without executing the code below
	// that prepares and saves changes to the external editor
	bool bProtectedFromSavingChangesToExternalEditor = FALSE;
	bProtectedFromSavingChangesToExternalEditor = DocumentIsProtectedFromTransferringDataToEditor();
	if (bProtectedFromSavingChangesToExternalEditor)
	{
		UpdateDocWithPhraseBoxContents(bAttemptStoreToKB, bNoStore, bSuppressWarningOnStoreKBFailure);

		// Do a local normal protected save to AI's native storage
		DoFileSave_Protected(TRUE, progressItem); // // TRUE means - show wait/progress dialog
		return TRUE;
	}

	// mrh 5Jun14 -- we now put our check for the collaborative editor running right here at the start, and do absolutely
	//  nothing if it's unsafe.

	if (!CollaborationEditorAcceptsDataTransfers())
	{
		wxString msg;
		msg = msg.Format(_("Adapt It cannot transfer your work to %s while %s is running.\nClick on OK to close this dialog. Leave Adapt It running, switch to %s and shut it down. Then switch back to Adapt It and do the save operation again."),
			gpApp->m_collaborationEditor.c_str(), gpApp->m_collaborationEditor.c_str(), gpApp->m_collaborationEditor.c_str());

		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(msg, _("Collaboration editor is running"), wxOK);
		return false;    // Bail out on an unsafe collaboration situation
	}

	UpdateDocWithPhraseBoxContents(bAttemptStoreToKB, bNoStore, bSuppressWarningOnStoreKBFailure);

	wxString postEditText;
	wxString updatedText;
	updatedText = MakeUpdatedTextForExternalEditor(gpApp->m_pSourcePhrases,
		makeTargetText, postEditText);
	// comment out the #define when a wxLogDebug listing of the updated text is not wanted
//#define _HAVE_A_LOOK
#if defined (_HAVE_A_LOOK) && !defined(NOLOGS)
#ifdef _DEBUG
	// have a look at what we got
	wxLogDebug(_T("\n *** OnFileSave(): updatedText to transfer to PT or BE when collaborating ***\n"));
	// wxLogDebug refuses to show updatedText, so maybe text is too long, so try
	// cutting it up into 3 pieces first -- yes, that works, the text was about 35,000
	// characters, so wxLogDebug happily outputs 1but 12,000, maybe more, but perhaps
	// it is limited to a 32 Kb buffer.
	//wxLogDebug(_T("%s\n"), updatedText.c_str());
	int count = updatedText.Len();
	int abit = count / 3;
	wxString acopy = updatedText;
	wxString first = acopy.Left(abit);
	acopy = acopy.Mid(abit);
	wxString second = acopy.Left(abit);
	acopy = acopy.Mid(abit);
	wxLogDebug(_T("%s\n"), first.c_str());
	wxLogDebug(_T("%s\n"), second.c_str());
	wxLogDebug(_T("%s\n"), acopy.c_str());

#endif
#endif
	// For testing purposes, assume it's target text, and a single-chapter
	// document...actually, there's nothing in the MakeUpdatedTextForExternalEditor()
	// internals that predisposes towards a single chapter doc or a whole book doc - it
	// is deliberately written so as to be agnostic about which is the case, it just
	// knows there is a doc containing information to extract and send to PT or BE,
	// with possibly some automated conflict resolution to be done when doing so.

	bool bMovedTextOK = TRUE;
	long resultTgt = -1; // reset to 0 if all goes well
	long resultFreeTrans = -1; // ditto
	wxArrayString outputTgt, outputFreeTrans; // for feedback from ::wxExecute()
	wxArrayString errorsTgt, errorsFreeTrans; // for feedback from ::wxExecute()

	if (!updatedText.IsEmpty())
	{
		// Get the updatedText to a file of the required name (overwriting the older
		// one already there) in the .temp folder; then make the command line for
		// target text and transfer the text to the external editor -- the following
		// calls internally make all the decisions necessary, such as whether a whole
		// book or just a chapter is to be sent, its filename, whether to Bibledit or
		// Paratext, and so forth, using member variables stored in the application
		// class  (don't add a BOM)
		if (gpApp->m_bCollaboratingWithParatext)
		{
			msgDisplayed = _("Please wait while the translation is sent to Paratext...");
		}
		else if (gpApp->m_bCollaboratingWithBibledit)
		{
			msgDisplayed = _("Please wait while the translation is sent to Bibledit...");
		}

		// whm 21Sep11 modified. For chapter sized transfers back to the external editor
		// we need to remove the \id XXX line from the updatedText string.
		// BEW 8Oct11, it needs to be earlier and also done on a free trans text too, so now
		// it's in MakeUpdatedTextForExternalEditor(), with the call RemoveIDMarkerAndCode()
		//if (gpApp->m_bCollabByChapterOnly && updatedText.Find(_T("\\id")) != wxNOT_FOUND)
		//{
			// the \id XXX line should be of the form:
		//	wxString idLine = _T("\\id XXX") + gpApp->m_eolStr;
		//	int idLineLen = idLine.Length();
		//	updatedText = updatedText.Mid(idLineLen); // retains the rest of the string after the idLineLen
		//}
		bMovedTextOK = MoveTextToTempFolderAndSave(collab_target_text, updatedText);
		// we don't expect an error, but tell the developer or user if there was one
		// and keep on processing
		if (!bMovedTextOK)
		{
			wxMessageBox(_T("Adapt_ItDoc.cpp, OnFileSave()'s call of MoveTextToTempFolderAndSave() failed, at line 3138. Processing continues, but you should immediately shut down WITHOUT saving, and then relaunch the application"));
			return FALSE;
		}
		resultTgt = -1;  outputTgt.Clear(); errorsTgt.Clear();
		TransferTextBetweenAdaptItAndExternalEditor(writing, collab_target_text,
			outputTgt, errorsTgt, resultTgt);

		// error handling
		wxString msg;
		// BEW 27Feb15 added more details about a possible fix for the likely cause of the problem
		if (resultTgt != 0)
		{
			wxASSERT(!gpApp->m_collaborationEditor.IsEmpty());
			// Not likely to happen, but it is possible if there are no books created for the PT/BE
			// project, or the files are locked/access denied.
			//msg = msg.Format(msg,gpApp->m_collaborationEditor.c_str(),gpApp->m_collaborationEditor.c_str());
			wxString temp1;
			temp1 = temp1.Format(_T("PT/BE Collaboration wxExecute returned error when writing target text. resultTgt = %d (Paratext permissions problem? rdwrtp7 returned: )"), resultTgt);
			gpApp->LogUserAction(temp1);
//			wxLogDebug(temp1);
			int ct;
			wxString temp;
			temp.Empty();
			for (ct = 0; ct < (int)outputTgt.GetCount(); ct++)
			{
				temp += outputTgt.Item(ct);
				gpApp->LogUserAction(temp);
//				wxLogDebug(temp);
			}
			temp1 += temp;
			temp.Empty();
			for (ct = 0; ct < (int)errorsTgt.GetCount(); ct++)
			{
				temp += errorsTgt.Item(ct);
				gpApp->LogUserAction(temp);
//				wxLogDebug(temp);
			}
			temp1 += temp;
			msg = temp1;
			wxMessageBox(msg, _T(""), wxICON_EXCLAMATION | wxOK);
			wxString msg2;
			wxString title = _("Elevate Permission Level?");
			msg2 = msg2.Format(_("Probably the owner of the text being transferred lacks Translator or Administrator permission level for the target text project within Paratext, or Bibledit.\nA permissison level that allows editing is necessary for a successful transfer of text when collaborating."));
			wxMessageBox(msg2, title, wxICON_INFORMATION | wxOK);
			return FALSE;
		} // end of TRUE block for test: if (resultTgt != 0)

		// The returned postEditText (as exported from the AI document at the time the
		// File / Save was invoked) now has to replace the saved preEditText in the
		// private app member for that purpose, becoming the new preEditTargetText
//#if defined(_DEBUG)
//		wxLogDebug(_T("\n\nStoreTargetText_PreEdit(postEditText) in Doc.cpp 2512: %s"), postEditText.c_str());
//#endif
		gpApp->StoreTargetText_PreEdit(postEditText);

		if (gpApp->m_bCollaborationExpectsFreeTrans)
		{
			// make a second call of MakeUpdatedTextForExternalEditor(), this time with
			// param2 set to makeFreeTransText, param1 and param3 are the same, and
			// when it returns, postEditFreeTransText is the free translation which has
			// to be saved in the app member for that purpose, becoming the new
			// preEditFreeTransText -- use StoreFreeTransText_PreEdit() to do that
			wxString postEditFreeTransText;
			wxString updatedFreeTransText = MakeUpdatedTextForExternalEditor(gpApp->m_pSourcePhrases,
				makeFreeTransText, postEditFreeTransText);
#if defined (_HAVE_A_LOOK)  && !defined(NOLOGS)
#ifdef _DEBUG
			// have a look at what we got
			wxLogDebug(_T("\n *** OnFileSave(): updatedFreeTransText to transfer to PT or BE when collaborating ***\n"));
			//wxLogDebug(_T("%s\n"), updatedFreeTransText.c_str());
			// wxLogDebug refuses to show updatedText, so maybe text is too long, so try
			// cutting it up into 3 pieces first -- yes, that works, the text was about 35,000
			// characters, so wxLogDebug happily outputs about 12,000, maybe more, but perhaps
			// it is limited to a 32 Kb buffer.
			int count = updatedFreeTransText.Len();
			int abit = count / 3;
			wxString acopy = updatedFreeTransText;
			wxString first = acopy.Left(abit);
			acopy = acopy.Mid(abit);
			wxString second = acopy.Left(abit);
			acopy = acopy.Mid(abit);
			wxLogDebug(_T("%s\n"), first.c_str());
			wxLogDebug(_T("%s\n"), second.c_str());
			wxLogDebug(_T("%s\n"), acopy.c_str());
#endif
#endif
			if (!updatedFreeTransText.IsEmpty())
			{
				// Get the updatedFreeTransText to a file of the required name
				// (overwriting the older one already there) in the .temp folder; then
				// make the command line for free translation text and transfer the
				// text to the external editor -- the following calls internally make
				// all the decisions necessary, such as whether a whole book or just a
				// chapter is to be sent, its filename, whether to Bibledit or
				// Paratext, and so forth, using member variables stored in the
				// application class (don't add a BOM)
				if (gpApp->m_bCollaboratingWithParatext)
				{
					msgDisplayed = _("Please wait while the free translation is sent to Paratext...");
				}
				else if (gpApp->m_bCollaboratingWithBibledit)
				{
					msgDisplayed = _("Please wait while the free translation is sent to Bibledit...");
				}

				bMovedTextOK = MoveTextToTempFolderAndSave(collab_freeTrans_text, updatedFreeTransText);
				resultFreeTrans = -1;  outputFreeTrans.Clear(); errorsFreeTrans.Clear();
				TransferTextBetweenAdaptItAndExternalEditor(writing, collab_freeTrans_text,
					outputFreeTrans, errorsFreeTrans, resultFreeTrans);
				// error handling
				if (resultFreeTrans != 0)
				{
					wxASSERT(!gpApp->m_collaborationEditor.IsEmpty());
					// Not likely to happen, but it is possible if there are no books created for the PT/BE
					// project, or the files are locked/access denied.
					//msg = msg.Format(msg,gpApp->m_collaborationEditor.c_str(),gpApp->m_collaborationEditor.c_str());
					wxString temp1;
					temp1 = temp1.Format(_T("PT/BE Collaboration wxExecute returned error when writing free translation text. resultFreeTrans = %d (PT permissions problem?) rdwrtp7 returned: "), resultFreeTrans);
					gpApp->LogUserAction(temp1);
//					wxLogDebug(temp1);
					int ct;
					wxString temp;
					temp.Empty();
					for (ct = 0; ct < (int)outputFreeTrans.GetCount(); ct++)
					{
						temp += outputFreeTrans.Item(ct);
						gpApp->LogUserAction(temp);
//						wxLogDebug(temp);
					}
					temp1 += temp;
					temp.Empty();
					for (ct = 0; ct < (int)errorsFreeTrans.GetCount(); ct++)
					{
						temp += errorsFreeTrans.Item(ct);
						gpApp->LogUserAction(temp);
//						wxLogDebug(temp);
					}
					temp1 += temp;
					msg = temp1;
					wxMessageBox(msg, _T(""), wxICON_EXCLAMATION | wxOK);
					wxString msg2;
					wxString title = _("Elevate Permission Level?");
					msg2 = msg2.Format(_("Probably the owner of the text being transferred lacks Translator or Administrator permission level for the target text project within Paratext, or Bibledit.\nA permissison level that allows editing is necessary for a successful transfer of text when collaborating."));
					wxMessageBox(msg2, title, wxICON_INFORMATION | wxOK);
					return FALSE;
				} // end of TRUE block for test: if (resultFreeTrans != 0)

				// the returned postEditFreeTransText (as exported from the AI document
				// at the time the File / Save was invoked) now has to replace the
				// saved preEditFreeTransText in the private app member for that
				// purpose, becoming the new preEditFreeTransText
				gpApp->StoreFreeTransText_PreEdit(postEditFreeTransText);
			}
		}

		// and then also do a local normal protected save to AI's native storage;
		DoFileSave_Protected(TRUE, progressItem); // // TRUE means - show wait/progress dialog
	}
	else
	{
		// returned an empty string, this indicates some kind error or unsafe situation
		// - which should have been seen already -- this is unlikely to ever happen so
		// just beep but still do the protected local save - the word done should never
		// be lost
		wxBell();
		DoFileSave_Protected(TRUE, progressItem); // // TRUE means - show wait/progress dialog
		// whm added 11Mar12. This situation occurrs if the user attempted to save while
		// Paratext is running, and instead of closing down Paratext, clicks the Cancel
		// button of the message prompt. The local AI doc gets saved by the DoFileSave_Protected()
		// call above, but the doc is then marked "clean" rather than "dirty" which with
		// respect to the Paratext data is not true. Immediately after getting here the
		// AI doc is not dirty and so the Save button and File | Save are disabled. To give
		// the user the opportunity of doing another save without having to do something
		// to make the doc dirty again, we'll set the doc as modified here
		this->Modify(TRUE);
		return FALSE;
	}
	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/// \return TRUE if file was successfully saved; FALSE otherwise ( the return value
///         may not be used by some functions which call this one, such as OnFileSave()
///         or OnFileSaveAs() )
/// \param	bShowWaitDlg	 -> if TRUE the wait/progress dialog is shown, otherwise it
///                             is not shown
/// \param  type             -> an enum value, either normal_save or, save_as, depending
///                             whether the user chose Save or Save As... command, respectively
/// \param  pRenamedFilename -> pointer to a string which is the new filename (it may
///                             have an attached extension which our code will remove
///                             and replace with .xml), if the user requested a rename,
///                             but will be (default) NULL if no renamed filename was
///                             supplied, or if the user chose Save command.
/// \param  bUserCancelled   <- ref to boolean, to tell caller when the return was due to
///                             user clicking the Cancel button in the OnFileSaveAs()
///                             function, however most calls (8 of the 9) are made from
///                             DoFileSave_Protected() and the latter makes no use of the
///                             values returned in the 3rd and 4th params.
/// \param pProgDlg         <-> pointer to an wxProgress dialog started up in OnFileSave()
/// \remarks
/// Called from: the Doc's OnFileSaveAs(); also called within DoFileSave_Protected() where
/// the latter is called from the following 8 functions: the App's DoAutoSaveDoc(),
/// OnFileSave(), OnSaveModified() and OnFilePackDoc(), the Doc's OnEditConsistencyCheck()
/// and DoConsistencyCheck(), and SplitDialog's SplitAtPhraseBoxLocation_Interactive() and
/// DoSplitIntoChapters().
/// Saves the current document and KB files in XML format and takes care of the necessary
/// housekeeping involved.
/// Ammended for handling saving when glossing or adapting.
/// BEW modified 13Nov09, if the local user has only read-only access to a remote
/// project folder, the local user must not be able to cause his local copy of the
/// remote document to be saved to the remote user's disk; if that could happen, the
/// remote user would almost certainly lose some of his edits
/// BEW 16Apr10, added SaveType param, for support of Save As... menu item
/// BEW 20Aug10, changed 2nd and 3rd params to have no default, and added the bool
/// reference 4th param (needed for OnFileSaveAs())
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::DoFileSave(bool bShowWaitDlg, enum SaveType type,
	wxString* pRenamedFilename, bool& bUserCancelled,
	const wxString& progressItem)
{
	bUserCancelled = FALSE;

#if defined(_DEBUG) && !defined(NOLOGS)
	CPile* myPilePtr = gpApp->m_pActivePile;
	if (myPilePtr != NULL)
	{
		CSourcePhrase* mySrcPhrasePtr = myPilePtr->GetSrcPhrase();
		wxLogDebug(_T("DoFileSave() start: sn = %d , src key = %s , m_adaption = %s , m_targetStr = %s , m_targetPhrase = %s"),
			mySrcPhrasePtr->m_nSequNumber, mySrcPhrasePtr->m_key.c_str(), mySrcPhrasePtr->m_adaption.c_str(),
			mySrcPhrasePtr->m_targetStr.c_str(), gpApp->m_targetPhrase.c_str());
	}
#endif

	// BEW added 19Apr10 -- ensure we start with the latest doc version for saving if the
	// save is a normal_save, but if a Save As... was asked for, the user may be about to
	// choose a legacy doc version number for the save, in which case the call of the
	// wxFileDialog below may result in a different value being set by the code further
	// below
	RestoreCurrentDocVersion();  // assume the default
	m_bLegacyDocVersionForSaveAs = FALSE; // initialize private member
	m_bDocRenameRequestedForSaveAs = FALSE; // initialize private member
	bool bDummySrcPhraseAdded = FALSE;
	SPList::Node* posLast = NULL;

	// refactored 9Mar09
	wxFile f; // create a CFile instance with default constructor
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	if (pApp->m_bReadOnlyAccess)
	{
		return TRUE; // let the caller think all is well, even though the save is suppressed
	}

	CAdapt_ItView* pView = (CAdapt_ItView*)GetFirstView();

	pApp->LogUserAction(_T("Initiated File Save by calling DoFileSave()"));

	// make the working directory the "Adaptations" one; or the current Bible book folder
	// if the m_bBookMode flag is TRUE

	// There are at least three ways within wxWidgets to change the current
	// working directory:
	// (1) Use ChangePathTo() method of the wxFileSystem class,
	// (2) Use the static SetCwd() method of the wxFileName class,
	// (3) Use the global namespace method ::wxSetWorkingDirectory()
	// We'll regularly use ::wxSetWorkingDirectory()
	bool bOK;
	wxString pathToSaveFolder; // use this with Save As... to prevent a change of working directory

	// whm 8Apr2021 added wxLogNull block below
	{
		wxLogNull logNo;	// eliminates any spurious messages from the system if the wxSetWorkingDirectory() call returns FALSE

		if (pApp->m_bBookMode && !pApp->m_bDisableBookMode)
		{
			// save to the folder specified by app's member  m_bibleBooksFolderPath
			bOK = ::wxSetWorkingDirectory(pApp->m_bibleBooksFolderPath);
			pathToSaveFolder = pApp->m_bibleBooksFolderPath;
		}
		else
		{
			// do legacy save, to the Adaptations folder
			bOK = ::wxSetWorkingDirectory(pApp->m_curAdaptationsPath);
			pathToSaveFolder = pApp->m_curAdaptationsPath;
		}
	} // end of wxLogNull scope
	if (!bOK)
	{
		// BEW changed 23Apr10, I've never know the working directory set call to fail if a
		// valid path is supplied, so this would be an extraordinary situation - to proceed
		// may or may not result in a valid save, but we risk a crash, so we should play
		// save and abort the save attempt. But the message should not be localizable as it
		// is almost certain that it will never be seen.
		wxMessageBox(_T(
			"Failed to set the current working directory. The save operation was not attempted."),
			_T(""), wxICON_EXCLAMATION | wxOK);
		m_bLegacyDocVersionForSaveAs = FALSE; // restore default
		m_bDocRenameRequestedForSaveAs = FALSE; // ditto
		pApp->LogUserAction(_T("Failed to set the current working directory. The save operation was not attempted."));
		return FALSE;
	}


	// if the phrase box is visible and has the focus, then its contents will have been
	// removed from the KB, so we must restore them to the KB, then after the save is done,
	// remove them again; but only provided the pApp->m_targetBox's window exists
	// (otherwise GetStyle call will assert)
	bool bNoStore = FALSE;
	bOK = FALSE;

	// BEW 9Aug11, in the call below, param1 TRUE is bAttemptStoreToKB, param2 bNoStore
	// returns TRUE to the caller if the attempted store fails for some reason, for all
	// other circumstances it returns FALSE, and param3 bSuppressWarningOnStoreKBFailure
	// has its default value of FALSE; this call replaces the commented out stuff
	// immediately following the call. The function is defined in helpers.cpp because we
	// need it elsewhere besides here
	UpdateDocWithPhraseBoxContents(TRUE, bNoStore);

	// get the path correct, including correct filename extension (.xml) and the backup
	// doc filenames too; the m_curOutputPath returns is the full path, that is, it ends
	// with the contents of the returned m_curOutputFilename value built in; the third
	// param may be useful in some contexts (see OnFileSave() and OnFileSaveAs()), but not
	// here
	wxString unwantedPathToSaveFolder;
	ValidateFilenameAndPath(gpApp->m_curOutputFilename, gpApp->m_curOutputPath,
		unwantedPathToSaveFolder); // we don't use 3rd param here
	if (!f.Open(gpApp->m_curOutputFilename, wxFile::write))
	{
		gpApp->LogUserAction(_T("Failed f.Open() for writing in DoFileSave()"));
		return FALSE; // if we get here, we'll miss unstoring from the KB, but its not likely
					  // to happen, so we'll not worry about it - it wouldn't matter much anyway
	}

	CSourcePhrase* pSrcPhrase;
	CBString aStr;
	CBString openBraceSlash = "</"; // to avoid "warning: deprecated conversion from string constant to 'char*'"

	// prologue (Changed BEW 02July07 at Bob Eaton's request)
	gpApp->GetEncodingStringForXmlFiles(aStr);
	DoWrite(f, aStr);

	// add the comment with the warning about not opening the XML file in MS WORD
	// 'coz is corrupts it - presumably because there is no XSLT file defined for it
	// as well. When the file is then (if saved in WORD) loaded back into Adapt It,
	// the latter goes into an infinite loop when the file is being parsed in.
	aStr = MakeMSWORDWarning(); // the warning ends with \r\n so we don't need to add them here

	// doc opening tag
	aStr += "<";
	aStr += xml_adaptitdoc;
	aStr += ">\r\n"; // eol chars OK for cross-platform???
	DoWrite(f, aStr);

	// in case file rename is wanted... from the Save As dialog
	wxString theNewFilename = _T("");
	bool bFileIsRenamed = FALSE;

	// if Save As... was chosen, its dialog should be shown here because the xml from this
	// point on needs to know which docVersion number to use
	if (type == save_as)
	{
		// get a file dialog (note: the user may ask for a save done with a legacy doc
		// version number in this dialog)
		wxString defaultDir = pathToSaveFolder; // set above
		wxString filter;
		filter = _("New XML format, for 6.0.0 and later (default)|*.xml|Legacy XML format, as in versions 3, 4 or 5. |*.xml||");
		wxString filename = gpApp->m_curOutputFilename;

	retry:	bFileIsRenamed = FALSE;
		wxFileDialog fileDlg(
			(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
			_("Save As"),
			defaultDir,	// an empty string would cause it to use the current working directory
			filename,	// the current document's filename
			filter, // the SaveType option - currently there are two, default is doc version 5, the other is doc version 4
			wxFD_SAVE); // don't want wxFD_OVERWRITE_PROMPT as part of the style param
						 // because if user changes filename, we'll save with the new
						 // name and after verifying the file is on disk and okay, we'll
						 // silently remove the old version, so that there is only one
						 // file with the document's data after a save of any kind
		fileDlg.Centre();

		// make the dialog visible
		if (fileDlg.ShowModal() != wxID_OK)
		{
			// user cancelled, while this is not strictly a failure we return FALSE
			// because the original will have been truncated, and so the caller must
			// restore it
			RestoreCurrentDocVersion(); // ensure a subsequent save uses latest doc version number
			m_bLegacyDocVersionForSaveAs = FALSE; // restore default
			m_bDocRenameRequestedForSaveAs = FALSE; // ditto
			f.Close();
			bUserCancelled = TRUE; // inform the caller that the user hit the Cancel button
			gpApp->LogUserAction(_T("Cancelled from Save As at wxFileDialog()"));
			return FALSE;
		}

		// check that the user did not change the folder's path, the user must not be able
		// to do this in Adapt It, the location for saving documents is fixed and the
		// pathToSaveFolder has been set to whatever it is for this session
		wxFileName fn(fileDlg.GetPath());
		wxString usersChosenFolderPath = fn.GetPath();
		if (pathToSaveFolder != usersChosenFolderPath)
		{
			// warn user to try again
			wxString msg;
			msg = msg.Format(_("You must not use the Save As... dialog to change where Adapt It stores its document files. You can only rename the file, or make a different 'Save as type' choice, or both."));
			// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
			gpApp->m_bUserDlgOrMessageRequested = TRUE;
			wxMessageBox(msg, _("Folder Change Is Not Allowed"), wxICON_EXCLAMATION | wxOK);
			gpApp->LogUserAction(_T("Folder Change Is Not Allowed"));
			goto retry;
		}

		// Determine if a file rename is wanted and ensure there is no name clash; for a
		// clash, reenter the dialog and start afresh after warning the user, if no clash,
		// set a boolean because we will do the rename **AFTER** document backup (which may
		// or may not be wanted), at the end of the calling function (renames are only
		// possible from a call of the OnFileSaveAs() function. (And document backup will
		// also do the needed backup file renaming at the end of the BackupDocument()
		// function -- fortunately, BackupDocument() uses an independent
		// m_curOutputBackupFilename (an app member currently, but that may change soon so
		// as to be on the doc class) and so the backup document file and its path updating
		// can be done completely within BackupDocument() without affecting the delay of
		// renaming the document until control returns to OnFileSaveAs(); and we'll leave
		// OnFileSaveAs to do the needed path updates for the renamed doc file.)
		theNewFilename = fileDlg.GetFilename();
		if (theNewFilename != filename)
		{
			// whm added 27Jun11 check for attempt to rename a _Collab... file using the
			// File | Save As function. Adapt It documents created under Collaboration with
			// PT or BE should not be renamed, otherwise it may break the internal linkage
			// of the PT/BE projects and their book files to a given set of AI docs.
			if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
			{
				wxString msg;
				msg = _("Adapt It documents cannot be renamed when collaborating with Paratext or Bibledit.");
				// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
				gpApp->m_bUserDlgOrMessageRequested = TRUE;
				wxMessageBox(msg, _("Cannot Change The Document's Filename"), wxICON_EXCLAMATION | wxOK);
				theNewFilename.Empty();
				gpApp->LogUserAction(_T("Cannot Change The Document's Filename"));
				goto retry;
			}

			// check for illegal characters in the user's typed new filename (this code
			// taken from OutputFilenameDlg::OnOK() and tweaked a bit)
			wxString fn = theNewFilename;
			wxString illegals = wxFileName::GetForbiddenChars(); //_T(":?*\"\\/|<>");
			wxString scanned = SpanExcluding(fn, illegals);
			if (scanned != fn)
			{
				// there is at least one illegal character,; beep and show the illegals to the
				// user and then re-enter the dialog to start over from scratch; illegals
				// are characters such as:  :?*\"\|/<>
				::wxBell();
				wxString message;
				message = message.Format(
					_("Filenames cannot include these characters: %s Please type a valid filename using none of those characters."), illegals.c_str());
				// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
				gpApp->m_bUserDlgOrMessageRequested = TRUE;
				wxMessageBox(message, _("Bad Characters In Filename"), wxICON_INFORMATION | wxOK);
				theNewFilename.Empty();
				gpApp->LogUserAction(_T("Bad Characters In Filename"));
				goto retry;
			}

			// check for a name conflict
			if (FilenameClash(theNewFilename))
			{
				wxString msg;
				msg = msg.Format(_("The new filename you have typed conflicts with an existing filename. You cannot use that name, please type another."));
				// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
				gpApp->m_bUserDlgOrMessageRequested = TRUE;
				wxMessageBox(msg, _("Conflicting Filename"), wxICON_EXCLAMATION | wxOK);
				theNewFilename.Empty();
				gpApp->LogUserAction(_T("Conflicting Filename"));
				goto retry;
			}
			else
			{
				bFileIsRenamed = TRUE; // theNewFilename has the renamed filename string
			}
		}
		if (bFileIsRenamed)
		{
			m_bDocRenameRequestedForSaveAs = TRUE; // set the private member, as the caller
												   // will need this flag for updating
												   // the window Title, and caller will
												   // restore its default FALSE value
			if (theNewFilename.IsEmpty())
			{
				// can't use an empty string as a filename, so stick with the current one,
				// return to the caller an empty string so that no rename is done
				pRenamedFilename->Empty();
			}
			else
			{
				// we've a string to return to caller for it to set up the new filename;
				// but first make sure we have an .xml extension on the new filename
				wxString thisFilename = theNewFilename;
				thisFilename = MakeReverse(thisFilename);
				wxString extn = thisFilename.Left(4);
				extn = MakeReverse(extn);
				// BEW 29Oct22 protect call
				int extnLen = extn.Len();
				bool bIsDot = TRUE; // initialise
				if (extnLen > 0)
				{
					bIsDot = (extn.GetChar(0) == _T('.'));
					if (bIsDot)
					{
						// we can assume it is an extension because it begins with a period
						if (extn != _T(".xml"))
						{
							thisFilename = thisFilename.Mid(4); // remove the .adt extension or whatever
							thisFilename = MakeReverse(thisFilename);
							thisFilename += _T(".xml"); // it's now *.xml
						}
						else
						{
							thisFilename = MakeReverse(thisFilename); // it's already *.xml
						}
						*pRenamedFilename = thisFilename;
					}
					else // extn doesn't begin with a period
					{
						// assume the user didn't add and extension and that what we cut off
						// was part of his file title, so add .xml to what he typed
						theNewFilename += _T(".xml");
						*pRenamedFilename = theNewFilename;
					}
				} // end of TRUE block for test: if (extnLen > 0)
			}
		}
		else
		{
			pRenamedFilename->Empty();  // tells caller no rename is wanted
		}
		// delay any requested doc file rename to the end of the calling function...

		// get the docVersion number the user wants used for the save, an index value of 0
		// always uses the VERSION_NUMBER as currently set, as does leaving any any
		// parameter (since 0 is the default if left out), but index values 1 or higher
		// select a legacy docVersion number (which gives different XML structure)
		// (currently the only other index value supported is 1, which maps to doc version
		// 4) Don't permit the possibility of a File Type change until the tests above
		// leading to reentrancy have been passed successfully
		int filterIndex = fileDlg.GetFilterIndex();
		SetDocVersion(filterIndex);

		// Execution control now takes one of two paths: if the user chose filterIndex ==
		// 0 item, which is VERSION_NUMBER's docVersion (currently == 6), then the code
		// for a norm Save is to be executed (except that in the Save As.. dialog he may
		// have also requested a document rename, in which case a block at the end of this
		// function will do that as well, as well as for when he makes the docVersion 4
		// choice). But if he chose filterIndex == 1 item, this is for docVersion set to
		// DOCVERSION4 (always == 4), in which case extra work has to be done - deep
		// copies of CSourcePhrase need to be created, and passed to a conversion function
		// FromDocVersion5ToDocVersion4() and the XML built from the converted deep copy
		// (to prevent corrupting the internal data structures which are docVersion5
		// compliant)
		// BEW 13Feb12, the old test won't work right now that 6 rather than 5 is the
		// current value of VERSION_NUMBER, so comment out the legacy way to set the
		// boolean, and do a better way -- that will work right if we later version the
		// document to 7 or 8, etc
		//m_bLegacyDocVersionForSaveAs = m_docVersionCurrent != (int)VERSION_NUMBER;
		if (filterIndex > 0)
		{
			// docVersion4 is wanted
			m_bLegacyDocVersionForSaveAs = TRUE;
		}
		else
		{
			// docVersion = the current VERSION_NUMBER value is wanted; currently it's 8
			m_bLegacyDocVersionForSaveAs = FALSE;
		}

		if (m_bLegacyDocVersionForSaveAs)
		{
			// Saving in doc version 4 may require the addition of a doc-final dummy
			// CSourcePhrase instance to carry moved endmarkers. We'll add such temporarily,
			// but only when needed, and remove it when done. It's needed if the very last
			// CSourcePhrase instance has a non-empty m_endMarkers member.
			posLast = gpApp->m_pSourcePhrases->GetLast();
			CSourcePhrase* pLastSrcPhrase = posLast->GetData();
			wxASSERT(pLastSrcPhrase != NULL);
			if (!pLastSrcPhrase->GetEndMarkers().IsEmpty())
			{
				// we need a dummy one at the end
				bDummySrcPhraseAdded = TRUE;
				int aCount = gpApp->m_pSourcePhrases->GetCount();
				CSourcePhrase* pDummyForLast = new CSourcePhrase;
				gpApp->m_pSourcePhrases->Append(pDummyForLast);
				pDummyForLast->m_nSequNumber = aCount;
			}
		}
	} // end of TRUE block for test: if (type == save_as)

	// place the <Settings> element at the start of the doc (this has to know what the
	// user chose for the SaveType, so this call has to be made after the
	// SetDocVersion() call above - as that call sets the doc's save state which
	// remains in force until changed, or restored by a RestoreCurrentDocVersion() call
	//
	// BEW 27Feb12, internally checks the value of m_bLegacyDocVersionForSaveAs flag, and
	// if TRUE, then it doesn't construct the docV6 attribute (first used in release
	// 6.2.0) for the m_bDefineFreeTransByPunctuation flag (see Adapt_It.h) as part of the
	// <Settings? tag
	aStr = ConstructSettingsInfoAsXML(1); // internally sets the docVersion attribute
							// to whatever is the current value of m_docVersionCurrent
	DoWrite(f, aStr);

	// prepare for progress dialog
	int counter;
	counter = 0;
	int nTotal = gpApp->m_pSourcePhrases->GetCount();
	wxString progMsg = _("Saving File %s  - %d of %d Total words and phrases");
	wxFileName fn(gpApp->m_curOutputFilename);
	wxString msgDisplayed = progMsg.Format(progMsg, fn.GetFullName().c_str(), 0, nTotal);
	CStatusBar* pStatusBar = NULL;
	pStatusBar = (CStatusBar*)gpApp->GetMainFrame()->m_pStatusBar;
	// whm 28Aug11 Note: pProgDlg can be NULL when DoFileSave_Protected() and
	// DoFileSave() are called from DoAutoSaveDoc() which does not set up a
	// wxProgressDialog(). Therefore we must test for NULL here.
	if (!progressItem.IsEmpty() && bShowWaitDlg) // whm 10Aug12 added && bShowWaitDlg test
	{
		pStatusBar->UpdateProgress(progressItem, 1, msgDisplayed);
	}
	// whm 24Aug11 moved the progress dialog to the top level OnFileSave() function. This
	// function (DoFileSave) receives a wxProgressDialog* pProgDlg pointer passed along
	// from OnFileSave(). When passed from DoAutoSaveDoc() pProgDlg is NULL.

	// process through the list of CSourcePhrase instances, building an xml element from
	// each
	SPList::Node* pos_pSP = gpApp->m_pSourcePhrases->GetFirst();

	// Branch and loop according to which doc version number is wanted. For a File / Save
	// it is VERSION_NUMBER's docVersion, also that is true for a Save As... in which the
	// top item (the default) was chosen as the filterIndex value of 0; but for a
	// filterIndex value of 1, the choice was for a legacy save (only DOCVERSION4 is
	// supported so far), and in this latter case, and only in this latter case, does
	// m_bLegacyDocVersionForSaveAs have a value of TRUE
	if (m_bLegacyDocVersionForSaveAs)
	{
		// user chose a legacy xml doc build, and so far there is only one such
		// choice, which is docVersion == 4
		wxString endMarkersStr; endMarkersStr.Empty();
		wxString inlineNonbindingEndMkrs; inlineNonbindingEndMkrs.Empty();
		wxString inlineBindingEndMkrs; inlineBindingEndMkrs.Empty();
		while (pos_pSP != NULL)
		{
			if (bShowWaitDlg)
			{
				counter++;
				if (counter % 1000 == 0)
				{
					msgDisplayed = progMsg.Format(progMsg, fn.GetFullName().c_str(), counter, nTotal);
					// whm 28Aug11 Note: pProgDlg can be NULL when DoFileSave_Protected() and
					// DoFileSave() are called from DoAutoSaveDoc() which does not set up a
					// wxProgressDialog(). Therefore we must test for NULL here.
					if (bShowWaitDlg)
					{
						pStatusBar->UpdateProgress(progressItem, counter, msgDisplayed);
					}
				}
			}
			pSrcPhrase = (CSourcePhrase*)pos_pSP->GetData();
			// get a deep copy, so that we can change the data to what is compatible with
			// doc version 4 without corrupting the pSrcPhrase which remains in doc
			// version 5
			CSourcePhrase* pDeepCopy = new CSourcePhrase(*pSrcPhrase);
			pDeepCopy->DeepCopy();

			// do the conversion from docVersion 5 to docVersion 4 (if endMarkersStr is
			// passed in non-empty, the endmarkers are inserted internally at the start of
			// pDeepCopy's m_markers member (and if pDeepCopy is a merger, they are also
			// inserted in the first instance of pDeepCopy->m_pSavedWords's m_markers
			// member too); and before returning it must check for endmarkers stored on
			// pDeepCopy (whether a merger or not makes no difference in this case) and
			// reset endMarkersStr to whatever endmarker(s) are found there - so that the
			// next iteration of the caller's loop can place them on the next pDeepCopy
			// passed in. (FromDocVersion5ToDocVersion4() leverages the fact that the
			// legacy code for docVersion 4 xml construction knows nothing about the new
			// members m_endMarkers, m_freeTrans, etc - so as long as pDeepCopy's
			// m_markers member is reset correctly, and m_endMarkers's content is returned
			// to the caller for placement on the next iteration, the legacy xml code will
			// build correct docVersion 4 xml from the docVersion 5 CSourcePhrase instances)
			FromDocVersion5ToDocVersion4(pDeepCopy, &endMarkersStr, &inlineNonbindingEndMkrs,
				&inlineBindingEndMkrs);

			pos_pSP = pos_pSP->GetNext();
			aStr = pDeepCopy->MakeXML(1); // 1 = indent the element lines with a single tab
			DeleteSingleSrcPhrase(pDeepCopy, FALSE); // FALSE means "don't try delete a partner pile"
			DoWrite(f, aStr);
		}
	}
	else // use chose a normal docVersion 5 (or later) xml build
	{
		// this is identical to what the File / Save choice does, for building the
		// doc's XML, for VERSION_NUMBER (currently 5 or later) for docVersion
#if defined (_DEBUG) && !defined(NOLOGS)
		int howmany;
		howmany = 9; // interested only in first nine items
		int countHowmany;
		countHowmany = 0;
#endif
		while (pos_pSP != NULL)
		{
			if (bShowWaitDlg)
			{
				counter++;
				if (counter % 100 == 0)
				{
					msgDisplayed = progMsg.Format(progMsg, fn.GetFullName().c_str(), counter, nTotal);
					// whm 28Aug11 Note: pProgDlg can be NULL when DoFileSave_Protected() and
					// DoFileSave() are called from DoAutoSaveDoc() which does not set up a
					// wxProgressDialog(). Therefore we must test for NULL here.
					if (bShowWaitDlg)
					{
						pStatusBar->UpdateProgress(progressItem, counter, msgDisplayed);
					}
				}
			}
			pSrcPhrase = (CSourcePhrase*)pos_pSP->GetData();
#if defined (_DEBUG) && !defined(NOLOGS)
			countHowmany++;
			if (countHowmany < howmany)
			{
				wxLogDebug(_T("DoFileSave() line %d: sequNum= %d , m_srcPhrase= %s , m_markers= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str());
			}
#endif
			pos_pSP = pos_pSP->GetNext();
			aStr = pSrcPhrase->MakeXML(1); // 1 = indent the element lines with a single tab
			DoWrite(f, aStr);
		}
	}

	// doc closing tag
	aStr = xml_adaptitdoc;
	aStr = openBraceSlash + aStr; //"</" + aStr;
	aStr += ">\r\n"; // eol chars OK for cross-platform???
	DoWrite(f, aStr);

	// close the file
	f.Flush();
	f.Close();

	// remove the dummy that was appended, if we did append one in the code above
	if (type == save_as && m_bLegacyDocVersionForSaveAs)
	{
		if (bDummySrcPhraseAdded)
		{
			posLast = gpApp->m_pSourcePhrases->GetLast();
			CSourcePhrase* pDummyWhichIsLast = posLast->GetData();
			wxASSERT(pDummyWhichIsLast != NULL);
			gpApp->GetDocument()->DeleteSingleSrcPhrase(pDummyWhichIsLast);
		}
	}

	// recompute m_curOutputPath, so it can be saved to config files as m_lastDocPath,
	// because the path computed at the end of OnOpenDocument() will have been invalidated
	// if the filename extension was changed by code earlier in DoFileSave()
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
	{
		gpApp->m_curOutputPath = pApp->m_bibleBooksFolderPath +
			gpApp->PathSeparator + gpApp->m_curOutputFilename;
	}
	else
	{
		gpApp->m_curOutputPath = pApp->m_curAdaptationsPath +
			gpApp->PathSeparator + gpApp->m_curOutputFilename;
	}
	gpApp->m_lastDocPath = gpApp->m_curOutputPath; // make it agree with what path was
												   // used for this save operation

	// Do the document backup if required (This call supports a docVersion 4 choice, and
	// also a request to rename the document; by internally accessing the private members
	// bool	m_bLegacyDocVersionForSaveAs, and bool m_bDocRenameRequestedForSaveAs either
	// or both of which may have been changed from their default values of FALSE depending
	// on the execution path through the code above
	if (gpApp->m_bBackupDocument)
	{
		bool bBackedUpOK;
		if (bFileIsRenamed)
		{
			bBackedUpOK = BackupDocument(gpApp, pRenamedFilename);
		}
		else
		{
			bBackedUpOK = BackupDocument(gpApp); // 2nd param is default NULL (no rename wanted)
		}
		if (!bBackedUpOK)
		{
			wxMessageBox(_(
				"Warning: the attempt to backup the current document failed."),
				_T(""), wxICON_EXCLAMATION | wxOK);
			gpApp->LogUserAction(_T("Warning: the attempt to backup the current document failed."));
		}
	}

	// Restore the latest document version number, in case the save done above was actually
	// a Save As... using an earlier doc version number. Must not restore earlier than
	// this, as a call of BackupDocument() will need to know what the user's chosen state
	// value currently is for docVersion.
	RestoreCurrentDocVersion();

	Modify(FALSE); // declare the document clean
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
		SetFilename(pApp->m_bibleBooksFolderPath + pApp->PathSeparator +
			pApp->m_curOutputFilename, TRUE); // TRUE = notify all views
	else
		SetFilename(pApp->m_curAdaptationsPath + pApp->PathSeparator +
			pApp->m_curOutputFilename, TRUE); // TRUE = notify all views

	// the KBs (whether glossing KB or normal KB) must always be kept up to date with a
	// file, so must store both KBs, since the user could have altered both since the last
	// save
	gpApp->StoreGlossingKB(bShowWaitDlg, FALSE); // FALSE = don't want backup produced
	gpApp->StoreKB(bShowWaitDlg, FALSE);

	// remove the phrase box's entry again (this code is sensitive to whether glossing is on
	// or not, because it is an adjustment pertaining to the phrasebox contents only, to undo
	// what was done above - namely, the entry put into either the glossing KB or the normal KB)
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_pTargetBox->IsShown() &&
			pView->GetFrame()->FindFocus() == (wxWindow*)pApp->m_pTargetBox->GetTextCtrl() && !bNoStore) // whm 12Jul2018 added GetTextCtrl()-> part
		{
			wxString emptyStr = _T("");
			if (gbIsGlossing)
			{
				if (!bNoStore)
				{
					pApp->m_pGlossingKB->GetAndRemoveRefString(pApp->m_pActivePile->GetSrcPhrase(),
						emptyStr, useGlossOrAdaptationForLookup);
				}
				pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
			}
			else
			{
				if (!bNoStore)
				{
					pApp->m_pKB->GetAndRemoveRefString(pApp->m_pActivePile->GetSrcPhrase(),
						emptyStr, useGlossOrAdaptationForLookup);
				}
				pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
			}
		}
	}
	// whm 24Aug11 Note: We don't destroy pProgDlg here because it is
	// created in the caller and will be destroyed there.
	if (m_bLegacyDocVersionForSaveAs)
	{
		wxString msg;
		wxString appVerStr;
		appVerStr = pApp->GetAppVersionOfRunningAppAsString();
		msg = msg.Format(_("This document (%s) is now saved on disk in the older (version 3, 4, 5) xml format.\nHowever, if you now make any additional changes to this document or cause it to be saved using this version (%s) of Adapt It, the format of the disk file will be upgraded again to the newer format.\nIf you do not want this to happen, you should immediately close the document, or exit from this version of Adapt It."), gpApp->m_curOutputFilename.c_str(), appVerStr.c_str());
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(msg, _T(""), wxICON_INFORMATION | wxOK);
		gpApp->LogUserAction(_T("Save As done as version 3,4,5 xml format."));
	}
	m_bLegacyDocVersionForSaveAs = FALSE; // restore default
	// whm 20Aug11 note: since a file save operation is very frequent, we avoid inflating the user log
	// with successful saves.
	return TRUE;
}

// Return TRUE if the save was successful, FALSE if some error
// absPath is an absolute path to the file to be saved - it can be in either
// the Adaptations folder, or to any of the Bible Book folders, and it ignores
// whether the app is in Bible Book folder mode or not. It just does the save,
// overwriting the former file contents. Use this when we do 'all document'
// tweaks that involve loading in each doc file, tweaking its contents in
// m_pSourcePhrases, and then saving over the top of the old file on disk.
// This function has no GUI information in it.
bool CAdapt_ItDoc::DoAbsolutePathFileSave(wxString absPath)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (!absPath.IsEmpty())
	{
		wxFile f; // create a CFile instance with default constructor

		wxFileName fn(absPath);
		wxString pathToFolder = fn.GetPath();
		wxASSERT(!pathToFolder.IsEmpty());
		// Set the current working directory
		wxString saveCurWorkingDir = _T("");
		saveCurWorkingDir = fn.GetCwd(); // so we can restore it later
		// Get the filename, since we are working with a relative path now
		wxString fullName = fn.GetFullName();
		wxASSERT(!fullName.IsEmpty());
		bool bOK = fn.SetCwd(pathToFolder);
		if (bOK)
		{
			if (!f.Open(fullName, wxFile::write))
			{
				pApp->LogUserAction(_T("Failed f.Open() for writing in doc::DoAbsolutePathFileSave(wxString absPath)"));
				return FALSE;
			}
			// The following code is taken from doc::DoSaveFile(), and many comments removed to
			// keep it short. If anything is unclear then look there for the details
			CSourcePhrase* pSrcPhrase;
			CBString aStr;
			CBString openBraceSlash = "</"; // to avoid "warning: deprecated conversion from string constant to 'char*'"

			// prologue (Changed BEW 02July07 at Bob Eaton's request)
			gpApp->GetEncodingStringForXmlFiles(aStr);
			DoWrite(f, aStr);

			// add the comment with the warning about not opening the XML file in MS WORD
			// 'coz is corrupts it - presumably because there is no XSLT file defined for it
			// as well. When the file is then (if saved in WORD) loaded back into Adapt It,
			// the latter goes into an infinite loop when the file is being parsed in.
			aStr = MakeMSWORDWarning(); // the warning ends with \r\n so we don't need to add them here

			// doc opening tag
			aStr += "<";
			aStr += xml_adaptitdoc;
			aStr += ">\r\n"; // eol chars OK for cross-platform???
			DoWrite(f, aStr);
			// Construct the initial <Settings> tag
			aStr = ConstructSettingsInfoAsXML(1); // internally sets the docVersion attribute
			// to whatever is the current value of m_docVersionCurrent
			DoWrite(f, aStr);
			// Process the list of CSourcePhrase instances
			SPList::Node* pos_pSP = gpApp->m_pSourcePhrases->GetFirst();
			while (pos_pSP != NULL)
			{
				pSrcPhrase = (CSourcePhrase*)pos_pSP->GetData();
				pos_pSP = pos_pSP->GetNext();
				aStr = pSrcPhrase->MakeXML(1); // 1 = indent the element lines with a single tab
				DoWrite(f, aStr);
			}
			// doc closing tag
			aStr = xml_adaptitdoc;
			aStr = openBraceSlash + aStr; //"</" + aStr;
			aStr += ">\r\n"; // eol chars OK for cross-platform???
			DoWrite(f, aStr);

			// close the file
			f.Flush();
			f.Close();
			// Restore original current working directory
			bOK = fn.SetCwd(saveCurWorkingDir);
			wxASSERT(bOK);
			return TRUE;
		}
	}
	else
	{
		pApp->LogUserAction(_T("Passed in empty path in signature. In doc::DoAbsolutePathFileSave(wxString absPath)"));
	}
	// Path was empty, or could not reset the current working volume to the
	// document's folder, or the attempt to do f.Open() for writing failed; so
	// could not save the file - the old version of it will remain on disk
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param	event	-> wxCommandEvent (unused)
/// \remarks
/// Called from: the doc/view framework when wxID_SAVEAS event is generated. Also called from
/// CMainFrame's SyncScrollReceive() when it is necessary to save the current document before
/// opening another document when sync scrolling is on.
/// OnFileSaveAs simply calls DoFileSave() and the latter sets an enum value of save_as
///
/// BEW changed 28Apr10 A failure might be due to the Open call failing, in which case the
/// document's file is unchanged, or to the user clicking the Cancel buton in the Save As
/// dialog, in which case the document's file will have been truncated to zero length by
/// the f.Open call done before the Save As dialog was opened. So we need code added in
/// order to recover the document, if either was the case; also we have to handle the
/// possibility that the document may not yet have ever been saved, which changes what we
/// need to do in the event of failure.
/// BEW 16Apr10, added enum, for support of Save As... menu item as well as Save
/// BEW 20Aug10, changed so that the temporary file with derived name
/// "tempSave_<filename>.xml" is saved in the project folder, and restored from there if
/// needed. Doing this means that the GUI never reveals it to the user, which is how it
/// should behave.
/// BEW 1Jul13, refactored so as to work happily in a DVCS context. The earlier versio of
/// this function aimed to keep just one copy of the data (to avoid user confusion), so it
/// did the rename by renaming the current document only, and in the evente of failurer or
/// Cancel, it restored the document (and filename) to it's original state. This old
/// protocol is dangerous in a DVCS environment, we don't want to give the user the
/// capability of renaming a currently open document, which could be under version
/// control, to something else - that would require us to complicate DVCS to accomodate
/// such a possibility. It's likely the user wants a copy for some reason, such as for
/// training purposes or similar, and so a renamed copy which can be removed from the
/// project without damaging anything is a better idea. So the refactored version renames
/// a COPY of the current document, and does not switch the open document to be this
/// renamed copy. Therefore, the name of the open document, after a successful SaveAs...,
/// is the same and all that's happened is a second, renamed, copy now resides on disk .
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnFileSaveAs(wxCommandEvent& WXUNUSED(event))
{
	SaveType saveType = save_as;
	wxString renamedFilename; renamedFilename.Empty();
	wxString* pRenamedFilename = &renamedFilename;

	wxString pathToSaveFolder;
	wxULongLong originalSize = 0;
	wxULongLong copiedSize = 0;
	bool bRemovedSuccessfully = TRUE;
	ValidateFilenameAndPath(gpApp->m_curOutputFilename, gpApp->m_curOutputPath, pathToSaveFolder);
	m_bDocRenameRequestedForSaveAs = FALSE; // restore default (ValidateFilenameAndPath()
											// may have set it to TRUE)
	bool bOutputFileExists = ::wxFileExists(gpApp->m_curOutputPath); // original doc file

	// In the following call, if pRenamedFilename returns an empty string, then no rename has been
	// requested; first param, value being TRUE, means "show wait/progress dialog"
	bool bUserCancelled = FALSE; // it's initialized to FALSE inside the DoFileSave() call to
	if (bOutputFileExists)
	{
		gpApp->LogUserAction(_T("Initiated Save As..."));
	}
	else
	{
		gpApp->LogUserAction(_T("Initiated Save As... but no doc file exists, so returning"));
		return;
	}
	// Now make a copy with a different name, which we can later rename; put it in the
	// project folder - otherwise when the DoSaveFile() dialog opens, it would be listed
	// with all the document names (which we don't want to happen, it would confuse the
	// user), so later when we've renamed it, we'll move it to the pathToSaveFolder
	wxString prefixStr = _T("tempSave_"); // don't localize this, it's never seen
	wxString newNameStr = prefixStr + gpApp->m_curOutputFilename;
	wxString tempFileAbsPath = gpApp->m_curProjectPath + gpApp->PathSeparator + newNameStr;
	bool bCopiedSuccessfully = TRUE;
	if (bOutputFileExists)
	{
		bCopiedSuccessfully = ::wxCopyFile(gpApp->m_curOutputPath, tempFileAbsPath);
		wxASSERT(bCopiedSuccessfully);
		wxFileName fn(gpApp->m_curOutputPath);
		originalSize = fn.GetSize();
		if (bCopiedSuccessfully)
		{
			wxFileName fnNew(tempFileAbsPath);
			copiedSize = fnNew.GetSize();
			wxASSERT(copiedSize == originalSize);
		}
	}

	// whm 26Aug11 Open a wxProgressDialog instance here for transform to glosses operations.
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	// BEW 1Jul13, the above warning of Bill's no longer applies, because the renamed file will
	// not be the current document, but will be a copy thereof, and the current document will
	// stay 'as is' and so it's nTotal value will not change, and the view will not switch to
	// displaying the renamed document on return, but retain the current one unchanged.
	wxString msgDisplayed;
	const int nTotal = gpApp->GetMaxRangeForProgressDialog(App_SourcePhrases_Count) + 1;
	wxString progMsg = _("Saving File %s  - %d of %d Total words and phrases");
	wxFileName fn(gpApp->m_curOutputFilename);
	msgDisplayed = progMsg.Format(progMsg, fn.GetFullName().c_str(), 1, nTotal);
	wxString newAbsPath; newAbsPath.Empty(); // renamed file (including its path) will be put here

	bool bSuccess = DoFileSave(TRUE, saveType, pRenamedFilename, bUserCancelled, _T(""));
	if (bSuccess)
	{
		// BEW 1Jul13, we do the rename on a copy, and only provided the save was
		// successful (there won't be a filename clash because that was checked for and
		// prevented within DoFileSave())
		if (!pRenamedFilename->IsEmpty())
		{
			// a rename is wanted, make the renamed copy from the temp copy created above
			// by moving and renaming (::wxRenameFile() does both at the one time)
			// FALSE is bool overwrite, which defaults to TRUE, but we want FALSE here
			newAbsPath = pathToSaveFolder + gpApp->PathSeparator + renamedFilename;
			bool bSuccess = ::wxRenameFile(tempFileAbsPath, newAbsPath, FALSE);
			if (bSuccess)
			{
				// The renamed file copy was created, nothing to do but make sure no temp
				// copy remains, then then return
				bool bSomethingOfThatNameExists = ::wxFileExists(tempFileAbsPath);
				if (bSomethingOfThatNameExists)
				{
					bRemovedSuccessfully = wxRemoveFile(tempFileAbsPath);
					wxASSERT(bRemovedSuccessfully);
				}
				return;
			}
			else
			{
				// the rename failed, tell the user and exit; remove any fragment if present
				wxString msg;
				if (renamedFilename.IsEmpty())
				{
					msg = _("Warning: the SaveAs... attempt failed for some reason, the file was not created.");
					wxMessageBox(msg, _("SaveAs... failed"), wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(_T("Warning: SaveAs failed at ::wxRenameFile() call, empty filename."));
				}
				else
				{
					msg = _("Warning: the SaveAs... attempt failed for some reason, the file: %s was not created.");
					msg = msg.Format(renamedFilename.c_str());
					wxMessageBox(msg, _("SaveAs... failed"), wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(_T("Warning: SaveAs failed at ::wxRenameFile() call."));
				}
				bool bSomethingOfThatNameExists = ::wxFileExists(newAbsPath);
				if (bSomethingOfThatNameExists)
				{
					bRemovedSuccessfully = wxRemoveFile(newAbsPath);
					wxASSERT(bRemovedSuccessfully);
					bRemovedSuccessfully = bRemovedSuccessfully;  // prevent compiler warning, one of these is enough
				}
				// and also the temp copy
				bSomethingOfThatNameExists = ::wxFileExists(tempFileAbsPath);
				if (bSomethingOfThatNameExists)
				{
					bRemovedSuccessfully = wxRemoveFile(tempFileAbsPath);
					wxASSERT(bRemovedSuccessfully);
				}
				return;
			}
		}
		else
		{
			// an empty filename'd file should not have been created, so just remove the
			// temporary copy & return; similarly for one with same name
			bool bSomethingOfThatNameExists = ::wxFileExists(tempFileAbsPath);
			if (bSomethingOfThatNameExists)
			{
				bRemovedSuccessfully = wxRemoveFile(tempFileAbsPath);
				wxASSERT(bRemovedSuccessfully);
				wxString msg = _("Warning: a SaveAs... file with the same name is illegal, so nothing was done.");
				wxMessageBox(msg, _("SaveAs... failed"), wxICON_EXCLAMATION | wxOK);
				gpApp->LogUserAction(msg);
			}
			return;
		}
	}
	else // handle failure at the DoSaveFile dialog, or a user Cancel button click
	{
		if (bUserCancelled)
		{
			// nothing to do except make sure any temporary fragment is gone, & then return
			bool bSomethingOfThatNameExists = ::wxFileExists(tempFileAbsPath);
			if (bSomethingOfThatNameExists)
			{
				bRemovedSuccessfully = wxRemoveFile(tempFileAbsPath);
				wxASSERT(bRemovedSuccessfully);
			}
			return;
		}
		else
		{
			// something went wrong, tell the user and remove any fragmet, then return
			wxString msg;
			if (renamedFilename.IsEmpty())
			{
				msg = _("Warning: the SaveAs... attempt failed for some reason, the file was not created.");
				wxMessageBox(msg, _("SaveAs... failed"), wxICON_EXCLAMATION | wxOK);
				gpApp->LogUserAction(_T("Warning: SaveAs failed at ::wxRenameFile() call, empty filename."));
			}
			else
			{
				msg = _("Warning: the SaveAs... attempt failed for some reason, the file: %s was not created.");
				msg = msg.Format(renamedFilename.c_str());
				wxMessageBox(msg, _("SaveAs... failed"), wxICON_EXCLAMATION | wxOK);
				gpApp->LogUserAction(_T("Warning: SaveAs failed at ::wxRenameFile() call."));
			}
			bool bSomethingOfThatNameExists = ::wxFileExists(newAbsPath);
			if (bSomethingOfThatNameExists)
			{
				bRemovedSuccessfully = wxRemoveFile(newAbsPath);
				wxASSERT(bRemovedSuccessfully);
			}
			// and also the temp copy
			bSomethingOfThatNameExists = ::wxFileExists(tempFileAbsPath);
			if (bSomethingOfThatNameExists)
			{
				bRemovedSuccessfully = wxRemoveFile(tempFileAbsPath);
				wxASSERT(bRemovedSuccessfully);
			}
			return;
		}

	} // end else block for test: if (bSuccess)

}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param  curFilename       -> the current output filename (app's m_curOutputFilename member)
/// \param  curPath           <- the full path to current doc folder for saves, including the
///                               filename (app's m_curOutputPath)
/// \param  pathForSaveFolder <-  absolute path to the folder in which the doc will be saved
///                               (returned as a potential convenience to the caller,
///                               which may want to use this for some special purpose)
/// \remarks
/// Called from: OnFileSave(), OnFileSaveAs(), DoFileSave()
/// Takes the current save folder and the current doc filename, and rebuilds the output
/// full absolute path to the document, and ensuring the document filename has .xml
/// extension (version 4.0.0 and higher of Adapt It no longer save *.adt binary files)
/// BEW created 28Apr10, because this encapsulation of checks is need in more than one
/// place. Strictly speaking, the function is unneeded because now that we only save in
/// xml, nothing should ever change the extention to anything else - nevertheless, we'll
/// retain it
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::ValidateFilenameAndPath(wxString& curFilename, wxString& curPath,
	wxString& pathForSaveFolder)
{
	// m_curOutputFilename was set when user created the doc; or it an existing doc was
	// read back in; the extension will be .xml
	wxString thisFilename = curFilename;

	// we want an .xml extension - make it so if it happens to be .adt
	thisFilename = MakeReverse(thisFilename);
	wxString extn = thisFilename.Left(4);
	extn = MakeReverse(extn);
	if (extn != _T(".xml"))
	{
		thisFilename = thisFilename.Mid(4); // remove any extension
		thisFilename = MakeReverse(thisFilename);
		thisFilename += _T(".xml"); // it's now guaranteed to be *.xml
	}
	else
	{
		thisFilename = MakeReverse(thisFilename); // it's already *.xml
	}
	curFilename = thisFilename;

	// make sure the backup filename complies too (BEW added 23June07)
	MakeOutputBackupFilenames(curFilename);

	// the m_curOutputPath member can be redone now that m_curOutputFilename is what is wanted
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
	{
		pathForSaveFolder = gpApp->m_bibleBooksFolderPath;
	}
	else
	{
		pathForSaveFolder = gpApp->m_curAdaptationsPath;
	}

	curPath = pathForSaveFolder + gpApp->PathSeparator + curFilename;
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Enables or disables menu and/or toolbar items associated with the wxID_SAVE identifier.
/// If Vertical Editing is in progress the File Save menu item is always disabled, and this
/// handler returns immediately. Otherwise, the item is enabled if the KB exists, and if
/// m_pSourcePhrases has at least one item in its list, and IsModified() returns TRUE;
/// otherwise the item is disabled.
/// BEW modified 13Nov09, if the local user has only read-only access to a remote
/// project folder, do not let him save his local copy of the remote document to the
/// remote machine, otherwise the remote user is almost certainly to lose some edits
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnUpdateFileSave(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}

	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// whm 25May11 Note: When collaborating with Paratext/Bibledit the Save... command is
	// available under the same conditions as when not collaborating with Paratext/Bibledit,
	// i.e., a Doc is open and it is dirty/modified.
	// whm 6Nov12 revised to use the more self-documenting
	// IsDocumentOpen() function.
	if (pApp->m_pKB != NULL && pApp->IsDocumentOpen() && IsModified())
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is
///                        about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Enables or disables menu and/or toolbar items associated with the wxID_SAVEAS
/// identifier. If Vertical Editing is in progress the File Save As... menu item is always
/// disabled, and this handler returns immediately. Otherwise, the item is enabled if the
/// KB exists, and if m_pSourcePhrases has at least one item in its list, and IsModified()
/// returns TRUE; otherwise the item is disabled.
/// BEW modified 13Nov09, if the local user has only read-only access to a remote
/// project folder, do not let him save his local copy of the remote document to the
/// remote machine, otherwise the remote user is almost certainly to lose some edits
/// BEW 9Aug11, disabled when in collaboration mode with Paratext or Bibledit
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnUpdateFileSaveAs(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// BEW 9Aug11 disable SaveAs... when collaborating with an external editor (at such a
	// time we don't want to support doc conversion to kbVersion 1, nor a doc name change)
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}
	// whm 14Jan11 removed the && IsModified() test below. Save As should be available
	// whether the document is "dirty" or not.
	//if (pApp->m_pKB != NULL && pApp->m_pSourcePhrases->GetCount() > 0 && IsModified())
	if (pApp->m_pKB != NULL && pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItDoc::OnUpdateSaveAndCommit(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pKB != NULL && pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

///////////////////////////////////////////////////////////////////////////////
/// \return TRUE if the document is successfully opened, otherwise FALSE.
/// \param	lpszPathName	-> the name and path of the document to be opened
/// \remarks
/// Called from: the App's DoTransformationsToGlosses( ) function.
/// Opens a document in another project in preparation for transforming its adaptations into
/// glosses in the current project. The other project's documents get copied in the process, but
/// are left unchanged in the other project. Since we are not going to look at the contents of
/// the document, we don't do anything except get it into memory ready for transforming.
/// BEW changed 31Aug05 so it would handle either .xml or .adt documents automatically (code pinched
/// from start of OnOpenDocument())
///////////////////////////////////////////////////////////////////////////////

bool CAdapt_ItDoc::OpenDocumentInAnotherProject(wxString lpszPathName)
{
	CAdapt_ItApp* pApp = GetApp();

	// BEW added 31Aug05 for XML doc support (we have to find out what extension it has
	// and then choose the corresponding code for loading that type of doc
	wxString thePath = lpszPathName;
	wxString extension = thePath.Right(4);
	extension.MakeLower();
	wxASSERT(extension[0] == _T('.')); // check it really is an extension

	wxFileName fn(thePath);
	wxString fullFileName;
	fullFileName = fn.GetFullName();

	// whm 26Aug11 Open a wxProgressDialog instance here for opening doc operations.
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	wxString msgDisplayed;
	wxString progMsg;
	CStatusBar* pStatusBar = NULL;
	// add 1 chunk to insure that we have enough after int division above
	const int nTotal = gpApp->GetMaxRangeForProgressDialog(XML_Input_Chunks) + 1;
	// Only show the progress dialog when there is at lease one chunk of data
	// Only create the progress dialog if we have data to progress
	if (nTotal > 0)
	{
		progMsg = _("Reading file %s - part %d of %d");
		//wxFileName fn(fullFileName); done above
		msgDisplayed = progMsg.Format(progMsg, fn.GetFullName().c_str(), 1, nTotal);
		pStatusBar = (CStatusBar*)gpApp->GetMainFrame()->m_pStatusBar;
		pStatusBar->StartProgress(_("Opening Document In Another Project"), msgDisplayed, nTotal);
	}

	if (extension == _T(".xml"))
	{
		// we have to input an xml document
		bool bReadOK = ReadDoc_XML(thePath, this, _("Opening Document In Another Project"), nTotal);

		if (!bReadOK)
		{
			// Let's see if we can recover the doc:
			if (pApp->m_commitCount > 0)
			{
				wxCommandEvent  dummyEvent;
				wxString        savedOutputFilename = pApp->m_curOutputFilename;
				wxString        savedAdaptationsPath = pApp->m_curAdaptationsPath;

				OnFileClose(dummyEvent);                            // the file's corrupt, so we close it to avoid crashes
				pApp->m_reopen_recovered_doc = FALSE;               // so the recovery code doesn't try to re-open the doc
				pApp->m_curOutputFilename = thePath;                // have to make these source values current for the recovery
				pApp->m_curAdaptationsPath = pApp->m_sourcePath;
				bReadOK = RecoverLatestVersion();
				pApp->m_curOutputFilename = savedOutputFilename;    // restore target values
				pApp->m_curAdaptationsPath = savedAdaptationsPath;

				if (bReadOK)                                        // if we recovered the doc, we retry the original read
					bReadOK = ReadDoc_XML(thePath, this, _("Opening Document In Another Project"), nTotal);

				if (bReadOK)
				{
					wxString msg;
					msg.Format(_T("The document %s was corrupt, but we have restored the latest version saved in the document history."), thePath.c_str());
					// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
					gpApp->m_bUserDlgOrMessageRequested = TRUE;
					wxMessageBox(msg);
				}
			}

			if (!bReadOK)
			{
				wxString s;
				s = _(
					"There was an error parsing in the XML file.\nIf you edited the XML file earlier, you may have introduced an error.\nEdit it in a word processor then try again.");
				wxMessageBox(s, fullFileName, wxICON_INFORMATION | wxOK);
				if (nTotal > 0)
					pStatusBar->FinishProgress(_("Opening Document In Another Project"));
				return FALSE; // return FALSE to tell caller we failed
			}
		}
	}
	else
	{
		wxMessageBox(_(
			"Sorry, the wxWidgets version of Adapt It does not read legacy .adt document format; it only reads the .xml format.")
			, fullFileName, wxICON_EXCLAMATION | wxOK);
		if (nTotal > 0)
			pStatusBar->FinishProgress(_("Opening Document In Another Project"));
		return FALSE;
	}
	if (nTotal > 0)
		pStatusBar->FinishProgress(_("Opening Document In Another Project"));

	// The doc in the other project may have been under version control, but in this project of course it isn't yet.  So we
	//  must initialize the appropriate variables.

	pApp->m_owner = pApp->m_strUserID;  // this is our doc
	pApp->m_commitCount = -1;			//  means not under version control (yet)
	pApp->m_versionDate = wxInvalidDateTime;
	pApp->m_nActiveSequNum = 0;         // sensible default if we don't get a "real" value

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param	event	-> wxCommandEvent (unused)
/// \remarks
/// Called automatically within the doc/view framework when an event associated with the
/// wxID_OPEN identifier (such as File | Open) is generated within the framework. It is
/// also called by the Doc's OnOpenDocument(), by the DocPage's OnWizardFinish() and by
/// SplitDialog's SplitIntoChapters_Interactive() function.
/// Rather than using the doc/view's default behavior for OnFileOpen() this function calls
/// our own DoFileOpen() function after setting the current work folder to the Adaptations
/// path, or the current book folder if book mode is on.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnFileOpen(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	// BEW 21Aug15, Default the following flag to a TRUE value - just in case
	// collaboration mode may be in effect
	pApp->m_bConflictResolutionTurnedOn = TRUE;

	// ensure that the current work folder is the Adaptations one for default; unless book
	// mode is ON, in which case it must the the current book folder.
	wxString dirPath;
	if (pApp->m_bBookMode && !pApp->m_bDisableBookMode)
		dirPath = pApp->m_bibleBooksFolderPath;
	else
		dirPath = pApp->m_curAdaptationsPath;
	bool bOK;
	// whm 8Apr2021 added wxLogNull block below
	{
		wxLogNull logNo;	// eliminates any spurious messages from the system if the wxSetWorkingDirectory() call returns FALSE
		bOK = ::wxSetWorkingDirectory(dirPath); // ignore failures
	} // end of wxLogNull scope
	bOK = bOK; // avoid warning
	// NOTE: This OnFileOpen() handler calls DoFileOpen() in the App, which now simply
	// calls DoStartWorkingWizard().
	pApp->DoFileOpen();
	// BEW added 7Oct14
	pApp->m_bZWSPinDoc = pApp->IsZWSPinDoc(pApp->m_pSourcePhrases);
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param	event	-> wxCommandEvent associated with the wxID_CLOSE identifier.
/// \remarks
/// This function is called automatically by the doc/view framework when an event
/// associated with the wxID_CLOSE identifier is generated. It is also called by: the App's
/// OnFileChangeFolder() and OnAdvancedBookMode(), by the View's OnFileCloseProject(), and
/// by DocPage's OnButtonChangeFolder() and OnWizardFinish() functions.
/// This override of OnFileClose does not close the app, it just clears out all the current view
/// structures, after calling our version of SaveModified. It simply closes files & leave the
/// app ready for other files to be opened etc. Our SaveModified() & this OnFileClose are
/// not OLE compliant. (A New... or Open... etc. will call DeleteContents on the doc structures
/// before a new doc can be made or opened). For version 2.0, which supports glossing, if one KB
/// gets saved, then the other should be too - this needs to be done in our SaveModified( ) function
/// NOTE: we don't change the values of the four flags associated with glossing, because this
/// function may be called for processes which serially open and close each document of a
/// project, and the flags will have to maintain their values across the calls to ClobberDocument;
/// and certainly ClobberDocumen( ) will be called each time even if this one isn't.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnFileClose(wxCommandEvent& event)
{
	NormalizeState();

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbVerticalEditInProgress)
	{
		// don't allow doc closure until the vertical edit is finished
		::wxBell();
		pApp->LogUserAction(_T("Disallow File Close - gbVerticalEditInProgress"));
		return;
	}

	// when collaborating on a doc is finished, restore the Copy Source flag value to what
	// it was before it was automatically turned off
	if (pApp->m_bSaveCopySourceFlag_For_Collaboration)
	{
		pApp->m_bCopySource = FALSE;
		pApp->GetView()->ToggleCopySource(); // toggles m_bCopySource's value & resets menu item
		pApp->m_bSaveCopySourceFlag_For_Collaboration = FALSE; // when closing doc, always clear

		// whm 2Aug2018 Note: The Select Copied Source menu item is enabled only when the
		// m_bCopySource value is TRUE. Its check status is determined by the value the
		// user stored in the project config file (i.e., it may be ticked, but will be
		// disabled whenever the Copy Source menu item is not ticked.
	}

	// whm 19Sep11 modified. The UnloadKBs() call below during collaboration should
	// not be done before the OnSaveModified() call a little farther below. Otherwise
	// the KB pointers become NULL and a crash can result in StoreText() farther down
	// the calling chain, when UpdateDocWithPhraseBoxContents( is called with bAttemptStoreToKB
	// == TRUE) and KB::StoreText() is called on NULL KBs. I've moved the block containing
	// the UnLoadKBs() call below down past the OnSaveModified() call. I've also added tests
	// in CKB::StoreText() for NULL KBs.

	// ensure no selection remains, in case the layout is destroyed later and the app
	// tries to do a RemoveSelection() call on a non-existent layout
	gpApp->GetView()->RemoveSelection();

	if (gpApp->m_bFreeTranslationMode)
	{
		// free translation mode is on, so we must first turn it off
		gpApp->GetFreeTrans()->OnAdvancedFreeTranslationMode(event);
	}

	bUserCancelled = FALSE; // default
	if (!OnSaveModified())
	{
		bUserCancelled = TRUE;
		pApp->LogUserAction(_T("Cancelled OnSaveModified() from OnFileClose()"));
		return;
	}

	// whm 2Sep2021 added. Here seems to be a location that gets executed when
	// a document is closed, both for regular non-collab docs and for collab docs.
	// We need to clear the auto-correct has map when the document closes.
	pApp->EmptyMapAndInitializeAutoCorrect();

	// whm 19Sep11 moved this block here from above the OnSaveModified() call. See
	// comment where the code is commented out above for reason for the move.
	// Remove KBs from the heap, when colloborating with an external editor
	if (pApp->m_bCollaboratingWithBibledit || pApp->m_bCollaboratingWithParatext)
	{
		// closure of the collaboration document should clobber the KBs as well, just in
		// case the user switches to a different language in PT for the next "get" - so we
		// set up for each document making no assumptions about staying within a certain
		// AI project each time - each setup is independent of what was setup last time
		// (we always create and delete these as a pair, so one test would suffice)
		if (pApp->m_pKB != NULL || pApp->m_pGlossingKB != NULL)
		{
			UnloadKBs(pApp); // also sets m_pKB and m_pGlossingKB each to NULL
		}
	}
	// BEW added 19Nov09, for read-only support; when a document is closed, attempt
	// to remove any read-only protection that is current for this project folder, because
	// the owning process may have come to have abandoned its ownership prior to the local
	// user closing this document, and that gives the next document opened in this project
	// by the local user the chance to own it for writing
	if (!pApp->m_curProjectPath.IsEmpty())
	{
		// if unowned, or if my process has the ownership, then ownership will be removed
		// at the doc closure (the ~AIROP-*.lock file will have been deleted), and TRUE
		// will be returned to bRemoved - which is then used to clear m_bReadOnlyAccess
		// to FALSE. This makes this project ownable by whoever next opens a document in it.
		bool bRemoved = pApp->m_pROP->RemoveReadOnlyProtection(pApp->m_curProjectPath);
		if (bRemoved)
		{
			pApp->m_bReadOnlyAccess = FALSE; // project folder is now ownable for writing
			// whm 7Mar12 Note: We do not reset the m_bFictitiousReadOnlyAccess	here because
			// if it is TRUE it should stay set to TRUE until a project close (in EraseKB)
			// or App exit. Note: the RemoveReadOnlyProtection() call above also removes our
			// fictitious ROPFile, but it gets created again when the next doc is opened as
			// long as the project has not closed (EraseKB called), since the
			// m_bFictitiousReadOnlyAccess flag does not get reset here.
			pApp->GetView()->canvas->Refresh(); // try force color change back to normal
			// white background -- it won't work as the canvas is empty, but the
			// removal of read only protection is still done if possible
		}
		else
		{
			pApp->m_bReadOnlyAccess = TRUE; // this project folder is still read-only
				// for this running process, as we are still in this project folder
		}
	}

	bUserCancelled = FALSE;
	CAdapt_ItView* pView = (CAdapt_ItView*)GetFirstView();
	wxASSERT(pView != NULL);
	pView->RemoveSelection(); // required, else if a selection exists and user closes doc and
			// does a Rebuild Knowledge Base, the m_selection array will retain hanging
			// pointers, and Rebuild Knowledge Base's RemoveSelection() call will cause a
			// crash
	pView->ClobberDocument(); // BEW 13Jul19 sets m_bDocumentDestroyed to TRUE (only DoAutoSaveDoc() uses)

	// delete the buffer containing the filed-in source text
	if (pApp->m_pBuffer != NULL)
	{
		delete pApp->m_pBuffer;
		pApp->m_pBuffer = (wxString*)NULL; // MFC had = 0
	}

	// show "Untitled" etc
	wxString viewTitle = _("Untitled - Adapt It");
	SetTitle(viewTitle);
	SetFilename(viewTitle, TRUE);	// here TRUE means "notify the views" whereas
									// in the MFC version TRUE meant "add to MRU list"
	// Note: SetTitle works, but the doc/view framework overwrites the result with "Adapt
	// It [unnamed1]", etc unless SetFilename() is also used.
	//
	// whm modified 13Mar09:
	// When the doc is explicitly closed on Linux, the Ctrl+O hot key doesn't work unless the focus is
	// placed on an existing element such as the toolbar's Open icon (which is where the next action
	// would probably happen).
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxASSERT(pFrame->m_pControlBar != NULL);
	pFrame->m_pControlBar->SetFocus();
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Enables or disables menu item associated with the wxID_CLOSE identifier.
/// If Vertical Editing is in progress the File Close menu item is disabled, and this handler
/// immediately returns. Otherwise, the item is enabled if m_pSourcePhrases has at least one
/// item in its list; otherwise the item is disabled.
///////////////////////////////////////////////////////////////////////////////

void CAdapt_ItDoc::OnUpdateFileClose(wxUpdateUIEvent& event)
{
	// BEW 10May14 I won't disable the close if clipboard adapting mode is still
	// in effect, rather, the OnFileClose() call will automatically restore the
	// cached document before doing anything else, and what will be closed will then
	// correctly be the cached-but-now-has-become-the-active document. This is a nicer
	// protocol than simply disabling all the File or document i/o, since a new user may
	// not know why he can't save or get a new file, so he may want to just close to make
	// things okay the brute force way - so we'll let him
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}

	if (gpApp->m_trialVersionNum >= 0)
	{
		event.Enable(FALSE);
		return;
	}

	if (pApp->m_pSourcePhrases->GetCount() > 0)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return TRUE if the document is successfully backed up, otherwise FALSE.
/// \param	pApp	         -> currently unused
/// \param  pRenamedFilename -> points to NULL (the default value), but if a valid
///                             different filename was supplied by the user in the
///                             Save As dialog, then it points to the wxString which
///                             holds that name (the caller will have verified
///                             beforehand that it is a valid filename))
/// \remarks
/// Called by the Doc's DoFileSave() function.
/// BEW added 23June07; do no backup if gbDoingSplitOrJoin is TRUE;
/// these operations could produce a plethora of backup docs, especially for a
/// single-chapters document split, so we just won't permit splitting, or joining
/// (except for the resulting joined file), or moving to generate new backups.
/// If rename is requested, we hold off on it to the very end because it will be the case
/// that any pre-existing backup will have the old filename, so we do the backup with the
/// old name, and only after that do we handle the rename. (We don't support renames nor
/// backing up when doing Split Document or Join Document either.)
/// BEW changed 29Apr10, to allow a rename option from user's use of the rename
/// functionality within the Save As dialog
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::BackupDocument(CAdapt_ItApp* WXUNUSED(pApp), wxString* pRenamedFilename)
{
	if (gbDoingSplitOrJoin)
		return TRUE;

	wxFile f; // create a CFile instance with default constructor

	// make the working directory the "Adaptations" one; or a bible book folder
	// if in book mode
	wxString basePath;
	bool bOK;
	// whm 8Apr2021 added wxLogNull block below
	{
		wxLogNull logNo;	// eliminates any spurious messages from the system if the wxSetWorkingDirectory() call returns FALSE

		if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
		{
			basePath = gpApp->m_bibleBooksFolderPath;
			bOK = ::wxSetWorkingDirectory(gpApp->m_bibleBooksFolderPath);
		}
		else
		{
			basePath = gpApp->m_curAdaptationsPath;
			bOK = ::wxSetWorkingDirectory(gpApp->m_curAdaptationsPath);
		}
	} // end of wxLogNull scope
	if (!bOK)
	{
		wxString str;
		//IDS_DOC_BACKUP_PATH_ERR
		if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
			str = str.Format(_(
				"Warning: document backup failed for the path:  %s   No backup was done."),
				GetApp()->m_bibleBooksFolderPath.c_str());
		else
			str = str.Format(_(
				"Warning: document backup failed for the path:  %s   No backup was done."),
				GetApp()->m_curAdaptationsPath.c_str());
		wxMessageBox(str, _T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}

	// make sure the backup filename complies too (BEW added 23June07) -- the function sets
	// m_curOutputBackupFilename based on the passed in filename string

	// BEW changed 29Apr10, MakeOutputBackupFilenames() will reset
	// m_curOutputBackupFilename and if there is to be a filename rename done below, we
	// would lose the old value of m_curOutputBackupFilename; so we store the latter so
	// that we can be sure to remove the old backup file if it exists on disk (it won't
	// exist, for example, if the use has only just turned on document backups), and then
	// we'll use m_curOutputBackupFilename's contents, whether renamed or not, to create
	// the wanted backup file
	//bool bOldBackupExists = FALSE; // set below but unused unused
	wxString saveOldFilename = gpApp->m_curOutputBackupFilename;
	if (pRenamedFilename == NULL)
	{
		// no rename is requested, so go ahead with the legacy call
		MakeOutputBackupFilenames(gpApp->m_curOutputFilename);
	}
	else
	{
		// a rename is requested, so the first param should be the new filename
		MakeOutputBackupFilenames(*pRenamedFilename);
	}

	// remove the old backup
	wxString aFilename = saveOldFilename;
	if (wxFileExists(aFilename))
	{
		// this backed up document file is on the disk, so delete it
		//bOldBackupExists = TRUE;
		if (!wxRemoveFile(aFilename))
		{
			wxString s;
			s = s.Format(_(
				"Could not remove the backed up document file: %s; the application will continue"),
				aFilename.c_str());
			wxMessageBox(s, _T(""), wxICON_EXCLAMATION | wxOK);
			// do nothing else, let the app continue
		}
	}

	// the new backup will have the name which is now in m_curOutputBackupFilename,
	// whether based on the original filename, or a user-renamed filename
	int len = gpApp->m_curOutputBackupFilename.Length();
	if (gpApp->m_curOutputBackupFilename.IsEmpty() || len <= 4)
	{
		wxString str;
		// IDS_DOC_BACKUP_NAME_ERR
		str = str.Format(_(
			"Warning: document backup failed because the following name is not valid: %s    No backup was done."),
			gpApp->m_curOutputBackupFilename.c_str());
		wxMessageBox(str, _T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}

	// copied from DoFileSave - I didn't change the share options, not likely to matter here
	bool bFailed = FALSE;
	if (!f.Open(gpApp->m_curOutputBackupFilename, wxFile::write))
	{
		wxString s;
		s = s.Format(_(
			"Could not open a file stream for backup, in BackupDocument(), for file %s"),
			gpApp->m_curOutputBackupFilename.c_str());
		wxMessageBox(s, _T(""), wxICON_EXCLAMATION | wxOK);
		// if f failed to Open(), we've just lost any earlier backup file we already had;
		// well, we could build some protection code but we'll not bother as failure to
		// Open() is unlikely, and it's only a backup which gets lost - presumably the doc
		// file itself is still good
		return FALSE;
	}

	CSourcePhrase* pSrcPhrase;
	CBString aStr;
	CBString openBraceSlash = "</"; // to avoid "warning:
			// deprecated conversion from string constant to 'char*'"

	// prologue (BEW changed 02July07 to use Bob's huge switch in the
	// GetEncodingStrongForXmlFiles() function which he did, to better support
	// legacy KBs & doc conversions in SILConverters conversion engines)
	gpApp->GetEncodingStringForXmlFiles(aStr);
	DoWrite(f, aStr);

	// add the comment with the warning about not opening the XML file in MS WORD
	// 'coz is corrupts it - presumably because there is no XSLT file defined for it
	// as well. When the file is then (if saved in WORD) loaded back into Adapt It,
	// the latter goes into an infinite loop when the file is being parsed in.
	aStr = MakeMSWORDWarning(); // the warning ends with \r\n
								// so we don't need to add them here
	// doc opening tag
	aStr += "<";
	aStr += xml_adaptitdoc;
	aStr += ">\r\n";
	DoWrite(f, aStr);

	// place the <Settings> element at the start of the doc
	aStr = ConstructSettingsInfoAsXML(1);
	DoWrite(f, aStr);

	// add the list of sourcephrases
	SPList::Node* pos_pSP = gpApp->m_pSourcePhrases->GetFirst();

	if (m_bLegacyDocVersionForSaveAs)
	{
		// user chose a legacy xml doc build, and so far there is only one such
		// choice, which is docVersion == 4
		wxString endMarkersStr; endMarkersStr.Empty();
		wxString inlineNonbindingEndMkrs; inlineNonbindingEndMkrs.Empty();
		wxString inlineBindingEndMkrs; inlineBindingEndMkrs.Empty();
		while (pos_pSP != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos_pSP->GetData();
			// get a deep copy, so that we can change the data to what is compatible
			// with doc version 4 without corrupting the pSrcPhrase which remains in
			// doc version 5
			CSourcePhrase* pDeepCopy = new CSourcePhrase(*pSrcPhrase);
			pDeepCopy->DeepCopy();

			// see comments in DoFileSave()
			FromDocVersion5ToDocVersion4(pDeepCopy, &endMarkersStr, &inlineNonbindingEndMkrs,
				&inlineBindingEndMkrs);

			pos_pSP = pos_pSP->GetNext();
			aStr = pDeepCopy->MakeXML(1); // 1 = indent the element lines with a single tab
			DeleteSingleSrcPhrase(pDeepCopy, FALSE); // FALSE means "don't try delete a partner pile"
			DoWrite(f, aStr);
		}
	}
	else // use chose a normal docVersion 5 xml build
	{
		while (pos_pSP != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos_pSP->GetData();
			pos_pSP = pos_pSP->GetNext();
			aStr = pSrcPhrase->MakeXML(1);
			DoWrite(f, aStr);
		}
	}
	// doc closing tag
	aStr = xml_adaptitdoc;
	aStr = openBraceSlash + aStr; //"</" + aStr;
	aStr += ">\r\n";
	DoWrite(f, aStr);

	// close the file
	f.Close();
	f.Flush();
	if (bFailed)
		return FALSE;
	else
		return TRUE;
}

int CAdapt_ItDoc::GetCurrentDocVersion()
{
	return m_docVersionCurrent;
}

/*
// The following function is currently unused.
// whm 10Nov2023 added the following function to aid in insertion of 
// the marker-being-unfiltered into pList.
// Why have the ThisMarkerMustRelocateBeforeOfAfterAdjacentMarker() 
// function?
// Our filtering code now does a good job of filtering markers and
// associated text - filtering any of the above 4 markers in any
// order, including carrying forward filtered material to a previous 
// location, and combining it with any already existing filtered 
// material that might exist on the previous source phrase.
// Filtering is relatively easy as we can readily determine where
// the filtered material should go - prior to the source phrase that
// precedes the marker being filtered. And, if the last word of the 
// associated text of this marker is currently storing filtered 
// material itself, and the marker itself gets filtered, its last
// word's stored material can be easily combined with the currently-
// being filtered marker, and both carried forward to be re-stored
// on the first visible source phrase preceding the marker being 
// filtered.
// Unfiltering is more complex especially when unfiltering one of
// several adjacent markers that had previously been filtered at a
// given location. It is more complex because once adjacent markers
// have been filtered we loose ordering information about the 
// filtered markers and their ordering with respect to any adjacent
// markers that are currently unfiltered and possibly visible before 
// or after the current source phrase. We don't know from their
// storage order within m_filteredInfo whether the marker being
// unfiltered from there should be inserted before or after any
// marker and its associated text that is already in an unfiltered 
// state adjacent to the marker being filtered. 
// 
// This function was created to deal with the following situation:
// Whevever multiple adjacent markers have previously been filtered,
// knowledge of their original ordering in the text can be lost, and
// that knowledge is needed to accurately determine the position 
// where the marker-being-unfiltered should be inserted back into the
// main text, especially when text that is adjacent to the marker-
// being-unfiltered's storage location is itself part of a filterable
// marker. Always unfiltering a marker and its associated text 
// following the storage source phrase, can easily result in two 
// adjacent markers ending up in an order that is reverse of their
// original order.
// For example, sapos 2 originally adjacent markers \s and \r were
// filtered. Our current unfiltering routine unfilters markers
// back to the main text immediately following their storage location.
// If the user unfilters the \r marker, then unfilters the
// \s marker they will end up being in the correct order in the main 
// text \s followed by \r. However, if the user unfilters the \s 
// marker, then unfilters the \r marker they will end up being 
// restored to the main text in the wrong/reverse order \r followed
// by \s. The situation only gets more complex when 3 or 4 adjacent
// markers have all been filtered and are all unfiltered one-by-one
// in different unfiltering orders. In the Nyindrou Scripture texts 
// one sometimes finds 4 filterable markers adjacent to each other:
// \ms, \mr, \s, and \r - each having its own associated text. When
// these texts are first created the \mr and \r markers are parsed
// as filtered, but a user can easily also filter \mr and \r so that
// all 4 markers \ms, \mr, \s, and \r get filtered and stored together
// on the same source phrase's m_filteredInfo member, that source 
// phrase being the last word of text just before the original 
// location of the first first of the 4 adjacent markers now in a
// filtered state. The user can choose to unfilter all of the 4
// already-filtered markers, and may unfilter all 4 of them in any 
// one of 24 different ways! Here are those 24 ways to unfilter them:
// \ms \mr \s \r, \ms \mr \r \s, \ms \s \mr \r, \ms \s \r \mr, \ms \r \mr \s, \ms \r \s \mr, 
// \mr \ms \s \r, \mr \ms \r \s, \mr \s \ms \r, \mr \s \r \ms, \mr \r \ms \s, \mr \r \s \ms,
// \s \ms \mr \r, \s \ms \r \mr, \s \mr \ms \r, \s \mr \r \ms, \s \r \ms \mr, \s \r \mr \ms,
// \r \ms \mr \s, \r \ms \s \mr, \r \mr \ms \s, \r \mr \s \ms, \r \s \ms \mr, \r \s \mr \ms.
// Within the above 24 different unfiltering sequences, only one
// sequence, the first one: \ms \mr \s \r, is the correct sequence.
// Unfiltering. The same possible sequences for filtering these
// four markers area also possible, and the m_filteredInfo storage
// member might also have the order of filtered marker strings 
// within \~FILTER ...\~FILTER* markers stored in similarly 
// different orders.
// Our algorithm mmust be able to unfilter markers and their
// associated words stored in any one of the above 23 incorrect
// sequences, and decide where to insert the marker strings in 
// the one correct order in the main text!
// My assumption is that we can indeed devise a function that can
// decide the correct position/node to insert the subList of source 
// phrases representing each marker-being-unfiltered string, 
// inserting it into the main pList of source phrases, and thereby
// end up with the correct order of all adjacent markers as they 
// are being unfiltered.
// I think we can gain sufficient knowledge to unfilter adjacent 
// filtered markers by examining the marker-being-unfiltered's 
// occursUnder information and scanning to determine what markers 
// may be adjacent - either following or preceding - the current 
// marker being unfiltered. 
// Depending on the occursUnder information available, it may be
// necessary to unfilter the current marker:
// a. immediately following the current marker being unfiltered (this
//    is the usual case when there are no adjacent markers).
// b. before an adjacent preceding marker and its associated text
//    (this requires scanning preceding associated text words to
//    locate the SP that contains the associated text marker and
//    return the position of the SP BEFORE that marker).
// c. after an adjacent following marker and its associated text.
//    (this requires scanning the following SP, and if it contains
//    the adjacent marker, continue scanning followin SPs until it
//    locates the SP that is the last word of associated text and
//    return the position of the SP AFTER that ending word's SP).
// 
// Let's say that all 4 markers \ms, \mr, \s, and \r were 
// previously filtered, and are stored within in a source phrase 
// with sequence number say 20.
// And, at a later time the user decides to unfilter some or all
// of the filtered material. There are a number of different ways
// the user might proceed since the unfiltering might be done in
// any of 23 possible orders, but the user decides to unfilter \s
// first. 
// The occursUnder string list of markers for the \s marker has:
//    "c"
// And the occursUnder string list of markers for the \r marker has:
//    "c s s1 s2 s3 s4"
// From these occursUnder lists we know the following about the 
// relative ordering of the \r and \s markers:
// While \s can occurs most anywhere under the "c" chapter marker,
// The \r marker occurs UNDER any adjacent section heading including
// \s.
// OK, let's now look at the following unfiltering scenario:
// The user decides first to unfilter the \s marker, and then unfilter
// the \r marker, both of which are currently stored at the source 
// phrase sequence number 20. The user first unfilters the \s marker
// which is inserted along with its associated text AFTER its storage
// location (sequence 20) starging at sequence numbers 21 and 
// following. Then after that, the user decides to unfilter the
// \r maker which is still stored at sequence number 20. The usual
// location for inserting filtered information is AFTER the source 
// phrase location where the filtered info is stored, which would
// usually be starting at sequence 21, but we already unfiltered the
// \s marker and its associated text starting at sequence number 21
// and following. If the \r marker were to be unfiltered starting at
// sequence number 21, it would push the already-unfiltered \s marker
// and its associated text AFTER its location - resulting in the \s
// marker and associated text being ordered AFTER the \r marker and
// its associated text. But \s "occurring under" \r is NOT the correct
// ordering. The ordering should be \r "occurring under" \s.
// Therefore, our unfiltering routine - when unfiltering \r in this
// situation, needs to check to see if there is an adjacent unfiltered
// marker in the text immediately AFTER its stored location, and if 
// so, check whether that adjacent marker is present in the currently 
// being unfiltered marker's occursUnder list. If so, the routine 
// needs to scan through the adjacent marker and its associated text 
// to find the sequence number of the last word of the adjacent 
// marker's text, and insert the \r marker and its associated text 
// AFTER that last word's SP sequence number.
// If we insert the \r marker and its associated text after that last
// word associated with the \s marker, then we will get the proper
// order of both markers \s and \r once both of them have been 
// unfiltered. 
// Hence, it isn't really feasible to rely on the ordering of 
// still-filtered marker information that is stored within the 
// pSP->m_filteredInfo member. The information we need is no longer 
// within that m_filteredInfo member! The \s member was already 
// unfiltered, and now that we are in the process of unfiltering an 
// adjacent \r marker, there is nothing within the m_filteredInfo 
// member's current storage alone to inform us that the \r marker and
// its associated text should be restored or unfiltered to a source 
// phrase that may be located many SP sequence numbers following the 
// current pSP source phrase - i.e., inserted at the source phrase 
// immediately following the last word of the \s marker's associated 
// text.
// With my recent refactoring of USFMAnalysis struct to include the usfm
// occursUnder information, we now have ordering information readily 
// available for the marker that is now being unfiltered. To utilize 
// that information we call the following function with the long name:
// bool ThisMarkerMustRelocateBeforeOfAfterAdjacentMarker(SPList::Node* currPos, 
//		SPList::Node*& prevPos, wxString occursUnderStr)
// This function then is called from the ReconstituteAfterFilteringChange() 
// function's if (bUnfilteringRequired) block.
// 
// TODO: Revise comment below !!!
// 1. Get the occursUnder list, if any, call LookupSFM(bareMarker) to get
//    the pUsfmAnalysis instance of the current marker being unfilterd,
//    and retrieve the pUsfmAnalysis->occursUnder information into a 
//    string list.
// 2. If the above list from occursUnder is not empty, call a new function
//     named with these input parameters:
//     ThisMarkerMustRelocateBeforeOfAfterAdjacentMarker(
//			saveNextPos, filterableMarkers)
//     This above mentioned function returns the SPList::Node* pointer to 
//     a pList position tempPos which, if non-NULL, points to the position 
//     in pList to insert the current pSublist.
//     This function scans backwards through pList checking previous source 
//     phrases for any "filterable" begin markers that satisfy these 
//     conditions:
//     a. A found marker must be "filterable", i.e., its 
//        pUsfmAnalysis->userCanSetFilter == TRUE.
//     b. It is an "adjacent" marker, that is, no non-marker text occurs
//        between the curent marker and the text assoicated with the
//        candidate marker.
// 3. If the ThisMarkerMustRelocateBeforeOfAfterAdjacentMarker()
//    function locates and returns a non-NULL pointer to the position of a 
//    source phrase (in pList) matching the conditions in 2 above, we then 
//    check to see if any of the filterableMarkersArr markers are present
//    within the currently being-unfiltered-marker's occursUnder list. 
// 4. If the adjacent marker is present within the occursUnder list, we
//    know we can asign our insertPos to be that returned position - the
//    position at which point we start inserting the source phrases of our 
//    pSublist that represent the unfiltered text being inserted into the 
//    document's pList of source phrases. If a tempPos is non-NULL, the 
//    third parameter filterableMarkersArr array will contain any potential
//    markers to check if present in the occursUnder string list.
// TODO: Update above comments
// whm 10Nov2023 added the following to aid in insertion of marker-being-unfiltered into pList
// when a previous adjacent marker must occur under the current marker-being-unfiltered.
bool CAdapt_ItDoc::ThisMarkerMustRelocateBeforeOfAfterAdjacentMarker(SPList::Node* currPos, 
	SPList::Node*& prevPos, wxString occursUnderStr)
{
	SPList::Node* currentPos = currPos; // use local node pointer
	wxArrayString filterableMkrsArr;
	filterableMkrsArr.Clear(); // initialize
	if (currentPos == NULL)
	{
		prevPos = NULL;
		return FALSE;
	}
	// The incoming parameter Node* pointer currPos is a pointer to a position in the pList.
	// That currPos pointer is actually the saveNextPos back in the caller, i.e., the position
	// of the source phrase FOLLOWING the source phrase containing the filtered marker that's 
	// currently being unfiltered. Therefore we need to start scanning backwards one (two???) 
	// position prior to that saveNextPos position for eligible markers in pList. 
	// TODO: If need to start scanning two positions prior uncomment the second block below.
	if (currentPos != NULL)
	{
		currentPos = currentPos->GetPrevious(); // Backup one to get the current position.
	}
	//if (currPos != NULL)
	//{
	//	currPos = currPos->GetPrevious(); // Backup one more to get previous position before the current one.
	//}
	bool bKeepSearching = TRUE;
	while (currentPos != NULL && bKeepSearching)
	{
		CSourcePhrase* ptempSP = currentPos->GetData();
		if (ptempSP != NULL)
		{
			// Examine ptempSP's m_markers and m_filteredInfo members. 
			if (ptempSP->m_markers.IsEmpty() && ptempSP->GetFilteredInfo().IsEmpty())
			{
				currentPos = currentPos->GetPrevious();
			}
			else
			{
				// There is content in m_markers and/or m_filteredInfo, so collect any
				// content present into a filterableMkrs array to make it easier to 
				// examine the markers one-by-one to see if they are present within the
				// occursUnderStr string of the current marker.
				// If a marker is present in occursUnderStr we return TRUE to the caller
				// ReconstituteAfterFilteringChange(), and return its pList node position 
				// in the prePos reference parameter.
				// We can combine any m_markers and m_filteredInfo strings together, since
				// the GetFilteredAndSweptUpMarkersFromString() function called below internally
				// calls the GetMarkersAndEndMarkersFromString() function which knows how to
				// deal with any \~FILTER ... \~FILTER* markers that may be enclosing a
				// candidate marker within the previous marker's m_filteredInfo member.
				// Our GetFilteredAndSweptUpMarkersFromString() function ensures that the return
				// filterableMkrs array only contains whole markers, and not any 
				// associated text that would be present together with a marker enclosed
				// within \~FILTER ...\~FILTER* markers.
				wxArrayString filteredMkrsArray;
				filteredMkrsArray.Clear(); // need to start each location check with empty array
				wxArrayString filteredMkrsArrayWithFilterBrackets;
				filteredMkrsArrayWithFilterBrackets.Clear();
				bool bInsertAtThisPos = FALSE;
				wxString markerStr = ptempSP->m_markers + ptempSP->GetFilteredInfo();
				GetFilteredAndSweptUpMarkersFromString(markerStr, filteredMkrsArrayWithFilterBrackets, filteredMkrsArray);
				size_t fm_ct = filteredMkrsArray.GetCount();
				wxString mkrToCheck;
				if (fm_ct > 0)
				{
					for (int i = 0; i < (int)fm_ct; i++)
					{
						mkrToCheck = filteredMkrsArray.Item(i);
						if (occursUnderStr.Find(mkrToCheck) != wxNOT_FOUND)
						{
							bInsertAtThisPos = TRUE;
						}
					}
					if (bInsertAtThisPos == TRUE)
					{
						bKeepSearching = FALSE;
						prevPos = currentPos; //return currPos;
						return TRUE;
					}
				}
				currentPos = currentPos->GetPrevious();
			}
		}
		else
		{
			bKeepSearching = FALSE;
		}
	}
	prevPos = NULL;
	return FALSE;
}
*/

/*
// This function is currently unused but saved for possible future use
// whm 26Nov2023 added the following function to aid in insertion of 
// the marker-being-unfiltered into pList.
// This function returns a list of any adjacent markers before and after 
// the input mkr and indicates the filter status of those markers
// The input parameters are:
//	wxString mkr - the marker being unfiltered
//	wxString ChVs - the chapter:verse context where the current pSrcPhrase is located
//	wxArrayString m_UsfmStructArr - the m_UsfmStructArr array that is on the Doc
// This function does the following:
// 1. Locates the marker-being-unfiltered (mkr) within the m_UsfmStructArr array
// 2. To narrow down its search it first locates the chapter:verse reference using
//    the context indicated by the ChVs incoming parameter.
// 3. Once the marker is located within the array, this function determines if
//    the marker mkr is adjacent to other markers, occurring before the mkr and
//    after the mkr. 
// 4. Adjacent markers are returned in a string of the form:
//    mkrBefore1:n:mkrBefore2:n@mkr@mkrAfter1:n:mkrAfter2:n
// 	  where the mkr itself is delimited by @ chars before and after
//    where the found markers are delimited by colons, and n is the filter status 1 or 0. 
// 5. The filter starus of each marker returned in 4 above is contained in a string
//    called filterStatusStr which contains a 0 or 1 for each marker concatenated together
//    into a string with the status of the marker mkr delimited by @, so the form of the
//    filterStatusStr is: "0001@1@1100" or "100@1@0" etc. 
wxString CAdapt_ItDoc::GetAdjacentUsfmMarkersAndTheirFilterStatus(wxString mkr, wxString ChVs, 
	wxArrayString m_UsfmStructArr, wxString& filterStatusStr, wxString& filterableMkrStr)
{
	wxString adjacentMkrStr;
	adjacentMkrStr.Empty();
	wxString sStatStr; 
	sStatStr.Empty();
	wxASSERT(!mkr.IsEmpty());
	wxString ch, vs;
	bool bNoColonInRef = FALSE;
	wxString colon = _T(":");
	if (!ChVs.IsEmpty())
	{
		int posColon = ChVs.Find(colon);
		if (posColon != wxNOT_FOUND)
		{
			ch = ChVs.Mid(0, posColon);
			vs = ChVs.Mid(posColon + 1);
		}
		else
		{
			// no colon in ch:vs so assume its just a ch number
			bNoColonInRef = TRUE;
			ch = ChVs;
		}
	}
	// Lines in the m_UsfmStructARR array are of the form:
	// \mkr:numChars:0
	// \mkr:numChars:1
	// \c n:numChars:0
	// \v nn:numChars:0
	// where:
	//   the marker (and any chapter or verse number) is the first field (before 1st colon)
	//   the numChars field is a number representing the character count of the marker and its assoc text
	//   the 0 or 1 is the filter status of the marker

	int totLines = 0;
	totLines = (int)m_UsfmStructArr.GetCount();
	wxString arrLine;
	wxString marker;
	wxString numChars;
	wxString filterStatus;
	int lineIndex = 0;
	wxString chapter = _T("\\c ") + ch;
	wxString verse = _T("\\v ") + vs;
	// Scan the m_UsfmStructArr array to find the ch:vs reference specified in the incoming parameter ChVs
	bool bRefFound = FALSE;
	bool bMkrFound = FALSE;
	bool bChFound = FALSE;
	bool bVsFound = FALSE;
	while (lineIndex < totLines && !bRefFound)
	{
		arrLine = m_UsfmStructArr.Item(lineIndex);
		ParseUsfmStructLine(arrLine, marker, numChars, filterStatus);
		if (marker.Find(chapter) != wxNOT_FOUND)
		{
			bChFound = TRUE;
		}
		if (bChFound && marker.Find(verse) != wxNOT_FOUND)
		{
			bVsFound = TRUE;
		}
		if (bChFound && bVsFound)
		{
			bRefFound = TRUE;
		}
		lineIndex++;
	}
	if (bRefFound || (!bRefFound && bChFound))
	{
		// We found a ch:vs reference, or at least a ch without a verse to narrow down
		// our search context.
		// Now continue searching from lineNum to locate the marker we're wanting to use
		// as the starting point for collecting any filterable markers that are following
		// that marker and adjacent to it. Being adjacent means there are no non-filterable
		// markers such as chapter or verse numbers.
		// Note: lineNum is now pointing to the line following the ch:vs reference
		while (lineIndex < totLines && !bMkrFound)
		{
			arrLine = m_UsfmStructArr.Item(lineIndex);
			ParseUsfmStructLine(arrLine, marker, numChars, filterStatus);
			if (marker == mkr)
			{
				bMkrFound = TRUE;
				break;
			}
			lineIndex++;
		}
		if (bMkrFound)
		{
			// The lineIndex now points at the array line containing the marker.
			// We will extract up to 5 lines before the marker and up to 5 lines after the marker
			// and examine them for adjacent markers. The number of lines extracted before and 
			// after the @mkr...@ can be less than 5 if the mkr being unfiltered is closer than 5
			// lines to the first line in the array, or to the last line in the array.
			adjacentMkrStr = _T("@") + marker + colon + numChars + colon + filterStatus +_T("@");
			sStatStr = _T("@") + filterStatus + _T("@");
			USFMAnalysis* pUsfmAnalysis;
			bool bUserCSF = FALSE;
			int nUserCSF = 0;
			wxString userCSF;
			userCSF.Empty();
			wxString bareMarker; 
			bareMarker.Empty();
			bareMarker = GetBareMarkerForLookup(marker);
			pUsfmAnalysis = LookupSFM(bareMarker);
			if (pUsfmAnalysis != NULL)
			{
				bUserCSF = pUsfmAnalysis->userCanSetFilter;
				nUserCSF = (int)bUserCSF;
				userCSF << nUserCSF;
				filterableMkrStr = _T("@") + userCSF + _T("@");
			}
			else
			{
				// marker must be an unknown marker, assume it is filterable i.e., userCanSetFilter is TRUE
				filterableMkrStr = _T("@1@");

			}
			wxString m;
			wxString c;
			wxString f;
			int nBefore = 5;
			int nAfter = 5;
			int tempLineIndex = lineIndex - 1; // don't include the marker line itself
			while (tempLineIndex >= 0 && nBefore > 0)
			{
				// Accumulate lines working backwards accumulating up to 5 lines before the marker
				arrLine = m_UsfmStructArr.Item(tempLineIndex);
				ParseUsfmStructLine(arrLine, m, c, f);
				bUserCSF = FALSE;
				nUserCSF = 0;
				userCSF.Empty();
				bareMarker.Empty();
				bareMarker = GetBareMarkerForLookup(m);
				pUsfmAnalysis = LookupSFM(bareMarker);
				if (pUsfmAnalysis != NULL)
				{
					bUserCSF = pUsfmAnalysis->userCanSetFilter;
					nUserCSF = (int)bUserCSF;
					userCSF << nUserCSF;
					filterableMkrStr = userCSF + filterableMkrStr;
				}
				else
				{
					// marker m must be an unknown marker, assume it is filterable i.e., userCanSetFilter is TRUE
					filterableMkrStr = _T("1") + filterableMkrStr;
				}
				adjacentMkrStr = arrLine + adjacentMkrStr;
				sStatStr = f + sStatStr;
				tempLineIndex--;
				nBefore--;
			}
			tempLineIndex = lineIndex + 1; // don't include the marker line itself
			while (tempLineIndex < totLines && nAfter > 0)
			{
				// Accumulate lines working forwards accumulating up to 5 lines after the marker.
				arrLine = m_UsfmStructArr.Item(tempLineIndex);
				ParseUsfmStructLine(arrLine, m, c, f);
				bUserCSF = FALSE;
				nUserCSF = 0;
				userCSF.Empty();
				bareMarker.Empty();
				bareMarker = GetBareMarkerForLookup(m);
				pUsfmAnalysis = LookupSFM(bareMarker);
				if (pUsfmAnalysis != NULL)
				{
					bUserCSF = pUsfmAnalysis->userCanSetFilter;
					nUserCSF = (int)bUserCSF;
					userCSF << nUserCSF;
					filterableMkrStr = filterableMkrStr + userCSF;
				}
				else
				{
					// marker m must be an unknown marker, assume it is filterable i.e., userCanSetFilter is TRUE
					filterableMkrStr = filterableMkrStr + _T("1");
				}
				adjacentMkrStr = adjacentMkrStr + arrLine;
				sStatStr = sStatStr + f;
				tempLineIndex++;
				nAfter--;
			}
			int dummyDebug = 1; wxUnusedVar(dummyDebug);
		}
	}
	filterStatusStr = sStatStr;
	return adjacentMkrStr;
}
*/

// This function parses a line from the m_USfmStructArr array into its components delimited by colon chars.
// This function is used within the ReorderFilterMaterialUsingUsfmStructData() function
void CAdapt_ItDoc::ParseUsfmStructLine(wxString line, wxString& mkr, wxString& numChars, wxString& filterStatus)
{
	// Lines in the m_UsfmStructArr array have 3 fields delimited by 2 colons, and so are of the form:
	// \mkr:numChars:0
	// \mkr:numChars:1
	// \c n:numChars:0
	// \v nn:numChars:0
	// where:
	//   The marker \mkr (and any chapter or verse number) is the marker field (before 1st colon) with
	//     initial backslash, but no following space. \c and \v markers have following space + number.
	//   The numChars field is a number representing the character count of the marker and its assoc text
	//   The 0 or 1 is the filter status of the marker.
	mkr.Empty();
	numChars.Empty();
	filterStatus.Empty();
	wxString colon = _T(":");
	int posColon = -1;
	wxString remainderStr;
	posColon = line.Find(colon);
	if (posColon != wxNOT_FOUND)
	{
		mkr = line.Mid(0, posColon);
		mkr.Trim(FALSE);
		mkr.Trim(TRUE);
		wxASSERT(!mkr.IsEmpty());
		remainderStr = line.Mid(posColon + 1);
		posColon = remainderStr.Find(colon);
		if (posColon != wxNOT_FOUND)
		{
			numChars = remainderStr.Mid(0, posColon);
			numChars.Trim(FALSE);
			numChars.Trim(TRUE);
			wxASSERT(!numChars.IsEmpty());
			remainderStr = remainderStr.Mid(posColon + 1);
			filterStatus = remainderStr;
			filterStatus.Trim(FALSE);
			filterStatus.Trim(TRUE);
			wxASSERT(!filterStatus.IsEmpty());
		}
	}
}

// whm 16Nov2023 added for support of the .usfmstruct file and the doc's m_UsfmStructArr array.
// This function is used to assign values to the the Doc's variables related to the creation
// and maintenance of the m_usfmStructArr in-memory array and related variables on the Doc, 
// and the external .usfmstruct file that is stored in the .usfmstruct folder, a sub-folder of
// the current project's "Adaptations" folder.
// This function takes as its first parameter an enum value of: createNewFile, recreateExistingFile, 
// openExistingFile, or createFromSPList. 
// The second parameter is a reference parameter inputBuffer which is replaced by an internally
// built string by calling RebuildSourceText() if the first parameter enum is createFromSPList.
// The third parameter is an SPList* pointer to a source phrase list which is also used if the
// first parameter enum is createFromSPList.
//
bool CAdapt_ItDoc::SetupUsfmStructArrayAndFile(enum UsfmStructFileProcess fileProcess, 
	wxString& inputBuffer, SPList* pList)
{
	// whm 13Nov2023 added the following code to create a wxArrayString UsfmStructArr from 
	// the source input *pApp->m_pBuffer text, or alternately from a pList of source phrases
	// and then saves that array of strings to a file named <filename>.usfmstruct that is 
	// saved to a hidden sub-directory at the following path:
	// /Adapt It Unicode Work/<project-directory/Adaptations/.usfmstruct/<filename>.usfmstruct
	// where <filename> is the name of the document file being created via gpApp->m_curOutputPath
	// which already has an .xml extension. We add the additional extension .usfmstruct to 
	// the usfm struct file we're creating.
	// This usfm struct file will get updated with filter status fields in the 
	// UpdateCurrentFilterStatusOfUsfmStructFileAndArray() function call made after TokenizeText() is
	// called later below.

	// Substitute a string generated from RebuildSourceText is the fileProcess is createFromSPList
	if (fileProcess == createFromSPList)
	{
		int textLen;
		textLen = RebuildSourceText(inputBuffer, RebuildFullExportText, pList);
		if (textLen == 0 || inputBuffer.IsEmpty() || pList->IsEmpty())
		{
			// Not likely to happen so an English message is OK.
			wxString msg = _T("RebuildSourceText could not create an inputBuffer.\n\nThis may affect the ability of Adapt It to filter or unfilter adjacent markers in correct sequence.");
			wxMessageBox(msg, _T(""), wxICON_WARNING | wxOK);
			gpApp->LogUserAction(msg);
			return FALSE; // the caller will set m_bUsfmStructEnabled to FALSE to disable usfmStruct processing
		}
	}

	m_usfmStructDirName = _T(".usfmstruct");
	wxFileName structFn(gpApp->m_curOutputPath);
	m_usfmStructFilePath = structFn.GetPath();
	m_usfmStructFileName = structFn.GetFullName(); // gets full name including extension, but excluding directories
	m_usfmStructDirPath = m_usfmStructFilePath + gpApp->PathSeparator + m_usfmStructDirName;
	if (!::wxDirExists(m_usfmStructDirPath))
	{
		// The hidden dir .usfmstruct doesn't exist yet so create it.
		bool bOK;
		bOK = ::wxMkdir(m_usfmStructDirPath);
		if (!bOK)
		{
			// failure to make the directory not expected so English message to the user log is sufficient
			wxString msg = _T("In OnNewDocument() - Failed to Create hidden directory at %s");
			msg = msg.Format(msg, m_usfmStructDirPath.c_str());
			gpApp->LogUserAction(msg);
			return FALSE; // the caller will set m_bUsfmStructEnabled to FALSE to disable usfmStruct processing
		}
	}

	m_usfmStructFilePathAndName = m_usfmStructDirPath + gpApp->PathSeparator + m_usfmStructFileName + m_usfmStructDirName;

	// The wxArrayString m_UsfmStructArr array is on the Doc class, and its contents persist while a doc is open.
	m_UsfmStructArr = GetUsfmStructureAndExtent(inputBuffer, TRUE);
	// Get the wxArrayString's lines and save them in the <filename>.usfmstruct file at:
	// .../Adapt It Unicode Work/<project-directory/Adaptations/.usfmstruct/<filename>.usfmstruct
	m_UsfmStructStringBuffer.Empty();
	size_t len = 0;
	// scan our array and determine its required character length including EOL chars
	int totCt = (int)m_UsfmStructArr.GetCount();
	for (int i = 0; i < totCt; i++)
	{
		m_UsfmStructStringBuffer = m_UsfmStructStringBuffer + m_UsfmStructArr.Item(i) + _T("\r\n");
		len += m_UsfmStructArr.Item(i).Length();
		len += 2; // for the EOLs _T("\r\n") to be added
	}

	if (fileProcess == createNewFile || fileProcess == recreateExistingFile)
	{
		// This block is executed when creating a new document in OnNewDocument() in non-collaboration
		// scenarios, and when creating a new document or opening an existing document in collaboration
		// scenarios.
		// We should ensure the .usfmstruct file doesn't exist because we want to start afresh for a new 
		// usfmstruct file.
		wxLogNull nolog; // avoid spurious messages from the system
		if (::wxFileExists(m_usfmStructFilePathAndName))
		{
			bool bRemoved = FALSE;
			bRemoved = ::wxRemoveFile(m_usfmStructFilePathAndName);
			if (!bRemoved)
			{
				// Not likely to happen, so an English message will suffice.
				wxString msg = _T("Unable to remove existing usfmstruct file at:\n%s");
				msg = msg.Format(msg, m_usfmStructFilePathAndName.c_str());
				gpApp->LogUserAction(msg);
				return FALSE; // the caller will set m_bUsfmStructEnabled to FALSE to disable usfmStruct processing
			}
		}
	}

	if (fileProcess == openExistingFile)
	{
		// The openExistingFile is used when AI is opening an existing file in
		// non-collaboration scenarios.
		// Open and read the .usfmstruct file into the m_UsfmStructArr array
		// so that the array has the doc's usfm structure listed for the life
		// of the open document.
		wxLogNull nolog; // avoid spurious messages from the system
		wxTextFile f(m_usfmStructFilePathAndName);
		bool bOpened = f.Open();
		if (!bOpened)
		{
			wxString msg = _T("Failed f.Open() for reading usfmstruct info to %s");
			msg = msg.Format(msg, m_usfmStructFilePathAndName.c_str());
			gpApp->LogUserAction(msg);
			return FALSE; // the caller will set m_bUsfmStructEnabled to FALSE to disable usfmStruct processing
		}
		else
		{
			// File is open for reading, and we read its contents into the m_UsfmStructArr
			// The Doc's m_UsfmStructArr should be empty
			m_UsfmStructArr.Clear();
			int totLines = f.GetLineCount();
			wxString lineStr;
			// Read each line of text and store it into the m_UsfmStructArr wxArrayString on the Doc
			for (int i = 0; i < totLines; i++)
			{
				lineStr = f.GetLine(i);
				m_UsfmStructArr.Add(lineStr);
			}
			f.Close();
		}
	}
	else // whm when fileProcess == createNewFile or fileProcess == recreateExistingFile
	{
		// Write the usfmstruct string to the .usfmstruct file
		wxLogNull nolog; // avoid spurious messages from the system
		wxFile f;
		if (!f.Open(m_usfmStructFilePathAndName, wxFile::write))
		{
			wxString msg = _T("Failed f.Open() for writing usfmstruct info to %s");
			msg = msg.Format(msg, m_usfmStructFilePathAndName.c_str());
			gpApp->LogUserAction(msg);
			return FALSE; // the caller will set m_bUsfmStructEnabled to FALSE to disable usfmStruct processing
		}
		else
		{
			f.Write(m_UsfmStructStringBuffer, len);
			f.Close();
		}
	}
	return TRUE;
}

// whm 8Feb2024 verified that this function needs no revision for when the filteredStuff
// input into the function contains swept up markers prefixed to one or more of the
// filtered markers enclosed by \~FILTER ...\~FILTER* brackets. It works well whether
// such swept up markers are present or not.
bool CAdapt_ItDoc::FilteredMaterialContainsMoreThanOneItem(wxString filteredStuff)
{
	// Check whether filteredStuff has more than one filtered item.
	// Each filtered item will be enclosed by \~FILTER ...\~FILTER* bracket markers
	// If there are more than one set of filter bracket markers return TRUE,
	// otherwise return FALSE
	wxString filterStr = filteredStuff;
	int posFilterMarker = -1;
	posFilterMarker = filterStr.Find(_T("\\~FILTER ")); // following space in find string uniquely gets the beginning bracket marker
	if (posFilterMarker != wxNOT_FOUND)
	{
		// Found one, remove it and check for another. If there is at least two markers
		// we can return TRUE, otherwise FALSE
		int posFilterEndMarker = -1;
		posFilterEndMarker = filterStr.Find(_T("\\~FILTER*"));
		int len = (int)filterStr.Length();
		if (posFilterEndMarker != wxNOT_FOUND && len > posFilterEndMarker + 9)
		{
			filterStr = filterStr.Mid(posFilterEndMarker + 9);
			if (filterStr.Find(_T("\\~FILTER ")) != wxNOT_FOUND)
			{
				// We found a second "\\~FILTER " substring, so return TRUE
				return TRUE;
			}
		}
	}
	return FALSE;
}

// whm 8Feb2024 added.
// This function gets the filtered info "segments" contained in filterStr.
// The "segments" contain the usual filtered info enclosed by \~FILTER ...\~FILTER*
// brackets. As of this date those "segments" may be prefixed by swept up markers
// that prefix a given segment. For example, now a segment may be comething like:
//   \c 11 \~FILTER \s Jon ta alomwa suni oro lau tan ala atou Jises\~FILTER*
// which has the swept up marker "\\c 11 " prefixing the bracketed filtered material.
wxArrayString CAdapt_ItDoc::GetFilteredInfoSegments(wxString filterStr)
{
	wxArrayString segmentsArr;
	segmentsArr.Clear();
	int posEndFilterBracket = -1;
	wxString remainingStr = filterStr; // start with the whole string
	wxString endFilterBracket = _T("\\~FILTER*");
	int nLenEndnFilterBracket = (int)endFilterBracket.Length();
	posEndFilterBracket = remainingStr.Find(endFilterBracket);
	while (posEndFilterBracket != wxNOT_FOUND)
	{
		wxString tempStr;
		tempStr = remainingStr.Mid(0, posEndFilterBracket + nLenEndnFilterBracket);
		segmentsArr.Add(tempStr);
		remainingStr = remainingStr.Mid(posEndFilterBracket + nLenEndnFilterBracket);
		posEndFilterBracket = remainingStr.Find(endFilterBracket);
	}
	return segmentsArr;
}

// whm 10Nov2023 added and revised 8Feb2024. Gets a list of markers and marker info
// contained in 3 parallel arrays from the input string filterStr.
// The filterStr input string should be one or more filtered strings encased with
// \~FILTER ... \~FILTER* brackets that are concatenated together typically coming
// from a m_filteredInfo member (via GetFilteredInfo() call).
// The filterStr string may have preceding markers occurring BEFORE a given filtered
// string enclosed by the filter brackets. These would be one or more markers which 
// are swept up during the filtering process by ReconstituteAfterFilteringChange(),
// and if existing are NOT enclosed within the following \~FILTER ... \~FILTER* 
// string. Any such swept up markers found are stored within the parallel 
// markersPrecedingFilteredOnes array. Even when no such swept up markers exist
// before a filtered string, the markersPrecedingFilteredOnes array item stores an
// empty string for that situation. This is in order to keep all 3 arrays in
// parallel for use by the caller.
// This function makes a call to GetMarkersAndEndMarkersFromString() which returns
// a wxArrayString of markers via the filteredMkrsArray in its third 
// reference parameter. 
// The filtered marker - including its \~FILTER and \~FILTER* brackets - is 
// returned in the filteredMkrsArrayWithFilterBrackets reference parameter.
// The markersPrecedingFilteredOnes() will contain any swept up markers that
// preceed the filtered marker or empty string for any filtered marker that does
// not have preceding swept up markers.
// The filteredMkrsArray array simply contains augmented whole markers. Note
// that are taken from inside the filtered brackets \~FILTER ...\~FILTER*.
// The filteredMkrsArray array doesn't not contain any of the swept up markers 
// that might preceed the filtered material. They go into the 
// markersPrecedingFilteredOnes array instead.
// All 3 arrays returned by reference from this function should always contain
// the same number of elements and are always in parallel.
// This function is called from the ReorderFilterMaterialUsingUsfmStructData()
// function.
// The input string filterStr is expected to contain filtered markers that are
// concatenated into the whole temMkrs string. The filtered markers will be
// embedded within \~FILTER ... \~FILTER* markers. Some of these may be preceded
// by swept up markers that were placed there by the 
// ReconstituteAfterFilteringChange() function or by TokenizeText() during initial 
// parsing of the document.
// We make a temporary copy of the marker that is embedded within the filter
// brackets \~FILTER ... \~FILTER* and look it up using the LookupSFM() function 
// which returns a pAnalysis struct of that marker. For each marker whose 
// pAnalysis->userCanSetFilter is TRUE the function returns it as an item within
// its returned filteredMkrsArray wxArrayString. The parallel arrays then 
// contains any/all filterable markers (and swept up markers) that were found
// returning the three arrays by reference to the caller.
void CAdapt_ItDoc::GetFilteredAndSweptUpMarkersFromString(wxString filterStr, 
	wxArrayString& markersPrecedingFilteredOnes,
	wxArrayString& filteredMkrsArrayWithFilterBrackets, 
	wxArrayString& filteredMkrsArray)
{
	markersPrecedingFilteredOnes.Clear();
	filteredMkrsArrayWithFilterBrackets.Clear();
	filteredMkrsArray.Clear();

	if (!filterStr.IsEmpty())
	{
		// Collect all marker(s) found in filterStr, check each marker, and 
		// return only those that are "filterable", that is, those whose 
		// pUsfmAnalysis->userCanSetFilter == TRUE.
		wxArrayString MkrList; 
		wxString endMarkers = _T("");
		// Here below is the revised coding as of 8Feb2024.
		// 
		// Populates 3 parallel wxArrayString arrays from the input string tfilterStrempMkrs which
		// contains mainly filtered markers within filter brackets |~FILTER ...\~FILTER*, 
		// and may contain swept up markers preceding those filtered markers. 
		// The markers are maintained to be parallel wxArrayString arrays.
		// The filterStr string might look something like this (broken up into one filtered 
		// segment per line for easier reading):
		// \~FILTER \ms Jises, iy are lau handru?\~FILTER*
		// \~FILTER \mr (Kalan 11:1-16:20)\~FILTER*
		// \c 11 \~FILTER \s Jon ta alomwa suni oro lau tan ala atou Jises\~FILTER*
		// \~FILTER \r (Luk 7:18-35)\~FILTER*
		//int nLen = filterStr.Length();
		// Break up the filterStr string into filter segments with any swept up markers
		// remaining at the beginning of each filtered segment
		wxString beginFilterBracket = _T("\\~FILTER");
		int posBeginFilterBracket = -1;
		wxString tempFilteredStr;
		wxString tempPreFilteredMkrs;
		wxArrayString segmentsArr;
		// Get the filterStr's filtered "segments". A given segment may now have a swept up
		// marker like \c 11 prefixing the bracketed filtered material.
		segmentsArr = GetFilteredInfoSegments(filterStr);
		int totSegments = (int)segmentsArr.GetCount();

		for (int i = 0; i < totSegments; i++)
		{
			wxString sweptUpStuff;
			tempFilteredStr = segmentsArr.Item(i);
			posBeginFilterBracket = tempFilteredStr.Find(beginFilterBracket);
			if (posBeginFilterBracket > 0)
			{
				// Get any sweptUpStuff from the tempFilteredStr - the stuff BEFORE the beginFilterBracket
				sweptUpStuff = tempFilteredStr.Mid(0, posBeginFilterBracket);
			}
			else
				sweptUpStuff = wxEmptyString;
			markersPrecedingFilteredOnes.Add(sweptUpStuff);
			wxString filteredStrMinusSweptUpStuff;
			filteredStrMinusSweptUpStuff.Empty();
			if (!sweptUpStuff.IsEmpty())
			{
				// There was some sweptUpStuff so remove it then store actual filtered material
				int lenSUS = (int)sweptUpStuff.Length();
				filteredStrMinusSweptUpStuff = tempFilteredStr.Mid(lenSUS);
				filteredMkrsArrayWithFilterBrackets.Add(filteredStrMinusSweptUpStuff);
			}
			else
			{
				// There was no sweptUpStuff so just store the actual filtered material
				filteredMkrsArrayWithFilterBrackets.Add(tempFilteredStr);
				filteredStrMinusSweptUpStuff = tempFilteredStr;
			}
			// Now populate the filteredMkrsArray with just the marker from inside the filtered material
			// now stored in filteredStrMinusSweptUpStuff
			wxString mkr; mkr.Empty();
			mkr = GetMarkerFromWithinOneFilteredString(filteredStrMinusSweptUpStuff);
			filteredMkrsArray.Add(mkr);
		}
		int nCount1 = (int)markersPrecedingFilteredOnes.GetCount();
		int nCount2 = (int)filteredMkrsArrayWithFilterBrackets.GetCount();
		int nCount3 = (int)filteredMkrsArray.GetCount();
		wxASSERT(nCount1 == nCount2);
		wxASSERT(nCount2 == nCount3);
		int break_here = 1; wxUnusedVar(break_here);
	}
}

// whm 8Feb2024 added. 
// This function gets the marker that is after the augmented begin filter bracket  "\\~FILTER "
// inside the input filteredMkrString that represents ONE filtered string enclosed by 
// \~FILTER ...\~FILTER* markers.
// Note: There should not be any prefixed swept up markers on filteredMkrString.
// This function is called from: GetFilteredAndSweptUpMarkersFromString()
wxString CAdapt_ItDoc::GetMarkerFromWithinOneFilteredString(wxString filteredMkrString)
{
	wxString tempStr = filteredMkrString;
	wxString augBeginFilterBracket = _T("\\~FILTER ");
	wxString backslash = _T("\\");
	wxString space = _T(" ");
	int posFilterBeginBracket = (int)tempStr.Find(augBeginFilterBracket);
	if (posFilterBeginBracket != wxNOT_FOUND)
	{
		tempStr = tempStr.Mid(posFilterBeginBracket + augBeginFilterBracket.Length());
		int posBackslash = tempStr.Find(backslash);
		wxString bareMkr = tempStr.Mid(posBackslash + 1);
		int posSpace = bareMkr.Find(space);
		bareMkr = bareMkr.Mid(0, posSpace);
		// Add the backslash and space back to the bare marker
		tempStr = backslash + bareMkr;
	}
	return tempStr;
}

// whm 10Feb2024 added for use in the TokenizeText() function.
// This function is called when ptr is pointing at some whitespace in the input
// text. It looks forward in the input text to see if the next filterable marker
// that occurs in the text is currently designated to be filtered. 
// If the next marker following the whitespace is a \c n or \v n marker the
// scanning continues over any whitespace until either non-marker text is encountered
// or a following marker. If that following marker is one to be filtered, then
// all the stuff scanned/parsed up to the found marker-to-be-filtered is parsed over
// and returned in the wxString sweptUpStuff reference parameter, and the length
// of the parsed over material is returned in the reference parameter nLenSweptUpStuff,
// and the function returns TRUE value.
// Any non-marker text word(s) encountered - or pEnd - in the forward scanning 
// halts the scanning and returns a FALSE value with empty reference parameters. 
// Since markers like \c n, \v n, \p, etc, are non-filterable, this function 
// parses over them in its search for a following marker to be filtered, and includes
// any \c n or \v n markers within the returned sweptUpStuff.
// Getting any existing swept up stuff put into m_filteredInfo, with it prefixed 
// to its following filtered and bracketed marker is important to the 
// RebuildSourceText() function.
// Note: While parsin and iterating ptr to check for a following marker to be filtered,
// we may encounter spurious periods that follow an empty marker such as \p ... etc.
// Hence, we need to build any sweptUpStuff piecemeal to allow for skipping of such
// spurious periods.
bool CAdapt_ItDoc::IsNextFilterableMkrToBeFiltered(wxChar* ptr, wxChar* 
	pEnd, wxString& sweptUpStuff, int& nLenSweptUpStuff)
{
	bool bFoundMkrToBeFiltered = FALSE;
	wxChar* pAux = ptr;
	int lenSweptStuff = 0;
	wxString tempSweptUpMaterial; tempSweptUpMaterial.Empty();
	wxString tempStr; tempStr.Empty();
	// When this function is called in TokenizeText() ptr should be pointing
	// at whitespace, so we'll parse the whitespace.
	while (pAux <= pEnd)
	{
		int wsLen = 0;
		wsLen = ParseWhiteSpace(pAux);
		lenSweptStuff += wsLen;
		// build the sweptUpStuff we've parsed over so far
		AppendItem(tempSweptUpMaterial, tempStr, pAux, wsLen);
		pAux += wsLen;
		int ctVerse = 0; // unused here
		if (IsChapterMarker(pAux) || IsVerseMarker(pAux, ctVerse))
		{
			int lenChVs = 0;
			lenChVs = ParseMarker(pAux);
			lenSweptStuff += lenChVs;
			AppendItem(tempSweptUpMaterial, tempStr, pAux, lenChVs);
			pAux += lenChVs;
			lenChVs = ParseWhiteSpace(pAux);
			lenSweptStuff += lenChVs;
			AppendItem(tempSweptUpMaterial, tempStr, pAux, lenChVs);
			pAux += lenChVs;
			// parse the following number and increment
			lenChVs = ParseNumber(pAux);
			lenSweptStuff += lenChVs;
			AppendItem(tempSweptUpMaterial, tempStr, pAux, lenChVs);
			pAux += lenChVs;
			// A chapter or verse marker is probably followed by whitespace so parse that too
			lenChVs = ParseWhiteSpace(pAux);
			lenSweptStuff += lenChVs;
			AppendItem(tempSweptUpMaterial, tempStr, pAux, lenChVs);
			pAux += lenChVs;
		}
		else if (IsMarker(pAux))
		{
			int lenMkr = 0;
			lenMkr = ParseMarker(pAux);
			// Don't increment lenSweptStuff here, but below in the while loop
			// We don't know if this marker will be stored in tempSweptUpMaterial until we
			// determine that both of these conditions are TRUE:
			// 1. It IS NOT a marker-to-be-filtered, and 
			// 2. It IS an empty marker
			// Hence, we delay the AppendItem(tempSweptUpMaterial, tempStr, pAux, lenSweptStuff) 
			// call to the IsEmptyMkr() TRUE block below.
			wxString augWholeMkr = wxString(pAux, lenMkr);
			augWholeMkr += _T(" ");
			if (gpApp->gCurrentFilterMarkers.Find(augWholeMkr) != wxNOT_FOUND)
			{
				// The marker we're pointing at is a marker designated to be filtered
				// We don't parse it here but the caller will do it; here we just set
				// the return bool to TRUE.
				bFoundMkrToBeFiltered = TRUE;
				// This marker is NOT to be included within the swept up material. Instead
				// the caller will deal with filtering it.
				break; // No need to go further beyond this marker
			}
			else
			{
				// pAux is pointing at some kind of not-to-be filtered marker and NOT at 
				// whitespace at this point.
				// There could be one or more contentless markers preceding a marker
				// currently being filtered. If so they should also be swept up here.
				bool bHasBogusPeriods = FALSE;
				int nWhitesLenIncludingBogusPeriods = 0;
				int nPeriodsInWhitesLen = 0;
				int accumItemLen = 0; // accumulate item len value for pass through while loop
				//wxString tempSweptUpMaterial; tempSweptUpMaterial.Empty();
				wxChar* tempAux = pAux; // preserve pAux for use after the while loop below
				bool bIsEmptyMkr = IsEmptyMkr(tempAux, pEnd, bHasBogusPeriods, nWhitesLenIncludingBogusPeriods, nPeriodsInWhitesLen);
				while (bIsEmptyMkr && tempAux < pEnd)
				{
					// We parsed the marker intially above to get an augWholeMkr value
					// but we didn't increment pAux or lenSweptStuff there. Since we are now
					// within a while loop, parse the marker again here and this time we
					// increment pAux, lenSweptStuff, and add any tempSweptUpMaterial.
					int onePassItemLen = 0;
					onePassItemLen = ParseMarker(tempAux);
					// Append the marker to the tempSweptUpMaterial
					AppendItem(tempSweptUpMaterial, tempStr, tempAux, onePassItemLen);
					wxString augWholeMkr = wxString(tempAux, onePassItemLen);
					augWholeMkr += _T(" ");
					tempAux += onePassItemLen;
					// A contentless marker could be a marker like \p \m and other markers
					// that are not followed by non-marker text. These will be part of any
					// swept up material, but only as long as they are actually followed by
					// a marker that is currently being filtered - otherwise TokenizeText()
					// will put them into the current source phrase's m_markers member.
					// Deal with any spurious periods 
					if (bHasBogusPeriods)
					{
						// There is likely a space between the marker and the bogus periods.
						// We should NOT include this space and NOT include the periods within
						// the tempSweepUpMaterial. However, we add the length of the space
						// to the onPassItemLen
						int whiteSpLen = ParseWhiteSpace(tempAux);
						// Here we don't append the whitespace to tempSweptUpMaterial
						tempAux += whiteSpLen;
						onePassItemLen += whiteSpLen;
						int nPeriods = 0;
						IteratePtrPastBogusPeriods(tempAux, pEnd, nPeriods); // iterates pAux but not lenSweptStuff
						// Since we are returning to the caller a value for nLenSweptUpStuff which
						// needs to include the length of the periods, even though the actual
						// periods are not included within our returned value for sweptUpStuff.
						// The caller may use the nLenSweptUpStuff to move its ptr value past
						// the sweptUpStuff and periods too. So in this case
						onePassItemLen += nPeriods;
						whiteSpLen = ParseWhiteSpace(tempAux); // this whitespace we add to tempSweptUpMaterial.
						AppendItem(tempSweptUpMaterial, tempStr, tempAux, whiteSpLen);
						tempAux += whiteSpLen;
						onePassItemLen += whiteSpLen;
					}
					else
					{
						int whiteSpLen = ParseWhiteSpace(tempAux);
						// Append the whitespace to the tempSweptUpMaterial
						AppendItem(tempSweptUpMaterial, tempStr, tempAux, whiteSpLen);
						tempAux += whiteSpLen;
						onePassItemLen += whiteSpLen;
					}
					// Is this marker one to be filtered? If so we're done. If not we continue
					// with the while loop iteration.
					if (gpApp->gCurrentFilterMarkers.Find(augWholeMkr) != wxNOT_FOUND)
					{
						// The marker we're pointing at is a marker designated to be filtered
						// We don't parse it here but the caller will do it; here we just set
						// the return bool to TRUE.
						bFoundMkrToBeFiltered = TRUE;
						// This marker is NOT to be included within the swept up material. Instead
						// the caller will deal with filtering it.
						break; // No need to go further beyond this marker
					}
					// If we get here the augWholeMkr above was not to be filtered, so we 
					// continue to iterate
					// The pAux pointer is now pointing past any whitespace that followed
					// the augWholeMkr above - could be another marker or non-marker text.
					accumItemLen += onePassItemLen;
					bIsEmptyMkr = IsEmptyMkr(tempAux, pEnd, bHasBogusPeriods, nWhitesLenIncludingBogusPeriods, nPeriodsInWhitesLen);
				} // end of while (IsEmptyMkr(tempAux, pEnd, bHasBogusPeriods, nWhitesLenIncludingBogusPeriods, nPeriodsInWhitesLen))
				int mkrLen = ParseMarker(tempAux); // The marker at tempAux is not empty, so we don't add it to the tempSweptUpMaterial
				wxString augmkr = wxString(tempAux, mkrLen);
				augmkr += _T(" ");
				if (gpApp->gCurrentFilterMarkers.Find(augmkr) != wxNOT_FOUND)
				{
					bFoundMkrToBeFiltered = TRUE;
					pAux += accumItemLen; // move pAux to point past the marker at tempAux
					lenSweptStuff += accumItemLen; // add the accumItemLen but not the mkrLen
					break; // since the marker at tempAux is not an empty marker we can break out of the while loop

				}
				else
				{
					pAux += accumItemLen; // move pAux to point past the marker at tempAux
					lenSweptStuff += accumItemLen; // add the accumItemLen but not the mkrLen
					break; 
				}
			}
		}
		else
		{
			// what follows the whitespace is non-marker material so just return FALSE
			bFoundMkrToBeFiltered = FALSE;
			return FALSE;
		}
	} // end of while (pAux <= pEnd)

	if (bFoundMkrToBeFiltered)
	{
		sweptUpStuff = tempSweptUpMaterial; // does NOT include any bogus periods found in the swept up material
		nLenSweptUpStuff = lenSweptStuff; // includes the length of any bogus periods found in the swept up material
		// Note: It is up to the caller in TokenizeText() to advance ptr past the tempSweptUpMaterial
		// by using the returned nLenSweptUpStuff
	}

	return 	bFoundMkrToBeFiltered;
}

void CAdapt_ItDoc::RestoreCurrentDocVersion()
{
	m_docVersionCurrent = (int)VERSION_NUMBER; // VERSION_NUMBER is #defined in AdaptitConstants.h
}

void CAdapt_ItDoc::SetDocVersion(int index)
{
	switch (index)
	{
	default: // default to the current doc version number, fall thru
	{
	}
	case 0:
	{
		m_docVersionCurrent = (int)VERSION_NUMBER; // currently #defined as 9 in AdaptitConstant.h
		break;
	}
	case 1:
	{
		m_docVersionCurrent = (int)DOCVERSION4;  // #defined as 4 in AdaptitConstants.h
		break;
	}
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return a CBString composed of settings info formatted as XML.
/// \param	nTabLevel	-> defines how many indenting tab characters are placed before each
///			               constructed XML line; 1 gives one tab, 2 gives two, etc.
/// Called by the Doc's BackupDocument(), DoFileSave(), and DoTransformedDocFileSave()
/// functions. Creates a CBString that contains the XML prologue and settings information
/// formatted as XML.
/// BEW 27Feb12, added the ftsbp attribute to store the m_bDefineFreeTransByPunctuation
/// boolean value, as per the user's last choice for "Verse" or "Punctuation" sectioning
/// prior to the last save of the doc in the current session
///////////////////////////////////////////////////////////////////////////////

CBString CAdapt_ItDoc::ConstructSettingsInfoAsXML(int nTabLevel)
{
	CBString	bstr;  bstr.Empty();
	CBString	btemp;
	int			i, commitCount;
	wxString	tempStr;
	// wx note: the wx version in Unicode build refuses to assign a CBString to char
	// numStr[24] so I'll declare numStr as a CBString also
	CBString	numStr; //char numStr[24];

#ifdef _UNICODE

	// first line -- element name and 4 attributes
	for (i = 0; i < nTabLevel; i++)
	{
		bstr += "\t"; // tab the start of the line
	}
	bstr += "<Settings docVersion=\"";
	// wx note: The itoa() operator is Microsoft specific and not standard; unknown to g++
	// on Linux/Mac. The wxSprintf() statement below in Unicode build won't accept CBString
	// or char numStr[24] for first parameter, therefore, I'll simply do the int to string
	// conversion in UTF-16 with wxString's overloaded insertion operatior << then convert
	// to UTF-8 with Bruce's Convert16to8() method. [We could also do it here directly with
	// wxWidgets' conversion macros rather than calling Convert16to8() - see the
	// Convert16to8() function in the App.]
	tempStr.Empty();
	// BEW 19Apr10, changed next line for support of Save As... command
	tempStr << GetCurrentDocVersion(); // tempStr is UTF-16
	numStr = gpApp->Convert16to8(tempStr);
	bstr += numStr; // add versionable schema number string

	// BEW 9Aug12 addition: support saving the content of wxString m_bookName_Current, it
	// could be empty, or some book name from the Paratext list, or a custom user-defined
	// name (possibly in a vernacular); this addition is part of the docVersion7 additions
	tempStr = gpApp->m_bookName_Current; // could be an empty string
	btemp = gpApp->Convert16to8(tempStr);
	InsertEntities(btemp); // escape any xml metacharacters
	bstr += "\" bookName=\"";
	bstr += btemp; // add the book name
	tempStr.Empty();

	// mrh - new fields with docVersion 7:
	btemp = gpApp->Convert16to8(gpApp->m_owner);
	InsertEntities(btemp);				// ensure any XML metacharacters in the owner name are escaped properly
	bstr += "\" owner=\"";
	bstr += btemp; // add owner name

	tempStr.Empty();
	commitCount = gpApp->m_commitCount;
	if (commitCount < 0)
		tempStr << NOOWNER;				// this doc isn't under version control
	else
		tempStr << commitCount;			// this many commits have been done
	numStr = gpApp->Convert16to8(tempStr);

	bstr += "\" ";
	bstr += xml_commitcnt;
	bstr += "=\"";
	bstr += numStr;						// add the commit count

	if (gpApp->m_versionDate.IsValid())
		numStr = gpApp->Convert16to8(gpApp->m_versionDate.Format(_T("%Y-%m-%d %H:%M:%S")));
	// %T gives an error on Windows, so we have to spell it out!
	else
		numStr = "";
	bstr += "\" revdate=\"";
	bstr += numStr;	// add revision date, empty if we don't have one

// mrh - new field with docVersion 8 - we save m_nActiveSequNum:
	tempStr.Empty();
	tempStr << gpApp->m_nActiveSequNum;	// "<<" handles num->wxString conversion
	numStr = gpApp->Convert16to8(tempStr);

	bstr += "\" ";
	bstr += xml_activeSequNum;
	bstr += "=\"";
	bstr += numStr;						// add the active sequence number

// now we add the doc's width and height - currently I don't think we use these on input, but may sometime.
	tempStr.Empty();
	tempStr << gpApp->m_docSize.x;
	numStr = gpApp->Convert16to8(tempStr);

	bstr += "\" ";
	bstr += xml_sizex;
	bstr += "=\"";
	bstr += numStr;						// add the doc width

	tempStr.Empty();
	tempStr << gpApp->m_docSize.y;
	numStr = gpApp->Convert16to8(tempStr);

	bstr += "\" ";
	bstr += xml_sizey;
	bstr += "=\"";
	bstr += numStr;						// add the doc height

	// BEW added 27Feb12, for docV6 support; but if m_bLegacyDocVersionForSaveAs is TRUE,
	// then skip this docV6 attribute's construction
	if (!m_bLegacyDocVersionForSaveAs)
	{
		// we aren't constructing a docV4 legacy document from a File / SaveAs... user choice
		tempStr.Empty(); // needs to start empty, otherwise << will append the string value of the int
		// BEW 20Oct14, if force verse sectioning is currently on, then ensure that
		// 'verse' sectioning is in effect at doc save time
		if (gpApp->m_bForceVerseSectioning)
		{
			// get m_bDefineFreeTransByPunction forced to value FALSE, and radio buttons
			// synced to that value if free trans mode is in effect currently
			gpApp->GetFreeTrans()->ForceVerseSectioning();
		}
		if (gpApp->m_bDefineFreeTransByPunctuation)
		{
			tempStr << (int)1;
		}
		else
		{
			tempStr << (int)0;
		}
		bstr += "\" ftsbp=\"";
		numStr = gpApp->Convert16to8(tempStr);
		bstr += numStr;
	}

	bstr += "\" specialcolor=\"";
	tempStr.Empty(); // needs to start empty, otherwise << will append the string value of the int
	tempStr << WxColour2Int(gpApp->m_specialTextColor);
	numStr = gpApp->Convert16to8(tempStr);
	bstr += numStr; // add specialText color number string
	bstr += "\"\r\n";

	// second line -- 5 attributes
	for (i = 0; i < nTabLevel; i++)
	{
		bstr += "\t"; // tab the start of the line
	}
	bstr += "retranscolor=\"";
	tempStr.Empty(); // needs to start empty, otherwise << will append the string value of the int
	tempStr << WxColour2Int(gpApp->m_reTranslnTextColor);
	numStr = gpApp->Convert16to8(tempStr);
	bstr += numStr; // add retranslation text color number string
	bstr += "\" navcolor=\"";
	tempStr.Empty(); // needs to start empty, otherwise << will append the string value of the int
	tempStr << WxColour2Int(gpApp->m_navTextColor);
	numStr = gpApp->Convert16to8(tempStr);
	bstr += numStr; // add navigation text color number string
	bstr += "\" curchap=\"";
	btemp = gpApp->Convert16to8(gpApp->m_curChapter);
	bstr += btemp; // add current chapter text color number string (app makes no use of this)
	bstr += "\" srcname=\"";
	btemp = gpApp->Convert16to8(gpApp->m_sourceName);
	bstr += btemp; // add name of source text's language
	bstr += "\" tgtname=\"";
	btemp = gpApp->Convert16to8(gpApp->m_targetName);
	bstr += btemp; // add name of target text's language

// mrh June 2012 - new fields for docVersion 7:
	if (gpApp->m_sourceLanguageCode.IsEmpty())
		gpApp->m_sourceLanguageCode = NOCODE;
	if (gpApp->m_targetLanguageCode.IsEmpty())
		gpApp->m_targetLanguageCode = NOCODE;		// ensure we output something
	bstr += "\" ";
	bstr += xml_srccode;
	btemp = gpApp->Convert16to8(gpApp->m_sourceLanguageCode);		// source language code
	bstr += "=\"";
	bstr += btemp;

	bstr += "\" ";
	bstr += xml_tgtcode;
	btemp = gpApp->Convert16to8(gpApp->m_targetLanguageCode);		// target language code
	bstr += "=\"";
	bstr += btemp;

	bstr += "\"\r\n"; // TODO: EOL chars need adjustment for Linux and Mac???

	// third line - one attribute (potentially large, containing unix strings with filter markers,
	// unknown markers, etc -- entities should not be needed for it though)
	for (i = 0; i < nTabLevel; i++)
	{
		bstr += "\t"; // tab the start of the line
	}
	bstr += "others=\"";
	btemp = gpApp->Convert16to8(SetupBufferForOutput(gpApp->m_pBuffer));
	bstr += btemp; // all all the unix string materials (could be a lot)
	bstr += "\"/>\r\n"; // TODO: EOL chars need adjustment for Linux and Mac??
	return bstr;

#else // non-Unicode version

	// first line -- element name and 4 attributes
	for (i = 0; i < nTabLevel; i++)
	{
		bstr += "\t"; // tab the start of the line
	}
	bstr += "<Settings docVersion=\"";
	// wx note: The itoa() operator is Microsoft specific and not standard; unknown to g++ on Linux/Mac.
	// The use of wxSprintf() below seems to work OK in ANSI builds, but I'll use the << insertion
	// operator here as I did in the Unicode build block above, so the code below should be the same
	// as that for the Unicode version except for the Unicode version's use of Convert16to8().
	tempStr.Empty(); // needs to start empty, otherwise << will append the string value of the int
	// BEW 19Apr10, changed next line for support of Save As... command
	tempStr << GetCurrentDocVersion();
	numStr = tempStr;
	bstr += numStr; // add versionable schema number string

// mrh - new fields with docVersion 7:
	btemp = gpApp->m_owner;				// no unicode conversion needed
	InsertEntities(btemp);				// ensure any XML metacharacters in the owner name are escaped properly
	bstr += "\" owner=\"" + btemp;		// add owner name

	tempStr.Empty();
	commitCount = gpApp->m_commitCount;
	if (commitCount < 0)
		tempStr << NOOWNER;			// this doc isn't under version control
	else
		tempStr << commitCount;			// this many commits have been done

	bstr += "\" commitcnt=\"" + tempStr;	// add commit count, without unicode conversion needed

	if (gpApp->m_versionDate.IsValid())
		numStr = gpApp->m_versionDate.Format(_T("%Y-%m-%d %H:%M:%S"));	// without unicode conversion
	else
		numStr = "";
	bstr += "\" revdate=\"" + numStr;	// add revision date, empty if we don't have one

	// now we add the doc's width and height - currently I don't think we use these on input, but may sometime.
	tempStr.Empty();
	tempStr << gpApp->m_docSize.x;
	numStr = tempStr;

	bstr += "\" ";
	bstr += xml_sizex;
	bstr += "=\"";
	bstr += numStr;						// add the doc width

	tempStr.Empty();
	tempStr << gpApp->m_docSize.y;
	numStr = tempStr;

	bstr += "\" ";
	bstr += xml_sizey;
	bstr += "=\"";
	bstr += numStr;						// add the doc height



	bstr += "\" specialcolor=\"";
	tempStr.Empty(); // needs to start empty, otherwise << will append the string value of the int
	tempStr << WxColour2Int(gpApp->m_specialTextColor);
	numStr = tempStr;
	bstr += numStr; // add specialText color number string
	bstr += "\"\r\n"; // TODO: EOL chars need adjustment for Linux and Mac??

	// second line -- 5 attributes
	for (i = 0; i < nTabLevel; i++)
	{
		bstr += "\t"; // tab the start of the line
	}
	bstr += "retranscolor=\"";
	tempStr.Empty(); // needs to start empty, otherwise << will append the string value of the int
	tempStr << WxColour2Int(gpApp->m_reTranslnTextColor);
	numStr = tempStr;
	bstr += numStr; // add retranslation text color number string
	bstr += "\" navcolor=\"";
	tempStr.Empty(); // needs to start empty, otherwise << will append the string value of the int
	tempStr << WxColour2Int(gpApp->m_navTextColor);
	numStr = tempStr;
	bstr += numStr; // add navigation text color number string
	bstr += "\" curchap=\"";
	btemp = gpApp->m_curChapter;
	bstr += btemp; // add current chapter text color number string (app makes no use of this)
	bstr += "\" srcname=\"";
	btemp = gpApp->m_sourceName;
	bstr += btemp; // add name of source text's language
	bstr += "\" tgtname=\"";
	btemp = gpApp->m_targetName;
	bstr += btemp; // add name of target text's language

	// mrh June 2012 - new fields for docVersion 7:
	bstr += "\" ";
	bstr += xml_srccode;
	btemp = gpApp->m_sourceLanguageCode;		// source language code
	bstr += "=\"" + btemp;

	bstr += "\" ";
	bstr += xml_tgtcode;
	btemp = gpApp->m_targetLanguageCode;		// target language code
	bstr += "=\"" + btemp;

	bstr += "\"\r\n"; // TODO: EOL chars need adjustment for Linux and Mac??

	// third line - one attribute (potentially large, containing unix strings with filter markers,
	// unknown markers, etc -- entities should not be needed for it though)
	for (i = 0; i < nTabLevel; i++)
	{
		bstr += "\t"; // tab the start of the line
	}
	bstr += "others=\"";
	btemp = SetupBufferForOutput(gpApp->m_pBuffer);
	bstr += btemp; // add all the unix string materials (could be a lot)
	bstr += "\"/>\r\n"; // TODO: EOL chars need adjustment for Linux and Mac??
	return bstr;
#endif
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param	buffer	-> a wxString formatted into delimited fields containing the book mode,
///						the book index, the current sfm set, a list of the filtered markers,
///						and a list of the unknown markers
/// \remarks
/// Called from: the AtDocAttr() in XML.cpp.
/// RestoreDocParamsOnInput parses the buffer string and uses its stored information to
/// update the variables held on the App that hold the corresponding information.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::RestoreDocParamsOnInput(wxString buffer)
{
	int dataLen = buffer.Length();
	// This function encapsulates code which formerly was in the Serialize() function, but
	// now that version 3 allows xml i/o, we need this functionality for both binary input
	// and for xml input. For version 2.3.0 and onwards, we don't store the source text in
	// the document so when reading in a document produced from earlier versions, we change
	// the contents of the buffer to a space so that a subsequent save will give a smaller
	// file; recent changes to use this member for serializing in/out the book mode
	// information which is needed for safe use of the MRU list, mean that we might have
	// that info read in, or it could be a legacy document's source text data. We can
	// distinguish these by the fact that the book mode information will be a string of 3,
	// 4 at most, characters followed by a null byte and EOF; whereas a valid legacy doc's
	// source text will be much much longer [see more comments within the function].
	// whm revised 6Jul05
	// We have to account for three uses of the wxString buffer here:
	// 1. Legacy use in which the buffer contained the entire source text.
	//    In this case we simply ignore the text and overwrite it with a space
	// 2. The extended app version in which only the first 3 or 4 characters were
	//    used to store the m_bBookMode and m_nBookIndex values.
	//    In this case the length of buffer string will be < 5 characters, and we handle
	//    the parsing of the book mode and book index as did the extended app.
	// 3. The current version 3 app which adds a unique identifier @#@#: to the beginning
	//    of the string buffer, then follows this by colon delimited fields concatenated in
	//    the buffer string to represent config data.
	//    In this case we verify we have version 3 structure by presence of the @#@#: initial
	//    5 characters, then parse the string like a unix data string. The book mode and book
	//    index will be the first two fields, followed by version 3 specific config values.
	// Note: The gCurrentSfmSet is always changed to be the same as was last saved in the
	// document. The gCurrentFilterMarkers is also always changed to be the same as way
	// last saved in the document. To ensure that the current settings in the active
	// USFMAnalysis structs are in agreement with what was last saved in the document we
	// call ResetUSFMFilterStructs().
	//
	// BEW modified 09Nov05 as follows:
	// The current value for the Book Folder mode (True or False), and the current book
	// index (-1 if book mode is not currently on) have to be made to override the values
	// saved in the document if different than what is in the document - but only provided
	// the project is still the same one as the project under which the document was last
	// saved. The reason is as follows. Suppose book mode is off, and you save the document
	// - it goes into the Adaptations folder. Now suppose you use turn book mode on and use
	// the enabled Move command to move the document to the oppropriate book folder. The
	// document is now in a book folder, but internally it still contains the information
	// that it was saved with book mode off, and so no book index is stored there either
	// but just a -1 value. If you then, from within the Start Working wizard open the
	// moved document, the RestoreDocParamsOnInput() function would, unless modified to not
	// do so, restore book mode to off, and set the book index to -1 (whether for an XML
	// file read, or a binary one). This is not what we want or expect. We must also check
	// that the project is unchanged, because the user has the option of opening an
	// arbitary recent document from any project by clicking its name in the MRU list, and
	// the stored source and target language names and book mode info is then used to set
	// up the right path to the document and work out what its project was and make that
	// project the current one -- when you do this, it would be most unlikely that that
	// document was saved after a Move and you did not then open it but changed to the
	// current project, so in this case the book mode and book index as stored in the
	// document SHOULD be used (ie. potentially can reset the mode and change the book
	// index) so that you are returning to the most likely former state. There is no way to
	// detect that the former project's document was moved without being opened within the
	// project, so if the current mode differs, then the constructed path would not be
	// valid and Adapt It will not do the file read -- but this failure is detected and the
	// user is told the document probably no longer exists and is then put into the Start
	// Working wizard -- where he can then turn the mode back on (or off) and locate the
	// document and open it safely and continue working, so the MRU open will not lead to a
	// crash even if the above very unlikely scenario obtains. But if the doc was opened in
	// the earlier project, then using the saved book mode and index values as described
	// above will indeed find it successfully. So, in summary, if the project is different,
	// we must use the stored info in the doc, but if the project is unchanged, then we
	// must override the info in the doc because the fact that it was just opened means
	// that we got it from whatever folder is consistent with the current mode (ie.
	// Adaptations if book folder mode is off, a book folder if it is on) and so the
	// current setting is what we must go with. Whew!! Hope you cotton on to all this!
	wxString curSourceName; // can't use app's m_sourceName & m_targetName because these will already be
	wxString curTargetName; // overwritten so we set curSourceName and curTargetName
				// by extracting the names from the app's m_curProjectName member which
				// doesn't get updated until the doc read has been successfully completed
	gpApp->GetSrcAndTgtLanguageNamesFromProjectName(gpApp->m_curProjectName, curSourceName, curTargetName);
	bool bSameProject = (curSourceName == gpApp->m_sourceName) && (curTargetName == gpApp->m_targetName);
	// BEW added 27Nov05 to keep settings straight when doc may have been pasted here in
	// Win Explorer but was created and stored in another project

	// whm 1Oct12 removed  && !gbTryingMRUOpen test from if block below
	if (!bSameProject)
	{
		// bSameProject being FALSE may be because we opened a doc created and saved in a
		// different project and it was a legacy *adt doc and so m_sourceName and
		// m_targetName will have been set wrongly, so we override the document's stored
		// values in favour of curSourceName and curTargetName which we know to be correct
		gpApp->m_sourceName = curSourceName;
		gpApp->m_targetName = curTargetName;
	}

	bool bVersion3Data;
	wxString strFilterMarkersSavedInDoc; // inventory of filtered markers read from the Doc's Buffer

	// initialize strFilterMarkersSavedInDoc to the App's gCurrentFilterMarkers
	strFilterMarkersSavedInDoc = gpApp->gCurrentFilterMarkers;

	// initialize SetSavedInDoc to the App's gCurrentSfmSet
	// Note: The App's Get proj config routine may change the gCurrentSfmSet to PngOnly
	enum SfmSet SetSavedInDoc = gpApp->gCurrentSfmSet;

	// check for version 3 special buffer prefix
	bVersion3Data = (buffer.Find(_T("@#@#:")) == 0);
	wxString field;
	if (bVersion3Data)
	{
		// case 3 above
		// assume we have book mode and index information followed by version 3 data
		//int curPos; // unused
		//curPos = 0;
		int fieldNum = 0;

		// Ensure that first token is _T("@#@#");
		wxASSERT(buffer.Find(_T("@#@#:")) == 0);

		wxStringTokenizer tkz(buffer, _T(":"), wxTOKEN_RET_EMPTY_ALL);

		while (tkz.HasMoreTokens())
		{
			field = tkz.GetNextToken();
			switch (fieldNum)
			{
			case 0: // this is the first field which should be "@#@#" - we don't do anything with it
			{
				break;
			}
			case 1: // book mode field
			{
				// whm 1Oct12 removed MRU related code
				/*
				// BEW modified 27Nov05 to only use the T or F values when doing an MRU
				// open; since for an Open done by a wizard selection in the Document
				// page, the doc is accessed either in Adaptations folder or a book
				// folder, and so we must go with whichever mode was the case when we
				// did that (m_bBookMode false for the former, true for the latter) and
				// we certainly don't want the document to be able to set different
				// values (which it could do if it was a foreign document just copied
				// into a folder and we are opening it on our computer for the first
				// time). I think the bSameProject value is not needed actually, an MRU
				// open requires we try using what's on the doc, and an ordinary wizard
				// open requires us to ignore what's on the doc.
				if (gbTryingMRUOpen)
				{
					// let the app's current setting stand except when an MRU open is tried
					if (field == _T("T"))
					{
						gpApp->m_bBookMode = TRUE;
					}
					else if (field == _T("F"))
					{
						gpApp->m_bBookMode = FALSE;
					}
					else
						goto t;
				}
				*/
				break;
			} // end of case 1:
			case 2: // book index field
			{
				// whm 1Oct12 removed MRU related code
				/*
				// see comments above about MRU
				if (gbTryingMRUOpen)
				{
					// let the app's current setting stand except when an MRU open is tried
					// use the file's saved index setting
					int i = wxAtoi(field);
					gpApp->m_nBookIndex = i;
					if (i >= 0  && !gpApp->m_bDisableBookMode)
					{
						gpApp->m_pCurrBookNamePair = ((BookNamePair*)(*gpApp->m_pBibleBooks)[i]);
					}
					else
					{
						// it's a -1 index, or the mode is disabled due to a bad parse of the
						//  books.xml file, so ensure no named pair and the folder path is empty
						gpApp->m_nBookIndex = -1;
						gpApp->m_pCurrBookNamePair = NULL;
						gpApp->m_bibleBooksFolderPath.Empty();
					}
				}
				*/
				break;
			} // end of case 2:
			case 3: // gCurrentSfmSet field
			{
				// gCurrentSfmSet is updated below.
				SetSavedInDoc = (SfmSet)wxAtoi(field); //_ttoi(field);
				break;
			} // end of case 3:
			case 4: // filtered markers string field
			{
				// gCurrentFilterMarkers is updated below.
				// Note: All Unknown markers that were also filtered, will also be listed
				// in the field input string.
				strFilterMarkersSavedInDoc = field;
				// whm added 9Jul12. It is possible that some documents have been saved before
				// we corrected the filtering and unfiltering of \x, \f and \fe markers, in which
				// case this filtered markers string field could have orphaned content markers
				// \xo ... etc without a parent \x, and \ft .... etc without parent \f or \fe.
				// We should clean up any orphaned content markers so that they won't make for
				// problems in marker filtering during the session. We can assume that if \x
				// if present in the filtered markers string field, that its content markers should
				// also be present. If \x is absent the content markers associated with \x should
				// also be absent. Same story for the \f and \fe markers and their associated
				// content markers. I've written a function called CleanupFilterMarkerOrphansInString()
				// to do the job.
				strFilterMarkersSavedInDoc = gpApp->CleanupFilterMarkerOrphansInString(strFilterMarkersSavedInDoc);
				break;
			} // end of case 4:
			case 5: // unknown markers string field
			{
				// The doc has not been serialized in yet so we cannot use
				// GetUnknownMarkersFromDoc() here, so we'll populate the
				// unknown markers arrays here.
				gpApp->m_currentUnknownMarkersStr = field;

				// Initialize the unknown marker data arrays to zero, before we populate them
				// with any unknown markers saved with this document being serialized in
				gpApp->m_unknownMarkers.Clear();
				gpApp->m_filterFlagsUnkMkrs.Clear(); // wxArrayInt

				wxString tempUnkMrksStr = gpApp->m_currentUnknownMarkersStr;

				// Parse out the unknown markers in tempUnkMrksStr
				wxString unkField, wholeMkr, fStr;

				wxStringTokenizer tkz2(tempUnkMrksStr); // use default " " whitespace here

				while (tkz2.HasMoreTokens())
				{
					unkField = tkz2.GetNextToken();
					// field1 should contain a token in the form of "\xx=0 " or "\xx=1 "
					int dPos1 = unkField.Find(_T("=0"));
					int dPos2 = unkField.Find(_T("=1"));
					wxASSERT(dPos1 != -1 || dPos2 != -1);
					int dummyIndex;
					if (dPos1 != -1)
					{
						// has "=0", so the unknown marker is unfiltered
						wholeMkr = unkField.Mid(0, dPos1);
						fStr = unkField.Mid(dPos1, 2); // get the "=0" filtering delimiter part
						if (!MarkerExistsInArrayString(&gpApp->m_unknownMarkers, wholeMkr, dummyIndex))
						{
							gpApp->m_unknownMarkers.Add(wholeMkr);
							gpApp->m_filterFlagsUnkMkrs.Add(FALSE);
						}
					}
					else
					{
						// has "=1", so the unknown marker is filtered
						wholeMkr = unkField.Mid(0, dPos2);
						fStr = unkField.Mid(dPos2, 2); // get the "=1" filtering delimiter part
						if (!MarkerExistsInArrayString(&gpApp->m_unknownMarkers, wholeMkr, dummyIndex))
						{
							gpApp->m_unknownMarkers.Add(wholeMkr);
							gpApp->m_filterFlagsUnkMkrs.Add(TRUE);
						}
					}
				}

				break;
			} // end of case 5:
			default:
			{
				// unknown field - ignore
				;
			}
			} // end of switch (fieldNum)
			fieldNum++;
		} // end of while (tkz.HasMoreTokens())
	}
	else if (dataLen < 5)
	{
		// case 2 above
		// assume we have book mode information - so restore it
		// whm modified to eliminate calling GetChar(0) on a possibly
		// empty string.
		wxChar ch;
		if (buffer.IsEmpty())
			ch = _T('\0');
		else
			ch = buffer.GetChar(0);
		if (ch == _T('T'))
			gpApp->m_bBookMode = TRUE;
		else if (ch == _T('F'))
			gpApp->m_bBookMode = FALSE;
		else
		{
			// oops, it's not book mode info, so do the other block instead
			goto t;
		}
		buffer = buffer.Mid(1); // get the index's string
		int i = wxAtoi(buffer);
		gpApp->m_nBookIndex = i;

		// set the BookNamePair pointer, but we don't have enough info for recreating the
		// m_bibleBooksFolderPath here, but SetupDirectories() can recreate it from the
		// doc-serialized m_sourceName and m_targetName strings, and so we do it there;
		// however, if book mode was off when this document was serialized out, then the
		// saved index value was -1, so we must check for this and not try to set up a
		// name pair when that is the case
		if (i >= 0 && !gpApp->m_bDisableBookMode)
		{
			gpApp->m_pCurrBookNamePair = ((BookNamePair*)(*gpApp->m_pBibleBooks)[i]);
		}
		else
		{
			// it's a -1 index, or the mode is disabled due to a bad parse of the books.xml file,
			// so ensure no named pair and the folder path is empty
			gpApp->m_pCurrBookNamePair = NULL;
			gpApp->m_bibleBooksFolderPath.Empty();
		}
	}
	else
	{
		// BEW changed 27Nov05, because we only let doc settings be used when MRU was being tried
	t:
		;
		// whm 1Oct12 removed MRU related code
		//if (gbTryingMRUOpen /* && !bSameProject */)
		//{
		//	// case 1 above
		//	// assume we have legacy source text data - for this there was no such thing
		//	// as book mode in those legacy application versions, so we can have book mode off
		//	gpApp->m_bBookMode = FALSE;
		//	gpApp->m_nBookIndex = -1;
		//	gpApp->m_pCurrBookNamePair = NULL;
		//	gpApp->m_bibleBooksFolderPath.Empty();
		//}
	}

	// whm ammended 6Jul05 below in support of USFM and SFM Filtering
	// Apply any changes to the App's gCurrentSfmSet and gCurrentFilterMarkers indicated
	// by any existing values saved in the Doc's Buffer member
	gpApp->gCurrentSfmSet = SetSavedInDoc;
	gpApp->gCurrentFilterMarkers = strFilterMarkersSavedInDoc;

	// ResetUSFMFilterStructs also calls SetupMarkerStrings() and SetupMarkerStrings
	// builds the various rapid access marker strings including the Doc's unknown marker
	// string pDoc->m_currentUnknownMarkersStr, and adds the unknown markers to the App's
	// gCurrentFilterMarkers string.
	ResetUSFMFilterStructs(gpApp->gCurrentSfmSet, strFilterMarkersSavedInDoc, allInSet);
}


///////////////////////////////////////////////////////////////////////////////
/// \return a wxString
/// \param	pCString	-> pointer to a wxString formatted into delimited fields containing the
///						book mode, the book index, the current sfm set, a list of the filtered
///						markers, and a list of the unknown markers
/// \remarks
/// Called from: ConstructSettingsInfoAsXML().
/// Creates a wxString composed of delimited fields containing the current book mode, the
/// book index, the current sfm set, a list of the filtered markers, and a list of the
/// unknown markers used in the document.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::SetupBufferForOutput(wxString* pCString)
{
	// This function encapsulates code which formerly was in the Serialize() function, but now that
	// version 3 allows xml i/o, we need this code for both binary output and for xml output
	pCString = pCString; // to quiet warning
	// wx version: whatever contents pCString had will be ignored below
	wxString buffer; // = *pCString;
	// The legacy app (pre version 2+) used to save the source text to the document file, but this
	// no longer happens; so since doc serializating is not versionable I can use this CString buffer
	// to store book mode info (T for true, F for false, followed by the _itot() conversion of the
	// m_nBookIndex value; and reconstruct these when serializing back in. The doc has to have
	// the book mode info in it, otherwise I cannot make MRU list choices restore the correct state
	// and folder when a document was saved in book mode, from a Bible book folder
	// whm added 26Feb05 in support of USFM and SFM Filtering
	// Similar reasons require that we use this m_pBuffer space to store some things pertaining
	// to USFM and Filtering support that did not exist in the legacy app. The need for this
	// arises due to the fact that with version 3, what is actually adapted in the source text
	// is dependent upon which markers are filtered and on which sfm set the user has chosen,
	// which the user can change at any time.
	wxString strResult;
	// add the version 3 special buffer prefix
	buffer.Empty();
	buffer << _T("@#@#:"); // RestoreDocParamsOnInput case 0:
	// add the book mode
	if (gpApp->m_bBookMode)
	{
		buffer << _T("T:");  // RestoreDocParamsOnInput case 1:
	}
	else
	{
		buffer << _T("F:");  // RestoreDocParamsOnInput case 1:
	}
	// add the book index
	buffer << gpApp->m_nBookIndex;  // RestoreDocParamsOnInput case 2:
	buffer << _T(":");

#if defined (_Trace_FilterMarkers) && !defined(NOLOGS)
	// BEW commented out these logging calls, they just make the log window harder to read for 
	// other content than what these are for
//	wxLogDebug(_T("In SERIALIZE OUT DOC SAVE:\n"));
//	wxLogDebug(_T("   App's gCurrentSfmSet = %d\n"), gpApp->gCurrentSfmSet);
//	wxLogDebug(_T("   App's gCurrentFilterMarkers = %s\n"), gpApp->gCurrentFilterMarkers.c_str());
//	wxLogDebug(_T("   Doc's m_sfmSetBeforeEdit = %d\n"), gpApp->m_sfmSetBeforeEdit);
//	wxLogDebug(_T("   Doc's m_filterMarkersBeforeEdit = %s\n"), gpApp->m_filterMarkersBeforeEdit.c_str());
#endif

	// add the sfm user set enum
	// whm note 6May05: We store the gCurrentSfmSet value, not the gProjectSfmSetForConfig in the doc
	// value which may have been different.
	buffer << (int)gpApp->gCurrentSfmSet;
	buffer << _T(":");

	buffer << gpApp->gCurrentFilterMarkers;
	buffer << _T(":");

	buffer << gpApp->m_currentUnknownMarkersStr;
	buffer << _T(":");
	return buffer;
}

///////////////////////////////////////////////////////////////////////////////
/// \return TRUE if file at path was successfully saved; FALSE otherwise
/// \param	path	-> path of the file to be saved
/// \remarks
/// Called from: the App's DoTransformationsToGlosses( ) in order to save another project's
/// document, which has just had its adaptations transformed into glosses in the current
/// project. The full path is passed in - it will have been made an *.xml path in the
/// caller.
/// We don't have to worry about the view, since the document is not visible during any
/// part of the transformation process.
/// We return TRUE if all went well, FALSE if something went wrong; but so far the caller
/// makes no use of the returned Boolean value and just assumes the function succeeded.
/// The save is done to a Bible book folder when that is appropriate, whether or not book
/// mode is currently in effect.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::DoTransformedDocFileSave(wxString path)
{
	wxFile f; // create a CFile instance with default constructor
	bool bFailed = FALSE;

	if (!f.Open(path, wxFile::write))
	{
		wxString s;
		s = s.Format(_(
			"When transforming documents, the Open function failed, for the path: %s"),
			path.c_str());
		wxMessageBox(s, _T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}

	CSourcePhrase* pSrcPhrase;
	CBString aStr;
	CBString openBraceSlash = "</"; // to avoid "warning:
				// deprecated conversion from string constant to 'char*'"

	// prologue (BEW changed 02July07)
	gpApp->GetEncodingStringForXmlFiles(aStr);
	DoWrite(f, aStr);

	// add the comment with the warning about not opening the XML file in MS WORD
	// 'coz is corrupts it - presumably because there is no XSLT file defined for it
	// as well. When the file is then (if saved in WORD) loaded back into Adapt It,
	// the latter goes into an infinite loop when the file is being parsed in.
	aStr = MakeMSWORDWarning(); // the warning ends with \r\n so
								// we don't need to add them here

	// doc opening tag
	aStr += "<";
	aStr += xml_adaptitdoc;
	aStr += ">\r\n"; // eol chars OK in cross-platform version ???
	DoWrite(f, aStr);

	// place the <Settings> element at the start of the doc
	aStr = ConstructSettingsInfoAsXML(1);
	DoWrite(f, aStr);

	// add the list of sourcephrases
	SPList::Node* pos_pSP = gpApp->m_pSourcePhrases->GetFirst();
	while (pos_pSP != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos_pSP->GetData();
		pos_pSP = pos_pSP->GetNext();
		aStr = pSrcPhrase->MakeXML(1); // 1 = indent the element lines with a single tab
		DoWrite(f, aStr);
	}

	// doc closing tag
	aStr = xml_adaptitdoc;
	aStr = openBraceSlash + aStr; //"</" + aStr;
	aStr += ">\r\n"; // eol chars OK in cross-platform version ???
	DoWrite(f, aStr);

	// close the file
	f.Close();
	f.Flush();
	if (bFailed)
		return FALSE;
	else
		return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
/// \return TRUE if currently opened document was successfully saved; FALSE otherwise
/// \remarks
/// Called from: the Doc's OnFileClose().
/// Takes care of saving a modified document, saving the project configuration file, and
/// other housekeeping tasks related to file saves.
/// BEW modified 13Nov09: if local user has read-only access to a remote project
/// folder, don't let any local actions result in saving the local copy of the document
/// on the remote machine, otherwise some loss of edits may happen
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::OnSaveModified()
{
	NormalizeState();

	// save project configuration fonts and settings
	CAdapt_ItApp* pApp = &wxGetApp();

	if (pApp->m_bReadOnlyAccess)
	{
		return TRUE; // make the caller think a save etc was done
	}

	wxCommandEvent dummyevent;

	// should not close a document or project while in "show target only" mode; so detect if that
	// mode is still active & if so, restore normal mode first
	if (gbShowTargetOnly)
	{
		//restore normal mode
		pApp->GetView()->OnToggleShowSourceText(dummyevent);
	}

	// get name/title of document
	wxString name = pApp->m_curOutputFilename;

	wxString prompt;
	bool bUserSavedDoc = FALSE; // use this flag to cause the KB to be automatically saved
								// if the user saves the Doc, without asking; but if the user
								// does not save the doc, he should be asked for the KB
	bool bOK; // we won't care whether it succeeds or not,
			  // since the later Get... can use defaults
	if (!pApp->m_curProjectPath.IsEmpty())
	{
		if (pApp->m_bUseCustomWorkFolderPath && !pApp->m_customWorkFolderPath.IsEmpty())
		{
			// whm 10Mar10, must save using what paths are current, but when the custom
			// location has been locked in, the filename lacks "Admin" in it, so that it
			// becomes a "normal" project configuration file in m_curProjectPath at the
			// custom location.
			if (pApp->m_bLockedCustomWorkFolderPath)
				bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
			else
				bOK = pApp->WriteConfigurationFile(szAdminProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
		}
		else
		{
			bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
		}
		// we don't expect a write error, but tell the developer or user if the write
		// fails, and keep on processing
		if (!bOK)
		{
			wxMessageBox(_T("Adapt_ItDoc.cpp, WriteConfigurationFile() failed, for project config file or admin project config file, in OnSaveModified() at lines 5986+"));
		}
	}

	bool bIsModified = IsModified();
	if (!bIsModified)
		return TRUE;        // ok to continue

	// BEW added 11Aug06; for some reason IsModified() returns TRUE in the situation when the
	// user first launches the app, creates a project but cancels out of document creation, and
	// then closes the application by clicking the window's close box at top right. We don't
	// want MFC to put up the message "Save changes for ?", because if the user says OK, then
	// the app crashes. So we detect an empty document next and prevent the message from appearing
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		// if there are none, there is no document to save, so useless to go on,
		// so return TRUE immediately
		return TRUE;
	}

	prompt = prompt.Format(_("The document %s has changed. Do you want to save it? "), name.c_str());
	// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
	gpApp->m_bUserDlgOrMessageRequested = TRUE;
	int result = wxMessageBox(prompt, _T(""), wxICON_QUESTION | wxYES_NO | wxYES_DEFAULT | wxCANCEL); //AFX_IDP_ASK_TO_SAVE
	wxCommandEvent dummyEvent; // BEW added 29Apr10
	switch (result)
	{
	case wxCANCEL:
	{
		return FALSE;       // don't continue
	}
	case wxYES:
	{
		// If so, either Save or Update, as appropriate
		// BEW changed 29Apr10, DoFileSave_Protected() protects against loss of the
		// document file, which is safer
		//bUserSavedDoc = DoFileSave(TRUE); // TRUE - show wait/progress dialog

		// whm 26Aug11 Open a wxProgressDialog instance here for save operations.
		// The dialog's pProgDlg pointer is passed along through various functions that
		// get called in the process.
		// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
		// be changed after the dialog is created. So any routine that gets passed the
		// pProgDlg pointer, must make sure that value in its Update() function does not
		// exceed the same maximum value (nTotal).
		wxString msgDisplayed;
		const int nTotal = gpApp->GetMaxRangeForProgressDialog(App_SourcePhrases_Count) + 1;
		wxString progMsg = _("Saving file %s - %d of %d Total words and phrases");
		wxFileName fn(gpApp->m_curOutputFilename);
		msgDisplayed = progMsg.Format(progMsg, fn.GetFullName().c_str(), 1, nTotal);
		CStatusBar* pStatusBar = NULL;
		pStatusBar = (CStatusBar*)gpApp->GetMainFrame()->m_pStatusBar;
		pStatusBar->StartProgress(_("Saving File"), msgDisplayed, nTotal);

		// whm added 17Jan12 code block below which is parallel to OnFileSave() to
		// save the collab files and do the DoFileSave_Protected() call too for AI's
		// own files.
		if (gpApp->m_bCollaboratingWithParatext || gpApp->m_bCollaboratingWithBibledit)
		{
			// Collaboration is ON
			// whm modified 17Jan12 consolidated the code for collab mode file saves
			// in a DoCollabFileSave() function as it needs to also be called from
			// OnSaveModified(), otherwise saves can be lost if user closes the main
			// frame window - which triggers OnSaveModified() but not OnFileSave().
			// Notes:
			// 1. DoCollabFileSave() returns a bool as does DoFileSave_Protected()
			// and DoFileSave().
			// 2. DoCollabFilesave() also calls DoFileSave_Protected(TRUE,pProgDlg)
			bUserSavedDoc = DoCollabFileSave(_("Saving File"), msgDisplayed);
		}
		else
		{
			// Collaboration is OFF
			bUserSavedDoc = DoFileSave_Protected(TRUE, _("Saving File")); // TRUE - show wait/progress dialog
		}
		if (!bUserSavedDoc)
		{
			wxMessageBox(_("Warning: document save failed for some reason.\n"),
				_T(""), wxICON_EXCLAMATION | wxOK);
			pStatusBar->FinishProgress(_("Saving File"));
			return FALSE;       // don't continue
		}
		pStatusBar->FinishProgress(_("Saving File"));
		break;
	} // end of case wxYES:

	case wxNO:
	{
		// If not saving changes, revert the document (& ask for a KB save)
		break;
	}
	default:
	{
		wxASSERT(FALSE);
		break;
	}
	} // end of switch (result)

	// whm Note: Since the progDlg is created on the stack, it will automatically
	// be disposed of when this funciton returns.
	return TRUE;    // keep going
}

////////////////////////////////////////////////////////////////////////////////////////
// NOTE: This OnSaveDocument() is from the docview sample program.
//
// The wxWidgets OnSaveDocument() method "Constructs an output file stream
// for the given filename (which must not be empty), and then calls SaveObject.
// If SaveObject returns TRUE, the document is set to unmodified; otherwise,
// an error message box is displayed.
//
//bool CAdapt_ItDoc::OnSaveDocument(const wxString& filename) // from wxWidgets mdi sample
//{
//    CAdapt_ItView* view = (CAdapt_ItView*) GetFirstView();
//
//    if (!view->textsw->SaveFile(filename))
//        return FALSE;
//    Modify(FALSE);
//    return TRUE;
//}

// below is code from the docview sample's original override (which doesn't call the
// base class member) converted to the first Adapt It prototype.
// The wxWidgets OnOpenDocument() "Constructs an input file stream
// for the given filename (which must not be empty), and calls LoadObject().
// If LoadObject returns TRUE, the document is set to unmodified; otherwise,
// an error message box is displayed. The document's views are notified that
// the filename has changed, to give windows an opportunity to update their
// titles. All of the document's views are then updated."
//
//bool CAdapt_ItDoc::OnOpenDocument(const wxString& filename) // from wxWidgets mdi sample
//{
//    CAdapt_ItView* view = (CAdapt_ItView*) GetFirstView();
//
//    if (!view->textsw->LoadFile(filename))
//        return FALSE;
//
//    SetFilename(filename, TRUE);
//    Modify(FALSE);
//    UpdateAllViews();
//
//    return TRUE;
//}

////////////////////////////////////////////////////////////////////////////////////////
// NOTE: The differences in design between MFC's doc/view framework
// and the wxWidgets implementation of doc/view necessitate some
// adjustments in order to not foul up the state of AI's data structures.
//
// Here below is the contents of the MFC base class CDocument::OnOpenDocument()
// method (minus _DEBUG statements):
//bool CDocument::OnOpenDocument(LPCTSTR lpszPathName)
//{
//	CFileException fe;
//	CFile* pFile = GetFile(lpszPathName,
//		CFile::modeRead|CFile::shareDenyWrite, &fe);
//	if (pFile == NULL)
//	{
//		ReportSaveLoadException(lpszPathName, &fe,
//			FALSE, AFX_IDP_FAILED_TO_OPEN_DOC);
//		return FALSE;
//	}
//	DeleteContents();
//	SetModifiedFlag();  // dirty during de-serialize
//
//	CArchive loadArchive(pFile, CArchive::load | CArchive::bNoFlushOnDelete);
//	loadArchive.m_pDocument = this;
//	loadArchive.m_bForceFlat = FALSE;
//	TRY
//	{
//		CWaitCursor wait;
//		if (pFile->GetLength() != 0)
//			Serialize(loadArchive);     // load me
//		loadArchive.Close();
//		ReleaseFile(pFile, FALSE);
//	}
//	CATCH_ALL(e)
//	{
//		ReleaseFile(pFile, TRUE);
//		DeleteContents();   // remove failed contents
//
//		TRY
//		{
//			ReportSaveLoadException(lpszPathName, e,
//				FALSE, AFX_IDP_FAILED_TO_OPEN_DOC);
//		}
//		END_TRY
//		DELETE_EXCEPTION(e);
//		return FALSE;
//	}
//	END_CATCH_ALL
//
//	SetModifiedFlag(FALSE);     // start off with unmodified
//
//	return TRUE;
//}

// Here below is the contents of the wxWidgets base class WxDocument::OnOpenDocument()
// method (minus alternate wxUSE_STD_IOSTREAM statements):
//bool wxDocument::OnOpenDocument(const wxString& file)
//{
//    if (!OnSaveModified())
//        return FALSE;
//
//    wxString msgTitle;
//    if (wxTheApp->GetAppName() != wxT(""))
//        msgTitle = wxTheApp->GetAppName();
//    else
//        msgTitle = wxString(_("File error"));
//
//    wxFileInputStream store(file);
//    if (store.GetLastError() != wxSTREAM_NO_ERROR)
//    {
//        (void)wxMessageBox(_("Sorry, could not open this file."), msgTitle, wxOK|wxICON_EXCLAMATION,
//                           GetDocumentWindow());
//        return FALSE;
//    }
//    int res = LoadObject(store).GetLastError();
//    if ((res != wxSTREAM_NO_ERROR) &&
//        (res != wxSTREAM_EOF))
//    {
//        (void)wxMessageBox(_("Sorry, could not open this file."), msgTitle, wxOK|wxICON_EXCLAMATION,
//                           GetDocumentWindow());
//        return FALSE;
//    }
//    SetFilename(file, TRUE);
//    Modify(FALSE);
//    m_savedYet = TRUE;
//
//    UpdateAllViews();
//
//    return TRUE;
//}

// The significant differences in the BASE class methods are:
// 1. MFC OnOpenDocument() calls DeleteContents() before loading the archived
//    file (with Serialize(loadArchive)). The base class DeleteContents() of
//    both MFC and wxWidgets do nothing themselves. The overrides of DeleteContents()
//    have the same code in both versions.
// 2. wxWidgets' OnOpenDocument() does NOT call DeleteContents(), but first calls
//    OnSaveModified(). OnSaveModified() calls Save() if the doc is dirty. Save()
//    calls either SaveAs() or OnSaveDocument() depending on whether the doc was
//    previously saved with a name. SaveAs() takes care of getting a name from
//    user, then eventually also calls OnSaveDocument(). OnSaveDocument() finally
//    calls SaveObject(store).
// The Implications for our conversion to wxWidgets:
// 1. In our OnOpenDocument() override we need to first call DeleteContents().
// 2. We just comment out the call to the wxDocument::OnOpenDocument() base class
//    transfer its calls to our override and make any appropriate adjustments to
//    the stream error messages.

///////////////////////////////////////////////////////////////////////////////
/// \return TRUE if file at filename was successfully opened; FALSE otherwise
/// \param	filename	-> the path/name of the file to open
/// \remarks
/// Called from: the App's DoKBRestore() and DiscardDocChanges(), the Doc's
/// LoadSourcePhraseListFromFile() and DoUnpackDocument(), the View's OnEditConsistencyCheck(),
/// DoConsistencyCheck() and DoRetranslationReport(), the DocPage's OnWizardFinish(), and
/// CMainFrame's SyncScrollReceive().
/// Opens the document at filename and does the necessary housekeeping and initialization of
/// KB data structures for an open document.
/// [see also notes within in the function]
/// BEW added 13Nov09: call of m_bReadOnlyAccess = SetReadOnlyProtection(), in order to give
/// the local user in the project ownership for writing permission (if FALSE is returned)
/// or READ-ONLY access (if TRUE is returned). (Also added to LoadKB() and OnNewDocument()
/// and OnCreate() for the view class.)
///////////////////////////////////////////////////////////////////////////////

bool CAdapt_ItDoc::OnOpenDocument(const wxString& filename, bool bShowProgress /* = true */)
{
	CAdapt_ItApp* pApp = GetApp();
	CAdapt_ItView* pView = pApp->GetView();

	// BEW 16Aug16, Restore the default, which is Shift_Launch no longer on, if it was on
	pApp->m_bDoNormalProjectOpening = TRUE;

	// refactored 10Mar09
	pApp->m_nSaveActiveSequNum = 0;     // reset to a default initial value, safe for any length of doc

	// whm Version 3 Note: Since the WX version i/o is strictly XML, we do not need nor use
	// the legacy version's OnOpenDocument() serialization facilities, and can thus avoid
	// the black box problems it caused.
	// Old legacy version notes below:
	// The MFC code called the virtual methods base class OnOpenDocument here:
	//if (!CDocument::OnOpenDocument(lpszPathName)) // The MFC code
	//	return FALSE;
	// The wxWidgets equivalent is:
	//if (!wxDocument::OnOpenDocument(filename))
	//	return FALSE;
	// wxWidgets Notes:
	// 1. The wxWidgets base class wxDocument::OnOpenDocument() method DOES NOT
	//    automatically call DeleteContents(), so we must do so here. Also,
	// 2. The OnOpenDocument() base class handles stream errors with some
	//    generic messages. For these reasons then, rather than calling the base
	//    class method, we first call DeleteContents(), then we just transfer
	//    and/or merge the relevant contents of the base class method here, and
	//    taylor its stream error messages to Adapt It's needs, as was done in
	//    DoFileSave().

	// BEW added 06Aug05 for XML doc support (we have to find out what extension it has
	// and then choose the corresponding code for loading that type of doc
	// BEW modified 14Nov05 to add the doc instance to the XML doc reading call, and to
	// remove the assert which assumed that there would always be a backslash in the
	// lpszPathName string, and replace it with a test on curPos instead (when doing a
	// consistency check, the full path is not passed in)

	pApp->m_nActiveSequNum = 0;		// mrh - initialize this to a sensible default -- should
									//  be set to a new value when we read in the xml for the doc.

	// BEW changed 9Apr12, support discontinuous auto-inserted spans highlighting
	gpApp->m_pLayout->ClearAutoInsertionsHighlighting();

	wxString thePath = filename;
	wxString extension = thePath.Right(4);
	extension.MakeLower();
	wxASSERT(extension[0] == _T('.')); // check it really is an extension
	bool bWasXMLReadIn = TRUE;

	//bool bBookMode;
	//bBookMode = gpApp->m_bBookMode; // for debugging only. 01Oct06
	//int nItsIndex;
	//nItsIndex = gpApp->m_nBookIndex; // for debugging only

	// get the filename
	wxString fname = thePath;
	fname = MakeReverse(fname);
	int curPos = fname.Find(gpApp->PathSeparator);
	if (curPos != -1)
	{
		fname = fname.Left(curPos);
	}
	fname = MakeReverse(fname);
	wxString extensionlessName;

	// whm 26Aug11 Open a wxProgressDialog instance here for loading KB operations.
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	wxString msgDisplayed;
	wxString progMsg;
	// add 1 chunk to insure that we have enough after int division above
	const int nTotal = gpApp->GetMaxRangeForProgressDialog(XML_Input_Chunks) + 1;

	// Only show the progress dialog when there is at lease one chunk of data, AND we're wanting
	//  to show progress dialogs just now.

	CStatusBar* pStatusBar = NULL;
	pStatusBar = (CStatusBar*)gpApp->GetMainFrame()->m_pStatusBar;
	if (nTotal > 0 && bShowProgress)
	{
		progMsg = _("Reading file %s - part %d of %d");
		wxFileName fn(filename);
		msgDisplayed = progMsg.Format(progMsg, fn.GetFullName().c_str(), 1, nTotal);
		pStatusBar->StartProgress(_("Opening the Document"), msgDisplayed, nTotal);
	}

	// force m_bookName_Current to be empty -- it will stay empty unless set from what is
	// stored in a document just loaded; or in collaboration mode by copying to it the
	// value of the m_CollabBookSelected member; or doing an export of xhtml or for
	// Pathway export, no book name is current and the user fills one out using the
	// CBookName dialog which opens for that purpose
	pApp->m_bookName_Current.Empty();

	// BEW 19Apr18 Provide more failure diagnostics here, for LogUserAction() - we want to know
	// the filesize (in case it got trucated; the path and filename - tells us from where and
	// whether it is a collaboration file, and the last 15 characters which should contain the
	// </AdaptItDoc> string
	wxFile f;
	long fileLen;
	int nReadBytes;
	if (f.Exists(filename) && f.Open(filename, wxFile::read))
	{
		fileLen = f.Length(); // get length of file in bytes.
		if (fileLen > 15) // bytes
		{
			char* pBuff = new char[fileLen + 1]; // create on the heap just in case it is a huge file
			memset(pBuff, 0, fileLen + 1);
			nReadBytes = f.Read(pBuff, fileLen);
			char* pShortBuff = new char[16];
			memset(pShortBuff, 0, 16); // fill with nulls

			long nStart = nReadBytes - 15;
			char* ptr = pBuff + nStart;
			char* pShort = pShortBuff;
			while (*ptr != 0)
			{
				// copy the last 15 characters to the short buffer
				// which should contain </AdaptItDoc> and maybe crlf after it)
				*pShort++ = *ptr++;
			}
			CBString bytes(pShortBuff);
			wxString endingStr;
			pApp->Convert8to16(bytes, endingStr);
			endingStr.Trim(FALSE); endingStr.Trim(TRUE); // both ends, in case some whitespace is present

			// Now construct the log entry for LogUserAction and insert it into the log
			wxString strLog = _T("OnOpenDocument: Path&Filename = %s , size (in bytes) = %d , File ending = %s");
			strLog = strLog.Format(strLog, filename.c_str(), nReadBytes, endingStr.c_str());
			pApp->LogUserAction(strLog);

			delete[] pBuff;
			delete[] pShortBuff;
			f.Close();
		}
		pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
	}

	wxFileName fn(filename);

	if (extension == _T(".xml"))
	{
		// we have to input an xml document
		// BEW modified 07Nov05, to add pointer to the document, since we may be reading
		// in XML documents for joining to the current document, and we want to
		// populate the correct document's CSourcePhrase list
		wxString thePath = filename;
		wxFileName fn(thePath);
		wxString fullFileName;
		fullFileName = fn.GetFullName();

		// whm 6Apr2020 Note: For document creation logging in ReadDoc_XML, the App's m_curOutputFilename needs to be
		// set to the current output file name, before the ReadDoc_XML() function call below. 
		pApp->m_curOutputPath = thePath;
		gpApp->m_curOutputFilename = fullFileName;

		// Write the first couple log lines of our logging file to log the filename and 
		// date-time. Also write a line telling what function we are calling from.
		// See comments above the LogDocCreationData() function in the App for more details.
		// If there is a parse failure, it happened after the last m_srcPhrase in
		// this file. It is stored in the folder _LOGS_EMAIL_REPORTS in work folder
		// when "Make diagnostic logfile during document creation and opening" check box
		// is ticked in the docPage or the GetSourceTextFromEditor dialog.
		if (gpApp->m_bMakeDocCreationLogfile) // turn this ON in docPage of the Wizard or in GetSourceTextFromEditor dialog; it is OFF by default
		{
			// Construct the parameter string composed of the current output filename + date-time stamp for Now().
			wxString fileNameLine;
			wxDateTime theTime = wxDateTime::Now(); //initialize to the current time
			wxString timeStr;
			timeStr = theTime.Format();
			// whm 13Apr2020 changed to log whole path/name of doc being created/opened + date-time stamp
			fileNameLine = pApp->m_curOutputPath + _T(" ") + timeStr;
			gpApp->LogDocCreationData(fileNameLine);
			// whm 6Apr2020 the following m_bParsingSource is set TRUE during logging 
			// to prevent TokenizeText() from doing unwanted logging in other operations
			// where TokenizeText is used.
			gpApp->m_bParsingSource = TRUE;
			// whm 14Apr2020 added following log line to indicate source of Data
			gpApp->LogDocCreationData(_T("In OnOpenDocument() logging Data via ReadDoc_XML() below:"));
		}

		bool bReadOK = ReadDoc_XML(thePath, this, _("Opening the Document"), nTotal); // pProgDlg can be NULL

		pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

		if (!bReadOK)
		{
			// if we could possibly recover the doc, but haven't posted the "recover doc" event yet, we do it now:
			if (pApp->m_commitCount > 0 && !pApp->m_recovery_pending)
			{
				//               wxCommandEvent  eventCustom (wxEVT_Recover_Doc);
				//               wxPostEvent (pApp->GetMainFrame(), eventCustom);       // Custom event handlers are in CMainFrame

				pApp->m_recovery_pending = TRUE;
				pApp->m_reopen_recovered_doc = TRUE;    // In this one case we just reopen the doc after recovery.  It should be the
														//  most common case.
			}

			// at this point, if we can't attempt a recovery, we just display a message and give up.  If we are attempting a recovery,
			//  we skip this block and continue with some of the initialization we need before we can bail out.

			if (!pApp->m_recovery_pending)
			{
				wxString s;
				// ugly message because we expect a good read, but we allow the user to continue
				// IDS_XML_READ_ERR
				s = _(
					"There was an error parsing in the XML file.\nIf you edited the XML file earlier, you may have introduced an error.\nEdit it in a word processor then try again.");
				wxMessageBox(s, fullFileName, wxICON_INFORMATION | wxOK);
				gpApp->LogUserAction(s);
				//}
				if (nTotal > 0 && bShowProgress)
				{
					pStatusBar->FinishProgress(_("Opening the Document"));
				}
				return FALSE;     // mrh - returning TRUE causes mayhem higher up!
			}
			gpApp->m_bParsingSource = FALSE; // make sure doc creation logging stays OFF
											// until explicitly turned on at another time
			gpApp->m_bMakeDocCreationLogfile = FALSE; // turn this OFF to prevent user
											// leaving it turned on, and wondering why doc creation takes minutes to complete

		}
		// whm 13Apr2020 added line at end of document opening log to indicate we reached end of the document
		// This essentially signals within the log file that the XML document opening was successful.
		if (gpApp->m_bMakeDocCreationLogfile)
		{
			gpApp->LogDocCreationData(_T("***End-of-Document***"));
		}
	}

	if (pApp->m_bWantSourcePhrasesOnly)
	{
		// From here on in for the rest of this function, all we do is set globals,
		// filenames, config file parameters, and change the view, all things we're not to
		// do if m_bWantSourcePhrasesOnly is set. Hence, we simply exit early; because all
		// we are wanting is the list of CSourcePhrase instances.
		gpApp->LogUserAction(_T("Return TRUE early from OnOpenDocument() m_bWantSourcePhrasesOnly"));
		ValidateNoteStorage();
		if (nTotal > 0 && bShowProgress)
		{
			pStatusBar->FinishProgress(_("Opening the Document"));
		}
		pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

		return TRUE; // Added by JF.
	}

	// update the window title
	SetDocumentWindowTitle(fname, extensionlessName);

	wxString filenameStr = fn.GetFullName(); //GetFileName(filename);
	if (bWasXMLReadIn)
	{
		// it was an *.xml file the user opened
		gpApp->m_curOutputFilename = filenameStr;

		// construct the backup's filename
		// BEW changed 23June07 to allow for the possibility that more than one period
		// may be used in a filename
		filenameStr = MakeReverse(filenameStr);
		filenameStr.Remove(0, 4); //filenameStr.Delete(0,4); // remove "lmx."
		filenameStr = MakeReverse(filenameStr);
		filenameStr += _T(".BAK");
		//filenameStr += _T(".xml"); // produces *.BAK.xml BEW removed 3Mar11
	}
	gpApp->m_curOutputBackupFilename = filenameStr;
	gpApp->m_curOutputPath = filename;

	// Now the filename strings are set up, if we're recovering a corrupt doc, we can bail out.

	if (gpApp->m_recovery_pending)
	{
		// whm 23Aug2018 added pStatusBar->FinishProgress(...) below
		// The progress bar should call FinishProgress before all return statements.
		if (nTotal > 0 && bShowProgress)
		{
			pStatusBar->FinishProgress(_("Opening the Document"));
		}
		pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
		return FALSE;
	}

	// filenames and paths for the doc and any backup are now guaranteed to be
	// what they should be
	// CAdapt_ItApp* pApp = GetApp();		// mrh - moved to start of function
	// CAdapt_ItView* pView = pApp->GetView();
//#ifdef _DEBUG
//	wxLogDebug(_T("OnOpenDocument at %d ,  Active Sequ Num  %d"),1,pApp->m_nActiveSequNum);
//#endif

	int width = wxSystemSettings::GetMetric(wxSYS_SCREEN_X);
	if (pApp->m_docSize.GetWidth() < 100 || pApp->m_docSize.GetWidth() > width)
	{
		::wxBell(); // tell me it was wrong
		pApp->m_docSize = wxSize(width - 40, 600); // ensure a correctly sized document
		pApp->GetMainFrame()->canvas->SetVirtualSize(pApp->m_docSize);
	}

	// refactored version: try the following here
	CLayout* pLayout = GetLayout();
	pLayout->SetLayoutParameters(); // calls InitializeCLayout() and UpdateTextHeights()
									// and other setters

	bool bIsOK = TRUE; // initialise

#ifdef _NEW_LAYOUT
	bIsOK = pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#else
	bIsOK = pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#endif
	if (!bIsOK)
	{
		// unlikely to fail, so just have something for the developer here
		wxMessageBox(_T("Error. RecalcLayout() failed in OnOpenDocument()"),
			_T(""), wxICON_STOP);
		gpApp->LogUserAction(_T("Error. RecalcLayout() failed in OnOpenDocument()"));
		if (nTotal > 0 && bShowProgress)
		{
			pStatusBar->FinishProgress(_("Opening the Document"));
		}
		wxASSERT(FALSE);
		wxExit();
	}

	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		// nothing to show
		wxString msg;
		msg = _("Nothing was read in successfully.\nThis can happen if the document being loaded was created with a later version of Adapt It that has either a higher docVersion value, or extra attributes in the <Settings> tag, or both.\nYou can try manual editing in Notepad or a similar PlainText editor (on a copy of the document xml file) removing attributes added recently to the <Settings> element, or lowering the docVersion number, or both, and then saving (as UTF-8).\nThen try to load the edited document file.\nComparing the docVersion and attributes of documents not opened for a long time may help you work out which are the things to remove or change. Confine such editing to lines 5 to 7 of the xml document file.\nPerhaps contacting the developers for help is best.");
		wxMessageBox(msg, fn.GetFullName(), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(msg);
		if (nTotal > 0 && bShowProgress)
		{
			pStatusBar->FinishProgress(_("Opening the Document"));
		}
		pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
		return FALSE;
	}

	// BEW 25Jun13, test the activesequnum value, because if it is large but the user has
	// manually fiddled with the document to make it have fewer piles, then the doc's
	// carried value of the active location may be beyond the end of the shortened
	// document, and then trying to set it returns NULL as the m_pActivePile value. So
	// check and if necessary give it a safe smaller value
	int nMaxCurrentSequNum = pApp->m_pSourcePhrases->GetCount() - 1;
	if (pApp->m_nActiveSequNum > nMaxCurrentSequNum)
	{
		pApp->m_nActiveSequNum = 0; // generally the most safe value it can have
	}
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);	// seq num was initially zero but should have been set
															// to a "real" value when the xml was read in

	pApp->m_pLayout = pApp->m_pLayout; // for debugging


	// BEW added 21Apr08; clean out the global struct gEditRecord & clear its deletion lists,
	// because each document, on opening it, it must start with a truly empty EditRecord; and
	// on doc closure and app closure, it likewise must be cleaned out entirely (the deletion
	// lists in it have content which persists only for the life of the document currently open)
	pView->InitializeEditRecord(gEditRecord);
	gEditRecord.deletedAdaptationsList.Clear(); // remove any stored deleted adaptation strings
	gEditRecord.deletedGlossesList.Clear(); // remove any stored deleted gloss strings
	gEditRecord.deletedFreeTranslationsList.Clear(); // remove any stored deleted free translations

	// whm added 1Oct12. After removing the MRU stuff from
	// OnOpenDocument(), I've retained the initial test, i.e., if
	// (pApp->m_pKB == NULL), and if that test passes, then there may
	// be something more that needs to be accounted for in the removal
	// of the MRU material. I'll signal that with a "Probable Programming
	// Error..." message
	if (pApp->m_pKB == NULL)
	{
		wxASSERT_MSG(FALSE, _T("In OnOpenDocument() m_pKB is NULL. Probable Programming Error after disabling MRU code."));
		pApp->LogUserAction(_T("In OnOpenDocument() m_pKB is NULL. Probable Programming Error after disabling MRU code."));
	}
	gbDoingInitialSetup = FALSE; // turn it back off, the pApp->m_targetBox now exists, etc

	// place the phrase box, but inhibit placement on first pile if doing a consistency
	// check, because otherwise whatever adaptation is in the KB for the first word/phrase
	// gets removed unconditionally from the KB when that is NOT what we want to occur!
	if (!gbConsistencyCheckCurrent)
	{
		// ensure its not a retranslation - if it is, move the active location to first
		// non-retranslation pile
		if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
		{
			// it is a retranslation, so move active location
			CPile* pNewPile;
			CPile* pOldPile = pApp->m_pActivePile;
			do {
				pNewPile = pView->GetNextPile(pOldPile);
				wxASSERT(pNewPile);
				pOldPile = pNewPile;
			} while (pNewPile->GetSrcPhrase()->m_bRetranslation);
			pApp->m_pActivePile = pNewPile;
			pApp->m_nActiveSequNum = pNewPile->GetSrcPhrase()->m_nSequNumber;
		}

		// BEW added 10Jun09, support phrase box matching of the text colour chosen
		if (gbIsGlossing && gbGlossingUsesNavFont)
		{
			pApp->m_pTargetBox->GetTextCtrl()->SetOwnForegroundColour(pLayout->GetNavTextColor());// whm 12Jul2018 added ->GetTextCtrl() part
		}
		else
		{
			pApp->m_pTargetBox->GetTextCtrl()->SetOwnForegroundColour(pLayout->GetTgtColor());// whm 12Jul2018 added ->GetTextCtrl() part
		}

		// whm 28Mar2018 Note: This next PlacePhraseBox() call is called from the DocPage's
		// OnWizardFinish(), which was in turn called by DocPage's OnWizardPageChanging().
		// The OnWizardPageChanging() function itself will end up calling PlaceBox(), so
		// we should suppress PlacePhraseBox()'s own PlaceBox() call and its execution of
		// code in SetupDropDownPhraseBoxForThisLocation() here by setting the App's
		// m_bMovingToDifferentPile flag to TRUE during the PlacePhraseBox() call.
		pApp->m_bMovingToDifferentPile = TRUE;
		pView->PlacePhraseBox(pApp->m_pActivePile->GetCell(1), 2); // selector = 2, because we
			// were not at any previous location, so inhibit the initial StoreText call,
			// but enable the removal from KB storage of the adaptation text (see comments under
			// the PlacePhraseBox function header, for an explanation of selector values)
		pApp->m_bMovingToDifferentPile = FALSE;

		// save old sequ number in case required for toolbar's Back button - no earlier one yet,
		// so just use the value -1
		pApp->m_nOldSequNum = -1;
	}

	// determine m_curOutputPath, so it can be saved to config files as m_lastDocPath
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
	{
		pApp->m_curOutputPath = pApp->m_bibleBooksFolderPath + pApp->PathSeparator
			+ pApp->m_curOutputFilename;
	}
	else
	{
		pApp->m_curOutputPath = pApp->m_curAdaptationsPath + pApp->PathSeparator
			+ pApp->m_curOutputFilename;
	}

	// BEW added 01Oct06: to get an up-to-date project config file saved (in case user
	// turned on or off the book mode in the wizard) so that if the app subsequently
	// crashes, at least the next launch will be in the expected mode (see near top of
	// CAdapt_It.cpp for an explanation of the m_bPassedAppInitialization flag)
	// BEW added 12Nov09, m_bAutoExport test to suppress writing the project config file
	// when export is done from the command line export command
	if (pApp->m_bPassedAppInitialization && !pApp->m_curProjectPath.IsEmpty() && !pApp->m_bAutoExport)
	{
		// BEW on 4Jan07 added change to WriteConfiguration to save the external current
		// work directory and reestablish it at the end of the WriteConfiguration call,
		// because the latter function resets the current directory to the project folder
		// before saving the project config file - and this clobbered the restoration of a
		// KB from the 2nd doc file accessed
		bool bOK;
		if (pApp->m_bUseCustomWorkFolderPath && !pApp->m_customWorkFolderPath.IsEmpty())
		{
			// whm 10Mar10, must save using what paths are current, but when the custom
			// location has been locked in, the filename lacks "Admin" in it, so that it
			// becomes a "normal" project configuration file in m_curProjectPath at the
			// custom location.
			if (pApp->m_bLockedCustomWorkFolderPath)
				bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
			else
				bOK = pApp->WriteConfigurationFile(szAdminProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
		}
		else
		{
			bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
		}
		// we don't expect a write error, but tell the developer or user if the write
		// fails, and keep on processing
		if (!bOK)
		{
			wxMessageBox(_T("Adapt_ItDoc.cpp, WriteConfigurationFile() failed, for project config file or admin project config file, in OnOpenDocument() at lines 6392+"));
		}
	}

	// whm 1Oct12 removed MRU code
	/*
	// wx version addition:
	// Add the file to the file history MRU
	// BEW added 12Nov09, m_bAutoExport test to suppress history update when export is
	// done from the command line export command
	// whm added 29Mar12, omit file history when in collaboration mode
	if (!pApp->m_curOutputPath.IsEmpty() && !pApp->m_bAutoExport
		&& !pApp->m_bCollaboratingWithParatext && !pApp->m_bCollaboratingWithBibledit)
	{
		wxFileHistory* fileHistory = pApp->m_pDocManager->GetFileHistory();
		fileHistory->AddFileToHistory(pApp->m_curOutputPath);
		// The next two lines are a trick to get past AddFileToHistory()'s behavior of
		// extracting the directory of the file you supply and stripping the path of all
		// files in history that are in this directoy. RemoveFileFromHistory() doesn't do
		// any tricks with the path, so the following is a dirty fix to keep the full
		// paths.
		fileHistory->AddFileToHistory(wxT("[tempDummyEntry]"));
		fileHistory->RemoveFileFromHistory(0); //
	}
	*/

	// BEW added 12Nov09, do the auto-export here, if asked for, and shut
	// down the app before returning; otherwise, continue for normal user
	// GUI interaction
	if (pApp->m_bAutoExport)
	{
		pApp->LogUserAction(_T("Doing m_bAutoExport from OnOpenDocument()"));
		wxLogNull logNo; // avoid spurious messages from the system

		// set up output path using m_autoexport_outputpath
		wxString docName = pApp->m_autoexport_docname;
		docName = MakeReverse(docName);
		docName = docName.Mid(4); // remove reversed ".xml"
		docName = MakeReverse(docName); // back to normal order without extension
		docName = docName + _T(".txt"); // make a plain text file
		pApp->m_curOutputFilename = docName;
		pApp->m_curOutputPath = pApp->m_autoexport_outputpath + pApp->PathSeparator + docName;

		// pinch what I need from ExportFunctions.cpp
		wxString target;	// a export data's buffer
		target.Empty();
		int nTextLength;
		nTextLength = RebuildTargetText(target);
		nTextLength = nTextLength; // avoid warning
		FormatMarkerBufferForOutput(target, targetTextExport);
		target = RemoveMultipleSpaces(target);
		// whm 19Sept2023 added to regularize the EOLs to CRLF and reduce multiple CRLFs to
		// a single CRLF
		NormalizeTextEOLsToCRLF(target, TRUE); // TRUE second parameter defaults bEndWithEOL to TRUE 

		// now write out the exported data string
		wxFile f;
		if (!f.Open(pApp->m_curOutputPath, wxFile::write))
		{
			wxString msg;
			msg = msg.Format(_("Unable to open the file for exporting the target text with path:\n%s"), pApp->m_curOutputPath.c_str());
			wxMessageBox(msg, _T(""), wxICON_EXCLAMATION | wxOK);
			pApp->LogUserAction(msg);
			if (nTotal > 0 && bShowProgress)
			{
				pStatusBar->FinishProgress(_("Opening the Document"));
			}
			pApp->OnExit();
			return FALSE;
		}
#ifndef _UNICODE // ANSI
		f.Write(target);
#else // _UNICODE
		wxFontEncoding enc = wxFONTENCODING_UTF8;
		pApp->ConvertAndWrite(enc, &f, target);
#endif // for _UNICODE
		f.Close();
		// shut down forcefully
		//pApp->OnExit();
		unsigned long pid = ::wxGetProcessId();
		enum wxKillError killErr;
		int rv = ::wxKill(pid, wxSIGTERM, &killErr); // makes OnExit() be called
		rv = rv; // prevent compiler warning
		if (nTotal > 0 && bShowProgress)
		{
			pStatusBar->FinishProgress(_("Opening the Document"));
		}

		return FALSE;
	}
	else
	{
		// whm added 7Mar12 code for fictitious read only access. If the m_bFictitiousReadOnlyAccess
		// flag is set, ForceFictitiousReadOnlyProtection() should be called before the call to
		// SetReadOnlyProtection().
		if (pApp->m_bFictitiousReadOnlyAccess)
		{
			pApp->m_pROP->ForceFictitiousReadOnlyProtection(pApp->m_curProjectPath);
		}

		// BEW added 13Nov09, for setting or denying ownership for writing permission.
		// This is something we want to do each time a doc is opened - if the local user
		// already has ownership for writing, no change is done and he retains it; but
		// if he had read only access, and the other person has relinquished the project,
		// then the local user will now get ownership. We do this here in the else block
		// because we don't want to support this functionality for automated adaptation
		// exports from the command line because those have the app open only for a few
		// seconds at most, and when they happen they change nothing so can be done
		// safely no matter who currently has ownership for writing.
		pApp->m_bReadOnlyAccess = pApp->m_pROP->SetReadOnlyProtection(pApp->m_curProjectPath);

		if (pApp->m_bReadOnlyAccess)
		{
			// if read only access is turned on, force the background colour change to show
			// now, instead of waiting for a user action requiring a canvas redraw
			pApp->GetView()->canvas->Refresh(); // needed? the call in OnIdle() is more effective

			// whm added 29Mar12. When read-only access is active, we don't show the phrasebox
			pApp->m_pTargetBox->HidePhraseBox(); // hides all three parts of the new phrasebox

			pApp->m_pTargetBox->Enable(FALSE); // whm 12July2018 Note: It is re-enabled in ResizeBox()
			pApp->m_pTargetBox->GetTextCtrl()->SetEditable(FALSE); // whm 12July2018 Note: SetEditable(TRUE) done in ResizeBox()
		}
		else
		{
			ValidateNoteStorage(); // ensure there are no bogus m_bHasNote flag values present
		}
	}

	if (nTotal > 0 && bShowProgress)
	{
		pStatusBar->FinishProgress(_("Opening the Document"));
	}

	// whm 15Oct2023 added. We're near the end of OnOpenDocument() and we need to ensure that
	// the Doc's variables and m_UsfmStructArr array are set up and populated for the current
	// document being opened by calling the Doc's SetupUsfmStructArrayAndFile() function.
	// When opening an existing document, there is a good chance that the user will be opening
	// a document that AI created before version 6.11.1 and there would not be any existing
	// <filename>.usfmstruct file to process. We check first to see if the <filename.usfmstruct
	// file exists. If so, we pass openExistingFile enum to SetupUsfmStructArrayAndFile(). If
	// the .usfmstruct file doesn't yet exist we need to pass createFromSPList to the 
	// SetupUsfmStructArrayAndFile() function. At this point in OnOpenDocument() the SPList
	// should exist for the just-opened document.
	m_usfmStructDirName = _T(".usfmstruct");
	wxFileName structFn(gpApp->m_curOutputPath);
	m_usfmStructFilePath = structFn.GetPath();
	m_usfmStructFileName = structFn.GetFullName(); // gets full name including extension, but excluding directories
	m_usfmStructDirPath = m_usfmStructFilePath + gpApp->PathSeparator + m_usfmStructDirName;
	if (!::wxDirExists(m_usfmStructDirPath))
	{
		// The hidden dir .usfmstruct doesn't exist yet so create it.
		bool bOK;
		bOK = ::wxMkdir(m_usfmStructDirPath);
		if (!bOK)
		{
			// failure to make the directory not expected so English message to the user log is sufficient
			wxString msg = _T("In OnNewDocument() - Failed to Create hidden directory at %s");
			msg = msg.Format(msg, m_usfmStructDirPath.c_str());
			gpApp->LogUserAction(msg);
			m_bUsfmStructEnabled = FALSE; // the usfm struct routines are disabled
		}
	}

	m_usfmStructFilePathAndName = m_usfmStructDirPath + gpApp->PathSeparator + m_usfmStructFileName + m_usfmStructDirName;
	if (!::wxFileExists(m_usfmStructFilePathAndName))
	{

		wxString inputBuffer;
		inputBuffer.Empty();
		bool bSetupOK;
		bSetupOK = SetupUsfmStructArrayAndFile(createFromSPList, inputBuffer, gpApp->m_pSourcePhrases);
		if (!bSetupOK)
		{
			// Not likely to happen so an English message is OK.
			wxString msg = _T("Adapt It could not set up the Usfm Struct Array or the .usfmstruct file.\n\nThis may affect the ability of Adapt It to filter or unfilter adjacent markers in correct sequence.");
			wxMessageBox(msg, _T(""), wxICON_WARNING | wxOK);
			pApp->LogUserAction(msg);
			m_bUsfmStructEnabled = FALSE; // the usfm struct routines are disabled
		}
	}
	else
	{
		wxString unusedString; unusedString.Empty();
		bool bSetupOK;
		bSetupOK = SetupUsfmStructArrayAndFile(openExistingFile, unusedString);
		if (!bSetupOK)
		{
			// Not likely to happen so an English message is OK.
			wxString msg = _T("Adapt It could not set up the Usfm Struct Array or the .usfmstruct file.\n\nThis may affect the ability of Adapt It to filter or unfilter adjacent markers in correct sequence.");
			wxMessageBox(msg, _T(""), wxICON_WARNING | wxOK);
			pApp->LogUserAction(msg);
			m_bUsfmStructEnabled = FALSE; // the usfm struct routines are disabled
		}
	}
	// amd also update the .usfmstruct file (that was created when 
	// document was first created) with current filter status information. We do that by calling the Doc function:
	// UpdateCurrentFilterStatusOfUsfmStructFileAndArray().
	if (m_bUsfmStructEnabled)
	{
		UpdateCurrentFilterStatusOfUsfmStructFileAndArray(m_usfmStructFilePathAndName);
	}

	// BEW 12Feb20 added call to check if the adaptation KB has any placeholder items stored
	// within - if any are found then this function removes them. Observing workflow as
	// Yolngu translators did their adapting at Milingimbi island, a placehold coming up with
	// a huge long list of useless saved tgt text items is just a nuisance. It needs to come
	// up with its phrasebox empty, ready for a meaning to be typed; and the meaning needs
	// to be blocked from entering the adapting KB (there are no stored placeholders in the
	// glossing KB) - so there's also a little block of code near top of StoreText() to cause
	// control to exit if the CSourcePhrase is m_bNullSourcePhrase TRUE and m_bRetranslation
	// is FALSE. The adaptation KB for this project is guaranteed to be read in and ready by now.
//	pApp->m_pKB->RemoveManuallyEnteredPlaceholdersFromKB();

	// update status bar with project name
	pApp->RefreshStatusBarInfo();

	//#if defined(_KBSERVER)
	if (pApp->m_bIsKBServerProject || pApp->m_bIsGlossingKBServerProject)
	{
		// BEW 28Apr16 cause OnIdle() to get authentication done, after wizard completes
		pApp->m_bEnteringKBserverProject = TRUE;
	}
	//#endif

		// whm 2Sept2021 added support for setting up an AutoCorrect feature to operate within 
		// the opened non-collaboration document.
		// NOTE: OnOpenDocument() only handles the opening of non-Collaboration documents. 
		// The setup up of AutoCorrect for collaboration document openings is done at the
		// end of the OK_btn_delayedHandler_GetSourceTextFromEditor() function in the 
		// CollabUtilities.cpp file.
	SetupAutoCorrectHashMap();

	pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

	return TRUE;
}

CLayout* CAdapt_ItDoc::GetLayout()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	return pApp->m_pLayout;
}

// return the CPile* at the passed in index, or NULL if the index is out of bounds;
// the pile list is at CLayout::m_pileList.
// CAdapt_ItView also has a member function of the same name
CPile* CAdapt_ItDoc::GetPile(const int nSequNum)
{
	// refactored 10Mar09, for new view layout design (no bundles)
	CLayout* pLayout = GetLayout();
	wxASSERT(pLayout != NULL);
	PileList* pPiles = pLayout->GetPileList();
	int nCount = pPiles->GetCount();
	if (nSequNum < 0 || nSequNum >= nCount)
	{
		// bounds error, so return NULL
		return (CPile*)NULL;
	}
	PileList::Node* pos_pPle = pPiles->Item(nSequNum); // relies on parallelism of
								// the m_pSourcePhrases and m_pileList lists
	wxASSERT(pos_pPle != NULL);
	return pos_pPle->GetData();
}

///////////////////////////////////////////////////////////////////////////////
/// \return TRUE if the current document has been modified; FALSE otherwise
/// \remarks
/// Called from: the App's GetDocHasUnsavedChanges(), OnUpdateFileSave(), OnSaveModified(),
/// CMainFrame's SyncScrollReceive() and OnIdle().
/// Internally calls the wxDocument::IsModified() method and the canvas->IsModified() method.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsModified() const // from wxWidgets mdi sample
{
	CAdapt_ItView* view = (CAdapt_ItView*)GetFirstView();

	if (view)
	{
		return (wxDocument::IsModified() || wxGetApp().GetMainFrame()->canvas->IsModified());
	}
	else
		return wxDocument::IsModified();
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param mod		-> if FALSE, discards any edits
/// \remarks
/// Called from: all places that need to set the document as either dirty or clean including:
/// the App's DoUsfmFilterChanges() and DoUsfmSetChanges(), the Doc's OnNewDocument(),
/// OnFileSave(), OnCloseDocument(), the View's PlacePhraseBox(), StoreText(), StoreTextGoingBack(),
/// ClobberDocument(), OnAdvancedRemoveFilteredFreeTranslations(), OnButtonDeleteAllNotes(),
/// OnAdvancedRemoveFilteredBacktranslations(), the DocPage's OnWizardFinish(), the CKBEditor's
/// OnButtonUpdate(), OnButtonAdd(), OnButtonRemove(), OnButtonMoveUp(), OnButtonMoveDown(),
/// the CNoteDlg's OnBnClickedNextBtn(), OnBnClickedPrevBtn(),
/// OnBnClickedFirstBtn(), OnBnClickedLastBtn(), OnBnClickedFindNextBtn(), the CPhraseBox's
/// OnPhraseBoxChanged(), CViewFilteredMaterialDlg's UpdateContentOnRemove(), OnOK(),
/// OnBnClickedRemoveBtn(), and (BEW added 28Nov12), the ViewFilteredMaterialDlg's OnOK() button.
/// Sets the Doc's dirty flag according to the value of mod by calling wxDocument::Modify(mod).
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::Modify(bool mod) // from wxWidgets mdi sample
{
	CAdapt_ItView* view = (CAdapt_ItView*)GetFirstView();
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxDocument::Modify(mod);

	if (!mod && view && pApp->GetMainFrame()->canvas)
		pApp->GetMainFrame()->canvas->DiscardEdits();
}


///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param      pList -> pointer to a SPList of source phrases
/// \remarks
/// Called from: the View's InitializeEditRecord(), OnEditSourceText(),
/// OnCustomEventAdaptationsEdit(), and OnCustomEventGlossesEdit().
/// If pList has any items this function calls DeleteSingleSrcPhrase() for each
/// item in the list. The boolean parameter is default FALSE (i.e. default is to
/// not attempt partner pile deletion)
/// BEW 26Mar10, no changes needed for support of doc version 5
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::DeleteSourcePhrases(SPList* pList, bool bDoPartnerPileDeletionAlso)
{
	// BEW added 21Apr08 to pass in a pointer to the list which is to be deleted (overload
	// of the version which has no input parameters and internally assumes the list is
	// m_pSourcePhrases) This new version is required so that in the refactored Edit Source
	// Text functionality we can delete the deep-copied sublists using this function.
	// BEW modified 27May09, to take the bool bDoPartnerPileDeletionAlso parameter,
	// defaulting to FALSE because the deep copied sublists never have partner piles
	//CAdapt_ItApp* pApp = &wxGetApp();
	//wxASSERT(pApp != NULL);
	// BEW 25Jun13 added next two lines, somehow on a new project this pList pointer would
	// go NULL, when first opening a doc file copied from elsewhere as the first doc of
	// the project
	if (pList == NULL)
		return;
	if (pList != NULL)
	{
		if (!pList->IsEmpty())
		{
			// delete all the tokenizations of the source text
			SPList::Node* node = pList->GetFirst();
			while (node)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)node->GetData();
				node = node->GetNext();
#ifdef _DEBUG
				//wxLogDebug(_T("   DeleteSourcePhrases pSrcPhrase at %p = %s"),
				//pSrcPhrase->m_srcPhrase, pSrcPhrase->m_srcPhrase.c_str());
#endif
				DeleteSingleSrcPhrase(pSrcPhrase, bDoPartnerPileDeletionAlso); // default
					// for the boolean passed in to DeleteSourcePhrases() is FALSE
			}
			pList->Clear();
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \remarks
/// Called from: the Doc's DeleteContents(), the View's ClobberDocument().
/// If the App's m_pSourcePhrases SPList has any items this function calls
/// DeleteSingleSrcPhrase() for each item in the list.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::DeleteSourcePhrases()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	//#define BOGUS_PREDELETE_OF_CSOURCEPHRASE_BUG
#ifdef BOGUS_PREDELETE_OF_CSOURCEPHRASE_BUG
#ifdef _DEBUG
	// In collaboration mode, one or more CSourcePhrase instances are being prematurely
	// deleted, and so when DeleteSingleSrcPhrase() is called on such ones (eg. as when
	// shutting down the app with the X button at top of window, which causes
	// OnCloseDocument() to be called) then a heap corruption error message results with
	// the message:
	// HEAP: Free Heap block <hex address> modified at <hex address> after it was freed
	// and the error can happen at an unexpected time too (but much rarer). Doc layout
	// doesn't crash, which makes me think it is in the saved m_pSavedWords instances that
	// the bogus deletions have happened. The code below scans all the parent pSrcPhrase
	// instances in the doc, and also any in their non-empty m_pSavedWords members, to
	// show in the Output window the sequ number the m_srcPhrase member. The idea is that
	// if there is a hanging ptr somewhere, the scan and display in the Output window will
	// cease at that point -- which tells us at least something useful. Added display of
	// the heap pointer value  (in hex) for each CSourcePhrase instance - so as to match
	// with the error report, since the error happens after this successful display of all of
	// the CSourcePhrase instances in the m_pSourcePhrase list.
	//
	// The bug fix? Bill found I'd used UngetWriteBuf() in wxString to restore a read-only
	// buffer I'd created with GetData() call - this is verbotten, and leads to heap
	// corruption; UngetWriteBuf() should only be used after a GetWriteBuf() call. I'd
	// made this error in two places.
	{

		SPList* pSrcPhrases = pApp->m_pSourcePhrases;
		if (pSrcPhrases != NULL)
		{
			SPList::Node* pos_pSP = pSrcPhrases->GetFirst();
			int sequnum = 0;
			int originalSN = 0;
			wxString srcStr;
			wxString originalSrcStr;
			CSourcePhrase* pOriginalSP = NULL;
			CSourcePhrase* pSrcPhrase = NULL; // parent ones, the ones laid out by RecalcLayout()
			// now scan over the whole doc, showing the info needed
			while (pos_pSP != NULL)
			{
				pSrcPhrase = pos_pSP->GetData();
				pos_pSP = pos_pSP->GetNext();
				sequnum = pSrcPhrase->m_nSequNumber;
				srcStr = pSrcPhrase->m_srcPhrase;
//				wxLogDebug(_T("\n ********************* Parent CSourcePhrase *************************"));
//				wxLogDebug(_T("sn = %d  srcPhrase = %s   HEX  %p"), sequnum, srcStr.c_str(), pSrcPhrase);
				if (!pSrcPhrase->m_pSavedWords->IsEmpty())
				{
//					wxLogDebug(_T("\n              ********       Originals      ********"));
					SPList* pOriginals = pSrcPhrase->m_pSavedWords;
					SPList::Node* posOriginal = pOriginals->GetFirst();
					while (posOriginal != NULL)
					{
						pOriginalSP = posOriginal->GetData();
						posOriginal = posOriginal->GetNext();
						// access members for display (this will crash if it's heap block has been freed)
						originalSN = pOriginalSP->m_nSequNumber;
						originalSrcStr = pOriginalSP->m_srcPhrase;
						// display info in the Output window
//						wxLogDebug(_T("              sn = %d  srcPhrase = %s   HEX  %p"),
//							originalSN, originalSrcStr.c_str(), pOriginalSP);
					}
				}
//				wxLogDebug(_T("    -------------------------------------------------"));
			} // loop ends
		}
	}
#endif
#endif

	if (pApp->m_pSourcePhrases != NULL)
	{
		if (!pApp->m_pSourcePhrases->IsEmpty())
		{
			// delete all the tokenizations of the source text
			SPList::Node* node = pApp->m_pSourcePhrases->GetFirst();
			while (node)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)node->GetData();
				node = node->GetNext();
#ifdef BOGUS_PREDELETE_OF_CSOURCEPHRASE_BUG
#ifdef _DEBUG && !defined(NOLOGS)
				wxString msg;
				msg = msg.Format(_T("Deleting    %s    at sequ num =  %d"),
					pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_nSequNumber);
				wxLogDebug(msg);
#endif
#endif
				DeleteSingleSrcPhrase(pSrcPhrase, FALSE); // FALSE is the
					// value for bDoPartnerPileDeletionAlso, because it is
					// more efficient to delete them later en masse with a call
					// to CLayout::DestroyPiles(), rather than one by one, as
					// the  one by one way involves a search to find the
					// partner, so it is slower
			}
			pApp->m_pSourcePhrases->Clear();
		}
	}
#ifdef BOGUS_PREDELETE_OF_CSOURCEPHRASE_BUG
#ifdef _DEBUG && !defined(NOLOGS)
	{
		wxString msg;
		msg = msg.Format(_T("Cleared  m_pSourcePhrases at end of DeleteSourcePhrases()"));
		wxLogDebug(msg);
	}
#endif
#endif
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param		pSrcPhrase -> the source phrase to be deleted
/// \remarks
/// Deletes the passed in CSourcePhrase instance, and if the bDoPartnerPileDeletionAlso bool value
/// is TRUE (its default value), then the partner pile in the CLayout::m_pileList list which
/// points at it is also deleted. Pass FALSE for this boolean if the CSourcePhrase being destroyed
/// is a temporary one in a list other than m_pSourcePhrases.
///
/// Called from: the App's DoTransformationsToGlosses(), DeleteSourcePhraseListContents(),
/// the Doc's DeleteSourcePhrases(), ConditionallyDeleteSrcPhrase(),
/// ReconstituteOneAfterPunctuationChange(), ReconstituteOneAfterFilteringChange(),
/// DeleteListContentsOnly(), ReconstituteAfterPunctuationChange(), the View's
/// ReplaceCSourcePHrasesInSpan(), TransportWidowedEndmarkersToFollowingContext(),
/// TransferCOmpletedSrcPhrases(), and CMainFrame's DeleteSourcePhrases_ForSyncScrollReceive().
///
/// Clears and deletes any m_pMedialMarkers, m_pMedialPuncts and m_pSavedWords before deleting
/// pSrcPhrase itself.
/// BEW 11Oct10, to support doc version 5's better handling of USFM fixedspace symbol ~,
/// we also must delete instances storing word1~word2 kind of content - if ~ is present,
/// then m_pSavedWords will contain two child CSourcePhrase pointers also to be deleted -
/// fortunately no code changes are needed to handle this.
/// BEW 13Sep22 add code to delete any cached data
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::DeleteSingleSrcPhrase(CSourcePhrase* pSrcPhrase, bool bDoPartnerPileDeletionAlso)
{
	// refactored 12Mar09
	if (pSrcPhrase == NULL)
		return;

	// if requested delete the CPile instance in CLayout::m_pileList which
	// points to this pSrcPhrase
	if (bDoPartnerPileDeletionAlso)
	{
		// this call is safe to make even if there is no partner pile, or if a matching
		// pointer is not in the list
		DeletePartnerPile(pSrcPhrase); // marks its strip as invalid as well
	}

	// 13Sep22 remove any cached string, only works right if pSrcPhrase->m_bHasInternalPunct is FALSE,
	// so set it false then call ClearCachedAttributesMetadata()
	pSrcPhrase->m_bHasInternalPunct = FALSE;
	//pSrcPhrase->ClearCachedAttributesMetadata();

	if (pSrcPhrase->m_pMedialMarkers != NULL)
	{
		if (pSrcPhrase->m_pMedialMarkers->GetCount() > 0)
		{
			pSrcPhrase->m_pMedialMarkers->Clear();
		}
		delete pSrcPhrase->m_pMedialMarkers;
		pSrcPhrase->m_pMedialMarkers = (wxArrayString*)NULL;
	}

	if (pSrcPhrase->m_pMedialPuncts != NULL)
	{
		if (pSrcPhrase->m_pMedialPuncts->GetCount() > 0)
		{
			pSrcPhrase->m_pMedialPuncts->Clear();
		}
		delete pSrcPhrase->m_pMedialPuncts;
		pSrcPhrase->m_pMedialPuncts = (wxArrayString*)NULL;
	}

	// also delete any saved CSourcePhrase instances forming a phrase (and these
	// will never have medial puctuation nor medial markers nor will they store
	// any saved minimal phrases since they are CSourcePhrase instances for single
	// words only (nor will it point to any CRefString instances) (but these will
	// have SPList instances on heap, so must delete those)
	// BEW note, 11Oct10, this block will also handle deletion of conjoined words using
	// USFM fixedspace symbol, ~
	if (pSrcPhrase->m_pSavedWords != NULL)
	{
		if (pSrcPhrase->m_pSavedWords->GetCount() > 0)
		{
			SPList::Node* node = pSrcPhrase->m_pSavedWords->GetFirst();
			while (node)
			{
				CSourcePhrase* pSP = (CSourcePhrase*)node->GetData();
				node = node->GetNext(); // need this for wxList
				if (pSP->m_pSavedWords != NULL) // whm 11Jun12 added NULL test
					delete pSP->m_pSavedWords;
				pSP->m_pSavedWords = (SPList*)NULL;
				if (pSP->m_pMedialMarkers != NULL) // whm 11Jun12 added NULL test
					delete pSP->m_pMedialMarkers;
				pSP->m_pMedialMarkers = (wxArrayString*)NULL;
				if (pSP->m_pMedialPuncts != NULL) // whm 11Jun12 added NULL test
					delete pSP->m_pMedialPuncts;
				pSP->m_pMedialPuncts = (wxArrayString*)NULL;
				if (pSP != NULL) // whm 11Jun12 added NULL test
					delete pSP;
				pSP = (CSourcePhrase*)NULL;
			}
		}
		if (pSrcPhrase->m_pSavedWords != NULL) // whm 11Jun12 added NULL test
			delete pSrcPhrase->m_pSavedWords; // delete the SPList* too
		pSrcPhrase->m_pSavedWords = (SPList*)NULL;
	}
	if (pSrcPhrase != NULL) // whm 11Jun12 added NULL test
		delete pSrcPhrase;
	pSrcPhrase = (CSourcePhrase*)NULL;
}

///////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param		pSrcPhrase -> the source phrase that was deleted
/// \remarks
/// Created 12Mar09 for layout refactoring. The m_pileList's CPile instances point to
/// CSourcePhrase instances and deleting a CSourcePhrase from the doc's m_pSourcePhrases
/// list usually needs to also have the CPile instance which points to it also deleted from
/// the corresponding place in the m_pileList. That task is done here. Called from
/// DeleteSingleSrcPhrase(), the latter having a bool parameter,
/// bDoPartnerPileDeletionAlso, which defaults to TRUE, and when FALSE is passed in this
/// function will not be called. (E.g. when the source phrase belongs to a temporary list
/// and so has no partner pile)
/// Note: the deletion will be done for some particular pSrcPhrase in the app's
/// m_pSourcePhrases list, and we want to have at least an approximate idea of the index
/// of which strip the copy of the pile pointer was in, because when we tweak the layout
/// we will want to know which strips to concentrate our efforts on. Therefore before we
/// do the deletion, we work out which strip the pile belongs to, mark it as invalid, and
/// store its index in CLayout::m_invalidStripArry. Later, our strip tweaking code will
/// use this information to make a speedy tweak of the layout before drawing is done (but
/// the information is not used whenever RecalcLayout() does a full rebuild of the
/// document's strips)
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::DeletePartnerPile(CSourcePhrase* pSrcPhrase)
{
	// refactored 4May09
	CLayout* pLayout = GetLayout();
	PileList* pPiles = pLayout->GetPileList();
	if (pPiles->IsEmpty())
		return;
	PileList::Node* posPile = pPiles->GetFirst();
	wxASSERT(posPile != NULL);
	CPile* pPile = NULL;
	while (posPile != NULL)
	{
		pPile = posPile->GetData();
		if (pSrcPhrase == pPile->GetSrcPhrase())
		{
			// we have found the partner pile, so break out
			break;
		}
		posPile = posPile->GetNext(); // go to next Node*
	} // end of while loop with test: posPile != NULL
	if (posPile == NULL)
	{
		return; // we didn't find a partner pile, so just return;
	}
	else
	{
		// found the partner pile in CLayout::m_pileList, so delete it...

		// get the CPile* instance currently at index, from it we can determine which strip
		// the deletion will take place from (even if we get this a bit wrong, it won't
		// matter)
		pPile = posPile->GetData();
		wxASSERT(pPile != NULL);
		MarkStripInvalid(pPile); // sets CStrip::m_bValid to FALSE, and adds the
								 // strip index to CLayout::m_invalidStripArray

		// now go ahead and get rid of the partner pile for the passed in pSrcPhrase
		pPile->SetStrip(NULL);

		// if destroying the CPile instance pointed at by app's m_pActivePile, set the
		// latter to NULL as well (otherwise, in the debugger it would have the value
		// 0xfeeefeee which is useless for pile ptr != NULL tests as it gives a spurious
		// positive result
		if (pLayout->m_pApp->m_nActiveSequNum != -1 && pLayout->m_pApp->m_pActivePile == pPile)
		{
			pLayout->m_pApp->m_pActivePile = NULL;
		}
		pLayout->DestroyPile(pPile, pLayout->GetPileList()); // destroy the pile, & remove
					// its node from m_pileList, because bool param, bRemoveFromListToo, is
					// default TRUE
		pPile = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param		pSrcPhrase -> the source phrase that was created and inserted in the
///                           application's m_pSourcePhrases list
/// \remarks
/// Created 13Mar09 for layout refactoring. The m_pileList's CPile instances point to
/// CSourcePhrase instances and creating a new CSourcePhrase for the doc's m_pSourcePhrases
/// list always needs to have the CPile instance which points to it also created,
/// initialized and inserted into the corresponding place in the m_pileList. That task is
/// done here.
///
/// Called from various places. It is not made a part of the CSourcePhrase creation process
/// for a good reason. Quite often CSourcePhrase instances are created and are only
/// temporary - such as those deep copied to be saved in various local lists during the
/// vertical edit process, and in quite a few other contexts as well. Also, when documents
/// are loaded from disk and very many CSourcePhrase instances are created in that process,
/// it is more efficient to not create CPile instances as part of that process, but rather
/// to create them all in a loop after the document has been loaded. For example, the
/// current code creates new CSourcePhrases on the heap in about 30 places in the app's
/// code, but only about 25% of those instances require a CPile partner created for the
/// CLayout::m_pileList; therefore we call CreatePartnerPile() only when needed, and it
/// should be called immediately after a newly created CSourcePhrase has just been inserted
/// into the app's m_pSourcePhrases list - so that the so that the strip where the changes
/// happened can be marked as "invalid".
/// Note: take care when CSourcePhrase(s) are appended to the end of the m_pSourcePhrases
/// list, because Creating the partner piles cannot handle discontinuities in the sequence
/// of piles in PileList. So, iterate from left to right over the new pSrcPhrase at the
/// list end, so that each CreatePartnerPile call is creating the CPile instance which is
/// next to be appended to PileList. We test for non-compliance with this rule and abort
/// the application if it happens, because to continue would inevitably lead to an app crash.
/// BEW 20Jan11, replacing partner piles is a problem in some circumstances, because the
/// pile count could change larger and so some new piles can't then be assigned to a
/// strip. This circumstance needs create_strips_keep_piles to be used for the
/// layout_selector enum value in RecalcLayout() in order to get the strips and piles in
/// sync; this comment is for information only, no code was changed below, except the
/// addition of AddUniqueInt() (an unrelated issue, the latter is to prevent duplicate
/// strip indices being stored in the m_invalidStripArray of CLayout)
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::CreatePartnerPile(CSourcePhrase* pSrcPhrase)
{
	// refactor 13Mar09
	CLayout* pLayout = GetLayout();
	int index = IndexOf(pSrcPhrase); // the index in m_pSourcePhrases for the passed
									 // in pSrcPhrase

	PileList::Node* aPosition = NULL;
	CPile* aPilePtr = NULL;
	wxASSERT(index != wxNOT_FOUND); // it must return a valid index!
	PileList* pPiles = pLayout->GetPileList();

	// if the pSrcPhrase is one added to the end of the document, there won't be any
	// existing pile pointers in the PileList with indices that large, so check for this
	// because an Item(index) call with an index out of range will crash the app, it
	// doesn't return a NULL which is what I erroneously though would happen
	PileList::Node* posPile = NULL;
	int lastPileIndex = pLayout->GetPileList()->GetCount() - 1;
	bool bAppending = FALSE;
	if (index > lastPileIndex + 1)
	{
		// we've skipped a pile somehow, this is a fatal error, tell developer and abort
		wxMessageBox(_T(
			"Ouch! CreatePartnerPile() has skipped a pSrcPhrase added to doc end, or they creations are not being done in left to right sequence. Must abort now."),
			_T(""), wxICON_ERROR | wxOK);
		wxASSERT(FALSE);
		wxExit();
	}
	else if (index == lastPileIndex + 1)
	{
		// we are creating the CPile instance which is due to be appended next tp PileList
		bAppending = TRUE;
	}
	else
	{
		// if control gets here with bAppending still FALSE, then an insertion is required
		posPile = pPiles->Item(index);
	}
	CPile* pNewPile = pLayout->CreatePile(pSrcPhrase); // creates a detached CPile
					// instance, initializes it, sets m_nWidth and m_nMinWidth etc
	if (!bAppending)
	{
		// we are inserting a new partner pile's pointer in the CLayout::m_pileList does
		// not get it also inserted in the CLayout::m_stripArray, and so the laid out
		// strips don't know of it. However, we can work out which strip it would be
		// inserted within, or thereabouts, and mark that strip as invalid and put its
		// index into CLayout::m_invalidStripArray. The inventory of invalid strips does
		// not have to be 100% reliable - they are approximate indicators where the layout
		// needs to be tweaked, which is all we need for the RecalcLayout() call later on.
		// Therefore, use the current pPile pointer in the m_pileList at index, and find
		// which strip that one is in, even though it is not the newly created CPile
		aPosition = pPiles->Item(index);
		aPilePtr = aPosition->GetData();
		if (aPilePtr != NULL)
			MarkStripInvalid(aPilePtr); // use aPilePtr to have a good shot at which strip
				// will receive the newly created pile, and mark it as invalid, and save
				// its index in CLayout::m_invalidStripArray; nothing is done if
				// aPilePtr->m_pOwningStrip is NULL

		// the indexed location is within the unaugmented CLayout::m_pileList; therefore an
		// insert operation is required; the index posPile value determined by index is the
		// place where the insertion must be done
		posPile = pPiles->Insert(posPile, pNewPile);
	}
	else
	{
		// appending, (see comment in block above for more details), so just mark the last
		// strip in m_stripArray as invalid, don't call MarkStripInvalid()
		aPosition = pPiles->GetLast(); // the one after which we will append the new one
		aPilePtr = aPosition->GetData();
		if (aPilePtr != NULL)
		{
			// do this manually... just mark the last strip as the invalid one, etc
			CStrip* pLastStrip = (CStrip*)pLayout->GetStripArray()->Last();
			pLastStrip->SetValidityFlag(FALSE); // makes m_bValid be FALSE
			int nStripIndex = pLastStrip->GetStripIndex();
			// BEW 20Jan11, changed to only add unique index values to the array
			AddUniqueInt(pLayout->GetInvalidStripArray(), nStripIndex); // this array makes
									// it easy to quickly compute which strips are invalid
		}
		// now do the append
		posPile = pPiles->Append(pNewPile); // do this only after aPilePtr is calculated
	}
}

// return the index in m_pSourcePhrases for the passed in pSrcPhrase
int CAdapt_ItDoc::IndexOf(CSourcePhrase* pSrcPhrase)
{
	wxASSERT(pSrcPhrase != NULL);
	SPList* pList = GetApp()->m_pSourcePhrases;
	int nIndex = pList->IndexOf(pSrcPhrase);
	return nIndex;
}

void CAdapt_ItDoc::ResetPartnerPileWidth(CSourcePhrase* pSrcPhrase,
	bool bNoActiveLocationCalculation)
{
	wxUnusedVar(bNoActiveLocationCalculation);

		// refactored 13Mar09 & some more on 27Apr09
	int index = IndexOf(pSrcPhrase); // the index in m_pSourcePhrases for the passed in
									 // pSrcPhrase, in the app's m_pSourcePhrases list
	wxASSERT(index != wxNOT_FOUND); // it must return a valid index!
	PileList* pPiles = GetLayout()->GetPileList();
	PileList::Node* posPile = pPiles->Item(index); // returns NULL if index lies beyond
												   // the end of m_pileList
	if (posPile != NULL)
	{
		CPile* pPile = posPile->GetData();
		wxASSERT(pPile != NULL);
		pPile->m_nMinWidth = pPile->CalcPileWidth(); // set m_nMinWidth - it's the maximum extent of the src,
							  // adapt or gloss text
		// mark the strip invalid and put the parent strip's index into
		// CLayout::m_invalidStripArray if it is not in the array already
		MarkStripInvalid(pPile);
	}
	else
	{
		// if it is null, this is a catastrophic error, and we must terminate the application;
		// or in DEBUG mode, give the developer a chance to look at the call stack
		wxMessageBox(_T(
			"Ouch! ResetPartnerPileWidth() was unable to find the partner pile. Must abort now."),
			_T(""), wxICON_EXCLAMATION | wxOK);
		wxASSERT(FALSE);
		wxExit();
	}
}

void CAdapt_ItDoc::MarkStripInvalid(CPile* pChangedPile)
{
	CLayout* pLayout = GetLayout();
	// we can mark a strip invalid only provided it exists; so if calling this in
	// RecalcLayout() after the strips were destroyed, and before they are rebuilt, we'd
	// be trying to access freed memory if we went ahead here without a test for strips
	// being in existence - so return if the m_stripArray has no contents currently
	if (pLayout->GetStripArray()->IsEmpty())
		return;
	// pChangedPile has to have a valid m_pOwningStrip (ie. a non-zero value), which may
	// not be the case for a set of newly created piles at the end of the document, so for
	// end-of-document scenarios we will code the caller to just assume the last of the
	// current strips and not call MarkStripInvalid() at all; but just in case one sneaks
	// through, test here and if it has a zero m_pOwningStrip value then exit without
	// doing anything (unfortunately we can't assume it will always be at the doc end)
	if (pChangedPile->GetStrip() == NULL)
	{
		// it's a newly created pile not yet within the current set of strips, so its
		// m_pOwningStrip member returned was NULL, we shouldn't have called this
		// function for this pChangedPile pointer, but since we did, we can only return
		// without doing anything
		return;
	}
	// if control gets to here, there are CStrip pointers stored in m_stripArray, and there
	// is an owning strip defined, so go ahead and mark the owning strip invalid
	wxArrayInt* pInvalidStripArray = pLayout->GetInvalidStripArray();
	CStrip* pStrip = pChangedPile->GetStrip();
	pStrip->SetValidityFlag(FALSE); // makes m_bValid be FALSE
	int nStripIndex = pStrip->GetStripIndex();
	// BEW 20Jan11, changed to only add unique index values to the array
	AddUniqueInt(pInvalidStripArray, nStripIndex); // this array makes it easy to quickly
												   // compute which strips are invalid
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param		pSrcPhrase -> the source phrase to be deleted
/// \param		pOtherList -> another list of source phrases
/// \remarks
/// Called from : the Doc's ReconstituteAfterPunctuationChange().
/// This function is used in document reconstitution after a punctuation change forces a
/// rebuild.
/// Clears and deletes any m_pMedialMarkers, m_pMedialPuncts before deleting
/// pSrcPhrase itself.
/// SmartDeleteSingleSrcPhrase deletes only those pSrcPhrase instances in its m_pSavedWords
/// list which are not also in the pOtherList.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::SmartDeleteSingleSrcPhrase(CSourcePhrase* pSrcPhrase, SPList* pOtherList)
{
	// refactored 12Mar09 - nothing was done here because it can be called only in
	// ReconstituteAdfterPunctuationChange() - and only then provided a merger could not be
	// reconstituted -- and so because all partner piles will need to be recreated anyway,
	//  just dealing with a few is pointless; code in that function will handle all instead
	if (pSrcPhrase == NULL)
		return;

	if (pSrcPhrase->m_pMedialMarkers != NULL)
	{
		if (pSrcPhrase->m_pMedialMarkers->GetCount() > 0)
		{
			pSrcPhrase->m_pMedialMarkers->Clear();
		}
		delete pSrcPhrase->m_pMedialMarkers;
	}

	if (pSrcPhrase->m_pMedialPuncts != NULL)
	{
		if (pSrcPhrase->m_pMedialPuncts->GetCount() > 0)
		{
			pSrcPhrase->m_pMedialPuncts->Clear();
		}
		delete pSrcPhrase->m_pMedialPuncts;
	}

	// also delete any saved CSourcePhrase instances forming a phrase (and these
	// will never have medial puctuation nor medial markers nor will they store
	// any saved minimal phrases since they are CSourcePhrase instances for single
	// words only (nor will it point to any CRefString instances) (but these will
	// have SPList instances on heap, so must delete those)
	if (pSrcPhrase->m_pSavedWords != NULL)
	{
		if (pSrcPhrase->m_pSavedWords->GetCount() > 0)
		{
			SPList::Node* pos_pSavedWords = pSrcPhrase->m_pSavedWords->GetFirst();
			while (pos_pSavedWords != NULL)
			{
				CSourcePhrase* pSP = (CSourcePhrase*)pos_pSavedWords->GetData();
				pos_pSavedWords = pos_pSavedWords->GetNext();
				SPList::Node* pos_otherList = pOtherList->Find(pSP);
				if (pos_otherList != NULL)
					continue; // it's in the other list, so don't delete it
				if (pSP->m_pSavedWords != NULL) // whm 11Jun12 added NULL test
					delete pSP->m_pSavedWords;
				if (pSP->m_pMedialMarkers != NULL) // whm 11Jun12 added NULL test
					delete pSP->m_pMedialMarkers;
				if (pSP->m_pMedialPuncts != NULL) // whm 11Jun12 added NULL test
					delete pSP->m_pMedialPuncts;
				if (pSP != NULL) // whm 11Jun12 added NULL test
					delete pSP;
			}
		}
		pSrcPhrase->m_pSavedWords->Clear();
		if (pSrcPhrase->m_pSavedWords != NULL) // whm 11Jun12 added NULL test
			delete pSrcPhrase->m_pSavedWords; // delete the SPList* too
	}
	if (pSrcPhrase != NULL) // whm 11Jun12 added NULL test
		delete pSrcPhrase;
}

// transfer info about punctuation which got changed, but which doesn't get transferred to
// the original pSrcPhrase (here, pDestSrcPhrase) from the new one resulting from the
// tokenization, for a conjoined pair (the new one is pFromSrcPhrase), unless we do it herein
void CAdapt_ItDoc::TransferFixedSpaceInfo(CSourcePhrase* pDestSrcPhrase, CSourcePhrase* pFromSrcPhrase)
{
	CSourcePhrase* pDestWord1SPh = NULL;
	CSourcePhrase* pDestWord2SPh = NULL;
	CSourcePhrase* pFromWord1SPh = NULL;
	CSourcePhrase* pFromWord2SPh = NULL;
	SPList::Node* destPos = pDestSrcPhrase->m_pSavedWords->GetFirst();
	pDestWord1SPh = destPos->GetData();
	destPos = pDestSrcPhrase->m_pSavedWords->GetLast();
	pDestWord2SPh = destPos->GetData();
	SPList::Node* fromPos = pFromSrcPhrase->m_pSavedWords->GetFirst();
	pFromWord1SPh = fromPos->GetData();
	fromPos = pFromSrcPhrase->m_pSavedWords->GetLast();
	pFromWord2SPh = fromPos->GetData();
	pDestWord1SPh->m_precPunct = pFromWord1SPh->m_precPunct; // copy any m_precPunct to list's first one
	pDestSrcPhrase->m_precPunct = pFromWord1SPh->m_precPunct; // put it also at top level
	pDestWord2SPh->m_follPunct = pFromWord2SPh->m_follPunct; // copy any 2nd word's m_follPunct to list's second one
	pDestSrcPhrase->m_follPunct = pFromWord2SPh->m_follPunct; // put it also at top level
	// handle transfer of m_follOuterPunct data
	pDestWord2SPh->SetFollowingOuterPunct(pFromWord2SPh->GetFollowingOuterPunct());
	pDestSrcPhrase->SetFollowingOuterPunct(pFromWord2SPh->GetFollowingOuterPunct()); // put it also at top level
	// the "outer" ones are handled, the "inner ones" are next - these are stored only on
	// the instances in each top level's m_pSavedWords list, and so we don't also copy
	// them to the top level
	pDestWord1SPh->m_follPunct = pFromWord1SPh->m_follPunct;
	// we do the next line, be it should always just be copying empty string to empty string
	pDestWord1SPh->SetFollowingOuterPunct(pFromWord1SPh->GetFollowingOuterPunct());
	pDestWord2SPh->m_precPunct = pFromWord2SPh->m_precPunct;

	// that handles the punctuation, now we must copy across any stored inline markers; in
	// a fixedspace conjoining, we store these only at the m_pSavedWords level, not at the
	// top level
	// First, do the inline ones for the first CSourcePhrase instance in m_pSavedWords
	pDestWord1SPh->SetInlineBindingEndMarkers(pFromWord1SPh->GetInlineBindingEndMarkers());
	pDestWord1SPh->SetInlineBindingMarkers(pFromWord1SPh->GetInlineBindingMarkers());
	pDestWord1SPh->SetInlineNonbindingMarkers(pFromWord1SPh->GetInlineNonbindingMarkers());
	pDestWord1SPh->SetInlineNonbindingEndMarkers(pFromWord1SPh->GetInlineNonbindingEndMarkers());
	// Second, do the inline ones for the second CSourcePhrase instance in m_pSavedWords
	pDestWord2SPh->SetInlineBindingEndMarkers(pFromWord2SPh->GetInlineBindingEndMarkers());
	pDestWord2SPh->SetInlineBindingMarkers(pFromWord2SPh->GetInlineBindingMarkers());
	pDestWord2SPh->SetInlineNonbindingMarkers(pFromWord2SPh->GetInlineNonbindingMarkers());
	pDestWord2SPh->SetInlineNonbindingEndMarkers(pFromWord2SPh->GetInlineNonbindingEndMarkers());

	// the caller will have already transferred data for m_markers and m_endMarkers at the
	// top level; here we have to copy the first to pDestWord1SPh, and the second to pDestWord2SPh
	pDestWord1SPh->m_markers = pDestSrcPhrase->m_markers;
	pDestWord2SPh->SetEndMarkers(pDestSrcPhrase->GetEndMarkers());

	// the lower level m_key members will need to be updated too, pFromSrcPhrase's lower
	// level instances have the new values which need to be transferred to the lower level
	// instances in pDestSrcPhrase
	pDestWord1SPh->m_key = pFromWord1SPh->m_key;
	pDestWord2SPh->m_key = pFromWord2SPh->m_key;
	// that should do it!
}

///////////////////////////////////////////////////////////////////////////////
/// \return     TRUE to indicate to the caller all is OK (the pSrcPhrase was updated),
///             otherwise return FALSE to indicate to the caller that fixesStr must have
///             a reference added, and the new CSourcePhrase instances must be abandoned
///             and the passed in pSrcPhrase retained unchanged
/// \param		pView		-> pointer to the View
/// \param		pList		-> pointer to m_pSourcePhrases (its use herein is deprecated)
/// \param		pos_callers	-> the iterator position locating the passed in pSrcPhrase
///                            pointer (its use herein is deprecated)
/// \param		pSrcPhrase	<- pointer of the source phrase
/// \param		fixesStr	-> (its use herein is deprecated, the caller adds to it if
///                            FALSE is returned)
/// \param		pNewList	<- the parsed new source phrase instances
/// \param		bIsOwned	-> specifies whether or not the pSrcPhrase passed in is one which is
///                            owned by another sourcephrase instance or not (ie. TRUE
///                            means that it is one of the originals stored in an owning
///                            CSourcePhrase's m_pSavedWords list member, FALSE means it
///                            is not owned by another and so is a candidate for
///                            adaptation/glossing and entry of its data in the KB;
///                            owned ones cannot be stored in the KB - at least not
///                            while they continue as owned ones)
/// \remarks
/// Called from: the Doc's ReconstituteAfterPunctuationChange()
/// Handles one pSrcPhrase and ignores the m_pSavedWords list, since that is handled within
/// the ReconstituteAfterPunctuationChange() function for the owning srcPhrase with
/// m_nSrcWords > 1. For the return value, see ReconstituteAfterPunctuationChange()'s
/// return value - same deal applies here.
/// BEW 11Oct10 (actually 21Jan11) modified to use FromSingleMakeSstr(), and to use the
/// TokenizeText() parser - but using target text and punctuation in order to obtain the
/// punctuation-less target text
/// BEW 8Mar11, changed so as not to try inserting new CSourcePhrase instances if the
/// pSrcPhrase passed in results in numElements > 1 in the TokenizeTextString() call
/// below, but just to leave pSrcPhrase unchanged in that case, abandon the new instances,
/// and return FALSE to have the caller put an appropriate entry in fixesStr
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::ReconstituteOneAfterPunctuationChange(CAdapt_ItView* pView,
	SPList*& WXUNUSED(pList), SPList::Node* WXUNUSED(pos_callers), CSourcePhrase*& pSrcPhrase,
	wxString& WXUNUSED(fixesStr), SPList*& pNewList, bool bIsOwned)
{
	// BEW added 5Apr05
	bool bHasTargetContent = TRUE; // assume it has an adaptation, clear below if not true
	bool bPlaceholder = FALSE; // default
	bool bNotInKB = FALSE; // default
	bool bRetranslation = FALSE; // default
	if (pSrcPhrase->m_bNullSourcePhrase) bPlaceholder = TRUE;
	if (pSrcPhrase->m_bRetranslation) bRetranslation = TRUE;
	if (pSrcPhrase->m_bNotInKB) bNotInKB = TRUE;

	wxString srcPhrase; // copy of m_srcPhrase member
	wxString targetStr; // copy of m_targetStr member
	wxString key; // copy of m_key member
	wxString adaption; // copy of m_adaption member
	wxString gloss; // copy of m_gloss member
	key.Empty(); adaption.Empty(); gloss.Empty();

	// setup the srcPhrase, targetStr and gloss strings - we must handle glosses too
	// regardless of the current mode (whether adapting or not)
	int numElements = 1; // default

	srcPhrase = FromSingleMakeSstr2(pSrcPhrase); // whm 5Feb2024 removed unused parameters - now calls FromSingleMakeSstr2()

	gloss = pSrcPhrase->m_gloss; // we don't care if glosses have punctuation or not
	if (pSrcPhrase->m_adaption.IsEmpty())
	{
		bHasTargetContent = FALSE;	// use to suppress copying of source punctuation
									// to an adaptation not yet existing
	}
	else
	{
		targetStr = pSrcPhrase->m_targetStr; // likewise, has punctuation, if any
	}

	// handle placeholders - these have elipsis ... as their m_key and m_srcPhrase
	// members, and so there is no possibility of punctuation changes having any effect
	// on these except possibly for the m_adaption member. Placeholders can occur
	// independently, or as part of a retranslation - the same treatment can be given
	// to instances occurring in either environment.
	SPList::Node* fpos;
	fpos = NULL;
	CSourcePhrase* pNewSrcPhrase;
	//SPList::Node* newpos;
	if (bPlaceholder)
	{
		// the adaptation, and gloss if any, is already presumably what the user wants,
		// so we'll just remove punctuation from the adaptation, and set the relevant members
		// (m_targetStr is already correct) - but only provided there is an existing adaptation
		pSrcPhrase->m_gloss = gloss;
		// remove any initial or final spaces before using it
		targetStr.Trim(TRUE); // trim right end
		targetStr.Trim(FALSE); // trim left end
		if (bHasTargetContent)
		{
			adaption = targetStr;
			// Note: RemovePunctuation() calls ParseWord() in order to give consistent
			// punctuation stripping with parsing text, src or tgt, in the rest of the app
			pView->RemovePunctuation(this, &adaption, from_target_text);
			pSrcPhrase->m_adaption = adaption;

			// update the KBs (both glossing and adapting KBs) provided it is
			// appropriate to do so
			if (!bPlaceholder && !bRetranslation && !bNotInKB && !bIsOwned)
				pView->StoreKBEntryForRebuild(pSrcPhrase, adaption, gloss);
		}
		return TRUE;
	}

	// BEW 8Jul05: a pSrcPhrase with empty m_srcPhrase and empty m_key can't produce
	// anything when passed to TokenizeTextString, and so to prevent numElements being
	// set to zero we must here detect any such sourcephrases and just return TRUE -
	// for these punctuation changes can produce no effect
	if (pSrcPhrase->m_srcPhrase.IsEmpty() && pSrcPhrase->m_key.IsEmpty())
		return TRUE; // causes the caller to use pSrcPhase 'as is'

	// reparse the srcPhrase string - if we get a single CSourcePhrase as the result,
	// we have a simple job to complete the rebuild for this passed in pSrcPhrase; if
	// we get more than one, we'll have to do something smarter... actually, it's too
	// complex to be smart, so we'll rely on visual editing after the fact to fix problems
	// that may have arisen
	srcPhrase.Trim(TRUE); // trim right end
	srcPhrase.Trim(FALSE); // trim left end
	numElements = pView->TokenizeTextString(pNewList, srcPhrase, pSrcPhrase->m_nSequNumber);
	//#ifdef _DEBUG
		//if (halt_here == 1)
		//{
		//	wxLogDebug(_T("  ReconsistuteOneAfterPunctuationChange: 5145  numElements = %d "),numElements);
		//}
	//#endif
	wxASSERT(numElements >= 1);
	pNewSrcPhrase = NULL;
	//newpos = NULL;
	if (numElements == 1)
	{
		// simple case - we can complete the rebuild in this block; note, the passed in
		// pSrcPhrase might be storing quite complex data - such as filtered material,
		// chapter & verse information and so forth, so we have to copy everything
		// across as well as update the source and target string members and
		// punctuation. The simplest direction for this copy is to copy from the parsed
		// new source phrase instance back to the original, since only m_key,
		// m_adaption, m_targetStr, precPunct and follPunct can possibly be different
		// in the new parse; it's unlikely m_srcPhrase will have changed, but just in case
		// I'll copy that too
		fpos = pNewList->GetFirst();
		pNewSrcPhrase = fpos->GetData();

		// BEW changed 10Mar11, so as to not copy anything other than the things affected,
		// as noted in the comment above. I'll leave the old code, which copied everything
		// redundantly, just in case I later change my mind.

		// next the text info and m_markers member
		pSrcPhrase->m_srcPhrase = pNewSrcPhrase->m_srcPhrase;
		pSrcPhrase->m_key = pNewSrcPhrase->m_key;
		pSrcPhrase->m_precPunct = pNewSrcPhrase->m_precPunct;
		pSrcPhrase->m_follPunct = pNewSrcPhrase->m_follPunct;

		// finally, the new docV5 members...
		pSrcPhrase->SetFollowingOuterPunct(pNewSrcPhrase->GetFollowingOuterPunct());

		// the adaptation, and gloss if any, is already presumably what the user wants,
		// so we'll just remove punctuation from the adaptation, and set the relevant members
		// (m_targetStr is already correct) - but only provided there is an existing adaptation

		// remove any initial or final spaces before using it
		targetStr.Trim(TRUE); // trim right end
		targetStr.Trim(FALSE); // trim left end
		pSrcPhrase->m_targetStr = targetStr;
		if (bHasTargetContent)
		{
			adaption = targetStr;
			pView->RemovePunctuation(this, &adaption, from_target_text);
			pSrcPhrase->m_adaption = adaption;

			// update the KBs (both glossing and adapting KBs) provided it is
			// appropriate to do so
			if (!bPlaceholder && !bRetranslation && !bNotInKB && !bIsOwned)
				pView->StoreKBEntryForRebuild(pSrcPhrase, pSrcPhrase->m_adaption, pSrcPhrase->m_gloss);
		}
		if (IsFixedSpaceSymbolWithin(pSrcPhrase))
		{
			// it's a conjoined pair, so there is more data to be transferred for the
			// instances in m_pSavedWords member (this actually transfers heaps of stuff
			// redundantly, but fixedspace conjoinings are so rare, it's not worth the
			// bother of making the adjustments to eliminate the redundant transfers)
			TransferFixedSpaceInfo(pSrcPhrase, pNewSrcPhrase);
		}
		return TRUE;
	}
	else
	{
		// BEW 8Mar11, deprecated the code for replacing pSrcPhrase with the two or more
		// tokenized instances resulting from the punctuation change - it's better to just
		// accept pSrcPhrase unchanged, add a ref to fixesStr in the caller, and return
		// FALSE to ensure that happens. (Caller cleans up pNewList, so can just return
		// here without any prior cleanup.)
		return FALSE;
	} // end of else block for test: if (numElements == 1)
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		FALSE if the rebuild fails internally at one or more locations so that the
///				user must later inspect the doc visually and do something corrective at such
///				locations; TRUE if the rebuild was successful everywhere.
/// \param		pView		-> pointer to the View
/// \param		pList		-> pointer to m_pSourcePhrases
/// \param		fixesStr	-> currently unused
/// \remarks
/// Called from: the Doc's RetokenizeText().
/// Rebuilds the document after a filtering change is indicated. The new document reflects
/// the new filtering changes.
/// BEW added 18May05
/// BEW (?)refactored 18Mar09
/// BEW 20Sep10, old code expected filtered info to only be in m_markers, so for
/// docVersion 5 the code for unfiltering needs to use m_filteredInfo instead; similarly
/// for the code for filtering (that is, store in m_filteredInfo, not m_markers)
/// BEW 22Sep10, finished updated for support of docVersion 5 (significant changes
/// required, and I expanded the comments considerably to make the logic easier to follow,
/// but I didn't remove the goto statements)
/// BEW 11Oct10, radically rewrote the inner loop and got rid of gotos (except one) and
/// used RebuildSourceText() call to construct the filteredStr -- which saves mobs of code
/// BEW 20Sep19 refactored the unfiltering to unfilter to the position in the list which
/// is after (rather than before) the CSourcePhrase which carries the filtered info; and likewise
/// if filtering, to store it to the CSourcePhrase which precedes.
///  information on the CSourcePhrase which precedes the unfiltered information in the doc
/// BEW 30Aug22 fixed the following bug: filtering \f ... \f* did not stop at the end of the
/// filter span, but continued filtering of piles until the next marker was encountered. This
/// resulted in adaptations being thrown away in the piles following the correct filter span.
/// The error was a logic error in the code in HasMatchingEndMarker() which caused FALSE to
/// be returned, instead of TRUE (for a successful match) - and so filtering did not halt.
/// whm 24Oct2023-3Jan2024 refactored the filtering and unfiltering parts, fixed some errors
/// and removed two goto statements and labels for simplification.
/// The unfiltering routine now has an outer for loop to process one marker-being-unfiltered
/// at a time.
//////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::ReconstituteAfterFilteringChange(CAdapt_ItView* pView,
	SPList*& pList, wxString& fixesStr)
{
	// Filtering has changed
	bool bSuccessful = TRUE;
	wxString endingMkrsStr; // BEW added 25May05 to handle endmarker sequences like \fq*\f*

	// Recalc the layout in case the view does some painting when the progress
	// was removed earlier or when the bar is recreated below
	UpdateSequNumbers(0); // get the numbers updated, as a precaution
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(gpApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(gpApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	gpApp->m_pActivePile = pView->GetPile(gpApp->m_nActiveSequNum);
	GetLayout()->PlaceBox();

	// put up a progress indicator
	int nOldTotal = pList->GetCount();
	if (nOldTotal == 0)
	{
		return 0;
	}
	int nOldCount = 0;

	// whm 26Aug11 Open a wxProgressDialog instance here for filtering change operations.
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	wxString msgDisplayed;
	const int nTotal = gpApp->GetMaxRangeForProgressDialog(App_SourcePhrases_Count) + 1;
	wxString progMsg = _("Pass 1 - %d of %d Total words and phrases");
	msgDisplayed = progMsg.Format(progMsg, 1, nOldTotal);
	CStatusBar* pStatusBar = NULL;
	pStatusBar = (CStatusBar*)gpApp->GetMainFrame()->m_pStatusBar;
	pStatusBar->StartProgress(_("Processing Filtering Change(s)"), msgDisplayed, nTotal);

	// BEW added 29Jul09, turn off CLayout Draw() while strips and piles could get
	// inconsistent with each other
	GetLayout()->m_bInhibitDraw = TRUE;

	// Set up a rapid access string for the markers changed to be now unfiltered,
	// and another for the markers now to be filtered. Unfiltering has to be done
	// before filtering is done.
	// whm 3Jan2024 addition.
	// Add two arrays markersToBeFilteredArr and markersToBeUnfilteredArr. This
	// will allow some simplification in processing the filtering changes received from
	// changes to the filter state of markers done in the "USFM and Filtering" tab of
	// Preferences.
	wxString strMarkersToBeUnfiltered;
	wxString strMarkersToBeFiltered;
	strMarkersToBeUnfiltered.Empty();
	strMarkersToBeFiltered.Empty();

	wxArrayString markersToBeUnfilteredArr;
	markersToBeUnfilteredArr.Clear();
	wxArrayString markersToBeFilteredArr;
	markersToBeFilteredArr.Clear();

	wxString valStr;
	// the m_FilterStatusMap has only the markers which have their filtering status changed
	MapWholeMkrToFilterStatus::iterator iter;
	for (iter = gpApp->m_FilterStatusMap.begin(); iter != gpApp->m_FilterStatusMap.end(); ++iter)
	{
		if (iter->second == _T("1"))
		{
			strMarkersToBeFiltered += iter->first + _T(' ');
		}
		else
		{
			wxString augMkrTemp = iter->first + _T(' ');
			augMkrTemp.Trim(FALSE); // trim any whitespace off front of marker
			strMarkersToBeUnfiltered += augMkrTemp;
			markersToBeUnfilteredArr.Add(augMkrTemp); // the array holds augmented space final marker elements
		}
	}

	// define some useful flags which will govern the code blocks to be entered
	bool bUnfilteringRequired = TRUE;
	bool bFilteringRequired = TRUE;
	// next two can have no markers but a single space, so the IsEmpty() test won't be
	// valid unless any whitespace preceding the markers is removed - which, of course,
	// removes any whitespace which comprises the whole content of either
	strMarkersToBeFiltered.Trim(FALSE); // trim whitespace off left end
	strMarkersToBeUnfiltered.Trim(FALSE); // trim whitespace off left end
	if (strMarkersToBeFiltered.IsEmpty())
		bFilteringRequired = FALSE;
	if (strMarkersToBeUnfiltered.IsEmpty())
		bUnfilteringRequired = FALSE;

	// BEW 30Sep19 If filtering, set the m_bCurrentlyFiltering boolean, in case
	// what's to be filtered contains hidden USFM3 attributes metadata that
	// needs to be un-hidden before the string for being filtered is finalized
	if (bFilteringRequired)
	{
		m_bCurrentlyFiltering = TRUE;
	}
	else
	{
		m_bCurrentlyFiltering = FALSE;
	}

	// in the block below we determine which SFM set's map to use, and determine what the full list
	// of filter markers is (the changed ones will be in m_FilterStatusMap); we need the map so we
	// can look up USFMAnalysis struct instances
	MapSfmToUSFMAnalysisStruct* pSfmMap;
	pSfmMap = gpApp->GetCurSfmMap(gpApp->gCurrentSfmSet);

	// reset the appropriate USFMAnalysis structs so that TokenizeText() calls will access
	// the changed filtering settings rather than the old settings (this also updates the app's
	// rapid access strings, by a call to SetupMarkerStrings() done just before returning)
	ResetUSFMFilterStructs(gpApp->gCurrentSfmSet, strMarkersToBeFiltered, strMarkersToBeUnfiltered);

	// Initialize for the loops. We must loop through the sourcephrases list twice - the
	// first pass will do all the needed unfilterings, the second pass will do the
	// required new filterings - trying to do these tasks in one pass would be much more
	// complicated and therefore error-prone.
	SPList::Node* pos_pList;
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pLastSrcPhrase = NULL;
	int nFound = -1;
	// whm 3Jan2024 note: offset is now only used in the if (!pSrcPhrase->GetFilteredInfo_After().IsEmpty()) block much later below
	int offset = 0; 
	int nEnd = 0;
	wxString filterBeginMkr = _T("\\~FILTER "); // note: includes a following space
	wxString filterEndMkr = _T("\\~FILTER*"); // note: includes final asterisk but no following space

	wxString preStr;
	wxString remainderStr;
	SPList* pSublist = new SPList;
	// BEW 20Sep10, for docVersion 5, the former tests of m_markers become tests of
	// m_filteredInfo, and restorage  to preStr uses content only from that

	// do the unfiltering pass through m_pSourcePhrases
	int curSequNum = -1;
	if (bUnfilteringRequired)
	{
		// whm 3Jan2024 modification. 
		// To simplify the "carry backwards" of filtered material being unfiltered, we 
		// need to process one marker-to-be-unfiltered at a time within a for loop that
		// processes one element of markersToBeUnfilteredArr array for each iteration of
		// the for loop below. 
		int mkrCount = (int)markersToBeUnfilteredArr.GetCount();
		for (int mkrIndex = 0; mkrIndex < mkrCount; mkrIndex++)
		{
			wxString augMarkerBeingUnfiltered = markersToBeUnfilteredArr.Item(mkrIndex);// whm 3Jan2024 added

			// BEW added 6Dec19
			m_currentUnfilterMkr = wxEmptyString; // Needed when unfiltering 
				// a short span of filtered information; IsUnstructuredPlainText()
				// makes use of it - to help with USFM3 attributes metadata hiding

			pos_pList = pList->GetFirst();
			bool bDidSomeUnfiltering;
			bool bIsFirstNode = TRUE;
			bool bDidSomeUnfiltering_After;

			// [deprecated] BEW 30Sep19 We filter to the first pSrcPhrase after the span, 
			// so when unfiltering we must insert the unfiltered content immediately before
			// that pSrcPhase. 
			// 
			// whm 15Nov2023 refactored and coding and comments simplified 3Jan2024.
			// As a general rult, we now filter to a PREVIOUS pSrcPhrase position BEFORE 
			// the being-filtered-span, and we now unfilter to a FOLLOWING pSrcPhrase
			// position AFTER the being-unfiltered-span.
			// The simple case is when there is a single non-adjacent marker. When it
			// is being filtered the filtered marker and associated text is "carried
			// forward" and stored on the source phrase immediately preceding the marker-
			// being-filtered. When a marker is being unfiltered the marker and its
			// associated text is extracted from storage, tokenized into a sub-list and
			// "carried backward" where the sub-list is inserted immediately following 
			// the source phrase location where the marker and associated text had been
			// stored.
			// The more complicated case is when more than one filterable marker is 
			// involved in either the filtering or unfiltering process, that is where
			// adjacent markers need to be filtered to a given source phrase, or unfiltered
			// from a given source phrase. This can happen during filtering when the last
			// word of text associated with a marker that is being filtered, has itself
			// already stored some filtered information from a previously filtered marker
			// (adjacent) following the marker being filtered. In such cases the filtered
			// information needs to be combined together during the "carrying forward"
			// process and stored together on the same source phrase. In such cases it is
			// important that the ordering of multiple filtered markers be correctly
			// stored so that the order reflects the order the markers had in the original
			// input text. This makes the unfiltering process simpler, and is generally
			// required in order for the RebuildSourceText() routine to correctly handle
			// filtered information when recreating the source text for export.
			// When more than one filterable marker is stored on a single source phrase
			// the process of unfiltering is a bit more complex. In such cases, any
			// filtered information being stored BEFORE the marker currently-being-unfiltered
			// needs to remain stored on the source phrase, and any filtered information that
			// was stored AFTER the marker currently-being-unfiltered needs to be "carried
			// backwards" to the last word of the associated text of the marker-being-
			// unfiltered once its associated text has been tokenized and inserted into
			// the main document.
			// 
			// For example, suppose the following 4 markers were all adjacent in the
			// original text and occured in the following order: \ms \mr \s \r. This
			// is a common occurrence in the Nyindrou NT books. By default the \mr and 
			// \r markers are filtered when the document is intially parsed. However,
			// it is quite possible a user might also filter the \ms and \s markers 
			// while intially adapting the sacred text withoutk having any major \ms or
			// regular \s section headings visible in the sacred text.
			// Then, let's suppose that the user decides to unfilter each of the 4 
			// markers separately. With a dumb method - that doesn't treat the stored
			// filtered information discretely - but simply inserts the marker-
			// being-unfiltered AFTER the pSrcPhrase where it was stored, the markers
			// would get unfiltered in their original adjacent ordering, only if the 
			// user were to unfilter them in reverse order starting with \r, then \s, 
			// then \mr, then \ms - would the resulting order get back to the original 
			// ordering of \ms \mr \s \r. This would work out OK because the usual
			// insertion point would be immediately following the pSrcPhrase that 
			// contains the filtered information for all 4 markers. 
			// However, let's suppose that the user decides to unfilter all 4 markers, 
			// starting with the \ms marker. With the dumb method, the \ms marker gets 
			// unfiltered immediately AFTER the pSrcPhrase that contained all 4 markers 
			// in its m_filteredInfo member. In this case, the \ms marker is unfiltered 
			// in its correct position/ordering, immediately following the pSrcPhrase 
			// where it was stored as filtered information. 
			// However, let's suppose the user then decides to unfilter the \s marker. 
			// If we unfilter the \s marker and its associated text in the usual place 
			// - immediately after the pSrcPhrase containing the filtered information - 
			// the \s marker and its associated text would get placed AFTER pSrcPhrase, 
			// but BEFORE the previously unfiltered \ms marker and its associated 
			// text - resulting in a wrong ordering of the markers and associated text:
			// \s ... \ms ... instead of \ms ... \s .... 
			// Proper handling of the filtered information needs to be smarter when
			// unfiltering multiple adjacent markers. Stored filtered material that is
			// adjacent to, but PRIOR to, the marker currently-being-unfiltered needs
			// to stay stored in its current location, the currently-being-unfiltered
			// marker's associated text tokenized and its sub-list of source phrases
			// inserted into the main text, and then any other stored filtered material
			// that is adjacent to, but FOLLOWING, the marker currently-being-unfiltered
			// needs to be "carried backwards" and stored on the last source phrase word
			// of the sub-list that was inserted for the currently-being-unfiltered
			// marker.
			// The above strategy only works if we ensure that multiple adjacent markers
			// are stored in their original ordering that they had in the input text
			// when it was intially parsed into AI as a source text. See comments
			// in the if (bFilteringRequired) block below for more information on how
			// we ensure that filtered information for multiple adjacent markers is
			// stored in the original ordering.

			// NOTE: We are currently in the TRUE block if (bUnfilteringRequired)

			// [BEW comment] At doc start, there won't be any unfilterable info
			// yet because there was no opportunity for filtering something.
			// Use bIsFirstNode == FALSE  to suppress that scenario
			//
			// whm 26Nov2023 modification.
			// I've changed the insertion of markers-being-unfiltered to AFTER the
			// current pSrcPhrase instance, rather than BEFORE the pSrcPhrase location.
			// Hence, I've added a follPos node pointer and changed the name of the
			// saveNextPos node pointer to saveFollPos with corresponding adjustments
			// to their assignments below.

			SPList::Node* saveNextPos = NULL;
			SPList::Node* prevPos = NULL;
			SPList::Node* follPos = NULL; // whm 26Nov2023 added but unused.
			follPos = follPos;  // avoid gcc set but not used warning

			// Unfiltering loop starts - each iteration deals with one CSourcePhrase instance
			while (pos_pList != NULL)
			{
				// looping over a pSrcPhrase at a time
				if (bIsFirstNode)
				{
					pSrcPhrase = (CSourcePhrase*)pos_pList->GetData(); // Get pSrcPhrase
					saveNextPos = pos_pList; // We insert somewhere, before this location - stays fixed  while we do so
					pos_pList = pos_pList->GetNext(); // moves the pointer/iterator to the next node, ready for iteration
					bIsFirstNode = FALSE; // skip this block for subsequent iterations
					continue;
				}
				else
				{
					prevPos = saveNextPos; // RHS was set before moving to next Node ptr, so is 'previous' still
					saveNextPos = pos_pList; // now we  can update it to current Node
					if (pos_pList != NULL)
					{
						pSrcPhrase = (CSourcePhrase*)pos_pList->GetData(); // Get pSrcPhrase
					}
					else
					{
						break; // at doc  end
					}
					// Get pos_pList ready for next iteration
					pos_pList = pos_pList->GetNext(); // moves the pointer/iterator to the next node
					if (pos_pList != NULL)
					{
						follPos = pos_pList;
					}

					// [BEW] The block above does this: (1) saveNextPos is where inserts happen before it
					// (2) pSrcPhrase was obtained before pos_pList moved move one past saveNextPos location
					// (3) there's not much need for prevPos, but we calculate it since it's used
					//     for setting pLastSrcPhrase at appox line 7802 (now deprecated), and approx 
					//     line 8480 for dealing with a merger
				}
	#if defined (_DEBUG) //&& !defined(NOLOGS)
				wxString filteredInfo = pSrcPhrase->GetFilteredInfo();
				if (!filteredInfo.IsEmpty())
				{
					wxLogDebug(_T("Doc,Unfiltering, Line %d : At sequNum = %d , m_srcPhrase = %s ,  m_filteredInfo: %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), filteredInfo.c_str());
				}
				else
				{
					wxLogDebug(_T("Doc,Unfiltering, Line %d : At sequNum = %d , m_srcPhrase = %s  , NO FILTERING STORED"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str());
				}
				if (pSrcPhrase->m_nSequNumber >= 422)
				{
					int halt_here = 1; halt_here = halt_here; // avoid gcc warning
				}
	#endif
				curSequNum = pSrcPhrase->m_nSequNumber;
				bDidSomeUnfiltering = FALSE;

				preStr.Empty();
				remainderStr.Empty();

				bool bWeUnfilteredSomething = FALSE;
				wxString bareMarker;

				// [BEW} acts on ONE instance of pSrcPhrase only each time it loops, but in so doing
				// it may add many by removing FILTERED status for a series of sourcephrase instances
				// (all such will be sourced from within m_filteredInfo {or m_filteredInfo_After
				// if using ParseWord2() rather than the legacy parser; I expect we will never use ParseWord2()}
				// because notes, free trans, and collected free translations are not unfilterable)

				// whm 3Jan2024 Simplified code below by testing if the augMarkerBeingUnfiltered string
				// is found within the m_filteredInfo member, rather than parsing through all the filtered
				// info using the while loop as done previously.
				wxString theFilteredInfo = pSrcPhrase->GetFilteredInfo();
				if (!theFilteredInfo.IsEmpty()) // do nothing when m_filteredInfo is empty
				{
					// m_markers often has an initial space, which is a nuisance, so check and remove
					// it if present (this can remain here, the change, if done, is benign)
					// whm modified 7Jul12. Eliminated the m_markers[0] array access. Any initial space
					// can more reliably be removed by the using the wxString::Trim() method. The m_markers
					// here is not likely to be empty, but to be safe we should not use m_markers[0] array
					// access.
					pSrcPhrase->m_markers.Trim(FALSE); // trim any space from left end

					// for pSrcPhrase, loop across any filtered substrings in m_filteredInfo, 
					// until no more are found. Often there is one only, but if storing more
					// than one (can be the case where 2 or more adjacent markers along with
					// their associated text have been filtered), the loop lets us cherry-pick
					// the content with the matching filterMkr, that's what we will unfilter.
					// 
					// whm 3Jan2024 removed the complex while loop that started here.
					//while ((offset = FindFromPos(pSrcPhrase->GetFilteredInfo(), filterMkr, offset)) != -1)

					wxString augMkrWithInitialFilterBracket = filterBeginMkr + augMarkerBeingUnfiltered;
					int posFilteredMkr = theFilteredInfo.Find(augMkrWithInitialFilterBracket);
					if (posFilteredMkr != wxNOT_FOUND)
					{
						// We found the marker, its posFilteredMkr is the index of the \~FILTER+augMarkerBeingUnfiltered
						// Now extract the filter string itself, and in the process of getting it, also get its 
						// previous substring preStr, and following remainderStr if they exist. They will all still 
						// be bracketed by \~FILTER ...\~FILTER*
						// whm 8Feb2024 this block revised to take into account that theFilteredInfo might be 
						// prefixed with one or more swept up markers.
						// 
						// TODO: Use GetFilteredInfoSegments() function here

						wxString wholeMkrWithFilterBrackets;
						int posFilteredMkrEndBracket;
						wholeMkrWithFilterBrackets = theFilteredInfo.Mid(posFilteredMkr);
						preStr = theFilteredInfo.Mid(0, posFilteredMkr);
						// whm 5Feb2024 added. To protect against assigning whitespace only in a SetFilteredInfo(preStr)
						// call I'm trimming off any initial whitespace on preStr
						preStr.Trim(FALSE); // whm 5Feb2024 added
						posFilteredMkrEndBracket = wholeMkrWithFilterBrackets.Find(filterEndMkr);
						if (posFilteredMkrEndBracket != wxNOT_FOUND)
						{
							remainderStr = wholeMkrWithFilterBrackets.Mid(posFilteredMkrEndBracket + filterEndMkr.Length());
							// whm 5Feb2024 addition. Trim the remainderStr to remove any whitespace. If remainderStr only
							// consists of whitespace, then we don't want it to add just whitespace in the SetFilteredInfo()
							// call farther below. If the m_filteredInfo then just contains whitespace it will cause the 
							// green wedge to appear for the location making the user think there is filtered info there
							// when there isn't; and if the bogus green wedge is clicked on the ViewFilteredMaterialDlg's
							// InitDialog() method can generate an assert/crash.  
							remainderStr.Trim(); // whm 5Feb2024 added
							wholeMkrWithFilterBrackets = wholeMkrWithFilterBrackets.Mid(0, posFilteredMkrEndBracket + filterEndMkr.Length());
						}
						
						// augMarkerBeingUnfiltered is not empty, so preserve a copy of it on the CAdapt_ItDoc
						// instance, which the check for unstructured source test can use
						if (!augMarkerBeingUnfiltered.IsEmpty())
						{
							m_currentUnfilterMkr = augMarkerBeingUnfiltered; // m_currentUnfilterMkr = mkr;
	#if defined (_DEBUG) && !defined(NOLOGS)
							wxLogDebug(_T("%s::%s(), line= %d, doc's m_currentUnfilterMkr: %s (Helps check for non-USFM src text)"),
								__FILE__, __FUNCTION__, __LINE__, m_currentUnfilterMkr.c_str());
	#endif
						}

						if (augMarkerBeingUnfiltered.IsEmpty())
						{
							// there was an error here... post a reference to its location
							// sequence numbers may not be uptodate, so do so first over whole list so that
							// the attempt to find the chapter:verse reference string will not fail
							pView->UpdateSequNumbers(0);
							if (!gbIsUnstructuredData)
							{
								fixesStr += pView->GetChapterAndVerse(pSrcPhrase);
								fixesStr += _T("  ");
							}
							bSuccessful = FALSE; // make sure the caller will show the error box

							m_currentUnfilterMkr.Empty(); // restore default empty state
							break; // exit this inner loop & iterate to the next CSourcePhrase instance
								   // or to what is in m_filteredInfo_After
						}

						// *****************
						// whm 3Jan2024 Testing NOTE concerning unknown markers:
						// A unit test with unknown markers indicates that
						// the unknown marker is inserted as unfiltered into the document's 
						// marker list in the "USFM and Filtering" tab of Preferences.
						// From there it can be unfiltered or filtered at will without
						// problems. While the marker itself \unm is stored within the source
						// phrase's m_markers field and as ?unm? in the m_inform field, and
						// any associated text displayed in red in the main window.
						// When filtered the unknown marker is stored in the previous source
						// phrase's m_filteredInfo field in the usual way. 
						// Therefore it doesn't appear that any further action needs to be
						// taken to properly handle the occurrence of unknown markers. 
						// *****************

						// Setup for unfiltering and do so
						bDidSomeUnfiltering = TRUE; // used for updating navText on original pSrcPhrase when done
						bWeUnfilteredSomething = TRUE; // used for reseting initial conditions in inner loop
						pSublist->Clear(); // clear list in preparation for Tokenizing
					
						wxString extractedStr = RemoveAnyFilterBracketsFromString(wholeMkrWithFilterBrackets); // we'll tokenize LHSide

						// tokenize the substring (using this we get its inline marker handling for free)
						extractedStr.Trim(FALSE); // remove any initial space
						wxASSERT(extractedStr[0] == gSFescapechar);

						int count = pView->TokenizeTextString(pSublist, extractedStr, pSrcPhrase->m_nSequNumber);
						bool bIsContentlessMarker = FALSE;

						// pSublist now has the tokenized unfiltered data

						USFMAnalysis* pSfm = NULL;	// whm moved here from below to ensure it is
													// initialized before call to AnalyseMarker

						bool bHaventAClueWhatItIs = FALSE; // if it's really something
															// unexpected, set this TRUE below
						int curPos = -1;
						if (!pSublist->IsEmpty())
						{
							// Note: wxList::GetLast() returns a node, not a pointer to a
							// data item, so we do the GetLast operation in two parts
							SPList::Node* lastPos = pSublist->GetLast();
							CSourcePhrase* pTailSrcPhrase = lastPos->GetData();
							if (pTailSrcPhrase)
							{
								// This block is for markup error recovery - in early versions
								// of Adapt It when markers were all stored in m_markers. 
								// It may not be very relevant now at Dec 2019
								if (pTailSrcPhrase->m_key.IsEmpty() && !pTailSrcPhrase->m_markers.IsEmpty())
								{
									// BEW 20Sep10, m_markers now won't ever store an endmarker, but
									// it could be an unknown marker (see comments above)
									wxString endmarkersStr = pTailSrcPhrase->m_markers;
									curPos = endmarkersStr.Find(_T('*'));
									if (curPos == wxNOT_FOUND)
									{
										// it's not an endmarker, but a contentless (probably unknown) marker
										bIsContentlessMarker = TRUE;
										endingMkrsStr.Empty();	// no endmarkers, so none to later insert
																// on this iteration
										// whm 3Jan2024 removed the goto f statement
									}

									if (!bIsContentlessMarker)
									{
										// filtered info is not contentless, so is there a marker?
										curPos = endmarkersStr.Find(gSFescapechar);
										if (curPos == -1)
										{
											// we found no marker at all, don't expect this,
											// but do what we must (ie. ignore the rest of the
											// block), and set the bool which tells us we are
											// stymied (whatever it is, we'll just make it
											// appear as adaptable source text further down in
											// the code)
											bHaventAClueWhatItIs = TRUE;
											endingMkrsStr.Empty(); // can't preserve what we failed to find
											// whm 3Jan2024 removed the goto h statement; // skip all the marker calcs, since it's not a marker
										}
									}

								} // end of block for detecting the parsing of an endmarker
							} // end of TRUE block for test: if (pTailSrcPhrase)
						} // end of if (!pSublist->IsEmpty())

						if (!bHaventAClueWhatItIs) // added to remove goto h above
						{
							// make the marker accessible, minus its backslash
							// 
							// whm 3Jan2024 removed f: jump label that was at this location previously

							bareMarker = augMarkerBeingUnfiltered.Mid(1); // remove backslash
							bareMarker.Trim(TRUE); // remove augmented final space

							// determine if there is an endmarker
							//bHasEndMarker = FALSE;
							extractedStr = MakeReverse(extractedStr);
							curPos = extractedStr.Find(_T('*')); // remember, extractedStr is reversed!!
							// determine if the extracted string has an endmarker at its end
							if (bIsContentlessMarker)
							{
								; //bHasEndMarker = FALSE;
							}
							else
							{
								if (curPos != wxNOT_FOUND)
								{
									// there is an asterisk, but it may be in the text rather
									// than an endmarker, so check it is part of a genuine
									// endmarker (this is a safer test than checking
									// bareMarker's USFMAnalysis, since some endmarkers can be
									// optional)
									int nStart = curPos + 1; // point past it
									// find the next backslash
									curPos = FindFromPos(extractedStr, gSFescapechar, nStart);
									wxString possibleEndMkr = extractedStr.Mid(nStart, curPos - nStart);
									possibleEndMkr = MakeReverse(possibleEndMkr);
								}
							}
							extractedStr = MakeReverse(extractedStr);// restore normal order
						
							// point at the marker's backslash in the buffer (ready for calling
							// AnalyseMarker)
							{	// this extra block extends for the next 28 lines. It avoids the bogus
								// warning C4533: initialization of 'f_iter' is skipped by 'goto h'
								// by putting its code within its own scope
								bool bFound = FALSE;
								MapSfmToUSFMAnalysisStruct::iterator f_iter;
								f_iter = pSfmMap->find(bareMarker); // find returns an iterator
								if (f_iter != pSfmMap->end())
									bFound = TRUE;
								if (bFound)
								{
									pSfm = f_iter->second;
									// if it was not found, then pSfm will remain NULL, and we know
									// it must be an unknown marker
								}
								else
								{
									pSfm = (USFMAnalysis*)NULL;
								}

								// we'll need this value for the first of the parsed sourcephrases
								// from the extracted text for unfiltering
								//bool bWrap; // unused
								//if (bFound)
								//{
								//	bWrap = pSfm->wrap;
								//}
								//else
								//{
								//	bWrap = FALSE;
								//}
							} // end of extra block
							
						} // end of if (!bHaventAClueWhatItIs)

						// set the members appropriately, note intial and final require
						// extra code -- the TokenizeTextString call tokenizes without any
						// context, and so we can assume that some sourcephrase members are
						// not set up correctly (eg. m_bSpecialText, and m_curTextType) so
						// we'll have to use some of TokenizeText's processing code to get
						// things set up right. (a position pos_partialList value of zero is
						// sufficient test for being at the final sourcephrase, after the
						// GetNext() call has obtained the final one)
						// 
						// whm 3Jan2024 removed h: jump label that was previously at this location
						
						bool bIsInitial = TRUE;
						int nWhich = -1;

						int extractedStrLen = extractedStr.Length();
						// wx version note: Since we require a read-only buffer we use
						// GetData which just returns a const wxChar* to the data in the
						// string.
						const wxChar* pChar = extractedStr.GetData();
						wxChar* pBufStart = (wxChar*)pChar;
						wxChar* pEnd;
						pEnd = (wxChar*)pChar + extractedStrLen; // whm added
						wxASSERT(*pEnd == _T('\0'));
						pEnd = pEnd; // avoid warning
						// lookup the marker in the active USFMAnalysis struct map,
						// get its struct
						wxString wholeMkr = augMarkerBeingUnfiltered;
						wholeMkr.Trim(TRUE); // remove following space
						int mkrLen = (int)wholeMkr.Length(); // we want the length including
													// backslash for AnalyseMarker()
						SPList::Node* pos_SubList = pSublist->GetFirst();
						CSourcePhrase* pSPprevious = NULL;
						while (pos_SubList != NULL)
						{
							//SPList::Node* savePos; // unused
							//savePos = pos_SubList;
							CSourcePhrase* pSP_SubList = (CSourcePhrase*)pos_SubList->GetData();
							pos_SubList = pos_SubList->GetNext();
							wxASSERT(pSP_SubList);
							nWhich++; // 0-based value for the iteration number
							if (bIsInitial)
							{
								// [BEW comment] call AnalyseMarker() and set the flags 
								// etc correctly, taking context into account, for this 
								// we need the pLastSrcPhrase pointer - but it is okay if 
								// it is NULL/
								// (Note: pSP_SubList is still in the temporary list pSublist,
								// while pLastSrcPhrase is in the m_pSourcePhrases main
								// list of the document.)
								pSP_SubList->m_curTextType = verse; // assume verse unless AnalyseMarker changes it
								pSP_SubList->m_bSpecialText = AnalyseMarker(pSP_SubList, pLastSrcPhrase, pBufStart, mkrLen, pSfm);

								// [BEW comment] we have to handle the possibility that pSP_SubList 
								// might have a contentless marker, or actually something not 
								// a marker somehow in m_markers, so do these below.
								// 
								// whm 3Jan2024 Notes: 
								// The refactored routines for unfiltering are centered
								// on markers that the user unfilters from the
								// "USFM and Filtering" tab of Preferences, and searches
								// for the presence of those "known" markers within the
								// m_filteredInfo fields, whereas the older routines did
								// the reverse - they centered on parsing all the markers
								// found within m_filteredInfo fields and checking those
								// against the "known" markers. Hence, in the refactored 
								// routines now, we may never see any contentless markers
								// nor any of the category bHaventAClueWhatItIs markers.
								//
								// whm 3Jan2024 Notes: Testing indicates that all "unknown" 
								// markers get listed at the top of the Doc's marker list 
								// in "USFM and Filtering" tab of Preferences, where they
								// can be filtered and unfiltered like all other known
								// markers.
								// 
								// whm 3Jan2024 Notes: Unknown markers are stored within 
								// pSrcPhrasem_markers like other markers and also are
								// surrounded with question markers as ?\unk? in the 
								// pSrcPhrase's m_inform member. When an unknown marker is
								// filtered, it is stored in a previous source phrase's
								// m_filteredInfo member as is other known markers.
								// I'm not real sure what the blocks of code below that 
								// deal with bIsContentlessMarker and with
								// bHaventAClueWhatItIs are for any more. Currently, they
								// are not likely to ever be entered.
								//
								// whm 3Jan2024 Notes: I devised some test data with unknown 
								// markers and isolated '*' in the text to explore what the 
								// blocks below do. The result was that those blocks apparently 
								// do very little. I will leave them in case there is some
								// scenario that I've not tested.
								if (bIsContentlessMarker)
								{
									//  we want this added 'as is' (including its following
									//  space) to pSrcPhrase's m_markers member, in the
									//  appropriate place and the remainderStr added, and
									//  this pSublist element removed (since its
									//  contentless, there can only be this one in the
									//  sublist), and continue - to effect the needed
									//  result we must set up remainderStr to have preStr
									//  plus this marker and space plus remainderStr's
									//  previous content, in that order
									//
									//  BEW 20Sep10; preStr and remainderStr for
									//  docVersion 5 are now associated with
									//  m_filteredInfo; but the unknown marker - being at
									//  the tail of a set of CSourcePhrases comprising a
									//  single one with no m_key content, does have
									//  to go into the pSrcPhrase's (NOT pSP_SubList's)
									//  m_markers member - preceding what is already
									//  there, and we must deal with preStr and
									//  remainderStr here because we break out of the loop
									//  at the end of this block
									pSrcPhrase->m_markers = pSP_SubList->m_markers + pSrcPhrase->m_markers;
									// handle the filtered info that remains, if any
									wxString aString;
									if (!preStr.IsEmpty())
										aString = preStr;
									if (!remainderStr.IsEmpty())
										aString += remainderStr;
									if (!aString.IsEmpty())
										pSrcPhrase->SetFilteredInfo(aString);
									else
										pSrcPhrase->SetFilteredInfo(_T(""));
									nWhich = 0;
									DeleteSingleSrcPhrase(pSP_SubList, FALSE); // don't leak memory;
										// & FALSE means don't delete a non-existent partner pile
									pSublist->Clear();
									break;
								}
								if (bHaventAClueWhatItIs)
								{
									// when we expected a marker in m_markers but instead
									// found text (which we hope would never be the case) -
									// but just in case something wrongly got shoved into
									// m_markers, we want to make it visible and adaptable
									// in in the document - if it's something which
									// shouldn't be there, then the user can edit the
									// source text manually to remove it. In this case, our
									// 'spurious' sourcephrase is going to be treated as
									// non-spurious, and we'll move the m_markers content
									// to m_srcPhrase, and remove punctuation etc and set
									// up m_key, m_precPunct and m_follPunct.
									SPList* pSublist2 = new SPList;
									wxString unexpectedStr = pSP_SubList->m_markers;
									int count;
									count = pView->TokenizeTextString(pSublist2, unexpectedStr,
										pSrcPhrase->m_nSequNumber);
									// the actual sequence number doesn't matter because we
									// renumber the whole list later on after the
									// insertions are done
									wxASSERT(count > 0);
									count = count; // avoid warning (retain, as is)
									CSourcePhrase* pSP2;
									SPList::Node* posX = pSublist2->GetFirst();
									pSP2 = (CSourcePhrase*)posX->GetData();
									posX = posX->GetNext();
									// we'll make an assumption that there is only one
									// element in pSublist2, which should be a safe
									// assumption, and if not -- well, we'll just add the
									// append the extra strings and won't worry about
									// punctuation except what's on the first element
									pSP_SubList->m_markers.Empty();
									pSP_SubList->m_srcPhrase = pSP2->m_srcPhrase;
									pSP_SubList->m_key = pSP2->m_key;
									pSP_SubList->m_precPunct = pSP2->m_precPunct;
									pSP_SubList->m_follPunct = pSP2->m_follPunct;
									// that should do it, but if there's more, well just
									// add the text so we don't lose anything - user will
									// have the option of editing what he sees afterwards
									while (posX != NULL)
									{
										pSP2 = (CSourcePhrase*)posX->GetData();
										posX = posX->GetNext();
										pSP_SubList->m_srcPhrase += PutSrcWordBreak(pSP2) + pSP2->m_srcPhrase;
										pSP_SubList->m_key += PutSrcWordBreak(pSP2) + pSP2->m_key;
									}
									// delete all the elements in pSP2, and then delete
									// the list itself
									DeleteListContentsOnly(pSublist2);
									if (pSublist2 != NULL) // whm 11Jun12 added NULL test
										delete pSublist2;
									bHaventAClueWhatItIs = FALSE;
								}

								// is it PNG SFM or USFM footnote marker?
								// comparing first two chars in mkr
								// whm 31Oct2023 modified the following test and block. The reason
								// is that it wrongly detects the \\fig marker in addition to detecting
								// footnotes, and in such cases it makes the pSP_SubList for the \fig marker's 
								// m_bFootnote = TRUE.
								// The AnalyseMarker() call above should adequately handle footnote
								// properties and assign its m_bFootnote member to TRUE.
								
								//if (mkr.Left(2) == _T("\\f")) // is it PNG SFM or USFM footnote marker?
								if (wholeMkr != _T("\\fig") && wholeMkr.Left(2) == _T("\\f")) // is it PNG SFM or USFM footnote marker?
								{
									// if not already set, then do it here
									if (!pSP_SubList->m_bFootnote)
										pSP_SubList->m_bFootnote = TRUE;
								}
								
								// completely redo the navigation text, so it accurately
								// reflects what is in the m_markers member of the
								// unfiltered section
								// whm 31Oct2023 removed the following call to RedoNavigationText(pSP_SubList).
								// The reason for removal is that some markers like \fig will
								// not have any content in their pSP_SubList's m_markers member. The
								// RedoNavigationText() function immediately returns an empty
								// string when m_marker is empty. This then, wipes out the
								// already correct m_inform value of markers like \fig. 
								// Again, the AnalyseMarker() function call above should 
								// accurately assign the m_inform member, and it should not 
								// need a hack like RedoNavitationText().
								//pSP_SubList->m_inform = RedoNavigationText(pSP_SubList); // whm 31Oct2023 removed

								pSPprevious = pSP_SubList; // set pSPprevious for the next iteration, for propagation
								bIsInitial = FALSE;
							} // end of TRUE block for test: if (bIsInitial)

							// when not the 0th iteration, we need to propagate the flags,
							// texttype, etc
							if (nWhich > 0)
							{
								// do propagation
								wxASSERT(pSPprevious);
								pSP_SubList->CopySameTypeParams(*pSPprevious);
							}

							// for the last pSP_SubList instance, there could be an endmarker which
							// follows it; if that is the case, we can assume the main
							// list's sourcephrase which will follow this final pSP_SubList
							// instance after we've inserted pSublist into the main list,
							// will already have its correct TextType and m_bSpecialText
							// value set, and so we won't try change it (and won't call
							// AnalyseMarker() again to invoke its endmarker-support code
							// either) instead we will just set sensible end conditions -
							// such as m_bBoundary set TRUE, and we'll let the TextType
							// propagation do its job. We will need to check if we have
							// just unfiltererd a footnote, and if so, set the
							// m_bFootnoteEnd flag.
							if (pos_SubList == NULL || count == 1)
							{
								// pSP_SubList is the final in pSublist, so do what needs to be
								// done for such an instance; (if there is only one
								// instance in pSublist, then the first one is also the
								// last one, so we check for that using the count == 1 test
								// -- which is redundant really since pos_SubList should be NULL
								// in that case too, but no harm is done with the extra
								// test)
								pSP_SubList->m_bBoundary = TRUE;
								// rely on the foonote TextType having been propagated
								if (pSP_SubList->m_curTextType == footnote)
									pSP_SubList->m_bFootnoteEnd = TRUE;
							}
						} // end of while loop for pSublist elements

						// [deprecated] BEW 30Sep19
						// now insert the completed CSourcePhrase instances into the
						// m_pSourcePhrases list preceding the SaveNextPos position
						// 
						// whm 31Oct2023 modified the routines below, because the unfiltering
						// of markers was not inserting them at the correct soure phrase location
						// in the sacred text. The old code was inserting them BEFORE the last
						// word of normal source text, instead of AFTER it.
						// To remedy the problem I've added code to get the position of the
						// source phrase AFTER the saveNextPos node, calling it insertPos,
						// which is then used at the insertion point for the unfiltered
						// material.
						
						SPList::Node* insertPos = NULL;
						// We can simply insert the marker-being-unfiltered's p_subList of
						// source phrases at the usual saveNextPos position  determined by
						// calling insertPos = aveNextPos->GetNext().
						// 
						// whm 2Feb2024 further modification. However, it is possible that 
						// the next source phrase could be a placeholder source phrase because 
						// the filtered marker being unfiltered might be the last word of a 
						// retranslation that has placeholders following it. In this case we 
						// need to get an insertPos that is the first source phrase following 
						// any/all placeholder(s). Or, if the end of the document is at that 
						// location we will simply Append the p_subList items to pList. 
						// Therefore we need to scan source phrases bypassing any/all that
						// have their m_bNullSourcePhrase flag TRUE until that flag becomes
						// FALSE, or we reach the end source phrse of the document.
						CSourcePhrase* ptempSP; 
						insertPos = saveNextPos->GetNext();
						while (insertPos != NULL && insertPos->GetData()->m_bNullSourcePhrase == TRUE)
						{
							ptempSP = insertPos->GetData();
							insertPos = insertPos->GetNext();
						}

#if defined(_DEBUG)
						// whm 31Oct2023 Debug block for inspection of source phrases at insertPos
						if (insertPos != NULL)
						{
							CSourcePhrase* ptempSP = insertPos->GetData();
							// For debugging and inspecting the 
							if (ptempSP)
							{
								int sn = ptempSP->m_nSequNumber;
								sn = sn;
								wxString tempKey = ptempSP->m_key;
								tempKey = tempKey;
							}
						}
#endif
						CSourcePhrase* pSP_SubList = NULL;
						pos_SubList = pSublist->GetFirst();
						while (pos_SubList != NULL)
						{
							pSP_SubList = (CSourcePhrase*)pos_SubList->GetData();
							pos_SubList = pos_SubList->GetNext();

							// wxList::Insert() inserts before specified position in the list
							// BEW 30Sep19 refactoring changes are here...
							// 
							// whm 31Oct2023 modified the routines below, because the unfiltering
							// of markers is not inserting them at the correct soure phrase location
							// in the sacred text. 
#if defined(_DEBUG)
							// whm 31Oct2023 Debug block for inspection of source phrases at insertPos
							if (insertPos != NULL)
							{
								CSourcePhrase* ptempSP = (CSourcePhrase*)insertPos->GetData();
								if (ptempSP != NULL)
								{
									int sn = ptempSP->m_nSequNumber;
									sn = sn;
									wxString tempKey = ptempSP->m_key;
									tempKey = tempKey;
								}
							}
#endif
							// whm 31Oct2023 modified the following to execute pList->Insert() before 
							// the insertPos instead of the saveNextPos position.
							//if (saveNextPos != NULL)
							if (insertPos != NULL)
							{
								// There exists a fixed location CSourcePhrase before which we can
								// insert
								//pList->Insert(saveNextPos, pSP_SubList);
								pList->Insert(insertPos, pSP_SubList);
							}
							else
							{
								// We must append the unfiltered instances to the
								// m_pSourcePhrases list
								pList->Append(pSP_SubList);
							}
							// m_pSourcePhrases will manage these unfiltered ones now
						} // end of while (pos_SubList != NULL)

						// whm 3Jan2024 modification.
						// The pSP_SubList, if not NULL from above, is the last source phrase word of the 
						// pSubList and that is where we need to store any followingFilteredMaterial 
						// remaining from the pSrcPhrase where is was originally stored before the 
						// current unfiltering operation.
						if (pSP_SubList != NULL)
						{
							pSP_SubList->SetFilteredInfo(remainderStr);
						}

						// whm 3Jan2024 modification.
						// The preStr value was also determined at an earlier location above.
						// We use the preStr value (which is any adjacent filtered material
						// the was stored in pSrcPhrase preceding the currently-being-unfiltered
						// marker material) storing it back into the pSrcPhrase's m_filteredInfo
						// member. 

						// [BEW comment] Propagation of textType was handled much further up 
						// to the CSourcePhrase at saveNextPos, so the insertion happening
						// prior to that will not disturb the propagated info - so again,
						// no change to that needed here either.
						// 
						// whm 3Jan2024 The preStr filtered material should stay in storage
						// at the pSrcPhrase location, replacing the original m_filteredInfo
						// that existed before this marker-being-unfiltered was processed 
						// above.
						// Note: other filtered material may have been at this location,
						// including the marker and its associated text that was just
						// unfiltered, as well as the remainderStr material which was "carried
						// backwards" to the last word of the associated text whose pSubList
						// was added to the main document above.
						pSrcPhrase->SetFilteredInfo(preStr); // param could be empty

						if (bIsContentlessMarker)
						{
							pSrcPhrase->m_inform = RedoNavigationText(pSrcPhrase);
							bIsContentlessMarker = FALSE;
						}

						pSublist->Clear(); // clear the local list (but leave the memory chunks in RAM)

						// BEW 20Sep19, this would be a good place to ensure that the
						// sequence numbers are updated
						UpdateSequNumbers(0); // starting at 0, the start of the doc
#if defined (_DEBUG)  && !defined(NOLOGS)
						wxLogDebug(_T("%s::%s(), line %d; INNER LOOP ; before SequNum Update: curSequNum %d ,  SN = %d , count %d"),
							__FILE__, __FUNCTION__, __LINE__, curSequNum, gpApp->m_nActiveSequNum, count);
#endif
						// update the active sequence number on the App
						// BEW changed 29Jul09, the test needs to be > rather than >=,
						// because otherwise a spurious increment by 1 can happen at the
						// end of the first run through this block
						if (gpApp->m_nActiveSequNum > curSequNum)
						{
							// adjustment of the value is needed (for unfilterings, the box
							// location remains a valid one (but not necessarily so when
							// filtering)
							gpApp->m_nActiveSequNum += count;
						}

						// Do the unfiltering adjustments needed when we unfiltered something.
						if (bWeUnfilteredSomething)
						{
							bWeUnfilteredSomething = FALSE; // reset for next iteration of inner loop

							// ahm 27Jan2024 The following code is not needed. The older way of
							// handling filtered material actually didn't store filtered material
							// on any merged word of a merger but on the overarching source phrase
							// holding the merged words. The refactored filtering/unfiltering also
							// doesn't need this block below.
							/*
							// BEW added 8Mar11, I forgot to remove the unfiltered info from
							// the saved originals of a merger! If the pSrcPhrase at oldPos is
							// a merger, then the first of the stored original list of
							// CSourcePhrase instances will also store in its m_filteredInfo
							// member the same filtered information - so we must check here,
							// and if filterMkr is within that instances m_filteredInfo, we
							// must replace its m_filteredInfo content with remainderStr as set
							// above
							//CSourcePhrase* pSrcPhraseTopLevel = oldPos->GetData();
							CSourcePhrase* pSrcPhraseTopLevel = prevPos->GetData();
							// we deliberately check for a non-empty m_pSavedWords list,
							// rather than looking at m_nSrcWords; we want our test to handle
							// fixedspace (~) pseudo-merger conjoining, as well as a real merger
							if (!pSrcPhraseTopLevel->m_pSavedWords->IsEmpty())
							{
								// it's either a merger, or a fixedspace conjoining of two; in
								// either case, any filtered info can only be on the first in
								// the m_pSavedWords list
								SPList::Node* posOriginalsList = pSrcPhraseTopLevel->m_pSavedWords->GetFirst();
								if (posOriginalsList != NULL)
								{
									CSourcePhrase* pFirstOriginal = posOriginalsList->GetData();
									wxASSERT(pFirstOriginal != NULL);
									wxString firstOriginalFilteredInfo = pFirstOriginal->GetFilteredInfo();
									if (!firstOriginalFilteredInfo.IsEmpty())
									{
										int anOffset = firstOriginalFilteredInfo.Find(wholeMkr); // is the
											// just-unfiltered marker also within this stored filtered material?
										if (anOffset != wxNOT_FOUND)
										{
											// it's present, so it has to be removed, as it was
											// from the parent - we do this by simply replacing
											// the content with the parent's altered content for
											// this member
											pFirstOriginal->SetFilteredInfo(remainderStr);
										}
									}
								}
							}
							*/

							// do the setup for next iteration of the loop
							preStr.Empty();
							remainderStr.Empty();
							UpdateSequNumbers(0); // get all the sequence
												  // numbers into correct order
						} // end of TRUE block for test: if (bWeUnfilteredSomething)
					} // end of if (posFilteredMkr != wxNOT_FOUND)

					m_currentUnfilterMkr.Empty(); // restore default empty state

				} // end of TRUE block for test: if (!theFilteredInfo.IsEmpty())

	//#ifndef USE_ LEGACY_ PARSER
				// BEW 1Nov22 unsure if this next bit is relevant to the legacy parser - probably relevant to filtering

				bDidSomeUnfiltering_After = FALSE; // reinitialize, for working with m_filteredInfo_After
				//bool bWeUnfilteredSomething = FALSE; // might be needed within a loop

				// BEW 18Apr17 CSourcePhrase now has a new member m_filteredInfo_After, where post-word
				// filtered information along with metadata for guiding replacement into m_pSourcePhrases
				// gets stored. We now check for that member having content, and we unfilter those bits
				// designated for unfiltering from there
				preStr.Empty();
				remainderStr.Empty();
				bareMarker.Empty();
				// BEW 18Apr17 added support for metadata for unfiltering marker placement(s)
				// Will be empty string if there is no contained metadata; the metadata, if
				// present has a form like  [[after_punct^^]] where there will be a punctuation
				// character between the ^^, or [[after_endMkr^^]] where there will be an
				// endmarker between the ^^, or [[after_word^^]] where the parsed word will
				// be between the ^^
				wxString unfilter_metadata = wxEmptyString;
				wxString inlineNBEndMkrs = wxEmptyString;
				// Unfiltering from m_filteredInfo_After will have to be done a bit differently. There
				// will be a [[after_......^]] substring immediately preceding each filtered \mkr which
				// we need to separate from the marker content; and we need to unfilter in a loop because
				// there could be several markers to be unfiltered. Third, we have to build a post-word
				// string (rather like helpers::FromSingleMakeSstr) initially (before unfiltering) with
				// inline binding endmarkers, puncts from m_punct, inline non-binding endmarkers,
				// puncts from m_follOuterPunct - doing this as a once off, then in a loop find where
				// to insert each unfiltered string without the \~FILTER & \~FILTER* markers in their
				// correct places. remainderStr will probably be not used because anything remaining
				// in m_filteredInfo_After must stay on that same *pSrcPhrase, and not be moved to
				// any other

				// We need two wxArrayString local arrays, because we extract in stored string order
				// within m_filteredInfo_After, and we have to get all unfilting bits 'n pieces from
				// that member, removing the bits for unfiltering as we go, and storing them somewhere
				// before we attempt restoration within the source text, then tokenizing, then melding
				// into the m_pSourcePhrases list. The following two arrays are our temporary storage.
				wxArrayString metaArr;
				wxArrayString unfilterArr;
				wxArrayString mkrsToMatchArr; // store each \mkr<space> here, repeats are possible
				wxString wordPlusAfter; // this is where we build the pSrcPhrase m_key + ending puncts and
										// inline markers (except non-binding inline markers - we store
										// those separately if any are found). Anything unfiltered can
										// then be melded into the post-word part of this string
				wxString finalInlineNonbindingEndmarker; // if a non-binding endmarker (like \wj* for 'words of Jesus')
										// is encountered, there should be only one possible per pSrcPhrase,
										// so store it here. It gets added at the end the CSourcePhrase at
										// the end of the unfiltered info tokenization


				if (!pSrcPhrase->GetFilteredInfo_After().IsEmpty()) // do nothing when m_filteredInfo_After is empty
					// This is the added unfiltering block, when m_filteredInfo_After was added in 18Apr17
				{
					// First task is to get the post-word string, with puncts and inline markers in place,
					// before we do the unfilterings and placements within it in the while loop below
					wordPlusAfter = BuildPostWordStringWithoutUnfiltering(pSrcPhrase, inlineNBEndMkrs);
					wxASSERT(!wordPlusAfter.IsEmpty());
					wxString filteredInfo_After; // each filtered content with its preceding marker
												 // and following endmarker is extracted to here
					nEnd = 0; // initialize, use this with offset, to remove a being-unfiltered
							  // text span from m_filteredInfo_After
					if (!inlineNBEndMkrs.IsEmpty())
					{
						finalInlineNonbindingEndmarker = inlineNBEndMkrs;
					}

					wxString mkrAfter; // whm 3Jan2024 added for routines below instead of mkr

					// For pSrcPhrase, loop across any filtered substrings in m_filteredInfo_After, until no
					// more are found ( filterMkr is \~FILTER ); the loop iterates so long as offset points
					// at a \~FILTER to be processed for its content and metadata and ending \~FILTER*; depending
					// on the user's marker choices for unfiltering, we may here unfilter all content, or only
					// matched bits of it
					while ((offset = FindFromPos(pSrcPhrase->GetFilteredInfo_After(), filterMkr, offset)) != -1)
					{
						// get the next one, its prestring and remainderstring too; on return start
						// will contain the offset to \~FILTER and end will contain the offset to the
						// character immediately following the space following the matching \~FILTER*
						wxString theFilteredInfo_After = pSrcPhrase->GetFilteredInfo_After(); // gets the contents
										// of m_filteredInfo_After, which will shorten as to-be-unfiltered strings
										// are extracted by successive iterations of the loop

						// Here, instead of calling GetNextFilteredMarker(theFilteredInfo,offset, start, end);
						// and returning the mkr (which was filtered), we need a similar function which does
						// that job but also skips removes the metadata substring & returns it via the signature.
						// This Reconstitute... function will need some local array variables (see above)
						// to store the separated bits, and a wxArrayString for the to-be-unfiltered markers -
						// since there may be more than one marker being unfiltered. These are for
						// testing for presence in strMarkersToBeUnfiltered). Such a new function has been
						// defined: GetNextFilteredMarker_After(). We use it below. We also must remove
						// the filtered stuff we are unfiltering, from m_filteredInfo_After, as we iterate,
						// after determining that the marker returned is a match for one of the marker
						// strings within strMarkersToBeUnfiltered. We add a space to the marker to make
						// sure the space is matched also, to prevent bogus matches

						// Now we can safely call GetNextFilteredMarker_After()
						unfilter_metadata = wxEmptyString;
						filteredInfo_After.Empty();
						mkrAfter = GetNextFilteredMarker_After(theFilteredInfo_After, filteredInfo_After,
							unfilter_metadata, offset, nEnd);

						if (mkrAfter.IsEmpty() || (offset == nEnd))
						{
							// there was an error in the call above... post a reference to its location
							// sequence numbers may not be uptodate, so do so first over whole list so that
							// the attempt to find the chapter:verse reference string will not fail
							pView->UpdateSequNumbers(0);
							if (!gbIsUnstructuredData)
							{
								fixesStr += pView->GetChapterAndVerse(pSrcPhrase);
								fixesStr += _T(" after word: pSrcPhrase->m_key  at sequ num wxItoa(pSrcPhrase->m_nSequNumber)   ");
							}
							bSuccessful = FALSE; // make sure the caller will show the error box
							break; // exit this inner loop & iterate to the next CSourcePhrase instance
						}
						else
						{
							// We successfully extracted a copy of something from m_filteredInfo_After. However,
							// we don't yet know if what we extracted is information which should be unfiltered.
							// So test for unfiltering it, and if so get the bits into the arrays above, and
							// if not so, abandon the extraction. The offset value will be updated differently
							// depending on what is the case: if we are going to unfilter the extracted info,
							// then we remove it from m_filteredInfo_After wxString member, and so the stuff
							// following it will slide down so that offset stays unchanged and possibly points
							// at another \~FILTER marker for something which may or may not be filterable. But if
							// the info is not for filtering then offset needs to be increased by the nEnd value
							// to be ready for a possible subsequent iteration of the loop
							wxString augmentedMkr = mkrAfter + _T(' '); // add final space
							// Test for unfiltering of mkr
							int offset3 = strMarkersToBeUnfiltered.Find(augmentedMkr);
							if (offset3 == wxNOT_FOUND)
							{
								// It's not one for being unfiltered
								offset = nEnd; // point offset past it
								nEnd = 0; // re-initialize
							}
							else
							{
								// It's one for being unfiltered, so get the relevant data stored
								// and remove the relevant stuff from m_filteredInfo_After
								if (bDidSomeUnfiltering_After == FALSE)
								{
									// Make sure RedoNavigationText() is called later
									bDidSomeUnfiltering_After = TRUE;
								}
								metaArr.Add(unfilter_metadata);
								unfilterArr.Add(filteredInfo_After);
								mkrsToMatchArr.Add(mkrAfter);

								// Next, remove from m_filteredInfo_After the stuff extracted,
								// do it with the help of offset and nEnd values
								size_t spanToRemove = (size_t)(nEnd - offset);
								wxString str = theFilteredInfo_After.Remove(offset, spanToRemove);
								pSrcPhrase->SetFilteredInfo_After(str); // shortened, or perhaps now empty
								nEnd = 0;
							}

						} // end of else block for test:  if (mkr.IsEmpty() || (offset == nEnd))

					} //  end of while loop with test: (offset = FindFromPos(pSrcPhrase->GetFilteredInfo_After(), filterMkr, offset)) != -1

					if (bDidSomeUnfiltering_After)
					{

						wxASSERT(FALSE); // tell developer this stuff is incomplete

					}
				} // end of TRUE block for test: if (!pSrcPhrase->GetFilteredInfo_After().IsEmpty())
	//#endif

				if (bDidSomeUnfiltering)
				{
					// the original pSrcPhrase still stores its original nav text in its
					// m_inform member and this is now out of date because some of its content
					// has been unfiltered and made visible, so we have to recalculate its
					// navtext now
					pSrcPhrase->m_inform = RedoNavigationText(pSrcPhrase);
				}

				// update progress bar every 200 iterations
				++nOldCount;
				if (nOldCount % 200 == 0) //if (20 * (nOldCount / 20) == nOldCount)
				{
					pStatusBar->UpdateProgress(_("Processing Filtering Change(s)"), nOldCount, msgDisplayed);
				}

				endingMkrsStr.Empty();
			} // loop end for checking each pSrcPhrase for presence of material to be unfiltered

			// BEW 20Sep19, with the change to storing filtered info on the prececing CSourcePhrase,
			// this check should now be unnecessary - but no harm in retaing it.

			// Check for an orphan carrier of filtered info at the end of the document, which
			// has no longer got any filtered info, and if that is the case, remove it from the
			// document
			SPList::Node* posLast = pList->GetLast();
			CSourcePhrase* pLastSrcPhrase = posLast->GetData();
			if (pLastSrcPhrase->m_key.IsEmpty() && pLastSrcPhrase->GetFilteredInfo().IsEmpty())
			{
				// it needs to be deleted
				gpApp->GetDocument()->DeleteSingleSrcPhrase(pLastSrcPhrase); // delete it and its partner pile
				pList->DeleteNode(posLast);
			}
		}

	} // end block for test bUnfilteringRequired

	// reinitialize the variables we need
	pos_pList = NULL;
	pSrcPhrase = NULL;
	wxString mkr; // whm 3Jan2024 temporarily added mkr initialization here
	mkr.Empty();
	nFound = -1;

	// Do the filtering pass now
	curSequNum = -1;
	if (bFilteringRequired)
	{
		// reinitialize the progress bar, and recalc the layout in case the view
		// does some painting when the progress bar is tampered with below
		UpdateSequNumbers(0); // get the numbers updated, as a precaution

		// reinitialize the progress window for the filtering loop
		nOldTotal = pList->GetCount();
		if (nOldTotal == 0)
		{
			pSublist->Clear();
			if (pSublist != NULL) // whm 11Jun12 added NULL test
				delete pSublist;
			pSublist = NULL;
			pStatusBar->FinishProgress(_("Processing Filtering Change(s)"));
			return FALSE;
		}
		nOldCount = 0;

		progMsg = _("Pass 2 - %d of %d Total words and phrases");
		msgDisplayed = progMsg.Format(progMsg, 1, nOldTotal);
		pStatusBar->UpdateProgress(_("Processing Filtering Change(s)"), nOldCount, msgDisplayed);

		// the following variables are for tracking how the active sequence number has to
		// be updated after each span of material designated for filtering is filtered out
		bool bBoxBefore = TRUE; // TRUE when the active location is before the first sourcephrase being filtered
		bool bBoxAfter = FALSE; // TRUE when it is located after the last sourcephrase being filtered
		// if both are FALSE, then the active location is within the section being filtered out
		int nStartLocation = -1; // gets set to the sequence number for the first sourcephrase being filtered
		int nAfterLocation = -1; // gets set to the sequ num for the first source phrase after the filter section
		int nCurActiveSequNum = gpApp->m_nActiveSequNum;
		wxASSERT(nCurActiveSequNum >= 0);

		wxString wholeMkr;
		wxString bareMkr; // wholeMkr without the latter's backslash
		wxString shortMkr; // wholeShortMkr without the latter's initial backslash
		wxString wholeShortMkr;
		wxString endMkr;
		endMkr.Empty();
		bool bHasEndmarker = FALSE;
		pos_pList = pList->GetFirst();
		SPList::Node* posStart = NULL; // location of first sourcephrase instance
									   // being filtered out
		SPList::Node* posEnd = NULL; // location of first sourcephrase instance
									 // after the section being filtered out
		wxString filteredStr; // accumulate filtered source text here
		wxString existingFilteredInfo; // accumulate existing filtered source text here // whm 24Oct2023 added
		wxString tempStr;
		preStr.Empty(); // store in here m_filteredInfo content (from first pSrcPhrase)
						// which is already in m_filteredInfo; we need to carry preStr
						// contents forward to the pSrcPhrase which follows our filtered
						// out span, and insert it at top of m_filteredInfo so that
						// if we do some unfiltering sometime, we do it top down, and
						// that will keep our unfiltered information in correct order -
						// because what we filter is immediately preceding the
						// pSrcPhrase which is going to store the filtered info.
		remainderStr.Empty(); // store here anything in m_filteredInfo which follows
							  // the to-be-filtered marker (from first pSrcPhrase)
		wxString strFilteredStuffToCarryForward; // put already filtered stuff which
				// is stored on the first CSourcePhrase of a to-be-filtered section
				// in here, and at the end of the inner loop, deal with it
		int filterableMkrOffset = -1; // initialize
		int filterableMkrOffset_NB = -1; // non-binding equivalent for filterableMkrOffset
		wxChar backslash[2] = { gSFescapechar,_T('\0') }; // Bill made it a null-terminated array,
			 // gSFescapechar is already defined as unicode wxChar = _T('\\') in AI.cpp
		int nStartingOffset = 0;     // initialize
		int nStartingOffset_NB = 0;  // initialize
		bool bIsUnknownMkr = FALSE;
		bool bMarkerInNonbindingSet = FALSE;
#if defined (_DEBUG)
		{
			if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 565)
			{
				int halt_here = 1;
				wxUnusedVar(halt_here);
				wxString mmkrs = pSrcPhrase->m_markers;
			}
		}
#endif

		// We are currently in the TRUE block if (bFilteringRequired)

		// Filtering loop starts - each iteration deals with one CSourcePhrase instance
		while (pos_pList != NULL)
		{
			wholeMkr = wxEmptyString; // must start empty at each iteration

			// acts on ONE instance of pSrcPhrase only each time it loops, but in so doing
			// it may remove many by imposing FILTERED status on a series of instances
			// starting from when it finds a marker which is to be filtered out in an
			// instance's m_markers member - when that happens the loop takes up again at
			// the sourcephrase immediately after the section just filtered out
			SPList::Node* oldPos = pos_pList;
			pSrcPhrase = (CSourcePhrase*)pos_pList->GetData();
			#if defined (_DEBUG) //&& !defined(NOLOGS)
			{
				if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 417)
				{
					int halt_here = 1;
					wxUnusedVar(halt_here);
					wxString mmkrs = pSrcPhrase->m_markers;
				}
			}
			#endif

			// whm 6Nov2023 provide a pointer to the previous source phrase. We'll use
			// this to store filtered info from a previously unfiltered char attribute
			// marker.
			CSourcePhrase* pPrevSrcPhrase = NULL;
			SPList::Node* prevPos = pos_pList->GetPrevious();
			if (prevPos != NULL)
			{
				pPrevSrcPhrase = (CSourcePhrase*)prevPos->GetData();
			}

			pos_pList = pos_pList->GetNext();
			curSequNum = pSrcPhrase->m_nSequNumber;
			nCurActiveSequNum = gpApp->m_nActiveSequNum;

			// BEW 21Sep10, docVersion 5 changes some of the requirements below, as noted.
			// BEW 30Sep19 docVersion 9, added m_inlineNonbindingMarkers as a place to check...
			// loop until we find a sourcephrase which is a candidate for filtering - such
			// a one will satisfy all of the following requirements:
			// 1. m_markers is not empty, or m_inlineNonbindingMarkers is not empty
			// 2. there is at least one marker in one of the above (look for gSFescapechar)
			// 3. the candidate marker, will be in m_markers currently, or in
			//      m_inlineNonbindingMarkers currently
			// 4. the candidate marker will NEVER be an endmarker (docVersion 9 stores
			//      them now in the m_endMarkers member, or m_inlineNonbindingEndMarkers)
			// 5. the marker's USFMAnalysis struct's filter member is currently set to TRUE
			//		(note: markers like xk, xr, xt, xo, fk, fr, ft etc which are inline
			//      between \x and its matching \x* or \f and its matching \f*, etc, are
			//      marked filter==TRUE, but they have to be skipped, and their
			//      userCanSetFilter member is **always** FALSE. We won't use that fact,
			//      but we use the facts that the first character of their markers is
			//      always the same, x for cross references, f for footnotes, etc, and that
			//      they will have inLine="1" ie, their inLine value in the struct will be
			//      TRUE. Then when parsing over a stretch of text which is marked by a
			//      marker which has no endmarker, we'll know to halt parsing if we come to
			//      a marker with inLine == FALSE; but if TRUE, then a second test is
			//      needed, textType="none" NOT being current will effect the halt - so
			//      this pair of tests should enable us to prevent parsing overrun. (Note:
			//      we want our code to correctly filter a misspelled marker which is
			//      always to be filtered, after the user has edited it to be spelled
			//      correctly.
			// 6. the marker is listed for filtering in the wxString strMarkersToBeFiltered
			//      (determined from the m_FilterStatusMap map which is set from the
			//      Filtering page of the GUI)
			wxString markersStr = wxEmptyString;
			wxString inlineNonbindingMarkersStr = wxEmptyString;
			// We don't test inlineBindingMarkers - these are character marking type, the
			// nonbinding ones can be several, such as \fig ... \fig*, \esb ... and ending at \esbe
			// and so forth. So we extend our testing to look at inline non-binding markers too.
			// The next block speeds processing - if there are no begin-markers in the two
			// relevant storage locations, we can immediately iterate to the next pSrcPhrase
			markersStr = pSrcPhrase->m_markers;
			inlineNonbindingMarkersStr = pSrcPhrase->GetInlineNonbindingMarkers();

			if (markersStr.IsEmpty() && inlineNonbindingMarkersStr.IsEmpty())
			{
				++nOldCount;
				if (nOldCount % 200 == 0) //if (20 * (nOldCount / 20) == nOldCount)
				{
					msgDisplayed = progMsg.Format(progMsg, nOldCount, nOldTotal);
					pStatusBar->UpdateProgress(_("Processing Filtering Change(s)"), nOldCount, msgDisplayed);
				}
				continue;
			}

			// BEW 30Sep19 For simplicity, the best way to handle filtering when
			// m_markers and m_inlineNonbindingMarkers could, either one, contain
			// the begin-marker which is, with its content, to be filtered out, is
			// to here create two if TRUE blocks based on testing m_inlineNonbindingMarkers
			// for non-empty, and m_markers for non-empty. Order of these tests is
			// immaterial - I've put the m_inlineNonbindingMarkers test first; any
			// marker for filtering cannot be in both storage locations on the one
			// pSrcPhrase. m_inlineNonbindingMarkers, if it contains anything,
			// won't contain contentless markers like \b, so we can code more simply.
			// After determining where the marker is located, control is directed
			// to one of two processing blocks, depending in the value of the flag
			// bMarkerInNonbindingSet. (If the begin marker is in m_inlineNonbindingMarkers,
			// then the relevant processing block will, of course, need to hunt for its
			// endmarker in m_inlineNonbindingEndMarkers, not m_endMarkers.)

			if (!inlineNonbindingMarkersStr.IsEmpty())
			{

				nStartingOffset_NB = 0;

				bMarkerInNonbindingSet = FALSE; // initialize
				bIsUnknownMkr = FALSE; // unknown markers will NEVER be in
					// m_inlineNonbindingMarkers, but needed for the call below

				filterableMkrOffset_NB = ContainsMarkerToBeFiltered(
					gpApp->gCurrentSfmSet,           // in
					inlineNonbindingMarkersStr,      // in
					strMarkersToBeFiltered,          // in
					wholeMkr, wholeShortMkr, endMkr, // each is 'out'
					bHasEndmarker, bIsUnknownMkr,    // both are 'out'
					nStartingOffset_NB);			 // in
				//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());

				// If not in nonbinding mkr storage, exit block and let control 
				// go on to check m_markers block just below
				if (filterableMkrOffset_NB != wxNOT_FOUND)
				{
					// we found the filter marker within pSrcPhrase->m_inlineNonbindingMarkers
					bMarkerInNonbindingSet = TRUE; // TRUE causes the m_markers test block to be skipped
				}

			} // end of TRUE block for test: if (!inlineNonbindingMarkersStr.IsEmpty())

#if defined (_DEBUG) && !defined(NOLOGS)
			{
				if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 24)
				{
					int halt_here = 1;
					wxUnusedVar(halt_here);
					wxString mmkrs = pSrcPhrase->m_markers;
				}
			}
#endif

			// Legacy code....  Skip this block if the marker was found in the
			// m_inlineNonbindingMarkers storage member of pSrcPhrase
			if (pSrcPhrase != NULL && !pSrcPhrase->m_markers.IsEmpty() && !bMarkerInNonbindingSet)
			{
				// Legacy block, which looks only at m_markers

				// NOTE: **** the legacy algorithm allows the user to put italics 
				// substrings (marked by \it ... \it*), or similar marker & endmarker
				// pairs, within text spans potentially filterable - this should be
				// safe because such embedded content marker pairs should have a 
				// TextType of none in the XML marker specifications document, and 
				// Adapt It will skip such ones, but stop scanning when either
				// inLine is FALSE, or if TRUE, then when TextType is not none ****

				nStartingOffset = 0;

g:				bIsUnknownMkr = FALSE;

				filterableMkrOffset = ContainsMarkerToBeFiltered(gpApp->gCurrentSfmSet,
					markersStr, strMarkersToBeFiltered, wholeMkr, wholeShortMkr, endMkr,
					bHasEndmarker, bIsUnknownMkr, nStartingOffset);

				if (filterableMkrOffset == wxNOT_FOUND)
				{
					// either wholeMkr is not filterable, or its not in strMarkersToBeFiltered
					// and its not in m_inlineNonbindingMarkers
					// -- if so, just iterate to the next sourcephrase
					++nOldCount;
					if (nOldCount % 200 == 0) //if (20 * (nOldCount / 20) == nOldCount)
					{
						msgDisplayed = progMsg.Format(progMsg, nOldCount, nOldTotal);
						pStatusBar->UpdateProgress(_("Processing Filtering Change(s)"), nOldCount, msgDisplayed);
					}

					continue;
				}

			} // end of TRUE block for test: if (!pSrcPhrase->m_markers.IsEmpty() && !bMarkerInNonbindingSet)

			// First, get whatever is currently in m_filteredInfo and put in
			// strFilteredStuffToCarryForward; because after our new span is filtered,
			// the next pSrcPhrase must have this prepended in its m_filteredInfo member
			// - which could, of course, be empty and usually would be; but if filtering
			// more than one marker, we must take care to try preserve information order.
			//								IMPORTANT
			// Sadly, the Filtering tab of Preferences lets the user choose more than one
			// marker for unfiltering at a time, and that can introduce a reordering of the
			// unfiltered information. Best we can do is filter to the start of the m_filteredInfo
			// string, and hope that the user has a look first in the FilteredInformationDialog
			// before unfiltering, and unfilters first, top down, anything preceding the marker
			// he/she wants to unfilter. That way, the m_filteredInfo string will behave like
			// a LIFO stack, because the pSrcPhrase carrying the more-than-one filtered strings
			// will stay fixed in location and all the unfiltering will get inserted before it
			// in correct information order.
			// Adapt It will do best if the user filters only one marker at a time, and unfilters
			// only one at a time, via Preferences' USFM & Filtering tab.
			// 
			// whm 31Oct2023-14Oct2023 comment about the above comments. 
			// There are a number of scenarios where filtering can result in different 
			// orderings of multiple adjacent filtered markers within the m_filteredInfo source
			// phrase mamber string including the carrying forward of filtered material when
			// a previously filtered marker is already stored on the last word of associated 
			// text of a marker currently being filtered. After exploring a number of ways of 
			// handling the filtering and subsequent unfiltering of adjacent filterable markers
			// I came up with 2 possible methods to help determine the proper ordering of 
			// filtered markers within the m_filteredInfo string, and deterining the position
			// of previously filtered material now being unfiltered:
			//		Method 1. Reworking our USFMAnalysis struct to include the "occursUnder"
			// information available from the usfm 3.0 standard's usfm.sty stylesheet, then 
			// drawing on that information when it is not clear at what position in 
			// m_filteredInfo subsequently filtered adjacent markers should be inserted within 
			// that string. I refactored the USFMAnalysis struct and its related functions to 
			// incorporate the "occursUnder" information so that it is now easily available by 
			// just calling LookupSFM() and examining the new pUSFMAnalysis->occursUnder member. 
			// This method worked for some situations, however, later I found the occursUnder 
			// information to be incomplete, especially for some common adjacent marker sequences 
			// such as \ms \mr \s \r (all filterable) which commonly occur within the Nyindrou
			// Scriptures - and marker sequences that are likely in other projects that work from
			// highly marked up, already published Scriptures. The problem is that the occursUnder
			// info can help order \mr AFTER/"occursUnder" the \ms marker, and also order the \r 
			// marker under the \s marker, but the occursUnder information doesn't help order 
			// the \s marker in relation to the \mr marker since the occursUnder list of markers 
			// for \s only lists the \c marker, and not others like \mr and \ms. Hence, after 
			// refactoring to include access to the occursUnder information (which may eventually
			// be of some help), I decided on a more determinate and hopefully more comprehensive 
			// methos of determining the proper ordering of multiple adjacent filtered markers 
			// within m_filteredInfo, but also where the marker-being-unfiltered along with its
			// accociated text should be inserted back into the text. 
			// The unfiltering process is more complex than the filtereing process since, when
			// unfiltering, one must often deal with determining how many source phrases forward 
			// or backwards to position the insertion point of the sublist of source phrases 
			// composing the associated text of the marker being unfiltered. This issue can be
			// quite complex when the situation involves 4 or more filterable adjacent markers 
			// that were previously filtered (such as \ms \mr \s and \r), and are now being
			// unfiltered. The ordering possibilities for 4 adjacent markers can involve 24
			// different orders of unfiltering!
			// Update 20Nov2023 Method 1 above is insufficient due to the occursUnder info not
			// being exhaustive. When the markers \ms \mr \s \r are all adjacent the occursUnder
			// information can be used to determine the relative ordering of the pair \ms and \mr, 
			// as well as the pair \s and \r. However it cannot determine the relative ordering 
			// of the first pair \ms mr when occuring adjacent to \s \r. Therefore, I've opted to
			// develop Method 2 below as the preferred solution.
			//		Mehod 2. A more determinate method for the positioning of filtered marterial, 
			// and positioning the insertion point of material being unfiltered, can be had by
			// storing a slightly modified usfm structure file in a hidden folder .usfmstruct
			// residing in the project's Adaptations folder. The usfm struct file is easily
			// and quickly generated by our existing function GetUsfmStructureAndExtent()
			// from CollabUtilities.cpp. This function creates a wxArrayString of lines,
			// each line having one usfm marker followed by colon-separated fields of
			// information including a field that represents the number of characters tallied
			// for the marker and its associated text, and a field that has an MD5 sum for
			// the marker and its associated text. The text file generated by the 
			// GetUsfmStructureAndExtent() function is called at the time a source text
			// is loaded from disk or received from Paratext and before TokenizeText() is
			// called on to parse the source input file. At this time the usfm struct file
			// is created and lives in its hidden folder for the life of the document. I
			// tweaked the usfm file to remove the MD5 information and in its place keep a
			// single "0" or "1" in its last field to indicate whether the particular marker
			// listed on each line is filtered ("1"), or not-filtered ("0"). The filtering
			// status recorded in the file is done by a separate function call that is
			// done after TokenizeText() has processed the input file and at other times
			// such as after editing the source text. That function is called 
			// UpdateCurrentFilterStatusOfUsfmStructFileAndArray().

			strFilteredStuffToCarryForward = pSrcPhrase->GetFilteredInfo(); // could be empty

			// Direct the program execution to the next block if m_inlineNonbindingMarkers 
			// has the filter marker. Else to the block of legacy code if m_markers has the 
			// filter marker - the legacy block has a little more stuff in it, but basically
			// each does the same job in the same way - the differences being due to scanning
			// for the matching endMarker in m_inlineNonbindingEndMarkers versus m_endMarkers
#if defined (_DEBUG) && !defined(NOLOGS)
			{
				if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
				{
					int halt_here = 1;
					wxUnusedVar(halt_here);
					wxString mmkrs = pSrcPhrase->m_markers;
				}
			}
#endif

			if (bMarkerInNonbindingSet)
			{
				// whm 24Oct2023 Note: The only non-binding markers are the inline ones:
				// _T("\\wj \\sls \\tl \\+wj \\+qt \\+sls \\+tl \\fig \\+fig ")
				// and the only filterable one of the above is the \fig marker - the \fig
				// marker being the only one that has the property userCanSetFilter="1".
				// Therefore this block should only be entered when the \fig or \+fig
				// maker has had a filtering change.
				// 
				// Non-binding markers do not nest. So there should only be the one
				// begin marker to filter out, from m_inlineNonbindingMarkers member.
				// So we will simply set preStr and remainderStr to empty (we won't try
				// any fancy stuff, such as to move preceding stored markers to the 
				// pPrevSrcPhrase defined later below - first in the post-span list,
				// they should not be present anyway, and if so, let them die).
				preStr = wxEmptyString;
				remainderStr = wxEmptyString;
				// m_inlineNonbindingMarkers can now be cleared, we've got the info we need
				wxString strEmpty = wxEmptyString;
				pSrcPhrase->SetInlineNonbindingMarkers(strEmpty);

				// okay, we've found a begin-marker to be filtered, we now have to look ahead to find
				// which CSourcePhrase instance is the last one in this filtering sequence - we
				// will assume the following (Our tokenising function should ensure these constraints):
				// 1. unknown markers never get stored in m_inlineNonbindingMarkers, so
				//      we don't have to code for their presence
				// 2. if the marker has an endmarker, then any other markers are skipped over -
				//      we just look for the matching endmarker as the last marker in the 
				//	    m_inlineNonbindingEndMarkers member - and that owning CSourcePhrase
				//		instance would then be the last in the span 
				// 3. filterable content markers which lack an endmarker will never occur
				//	    in m_inlineNonbindingMarkers
				// 4. filterable footnotes, endnotes or cross references likewise, though they
				//      are inline and take end-markers, will also never occur in 
				//      m_inlineNonbindingMarkers; they are handled by the legacy code block
				//      which deals only with m_markers and m_filteredInfo

#if defined (_DEBUG) && defined(WHERE)
				{
					if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1;
						wxUnusedVar(halt_here);
						wxString mmkrs = pSrcPhrase->m_markers;
					}
				}
#endif

				// we can now partly or fully determine where the active location is in
				// relation to this location
				if (nCurActiveSequNum < pSrcPhrase->m_nSequNumber)
				{
					// if control comes here, the location is determinate
					bBoxBefore = TRUE;
					bBoxAfter = FALSE;
				}
				else
				{
					// if control comes here, the location is indeterminate - it might yet be
					// within the filtering section, or after it - we'll assume the latter, and
					// change it later if it is wrong when we get to the first sourcephrase
					// instance following the section for filtering
					bBoxBefore = FALSE;
					bBoxAfter = TRUE;
				}
				nStartLocation = pSrcPhrase->m_nSequNumber;
				// NOTE: we'll deal with preStr and remainderStr later

				// whm 24Oct2023 added a wxString existingFilteredInfo to deal with any 
				// existing filtered info found within the marker's associated text being 
				// currently processed. This existingFilteredInfo will consist of one or
				// more filter string(s) already delimited by \~FILTER ... \~FILTER* markers. 
				// Later below, if existingFilteredInfo is NOT empty, its contents will be 
				// prefixed to the filteredStr variable below after it has been completely 
				// processed, then the entire filtered information (existing and current)
				// will be set to the proper source phrase preceding the location where
				// this current pSrcPhrase's deep copy will be placed.
				existingFilteredInfo.Empty();

				posStart = oldPos; // preserve this starting location for later on

				// we can commence to build filteredStr now (Note: because filtering stores a
				// string, rather than a sequence of CSourcePhrase instances, any adaptations
				// will be thrown away irrecoverably. USFM3 attributes metadata restoration,
				// if needed, will take place later outside this function. 
				// whm 8Feb2024 delay adding the filterMkr  adn _T(' ') to filteredStr until
				// later below, since there may be swept up markers to add to filteredStr first
				// before adding the filterMkr
				//filteredStr = filterMkr; // add the \~FILTER beginning marker
				//filteredStr += _T(' '); // add space
				CSourcePhrase* pSrcPhraseFirst = new CSourcePhrase(*pSrcPhrase);
				pSrcPhraseFirst->DeepCopy();
				pSublist->Append(pSrcPhraseFirst); // we've already got the first to go in
					// the sublist, so put it there and then loop to get the rest

				// Enter an inner loop which has as it's sole purpose finding which
				// CSourcePhrase instance at pos_pList or beyond is the last one for filtering out
				// as part of the current filterable span. In the loop we make deep copies in
				// order to create a sublist of accepted within-the-span CSourcePhrase
				// instances; we then use UpdateSequNumbers() to renumber from 0 those
				// instances in the sublist, and then after the loop ends we process all the
				// sublist's contents in one hit by using the ExportFunctions.cpp function,
				// RebuildSourceText(), passing in a pointer to the sublist. Doing it this way
				// means that we have one place only for reconstituting the source text,
				// giving us consistency, and we get the inline markers handling done 'for
				// free' rather than having to add it to the complex code this approach replaces.
				// BEW 30Sep19, And that's where also, if needed, USFM3 attributes metadata in
				// m_punctsPattern, gets restored from being hidden.

				SPList::Node* pos_partialList; // this is for tracking the 'next' location
				CSourcePhrase* pSrcPhr; // we will look for a section-ending matching endmarker
					// in this one, if we don't find one, we iterate and try the
					// m_inlineNonbindingMarkers member of the next instance; if
					// we find a matching endmarker, pSrcPhr would be
					// WITHIN and at the end of the filterable section
				CSourcePhrase* pSrcPhraseNext; // we track the 'next' one at each
					// loop iteration, and if we fail to get correct halt location
					// we call IsEndingSrcPhrase() to make various safety checks
					// to try avoid span overrun and/or marker content overlap
				pSrcPhr = (CSourcePhrase*)pos_pList->GetData(); // avoids compiler warning

				// The scanning loop for the matching endmarker commences
				// note: execution breaks out when a halt location is determined
				// or at end of document
				for (pos_partialList = pos_pList; pos_partialList != NULL; )
				{
					//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());
					pSrcPhr = (CSourcePhrase*)pos_partialList->GetData();
					pos_partialList = pos_partialList->GetNext(); // advance to next Node of the passed in pList
					wxASSERT(pSrcPhr);
					posEnd = pos_partialList; // on exit of the loop, posEnd will be where
								   // pSrcPhraseNext is located, or NULL if we reached
								   // the end of the document
					if (pos_partialList == NULL)
					{
						pSrcPhraseNext = NULL;
					}
					else
					{
						pSrcPhraseNext = (CSourcePhrase*)pos_partialList->GetData();
					}

					// Check for a loop halt to scanning caused by finding the required
					// matching endmarker for the contents of wholeMkr. If no match is found
					// (as would be the case if wholeMkr is not an SFM which has a pairing
					// endmarker defined), then the pSrcPhraseNext instance needs to be
					// checked - for a halt-causing begin-marker etc. If any of the criteria
					// for halting the loop is not satisfied, the spanning loop continues.
					// A deep copy of the CSourcePhrase instance would then be made, and
					// accumulated to the sublist, and the loop iterate one or more times
					// until a halt is achieved - then control breaks from the loop and the
					// last pSrcPhrase (deep copy) is made & is added to the sublist which
					// constitutes the filtering span of instances.
					if (HasMatchingEndMarker(wholeMkr, pSrcPhr, TRUE)) // 3rd param is
									// bSearchInNonbindingEndMkrs, which is default FALSE
									// doing the search in m_markers content, so here it is TRUE
					{
//						wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());
						// whm 31Oct2023 correction. The following line gets pSrcPhr assigned to 
						// the following source phrase at pos_partialList with the result that the source
						// phrase pSrcPhr that gets appended to the pSubList below is NOT the
						// last word of the caption text being filtered, but the word of sacred
						// text following it!! That is not what we want, so I'm commenting out
						// the following line so that pSrcPhr remains the last word of caption
						// text and gets appended as the last source phrase in pSubList.
						//pSrcPhr = (CSourcePhrase*)pos_partialList->GetData();

						// halt here, this pSrcPhr is last in the filterable span
						break;
					}
					else if (pSrcPhraseNext != NULL)
					{
						
						// No match found, so check criteria for forcing a halt,
						// if no cause is found then continue iterating loop
						if (IsEndingSrcPhrase(gpApp->gCurrentSfmSet, pSrcPhraseNext, existingFilteredInfo)) // whm 24Oct2023 added 3rd parameter
						{
							// this 'next' CSourcePhrase instance causes a halt, and is not
							// itself to be within the filterable span, so the present
							// pSrcPhr instance is last in the span
							break;
						}
						// a FALSE value in the above test means that scanning should
						// continue, so just fall through to the code below which makes and
						// appends to the sublist the required deep copy of pSrcPhr
					}
					else // pSrcPhraseNext does not exist (the pointer is NULL)
					{
						// so pSrcPhr is the last CSourcePhrase instance in the document
						break;
					}
					// if control has not broken out of the loop, then we must continue
					// scanning over more CSourcePhrase instances till we halt; but first we
					// must create the needed deep copy and append it to the sublist
					CSourcePhrase* pSrcPhraseCopy = new CSourcePhrase(*pSrcPhr); // a shallow copy
					pSrcPhraseCopy->DeepCopy(); // now it's a deep copy of pSrcPhrase
					pSublist->Append(pSrcPhraseCopy);
				} // end of for loop: for (pos_partialList = pos_pList; pos_partialList != NULL; )
#if defined (_DEBUG) && !defined(NOLOGS)
				{
					if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1;
						wxUnusedVar(halt_here);
						wxString mmkrs = pSrcPhrase->m_markers;
					}
				}
#endif

				// do the final needed deep copy of pSrcPhrase and append to the sublist
				CSourcePhrase* pSrcPhraseCopy = new CSourcePhrase(*pSrcPhr); // a shallow copy
				pSrcPhraseCopy->DeepCopy(); // now it's a deep copy of pSrcPhrase
				pSublist->Append(pSrcPhraseCopy);
				// get the sequence numbers in the stored instances consecutive from 0
				UpdateSequNumbers(0, pSublist);

				// complete the determination of where the active location is in relation to
				// this filtered section, and work out the active sequ number adjustment needed
				// and make the adjustment
				if (bBoxBefore == FALSE)
				{
					// adjustment maybe needed only when we know the box was not located
					// preceding the filter section
					if (posEnd == NULL)
					{
						// at the document end, so everything up to the end is to be filtered;
						// so either the active location is before the filtered section (i.e.
						// bBoxBefore == TRUE), or it is within the filtered section (i.e.
						// bBoxBefore == FALSE)
						bBoxAfter = FALSE;
					}
					else
					{
						// posEnd is defined, so get the sequence number for this location
						nAfterLocation = posEnd->GetData()->m_nSequNumber;

						// work out if an adjustment to bBoxAfter is needed (bBoxAfter is
						// set TRUE so far)
						if (nCurActiveSequNum < nAfterLocation)
							bBoxAfter = FALSE; // the box lay within this section
											   // being filtered
					}
				}
				bool bPosEndNull = posEnd == NULL ? TRUE : FALSE; // used below
						// to work out where to set the final active location

				// Here we'export' the src text into a wxString, and then append that to
				// filteredStr
				wxString strFilteredStuff;
				strFilteredStuff.Empty();
				if (!pSublist->IsEmpty())
				{
					// BEW addition 9Apr15
					// After strFilteredStuffToCarryForward (that is, forward into  the m_filteredInfo
					// member string of the pSrcPhrase first after the span which gets removed)
					// but before RebuildSourceText() is called, we have to check (here) if the 
					// pSrcPhrase in pSublist contains any content from unfiltered custom markers,
					// and clear it out, and also clear out m_filteredInfo as well.

					// So, we'll do a loop now to unlaterally empty every member from which we don't want
					// any custom content to contribute to the value of strFilteredStuff that gets passed
					// back from the rebuild call.
					SPList::Node* pos_subList;
					CSourcePhrase* pSrcPhr = NULL;
					if (!pSublist->IsEmpty())
					{
						pos_subList = pSublist->GetFirst();
						while (pos_subList != NULL)
						{
							pSrcPhr = pos_subList->GetData();
							pos_subList = pos_subList->GetNext();
							pSrcPhr->SetFilteredInfo(_T(""));
							pSrcPhr->SetCollectedBackTrans(_T(""));
							pSrcPhr->SetNote(_T(""));
							pSrcPhr->SetFreeTrans(_T(""));
						}
					}
					// whm 6Nov2023 added. Need to reset m_bCurrentlyFiltering to TRUE,
					// because more than one marker may be filtered, and the RebuildSourceText()
					// sets the m_bCurrentlyFiltering to FALSE near the end of its function.
					// If we don't reinitialize m_bCurrentlyFiltering to TRUE, then subsequent
					// calls of RebuildSourceText() for any second and following char attribute 
					// markers will fail to have their hidden metadata included within their
					// filtered material.
					m_bCurrentlyFiltering = TRUE;

					// end of addition done on 9Apr15
					// BEW changed 29Mar23, pass in pointer, not a reference
					int textLen = RebuildSourceText(strFilteredStuff, RebuildFilteringSegment, pSublist);
					wxUnusedVar(textLen); // to avoid a compiler warning
					//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());

					// BEW 30Sep19 the above RebuildSourceText() will, embedded in it,
					// check for the existence of hidden USFM5 attributes metadata, and
					// unhide it. The returned textLen value will include the length of
					// that meta data in the returned strFilteredStuff

					// remove any initial whitespace
					strFilteredStuff.Trim(FALSE);
#if defined (_DEBUG) && !defined(NOLOGS)
					{
						if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1;
							wxUnusedVar(halt_here);
							wxString mmkrs = pSrcPhrase->m_markers;
						}
					}
#endif
				}
				else
				{
					// we don't ever expect such an error, so an English message will do
					wxString msg;
					wxBell();
					msg = msg.Format(_T("Filtering the content for marker %s failed.\nDeep copies were not stored.\nSome source text data has been lost at sequNum %d.\nDo NOT save the document, exit, relaunch and try again."),
						wholeMkr.c_str(), nStartLocation);
					wxMessageBox(msg, _T(""), wxICON_ERROR | wxOK);
					// put a message into the document so it is easy to track down where it
					// went wrong
					strFilteredStuff = _T("THIS IS WHERE THE FAILURE TO STORE DEEP COPIES OCCURRED. ");
				}

				// whm 24Oct2023 modification. When a filtered marker is adjacent to other non-filtered 
				// markers such as a chapter marker, for example, \c 11 the strFilteredStuff string that
				// was generated by the RebuildSourceText(strFilteredStuff...) call above, it will 
				// potentially contain one or more marker(s) and associated text that must not be included 
				// in the filteredStr assignment from strFilteredStuff below.
				// We need to purge the non-filtered material from the strFilteredStuff variable before 
				// assigning its content to filteredStr. So, for example, when the chapter marker 
				// \c 11 CRLF is adjacent to the \ms ... filtered part, the strFilteredStuff as returned 
				// from RebuildSourceText() might look like this:
				//	"\\c 11\r\n\\ms Jises akohok sisi-in ma iy imek, ano iy amak ja"
				// In this case we need to purge the "\\c 11\r\n" part from the string, leaving just the 
				// filtered material:
				//	\\ms Jises akohok sisi-in ma iy imek, ano iy amak ja
				// Note: wholeMkr still holds the whole marker we are currently filtering out, so use it 
				// to find the index into strFilteredStuff of that marker
				// 
				// whm 8Feb2024 modification update. BEW and I decided that the filtered information should
				// retain the swept up markers like the "\\c 11\r\n" part mentioned above, instead of
				// purging it from the filtered information. We now leave it prefixed to the filtered info
				// and enclose the actual marker-being-filtered and its associated text within the filtered
				// bracket markers. The will allow us to later determine where the swept up markers should
				// be placed when rebuilding the source text.
				int posWholeMkr = (int)strFilteredStuff.Find(wholeMkr);
				// First get the swept up stuff before the wholeMkr since we'll keep it outside the filter
				// begin marker \~FILTER
				wxString sweptUpStr = wxEmptyString; 
				if (posWholeMkr != wxNOT_FOUND)
				{
					// Separate any swept up preceding material from the strFilteredStuff that's going to 
					// be enclosed in the filter bracket markers.
					sweptUpStr = strFilteredStuff.Mid(0, posWholeMkr);
					strFilteredStuff = strFilteredStuff.Mid(posWholeMkr);
				}

				filteredStr += sweptUpStr; // sweptUpStr is empty when no swept up material is present
				filteredStr = filterMkr; // add the \~FILTER beginning marker - after any sweptUpStr
				filteredStr += _T(' '); // add space
				filteredStr += strFilteredStuff;
				// We are done with wholeMkr for this filtering span, so clear it, likewise strFilteredStuff
				wholeMkr = wxEmptyString;
				strFilteredStuff = wxEmptyString;

				// add the bracketing end filtermarker \~FILTER*
				filteredStr.Trim(); // don't need a final space before \~FILTER*
				filteredStr += filterMkrEnd; // adds \~FILTER*

				// delete the sublist's deep copied CSourcePhrase instances
				bool bDoPartnerPileDeletionAlso = FALSE; // there are no partner piles to delete
				DeleteSourcePhrases(pSublist, bDoPartnerPileDeletionAlso);
				pSublist->Clear(); // ready it for a later filtering out

				// remove the pointers from the m_pSourcePhrases list (ie. those which were
				// filtered out), and delete their memory chunks; any adaptations on these are
				// lost forever, but not from the KB unless the latter is rebuilt from the
				// document contents at a later time
				SPList::Node* pos_delNode; // use this to save the old location so as to delete the
									// old node once the iterator has moved past it
				int filterCount = 0;
				for (pos_partialList = posStart; (pos_delNode = pos_partialList) != posEnd; )
				{
					filterCount++;
					CSourcePhrase* pSP = (CSourcePhrase*)pos_partialList->GetData();
					pos_partialList = pos_partialList->GetNext();
					DeleteSingleSrcPhrase(pSP, TRUE); // don't leak memory, do also
						// delete their partner piles, as the latter should exist for
						// information unfiltered up to now and therefore was visible
						// in the view
					pList->DeleteNode(pos_delNode);
				}

				// update the sequence numbers on the sourcephrase instances which remain in
				// the document's list and reset nAfterLocation and nStartLocation accordingly
				UpdateSequNumbers(0);
				nAfterLocation = nStartLocation;
				nStartLocation = nStartLocation > 0 ? nStartLocation - 1 : 0;

				// we can now work out what adjustment is needed
				// 1. if the active location was before the filter section, no adjustment is
				//     needed
				// 2. if it was after the filter section, the active sequence number must be
				//     decreased by the number of sourcephrase instances in the section being
				//     filtered out
				// 3. if it was within the filter section, it will not be possible to preserve
				//     its location in which case we must try find a safe location (a) as close
				//     as possible after the filtered section (when posEnd exists), or (b), as
				//     close as possible before the filtered section (when posEnd is NULL)
				if (!bBoxBefore)
				{
					if (bBoxAfter)
					{
						nCurActiveSequNum -= filterCount;
					}
					else
					{
						// the box was located within the span of the material which was
						// filtered out
						if (bPosEndNull)
						{
							// put the box before the filtered section (this may not be a valid
							// location, eg. it might be a retranslation section - but we'll
							// adjust later when we set the bundle indices)
							nCurActiveSequNum = nStartLocation;
						}
						else
						{
							// put it after the filtered section (this may not be a valid
							// location, eg. it might be a retranslation section - but we'll
							// adjust later )
							nCurActiveSequNum = nAfterLocation;
						}
					}
				}
				gpApp->m_nActiveSequNum = nCurActiveSequNum;
#if defined (_DEBUG) && !defined(NOLOGS)
				{
					if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1;
						wxUnusedVar(halt_here);
						wxString mmkrs = pSrcPhrase->m_markers;
					}
				}
#endif

				// Construct m_inlineNonbindingMarkers on the first sourcephrase following 
				// the filtered section if there is nonbinding marker content needing to be
				// carried forward. A filtered section going as far as to the end of the 
				// document will manifest by pos_partialList being NULL on exit of the relevant loop 
				// above. That CSourcePhrase after the filtered span should be pointed to
				// by pPrevSrcPhrase (defined below) if we are not at doc end.
				// If we *are* at doc end, then preStr and remainderStr should be empty,
				// and we need do nothing with them.
				// BEW 30Sep19 changes
				// (1) define pPrevSrcPhrase
				// 
				// (2) filteredStr has to be appropriately stored, it no longer is embedded in
				// pPrevSrcPhrase's m_markers member, but at the START of its
				// m_filteredInfo member (to preserve the order of source text information
				// across filtering/unfiltering changes)
				// (3) the new storage for already filtered stuff being carried forward, the
				// string strFilteredStuffToCarryForward, has to be handled here too (it
				// could, of course, be an empty string)
				// 
				// whm 2Feb2024 added. Here we need to ensure that the pPrevSrcPhrase
				// is not a placeholder source phrase that is at the end of a retranslation.
				// If it is a placeholder, we need to iterate back to a previous source phrase
				// that is not a placeholder. This is similar to what was necessary when
				// unfiltering a filtered marker and text that was stored on a source phrase
				// that was followed by one or more placeholders and we iterated to following
				// source phrase until we came to a non-placeholder source phrase and inserted
				// the marker and its text's sublist there.
				// There is a parallel block later below to iterate past placeholder source 
				// phrases in the block where bIsMarkerInNonbindingSet is FALSE.
				CSourcePhrase* pPrevSrcPhrase = NULL;
				CSourcePhrase* ptempSP;
				if (prevPos != NULL)
				{
					ptempSP = prevPos->GetData();
					if (ptempSP->m_bNullSourcePhrase != TRUE)
					{
						pPrevSrcPhrase = prevPos->GetData();
					}
					else
					{
						while (prevPos != NULL && prevPos->GetData()->m_bNullSourcePhrase == TRUE)
						{
							ptempSP = prevPos->GetData();
							prevPos = prevPos->GetPrevious();
						}
						if (prevPos != NULL)
						{
							pPrevSrcPhrase = prevPos->GetData();
						}
						else
						{
							// prevPos is NULL meaning that we are at the very beginning of the document.
							// This shouldn't ordinarily happen with usfm scripture text since it
							// would have an \id line with at least a 3-letter scripture book code.
							// However, we need to do something reasonable in this case. Probably best
							// would be to set prevPos to the following source phrase and dump the
							// filtered marker there.
							prevPos = prevPos->GetNext();
							pPrevSrcPhrase = prevPos->GetData();
						}
					}

				}
				if (prevPos == NULL)
				{
					// prevPos is NULL meaning that we are at the very beginning of the document.
					// This shouldn't ordinarily happen with usfm scripture text since it
					// would have an \id line with at least a 3-letter scripture book code.
					// However, we need to do something reasonable in this case. Probably best
					// would be to set prevPos to the following source phrase and dump the
					// filtered marker there.
					prevPos = prevPos->GetNext();
					pPrevSrcPhrase = prevPos->GetData();
				}
				wxASSERT(pPrevSrcPhrase != NULL);

				// whm Note: The parallel section outside the if (bMarkerInNonbindingSet)
				// farther below has code to prepend markers into m_markers, but this is
				// not needed here within the if (bMarkerInNonbindingSet) block since such
				// markers don't store stuff within their m_markers member.

				// insert any already filtered stuff we needed to carry forward before the newly
				// filtered material (because if it was unfiltered, it would appear in the
				// view before pPrevSrcPhrase, and so we must retain that order)
				if (!strFilteredStuffToCarryForward.IsEmpty())
				{
					filteredStr = strFilteredStuffToCarryForward + filteredStr;
				}
				// we've carried the already filtered info forward, so make sure it goes no further
				strFilteredStuffToCarryForward.Empty();

				// whm 24Oct2023 added. Here would seem to be the proper place to carry forward 
				// any existingFilteredInfo that was found during the processing of the current
				// filtered marker, prefixing it now to the filteredStr before it gets stored
				// in the appropriate source phrase.
				if (!existingFilteredInfo.IsEmpty())
				{
					// whm 24Oct2023 devised a smarter way to know where to put the newly filtered 
					// filterStr within the string that goes into the m_filteredInfo member. When there 
					// already exists one or more filtered markers within existingFilteredInfo, we now
					// have a more precise method of ordering multiple adjacent filtered markers - see 
					// the ReorderFilterMaterialUsingUsfmStructData() function call below and the
					// comments preceding it.
					filteredStr = filteredStr + existingFilteredInfo;
				}

				existingFilteredInfo.Empty();

				// Insert the newly filtered material (and any carried forward filtered info
				// which we inserted above) to the start of m_filteredInfo on the CSourcePhrase
				// which follows the filtered out section - that one might have filtered material
				// already, so we have to check and take the appropriate branch.
				wxString filteredStuff = pPrevSrcPhrase->GetFilteredInfo();

				// whm 15Nov2023 update to the previous strategy, which was not sufficiently robust 
				// for when multiple adjacent markers are filtered. Before storing the filteredStuff,
				// we need to ensure that we have the correct order of multiple instances of filtered 
				// info that may be within the filteredStuff string. This is important as it needs to
				// reflect what the original ordering of the filtered markers was in the original
				// document, otherwise when RebuildSourceText() is called to export the source text
				// the markers won't be in their correct ordering. 
				// 
				// We insert the filteredStr prefixing it on the filteredStuff string. However, the
				// order of markers can't be positivley determined as to where exactly the inserted 
				// material should go within filteredStuff. Therefore, we call the 
				// ReorderFilterMaterialUsingUsfmStructData() function which consults the 
				// Doc's m_UsfmStructArr array, and determine from it what the order of any adjacent
				// filtered markers should be, and if needed, reorders the incoming filteredStuff
				// string of markers to the order they existed within the original m_UsfmStructArr
				// array.
				// The ReorderFilterMaterialUsingUsfmStructData() guarantees that we preserve the 
				// relative ordering of the adjacent filtered markers in filteredStuff.
				filteredStuff = filteredStr + filteredStuff; // inserted at start of string, but it may need reordering
				// To avoid un-needed warnings, test filteredStuff to see if more than one filtered 
				// item is in filteredStuff. If it only has a single filtered item reordering isn't
				// necessary, and even if the .usfmstruct apparratus is not enabled, we need not
				// warn the user about it.
				if (FilteredMaterialContainsMoreThanOneItem(filteredStuff))
				{
					if (m_bUsfmStructEnabled)
					{
						wxString ChVs = pView->GetChapterAndVerse(pPrevSrcPhrase);
						filteredStuff = ReorderFilterMaterialUsingUsfmStructData(filteredStuff, ChVs, m_UsfmStructArr);
					}
					else
					{
						// Give a warning message to the user
						wxString msg = _("Adapt It could not set up the Usfm Struct Array or the .usfmstruct file.\n\nThis may affect the ability of Adapt It to filter or unfilter adjacent markers in correct sequence.");
						wxMessageBox(msg, _T(""), wxICON_WARNING | wxOK);
						gpApp->LogUserAction(msg);

					}
				}
				// Store it back on the pPrevSrcPhrase CSourcePhrase.
				pPrevSrcPhrase->SetFilteredInfo(filteredStuff);

				// These should be empty already, but make sure
				preStr.Empty();
				remainderStr.Empty();

				// Turn off the boolean for dealting with filtering nonbinding begin mkr
				bMarkerInNonbindingSet = FALSE;

				// get the navigation text set up correctly
				// 
				// whm 31Oct2023 removed the following call to RedoNavigationText(pPrevSrcPhrase).
				// The reason for removal is that some markers like \fig will
				// not have any content in their pSP's m_markers member. The
				// RedoNavigationText() function was apparently created when filtered info
				// was stored in m_markers. It is not helpful anymore since it immediately 
				// returns an empty string when m_markers is empty which then, wipes out the
				// already correct m_inform value of markers like \fig. 
				// Here we are within the TRUE block of if (bMarkerInNonbindingSet) so
				// we can assume that pPrevSrcPhrase now has filtered info within its
				// m_filteredInfo member, and it will be marked by a green caret above this
				// pPrevSrcPhrase. Also its m_inform will still be intact and should display
				// accordingly.
				//pPrevSrcPhrase->m_inform = RedoNavigationText(pPrevSrcPhrase);

				// enable iteration from this location
				if (posEnd == NULL)
				{
					pos_pList = NULL;
				}
				else
				{
					pos_pList = posEnd; // this could be the start of a consecutive section
									// for filtering out
				}
				// update progress bar every 200 iterations (1000 is a bit too many)

				++nOldCount;
				if (nOldCount % 200 == 0) //if (20 * (nOldCount / 20) == nOldCount)
				{
					msgDisplayed = progMsg.Format(progMsg, nOldCount, nOldTotal);
					pStatusBar->UpdateProgress(_("Processing Filtering Change(s)"), nOldCount, msgDisplayed);
				}
#if defined (_DEBUG) && !defined(NOLOGS)
				{
					if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1;
						wxUnusedVar(halt_here);
						wxString mmkrs = pSrcPhrase->m_markers;
					}
				}
#endif

			} // end of TRUE block for test: if (bMarkerInNonbindingSet)
			else
			{

				// Legacy code...
				
				// whm 24Oct2023 Note: This else block is for all filterable markers except for
				// the \fig and \+fig marker which get treated in the if block that starts at
				// about line 9320.

				// if we get here, it's a marker which is to be filtered out, and we know its
				// offset - so set up preStr and remainderStr so we can commence the filtering
				// properly...

				// Question: What if we filter a section containing within it filtered
				// information? 
				// Legacy Answer: This is not possible, except if there is filtered
				// information stored on the CSourcePhrase which has the wholeMkr in its
				// m_markers member -- in that case and that case alone, the to-be-filtered
				// section CAN contain filtered material which is to remain filtered -- if so,
				// we must carry that already filtered information forward along with the
				// to-be-filtered material eventually placed after it (to preserve the correct
				// order of the information should all be unfiltered).
				// SFM and USFM markup does not permit marker nesting, except for \f and \x,
				// and we've a TextType and special code to handle such information as wholes,
				// and so there will never be nesting of filtered information within the Adapt
				// It document; but the CSourcePhrase instance with the filterable marker is
				// the exception -- because if filtered markers all happened to stack at the
				// one CSourcePhrase, then unfiltering and refiltering must restore that
				// stacking in m_filteredInfo and do it in the correct order. So we have to
				// check now for this special case, and any m_filteredInfo content there has to
				// be carried forward....
				// BEW Answer later (30Sep19): later versions of USFM2 and USFM3 are more
				// complex. Some inline non-binding markers are filterable; and are not
				// stored in m_markers. Recent CSourcePhrase definitions have extra storage
				// to be considered - m_inlineNonbindingMarkers and m_inlineNonbindingEndMarkers.
				// However the algorithm of taking forward prestring and poststring not-to-be
				// filtered markers, below, should be sound in principal - but require changes
				// to cope with looking into two storage locations per pSrcPhrase - m_markers
				// (as before) and now also m_inlineNonbindingMarkers as well.

				// BEW 21Sep10 -- read the next two paragraphs carefully, because for
				// docVersion 5 the protocols described in them need changing slightly - the
				// variations will be explained after these two paragraphs...
				//
				// Legacy comments (when filtered info was all stored in m_markers):
				// We have to be careful here, we can't assume that .Mid(filterableMkrOffset)
				// will deliver the correct remainderStr to be stored till later on, because a
				// filterable marker like \b could be followed by an unfiltered marker like \v,
				// or something filtered (and hence \~FILTER would follow), or even a different
				// filterable marker (like \x), and so we have to check here for the presence
				// of another marker which follows it - if there is one, we have found a marker
				// which is to be filtered, but which has no content - such as \b, and in that
				// case all we need do is bracket it with \~FILTER and \~FILTER* and then retry
				// the ContainsMarkerToBeFiltered() call above.
				//
				// Note: markers like \b which have no content must always be
				// userCanSetFilter="0" because they must always be filtered, or always be
				// unfiltered, but never be able to have their filtering status changed. This
				// is because out code for filtering out when a marker has been changed always
				// assumes there is some following content to the marker, but in the case of \b
				// or similar contentless markers this would not be the case, and our code
				// would then incorrectly filter out whatever follows (it could be inspired
				// text!) until the next marker is encountered. At present, we have specified
				// that \b is always to be filtered, so the code below will turn \b as an
				// unknown and unfiltered marker when PngOnly is the SFM set, to \~FILTER \b
				// \~FILTER* when the user changes to the UsfmOnly set, or the UsfmAndPng set.
				// Similarly for other contentless markers.
				//
				// Variations for docVersion 5: \~FILTER and \~FILTER* no longer will appear
				// in the CSourcePhrase m_markers member; \b and similar markers can still
				// appear there, and the protocols for this and other contentless filterable
				// markers are unchanged. If we encounter such a marker, we do not bracket it
				// with \~FILTER and \~FILTER* in the m_markers member, but rather move it to
				// the end of the m_filteredInfo member and provide \~FILTER and \~FILTER*
				// bracketing markers for it there instead.
				int wholeMkrLen = wholeMkr.Length();
				int nOffsetToNextBit = filterableMkrOffset + wholeMkrLen;
				// whm 16Sep2022 moved the assignment of nFound before the if test in order to
				// utilize the value of nFound in the else/else if part which determines what
				// to do when a marker like \fv follows \f within the m_markers member.
				nFound = FindFromPos(markersStr, backslash, nOffsetToNextBit);
				//if ((wholeMkr != _T("\\f")) && (wholeMkr != _T("\\x")) &&
				//	(nFound = FindFromPos(markersStr, backslash, nOffsetToNextBit)) != wxNOT_FOUND)
				if ((wholeMkr != _T("\\f")) && (wholeMkr != _T("\\x")) &&
					(nFound != wxNOT_FOUND))
				{
					// there is a following SF marker which is not a \f or \x (the latter two
					// can have a following marker within their scope, so whether that happens
					// or not, they are not to be considered as contentless), so the current
					// one cannot have any text content -- this follows from the fact that the
					// text content of a marker cannot appear in m_markers (because in
					// docVersion 5 filtered markers are now not stored in m_markers, but in
					// m_filteredInfo), so if we find another marker using the FindFromPos()
					// call then we know the one found at the ContainsMarkerToBeFiltered() call
					// is a contentless marker.
					// Also, docVersion 5's storage in the CSourcePhrase implies that if a
					// marker which has content visible in the interlinear main window display
					// is encountered in m_markers, then it will be the last marker in
					// m_markers - this fact makes further assumptions below, safe to make
//					wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());

					// extract the marker (marker only, no following space included)
					wxString contentlessMkr = markersStr.Mid(filterableMkrOffset, nOffsetToNextBit - filterableMkrOffset);
					// wx version note: Since we require a read-only buffer we use GetData
					// which just returns a const wxChar* to the data in the string.
					const wxChar* ptr = contentlessMkr.GetData();
#if defined (_DEBUG) && !defined(NOLOGS)
					{
						if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1;
							wxUnusedVar(halt_here);
							wxString mmkrs = pSrcPhrase->m_markers;
						}
					}
#endif

					// whm added ensure buffer ends with null char
					wxChar* pEnd;
					pEnd = (wxChar*)ptr + wholeMkrLen;
					wxASSERT(*pEnd == _T('\0'));
					pEnd = pEnd; // avoid warning
					wxString temp;
					temp = GetFilteredItemBracketed(ptr, wholeMkrLen); // temp lacks a final space
					temp += _T(' '); // add the required trailing space

					// BEW 21Sep10, new code needed here for docVersion 5 - we have to remove
					// the contentless marker from the m_markers string (and chuck it away), and put the
					// bracketed version of it, stored in temp, into the end of m_filteredInfo
					markersStr.Remove(filterableMkrOffset, nOffsetToNextBit - filterableMkrOffset);
					// for an unknown reason it does not delete the space, so I have to test and
					// if so, delete it
					// whm modified 7Jul12 to include array access out-of-range tests
					if (!markersStr.IsEmpty() && markersStr.Len() > (size_t)filterableMkrOffset && markersStr[filterableMkrOffset] == _T(' ')) //if (markersStr[filterableMkrOffset] == _T(' '))
					{
						// wxString::Remove needs 1 as second parameter otherwise it truncates
						// remainder of string
						markersStr.Remove(filterableMkrOffset, 1); // delete extra space
																	// if one is here
					}
					// now update the m_filteredInfo member to contain this marker
					// appropriately filtered
					wxString filteredStr = pSrcPhrase->GetFilteredInfo();
					filteredStr += temp;
					pSrcPhrase->SetFilteredInfo(filteredStr);
					// update the local string populated above, since we've added to m_filteredInfo
					strFilteredStuffToCarryForward = pSrcPhrase->GetFilteredInfo();
					// update the m_markers member with the shorter markersStr contents
					pSrcPhrase->m_markers = markersStr;
#if defined (_DEBUG) && !defined(NOLOGS)
					{
						if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1;
							wxUnusedVar(halt_here);
							wxString mmkrs = pSrcPhrase->m_markers;
						}
					}
#endif

					// get the navigation text set up correctly (the contentless marker just
					// now filtered out should then no longer appear in the nav text line)
					pSrcPhrase->m_inform = RedoNavigationText(pSrcPhrase);

					// advance beyond this just-filtered contentless marker's location and try
					// again
					// BEW 21Sep10, for docVersion 5 the calculation is different (simpler)
					nStartingOffset = nFound; // point at the next marker found at
												// the above FindFromPos() call
					goto g;
				} // end of TRUE block for test:
				// if ((wholeMkr != _T("\\f")) && (wholeMkr != _T("\\x")) &&
				//	(nFound = FindFromPos(markersStr, backslash, nOffsetToNextBit)) != wxNOT_FOUND)
				// 
				// whm 16Sep2022 added an else if test for when a marker like \fv immediately follows \f
				// wihtin m_markers
				else if (nFound != wxNOT_FOUND
					&& (markersStr.Mid(nFound, 2) == _T("\\f") || markersStr.Mid(nFound, 2) == _T("\\x")))
				{
					// Either \f or \x is the current wholMkr being examined, and
					// there is a marker directly following \f or \x which is of the form \f? or \x?,
					// where \f? might be one of the 2 or 3 letter footnote markers \\fq \\fl \\ft \\fdc 
					// \\fe \\fv \\fp \\fqa \\fr \\fk \\fm, (other than 1-letter \f itself),
					// or \x? might be one of the cross reference markers ... other than \x itself.
					// Hence, there is a following SF marker that is NOT \f nor \x, but is a related marker 
					// that begins with "\f..." or "\x...".
					// A prine example of when this "else if" block is entered is when the current wholeMrk
					// if \f and it is followed immediately by a \fv "Footnote - Embedded Verse Number" which
					// has \fv* as an end marker but the end marker is optional (its embedded text ends at the
					// next embedded marker or the footnote end marker \f*), and often the end marker is
					// not used in real text. 
					// An example would be \f \fv 4:1 ...(other embedded footnote markers and text)... \f*.
					// In the above example "4:1" is the content that follows the \fv marker, and that content
					// is filterable along with the rest of the footnote.
					// [TODO]
					//
					int HaltHere = 1;
					HaltHere = HaltHere;
#if defined (_DEBUG) && !defined(NOLOGS)
					{
						if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1;
							wxUnusedVar(halt_here);
							wxString mmkrs = pSrcPhrase->m_markers;
						}
					}
#endif
				}
				else
				{
					// there is no following SF marker, so the current one may be assumed to
					// have content currently visible in the interlinear display
					;
				}

#if defined(_DEBUG)
				if (pSrcPhrase->m_nSequNumber == 168)
				{
					int break_here = 0; wxUnusedVar(break_here);
				}
#endif

				preStr = markersStr.Left(filterableMkrOffset); // this stuff we
					// accumulate for later on -- it will later go to the CSourcePhrase
					// which follows the instances about to be filtered out; in
					// docVersion 5 I can't think of anything that might be in preStr
					// and so it is likely to always be empty, but just in case it
					// isn't, we must preserve whatever is there & transfer it
				remainderStr = markersStr.Mid(filterableMkrOffset + wholeMkrLen); // this stuff is whatever
					// stuff follows the one we are about to filter, -- there may
					// be other following markers - such as \p or \v etc which need
					// to be accumulated and forwarded to the CSourcePhrase which
					// follows the instance about to be filtered out (in docVersion
					// 5, remainderStr won't ever have any filtered content data,
					// but only markers and possibly a verse or chapter number)
					// We retain anything which remains following our found marker
					//remainderStr = remainderStr.Mid(wholeMkrLen); // wholeMkrLen is the length of wholeMkr
				remainderStr.Trim(FALSE); // trim off any initial spaces, or if only spaces
											// remain, then this will empty remainderStr
											// 
				// BEW 29Aug22 a reminder, wholeMarker was set earlier at lines 9162++ by this call:
				//filterableMkrOffset = ContainsMarkerToBeFiltered(gpApp->gCurrentSfmSet,
				//	markersStr, strMarkersToBeFiltered, wholeMkr, wholeShortMkr, endMkr,
				//	bHasEndmarker, bIsUnknownMkr, nStartingOffset); and further down from here
				// m_markers is set to the shorter remainder string, after the current wholeMarker
				// has been dealt with - somewhere near 9760+ or -

#if defined (_DEBUG) && !defined(NOLOGS)
				{
					if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1;
						wxUnusedVar(halt_here);
						wxString mmkrs = pSrcPhrase->m_markers;
					}
				}
#endif

				//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());
				// okay, we've found a marker to be filtered, we now have to look ahead to find
				// which sourcephrase instance is the last one in this filtering sequence - we
				// will assume the following:
				// BEW 21Sep10: the following protocols are valid also for docVersion 5
				// 1. unknown markers never have an associated endmarker - so their extent ends
				//      when a subsequent marker is encounted which is not an inline one, and
				//      is found in m_markers - the owning CSourcePhrase instance is NOT in
				//      the filterable span
				// 2. if the marker has an endmarker, then any other markers are skipped over -
				//      we just look for the matching endmarker as the last marker in m_endMarkers
				//      member - that owning CSourcePhrase instance would then be the last in the
				//      span 
				//		BEW 30Sep19 The complexity of what precedes argues for handling filterable
				//		content in m_inlineNonbindingMarkers in its own (large) processing block,
				//		because lots of the above apparatus won't apply in that situation.
				// 3. filterable markers which lack an endmarker will end their content when the
				//      next marker is encountered in a subsequent CSourcePhrase instance
				//      whose m_markers member contains that marker - which must not be an
				//      inline one (easily satisfied, since docV5 NEVER stores inline markers
				//      in m_markers, with the exception of \f, \fe or \x)
				//		BEW 30Sep19 This point continues to be valid I think, for USFM3
				// 4. markers which have an optional endmarker will end using criterion 3. above,
				//      unless the marker at that location has its first two characters
				//      identical to wholeShortMkr - in which case the section will end when
				//      the first marker is encountered for which that is not so (this allows
				//		skipping over markers internal to \f .... \f*, and/or \x .... \x*)

				// we can now partly or fully determine where the active location is in
				// relation to this location
				if (nCurActiveSequNum < pSrcPhrase->m_nSequNumber)
				{
					// if control comes here, the location is determinate
					bBoxBefore = TRUE;
					bBoxAfter = FALSE;
				}
				else
				{
					// if control comes here, the location is indeterminate - it might yet be
					// within the filtering section, or after it - we'll assume the latter, and
					// change it later if it is wrong when we get to the first sourcephrase
					// instance following the section for filtering
					bBoxBefore = FALSE;
					bBoxAfter = TRUE;
				}
				nStartLocation = pSrcPhrase->m_nSequNumber;
				// NOTE: we'll deal with preStr when we set up pPrevSrcPhrase's
				// m_markers member later on; likewise for anything still in remainderStr

				// whm 24Oct2023 added a wxString existingFilteredInfo to deal with any 
				// existing filtered info found within the marker's associated text being 
				// currently processed. This existingFilteredInfo will consist of one or
				// more filter string(s) already delimited by \~FILTER ... \~FILTER* markers. 
				// Later below, if existingFilteredInfo is NOT empty, its contents will be 
				// prefixed to the filteredStr variable below after it has been completely 
				// processed, then the entire filtered information (existing and current)
				// will be set to the proper source phrase preceding the location where
				// this current pSrcPhrase's deep copy will be placed.
				existingFilteredInfo.Empty();

				posStart = oldPos; // preserve this starting location for later on
//				wxLogDebug(_T("%s::%s() , line  %d  STARTING THE FILTERED SPAN wholeMarker =  %s , at nStartLocation sn = %d"),
//					__FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str(), nStartLocation);
				// we can commence to build filteredStr now (Note: because filtering stores a
				// string, rather than a sequence of CSourcePhrase instances, any adaptations
				// will be thrown away irrecoverably.
				// whm 8Feb2024 delay adding filterMkr and _T(' ") until later.
				//filteredStr = filterMkr; // add the \~FILTER beginning marker
				//filteredStr += _T(' '); // add space
				CSourcePhrase* pSrcPhraseFirst = new CSourcePhrase(*pSrcPhrase);
				pSrcPhraseFirst->DeepCopy();
				pSublist->Append(pSrcPhraseFirst); // we've already got the first to go in
												// the sublist, so put it there and then loop
												// to get the rest
				// Enter an inner loop which has as it's sole purpose finding which
				// CSourcePhrase instance at pos_pList or beyond is the last one for filtering out
				// as part of the current filterable span. In the loop we make deep copies in
				// order to create a sublist of accepted within-the-span CSourcePhrase
				// instances; we then use UpdateSequNumbers() to renumber from 0 those
				// instances in the sublist, and then after the loop ends we process all the
				// sublist's contents in one hit by using the ExportFunctions.cpp function,
				// RebuildSourceText(), passing in a pointer to the sublist. Doing it this way
				// means that we have one place only for reconstituting the source text,
				// giving us consistency, and we get the inline markers handling done 'for
				// free' rather than having to add it to the complex code this approach replaces.
				//
				// BEW 7Dec10:
				// Question: What if we filter a section where there is a note, or free
				// translation or a collected backtranslation?
				// Answer: note information is irreversibly lost. Free and / or collected back
				// translation information halts parsing, so we retain those. (Legacy code
				// didn't retain those though.)
				SPList::Node* pos_partialList; // this is the 'next' location
				CSourcePhrase* pSrcPhr; // we look for a section-ending matching endmarker
										// in this one, if we don't find one, we try the
										// m_markers member of pSrcPhraseNext instead; if
										// we find a matching endmarker, pSrcPhrase would be
										// WITHIN and at the end of the filterable section
				CSourcePhrase* pSrcPhraseNext; // this could have in its m_markers member
												// a non-inline marker which ends the section
												// that is, this one would NOT be part of the
												// filterable section
				// put our deep copies of the span's CSourcePhrase instances in pSublist (see
				// above, it's on the heap)
				//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());
				// Initialize pSrcPhr, to avoid a compiler warning after the loop
				pSrcPhr = (CSourcePhrase*)pos_pList->GetData(); // redundant, avoids the warning later
#if defined (_DEBUG) && !defined(NOLOGS)
				{
					if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1;
						wxUnusedVar(halt_here);
						wxString mmkrs = pSrcPhrase->m_markers;
					}
				}
#endif

				for (pos_partialList = pos_pList; pos_partialList != NULL; )
				{
					pSrcPhr = (CSourcePhrase*)pos_partialList->GetData();

					pos_partialList = pos_partialList->GetNext(); // advance to next Node of the passed in pList
					wxASSERT(pSrcPhr);
					posEnd = pos_partialList; // on exit of the loop, posEnd will be where
									// pSrcPhraseNext is located, or NULL if we reached
									// the end of the document
					if (pos_partialList == NULL)
					{
						// BEW 20Sep19 deprecated comment
						// we've come to the doc end, and that forces the span end too with
						// pSrcPhrase as the last one (and so we'll need an ophan created
						// later in order to "carry" the filtered information)
						// End deprecated comment.

						// BEW 30Sep19 the above comment is now wrong; since we now store
						// to the preceding CSourcePhrase, coming to the end of the doc
						// does not require creation of a dummy CSourcePhrase to carry the
						// filtered info
						pSrcPhraseNext = NULL;
					}
					else
					{
						pSrcPhraseNext = (CSourcePhrase*)pos_partialList->GetData();
					}

					// Check for a loop halt to scanning caused by finding the required
					// matching endmarker for the contents of wholeMkr. If no match is found
					// (as would be the case if wholeMkr is not an SFM which has a pairing
					// endmarker defined), then the pSrcPhraseNext instance needs to be
					// checked - for a halt-causing begin-marker etc. If any of the criteria
					// for halting the loop is not satisfied, the spanning loop continues.
					// A deep copy of the CSourcePhrase instance would then be made, and
					// accumulated to the sublist, and the loop iterate one or more times
					// until a halt is achieved - then control breaks from the loop and the
					// last pSrcPhrase (deep copy is made) is added to the sublist which
					// constitutes the filtering span of instances.
					if (HasMatchingEndMarker(wholeMkr, pSrcPhr)) // 3rd param is 
						// bSearchInNonbindingMkrs, which is default FALSE for
						// doing the search in m_markers content
					{
//						wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());
						// halt here, this pSrcPhr is last in the filterable span
						break;
					}
					else if (pSrcPhraseNext != NULL)
					{
						if (IsEndingSrcPhrase(gpApp->gCurrentSfmSet, pSrcPhraseNext, existingFilteredInfo)) // whm 24Oct2023 added 3rd parameter
						{
							// this 'next' CSourcePhrase instance causes a halt, and is not
							// itself to be within the filterable span, so the present
							// pSrcPhr instance is last in the span
							//bAtEnd = TRUE;  // and bAtDocEnd remains FALSE
							break;
						}
						// a FALSE value in the above test means that scanning should
						// continue, so just fall through to the code below which makes and
						// appends to the sublist the required deep copy of pSrcPhr
					}
					else // pSrcPhraseNext does not exist (the pointer is NULL)
					{
						// so pSrcPhr is the last CSourcePhrase instance in the document
						break;
					}
					// if control has not broken out of the loop, then we must continue
					// scanning over more CSourcePhrase instances till we halt; but first we
					// must create the needed deep copy and append it to the sublist
					CSourcePhrase* pSrcPhraseCopy = new CSourcePhrase(*pSrcPhr); // a shallow copy
					pSrcPhraseCopy->DeepCopy(); // now it's a deep copy of pSrcPhrase
					pSublist->Append(pSrcPhraseCopy);
				} // end of for loop: for (pos_partialList = pos_pList; pos_partialList != NULL; )
#if defined (_DEBUG) && !defined(NOLOGS)
				{
					if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1;
						wxUnusedVar(halt_here);
						wxString mmkrs = pSrcPhrase->m_markers;
					}
				}
#endif

				// do the final needed deep copy of pSrcPhrase and append to the sublist
				CSourcePhrase* pSrcPhraseCopy = new CSourcePhrase(*pSrcPhr); // a shallow copy

				// whm 31Oct2023 added block below
				wxString tempFInfo = pSrcPhr->GetFilteredInfo();
				if (!tempFInfo.IsEmpty() && existingFilteredInfo.Find(tempFInfo) != wxNOT_FOUND)
				{
					// The existingFilteredInfo we retrieved is located in this final pSrcPhr, 
					// and we will be carrying that filtered info forward to a different source
					// phrase below, so we need to remove it from this pSrcPhr.
					pSrcPhr->SetFilteredInfo(wxEmptyString);
				}

				pSrcPhraseCopy->DeepCopy(); // now it's a deep copy of pSrcPhrase
				pSublist->Append(pSrcPhraseCopy);
				// get the sequence numbers in the stored instances consecutive from 0
				UpdateSequNumbers(0, pSublist);
				//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());

				// complete the determination of where the active location is in relation to
				// this filtered section, and work out the active sequ number adjustment needed
				// and make the adjustment
				if (bBoxBefore == FALSE)
				{
					// adjustment maybe needed only when we know the box was not located
					// preceding the filter section
					if (posEnd == NULL)
					{
						// at the document end, so everything up to the end is to be filtered;
						// so either the active location is before the filtered section (ie.
						// bBoxBefore == TRUE), or it is within the filtered section (it.
						// bBoxBefore == FALSE)
						bBoxAfter = FALSE;
					}
					else
					{
						// posEnd is defined, so get the sequence number for this location
						nAfterLocation = posEnd->GetData()->m_nSequNumber;

						// work out if an adjustment to bBoxAfter is needed (bBoxAfter is
						// set TRUE so far)
						if (nCurActiveSequNum < nAfterLocation)
							bBoxAfter = FALSE; // the box lay within this section
												// being filtered
					}
				}
				bool bPosEndNull = posEnd == NULL ? TRUE : FALSE; // used below to work out
												// where to set the final active location

				// here 'export' the src text into a wxString, and then append that to
				// filteredStr
				wxString strFilteredStuff;
				if (!pSublist->IsEmpty())
				{
					// BEW addition 9Apr15 to fix a bug where two consecutive filterable spans such
					// as \f...\f*\x...\x* get filtered as \f...\f*\f...\f*\x...\x*. The reason is that
					// RebuildSourceText() call, in this block, rebuilds from pSublist; but earlier,
					// in the first filtering pass (which filtered \f...\f*) the filtered string got
					// stored in the CSourcePhrase which is the first in the second filterable span,
					// in the instance's m_filteredInfo member; and the second iteration then produced
					// the pSublist and the second iteration's call of RebuildSourceText then rebuilt
					// using the source text but prepended with the stored m_filteredInfo contents,
					// thereby doubling up the \f...\f* information. The fix is the following:
					// After strFilteredStuffToCarryForward (that is, forward into a new iteration of
					// the outer loop) is set, but before RebuildSourceText() is called,
					// we have to check (here) if the first pSrcPhrase in pSublist contains content in
					// its m_filteredInfo member - and if it does, we must here empty out that content.
					// We don't expect free translation, notes, collected back translations in pSublist,
					// but we can't rule out that there might be some, so we must clear that stuff too.
					// And we can't rule out a non-first pSrcPhrase in pSublist won't have filtered stuff.
					// So, to be safe, we here need to build only from the source text, markers and punctuation
					// in the instances in pSublist. To ensure that is so, we'll do a loop now to unlaterally
					// empty every member from which we don't want any content to contribute to the value of
					// strFilteredStuff that gets passed back from the rebuild call.
					// The reason why we have an earlier iteration stored in m_filteredInfo already is because
					// usually there is only one span to filter on any CSourcePhrase, and so the outer loop
					// terminates at the end of the first iteration, so we want m_filteredInfo set already if
					// that was the case.
					//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());
					SPList::Node* pos_subList;
					CSourcePhrase* pSrcPhr = NULL;
					if (!pSublist->IsEmpty())
					{
						pos_subList = pSublist->GetFirst();
						while (pos_subList != NULL)
						{
							pSrcPhr = pos_subList->GetData();
							pos_subList = pos_subList->GetNext();
							pSrcPhr->SetFilteredInfo(_T(""));
							pSrcPhr->SetCollectedBackTrans(_T(""));
							pSrcPhr->SetNote(_T(""));
							pSrcPhr->SetFreeTrans(_T(""));
						}
					}
					//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());
					
					// whm 6Nov2023 added. Need to reset m_bCurrentlyFiltering to TRUE,
					// because more than one marker may be filtered, and the RebuildSourceText()
					// sets the m_bCurrentlyFiltering to FALSE near the end of its function.
					// If we don't reinitialize m_bCurrentlyFiltering to TRUE, then subsequent
					// calls of RebuildSourceText() for any second and following char attribute 
					// markers will fail to have their hidden metadata included within their
					// filtered material.
					m_bCurrentlyFiltering = TRUE;

					// end of addition done on 9Apr15
					int textLen = RebuildSourceText(strFilteredStuff, RebuildFilteringSegment, pSublist);
					wxUnusedVar(textLen); // to avoid a compiler warning

					// BEW 30Sep19 the above RebuildSourceText() will, embedded in it,
					// check for the existence of hidden USFM5 attributes metadata, and
					// unhide it. The returned textLen value will include the length of
					// that meta data in the returned strFilteredStuff
					//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());
					// remove any initial whitespace
					strFilteredStuff.Trim(FALSE);
				}
				else
				{
					// we don't ever expect such an error, so an English message will do
					wxString msg;
					wxBell();
					msg = msg.Format(_T("Filtering the content for marker %s failed.\nDeep copies were not stored.\nSome source text data has been lost at sequNum %d.\nDo NOT save the document, exit, relaunch and try again."),
						wholeMkr.c_str(), nStartLocation);
					wxMessageBox(msg, _T(""), wxICON_ERROR | wxOK);
					// put a message into the document so it is easy to track down where it
					// went wrong
					strFilteredStuff = _T("THIS IS WHERE THE FAILURE TO STORE DEEP COPIES OCCURRED. ");
				}
				//wxLogDebug(_T("%s::%s() , line  %d  wholeMarker =  %s"), __FILE__, __FUNCTION__, __LINE__, wholeMkr.c_str());

				// whm 24Oct2023 modification. When a filtered marker is adjacent to other non-filtered 
				// markers such as a chapter marker, for example, \c 11 the strFilteredStuff string here 
				// was generated by the RebuildSourceText(strFilteredStuff...) call above, and it will 
				// potentially contain a lot of marker(s) and associated text that must not be included 
				// in the filteredStr assignment from strFilteredStuff below.
				// We need to purge the non-filtered material from the strFilteredStuff variable before 
				// assigning its content to filteredStr. So, for example, when the chapter marker 
				// \c 11 CRLF is adjacent to the \ms ... filtered part, the strFilteredStuff as returned 
				// from RebuildSourceText() might look like this:
				//	"\\c 11\r\n\\ms Jises akohok sisi-in ma iy imek, ano iy amak ja"
				// In this case we need to purge the "\\c 11\r\n" part from the string, leaving just the 
				// filtered material:
				//	\\ms Jises akohok sisi-in ma iy imek, ano iy amak ja
				// Note: wholeMkr still holds the whole marker we are currently filtering out, so use it 
				// to find the index into strFilteredStuff of that marker
				// 
				// whm 8Feb2024 modification update. BEW and I decided that the filtered information should
				// retain the swept up markers like the "\\c 11\r\n" part mentioned above, instead of
				// purging it from the filtered information. We now leave it prefixed to the filtered info
				// and enclose the actual marker-being-filtered and its associated text within the filtered
				// bracket markers. The will allow us to later determine where the swept up markers should
				// be placed when rebuilding the source text.
				int posWholeMkr = (int)strFilteredStuff.Find(wholeMkr);
				// First get the swept up stuff before the wholeMkr since we'll keep it outside the filter
				// begin marker \~FILTER
				wxString sweptUpStr = wxEmptyString;
				if (posWholeMkr != wxNOT_FOUND)
				{
					// Separate any swept up preceding material from the strFilteredStuff that's going to 
					// be enclosed in the filter bracket markers.
					sweptUpStr = strFilteredStuff.Mid(0, posWholeMkr);
					strFilteredStuff = strFilteredStuff.Mid(posWholeMkr);
				}

				filteredStr = sweptUpStr; // sweptUpStr is empty when no swept up material is present
				filteredStr += filterMkr; // add the \~FILTER beginning marker - after any sweptUpStr
				filteredStr += _T(' '); // add space
				filteredStr += strFilteredStuff;
				// We are done with wholeMkr for this filtering span, so clear it, likewise strFilteredStuff
				wholeMkr = wxEmptyString;
				strFilteredStuff = wxEmptyString;

				// add the bracketing end filtermarker \~FILTER*
				filteredStr.Trim(); // don't need a final space before \~FILTER*
				filteredStr += filterMkrEnd; // adds \~FILTER*

				// delete the sublist's deep copied CSourcePhrase instances
				bool bDoPartnerPileDeletionAlso = FALSE; // there are no partner piles to delete
				DeleteSourcePhrases(pSublist, bDoPartnerPileDeletionAlso);
				pSublist->Clear(); // ready it for a later filtering out

				// remove the pointers from the m_pSourcePhrases list (ie. those which were
				// filtered out), and delete their memory chunks; any adaptations on these are
				// lost forever, but not from the KB unless the latter is rebuilt from the
				// document contents at a later time
				SPList::Node* pos_delNode; // use this to save the old location so as to delete the
									// old node once the iterator has moved past it
				int filterCount = 0;
				for (pos_partialList = posStart; (pos_delNode = pos_partialList) != posEnd; )
				{
					filterCount++;
					CSourcePhrase* pSP = (CSourcePhrase*)pos_partialList->GetData();
					pos_partialList = pos_partialList->GetNext();
					DeleteSingleSrcPhrase(pSP, TRUE); // don't leak memory, do also delete their
								// partner piles, as the latter should exist for information
								// unfiltered up to now and therefore was visible in the view
					pList->DeleteNode(pos_delNode);
				}

				// update the sequence numbers on the sourcephrase instances which remain in
				// the document's list and reset nAfterLocation and nStartLocation accordingly
				UpdateSequNumbers(0);
				nAfterLocation = nStartLocation;
				nStartLocation = nStartLocation > 0 ? nStartLocation - 1 : 0;

				// we can now work out what adjustment is needed
				// 1. if the active location was before the filter section, no adjustment is
				//     needed
				// 2. if it was after the filter section, the active sequence number must be
				//     decreased by the number of sourcephrase instances in the section being
				//     filtered out
				// 3. if it was within the filter section, it will not be possible to preserve
				//     its location in which case we must try find a safe location (a) as close
				//     as possible after the filtered section (when posEnd exists), or (b), as
				//     close as possible before the filtered section (when posEnd is NULL)
				if (!bBoxBefore)
				{
					if (bBoxAfter)
					{
						nCurActiveSequNum -= filterCount;
					}
					else
					{
						// the box was located within the span of the material which was
						// filtered out
						//bBoxLocationDestroyed = TRUE;
						if (bPosEndNull)
						{
							// put the box before the filtered section (this may not be a valid
							// location, eg. it might be a retranslation section - but we'll
							// adjust later when we set the bundle indices)
							nCurActiveSequNum = nStartLocation;
						}
						else
						{
							// put it after the filtered section (this may not be a valid
							// location, eg. it might be a retranslation section - but we'll
							// adjust later when we set the bundle indices)
							nCurActiveSequNum = nAfterLocation;
						}
					}
				}
				gpApp->m_nActiveSequNum = nCurActiveSequNum;

				// Construct m_markers on the first sourcephrase following the filtered
				// section; if the filtered section is at the end of the document (shouldn't
				// happen, but who knows what a user will do?) then we will need to detect this
				// and create a CSourcePhrase instance with empty key in order to be able to
				// store the filtered content in its m_markers member, and add it to the tail
				// of the doc. A filtered section at the end of the document will manifest by
				// pos_partialList being NULL on exit of the above loop
				// BEW 22Sep10, changes for docVersion 5:
				// (1) preStr and remainderStr will need to be inserted at the start of the
				// pPrevSrcPhrase's m_markers member, if either or both are non-empty
				// (they'll almost certainly be both empty)
				// (2) filteredStr has to be appropriately stored, it no longer is embedded in
				// pPrevSrcPhrase's m_markers member, but at the START of its
				// m_filteredInfo member (to preserve the order of source text information
				// across filtering/unfiltering changes)
				// (3) the new storage for already filtered stuff being carried forward, the
				// string strFilteredStuffToCarryForward, has to be handled here too (it
				// could, of course, be an empty string)
				// 
				// whm 2Feb2024 removed. The following code is not needed as it was designed
				// when filtered information was saved on a following source phrase and moreover
				// it didn't account for the possibility of of encountering a placeholder.
				/*
				CSourcePhrase* pPrevSrcPhrase = NULL;
				if (posEnd == NULL)
				{
					pPrevSrcPhrase = new CSourcePhrase;

					// force it to at least display an asterisk in nav text area to alert the
					// user to its presence
					pPrevSrcPhrase->m_bNotInKB = TRUE;
					pList->Append(pPrevSrcPhrase);
				}
				else
				{
					// get the first sourcephrase instance following the filtered section
					// 
					// whm 6Nov2023 changed the location for storing the filtered marker
					// and its associated text to the source phrase instance BEFORE the
					// filtered section, which source phrase we've set elsewhere to be
					// pPrevSrcPhrase.
					// whm 2Feb2024 see revision below.
					//pPrevSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					pPrevSrcPhrase = pPrevSrcPhrase;
				}
				wxASSERT(pPrevSrcPhrase);
				*/
				// whm 4Feb2024 Below is code that determines the follPos and the 
				// pFollSrcPhrase - being the source phrase that immediately follows the
				// position/location subsequent to the removal of the filtered marker and its
				// associated text. We can get the follPos node and its source phrase data 
				// now that the sublist of filtered SPs have been removed from the pList and 
				// the sequ numbers have been updated. We can get the follPos node by calling 
				// GetNext() of the prePos node. The determination of pFollSrcPhrase is here
				// conditional - we may or may not need to use it below. 
				// See more notes/comments below where we assign preStr to the m_markers 
				// member.
				SPList::Node* follPos = prevPos->GetNext();
				CSourcePhrase* pFollSrcPhase = NULL;
				if (follPos != NULL)
					pFollSrcPhase = follPos->GetData();
				// whm 2Feb2024 added. Here we need to ensure that the pPrevSrcPhrase
				// is not a placeholder source phrase that is at the end of a retranslation.
				// If it is a placeholder, we need to iterate back to a previous source phrase
				// that is not a placeholder. This is similar to what was necessary when
				// unfiltering a filtered marker and text that was stored on a source phrase
				// that was followed by one or more placeholders and we iterated to following
				// source phrase until we came to a non-placeholder source phrase and inserted
				// the marker and its text's sublist there.
				// There is a parallel block earlier above to iterate past placeholder source 
				// phrases in the block where bIsMarkerInNonbindingSet is TRUE.
				CSourcePhrase* pPrevSrcPhrase = NULL;
				CSourcePhrase* ptempSP;
				if (prevPos != NULL)
				{
					ptempSP = prevPos->GetData();
					if (ptempSP->m_bNullSourcePhrase != TRUE)
					{
						pPrevSrcPhrase = prevPos->GetData();
					}
					else
					{
						while (prevPos != NULL && prevPos->GetData()->m_bNullSourcePhrase == TRUE)
						{
							ptempSP = prevPos->GetData();
							prevPos = prevPos->GetPrevious();
						}
						if (prevPos != NULL)
						{
							pPrevSrcPhrase = prevPos->GetData();
						}
						else
						{
							// prevPos is NULL meaning that we are at the very beginning of the document.
							// Thsi shouldn't ordinarily happen with usfm scripture text since it
							// would have an \id line with at least a 3-letter scripture book code.
							// However, we need to do something reasonable in this case. Probably best
							// would be to set prevPos to the following source phrase and dump the
							// filtered marker there.
							prevPos = prevPos->GetNext();
							pPrevSrcPhrase = prevPos->GetData();
						}
					}
				}
				if (prevPos == NULL)
				{
					// prevPos is NULL meaning that we are at the very beginning of the document.
					// This shouldn't ordinarily happen with usfm scripture text since it
					// would have an \id line with at least a 3-letter scripture book code.
					// However, we need to do something reasonable in this case. Probably best
					// would be to set prevPos to the following source phrase and dump the
					// filtered marker there.
					prevPos = prevPos->GetNext();
					pPrevSrcPhrase = prevPos->GetData();
				}
				wxASSERT(pPrevSrcPhrase != NULL);

				// fill its m_markers with the material it needs to store,
				// in the correct order
				tempStr = pPrevSrcPhrase->m_markers; // hold this stuff temporarily,
								// as we must later add it to the end of everything else
				tempStr.Trim(FALSE); // this is easier than the above line

				// whm 4Feb2024 NOTE. The storage of m_markers from preStr in the
				// pPrevSrcPhrase location can result in loss of ordering information,
				// that we will need when it comes to unfiltereing and rebuilding the source
				// text. For example, consider the following original source text lines:
				//		\ms Jesus brought Good News for all people
				//		\c 1
				//		\s1 The Preaching of John the Baptist
				//		\p
				//		\v 1 This is the Good News about \em Jesus Christ\em*, the Son of God.
				// And, suppose we then filter the \s1 marker and its text. 
				// m_markers content: 
				// pPrevSrcPhrase->m_markers is: 
				//	"\\c 1\r\n\\p\r\n\\v 1 ", and
				// pPrevSrcPhrase->m_filteredInfo is: 
				//	"\\~FILTER \\s1 The Preaching of John the Baptist\\~FILTER*"
				// When the \s1 marker was filtered we lost the ordering information, namely that
				// the \s1 marker and its associated text was ordered between the "\\c 1\r\n"
				// and \\p\r\n\\v1 parts of the original input text. To properly unfilter and/or
				// rebuild the source text, we need to regain that lost ordering information so 
				// that for proper:
				//    Unfiltering we put the "\\c 1\r\n" first part of m_markers on the 
				// the FIRST word of the \s1 associated text "The", but we need to put the 
				// second \\p\r\n\\v1 part on the first word of \v 1 "This"
				// 
				// whm 8Feb2024 update to above comment: BEW and I decided that it would be good
				// to actually leave the swept up material - the "\\c 1\r\n" part mentioned above,
				// WITHIN the m_filteredInfo member, but PREFIXED to the filtered marker that it
				// was associated with, i.e., the \s1 marker above. Hence upon filtering the s1 
				// marker and its associated text would be stored as:
				//   "\\c 1\r\n\\~FILTER \\s1 The Preaching of John the Baptist\\~FILTER*"
				// in which the \\c 1\r\n" part is stored OUTSIDE the filter brackets.

				// whm 8Feb2024 modified. Since we are now storing in m_filteredInfo the swept up 
				// markers prefixing them to the filter-bracketed marker-being-filtered, we do 
				// not want to store such swept up material in m_markers where it just looses all
				// ordering information. Therefore, we should remove the swept up stuff from the
				// preStr below before storing preStr into m_markers.
				// TODO: I'm commenting out the next line until tests show that we need to
				// just remove swept up stuff from preStr. When filtering the \s1 marker
				// preStr was "\\c 1\r\n" which was equivalent to the swept up part, but what
				// about when there is other bracketed filtered stuff within preStr???
				// Also when testing this by filtering \s1 in the Hezekiah doc, it was clear that
				// the RebuildSourceText() call above wasn't producing a correct string
				// TODO
				//pPrevSrcPhrase->m_markers = preStr; // any previously assumulated
															// filtered info, or markers
				// whm 8Feb2024 TODO: Determine if the adjustment to m_markers below and
				// addition of tempStr is still necessary
				// 
				// BEW 22Sep10 added next 3 lines
				pPrevSrcPhrase->m_markers.Trim();
				pPrevSrcPhrase->m_markers += _T(" "); //ensure an intervening space
				pPrevSrcPhrase->m_markers += remainderStr;
				pPrevSrcPhrase->m_markers.Trim(FALSE); // delete contents
													// if only spaces are present
				if (!tempStr.IsEmpty())
				{
					pPrevSrcPhrase->m_markers.Trim();
					pPrevSrcPhrase->m_markers += _T(" "); //ensure an intervening space
					// append whatever was originally on this srcPhrase::m_markers member
					pPrevSrcPhrase->m_markers += tempStr;
				}

				// insert any already filtered stuff we needed to carry forward before the newly
				// filtered material (because if it was unfiltered, it would appear in the
				// view before it, and so we must retain that order)
				if (!strFilteredStuffToCarryForward.IsEmpty())
				{
					//(in the legacy code, this bit of work was done by remainderStr, because
					//filtered info was all in m_markers; but for docVersion 5 that was
					//inappropriate -- so I retained remainderStr only for contentless markers stuff
					//which might come after the marker to be filtered out, and stored already
					//filtered stuff in strFilteredStuffToCarryForward)
					filteredStr = strFilteredStuffToCarryForward + filteredStr;

				}
				// we've carried the already filtered info forward, so make sure it goes no further
				strFilteredStuffToCarryForward.Empty();

				// whm 24Oct2023 added. Here would seem to be the proper place to carry forward 
				// any existingFilteredInfo that was found during the processing of the current
				// filtered marker, prefixing it now to the filteredStr before it gets stored
				// in the appropriate source phrase.
				if (!existingFilteredInfo.IsEmpty())
				{
					// whm 24Oct2023 devised a smarter way to know where to put the newly filtered 
					// filterStr within the string that goes into the m_filteredInfo member. When there 
					// already exists one or more filtered markers within existingFilteredInfo, we now
					// have a more precise method of ordering multiple adjacent filtered markers - see 
					// the ReorderFilterMaterialUsingUsfmStructData() function call below and the
					// comments preceding it.
					filteredStr = filteredStr + existingFilteredInfo;
				}

				existingFilteredInfo.Empty();

				// Insert the newly filtered material (and any carried forward filtered info
				// which we appended above) to the start of m_filteredInfo on the CSourcePhrase
				// which follows the filtered out section - that one might have filtered material
				// already, so we have to check and take the appropriate branch.
				wxString filteredStuff = pPrevSrcPhrase->GetFilteredInfo();

				// whm 15Nov2023 update to the previous strategy, which was not sufficiently robust 
				// for when multiple adjacent markers are filtered. Before storing the filteredStuff,
				// we need to ensure that we have the correct order of multiple instances of filtered 
				// info that may be within the filteredStuff string. This is important as it needs to
				// reflect what the original ordering of the filtered markers was in the original
				// document, otherwise when RebuildSourceText() is called to export the source text
				// the markers won't be in their correct ordering. 
				// 
				// We insert the filteredStr prefixing it on the filteredStuff string. However, the
				// order of markers can't be positivley determined as to where exactly the inserted 
				// material should go within filteredStuff. Therefore, we call the 
				// ReorderFilterMaterialUsingUsfmStructData() function which consults the 
				// Doc's m_UsfmStructArr array, and determine from it what the order of any adjacent
				// filtered markers should be, and if needed, reorders the incoming filteredStuff
				// string of markers to the order they existed within the original m_UsfmStructArr
				// array.
				// The ReorderFilterMaterialUsingUsfmStructData() guarantees that we preserve the 
				// relative ordering of the adjacent filtered markers in filteredStuff.
				filteredStuff = filteredStr + filteredStuff;
				// To avoid un-needed warnings, test filteredStuff to see if more than one filtered 
				// item is in filteredStuff. If it only has a single filtered item reordering isn't
				// necessary, and even if the .usfmstruct apparratus is not enabled, we need not
				// warn the user about it.
				if (FilteredMaterialContainsMoreThanOneItem(filteredStuff))
				{
					if (m_bUsfmStructEnabled)
					{
						wxString ChVs = pView->GetChapterAndVerse(pPrevSrcPhrase);
						filteredStuff = ReorderFilterMaterialUsingUsfmStructData(filteredStuff, ChVs, m_UsfmStructArr);
					}
					else
					{
						// Give a warning message to the user
						wxString msg = _("Adapt It could not set up the Usfm Struct Array or the .usfmstruct file.\n\nThis may affect the ability of Adapt It to filter or unfilter adjacent markers in correct sequence.");
						wxMessageBox(msg, _T(""), wxICON_WARNING | wxOK);
						gpApp->LogUserAction(msg);

					}
				}
				// Store it back on the pPrevSrcPhrase CSourcePhrase.
				pPrevSrcPhrase->SetFilteredInfo(filteredStuff);

				// These should be empty already, but make sure
				preStr.Empty();
				remainderStr.Empty();

				// get the navigation text set up correctly
				// whm 2Feb2024 Note: In the bMarkerInNonbindingSet section farther 
				// above the RedoNavigationText() call was commented out because for \fig
				// markers being filtered will not have any content in their PSP's
				// m_markers member, and the RedoNavigationText() function immediately
				// returns an empty string when m_markers is empty which then, wipes out the
				// already correct m_inform value of markers like \fig.
				// However, here it doesn't seem to have negative effects.
				pPrevSrcPhrase->m_inform = RedoNavigationText(pPrevSrcPhrase);

#if defined (_DEBUG) && !defined(NOLOGS)
				{
					if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1;
						wxUnusedVar(halt_here);
						wxString mmkrs = pSrcPhrase->m_markers;
					}
				}
#endif

				// enable iteration from this location
				if (posEnd == NULL)
				{
					pos_pList = NULL;
				}
				else
				{
					pos_pList = posEnd; // this could be the start of a consecutive section
									// for filtering out
				}
				// update progress bar every 200 iterations (1000 is a bit too many)

				++nOldCount;
				if (nOldCount % 200 == 0) //if (20 * (nOldCount / 20) == nOldCount)
				{
					msgDisplayed = progMsg.Format(progMsg, nOldCount, nOldTotal);
					pStatusBar->UpdateProgress(_("Processing Filtering Change(s)"), nOldCount, msgDisplayed);
				}

			} // end of else block for test: if (bMarkerInNonbindingSet)

		} // end of while loop for scanning contents of successive pSrcPhrase instances
		  // the test being:  while (pos_pList != NULL)

		// prepare for update of view... locate the phrase box approximately where it was,
		// but if that is not a valid location then put it at the end of the doc
		int numElements = pList->GetCount();
		if (gpApp->m_nActiveSequNum > gpApp->GetMaxIndex())
			gpApp->m_nActiveSequNum = numElements - 1;

	} // end of TRUE block for test:  if (bFilteringRequired)

	// whm 23Aug2018 Change. Moved the pStatusBar->FinishProgress() call that is about
	// 10 lines above within the bIsFilteringRequired == TRUE block to this outer block.
	// where it will be parallel to the pStatusBar->StartProgress() call near the
	// beginning of ReconstituteAfterFilteringChange()
	// remove the progress indicator window
	pStatusBar->FinishProgress(_("Processing Filtering Change(s)"));


	// GetSavePhraseBoxLocationUsingList calculates a safe location (ie. not in a
	// retranslation), sets the app's m_nActiveSequNum member to that value, and
	// calculates and sets m_targetPhrase to agree with what will be the new phrase box
	// location; it doesn't move the location if it is already safe; in either case it
	// sets the box text to be the m_adaption contents for the current or new active
	// location after this call is made
	gpApp->GetSafePhraseBoxLocationUsingList(pView);

	// remove the progress window, clear out the sublist from memory
	// wx version note: Since the progress dialog is modeless we do not need to destroy
	// or otherwise end its modeless state; it will be destroyed when
	// ReconstituteAfterFilteringChange goes out of scope
	if (pSublist != NULL)
	{
		pSublist->Clear();
		delete pSublist;
		pSublist = NULL;
	}
	// BEW added 29Jul09, turn back on CLayout Draw() so drawing of the view
	// can now be done
	GetLayout()->m_bInhibitDraw = FALSE;
#if defined (_DEBUG) && !defined(NOLOGS)
	{
		if (pSrcPhrase != NULL && pSrcPhrase->m_nSequNumber >= 2)
		{
			int halt_here = 1;
			wxUnusedVar(halt_here);
			wxString mmkrs = pSrcPhrase->m_markers;
		}
	}
#endif

	return bSuccessful;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE when we want the caller to copy the pLastSrcPhrase->m_curTextType value to the
///				global enum, gPreviousTextType; otherwise we return FALSE to suppress that global
///				from being changed by whatever marker has just been parsed (and the caller will
///				reset the global to default TextType verse when an endmarker is encountered).
/// \param		pChar		-> points at the marker just found (ie. at its backslash)
/// \param		pAnalysis	-> points at the USFMAnalysis struct for this marker, if the marker
///								is not unknown otherwise it is NULL.
/// \remarks
/// Called from: the Doc's RetokenizeText().
/// TokenizeText() calls AnalyseMarker() to try to determine, among other things, what the TextType
/// propagation characteristics should be for any given marker which is not an endmarker; for some
/// such contexts, AnalyseMarker will want to preserve the TextType in the preceding context so it
/// can be restored when appropriate - so IsPreviousTextTypeWanted determines when this preservation
/// is appropriate so the caller can set the global which preserves the value
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsPreviousTextTypeWanted(wxChar* pChar, USFMAnalysis* pAnalysis)
{
	wxString bareMkr = GetBareMarkerForLookup(pChar);
	//wxASSERT(!bareMkr.IsEmpty());  // BEW 6Sep23 this asserted during my unittest for missing ch2 and ch7
	// so if bareMkr is empty, the only option is to return FALSE and let parsing continue
	if (bareMkr.IsEmpty())
	{
#if defined (_DEBUG)
		wxString pointsAt = wxString(pChar, 16);
		wxLogDebug(_T("IsPreviousTextTypeWanted() line %d, bareMkr empty at: pointsAt= [%s], returning FALSE"), __LINE__, pointsAt.c_str());
#endif
		return FALSE;
	}
	wxString markerWithoutBackslash = GetMarkerWithoutBackslash(pChar);

	// if we have a \f or \x marker, then we always want to get the TextType on whatever
	// is the sourcephrase preceding either or these
	if (markerWithoutBackslash == _T("f") || markerWithoutBackslash == _T("x"))
		return TRUE;
	// for other markers, we want the preceding sourcephrase's TextType whenever we
	// have encountered some other inLine == TRUE marker which has TextType of none
	// because these are the ones we'll want to propagate the previous type across
	// their text content - to check for these, we need to look inside pAnalysis
	if (pAnalysis == NULL)
	{
		return FALSE;
	}
	else
	{
		// its a known marker, so check if it's an inline one 
		// BEW 8Jun23 added to the test - as nested markers were unknown when this
		// function was first built; so added: || *(pChar + 1) == _T('+')
		// So i tests: either its none type, or there is a + character after the 
		// backslash (i.e. nested, and nested markers DO NOT change the textType
		// - the outer type applies, so propagate from pLastSrcPhrase
		if (pAnalysis->inLine && (pAnalysis->textType == none || *(pChar + 1) == _T('+')) )
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return
/// \param		filename	-> the filename to associate with the current document
/// \param		notifyViews	-> defaults to FALSE; if TRUE wxView's OnChangeFilename
///                            is called for all views
/// \remarks
/// Called from: the App's OnInit(), DoKBRestore(), DoTransformationsToGlosses(),
/// ChangeDocUnderlyingFileDetailsInPlace(), the Doc's OnNewDocument(), OnFileClose(),
/// DoFileSave(), SetDocumentWindowTitle(), DoUnpackDocument(), the View's
/// OnEditConsistencyCheck(), DoConsistencyCheck(), DoRetranslationReport(), the DocPage's
/// OnWizardFinish(), and CMainFrame's SyncScrollReceive().
/// Sets the file name associated internally with the current document.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::SetFilename(const wxString& filename, bool notifyViews)
{
	m_documentFile = filename;
	if (notifyViews)
	{
		// Notify the views that the filename has changed
		wxNode* node = m_documentViews.GetFirst();
		while (node)
		{
			wxView* view = (wxView*)node->GetData();
			view->OnChangeFilename();
			// OnChangeFilename() is called when the filename has changed. The default
			// implementation constructs a suitable title and sets the title of
			// the view frame (if any).
			node = node->GetNext();
		}
	}
}


///////////////////////////////////////////////////////////////////////////////
/// \return		a pointer to the running application (CAdapt_ItApp*)
/// \remarks
/// Called from: Most routines in the Doc which need a pointer to refer to the App.
/// A convenience function.
///////////////////////////////////////////////////////////////////////////////
CAdapt_ItApp* CAdapt_ItDoc::GetApp()
{
	return (CAdapt_ItApp*)&wxGetApp();
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the character immediately before prt is a newline character (\n)
/// \param		ptr			-> a pointer to a character being examined/referenced
/// \param		pBufStart	-> the start of the buffer being examined
/// \remarks
/// Called from: ExportFunctions's IsMarkerRTF().
/// Determines if the previous character in the buffer is a newline character, providing ptr
/// is not pointing at the beginning of the buffer (pBufStart).
/// whm 16Aug2023 No longer used. IsPreCharANewline() was used only in ExportFunctions's 
/// IsMarkerRTF() but is now commented out.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsPrevCharANewline(wxChar* ptr, wxChar* pBufStart)
{
	if (ptr <= pBufStart)
		return TRUE; // treat start of buffer as a virtual newline
	--ptr; // point at previous character
	if (*ptr == _T('\n'))
		return TRUE;
	else
		return FALSE;
}


// BEW 23Apr15 added provisional support for Dennis Walters request for / as a
// like-whitespace wordbreak; only in Unicode version
// 
// BEW 23Nov22 This function does not return TRUE for *pChar == _T('\n'), so when
// ParseWhiteSpace(wxChar* pChar) is called, it does not include the newline in the
// span - probably it should, so that at newlines in the input data parsing, we advance
// ptr over them. Probably safer for ParseWord(). I'll try the change and see if it
// produces problems.
// 
// whm 18Aug2023 modified. BEW's comment above about the function not returning TRUE for
// *pChar == _T('\n') is not correct at least now as of 18Aug2023. Testing shows that the
// wxWidgets wxIsspace() function does return TRUE for all common whitespace characters 
// including TAB '\t', LF '\n', CR '\r', and Space ' ', and does so on all platforms (at 
// least Windows and Linux).
// .  
// As of 18Aug2023, this IsWhiteSpace() function here in the doc now simply calls the 
// exact same global function that is defined in helpers.cpp. 
// ***** ALL CHANGES TO WHITE SPACE DETECTING SHOULD NOW BE MADE IN THE VERSION IN helpers.cpp *******
bool CAdapt_ItDoc::IsWhiteSpace(wxChar* pChar)
{
	// *******************************************************************************************************
	// ********* ALL CHANGES TO IsWhiteSpace() SHOULD BE MADE TO IsWhiteSpace() DEFINED IN helpers.cpp *******
	// ********* THIS FUNCTION HERE NOW JUST CALLS THE GLOBAL FUNCTION IsWhiteSpace() IN helpers.cpp   *******
	// ********* SEE THE return STATEMENT BELOW WHERE THE GLOBAL FUNCTION IN helpers.cpp IS CALLED     *******
	// *******************************************************************************************************
	/*	
	// BEW 30July11 -- the following block also needs to be added to the beginning of the
	// following similar functions in helpers.cpp: IsWhiteSpace() and
	// Is_NonEol_WhiteSpace() and has been
#ifdef _UNICODE
	wxChar NBSP = (wxChar)0x00A0; // standard Non-Breaking SPace
	wxChar HairSpace = (wxChar)0x200A; // used between curly quotes in MATBVM.SFM doc
#else
	wxChar NBSP = (unsigned char)0xA0;  // standard Non-Breaking SPace
#endif

	// handle common ones first...
	// returns true for tab 0x09, return 0x0D or space 0x20
	// _istspace not recognized by g++ under Linux; the wxIsspace() fn and those it relies
	// on return non-zero if a space type of character is passed in
	// BEW added 3rd subtest 23Nov2. And HairSpace on 17Dec22, 19Aug23 added test for '\r'
	if (wxIsspace(*pChar) != 0 || *pChar == NBSP || *pChar == _T('\r') || *pChar == _T('\n') || *pChar == HairSpace)
	{
		return TRUE;
	}
	else
	{
#ifdef _UNICODE
		//#if defined(FWD_SLASH_DELIM)
				// BEW 23Apr15, support / as if a whitespace word-breaker
		if (gpApp->m_bFwdSlashDelimiter)
		{
			if (*pChar == _T('/'))
				return TRUE;
		}
		//#endif
				// BEW 3Aug11, support ZWSP (zero-width space character, U+200B) as well, and from
				// Dennis Drescher's email of 3Aug11, also various others - more common exotic ones
				// tried first, and if not those then the less common ones
				// BEW 4Aug11 changed the code to not test each individually, but just test if
				// wxChar value falls in the range 0x2000 to 0x200D - which is much quicker; and
				// treat U+2060 individually
				// BEW 24Mar12, removed 0x200C and 0x200D from being word-breaking, because Mark
				// Penny said (13Mar12) in an email that those two are used as word-forming
				// characters in many Indian languages
		wxChar WJ = (wxChar)0x2060; // WJ is "Word Joiner"
		// Better to do the check with a range, rather than the commented out stuff below
		// BEW added 3rd subtest 23Nov22
		if (*pChar == WJ || (*pChar >= (wxChar)0x2000 && *pChar <= (wxChar)0x200B) || *pChar == _T('\n'))
		{
			return TRUE;
		}

#endif
	}
	return FALSE;
	*/
	// whm 18Aug2023 note: the IsWhiteSpace() function in helpers.cpp is a "global function"
	// being in global scope (i.e., not part of a class). To avoid a re-entry situation call
	// here within the CAdapt_ItDoc class we prefix :: on the function call of IsWhiteSpace()
	// below which forces the call to the global function in helpers.cpp which also takes a
	// const parameter.
	// ********* CALL THE GLOBAL FUNCTION IN helpers.cpp  *******
	// ********* DO NOT CHANGE THE LINES BELOW ******************
	const wxChar* pcChar = pChar;
	return ::IsWhiteSpace(pcChar);
	// ********* DO NOT CHANGE THE LINES ABOVE ******************
}


///////////////////////////////////////////////////////////////////////////////
/// \return		the number of whitespace characters parsed
/// \param		pChar	-> a pointer to a character being examined/referenced
/// \remarks
/// Called from: the Doc's GetMarkersAndEndMarkersFromString(), TokenizeText(), DoMarkerHousekeeping(),
/// the View's DetachedNonQuotePunctuationFollows(), FormatMarkerBufferForOutput(),
/// FormatUnstructuredTextBufferForOutput(), DoExportInterlinearRTF(), DoExportSrcOrTgtRTF(),
/// DoesTheRestMatch(), ProcessAndWriteDestinationText(), ApplyOutputFilterToText(),
/// ParseAnyFollowingChapterLabel(), NextMarkerIsFootnoteEndnoteCrossRef(),
/// IsFixedSpaceAhead() and from Usfm2Oxes ParseMarker_Content_Endmarker(),
/// and GetNextFilteredMarker_After()
/// Parses through a buffer's whitespace beginning at pChar.
///////////////////////////////////////////////////////////////////////////////
int CAdapt_ItDoc::ParseWhiteSpace(wxChar* pChar)
{
	int	length = 0;
	wxChar* ptr = pChar;
	while (IsWhiteSpace(ptr))
	{
		length++;
		ptr++;
	}
	return length;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		the number of filtering sfm characters parsed
/// \param		wholeMkr	-> the whole marker (including backslash) to be parsed
/// \param		pChar		-> pointer to the backslash character at the beginning of the marker
/// \param		pBufStart	-> pointer to the start of the buffer
/// \param		pEnd		-> pointer at the end of the buffer
/// \remarks
/// Called from: the Doc's TokenizeText()
/// Parses through the filtering marker beginning at pChar (the initial backslash).
/// Upon entry pChar must point to a filtering marker determined by a prior call to
/// IsAFilteringSFM(). 
/// 
/// whm 24Oct2023 comment. The above comment is incorrect. It should read:
/// "Upon entry pChar must point to a filtering marker determined by examining the
/// gCurrentFilterMarkers string." The reason why is The IsAFilteringSFM() function
/// only returns the DEFAULT state of the marker as defined in the AI_USFM.xml control
/// file. It's filter="0" does NOT change from that value even when the user ticks the
/// filtering box within the USFM/Filtering tab in Preferences.
/// 
/// Parsing will include any embedded (inline) markers belonging
/// to the parent marker.
/// BEW 9Sep10 removed need for param pBufStart, since only IsMarker() used to use
/// it as its second param and with docVersion 5 changes that became unnecessary
/// BEW additions 24Oct14 for support of USFM nested markers
/// BEW Filtering of \fig ... \fig* exited early because the figure information carried
/// a windows path string, so the rest of the figure configuration data ended up in
/// the data. Fixed this to span across the contents without checking for a marker other
/// than \fig*
///////////////////////////////////////////////////////////////////////////////
int CAdapt_ItDoc::ParseFilteringSFM(const wxString wholeMkr, wxChar* pChar,
									wxChar* pBufStart, wxChar* pEnd)
{
	wxUnusedVar(pBufStart);
	// whm added 10Feb2005 in support of USFM and SFM Filtering support
	// BEW ammended 10Jun05 to have better parse termination criteria
	// Used in TokenizeText(). For a similar named function used
	// only in DoMarkerHousekeeping(), see ParseFilteredMarkerText().
	// Upon entry pChar must point to a filtering marker determined
	// by prior call to IsAFilteringSFM().
	// ParseFilteringSFM advances the ptr until one of the following
	// conditions is true:
	// 1. ptr == pEnd (end of buffer is reached).
	// 2. ptr points just past a corresponding end marker to the one passed in.
	// 3. ptr points to a subsequent non-inLine and non-end marker. This
	//    means the "content markers"
	// whm ammended 30Apr05 to include "embedded content markers" in
	// the parsed filtered marker, i.e., any \xo, \xt, \xk, \xq, and
	// \xdc that follow the marker to be parsed will be included within
	// the span that is parsed. The same is true for any footnote content
	// markers (see notes below).
	int	length = 0;
	int endMkrLength = 0;
	wxChar* ptr = pChar;
	if (ptr < pEnd)
	{
		// advance pointer one to point past wholeMkr's initial backslash
		length++;
		ptr++;
	}
	// BEW 24Oct14 added next 3 lines
	//bool bIsNestedMkr = FALSE;
	bool bIsWholeMkr = TRUE;
	wxString theTag; theTag.Empty();
	wxString baseOfEndMkr;

	while (ptr != pEnd)
	{
		//if (IsMarker(ptr,pBufStart)) BEW changed 7Sep10
		if (IsMarker(ptr))
		{
			if (IsCorresEndMarker(wholeMkr, ptr, pEnd))
			{
				// it is the corresponding end marker so parse it
				// Since end markers may not be followed by a space we cannot
				// use ParseMarker to reliably parse the endmarker, so
				// we'll just add the length of the end marker to the length
				// of the filtered text up to the end marker
				endMkrLength = wholeMkr.Length() + 1; // add 1 for *
				return length + endMkrLength;
			}
			else if (IsInLineMarker(ptr, pEnd) &&
				IsNestedMarkerOrMarkerTag(ptr, theTag, baseOfEndMkr, bIsWholeMkr))
			{
				// BEW 24Oct14 addition. Bleed the \+tag nested markers here, because
				// the block following is for non-nested inline ones, like the content
				// markers within footnotes or crossrefs or endnotes, and the next block's
				// test checks the char following the backslash and we don't want that to
				// be a +, so we handle the nested ones here first (note: IsInLineMarker()
				// has been refactored to support USFM nested markers)
				; // continue parsing, nested ones get included within a filtering, if encountered
			}
			else if (IsInLineMarker(ptr, pEnd) && *(ptr + 1) == wholeMkr.GetChar(1))
			{
				; // continue parsing
				// We continue incrementing ptr past all inLine markers following a
				// filtering marker that start with the same initial letter (after
				// the backslash) since those can be assumed to be "content markers"
				// embedded within the parent marker. For example, if our filtering
				// marker is the footnote marker \f, any of the footnote content
				// markers \fr, \fk, \fq, \fqa, \ft, \fdc, \fv, and \fm that happen to
				// follow \f will also be filtered. Likewise, if the cross reference
				// marker \x if filtered, any inLine "content" markers such as \xo,
				// \xt, \xq, etc., that might follow \x will also be subsumed in the
				// parse and therefore become filtered along with the \x and \x*
				// markers. The check to match initial letters of the following markers
				// with the parent marker should eliminate the possibility that another
				// unrelated inLine marker (such as \em emphasis) would accidentally
				// be parsed over
			}
			else
			{
				wxString bareMkr = GetBareMarkerForLookup(ptr);
				wxASSERT(!bareMkr.IsEmpty());
				// BEW 24Oct14, LookupSFM() has been refactored for support of USFM nested markers
				USFMAnalysis* pAnalysis = LookupSFM(bareMkr);
				if (pAnalysis)
				{
					if (pAnalysis->textType == none)
					{
						; // continue parsing
						// We also increment ptr past all inLine markers following a filtering
						// marker, if those inLine markers are ones which pertain to character
						// formatting for a limited stretch, such as italics, bold, small caps,
						// words of Jesus, index entries, ordinal number specification, hebrew or
						// greek words, and the like. Currently, these are: ord, bd, it, em, bdit,
						// sc, pro, ior, w, wr, wh, wg, ndx, k, pn, qs -- and their corresponding
						// endmarkers (not listed here) -- this list is specific to Adapt It, it
						// is not a formally defined subset within the USFM standard
					}
					else
					{
						break;	// it's another marker other than corresponding end marker, or
								// a subsequent inLine marker or one with TextType none, so break
								// because we are at the end of the filtered text.
					}
				}
				else
				{
					// pAnalysis is null, this indicates either an unknown marker, or a marker from
					// a different SFM set which is not in the set currently active - eiher way, we
					// treat these as inLine == FALSE, and so such a marker halts parsing
					break;
				}
			}
		}
		length++;
		ptr++;
	}
	return length;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		the number of numeric characters parsed
/// \param		pChar		-> pointer to the first numeric character
/// \remarks
/// Called from: the Doc's TokenizeText(), DoMarkerHousekeeping(), and
/// DoExportInterlinearRTF().
/// Parses through the number until whitespace is encountered (generally a newline)
/// BEW added test for a null, because this function is used in DoMarkerHousekeeping() and
/// so looks at m_markers strings, where it is sometimes possible for a verse number, for
/// example, to end the m_markers string (we try to have a space there), and I got a crash
/// when parsing "\v 4" from a Dynamic Tok Pisin file of James, in chapter 1 -- length had
/// somehow run on to a value of 779 before a crash happened!
//////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItDoc::ParseNumber(wxChar* pChar)
{
	wxChar* ptr = pChar;
	int length = 0;
	wxChar hyphen = _T('-');
	wxChar chA = _T('a');
	wxChar chB = _T('b');
	// BEW 24Aug11, added 2nd test to next line
	// BEW 9Sep14, added subtest for \ of a marker, otherwise \c 4 followed by a line
	// \s Stori.... gives m_markers with "\c 4\s " which gets interpretted by ParseNumber
	// as "4\s" is the 'number' for the chapter, & carries it through each verse in doc!
	// BEW 11Jun23 added subtest: && *ptr != _T('\n')
	// whm 21Aug2023 Note: The IsWhiteSpace() function detects both '\n' and '\r' so those EOL
	// chars need not be explicitly tested for here, but testing for them doesn't hurt anything.
	// BEW 8Sep23, oops, this will parse beyond the end of the number digits, as the while loop
	// does not check that ptr is a digit at each iteration - Fix this: add, && IsAnsiDigit(*ptr)
	// BEW 20Sep23 adding  AND IsAnsiDigit(*ptr) to the test was too strong, it destroyed the
	// ability to parse through the hyphen of a bridge verse number, eg. "3-5", so that the -5
	// ended up as GUI src text in the layout. The fix is to OR it with a hyphen.
	while (!IsWhiteSpace(ptr) && (*ptr != _T('\0')) && (*ptr != _T('\r')) && (*ptr != _T('\n')) && (*ptr != gSFescapechar) && (IsAnsiDigit(*ptr) || hyphen) )
	{
		// BEW 18Oct23 for unknown reason, for a string like:  37).\f* after parsing the 37 correctly, so that ptr 
		// points at ')', IsAnsiDigit(*ptr) in the while test returns TRUE, similarly for the '.' following; so that
		// if I do nothing more, the a length of 4 is returned, rather than the correct value of 2. So my fix will
		// be to explicitly check for *ptr == ')', and when matched, to break from the loop with correct length 2,
		// because on return, code checks for ')' to complete the bracketed number
		if (*ptr == _T(')'))
		{
			break;
		}
		else
		{
			ptr++;
			length++;
		}
	}
	// Handle verse parts where a or b is suffixed
	if (*ptr == chA)
	{
		ptr++;
		length++;
	}
	else if (*ptr == chB)
	{
		ptr++;
		length++;
	}
	return length;
}

// BEW 1Aug23, to get a number string without having to use wxChar*
wxString CAdapt_ItDoc::ParseNumberInStr(wxString strStartingWithNumber)
{
	wxString strReturn = wxEmptyString;
	if (strStartingWithNumber.IsEmpty())
	{
		return strReturn;
	}
	int numLen;
	numLen = 0; // init
	const wxChar* pBuffStart = strStartingWithNumber.GetData();
	wxChar* ptr = (wxChar*)pBuffStart; // this is not const
	wxChar* pEnd = ptr + strStartingWithNumber.Len(); // points to null if .c_str() called
	wxUnusedVar(pEnd);
	numLen = ParseNumber(ptr);
	strReturn = wxString(ptr, numLen);
	return strReturn;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the marker being pointed to by pChar is a verse marker, FALSE otherwise.
/// \param		pChar		-> pointer to the first character to be examined (a backslash)
/// \param		nCount		<- returns the number of characters forming the marker
/// \remarks
/// Called from: the Doc's TokenizeText() and DoMarkerHousekeeping(),
/// DoExportInterlinearRTF() and DoExportSrcOrTgtRTF().
/// Determines if the marker at pChar is a verse marker. Intelligently handles verse markers
/// of the form \v and \vn.
/// BEW 24Oct14 no changes needed for support of USFM nested markers
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsVerseMarker(wxChar* pChar, int& nCount)
// version 1.3.6 and onwards will accomodate Indonesia branch's use
// of \vn as the marker for the number part of the verse (and \vt for
// the text part of the verse - AnalyseMarker() handles the latter)
{
	wxChar* ptr = pChar;
	ptr++;
	if (*ptr == _T('v'))
	{
		ptr++;
		if (*ptr == _T('n'))
		{
			// must be an Indonesia branch \vn 'verse number' marker
			// if white space follows
			ptr++;
			nCount = 3;
		}
		else
		{
			nCount = 2;
		}
		return IsWhiteSpace(ptr);
	}
	else
		return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar points at a \~FILTER (beginning filtered material marker)
/// \param		pChar		-> a pointer to the first character to be examined (a backslash)
/// \param		pEnd		-> a pointer to the end of the buffer
/// \remarks
/// Called from: the Doc's GetMarkersAndEndMarkersFromString()
/// Determines if the marker being pointed at is a \~FILTER marking the beginning of filtered
/// material.
/// BEW 24Mar10 no changes needed for support of doc version 5
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsFilteredBracketMarker(wxChar* pChar, wxChar* pEnd)
{
	// whm added 10Feb2005 in support of USFM and SFM Filtering support
	// determines if pChar is pointing at the filtered text begin bracket \~FILTER
	wxChar* ptr = pChar;
	// whm 8Jun12 modified for wxWidgets-2.9.3 wxStrlen_() is invalid, use wxStrlen()
	//for (int i = 0; i < (int)wxStrlen_(filterMkr); i++) //_tcslen
	for (int i = 0; i < (int)wxStrlen(filterMkr); i++) //_tcslen
	{
		if (ptr + i >= pEnd)
			return FALSE;
		if (*(ptr + i) != filterMkr[i])
			return FALSE;
	}
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar points at a \~FILTER* (ending filtered material marker)
/// \param		pChar		-> a pointer to the first character to be examined (a backslash)
/// \param		pEnd		-> a pointer to the end of the buffer
/// \remarks
/// Called from: the Doc's GetMarkersAndEndMarkersFromString().
/// Determines if the marker being pointed at is a \~FILTER* marking the end of filtered
/// material.
/// BEW 24Mar10 no changes needed for support of doc version 5
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsFilteredBracketEndMarker(wxChar* pChar, wxChar* pEnd)
{
	// whm added 18Feb2005 in support of USFM and SFM Filtering support
	// determines if pChar is pointing at the filtered text end bracket \~FILTER*
	wxChar* ptr = pChar;
	// whm 8Jun12 modified for wxWidgets-2.9.3 wxStrlen_() is invalid, use wxStrlen()
	//for (int i = 0; i < (int)wxStrlen_(filterMkrEnd); i++) //_tcslen
	for (int i = 0; i < (int)wxStrlen(filterMkrEnd); i++) //_tcslen
	{
		if (ptr + i >= pEnd)
			return FALSE;
		if (*(ptr + i) != filterMkrEnd[i])
			return FALSE;
	}
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		the number of characters parsed
/// \param		pChar		-> a pointer to the first character to be parsed (a backslash)
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange(), GetWholeMarker(), TokenizeText(),
/// DoMarkerHousekeeping(), IsEndingSrcPhrase(), ContainsMarkerToBeFiltered(),
/// RedoNavigationText(), GetNextFilteredMarker(), the View's FormatMarkerBufferForOutput(),
/// DoExportSrcOrTgtRTF(), FindFilteredInsertionLocation(), IsFreeTranslationEndDueToMarker(),
/// ParseFootnote(), ParseEndnote(), ParseCrossRef(), ProcessAndWriteDestinationText(),
/// ApplyOutputFilterToText(), ParseMarkerAndAnyAssociatedText().
/// Parses through to the end of a standard format marker.
/// Caution: This function will fail unless the marker pChar points at is followed
/// by whitespace of some sort - a potential crash problem if ParseMarker is used for parsing
/// markers in local string buffers; ensure the buffer ends with a space so that if an end
/// marker is at the end of a string ParseMarker won't crash (TCHAR(0) won't help at the end
/// of the buffer here because _istspace which is called from IsWhiteSpace() only recognizes
/// 0x09 ?0x0D or 0x20 as whitespace for most locales.)
/// BEW 1Feb11, added test for forbidden marker characters using app::m_forbiddenInMarkers
/// BEW 24Oct14 no changes needed for support of USFM nested markers
/// BEW 30Nov22, there was no sanity check. So if pChar points at, say, "2.22" which is  NOT
/// a marker, it returns itemLen = 4 !!! Fix this, pChar must point at gSFescapechar
///////////////////////////////////////////////////////////////////////////////
int CAdapt_ItDoc::ParseMarker(wxChar* pChar)
{
	// whm Note: Caution: This function will fail unless the marker pChar points at is
	// followed by whitespace of some sort - a potential crash problem if ParseMarker is
	// used for parsing markers in local string buffers; ensure the buffer ends with a
	// space so that if an end marker is at the end of a string ParseMarker won't crash
	// (TCHAR(0) won't help at the end of the buffer here because _istspace which is called
	// from IsWhiteSpace() only recognizes 0x09 ?0x0D or 0x20 as whitespace for most
	// locales.
	// whm modified 24Nov07 added the test to end the while loop if *ptr points to a null
	// char. Otherwise in the wx version a buffer containing "\fe" could end up with a
	// length of something like 115 characters, with an embedded null char after the third
	// character in the string. This would foul up subsequent comparisons and Length()
	// checks on the string, resulting in tests such as if (mkrStr == _T("\fe")) failing
	// even though mkrStr would appear to contain the simple string "\fe".
	// I still consider ParseMarker as designed to be dangerous and think it appropriate to
	// TODO: add a wxChar* pEnd parameter so that tests for the end of the buffer can be
	// made to prevent any such problems. The addition of the test for null seems to work
	// for the time being.
	// whm ammended 7June06 to halt if another marker is encountered before whitespace
	// BEW ammended 11Oct10 to halt if a closing bracket ] follows the (end)marker
	int len = 0;
	wxChar* ptr = pChar; // was wchar_t
	if (*pChar != gSFescapechar)
	{
		return len; // BEW 30Nov22 added this sanity check
	}
	wxChar* pBegin = ptr;
	while (!IsWhiteSpace(ptr) && *ptr != _T('\0') && gpApp->m_forbiddenInMarkers.Find(*ptr) == wxNOT_FOUND)
	{
		if (ptr != pBegin && (*ptr == gSFescapechar || *ptr == _T(']')))
			break;
		ptr++;
		len++;
		if (*(ptr - 1) == _T('*')) // whm ammended 17May06 to halt after asterisk (end marker)
			break;
	}
	return len;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString representing the marker being pointe to by pChar
/// \param		pChar		-> a pointer to the first character to be examined (a backslash)
/// \param		pEnd		-> a pointer to the end of the buffer
/// \remarks
/// Called from: the Doc's GetMarkersAndEndMarkersFromString().
/// Returns the whole marker by parsing through an existing marker until either whitespace is
/// encountered or another backslash is encountered.
/// BEW fixed 10Sep10, the last test used forward slash, and should be backslash
/// BEW 24Oct14, no changes needed for support of USFM nested markers
/// BEW 25Mar15, refactored - it was returning nothing because pChar was pointing at
/// backslash on entry, so added a code block to accumulate the backslash before doing
/// the loop
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::MarkerAtBufPtr(wxChar* pChar, wxChar* pEnd) // whm added 18Feb05
{
	int len = 0;
	wxChar* ptr = pChar;
	// To make this code safe when the m_markers member contains \p\v sequence (with no
	// intervening space) or the more common \p \v sequence (with intervening space),
	// requires changes. First, on entry pChar points at the initial backslash, and so
	// the && *ptr != _T('\\') subtest causes immediate break from the loop, leading to
	// nothing being returned. So we need to accumulate that initial backslash unilaterally.
	// After that, the loop will work correctly for either \p\v  or  \p \v  sequences
	if (*ptr == _T('\\'))
	{
		ptr++;
		len++;
	}
	// Now traverse the rest of the marker, up to the next whitespace or backslash
	while (ptr < pEnd && !IsWhiteSpace(ptr) && *ptr != _T('\\'))
	{
		ptr++;
		len++;
	}
	return wxString(pChar, len);
}

// return TRUE if the quotation character at pChar is either " or '
bool CAdapt_ItDoc::IsStraightQuote(wxChar* pChar)
{
	if (gpApp->m_bDoubleQuoteAsPunct)
	{
		if (*pChar == _T('\"')) return TRUE; // ordinary double quote
	}
	if (gpApp->m_bSingleQuoteAsPunct)
	{
		if (*pChar == _T('\'')) return TRUE; // ordinary single quote
	}
	return FALSE;
}

bool CAdapt_ItDoc::IsFootnoteInternalEndMarker(wxChar* pChar)
{
	wxString endMkr = GetWholeMarker(pChar);
	if (endMkr[0] != gSFescapechar)
		return FALSE;
	if (endMkr == _T("\\fig*"))
		return FALSE;
	wxString reversed = MakeReverse(endMkr);
	if (reversed[0] != _T('*'))
		return FALSE;
	else
	{
		reversed = reversed.Mid(1); // remove initial *
		endMkr = MakeReverse(reversed); // now \f should be first 2 characters
									// if it is an internal footnote endmarker
		int length = endMkr.Len();
		if (length < 3)
			return FALSE; // it could be \f at best, and that is not enough
		if (endMkr.Find(_T("\\f")) != 0)
			return FALSE; // \f has to be at the start of the marker, to qualify
		endMkr = endMkr.Mid(2); // chop off the initial \f
		if (endMkr.Len() > 0)
		{
			// if it has any content left, then it is an internal footnote endmarker,
			// any other value disqualifies it
			return TRUE;
		}
	}
	return FALSE;
}

bool CAdapt_ItDoc::IsCrossReferenceInternalEndMarker(wxChar* pChar)
{
	wxString endMkr = GetWholeMarker(pChar);
	if (endMkr[0] != gSFescapechar)
		return FALSE;
	wxString reversed = MakeReverse(endMkr);
	if (reversed[0] != _T('*'))
		return FALSE;
	else
	{
		reversed = reversed.Mid(1); // remove initial *
		endMkr = MakeReverse(reversed); // now \x should be first 2 characters
							// if it is an internal crossReference endmarker
		int length = endMkr.Len();
		if (length < 3)
			return FALSE; // it could be \x at best, and that is not enough
		if (endMkr.Find(_T("\\x")) != 0)
			return FALSE; // \x has to be at the start of the marker, to qualify
		endMkr = endMkr.Mid(2); // chop off the initial \x
		if (endMkr.Len() > 0)
		{
			// if it has any content left, then it is an internal crossReference
			// endmarker, any other value disqualifies it
			return TRUE;
		}
	}
	return FALSE;
}

// BEW 30Sep19 added 3rd param, the boolean is default FALSE for checking for a match
// in pSrcPhrase->m_endMarkers member. If the bool is passed in as TRUE, the check is
// done instead in the pSrcPhrase->m_inlineNonbindingEndMarkers member. The mkr passed
// in is a begin-mkr which is to be matched to wherever its endmarker is in the span
// of CSourcePhrase instances being accumulated for filtering out, so we must internally
// construct from it the endMkr we want to match.
// And some refactoring here and there to take m_inlineNonbindingMarkers, and
// m_inlineNonbindingEndMarkers into account.
// If the return value is TRUE, then that passed in pSrcPhrase is the end-of-span one,
// and the caller will not call the safety checking function IsEndingSrcPhrase() on
// pSrcPhraseNext which acts to prevent span overrun or marker content overlap.
bool CAdapt_ItDoc::HasMatchingEndMarker(wxString mkr, CSourcePhrase* pSrcPhrase, bool bSearchInNonbindingEndMkrs)
{
	wxString mymkr = mkr;
	wxString endMkr = wxEmptyString;
	// Handle \esb and \esbe  in USFM3 standard
	if (mymkr == wxString(_T("\\esb")))
	{
		endMkr = _T("\\esbe");
	}
	else
	{
		mymkr = mymkr.Trim(); // remove any ending whitespace (there shouldn't be any anyway)
		mymkr += _T('*');

	}
	// Check in the non-binding end marker storage...
	if (bSearchInNonbindingEndMkrs)
	{
		// whm 31Oct2023 correction. Within this bSearchInNonbindingEndMkrs TRUE block
		// the endMkr that we may be dealing with could be "\\fig*". The if-else test
		// above does NOT set endMkr to anything, but leaves it wxEmptyString when 
		// the incoming mkr parameter is "\\fig". Below the if (endMkr == wholeNonbindingEndMkr)
		// test will fail for any "\\fig*" end marker stored within the 
		// pSrcPhrase->m_inlineNonbindingEndMarkers member. To fix this shortcoming, I'm
		// assigning the mymkr value determined above to the endMkr here within the
		// bSearchInNonbindingEndMkrs TRUE block.
		endMkr = mymkr;

		wxString inlineNonbindingEndMkrs = pSrcPhrase->GetInlineNonbindingEndMarkers();

		// return FALSE if pSrcPhrase->GetInlineNonbindingEndMarkers() is empty
		if (inlineNonbindingEndMkrs.IsEmpty())
		{
			return FALSE;
		}
		// the UsfmOnly set must be currently in use; the matching endmarker, 
		// if it exists, the caller says to look in m_inlineNonbindingEndMarkers;
		// and it will ALWAYS be the last one if that member stores more than one
		// - because if the earlier one was the filter marker, then it being filtered 
		// would remove the next one from contention for being available to 
		// the filtering mechanism ... so, there would not be a 'next' one
		// we need to consider.
		// A note about USFM3: our quick access marker strings include in the
		// inLine Non-binding set, the non-inline but Non-binding markers
		// \esb and its endmarker \esbe in the Non-binding End markers set.
		// These markers are used for extended sidebar markup, and are
		// filterable = 1, and useCanSetFilter = 1; there could be a lot
		// of text content between them.
		wxString wholeNonbindingEndMkr = GetLastMarker(inlineNonbindingEndMkrs);
		// Trim off any final whitespace
		wholeNonbindingEndMkr.Trim();
		if (endMkr == wholeNonbindingEndMkr)
		{
			// we have a match
			return TRUE;
		}
		return FALSE; // no match
	} // end of TRUE block for test: if (bSearchInNonbindingEndMkrs)

	else
	{
		wxString endMkrs = pSrcPhrase->GetEndMarkers();
		if (gpApp->gCurrentSfmSet == PngOnly)
		{
			// check for one of the 'footnote end' markers, the only endmarkers in the PNG 1998
			// marker set
			if (endMkrs.IsEmpty())
			{
				return FALSE;
			}
			if (endMkrs == _T("\\fe") || endMkrs == _T("\\F"))
			{
				// it's one of those two, so if mkr is \f, we've got a match
				wxString mkrPlusSpace = mkr + _T(' ');
				if (mkrPlusSpace == _T("\\f "))
				{
					return TRUE;
				}
				else
				{
					return FALSE;
				}
			}
		}
		// the UsfmOnly set must be currently in use; the matching endmarker, 
		// if it exists, must be in m_endMarkers and it will ALWAYS be the last one 
		// if that member stores more than one - because it the earlier one was the
		// filter marker, then it being filtered would remove the next one from 
		// being available to the filtering mechanism, hence, there cannot be
		// a 'next' one
		wxString endmarkers = pSrcPhrase->GetEndMarkers();
		if (endmarkers.IsEmpty())
		{
			return FALSE; // no match is possible
		}
		wxString wholeEndMkr = GetLastMarker(endmarkers);
		if (mymkr == wholeEndMkr)
		{
			// we have a match
			return TRUE;
		}
		return FALSE; // no match
	} // end of else block for test: if (bSearchInNonbindingEndMkrs)
}

// NOTE: the endmarker for endnote is included in the test, so while the name of this
// function suggests only \f* and \x* return TRUE, \fe* will also return TRUE
// BEW 7Dec10, added check for \fe or \f when SFM set is PngOnly
// BEW 24Oct14 no changes needed for support of USFM nested markers
// BEW 15Apr20 extended & refactored to support \ef* and \ex* USFM3
// extended footnotes and extended cross-references
bool CAdapt_ItDoc::IsFootnoteOrCrossReferenceEndMarker(wxChar* pChar)
{
	wxString endMkr = GetWholeMarker(pChar);
	if (gpApp->gCurrentSfmSet == PngOnly)
	{
		// check for 'footnote end' markers, the only endmarkers in the PNG 1998
		// marker set
		if (endMkr == _T("\\fe") || endMkr == _T("\\F"))
			return TRUE;
	}
	if (endMkr == _T("\\fig*"))
		return FALSE;
	if (endMkr == _T("\\fe*"))
	{
		// we include a test for the endmarker of an endnote in this function, because we
		// want the handling for \f* and \fe* to be the same  - either, if found, should
		// be stored in m_endMarkers, and either can have outer punctuation following it
		return TRUE;
	}
	// whm 9Jul12 added endMkr.IsEmpty() test to prevent out-of-range array access
	// return if endMkr is empty or if its first character is not '\'
	if (endMkr.IsEmpty() || endMkr[0] != gSFescapechar)
		return FALSE;
	wxString rev = MakeReverse(endMkr);
	if (rev[0] != _T('*'))
		return FALSE;
	else
	{
		rev = rev.Mid(1); // remove initial *
		// rev is maybe one of:   f\  fe\  x\  xe\  <== ending backslash in comment. GCC warns about muitiline comment
		// To qualify for correctness, the [0] index one must be either f or x
		// For each of those, also test [1] for 'e' - and for each each the
		// backslash must follow. First, footnote and extended footnote
		if (rev[0] == _T('f'))
		{
			if (rev[1] == gSFescapechar)
			{
				// it's a \f* end marker
				m_bIsWithinUnfilteredInlineSpan = FALSE; // BEW added 2Dec22, as few places restore it to FALSE
				return TRUE;
			}
			else
			{
				if (rev[1] == _T('e') && rev[2] == gSFescapechar)
				{
					// it's a \ef* extended footnote end marker
					m_bIsWithinUnfilteredInlineSpan = FALSE; // BEW added 2Dec22, as few places restore it to FALSE
					return TRUE;
				}
			}
		}
		// Next, handle cross refs ones
		if (rev[0] == _T('x'))
		{
			if (rev[1] == gSFescapechar)
			{
				// it's a \x* end marker
				m_bIsWithinUnfilteredInlineSpan = FALSE; // BEW added 2Dec22, as few places restore it to FALSE
				return TRUE;
			}
			else
			{
				if (rev[1] == _T('e') && rev[2] == gSFescapechar)
				{
					// it's a \ex* extended x-ref end marker
					return TRUE;
				}
			}
		}
		/* legacy code
				endMkr = MakeReverse(reversed);
				int length = endMkr.Len();
				if (length > 2)
					return FALSE; // what remains is more than \x or \f, so disqualified
				if ((endMkr.Find(_T("\\x")) == 0) || (endMkr.Find(_T("\\f")) == 0))
					return TRUE; // what remains is either \x or \f, so it qualifies
		*/
	}
	// It's none of these
	return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing to an opening quote mark
/// \param		pChar		-> a pointer to the character to be examined
/// \remarks
/// Called from: the Doc's ParseWord(), the View's DetachedNonQuotePunctuationFollows().
/// Determines is the character being examined is some sort of opening quote mark. An
/// opening quote mark may be a left angle wedge <, a Unicode opening quote char L'\x201C'
/// or L'\x2018', or an ordinary quote or double quote or char 145 or 147 in the ANSI set.
/// Assumes that " is defined as m_bDoubleQuoteAsPunct in the App and/or that ' is defined
/// as m_bSingleQuoteAsPunct in the App.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsOpeningQuote(wxChar* pChar)
{
	// next three functions added by BEW on 17 March 2005 for support of
	// more clever parsing of sequences of quotes with delimiting space between
	// -- these are to be used in a new version of ParseWord(), which will then
	// enable the final couple of hundred lines of code in TokenizeText() to be
	// removed
	// include legacy '<' as in SFM standard, as well as smart quotes
	// and normal double-quote, and optional single-quote
	if (*pChar == _T('<')) return TRUE; // left wedge
#ifdef _UNICODE
	if (*pChar == L'\x201C') return TRUE; // unicode Left Double Quotation Mark
	if (*pChar == L'\x2018') return TRUE; // unicode Left Single Quotation Mark
#else // ANSI version
	if ((unsigned char)*pChar == 147) return TRUE; // Left Double Quotation Mark
	if ((unsigned char)*pChar == 145) return TRUE; // Left Single Quotation Mark
#endif
	if (gpApp->m_bDoubleQuoteAsPunct)
	{
		if (*pChar == _T('\"')) return TRUE; // ordinary double quote
	}
	if (gpApp->m_bSingleQuoteAsPunct)
	{
		if (*pChar == _T('\'')) return TRUE; // ordinary single quote
	}
	// the left-pointing double angle quotation mark
#ifdef _UNICODE
	if (*pChar == L'\x00AB') return TRUE; // left-pointing double chevron
#else
	if (*pChar == '\xAB') return TRUE; // left-pointing double chevron
#endif
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing to a " or to a ' (apostrophe) quote mark
/// \param		pChar		-> a pointer to the character to be examined
/// \remarks
/// Called from: the Doc's ParseWord().
/// Assumes that " is defined as m_bDoubleQuoteAsPunct in the App and/or that ' is defined
/// as m_bSingleQuoteAsPunct in the App.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsAmbiguousQuote(wxChar* pChar)
{
	if (gpApp->m_bDoubleQuoteAsPunct)
	{
		if (*pChar == _T('\"')) return TRUE; // ordinary double quote
	}
	if (gpApp->m_bSingleQuoteAsPunct)
	{
		if (*pChar == _T('\'')) return TRUE; // ordinary single quote (ie. apostrophe)
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing to a closing quote mark
/// \param		pChar		-> a pointer to the character to be examined
/// \remarks
/// Called from: the Doc's ParseWord().
/// Determines is the character being examined is some sort of closing quote mark.
/// An closing quote mark may be a right angle wedge >, a Unicode closing quote char L'\x201D'
/// or L'\x2019', or an ordinary quote or double quote or char 146 or 148 in the ANSI set.
/// Assumes that " is defined as m_bDoubleQuoteAsPunct in the App and/or that ' is defined
/// as m_bSingleQuoteAsPunct in the App.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsClosingQuote(wxChar* pChar)
{
	// include legacy '>' as in SFM standard, as well as smart quotes
	// and normal double-quote, and optional single-quote
	if (*pChar == _T('>')) return TRUE; // right wedge
#ifdef _UNICODE
	if (*pChar == L'\x201D') return TRUE; // unicode Right Double Quotation Mark
	if (*pChar == L'\x2019') return TRUE; // unicode Right Single Quotation Mark
#else // ANSI version
	if ((unsigned char)*pChar == 148) return TRUE; // Right Double Quotation Mark
	if ((unsigned char)*pChar == 146) return TRUE; // Right Single Quotation Mark
#endif
	if (gpApp->m_bDoubleQuoteAsPunct)
	{
		if (*pChar == _T('\"')) return TRUE; // ordinary double quote
	}
	if (gpApp->m_bSingleQuoteAsPunct)
	{
		if (*pChar == _T('\'')) return TRUE; // ordinary single quote
	}
	// the right-pointing double angle quotation mark
#ifdef _UNICODE
	if (*pChar == L'\x00BB') return TRUE; // the double chevron
#endif
	return FALSE;
}

bool CAdapt_ItDoc::IsClosingDoubleChevron(wxChar* pChar)
{
	// the right-pointing double angle quotation mark
#ifdef _UNICODE
	if (*pChar == L'\x00BB') return TRUE; // right-pointing double chevron
#else
	if (*pChar == '\xBB') return TRUE; // right-pointing double chevron
#endif
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing to a closing curly quote mark
/// \param		pChar		-> a pointer to the character to be examined
/// \remarks
/// Called from: the Doc's ParseWord().
/// Determines is the character being examined is some sort of non-straight closing quote
/// mark, that is, not one of ' or ". So a closing curly quote mark may be a right angle
/// wedge >, or a Unicode closing quote char L'\x201D' or L'\x2019'.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsClosingCurlyQuote(wxChar* pChar)
{
	// include legacy '>' as in SFM standard, as well as smart quotes
	// but not normal double-quote, nor single-quote
	if (*pChar == _T('>')) return TRUE; // right wedge
#ifdef _UNICODE
	if (*pChar == L'\x201D') return TRUE; // unicode Right Double Quotation Mark
	if (*pChar == L'\x2019') return TRUE; // unicode Right Single Quotation Mark
#else // ANSI version
	if ((unsigned char)*pChar == 148) return TRUE; // Right Double Quotation Mark
	if ((unsigned char)*pChar == 146) return TRUE; // Right Single Quotation Mark
#endif
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing to a closing doublequote " (straight, not curly)
///             which should NOT be interpretted as a closing quote, but rather as an
///             opening quote for the word which follows; FALSE if it is acceptable as
///             a closing quote to the just parsed word
/// \param		pChar		-> a pointer to the character to be examined
/// \param      pPunctStart -> a pointer to the start of the string being parsed
///             (typically, it would point at a space which is ambiguous as to
///             whether it is a word delimiting space, or a closing punctuation
///             delimiting space)
/// \remarks
/// Called from: the Doc's ParseAdditionalFinalPuncts(). This is a hack. It's "protection"
/// just in case the clearing of the flag m_bHasPrecedingStraightQuote did not stop the
/// caller from recognising a straight doublequote wrongly as a closing quote - so this
/// hack should catch anything that leaks through. m_bHasPrecedingStraightQuote is TRUE
/// only when " is encountered as a word initial quote, ' is now (2Nov16, BEW)interpretted
/// the same, because while ' is often preceding a vowel in some Pacific languages to
/// indicate the vowel is "hard",this is an issue only when the vowel is word initial.
/// ' needs to be defaulted to being punctuation so that '\it <some word> gets parsed
/// properly - otherwise the ' ends up as a word in its own right on its own CSourcePhrase.
/// The function looks at what follows *ptr, and what precedes, since *ptr is " character.
/// If what follows it not a whitespace, then " must be interpretted as belonging to the
/// next word in the parse, and so we return TRUE. It can't be a closing quote. Looking
/// to what precedes, we examine the character immediately preceding *pPunctStart - that
/// will typically be a parsed over punctuation character. The " we are concerned about
/// should only be a 'detached quote' if there was, prior to any just-pased-over whitespace,
/// another straight quote, or a curly closed quote, or a > chevron.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::CannotBeClosingQuote(wxChar* ptr, wxChar* pPunctStart)
{
	wxChar charNext = *(ptr + 1);
	if (!IsWhiteSpace(&charNext))
	{
		return TRUE;
	}
	wxChar charBeforeParseStartLoc = *(pPunctStart - 1);
	if (!IsClosingQuote(&charBeforeParseStartLoc))
	{
		return TRUE;
	}
	return FALSE;
}


// BEW 15Dec10, changes needed to handle PNG 1998 marker set's \fe and \F
// BEW 24Oct14 no changes needed for support of USFM nested markers, the ones dealt
// with here never take +
// BEW 30Sep19 added \fig* to this, as for USFM3 it needs to be m_bSpecialText TRUE
// when not filtered, so that the caption text is in the special text colour (red)
// Required a significant amount of refactoring, as the earlier version was not all
// that hot anyway!
// BEW 3Jul23 needed a deep refactor, to prevent red runon, and to properly handle all 5 possible
// spans; and added typeChangingEndMkr to return to the caller what marker actually caused the type
// to change, whether \f* \x* \fe* \ef* or \ex*. When TRUE is returned, the typeChangingEndMkr will
// tell us which code block to use in the caller to effect the closing off of the span, etc.
// When FALSE is returned, the return typeChangingEndMkr as wxEmptyString - to act as a flag
bool CAdapt_ItDoc::IsTextTypeChangingEndMarker(CSourcePhrase* pLastSrcPhrase, wxString& typeChangingEndMkr)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	if (gpApp->gCurrentSfmSet == PngOnly || gpApp->gCurrentSfmSet == UsfmAndPng)
	{
		// in the PNG 1998 set, there is no marker for endnotes, and cross references were
		// not included in the standard but inserted manually from a separate file, and so
		// there is no \x nor any endmarker for a cross reference either; there were only
		// two marker synonyms for ending a footnote, \fe or \F
		wxString fnoteEnd1 = _T("\\fe");
		wxString fnoteEnd2 = _T("\\F");
		wxString endmarkers = pLastSrcPhrase->GetEndMarkers();
		if (endmarkers.IsEmpty())
			return FALSE;
		if (endmarkers.Find(fnoteEnd1) != wxNOT_FOUND)
		{
			return TRUE;
		}
		else if (endmarkers.Find(fnoteEnd2) != wxNOT_FOUND)
		{
			return TRUE;
		}
	}
	else
	{
		wxString fnoteEnd = _T("\\f*");
		wxString endnoteEnd = _T("\\fe*"); // endnote text item, textType = footnote (9), navText = "endnote"
		wxString crossRefEnd = _T("\\x*");
		wxString extfnoteEnd = _T("\\ef*"); // BEW added 21Apr20, "study note text item" like \f* ... \f* span, textType = note (34)
		wxString extcrossRefEnd = _T("\\ex*"); // BEW added 21Apr20 "list of study bible extended cross references" - a span, textType = note (34)
		wxString figEnd = _T("\\fig*"); // BEW 30Sep19, added (the endmarker will be in the 'inline non-binding endmarkers' member variable
			// & it has a span, but is ignored for span purposes (i.e. m_bIsWithinUnfilteredInlineSpan is FALSE), because
			// nonbinding markers should not alter the textType.
		// BEW 3July23, so there are 5 spans to be supported, and when in one of these, m_bIsWithinUnfilteredInlineSpan
		// should be TRUE. Do not change the value of m_bIsWithinUnfilteredInlineSpan within this present function, but only
		// in the function's caller IsTextTypeChangingEndMarker() when this function returns TRUE for bool bIsChanger

		wxString endmarkers = pLastSrcPhrase->GetEndMarkers();
		wxString lastMkr = wxEmptyString; // init  -- BEW deprecate after refactor

		// BEW 9Jan23 add support for endMkr being one of the pApp->m_RedEndMarkers set, 
		// pLastSrcPhrase is what was passed in, when the pLastSrcPhrase is the one which
		// ends one of the five spans, it's m_endMarkers member should have the relevant
		// endmarker (even if not final in m_endMarkers)
		int offset = wxNOT_FOUND; // init
		wxString augEndMkr;
		if (endmarkers.IsEmpty())
		{
			// Can't possibly be the pLastSrcPhrase which ends the span
			return FALSE;
		}
		else
		{
			// BEW 3Jul23 complete refactor here. Handle each of the possible spans, in
			// sequence. If a given span type's endMkr is detected, return that endMkr
			// via the signature, and return TRUE so that bIsChanger in the caller can
			// get the span closed off correctly, without any red runon.

			// First, span internal endmarkers - like \fv* \ft* etc do not close a span,
			// check the pApp->m_EmbeddedIgnoreEndMarkers fast-access string, and if in
			// it, return FALSE. Test inludes also embedded \xo* etc. Then we can check
			// for one of the five known span-ending endMkrs. Embedded endMkrs in a span
			// will not have a following inlineNonbindingEndMkr following, so we can
			// use GetLastEndMarker() and test m_EmbeddedIgnoreEndMarkers using that.
			lastMkr = GetLastEndMarker(endmarkers);
			augEndMkr = lastMkr + _T(' ');
			offset = pApp->m_EmbeddedIgnoreEndMarkers.Find(augEndMkr);
			if (offset >= 0)
			{
				// Control is within a span, and so it's not a pLastSrcPhrase for closing the span
				return FALSE;
			}
			// Now deal with each possible span. Footnotes are common, so handle first
			offset = wxNOT_FOUND;
			offset = endmarkers.Find(fnoteEnd);
			if (offset >= 0)
			{
				// We found \f* within endmarkers, so this pLastSrcPhrase finishes the footnote span
				typeChangingEndMkr = fnoteEnd;
				return TRUE;
			}
			offset = endmarkers.Find(crossRefEnd);
			if (offset >= 0)
			{
				// We found \x* within endmarkers, so this pLastSrcPhrase finishes the cross-ref span
				typeChangingEndMkr = crossRefEnd;
				return TRUE;
			}
			offset = endmarkers.Find(endnoteEnd);
			if (offset >= 0)
			{
				// We found \fe* within endmarkers, so this pLastSrcPhrase finishes the end note span
				typeChangingEndMkr = endnoteEnd;
				return TRUE;
			}
			offset = endmarkers.Find(extfnoteEnd);
			if (offset >= 0)
			{
				// We found \ef* within endmarkers, so this pLastSrcPhrase finishes the external study note span
				typeChangingEndMkr = extfnoteEnd;
				return TRUE;
			}
			offset = endmarkers.Find(extcrossRefEnd);
			if (offset >= 0)
			{
				// We found \ex* within endmarkers, so this pLastSrcPhrase finishes the extended study note span
				typeChangingEndMkr = extcrossRefEnd;
				return TRUE;
			}
			else
			{
				// If none of those above was in endMarkers, then return an empty marker, and FALSE
				
				return FALSE;
			}
			// Note: embedded end markers of type \+endMkr do not occur in the parse of the spans,
			// because it's in the adaptations that they may occur because there they are designated
			// as 'embedded' and so would require the + in the target text's marker

		} // end of else block for test: if (endmarkers.IsEmpty())

	} // end of else block for test: if (gpApp->gCurrentSfmSet == PngOnly || gpApp->gCurrentSfmSet == UsfmAndPng)

	// If control gets to here, returning FALSE is the right story
	typeChangingEndMkr = wxEmptyString;
	return FALSE;
}

bool CAdapt_ItDoc::IsPunctuation(wxChar* ptr, bool bSource) // bSource is default TRUE
{
	if (bSource)
	{
		if (gpApp->m_strSpacelessSourcePuncts.IsEmpty())
		{
			return FALSE;
		}
		int offset = wxNOT_FOUND;
		offset = gpApp->m_strSpacelessSourcePuncts.Find(*ptr);
		if (offset == wxNOT_FOUND)
		{
			return FALSE;
		}
		return TRUE;
	}
	else
	{
		if (gpApp->m_strSpacelessTargetPuncts.IsEmpty())
		{
			return FALSE;
		}
		int offset = wxNOT_FOUND;
		offset = gpApp->m_strSpacelessTargetPuncts.Find(*ptr);
		if (offset == wxNOT_FOUND)
		{
			return FALSE;
		}
		return TRUE;
	}
}



//////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param	span		           -> span of characters extracted from the text buffer
///                                   by the FindParseHaltLocation() function; we parse this
/// \param  wordProper             <- the word itself [see a) below]
/// \param  firstFollPuncts	       <- any punctuation characters (out-of-place ones, [see b)
///                                   below])
/// \param	nEndMkrsCount          <- how many inline binding endmarkers there are in the
///                                   span string [this is known to the caller beforehand]
/// \param	inlineBindingEndMarkers <- one of more inline binding endmarkers following the
///                                    wordProper in the span string
/// \param  secondFollPuncts        <- normal "following punctuation" which, if an inline
///                                    binding endmarker is present, should (if the USFM
///                                    markup is correctly done) follow the marker [Note:
///                                    if there is no inline binding endmarker present,
///                                    only firstFollPuncts will have punctuation chars in
///                                    it, and they will be in standard position (of course)]
/// \param  ignoredWhiteSpaces      <- one or more characters of whitespace - because
///                                    Adapt It normalizes most \n and \r characters out of
///                                    the data (using space instead) typically this will just
///                                    be one of more spaces, but we don't rely on that being
///                                    true
/// \param  wordBuildersForPostWordLoc <- For storing one or more wordbuilding characters     // <<-- deprecate, asap BEW 7Nov22, comment out 11874 and easily find where to refactor
///                                    which are at the end of m_follPunct because they were
///                                    formerly punctuation but the user has changed the
///                                    punctuation set and now they are word-building ones
///                                    (the caller will restore them to their word-final
///                                    location)
/// \param  spacelessPuncts          -> the (spaceless) punctuation set being used (usually
///                                    src punctuation, but target punctuation can be passed
///                                    if we want to parse target text for some reason - in
///                                    which case span should contain target text) Note, if
///                                    we want space to be part of the punctuation set, we
///                                    must add it here explicitly in a local string before
///                                    doing anything else
/// \remarks
/// Called from: IsFixedSpaceAhead()
/// FindParseHaltLocation() is used within IsFixedSpaceAhead() (itself within ParseWord()
/// called from TokenizeText()) to extract characters from the input buffer until a
/// halting location is reached - which could be at a ~ fixedspace marker, or if certain
/// other post-word data is encountered. That defines a span of characters which commence
/// with the characters of the word being parsed, but which could end with quite complex
/// possibilities. This ParseSpanBackwards() function parsed from the end of that span,
/// backwards towards its start, extracting each information type which it returns via the
/// signature's parameters. The material being parsed, in storage order (in a RTL script
/// this would be rendered RTL, not LTR of course, but both are stored in LTR order) may
/// be this:
/// a) the word proper (it may contain embedded punctuation which must remain invisible to
/// our parsers, that's why we parse backwards - we expect to reach characters at the end
/// of the word before the backwards parse has a chance to hit an embedded punct character)
/// b) out-of-place (for canonical USFM markup) following punctuation (which may contain
/// embedded space - such as for closing curly quote sequences)
/// c) inline binding endmarker(s) (we allow for more than one - we'll extract them as a
/// sequence and not try to remove any unneeded spaces between them - they normally would
/// have no space between any such pair) -- the FindParseHaltLocation() knows how many such
/// markers it scanned over to get to the halt location, and it returned a count for that,
/// and so we pass in that count value in the nEndMkrsCount param
/// d) more following punctuation (this is in the canonical location if there is an inline
/// binding marker present - punctuation should only follow such an endmarker in good USFM
/// markup, never precede it -- so the caller will coalesce the out of place puncts with
/// the in place puncts, to restore good USFM markup [white space between word and puncts,
/// keep it if present, because some languages require space between word and puncts at
/// either end.
/// e) some white space - this would be ignorable, and we'll return it so that the caller
/// can get it's iterator position set correctly, but the caller will then just ignore any
/// such white space returned
/// BEW created 11Oct10 (actually 27Jan11), to support the improved USFM parser build into
/// doc version 5
/// BEW 2Feb11, added a string to signature for storing punctuation characters that have
/// changed their status to being word-building
/// BEW 24Oct14, no changes needed to support USFM nested markers
//////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::ParseSpanBackwards(wxString& span, wxString& wordProper,
	wxString& firstFollPuncts, int nEndMkrsCount, wxString& inlineBindingEndMarkers,
	wxString& secondFollPuncts, wxString& ignoredWhiteSpaces,
	wxString& wordBuildersForPostWordLoc, wxString& spacelessPuncts)
{
	// initialize
	wordProper.Empty(); firstFollPuncts.Empty(); inlineBindingEndMarkers.Empty();
	secondFollPuncts.Empty(); ignoredWhiteSpaces.Empty();
	wordBuildersForPostWordLoc.Empty(); // potentially used when parsing the first or
										// second word of a conjoined pair, or when
										// parsing a non-conjoined word
#if defined(_DEBUG) && defined(TOKENIZE_BUG)
	if (aSequNum >= 1367)
	{
		int halt_here = 1;
		wxUnusedVar(halt_here);
	}
#endif

	// reverse the string
	if (span.IsEmpty())
	{
		// BEW 6Jan23 we make limited use of this function, it's for fixed-space support, and 
		// if span is empty, return without showing a message box, and don't sound the bell.
		//wxBell();
		//wxMessageBox(_T("Error: in ParseSpanBackwards(), input string 'span' is empty"));
		return;
	}
	int length = span.Len();
	wxString str = MakeReverse(span);

	// check we have a non-empty punctuation characters set - if it's empty, we can skip
	// parsing for punctuation characters
	bool bPunctSetNonEmpty = TRUE;
	wxString punctSet; punctSet.Empty();
	if (spacelessPuncts.IsEmpty())
	{
		bPunctSetNonEmpty = FALSE;
	}
	else
	{
		// we need space to be in the punctuation set, so add it to a local string and use the
		// local string thereafter; we don't add it if there are no punctuation characters set
		punctSet = spacelessPuncts + _T(' ');
	}

	// get access to the wxString's buffer - then iterate across it, collecting the
	// substrings as we go
	const wxChar* pBuffer = str.GetData();
	wxChar* p = (wxChar*)pBuffer;
	wxChar* pEnd = p + length;
	wxChar* pStartHere = p;
	int punctsLen2 = 0;
	int punctsLen1 = 0;
	int ignoredWhitespaceLen = 0;
	int bindingEndMkrsLen = 0;

	// first get any ignorable whitespace
	ignoredWhitespaceLen = ParseWhiteSpace(p);
	if (ignoredWhitespaceLen > 0)
	{
		wxString ignoredSpaceRev(p, p + ignoredWhitespaceLen);
		ignoredWhiteSpaces = MakeReverse(ignoredSpaceRev); // normal order
		pStartHere = p + ignoredWhitespaceLen; // advance starting location
	}
	// next, any punctuation characters -- we'll put them in secondFollPuncts string
	// whether of not nEndMkrsCount is zero (because this is where we'd expect good USFM
	// markup to have them); skip this step if there are no punctuation characters defined
	p = pStartHere;
	wxString puncts; puncts.Empty();
	if (bPunctSetNonEmpty)
	{
		// allow \n and \r to be parsed over too (ie. whitespace, not just space),
		// space character is already in punctSet, so no need to add an explicit test;
		// Note, the loop will also end if it encounters what used to be a word-building
		// character which, due to user changing punctuation set, it became a punctuation
		// character and so got pulled off the word's end and stored in m_follPunct, but
		// subsequent to that the user again changed the punctuation set making it back
		// into a word building character - so that it is still in m_follPunct at its end
		// (it may be the only character in m_follPunct), and so we will have to test for
		// this and store it and any like it in a special string,
		// wordBuildersForPostWordLoc, to return such characters to the caller for
		// placement there back at the end of the parsed word
		while (p < pEnd)
		{
			if (punctSet.Find(*p) != wxNOT_FOUND || *p == _T('\n') || *p == _T('\r'))
				puncts += *p++;
			else
				break;
		}
		// add the puncts to secondFollPuncts, if any were found -- note, there could be a
		// space (it's not necessarily bad USFM markup, some languages require it) at the
		// end of the (reversed)substring -- we'll collect it & retain it if present
		if (!puncts.IsEmpty())
		{
			secondFollPuncts = MakeReverse(puncts); // normal order
			punctsLen2 = secondFollPuncts.Len();
			puncts.Empty(); // in case we reuse it for a subsequent inline binding endmarker
			pStartHere = pStartHere + punctsLen2; // advance starting location
		}
	}
	// now, however many (reversed) inline binding endmarkers were found to be present --
	// since any such are reversed, and because there are no inline markers in the PNG
	// 1998 SFM marker set, we know that asterisk * must be the first character
	// encountered if a marker is present...
	// since we parse backwards we could use the version of ParseMarker() that is in
	// helpers.cpp, in a loop, because it checks for initial * and so can find reversed
	// USFM endmarkers, however the easiest way is to assume that the nEndMkrsCount value
	// passed in is correct, and just use FindFromPos() in a loop - searching for a
	// backslash on each iteration. Until the latter proves to be non-robust, that will
	// suffice
	// Note: we know that the marker or markers to be parsed next are all inline
	// binding endmarkers - that was verified in the prior call of
	// FindParseHaltLocation() which did the requisite test and set nEndMkrsCount
	p = pStartHere;

	// it's possible that changed punctuation resulted in a word-final character moving to
	// be in m_follPunct; this is benign except when there was also an inline binding
	// endmarker present - because Adapt It will restore the character to after the inline
	// marker, thinking it is to remain as punctuation, and if it is now no longer in the
	// punctuation set being used, then it needs to be stored for the caller to process it,
	// and the parsing point set to follow it before further parsing takes place. Test and
	// do that now. There could be more than one.
	wxString nowWordBuilding; nowWordBuilding.Empty();
	//bool bStoredSome = FALSE; // set but unused
	if (nEndMkrsCount > 0 && *p != _T('*') && punctSet.Find(*p) == wxNOT_FOUND)
	{
		while (*p != _T('*') && punctSet.Find(*p) == wxNOT_FOUND)
		{
			//bStoredSome = TRUE;
			nowWordBuilding += *p;
			p++;
			pStartHere = p;
		}
	}
	// any additional puncts which are between where p points and the * of the reversed
	// marker have to be taken to the end of the word - this will "bury" any such as
	// word-internal punctuation -- this is the cost we pay for refusing to generate a
	// pair of CSourcePhrase instances from a single instance when the user changes
	// punctuation settings - otherwise, we get potential messes, and this 'solution' is
	// the best compromise.
	// To generate data to illustrate this, a sequence like \k extreme\k* is useful,
	// make m and e become punctuation characters, then unmake e as a punctuation
	// (returning it to word-building status) -- when the reverse parse comes to the eme
	// 3-char sequence, the first e goes to the end of the word, but m continuing as
	// punctuation blocks the loop above, leaving 2-char sequence, me, before the * of the
	// reversed \k* endmarker. If we don't also move that "me" sequence to the end of the
	// word, the wxASSERT below would trip, and that "m" character would cause the
	// generation, of a second CSourcePhrase, and a rather unhelpful mess at that point in
	// the document. We have to get p pointing at * before we continue the parse.
	if (!nowWordBuilding.IsEmpty() && *p != _T('*'))
	{
		// grab and append the rest
		while (*p != _T('*'))
		{
			nowWordBuilding += *p;
			p++;
		}
	}
	if (!nowWordBuilding.IsEmpty())
	{
		wordBuildersForPostWordLoc = MakeReverse(nowWordBuilding); // return these to
				// IsFixedSpaceAhead() which in turn will return these to ParseWord() where,
				// if the string is not empty, they'll be appended to the word; ptr will
				// get updated in IsFixedSpaceAhead() I think, as probably will the len
				// value, if this function was called from there, else in
				// FinishOffConjoinedWordsParse() if called from the latter
	}
	// p should now be pointing at an * if nEndMkrsCount is not zero
#ifdef _DEBUG
	if (nEndMkrsCount > 0)
	{
		wxASSERT(*p == _T('*'));
	}
#endif
	if (nEndMkrsCount > 0)
	{
		int lastPos = 0;
		wxString aReversedSpan(p, pEnd);
		int index;
		for (index = 0; index < nEndMkrsCount; index++)
		{
			// use the helpers.cpp function: int FindFromPos(const wxString& inputStr,
			// const wxString& subStr, int startAtPos), it allows us to find several
			// instances of a substring within the string
			lastPos = FindFromPos(aReversedSpan, _T("\\"), lastPos);
			lastPos++; // include the backslash marker
		}
		wxString theBindingEndMarkers(p, p + lastPos);
		bindingEndMkrsLen = theBindingEndMarkers.Len();
		inlineBindingEndMarkers = MakeReverse(theBindingEndMarkers); // normal order
		pStartHere = p + bindingEndMkrsLen; // advance starting location
	}
	// next, any pre-marker punctuation characters in the unreversed string -- we'll put
	// them in firstFollPuncts string whether of not nEndMkrsCount is zero (because if
	// there was no inline binding endmarker just parsed, we'd have already collected all
	// the punctuation characters which follow the word; so any collected now must not have
	// been collected because of an intervening inline binding endmarker; but skip this
	// step if there are no punctuation characters defined
	p = pStartHere;
	if (bPunctSetNonEmpty)
	{
		// allow \n and \r to be parsed over too (ie. whitespace, not just space),
		// space character is already in punctSet, so no need to add an explicit test
		while (p < pEnd)
		{
			if (punctSet.Find(*p) != wxNOT_FOUND || *p == _T('\n') || *p == _T('\r'))
				puncts += *p++;
			else
				break;
		}
		// add the puncts to firstFollPuncts, if any were found -- note, there could be a
		// space (it's not necessarily bad USFM markup, some languages require it) at the
		// end of the (reversed)substring -- we'll collect it & retain it if present
		if (!puncts.IsEmpty())
		{
			firstFollPuncts = MakeReverse(puncts); // normal order
			punctsLen1 = firstFollPuncts.Len();
			puncts.Empty();
			pStartHere = pStartHere + punctsLen1; // advance starting location
		}
	}


	// finally, what remains is the word proper (it could have embedded punctuation
	// 'invisible' to our parsing algorithms - it's invisible provided it has a
	// non-punctuation character both before and after it)
	p = pStartHere;
	wxString theReversedWord(p, pEnd);
	wordProper = MakeReverse(theReversedWord);

#ifdef _DEBUG
	int wordLen = wordProper.Len();
	int storedRevertedPunctsLen = wordBuildersForPostWordLoc.Len();
	wxASSERT(bindingEndMkrsLen + wordLen + punctsLen1 + punctsLen2 +
		ignoredWhitespaceLen + storedRevertedPunctsLen == length);
#endif
}


//////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if ~ conjoins the word and the next, FALSE if there is no such
///             conjoining
/// \param		ptr			    <-> ref to the pointer to the next character to be parsed
///                                (it will be the first character of word about to be
///                                parsed)
/// \param      pEnd            -> pointer to first char past the end of the buffer
///                                (to ensure we don't overrun buffer end)
/// \param		pWdStart	    <- ptr value when function is just entered
/// \param	    pWdEnd          <- points at the first character past the last character
///                                of the first word parsed over
/// \param	    punctBefore     <- any punctuation (it can have space within, provided
///                                that it does not end with a space) which follows
///                                the word (*** this should always be empty, because the
///                                caller has already parsed over initial punctuation, and
///                                so this member never gets filled) -- remove later on ***
/// \param      endMkr          <- any inline binding endmarker, if present
/// \param      spacelessPuncts -> the (spaceless) punctuation set to be used herein
/// \remarks
/// Called from: ParseWord()
/// ******************************************************** NOTE *********************
/// NOTE: (this is now different, see next paragraph!) our parsing algorithms for scanning
/// words which are conjoined by ~ assumes that there is no punctuation within the word
/// proper - so xyz:abc would NOT be parsed as a single word; our general parser,
/// ParseWord() DOES handle this type of thing as a single word, but for word1~word2 type
/// of conjoining, word1 and word2 must have no internal punctuation. For the moment, we
/// feel this is a satisfactory simplification, because use of ~ in actual data is rare (no
/// known instances in a decade of Adapt It use), and so too is the use of punctuation as a
/// word-building character.
///
/// BEW 25Jan11: ***BIGGER NOTE**** I've left the above NOTE here, at the time it seemed a
/// reasonable simplification. But user's dynamic changes to punctuation settings proved
/// it be it's archilles heel. The early code used ScanExcluding() to parse over the word
/// proper, and if there is embedded punctuation (as there might be if a file is loaded
/// while inadequate punctuation settings were in effect), then the internal punctuation
/// can become visible to such a scan - and cause a disastrous result. The correct way to
/// handle scanning a word is to honour the fact that there may be internal punctuation
/// which must remain "unseen" by any scanning process - the way to do that is to scan
/// inward over punctuation from the start of the word, until a non-punct is reached, and
/// for scanning at the end of the word, reverse the word and scan inwards in the reversed
/// string until a non-punct is reached, and then undo the reversals. So to do these scans,
/// ScanIncluding() is to be used from either end, WE MUST NOT SCAN ACROSS THE WORD ITSELF
/// LOOKING FOR PUNCTUATION AT THE OTHER END OF IT. Instead, scan in from either end. That
/// gives us the problem of determining where the "other end" is before we can do the
/// reversal of what lies between and then do the scan in. If there is a ~ fixed space, we
/// can use that as defining the other end. But if there is no fixed space (~) present, we
/// have to define the other end as whitespace or a backslash (ie. ignore punctuation for
/// determining where the other end is). In support of these observations the code will be
/// re-written below.
/// ******************************************************** END NOTE *****************
/// When the scanning ptr points at a word, we don't know whether the word will be a
/// singleton, or the first word of a pair conjoined by USFM ~ fixed space marker. We
/// support punctuation and inline binding markers before or after ~ too, so these
/// substrings may be present. The caller needs to know if it has to handle the word about
/// to be parsed as a conjoined pair, or not. To find this out, we first try to find if ~
/// is present. If it is, that's the dividing point between a conjoined pair (and we return
/// TRUE eventually). If there is no such character (we return FALSE eventually), it's not
/// a conjoined pair and the end of the word will be determined by scanning back from later
/// whitespace or a later marker. A ] character also is considered as an end point for the
/// word. We pass in references to the start and end locations for the word, etc, so that
/// the useful info we learn as we parse does not have to be reparsed in the caller. If
/// TRUE is returned, another function in the caller will be called in order to complete
/// the delimitation of the conjoined word pair, as far as the final character of the
/// second word. The ptr value returned must be, if ~ was detected, following the character
/// ~. If FALSE is returned, we've a normal word parsing, and the caller will only use the
/// pWdEnd value - resetting the caller's ptr variable to that location, since the caller
/// can successfully parse on from that point (this would mean throwing information away
/// about following punctuation, but that is a small matter because the latter is low
/// frequency in the text, and the caller will reparse that information quickly anyway).
/// BEW created 11Oct10, to support the improved USFM parser build into doc version 5
/// BEW 24Oct14 no changes needed for support of USFM nested markers
//////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsFixedSpaceAhead(wxChar*& ptr, wxChar* pEnd, wxChar*& pWdStart,
	wxChar*& pWdEnd, wxString& punctBefore, wxString& endMkr,
	wxString& wordBuildersForPostWordLoc, wxString& spacelessPuncts,
	bool bTokenizingTargetText)
{
	wxUnusedVar(bTokenizingTargetText); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(spacelessPuncts); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(wordBuildersForPostWordLoc); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(endMkr); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(punctBefore); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(pWdEnd); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(pWdStart); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(pEnd); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(ptr); // avoid compiler warning unreferenced formal parameter

	/* BEW 17Jul23 we no longer call this
	wxChar* pSave = ptr; // BEW 30Sep22, because despite what the comment just
			// below says, I didn't scan with p, but fiddled with ptr. I want 
			// pSave so that if no ~ is found, I can return ptr as the pSave value
	wxChar* p = ptr; // scan with p, so that we can return a ptr value which is at
					 // the place we want the caller to pick up from (and that will
					 // be determined by what we find herein)
	wxString FixedSpace = _T("~");
	punctBefore.Empty();
	endMkr.Empty();
	pWdStart = ptr;

	// Find where ~ is, if present; we can't just call .Find() in the string defined by
	// ptr and pEnd, because it could contain thousands of words and a ~ may be many
	// hundreds of words ahead. Instead, we must scan ahead, parsing over any ignorable
	// white space, until we come to either ~, or non-ignorable whitespace, or a closing
	// bracket (]) - halting immediately before any such character. We need a function for
	// this and it can return, via its signature, what the specific halt condition was. If
	// we halt due to ] or whitespace, then we infer that we do not have conjoining of the
	// word being defined from the parse. We also may parse over an inline binding
	// endmarker, (perhaps more than one), these don't halt parsing - but we'll return the
	// info in the signature, along with a count of how many such markers we parsed over.
	wxChar* pHaltLoc = NULL;
	bool bFixedSpaceIsAhead = FALSE;
	bool bFoundInlineBindingEndMarker = FALSE;
	bool bFoundFixedSpaceMarker = FALSE;
	bool bFoundClosingBracket = FALSE;
	bool bFoundHaltingWhitespace = FALSE;
	int nFixedSpaceOffset = -1;
	int nEndMarkerCount = 0;
	pHaltLoc = FindParseHaltLocation(p, pEnd, &bFoundInlineBindingEndMarker,
		&bFoundFixedSpaceMarker, &bFoundClosingBracket,
		&bFoundHaltingWhitespace, nFixedSpaceOffset, nEndMarkerCount,
		bTokenizingTargetText);
	bFixedSpaceIsAhead = bFoundFixedSpaceMarker;
	// BEW 11Feb14, test for ~ found, but it is followed by whitespace or buffer end or
	// closing ] character.
	// BEW 3Oct22, this next test and it's TRUE block should not be here. We advance over ~ just before
	// the else block below. Until then don't advance, so that ~ does not get included in the aSpan calculation
	//if (bFixedSpaceIsAhead && (bFoundFixedSpaceMarker || bFoundHaltingWhitespace || bFoundClosingBracket))
	//{
	//	// pHaltLoc will have been returned as pointing at the ~ character, so advance
	//	// pHaltLoc to point past it, and then reset bFixedSpaceIsAhead to FALSE
	//	pHaltLoc += 1;
	//	bFixedSpaceIsAhead = FALSE;
	//}
	wxString aSpan(ptr, pHaltLoc); // this could be up to ~, or a [ or ], or a whitespace

	// we know whether or not we found a USFM fixedspace marker, what we do next depends
	// on whether we did or not
	wxString wordProper; // emptied at start of ParseSpanBackwards() call below
	wxString firstFollPuncts; // ditto
	wxString inlineBindingEndMarkers; // ditto
	wxString secondFollPuncts; // ditto
	wxString ignoredWhiteSpaces; // ditto
	// if ptr is already at pEnd (perhaps punctuation changes made a short word into all
	// puncts), then no point in calling ParseSpanBackwards() and generating a message
	// about an empty span, instead code to jump the call
	if (!aSpan.IsEmpty())
	{
		ParseSpanBackwards(aSpan, wordProper, firstFollPuncts, nEndMarkerCount,
			inlineBindingEndMarkers, secondFollPuncts,
			ignoredWhiteSpaces, wordBuildersForPostWordLoc,
			spacelessPuncts);
	}
	else
	{
		wordProper.Empty();
		firstFollPuncts.Empty();
		nEndMarkerCount = 0;
		secondFollPuncts.Empty();
		ignoredWhiteSpaces.Empty();
		wordBuildersForPostWordLoc.Empty();
		inlineBindingEndMarkers.Empty();
		pWdEnd = NULL;
	}
	// now use the info extracted to set the IsFixedSpaceAhead() param values ready
	// for returning to ParseWord()
	if (bFixedSpaceIsAhead)
	{
		// now use the info extracted to set the IsFixedSpaceAhead() param values ready
		// for returning to ParseWord()

		// first, pWdEnd -- this will be the length of wordProper after pWdStart
		pWdEnd = pWdStart + wordProper.Len();

		// second, punctuation which follows the word but precedes the fixed space; if
		// there is correct markup and there is an inline binding endmarker, it would all be
		// after that marker (or markers, if there is more than one here), but user markup
		// errors might have some or all before such a marker - if so, we move the
		// before-marker puncts to be immediately after the endmarker(s) and append
		// whatever is already after the endmarkers. We won't remove any initial whitespace
		// before the puncts, as that would be inappropriate -- some languages'
		// punctuation conventions are to have a space between the word and preceding or
		// following punctuation - so if there is space there, we must retain it
		if (nEndMarkerCount == 0)
		{
			// all the punctuation is together in secondFollPuncts, if there is any at all
			if (secondFollPuncts.IsEmpty())
			{
				punctBefore.Empty();
			}
			else
			{
				punctBefore = secondFollPuncts;
			}
		}
		else
		{
			// handle any out-of-place puncts (will be in firstFollPuncts if there is any)
			// first, and then append any which follows the inline binding endmarker() to it
			if (firstFollPuncts.IsEmpty())
			{
				punctBefore.Empty();
			}
			else
			{
				punctBefore = firstFollPuncts;
			}
			if (!secondFollPuncts.IsEmpty())
			{
				punctBefore += secondFollPuncts;
			}
		}

		// third, the contents for endMkr; there could be space(s) in the string, and
		// they should be removed as they contribute nothing except to make things more
		// complicated than is necessary for rendering the markup for publishing, so we
		// remove them
		endMkr.Empty();
		if (!inlineBindingEndMarkers.IsEmpty())
		{
			while (inlineBindingEndMarkers.Find(_T(' ')) != wxNOT_FOUND)
			{
				// remove all spaces, leaving only the one or more inline binding endmarkers
				inlineBindingEndMarkers.Remove(inlineBindingEndMarkers.Find(_T(' ')), 1);
			}
			endMkr = inlineBindingEndMarkers;
		}

		// last, since ~ is not in aSpan but immediately after it, set ptr to point past
		// the ~ fixedspace character
		ptr = ptr + nFixedSpaceOffset + 1;
	} // end of TRUE block for test: if (bFixedSpaceIsAhead)
	else
	{
		// BEW 30Sep22, no ~ means no ptr advancement, and all the above wxStrings emptied
		// at lines 12001-7. So if ptr is not to be advance, set ptr to pSave which I added
		// above. And pWdEnd should be set to NULL.
		ptr = pSave;
		pWdEnd = NULL;
		return FALSE; // tell the caller that no fixedspace was encountered
	} // end of else block for test: if (bFixedSpaceIsAhead)
	*/
	return FALSE; // was TRUE;
}

//////////////////////////////////////////////////////////////////////////////////
/// \return		                   nothing
/// \param		ptr			   <-> ref to the pointer to the next character to be parsed
///                                (it will be the first character after ~ character pair)
/// \param      pEnd            -> pointer to first char past the end of the buffer
///                                (to ensure we don't overrun buffer end)
/// \param		pWord2Start	    <- points at where 2nd of conjoined words starts (actual word)
/// \param	    pWord2End       <- points at the first character past the last character
///                                of the second of the conjoined words parsed over
/// \param	    punctAfter      <- any punctuation (it can have space within, provided
///                                that it does not end with a space) which follows ~ and
///                                precedes the second (conjoined) word
/// \param      bindingMkr      <- any inline binding beginmarker, if present
/// \remarks
/// Called from: ParseWord()
/// ******************************************************** NOTE *********************
/// NOTE: our parsing algorithms for scanning words which are conjoined by ~ assumes that
/// there is no punctuation within the word proper - so xyz:abc would NOT be parsed as a
/// single word; our general parser, ParseWord() DOES handle this type of thing as a single
/// word, but for word1~word2 type of conjoining, word1 and word2 must have no internal
/// punctuation. For the moment, we feel this is a satisfactory simplification, because
/// use of ~ in actual data is rare (no known instances in a decade of Adapt It use), and
/// so too is the use of punctuation as a word-building character.
/// ******************************************************** END NOTE *****************
/// On input, we know we have a USFM ~ marker conjoining two words (the words may have
/// punctuation before or after and inline binding marker and endmarker wrapping too), and
/// this function does the parsing from the character following ~ to the end of the
/// second word proper - but it does NOT attempt to parse into any following punctuation
/// or binding endmarker which may follow the second word - the caller will do that. When
/// ready to return, ptr must be set to point at whatever character following the end of
/// the second word. If the completion of the parse encounters any or all of, in the
/// following order, preceding punctuation before the second word (it may legally contain
/// space, eg. between nested quote symbols), or an inline binding beginmarker, these are
/// stored in the relevant strings in the signature to return their values to the caller.
/// The caller then has to use the returned ptr value to work out how many characters were
/// parsed over, update the callers len (length) value, and then parse on over anything
/// which may lie beyond the end of the second word (such as final punctuation, etc).
/// BEW created 11Oct10, to support the improved USFM parser build into doc version 5
/// BEW refactored 28Jan11, to parse 'inwards' from the ends, rather than across the word
/// BEW 2Feb11, added 4 more strings to signature, to return punctuation pulled off ends
/// of the word due to word-building status becoming punctuation status (2 of them), or to
/// return word-building characters to be added to ends of the word due to punctuation
/// status becoming changed to word-building status (because user used Preferences
/// Punctuation tab to dynamically change the punctuation settings)
/// BEW 24Oct14, no changes for support of USFM nested markers. (But bTokenizingTargetText
/// needed to be added to signature because the call FindMarseHaltLocation() had a hard-
/// coded tgt punctuation string within it, which needed to be set to be src or target
/// depending on what was passed to TokenizeText() - this produced a small cascade of
/// signature changes in a few functions, since FindMarseHaltLocation() as used in
/// various places - but at least now TokenizeText() uses either src or tgt puncts
/// throughout, and consistently one or the other, depending on bTokenizingTargetText
//////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::FinishOffConjoinedWordsParse(wxChar*& ptr, wxChar* pEnd, wxChar*& pWord2Start,
	wxChar*& pWord2End, wxString& punctAfter, wxString& bindingMkr,
	wxString& newPunctFrom2ndPreWordLoc, wxString& newPunctFrom2ndPostWordLoc,
	wxString& wordBuildersFor2ndPreWordLoc, wxString& wordBuildersFor2ndPostWordLoc,
	wxString& spacelessPuncts, bool bTokenizingTargetText)
{
	wxUnusedVar(bTokenizingTargetText); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(spacelessPuncts); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(wordBuildersFor2ndPostWordLoc); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(wordBuildersFor2ndPreWordLoc); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(newPunctFrom2ndPostWordLoc); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(newPunctFrom2ndPreWordLoc); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(bindingMkr); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(punctAfter); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(pWord2End); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(pWord2Start); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(pEnd); // avoid compiler warning unreferenced formal parameter
	wxUnusedVar(ptr); // avoid compiler warning unreferenced formal parameter

	/* BEW 17Jul23 we not longer support the legacy way of fixed space processing
	// Note: the punctAfter param is "punctuation after the ~ fixedspace, which, since
	// this function is only used to parse the second of two conjoined words, is also the
	// preceding punctuation for the second of the two words (it is NOT the *'punctuation
	// after the second word' - the latter will be determined in the caller, ParseWord())
	wxChar* p = ptr;
	punctAfter.Empty();
	bindingMkr.Empty();
	pWord2Start = NULL;
	pWord2End = NULL;
	int length = 0;
	// this two for punctuation returning to word-building status
	wordBuildersFor2ndPreWordLoc.Empty();
	wordBuildersFor2ndPostWordLoc.Empty();
	// this two for word-building characters becoming punctuation characters
	newPunctFrom2ndPreWordLoc.Empty();
	newPunctFrom2ndPostWordLoc.Empty();
	// the FinishOffConjoinedWordsParse() needs all 4, of these, but for the first word or
	// a conjoined pair, or the only word when parsing a word not conjoined, the
	// equivalent tweaks and storage is scattered over several functions - in ParseWord(),
	// in IsFixedSpaceAhead() and in ParseSpanBackwards().

	// we need a punctuation string which includes space
	wxString punctuation = spacelessPuncts + _T(' ');
	if (p < pEnd)
	{
		// check out the possibility of word-initial punctuation preceding word2's
		// characters, and beware there may be detached opening quote, and so we can't
		// assume there won't be a space within the punctuation string (if there is a
		// punctuation string, that is)
		punctAfter = SpanIncluding(p, pEnd, punctuation);
		length = punctAfter.Len();
		if (length > 0)
		{
			p = p + length;
		}
		// we've stopped because either we have come to a beginmarker, or to the
		// second word of the conjoined pair, or to the end of the buffer, or to a former
		// punctuation character which has just become a word-building one, and so is not
		// in the punctuation set
		if (p >= pEnd)
		{
			// this would be totally unexpected, all we can do is set the pointers to the
			// end and start of the second word to point where pEnd points, and return
			pWord2Start = p;
			pWord2End = p;
			ptr = p;
			return;
		}
		else
		{
			// there's more, so check out what is next - could be the start of the word,
			// or an inline binding beginmarker (could even be a sequence of these)
			// BEW 28Jan11, changed to using IsMarker() because it tests for \ followed by
			// a single alphabetic character, and so we don't have \ followed by space
			// giving a false positive
			// BEW 3Feb11, *p might be a punctuation character made into a word-building
			// one by the user just having altered the punctuation settings -- so if
			// inline marker(s) follow, such a character will need to end up at the start of the
			// word -- that is, jump the marker. We have a function for handling this
			// check etc.
			wordBuildersFor2ndPreWordLoc = SquirrelAwayMovedFormerPuncts(p, pEnd, spacelessPuncts);
			if (!wordBuildersFor2ndPreWordLoc.IsEmpty())
			{
				// advance pointer p, to point beyond the one or more puncts which are now
				// word-building and needing to be moved later on to start of the word proper
				size_t numChars = wordBuildersFor2ndPreWordLoc.Len();
				p += numChars;
			}

			// when we get here, p must be pointing at the marker if it is present, or at
			// the word proper if no marker is present
			bindingMkr.Empty();
			while (IsMarker(p))
			{
				wxString aBindingMkr = GetWholeMarker(p);
				length = aBindingMkr.Len();
				wxString mkrPlusSpace = aBindingMkr + _T(' ');
				if (gpApp->m_inlineBindingMarkers.Find(mkrPlusSpace) != wxNOT_FOUND)
				{
					// it is a beginmarker of the inline binding type (what USFM calls
					// 'Special Markers'), and so we need to deal with it - we store these
					// with their trailing space
					bindingMkr += mkrPlusSpace; // caller will store returned string(s) in
												// m_inlineBindingMarkers member
					p += length;
					length = ParseWhiteSpace(p); // get past the whitespace after the marker
												 // (it might not be a single character)
					p += length;
				}
				else
				{
					// the marker is not the expected inline binding beginmarker, this
					// constitutes a USFM markup error. We can't process it as if it were
					// a binding marker, because it may be a marker preceding the next
					// word in the data and not conjoined, so we'll just return what we have
					// and put ptr back preceding any punctuation we may have found -- and
					// since we've not changed ptr yet, all we need do is return
					return;
				}
			} // end of loop for test: while (IsMarker(p))

			// We are potentially at the start of word2; the user may have changed
			// punctuation settings in such a way that one or more characters at the start
			// of the word have just become punctuation characters - we have to store these
			// in a string to return them to the caller (where they will be added to the
			// m_precPunct member of secondWord after any other puncts already in there) --
			// note that doing this means that if the source text is reconstituted, any
			// such puncts would move to being immediately preceding an inline binding
			// marker(s) if one or more of the latter precede the word). We must check
			// here for any such and remove them to the passed in storage string, and
			// advance our parsing pointer, p, to point beyond them ready to setting
			// pWord2Start further below.
			while (spacelessPuncts.Find(*p) != wxNOT_FOUND)
			{
				// *p is a punctuation character now, so store it and advance p
				newPunctFrom2ndPreWordLoc += *p++;
			}

			// we are at the start of word2, we can't scan over it using SpanExcluding()
			// because if there is embedded punctuation, it would foul the integrity of
			// the parse; so use FindParseHaltLocation() and ParseSpanBackwards() as the
			// IsFixedSpaceAhead() function does - this combination adhere's to our
			// word-parsing protocol, which is to parse inwards from either end, never
			// across it
			pWord2Start = p;
			ptr = p;

			// Find a halting location which is beyond the currently to-be-parsed word, but
			// not past the start of information which belongs to the following of what
			// could be thousands of words. Instead, we must scan ahead, parsing over any
			// ignorable white space, until we come to either ~, or non-ignorable
			// whitespace, or a closing bracket (]) - halting immediately before any such
			// character. We need a function for this and it can return, via its signature,
			// what the specific halt condition was. We also may parse over an inline
			// binding endmarker, (perhaps more than one), these don't halt parsing - but
			// we'll return the info in the signature, along with a count of how many such
			// markers we parsed over. We don't use much of what we find, just the
			// wordProper, because we let the caller handle everything to be parsed from
			// the end of the wordProper onwards
			wxChar* pHaltLoc = NULL;
			bool bFoundInlineBindingEndMarker = FALSE;
			bool bFoundFixedSpaceMarker = FALSE;
			bool bFoundClosingBracket = FALSE;
			bool bFoundHaltingWhitespace = FALSE;
			int nFixedSpaceOffset = -1;
			int nEndMarkerCount = 0;
			pHaltLoc = FindParseHaltLocation(p, pEnd, &bFoundInlineBindingEndMarker,
				&bFoundFixedSpaceMarker, &bFoundClosingBracket,
				&bFoundHaltingWhitespace, nFixedSpaceOffset, nEndMarkerCount,
				bTokenizingTargetText);
			wxString aSpan(ptr, pHaltLoc); // this could be up to a [ or ], or a
										  // whitespace or a beginmarker
			// now parse backwards to extract the span's info
			wxString wordProper; // emptied at start of ParseSpanBackwards() call below
			wxString firstFollPuncts; // ditto
			wxString inlineBindingEndMarkers; // ditto
			wxString secondFollPuncts; // ditto
			wxString ignoredWhiteSpaces; // ditto
			ParseSpanBackwards(aSpan, wordProper, firstFollPuncts, nEndMarkerCount,
				inlineBindingEndMarkers, secondFollPuncts, ignoredWhiteSpaces,
				wordBuildersFor2ndPostWordLoc, spacelessPuncts);
			// now use the info extracted to set the FinishedOffConjoinedWordsParse() param
			// values ready for returning to ParseWord() -- all we want is wordProper --
			// note, if there is one or more now-word-building-characters in the
			// wordBuildersFor2ndPostWordLoc string, they are passed back to the caller
			// via the signature and will be appended to secondWord there, and the
			// caller's ptr value incremented by however many there are (we don't do it
			// here because it would return a wrong location for ptr and pWord2End to the
			// caller)
			newPunctFrom2ndPostWordLoc = firstFollPuncts; // new puncts pulled of end of word
			length = wordProper.Len();
			pWord2End = ptr + length;
			ptr = pWord2End;
		} // end of else block for test: if (p >= pEnd)
	} // end of TRUE block for test: if (p < pEnd)
	*/
}

///////////////////////////////////////////////////////////////////////////////
/// \return		the number of characters parsed over
/// \param  ptr            -> pointer to the next wxChar to be parsed (it should
///                           point at the starting character of the word proper,
///                           and after preceding punctuation for that word (if any)
/// \param  pEnd		   -> a pointer to the first character beyond the input
///                           buffer's end (could be tens of kB ahead of ptr)
///                           marker, or an inline binding marker)
/// \param	pbFoundInlineBindingEndMarker   <- ptr to boolean, its name explains it; there
///                                    might be two or more in sequence, so a count of how
///                                    many of these there are is return in nEndMarkerCount
/// \param	pbFoundInlineNonbindingEndMarker <- ptr to boolean, its name explains it; these
///                                    are rare and only one will be at any one CSourcePhrase
/// \param	pbFoundFixedSpaceMarker <- ptr to boolean, TRUE if ~ encountered at or before
///                                    the halting location (~ IS the halting location
///                                    provided it precedes non-ignorable whitespace)
/// \param	pbFoundBracket          <- ptr to boolean, TRUE if ] or [ encountered (either
///                                    halts the scan, if it precedes ~ or whitespace)
/// \param  pbFoundHaltingWhitespace <- ptr to bool, TRUE if space or \n or \r encountered
///                                    and that whitespace is not ignorable (see comments
///                                    below for a definition of what is ignorable whitespace)
/// \remarks
/// Called from: the Doc's IsFixedSpaceAhead(), from TokenizeText(), from
/// FinishOffConjoinedWordsParse(), and from ParseWordInwardsFromEnd()
/// The IsFixedSpaceAhead() function, which is mission critical for delimiting a parsed
/// word or conjoined pair of words in the ParseWord() function, requires a smart subparser
/// which looks ahead for a fixed space marker (~), but only looks ahead a certain distance
/// - ensuring the parsing pointer does not encroach into material which belongs to any of
/// the words which follow. This is that subparser. In doing it's job, it may parse over
/// whitespace which is ignorable, and possibly one or more inline binding endmarkers.
/// The halting conditions are:
/// a) finding non-ignorable whitespace
/// b) finding ~ (the fixed space marker of USFM)
/// c) finding a closing bracket, ] or an opening bracket [
/// d) finding a begin-marker, or an endmarker which is not an inline binding one
/// We return, via the signature, information about the data types parsed over, to help
/// the caller to do it's more definitive parsing and data storage more easily.
/// The following conditions define ignorable whitespace for the scanning process:
/// i)  immediately after an inline binding endmarker - provided what follows the whitespace
///     is either ] or ~ or another inline binding endmarker or punctuation which is a
///     closing quote or closing doublequote
/// ii) between non-punctuation and an immediately following inline binding endmarker
/// iii)after punctuation, provided a closing quote or closing doublequote follows
/// No punctuation set is passed in, because this function deliberately does not
/// distinguish between punctuation and word-building characters -- halt location is
/// determined solely by ~ or [ or ] or certain SF markers.
/// BEW 11Oct10, (actually created 25Jan11)
/// BEW 4Jan2012, altered FindParseHaltLocation() so that it does not halt at a ] (closing
/// bracket) when ] is not included in the list of punctuation characters. (Data which
/// revealed the problem: adapt a word with the adaptation "voice [lit:neck]"  -- the ParseWord()
/// function hung at the [ character.)
/// BEW 24Oct14, no changes needed to support USFM nested markers (internally uses
/// marker fast access strings, and the inlineBinding and nonBinding ones have
/// nested markers within them explicitly as of 24Oct14)
/// BEW 24Oct14 no changes needed for support of USFM nested markers
//////////////////////////////////////////////////////////////////////////////////
wxChar* CAdapt_ItDoc::FindParseHaltLocation(wxChar* ptr, wxChar* pEnd,
	bool* pbFoundInlineBindingEndMarker,
	bool* pbFoundFixedSpaceMarker,
	bool* pbFoundClosingBracket,
	bool* pbFoundHaltingWhitespace,
	int& nFixedSpaceOffset,
	int& nEndMarkerCount,
	bool bTokenizingTargetText)
{
	wxChar* p = ptr; // scan with p
	wxChar* pHaltLoc = ptr; // initialize to the start of the word proper
	enum SfmSet whichSFMSet = gpApp->gCurrentSfmSet;
	wxChar fixedSpaceChar = _T('~');
	// intialize return parameters
	*pbFoundInlineBindingEndMarker = FALSE;
	*pbFoundFixedSpaceMarker = FALSE;
	*pbFoundClosingBracket = FALSE;
	*pbFoundHaltingWhitespace = FALSE;
	nFixedSpaceOffset = -1;
	nEndMarkerCount = 0;
	wxString lastEndMarker; lastEndMarker.Empty();
	wxString puncts;
	if (bTokenizingTargetText)
	{
		puncts = gpApp->m_punctuation[1];
	}
	else
	{
		puncts = gpApp->m_punctuation[0];
	}
	int offsetToEndOfLastBindingEndMkr = -1;
	// scan ahead, looking for the halt location prior to a following word or
	// end-of-buffer
	while (p < pEnd)
	{
		// the test
		// BEW 2Mar15, refactored because we store ] on m_follPunct if it is punctuation, but
		// instead on m_key & m_srcPhrase if word-building, and there is no need to call
		// IsClosingBracketWordBuilding() here, it instead needs to be called in TokenizeText()
		// where the storage decision will be made on the next iteration of that function's
		// parsing loop. Here we unilaterally halt parsing when ] is reached
		if (!IsMarker(p) && !IsWhiteSpace(p) && !IsFixedSpace(p) && (*p != _T(']')))
		{
			// if none of those, then it's part of the word, or part of punctuation which
			// follows it, so keep scanning
			p++;
		}
		else
		{
			// it's one of those - handle each possibility appropriately
			if (*p == fixedSpaceChar)
			{
				nFixedSpaceOffset = (int)(p - ptr);
				*pbFoundFixedSpaceMarker = TRUE;
				// BEW added 11Feb14, the comment in IsFixedSpaceAhead() which immediately
				// precedes the call of this FindParseHaltLocation() function has not been
				// implemented correctly. Without the addition which follows here, control
				// would break from the loop now, and *pbFoundHaltingWhitespace = TRUE; would
				// not be set if a halting space followed the ~ character [that wouldn't be
				// correct USFM markup, but someone has marked up their text in just that
				// way!] and got a parser crash as a consequence], hence this fix. So test
				// for whitespace following the tilde, or buffer end. Also test for ]
				// following the tilde - that too is a halting condition
				if (!(p + 1 < pEnd) || IsWhiteSpace(p + 1))
				{
					*pbFoundHaltingWhitespace = TRUE;
				}
				else if (*(p + 1) == _T(']'))
				{
					*pbFoundClosingBracket = TRUE;
				}
				break;
			}
			else if (*p == _T(']'))
			{
				*pbFoundClosingBracket = TRUE;
				break;
			}
			// if neither of the above, it must be one of the other conditions - try
			// endmarkers next; if it is one, and if it is an inline binding marker, we
			// note the fact and continue scanning; but other endmarkers halt scanning
			// (including the non-binding inline ones, like \wj*)
			if (IsMarker(p))
			{
				wxString wholeMkr = GetWholeMarker(p);
				int offset = wholeMkr.Find(_T('*'));
				if (whichSFMSet == PngOnly)
				{
					// this is a sufficient condition for determining that there is no ~
					// conjoining (endmarkers in this set are only \F or \fe - either is a
					// footnote end, and there would not be conjoining across that kind of
					// a boundary) and so we are at the end of a word for sure, so return
					break;
				}
				else // must be UsfmOnly or UsfmAndPng - we assume UsfmOnly
				{
					if (offset == wxNOT_FOUND)
					{
						//  there is no asterisk in the marker, so it is not an endmarker
						//  - it must then be a beginmarker, and they halt scanning
						break;
					}
					else
					{
						// it's an endmarker, but we parse over only those which are
						// inline binding ones, otherwise the marker halts scanning
						wxString beginMkr = wholeMkr;
						// BEW 24Oct14 no change needed here for support of USFM nested
						// markers, and likewise for the text .Find() just below
						beginMkr = beginMkr.Truncate(beginMkr.Len() - 1); // remove
											// the * (we are assuming the asterisk was at
											// the end where it should be)
						wxString mkrPlusSpace = beginMkr + _T(' '); // append a space
						int offset2 = gpApp->m_inlineBindingMarkers.Find(mkrPlusSpace);
						if (offset2 == wxNOT_FOUND)
						{
							// it's not one of the space-delimited markers in the fast access
							// string of inline binding beginmarkers, so it halts scanning
							break;
						}
						else
						{
							// it's an inline binding endmarker, so we scan over it and
							// let the caller handle it when parsing backwards to find the
							// end of the text part of the word just parsed over
							*pbFoundInlineBindingEndMarker = TRUE;
							lastEndMarker = wholeMkr;
							nEndMarkerCount++;
							unsigned int markerLen = wholeMkr.Len(); // use this to jump p forwards
							offsetToEndOfLastBindingEndMkr = (int)(p - ptr) + markerLen;
							p = p + markerLen;
						}
					}
				} // end of else block for test: if (whichSFMSet == PngOnly)
			} // end of TRUE block for test: if (IsMarker(p))
			else if (IsWhiteSpace(p))
			{
				// it's whitespace - some such can just be ignored, others constitute the
				// end of the word or word plus punctuation (and possibly binding
				// endmarker(s)) and so constitute grounds for halting - determine which
				// is the case
				// first, handle condition (i) in the remarks of the function description
				if (*pbFoundInlineBindingEndMarker == TRUE && p == (ptr + offsetToEndOfLastBindingEndMkr))
				{
					// The iterator, p, is pointing at a whitespace character immediately
					// following an inline binding marker just parsed over. This halts
					// scanning except when this whitespace (or several whitespace
					// characters) is followed by ~ or one of [ or ], or another inline
					// binding endmarker -- check these subconditions out, if one of them
					// is satisfied, then advance p to the ~ or [ or ] and halt there, but
					// if another inline binding endmarker follows, advance p to its start
					// and let the scanning loop continue
					int whitespaceSpan = ParseWhiteSpace(p);
					if (*(p + whitespaceSpan) == fixedSpaceChar)
					{
						// there is a fixedspace marker following, so return with p
						// pointing at it, etc
						p = p + whitespaceSpan;
						nFixedSpaceOffset = (int)(p - ptr);
						*pbFoundFixedSpaceMarker = TRUE;
						break;
					}
					else if (*(p + whitespaceSpan) == _T(']') || *(p + whitespaceSpan) == _T('['))
					{
						// there is an opening or closing bracket following the
						// whitespace(s), this halts scanning and also means there is no
						// conjoining (the whitespace is ignorable)
						p = p + whitespaceSpan;
						break;
					}
					else if (IsMarker(p + whitespaceSpan))
					{
						// it's a marker -- if it is an inline binding endmarker, then
						// jump over it, etc, and continue scanning, otherwise, it halts
						// scanning (and might as well halt at the space where p currently
						// is if that is the case)
						wxString wholeMkr = GetWholeMarker(p + whitespaceSpan);
						int offset = wholeMkr.Find(_T('*'));
						if (whichSFMSet == PngOnly)
						{
							// this is a sufficient condition for determining that there is no ~
							// conjoining (endmarkers in this set are only \F or \fe - either is a
							// footnote end, and there would not be conjoining across that kind of
							// a boundary) and so we are at the end of a word for sure, so return
							*pbFoundHaltingWhitespace = TRUE;
							break;
						}
						else // must be UsfmOnly or UsfmAndPng - we assume UsfmOnly
						{
							if (offset == wxNOT_FOUND)
							{
								//  there is no asterisk in the marker, so it is not an endmarker
								//  - it must then be a beginmarker, and they halt scanning
								*pbFoundHaltingWhitespace = TRUE;
								break;
							}
							else
							{
								// it's an endmarker, but we parse over only those which are
								// inline binding ones, otherwise the marker halts scanning
								// BEW 24Oct14 no change needed here for support of USFM nested
								// markers, and likewise for the text .Find() just below
								wxString beginMkr = wholeMkr.Truncate(wholeMkr.Len() - 1); // remove
													// the * (we are assuming the asterisk was at
													// the end where it should be)
								wxString mkrPlusSpace = beginMkr + _T(' '); // append a space
								int offset2 = gpApp->m_inlineBindingMarkers.Find(mkrPlusSpace);
								if (offset2 == wxNOT_FOUND)
								{
									// it's not one of the space-delimited markers in the fast access
									// string of inline binding beginmarkers, so it halts scanning
									*pbFoundHaltingWhitespace = TRUE;
									break;
								}
								else
								{
									// it's an inline binding endmarker, so we scan over it and
									// let the caller handle it when parsing backwards to find the
									// end of the text part of the word just parsed over,
									// continue iterating
									*pbFoundInlineBindingEndMarker = TRUE;
									nEndMarkerCount++;
									unsigned int markerLen = wholeMkr.Len(); // use this to jump p forwards
									p = p + whitespaceSpan; // point p at the start of the binding endmarker
									offsetToEndOfLastBindingEndMkr = (int)(p - ptr) + markerLen;
									p = p + markerLen;
								}
							}
						} // end of else block for test: if (whichSFMSet == PngOnly)
					} // end of TRUE block for test: else if (IsMarker(p + whitespaceSpan))
					else if (IsClosingCurlyQuote(p + whitespaceSpan))
					{
						// it's a closing curly quote, or a > chevron -- so scan over it &
						// continue
						p = p + whitespaceSpan;
					}
					else
					{
						// any other punctuation coming after a space or spaces should be
						// considered as opening punctuation for the following word, so
						// halt now
						*pbFoundHaltingWhitespace = TRUE;
						break;
					}

				} // end of TRUE block for test: if (*pbFoundInlineBindingEndMarker == TRUE &&
				  //                                 p == (ptr + offsetToEndOfLastBindingEndMkr))
				else
				{
					// subcondition (i) does not apply, so now test for subcondition (ii)
					// -- between something and a following inline binding endmarker
					int whitespaceSpan = ParseWhiteSpace(p);
					if (IsMarker(p + whitespaceSpan))
					{
						// it's a marker -- if it is an inline binding endmarker, then
						// jump over it, etc, and continue scanning, otherwise, it halts
						// scanning (and might as well halt at the space where p currently
						// is if that is the case)
						wxString wholeMkr = GetWholeMarker(p + whitespaceSpan);
						int offset = wholeMkr.Find(_T('*'));
						if (whichSFMSet == PngOnly)
						{
							// this is a sufficient condition for determining that there is no ~
							// conjoining (endmarkers in this set are only \F or \fe - either is a
							// footnote end, and there would not be conjoining across that kind of
							// a boundary) and so we are at the end of a word for sure, so return
							*pbFoundHaltingWhitespace = TRUE;
							break;
						}
						else // must be UsfmOnly or UsfmAndPng - we assume UsfmOnly
						{
							if (offset == wxNOT_FOUND)
							{
								//  there is no asterisk in the marker, so it is not an endmarker
								//  - it must then be a beginmarker, and they halt scanning
								*pbFoundHaltingWhitespace = TRUE;
								break;
							}
							else
							{
								// it's an endmarker, but we parse over only those which are
								// inline binding ones, otherwise the marker halts scanning
								// BEW 24Oct14 no change needed here for support of USFM nested
								// markers, and likewise for the text .Find() just below
								wxString beginMkr = wholeMkr.Truncate(wholeMkr.Len() - 1); // remove
													// the * (we are assuming the asterisk was at
													// the end where it should be)
								wxString mkrPlusSpace = beginMkr + _T(' '); // append a space
								int offset2 = gpApp->m_inlineBindingMarkers.Find(mkrPlusSpace);
								if (offset2 == wxNOT_FOUND)
								{
									// it's not one of the space-delimited markers in the fast access
									// string of inline binding beginmarkers, so it halts scanning
									*pbFoundHaltingWhitespace = TRUE;
									break;
								}
								else
								{
									// it's an inline binding endmarker, so we scan over it and
									// let the caller handle it when parsing backwards to find the
									// end of the text part of the word just parsed over,
									// continue iterating
									*pbFoundInlineBindingEndMarker = TRUE;
									nEndMarkerCount++;
									unsigned int markerLen = wholeMkr.Len(); // use this to jump p forwards
									p = p + whitespaceSpan; // point p at the start of the binding endmarker
									offsetToEndOfLastBindingEndMkr = (int)(p - ptr) + markerLen;
									p = p + markerLen;
								}
							}
						} // end of else block for test: if (whichSFMSet == PngOnly)
					} // end of TRUE block for test: else if (IsMarker(p + whitespaceSpan))
					else
					{
						// subcondition (ii) doesn't apply, so try subconditon (iii) --
						// this boils down to testing for a closing (curly) quote or >
						// wedge after the whitespace, if we find that ignore the space
						// and continue scanning, otherwise we halt here
						int whitespaceSpan = ParseWhiteSpace(p);
						if (IsClosingCurlyQuote(p + whitespaceSpan))
						{
							// this space(s) is/are to be ignored, continue scanning
							p = p + whitespaceSpan;
						}
						else
						{
							// none of the subconditions for regarding this space as ignorable are
							// satisfied, so halt here
							*pbFoundHaltingWhitespace = TRUE;
							break;
						}
					}
				} // end of else block for test: if (*pbFoundInlineBindingEndMarker == TRUE &&
				  //                                 p == (ptr + offsetToEndOfLastBindingEndMkr))
			} // end of TRUE block for test: else if (IsWhiteSpace(p))
			else
			{
				// it's not whitespace -- control should never enter here, but if it does,
				// then halt for safety's sake
				break;
			}
		} // end of else block for test: if (!IsMarker(p) && !IsWhiteSpace(p) && !IsFixedSpaceOrBracket(p))
	}
	pHaltLoc = p;
	return pHaltLoc;
}

wxString CAdapt_ItDoc::SquirrelAwayMovedFormerPuncts(wxChar* ptr, wxChar* pEnd, wxString& spacelessPuncts)
{
	wxString squirrel; squirrel.Empty();
	// first, find out if there is an inline binding beginmarker no more than
	// MAX_MOVED_FORMER_PUNCTS characters ahead of where ptr points on entry; if there
	// isn't, return an empty string because the caller must then assume that ptr on entry
	// is pointing at the actual start of the word which is to be parsed; if there is,
	// then make a further check - there must not be a space preceding the marker - if
	// there is, then return an empty string, because ptr must be pointing at a word to be
	// parsed
	int numCharsToCheck = (int)MAX_MOVED_FORMER_PUNCTS;
	bool bMarkerExists = FALSE;
	bool bItsAnInlineBindingMarker = FALSE;
	int count = 1;
	while (count <= numCharsToCheck)
	{
		if (IsWhiteSpace(ptr + count))
		{
			// white space encountered before a marker was reached, so return the empty
			// string
			return squirrel;
		}
		else if (IsMarker(ptr + count))
		{
			bMarkerExists = TRUE; // we must exit at the first found, we can't look beyond it
			break;
		}
		else
		{
			count++;
		}
	}
	// did we find a marker?
	if (!bMarkerExists)
	{
		// no marker within the allowed small span of following characters (3 is
		// MAX_MOVED_FORMER_PUNCTS value -- see AdaptItConstants.h) so the caller must
		// assume that ptr is the actual start of the word - it will deduce that fact if
		// the returned string is empty
		return squirrel;
	}
	else
	{
		// we found a marker, but it has to be an inline binding marker (and not an inline
		// binding endmarker); so check if it is an inline binding marker - if so, and
		// providing there was no preceding whitespace (tested in the loop above), we can
		// test for squirreling some non-restored word initial word-building characters
		// that got moved earlier to precede the inline binding marker, into the squirrel
		// string for safekeeping until the caller needs to insert them at the start of the
		// word to be parsed
		wxString wholeMkr = GetWholeMarker(ptr + count);
		// if it's an endmarker, return, we've not the situation we expect could happen
		if (wholeMkr[wholeMkr.Len() - 1] == _T('*'))
		{
			// it's an endmarker - return
			return squirrel;
		}
		wxString bareMkr = wholeMkr.Mid(1); // remove the initial backslash
		USFMAnalysis* pUsfmAnalysis = LookupSFM(bareMkr);
		if (pUsfmAnalysis == NULL)
		{
			// it's an unknown marker, therefore not an inline binding marker
			return squirrel; // caller will have to assume the char(s) at ptr are start of a word
		}
		else
		{
			wxString wholeMkrPlusSpace = wholeMkr + _T(' ');
			if (gpApp->m_inlineBindingMarkers.Find(wholeMkrPlusSpace) != wxNOT_FOUND)
			{
				// we've found a valid beginmarker from the set of inline binding markers
				bItsAnInlineBindingMarker = TRUE;
			}
		}
	}
	if (!bItsAnInlineBindingMarker)
	{
		squirrel.Empty();
		return squirrel;
	}
	wxChar* pNewEnd = ptr + count; // where the inline binding marker commences
	// now move each of them up to the marker, to squirrel string, provided they are not
	// in the punctuation set -- do this only if an inline binding marker was found ahead
	// of the characters at issue (because it's only such a marker that caused the move of
	// the former word-building char to become a punt in the first place, so it's only
	// from that kind of movement round the marker that we need a recovery mechanism for)
	while (bItsAnInlineBindingMarker && ptr < pNewEnd && ptr < pEnd &&
		spacelessPuncts.Find(*ptr) == wxNOT_FOUND)
	{
		squirrel += *ptr++;
	}
	if (bItsAnInlineBindingMarker && !squirrel.IsEmpty() && *ptr != gSFescapechar)
	{
		// there is at least one more moved here when it became punctuation, but it
		// remains as punctuation still... so to enable the caller to get the parsing ptr
		// to point at the marker's backslash when we return, we have to grab all the
		// rest, whether punctuation or not, and squirrel them away too. This can result
		// in punctuation being "buried" in word-medial location. We can't help this, it's
		// the price we pay for having one CSourcePhrase under punctuation changes
		// generate just one altered CSourcePhrase -- if not, we'll get more than one and
		// then things get messy
		while (*ptr != gSFescapechar)
		{
			squirrel += *ptr++;
		}
	}
	return squirrel;
}


void CAdapt_ItDoc::ValidateNoteStorage()
{
	SPList* pList = gpApp->m_pSourcePhrases;
	if (pList == NULL || pList->IsEmpty())
		return;
	SPList::Node* pos_pList = pList->GetFirst();
	while (pos_pList != NULL)
	{
		CSourcePhrase* pSrcPhrase = pos_pList->GetData();
		pos_pList = pos_pList->GetNext();
		if ((pSrcPhrase->GetNote()).IsEmpty())
		{
			pSrcPhrase->m_bHasNote = FALSE;
		}
		else
		{
			// it has a note string, so ensure the flag is set
			pSrcPhrase->m_bHasNote = TRUE;
		}
	}
}

// TRUE if not punct, or ~, or a marker, or not [ nor ], & not whitespace etc
// Note: the m_spacelessPuncts used here has already been set to source text
// punctuation characters, or target text punctuation characters, according to
// what TokenizeText() currently, or at last call, used when parsing
// BEW created 9Sep16, for use in a refactored & simplified ParseWord() function
// that handles ~ (USFM fixed space) better
bool CAdapt_ItDoc::IsInWordProper(wxChar* ptr, wxString& spacelessPuncts)
{
	// First test, is it a punctuation character, or a ~ character
	if (IsOneOf(ptr, spacelessPuncts))
	{
		return FALSE; // it's one of those, so not in the word proper
	}
	// Test for it being whitespace
	if (IsWhiteSpace(ptr))
	{
		return FALSE;
	}
	// Test for it being the first character of an SFM or USFM marker
	// Test for it being [ or ] or a solidus (forward slash)
	if ((*ptr == _T('\\')))
	{
		return FALSE;
	}
	// Test for it being [ or ] or a solidus (forward slash)
	if ((*ptr == _T('[')) || (*ptr == _T(']')))  // || (*ptr == _T('/'))) <- not here,
		// so we can parse dates like 12/04/2016 as a 'word' ** Check this works with / <-> ZWSP choice **
	{
		return FALSE;
	}
	return TRUE; // the only possibility left is that it is a word-building character
}

// TRUE if it is a ~ (tilde), the USFM fixed-space character
bool CAdapt_ItDoc::IsFixedSpace(wxChar* ptr)
{
	return *ptr == _T('~');
}


/// returns     TRUE if the marker is \f* or \fe* or \x* for USFM set, or if PNG 1998 set
///             is current, if the marker is \F or \fe
/// ptr        ->  the scanning pointer for the parse
/// pWholeMkr  <-  ptr to the endmarker string, empty if there is no marker at ptr
/// Called when ptr has possibly reached an endmarker following parsing of the word (and
/// possibly some following whitespace, the case when there was following puncts and ptr
/// points past them will be handled somewhere else probably). The intention of this function
/// is to alert the caller that any endmarker which should be stored in m_endMarkers and which
/// is currently being pointed at by ptr, must be flagged as present (so the caller can
/// then get it stored in m_endMarkers before returning from the caller to TokenizeText().
/// This function is very specific to making the ParseWord() parser work properly, so is
/// private in the document class. It the sfm set is PNG 1998 one, and the marker is \fe,
/// elsewhere in the app we default to assuming \fe is a USFM marker, since it is in both
/// sets with different meaning. Here we have a problem, if the set is the combined
/// UsfmAndPng, because it could then be a footnote endmarker of PNG 1998 set, or an
/// endnote beginmarker of the USFM set - and either could occur in the context where the
/// parser's ptr is currently at, so that's no help. So we'll require the set to be
/// explicitly PngOnly before we interpret it as the former. If it's UsfmAndPng, we'll
/// interpret it as the latter - and it that gives a false parse, then too bad. People
/// should be using only Usfm by now anyway!
/// BEW 24Oct14 no change needed for support of USFM nested markers
bool CAdapt_ItDoc::IsEndMarkerRequiringStorageBeforeReturning(wxChar* ptr, wxString* pWholeMkr)
{
	if (gpApp->gCurrentSfmSet == PngOnly)
	{
		//if (*ptr == gSFescapechar)
		if (IsMarker(ptr))
		{
			(*pWholeMkr) = GetWholeMarker(ptr);
			if (*pWholeMkr != _T("\\fe") && *pWholeMkr != _T("\\F"))
			{
				return FALSE;
			}
		}
		else
		{
			(*pWholeMkr).Empty();
			return FALSE;
		}
	}
	else
	{
		// it's either USFM set or UsfmAndPng set --  treat both as if USFM
		//if (*ptr == gSFescapechar)
		if (IsMarker(ptr))
		{
			(*pWholeMkr) = GetWholeMarker(ptr);
			if (*pWholeMkr != _T("\\f*") && *pWholeMkr != _T("\\fe*") && *pWholeMkr != _T("\\x*"))
			{
				return FALSE;
			}
		}
		else
		{
			(*pWholeMkr).Empty();
			m_bIsWithinUnfilteredInlineSpan = FALSE; // BEW added 2Dec22, as few places restore it to FALSE
			return FALSE;
		}
	}
	return TRUE;
}

// returns     the updated value of len, agreeing with where updated ptr is on return
// ptr            <->  the scanning pointer for the parse
// pEnd            ->  first character past the end of the data buffer we are parsing
// pSrcPhrase     <->  where we are storing information parsed, here it is final
//                     endmarker(s) and any immediately following punctuation for each;
//					   the endmarkers to be appended to its m_follOuterPunct member
// len             ->  the len value before ptr is maybe advanced in this internal scan
// bInlineBindingEndMkrFound <-> input FALSE, and returned as TRUE if an inline binding
//                               endmarker was detected and parsed over & stored (we
//                               use the TRUE value in the caller to enable a second
//                               attempt to collect final punctuation following such a
//                               marker) When  true, length returned is updated larger
// bNonbindingEndMkrFound	<-> input FALSE, returned as TRUE if an inline non-binding
//								marker found and stored, and  length returned updated
// bNormalEndMkrFound		<-> input FALSE, return TRUE if \x* \ex* \f* or \ef* was
//								found & stored, with ptr & length updated as above.
//								These four (two are new in USFM3) are stored in m_endMarkers
// endMkr          <-  the endmarker parsed over, in case the caller needs it
//
// Called when ptr has reached an endmarker following parsing of the word (and possibly
// also having parsed over punctuation too). There are three kinds of endmarker parse we
// handle here; first kind is parsing over one or more sequential inline binding
// endmarkers, that is, not \f* \ef* \x* \ex* nor any of the 5 in the 
// m_inlineNonbindingEndMarkers set. Any of these we will store in the 
// m_inlineBindingEndMarkers member of pSrcPhrase.
//
// The other kind of endmarkers we must deal with are those internal to footnotes or
// crossReferences, or internal to extended footnotes or crossreferences. These endmarkers
// in the case of footnotes start with \f and end with *, and for crossReferences, start
// with \x and end with *, and each has other characters between the \f and *, or the \x
// and *. These are \fdc* and \fm*, and we can include \fe* too (for endnotes); & for
// crossReferences, \xot* \xnt* \xdc* etc (these may be lacking).
// New USFM3 ones like \ef* and \ex*, these are to be stored in the m_endMarkers member.
//
// If this function finds no end marker of the type it deals with, then ptr and len are 
// returned unchanged to the caller, and further possibilities are then tried. 
// If it finds an endmarker (it finds ONLY ONE PER CALL) there may be following
// final punctuation characters - we have a pre-exit loop to check herin to parse over
// and put them in the m_follOuterPunct member of the current pSrcPhrase, advancing ptr 
// and len to point past them.
//
// The function has no loop, and must stay that way;
// however it is called in a loop, so can deal with successive endMarkers that way. So it
// deals with just one endMarker if ptr points to one; stores same, and returns an updated
// len value so caller's len can be updated to point to the same location. 
// BEW refactored 11Mar20. What I'm adding now is a punctuation-collecting loop after the 
// end marker has been dealt with, providing a single endmarker was found - because USFM3
// markup has things like: footnote:xref data spans where the : is word final punctuation
// that should get stored in pSrcPhrase's m_follOuterPunct -- otherwise it gets wrongly 
// assigned to a following empty CSourcePhrase instance.
// BEW 16Apr20 refactored for better support of USFM3 and cleaner algorithm
int CAdapt_ItDoc::ParseInlineEndMarkers(wxChar*& ptr, wxChar* pEnd,
	CSourcePhrase*& pSrcPhrase, wxString& inlineNonBindingEndMkrs, int len,
	bool& bBindingEndMkrFound, bool& bNonbindingEndMkrFound,
	bool& bNormalEndMkrFound, wxString& endMkr)
{
//#if defined (_DEBUG)
	//if (pSrcPhrase->m_nSequNumber == 2) // data: _punct_between_footnote_and_xref2.txt
	//if (pSrcPhrase->m_nSequNumber == 84 || pSrcPhrase->m_nSequNumber == 136)
	//if (pSrcPhrase->m_nSequNumber >= logStart && pSrcPhrase->m_nSequNumber <= logEnd) // 136 &  137 
	//{
	//	int halt_here = 1;
	//	wxUnusedVar(halt_here);
	//}
//#endif
	int inputLen = len; // save the input len value - so that if a marker is found and
						// stored, we can easily test for that fact
	endMkr.Empty();
	bool bIs_f_x_fe_xe_endMkr = FALSE;
	bool bIsMkr = IsMarker(ptr);
	wxUnusedVar(bIsMkr);
	bool bIsEndMkr = IsEndMarker(ptr, pEnd);
	if (!bIsEndMkr)
	{
		// do no parse if we are not pointing to an end- marker
		return len;
	}
	else
	{
		// BEW 16Apr20 USFM3 adds some more inLine "extended" markers, such as \ef ... \ef* 
		// (extended footnote) and \ex .... \ex* (extended cross reference), and we will
		// handle \ef* and \ex* here too. So below I'll refactor the code - the 'normal'
		// endmarker storage suggested by the name bInlineNormalMkrFound is to use
		// m_endMarkers member of the CSourcePhrase instance; with the exception that
		// if the endMarker is \+jmp then that will be included in the 'normal'
		// set and so be stored in m_endMarkers also

		// BEW 15Apr20 for \f* \x* \ef* \ex*
		bIs_f_x_fe_xe_endMkr = IsFootnoteOrCrossReferenceEndMarker(ptr);
		if (bIs_f_x_fe_xe_endMkr)
		{
			// Get it stored
			endMkr = GetWholeMarker(ptr);
			// it's one of \f* \ef* \x* or \ex*; these are all stored in m_endMarkers
			int length = endMkr.Len();
			wxString endMkrs = pSrcPhrase->GetEndMarkers();
			endMkrs += endMkr;
			pSrcPhrase->SetEndMarkers(endMkrs);

			// Update len value, and set ptr to point at the next character 
			// immediately after the end marker - it might be whitespace, punctuation,
			// a further endMarker, ] (bracket), or the beginning of the next word to
			// be parsed - this function returns to a loop, which will iterate this
			// function and break out when len does not advance because there are no
			// more final puncts or endmarkers to deal with for the current pSrcPhrase
			bNormalEndMkrFound = TRUE;
			len += length;
			ptr += length;
			m_bIsWithinUnfilteredInlineSpan = FALSE; // BEW added 2Dec22, as few places restore it to FALSE
		}
		// The following are the storage attempts for the rest of what markers may occur
		else if (!bIs_f_x_fe_xe_endMkr)
		{
			// it's not one of \f* \ef* \x* or \ex*; and we also in the function do not parse
			// over any of the 5 inline non-binding endmarkers (\wj* \qt* \sls* \tl*
			// \fig*) so test for these and exit without doing anything if we are pointing
			// at one of them
			// BEW 30Sep19, refactor a bit, because \ef* otherwise ends up wrongly
			// in the storage for inline binding endmarker, rather than m_endMarkers;
			// similarly for \ex*
			wxString wholeEndMkr = GetWholeMarker(ptr);
			wxString wholeEndMkrPlusSpace = wholeEndMkr + _T(" ");
			int length = wholeEndMkr.Len();
			int offset = wxNOT_FOUND; // initialise
			if (inlineNonBindingEndMkrs.Find(wholeEndMkrPlusSpace) == wxNOT_FOUND)
			{
				// It's not in the non-binding fast access string...

				// There are now several possibilities... distinguish between & process ...
				// The protocol: we are pointing at an inline endmarker - so determine
				// what it is, and store appropriately. It's either a binding type,
				// or a normal type (normal types include markers internal to footnotes,
				// end notes and cross references, including for \ef and \ex spans)
				// and return (there may be more than one, so the caller will repeat the
				// call until the len value returned is equal to what was input - which is
				// a sufficient test for parsing over nothing during the call)
				//
				// option (1) we are pointing at an inline endmarker internal to a footnote,
				// endnote or crossReference - and if that is the case, parse it, store,
				// and return to the caller -- again, the caller receiving a len value
				// equal to what was input indicates the caller's loop must end
				// option (2) we must also test for the marker plus space being in the
				// gpApp->m_inlineBindingEndMarkers fast access string, and only
				// store to m_endMarkers when its neither binding nor nonbinding
				// option (3) the left-overs: when its neither binding nor nonbinding -
				// put it in m_endMarkers
				if (IsCrossReferenceInternalEndMarker(ptr) || IsFootnoteInternalEndMarker(ptr))
				{
					// option (1) obtains
					pSrcPhrase->AddEndMarker(wholeEndMkr);  // add to m_endMarkers
					bNormalEndMkrFound = TRUE;
				}
				else
				{
					// checkfor binding endmarker which slipped thru the net
					offset = wholeEndMkr.Find(_T("*"));
					if (offset == wxNOT_FOUND)
					{
						// It's not an endmarker, so don't advance len value,
						// just return what length was passed in
						return len;
					}
					else
					{
						// Make the begin-mkr  (we don't have a fast-access
						// string defined for inline binding end markers)
						wxString beginMkr = wholeEndMkr.Left(offset);
						beginMkr += _T(' '); // add following space
						offset = gpApp->m_inlineBindingMarkers.Find(beginMkr);
						if (offset == wxNOT_FOUND)
						{
							// It's not an inline binding end marker, so must
							// be the 'remainder' solution - a normal endmarker
							// to be stored in m_endMarkers; but it could be
							// one of the USFM3 character attribute end markers -
							// these we store in the non-binding end marker
							// storage. Check it out & store accordingly
							offset = charAttributeEndMkrs.Find(wholeEndMkrPlusSpace);
							if (offset == wxNOT_FOUND)
							{
								// It's not one of the USFM3 character attribute end markers,
								// so it needs to go in m_endMarkers
								pSrcPhrase->AddEndMarker(wholeEndMkr);  // add to m_endMarkers
								bNormalEndMkrFound = TRUE;
							}
							else
							{
								// It's found within the set of USFM3 character attribute
								// end markers; these we store in the non-binding end mkr
								// storage - with the exception of \+jmp* which, because it's
								// embedded within some other non-filtered span, we need to
								// append it m_endMarkers member of pSrcPhrase
								wxString plusJmpEndMkr(_T("\\+jmp*"));
								if (wholeEndMkr == plusJmpEndMkr)
								{
									pSrcPhrase->AddEndMarker(plusJmpEndMkr);
									bNormalEndMkrFound = TRUE;
								}
								else
								{
									wxString strNonbinding = pSrcPhrase->GetInlineNonbindingEndMarkers();
									strNonbinding += wholeEndMkr;
									pSrcPhrase->SetInlineNonbindingEndMarkers(strNonbinding);
									bNonbindingEndMkrFound = TRUE;
								}
							}
						}
						else
						{
							// it's an inline binding end marker
							pSrcPhrase->AppendToInlineBindingEndMarkers(wholeEndMkr);
							bBindingEndMkrFound = TRUE;
						}
					} // end of else block for test: if (offset == wxNOT_FOUND)

				} // end of else block for test: if (IsCrossReferenceInternalEndMarker(ptr) 
				  //								|| IsFootnoteInternalEndMarker(ptr))
			} // end of TRUE block for test:
			  // if (inlineNonBindingEndMkrs.Find(wholeEndMkrPlusSpace) == wxNOT_FOUND)
			else
			{
				wxString strNonbinding = pSrcPhrase->GetInlineBindingEndMarkers();
				strNonbinding += wholeEndMkr;
				pSrcPhrase->SetInlineNonbindingEndMarkers(strNonbinding);
				bNonbindingEndMkrFound = TRUE;
			}
			// Return the marker in endMkr, update len value, and set ptr
			// to point at the next character immediately after the end marker
			endMkr = wholeEndMkr;
			len += length;
			ptr += length;

		} // end of TRUE block for test: else if (!bIs_f_x_fe_xe_endMkr)

	} // end of else block for test: if (!IsEndMkr)

	// Did we parse and store an endmarker? Loop to get any further final puncts
	if (len > inputLen)
	{
		int offset = wxNOT_FOUND; // initialise
		bool bUseTgtPuncts = m_bTokenizingTargetText; // from Doc.h to preserve bool value
													  // passed in, in TokenizeText() call
		// Yes we did; so parse over any following punctuation that belongs to the
		// m_follOuterPunct member and store it, updating len and ptr before returning
		// - include space in the parse so long as a final punct follows it
		wxString space = _T(" ");
		bool bIncludeSpace = FALSE;
		while (
			(ptr < pEnd) &&
			(*ptr != _T(']')) &&
			(!IsMarker(ptr) && !IsEndMarker(ptr, pEnd)))
		{
			bIncludeSpace = FALSE;
			if (*ptr == _T(' '))
			{
				wxString afterSpace = *(ptr + 1);
				int offset2 = wxNOT_FOUND;
				if (bUseTgtPuncts)
				{
					// use the word-final set of target language punctuation characters
					offset2 = gpApp->m_finalTgtPuncts.Find(afterSpace);
				}
				else
				{
					// use the word-final set of source language punctuation characters
					offset2 = gpApp->m_finalSrcPuncts.Find(afterSpace);
				}
				if (offset2 != wxNOT_FOUND)
				{
					bIncludeSpace = TRUE;
				}
			}

			if (bIncludeSpace)
			{
				pSrcPhrase->AddFollOuterPuncts(space);
				// Add it also to end of m_srcPhrase so it's seen in the GUI
				pSrcPhrase->m_srcPhrase += space;
				len++;
				ptr++;
			}
			else
			{
				if (bUseTgtPuncts)
				{
					// use the word-final set of target language punctuation characters
					offset = gpApp->m_finalTgtPuncts.Find(*ptr);
				}
				else
				{
					// use the word-final set of source language punctuation characters
					offset = gpApp->m_finalSrcPuncts.Find(*ptr);
				}
				if (offset == wxNOT_FOUND)
				{
					// The character at ptr is not a punctuation character
					return len;

				}
				else
				{
					// A punctuation character is at ptr. Deal with it, and advance ptr and len,
					// and iterate the loop until all consecutive final puncts are collected
					// and appended to m_follOuterPunct
					wxChar aPunct = *ptr;
					pSrcPhrase->AddFollOuterPuncts(aPunct);
					// Add it also to end of m_srcPhrase so it's seen in the GUI
					pSrcPhrase->m_srcPhrase += aPunct;
					len++;
					ptr++;
				} // end of else block for test: if (offset == wxNOT_FOUND)
			} // end  of else block for test: if (bIncludeSpace)

		}  // end of while loop for scanning and storing final puncts in m_follOuterPunct

	} // end of TRUE block for test: if (len > inputLen) i.e. a marker was
	  // found and stored, len & ptr updated, and maybe some further puncts too -
	  // and additional increase of len and ptr for them as well
	return len;
}

// returns     the updated value of len, agreeing with where ptr is on return
// ptr            <->  the scanning pointer for the parse
// pEnd            ->  first character past the end of the data buffer we are parsing
// pSrcPhrase     <->  where we are storing information parsed, here it is final
//                     punctuation to be appended to its m_follPunct member
// spacelessPuncts ->  the punctuation set being used (either source puncts, or target ones)
// len             ->  the len value before ptr is advanced in this internal scan
// bExitOnReturn  <-   return TRUE if ParseWord() should be exited on return
// bHasPrecedingStraightQuote <-> default is FALSE, the boolean passed in is stored
//                                on the CAdapt_ItDoc class with public access; and
//                                is set TRUE if a straight quote (" or ') is detected
//                                in TokenizeText() when parsing punctuation preceding
//                                a word. The matching closing straight quote could be
//                                many word parses further on, and so we leave it set
//                                until one of the following happens, whichever is first:
//                                a new verse is started, or, its TRUE value is used to
//                                assign ownership of ' or " to the currently being parsed
//                                word as its final punctuation, or part of its final
//                                punctuation (if there are more than one, we'll assign them
//                                all - which could lead to a misparse if an opening
//                                straight quote occurs prior to the next word - it's
//                                opening quote would wrongly be put in the following puncts
//                                of the preceding word -- but probably this would never
//                                happen in practice [we hope])
// additions	<-	what we to what we already have for m_srcPhrase final punctuation
//					and for adding to m_follPunct
// bPutInOuterStorage   ->		 pass in false, but we'll just set it internally
//								 to whatever it needs to be depending on what we parse
// Called after a sequence of word-final punctuation ends at space - there could be
// additional detached endquotes, single or double - this function collects these, stores
// them appropriately in pSrcPhrase, and advances len and ptr to the end of the material
// parsed over.
// BEW created 11Oct10
// BEW 2Dec10 added ] character as cause to return, ptr should be pointing at it on return
// BEW 24Oct14, no changes needed for support of USFM nested markers
// BEW 30Sep19, added code for endmarker being parsed and stored too
// BEW 16Apr20 refactored somewhat
int CAdapt_ItDoc::ParseAdditionalFinalPuncts(wxChar*& ptr, wxChar* pEnd,
	CSourcePhrase*& pSrcPhrase, wxString& spacelessPuncts,
	int len, bool& bExitOnReturn, bool& bHasPrecedingStraightQuote,
	wxString& additions, bool bPutInOuterStorage)
{
	wxChar* pPunctStart = ptr;
	wxChar* pPunctEnd = ptr;
	size_t counter = 0;
	bool bFoundClosingQuote = FALSE;
	wxChar* pLocation_OK = ptr;
	// The test is complex, and setting bFoundClosingQuote  is what we
	// mainly want to know, whether true or false, but the while loop
	// can exit with bFoundClosingQuote set TRUE, but ptr and pLocation_OK
	// having same value but pointing a one or more punctuation characters
	// not yet parsed. So after the while loop another loop will parse over
	// any puncts that remain before whatever causes halting (e.g. a marker)
	while (!IsEnd(ptr) && (IsWhiteSpace(ptr) || IsClosingQuote(ptr)) && !IsMarker(ptr)
		&& *ptr != _T(']'))
	{
		if (IsClosingQuote(ptr))
		{
			bFoundClosingQuote = TRUE;
			// now determine if it is a curly endquote or right chevron, and if so
			// then it is definitely to be included in the following punctuation of
			// the current pSrcPhrase
			if (IsClosingCurlyQuote(ptr))
			{
				// mark the location following it
				pLocation_OK = ptr;
				pLocation_OK = (wxChar*)(pLocation_OK + 1);
			}
		}
		counter++;
		ptr++;
		pPunctEnd = ptr;
		// if the punctuation end is also pEnd, then tell the caller not to parse further
		// on return
		if (IsEnd(pPunctEnd))
		{
			bExitOnReturn = TRUE;
		}
	}
	// BEW 17Apr20 The complex test will exit after detecting a closing curly quote,
	// leaving ptr and pLocation_OK possibly pointing at a punctuation character or
	// characters without accumulating all up to a halting point - such as an endmarker
	// then code further below will  not match with comments, and misbehave. So get
	// as many as there are before an endmarker or ] or doc end. counter tracks how many
	wxString strPuncts = m_spacelessPuncts; // RHS is Doc.cpp member, set by TokenizeText()
											// to src or tgt set, as required
	int anOffset = wxNOT_FOUND;
	while (!IsMarker(ptr) && (*ptr != _T(']')) && !IsEnd(ptr))
	{
		wxString s(*ptr);
		anOffset = strPuncts.Find(s);
		if (anOffset == wxNOT_FOUND)
		{
			break;
		}
		else
		{
			counter++;
			ptr++;
			pLocation_OK++;
			pPunctEnd = ptr;
		}
	}
	// On exit of the loop we are either at buffer end, or backslash of a marker, or a ]
	// closing bracket, or some character which is not whitespace nor a closing quote
	// (IsClosingQuote() also tests for a straightquote or doublequote, so
	// IsCLosingCurlyQuote() was also used as it does not test for straight ones)
	if (bFoundClosingQuote)
	{
		// we matched something more than just whitespace and the something is
		// curly endquote(s) and possibly a straight one (or more than one) - pLocation_OK
		// will point at the character following the last curly endquote scanned over, so
		// only white space and one or more straight quotes can follow that location
		//
		// BEW 3Aug17 added text on next line, IsMarker() and not IsEndMarker() so as
		// to enter the TRUE block when a begin marker is being pointed at, whether \v, or
		// \x or \f or \fe etc because we need to go back to TokenizeText to parse these
		// and possibly filter one or more, so we need to just accept what we've parsed
		// over here, if anything, and return with ptr pointing at the marker, or pointing
		// at the start of any previous whitespace if there is any just parsed over.
		// Use IsEndMarker(ptr, pEnd) call here too? dunno; change IsEndMarker() call into
		// IsMarker() call here; snd also some code to test that if it is a marker here, it
		// is not an inline binding marker
		int offset = wxNOT_FOUND;
		if (IsMarker(ptr))
		{
			// Check it's not a binding type, as these insignificant ones
			// should not affect storage nor the text stream parsing in any
			// significant way - that is, we want wxNOT_FOUND to be the
			// value in the test which follows
			wxString aWholeMkr = GetWholeMarker(ptr);
			wxString augmentedMkr = aWholeMkr + _T(' ');
			offset = gpApp->m_inlineBindingMarkers.Find(augmentedMkr);
		}

		if ((IsMarker(ptr) && offset == wxNOT_FOUND) || IsEnd(ptr))
		{
			// an endmarker or a begin marker is what ptr points at now, or the buffer's end,
			// so we'll accept everything as valid final punctuation for the current
			// pSrcPhrase; and if not at buffer end then further parsing is needed in the
			// caller because there may be more markers and punctuation to be handled for
			// the end of the current word. The marker is NOT an inlinebinding one
			bExitOnReturn = FALSE; // BEW 17Apr20 -- needs to be FALSE, so that further
								   // processing can happen, otherwise exits to TokenizeText
								   // prematurely (about line 31,195)

			// Back up over any preceding space & adjust ptr & counter
			int aWhiteSpanLength = 0;
			wxChar* pTemp = ptr;
			while ((size_t)aWhiteSpanLength < counter)
			{
				pTemp--;
				if (IsWhiteSpace(pTemp))
				{
					aWhiteSpanLength++;
				}
				else
				{
					break;
				}
			}

			if (aWhiteSpanLength > 0)
			{
				counter -= aWhiteSpanLength;
				ptr = ptr - (size_t)aWhiteSpanLength;
			}

			wxString finalPunct(pPunctStart, counter);
			if (bPutInOuterStorage)
			{
				pSrcPhrase->AddFollOuterPuncts(finalPunct);
			}
			else
			{
				pSrcPhrase->m_follPunct += finalPunct;
			}
			pSrcPhrase->m_srcPhrase += finalPunct; // add any detached punct'n
			additions += finalPunct; // accumulate here, so that the caller can add any
				// additions to secondWord of ~ conjoining, in the
				// m_srcPhrase and m_follPunct members; note this
				// setting of additions is done whether fixedspace
				// was encountered or not
			// What ptr points at now could be an inline non-binding endmarker (like \wj*)
			// or one of \f* \x* \ef* or \ex* - so while our parse of the punctuation in
			// this function halts, the caller's parse may continue over potential 
			// endmarkers or puncts further on, and there could be outer following
			// punctuation too; it won't though if bExitOnReturn is TRUE - so we set
			// it to FALSE above
			len += counter;

//#if defined (_DEBUG)
			//if (pSrcPhrase->m_nSequNumber == 2) // data: _punct_between_footnote_and_xref2.txt
			//if (pSrcPhrase->m_nSequNumber == 84 || pSrcPhrase->m_nSequNumber == 136)
			//if (pSrcPhrase->m_nSequNumber >= logStart && pSrcPhrase->m_nSequNumber <= logEnd) // 136 &  137 
			//{
			//	int halt_here = 1;
			//	wxUnusedVar(halt_here);
			//}
//#endif
		} // end of TRUE block for test: if (IsEndMarker(ptr,pEnd) || IsEnd(ptr))
		else
		{
			// ptr is not pointing at the start of a marker; the situation is somewhat
			// ambiguous - the difficulty here is that we may have some ending
			// punctuation parsed over which belongs to the final punctuation of the
			// current pSrcPhrase, followed by some initial punctuation (it can only be
			// straight singlequote or straight doublequote) which belongs to the start
			// of the next word to be parsed - so we'll accept only up to where
			// pLocation_OK points as belonging to final punctuation of pSrcPhrase, and
			// anything after that belongs to the next call of ParseWord() as initial
			// punctuation for that call's word; however if bHasPrecedingStraightQuote is
			// TRUE, then we'll accept the whole lot, because we assume that any straight
			// quotes match any found earlier somewhere.
			size_t shortCount = 0;
			if (pLocation_OK > pPunctStart)
			{
				// we found at least one curly endquote, so work out if they all were
				// curly endquotes that we parsed over (and accept them all) or if
				// only some of them were (we accept only those up to pLocation_OK,
				// and if any quotes follow we assume they belong to the next word -
				// unless bHasPrecedingStraightQuote is TRUE)
				shortCount = pLocation_OK - pPunctStart;
				if (shortCount < counter)
				{
					// we parsed over non-curly (& non-right-chevron) non-endquote
					// quote character lying beyond pLocation_OK, or, we may have just
					// whitespace following pLocation_OK -- handle these possibilities
					wxString finalPunct(pPunctStart, shortCount);
					if (bPutInOuterStorage)
					{
						pSrcPhrase->AddFollOuterPuncts(finalPunct);
					}
					else
					{
						pSrcPhrase->m_follPunct += finalPunct;
					}
					pSrcPhrase->m_srcPhrase += finalPunct;
					additions += finalPunct;
					size_t theRest = pPunctEnd - pLocation_OK;
					wxString remainder(pLocation_OK, theRest);
					wxString minusEndingSpaces = remainder.Trim();
					if (minusEndingSpaces.IsEmpty())
					{
						// there was only whitespace in remainder, so we can include
						// it in the parsed over data span & tell the caller to return
						len += counter;
						bExitOnReturn = TRUE;
						return len;
					}
					else
					{
						// remainer has some nonwhitespace content, but that must
						// belong (we assume) to the next word's parse, so set the ptr
						// location to be pLocation_OK; but if bHasPrecedingStraightQuote
						// is TRUE, accept it all
						if (bHasPrecedingStraightQuote)
						{
							if (bPutInOuterStorage)
							{
								pSrcPhrase->AddFollOuterPuncts(remainder);
							}
							else
							{
								pSrcPhrase->m_follPunct += remainder;
							}
							pSrcPhrase->m_srcPhrase += remainder;
							additions += remainder;
							ptr += theRest;
							len += (int)theRest;
							bHasPrecedingStraightQuote = FALSE; // we've made a decision
								// based on it's TRUE value, so we must now restore
								// its default FALSE value in case further matching
								// of preceding and following straight quotes is
								// required in the parse of further words
						}
						else
						{
							ptr = pLocation_OK;
							len += shortCount;
							bExitOnReturn = TRUE;
							return len;
						}
					}
				}
				else
				{
					// shortCount and counter are the same value, so we accept it all
					// and we must tell the caller to return because ptr is not pointing
					// at a marker but something else which is not a quote symbol.
					// Possibly it could be other punctuation ptr is pointing at, and if
					// it is so without any spaces, then we should accept it as belonging
					// to the end of the current final punctuation - so accumulate it
					// until space or non-puncts are encountered. But check for ] first,
					// if pointing at that, (it's defaulted as punctuation) don't
					// accumulate it but return instead
					wxString finalPunct(pPunctStart, counter);
					if (bPutInOuterStorage)
					{
						pSrcPhrase->AddFollOuterPuncts(finalPunct);
					}
					else
					{
						pSrcPhrase->m_follPunct += finalPunct;
					}
					pSrcPhrase->m_srcPhrase += finalPunct;
					additions += finalPunct;
					len += counter;
					// are we pointing at ] bracket?
					if (*ptr == _T(']'))
					{
						// we must return
						bExitOnReturn = TRUE;
						return len;
					}
					// else, accumulate any more puncts until space or non-punct or a
					// ] bracket is reached
					while (ptr < pEnd && (spacelessPuncts.Find(*ptr) != wxNOT_FOUND)
						&& *ptr != _T(']'))
					{
						wxString aPunct = *ptr;
						if (bPutInOuterStorage)
						{
							pSrcPhrase->AddFollOuterPuncts(aPunct);
						}
						else
						{
							pSrcPhrase->m_follPunct += *ptr;
						}
						pSrcPhrase->m_srcPhrase += *ptr;
						additions += *ptr;
						len++;
						ptr++;
					}
					bExitOnReturn = TRUE;
					return len;
				}
			} // end of TRUE block for test: if (pLocation_OK > pPunctStart)
			else
			{
				// pLocation_OK has not advanced from pPunctStart where we started this
				// parse, so we didn't find any curly endquotes; so count all the punct and
				// whitespace parsed over as belonging to a later word -- and ptr is not
				// pointing at an endmarker, but if might be pointing at ] closing bracket,
				// so either way we must be done & can return after we finish off the
				// pSrcPhrase members; however, if bHasPrecedingStraightQuote is TRUE, then
				// we assume that only straight quotes were in the parse and that they
				// should be included as following punctuation for the current word. This
				// might be a faulty decsion if some belong to the current word and some to
				// the following word yet to be parsed, but our code can't reasonably be
				// made smart enough to decide where to make the division - and so we'll
				// just hope that that situation won't ever occur.
				if (bHasPrecedingStraightQuote || *ptr == _T(']'))
				{
					// Do a sanity (hack) test here, just in case markup inconsistency
					// let a straight doublequote get to here wrongly as a candidate
					// for closing quote, when it should be opening quote for the
					// word which follows (Seth's bug) BEW 19Oct15
					if (CannotBeClosingQuote(ptr, pPunctStart))
					{
						// reject the extras just parsed over
						ptr = pPunctStart; // restore ptr to location where we started from
						bExitOnReturn = TRUE;
						return len;
					}
					// okay, take the extras just parsed over
					if (counter > 0)
					{
						wxString finalPunct(pPunctStart, counter);
						if (bPutInOuterStorage)
						{
							pSrcPhrase->AddFollOuterPuncts(finalPunct);
						}
						else
						{
							pSrcPhrase->m_follPunct += finalPunct;
						}
						pSrcPhrase->m_srcPhrase += finalPunct;
						additions += finalPunct;
						len += counter;
						return len;
					}
				}
				else
				{
					// reject the extras just parsed over
					ptr = pPunctStart; // restore ptr to location where we started from
					bExitOnReturn = TRUE;
					return len;
				}
			} // end of else block for test: if (pLocation_OK > pPunctStart)
		} // end of else block for test: if marker and not an inline binding mkr or is at buffer end
	} // end of TRUE block for test: if (bFoundClosingQuote)
	else if (IsEndMarker(ptr, pEnd) || IsEnd(ptr))
	{
		bExitOnReturn = FALSE;
		if (counter > 0)
		{
			if (IsEnd(ptr))
			{
				// ensure that if ptr is at pEnd, the caller does not parse further
				bExitOnReturn = TRUE;
			}
			// an endmarker is what ptr points at now, or the buffer's end, so we'll accept
			// everything as valid final punctuation for the current pSrcPhrase; and if not
			// at buffer end then further parsing is needed in the caller because there may
			// be more markers and punctuation to be handled for the end of the current
			// word
			wxString finalPunct(pPunctStart, counter);
			pSrcPhrase->m_follPunct += finalPunct;
			pSrcPhrase->m_srcPhrase += finalPunct; // add any punct'n
			additions += finalPunct; // accumulate here, so that the caller
				// can add any additions to secondWord of ~ conjoining, in the
				// m_srcPhrase and m_follPunct members (if there is conjoining)
			// What ptr points at now could be an inline non-binding endmarker (like \wj*)
			// or one of \f* \x* \ef* or \ex* etc, so while our parse of the
			// punctuation in this function halts, the caller's parse must 
			// continue over potential endmarkers further on, and there could 
			// be outer following punctuation too
			len += counter;
		} // end of TRUE block for test: if (counter > 0)
		else
		{
			// nothing extra, so return, but continue parsing in ParseWord() on return
			ptr = pPunctStart; // restore ptr to location where we started from
			bExitOnReturn = FALSE;
			return len;
		}
	}
	else if (*ptr == _T(']'))
	{
		// accept everything up to that point
		if (counter > 0)
		{
			wxString finalPunct(pPunctStart, counter);
			if (bPutInOuterStorage)
			{
				pSrcPhrase->AddFollOuterPuncts(finalPunct);
			}
			else
			{
				pSrcPhrase->m_follPunct += finalPunct;
			}
			pSrcPhrase->m_srcPhrase += finalPunct;
			additions += finalPunct;
			len += counter;
			bExitOnReturn = TRUE;
			return len;
		}
	}
	else
	{
		// we either didn't parse over anything, including white space; or we only
		// parsed over whitespace -- the latter is of no interest (we let the caller
		// advance over it)
		ptr = pPunctStart; // restore ptr to location where we started from
		bExitOnReturn = FALSE; // BEW 17Apr20 was FALSE
		return len;
	} // end of else block for test: if (bFoundClosingQuote)
	return len;
}

// BEW 25Jul23 added. It seems weird to use ParseFinalPuncts on a, say, reversed string
// with final punct before reversing. But ParseFinalPuncts returns correct length, parsing
// left to right, so I made ParsePuncts() to look more normal to someone maintaining AI
// One thing I added, and it's what messed with ParseAWord(), is that AI normally does not
// contain straight single quote ( '\'' ) as a punctuation character (it's often a glottal
// stop in many languages), so here, before ParseFinalPuncts is called, I'll add single
// straight to a temporary copy of spacelessPuncts.
int CAdapt_ItDoc::ParsePuncts(wxChar* pChar, wxChar* pEnd, wxString spacelessPuncts)
{
	wxString punctsSet;
	punctsSet = spacelessPuncts;
	// whm 22Sep2023 removed the following line thinking it to be illogical to add a word-
	// building glottal stop to a punctsSet.
	//punctsSet << _T('\'');
	int parsedPunctsLen;
	parsedPunctsLen = ParseFinalPuncts(pChar, pEnd, punctsSet);
	return parsedPunctsLen;
}

// BEW 29May23 if I'm to support data like  "laughter"\\f*... etc, where these puncts,
// or the ' punct, bracket a word intended to be considered by the reader has a meaning
// for what precedes, then I have to allow " or 1 to be considered by Adapt It as legit
// "final punctuation". Up to now, it refuses to consider either as a punctuation character
// but clearly each is. So, refactor accordingly. The while loop therefore needs fixing
//
// *********  NOTE ***** BEW 3Jun23 if I get a message, errorC2248: cannot access private member declared in class
// *********  regarding operator= , when using ParseFinalPuncts() , it's because I was assuming that the function
// *********  ParseFinaPuncts() returns a wxString, when it actually returns an int!!!!! Duh! Homer brain struck again
// *********  I've done this a sufficient number of times, and found the explanations opaque, I need a note somewhere.
int CAdapt_ItDoc::ParseFinalPuncts(wxChar* pChar, wxChar* pEnd, wxString spacelessPuncts)
{
	int length = 0;
	wxChar* ptr = pChar; // iterator
	//int offset = wxNOT_FOUND;
	if (ptr < pEnd && (spacelessPuncts.Find(*ptr) == wxNOT_FOUND))
	{
		// ptr is not pointing at a punctuation character, so return 0
		return length;
	}
	else
	{
		// There is at least one punctuation character, so parse over each in a loop
		// until the loop exit condition is met. A while loop suffices. Punctuation characters
		// which are not word-final, have to be excluded, so the loop will exit if one such is at ptr
		while ( !IsEnd(ptr) && !IsWhiteSpace(ptr) && (spacelessPuncts.Find(*ptr) != wxNOT_FOUND) 
				&& (*ptr != _T('[')) && (*ptr != _T('(')) && (*ptr != _T('{')) && (*ptr != gSFescapechar)
				//&& (!IsOpeningQuote(ptr)) && (*ptr != _T('\"')) && (*ptr != _T('\'')) ) BEW 29May23 removed, gotta allow " or ' as storable in m_finalPunct
			)
		{
			length++;
			ptr++;
		}
	}
	return length;
}


//BEW added 12Sep22 in support of the dual identities of \w .. \w* markers - for Tokenising properly
// ptr points at the current parsing location of the in-buffer source text USFM (or no usfm) data.
// When ptr encounters an augmented _T("\\w ") i.e. \w<space>, marker, there are two possible parsing
// paths. One is for \w word\w* just wrapping word, where word is valid source text information, but
// the word is also intended for Paratext to copy it out for a glossary dictionary. The other path is
// for when there is a bar ( | ) following the augmented marker, where the bar indicates that information
// follows which is not part of the inspired text, and so should be hidden from view by caching it on
// the current pile's current pSrcPhrase instance in a (repurposed) location called "pupat" -- see the
// declaration of CSourcePhrase. When a bar is present, then the CSourcePhrase instance will receive
// in pupat (called the m_punctsPattern member, but has no relationship to punctuation anymore, it's been
// repurposed for caching) the material to be cached: the first 3 characters of which will be <sp>|<sp>
// with the rest or the material to be hidden, following - and the correct endmarker at the end. There
// may be punctuation in the string, in which case entity changes will have been done, e.g. &quot; 
// replacing " because the information has to be stored in XML when the document is saved to disk.
// Also, every time pupat has content, the 22nd bool bit-flag,(corresponding to the CSourcePhrase
// member m_bUnused) will be set to 1. CSourcePhrase has member storage markers for certain types of
// inLine markers, such as inlineBindingMarkers (iBM) and endmarkers (iBEM), inlineNonbindingMmarkers (iNM)
// and endmarkers (iNEM) which hold marker forms relevant to caching, or non-caching but as non-typed
// indicators for wrapping a word or phrase which AI is to give minimal support to. \w and \w* are one
// of the latter, when there is no bar in the data so-wrapped.
// The algorithm for IsWmkrNoBar(ptr) as follows: 1. check if ptr is pointing at \w<sp>, if not, return FALSE.
// If its \w<SP>, search forward until the matching \w* endmarker terminates the search. IN the search,
// look for a bar character. If no matching endmarker is found (but some other one is, or end of doc) then
// return FALSE. If bar is encountered, then return TRUE; otherwise, return FALSE
bool CAdapt_ItDoc::IsWmkrWithBar(wxChar* ptr)
{
	wxChar bar = _T('|');
	wxString augBeginMkr = _T("\\w ");
	// Get the marker at ptr, and augment it by appending space - but check first that ptr points at a marker
	// and that it is not pointing at an end marker (since GetWholeMarker will return both marker or endmarker)
	// Then we can be sure that if ptr is pointing at a marker, it is a beginMkr
	wxString wholeMkr = GetWholeMarker(ptr);
	if (wholeMkr.IsEmpty())
	{
		// ptr is not pointing at a marker, whether beginMkr or endMkr
		return FALSE;
	}
	bool bEndMkr = IsEndMarker2(ptr);
	if (bEndMkr)
	{
		// ptr is pointing at an endMkr, we want a beginMkr, so return FALSE
		return FALSE;
	}
	// augment the marker by appending space
	wxString augMkr = wholeMkr + _T(' ');
	// Test for identity with augBeginMkr
	if (augMkr == augBeginMkr)
	{
		// we have a match so scan for a bar, or till enMkr (or some other marker, or doc end
		wxChar* auxPtr = ptr; // make sure we don't alter value of ptr
		// get past the backslash, w, and following space before beginning search
		auxPtr += 2; // we could be pointing at char prior to bar now, but more than one space may precede the bar so code accordingly
		bool bAnotherMkr = FALSE;
		do {
			auxPtr++;
			if (*auxPtr == bar)
			{
				// Found a bar character, so we need to return TRUE immediately
				return TRUE;
			}
			else
			{
				// If bAnotherMkr is TRUE, even if it is the endMkr _T("\\w*"), control getting to the marker
				// means that no bar was present in the span of \w .... \w*, so exit the scan & return FALSE
				bAnotherMkr = IsMarker(auxPtr);
			}
		} while (!IsEnd(auxPtr) && !bAnotherMkr);
	}
	return FALSE; // we didn't find a bar
}

// returns the new updated value for len, and ptr, after parsing over any whitespace
int CAdapt_ItDoc::ParseOverAndIgnoreWhiteSpace(wxChar*& ptr, wxChar* pEnd, int len)
{
	wxChar* pParseStartLoc = ptr;
	wxChar* pParseHaltLoc = NULL;
	while (IsWhiteSpace(ptr) && ptr < pEnd)
	{
		ptr++;
	}
	pParseHaltLoc = ptr;
	if (pParseHaltLoc > pParseStartLoc)
	{
		len += (int)(pParseHaltLoc - pParseStartLoc);
	}
	return len;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
///	\param		useSfmSet	->	which of the three sfm set possibilities we are dealing with
/// \param		filterMkrs	->	concatenated markers (each with a following space) which are
///								the markers formerly unfiltered but now designated by the user
///								as to be filtered,
/// \param		unfilterMkrs ->	concatenated markers (each with a following space) which are
///								the markers formerly filtered but now designated by the user
///								as to be unfiltered.
/// \remarks
/// Called from: the App's DoUsfmFilterChanges(), the Doc's RestoreDocParamsOnInput(),
/// ReconstituteAfterFilteringChange(), RetokenizeText().
/// This is an overloaded version of another function called ResetUSFMFilterStructs.
/// Changes only the USFMAnalysis structs which deal with the markers in the filterMkrs
/// string and the unfilterMkrs string.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::ResetUSFMFilterStructs(enum SfmSet useSfmSet, wxString filterMkrs,
	wxString unfilterMkrs)
{
	// BEW added 25May05 in support of changing filtering settings for USFM, SFM or
	// combined Filtering set The second and third strings must have been set up in the
	// caller by iterating through the map m_FilterStatusMap, which contains associations
	// between the bare marker as key (ie. no backslash or final *) and a literal string
	// which is "1" when the marker is unfiltered and about to be filtered, and "0" when it
	// is filtered and about to be unfiltered. This map is constructed when the user exits
	// the Filter tab of the Preferences or Start Working... wizard.
	MapSfmToUSFMAnalysisStruct* pSfmMap;
	USFMAnalysis* pSfm;
	wxString fullMkr;

	pSfmMap = gpApp->GetCurSfmMap(useSfmSet);

	MapSfmToUSFMAnalysisStruct::iterator iter;
	// enumerate through all markers in pSfmMap and set those markers that occur in the
	// filterMkrs string to the equivalent of filter="1" and those in unfilterMkrs to the
	// equivalent of filter="0"; doing this means that any call of TokenizeText() (or
	// functions which call it such as TokenizeTextString() etc) will, when they get to the
	// LookupSFM(marker) call, get the USFMAnalysis with the filtering settings which need
	// to be in place at the time the lookup is done

	for (iter = pSfmMap->begin(); iter != pSfmMap->end(); ++iter)
	{
		wxString key = iter->first; // use only for inspection
		pSfm = iter->second;
		fullMkr = gSFescapechar + pSfm->marker + _T(' '); // each marker in filterMkrs is
														  // delimited by a space
		if (filterMkrs.Find(fullMkr) != -1)
		{
			pSfm->filter = TRUE;
			// because of how the caller constructs filterMkrs and unfilterMkrs, it is
			// never possible that a marker will be in both these strings, so if we do this
			// block we can skip the next
			continue;
		}
		if (unfilterMkrs.Find(fullMkr) != -1)
		{
			pSfm->filter = FALSE;
		}
	}
	// redo the special fast access marker strings to reflect any changes to pSfm->filter
	// attributes
	gpApp->SetupMarkerStrings();
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
///	\param		useSfmSet	->	which of the three sfm set possibilities we are dealing with
/// \param		filterMkrs	->	concatenated markers (each with a following space) which are
///								the markers formerly unfiltered but now designated by the user
///								as to be filtered,
/// \param		resetMkrs	-> an enum indicating whether to reset allInSet or onlyThoseInString
/// \remarks
/// Called from: the Doc's RestoreDocParamsOnInput().
/// The filterMkrs parameter is a wxString of concatenated markers delimited by following spaces.
/// If resetMkrs == allInSet, ResetUSFMFilterStructs() sets the filter attributes of the
/// appropriate SfmSet of markers to filter="1" if the marker is present in the
/// filterMkrs string, and for all others the filter attribute is set to filter="0"
/// if it is not already zero.
/// If resetMkrs == onlyThoseInString ResetUSFMFilterStructs() sets the filter attributes
/// of the appropriate SfmSet of markers to filter="1" of only those markers which
/// are present in the filterMkrs string.
/// ResetUSFMFilterStructs does nothing to the USFMAnalysis structs nor their
/// maps in response to the presence of unknown markers (filtered or not), since unknown markers
/// do not have any identifiable attributes, except for being considered userCanSetFilter
/// as far as the filterPage is concerned.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::ResetUSFMFilterStructs(enum SfmSet useSfmSet, wxString filterMkrs,
	enum resetMarkers resetMkrs)
{
	// whm added 5Mar2005 in support of USFM and SFM Filtering support
	MapSfmToUSFMAnalysisStruct* pSfmMap;
	USFMAnalysis* pSfm;
	wxString key;
	wxString fullMkr;

	pSfmMap = gpApp->GetCurSfmMap(useSfmSet);

	MapSfmToUSFMAnalysisStruct::iterator iter;
	// enumerate through all markers in pSfmMap and set those markers that
	// occur in the filterMkrs string to filter="1" and, if resetMkrs is allInSet,
	// we also set those that don't occur in filterMkrs to filter="0"

	for (iter = pSfmMap->begin(); iter != pSfmMap->end(); ++iter)
	{
		wxString key = iter->first; // use only for inspection
		pSfm = iter->second;
		fullMkr = gSFescapechar + pSfm->marker + _T(' '); // each marker in filterMkrs
														  // is delimited by a space
		if (filterMkrs.Find(fullMkr) != -1)
		{
			pSfm->filter = TRUE;
		}
		else if (resetMkrs == allInSet)
		{
			pSfm->filter = FALSE;
		}
	}
	// The m_filterFlagsUnkMkrs flags are already changed in the filterPage
	// so they should not be changed (reversed) here

	// redo the special fast access marker strings to reflect any changes to pSfm->filter
	// attributes or the presence of unknown markers
	gpApp->SetupMarkerStrings();
}


///////////////////////////////////////////////////////////////////////////////
/// \return		the whole standard format marker including the initial backslash and any ending *
/// \param		pChar			-> a pointer to the first character of the marker (a backslash)
/// \remarks
/// Called from: the Doc's GetMarkerWithoutBackslash(), IsInLineMarker(), IsCorresEndMarker(),
/// TokenizeText(), the View's RebuildSourceText(), FormatMarkerBufferForOutput(),
/// DoExportInterlinearRTF(), ParseFootnote(), ParseEndnote(), ParseCrossRef(),
/// ProcessAndWriteDestinationText(), ApplyOutputFilterToText(), IsCharacterFormatMarker(),
/// DetermineRTFDestinationMarkerFlagsFromBuffer().
/// Returns the whole standard format marker including the initial backslash and any ending
/// asterisk.
/// BEW 15Sep10, it helps to have a predictable return if pChar on input is not pointing
/// at a backslash - so test and return the empty string. (Better this way for OXES support)
/// BEW 24Oct14, no changes needed for support of USFM nested markers
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::GetWholeMarker(wxChar* pChar)
{
	//if (*pChar != gSFescapechar)
	if (!IsMarker(pChar))
	{
		wxString s; s.Empty();
		return s;
	}
	// whm added 10Feb2005 in support of USFM and SFM Filtering support
	// returns the whole marker including backslash and any ending *
	wxChar* ptr = pChar;
	int itemLen = ParseMarker(ptr);
	return wxString(ptr, itemLen);
}

///////////////////////////////////////////////////////////////////////////////
/// \return		the whole standard format marker including the initial backslash
///             and any ending *
/// \param		str	-> a wxString in which the initial backslash of the marker to be
///					   obtained is at the beginning of the string
/// \remarks
/// Called from: the View's RebuildSourceText(), and many other places
/// Returns the whole standard format marker including the initial backslash and any ending
/// asterisk. Internally uses ParseMarker() just like the version of GetWholeMarker() that
/// uses a pointer to a buffer.
/// BEW 15Sep10, it helps to have a predictable return if pChar on input is not pointing
/// at a backslash - so test and return the empty string. (Better this way for OXES support)
/// BEW 24Oct14, no changes needed for support of USFM nested markers
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::GetWholeMarker(wxString str)
{
	if (str[0] != gSFescapechar)
	{
		wxString s; s.Empty();
		return s;
	}
	// BEW added 2Jun2006 for situations where a marker is at the start of a CString
	// returns the whole marker including backslash and any ending *
	int len = str.Length();
	// wx version note: Since we require a read-only buffer we use GetData which just
	// returns a const wxChar* to the data in the string.
	const wxChar* pChar = str.GetData();
	wxChar* pEnd;
	pEnd = (wxChar*)pChar + len;
	wxChar* pBufStart = (wxChar*)pChar;
	wxASSERT(*pEnd == _T('\0'));
	pEnd = pEnd; // avoid warning
	int itemLen = ParseMarker(pBufStart);
	wxString mkr = wxString(pChar, itemLen);
	return mkr;
}

// BEW added 31May23 for use in propagation code (in TokenizeText)
// return empty string if endMkrs is empty
wxString CAdapt_ItDoc::GetLastEndMarker(wxString endMkrs)
{
	wxString endMkr = wxEmptyString; // init
	if (endMkrs.IsEmpty())
	{
		return endMkr; // empty
	}
	wxString reversed = MakeReverse(endMkrs);
	// Take Left() substring up to first backslash, include backslash in Left()
	int offset = wxNOT_FOUND; // init
	offset = reversed.Find(gSFescapechar);
	if (offset == wxNOT_FOUND)
	{
		// there are no markers in endMkrs
		return endMkr; // still empty
	}
	else
	{
		// Found a backslash
		endMkr = reversed.Left(offset + 1); // include the backslash
		wxASSERT(endMkr.GetChar(0) == _T('*'));
		endMkr = MakeReverse(endMkr);
		wxASSERT(endMkr.GetChar(0) == gSFescapechar);
	}
	return endMkr;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		the standard format marker without the initial backslash, but including
///             any ending *
/// \param		pChar	-> a pointer to the first character of the marker (a backslash)
/// \remarks
/// Called from: the Doc's IsPreviousTextTypeWanted(), GetBareMarkerForLookup(),
/// IsEndMarkerForTextTypeNone(), the View's InsertNullSourcePhrase().
/// Returns the standard format marker without the initial backslash, but includes any end
/// marker asterisk. Internally calls GetWholeMarker().
/// BEW 24Oct14, no changes needed for support of USFM nested markers
/// BEW 7Nov16, Updated for supporting nested TextType none markers, these have
/// + after the backslash; we need to remove the + if present
/// whm 4Sep2023 modified to handle situations where pChar points at string content 
/// that starts with a backslash, but it gets an empty string from GetWholeMakrer(ptr)
/// In this situation with Mkr being an empty string we must protect the GetChar(1)
/// call ensuring that it doesn't get called on an empty string. In this case we don't
/// call GetChar(1) unless the Mkr string has a length >= 2 to avoid an exception crash.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::GetMarkerWithoutBackslash(wxChar* pChar)
{
	// whm added 10Feb2005 in support of USFM and SFM Filtering support
	// Strips off initial backslash but leaves any final asterisk in place.
	// The bare marker string returned is suitable for marker lookup only if
	// it is known that no asterisk is present; if unsure, call
	// GetBareMarkerForLookup() instead.
	wxChar* ptr = pChar;
	if (*pChar == gSFescapechar)
	{
		wxString Mkr = GetWholeMarker(ptr);
		// Check for + after the backslash
		if (Mkr.Length() >=2 && Mkr.GetChar(1) == _T('+'))
		{
			return Mkr.Mid(2); // strip of the initial backslash and the '+'
		}
		else
		{
			return Mkr.Mid(1); // strip off initial backslash
		}
	}
	else
	{
		return wxEmptyString;
	}
}


///////////////////////////////////////////////////////////////////////////////
/// \return		the standard format marker without the initial backslash and
///             without any ending *
/// \param		pChar	-> a pointer to the first character of the marker in the
///                        buffer (a backslash)
/// \remarks
/// Called from: the Doc's IsPreviousTextTypeWanted(), ParseFilteringSFM(), LookupSFM(),
/// AnalyseMarker(), IsEndMarkerForTextTypeNone(), the View's InsertNullSourcePhrase(),
/// DoExportInterlinearRTF(), IsFreeTranslationEndDueToMarker(), HaltCurrentCollection(),
/// ParseFootnote(), ParseEndnote(), ParseCrossRef(), ProcessAndWriteDestinationText(),
/// ApplyOutputFilterToText().
/// Returns the standard format marker without the initial backslash, and without any end
/// marker asterisk. Internally calls GetMarkerWithoutBackslash().
/// BEW 24Oct14, no changes needed for support of USFM nested markers
/// BEW 7Nov16, updated to handle nested markers like \+it and \+it*  If + is present
/// it has to be stripped off too, to get a valid bare tag for lookup purposes
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::GetBareMarkerForLookup(wxChar* pChar)
{
	// whm added 10Feb2005 in support of USFM and SFM Filtering support
	// Strips off initial backslash and any ending asterisk.
	// The bare marker string returned is suitable for marker lookup.
	wxChar* ptr = pChar;
	wxString bareMkr = GetMarkerWithoutBackslash(ptr); // The calls GetWholeMarker()
			// and just returns the result of stripping off the initial backslash,
			// so if + is present, it will be the first character. Check and remove it
	// BEW 29Oct10 protect Get Char(0)
	wxChar first; //= _T('\0'); // initialise BEW dangerous to set to NULL, comment that out
	int length = bareMkr.Len();
	if (length > 0)
	{
		first = bareMkr.GetChar(0); // safe now
		if (first == _T('+'))
		{
			// Only markers which are inline & which we assign TextType value of none
			// can qualify for having \+ before the tag. We've found one such
			bareMkr = bareMkr.Mid(1);
		}
		int posn = bareMkr.Find(_T('*'));
		// The following GetLength() call could on rare occassions return a
		// length of 1051 when processing the \add* marker.
		// whm comment: the reason for the erroneous result from GetLength
		// stems from the problem with the original code used in ParseMarker.
		// (see caution statement in ParseMarker).
		if (posn >= 0)
		{// whm revised 7Jun05
			// strip off asterisk for attribute lookup
			bareMkr = bareMkr.Mid(0, posn);
		}
	}
	else
	{
		// Must be empty string
		return wxEmptyString;
	}
	return bareMkr;
}

// whm 30Nov2023 added.
// An override of above function that gets a bare marker from a whole marker.
// For markers that have a following space and number, such as \c 1 and \v 22
// this function leaves off the following space and number.
// any following space and number
wxString CAdapt_ItDoc::GetBareMarkerForLookup(wxString wholeMkr)
{
	wxString bareMarker;
	bareMarker.Empty();
	int mkrpos = wxNOT_FOUND;
	wholeMkr.Trim(FALSE); // trim any initial space
	// remove the backslash
	mkrpos = wholeMkr.Find(gSFescapechar);
	if (mkrpos != wxNOT_FOUND)
		bareMarker = wholeMkr.Mid(mkrpos + 1);
	else
		bareMarker = wholeMkr; // no gSFescapechar found so wholeMkr is malformed and not really a whole marker, but continue in case a bare marker was imput
	bareMarker.Trim(FALSE); // remove any leading space
	// remove any '+' char after the removed backslash 
	mkrpos = bareMarker.Find(_T("+"));
	if (mkrpos != wxNOT_FOUND)
		bareMarker.Remove(mkrpos, 1);
	bareMarker.Trim(FALSE); // again remove any leading space
	// remove any marker content consisting of a following space and number
	mkrpos = bareMarker.Find(_T(" "));
	if (mkrpos != wxNOT_FOUND)
	{
		// a space follows the bareMarker; remove any space and following number or whatever follows any space
		bareMarker = bareMarker.Mid(0, mkrpos);
	}
	// just to make sure remove any leading and following spaces
	bareMarker.Trim(FALSE);
	bareMarker.Trim(TRUE);
	return bareMarker;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		pMkrList	<- a wxArrayString that holds standard format markers 
/// \param		str			-> the string containing standard format markers and associated text
/// \remarks
/// Called from: the Doc's GetUnknownMarkersFromDoc(), the View's GetMarkerInventoryFromCurrentDoc(),
/// CPlaceInternalMarkers::InitDialog().
/// Scans str and collects all standard format markers (but not their associated text) into
/// pMkrList, one marker per array item (and final endmarker if there is one).
/// whm added str param 18Feb05
/// BEW 24Mar10 no changes needed for support of doc version 5
/// BEW 24Oct14, no changes needed for support of USFM nested markers
/// BEW 25Mar15, some refactoring to fix non-robust marker handling code - it failed
/// when two markers (like \p\v ) occurred in sequence with no intervening space. The
/// function GetMarkerAtBuf() was also similarly changed because it returned nothing
/// when control was pointing at a \p\v sequence.
/// BEW 25Mar15, as well as the above changes, the endmarker detection code in the
/// legacy version of this function was made redundant by the docVersion change at 5
/// if I remember correctly, where endmarkers no longer get stored in m_markers after their
/// corresponding beginmarker, but rather in a separate m_endMarkers member of CSourcePhrase.
/// So we have to look for a matching endmarker in m_endMarkers, rather than in m_markers.
/// whm 22Jan2024 Note: This function doesn't include associated text within the pMkrList
/// items, but only begin and end markers; and does not include the chapter or verse
/// numbers within the markers. I've changed the name of this function from it's original
/// GetMarkersAndTextFromString() to GetMarkersAndEndMarkersFromString() - a function name 
/// which more accurately describes what it actually does.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::GetMarkersAndEndMarkersFromString(wxArrayString* pMkrList, wxString str, wxString endmarkers)
{
	// Populates a wxArrayString containing sfms parsed from the input str. 
	// pMkrList will contain one list item for each marker found in str in order from 
	// beginning of str to end.
	int nLen = str.Length();
	// wx version note: Since we require a read-only buffer we use GetData which just
	// returns a const wxChar* to the data in the string.
	const wxChar* pBuf = str.GetData();
	wxChar* pEnd = (wxChar*)pBuf + nLen; // cast necessary because pBuf is const
	wxASSERT(*pEnd == _T('\0')); // whm added 18Jun06
	wxChar* ptr = (wxChar*)pBuf;
	//wxChar* pBufStart = (wxChar*)pBuf; // BEW 9Sep10, IsMarker() call no longer needs this
	wxString accumStr = _T("");
	// caller needs to call Clear() to start with empty list
	while (ptr < pEnd)
	{
		if (IsFilteredBracketMarker(ptr, pEnd))
		{
			// It's a filtered marker opening bracket. There should always
			// be a corresponding closing bracket, so parse and accumulate
			// chars until end of filterMkrEnd.
			while (ptr < pEnd && !IsFilteredBracketEndMarker(ptr, pEnd))
			{
				accumStr += *ptr;
				ptr++;
			}
			if (ptr < pEnd)
			{
				// accumulate the filterMkrEnd
				// whm 8Jun12 modified for wxWidgets-2.9.3 wxStrlen_() is invalid, use wxStrlen()
				//for (int i = 0; i < (int)wxStrlen_(filterMkrEnd); i++)
				for (int i = 0; i < (int)wxStrlen(filterMkrEnd); i++)
				{
					accumStr += *ptr;
					ptr++;
				}
			}
			accumStr.Trim(FALSE); // trim left end
			accumStr.Trim(TRUE); // trim right end
			// add the filter sfm and associated text to list
			pMkrList->Add(accumStr);
			accumStr.Empty();
		}
		//else if (IsMarker(ptr,pBufStart))
		else if (IsMarker(ptr))
		{
			// It's a non-filtered sfm. Non-filtered sfms can be followed by
			// a corresponding markers or no end markers. We'll parse and
			// accumulate chars until we reach the next marker (or end of buffer).
			// If the marker is a corresponding end marker we'll parse and
			// accumulate it too, otherwise we'll not accumulate it with the
			// current accumStr.
			// First save the marker we are at to check that any end marker
			// that follows is indeed a corresponding end marker.
			wxString currMkr = MarkerAtBufPtr(ptr, pEnd); // BEW 25Mar15, refactored this
			int itemLen;
			//while (ptr < pEnd && *(ptr + 1) != gSFescapechar) <<-- unsafe for a \p\v sequence
			// Must accumulate the backslash being pointed at before entering the loop
			accumStr += *ptr;
			ptr++;
			while (ptr < pEnd && (!IsWhiteSpace(ptr) && *ptr != gSFescapechar))
			{
				accumStr += *ptr;
				ptr++;
			}
			itemLen = ParseWhiteSpace(ptr); // ignore return value
			ptr += itemLen;
			if (itemLen > 0)
				accumStr += _T(' ');
			// BEW 25Mar15, the endmarker code here was made redundant at docVersion 5 (?) and
			// above, because from that point onwards endmarkers are never stored in the
			// m_markers member of a CSourcePhrase. Instead, they are stored in the
			// m_endMarkers member. To get the endmarker showing correctly at the end of
			// the string being composed, we therefore must take the currMkr string found
			// above, append * to make it a 'correponding endmarker' possibility, and search
			// to find out if that putative endmarker is indeed stored in m_endMarkers.
			// If so, we can append it to accumStr

			// If there is a matching endmarker, add it to accumStr too
			if (!endmarkers.IsEmpty())
			{
				int offset = wxNOT_FOUND;
				wxString endMkr = currMkr + _T('*');
				offset = endmarkers.Find(endMkr);
				if (offset != wxNOT_FOUND)
				{
					// A matching endmarker exists on this CSourcePhrase instance
					accumStr += endMkr;
				}
			}
			accumStr.Trim(TRUE); // trim right end
			accumStr.Trim(FALSE); // trim left end
			// add the non-filter sfm and associated text to list
			pMkrList->Add(accumStr);
			accumStr.Empty();
		}
		else
			ptr++;
	} // end of while (ptr < pEnd)
	// We've finished building the wxArrayString
}

// whm 8Jan2024 added. This function is similar to the GetMarkersAndEndMarkersFromString() function
// above, but include any white space following the Marker. 
// The pMkrList will contain a list of all markers and following whitespace, one marker/whitespace
// per list item.
// The str is the input string from pSrcPhrase->m_markers provided by the caller.
// This function is designed to be called from the RemoveDuplicateMarkersFromMkrString() function. 
// It provides that function with an inventory of markers existing in the m_markers member passed
// in here as str. Each marker in the inventory includes any following whitespace (usually a
// space or CR (\r), LF (\n) or combination CRLF \r\n). The RemoveDuplicateMarkersFromMkrString() 
// can then use the information provided from this function to remove duplicate markers from the 
// m_markers input string. Within the RemoveDuplicateMarkersFromMkrString() function, if the 
// marker has following white space and a duplicate marker also has that same white space, the 
// duplicate white space is also removed along with any duplicate marker found in the callers 
// m_markers member.
// Note: filtered markers and end markers are not expected in m_markers and so are not treated
// here.
void CAdapt_ItDoc::GetMarkersAndFollowingWhiteSpaceFromString(wxArrayString& MkrList, wxString str)
{
	// Populates a wxArrayString containing usfm markers and any white space
	// following the marker parsed from the input str. pMkrList will contain one list item for
	// each marker and following white space found in str, in order from beginning of
	// str to end.
	MkrList.Clear();
	int nLen = str.Length();
	// wx version note: Since we require a read-only buffer we use GetData which just
	// returns a const wxChar* to the data in the string.
	const wxChar* pBuf = str.GetData();
	wxChar* pEnd = (wxChar*)pBuf + nLen; // cast necessary because pBuf is const
	wxASSERT(*pEnd == _T('\0')); // whm added 18Jun06
	wxChar* ptr = (wxChar*)pBuf;
	//wxChar* pBufStart = (wxChar*)pBuf; // BEW 9Sep10, IsMarker() call no longer needs this
	wxString accumStr = _T("");
	// caller needs to call Clear() to start with empty list
	while (ptr < pEnd)
	{
		// Filtered markers with brackets are not stored within m_markers
		// an so we won't expect them in str.
		/*
		if (IsFilteredBracketMarker(ptr, pEnd))
		{
			// It's a filtered marker opening bracket. There should always
			// be a corresponding closing bracket, so parse and accumulate
			// chars until end of filterMkrEnd.
			while (ptr < pEnd && !IsFilteredBracketEndMarker(ptr, pEnd))
			{
				accumStr += *ptr;
				ptr++;
			}
			if (ptr < pEnd)
			{
				// accumulate the filterMkrEnd
				// whm 8Jun12 modified for wxWidgets-2.9.3 wxStrlen_() is invalid, use wxStrlen()
				//for (int i = 0; i < (int)wxStrlen_(filterMkrEnd); i++)
				for (int i = 0; i < (int)wxStrlen(filterMkrEnd); i++)
				{
					accumStr += *ptr;
					ptr++;
				}
			}
			accumStr.Trim(FALSE); // trim left end
			accumStr.Trim(TRUE); // trim right end
			// add the filter sfm and associated text to list
			pMkrList->Add(accumStr);
			accumStr.Empty();
		}
		else 
		*/
		if (IsMarker(ptr))
		{
			// We'll parse and accumulate chars until we reach the next marker (or 
			// end of buffer).
			// If the marker is a corresponding end marker we'll parse and
			// accumulate it too, otherwise we'll not accumulate it with the
			// current accumStr.
			// First save the marker we are at to check that any end marker
			// that follows is indeed a corresponding end marker.
			wxString currMkr = MarkerAtBufPtr(ptr, pEnd); // BEW 25Mar15, refactored this
			int itemLen;
			// Must accumulate the backslash being pointed at before entering the loop
			accumStr += *ptr;
			ptr++;
			// The marker could be a \c n or \v n marker which has whitespace as part
			// of the marker itself, wo the while loop below should not stop at whitespace
			// as part of its iteration through the m_marker string.
			// TODO: Is this stopping at whitespace a flaw in the logic of the similar-named
			// GetMarkersAndEndMarkersFromString() function above???
			while (ptr < pEnd && *ptr != gSFescapechar) //while (ptr < pEnd && (!IsWhiteSpace(ptr) && *ptr != gSFescapechar))
			{
				accumStr += *ptr;
				ptr++;
			}
			// If ptr is now pointing at white we accumulate it along with the marker
			itemLen = ParseWhiteSpace(ptr); 
			wxString whiteSp = wxString(ptr, itemLen);
			if (!whiteSp.IsEmpty())
			{
				accumStr += whiteSp;
				ptr += itemLen;
			}
			ptr += itemLen;
			// We don't add any extra space as we don't expect any associated text in m_markers (str)
			//if (itemLen > 0)
			//	accumStr += _T(' ');
			// 
			// BEW 25Mar15, the endmarker code here was made redundant at docVersion 5 (?) and
			// above, because from that point onwards endmarkers are never stored in the
			// m_markers member of a CSourcePhrase. Instead, they are stored in the
			// m_endMarkers member. To get the endmarker showing correctly at the end of
			// the string being composed, we therefore must take the currMkr string found
			// above, append * to make it a 'correponding endmarker' possibility, and search
			// to find out if that putative endmarker is indeed stored in m_endMarkers.
			// If so, we can append it to accumStr

			// End markers are not treated here
			/*
			if (!endmarkers.IsEmpty())
			{
				int offset = wxNOT_FOUND;
				wxString endMkr = currMkr + _T('*');
				offset = endmarkers.Find(endMkr);
				if (offset != wxNOT_FOUND)
				{
					// A matching endmarker exists on this CSourcePhrase instance
					accumStr += endMkr;
				}
			}
			*/
			// accumStr.Trim(TRUE); // Do not trim off any white space from right end!
			accumStr.Trim(FALSE); // trim left end
			// add the non-filter sfm and associated text to list
			MkrList.Add(accumStr);
			accumStr.Empty();
		}
		else
			ptr++;
	} // end of while (ptr < pEnd)
	// We've finished building the wxArrayString
}

///////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there is a filename clash, FALSE if the typed name is unique
///
/// \remarks
/// Get the active document folder's document names into the app class's
/// m_acceptedFilesList and test them against the user's typed filename.
/// Use in OutputFilenameDlg.cpp's OnOK()button handler.
/// Before this protection was added in 22July08, an existing document with lots of
/// adaptation and other work contents already done could be wiped out without warning
/// merely by the user creating a new document with the same name as that document file.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::FilenameClash(wxString& typedName)
{
	gpApp->m_acceptedFilesList.Clear();
	wxString dirPath;
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
		dirPath = gpApp->m_bibleBooksFolderPath;
	else
		dirPath = gpApp->m_curAdaptationsPath;
	bool bOK;
	// whm 8Apr2021 added wxLogNull block below
	{
		wxLogNull logNo;	// eliminates any spurious messages from the system if the wxSetWorkingDirectory() call returns FALSE
		bOK = ::wxSetWorkingDirectory(dirPath); // ignore failures
	} // end of wxLogNull scope
	bOK = bOK; // avoid warning
	wxString docName;
	gpApp->GetPossibleAdaptionDocuments(&gpApp->m_acceptedFilesList, dirPath);
	int offset = -1;

	// remove any .xml or .adt which the user may have added to the passed in filename
	wxString rev = typedName;
	rev = MakeReverse(rev);

	// BEW note 26Apr10, .adt extensions occurred on in versions 1-3, but there is no harm
	// in leaving this line unremoved and similarly the test a little further below
	wxString adtExtn = _T(".adt");

	wxString xmlExtn = _T(".xml");
	adtExtn = MakeReverse(adtExtn);
	adtExtn = MakeReverse(adtExtn);

	// BEW note 26Apr10, these next 6 lines could be removed for versions 4.0.0 onwards,
	// but we'll leave them is they waste very little time, and do no harm
	offset = rev.Find(adtExtn);
	if (offset == 0)
	{
		// it's there, so remove it
		rev = rev.Mid(4);
	}

	offset = rev.Find(xmlExtn);
	if (offset == 0)
	{
		// it's there, so remove it
		rev = rev.Mid(4);
	}
	rev = MakeReverse(rev);
	int len = rev.Length();

	// test for filename clash
	int ct;
	for (ct = 0; ct < (int)gpApp->m_acceptedFilesList.GetCount(); ct++)
	{
		docName = gpApp->m_acceptedFilesList.Item(ct);
		offset = docName.Find(rev);
		if (offset == 0)
		{
			// this one is a candidate for a clash, check further
			int docNameLen = docName.Length();
			if (docNameLen >= len + 1)
			{
				// there is a character at len, so see if it is the . of an extension
				wxChar ch = docName.GetChar(len);
				if (ch == _T('.'))
				{
					// the names clash
					gpApp->m_acceptedFilesList.Clear();
					return TRUE;
				}
			}
			else
			{
				// BEW changed 26Apr10, (to include a 'shorter' option) same length or
				// shorter; if equal then this is a clash and we'll return TRUE and give a
				// beep as well; but if shorter, then it's a different name & we'll accept
				// it by falling through and returning FALSE
				if (docNameLen == len)
				{
					// it's the same name
					::wxBell();
					gpApp->m_acceptedFilesList.Clear();
					return TRUE;
				}
			}
		}
	}
	gpApp->m_acceptedFilesList.Clear();
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a pointer to the USFMAnalysis struct associated with the marker at pChar,
///				or NULL if the marker was not found in the MapSfmToUSFMAnalysisStruct.
/// \param		pChar	-> a pointer to the first character of the marker in the
///                        buffer (a backslash)
/// \remarks
/// Called from: the Doc's ParseWord(), IsMarker(), TokenizeText(), DoMarkerHousekeeping(),
/// IsEndMarkerForTextTypeNone(), the View's InsertNullSourcePhrase(),
/// Determines the marker pointed to at pChar and performs a look up in the
/// MapSfmToUSFMAnalysisStruct hash map. If the marker has an association in the map it
/// returns a pointer to the USFMAnalysis struct. NULL is returned if no marker could be
/// parsed from pChar, or if the marker could not be found in the hash map.
/// BEW 24Oct14 changes needed for support of USFM nested markers
/// whm 23Sep2023 removed the block forcing values for marker "fig". The attribute 
/// values for the \fig marker need to be specified within the AI_USFM.xml control 
/// file rather than the LookupSFM() functions - which I have done as of this date.
/// Note also that the navigationText was already "figure" in AI_USFM.xml which I 
/// think is better than "illustration" below - being shorter for use as navigation 
/// text and, more mnemonic for association with the \fig marker.
///////////////////////////////////////////////////////////////////////////////
USFMAnalysis* CAdapt_ItDoc::LookupSFM(wxChar* pChar)
{
	// Looks up the sfm pointed at by pChar
	// Returns a USFMAnalysis struct filled out with attributes
	// if the marker is found in the appropriate map, otherwise
	// returns NULL.
	// whm ammended 11July05 to return the \bt USFM Analysis struct whenever
	// any bare marker of the form bt... exists at pChar
	wxChar* ptr = pChar;
	bool bFound = FALSE;
	// get the bare marker
	wxString bareMkr = GetBareMarkerForLookup(ptr);
	// look up and Retrieve the USFMAnalysis into our local usfmAnalysis struct
	// variable.
	// If bareMkr begins with bt... we will simply use bt which will return the
	// USFMAnalysis struct for \bt for all back-translation markers based on \bt...
	if (bareMkr.Find(_T("bt")) == 0)
	{
		// bareMkr starts with bt... so shorten it to simply bt for lookup purposes
		bareMkr = _T("bt");
	}
	// BEW 24Oct14, add support here for USFM nested markers, these are of form \+tag
	// so for any such, we have to extract the tag so as to be able to lookup the
	// appropriate struct
	bool bIsNestedMkr = FALSE;
	bool bIsWholeMkr = FALSE;
	wxString baseOfEndMkr;
	wxString theTag; theTag.Empty();
	bIsNestedMkr = IsNestedMarkerOrMarkerTag(&bareMkr, theTag, baseOfEndMkr, bIsWholeMkr);
	wxUnusedVar(bIsNestedMkr); // here we don't need the boolean returned, we just want a lookup
	if (baseOfEndMkr.IsEmpty())
	{
		bareMkr = theTag; // it was not an endmarker
	}
	else
	{
		bareMkr = baseOfEndMkr; // it was an endmarker
	}
	MapSfmToUSFMAnalysisStruct::iterator iter;
	// The particular MapSfmToUSFMAnalysisStruct used for lookup below depends the appropriate
	// sfm set being used as stored in gCurrentSfmSet enum.
	switch (gpApp->gCurrentSfmSet)
	{
	case UsfmOnly:
	{
		iter = gpApp->m_pUsfmStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pUsfmStylesMap->end());
	}
		break;
	case PngOnly:
	{
		iter = gpApp->m_pPngStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pPngStylesMap->end());
	}
		break;
	case UsfmAndPng:
	{
		iter = gpApp->m_pUsfmAndPngStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pUsfmAndPngStylesMap->end());
	}
		break;
	default:
	{
		iter = gpApp->m_pUsfmStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pUsfmStylesMap->end());
	}
	} // end o fo switch (gpApp->gCurrentSfmSet)

	if (bFound)
	{
		// iter->second points to the USFMAnalysis struct

		// BEW 30Sep19 alter some of \fig's attributes, so in USFM3 we can show it's
		// unfiltered caption string with navtext and m_bSpecialText colouring
		USFMAnalysis* pUsfmAnalyis = iter->second;
		wxString bareMkr = pUsfmAnalyis->marker;
		// whm 23Sep2023 removed the following block for marker "fig" that forces the 
		// attribute values locally here. The \fig marker's attributes need to be 
		// specified within the AI_USFM.xml control file, rather than here - which I 
		// have done as of this date.
		// Note also that the navigationText was already "figure" in AI_USFM.xml which I 
		// think is better than "illustration" below - being shorter for use as navigation 
		// text and, more mnemonic for association with the \fig marker for users.
		/*
		if (bareMkr == _T("fig"))
		{
			pUsfmAnalyis->special = TRUE;
			pUsfmAnalyis->bdryOnLast = TRUE;
			pUsfmAnalyis->inform = TRUE;
			pUsfmAnalyis->navigationText = _T("illustration");
		}
		*/
		return pUsfmAnalyis;
	}
	else
	{
		return (USFMAnalysis*)NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a pointer to the USFMAnalysis struct associated with the marker at pChar,
///				or NULL if the marker was not found in the MapSfmToUSFMAnalysisStruct.
/// \param		pChar	      -> a pointer to the first character of the marker in the
///                              buffer (a backslash)
/// \param      tagOnly       <- Whether \tag or \+tag or tag or +tag was passed in, it
///                              returns the tag string here (it may have * at its end)
/// \param      baseOfEndMkr  <- If an endmarker was passed in, it is the tagOnly without the
///                              final * character; if not an endmarker passed in, then
///                              empty string is returned (This can be used as a defacto
///                              test of whether what was passed in was an endmarker or
///                              from an endmarker.)
/// \param      bIsNestedMkr  <- TRUE if of form \+tag, FALSE if of form \tag
/// \remarks
/// Called from: the Doc's ParseWord(), IsMarker(), TokenizeText(), DoMarkerHousekeeping(),
/// IsEndMarkerForTextTypeNone(), the View's InsertNullSourcePhrase(),
/// Determines the marker pointed to at pChar and performs a look up in the
/// MapSfmToUSFMAnalysisStruct hash map. If the marker has an association in the map it
/// returns a pointer to the USFMAnalysis struct. NULL is returned if no marker could be
/// parsed from pChar, or if the marker could not be found in the hash map.
/// BEW 24Oct14 variant useful for support of USFM nested markers, used in ParseWord()
/// whm 23Sep2023 removed the block forcing values for marker "fig". The attribute 
/// values for the \fig marker need to be specified within the AI_USFM.xml control 
/// file rather than the LookupSFM() functions - which I have done as of this date.
/// Note also that the navigationText was already "figure" in AI_USFM.xml which I 
/// think is better than "illustration" below - being shorter for use as navigation 
/// text and, more mnemonic for association with the \fig marker.
///////////////////////////////////////////////////////////////////////////////
USFMAnalysis* CAdapt_ItDoc::LookupSFM(wxChar* pChar, wxString& tagOnly,
	wxString& baseOfEndMkr, bool& bIsNestedMkr)
{
	// Looks up the sfm pointed at by pChar
	// Returns a USFMAnalysis struct filled out with attributes
	// if the marker is found in the appropriate map, otherwise
	// returns NULL.
	// whm ammended 11July05 to return the \bt USFM Analysis struct whenever
	// any bare marker of the form bt... exists at pChar
	wxChar* ptr = pChar;
	bool bFound = FALSE;
	// BEW 9Nov16, There is a years-old error below. bareMkr should NEVER be what
	// is passed to IsNestedMarkerOrMarkerTag() below, because GetBareMarkerForLookup()
	// strips not just the \ and any *, but also the + of a nested marker, and so the
	// function below would, for a \+it marker, return bIsNested set incorrectly to
	// FALSE. So the safe thing to do is to pass it the whole marker.
	wxString aWholeMkr = GetWholeMarker(pChar);
	// get the bare marker
	wxString bareMkr = GetBareMarkerForLookup(ptr);
	// look up and Retrieve the USFMAnalysis into our local usfmAnalysis struct
	// variable.
	// If bareMkr begins with bt... we will simply use bt which will return the
	// USFMAnalysis struct for \bt for all back-translation markers based on \bt...
	if (bareMkr.Find(_T("bt")) == 0)
	{
		// bareMkr starts with bt... so shorten it to simply bt for lookup purposes
		bareMkr = _T("bt");
	}
	// BEW 24Oct14, add support here for USFM nested markers, these are of form \+tag
	// so for any such, we have to extract the tag so as to be able to lookup the
	// appropriate struct, and if a USFM endmarker, remove the * at the end
	bIsNestedMkr = FALSE; // initialize
	bool bIsWholeMkr = FALSE;  // initialize
	wxString theTag; theTag.Empty(); // initialize
	tagOnly.Empty(); baseOfEndMkr.Empty(); // initialize both
	bIsNestedMkr = IsNestedMarkerOrMarkerTag(&aWholeMkr, tagOnly, baseOfEndMkr, bIsWholeMkr);
	wxUnusedVar(bIsWholeMkr);
	if (baseOfEndMkr.IsEmpty())
	{
		bareMkr = tagOnly;
	}
	else
	{
		bareMkr = baseOfEndMkr;
	}
	MapSfmToUSFMAnalysisStruct::iterator iter;
	// The particular MapSfmToUSFMAnalysisStruct used for lookup below depends the appropriate
	// sfm set being used as stored in gCurrentSfmSet enum.
	switch (gpApp->gCurrentSfmSet)
	{
	case UsfmOnly:
	{
		iter = gpApp->m_pUsfmStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pUsfmStylesMap->end());
	}
		break;
	case PngOnly:
	{
		iter = gpApp->m_pPngStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pPngStylesMap->end());
	}
		break;
	case UsfmAndPng:
	{
		iter = gpApp->m_pUsfmAndPngStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pUsfmAndPngStylesMap->end());
	}
		break;
	default:
	{
		iter = gpApp->m_pUsfmStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pUsfmStylesMap->end());
	}
	} // end of switch (gpApp->gCurrentSfmSet)

	if (bFound)
	{
		// iter->second points to the USFMAnalysis struct

		// BEW 30Sep19 alter some of \fig's attributes, so in USFM3 we can show it's
		// unfiltered caption string with navtext and m_bSpecialText colouring
		USFMAnalysis* pUsfmAnalyis = iter->second;
		wxString bareMkr = pUsfmAnalyis->marker;
		// whm 23Sep2023 removed the following block for marker "fig" that forces the 
		// attribute values locally here. The \fig marker's attributes need to be 
		// specified within the AI_USFM.xml control file, rather than here - which I 
		// have done as of this date.
		// Note also that the navigationText was already "figure" in AI_USFM.xml which I 
		// think is better than "illustration" below - being shorter for use as navigation 
		// text and, more mnemonic for association with the \fig marker for users.
		/*
		if (bareMkr == _T("fig"))
		{
			pUsfmAnalyis->special = TRUE;
			pUsfmAnalyis->bdryOnLast = TRUE;
			pUsfmAnalyis->inform = TRUE;
			pUsfmAnalyis->navigationText = _T("illustration");
		}
		*/
		return pUsfmAnalyis;
	}
	else
	{
		return (USFMAnalysis*)NULL;
	}
}



///////////////////////////////////////////////////////////////////////////////
/// \return		a pointer to the USFMAnalysis struct associated with the bareMkr,
///				or NULL if the marker was not found in the MapSfmToUSFMAnalysisStruct.
/// \param		bareMkr	-> a wxString containing the bare marker to use in the lookup
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange(), ParseFilteringSFM(),
/// GetUnknownMarkersFromDoc(), AnalyseMarker(), IsEndingSrcPhrase(),
/// ContainsMarkerToBeFiltered(), RedoNavigationText(), DoExportInterlinearRTF(),
/// IsFreeTranslationEndDueToMarker(), HaltCurrentCollection(), ParseFootnote(),
/// ParseEndnote(), ParseCrossRef(), ParseMarkerAndAnyAssociatedText(),
/// GetMarkerInventoryFromCurrentDoc(), MarkerTakesAnEndMarker(),
/// CViewFilteredMaterialDlg::GetAndShowMarkerDescription().
/// Looks up the bareMkr in the MapSfmToUSFMAnalysisStruct hash map. If the marker has an
/// association in the map it returns a pointer to the USFMAnalysis struct. NULL is
/// returned if the marker could not be found in the hash map.
/// BEW 10Apr10, no changes for support of doc version 5
/// BEW 24Oct14 changes needed for support of USFM nested markers. LookupSFM() does
/// not try to lookup endmarkers, it is intended that TokenizeText() - which calls it,
/// handles the begin markers, and then passes off parsing the word and any endmarkers
/// to ParseWord() - so we don't bother in LookupSFM() to determine if a marker is
/// an endmarker, because it should never encounter any.
/// BEW 24Oct14 refactored for support of USFM nested markers
/// whm 23Sep2023 removed the block forcing values for marker "fig". The attribute 
/// values for the \fig marker need to be specified within the AI_USFM.xml control 
/// file rather than the LookupSFM() functions - which I have done as of this date.
/// Note also that the navigationText was already "figure" in AI_USFM.xml which I 
/// think is better than "illustration" below - being shorter for use as navigation 
/// text and, more mnemonic for association with the \fig marker.
///////////////////////////////////////////////////////////////////////////////
USFMAnalysis* CAdapt_ItDoc::LookupSFM(wxString bareMkr)
{
	// overloaded version of the LookupSFM above to take bare marker
	// Looks up the bareMkr CString sfm in the appropriate map
	// Returns a USFMAnalysis struct filled out with attributes
	// if the marker is found in the appropriate map, otherwise
	// returns NULL.
	// whm ammended 11July05 to return the \bt USFM Analysis struct whenever
	// any bare marker of the form bt... is passed in
	if (bareMkr.IsEmpty())
		return (USFMAnalysis*)NULL;
	bool bFound = FALSE;
	// look up and Retrieve the USFMAnalysis into our local usfmAnalysis struct
	// variable.
	// If bareMkr begins with bt... we will simply use bt which will return the
	// USFMAnalysis struct for \bt for all back-translation markers based on \bt...
	if (bareMkr.Find(_T("bt")) == 0)
	{
		// bareMkr starts with bt... so shorten it to simply bt for lookup purposes
		bareMkr = _T("bt"); // bareMkr is value param so only affects local copy
	}
	// BEW 24Oct14, add support here for USFM nested markers, these are of form \+tag
	// so for any such, we have to extract the tag so as to be able to lookup the
	// appropriaate struct
	bool bIsNestedMkr = FALSE;
	bool bIsWholeMkr = FALSE;
	wxString tagOnly; tagOnly.Empty();
	wxString baseOfEndMkr;
	bIsNestedMkr = IsNestedMarkerOrMarkerTag(&bareMkr, tagOnly, baseOfEndMkr, bIsWholeMkr);
	wxUnusedVar(bIsNestedMkr);
	if (baseOfEndMkr.IsEmpty())
	{
		bareMkr = tagOnly;
	}
	else
	{
		bareMkr = baseOfEndMkr;
	}
	MapSfmToUSFMAnalysisStruct::iterator iter;
	// The particular MapSfmToUSFMAnalysisStruct used for lookup below depends the
	// appropriate sfm set being used as stored in gCurrentSfmSet enum.
	switch (gpApp->gCurrentSfmSet)
	{
	case UsfmOnly:
	{
		iter = gpApp->m_pUsfmStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pUsfmStylesMap->end());
	}
		break;
	case PngOnly:
	{
		iter = gpApp->m_pPngStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pPngStylesMap->end());
	}
		break;
	case UsfmAndPng:
	{
		iter = gpApp->m_pUsfmAndPngStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pUsfmAndPngStylesMap->end());
	}
		break;
	default:
	{
		iter = gpApp->m_pUsfmStylesMap->find(bareMkr);
		bFound = (iter != gpApp->m_pUsfmStylesMap->end());
	}
	} // end of switch (gpApp->gCurrentSfmSet)

	if (bFound)
	{
		// iter->second points to the USFMAnalysis struct

		// BEW 30Sep19 alter some of \fig's attributes, so in USFM3 we can show it's
		// unfiltered caption string with navtext and m_bSpecialText colouring
		USFMAnalysis* pUsfmAnalyis = iter->second;
		wxString bareMkr = pUsfmAnalyis->marker;
		// whm 23Sep2023 removed the following block for marker "fig" that forces the 
		// attribute values locally here. The \fig marker's attributes need to be 
		// specified within the AI_USFM.xml control file, rather than here - which I 
		// have done as of this date.
		// Note also that the navigationText was already "figure" in AI_USFM.xml which I 
		// think is better than "illustration" below - being shorter for use as navigation 
		// text and, more mnemonic for association with the \fig marker for users.
		/*
		if (bareMkr == _T("fig"))
		{
			pUsfmAnalyis->special = TRUE;
			pUsfmAnalyis->bdryOnLast = TRUE;
			pUsfmAnalyis->inform = TRUE;
			pUsfmAnalyis->navigationText = _T("illustration");
		}
		*/
		return pUsfmAnalyis;
	}
	else
	{
		return (USFMAnalysis*)NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the passed-in marker unkMkr exists in any element of the pUnkMarkers
///				array, FALSE otherwise
/// \param		pUnkMarkers		-> a pointer to a wxArrayString that contains a list of
///									markers
/// \param		unkMkr			-> the whole marker being checked to see if it exists
///                                in pUnkMarkers
/// \param		MkrIndex		<- the index into the pUnkMarkers array if unkMkr is
///                                found, otherwise -1
/// \remarks
/// Called from: the Doc's RestoreDocParamsOnInput(), GetUnknownMarkersFromDoc(),
/// CFilterPageCommon::AddUnknownMarkersToDocArrays().
/// Determines if a standard format marker (whole marker including backslash) exists in any
/// element of the array pUnkMarkers.
/// If the whole marker exists, the function returns TRUE and the array's index where the
/// marker was found is returned in MkrIndex. If the marker doesn't exist in the array
/// MkrIndex returns -1.
/// BEW 24Oct14 no changes needed for support of USFM nested markers (note, coding logic
/// errors leading to a nested marker being unrecognised as a USFM would cause the nested
/// marker to end up in pUnkMarkers probably - and be marked as ??\+tag?? in the view)
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::MarkerExistsInArrayString(wxArrayString* pUnkMarkers,
	wxString unkMkr, int& MkrIndex)
{
	// returns TRUE if the passed-in marker unkMkr already exists in the pUnkMarkers
	// array. MkrIndex is the index of the marker returned by reference.
	int ct;
	wxString arrayStr;
	MkrIndex = -1;
	for (ct = 0; ct < (int)pUnkMarkers->GetCount(); ct++)
	{
		arrayStr = pUnkMarkers->Item(ct);
		if (arrayStr.Find(unkMkr) != -1)
		{
			MkrIndex = ct;
			return TRUE;
		}
	}
	// if we get to here we didn't find unkMkr in the array;
	// MkrIndex is still -1 and return FALSE
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the passed-in marker wholeMkr exists in MarkerStr, FALSE otherwise
/// \param		MarkerStr	-> a wxString to be examined
/// \param		wholeMkr	-> the whole marker being checked to see if it exists in MarkerStr
/// \param		markerPos	<- the index into the MarkerStr if wholeMkr is found, otherwise -1
/// \remarks
/// Called twice, but only from: the App's SetupMarkerStrings().
/// Determines if a standard format marker (whole marker including backslash) exists in a
/// given string. If the whole marker exists, the function returns TRUE and the zero-based
/// index into MarkerStr is returned in markerPos. If the marker doesn't exist in the
/// string markerPos returns -1.
/// BEW 24Oct14, the SetupMarkerStrings() calling function builds rapid access wxString
/// marker collections based on the marker definitions in the m_pUsfmAndPngStylesMap, and so
/// knows nothing about USFM nested markers. So, to support USFM nested markers here, nothing
/// needs to be done. We do have rapid access strings not constructed from m_pUsfmAndPngStylesMap,
/// and for those, markes of form \+tag are included when appropriate (that is, only for
/// inline binding and nonbinding markers) - so for those a Find() operation is appropriate,
/// but for the strings made by SetupMarkerStrings(), a Find() should only be done after
/// the tag of a \+tag structured marker has been extracted, and the appropriate equivalent
/// unnested marker form (i.e. \tag ) reconstructed for the Find() lookup.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::MarkerExistsInString(wxString MarkerStr, wxString wholeMkr, int& markerPos)
{
	// returns TRUE if the passed-in marker wholeMkr already exists in the string of
	// markers MarkerStr. markerPos is the position of the wholeMkr in MarkerStr returned
	// by reference.
	markerPos = MarkerStr.Find(wholeMkr);
	if (markerPos != -1)
		return TRUE;
	// if we get to here we didn't find wholeMkr in the string MarkerStr, so markerPos is
	// -1 and return FALSE
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the pUsfmAnalysis represents a filtering marker by default
///				FALSE otherwise. Note this return value DOES NOT indicate what the
///				current filtering status of a marker is, only what its DEFAULT value
///				is as indicated in the AI_USFM.xml control file.
/// \param		pUsfmAnalysis	-> a pointer to a USFMAnalysis struct
/// \remarks
/// Called from: the Doc's TokenizeText().
/// Determines if a USFMAnalysis struct indicates that the associated standard format marker
/// is a filtering marker.
/// Prior to calling IsAFilteringSFM, the caller should have called LookupSFM(wxChar* pChar)
/// or LookupSFM(wxString bareMkr) to populate the pUsfmAnalysis struct, which should then
/// be passed to this function.
/// BEW 24Oct14, no changes for support of USFM nested markers
/// whm 24Oct2023 removed this IsAFilteringSFM() from active use since it has been mis-used
/// due to a mis-understanding. The value returned by this function DOES NOT reliably indicate 
/// the current filtering status of the marker whose properties were determined by a 
/// prior call of LookupSFM(). It only indicates relaibly what the default filter="0" or 
/// filter="1" settings are within the AI_USFM.xml control file. 
/// The most reliable method is by examining whether the sfm marker exists within the 
/// gCurrentFilterMarkers string to determine the current filtering status of a marker.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsAFilteringSFM(USFMAnalysis* pUsfmAnalysis)
{
	// whm added 10Feb2005 in support of USFM and SFM Filtering support
	// whm removed 2nd parameter 9Jun05
	// Prior to calling IsAFilteringSFM, the caller should have called LookupSFM(TCHAR
	// *pChar) or LookupSFM(CString bareMkr) to determine pUsfmAnalysis which should then
	// be passed to this function.

	// Determine the filtering state of the marker
	if (pUsfmAnalysis != NULL)
	{
		// we have a known marker so return its DEFALUT filter status from the USFMAnalysis
		// struct found by previous call to LookupSFM().
		// WARNING: The pUsfmAnalysis->filter property below comes from the AI_USFM.xml 
		// control file and DOES NOT indicate the current filtering status of any USFM 
		// maker!! To get the current filtering status of a USFM marker you must examing 
		// the App's gCurrentFilterMarkers string.
		return (bool)pUsfmAnalysis->filter;
	}
	else
	{
		// the passed in pUsfmAnalysis was NULL so
		return FALSE;
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if unkMkr is both an unknown marker and it also is designated as a
///				filtering marker, FALSE otherwise.
/// \param		unkMkr	-> a bare marker (without a backslash)
/// \remarks
/// Called from: the Doc's AnalyseMarker(), RedoNavigationText().
/// Determines if a marker is both an unknown marker and it also is designated as a
/// filtering marker.
/// unkMKr should be an unknown marker in bare form (without backslash)
/// Returns TRUE if unkMKr exists in the m_unknownMarkers array, and its filter flag
/// in m_filterFlagsUnkMkrs is TRUE.
/// BEW 24Oct14, no changes for support of USFM nested markers. A nested marker always has
/// an known (to the USFM standard) unnested marker associated with it. So if our
/// application's logic handles nested markers correctly, they should never be mistakenly
/// be "unknown", but if one becomes unknown, it will be shown between ?? ?? in the view's
/// whiteboard area - and so would signal that I've some wrong logic which I need to fix.
/// So the appropriate thing to do here is to allow unknown markers with + as their initial
/// character to be treated as unknowns. So make no changes herein.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsAFilteringUnknownSFM(wxString unkMkr)
{
	// unkMKr should be an unknown marker in bare form (without backslash)
	// Returns TRUE if unkMKr exists in the m_unknownMarkers array, and its filter flag
	// in m_filterFlagsUnkMkrs is TRUE.
	int ct;
	unkMkr = gSFescapechar + unkMkr; // add the backslash
	for (ct = 0; ct < (int)gpApp->m_unknownMarkers.GetCount(); ct++)
	{
		if (unkMkr == gpApp->m_unknownMarkers.Item(ct))
		{
			// we've found the unknown marker so check its filter status
			if (gpApp->m_filterFlagsUnkMkrs.Item(ct) == TRUE)
				return TRUE;
		}
	}
	// the unknown marker either wasn't found (an error), or wasn't flagged to be filtered, so
	return FALSE;
}

// BEW 20Oct22 get count of characters from a wrapper character, ( or [ or { , halting when
// pointing at the first following whitespace, or at pEnd if no whites follow. Use this to
// determine a halting place when the input source text being parsed has a missing ) or ] or
// } character. The idea is to provide the missing closing wrapper character prior to the first
// space, to "heal" this kind of data glitch on the user's behalf. It probably would heal most
// such situations, where the missing halter causes one or more extra pSrcPhrase instances to
// appear in the source text, contaianing stuff from what the closing wrapper should have 
// enclosed. Data like    "word(data1 data2)" but the loaded source text has "word(data1 data2"
// instead. For such data, often there is no data2 word or more, just "word(data1"<space>, so
// knowing where that <space> is allows me to put a closing ) or } or ] before it. Then
// the message from something like: IsClosedParenthesisAhead() below can tell the user about
// the healing. If there is a closing wrapper, and data2, data3 not enclosed, editing the 
// source text in the running AI, and moving such words into the wrapped section may allow
// a simple doc fix, once the warning has been seen.
// pChar  ->, must point at ( or } or [
// counter <-, counts including the opening wrapper char, up to but not inclusing the next whitespace
// pEnd   ->, end of document
// return 0 if fails, but the num whitespace chars if scans to one, or to pEnd
void  CAdapt_ItDoc::GetLengthToWhitespace(wxChar* pChar, unsigned int& counter, wxChar* pEnd)
{
	wxChar* ptr = pChar; // initialise
	wxChar openParen = _T('(');
	wxChar openBrace = _T('{');
	wxChar openBracket = _T('[');
	counter = 0; // initialise
	// Sanity check
	if ( !((*ptr == openParen) || (*ptr == openBrace) || (*ptr == openBracket)) )
	{
		return;
	}
	ptr++;
	counter++; // get past the initial wrapper character
	while (!IsWhiteSpace(ptr) && (ptr < pEnd))
	{
		ptr++;
		counter++;
	}
	return;
}

// BEW 18Oct22 added, in support of parsing data like "word(singular person)" The returned
// count value will be the count of all wxChars sanned over, including the initial '(' but
// excluding the closing ')'. If the user's document contains '(' but does not close it off
// with a ')' matching the halt criterion (see comment after bGoodParse below), then we
// return FALSE, without moving pChar forward. I have included a hack to programmatically
// add a closing ), and giving the user an informative message. Remember, when moving the
// the phrasebox on while adapting, ParseWord() gets called within RemovePunctuation(),
// acting on a temporary pSrcPhrase on heap, with its m_nSequNumber set to zero. So when
// IsClosedParenthesisAhead() returns false, control in the caller enters the else block,
// and that's where the programmatic addition of ) happens; but if the sequ number is
// 0, (indicating control is in RemovePunctuation()'s call of ParseWord()) then that
// else block is skipped - as it does nothing useful since that pSrcPhrase is deleted
// before RemovePunctuation() exits
bool CAdapt_ItDoc::IsClosedParenthesisAhead(wxChar* pChar, unsigned int& count, wxChar* pEnd, CSourcePhrase* pSrcPhrase, bool& bTokenizingTargetText)
{
	wxChar* ptr = pChar; // initialise
	wxChar closeParen = _T(')');
	wxChar openParen = _T('(');
	//wxChar space = _T(' '); //assuming Latin space suffices, Asian languages using zwsp 
							// unlikely to have text data enclosed in ( and ), and even
							// if they did, the function would scan over zwsp just fine
	wxASSERT(*ptr == openParen); // gotta start at the open parenthesis
	count = 0;
	unsigned int max = 99;
	unsigned int nCountToWhitespace = 0; // initialise
	unsigned int distance = 0;
	bool bGoodParse = TRUE; // inintialise
	// We scan forward for the halt condition. We don't assume it will be at the first
	// space, or any space for that matter. We halt when ptr points at ')' AND that
	// *(ptr + 1) points at space (probably use IsWhiteSpace() for that test, as it's
	// to be the separation whitespace between the current pSrcPhrase and the next)
	// If, while scanning, ptr points at another openParen before the halt condition is
	// satisfied, then the parse fails.

	// How many chars are available between ptr and pEnd?
	distance = (unsigned int)(pEnd - ptr);
	// get past the opening '('
	ptr++;
	count++;
	while ( (ptr < pEnd) && (*ptr != closeParen) )
	{
		ptr++;
		count++;
		// adjust the max distance, if it exceed the number of chars available ahead
		if (max > distance)
		{
			max = distance;
		}
		if ((*ptr == openParen) || (count > max) || (ptr == pEnd))
		{
			// Try a healing hack, on the assumption that usually the word following the
			// opening '(' is what should have been closed off with a missing ')'
			wxChar* ptr2 = pChar;
			GetLengthToWhitespace(ptr2, nCountToWhitespace, pEnd);
			if (nCountToWhitespace == 0)
			{
				// Hopefully control will never enter here
				wxString title = _("Caution: maybe location lacks closing parenthesis )");
				wxString msg;
				msg = msg.Format(_("Function: %s(): At source word: %s , the text in (...) was too long (max 99), or a closing ) is missing, or document end reached. Adapt It will keep running."),
					__FUNCTION__, pSrcPhrase->m_key.c_str());
				// Don't show the message box, if pSrcPhrase has sn = 0, as is the case when ParseWord()
				// is called in RemovePunctuation(), working on target text, not src text
				if (!(pSrcPhrase->m_nSequNumber == 0 && bTokenizingTargetText == TRUE))
				{
					wxMessageBox(msg, title, wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(msg);
				}
				count = 0; // this keeps ParseWord() from advancing pChar past the '('
				return FALSE;
			}
			else
			{
				// characters were parsed over, so return  count = nCountToWhitespace, then after
				// showing the message below, return FALSE. The caller should then check for FALSE,
				// and if the count value returned is > 0, add a closing '}' character to m_follPunct,
				// and make sure m_srcPhrase will display correctly due to this hack; and do so
				// without advancing ptr, and then return ptr and updated len to TokenizeText immediately
				count = nCountToWhitespace;

				wxString title = _("Warning: a closing ) character was missing");
				wxString msg;
				msg = msg.Format(_("Function: %s(): At source word: %s , a closing parenthesis ) was inserted by Adapt It preceding the next space character. You might need to edit the source text."),
					__FUNCTION__, pSrcPhrase->m_key.c_str());
				// Don't show the message box, if pSrcPhrase has sn = 0, as is the case when ParseWord()
				// is called in RemovePuntuation(), working on target text, not src text
				if (!(pSrcPhrase->m_nSequNumber == 0 && bTokenizingTargetText == TRUE))
				{
					wxMessageBox(msg, title, wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(msg);
				}
				return FALSE;

			} // end of else block for test: if (nLengthToWhitespace == 0)
		}
		// To exit from the loop, ptr should be pointing at ')', so check if the char after
		// ')' is a whitespace, if so the exit the loop - the halt condition is satisfied
		if ((*ptr == closeParen) && IsWhiteSpace(ptr + 1))
		{
			break;
		}
	}
	return bGoodParse;
}

// BEW 21Oct22 added, in support of parsing data like "word{singular person}" The returned
// count value will be the count of all wxChars sanned over, including the initial '{' but
// excluding the closing '}'. If the user's document contains '{' but does not close it off
// with a '}' matching the halt criterion (see comment after bGoodParse below), then we
// return FALSE, without moving pChar forward. I have included a hack to programmatically
// add a closing }, and giving the user an informative message. Remember, when moving the
// the phrasebox on while adapting, ParseWord() gets called within RemovePunctuation(),
// acting on a temporary pSrcPhrase on heap, with its m_nSequNumber set to zero. So when
// IsClosedParenthesisAhead() returns false, control in the caller enters the else block,
// and that's where the programmatic addition of } happens; but if the sequ number is
// 0, (indicating control is in RemovePunctuation()'s call of ParseWord()) then that
// else block is skipped - as it does nothing useful since that pSrcPhrase is deleted
// before RemovePunctuation() exits
bool CAdapt_ItDoc::IsClosedBraceAhead(wxChar* pChar, unsigned int& count, wxChar* pEnd, CSourcePhrase* pSrcPhrase, bool& bTokenizingTargetText)
{
	wxChar* ptr = pChar; // initialise
	wxChar closeBrace = _T('}');
	wxChar openBrace = _T('{');
	//wxChar space = _T(' '); //assuming Latin space suffices, Asian languages using zwsp 
							// unlikely to have text data enclosed in { and }, and even
							// if they did, the function would scan over zwsp just fine
	wxASSERT(*ptr == openBrace); // gotta start at the open brace
	count = 0;
	unsigned int max = 99;
	unsigned int nCountToWhitespace = 0; // initialise
	unsigned int distance = 0;
	bool bGoodParse = TRUE; // inintialise
	// We scan forward for the halt condition. We don't assume it will be at the first
	// space, or any space for that matter. We halt when ptr points at '}' AND that
	// *(ptr + 1) points at space (probably use IsWhiteSpace() for that test, as it's
	// to be the separation whitespace between the current pSrcPhrase and the next)
	// If, while scanning, ptr points at another openBrace before the halt condition is
	// satisfied, then the parse fails.
	ptr++;
	count++; // get past the initial '('
	while ((*ptr != closeBrace) && (ptr < pEnd))
	{
		ptr++;
		count++;

		// How many chars are available between ptr and pEnd?
		distance = (unsigned int)(pEnd - ptr) - 1;
		if (max > distance)
		{
			max = distance;
		}
		if ((*ptr == openBrace) || (count > max) || (ptr == pEnd))
		{
			// Try a healing hack, on the assumption that usually the word following the
			// opening '{' is what should have been closed off with a missing '}'
			wxChar* ptr2 = pChar;
			GetLengthToWhitespace(ptr2, nCountToWhitespace, pEnd);
			if (nCountToWhitespace == 0)
			{
				// Hopefully control will never enter here
				wxString title = _("Caution: maybe location lacks closing brace }");
				wxString msg;
				msg = msg.Format(_("Function: %s(): At source word: %s , the text in {...} was too long (max 99), or a closing } is missing, or document end reached. Adapt It will keep running."),
					__FUNCTION__, pSrcPhrase->m_key.c_str());
				// Don't show the message box, if pSrcPhrase has sn = 0, as is the case when ParseWord()
				// is called in RemovePuntuation(), working on target text, not src text
				if (!(pSrcPhrase->m_nSequNumber == 0 && bTokenizingTargetText == TRUE))
				{
					wxMessageBox(msg, title, wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(msg);
				}
				count = 0; // this keeps ParseWord() from advancing pChar past the '{'
				return FALSE;
			}
			else
			{
				// characters were parsed over, so return  count = nCountToWhitespace, then after
				// showing the message below, return FALSE. The caller should then check for FALSE,
				// and if the count value returned is > 0, add a closing '}' character to m_follPunct,
				// and make sure m_srcPhrase will display correctly due to this hack; and do so
				// without advancing ptr, and then return ptr and updated len to TokenizeText immediately
				count = nCountToWhitespace;

				wxString title = _("Warning: a closing } character was missing");
				wxString msg;
				msg = msg.Format(_("Function: %s(): At source word: %s , a closing brace } was inserted by Adapt It preceding the next space character. You might need to edit the source text."),
					__FUNCTION__, pSrcPhrase->m_key.c_str());
				// Don't show the message box, if pSrcPhrase has sn = 0, as is the case when ParseWord()
				// is called in RemovePuntuation(), working on target text, not src text
				if (!(pSrcPhrase->m_nSequNumber == 0 && bTokenizingTargetText == TRUE))
				{
					wxMessageBox(msg, title, wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(msg);
				}
				return FALSE;

			} // end of else block for test: if (nLengthToWhitespace == 0)
		}
		// To exit from the loop, ptr should be pointing at '}', so check if the char after
		// '}' is a whitespace, if so the exit the loop - the halt condition is satisfied
		if ((*ptr == closeBrace) && IsWhiteSpace(ptr + 1))
		{
			break;
		}
	}
	return bGoodParse;
}

// BEW 21Oct22 added, in support of parsing data like "word[singular person]" The returned
// count value will be the count of all wxChars sanned over, including the initial '[' but
// excluding the closing ']'. If the user's document contains '[' but does not close it off
// with a ']' matching the halt criterion (see comment after bGoodParse below), then we
// return FALSE, without moving pChar forward. I have included a hack to programmatically
// add a closing ], and giving the user an informative message. Remember, when moving the
// the phrasebox on while adapting, ParseWord() gets called within RemovePunctuation(),
// acting on a temporary pSrcPhrase on heap, with its m_nSequNumber set to zero. So when
// IsClosedBracketAhead() returns false, control in the caller enters the else block,
// and that's where the programmatic addition of ] happens; but if the sequ number is
// 0, (indicating control is in RemovePunctuation()'s call of ParseWord()) then that
// else block is skipped - as it does nothing useful since that pSrcPhrase is deleted
// before RemovePunctuation() exits
// Note, since this is almost identical to the two above, I've removed commenting
bool CAdapt_ItDoc::IsClosedBracketAhead(wxChar* pChar, unsigned int& count, wxChar* pEnd, CSourcePhrase* pSrcPhrase, bool& bTokenizingTargetText)
{
	wxChar* ptr = pChar;
	wxChar closeBracket = _T(']');
	wxChar openBracket = _T('[');
	wxASSERT(*ptr == openBracket);
	count = 0;
	unsigned int max = 99;
	unsigned int nCountToWhitespace = 0;
	unsigned int distance = 0;
	bool bGoodParse = TRUE;
	ptr++;
	count++;
	while ((*ptr != closeBracket) && (ptr < pEnd))
	{
		ptr++;
		count++;
		distance = (unsigned int)(pEnd - ptr) - 1;
		if (max > distance)
		{
			max = distance;
		}
		if ((*ptr == openBracket) || (count > max) || (ptr == pEnd))
		{
			wxChar* ptr2 = pChar;
			GetLengthToWhitespace(ptr2, nCountToWhitespace, pEnd);
			if (nCountToWhitespace == 0)
			{
				wxString title = _("Caution: maybe location lacks closing bracket ]");
				wxString msg;
				msg = msg.Format(_("Function: %s(): At source word: %s , the text in [...] was too long (max 99), or a closing ] is missing, or document end reached. Adapt It will keep running."),
					__FUNCTION__, pSrcPhrase->m_key.c_str());
				if (!(pSrcPhrase->m_nSequNumber == 0 && bTokenizingTargetText == TRUE))
				{
					wxMessageBox(msg, title, wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(msg);
				}
				count = 0;
				return FALSE;
			}
			else
			{
				count = nCountToWhitespace;
				wxString title = _("Warning: a closing ] character was missing");
				wxString msg;
				msg = msg.Format(_("Function: %s(): At source word: %s , a closing bracket ] was inserted by Adapt It preceding the next space character. You might need to edit the source text."),
					__FUNCTION__, pSrcPhrase->m_key.c_str());
				if (!(pSrcPhrase->m_nSequNumber == 0 && bTokenizingTargetText == TRUE))
				{
					wxMessageBox(msg, title, wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(msg);
				}
				return FALSE;

			}
		}
		if ((*ptr == closeBracket) && IsWhiteSpace(ptr + 1))
		{
			break;
		}
	}
	return bGoodParse;
}

int CAdapt_ItDoc::CountWhitesSpan(wxChar* pChar, wxChar* pEnd)
{
	int countWhites = 0;
	wxChar* pAux = pChar; // initialise
	// \r and \n are each whitespace characters, so for windows build, each gets counted
	while (IsWhiteSpace(pAux) && (pAux < pEnd))
	{
		countWhites++;
		pAux++;
	}
	return countWhites;
}

// BEW 5Nov20 added for ParseWord(): ptr-> points at ).<space>(<space>nxtwrd, 
// after parsing in TokeniseText() before dealing with following punctuations
// Without a block dedicated to identifying the first space as the word separator,
// the punctuation ").<space>(" wrongly ends up as following punctuation
bool CAdapt_ItDoc::IsOpenParenthesisAhead(wxChar* pChar, wxChar* pEnd)
{
	wxChar* ptr = pChar; // initialise
	wxChar closeParen = _T(')');
	wxChar openParen = _T('(');
	wxChar space = _T(' ');
	// If ptr is not pointing at ) then return FALSE
	if (*ptr != closeParen)
	{
		return FALSE;
	}
	if ((ptr + 1) < pEnd) // ensure there's room to find a ( ahead
	{
		ptr++; // point past the ) character
	}
	else
	{
		// No room
		return FALSE;
	}
	// We allow for a ( character to be as far as 3 characters further; if
	// it isn't found by then, return FALSE; if it is found then return TRUE,
	// but only provided intervening characters are each either a punctuation
	// character or a space.
	int offset = wxNOT_FOUND;
	offset = m_spacelessPuncts.Find(*ptr);
	if (offset == wxNOT_FOUND)
	{
		if (*ptr != space)
		{
			// ptr is not pointing at a punctuation character, nor space
			return FALSE;
		}
	}
	else
	{
		// Found a punctuation character, is it an open parenthesis?
		if (*ptr == openParen)
		{
			// Yes, there is one ahead of the passed in location
			return TRUE;
		}
	}

	// No success yet, so keep looking...
	if ((ptr + 1) < pEnd) // ensure there's room to find a ( ahead
	{
		ptr++;// ptr is now past, say, ). (two characters)
	}
	else
	{
		// No room
		return FALSE;
	}
	// What is at ptr location?
	offset = m_spacelessPuncts.Find(*ptr);
	if (offset == wxNOT_FOUND)
	{
		// ptr is not pointing at punctuation
		if (*ptr != space)
		{
			// ptr is not pointing at punctuation, nor a space
			return FALSE;
		}
	}
	else // ptr is pointing at a punctuation character. 
	{
		// Is it a ( character ?
		if (*ptr == openParen)
		{
			// Yep, there is a ( character ahead
			return TRUE;
		}
	}

	// No success yet, so keep looking...
	if ((ptr + 1) < pEnd) // ensure there's room to find a ( ahead
	{
		ptr++;// ptr is now past, say,<space> ). (three characters)
	}
	else
	{
		// No room
		return FALSE;
	}
	// One last shot... What is at ptr location?
	offset = m_spacelessPuncts.Find(*ptr);
	if (offset == wxNOT_FOUND)
	{
		// ptr is not pointing at punctuation [and ( is a punct char]
		if (*ptr != space)
		{
			// ptr is not pointing at punctuation, nor a space, nor (
			return FALSE;
		}
	}
	else // ptr is pointing at a punctuation character. 
	{
		// Is it a ( character ?
		if (*ptr == openParen)
		{
			// Yep, there is a ( character ahead
			return TRUE;
		}
	}
	// look no further - we assume there's no point in having a 
	// parse of )....( in a block, because we can't be sure that
	// there is an opening parenthesis ahead which makes certain
	// that the parser must call a halt to parsing between the
	// ) and following ( somewhere.
	// This function will be in the caller's test, and if it fails
	// then the block is skipped and legacy code will operate to
	// determine what's punctuation and where the word break will be	
	return FALSE;
}

// BEW 5Nov20 added for ParseWord(): ptr-> points at ).<space>(<space>nxtwrd, 
// after parsing in TokeniseText() before dealing with following punctuations
// Without a block dedicated to identifying the first space as the word separator,
// the punctuation ").<space>(" wrongly ends up as following punctuation
bool CAdapt_ItDoc::IsOpenParenthesisAhead2(wxChar* pChar, wxChar* pEnd)
{
	wxChar* ptr = pChar; // initialise
	//wxChar closeParen = _T(')');
	wxChar openParen = _T('(');
	wxChar space = _T(' ');
	// If ptr is not pointing at ) then return FALSE
	if ((ptr + 1) < pEnd) // ensure there's room to find a ( ahead
	{
		ptr++; // point past the ) character
	}
	else
	{
		// No room
		return FALSE;
	}
	// We allow for a ( character to be as far as 3 characters further; if
	// it isn't found by then, return FALSE; if it is found then return TRUE,
	// but only provided intervening characters are each either a punctuation
	// character or a space.
	int offset = wxNOT_FOUND;
	offset = m_spacelessPuncts.Find(*ptr);
	if (offset == wxNOT_FOUND)
	{
		if (*ptr != space)
		{
			// ptr is not pointing at a punctuation character, nor space
			return FALSE;
		}
	}
	else
	{
		// Found a punctuation character, is it an open parenthesis?
		if (*ptr == openParen)
		{
			// Yes, there is one ahead of the passed in location
			return TRUE;
		}
	}

	// No success yet, so keep looking...
	if ((ptr + 1) < pEnd) // ensure there's room to find a ( ahead
	{
		ptr++;// ptr is now past, say, ). (two characters)
	}
	else
	{
		// No room
		return FALSE;
	}
	// What is at ptr location?
	offset = m_spacelessPuncts.Find(*ptr);
	if (offset == wxNOT_FOUND)
	{
		// ptr is not pointing at punctuation
		if (*ptr != space)
		{
			// ptr is not pointing at punctuation, nor a space
			return FALSE;
		}
	}
	else // ptr is pointing at a punctuation character. 
	{
		// Is it a ( character ?
		if (*ptr == openParen)
		{
			// Yep, there is a ( character ahead
			return TRUE;
		}
	}

	// No success yet, so keep looking...
	if ((ptr + 1) < pEnd) // ensure there's room to find a ( ahead
	{
		ptr++;// ptr is now past, say,<space> ). (three characters)
	}
	else
	{
		// No room
		return FALSE;
	}
	// One last shot... What is at ptr location?
	offset = m_spacelessPuncts.Find(*ptr);
	if (offset == wxNOT_FOUND)
	{
		// ptr is not pointing at punctuation [and ( is a punct char]
		if (*ptr != space)
		{
			// ptr is not pointing at punctuation, nor a space, nor (
			return FALSE;
		}
	}
	else // ptr is pointing at a punctuation character. 
	{
		// Is it a ( character ?
		if (*ptr == openParen)
		{
			// Yep, there is a ( character ahead
			return TRUE;
		}
	}
	// look no further - we assume there's no point in having a 
	// parse of )....( in a block, because we can't be sure that
	// there is an opening parenthesis ahead which makes certain
	// that the parser must call a halt to parsing between the
	// ) and following ( somewhere.
	// This function will be in the caller's test, and if it fails
	// then the block is skipped and legacy code will operate to
	// determine what's punctuation and where the word break will be	
	return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing at a standard format marker, FALSE otherwise
/// \param		pChar		-> a pointer to a character in a buffer
/// \remarks
/// Called from: the Doc's ParseFilteringSFM(), ParseFilteredMarkerText(),
/// GetMarkerAndTextFromString(), TokenizeText(), DoMarkerHousekeeping(), the View's
/// FormatMarkerBufferForOutput(), FormatUnstructuredTextBufferForOutput(),
/// ApplyOutputFilterToText(), ParseMarkerAndAnyAssociatedText(), IsMarkerRTF(), and in
/// Usfm2Oxes class
/// Determines if pChar is pointing at a standard format marker in the given buffer
/// BEW 26Jan11, added test for character after the backslash, that it is alphabetic (this
/// prevents spurious TRUE returns if a \ is followed by whitespace)
/// BEW 31Jan11, made it smarter still
/// BEW 24Oct14, added support for USFM nested markers (\+tag)
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsMarker(wxChar* pChar)
{
	// also use bool IsAnsiLetter(wxChar c) for checking character after backslash is an
	// alphabetic one; and in response to issues Bill raised in any email on Jan 31st about
	// spurious marker match positives, make the test smarter so that more which is not a
	// genuine marker gets rejected (and also, use IsMarker() in ParseWord() etc, rather
	// than testing for *ptr == gSFescapechar)
	if (*pChar == gSFescapechar)
	{
		// reject \n but allow the valid USFM markers \nb \nd \nd* \no \no* \ndx \ndx*
		if (*(pChar + 1) == _T('n'))
		{
			if (IsAnsiLetter(*(pChar + 2)))
			{
				// assume this is one of the allowed USFM characters listed in the above
				// comment
				return TRUE;
			}
			else if (IsWhiteSpace(pChar + 2)) // see helpers.cpp for definition
			{
				// it's an \n escaped linefeed indicator, not an SFM
				return FALSE;
			}
			else
			{
				// the sequence \n followed by some nonalphabetic character nor
				// non-whitespace character is unlikely to be a valid SFM or USFM, so
				// return FALSE here too -- if we later want to make the function more
				// specific, we can put extra tests here
				return FALSE;
			}
		}
		else if (*(pChar + 1) == _T('+') && IsAnsiLetter(*(pChar + 2)))
		{
			// BEW 24Oct14 added support for USFM nested markers
			return TRUE;
		}
		else if (!IsAnsiLetter(*(pChar + 1)))
		{
			return FALSE;
		}
		else
		{
			// after the backslash is an alphabetic character, so assume its a valid marker
			return TRUE;
		}
	}
	else
	{
		// not pointing at a backslash, so it is not a marker
		return FALSE;
	}
}

// BEW 24Oct14 no changes needed for support of USFM nested markers
bool CAdapt_ItDoc::IsMarker(wxString& mkr)
{
	const wxChar* pConstBuff = mkr.GetData();
	wxChar* ptr = (wxChar*)pConstBuff;
	return IsMarker(ptr);
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing at a standard format marker which is also an end
///				marker (ends with an asterisk), FALSE otherwise.
/// \param		pChar	-> a pointer to a character in a buffer
/// \param		pEnd	-> a pointer to the end of the buffer
/// \remarks
/// Called from: the Doc's GetMarkersAndEndMarkersFromString(), AnalyseMarker(), the View's
/// FormatMarkerBufferForOutput(), DoExportInterlinearRTF(), ProcessAndWriteDestinationText(),
/// and helper.cpp's FindSplitLocationForPunctsAndMkrsSubstringsPair().
/// Determines if the marker at pChar is a USFM end marker (ends with an asterisk).
/// BEW added to it, 11Feb10, to handle SFM endmarkers \F or \fe for 'footnote end'
/// BEW added 11Oct10, support for halting at ] bracket
/// BEW 24Oct14, no changes needed for support of USFM nested markers
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsEndMarker(wxChar* pChar, wxChar* pEnd)
{
	// Returns TRUE if pChar points to a marker that ends with *
	wxChar* ptr = pChar;
	// Advance the pointer forward until one of the following conditions ensues:
	// 1. ptr == pEnd (return FALSE)
	// 2. ptr points to a any whitespace character (return FALSE)
	// 3. ptr points to another marker (return FALSE)
	// 4. ptr points to a * (return TRUE)
	// 5. ptr points to a ] (return FALSE)
	// 6. ptr points at \F or \fe and  PngOnly is the marker set being used (return TRUE)

	// First, handle the PngOnly special case of \fe or \F footnote end markers
	if (gpApp->gCurrentSfmSet == PngOnly)
	{
		wxString tempStr1(ptr, 2);
		if (tempStr1 == _T("\\F"))
			return TRUE;
		wxString tempStr2(ptr, 3);
		if (tempStr2 == _T("\\fe"))
			return TRUE;
	}

	// neither of those, so must be USFM endmarker if it is one at all
	while (ptr < pEnd)
	{
		ptr++;
		if (*ptr == _T('*'))
			return TRUE;
		else if (IsWhiteSpace(ptr) || *ptr == gSFescapechar || *ptr == _T(']'))
			return FALSE;
	}
	return FALSE;
}

bool CAdapt_ItDoc::IsEndMarker2(wxChar* pChar)
{
	// Returns TRUE if pChar points to a marker that ends with *
	wxChar* ptr = pChar;
	// Advance the pointer forward until one of the following conditions ensues:
	// 1. ptr == (wxChar*)NULL (return FALSE)
	// 2. ptr points to a any whitespace character (return FALSE)
	// 3. ptr points to another marker (return FALSE)
	// 4. ptr points to a * (return TRUE)
	// 5. ptr points to a ] (return FALSE)
	// 6. ptr points at \F or \fe and  PngOnly is the marker set being used (return TRUE)

	// First, handle the PngOnly special case of \fe or \F footnote end markers
	if (gpApp->gCurrentSfmSet == PngOnly)
	{
		wxString tempStr1(ptr, 2);
		if (tempStr1 == _T("\\F"))
			return TRUE;
		wxString tempStr2(ptr, 3);
		if (tempStr2 == _T("\\fe"))
			return TRUE;
	}

	// neither of those, so must be USFM endmarker if it is one at all
	while (ptr != (wxChar*)NULL)
	{
		ptr++;
		if (*ptr == _T('*'))
			return TRUE;
		else if (IsWhiteSpace(ptr) || *ptr == gSFescapechar || *ptr == _T(']') || ptr == (wxChar*)NULL)
			return FALSE;
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing at a standard format marker which is also
///             an inLine marker (or embedded marker), FALSE otherwise.
/// \param		pChar	-> a pointer to a character in a buffer
/// \param		pEnd	<- currently unused
/// \remarks
/// Called from: the Doc's ParseFilteringSFM(), the View's FormatMarkerBufferForOutput().
/// Determines if the marker at pChar is a USFM inLine marker, i.e., one which is defined
/// in AI_USFM.xml with inLine="1" attribute. InLine markers are primarily "character
/// style" markers and also include all the embedded content markers whose parent markers
/// are footnote, endnotes and crossrefs.
/// BEW 24Oct14, Such markers are typically the ones which potentially may be nested.
/// Therefore, some additions are below to support determining when a nested marker
/// is in-line; nested markers are not enumerated in the USFM standard, but are constructable
/// on-demand from any unnested one by addition of + following the backspace. So our
/// approach here is to determine if the marker at pChar is a nested one, and construct
/// its equivalent legacy associated marker - and use that for the lookup. (Footnote,
/// endnote and crossref markers do not have nested equivalents however, but other inline
/// markers legally may have them.)
/// BEW 24Oct14 additions for support of USFM nested markers
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsInLineMarker(wxChar* pChar, wxChar* WXUNUSED(pEnd))
{
	// Returns TRUE if pChar points to a marker that has inLine="1" [true] attribute
	wxChar* ptr = pChar;
	wxString wholeMkr = GetWholeMarker(ptr);

	// BEW 24Oct14, addition for support of nested UFSM markers (i.e. of form \+tag )
	bool bIsNestedMkr = FALSE;
	bool bIsWholeMkr = TRUE;
	wxString tagOnly; tagOnly.Empty();
	wxString baseOfEndMkr;
	bIsNestedMkr = IsNestedMarkerOrMarkerTag(&wholeMkr, tagOnly, baseOfEndMkr, bIsWholeMkr);
	wxUnusedVar(bIsNestedMkr);
	wxUnusedVar(bIsWholeMkr);
	// Prepare the correct lookup marker string
	wholeMkr = gSFescapechar;
	if (baseOfEndMkr.IsEmpty())
	{
		// not an endmarker, so tagOnly has the wanted tag
		wholeMkr += tagOnly;
	}
	else
	{
		// it was an endmarker, so baseOfEndMkr has the wanted tag
		wholeMkr += baseOfEndMkr;
	}
	// note: no + is present now, if it in fact was a ptr to \+tag passed in

	// end of 24Oct14 addition, and next 3 lines no longer needed
	//int aPos = wholeMkr.Find(_T('*'));
	//if (aPos != -1)
	//	wholeMkr.Remove(aPos,1);
	// whm revised 13Jul05. In order to get an accurate Find of wholeMkr below we
	// need to ensure that the wholeMkr is followed by a space, otherwise Find would
	// give a false positive when wholeMkr is "\b" and the searched string has \bd, \bk
	// \bdit etc.
	wholeMkr.Trim(TRUE); // trim right end
	wholeMkr.Trim(FALSE); // trim left end
	wholeMkr += _T(' '); // ensure wholeMkr has a single final space
	// These rapid access strings don't have nested marker definitions in them, that's
	// why we constructed the whole marker without any + indicating nesting, above
	switch (gpApp->gCurrentSfmSet)
	{
	case UsfmOnly:
	{
		if (gpApp->UsfmInLineMarkersStr.Find(wholeMkr) != -1)
		{
			// it's an inLine marker
			return TRUE;
		}
		break;
	}
	case PngOnly:
	{
		if (gpApp->PngInLineMarkersStr.Find(wholeMkr) != -1)
		{
			// it's an inLine marker
			return TRUE;
		}
		break;
	}
	case UsfmAndPng:
	{
		if (gpApp->UsfmAndPngInLineMarkersStr.Find(wholeMkr) != -1)
		{
			// it's an inLine marker
			return TRUE;
		}
		break;
	}
	default:
	{
		if (gpApp->UsfmInLineMarkersStr.Find(wholeMkr) != -1)
		{
			// it's an inLine marker
			return TRUE;
		}
		break;
	}
	} // end of switch (gpApp->gCurrentSfmSet)
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing at a standard format marker which is also a
///				corresponding end marker for the specified wholeMkr, FALSE otherwise.
/// \param		wholeMkr	-> a wxString containing the marker (including backslash)
/// \param		pChar		-> a pointer to a character in a buffer
/// \param		pEnd		-> a pointer to the end of the buffer
/// \remarks
/// Called from: the Doc's ParseFilteringSFM(), ParseFilteredMarkerText(),
/// GetMarkersAndEndMarkersFromString(), the View's ParseFootnote(), ParseEndnote(),
/// ParseCrossRef(), ProcessAndWriteDestinationText(), ApplyOutputFilterToText()
/// ParseMarkerAndAnyAssociatedText(), and CViewFilteredMaterialDlg::InitDialog().
/// Determines if the marker at pChar is the corresponding end marker for the
/// specified wholeMkr.
/// IsCorresEndMarker returns TRUE if the marker matches wholeMkr and ends with an
/// asterisk. It also returns TRUE if the gCurrentSfmSet is PngOnly and wholeMkr
/// passed in is \f and marker being checked at ptr is \fe or \F.
/// BEW 24Oct14, no changes needed for support of USFM nested markers. (Since
/// this function is used for filtering, and because inline binding and inline
/// nonbinding markers cannot be filtered, it's unlikely this function will
/// be called for wholeMkr being a nested one (ie. of form \+tag ). However, it
/// would handle such correctly without any changes being needed.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsCorresEndMarker(wxString wholeMkr, wxChar* pChar, wxChar* pEnd)
{
	// Returns TRUE if the marker matches wholeMkr and ends with *
	// Also returns TRUE if the gCurrentSfmSet is PngOnly and wholeMkr passed in
	// is \f and marker being checked at ptr is \fe or \F
	wxChar* ptr = pChar;

	// First, handle the PngOnly special case of \fe footnote end marker
	if (gpApp->gCurrentSfmSet == PngOnly && wholeMkr == _T("\\f"))
	{
		wxString tempStr = GetWholeMarker(ptr);
		// debug
		//int len;
		//len = tempStr.Length();
		// debug
		if (tempStr == _T("\\fe") || tempStr == _T("\\F"))
		{
			return TRUE;
		}
	}

	// not a PngOnly footnote situation so do regular USFM check
	// for like a marker ending with *
	int wholeMkrLen = wholeMkr.Length(); // only needs to be calculated once
	for (int i = 0; i < wholeMkrLen; i++)
	{
		if (ptr < pEnd)
		{
			if (*ptr != wholeMkr[i])
				return FALSE;
			ptr++;
		}
		else
			return FALSE;
	}
	// markers match through end of wholeMkr
	if (ptr < pEnd)
	{
		if (*ptr != _T('*'))
			return FALSE;
	}
	// the marker at pChar has an asterisk on it so we have the corresponding end marker
	return TRUE;
}

bool CAdapt_ItDoc::IsLegacyDocVersionForFileSaveAs()
{
	return m_bLegacyDocVersionForSaveAs;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing at a standard format marker which is also a
///				chapter marker (\c ), FALSE otherwise.
/// \param		pChar		-> a pointer to a character in a buffer
/// \remarks
/// Called from: the Doc's TokenizeText(), DoMarkerHousekeeping(),
/// DoExportInterlinearRTF(), DoExportSrcOrTgtRTF().
/// Returns TRUE only if the character following the backslash is a c followed by whitespace,
/// FALSE otherwise. Does not check to see if a number follows the whitespace.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsChapterMarker(wxChar* pChar)
{
	wxChar* ptr = pChar;
	ptr++;
	if (*ptr == _T('c'))
	{
		ptr++;
		return IsWhiteSpace(ptr);
	}
	else
		return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing at a Null character, i.e., (wxChar)0.
/// \param		pChar		-> a pointer to a character in a buffer
/// \remarks
/// Called from: the Doc's ParseWord(), TokenizeText(), DoMarkerHousekeeping(), the View's
/// DoExportSrcOrTgtRTF() and ProcessAndWriteDestinationText().
/// Returns TRUE if the buffer character at pChar is the null character (wxChar)0.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsEnd(wxChar* pChar)
{
	return *pChar == (wxChar)0;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString constructed of the characters from the buffer, starting with the
///				character at ptr and including the next itemLen-1 characters.
/// \param		dest		<- a wxString that gets concatenated with the composed src string
/// \param		src			<- a wxString constructed of the characters from the buffer, starting with the
///								character at ptr and including the next itemLen-1 characters
/// \param		ptr			-> a pointer to a character in a buffer
/// \param		itemLen		-> the number of buffer characters to use in composing the src string
/// \remarks
/// Called from: the Doc's DoMarkerHousekeeping(), ParsePreWord(), and TokenizeText().
/// AppendItem() actually does double duty. It not only returns the wxString constructed from
/// itemLen characters (starting at ptr); it also returns by reference the composed
/// string concatenated to whatever was previously in dest.
/// In actual code, no use is made of the returned wxString of the AppendItem()
/// function itself; only the value returned by reference in dest is used.
/// TODO: Change to a Void function since no use is made of the wxString returned.
/// BEW 13Jul11, the legacy version formed the string including any final \r\n or in other
/// OSes, \n or \r; and we relied on post-processing to remove these as a 'normalization'
/// of the data. But for supporting contentless USFM verses from Paratext, the \r and/or
/// \n are not getting removed which puts vertical white space into the layout - so we may as
/// well test here for final carriage return and or line feed, and remove them from the
/// formed string after itemLen has been used to form it.
/// whm 22Aug2023 revised to remove the "endianness" conditionally compiled code blocks as
/// unneeded.
///////////////////////////////////////////////////////////////////////////////
wxString& CAdapt_ItDoc::AppendItem(wxString& dest, wxString& src, const wxChar* ptr, int itemLen)
{
	src = wxString(ptr, itemLen);

	// whm 22Aug2023 modified. The conditionally compiled code blocks below for __WXMSW__ and the other
	// platforms is not really needed. There is no need to account for endianness is most of our code
	// which doesn't apply to whole wxChar characters, nor to the wxChars indexed within wxStrings.
	// Hence, I'm commenting out the conditional tests below as unneeded. The code is also too
	// dangerous as it attempts to assign null characters to a wxChar buffer. All that is needed is
	// for this function to append the wxString sub-string to the dest wxString and return the src
	// wxString. 
	// According to the comment above the function, the caller of AppendItem() never captures
	// its return value so it could be made into a void function, but I'll not do that for this
	// revision.
	/*
	// BEW added 13Jul11
#ifdef __WXMSW__
	// handle either endianness
	if (itemLen >= 2 && ((*(ptr - 1) == _T('\n') && *(ptr - 2) == _T('\r')) ||
		(*(ptr - 1) == _T('\r') && *(ptr - 2) == _T('\n'))))
	{
		const wxChar* pBuffer = src.GetData();
		wxChar* pBufStart = (wxChar*)pBuffer; // point to start of text
		wxChar* pEnd = pBufStart + itemLen;
		wxASSERT(*pEnd == _T('\0')); // ensure there is a null there
		if (*(pEnd - 1) == _T('\n') || *(pEnd - 1) == _T('\r'))
		{
			*(pEnd - 1) = _T('\0'); // overwrite with a null wxChar
		}
		if (*(pEnd - 2) == _T('\r') || *(pEnd - 2) == _T('\n'))
		{
			*(pEnd - 2) = _T('\0'); // overwrite with a null wxChar
		}
		// whm 12Aug11 removed this UngetWriteBuf() call, which should NEVER be done on a READ-ONLY
		// buffer established with ::GetData().
		//src.UngetWriteBuf(); // cause str's length to be recalculated
	}
#else
	if (itemLen >= 1 && (*(ptr - 1) == _T('\n') || *(ptr - 1) == _T('\r')))
	{
		const wxChar* pBuffer = src.GetData();
		wxChar* pBufStart = (wxChar*)pBuffer; // point to start of text
		wxChar* pEnd = pBufStart + itemLen;
		wxASSERT(*pEnd == _T('\0')); // ensure there is a null there
		if (*(pEnd - 1) == _T('\n') || *(pEnd - 1) == _T('\r'))
		{
			*(pEnd - 1) = _T('\0'); // overwrite with a null wxChar
		}
		// whm 12Aug11 removed this UngetWriteBuf() call, which should NEVER be done on a READ-ONLY
		// buffer established with ::GetData().
		//src.UngetWriteBuf(); // cause str's length to be recalculated
	}
#endif
	*/

	dest += src;
	return src; // whm 22Aug2023 note: This return value could be removed if the function were changed to a void function.
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString constructed of dest + src (with inserted space between them if
///				dest doesn't already end with a space).
/// \param		dest		<- a wxString that gets concatenated with the composed src string
/// \param		src			-> a wxString to be appended/concatenated to dest
/// \remarks
/// Called from: the Doc's TokenizeText().
/// AppendFilteredItem() actually does double duty. It not only returns the wxString src;
/// it also returns by reference in dest the composed/concatenated dest + src (insuring
/// that a space intervenes between unless dest was originally empty.
/// In actual code, no use is made of the returned wxString of the AppendFilteredItem()
/// function itself; only the value returned by reference in dest is used.
/// TODO: Change to a Void function since no use is made of the wxString returned.
///////////////////////////////////////////////////////////////////////////////
wxString& CAdapt_ItDoc::AppendFilteredItem(wxString& dest, wxString& src)
{
	// whm added 11Feb05
	// ensure the filtered item is padded with space if it is not first
	// in dest
	if (!dest.IsEmpty())
	{
		if (dest[dest.Length() - 1] != _T(' '))
			// append a space, but only if there is not already one at the end
			dest += _T(' ');
	}
	dest += src;
	dest += _T(' ');
	return src;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		the wxString starting at ptr and composed of itemLen characters
///             after enclosing the string between \~FILTER and \~FILTER* markers.
/// \param		ptr			-> a pointer to a character in a buffer
/// \param		itemLen		-> the number of buffer characters to use in composing the
///                            bracketed string
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange(), TokenizeText(), and
/// PaarsePostWordStuff().
/// Constructs the string starting at ptr (whose length is itemLen in the buffer); then
/// makes the string a "filtered" item by bracketing it between \~FILTER ... \~FILTER*
/// markers. The passed in string may be just a marker (contentless, and having no
/// following space), or a marker followed by a space and some text content (and possibly
/// then a space and then possibly an endmarker as well)
/// BEW 21Sep10, no change needed for docVersion 5
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::GetFilteredItemBracketed(const wxChar* ptr, int itemLen)
{
	// whm added 11Feb05; BEW changed 06Oct05 to simpify a little and remove the unneeded
	// first argument (which was a CString& -- because it was being called with wholeMkr
	// supplied as that argument's string, which was clobbering the marker in the caller)
	// bracket filtered info with unique markers \~FILTER and \~FILTER*
	// wxString src;
	wxString temp(ptr, itemLen);
	temp.Trim(TRUE); // trim right end
	temp.Trim(FALSE); // trim left end
	//wx version handles embedded new lines correctly
	wxString temp2;
	temp2 << filterMkr << _T(' ') << temp << _T(' ') << filterMkrEnd;
	temp = temp2;
	return temp;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString with any \~FILTER and \~FILTER* filter bracketing markers removed
/// \param		src		-> the string to be processed (which has \~FILTER and \~FILTER* markers)
/// \remarks
/// Called from: the View's IsWrapMarker().
/// Returns the string after removing any \~FILTER ... \~FILTER* filter bracketing markers
/// that exist in the string. Strips out multiple sets of bracketing filter markers if found
/// in the string. If src does not have any \~FILTER and \~FILTER* bracketing markers, src is
/// returned unchanged. Trims off any remaining space at left end of the returned string.
/// BEW 22Feb10, no changes for support of doc version 5
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::GetUnFilteredMarkers(wxString& src)
{
	// whm added 11Feb05
	// If src does not have the unique markers \~FILTER and \~FILTER* we only need return
	// the src unchanged
	// The src may have embedded \n chars in it. Note: Testing shows that use
	// of CString's Find method here, even with embedded \n chars works OK.
	int beginMkrPos = src.Find(filterMkr);
	int endMkrPos = src.Find(filterMkrEnd);
	while (beginMkrPos != -1 && endMkrPos != -1)
	{
		// Filtered material markers exist so we can remove all text between
		// the two filter markers inclusive of the markers. Filtered material
		// is never embedded within other filtered material so we can assume
		// that each sequence of filtered text we encounter can be deleted as
		// we progress linearly from the beginning of the src string to its end.
		wxString temps = filterMkrEnd;
		src.Remove(beginMkrPos, endMkrPos - beginMkrPos + temps.Length());
		beginMkrPos = src.Find(filterMkr);
		endMkrPos = src.Find(filterMkrEnd);
	}
	// Note: The string returned by GetUnFilteredMarkers may have an initial
	// space, which I think would not usually happen in the legacy app before
	// filtering. I have therefore added the following line, which is also
	// probably needed for proper functioning of IsWrapMarker in the View:
	src.Trim(FALSE); // FALSE trims left end only
	return src;
}

/*
///////////////////////////////////////////////////////////////////////////////
/// \return		0 (zero)
/// \remarks
/// Called from: the Doc's TokenizeText(), DoMarkerHousekeeping(),
/// Clear's the App's working buffer.
/// TODO: Eliminate this function and the App's working buffer and just declare and use a local
/// wxString buffer in the two Doc functions that call ClearBuffer(), and the View's version of
/// ClearBuffer().
/// whm 4Sep2023 removed this function along with the buffer on the App
///////////////////////////////////////////////////////////////////////////////
int CAdapt_ItDoc::ClearBuffer()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	pApp->buffer.Empty();
	return 0;
}
*/

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE unless the text in rText contains at least one marker that defines it
///				as "structured" text, in which case returns FALSE
/// \param		rText	-> the string buffer being examined
/// \remarks
/// Called from: the Doc's TokenizeText().
/// Returns TRUE if rText does not have any of the following markers: \id \v \vt \vn \c \p \f \s \q
/// \q1 \q2 \q3 or \x.
/// BEW 24Oct14, no changes needed for support of USFM nested markers. (Lack of \+ does
/// not logically imply that it is not a USFM marked up text.)
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsUnstructuredPlainText(wxString& rText)
// we deem the absence of \id and any of \v \vt \vn \c \p \f \s \q
// \q1 \q2 \q3 or \x standard format markers to be sufficient
// evidence that it is unstructured plain text
{
	wxString s1 = gSFescapechar;
	int nFound = -1;
	wxString s = s1 + _T("id ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \id
	s = s1 + _T("v ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \v
	s = s1 + _T("vn ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \vn
	s = s1 + _T("vt ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \vt
	s = s1 + _T("c ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \c

	// BEW added 10Apr06 to support small test files with just a few markers
	s = s1 + _T("p ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \p
	s = s1 + _T("f ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \f
	s = s1 + _T("s ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \s
	s = s1 + _T("q ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \q
	s = s1 + _T("q1 ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \q1
	s = s1 + _T("q2 ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \q2
	s = s1 + _T("q3 ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \q3
	s = s1 + _T("x ");
	nFound = rText.Find(s);
	if (nFound >= 0)
		return FALSE; // has \x
	// that should be enough, ensuring correct identification <<-- not so 6Dec19
	// of even small test files with only a few SFM markers

	// BEW 6Dec19 It turns out that the 10Apr16	addition is
	// only adequate for parsing small test files - having
	// one of those markers - such as \v marker. It fails to 
	// return the correct result when this function is called in
	// TokenizeTextString() which internally calls TokenizeText(),
	// in the context of a short string with a filterable marker,
	// such as when unfiltering \fig marker. So I have provided
	// the unfilter marker in doc's new member string:
	// m_currentUnfilterMkr. The latter, once the unfiltering
	// loop has gotten the marker, gets the marker copied there
	// so as to be available here when TokenizeTextString() is
	// called. If the marker is a valid one, then we know
	// the data is structured. m_currentUnfilterMkr is cleared
	// to FALSE at the end of each iteration of the unfiltering
	// loop (the user may have requested unfiltering of more
	// than one filtered markers).
	if (m_currentUnfilterMkr.IsEmpty())
	{
		// Either we are not unfiltering, or we are but the filtered
		// data is bad by not having a begin-marker starting the
		// filtered content. In either case, we have no way to avoid
		// returning TRUE - and doing that will prevent USFM3 cache
		// metadata from being mis-handed
		;
	}
	else
	{
		// m_currentUnfilterMkr has a begin marker. That's all we
		// need to know; as even an unknown marker such as \y is
		// considered to be indicative of a USFM structured text.
		// But unstructured text gets \p markers auto-inserted to
		// preserve paragraphing structure, so play safe by excluding
		// \p from consideration here.
		wxString strParagraph(_T("\\p"));
		if (m_currentUnfilterMkr != strParagraph)
		{
			return FALSE;
		}
		// But if they match, returning TRUE is appropriate, so fall thru
	}
	return TRUE; // assume unstructured plain text
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if some character other than end-of-line char(s) (\n and/or \r) is found
///				past the nFound position in rText, otherwise FALSE.
/// \param		rText		-> the string being examined
/// \param		nTextLength	-> the length of the rText string
/// \param		nFound		-> the position in rText beyond which we examine content
/// \remarks
/// Called from: the Doc's AddParagraphMarkers().
/// Determines if there are any characters other than \n or \r beyond the nFound position in
/// rText. Used in AddParagraphMarkers() to add "\p " after each end-of-line in rText.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::NotAtEnd(wxString& rText, const int nTextLength, int nFound)
{
	nFound++; // get past the newline
	if (nFound >= nTextLength - 1)
		return FALSE; // we are at the end

	int index = nFound;
	wxChar ch;
	while ( (index < nTextLength) && ((ch = rText.GetChar(index)) == _T('\r') || (ch = rText.GetChar(index)) == _T('\n')) )
	{
		index++; // skip the carriage return or newline
		if (index >= nTextLength)
			return FALSE; // we have arrived at the end
	}

	return TRUE; // we found some other character before the end was reached
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		rText		-> the string being examined
/// \param		nTextLength	-> the length of the rText string
/// \remarks
/// Called from: the Doc's TokenizeText().
/// Adds "\p " after each end-of-line in rText. The addition of \p markers is done to provide
/// minimal structuring of otherwise "unstructured" text for Adapt It's internal operations.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::AddParagraphMarkers(wxString& rText, int& nTextLength)
{
	// adds \p followed by a space following every \n in the text buffer
	wxString s = gSFescapechar;
	s += _T("p ");
	const wxChar* paragraphMarker = (const wxChar*)s;
	int nFound = 0;
	int nNewLength = nTextLength;
	while (((nFound = FindFromPos(rText, _T("\n"), nFound)) >= 0) &&
		NotAtEnd(rText, nNewLength, nFound))
	{
		nFound++; // point past the newline

		// we are not at the end, so we insert \p here
		rText = InsertInString(rText, nFound, paragraphMarker);
		nNewLength = rText.Length();
	}
	nTextLength = nNewLength;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		pstr	<- the wxString buffer
/// \remarks
/// Called from: the Doc's OnNewDocument(),
/// Removes any existing fixed space ~ in pstr by overwriting it with a space. The
/// processed text is returned by reference in pstr. This function call would normally be
/// followed by a call to RemoveMultipleSpaces() to remove any remaining multiple spaces.
/// In our case, the subsequent call of TokenizeText() in OnNewDocument() discards any
/// extra spaces left by OverwriteUSFMFixedSpaces().
/// BEW 23Nov10, changed to support ~ rather than !$ (the latter is deprecated)
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OverwriteUSFMFixedSpaces(wxString*& pstr)
{
	// whm revised in wx version to have input string by reference in first parameter and
	// to set up a write buffer within this function.
	int len = (*pstr).Length();
	// whm 8Jun12 modified for 2.9.3 use wxStringBuffer.
	// Create the wxStringBuffer in a specially scoped block. This is not crucial here
	// in this function since the wxString never needs to be accessed directly within
	// this function (as *pstr) after the wxStringBuffer is created. It is good practice
	// however to put it within a specially scoped block, in case someone later uses
	// this function as an example of how to set up a wxStringBuffer.
	{ // begin special scoped block
		wxStringBuffer pBuffer((*pstr), len + 1);
		//wxChar* pBuffer = (*pstr).GetWriteBuf(len + 1);
		wxChar* pBufStart = pBuffer;
		wxChar* pEnd = pBufStart + len;
		wxASSERT(*pEnd == _T('\0'));
		wxChar* ptr = pBuffer;
		while (ptr < pEnd)
		{
			if (*ptr == _T('~'))
			{
				// we are pointing at an instance of ~,
				// so overwrite it and continue processing
				*ptr++ = _T(' ');
			}
			else
			{
				ptr++;
			}
		}
		// whm len should not have changed, just release the buffer
	} // end special scoped block - (*pstr) is put back into a normal state at this point
	//(*pstr).UngetWriteBuf(); // whm 8Jun12 removed - not needed with wxStringBuffer above
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		pstr	<- the wxString buffer
/// \remarks
/// Called from: the Doc's OnNewDocument(),
/// Removes any existing discretionary line break // sequences in pstr by overwriting the
/// sequence with spaces. The processed text is returned by reference in pstr.
/// This function call would normally be followed by a call to RemoveMultipleSpaces() to
/// remove any remaining multiple spaces. In our case, the subsequent call of
/// TokenizeText() in OnNewDocument() discards any extra spaces left by
/// .OverwriteUSFMDiscretionaryLineBreaks().
void CAdapt_ItDoc::OverwriteUSFMDiscretionaryLineBreaks(wxString*& pstr)
{
	int len = (*pstr).Length();
	// whm 8Jun12 modified for 2.9.3 use wxStringBuffer
	// Create the wxStringBuffer in a specially scoped block. This is not crucial here
	// in this function since the wxString never needs to be accessed directly within
	// this function (as *pstr) after the wxStringBuffer is created. It is good practice
	// however to put it within a specially scoped block, in case someone later uses
	// this function as an example of how to set up a wxStringBuffer.
	{ // begin special scoped block
		wxStringBuffer pBuffer((*pstr), len + 1);

		//wxChar* pBuffer = (*pstr).GetWriteBuf(len + 1);
		wxChar* pBufStart = pBuffer;
		wxChar* pEnd = pBufStart + len;
		wxASSERT(*pEnd == _T('\0'));
		wxChar* ptr = pBuffer;
		while (ptr < pEnd)
		{
			if (wxStrncmp(ptr, _T("//"), 2) == 0)
			{
				// we are pointing at an instance of //,
				// so overwrite it and continue processing
				*ptr++ = _T(' ');
				*ptr++ = _T(' ');
			}
			else
			{
				ptr++;
			}
		}
		// whm len should not have changed, just release the buffer
	} // end special scoped block - (*pstr) is put back into a normal state at this point
	//(*pstr).UngetWriteBuf(); // whm 8Jun12 removed - not needed with wxStringBuffer above
}

#ifndef __WXMSW__
#ifndef _UNICODE
///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		pstr	<- the wxString buffer
/// \remarks
/// Called from: the Doc's OnNewDocument().
/// Changes MS Word "smart quotes" to regular quotes. The character values for smart quotes
/// are negative (-108, -109, -110, and -111). Warns the user if other negative character
/// values are encountered in the text, i.e., that he should use TecKit to convert the data
/// to Unicode then use the Unicode version of Adapt It.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OverwriteSmartQuotesWithRegularQuotes(wxString*& pstr)
{
	// whm added 12Apr2007
	bool hackedFontCharPresent = FALSE;
	int hackedCt = 0;
	wxString hackedStr;
	hackedStr.Empty();
	int len = (*pstr).Length();
	// whm 8Jun12 modified for 2.9.3 use wxStringBuffer
	// Create the wxStringBuffer in a specially scoped block. This is not crucial here
	// in this function since the wxString never needs to be accessed directly within
	// this function (as *pstr) after the wxStringBuffer is created. It is good practice
	// however to put it within a specially scoped block, in case someone later uses
	// this function as an example of how to set up a wxStringBuffer.
	{ // begin special scoped block
		wxStringBuffer pBuffer((*pstr), len + 1);
		//wxChar* pBuffer = (*pstr).GetWriteBuf(len + 1);
		wxChar* pBufStart = pBuffer;
		wxChar* pEnd = pBufStart + len;
		wxASSERT(*pEnd == _T('\0'));
		wxChar* ptr = pBuffer;
		while (ptr < pEnd)
		{
			if (*ptr == -111) // left single smart quotation mark
			{
				// we are pointing at a left single smart quote mark, so convert it to a regular single quote mark
				*ptr++ = _T('\'');
			}
			else if (*ptr == -110) // right single smart quotation mark
			{
				// we are pointing at a right single smart quote mark, so convert it to a regular single quote mark
				*ptr++ = _T('\'');
			}
			else if (*ptr == -109) // left double smart quotation mark
			{
				// we are pointing at a left double smart quote mark, so convert it to a regular double quote mark
				*ptr++ = _T('\'');
			}
			else if (*ptr == -108) // right double smart quotation mark
			{
				// we are pointing at a left double smart quote mark, so convert it to a regular double quote mark
				*ptr++ = _T('\'');
			}
			else if (*ptr < 0)
			{
				// there is a hacked 8-bit character besides smart quotes. Warn user that the data will not
				// display correctly in this version, that he should use TecKit to convert the data to Unicode
				// then use the Unicode version of Adapt It
				hackedFontCharPresent = TRUE;
				hackedCt++;
				if (hackedCt < 10)
				{
					int charValue = (int)(*ptr);
					hackedStr += _T("\n   character with ASCII value: ");
					hackedStr << (charValue + 256);
				}
				else if (hackedCt == 10)
					hackedStr += _T("...\n");
				ptr++; // advance but don't change the char (we warn user below)
			}
			else
			{
				ptr++;
			}
		}
		// whm len should not have changed, just release the buffer
	} // end special scoped block - (*pstr) is put back into a normal state at this point
	//(*pstr).UngetWriteBuf(); // whm 8Jun12 removed - not needed with wxStringBuffer above

	// In this case we should warn every time a new doc is input that has the hacked chars
	// so we don't test for  && !gbHackedDataCharWarningGiven here.
	if (hackedFontCharPresent)
	{
		gbHackedDataCharWarningGiven = TRUE;
		wxString msg2 = _("\nYou should not use this non-Unicode version of Adapt It.\nYour data should first be converted to Unicode using TecKit\nand then you should use the Unicode version of Adapt It.");
		wxString msg1 = _("Extended 8-bit ASCII characters were detected in your\ninput document:");
		msg1 += hackedStr + msg2;
		wxMessageBox(msg1, _("Warning: Invalid Characters Detected"), wxICON_EXCLAMATION | wxOK);
	}
}
#endif
#endif


///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the passed in (U)SFM marker is \free, \note, or \bt or a derivative
///             FALSE otherwise
/// \param		mkr                     ->  the augmented marker (augmented means it ends with a space)
/// \param      bIsForeignBackTransMkr  <-  default FALSE, TRUE if the marker is \btxxx
///                                         where xxx is one or more non-whitespace
///                                         characters (such as \btv 'back trans of
///                                         verse', \bts 'back trans of subtitle' or
///                                         whatever - Bob Eaton uses such markers in SAG)
/// \remarks
/// Called from: the Doc's TokenizeText().
/// Test for one of the custom Adapt It markers which require the filtered information to
/// be stored on m_freeTrans, m_note, or m_collectedBackTrans string members used for
/// document version 5 (see docVersion in the xml)
///
/// BEW modified 19Feb10 for support of doc version = 5. Bob Eaton's markers will be
/// parsed, and when identified, will be wrapped with filterMkr and filterMkrEnd, and
/// stored in m_filteredInfo; and got from there for any exports where requested; but
/// Adapt It will no longer attempt to treat such foreign markers as "collected", it will
/// just ignore them - but they will be displayed in the Filtered Information dialog.
/// Adapt It's \bt marker will have its content stored in m_collectedBackTrans member
/// instead, and without any preceding \bt. So the added parameter allows us to determine
/// when we are parsing a marker starting with \bt but is not our own because of extra
/// characters in it.
/// BEW 24Oct14, no changes needed for support of USFM nested markers - because these
/// three marker types are never nested, and so \+free, \+note, \+bt etc will never
/// occur in valid USFM marked up text
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsMarkerFreeTransOrNoteOrBackTrans(const wxString& mkr, bool& bIsForeignBackTransMkr)
{
	bIsForeignBackTransMkr = FALSE; // initialize to default value
	if (mkr == _T("\\free "))
	{
		return TRUE;
	}
	else if (mkr == _T("\\note "))
	{
		return TRUE;
	}
	else
	{
		int offset = mkr.Find(_T("\\bt"));
		if (offset == 0)
		{
			// check for whether it is our own, or a foreign back trans marker
			int length = mkr.Len();
			if (length > 4)
			{
				// it has at least one extra character before the final space,
				// so it is a foreign one
				bIsForeignBackTransMkr = TRUE;
			}
			return TRUE;
		}
	}
	return FALSE;
}

// BEW March 2010 for support of doc version 5
void CAdapt_ItDoc::SetFreeTransOrNoteOrBackTrans(const wxString& mkr, wxChar* ptr,
	size_t itemLen, CSourcePhrase* pSrcPhrase)
{
	// if it is one of the three custom markers, set the relevent
	// CSourcePhrase member directly here
	wxString filterStr(ptr, (size_t)itemLen);
	size_t len;
	wxChar aChar;
	if (mkr == _T("\\free"))
	{
		filterStr = filterStr.Mid(6); // start from after "\free "
		// remove |@number@| string -- don't bother to return the number value because it
		// is done later in TokenizeText() after this present function returns
		int nFound = filterStr.Find(_T("|@"));
		if (nFound != wxNOT_FOUND)
		{
			// there is the src word count number substring present, remove it and its
			// following space
			int nFound2 = filterStr.Find(_T("@| "));
			wxASSERT(nFound2 - nFound < 10);
			filterStr.Remove(nFound, nFound2 + 3 - nFound);
		}
		len = filterStr.Len();
		// end of filterStr will be "\free*" == 6 characters
		filterStr = filterStr.Left((size_t)len - 6);
		// it may also end in a space now, so remove it if there
		filterStr.Trim();
		// we now have the free translation text, so store it
		pSrcPhrase->SetFreeTrans(filterStr);
	}
	else if (mkr == _T("\\note"))
	{
		filterStr = filterStr.Mid(6); // start from after "\note "
		len = filterStr.Len();
		// end of filterStr will be "\note*" == 6 characters
		filterStr = filterStr.Left((size_t)len - 6);
		// it may also end in a space now, so remove it if there
		filterStr.Trim();
		// we now have the note text, so store it
		pSrcPhrase->SetNote(filterStr);
	}
	else
	{
		// could be \bt, or longer markers beginning with those 3 chars
		wxASSERT(!filterStr.IsEmpty()); // whm 11Jun12 added. GetChar(0) should never be called on an empty string
		int fLen = filterStr.Len();
		if (fLen > 0)
		{
			aChar = filterStr.GetChar(0);
			while (!IsWhiteSpace(&aChar))
			{
				// trim off from the front the marker info, a character at
				// a time
				filterStr = filterStr.Mid(1);
				aChar = filterStr.GetChar(0);
			}
			filterStr.Trim(FALSE); // trim any initial white space
			// it may also end in a space now, so remove it if there
			filterStr.Trim();
			// we now have the back trans text, so store it
			pSrcPhrase->SetCollectedBackTrans(filterStr);
		}
		else
		{
			pSrcPhrase->SetCollectedBackTrans(wxEmptyString);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		pointer to the rest of the input text yet to be parsed
/// \param		ptr			->  ptr to input text, pointing at the next character
///							    after ]
/// \param		pSrcPhrase	->  the CSourcePhrase instance which will store the ] and
///								any punctuation immediately following it
/// \remarks
/// The character sequence, ]"<newline>\s caused a misparse leading to an assert tripping
/// in ParseWord(). The former algorithm of putting only the ] on the pSrcPhrase is
/// deficient. Instead, ] and any puncts after it are to be stored, stop parsing at
/// next whitespace or marker - whichever is first.
/// We assume that punctuation after a ] is only going to be word-final, that is, not
/// belonging to an input word which follows the ] somewhere; and we also assume that
/// a following word will not abutt the preceding ] character
wxChar* CAdapt_ItDoc::HandlePostBracketPunctuation(wxChar* ptr, CSourcePhrase* pSrcPhrase, bool bParsingSrcText)
{
	wxASSERT(*(ptr - 1) == _T(']')); // check ptr is pointing to character after the ] character
	wxChar* p = ptr;
	bool bIsWhitespace = IsWhiteSpace(p);
	bool bIsPunctuation = IsPunctuation(p, bParsingSrcText);
	bool bIsMkr = IsMarker(p);

	while (!bIsWhitespace && !bIsMkr & bIsPunctuation)
	{
		pSrcPhrase->m_follPunct += *p; // store it
		p++; // point at the next character

		bIsWhitespace = IsWhiteSpace(p);
		bIsPunctuation = IsPunctuation(p, bParsingSrcText);
		bIsMkr = IsMarker(p);
	}
	// Provided p is not pointing at a marker, check the possibility that there
	// maybe a further closing curly quote or doublequote (with an intervening
	// space) also following the punctuation characters currently scanned over
	// and saved. If there is, add them to m_follPunct too
	if (!bIsMkr)
	{
		if (!IsEnd(p) && (*p == _T(' ')))
		{
			if (!IsEnd(p + 1L) && IsClosingCurlyQuote(p + 1L))
			{
				// We've a detached closing single or doublequote, so add it in
				// along with the preceding space
				pSrcPhrase->m_follPunct += *p; // the space
				pSrcPhrase->m_follPunct += *(p + 1L); // the curly endquote
				p = p + 2L;
			}
		}
	}
	return p;
}


// We can use this for testing whether the xref span lies before the word or phrase, or
// after it. It's a helper for filtering cross references, so we can determine what kind
// of metadata information to included in the filtered xref string - whether, when
// unfiltering, to restore to pre-word position, or to post word position.
// BEW 30Sep19 created
bool CAdapt_ItDoc::IsXRefNext(wxChar* ptr, wxChar* pEnd) // does a \x marker occur at ptr?
{
	if ((ptr + 20) >= pEnd)
	{
		// not enough space for a xref 
		return FALSE;
	}
	if (*ptr != gSFescapechar)
	{
		return FALSE;
	}
	wxString wholeMkr = GetWholeMarker(ptr);
	wxString augmentedWholeMkr = wholeMkr + _T(' ');
	wxString xref = _T("\\x ");
	return augmentedWholeMkr == xref;
}

wxString CAdapt_ItDoc::FindWordBreakChar(wxChar* ptr, wxChar* pBufStart)
{
	wxUnusedVar(pBufStart); // avoid gcc warning
	wxString strReturn; strReturn = wxEmptyString; // initialize to a "safe" value
	wxChar* pSpann; pSpann = ptr; wxUnusedVar(pSpann);
	wxString mySpan;
	mySpan = wxEmptyString; // init
	// BEW 22Mar23, MUST not return a NULL. pBufStart is a small local span, typically starting with
	// a begin mkr. So what we want to return is the first whitespace earlier than pBufStart, which is
	// where ptr starts off pointing at as well.
	// BEW 13JUL23 the code can currently insert NULL when these no whitespace to grab, so probably the
	// best thing to do is to remove NULL from the function, turn chReturn into strReturn and initialise
	// it to empty string, and handle initial values of other values similarly
	wxChar* pTemp = ptr; // don't corrupt ptr value
	wxChar chLast1 = *(pTemp - 1);
	bool bIsWhitespace = FALSE;
	bIsWhitespace = IsWhiteSpace(pTemp - 1);
	if (bIsWhitespace)
	{
		return (wxString)chLast1;
	}
	else
	{
		mySpan = wxEmptyString;
		return strReturn;
	}
}

// return TRUE if we have an empty CSourcePhrase which has a verse marker and verse number (actually,
// tokBuffer will have the verse marker and number at the time this function is called),
// and a following \p or other marker without content (also in tokBuffer), and ptr is pointing at the
// \v of the next verse. We can get such a situation, for example, if merging to a
// document with some empty CSourcePhrase instances which come from Paratext empty verse
// markers, and the data for merging has an introduced \p marker (or other contentless
// marker) between the empty markers -- without this function, the legacy parser would
// accumulate the preceding \v, verse number, \p, and following \v into the one
// CSourcePhrase, effectively removing the earlier verse from the merged source text
bool CAdapt_ItDoc::ForceAnEmptyUSFMBreakHere(wxString tokBuffer,
	CSourcePhrase* pSrcPhrase, wxChar* ptr)
{
	// the condition for returning TRUE is:
	// 1. tokBuffer has a \v in it already AND
	// 2. ptr points at a \v marker AND
	// 3. m_key is still empty
	wxString aVerseMkr = _T("\\v");
	int offset = tokBuffer.Find(aVerseMkr);
	int nCount = 0;
	if (offset != wxNOT_FOUND && pSrcPhrase->m_key.IsEmpty() && IsVerseMarker(ptr, nCount))
	{
		if (nCount == 2 || nCount == 3)
		{
			// it's a verse marker, ie either \v or \vn
			return TRUE;
		}
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		useSfmSet		-> an enum of type SfmSet: UsfmOnly, PngOnly, or UsfmAndPng
/// \param		pUnkMarkers		<- a wxArrayString that gets populated with unknown (whole) markers,
///									always populated in parallel with pUnkMkrsFlags.
/// \param		pUnkMkrsFlags	<- a wxArrayInt of flags that gets populated with ones or zeros,
///									always populated in parallel with pUnkMarkers.
/// \param		unkMkrsStr		-> a wxString containing the current unknown (whole) markers within
///									the string - the markers are delimited by spaces following each
///									whole marker.
/// \param		mkrInitStatus	-> an enum of type SetInitialFilterStatus: setAllUnfiltered,
///									setAllFiltered, useCurrentUnkMkrFilterStatus, or
///									preserveUnkMkrFilterStatusInDoc
/// \remarks
/// Called from: the Doc's OnNewDocument(), CFilterPageCommon::AddUnknownMarkersToDocArrays()
/// and CFilterPagePrefs::OnOK().
/// Scans all the doc's source phrase m_markers and m_filteredInfo members and inventories
/// all the unknown markers used in the current document; it stores all unique markers in
/// pUnkMarkers, stores a flag (1 or 0) indicating the filtering status of the marker in
/// pUnkMkrsFlags, and maintains a string called unkMkrsStr which contains the unknown
/// markers delimited by following spaces.
/// An unknown marker may occur more than once in a given document, but is only stored once
/// in the unknown marker inventory arrays and string.
/// The SetInitialFilterStatus enum values can be used as follows:
///	  The setAllUnfiltered enum would gather the unknown markers into m_unknownMarkers
///      and set them all to unfiltered state in m_filterFlagsUnkMkrs (currently
///      unused);
///	  The setAllFiltered could be used to gather the unknown markers and set them all to
///      filtered state (currently unused);
///	  The useCurrentUnkMkrFilterStatus would gather the markers and use any currently
///      listed filter state for unknown markers it already knows about (by inspecting
///     m_filterFlagsUnkMkrs), but process any other "new" unknown markers as unfiltered.
///   The preserveUnkMkrFilterStatusInDoc causes GetUnknownMarkersFromDoc to preserve
///     the filter state of an unknown marker in the Doc, i.e., set m_filterFlagsUnkMkrs
///     to TRUE if the unknown marker in the Doc was within \~FILTER ... \~FILTER* brackets,
///     otherwise sets the flag in the array to FALSE.
/// BEW 24Mar10 updated for support of doc version 5 (some changes were needed)
/// BEW 25Mar15, added 3rd argument to GetMarkersAndEndMarkersFromString() to accomodate the fact
/// that in recent versions (docVersion >= 5?) endmarkers are no longer stored in m_markers
/// but in m_endMarkers
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::GetUnknownMarkersFromDoc(enum SfmSet useSfmSet,
	wxArrayString* pUnkMarkers,
	wxArrayInt* pUnkMkrsFlags,
	wxString& unkMkrsStr,
	enum SetInitialFilterStatus mkrInitStatus)
{
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	SPList* pList = gpApp->m_pSourcePhrases;
	wxArrayString MarkerList; // gets filled with all the currently used markers including
							// filtered ones
	wxArrayString* pMarkerList = &MarkerList;

	// save the previous state of m_unknownMarkers and m_filterFlagsUnkMkrs to be able to
	// restore any previously set filter settings for the unknown markers, i.e., when the
	// useCurrentUnkMkrFilterStatus enum parameter is passed-in.
	wxArrayString saveUnknownMarkers;
	// wxArrayString does not have a ::Copy method like MFC's CStringArray::Copy, so we'll
	// do it by brute force CStringArray::Copy removes any existing items in the
	// saveUnknownMarkers array before copying all items from the m_unknownMarkers array
	// into it.
	saveUnknownMarkers.Clear();// start with an empty array
	int act;
	for (act = 0; act < (int)gpApp->m_unknownMarkers.GetCount(); act++)
	{
		// copy all items from m_unknownMarkers into saveUnknownMarkers note: do NOT use
		// subscript notation to avoid assert; i.e., do not use saveUnknownMarkers[act] =
		// gpApp->m_unknownMarkers[act]; instead use form below
		saveUnknownMarkers.Add(gpApp->m_unknownMarkers.Item(act));
	}
	wxArrayInt saveFilterFlagsUnkMkrs;
	// again copy by brute force elements from m_filterFlagsUnkMkrs to
	// saveFilterFlagsUnkMkrs
	saveFilterFlagsUnkMkrs.Empty();
	for (act = 0; act < (int)gpApp->m_filterFlagsUnkMkrs.GetCount(); act++)
	{
		// copy all items from m_unknownMarkers into saveUnknownMarkers
		saveFilterFlagsUnkMkrs.Add(gpApp->m_filterFlagsUnkMkrs.Item(act));
	}

	// start with empty data
	pUnkMarkers->Empty();
	pUnkMkrsFlags->Empty();
	unkMkrsStr.Empty();
	wxString EqZero = _T("=0 "); // followed by space for parsing efficiency
	wxString EqOne = _T("=1 "); // " " "

	USFMAnalysis* pSfm;
	wxString key;

	//MapSfmToUSFMAnalysisStruct* pSfmMap; // unused
	//pSfmMap = gpApp->GetCurSfmMap(useSfmSet);
	useSfmSet = useSfmSet; // avoid warning

	// Gather markers from all source phrase m_markers strings
	MapSfmToUSFMAnalysisStruct::iterator iter;
	SPList::Node* posn;
	posn = pList->GetFirst();
	CSourcePhrase* pSrcPhrase;
	while (posn != 0)
	{
		// process the markers in each source phrase m_markers string individually
		pSrcPhrase = (CSourcePhrase*)posn->GetData();
		posn = posn->GetNext();
		wxASSERT(pSrcPhrase);
		if (!pSrcPhrase->m_markers.IsEmpty() || !pSrcPhrase->GetFilteredInfo().IsEmpty())
		{
			// m_markers and/or m_filteredInfo for this source phrase has content to examine
			pMarkerList->Empty(); // start with an empty marker list

			// The GetMarkersAndEndMarkersFromString function below fills the CStringList
			// pMarkerList with all the markers and their associated texts, one per list
			// item. Each item will include end markers for those that have them. Also,
			// Filtered material enclosed within \~FILTER...\~FILTER* brackets will also be
			// listed as a single item (even though there may be other markers embedded
			// within the filtering brackets.
			GetMarkersAndEndMarkersFromString(pMarkerList, pSrcPhrase->m_markers + pSrcPhrase->GetFilteredInfo(),
				pSrcPhrase->GetEndMarkers());
			// Now iterate through the strings in pMarkerList, check if the markers they
			// contain are known or unknown.
			wxString resultStr;
			resultStr.Empty();
			wxString wholeMarker, bareMarker;
			bool markerIsFiltered;
			int mlct;
			for (mlct = 0; mlct < (int)pMarkerList->GetCount(); mlct++)
			{
				// examine this string list item
				resultStr = pMarkerList->Item(mlct);
				wxASSERT(resultStr.Find(gSFescapechar) == 0);
				markerIsFiltered = FALSE;
				if (resultStr.Find(filterMkr) != -1)
				{
					resultStr = pDoc->RemoveAnyFilterBracketsFromString(resultStr);
					markerIsFiltered = TRUE;
				}
				resultStr.Trim(FALSE); // trim left end
				resultStr.Trim(TRUE);  // trim right end
				int strLen = resultStr.Length();
				int posm = 1;
				wholeMarker.Empty();
				// get the whole marker from the string
				while (posm < strLen && resultStr[posm] != _T(' ') &&
					resultStr[posm] != gSFescapechar)
				{
					wholeMarker += resultStr[posm];
					posm++;
				}
				wholeMarker = gSFescapechar + wholeMarker;
				// do not include end markers in this inventory, so remove any final *
				int aPos = wholeMarker.Find(_T('*'));
				if (aPos == (int)wholeMarker.Length() - 1)
					wholeMarker.Remove(aPos, 1);

				wxString tempStr = wholeMarker;
				tempStr.Remove(0, 1);
				bareMarker = tempStr;
				wholeMarker.Trim(TRUE); // trim right end
				wholeMarker.Trim(FALSE); // trim left end
				bareMarker.Trim(TRUE); // trim right end
				bareMarker.Trim(FALSE); // trim left end
				wxASSERT(wholeMarker.Length() > 0);
				// Note: The commented out wxASSERT above can trip if the input text had an
				// incomplete end marker \* instead of \f* for instance, or just an
				// isolated backslash marker by itself \ in the text. Such typos become
				// unknown markers and show in the nav text line as ?\*? etc.

				// lookup the bare marker in the active USFMAnalysis struct map
				// whm ammended 11Jul05 Here we want to use the LookupSFM() routine which
				// treats all \bt... initial back-translation markers as known markers all
				// under the \bt marker with its description "Back-translation"
				pSfm = LookupSFM(bareMarker); // use LookupSFM which properly handles
											  // \bt... forms as \bt
				bool bFound = pSfm != NULL;
				if (!bFound)
				{
					// it's an unknown marker, so process it as such only add marker to
					// m_unknownMarkers if it doesn't already exist there
					int newArrayIndex = -1;
					if (!MarkerExistsInArrayString(pUnkMarkers, wholeMarker,
						newArrayIndex))
					{
						bool bFound = FALSE;
						// set the filter flag to unfiltered for all unknown markers
						pUnkMarkers->Add(wholeMarker);
						if (mkrInitStatus == setAllUnfiltered) // unused condition
						{
							pUnkMkrsFlags->Add(FALSE);
						}
						else if (mkrInitStatus == setAllFiltered) // unused condition
						{
							pUnkMkrsFlags->Add(TRUE);
						}
						else if (mkrInitStatus == preserveUnkMkrFilterStatusInDoc)
						{
							// whm added 27Jun05. After any doc rebuild is finished, we
							// need to ensure that the unknown marker arrays and
							// m_currentUnknownMarkerStr are up to date from what is now
							// the situation in the Doc.
							// Use preserveUnkMkrFilterStatusInDoc to cause
							// GetUnknownMarkersFromDoc to preserve the filter state of an
							// unknown marker in the Doc, i.e., set m_filterFlagsUnkMkrs to
							// TRUE if the unknown marker in the Doc was within \~FILTER
							// ... \~FILTER* brackets, otherwise the flag is FALSE.
							pUnkMkrsFlags->Add(markerIsFiltered);
						}
						else // mkrInitStatus == useCurrentUnkMkrFilterStatus
						{
							// look through saved passed-in arrays and try to make the
							// filter status returned for any unknown markers now in the
							// Doc conform to the filter status in any corresponding saved
							// passed-in arrays.
							int mIndex;
							for (mIndex = 0; mIndex < (int)saveUnknownMarkers.GetCount(); mIndex++)
							{
								if (saveUnknownMarkers.Item(mIndex) == wholeMarker)
								{
									// the new unknown marker is same as was in the saved
									// marker list so make the new unknown marker use the
									// same filter status as the saved one had
									bFound = TRUE;
									int oldFlag = saveFilterFlagsUnkMkrs.Item(mIndex);
									pUnkMkrsFlags->Add(oldFlag);
									break;
								}
							}
							if (!bFound)
							{
								// new unknown markers should always start being unfiltered
								pUnkMkrsFlags->Add(FALSE);
							}
						}
						unkMkrsStr += wholeMarker; // add it to the unknown markers string
						if (pUnkMkrsFlags->Item(pUnkMkrsFlags->GetCount() - 1) == FALSE)
						{
							unkMkrsStr += EqZero; // add "=0 " unfiltered unknown marker
						}
						else
						{
							unkMkrsStr += EqOne; // add "=1 " filtered unknown marker
						}
					}
				}// end of if (!bFound)
			}// end of while (posMkrList != NULL)
		}// end of if (!pSrcPhrase->m_markers.IsEmpty())
	}// end of while (posn != 0)
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString containing a list of whole unknown markers; each
///             marker (xx) formatted as "\xx=0 " or "\xx=1 " with following space within
///             the string.
/// \param		pUnkMarkers*	-> pointer to a wxArrayString of whole unknown markers
/// \param		pUnkMkrsFlags*	-> pointer to a wxArrayInt of int flags indicating
///                                whether the unknown marker is filtered (1)
///                                or unfiltered (0).
/// \remarks
/// Called from: Currently GetUnknownMarkerStrFromArrays() is only called from debug trace
/// blocks of code and only when the _Trace_UnknownMarkers define is activated.
/// Composes a string of unknown markers suffixed with a zero flag and following space ("=0
/// ") if the filter status of the unknown marker is unfiltered; or with a one flag and
/// followoing space ("=1 ") if the filter status of the unknown marker is filtered. The
/// function also verifies the integrity of the arrays, i.e., that they are consistent in
/// length - required for them to operate in parallel.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::GetUnknownMarkerStrFromArrays(wxArrayString* pUnkMarkers,
	wxArrayInt* pUnkMkrsFlags)
{
	int ctMkrs = pUnkMarkers->GetCount();
	// verify that our arrays are parallel
	pUnkMkrsFlags = pUnkMkrsFlags; // to avoid compiler warning
	wxASSERT(ctMkrs == (int)pUnkMkrsFlags->GetCount());
	wxString tempStr, mkrStr;
	tempStr.Empty();
	for (int ct = 0; ct < ctMkrs; ct++)
	{
		mkrStr = pUnkMarkers->Item(ct);
		mkrStr.Trim(FALSE); // trim left end
		mkrStr.Trim(TRUE); // trim right end
		mkrStr += _T("="); // add '='
		mkrStr << pUnkMkrsFlags->Item(ct); // add a 1 or 0 flag formatted as string
		mkrStr += _T(' '); // ensure a single final space
		tempStr += mkrStr;
	}
	return tempStr;
}
bool CAdapt_ItDoc::IsGenuineFollPunct(wxChar chPunct)
{
	int offset = wxNOT_FOUND;
	offset = m_strInitialPuncts.Find(chPunct);
	if (offset == wxNOT_FOUND)
	{
		return TRUE;
	}
	return FALSE;
}

// Return -1 if unable to parse to the next whitespace
int CAdapt_ItDoc::ScanToWhiteSpace(wxChar* pChar, wxChar* pEnd)
{
	if (pChar > (pEnd - 1))
	{
		return -1;
	}
	int charCount = 0;
	wxChar* ptr = pChar;
	while (ptr < (pEnd - 1) && !IsWhiteSpace(ptr)) // (pEnd -1) to allow for a terminating whitespace to exist
	{
		ptr++;
		charCount++;
	}
	return charCount;
}

//BEW 16Nov23 need a parser for things like:  12-nha  28-ŋura  26-dja etc. ParseAWord could do it, but that
// is much further below and ParseDate() or ParseChVerseUnchanged() would unhelpfully get called before control
// can get that far. So need something which starts off like ParseDate(), and after the first number there must
// be a hyphen, and after that alphabetic chars. We don't have a reliable test for alphabetics when exotic languages
// are to be supported, so we could just require that after the hyphen every character until whitespace is 
// (a) not punctuation, (b) not a digit. Failure of those tests, return emptyString, (and ParseDate() can have a go)
// else return the whole as wxString non-empty (and caller treats that as signal to skip call of ParseDate() ).
// Declarlation is in .h public access, about line 280
wxString CAdapt_ItDoc::ParseNumberHyphenSuffix(wxChar* pChar, wxChar* pEnd, wxString spacelessPuncts)
{
	wxChar* ptr = pChar;
	wxString strResult = wxEmptyString;
	bool bIsDigit = IsAnsiDigit(*pChar);
	if (!bIsDigit)
	{
		return strResult; // empty
	}
	wxString hyphen = _T("-");
	int nSpanLen = 0; // init
	int offset = wxNOT_FOUND; // init
	wxString strBefore = wxEmptyString;
	wxString strAfter = wxEmptyString;
	// Starts with a digit
	nSpanLen = ScanToWhiteSpace(ptr, pEnd);
	if (nSpanLen > 0)
	{
		strResult = wxString(ptr, nSpanLen);
		offset = strResult.Find(hyphen);
		if (offset == wxNOT_FOUND)
		{
			// no internal hyphen, so return empty string
			strResult.Empty();
			return strResult;
		}
		// We know there is at least one or more initial digits, and there is
		// also a hyphen. But the digits may have a non-digit within, and the
		// post-hyphen content may not be purely alphabetic, so separate into
		// strBefore (check all are digits), and strAfter (check all are not puncts
		// and not digits) in two loops
		strBefore = strResult.Left(offset); //wxString(ptr, offset);
		offset++; // point at what follows the hyphen
		strAfter = strResult.Mid(offset);
		// To be valid, strAfter must contain at least one character. If not, return empty str
		if (strAfter.IsEmpty())
		{
			strResult.Empty();
			return strResult;
		}
		// Now test that contents of strBefore are all digits, and of strAfter neither digits
		// nor alphabetics.
		bool bIsAnsiDigit = FALSE; // init
		wxChar* pEnd;
		int beforeLen = (int)strBefore.Length();
		const wxChar* pBefore = strBefore.GetData(); // pBefore is constant, the loop changes nothing
		pEnd = (wxChar*)pBefore + beforeLen;
		wxChar* pBufStart = (wxChar*)pBefore;
		wxChar* pAux = pBufStart; // init
		while (pAux < pEnd)
		{
			bIsAnsiDigit = IsAnsiDigit(*pAux);
			if (!bIsAnsiDigit)
			{
				// Initial digits string has a non-digit, so function fails to satisfy the structure constraint
				strResult.Empty();
				return strResult;
			}
			// ptr pointed at a digit, so advance ptr to next character
			pAux++;
		}
		// If control did not return within the above loop, then all characters preceding the hyphen are digits
		// Now do similarly for the strAfter: in this case we want no puncts, and no digits in the post-hyphen string
		bIsAnsiDigit = FALSE;
		int afterLen = (int)strAfter.Length();
		const wxChar* pAfter = strAfter.GetData();
		pEnd = (wxChar*)pAfter + afterLen;
		pBufStart = (wxChar*)pAfter;
		pAux = pBufStart; // init
		while (pAux < pEnd)
		{
			bIsAnsiDigit = IsAnsiDigit(*pAux);
			if (bIsAnsiDigit)
			{
				// post-hyphen string has a digit, so function fails to satisfy the structure constraint
				strResult.Empty();
				return strResult;
			}
			// Now test that pAux is not punctuation character
			offset = -1; // init
			offset = spacelessPuncts.Find(*pAux);
			if (offset >= 0)
			{
				// The suffix string contains a punctuation character, so function fails
				// to satisfy the structure constrint
				strResult.Empty();
				return strResult;
			}
			// ptr pointed at a digit, so advance ptr to next character
			pAux++;
		}
		// If control gets to here, all's well: strResult is one or more digits, then a hyphen,
		// and then a suffix string up to the first instance of whitespace, and the suffix
		// string has no digits nor any punctuation. So it's a kosher parsing result.
	}
	return strResult;
	/*  loop processing - clone & tweak from this code from Bill.... 
		// wx version note: Since we require a read-only buffer we use GetData which just
		// returns a const wxChar* to the data in the string theRest.
		const wxChar* ptr = theRest.GetData();
		wxChar* pEnd;
		pEnd = (wxChar*)ptr + len2 - metadataLength; 
		wxChar* pBufStart = (wxChar*)ptr;
	*/
}

// BEW added 16Jun23 for parsing data like 02/26/01 or 02/26/2001, or 2010/05/24, or 12/02
// If parsed successfully, returns the length of the date string. Any error or inconsistency,
// return -1. The date must not include an internal whitespace, return -1 if it does. We
// parse for at least one separator. If there is a second, it mustbe the same - eg, / and / , 
// : and : , or - and - (hyphens); and the string must start and end with a digit. First character,
// a digit, must be what pChar points at. It's okay if what follows, on return, is puncts.
// Bummer. In Gupapuyngu Mark, there is one sequence which is not yet parsed right:  "10:4-ŋuru"
// which means "from 10:4" -- the 10:4 is a chapter:verse, and ParseNumberHyphenSuffix() will have
// rejected it, returning empty string. So ParseDate gets to try next. The suffix is present, after
// a hyphen, but what precedes the hyphen is a substring which contains punctuation (could be : or .)
// and there's no '/' (which by itself is an insufficient test, but is a good test if : or . precede
// a present hyphen. So I need to refactor to reject a string like "10:4-ŋuru"
int CAdapt_ItDoc::ParseDate(wxChar* pChar, wxChar* pEnd, wxString spacelessPuncts)
{
	wxChar* ptr = pChar; wxUnusedVar(ptr); // avoid warning variable initialized but not referenced
	wxString strDate = wxEmptyString; // init
	wxString legal_separators = _T("/-"); // BEW 30Jun23 removed ':' from list, as 7:14 would be 
										  // handled as a date, not ch:verse
	int offset = wxNOT_FOUND; // init
	wxString theSeparator = wxEmptyString; // init
	int separatorCount = 0; // init
	int nSaveOriginalLength = 0; // init
	bool bIsPunct = FALSE; // init
	bIsPunct = bIsPunct;  // avoid gcc set but not used warning

	int dateSpanLen = 0;
	wxChar aChar;
	int charCount = 0;
	//int maxLen = 10; // 2 for days, 2 for months, 4 for year, 2 for separators = 10
	//int minLen = 6;  // 1 for days, 1 for months, 2 for year, 2 for separator = 6
	if (IsAnsiDigit(*pChar))
	{
		// Starts with a digit
		dateSpanLen = ScanToWhiteSpace(pChar, pEnd);
		strDate = wxString(pChar, dateSpanLen);

		{ // scoping span
			//BEW 22Jun23 added code for shortening span if one or more puncts follow.
			int count = 0; // count final puncts that get removed
			wxString revDate = MakeReverse(strDate);

			// loop from start, chucking away every wxChar which is punctuation
			//bool bIsPunct = FALSE;
			aChar = revDate.GetChar(0);

			// BEW 17Nov23 add code to reject data like: "10:4-ŋuru", or same with . instead of :
			// First test is for offset to : or .
			int offset1 = -1;
			int offset2 = -1;
			wxChar chsep1 = _T(':');
			wxChar chsep2 = _T('.');
			offset1 = strDate.Find(chsep1);
			offset2 = strDate.Find(chsep2);
			//bool bHasASeparator = FALSE; // init
			if (offset1 >= 0 || offset2 >= 0)
			{
				return 0;
				// This bool being true is probably sufficient
				//bHasASeparator = TRUE;
			}
			/* for now, comment out
			// What might matter is where the : or . punct separator is in relation to valid date
			// separators ( / or - ), if prior to '/' or especially to '-', then reject the
			// strDate as a valid date
			int offset3 = -1;
			int offset4 = -1;
			wxChar chsep3 = _T('-');
			wxChar chsep4 = _T('/');
			offset3 = strDate.Find(chsep3);
			offset4 = strDate.Find(chsep4);
			// I've not made any comparison tests of the 4 offsets here, as I think bHasASeparator
			// is probably sufficient for rejection
			*/

			int myoffset = wxNOT_FOUND;
			myoffset = spacelessPuncts.Find(aChar);
			// If myoffset returns >= zero, aChar is a final punctuation to be chucked away
			// as we want to parse over only a genuine date - starting and ending with a digit
			while (myoffset >= 0)
			{
				revDate = revDate.Mid(1); // removes 1st punct, shortening revDate
				count++;
				// Prepare for next iteration
				aChar = revDate.GetChar(0);
				myoffset = spacelessPuncts.Find(aChar);
			} // end of punctuation removals loop
			if (count > 0)
			{
				// revString was shortened, and now has no final puncts at end 
				// when reversed back to normal order
				strDate = MakeReverse(revDate);
				dateSpanLen -= count;
			}
		} // end scoping span

		nSaveOriginalLength = dateSpanLen; // needed at end

		// Check the date is well-formed as far as length is concerned.
		// 
		// whm 20Jan2024 removed the following arbitrary length limit of the
		// date. It is not uncommon for people to have dates like 10/May/2020
		// or 10/September/2020 or 10/<some foreign language month name>/2020
		// etc. Even the Hezekiah test file has a 19/May/2025 date in its \id
		// line. The dateSpanLen was determined by scanning to the next white
		// space or pEnd so we should not place an arbitrary limit on the
		// length of the date string.
		//if (dateSpanLen > 10)
		//{
		//	// date format is too long
		//	return -1;
		//}
		int index;
		// Loop until we come to the first separator, then exit after determining what
		// the separator is. If it's not legal, then return -1. (We have up to 3 fields to deal
		// with, so we will use up to 3 loops to traverse them all, shortening strDate and dateSpanLen
		// after each field is handled)
		
		// First loop
		for (index = 0; index < dateSpanLen && separatorCount == 0; index++)
		{
			// We are in the first field of the date
			aChar = strDate.GetChar(index);
			// What is aChar? Either Ansi digit character, or theSeparator, or if neither, 
			// then it's a malformed date --  so return -1 if so
			if (IsAnsiDigit(aChar))
			{
				charCount++;
			}
			else
			{
				// Not a digit, so might be theSeparator character, or the date is malformed
				offset = legal_separators.Find(aChar);
				if (offset >= 0)
				{
					// It's a legal separator, so set theSeparator etc
					theSeparator = aChar;
					charCount++; // count the separator too
					separatorCount = 1;
					break; // this first loop is finished
				}
				else
				{
					// Not a legal separator, so is a malformed date, return -1
					return -1;
				}
			}
		} // end of first loop, with test: for (index = 0; index < dateSpanLen && separatorCount == 0; index++)

		// Prepare for the middle loop, or the last loop (if a field is absent). This is field 2
		strDate = strDate.Mid(charCount);
		dateSpanLen = strDate.Length();
		index = 0;
		charCount = 0;
		wxChar lastChar; // set this for each iteration, so when we exit we can verify that it's an ANSI digit
		lastChar = _T(' '); // initialise to something benign and non-digit - use space (avoids compiler warning)

		// Second loop
		// whm 20Jan2024 modified this loop to accept non-ansi chars for the second loop
		// for dates like 19/May/2005 used in the Hezekiah \id line.
		for (index = 0; index < dateSpanLen && separatorCount == 1; index++)
		{
			// We are in the 2nd field of the date
			aChar = strDate.GetChar(index);
			// What is aChar? Either Ansi digit character, or theSeparator, or if neither, it might be
			// a 2 field date
			// whm 20Jan2024 valid dates should allow the month name or abbreviation to be used

			//if (IsAnsiDigit(aChar))
			//{
				charCount++;
				lastChar = aChar;
			//}
			//else
			//{
				// Not a digit, so might be theSeparator character (for a 3 field date), 
				// or whitespace if it's a 2 field date
				if (aChar == theSeparator)
				{
					// It's a 3 field date, and it's the same legal separator, so this 2nd loop is finished
					charCount++;
					separatorCount++; // now equals 2
					break; // this 2nd loop is finished, successfully
				}
				else
				{
					// aChar is not the separator, so this might be a 2 field date. If so, aChar will be
					// either a whitespace, or punctuation -- check it out. If it checks out, and lastChar
					// is a digit, it's a valid 2-field date
					bIsPunct = FALSE; // re-initialise
					offset = wxNOT_FOUND;
					offset = spacelessPuncts.Find(aChar);
					if (IsWhiteSpace(&aChar) || offset >= 0)
					{
						// It was either whitespace (typically latin space, or newline, or others) or 
						// a punctuation character; so this is a 2 field date, and parsing is done
						if (!IsAnsiDigit(lastChar))
						{
							return -1; // malformed date
						}
						dateSpanLen = nSaveOriginalLength;
						return dateSpanLen;
					}
					//else
					//{
						// Not the same separator, or not at date's end or punctuation which follows,
						// so gotta aasume it's a malformed date, return -1
						//return -1;
					//}
				}
			//}
		} // end of the second loop for test: for (index = 0; index < dateSpanLen && separatorCount == 1; index++)

		// Prepare for the 3rd and final loop
		strDate = strDate.Mid(charCount - 1);
		dateSpanLen = strDate.Length();
		index = 0;
		charCount = 0;
		offset = strDate.Find(theSeparator);
		if (offset >= 0)
		{
			// Error, there can't be 3 or more separators in a valid date
			return -1;
		}

		// Third loop
		for (index = 0; index < dateSpanLen && separatorCount == 2; index++)
		{
			// We are in the last (3rd) field of the date
			aChar = strDate.GetChar(index);
			// What is aChar? Either Ansi character, or theSeparator, or if neither, it's a malformed
			// date so return -1
			if (IsAnsiDigit(aChar))
			{
				charCount++;
				lastChar = aChar;
			}
			else
			{
				// Not a digit, so must be whitespace, or punctuation, or it's a malformed date
				offset = wxNOT_FOUND;
				offset = spacelessPuncts.Find(aChar);
				if (IsWhiteSpace(&aChar) || offset >= 0)
				{
					// It's the same and legal separator, so this 2nd loop is finished & valid
					break; // this 3rd loop is finished, successfully if lastChar is a digit
				}
			}
		} // end of the third loop, for test: for (index = 0; index < dateSpanLen && separatorCount == 2; index++)
		// Check that the lastChar is an Ansi digit, if not, the date is malformed
		if (!IsAnsiDigit(lastChar))
		{
			return -1; //malformed date
		}
		// If control gets here, all was well - for a 3-field valid date
		dateSpanLen = nSaveOriginalLength;
	} // end of TRUE block for test: if (IsAnsiDigit(*pChar))
	else
	{ 
		//pChar does not point at a digit, return -1
		return -1;
	}
	return dateSpanLen;
}

// BEW 7Jun23 created next, for parsing final puncts, which may be all or some detached by preceding
// whitespace(s), and getting to the puncts may require parsing first over one or more inlineBindingEndMarkers
wxChar* CAdapt_ItDoc::ParsePostWordPunctsAndEndMkrs(wxChar* pChar, wxChar* pEnd, CSourcePhrase* pSrcPhrase, int& itemLen, wxString spacelessPuncts)
{
	// pChar comes in, pointing at the first wxChar following whatever ParseAWord() parsed over, and the caller will have
	// a len value which is not zero. We parse over binding endMkr if present, then over puncts (detached or not) - and there
	// maybe a more than one sequence of "<whitespace(s)><followingPunct(s)>" to parse over, e.g. "jooni ! » Daaru" in Steve White's
	// source data. pSrcPhrase is needed so anything parsed over can be appropriately stored. itemLen tracks how many characters are
	// parsed over up to the point control returns to ParseWord(); and our internal ptr will have advanced that far, so is returned
	// to ParseWord(). After this function returns, we test for what to do next - as further down in ParseWord() we have a lot of smarts
	// for parsing complex markup - like in foonotes, and nonbinding endMkrs, and even more detached or non-detached puncts.
	// itemLen is returned to the caller, so that the caller's len value can be increased to match where ptr got to.
	wxChar* ptr = pChar;
	CAdapt_ItApp* pApp = &wxGetApp(); // for access to the m_charFormatEndMkrs fast-access string (inline binding endMkrs)
	wxChar space = _T(' ');
	// BEW 20Jun23, the following assert causes infinite loop if pSrcPhrase->m_key is empty. Being empty is unusual, but
	// if we don't advance ptr by at least one wxChar, then the infinite loop happens. So I'll try saving a asterisk in m_key and
	// m_srcPhrase, and return itemLen = 1,  and ptr advanced by 1. If no subsequent content is added in the caller, an 
	// isolated asterisk will be seen but carry no meaning, it would be in the GUI as a pSrcPhrase, & prevent an app infinite loop
	if (pSrcPhrase->m_key.IsEmpty())
	{
		// BEW 18Jul23, putting * was not a good idea to Bill, nor to me. Perhaps do something meaningful instead, like
		// <empty-key> ( length 11 ) as m_key and m_srcPhrase, which still protects from an infinite loop
		// BEW 25Aug23 the < and > are not essential, and might be causing an infinite loop (Bill reported 25Aug23), 
		// especially for src data where m_srcPhrase has valid puncts "<<" preceding; so I'll remove them
		pSrcPhrase->m_key << _T("empty-key");
		pSrcPhrase->m_srcPhrase << _T("empty-key");
		ptr += 9;
		itemLen = 9;
		return ptr;
	}
	//wxASSERT(!pSrcPhrase->m_key.IsEmpty());
	int offset = wxNOT_FOUND; // init
	wxString wholeMkr = wxEmptyString;
	wxString augWholeMkr = wxEmptyString;
	int numEndPuncts; numEndPuncts = 0; // init
	wxString strEndPuncts; strEndPuncts = wxEmptyString; // init
	
	int itemSpan = 0; // this is an item length valid only for the current iteration, the loop may iterate several times, and
					  // each time set a new itemItemSpan when parsed data is stored in pSrcPhrase; but we need to accumulate
					  // these small spans' lengths for as long as the loop iterates, so use itemLenAccum for that.
	int itemLenAccum = 0; // When ParsePostWordPuncts() is exited, set parameter itemLen to its value, with ptr agreeing
						  // (we can do that in one line, itemLen = itemLenAccum). It's not possible to know ahead of
						  // calling ParsePostWordPuncts() just how many iterations will be needed.
	int mkrLen = 0; // init
	itemLen = 0; // init
	// What might follow pSrcPhrase->m_key?
	// 1. no endMkr or puncts, but just a space or newline signalling it's time to return in caller, to generate next pSrcPhrase
	// 2. An endmkr belonging to m_charFormatEndMkrs fast-access string. Inline binding end markers 'bind', so we can assumme
	//    there is no punctuation before it, but there may be after it - either attached, or detached by whitespace
	// 3. Punctuation character(s) - may be more than one in sequence, but usually one; or the same but following the endMkr of 2.
#if defined (_DEBUG) && !defined(NOLOGS)
	if (pSrcPhrase->m_nSequNumber >= 8)
	{
		int halt_here = 1; wxUnusedVar(halt_here); // avoid warning variable initialized but not referenced
	}
#endif
	if (*ptr == gSFescapechar)
	{
		// the marker at ptr may be an endMkr, belonging to the m_charFormatEndMkrs set. 
		wholeMkr = GetWholeMarker(ptr);
		wxASSERT(!wholeMkr.IsEmpty());
		augWholeMkr = wholeMkr + space;
		offset = pApp->m_charFormatEndMkrs.Find(augWholeMkr);
		//if (offset == wxNOT_FOUND)
		if (offset >= 0)
		{
			// It's an inline binding end marker, so parse over it, and store in the pSrcPhrase->m_inlineBindingEndMarkers
			mkrLen = wholeMkr.Length();
			wxString strBinds = pSrcPhrase->GetInlineBindingEndMarkers();
			strBinds << wholeMkr;
			pSrcPhrase->SetInlineBindingEndMarkers(strBinds);
			itemSpan = mkrLen;
			itemLenAccum += itemSpan;
			ptr += itemSpan; // ptr has advanced
			itemLen += itemSpan;
		}
	} // end of TRUE block for test: if (*ptr = gSFescapeChar)
	else
	{
		// BEW 18Jul23, not having this else block earlier was a source of error when
		// the input source data at this current pSrcPhrase was ptr pointing at ",\\it*\n....".
		// The do loop below expects ptr to point at backslash, but unparsed comma prevents that,
		// so the do loop below skips where the \it* marker would get correctly parsed, and control
		// enters the else block, where comma does get parsed, but a bad test of pNext (I'll fix
		// this now too) causes a break from the do loop, and \it* is left unparsed - so that the
		// next pSrcPhrase sees it as an unknown endMkr and puts up an error message telling the
		// user what marker it is and presenting it in a context of surrounding words. So here,
		// I need to parse over the punct, to get to the endMkr
		numEndPuncts = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);  // a span of puncts, or none
		if (numEndPuncts > 0)
		{
			// Parsed one or more puncts, deal with them, update ptr, augment itemSpan, & itemLenAccum
			strEndPuncts = wxString(ptr, numEndPuncts); // will be empty if ptr is not at a punct
			pSrcPhrase->m_follPunct << strEndPuncts;
			pSrcPhrase->m_srcPhrase << strEndPuncts;
			itemSpan += numEndPuncts;
			itemLenAccum += itemSpan;
			ptr += itemSpan; // ptr has advanced, so for data like ",\\it*" ptr now points at the \it* endMkr
				// and so the do loop below will correctly pick up the \it* marker and process it right. But
				// if a beginMkr (e.g. \f ) is at ptr, then that belongs on the next pSrcPhrase - so check
				// and if so, force return here after doing necessary updates
			itemLen += itemSpan;

			/* Remove this stuff, best idea is to hand over now to the do loop
			wxString wholeMkr; wholeMkr = wxEmptyString;
			bool bIsEndMkr; bIsEndMkr = FALSE; // init
			bool bIsBeginMkr; bIsBeginMkr = FALSE; // init
			bIsBeginMkr = IsBeginMarker(ptr, pEnd, wholeMkr, bIsEndMkr);
			if (*ptr == gSFescapechar && bIsBeginMkr)
			{
				// If TRUE, then the beginMkr at ptr belongs on the next pSrcPhrase, so return itemLen in
				// signature, and ptr value 
				itemLen = itemLenAccum;
				return ptr;
			}
			*/
		} // end of TRUE block for test: if (numEndPuncts > 0)
	} // end of the else block for test: if (*ptr == gSFescapechar)

#if defined (_DEBUG) && !defined(NOLOGS) // && defined (LOGMKRS)
	wxString mypointsAt = wxString(ptr, 16);
	wxLogDebug(_T("ParsePostWordPunctsAndEndMkrs(), before its while loop: line %d, sn= %d, in ParseWord() ptr= [%s]"),
		__LINE__,  pSrcPhrase->m_nSequNumber, mypointsAt.c_str() );
	if (pSrcPhrase->m_nSequNumber >= 13)
	{
		int halt_here = 1; wxUnusedVar(halt_here); // avoid warning variable initialized but not referenced
	}
#endif

	// Now ptr points at one of these options (longest first, shortest last):
	// 1. One or more substrings of type: space + punct(s)
	// 2. A mix of undetached puncts and substrings of type: space + punct(s)
	// 3. No whitespace(s) but post-word punctuation (but not including any pre-word begining puncts for 
	//    m_precPunct on next pSrcPhrase)
	// 4. No whitespace(s), but another post-word endMkr
	// 5. A whitespace (or newline, or gSfescapechar) preceding which, ptr should be returned to ParseWord(), 
	//    for the caller to initiate returning len to start off a new pSrcPhrase

	// Start with 1. above
	int numSpaces;
	wxString strEndSpaces;
	int numGoodOnes = 0;
	int numBadOnes = 0;
	wxChar* pAux;

	pAux = ptr;  // use pAux for parsing over one or more following puncts; do all options for each iteration
	bool bIterateAgain = TRUE;
	while (bIterateAgain)
	{
		// pAux and itemSpan apply only to the current iteration, they are reset to ptr and 0 at every new iteration
		pAux = ptr;  // use pAux for parsing over one or more following puncts; do all options for each iteration
		itemSpan = 0; // init to zero at each iteration

		// BEW 8Jul23 following a parsed endMkr, item 4 above is the possibility that another endMkr follows
		// immediately, there could be more than one, so check for ptr pointing at gSFescapechar, and if that
		// is an endMkr, parse over, update ptr, store it in m_endMarkers, update itemSpan for this iteration
		// add to itemLenAccum, set bIterateAgain TRUE
		if (*pAux == gSFescapechar)
		{
			// First try for an inline binding endMkr
			wholeMkr = GetWholeMarker(pAux);
			wxASSERT(!wholeMkr.IsEmpty());
			augWholeMkr = wholeMkr + space;
			offset = pApp->m_charFormatEndMkrs.Find(augWholeMkr);
			if (offset >= 0)
			{
				// It's an inline binding end marker, so parse over it, and store in
				// pSrcPhrase->m_inlineBindingEndMarkers
				mkrLen = wholeMkr.Length();
				wxString strBinds = pSrcPhrase->GetInlineBindingEndMarkers();
				strBinds << wholeMkr;
				pSrcPhrase->SetInlineBindingEndMarkers(strBinds);
				itemSpan = mkrLen;
				pAux += itemSpan;
				ptr += itemSpan; // ptr has advanced
				itemLenAccum += itemSpan;
				// whm 19Jul2023 added. The itemLenAccum value is here being updated, but the function's
				// ref parameter itemLen doesn't get updated below for the parsing of a \fk* end marker
				// within the 41MATNYNT.SFM input file. This ultimately results in the item len back in
				// TokenizeText() having a value of 6 instead of 10 when ptr points at "ai.\\fk*\\f*\n..."
				// which taking 6 chars results in "ai.\\fk" instead of "ai.\\fk*\\f*". That situation
				// results in an extraneous source phrase created that just contains an asterisk m_key.
				// and going through more loops that eventually result in the footnote end marker \f*
				// being duplicated and stored in the source phrase that follows the extraneous asterisk
				// one.
				itemLen = itemLenAccum;
				bIterateAgain = TRUE;
			}
			else
			{
				// offset returned wxNOT_FOUND, so (ptr and) pAux while pointing at a marker,
				// it may be of a different type - of the inline non-binding type, like \wj*
				wholeMkr = GetWholeMarker(pAux);
				wxASSERT(!wholeMkr.IsEmpty());
				augWholeMkr = wholeMkr + space;
				offset = pApp->m_inlineNonbindingEndMarkers.Find(augWholeMkr);
				if (offset >= 0)
				{
					// blue end markers fast access set includes \wj* and 13 others
					mkrLen = wholeMkr.Length();
					wxString strNonbinding = pSrcPhrase->GetInlineNonbindingEndMarkers();
					strNonbinding << wholeMkr;
					pSrcPhrase->SetInlineNonbindingEndMarkers(strNonbinding);
					itemSpan = mkrLen;
					pAux += itemSpan;
					ptr += itemSpan; // ptr has advanced
					itemLenAccum += itemSpan;
					bIterateAgain = TRUE;
				} // end of TRUE block for test: if (*pAux == gSFescapechar) -- inner
				else
				{
					// Quite possibly pAux is pointing at a beginMkr. We must deal with that
					// if so, otherwise control will enter the block for showing the user
					// a message dialog saying the marker is unknown - and then the next
					// pSrcPhrase will fail if it is asked to handle a beginMkr
					bool bIsEndMkr; bIsEndMkr = FALSE; // init
					wxString nextWholeMkr; nextWholeMkr = wxEmptyString; // init
					bool bIsBeginMkr; wxString endMkrs;
					bIsBeginMkr = IsBeginMarker(pAux, pEnd, nextWholeMkr, bIsEndMkr);
					// BEW 17Oct23 need a block here to handle legitimate endmkrs, e.g. \f* when unfiltering
					bIsEndMkr = IsEndMarker(pAux, pEnd);
					if (pAux < pEnd && bIsEndMkr)
					{
						nextWholeMkr = GetWholeMarker(pAux);
						augWholeMkr = nextWholeMkr + space;
						offset = pApp->m_RedEndMarkers.Find(augWholeMkr); // this set includes \f* and many others
						if (offset >= 0)
						{

							mkrLen = nextWholeMkr.Length();
							itemSpan = mkrLen;
							endMkrs = pSrcPhrase->GetEndMarkers();
							endMkrs << nextWholeMkr;
							pSrcPhrase->SetEndMarkers(endMkrs); 
							pAux += itemSpan;
							ptr += itemSpan; // ptr has advanced
							itemLenAccum += itemSpan;
							bIterateAgain = TRUE;
						} // end of TRUE block for test: if (pAux < pEnd && bIsEndMkr)
						else
						{
							goto unknown;
						}
					}
					else if (pAux < pEnd && bIsBeginMkr )
					{
						// Must exit the loop immediately, beginMkrs belong on the next pSrcPhrase
						ptr = pAux;
						itemLen = itemLenAccum;
						bIterateAgain = FALSE;
					} // end of TRUE block for test: if (pAux < pEnd && bIsBeginMkr )
					else
					{
unknown:				bool bIsAnEndMkr;
						bIsAnEndMkr = FALSE; // initialize
						bIsAnEndMkr = bIsAnEndMkr; // avoid gcc warning set but not used warning
						int myOffset; myOffset = wxNOT_FOUND; // init
						myOffset = wholeMkr.Find(wxString(_T('*')));
						wxString wholeEndMkr;
						wxString strBefore;
						wxString strAfter;
						if (myOffset != wxNOT_FOUND)
						{
							// The whole mkr contains *, so is an endmarker -- this is
							// a parsing error because the endmarker should have been
							// included in the parse done by ParseWord() for the previous
							// CSourcePhrase instance, because it's ParseWord which handles
							// post-word endmarkers
							wholeEndMkr = wholeMkr;
							bIsAnEndMkr = TRUE;
						}
						wxString strApproxLocation;
						strApproxLocation = wxEmptyString; // init
						int curSN = pSrcPhrase->m_nSequNumber;
						CAdapt_ItView* pView;
						pView = gpApp->GetView();
						CPile* pCurPile;
						pCurPile = pView->GetPile(curSN);
						if (pCurPile != NULL)
						{
							CSourcePhrase* pCurSrcPhrase;
							// BEW 17Oct23 a better choice for pCurSrcPhrase is the passed in pSrcPhrase
							//pCurSrcPhrase = pCurPile->GetSrcPhrase();
							pCurSrcPhrase = pSrcPhrase;
							if (pCurSrcPhrase != NULL)
							{
								wxString curKey;
								curKey = pCurSrcPhrase->m_key;
								// BEW15Dec22 try to provide an approximate src string for the error - 30 chars
								// either side of the ptr value, or less if near start of end of input source text
								CSourcePhrase* pSPLocBefore = NULL; // go back 5 pSrcPhases, or to the sn = 0 one
								pSPLocBefore = pSPLocBefore; // avoid gcc warning set but not used warning
								CSourcePhrase* pSPLocAfter = NULL; // go forward 5 pSrcPhases, or to the sn = MAXINDEX one
								pSPLocAfter = pSPLocAfter; // avoid gcc warning set but not used warning
								CPile* pLocBefore_Pile;
								CPile* pLocAfter_Pile;
								int maxIndex; maxIndex = gpApp->GetMaxIndex();
								int snLocBefore; snLocBefore = curSN; // initialise
								int snLocAfter; snLocAfter = curSN; // initialise
								int snLocAfterEnd; snLocAfterEnd = curSN; // initialise
								snLocBefore -= 2; // BEW 17Oct23 was 5 
								snLocAfter += 1; // starting at next after curSN
								snLocAfterEnd = snLocAfter + 2; // BEW 17Oct23 was 5
								if (snLocBefore > 0)
								{
									// At least 2 previous pSrcPhrase instances are available
									pLocBefore_Pile = pView->GetPile(snLocBefore);
									wxASSERT(pLocBefore_Pile != NULL); // change later into an if/else test ********
								}
								else
								{
									// Too close to start of doc to fit 2, so start at sn = 0 pile
									pLocBefore_Pile = pView->GetPile(0);
									wxASSERT(pLocBefore_Pile != NULL);
								}
								pSPLocBefore = pLocBefore_Pile->GetSrcPhrase();
								// while loop in GetAccumulatedKeys() finishes one short of curSN
								strBefore = GetAccumulatedKeys(pApp->m_pSourcePhrases, snLocBefore, curSN);

								// Next, similar calulations to  get strAfter set, starting from curSN + 1
								pLocAfter_Pile = pView->GetPile(snLocAfter);
								wxASSERT(pLocAfter_Pile != NULL);
								pSPLocAfter = pLocAfter_Pile->GetSrcPhrase();
								if (snLocAfterEnd < maxIndex)
								{
									// There is enough room for 5 piles following curSN  to be accessed
									strAfter = GetAccumulatedKeys(pApp->m_pSourcePhrases, snLocAfter, snLocAfterEnd);
								}
								else
								{
									// Not enough room to access five, so access to maxIndex
									strAfter = GetAccumulatedKeys(pApp->m_pSourcePhrases, snLocAfter, maxIndex);
								}
								wxString space; space = _T(" ");
								strApproxLocation = strBefore;
								strApproxLocation << curKey;
								strApproxLocation << space;
								strApproxLocation << strAfter;

								// We must not lose the unknown endMkr, append it in pSrcPhrase's m_endMarkers, update ptr and
								// itemLenAccum (that advances ptr, which prevents infinite looping, and break from the loop
								int theMkrLen; theMkrLen = wholeEndMkr.Length();
								wxString m_endmkrs; m_endmkrs = pSrcPhrase->GetEndMarkers();
								m_endmkrs << wholeEndMkr;
								pSrcPhrase->SetEndMarkers(m_endmkrs);
								ptr += theMkrLen;
								itemLenAccum += theMkrLen;
								itemLen += theMkrLen; // returned by signature, keep ptr and what's parsed over, in sync

								wxString msg = _("Warning: While loading source text, encountered unexpected end-marker: %s \nPossibly occurs in the pile following: %s\n in the span: %s \n Either correct the unknown end-marker and reload the file, or just ignore the error.");
								msg = msg.Format(msg, wholeEndMkr.c_str(), curKey.c_str(), strApproxLocation.c_str());
								//wxString title = _T("Warning: Unexpected End Marker"); // BEW 17Oct23 don't display the msg box, just use LogUserAction()
								//wxMessageBox(msg, title, wxICON_WARNING | wxOK);
								pApp->LogUserAction(msg); // whm 17Oct2023 commented out - see note above.
								bIterateAgain = FALSE;
							} // end of TRUE block for test: if (pCurSrcPhrase != NULL)

						} // end of TRUE block for test: if (pPile != NULL)
						bIterateAgain = FALSE;

					} // end of else block for test: if (pAux < pEnd && bIsBeginMkr )
				} // end of else block for test: if (offset >= 0)

			} // end of else block for more outer test: if (offset >= 0)

		} // end of TRUE block for test: if (*pAux == gSFescapechar)
		else
		{
			// pAux does not point at gSFescapechar
			numSpaces = CountWhitesSpan(pAux, pEnd);
			strEndSpaces = wxString(pAux, numSpaces); // empty if numSpaces is 0
			if (numSpaces == 0)
			{
				// No spaces parsed over, so pAux remains at ptr so far, for this iteration,
				// and if there is a final punct at pAux (or more than one punct), they are
				// genuine following ones, provided it or each does not belong to strInitialPuncts
				numEndPuncts = ParseFinalPuncts(pAux, pEnd, spacelessPuncts);  // a span of puncts, or none
				strEndPuncts = wxString(pAux, numEndPuncts); // a string, will be empty if pAux is not at a punct
				if (numEndPuncts == 0)
				{
					// If zero whites and zero puncts, we have a word which either has only a
					// m_charFormatMarker we've already parsed and stored on pSrcPhrase, or no
					// inline binding endMkr, so a word with no ending punctuation. So we have
					// enough information to exit the do loop here - beware, it may not be the
					// first iteration
					itemLen = itemLenAccum;
					ptr = pChar + itemLen;
					return ptr;
				} // end of TRUE block for test: if (numEndPuncts == 0)
				else
				{
					// numEndPuncts is 1 or more. So get them (they are not detached; e.g. Iisa, 
					// where the comma punct follows a name for Jesus), and check that begin puncts
					// for next pSrcPhrase are counted, so we can adjust numEndPunct and strEndPuncts
					// to only have genuine word-following final puncts. (They may all be rejected as
					// non-genuine, return ptr unmoved in this iteration, beware, previous iterations
					// may have parsed puncts, stored on pSrcPhrase, and accumulated itemSpan into
					// itemLenAccum, so use the latter for returning a value to itemLen.)
					CountGoodAndBadEndPuncts(strEndPuncts, numGoodOnes, numBadOnes); // for this iteration
					if (numEndPuncts == numGoodOnes)
					{
						// All of the puncts parsed over, are genuine following puncts, for storing in m_follPunct
						// at this iteration; so do the stores and updates and continue looping - a detached punct
						// may follow - keep looping until ptr does not advance
#if defined (_DEBUG) && !defined(NOLOGS)
						if (pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1;
							wxUnusedVar(halt_here);
						}
#endif

						pSrcPhrase->m_follPunct += strEndPuncts;
						pSrcPhrase->m_srcPhrase += strEndPuncts;
						//bIterateAgain = TRUE; // ensure we iterate this inner loop
						itemSpan = numEndPuncts;
						itemLenAccum += itemSpan; // we are not exiting the function, so keep accumulating itemSpans
						pAux += itemSpan;
						ptr = pAux; // prepare for next iteration, as we set pAux to ptr at start of each iteration,
									// and itemSpan reset to 0 there too
						// BEW 22Jun23 if what followed the word, and the just parsed following punct(s), is whitespace
						// following by punctuation which is in strInitialPuncts - and therefore is beginning punct for
						// the next pSrcPhrase, determine if ptr is pointing at a whitespace, and (ptr + 1) points at
						// something in strInitialPuncts, or something not a punct char.
						// If so, break from the loop without advancing ptr, and ptr will be immediately returned
						{ // scoping block
							int myOffset = wxNOT_FOUND;
							// BEW 18Jul23 add check for bEndMkrAtPtr being TRUE. We need to know so as to protect
							// from the do loop being exited from early (i.e. wrongly), leaving an 'unknown endMkr'
							// for the next pSrcPhrase to choke on
							bool bEndMkrAtPtr; bEndMkrAtPtr = FALSE; // init
							if (*ptr == gSFescapechar && IsEndMarker(ptr, pEnd))
							{
								bEndMkrAtPtr = TRUE;
							}
							// ptr points at an endMkr, an unprotected access done by pNext would grab the first
							// character after the backslash of the endMkr - which could be any ascii letter - that
							// must be prevented, otherwise control could break from the do loop, and the endMkr
							// not get parsed. Gotta protect from that.  bEndMkrAtPtr set TRUE does the protection.
							wxChar* pNext = (ptr + 1); // what's pNext pointing at?
							wxChar chAtNext = *pNext;
							myOffset = m_strInitialPuncts.Find(chAtNext);
							bool bNextIsPunct = IsPunctuation(pNext); // 2nd param bIsSource is default TRUE
							// 1st subtest TRUE if pNext belongs on next pSrcPhrase, 2nd TRUE if pNext is something other 
							// than punctuation - such as the first char of the next word to be parsed, or wrongly, the
							// character after the backslash of an endMkr - horrors, if we don't protect from that!
							if (!bEndMkrAtPtr && (myOffset >= 0 || !bNextIsPunct) )
							{
								// if not an endMkr at ptr, AND either of the next two is true, 
								// we are done parsing post word puncts, so break from the do loop, and return
								// what's been spanned via the itemLen of the signature
								bIterateAgain = FALSE;
								itemLen = itemLenAccum;
								break; // from the loop
							}
							else
							{
								// whm 19Jul2023 added the next line to update the value of the reference parameter
								// itemLen here from itemLenAccum. Otherwise the itemLen value was not correct for
								// the parsing of 41MATNYNT.SFM at sn=1055 where ptr at this point was pointing at
								// a footnote end marker. This results in the following issue: After the function 
								// ParsePostWordPunctsAndMkrs() returns, the itemLen passed in the function's
								// reference parameter not being updated, resulting in the ptr value back in the
								// caller to point at the asterisk of the footnote end marker rather than just past
								// that asterisk.
								itemLen = itemLenAccum;

								bIterateAgain = TRUE; // keep looping
							}
						}
					} // end of TRUE block for test: if (numEndPuncts == numGoodOnes)
					else
					{
						// There must have been at least one bad one, or maybe all were bad because all were actually
						// pre-word begin puncts belonging to the next pSrcPhrase. Handle these two possibilities.
						// The more draconian one first...
						if (numEndPuncts == numBadOnes)
						{
							// All belong on the next pSrcPhrase, so we can't advance pAux or ptr here, and so
							// there's no puncts to store in m_follPunct. In fact, we can return here, with
							// ptr unmoved from pAux, at this iteration (earlier iterations may have stored
							// something, but not this one)
							itemSpan = 0;
							itemLen = itemLenAccum; // no increase in itemLenAccum
							ptr = pChar + itemLen;
							bIterateAgain = FALSE; // break out of the loop
						} // end of TRUE block for test: if (numEndPuncts == numBadOnes)
						else
						{
							// There are fewer bad ones than indicated by numEndPuncts. But a bad one must
							// cause the function, ParsePostWordPuncts(), to exit - because what's at pAux
							// + good ones, belongs on the next pSrcPhrase. So keep any good ones, because 
							// those must be stored in pSrcPhrase m_follPunct, and be appended to m_srcPhrase
							// as well, and itemLenAccum will set the itemLen value for returning, and also
							// enable setting the ptr value for returning too. Do those things here.
							itemSpan = numGoodOnes;
							itemLenAccum += itemSpan;
							strEndPuncts = wxString(pAux, itemSpan);
							pSrcPhrase->m_follPunct << strEndPuncts;
							pSrcPhrase->m_srcPhrase << strEndPuncts;
							itemLen = itemLenAccum;
							ptr = pChar + itemLen;
							bIterateAgain = FALSE; // break out of the loop
						} // end of else block for test: if (numEndPuncts == numBadOnes)

					} // end of else block for test: if (numEndPuncts == numGoodOnes)
				}
			} // end of TRUE block for test: if (numSpaces == 0)
			else
			{
				// numSpaces is not zero. Something stopped the parse - might be a punctuation character,
				// but could be a number of other things. Keep looping only provided we parsed over at least
				// one punct from spacelessPuncts which is NOT in strInitialPuncts
				wxChar* pSavePAux = pAux; // because if we don't restore the current position after
						// ParseFinalPuncts() has completed, pAux will point AFTER the whitespace of
						// a second iteration, thereby if the next punct is after the space of <space><punct>,
						// pAux would be pointing at the <punct> rather than <space><punct>, giving a mis-parse.
				pAux += numSpaces; // advance pAux to point at whatever follows the spaces.
				// Don't set itemSpan, or accumulate into itemLenAccum, until we know there are
				// puncts to parse over and we've done so, and got their length.
				// We won't know if we have detached puncts until we parse for them next, and take care,
				// because it's conceivable that we may parse over begining puncts belonging to the next
				// pSrcPhrase's m_precPunct member, so we have to check in strInitialPuncts too
				numEndPuncts = ParseFinalPuncts(pAux, pEnd, spacelessPuncts);  // a span of puncts, or none
				strEndPuncts = wxString(pAux, numEndPuncts); // strEndPuncts, at this iteration, will be 
															 // empty if pAux was not at a known punct
				// Gotta restore pAux to its saved position (see explanation at pSavePAux above)
				pAux = pSavePAux;

				if (numEndPuncts == 0)
				{
					// ParseFinalPuncts() stopped parsing before detecting any puncts from spacelessPuncts to
					// parse over, at this iteration. (Beware, earlier iterations may have parsed, stored on
					// pSrcPhrase, and augmented itemLenAccum, etc.)
					// So ignore the spaces parsed over, ptr should be returned unchanged in value
					itemLen = itemLenAccum;
					ptr = pChar + itemLen;
					return ptr;
				}
				else
				{
					// parsed one or more puncts from spacelessPuncts... find out how many were good ones
					CountGoodAndBadEndPuncts(strEndPuncts, numGoodOnes, numBadOnes); // for this iteration
					if (numEndPuncts == numGoodOnes)
					{
						// All of the puncts parsed over, are genuine following puncts, for storing in m_follPunct
						// at this iteration; so do the stores and updates and continue looping - a detached punct
						// may follow - keep looping until ptr does not advance
						pSrcPhrase->m_follPunct += strEndSpaces + strEndPuncts;
						pSrcPhrase->m_srcPhrase += strEndSpaces + strEndPuncts;
						itemSpan = numSpaces + numEndPuncts;
						itemLenAccum += itemSpan; // we are not exiting the function, so keep accumulating itemSpans
						pAux += itemSpan;
						ptr = pAux; // prepare for next iteration, as we set pAux to ptr at start of each iteration,
									// and itemSpan reset to 0 there too
						bIterateAgain = TRUE; // ensure we iterate this inner loop
					} // end of TRUE block for test: if (numEndPuncts == numGoodOnes)
					else
					{
						// There must have been at least one bad one, or maybe all were bad because all were actually
						// pre-word begin puncts belonging to the next pSrcPhrase. Handle these two possibilities.
						// The more draconian one first...
						if (numEndPuncts == numBadOnes)
						{
							// All belong on the next pSrcPhrase, so we can't advance pAux or ptr here, and so
							// there's no puncts to store in m_follPunct. In fact, we can return here, with
							// ptr unmoved from pAux, at this iteration (earlier iterations may have stored
							// something, but not this one)
							itemSpan = 0;
							itemLen = itemLenAccum; // no increase in itemLenAccum
							ptr = pChar + itemLen; // spaces parsed over in this iteration are ignored
							bIterateAgain = FALSE; // break out of the loop
						} // end of TRUE block for test: if (numEndPuncts == numBadOnes)
						else
						{
							// There are fewer bad ones than indicated by numEndPuncts. But a bad one must
							// cause the function, ParsePostWordPuncts(), to exit - because what's at pAux
							// + the good ones, belongs on the next pSrcPhrase. So we keep any good ones, 
							// because those must be stored in pSrcPhrase m_follPunct, and be appended to
							// m_srcPhrase as well, and itemLenAccum will set the itemLen value to return,
							// and also enable setting the ptr value for returning. Do those things here.
							itemSpan = numSpaces + numGoodOnes;
							itemLenAccum += itemSpan;
							strEndPuncts = wxString(pAux, itemSpan);
							pSrcPhrase->m_follPunct << strEndPuncts;
							pSrcPhrase->m_srcPhrase << strEndPuncts;
							itemLen = itemLenAccum;
							ptr = pChar + itemLen;
							bIterateAgain = FALSE; // break out of the loop
						} // end of else block for test: if (numEndPuncts == numBadOnes)

					} // end of else block for test: if (numEndPuncts == numGoodOnes)

				} // end of else block for test: if (numEndPuncts == 0)

			} // end of the else block for test: if (numSpaces == 0) -- i.e. there are spaces parsed over

		} // end of else block for test: if (*pAux == gSFescapechar)

	} // end of the while loop
	return ptr;
}

// BEW created 7Jun23 for use in ParsePostWordPuncts() which in turn is used in ParseWord() of TokenizeText()
void CAdapt_ItDoc::CountGoodAndBadEndPuncts(wxString strEndPuncts, int& nGood, int& nBad)
{
	// Count how many of strEndPuncts do NOT belong in strInitialPuncts, 
	// i.e. they are good ones (genuine word-following puncts).
	// Count also how many are bad ones - ie. being pre-word puncts
	// they belong in the next pSrcPhrase's m_precPunct member.
	nGood = 0;
	nBad = 0;
	int index;
	int numEndPuncts = strEndPuncts.Length();
	for (index = 0; index < numEndPuncts; index++)
	{
		wxChar chIter = strEndPuncts.GetChar(index);
		bool bIsGenuine = IsGenuineFollPunct(chIter);
		if (bIsGenuine)
		{
			// it's a good one
			nGood++;
		}
		else
		{
			// Found a pre-word punct that belongs at the start of the next pSrcPhrase,
			// so any further puncts cannot be legit final ones for the present pSrcPhrase.
			// Therefore count the bad ones so we can work out how many of strEndPuncts we need
			// to retain, when the for loop exits. If we retain at least one, then we will 
			// have an advancement of ptr, and the outer loop can keep iterating
			nBad++;
		} // end of else block for test: if (offset2 == wxNOT_FOUND)

	} // end of for loop: for (index = 0; index < numEndPuncts; index++)}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		pNewSrcPhrasesList			-> a list of pointers to CSourcePhrase instances
/// \param		nNewCount					-> how many entries are in the pNewSrcPhrasesList
///												list (currently unused)
/// \param		propagationType				<- the TextType value for the last CSourcePhrase
///												instance in the list
/// \param		bTypePropagationRequired	<- TRUE if the function determines that the caller
///												must take the returned propagationType value
///												and propagate it forwards until a CSourcePhrase
///												instance with its m_bFirstOfType member set TRUE
///												is encountered, otherwise FALSE (no propagation
///												needed)
/// \remarks
/// Called from: the Doc's RetokenizeText(), the View's ReconcileLists() and OnEditSourceText(),
/// and also from XML's MurderTheDocV4Orphans()
/// There are two uses for this function:
///   (1) To do navigation text, special text colouring, and TextType value cleanup
///         after the user has edited the source text - which potentially allows the user
///         to edit, add or remove markers and/or change their location. Editing of markers
///         potentially might make a typo marker into one currently designated as to be
///         filtered, so this is checked for and if it obtains, then the requisite
///         filtering is done at the end as an extra (automatic) step.
///   (2) To do the same type of cleanup job, but over the whole document from start to
///         end, after the user has changed the SFM set (which may also involve changing
///         filtering settings in the newly chosen SFM set, or it may not) - when used in
///         this way, all filtering changes will already have been done by custom code for
///         that operation, so DoMarkerHousekeeping() only needs to do the final cleanup of
///         the navigation text and text colouring and (cryptic) TextType assignments.
/// NOTE: m_FilterStatusMap.Clear(); is done early in DoMarkerHousekeeping(), so the prior
///         contents of the former will be lost.
/// BEW 24Mar10, updated for support of doc version 5(changes needed - just a block of code
/// removed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/// BEW 11Oct10 (actually 6Jan11) added code for closing off a TextType span because of
/// endmarker content within m_endMarkers - I missed doing this in the earlier tweaks
/// BEW 24Oct14, some changes for support of USFM nested markers - and there are a
/// few comments added within for explanatory purposes because some of the internal calls
/// are calls to functions refactored for USFM nested marker support
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::DoMarkerHousekeeping(SPList* pNewSrcPhrasesList, int WXUNUSED(nNewCount),
	TextType& propagationType, bool& bTypePropagationRequired)
{
	// The following comments were in the legacy versions, when this function was only used
	// after the source text was edited...
	// Typically, when this function is entered, the TextType may need adjusting or
	// setting, chapter and verse numbers and associated strings may need adjusting,
	// certain flags may need setting or clearing. This ensures all the attributes in each
	// sourcephrase instance are mutually consistent with the standard format markers
	// resulting from the user's editing of the source text and subsequent marker
	// editing/transfer operations.
	// The following indented comments only apply to the pre-3.7.0 versions:
		// Note: gpFollSrcPhrase may need to be accessed; but because this function is
		// called before unwanted sourcephrase instances are removed from the main list in
		// the case when the new sublist is shorter than the modified selected instances
		// sublist, then there would be one or more sourcephrase instances between the end
		// of the new sublist and gpFollSrcPhrase. If TextType propagation is required
		// after the sublist is copied to the main list and any unwanted sourcephrase
		// instances removed, then the last 2 parameters enable the caller to know the fact
		// and act accordingly
	// For the refactored source text edit functionality of 3.7.0, the inserting of new
	// instances is done after the old user's selection span's instances have been removed,
	// so there are no intervening unwanted CSourcePhrase instances. Propagation still may
	// be necessary, so we still return the 2 parameters to the caller for it to do any
	// such propagating. The function cannot be called, however, if the passed in list is
	// empty - it is therefore the caller's job to detect this and refrain

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	SPList* pL = pNewSrcPhrasesList;
	wxASSERT(pL);
	CSourcePhrase* pLastSrcPhrase = gpPrecSrcPhrase; // the one immediately preceding sublist
													 // (it could be null)
	CSourcePhrase* pFollowing = gpFollSrcPhrase; // first, following the sublist (could be null)
	CSourcePhrase* pSrcPhrase = 0; // the current one, used in our iterations

	gpApp->m_FilterStatusMap.clear();
	// empty the map, we want to use it to handle filtering of an edited marker
	// when the editing changes it to be a marker designated as one which is to be
	// filtered; we repopulate it just before the AnalyseMarker() call below

	// we'll use code and functions used for parsing source text, so we need to set up some
	// buffers so we can simulate the data structures pertinent to those function calls we
	// have to propagate the preceding m_bSpecialText value, until a marker changes it; if
	// there is no preceding context, then we can assume it is FALSE (if a \id follows,
	// then it gets reset TRUE later on)
	bool bSpecialText = FALSE;
	if (gpPrecSrcPhrase != 0)
		bSpecialText = gpPrecSrcPhrase->m_bSpecialText;

	// set up some local variables
	wxString mkrBuffer; // where we will copy standard format marker strings to, for parsing
	int itemLen = 0;

	// whm 4Sep2023 removed the App's buffer and ClearBuffer. Just use a local wxString buffer.
	wxString buffer;
	buffer.Empty();
	//int strLen = ClearBuffer(); // clear's the class's buffer[256] buffer
	//strLen = strLen; // avoid warning
	
	//bool bHitMarker; // set but not used

	// BEW added 01Oct06; if the sublist (ie. pNewSrcPhrasesList) is empty (because the
	// user deleted the selected source text, then we can't get a TextType value for the
	// end of the sublist contents; so we get it instead from the gpFollSrcPhrase global,
	// which will have been set in the caller already (if at the end of the doc we'll
	// default the value to verse so that the source text edit does not fail)
	TextType finalType; // set this to the TextType for the last sourcephrase instance
						// in the sublist -- but take note of the above comment sublist

	// whm Note: if the first position node of pL is NULL finalType will not have been
	// initialized (the while loop never entered) and a bogus value will get assigned to
	// propagationType after the while loop. It may never happen that pos_pL == NULL, but to
	// be sure I'm initializing finalType to noType
	finalType = noType;

	// BEW 24Oct14, next three lines added for the refactored LookupSFM() call later on
	bool bIsNestedMkr = FALSE;
	wxString tagOnly;
	wxString baseOfEndMkr;

	USFMAnalysis* pUsfmAnalysis = NULL; // whm added 11Feb05

	SPList::Node* pos_pL = pL->GetFirst();
	bool bInvalidLast = FALSE;
	if (pLastSrcPhrase == NULL) // MFC had == 0
		bInvalidLast = TRUE; // only possible if user edited source text at the very
							 // first sourcephrase in the doc iterate over each
							 // sourcephrase instance in the sublist
	bool bStartDefaultTextTypeOnNextIteration = FALSE;
	bool bSkipPropagation = FALSE;
	while (pos_pL != 0) // pos_pL will be NULL if the pL list is empty
	{
		pSrcPhrase = (CSourcePhrase*)pos_pL->GetData();
		pos_pL = pos_pL->GetNext();
		wxASSERT(pSrcPhrase);
		pSrcPhrase->m_inform.Empty(); // because AnalyseMarker() does +=, not =,
									  // so we must clear its contents first
#if defined (_DEBUG) && !defined(NOLOGS)
		if (pSrcPhrase->m_nSequNumber == 22)
		{
			int halt_here = 1; wxUnusedVar(halt_here);
		}

#endif

		// BEW 11Oct10 (actually 6Jan11) endmarkers in docV5 are no longer stored at the
		// start of the next CSourcePhrase's m_markers member, but on the current
		// CSourcePhrase which ends the actual TextType span. Therefore, interating
		// through the list we'll come to an m_endMarkers which ends a span such as a
		// footnote, endnore or cross reference before we come to the CSourcePhrase
		// instance which follows and for which m_bFirstOfType for the new TextType value
		// will be TRUE. So check here for non-empty m_endMarkers member (other storage of
		// markers, the inline types, doesn't affect TextType, so we can ignore those and
		// only need examine m_endMarkers), and if it contains \f* or \x* or \fe* for
		// USFM 2.x marker set, or \fe or \F for PNG 1998 marker set, then we must end the
		// type on the current pSrcPhrase (ie. it is the last with the current TextType
		// value) and tell the code that the next iteration of the loop must commence a
		// new TextType - which we'll default to 'verse' type, and m_bSpecialText = FALSE
		// -- the next iteration can then change to some other type if the next
		// iteration's pSrcPhrase->m_markers contains a final marker which changes the
		// TextType - the code for doing that is already in place below. How we'll tell
		// the code what to do on the next iteration will be done with a new local
		// boolean, bStartDefaultTextTypeOnNextIteration -- which we'll set TRUE if one of
		// the endmarkers of either set is found in m_endMarkers of the current instance;
		// We'll also need a bSkipPropagation flag, default FALSE, but when set TRUE, it causes
		// a skip of the code further down which propagates from the last CSourcePhrase
		// instance when m_markers is empty -- which is typically the case after an
		// endnote, footnote or cross reference
		bSkipPropagation = FALSE; // default value
		if (bStartDefaultTextTypeOnNextIteration)
		{
			// a switch to default TextType is requested - do it here, then let the code
			// below override the value we set here if m_markers has a last marker which
			// requires a different TextType value
			pSrcPhrase->m_curTextType = verse;
			pSrcPhrase->m_bSpecialText = FALSE;
			pSrcPhrase->m_bFirstOfType = TRUE;
			// m_inform has be cleared to default empty above, code further below may put
			// something in it (if m_markers is non-empty)
			bStartDefaultTextTypeOnNextIteration = FALSE; // restore default bool value
			bSkipPropagation = TRUE; // used about 70 lines below, to skip a code block
									 // for propagating from the previous instance, which
									 // is not wanted when we have already closed of a
									 // TextType span on the previous iteration (see the
									 // code block immediately below)
		}
		if (!pSrcPhrase->GetEndMarkers().IsEmpty())
		{
			wxArrayString array;
			array.Clear();
			pSrcPhrase->GetEndMarkersAsArray(&array);
			size_t count = array.GetCount();
			if (count > 0)
			{
				wxString wholeEndMkr; wholeEndMkr.Empty();
				wholeEndMkr = array.Item(count - 1); // get the last one, if there is more than one
									// for instance, it may have \ft*\f* in the old way of
									// doing USFM
				wxASSERT(!wholeEndMkr.IsEmpty());
				if (gpApp->gCurrentSfmSet == UsfmOnly || gpApp->gCurrentSfmSet == UsfmAndPng)
				{
					if (wholeEndMkr == _T("\\f*") || wholeEndMkr == _T("\\fe*") ||
						wholeEndMkr == _T("\\x*"))
					{
						// it's the end of either a footnote, endnote or cross reference
						bStartDefaultTextTypeOnNextIteration = TRUE;
						// whm 3Sep2023 added to ensure that m_inform is "end fn", esp for collaboration 
						// scenario where m_inform is otherwise empty - even when m_bFootnoteEnd is TRUE.
						// Note: This block is executing when there are end markers present, and 
						// this situation skips the calls of LookupSFM() and AnalyseMarker() that 
						// are done when processing the m_markers buffer in the other part of this
						// function below. Those calls - in particular the AnalyseMarker() call
						// if also done here would set the m_inform properly to "end fn", but
						// I'm assuming that TokenizeText() will have properly set the other pSrcPhrase
						// attributes/members, and/or code blocks below that treat m_markers with content.
						if (pSrcPhrase->m_bFootnoteEnd)
						{
							// m_inform was emptied above at start of this function so
							// it will always be empty at this point.
							pSrcPhrase->m_inform = _("end fn"); // localizable
						}
					}
				}
				else
				{
					// must be PngOnly
					if (wholeEndMkr == _T("\\fe") || wholeEndMkr == _T("\\F"))
					{
						// it's the end of a footnote (either the \fe marker or the \F
						// marker can end a footnote in the legacy marker set)
						bStartDefaultTextTypeOnNextIteration = TRUE;
					}
				}
			}
		}

		// get any marker text into mkrBuffer
		mkrBuffer = pSrcPhrase->m_markers;
		int lengthMkrs = mkrBuffer.Length();
		// wx version note: Since we require a read-only buffer we use GetData which just
		// returns a const wxChar* to the data in the string.
		const wxChar* pBuffer = mkrBuffer.GetData();
		wxChar* pEndMkrBuff; // set this dynamically, for each
							 // source phrase's marker string
		wxString temp; // can build a string here
		wxChar* ptr = (wxChar*)pBuffer;
		wxChar* pBufStart = (wxChar*)pBuffer;
		pEndMkrBuff = pBufStart + lengthMkrs; // point to null at end
		wxASSERT(*pEndMkrBuff == _T('\0')); // whm added for wx version - needs to be
											// set explicitly when mkrBuffer is empty
		if (mkrBuffer.IsEmpty())
		{
			// there is no marker string on this sourcephrase instance, so if we are at the
			// beginning of the document, m_bFirstOfType will be TRUE, otherwise, there
			// will be a preceding sourcephrase instance and m_bFirstOfType will be FALSE,
			// and we can just copy it's value
			if (bInvalidLast)
			{
				pSrcPhrase->m_bFirstOfType = TRUE;
				pSrcPhrase->m_curTextType = verse; // this is the only possibility,
												   // at start of doc & no marker
				bInvalidLast = FALSE; // all subsequent sourcephrases will have a valid
									  // preceding one
				pSrcPhrase->m_inform.Empty();
				pSrcPhrase->m_chapterVerse.Empty();
				pSrcPhrase->m_bSpecialText = bSpecialText; // can not be special text here
			}
			else
			{
				if (!bSkipPropagation)
				{
					// if no skipping of this propagation code is wanted, then do the
					// propagation from the earlier instance; when bSkipPropagation is
					// TRUE, we skip because in code above we've closed of a TextType span
					// already and so this pSrcPhrase is the first of a new TextType span,
					// which defaults to verse and not special text in the absence of a
					// marker to specify otherwise
					pSrcPhrase->m_bFirstOfType = FALSE;
					pSrcPhrase->m_curTextType = pLastSrcPhrase->m_curTextType; // propagate the
																	// earlier instance's type
					// whm 3Sep2023 commented out the m_inform.Empty() call below, otherwise 
					// "fn end" gets removed from above.
					//pSrcPhrase->m_inform.Empty();
					pSrcPhrase->m_chapterVerse.Empty();
					// propagate the previous value
					pSrcPhrase->m_bSpecialText = pLastSrcPhrase->m_bSpecialText;
				}
			}
		} // end of TRUE block for test: if (mkrBuffer.IsEmpty())
		else
		{
			// there is a marker string on this sourcephrase instance
			if (bInvalidLast)
			{
				// we are at the very beginning of the document
				pLastSrcPhrase = 0; // ensure its null
				bInvalidLast = FALSE; // all subsequent sourcephrases will have a valid
									  // preceding one
				pSrcPhrase->m_bSpecialText = bSpecialText; // assume this value, the marker
														   // may later change it
				goto x; // code at x comes from TokenizeText, and should not break for
						// pLast == 0
			}
			else
			{
				// we are not at the beginning of the document
				pSrcPhrase->m_bSpecialText = pLastSrcPhrase->m_bSpecialText; // propagate
																	// previous, as default
			x:	while (ptr < pEndMkrBuff)
				{
					if (IsWhiteSpace(ptr))
					{
						itemLen = ParseWhiteSpace(ptr);
						ptr += itemLen; // advance pointer past the white space
					}

					// are we at the end of the markers text string?
					if (IsEnd(ptr) || ptr >= pEndMkrBuff)
					{
						break;
					}

					// are we pointing at a standard format marker?
				b:	if (IsMarker(ptr)) // pBuffer added for v1.4.1 contextual sfms
					{
						// its a marker of some kind
						int nMkrLen = 0;
						if (IsVerseMarker(ptr, nMkrLen))
						{
							if (nMkrLen == 2)
							{
								// its a verse marker
								buffer += gSFescapechar;
								buffer += _T("v");
								ptr += 2; // point past the \v marker
							}
							else
							{
								// its an Indonesia branch verse marker \vn
								buffer += gSFescapechar;
								buffer += _T("vn");
								ptr += 3; // point past the \vn marker
							}

							itemLen = ParseWhiteSpace(ptr);
							AppendItem(buffer, temp, ptr, itemLen); // add white
																	   // space to buffer
							ptr += itemLen; // point at verse number

							itemLen = ParseNumber(ptr);
							AppendItem(buffer, temp, ptr, itemLen); // add number (or range
																	   // eg. 3-5) to buffer
							// whm 11Jun12 added !pApp->m_curChapter.IsEmpty() && to the test below
							// since GetChar(0) should never be called on an empty string
							// whm 5Sep2023 test. Decided to comment out all use of the App's global 
							// m_curChapter and leave the existing pSrcPhrase->m_chapterVerse
							// unchanged from its value determined in the previous TokenizeText() call.
							/*
							if (!pApp->m_curChapter.IsEmpty())
							{
								if (pApp->m_curChapter.GetChar(0) == '0')
								{
									pApp->m_curChapter.Empty(); // caller will have set it non-zero
																// if there are chapters
								}
							}
							pSrcPhrase->m_chapterVerse = pApp->m_curChapter; // set to n: form
							pSrcPhrase->m_chapterVerse += temp; // append the verse number
							*/
							pSrcPhrase->m_bVerse = TRUE; // set the flag to signal start of a
														 // new verse
							ptr += itemLen; // point past verse number

							// set pSrcPhrase attributes
							pSrcPhrase->m_bVerse = TRUE;
							if (pSrcPhrase->m_curTextType != poetry) // poetry sfm comes before \v
							{
								// if its already poetry, don't change it
								pSrcPhrase->m_curTextType = verse;
							}
							pSrcPhrase->m_bSpecialText = FALSE;

							itemLen = ParseWhiteSpace(ptr); // past white space which is
															// after the marker
							AppendItem(buffer, temp, ptr, itemLen); // add it to the buffer
							ptr += itemLen; // point past the white space

							goto b; // check if another marker follows:
						}
						else
						{
							// some other kind of marker - perhaps its a chapter marker?
							if (IsChapterMarker(ptr))
							{
								// its a chapter marker
								buffer += gSFescapechar;
								buffer += _T("c");
								ptr += 2; // point past the \c marker

								itemLen = ParseWhiteSpace(ptr);
								AppendItem(buffer, temp, ptr, itemLen); // add white space
																		   // to buffer
								ptr += itemLen; // point at chapter number
								itemLen = ParseNumber(ptr);
								AppendItem(buffer, temp, ptr, itemLen); // add chapter number
																		   // to buffer
								// whm 5Sep2023 test. Decided to comment out all use of the App's global 
								// m_curChapter and leave the existing pSrcPhrase->m_chapterVerse
								// unchanged from its value determined in the previous TokenizeText() call.
								/*
								pApp->m_curChapter = temp;
								pApp->m_curChapter += _T(':'); // get it ready to
															   // append verse numbers
								*/
								ptr += itemLen; // point past chapter number

								// set pSrcPhrase attributes
								pSrcPhrase->m_bChapter = TRUE;
								pSrcPhrase->m_bVerse = TRUE; // always have verses following a
															 // chapter
								if (pSrcPhrase->m_curTextType != poetry) // poetry sfm comes before \v
								{
									pSrcPhrase->m_curTextType = verse;
								}
								pSrcPhrase->m_bSpecialText = FALSE;

								itemLen = ParseWhiteSpace(ptr); // parse white space following
																// the number
								AppendItem(buffer, temp, ptr, itemLen); // add it to buffer
								ptr += itemLen; // point past it

								goto b; // check if another marker follows
							}
							else
							{
								// neither verse nor chapter, so we don't have to worry
								// about a following number, so just append the marker to
								// the buffer string

								// BEW 24Oct14 the next call also handles USFM nested markers
								// correctly, but internally constructing the unnested equivalent
								// marker and doing the lookup with that - so no change is
								// needed here; ParseMarker() is also refactored for support
								// of USFM nested markers. The markers we are dealing with are
								// from m_markers member only, and there should never be a
								// nested marker stored there. So we could use LookupSFM(ptr)
								// equally well here; but if we use the 4 param signature
								// override, then we should test that bIsNestedMkr is always
								// FALSE here.
								// Returns NULL if unknown marker
								pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr);

								// whm 24Feb2022 modified the following code (wxASSERT) after getting
								// notice from Prabhu B about a Debug Alert from the wxASSERT(bIsNestedMkr == FALSE)
								// line below that kept popping up for him in the release version. His situation
								// is a collaboration with Paratext. 
								// After getting Prabhu's data for both Paratext 9.2 and Adapt It, I could not
								// replicate the "debug alert" he was getting, that is, in my tests of his
								// data the following wxASSERT() NEVER trips when opening either GEN ch 1 or ch 2.
								// So, to prevent him from being bothered by repeated "debug alert"s, I'm changing
								// the wxASSERT() below to just logging the situation in the user log file.
								//wxASSERT(bIsNestedMkr == FALSE);
								if (bIsNestedMkr)
								{
									// get temp values for ptr and ItemLen
									wxChar* tempptr = ptr;
									int tempItemLen = ParseMarker(tempptr);
									wxString tempMkr(tempptr, tempItemLen);
									wxString msg = _T("In DoMarkerHousekeeping() marker %s unexpectedly bIsNestedMkr is TRUE, IGNORING");
									msg = msg.Format(msg, tempMkr.c_str());
									pApp->LogUserAction(msg);
								}
								wxUnusedVar(tagOnly);
								wxUnusedVar(baseOfEndMkr);
								itemLen = ParseMarker(ptr);
								AppendItem(buffer, temp, ptr, itemLen);

								// we wish to know if this marker, which is not within a
								// span bracketed by \~FILTER followed by \~FILTER*, has
								// potentially been edited so that it really needs to be
								// filtered, along with its following text content, rather
								// than left unfiltered and its content visible for
								// adapting in the doc. If it should be filtered, we will
								// put an entry into m_FilterStatusMap to that effect, and
								// the caller will later use the fact that that map is not
								// empty to call RetokenizeText() with the option for
								// filter changes turned on (ie. bool parameter 2 in the
								// call is TRUE), and that will accomplish the required
								// filtering.
								wxString mkr(ptr, itemLen); // construct the wholeMarker
								wxString mkrPlusSpace = mkr + _T(' '); // add the trailing space
								// BEW 24Oct14, USFM nested markers are not filterable
								// because they are not important enough; so the way to
								// support USFM markers here is simply to let a marker of form
								// \+tag be passed in as-is, it will fail to be matched, which
								// would result in wxNOT_FOUND being returned, and no filtering
								// would be done due to it
								int curPos = gpApp->gCurrentFilterMarkers.Find(mkrPlusSpace);
								if (curPos >= 0)
								{
									// its a marker, currently unfiltered, which should be
									// filtered
									wxString valStr;
									if (gpApp->m_FilterStatusMap.find(mkr) == gpApp->m_FilterStatusMap.end())
									{
										// marker does not already exist in
										// m_FilterStatusMap so add it as an entry meaning
										// 'now to be filtered' (a 1 value)
										(gpApp->m_FilterStatusMap)[mkr] = _T("1");
									}
								}

								// set default pSrcPhrase attributes
								if (pSrcPhrase->m_curTextType != poetry)
									pSrcPhrase->m_curTextType = verse; // assume verse unless
																	 // AnalyseMarker changes it

								// analyse the marker and set fields accordingly
								// BEW 24Oct14 this call, if the marker was a nested one,
								// will use the pUsfmAnalysis obtained above, which will
								// be obtained from the non-nested equivalent marker, so
								// no other change is needed here
								pSrcPhrase->m_bSpecialText = AnalyseMarker(pSrcPhrase, pLastSrcPhrase,
									(wxChar*)ptr, itemLen, pUsfmAnalysis);

								// advance pointer past the marker
								ptr += itemLen;

								itemLen = ParseWhiteSpace(ptr); // parse white space after it
								AppendItem(buffer, temp, ptr, itemLen); // add it to buffer
								ptr += itemLen; // point past it
								goto b; // check if another marker follows
							} // end of else block of if (IsChapterMarker(ptr))
						} // end of else block of if (IsVerseMarker(ptr, nMkrLen))
					}
					else
					{
						// get ready for next iteration
						buffer.Empty(); // whm 4Sep2023 removed App's buffer, and made a local wxString buffer instead
						// strLen = ClearBuffer(); // empty the small working buffer
						itemLen = 0;
						ptr++;	// whm added. The legacy did not increment ptr here.
								// The legacy app never reached this else block, because,
								// if it had, it would enter an endless loop. The version 3
								// app can have filtered text and can potentially reach
								// this else block, so we must ensure that we avoid an
								// endless loop by incrementing ptr here.
					}
				} // end of while (ptr < pEndMkrBuff)
			} // end of else block of if (bInvalidLast)
		} // end of else block for test: if (mkrBuffer.IsEmpty())

		// make this one be the "last" one for next time through
		pLastSrcPhrase = pSrcPhrase;
		finalType = pSrcPhrase->m_curTextType; // keep this updated continuously, to be used
											   // below
		gbSpecialText = pSrcPhrase->m_bSpecialText; // the value to be propagated at end of
													// OnEditSourceText()
	} // end of while (pos_pL != 0) loop

	// BEW added 01Oct06; handle an empty list situation (the above loop won't have been
	// entered so finalType won't yet be set
	if (pL->IsEmpty())
	{
		finalType = verse; // the most likely value, so the best default if the code
						   // below doesn't set it
		if (gpFollSrcPhrase != NULL)
		{
			// using the following CSourcePhrase's TextType value is a sneaky way to ensure
			// we don't get any propagation done when the sublist was empty; as we don't
			// expect deleting source text to bring about the need for any propagation
			// since parameters should be correct already
			finalType = gpFollSrcPhrase->m_curTextType;
		}
		// BEW added 19Jun08; we need to also give a default value for gbSpecialText in
		// this case to, because prior to this change it was set only within the loop and
		// not here, and leaving it unset here would result in who knows what being
		// propagated, it could have been TRUE or FALSE when this function was called
		gbSpecialText = FALSE; // assume we want 'inspired text' colouring
	}

	// at the end of the (sub)list, we may have a different TextType than for the
	// sourcephrase which follows, if so, we will need to propagate the type if a standard
	// format marker does not follow, provided we are not at the document end, until either
	// we reach the doc end, or till we reach an instance with m_bFirstOfType set TRUE; but
	// nothing need be done if the types are the same already. We also have to propagate
	// the m_bSpecialText value, by the same rules.... if we have been cleaning up after an
	// SFM set change, which is done over the whole document (ie. m_pSourcePhrases list is
	// the first parameter), then pFollowing will have been set null in the caller, and no
	// propagation would be required
	bTypePropagationRequired = FALSE;
	propagationType = finalType;
	if (pFollowing == NULL) // MFC had == 0
		return;		// we are at the end of the document, so no propagation is needed
	if (pFollowing->m_curTextType == finalType)
		return;		// types are identical, so no propagation is needed
	if (pFollowing->m_bFirstOfType)
		return; // type changes here obligatorily (probably due to a marker), so
				// we cannot propagate

	// if we get here, then propagation is required - so return that fact to the caller
	bTypePropagationRequired = TRUE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if no errors; FALSE if an error occurred
/// \param		exportPathUsed		<- a wxString to return the path/name of the packed
///                                 document to the caller
/// \param      bInvokeFileDialog -> TRUE (default) presents the wxFileDialog; FALSE
///                                 uses the <current doc name>.aip
/// \remarks
/// Called from: the Doc's OnFilePackDocument() and EmailReportDlg::OnBtnAttachPackedDoc.
/// Assembles the raw contents that go into an Adapt It Packed Document into the packByteStr
/// which is a CBString byte buffer.
/// whm 6Aug11 revised for when navigation protection is ON for the _PACKED_INPUTS_OUTPUTS
/// folder. Note: The Pack Document... and the Unpack Document... commands are not available
/// when collaboration with Paratext/Bibledit is activated.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::DoPackDocument(wxString& exportPathUsed, bool bInvokeFileDialog)
{
	CBString packByteStr;
	wxString packStr;
	packStr.Empty();

	// whm 26Aug11 Open a wxProgressDialog instance here for packing doc operations.
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	wxString msgDisplayed;
	const int nTotal = gpApp->GetMaxRangeForProgressDialog(App_SourcePhrases_Count) + 1;
	wxString progMsg = _("%s  - %d of %d Total words and phrases");
	wxFileName fn(gpApp->m_curOutputFilename);
	msgDisplayed = progMsg.Format(progMsg, fn.GetFullName().c_str(), 1, nTotal);
	CStatusBar* pStatusBar = NULL;
	pStatusBar = (CStatusBar*)gpApp->GetMainFrame()->m_pStatusBar;
	pStatusBar->StartProgress(_("Packing Document"), msgDisplayed, nTotal);

	// first character needs to be a 1 for the regular app doing the pack, or a 2 for the
	// Unicode app (as resulting from sizeof(wxChar) ) and the unpacking app will have to
	// check that it is matching; and if not, warn user that continuing the unpack might
	// not result in properly encoded text in the docment (but allow him to continue,
	// because if source and target text are all ASCII, the either app can read the packed
	// data from the other and give valid encodings in the doc when unpacked.)
	//
	// whm Note: The legacy logic doesn't work cross-platform! The sizeof(char) and
	// sizeof(w_char) is not constant across platforms. On Windows sizeof(char) is 1 and
	// sizeof(w_char) is 2; but on all Unix-based systems (i.e., Linux and Mac OS X) the
	// sizeof(char) is 2 and sizeof(w_char) is 4. We can continue to use '1' to indicate
	// the file was packed by an ANSI version, and '2' to indicate the file was packed by
	// the Unicode app for back compatibility. However, the numbers cannot signify the size
	// of char and w_char across platforms. They can only be used as pure signals for ANSI
	// or Unicode contents of the packed file. Here in OnFilePackDoc we will save the
	// string _T("1") if we're packing from an ANSI app, or the string _T("2") if we're
	// packing from a Unicode app. See DoUnpackDocument() for how we can interpret "1" and
	// "2" in a cross-platform manner.
	//
#ifdef _UNICODE
	packStr = _T("2");
#else
	packStr = _T("1");
#endif

	packStr += _T("|*0*|"); // the zeroth unique delimiter

	// get source and target language names, or whatever is used for these
	wxString curSourceName;
	wxString curTargetName;
	gpApp->GetSrcAndTgtLanguageNamesFromProjectName(gpApp->m_curProjectName,
		curSourceName, curTargetName);

	// get the book information (mode flag, disable flag, and book index; as ASCII string
	// with colon delimited fields)
	wxString bookInfoStr;
	bookInfoStr.Empty();
	if (gpApp->m_bBookMode)
	{
		bookInfoStr = _T("1:");
	}
	else
	{
		bookInfoStr = _T("0:");
	}
	if (gpApp->m_bDisableBookMode)
	{
		bookInfoStr += _T("1:");
	}
	else
	{
		bookInfoStr += _T("0:");
	}
	if (gpApp->m_nBookIndex != -1)
	{
		bookInfoStr << gpApp->m_nBookIndex;
	}
	else
	{
		bookInfoStr += _T("-1");
	}

	wxLogNull logNo; // avoid spurious messages from the system

	// update and save the project configuration file
	bool bOK = TRUE; // whm initialized, BEW changed to default TRUE 25Nov09
	// BEW added flag to the following test on 25Nov09
	if (!gpApp->m_curProjectPath.IsEmpty() && !gpApp->m_bReadOnlyAccess)
	{
		if (gpApp->m_bUseCustomWorkFolderPath && !gpApp->m_customWorkFolderPath.IsEmpty())
		{
			// whm 10Mar10, must save using what paths are current, but when the custom
			// location has been locked in, the filename lacks "Admin" in it, so that it
			// becomes a "normal" project configuration file in m_curProjectPath at the
			// custom location.
			if (gpApp->m_bLockedCustomWorkFolderPath)
				bOK = gpApp->WriteConfigurationFile(szProjectConfiguration, gpApp->m_curProjectPath, projectConfigFile);
			else
				bOK = gpApp->WriteConfigurationFile(szAdminProjectConfiguration, gpApp->m_curProjectPath, projectConfigFile);
		}
		else
		{
			bOK = gpApp->WriteConfigurationFile(szProjectConfiguration, gpApp->m_curProjectPath, projectConfigFile);
		}
	}
	// we don't expect any failure here, so an English message hard coded will do
	if (!bOK)
	{
		wxMessageBox(_T(
			"Writing out the configuration file failed in OnFilePackDoc, command aborted\n"),
			_T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(_T("Writing out the configuration file failed in OnFilePackDoc, command aborted"));
		pStatusBar->FinishProgress(_("Packing Document"));
		return FALSE;
	}

	// get the size of the configuration file, in bytes
	wxFile f;
	wxString configFile = gpApp->m_curProjectPath + gpApp->PathSeparator +
		szProjectConfiguration + _T(".aic");
	int nConfigFileSize = 0;
	if (f.Open(configFile, wxFile::read))
	{
		nConfigFileSize = f.Length();
		wxASSERT(nConfigFileSize);
	}
	else
	{
		wxMessageBox(_T(
			"Getting the configuration file's size failed in OnFilePackDoc, command aborted\n"),
			_T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(_T("Getting the configuration file's size failed in OnFilePackDoc, command aborted"));
		pStatusBar->FinishProgress(_("Packing Document"));
		return FALSE;
	}
	f.Close(); // needed because in wx we opened the file

	// save the doc as XML
	bool bSavedOK = TRUE;
	// BEW added test on 25Nov09, so documents can be packed when user has read only access
	// BEW changed 29Apr10, to use DoFileSave_Protected() rather than DoFileSave() because the
	// former gives better protection against data loss in the event of file truncation
	// due to a processing error.
	if (!gpApp->m_bReadOnlyAccess)
	{
		bSavedOK = DoFileSave_Protected(TRUE, _("Packing Document"));
		// English error message will have been seen in the call, so just prevent the pack
		// from proceeding further; but we don't expect a failure in DoFileSave_Protected()
		if (!bSavedOK)
		{
			gpApp->LogUserAction(_T("DoFileSave_Protected() return FALSE in DoPackDocument() at line 16,022"));
			wxCHECK_MSG(bSavedOK, FALSE, _T("DoPackDocument(): DoFileSave_Protected() failed, so packing was not done"));
		}
	}

	// construct the absolute path to the document as it currently is on disk; if the
	// local user has read-only access, the document on disk may not have been recently
	// saved. (Read-only access must not force document saves on a remote user
	// who has ownership of writing permission for data in the project; otherwise, doing
	// so could cause data to be lost)
	wxString docPath;
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
	{
		docPath = gpApp->m_bibleBooksFolderPath;
	}
	else
	{
		docPath = gpApp->m_curAdaptationsPath;
	}
	docPath += gpApp->PathSeparator + gpApp->m_curOutputFilename; // it will have .xml extension

	// get the size of the document's XML file, in bytes
	int nDocFileSize = 0;
	if (f.Open(docPath, wxFile::read))
	{
		nDocFileSize = f.Length();
		wxASSERT(nDocFileSize);
	}
	else
	{
		wxMessageBox(_T(
			"Getting the document file's size failed in OnFilePackDoc, command aborted\n"),
			_T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(_T("Getting the document file's size failed in OnFilePackDoc, command aborted"));
		pStatusBar->FinishProgress(_("Packing Document"));
		return FALSE;
	}
	f.Close(); // needed for wx version which opened the file to determine its size

	// construct the composed information required for the pack operation, as a wxString
	packStr += curSourceName;
	packStr += _T("|*1*|"); // the first unique delimiter
	packStr += curTargetName;
	packStr += _T("|*2*|"); // the second unique delimiter
	packStr += bookInfoStr;
	packStr += _T("|*3*|"); // the third unique delimiter
	packStr += gpApp->m_curOutputFilename;
	packStr += _T("|*4*|"); // the fourth unique delimiter

	// set up the byte string for the data, taking account of whether we have unicode data
	// or not
#ifdef _UNICODE
	packByteStr = gpApp->Convert16to8(packStr);
#else
	packByteStr = packStr.c_str();
#endif

	// from here on we work with bytes, and so use CBString rather than wxString for the data

	if (!f.Open(configFile, wxFile::read))
	{
		// if error, just return after telling the user about it -- English will do,
		// it shouldn't happen
		wxString s;
		s = s.Format(_T(
			"Could not open a file stream for project config, in OnFilePackDoc(), for file %s"),
			gpApp->m_curProjectPath.c_str());
		wxMessageBox(s, _T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(s);
		pStatusBar->FinishProgress(_("Packing Document"));
		return FALSE;
	}
	int nFileLength = nConfigFileSize; // our files won't require more than
									   // an int for the length

	// create a buffer large enough to receive the whole lot, allow for final null byte (we
	// don't do anything with the data except copy it and resave it, so a char buffer will
	// do fine for unicode too), then fill it
	char* pBuff = new char[nFileLength + 1];
	memset(pBuff, 0, nFileLength + 1);
	int nReadBytes = f.Read(pBuff, nFileLength);
	if (nReadBytes < nFileLength)
	{
		wxMessageBox(_T(
			"Project file read was short, some data missed so abort the command\n"),
			_T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(_T("Project file read was short, some data missed so abort the command"));
		pStatusBar->FinishProgress(_("Packing Document"));
		return FALSE;
	}
	f.Close(); // assume no errors

	// append the configuration file's data to packStr and add the next
	// unique delimiter string
	packByteStr += pBuff;
	packByteStr += "|*5*|"; // the fifth unique delimiter

	// clear the buffer, then read in the document file in similar fashion &
	// delete the buffer when done
	delete[] pBuff;
	if (!f.Open(docPath, wxFile::read))
	{
		// if error, just return after telling the user about it -- English will do,
		// it shouldn't happen
		wxString s;
		s = s.Format(_T(
			"Could not open a file stream for the XML document as text, in OnFilePackDoc(), for file %s"),
			docPath.c_str());
		wxMessageBox(s, _T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(s);
		pStatusBar->FinishProgress(_("Packing Document"));
		return FALSE;
	}
	nFileLength = nDocFileSize; // our files won't require more than an int for the length
	pBuff = new char[nFileLength + 1];
	memset(pBuff, 0, nFileLength + 1);
	nReadBytes = f.Read(pBuff, nFileLength);
	if (nReadBytes < nFileLength)
	{
		wxMessageBox(_T(
			"Document file read was short, some data missed so abort the command\n"),
			_T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(_T("Document file read was short, some data missed so abort the command"));
		pStatusBar->FinishProgress(_("Packing Document"));
		return FALSE;
	}
	f.Close(); // assume no errors
	packByteStr += pBuff;
	delete[] pBuff;

	// whm Pack design notes for future consideration:
	// 1. Initial design calls for the packing/compression of a single Adapt It document
	//    at a time. With the freeware zip utils provided by Lucian Eischik (based on zlib
	//    and info-zip) it would be relatively easy in the future to have the capability of
	//    packing multiple files into the .aip zip archive.
	// 2. Packing/zipping can be accomplished by doing it on external files (as done below)
	//    or by doing it in internal buffers (in memory).
	// 3. If in future we want to do the packing/zipping in internal buffers, we would do it
	//    with the contents of packByteStr after this point in OnFilePackDoc, and before
	//    the pBuf is written out via CFile ff below.
	// 4. If done in a buffer, after compression we could add the following Warning statement
	//    in uncompressed form to the beginning of the compressed character buffer (before
	//    writing it to the .aip file): "|~WARNING: DO NOT ATTEMPT TO CHANGE THIS FILE WITH
	//    AN EDITOR OR WORD PROCESSOR! IT CAN ONLY BE UNCOMPRESSED WITH THE UNPACK COMMAND
	//    FROM WITHIN ADAPT IT VERSION 3.X. COMPRESSED DATA FOLLOWS:~|"
	//    The warning would serve as a warning to users if they were to try to load the file
	//    into a word processor, not to edit it or save it within the word processor,
	//    otherwise the packed file would be corrupted. The warning (without line breaks
	//    or quote marks) would be 192 bytes long. When the file would be read from disk
	//    by DoUnpackDocument, this 192 byte warning would be stripped off prior to
	//    uncompressing the remaining data using the zlib tools.

	// whm 22Sep06 update: The wx version now uses wxWidget's built-in wxZipOutputStream
	// facilities for compressing and uncompressing packed documents, hence, it no longer
	// needs the services of Lucian Eischik's zip and unzip library. The wxWidget's zip
	// format is based on the same free-ware zlib library, so there should be no problem
	// zipping and unzipping .aip files produced by the MFC version or the WX version.

	wxString exportFilename;
	wxString exportPath;
	wxString uniqueFilenameAndPath;
	wxString defaultDir;
	// whm 6Aug11 modified.
	// Check whether navigation protection is in effect for _PACKED_INPUTS_OUTPUTS,
	// and whether the App's m_lastPackedOutputPath is empty or has a valid path,
	// and set the defaultDir for the export accordingly.
	bool bBypassFileDialog_ProtectedNavigation = FALSE;
	if (gpApp->m_bProtectPackedInputsAndOutputsFolder)
	{
		// Navigation protection is ON, so set the flag to bypass the wxFileDialog
		// and force the use of the special protected folder for the export.
		bBypassFileDialog_ProtectedNavigation = TRUE;
		exportPath = gpApp->m_packedInputsAndOutputsFolderPath;
		defaultDir = gpApp->m_packedInputsAndOutputsFolderPath;
	}
	else if (gpApp->m_lastPackedOutputPath.IsEmpty()
		|| (!gpApp->m_lastPackedOutputPath.IsEmpty() && !::wxDirExists(gpApp->m_lastPackedOutputPath)))
	{
		// Navigation protection is OFF so we set the flag to allow the wxFileDialog
		// to appear. But the m_lastPackedOutputPath is either empty or, if not empty,
		// it points to an invalid path, so we initialize the defaultDir to point to
		// the special protected folder, even though Navigation protection is not ON.
		// In this case, the user could point the export path elsewhere using the
		// wxFileDialog that will appear.
		bBypassFileDialog_ProtectedNavigation = FALSE;
		exportPath = gpApp->m_packedInputsAndOutputsFolderPath;
		defaultDir = gpApp->m_packedInputsAndOutputsFolderPath;
	}
	else
	{
		// Navigation protection is OFF and we have a valid path in m_lastPackedOutputPath,
		// so we initialize the defaultDir to point to the m_lastPackedOutputPath for the
		// location of the export. The user could still point the export path elsewhere
		// in the wxFileDialog that will appear.
		bBypassFileDialog_ProtectedNavigation = FALSE;
		exportPath = gpApp->m_lastPackedOutputPath;
		defaultDir = gpApp->m_lastPackedOutputPath;
	}
	// make a suitable default output filename for the packed data
	exportFilename = gpApp->m_curOutputFilename;
	int len = exportFilename.Length();
	exportFilename.Remove(len - 3, 3); // remove the xml extension
	exportFilename += _T("aip"); // make it a *.aip file type

	// whm addition 21Feb12. Bruce at Kim's request suggests we identify the language
	// names by including them (prefixed) in the composed name of the Packed Document. This would
	// be helpful for when a computer has multiple AI projects since the _PACKED_INPUTS_OUTPUTS
	// folder (or whatever folder) is not associated with a particular project, but is
	// located directly within the Adapt It Unicode Work folder.
	exportFilename = gpApp->m_sourceName + _T('-') + gpApp->m_targetName + _T('_') + exportFilename;

	// Remove any _Collab_ part of the name which isn't really necessary.
	exportFilename.Replace(_T("_Collab_"), _T(""), TRUE);

	// Here we add the incoming parameter bInvokeFileDialog to the test. When DoPackDocument()
	// is called from EmailReportDlg.cpp it calls it with the bInvokeFileDialog parameter
	// FALSE because it wants the document packed without user interaction in order to attach
	// the currently open doc as a packed document to the email report.
	if (!bBypassFileDialog_ProtectedNavigation && bInvokeFileDialog)
	{
		// Control goes through this block when Navigation protection is OFF for
		// _PACKED_INPUTS_OUTPUTS and when the bInvokeFileDialog is TRUE (bInvokeFileDialog
		// is TRUE when DoPackDocument() is called from the "Pack Document..." command,
		// but FALSE when DoPackDocument() is called from EmailReportDlg.cpp). In other
		// words this block is not executed when attaching packed documents to email
		// reports, and not executed when Navigation Protection is ON.
		wxString filter;
		// get a file Save As dialog for Source Text Output
		filter = _("Packed Documents (*.aip)|*.aip||"); // set to "Packed Document (*.aip) *.aip"
		wxFileDialog fileDlg(
			(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
			_("Filename For Packed Document"),
			defaultDir,
			exportFilename,
			filter,
			wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
		// wxHIDE_READONLY was deprecated in 2.6 - the checkbox is never shown
		// GDLC wxSAVE & wxOVERWRITE_PROMPT were deprecated in 2.8
		fileDlg.Centre();

		if (fileDlg.ShowModal() != wxID_OK)
		{
			// user cancelled file dialog so return to what user was doing previously, because
			// this means he doesn't want the Pack Document... command to go ahead
			gpApp->LogUserAction(_T("Cancelled from DoPackDocument() at wxFileDialog()"));
			pStatusBar->FinishProgress(_("Packing Document"));
			return FALSE;
		}

		// get the user's desired path
		exportPath = fileDlg.GetPath();
	}
	else
	{
		// Either Navigation Protection is ON, or the bInvokeFileDialog is FALSE. This
		// block is executed when Nav Protection is ON and when packing documents for
		// email reports.
		exportPath = exportPath + gpApp->PathSeparator + exportFilename;
		// Ensure that exportPath is unique so we don't overwrite any existing ones in the
		// appropriate outputs folder.
		uniqueFilenameAndPath = GetUniqueIncrementedFileName(exportPath, incrementViaDate_TimeStamp, TRUE, 2, _T("_packed_")); // TRUE - always modify
		// Use the unique path for exportPath
		exportPath = uniqueFilenameAndPath;
	}

	// get the length of the total byte string in packByteStr (exclude the null byte)
	int fileLength = packByteStr.GetLength();

	// wx version: we use the wxWidgets' built-in zip facilities to create the zip file,
	// therefore we no longer need the zip.h, zip.cpp, unzip.h and unzip.cpp freeware files
	// required for the MFC version.
	// first, declare a simple output stream using the temp zip file name
	// we set up an input file stream from the file having the raw data to pack
	wxString tempZipFile;
	wxString nameInZip;
	int extPos = exportPath.Find(_T(".aip"));
	tempZipFile = exportPath.Left(extPos);
	extPos = exportFilename.Find(_T(".aip"));
	nameInZip = exportFilename.Left(extPos);
	nameInZip = nameInZip + _T(".aiz");

	wxFFileOutputStream zippedfile(exportPath);
	// then, declare a zip stream placed on top of it (as zip generating filter)
	wxZipOutputStream zipStream(zippedfile);
	// wx version: Since our pack data is already in an internal buffer in memory, we can
	// use wxMemoryInputStream to access packByteStr; run it through a wxZipOutputStream
	// filter and output the resulting zipped file via wxFFOutputStream.
	wxMemoryInputStream memStr(packByteStr, fileLength);
	// create a new entry in the zip file using the .aiz file name
	zipStream.PutNextEntry(nameInZip);
	// finally write the zipped file, using the data associated with the zipEntry
	zipStream.Write(memStr);
	if (!zipStream.Close() || !zippedfile.Close() ||
		zipStream.GetLastError() == wxSTREAM_WRITE_ERROR) // Close() finishes writing the
													// zip returning TRUE if successfully
	{
		wxString msg;
		msg = msg.Format(_("Could not write to the packed/zipped file: %s"), exportPath.c_str());
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(msg, _T(""), wxICON_ERROR | wxOK);
		gpApp->LogUserAction(msg);
	}

	exportPathUsed = exportPath;

	// whm 14Jul11 added message
	if (bInvokeFileDialog)
	{
		// Except for when preparing packed documents to attach to email reports
		// (bInvokeFileDialog will be FALSE) we inform the user at this point of
		// the successful completion of the export, and indicate the file name
		// that was used and its outputs folder name and location.
		wxFileName fn(exportPath);
		wxString fileNameAndExtOnly = fn.GetFullName();

		// Store this export path in the App's m_lastPackedOutputPath. We do this
		// only within this bInvokeFileDialog, so it doesn't remember a last path
		// for packed documents that were prepared as part of email reports.
		gpApp->m_lastPackedOutputPath = fn.GetPath();

		wxString msg;
		msg = msg.Format(_("The packed document file was named:\n\n%s\n\nIt was saved at the following path:\n\n%s"), fileNameAndExtOnly.c_str(), exportPath.c_str());
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(msg, _("Packing of document successful"), wxICON_INFORMATION | wxOK);
		// whm 20Aug11 note: no need to log success after "initiating" log entry in caller
	}
	// remove the progress dialog
	pStatusBar->FinishProgress(_("Packing Document"));
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		the value of the m_bSpecialText member of pSrcPhrase
/// \param		pSrcPhrase		<- a pointer to the source phrase instance on
///									which this marker will be stored
/// \param		pLastSrcPhrase	<- a pointer to the source phrase immediately preceding
///									the current pSrcPhrase one (may be null)
/// \param		pChar			-> pChar points to the marker itself (ie. the marker's
///									backslash)
/// \param		len				-> len is the length of the marker at pChar in characters
///									(not bytes), determined by ParseMarker() in the caller
/// \param		pUsfmAnalysis	<- a pointer to the struct on the heap that a prior call to
///									LookupSFM(ptr) returned, and could be NULL for an
///									unknown marker. AnalyseMarker can potentially change
///									this to NULL, but it doesn't appear that such a change
///									affects pUsfmAnalysis in any calling routine
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange(), TokenizeText() and
/// DoMarkerHousekeeping().
/// Analyzes the current marker at pChar and determines what TextType and/or other
/// attributes should be applied to the the associated pSrcPhrase, and particularly
/// what the m_curTextType member should be. Determines if the current TextType should
/// be propagated or changed to something else. The return value is used to set the
/// m_bSpecialText member of pSrcPhrase in the caller.
/// BEW 30Sep19 added a block to check for \fig marker - before, we returned FALSE
/// for that one, but for USFM 3 we want TRUE so it will have its caption words,
/// when \fig .... \fig* is not a filtered span, coloured as other 'special text'
/// spans - otherwise, it would get verse m_bSpecialText FALSE, and be coloured the
/// same as verse text. 
/// 
/// pSrcPhrase is the source phrase instance on which this marker will be stored,
/// pBeginMkr points to the marker itself (ie. the marker's backslash),
/// mkrLen is its length in characters (not bytes), determined by ParseMarker() in the caller
/// pUsfmAnalysis is the struct on the heap that a prior call to LookupSFM(ptr) returned,
/// and could be NULL for an unknown marker.
/// The returned bool is the value of the m_bSpecialText member of pSrcPhrase.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::AnalyseMarker(CSourcePhrase* pSrcPhrase, CSourcePhrase* pLastSrcPhrase,
									wxChar* pBeginMkr, int mkrLen, USFMAnalysis* pUsfmAnalysis)
	// BEW ammended 21May05 to improve handling of endmarkers and suppressing their display
	// in navigation text area of main window
{
	CSourcePhrase* pThis = pSrcPhrase;
	CSourcePhrase* pLast = pLastSrcPhrase;
	wxString str(pBeginMkr, mkrLen);// need this to get access to wxString's overloaded operators
							// (some people define huge standard format markers, so we need
							// a dynamic string)
	bool bIsPreviousTextTypeWanted = FALSE; // initialize
	// BEW 30Sep19 added new block for supporting USFM3 \fig ... \fig* span, unfiltered;
	// bleed out this special case
	// 
	// whm 31Oct2023 modified test and the "bleed out special case" block below,
	// because the pLast seems to always be NULL when we're analyzing the \fig marker.
	// I've moved the pLast != NULL condition to inside the block to protext the assignment
	// of the gPreviousTextType and pLast->m_bBoundary from dereferencing the pLast pointer. 
	// At least this change will allow the bleed out special case" to work and return proper 
	// values for the analysis of the \fig marker within the unfiltering case back in 
	// ReconstituteAfterFilteringChange().
	//if (str == _T("\\fig") && pLast != NULL)
	if (str == _T("\\fig"))
	{
		bIsPreviousTextTypeWanted = TRUE; // whm note: this is a useless local assignment
		if (pLast != NULL)
		{
			gPreviousTextType = pLast->m_curTextType;
			pLast->m_bBoundary = TRUE;
		}
		pThis->m_bFirstOfType = TRUE;
		pThis->m_curTextType = noType;
		pThis->m_inform = _T("figure");
		pThis->m_bSpecialText = TRUE;
		return TRUE;
	}
	wxString strMkr; // for version 1.4.1 and onwards, to hold the marker less the esc char
	strMkr = str.Mid(1); // we want everything after the sfm escape character
	bool bEndMarker = IsEndMarker(pBeginMkr, pBeginMkr + mkrLen);

	// BEW added 23May05; the following test only can return TRUE when the passed in marker
	// at pBeginMkr is a beginning marker for an inline section (these have the potential to
	// temporarily interrupt the propagation of the TextType value, while another value
	// takes effect), or is the beginning marker for a footnote
	wxString nakedMkr = GetBareMarkerForLookup(pBeginMkr);
	bIsPreviousTextTypeWanted = FALSE;
	if (!bEndMarker)
		bIsPreviousTextTypeWanted = IsPreviousTextTypeWanted(pBeginMkr, pUsfmAnalysis);
	if (bIsPreviousTextTypeWanted)
	{
		if (pLast)
		{
			// set the global, and it will stay set until an endmarker or a footnote
			// endmarker makes use of it, and then clears it
			gPreviousTextType = pLast->m_curTextType;
		}
		else
			gPreviousTextType = verse; // a reasonable default at the start of the doc
	}

	// BEW 23May05 Don't delete this summary from Bill, it is a good systematic
	// treatment of what needs to be handled by the code below.

	// Determine how to handle usfm markers that can occur embedded
	// within certain other usfm markers. These include:
	//
	// 1. The "footnote content elements" marked by \fr...\fr*, \fk...\fk*,
	// \fq...\fq*, \fqa...\fqa*, \fv...\fv*, \ft...\ft* and \fdc...\fdc*.
	// These footnote content element markers would be found only between
	// \f and \f*. Their presence outside of \f and \f*, i.e., outside of
	// the footnote textType, would be considered an error.
	// Note: The ending markers for these footnote content elements are
	// optional according to UBS docs, and the default is to only use the
	// beginning marker and \ft to return to regular footnote text.
	//
	// 2. The "cross reference content element" markers. These include:
	// \xo...\xo*, \xk...\xk*, \xq...\xq*, \xt...\xt* and \xdc...\xdc*.
	// These cross reference content elements would be found only between
	// \x and \x*. Their presence outside of \x and \x*, i.e., outside of
	// the crossReference textType, would be considered an error.
	//
	// 3. The "Special kinds of text" markers. These include:
	// \qt...\qt*, \nd...\nd*, \tl...\tl*, \dc...\dc*, \bk...\bk*,
	// \sig...\sig*, \pn...\pn*, \wj...\wj*, \k...\k*, \sls...\sls*,
	// \ord...\ord*, and \add...\add*. Note: \lit is a special kind of
	// text but is a paragraph style. These special kinds of text markers
	// can occur in verse, poetry, note and noType textTypes. Most of the
	// special kinds of text markers could also occur in footnote textType.
	//
	// 4. The "Character styling" markers. These are now considered
	// "DEPRECATED" by UBS, but include:
	// \no...\no*, \bd...\bd*, \it...\it*, \bdit...\bdit*, \em...\em*,
	// and \sc...\sc*. They also can potentially be found anywhere. Adapt
	// It could (optionally) convert bar coded character formatting to
	// the equivalent character styling markers.
	//
	// 5. The "Special features" markers. These include:
	// \fig...\fig*  (with the bar code separated parameters
	// Desc|Cat|Size|Loc|Copy|Cap|Ref), and also the markers \pro...\pro*,
	// \w...\w*, \wh...\wh*, \wg...\wg*, and \ndx...\ndx*. These also
	// may potentially be found anywhere.
	//
	// The only end markers used in the legacy app were the footnotes \f* and \fe.
	// In USFM, however, we can potentially have many end markers, so we need
	// to have some special processing. I think I've got it smart enough, but it
	// can be changed further if necessary.

	if (!bEndMarker)
		pThis->m_bFirstOfType = TRUE; //default
	//bool bFootnoteEndMarker = FALSE; // BEW added 23May05
	// pUsfmAnalysis will be NULL for unknown marker
	if (pUsfmAnalysis)
	{
		if (bEndMarker)
		{
			// verify that the found USFM marker matches
			if (pUsfmAnalysis->endMarker != strMkr)
			{
				bEndMarker = FALSE;		// it isn't a recognized end marker
				pUsfmAnalysis = NULL;	// although the bare form was found
										// lookup didn't really succeed
			}
		}
		// check for legacy png \fe and \F endmarkers that have no asterisk
		// (BEW changes below, 23May05)
		if (pUsfmAnalysis && pUsfmAnalysis->png && (pUsfmAnalysis->marker == _T("fe")
			|| pUsfmAnalysis->marker == _T("F")))
		{
			bEndMarker = TRUE; // we have a png end marker
			//bFootnoteEndMarker = TRUE; // need this for restoring previous TextType
		}
		//if (pUsfmAnalysis && pUsfmAnalysis->usfm && pUsfmAnalysis->endMarker == _T("f*"))
			//bFootnoteEndMarker = TRUE; // need this for restoring previous TextType
	}
	// If bEndMarker is TRUE, our marker is actually an end marker. If pUsfmAnalysis is
	// NULL we can assume that it's an unknown type, so we'll treat it as special text as
	// did the legacy app, and will assign similar default values to pLast and pThis.

	// pUsfmAnalysis will be NULL for unknown marker
	//bool bEndMarkerForTextTypeNone = FALSE;
	bool bIsFootnote = FALSE;
	if (pUsfmAnalysis)
	{
		// Handle common//typical cases first...

		// Beginning footnote markers must set m_bFootnote to TRUE for backwards
		// compatibility with the legacy app (fortunately both usfm and png use
		// the same \f marker!)
		if (strMkr == _T("f"))
		{
			pThis->m_bFootnote = TRUE;
			bIsFootnote = TRUE;
		}

		// Version 3.x sets m_curTextType and m_inform according to the attributes
		// specified in AI_USFM.xml (or default strings embedded in program code when
		// AI_USFM.xml is not available); we set a default here, but the special cases
		// further down may set different values
		//
		// BEW note 11Oct10: if AnalyseMarker() is called more than once for the same
		// marker, then this next block appends the navigationText value to m_inform once
		// per call; so if we leave it as is (which is what I'm doing for the present), we
		// must ensure that code only calls it once per marker -- TokenizeText() changes is
		// a place to watch out for carefully; otherwise, change it to search for
		// navigationText in m_inform and not add it on subsequent calls if it is already
		// stored there.

		pThis->m_curTextType = pUsfmAnalysis->textType;
		if (pUsfmAnalysis->inform && !bEndMarker)
		{
			if (!pThis->m_inform.IsEmpty() &&
				pThis->m_inform[pThis->m_inform.Length() - 1] != _T(' '))
			{
				pThis->m_inform += _T(' ');
			}
			// BEW 6Jul23 before entry, when \s is last beginMkr, pThis->m_inform is already "sect head"
			// and pUsfmAnalysis->navigationText is also "sect head" - without refactoring to keep it
			// to that string occuring just once, check and don't add it if it's already there.
			wxString informTest = pUsfmAnalysis->navigationText;
			// Is informText already there?
			int offset = wxNOT_FOUND; // init
			offset = pThis->m_inform.Find(informTest);
			// Suppress doubling up if it's already present, i.e. offset >= 0
			if (offset == wxNOT_FOUND)
			{
				// The "sect head" substring is not already present, so add it
				pThis->m_inform += pUsfmAnalysis->navigationText;
			}
			else
			{
				// It's already present, so Trim off the final space added above
				pThis->m_inform.Trim();
			}
		}
		// Handle the special cases below....

		if (pLast != 0)
		{
			// stuff in here requires a valid 'last source phrase ptr'
			if (!bEndMarker)
			{
				// initial markers may, or may not, set a boundary on the last sourcephrase
				// (eg. those with TextType == none never set a boundary on the last
				// sourcephrase)
				pLast->m_bBoundary = pUsfmAnalysis->bdryOnLast;

				if (pUsfmAnalysis->inLine)
				{
					if (bIsFootnote || pUsfmAnalysis->marker == _T("x"))
					{
						pLast->m_bBoundary = TRUE;
						pThis->m_bFirstOfType = TRUE;
					}
					else
					{
						// its not a footnote, or cross reference, but it is an inline
						// section, so determine whether or not it's a section with
						// TextType == none
						// BEW 8Jun23, nested markers were unknown when this function was first
						// created. Need a 2nd subtest, with OR, check strMkr for inital + indicating its
						// nested; and pLast's values should propagate
						if (pUsfmAnalysis->textType == none || (!strMkr.IsEmpty() && strMkr.GetChar(0) == _T('+')) )
						{
							// this section is one where we just keep propagating the
							// preceding context across it
							pThis->m_curTextType = pLast->m_curTextType;
							pThis->m_bSpecialText = pLast->m_bSpecialText;
							pThis->m_bBoundary = FALSE;
							pThis->m_bFirstOfType = FALSE;
							return pThis->m_bSpecialText;
						}
						else
						{
							// this section takes its own TextType value, and other flags
							// to suite (we'll set m_bFirstOfType only if there is to be a
							// boundary on the preceding sourcephrse)
							pThis->m_bFirstOfType = pUsfmAnalysis->bdryOnLast == TRUE;
						}
					}
				}
				else
				{
					// let the type set in the common section stand unchanged
					;
				}
			}
			else
			{
				return FALSE;
			}
		}
		return pUsfmAnalysis->special;
	}
	else  // it's an unknown sfm, so treat as special text
	{
		// we don't have a pUsfmAnalysis for this situation
		// so set some reasonable defaults (as did the legacy app)
		if (pLast != NULL)
		{
			// stuff in here requires a valid 'last source phrase ptr'
			pLast->m_bBoundary = TRUE;
		}
		pThis->m_bFirstOfType = TRUE;
		pThis->m_curTextType = noType;
		// just show the marker bracketed by question marks, i.e., ?\tn?
		// whm Note 11Jun05: I assume that an unknown marker should not appear in the
		// navigation text line if it is filtered. I've also modified the code in
		// RedoNavigationText() to not include the unknown marker in m_inform when the
		// unknown marker is filtered there, and it seems that would be appropriate here
		// too. If Bruce thinks the conditional call to IsAFilteringUnknownSFM is not
		// appropriate here the conditional I've added should be removed; likewise the
		// parallel code I've added near the end of RedoNavigationText should be evaluated
		// for appropriateness.
		// BEW comment 15Jun05 - I agree unknowns which are filtered should not appear with
		// ?..? bracketing; in fact, I've gone as far as to say that no filtered marker
		// should have its nav text displayed in the main window -- and coded accordingly
		if (!IsAFilteringUnknownSFM(nakedMkr))
		{
			pThis->m_inform += _T("?");
			pThis->m_inform += str; // str is a whole marker here
			pThis->m_inform += _T("? ");
		}
		return TRUE; //ie. assume it's special text
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		always TRUE
/// \remarks
/// Called from: the doc/view framework - but at different times in MFC than
/// in the wx framework.
/// Deletes the list of source phrases (by calling DeleteSourcePhrases) and destroys the
/// view's strips, piles and cells.
/// This override is never explicitly called in the MFC version. In the wx version,
/// however, DeleteContents() needs to be called explicitly from the Doc's OnNewDocument(),
/// OnCloseDocument() and the View's ClobberDocument() because the doc/view framework in wx
/// works differently. In wx code, the Doc's OnNewDocument() must avoid calling the
/// wxDocument::OnNewDocument base class - because it calls OnCloseDocument() which in turn
/// would foul up the KB structures because OnCloseDocument() calls EraseKB(), etc. Instead
/// the wx version just calls DeleteContents() explicitly where needed.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::DeleteContents()
// refactored 10Mar09
// This is an override of the doc/view method
// MFC docs say: "Called by the framework to delete the document's data without destroying
// the CDocument object itself. It is called just before the document is to be destroyed.
// It is also called to ensure that a document is empty before it is reused. This is
// particularly important for an SDI application, which uses only one document; the
// document is reused whenever the user creates or opens another document. Call this
// function to implement an "Edit Clear All" or similar command that deletes all of the
// document's data. The default implementation of this function does nothing. Override this
// function to delete the data in your document."
/// BEW 12Jul19 moved mutex to start & end of function, because Evelyn at Gali'winku
/// (Warramiri - Matata) had a doc contents emptying experience
{
	CAdapt_ItApp* pApp = &wxGetApp();
	pApp->m_bDocumentDestroyed = TRUE;

	s_AutoSaveMutex.Lock();

	// zero the contents of the read-in file of source text data
	if (pApp->m_pBuffer != 0)
	{
		pApp->m_pBuffer->Empty();
	}

	// delete the source phrases
	DeleteSourcePhrases(); // this does not delete the partner piles as
		// the internal DeleteSingleSrcPhrase() has the 2nd param FALSE so
		// that it does not call DeletePartnerPile() -- so delete those
		// separately below en masse with the DestroyPiles() call

	// the strips, piles and cells have to be destroyed to make way for the new ones
	CAdapt_ItView* pView = (CAdapt_ItView*)NULL;
	pView = (CAdapt_ItView*)GetFirstView();
	wxASSERT(pApp != NULL);
	if (pView != NULL)
	{
		CLayout* pLayout = GetLayout();
		pLayout->DestroyStrips();
		pLayout->DestroyPiles(); // destroy these en masse
		pLayout->GetPileList()->Clear();
		pLayout->GetInvalidStripArray()->Clear();

		if (pApp->m_pTargetBox != NULL)
		{
			pApp->m_pTargetBox->GetTextCtrl()->ChangeValue(_T(""));
		}

		pApp->m_targetPhrase = _T("");
	}

	pApp->m_pTargetBox->m_Translation.Empty(); // make sure the global var is clear

	s_AutoSaveMutex.Unlock();

	return wxDocument::DeleteContents(); // just returns TRUE
}


///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		pKB		<- a pointer to the current KB instance
/// \remarks
/// Called from: the App's SubstituteKBBackup(), ClearKB(), AccessOtherAdaptionProject(),
/// the Doc's OnCloseDocument(), the View's OnFileCloseProject(), DoConsistencyCheck().
/// Deletes the Knowledge Base after emptying and deleting its maps and its contained
/// list of CTargetUnit instances, and each CTargetUnit's contained list of CRefString
/// objects. (Note: OnCloseDocument() is not called explicitly by the Adapt It
/// code. It is called only by the framework when the application is being shut down.
/// Therefore it really involves a project closure as well, and therefore Erasure
/// of the KB and GlossingKB is appropriate; if the doc is dirty, then the user will
/// be given a chance to save it, and if he does, the KBs get saved then automatically
/// too.)
/// BEW added 13Nov09: removal of read-only protection (which involves unlocking
/// the ~AIROP-machinename-user-name.lock file, and removing it from the project
/// folder, rendering the project ownable for writing by whoever first enters it
/// subsequently). Doing this is appropriate in EraseKB() because EraseKB() is
/// called whenever the project is being left by whoever has current ownership
/// permission.
/// BEW 28May10, removed TUList, as it is redundant & now unused
/// BEW 1Jun10, added deletion of CRefStringMetadata instance
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::EraseKB(CKB* pKB)
{
	// Empty the map and delete their contained objects
	if (pKB != NULL)
	{
		// Clear all elements from each map, and delete each map
		for (int i = 0; i < MAX_WORDS; i++)
		{
			if (pKB->m_pMap[i] != NULL) // test for NULL whm added 10May04
			{
				if (!pKB->m_pMap[i]->empty())
				{
					MapKeyStringToTgtUnit::iterator iter;
					for (iter = pKB->m_pMap[i]->begin(); iter != pKB->m_pMap[i]->end(); ++iter)
					{
						wxString srcKey = iter->first;
						CTargetUnit* pTU = iter->second;
						wxASSERT(pTU != NULL);
						TranslationsList::Node* tnode = NULL;
						if (pTU->m_pTranslations->GetCount() > 0)
						{
							for (tnode = pTU->m_pTranslations->GetFirst();
								tnode; tnode = tnode->GetNext())
							{
								CRefString* pRefStr = (CRefString*)tnode->GetData();
								if (pRefStr != NULL)
								{
									pRefStr->DeleteRefString();
								}
							}
						}
						if (pTU != NULL) // whm 11Jun12 added NULL test
							delete pTU;
						//pTU = (CTargetUnit*)NULL;
					}
					pKB->m_pMap[i]->clear();
				}
				if (pKB->m_pMap[i] != NULL) // whm 11Jun12 added NULL test
					delete pKB->m_pMap[i];
				pKB->m_pMap[i] = (MapKeyStringToTgtUnit*)NULL; // whm added 10May04
			}
		}
	}

	if (pKB != NULL)
	{
		// Lastly delete the KB itself
		if (pKB != NULL) // whm 11Jun12 added NULL test
			delete pKB;
		pKB = (CKB*)NULL;
	}

	// BEW added 13Nov09, for restoring the potential for ownership for write permission
	// of the current accessed project folder.
	if (!gpApp->m_curProjectPath.IsEmpty())
	{
		bool bRemoved = gpApp->m_pROP->RemoveReadOnlyProtection(gpApp->m_curProjectPath);
		bRemoved = bRemoved; // to avoid warning
		// we are leaving this folder, so the local process must have m_bReadOnlyAccess unilaterally
		// returned to a FALSE value - whether or not a ~AIROP-*.lock file remains in the folder
		gpApp->m_bReadOnlyAccess = FALSE;
		// whm 7Mar12 added. The project is being closed, so unilaterally set m_bFictitiousReadOnlyAccess
		// to FALSE
		gpApp->m_bFictitiousReadOnlyAccess = FALSE; // ditto
		gpApp->GetView()->canvas->Refresh(); // force color change back to normal white background
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		always TRUE
/// \remarks
/// Called from: the doc/view framework automatically calls OnCloseDocument() when
/// necessary; it is not explicitly called from program code.
/// Closes down the current document and clears out the KBs from memory. This override does
/// not call the base class wxDocument::OnCloseDocument(), but does some document
/// housekeeping and calls DeleteContents() and finally sets Modify(FALSE).
///////////////////////////////////////////////////////////////////////////////

bool CAdapt_ItDoc::OnCloseDocument()
// MFC Note: This function just closes the doc down, with no saving, and clears out
// the KBs from memory with no saving of them either (presumably, they were saved
// to disk earlier if their contents were of value.) The disk copies of the KBs
// therefore are unchanged from the last save.
//
// whm notes on CLOSING the App, the View, and the Doc:
// This note describes the flow of control when the MFC app (CFrameWnd) does OnClose()
// and the WX app (wxDocParentFrame) does OnCloseWindow():
// IN MFC:	CFrameWnd::OnClose()
// - ->		pApp::CloseAllDocuments(FALSE) // parameter bool bEndSession
// - ->		CDocMagager::CloseAllDocuments(FALSE) // parameter bool bEndSession
// - ->		CDocTemplate::CloseAllDocuments(FALSE) // parameter bool bEndSession
// - ->		CAdapt_ItDoc::OnCloseDocument() [see note following:]
// - ->		CDocument::OnCloseDocument() // MFC app overrides this and calls it at end of override
// The MFC AI override calls EraseKB on the adapting and glossing KBs, updates
// some settings for the view and the app for saving to config files on closure, then
// lastly calls the CDocument::OnCloseDocument() which itself calls pFrame->DestroyWindow()
// for any/all views, then calls the doc's DeleteContents(), and finally calls delete on
// "this" the document if necessary (i.e., if m_bAutoDelete is TRUE). The important thing
// to note here is that WITHIN OnCloseDocument() ALL 3 of the following are done in this
// order:	(1) The view(s) are closed (and associated frames destroyed) - a flag is used
//				to prevent (3) below from happening while closing/deleting the views
//			(2) The Doc's DeleteContents() is called
//			(3) The doc itself is deleted
//
// IN WX:	wxDocParentFrame::OnCloseWindow() // deletes all views and documents, then the wxDocParentFrame and exits the app
// - ->		wxDocManager::Clear() // calls CloseDocuments(force) and deletes the doc templates
// - ->*	wxDocManager::CloseDocuments(bool force) // On each doc calls doc->Close() then doc->DeleteAllViews() then delete doc
// - ->		wxDocument::Close() // first calls OnSaveModified, then if ok, OnCloseDocument()
// - ->		CAdapt_ItDoc::OnCloseDocument() [see note following:]
// - ->		[wxDocument::OnCloseDocument()] // WX app overrides this
// The WX AI override calls EraseKB on the adapting and glossing KBs and updates settings
// just as the MFC override does. Problems occur at line marked - ->* above due to the
// EARLY DeleteAllViews() call. This DeleteAllViews() also calls view->Close() on any
// views, and view->Close() calls view::OnClose() whose default behavior calls
// wxDocument::Close to "close the associated document." This results in OnCloseDocument()
// being called a second time in the process of closing the view(s), with damaging
// additional calls to EraseKB (the m_pMap[i] members have garbage pointers the second time
// around). To avoid this problem we need to override one or more of the methods that
// result in the additional damaging call to OnCloseDocument, or else move the erasing of
// our CKB structures out of OnCloseDocument() to a more appropriate place.
// Trying the override route, I tried first overriding view::OnClose() and doc::DeleteAllViews

// WX Note: Compare the following differences between WX and MFC
	// In wxWidgets, the default docview.cpp wxDocument::OnCloseDocument() looks like this:
				//bool wxDocument::OnCloseDocument()
				//{
				//	// Tell all views that we're about to close
				//	NotifyClosing();  // calls OnClosingDocument() on each view which does nothing in base class
				//	DeleteContents(); // does nothing in base class
				//	Modify(FALSE);
				//	return TRUE;
				//}

	// In MFC, the default doccore.cpp CDocument::OnCloseDocument() looks like this:
				//void CDocument::OnCloseDocument()
				//	// must close all views now (no prompting) - usually destroys this
				//{
				//	// destroy all frames viewing this document
				//	// the last destroy may destroy us
				//	bool bAutoDelete = m_bAutoDelete;
				//	m_bAutoDelete = FALSE;  // don't destroy document while closing views
				//	while (!m_viewList.IsEmpty())
				//	{
				//		// get frame attached to the view
				//		CView* pView = (CView*)m_viewList.GetHead();
				//		CFrameWnd* pFrame = pView->GetParentFrame();
				//		// and close it
				//		PreCloseFrame(pFrame);
				//		pFrame->DestroyWindow();
				//			// will destroy the view as well
				//	}
				//	m_bAutoDelete = bAutoDelete;
				//	// clean up contents of document before destroying the document itself
				//	DeleteContents();
				//	// delete the document if necessary
				//	if (m_bAutoDelete)
				//		delete this;
				//}
	// Compare wxWidgets wxDocument::DeletAllViews() below to MFC's OnCloseDocument() above:
				//bool wxDocument::DeleteAllViews()
				//{
				//    wxDocManager* manager = GetDocumentManager();
				//
				//    wxNode *node = m_documentViews.First();
				//    while (node)
				//    {
				//        wxView *view = (wxView *)node->Data();
				//        if (!view->Close())
				//            return FALSE;
				//
				//        wxNode *next = node->Next();
				//
				//        delete view; // Deletes node implicitly
				//        node = next;
				//    }
				//    // If we haven't yet deleted the document (for example
				//    // if there were no views) then delete it.
				//    if (manager && manager->GetDocuments().Member(this))
				//        delete this;
				//
				//    return TRUE;
				//}
	// Conclusion: Our wxWidgets version of OnCloseDocument() should NOT call the
	// wxDocument::OnCloseDocument() base class method, but instead should make the
	// following calls in its place within the OnCloseDocument() override:
	//		DeleteAllViews() // assumes 'delete this' at end can come before DeleteContents()
	//		DeleteContents()
	//		Modify(FALSE)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItView* pView;
	CAdapt_ItDoc* pDoc;
	CPhraseBox* pBox;
	pApp->GetBasePointers(pDoc, pView, pBox);
	wxASSERT(pView);

	// Anticipate perhaps a new document may be opened, so default the following flag to
	// a TRUE value - just in case collaboration mode may be in effect
	pApp->m_bConflictResolutionTurnedOn = TRUE;

	// mrh Sept 13 - if a trial look at previously committed versions is current, we MUST NOT close the document!
	// However we can be called from DocumentChangedExternally(), in which case m_bReopeningAfterClosing is TRUE, and in this
	//  case we must perform the close.

	if (pApp->m_trialVersionNum >= 0 && !m_bReopeningAfterClosing)
	{
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(_("Before closing the document, you must either ACCEPT the revision or RETURN to the latest one."));
		return FALSE;
	}

	// put up a Wait dialog; but it's nonmodal and on Linux its contents are not shown
	// so do it only for Windows
#if defined(__WXMSW__)
	CWaitDlg waitDlg(pApp->GetMainFrame());
	// indicate we want the closing the document wait message
	waitDlg.m_nWaitMsgNum = 22;	// 22 has "Closing the document..."
	waitDlg.Centre();
	waitDlg.Show(TRUE);
	waitDlg.Update();
	// the wait dialog is automatically destroyed when it goes out of scope below
#endif

	// BEW 28Sep12, for kbserver support, we need to call ReleaseKBServer() for each
	// kbType here before the KBs are clobbered (App closure by File > Exit, or the X
	// checkbox at top right of the frame window, causes control to go thru here - so we
	// need to save the kbserver params - particularly the m_kbServerLastSync datetime
	// value. A preceding WriteProjectConfiguration() is really needed too, so that we
	// ensure the m_bIsKBServerProject and m_bIsGlossingKBServerProject flags' values
	// are made persistent for the current AI project
	bool bOK;
	if (!pApp->m_curProjectPath.IsEmpty())
	{
		if (pApp->m_bUseCustomWorkFolderPath && !pApp->m_customWorkFolderPath.IsEmpty())
		{
			// whm 10Mar10, must save using what paths are current, but when the custom
			// location has been locked in, the fimkrLename lacks "Admin" in it, so that it
			// becomes a "normal" project configuration file in m_curProjectPath at the
			// custom location.
			if (pApp->m_bLockedCustomWorkFolderPath)
				bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
			else
				bOK = pApp->WriteConfigurationFile(szAdminProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
		}
		else
		{
			bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath, projectConfigFile);
		}
		// we don't expect a write error, but tell the developer or user if the write
		// fails, and keep on processing
		if (!bOK)
		{
			wxString msg = _T("In OnCloseDocument() WriteConfigurationFile() failed for project config file or admin project config file.");
			wxMessageBox(msg);
			pApp->LogUserAction(msg);
		}
	}

	// mrh Oct12 -- If OnCloseDocument() is called from DocChangedExternally(), we need to preserve
	// the current KB, so we now have a private flag to indicate this.

	if (!m_bReopeningAfterClosing)
	{

		//#if defined(_KBSERVER)
		if (pApp->m_bIsKBServerProject)
		{
			pApp->ReleaseKBServer(1); // the adaptations one
			pApp->LogUserAction(_T("ReleaseKBServer(1) called in OnCloseDocument()"));
		}
		if (pApp->m_bIsGlossingKBServerProject)
		{
			pApp->ReleaseKBServer(2); // the glossings one
			pApp->LogUserAction(_T("ReleaseKBServer(2) called in OnCloseDocument()"));
		}
		//#endif

				// the EraseKB() call will also try to remove any read-only protection
		EraseKB(pApp->m_pKB); // remove KB data structures from memory - EraseKB in the App in wx
		pApp->m_pKB = (CKB*)NULL; // whm added
		EraseKB(pApp->m_pGlossingKB); // remove glossing KB structures from memory -
									  // EraseKB in the App in wx
		pApp->m_pGlossingKB = (CKB*)NULL; // whm added
	}

	// GDLC 2010-03-27 pFreeTrans is now unused in this function
	//	CFreeTrans* pFreeTrans = pApp->GetFreeTrans();
	//	wxASSERT(pFreeTrans);

	pApp->m_lastDocPath = pApp->m_curOutputPath;

	// mrh Oct12 - with docVersion 8, the active seq number is saved in the doc's xml.  So now,
	//  with no doc open, m_nActiveSequNum must be zero, no matter what.  Its last value used
	//  to be saved in the config file, but not any longer.

	pApp->m_nActiveSequNum = 0;

	// BEW added 21Apr08; clean out the global struct gEditRecord & clear its deletion
	// lists, because each document, on opening it, it must start with a truly empty
	// EditRecord; and on doc closure and app closure, it likewise must be cleaned out
	// entirely (the deletion lists in it have content which persists only for the life of
	// the document currently open)
	pView->InitializeEditRecord(gEditRecord);
	gEditRecord.deletedAdaptationsList.Clear(); // remove any stored deleted adaptation strings
	gEditRecord.deletedGlossesList.Clear(); // remove any stored deleted gloss strings
	gEditRecord.deletedFreeTranslationsList.Clear(); // remove any stored deleted free translations

	// send the app the current size & position data, for saving to config files on closure
	wxRect rectFrame;
	CMainFrame* pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame);
	rectFrame = pFrame->GetRect(); // screen coords
	rectFrame = NormalizeRect(rectFrame); // use our own from helpers.h
	pApp->m_ptViewTopLeft.x = rectFrame.GetX();
	pApp->m_ptViewTopLeft.y = rectFrame.GetY();

	pApp->m_szView.SetWidth(rectFrame.GetWidth());
	pApp->m_szView.SetHeight(rectFrame.GetHeight());
	pApp->m_bZoomed = pFrame->IsMaximized();

	DeleteContents(); // this is required to avoid leaking heap memory on exit
	Modify(FALSE);

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		nValueForFirst	-> the number to use for the first source phrase in pList
/// \param		pList			<- a SPList of source phrases whose m_nSequNumber members are
///									to be put in sequence
/// \remarks
/// Called from: the Doc's TokenizeText().
/// Resets the m_nSequNumber member of all the source phrases in pList so that they are in
/// numerical sequence (ascending order) with no gaps, starting with nValueForFirst.
/// This function differs from UpdateSequNumbers() in that AdjustSequNumbers() effects its
/// changes only on the pList passed to the function; in UpdateSequNumbers() the current
/// document's source phrases beginning with nFirstSequNum are set to numerical sequence
/// through to the end of the document.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::AdjustSequNumbers(int nValueForFirst, SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* node = pList->GetFirst();
	if (node == NULL)
		return;
	int sn = nValueForFirst - 1;
	while (node)
	{
		sn++;
		pSrcPhrase = (CSourcePhrase*)node->GetData();
		node = node->GetNext();
		pSrcPhrase->m_nSequNumber = sn;
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		pstr	<- a wxString buffer containing text to process
/// \remarks
/// Called from: the Doc's OnNewDocument().
/// Removes any ventura publisher optional hyphen codes ("<->") from string buffer pstr.
/// After removing any ventura optional hyphens it resets the App's m_nInputFileLength
/// global to reflect the new length.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::RemoveVenturaOptionalHyphens(wxString*& pstr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxString strVOH = _T("<->");
	int nFound = 0;
	int nNewLength = (*pstr).Length();
	while ((nFound = FindFromPos((*pstr), strVOH, nFound)) != -1)
	{
		// found an instance, so delete it
		// Note: wxString::Remove must have second param otherwise it will just
		// truncate the remainder of the string
		(*pstr).Remove(nFound, 3);
	}

	// set the new length
	nNewLength = (*pstr).Length();
	pApp->m_nInputFileLength = (wxUint32)(nNewLength + 1); // include terminating null char
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString in which any \n, \r, or \t characters have been converted to spaces
/// \param		str		-> a wxString that is examined for embedded whitespace characters
/// \remarks
/// Called from: the Doc's TokenizeText().
/// This version of NormalizeToSpaces() is used in the wx version only.
/// This function changes any kind of whitespace (\n, \r, or \t) in str to simple space(s).
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::NormalizeToSpaces(wxString str)
{
	// whm added to normalize white space when presented with wxString (as done in the wx version)
	str.Replace(_T("\n"), _T(" ")); // LF (new line on Linux and internally within Windows)
	str.Replace(_T("\r"), _T(" ")); // CR (new line on Mac)
	str.Replace(_T("\t"), _T(" ")); // tab
	return str;
	// alternate code below:
	//wxString temp;
	//temp = str;
	//int len = temp.Length();
	//int ct;
	//for (ct = 0; ct < len; ct++)
	//{
	//	if (wxIsspace(temp.GetChar(ct)))
	//		temp.SetChar(ct, _T(' '));
	//}
	//return temp;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if pChar is pointing at an end marker whose associated textType is none,
///				otherwise FALSE
/// \param		pChar	-> a pointer to a character in a buffer
/// \remarks
/// Called from: the Doc's AnalyseMarker().
/// Determines if the marker at pChar in a buffer is an end marker and if so, if the end marker
/// has an associated textType of none.
/// BEW 7Nov16 Refactored so it works correctly if the marker indicates nesting, that is,
/// starting with \+
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsEndMarkerForTextTypeNone(wxChar* pChar)
{
	bool bEndMarker = IsEndMarker2(pChar); // BEW added 7Nov16 as insurance
	if (!bEndMarker)
		return FALSE;

	// BEW 24Apr20 AI_USSFM is under-marked for TextType none instances, so use a fast access string
	wxString endMkr = GetWholeMarker(pChar); // use fast access string on app: m_charFormatEndMkrs
	int offset = wxNOT_FOUND;
	wxString augEndMkr = endMkr + _T(' ');
	offset = gpApp->m_charFormatEndMkrs.Find(augEndMkr);
	if (offset >= 0)
	{
		return TRUE;
	}

	/* legacy version
	wxString bareMkr = GetBareMarkerForLookup(pChar); // BEW 7Nov16 Updated to also remove
													  // + in \+it or \+it* etc (TextType none markers)
	wxASSERT(!bareMkr.IsEmpty());
	USFMAnalysis* pAnalysis = LookupSFM(bareMkr);
	wxString marker = GetMarkerWithoutBackslash(pChar); // BEW 7Nov16, also updated
														// to remove + if present after backslash
	wxASSERT(!marker.IsEmpty());
	if ((marker == pAnalysis->endMarker) && (pAnalysis->textType == none) && bEndMarker)
		return TRUE;
	else
		return FALSE;
	*/
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		the count of how many CSourcePhrase instances are in the m_pSourcePhrases list
///				after the retokenize and doc rebuild is done.
/// \param		bChangedPunctuation	-> TRUE if punctuation has changed, FALSE otherwise
/// \param		bChangedFiltering	-> TRUE if one or more markers' filtering status has changed,
///										FALSE otherwise
/// \param		bChangedSfmSet		-> TRUE if the Sfm Set has changed, FALSE otherwise
/// \remarks
/// Called from: the App's DoPunctuationChanges(), DoUsfmFilterChanges(),
/// DoUsfmSetChanges(), the View's OnEditSourceText().
/// Calls the appropriate document rebuild function for the indicated changes. For
/// punctuation changes if calls ReconstituteAfterPunctuationChange(); for filtering
/// changes it calls ReconstituteAfterFilteringChange(); and for sfm set changes, the
/// document is processed three times, the first pass calls SetupForSFMSetChange() and
/// ReconstituteAfterFilteringChange() to unfilter any previously filtered material, the
/// second pass again calls SetupForSFMSetChange() with adjusted parameters and
/// ReconstituteAfterFilteringChange() to filter any new filtering changes. The third pass
/// calls DoMarkerHousekeeping() to ensure that TextType, m_bSpecialText, and m_inform
/// members of pSrcPhrase are set correctly at each location after the other major changes
/// have been effected.
///////////////////////////////////////////////////////////////////////////////
int CAdapt_ItDoc::RetokenizeText(bool bChangedPunctuation, bool bChangedFiltering,
	bool bChangedSfmSet)
	// bew modified signature 18Apr05
	// Returns the count of how many CSourcePhrase instances are in the m_pSourcePhrases list
	// after the retokenize and doc rebuild is done.
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItView* pView = pApp->GetView();
	wxASSERT(pView->IsKindOf(CLASSINFO(CAdapt_ItView)));

	// first determine whether or not the data was unstructured plain text - we need to
	// know because we don't want to try accumulate chapter:verse references for locations
	// where the rebuild failed if in fact there are no \c and \v markers in the original
	// source data!
	gbIsUnstructuredData = pView->IsUnstructuredData(gpApp->m_pSourcePhrases);

	// set up the string which is to preserve a record of where rebuilding will need to be
	// done manually later on, because what was expected did not occur
	wxString fixesStr;
	if (gbIsUnstructuredData)
	{
		// this one will not change, since there are no chapter verse references able to be
		// constructed
		fixesStr = _(
			"There were places where automatic rebuilding of the document potentially did not fully succeeded. Visually check and edit where necessary: ");
	}
	else
	{
		// it has standard format markers including \v and \c (presumably), so we can add
		// n:m style of references to the end of the string - we take whatever is in the
		// m_chapterVerse wxString member of the passed in pointer to the CSourcePhrase
		// instance
		// IDS_MANUAL_FIXES_REFS
		fixesStr = _(
			"Locate the following chapter:verse locations for potential errors in the rebuild of the document. Visually check and edit where necessary: ");
	}

	int nOldTotal = gpApp->m_pSourcePhrases->GetCount();
	if (nOldTotal == 0)
	{
		return 0;
	}

	// put up a progress indicator
	// whm Note: RetokenizeText doesn't really need a progress dialog; it is mainly called
	// by other routines that have their own progress dialog, with the result that to have
	// a separate progress dialog for RetokenizeText, we end up with two progress dialogs,
	// one partially hiding the other.

	int nOldCount = 0;

	// whatever initialization is needed
	SPList::Node* pos_pSP;
	SPList::Node* oldPos;
	CSourcePhrase* pSrcPhrase = NULL;
	bool bNeedMessage = FALSE;

	// perform each type of document rebuild
	bool bSuccessful;
	if (bChangedPunctuation)
	{
		pos_pSP = gpApp->m_pSourcePhrases->GetFirst();
		while (pos_pSP != NULL)
		{
			oldPos = pos_pSP;
			pSrcPhrase = (CSourcePhrase*)pos_pSP->GetData();
			pos_pSP = pos_pSP->GetNext();

			// acts on ONE instance of pSrcPhrase only each time it loops, & it may add
			// many to the list, or remove some, or leave number in the list unchanged
			bSuccessful = ReconstituteAfterPunctuationChange(pView,
				gpApp->m_pSourcePhrases, oldPos, pSrcPhrase, fixesStr);
			if (!bSuccessful)
			{
				// adaptation abandoned, so add a chapter:verse reference to the fixesStr
				// if the source text was (U)SFM structured text. The code for adding to
				// fixesStr (a chapter:verse reference plus 3 spaces) needs to be within
				// each of ReconstituteAfterPunctuationChange's subfunctions, as it depends
				// on pSrcPhrase being correct and so we must do the update to fixesStr
				// before we mess with replacing the pSrcPhrase with what was the new
				// parse's CSourcePhrase instances when automatic rebuild could not be done
				// correctly
				// BEW changed 8Mar11 for punctuation reconstitution -- to include the
				// m_srcPhrase test after the chapter:verse & a delimiting space, and we
				// don't make any insertions of new CSourcePhrase instances into
				// m_pSourcePhrases, but wherever FALSE is returned, we just keep the
				// original pSrcPhrase unchanged and have a reference for where this was
				// in fixesStr
				bNeedMessage = TRUE;
			}
			// update progress bar every 20 iterations
			++nOldCount;
			//if (20 * (nOldCount / 20) == nOldCount)
			//{
			//	//prog.m_progress.SetValue(nOldCount); //prog.m_progress.SetPos(nOldCount);
			//	//prog.TransferDataToWindow(); //prog.UpdateData(FALSE);
			//	//wxString progMsg = _("Retokenizing - File: %s  - %d of %d Total words and phrases");
			//	//progMsg = progMsg.Format(progMsg,gpApp->m_curOutputFilename.c_str(),nOldCount,nOldTotal);
			//}
		}
	}

	if (bChangedSfmSet)
	{
		// We accomplish the desired effects by successive calls of
		// ReconstituteAfterFilteringChanges(), with a little massaging of the data
		// structures in which it relies, before each call.
		bool bSuccessful;

		// The first pass through the document has to be done with the previous SFM set in
		// effect, and the saved wxString of the previous filter markers for that set -
		// these have to be unfiltered, but we won't unfilter any which are markers in
		// common with the new set and which are also filtered in the new set. Since we are
		// going to fiddle with the SfmSet value, we need to save the current value and
		// restore it when we are done. m_sfmSetAfterEdit stores the current value in
		// effect after the Preferences are exited, so we will use that for restoring
		// gCurrentSfmSet later below

#ifdef _Trace_RebuildDoc
		TRACE1("\n saveCurrentSfmSet = %d\n", (int)m_sfmSetAfterEdit);
		TRACE3("\n bChangedSfmSet TRUE; origSet %d, newSet %d, origMkrs %s\n", m_sfmSetBeforeEdit,
			gpApp->gCurrentSfmSet, m_filterMarkersBeforeEdit);
		TRACE2("\n bChangedSfmSet TRUE; curFilterMkrs: %s\n and the secPassMkrs: %s, pass = FIRST\n\n",
			gpApp->gCurrentFilterMarkers, m_secondPassFilterMarkers);
#endif

		SetupForSFMSetChange(gpApp->m_sfmSetBeforeEdit, gpApp->gCurrentSfmSet,
			gpApp->m_filterMarkersBeforeEdit, gpApp->gCurrentFilterMarkers,
			gpApp->m_secondPassFilterMarkers, first_pass);

		if (gpApp->m_FilterStatusMap.size() > 0)
		{
			// we only unfilter if there is something to unfilter
			bSuccessful = ReconstituteAfterFilteringChange(pView, gpApp->m_pSourcePhrases, fixesStr);
			if (!bSuccessful)
			{
				// at least one error, so make sure there will be a message given (the
				// ReconstituteAfterFilteringChange() function will append the needed
				// material to fixesStr internally (each time there is such an error)
				// before returning
				bNeedMessage = TRUE;
			}
		}

		// restore the filtering status of the original set's markers, in case the user
		// later changes back to that set (gCurrentSfmSet's value is still the one for the
		// old set)
		ResetUSFMFilterStructs(gpApp->gCurrentSfmSet, gpApp->m_filterMarkersBeforeEdit, _T(""));

		// restore the current SFM set value. This is the value which the user changed to
		// in the USFMPage, and it has to be the current value when the second pass is
		// executed below
		gpApp->gCurrentSfmSet = gpApp->m_sfmSetAfterEdit;

#ifdef _Trace_RebuildDoc
		TRACE3("\n bChangedSfmSet TRUE; origSet %d, newSet %d, origMkrs %s\n", m_sfmSetBeforeEdit,
			gpApp->gCurrentSfmSet, m_filterMarkersBeforeEdit);
		TRACE2("\n bChangedSfmSet TRUE; gCurrentFilterMarkers: %s\n and the secPassMkrs: %s, pass = SECOND\n\n",
			gpApp->gCurrentFilterMarkers, m_secondPassFilterMarkers);
#endif

		SetupForSFMSetChange(gpApp->m_sfmSetBeforeEdit,
			gpApp->gCurrentSfmSet, gpApp->m_filterMarkersBeforeEdit,
			gpApp->gCurrentFilterMarkers, gpApp->m_secondPassFilterMarkers,
			second_pass);

		if (gpApp->m_FilterStatusMap.size() > 0)
		{
			// we only filter if there is something to filter
			bSuccessful = ReconstituteAfterFilteringChange(pView, gpApp->m_pSourcePhrases, fixesStr);
			if (!bSuccessful)
			{
				// at least one error, so make sure there will be a message given (the
				// ReconstituteAfterFilteringChange() function will append the needed
				// material to fixesStr internally (each time there is such an error)
				// before returning
				bNeedMessage = TRUE;
			}
		}

		// Typically, after any refiltering is done, there will be errors remaining in the
		// document - these are old pSrcPhrase->m_inform strings which are now out of date,
		// TextType values which are set or changed at the wrong places and improperly
		// propagated in the light of the new SFM set now in effect, and likewise
		// m_bSpecialText will in many places be wrong, changed when it shouldn't be, etc.
		// To fix all this stuff we have to scan across the whole document with the
		// DoMarkerHousekeeping() function, which duplicates some of TokenizeText()'s code,
		// to get the TextType, m_bSpecialText, and m_inform members of pSrcPhrase correct
		// at each location Setup the globals for this call...
		gpFollSrcPhrase = NULL; // the "sublist" is the whole document, so there is no
		gpPrecSrcPhrase = NULL; // preceding or following source phrase to be considered
		gbSpecialText = FALSE;
		gPropagationType = verse; // default at start of a document
		gbPropagationNeeded = FALSE; // gpFollSrcPhrase is null, & we can't propagate
									 // at end of doc
		int docSrcPhraseCount = gpApp->m_pSourcePhrases->size();
		DoMarkerHousekeeping(gpApp->m_pSourcePhrases,
			docSrcPhraseCount, gPropagationType, gbPropagationNeeded);
	}

	if (bChangedFiltering)
	{
		// if called, ReconstituteAfterFilteringChange() sets up the progress window again
		// and destroys it before returning
		bool bSuccessful = ReconstituteAfterFilteringChange(pView, gpApp->m_pSourcePhrases, fixesStr);
		if (!bSuccessful)
		{
			// at least one error, so make sure there will be a message given (the
			// ReconstituteAfterFilteringChange() function will append the needed material
			// to fixesStr internally (each time there is such an error) before returning
			bNeedMessage = TRUE;
		}
	}

	// find out how many instances are in the list when all is done and return it to the
	// caller
	int count = gpApp->m_pSourcePhrases->GetCount();

	// make sure everything is correctly numbered in sequence; shouldn't be necessary,
	// but no harm done
	UpdateSequNumbers(0);

	// warn the user if he needs to do some visual checking etc.
	if (bNeedMessage)
	{
		// make sure the message is not too huge for display - if it exceeds 1200
		// characters, trim the excess and add "... for additional later locations where
		// manual editing is needed please check the document visually. A full list has
		// been saved in your project folder in Rebuild Log.txt" (the addition is not put
		// in the message if the data is unstructured as (U)SFM stuff)
		int len = fixesStr.Length();

		// build the path to the current project's folder and output the full log
		if (!gbIsUnstructuredData)
		{
			wxString path;
			path.Empty();
			path << gpApp->m_curProjectPath;
			path << gpApp->PathSeparator;
			path << _T("Rebuild Log");
			// add a unique number each time, incremented by one from previous number
			// (starts at 0 when app was launched)
			gnFileNumber++; // get next value
			wxString suffixStr;
			suffixStr = suffixStr.Format(_T("%d"), gnFileNumber);
			//suffixStr = _T("1");

			path += suffixStr;
			path += _T(".txt");
			//path << suffixStr;
			//path << _T(".txt");

			wxLogNull logNo; // avoid spurious messages from the system

			wxFile fout;
			bool bOK;
			bOK = fout.Open(path, wxFile::write);
			if (!bOK)
			{
				// the data for the user to visually inspect can't be written out
				// so tell this to the user - an English message will do as we don't
				// ever expect this to happen
				wxMessageBox(_T("The data for visual inspection of fixes needed when updating the document could not be written out. You should check that the document is as you expect it to be."));
			}
			else
			{
				fout.Write(fixesStr, len);
				fout.Close();
			}
		}

		// prepare a possibly shorter message - if there are not many bad locations it may
		// suffice; but if too long then the message itself will inform the user to look in
		// the project folder for the "Rebuild Log.txt" file
		if (len > 1200 && !gbIsUnstructuredData)
		{
			// trim the excess and add the string telling user to check visually
			// & of the existence of Rebuild Log.txt
			fixesStr = fixesStr.Left(1200);
			fixesStr = MakeReverse(fixesStr);
			int nFound = fixesStr.Find(_T(' '));
			if (nFound != -1)
			{
				fixesStr = fixesStr.Mid(nFound);
			}
			fixesStr = MakeReverse(fixesStr);
			wxString appendStr;
			// IDS_APPEND_MSG
			appendStr = _(
				" ... for additional later locations needing manual editing please check the document visually. The full list has been saved in your project folder in the file \"Rebuild Log.txt\"");
			fixesStr += appendStr;
		}
		else if (!gbIsUnstructuredData)
		{
			wxString appendLogStr;
			// IDS_APPEND_LOG_REF
			appendLogStr = _(
				"    This list has been saved in your project folder in the file \"Rebuild Log.txt\"");
			fixesStr += appendLogStr; // tell the user about the log file:  Rebuild Log.txt
		}
		// display the message - in the case of unstructured data, there will be no list of
		// locations and the user will just have to search the document visually
		wxMessageBox(fixesStr, _T(""), wxICON_INFORMATION | wxOK);
	}

	// this is where we need to have the layout updated. We will do the whole lot, that is,
	// destroy and recreate both piles and strips
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#else
	GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#endif

	gpApp->m_pActivePile = pView->GetPile(gpApp->m_nActiveSequNum);
	GetLayout()->m_docEditOperationType = retokenize_text_op;
	return count;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		nFirstSequNum	-> the number to use for the first source phrase in pList
/// \param      pOtherList      -> default value is NULL, but if a pointer to a list of
///                                CSourcePhrase instances is supplied (this list can be
///                                of any length), then the renumbering happens in that
///                                list. When NULL, the app's m_pSourcePhrases list is used.
/// \remarks
/// Called from: the Doc's TokenizeText(), and ReconstituteAfterFilteringChange() and
/// other places - about two dozen in all so far.
/// Fixes the m_nSequNumber member of the source phrases in the current document
/// starting with nFirstSequNum in pList, so that all the remaining source phrases' sequence
/// numbers continue in numerical sequence (ascending order) with no gaps.
/// This function differs from AdjustSequNumbers() in that AdjustSequNumbers() effects its
/// changes only on the pList passed to the function; in UpdateSequNumbers() the current
/// document's source phrases beginning with nFirstSequNum are set to numerical sequence
/// through to the end of the document.
/// BEW changed 16Jul09 to have a second parameter which defaults to NULL, but otherwise is
/// a pointer to the SPList on which the updating is to be done. This allows the function
/// to be used on sublists which have to be processed by RecalcLayout(), as when doing a
/// range print - the refactored view requires that the partner piles be accessible by a
/// sequence number, and this will only work if the sublist of CSourcePhrase instances has
/// the element's m_nSequNumber values reset so as to be 0-based and numbered from the
/// first in the sublist. pOtherList can be set to any list, including of course, the
/// m_pSourcePhrases list, if the former contents of that list have been stored elsewhere
/// beforehand
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::UpdateSequNumbers(int nFirstSequNum, SPList* pOtherList)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList;
	if (pOtherList == NULL)
		// use the normal list which defines the whole document
		pList = pApp->m_pSourcePhrases;
	else
		// use some other list, typically a sublist with fewer elements, that stores
		// temporary subset of (shallow) copies of the main list's CSourcePhrase instances
		pList = pOtherList;

	// whm 26Aug11 modified. If pOtherList is NULL and pApp->m_pSourcePhrases has
	// a zero count, pList is an empty list and there are no sequence number to
	// update, so the function should just return.
	if (pList->GetCount() == 0)
		return;

	// get the first
	SPList::Node* pos_pList = pList->Item(nFirstSequNum);
	wxASSERT(pos_pList != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos_pList->GetData();
	pos_pList = pos_pList->GetNext();
	wxASSERT(pSrcPhrase);
	pSrcPhrase->m_nSequNumber = nFirstSequNum;
	int index = nFirstSequNum;

	while (pos_pList != 0)
	{
		pSrcPhrase = (CSourcePhrase*)pos_pList->GetData();
		pos_pList = pos_pList->GetNext();
		wxASSERT(pSrcPhrase);
		index++; // next sequence number
		pSrcPhrase->m_nSequNumber = index;
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		event	-> a wxCommandEvent associated with the wxID_NEW identifier
/// \remarks
/// Called from: the doc/view framework when File | New menu item is selected. In the wx
/// version this override just calls the App's OnFileNew() method.
/// BEW 24Aug10, removed the bool bUserSelectedFileNew member from the application, now
/// the view's OnCreate() call just checks for m_pKB == NULL and m_pGlossingKB == NULL as
/// an indicator that the view was clobbered, and it then recreates the in-memory KBs
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnFileNew(wxCommandEvent& event)
{
	// called when File | New menu item selected specifically by user
	// Note: The App's OnInit() skips this and calls pApp->OnFileNew directly
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	// BEW 21Aug15, Default the following flag to a TRUE value - just in case
	// collaboration mode may be in effect
	pApp->m_bConflictResolutionTurnedOn = TRUE;

	pApp->OnFileNew(event);
	// BEW added 7Oct14
	pApp->m_bZWSPinDoc = pApp->IsZWSPinDoc(pApp->m_pSourcePhrases);
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress the Split Document menu item is disabled and this
/// handler returns immediately. Otherwise, it enables the Split Document command on the
/// Tools menu if a document is open, unless the app is in Free Translation Mode.
/// BEW modified 13Nov09, don't allow user with read-only access to cause document
/// change of this kind on the remote user's machine
/// whm added 7Jul11 Don't allow splitting of documents when collaborating with an external
/// editor such as Paratext or Bibledit.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnUpdateSplitDocument(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	// BEW modified 03Nov05: let it be enabled for a dirty doc, but check for dirty flag
	// set and if so do an automatic save before attempting the split
	if (pApp->m_pKB != NULL && pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress or if the app is in Free Translation mode, the
/// Join Documents menu item is disabled and this handler returns immediately. It
/// enables the Join Document command if a document is open, otherwise it
/// disables the command.
/// BEW added 13Nov09, don't allow local user with read-only access to a remote project
/// folder to make document changes of this kind on the remote machine
/// whm added 7Jul11 Don't allow joining of documents when collaborating with an external
/// editor such as Paratext or Bibledit.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnUpdateJoinDocuments(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pKB != NULL && pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the Move Document command on the Tools menu and returns immediately if
/// vertical editing is in progress, or if the application is in Free Translation Mode.
/// This event handler enables the Move Document command if a document is open, otherwise
/// it disables the command.
/// BEW added 13Nov09, don't allow local user with read-only access to a remote project
/// folder to make document changes of this kind on the remote machine
/// whm added 7Jul11 Don't allow moving of documents when collaborating with an external
/// editor such as Paratext or Bibledit.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnUpdateMoveDocument(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pKB != NULL && pApp->m_bBookMode && pApp->m_nBookIndex != -1
		&& !pApp->m_bDisableBookMode)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there is a SF begin-marker in the passed in pSrcPhraseNext which,
///				for theSfmSet, is determined to be a marker whose endmarker should halt  
///				the scanning for the span to be filtered out. Otherwise FALSE (and the
///				caller will accumulate this one and keep on searching for where to halt).
/// \param		sfmSet			-> indicates which SFM set is to be considered active for the
///									LookupSFM() call
/// \param		pSrcPhraseNext	-> the CSourcePhrase instance whose m_markers member contains the
///								   stuff we are wanting to check out for a halt condition; it's
///								   the instance AFTER the actively being checked instance
/// \param		filterInfo		<- collect and return any encountered filtered information to
///								   the caller, so the caller can use it to carry it forward 
///								   when needed. 
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange().
/// Implements the protocol for determining when to stop scanning in a variety of
/// situations, when a prior call to a different function (HasMatchingEndMarker())
/// did not halt scanning at the previous CSourcePhrase instance because of the matching
/// endmarker for some reason was not there but should have been.
///
/// The passed in instance will be what the caller names as pSrcPhraseNext, that is,
/// the next one after the currently active one being considered as the last in the
/// filter span of instances. (pSrcPhraseNext is not NULL, caller weeds that option out)
/// 
/// So this function is extra insurance we don't filter out good (sacred text) content.
/// These are what we consider here...
///    - pSrcPhrase->m_filteredInfo might contain filtered material (this must stop
///      scanning because we can't embed filtered material in filtered material), (returns TRUE)
///    - or pSrcPhrase may contain a marker which Adapt It should ignore (eg. most inline markers)
///       those don't halt scanning - so returns FALSE for such
///    - or an unknown marker - these always halt scanning, (returns TRUE)
///    - or an embedded content marker within an \x (cross reference section) or \f (footnote)
///         or \fe (endnote) section - these don't halt scanning, (returns FALSE)
///    - or an inLine == FALSE marker - these halt scanning. (returns TRUE, but we need
///		 to test for \esb begin marker, which is inLine == FALSE, but non-binding type - that
///		 too should halt scanning; the endmarker \esbe, if relevant, was checked in the caller
///		 by HasMatchingEndMarker() prior to IsEndingSrcPhrase() being called.)
///    BEW 11Oct10, changes needed for support of docVersion 5
///	   BEW 30Sep19, updated comments for clarity, due to USFM3 now needing to be supported
///		 and some refactoring here and there to take m_inlineNonbindingMarkers into account
///    whm 24Oct2023 added last parameter to return any encountered filtered information to
///	   the caller, so the caller can use it to carry it forward when needed. We no longer use
///	   the existence of filterInfo to exclude the passed in CSourcePhrase instance from being 
///    in the to-be-filtered span. Instead we depend on other criteria.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::IsEndingSrcPhrase(enum SfmSet sfmSet, CSourcePhrase* pSrcPhraseNext, wxString& filterInfo)
{
	// whm 24Oct2023 we now carry forward any filtered info that is encountered via the
	// filterInfo reference parameter. When there is filtered information in pSrcPhraseNext
	// we add it to the filterInfo parameter, but we no longer use it to exclude the passed 
	// in CSourcePhrase instance from being in the to-be-filtered span.
	// 
	// [deprecated comment]: check for m_filteredInfo content first - if there is any, then we must exclude the
	// passed in CSourcePhrase instance from being in the to-be-filtered span, returning TRUE
	//if (!pSrcPhraseNext->GetFilteredInfo().IsEmpty())
	//{
	//	// something is filtered here, so we must halt
	//	return TRUE;
	//}
	wxString fInfo;
	fInfo = pSrcPhraseNext->GetFilteredInfo();
	if (!fInfo.IsEmpty())
	{
		filterInfo = filterInfo + fInfo;
	}

	// we'll allow a Note to be scanned over and lost in the filtering process, but not if
	// we've come to a free translation anchor, or where collected back translations are
	// stored, the latter two must halt scanning
	if (!pSrcPhraseNext->GetFreeTrans().IsEmpty() || !pSrcPhraseNext->GetCollectedBackTrans().IsEmpty())
	{
		return TRUE;
	}

	// now check out whatever might be in m_markers member or m_inlineNonbindingMarkers
	wxString markers = pSrcPhraseNext->m_markers;
	wxString nonbindingMkrs = pSrcPhraseNext->GetInlineNonbindingMarkers();
	bool bCheckNonbinding = FALSE;
	bool bCheckMarkers = FALSE;
	int nFound = markers.Find(gSFescapechar);
	int nFound2 = nonbindingMkrs.Find(gSFescapechar);
	if ((nFound == wxNOT_FOUND) && (nFound2 == wxNOT_FOUND))
	{
		// no SF markers in m_markers, neither in m_inlineNonbindingMarkers, so there 
		// is no reason to be halted by this pSrcPhraseNext
		return FALSE;
	}
	if (nFound != wxNOT_FOUND)
	{
		bCheckMarkers = TRUE;
	}
	if (nFound2 != wxNOT_FOUND)
	{
		bCheckNonbinding = TRUE;
	}

	if (bCheckMarkers) //  these are the legacy checks; anything that halts, 
					   //  return TRUE, otherwise fall thru to bCheckNonbinding block
	{
		wxString wholeMkr = GetLastMarker(markers);
		wxASSERT(!wholeMkr.IsEmpty());
		// m_markers does not contain any endmarkers, so wholeMkr is a beginmarker. Remove
		// its backslash so we can look it up
		wxString bareMkr = wholeMkr.Mid(1);

		// do lookup of the marker
		SfmSet saveSet = gpApp->gCurrentSfmSet; // save current set temporarily,
												// as sfmSet may be different
		gpApp->gCurrentSfmSet = sfmSet; // install the set to be used - as passed in
		USFMAnalysis* analysis = LookupSFM(bareMkr); // internally uses gUserSfmSet
		if (analysis == NULL)
		{
			// this must be an unknown marker - we deem these all inLine == FALSE, so this
			// indicates we are located at an ending sourcephrase
			gpApp->gCurrentSfmSet = saveSet; // restore earlier setting
			return TRUE;
		}
		else
		{
			// This is a known marker in the sfmSet marker set, so check it out (We don't check
			// for inline endmarkers like \f*, \fe* or \x* because if one of these occurs, and
			// it must halt scanning at the CSourcePhase which stores them - and that
			// CSourcePhrase instance is then WITHIN the span, but such a marker will occur on
			// the previous CSourcePhrase to the one passed in here. So IsEndingSrcPhrase() is
			// only used when a previous span-ending function call which just looks at
			// endmarkers has returned FALSE.)
			gpApp->gCurrentSfmSet = saveSet; // restore earlier setting
			if (analysis->inLine == FALSE)
			{
				// it's not an inLine marker, so it must end the filtering scan
				// because its a content marker
				gpApp->gCurrentSfmSet = saveSet; // restore earlier setting
				return TRUE;
			}
			else
			{
				// Inline markers \f, \fe or \x also are stored in m_markers, and if present
				// must cause a halt, so test for these too; but we keep parsing over any
				// embedded content markers in footnotes or endnotes, and in cross references,
				// such as: any of \xo, \xk, etc or \fr, \fk, \fv, fm, etc). The OR test's RHS
				// part is for testing for embedded content markers within an endnote - these
				// don't halt scanning either.
				wxString bareMkr = wholeMkr.Mid(1); // remove initial backslash
				wxString shortMkr = bareMkr.Left(1); // take only the first character
				if (((shortMkr == _T("f") || shortMkr == _T("x")) && shortMkr != bareMkr) ||
					((shortMkr == _T("f")) && (bareMkr != _T("fe"))))
				{
					// its an embedded content marker of a kind which does not halt scanning
					; // fall thru
				}
				else
				{
					// it must halt scanning
					gpApp->gCurrentSfmSet = saveSet; // restore earlier setting
					return TRUE;
				}
			}
		} // end else block for test: if (analysis == NULL)
		gpApp->gCurrentSfmSet = saveSet; // restore earlier setting

		// Checkout m_inlineNonbindingMarkers contents. If it contains any non-binding 
		// begin-marker, then halt and the previous instance is last, otherwise we'd 
		// overlap markup spans illegally
		if (bCheckNonbinding)
		{
			return TRUE;
		}
	}
	// tell the caller it's not the ending instance yet
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		offset of the marker which is to be filtered (ie. offset of its backslash) if markers
///				is a non-empty string containing a SFM which is designated as to be filtered (by being
///				listed in filterList string) and it is not preceded by \~FILTER; otherwise it returns -1.
/// \param		sfmSet			-> indicates which SFM set is to be considered active for the
///									LookupSFM() call
/// \param		markers			-> the pSrcPhrase->m_markers string from the sourcephrase being
///									currently considered, or pSrcPhrase's m_inlineNonbindingMarkers
/// \param		filterList		-> the list of markers to be filtered out, space delimited, including
///									backslashes... (the list might be just those formerly unfiltered
///									and now designated to be filtered, or in another context (such as
///									changing the SFM set) it might be the full set of markers designated
///									for filtering - which is the case is determined by the caller)
/// \param		wholeMkr		<- the SFM, including backslash, found to be designated for filtering out
/// \param		wholeShortMkr	<- the backslash and first character of wholeMkr (useful, when wholeMkr
///									is \x or \f)
/// \param		endMkr			<- the endmarker for wholeMkr, or an empty string if it does not potentially
///									take an endmarker
/// \param		bHasEndmarker	<- TRUE when wholeMkr potentially takes an endmarker (determined by Lookup())
/// \param		bUnknownMarker	<- TRUE if Lookup() determines the SFM does not exist in the sfmSet marker set
/// \param		startAt			-> the starting offset in the markers string at which the scanning is to be
///									commenced
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange().
/// Determines if a source phrase's m_markers member contains a marker to be filtered, and
/// if so, returns the offset into m_markers where the marker resides.
/// BEW 21Sep10, updated for docVersion 5
/// BEW 30Sep19, docVersion is 9, but no change needed here; however the function
/// will be called once or twice for each pSrcPhrase now, because some inline nonbinding
/// markers (like \fig) are filterable and not stored in pSrcPhrase->m_markers, and
/// others like sidebar non-inline marker (\esb) and its non-inline endmarker (\esbe) 
/// are filterable as well. The caller is refactored to support these new filter possibilities
///////////////////////////////////////////////////////////////////////////////
int CAdapt_ItDoc::ContainsMarkerToBeFiltered(enum SfmSet sfmSet, wxString markers,
	wxString filterList, wxString& wholeMkr, wxString& wholeShortMkr,
	wxString& endMkr, bool& bHasEndmarker, bool& bUnknownMarker,
	int startAt)
{
	int offset = startAt;
	if (markers.IsEmpty())
		return wxNOT_FOUND;
	bHasEndmarker = FALSE; // default
	bUnknownMarker = FALSE; // default
	int len = markers.Length();
	// wx version note: Since we require a read-only buffer we use GetData which just
	// returns a const wxChar* to the data in the string.
	const wxChar* pBuff = markers.GetData();
	wxChar* pEnd;
	pEnd = (wxChar*)pBuff + len; // point at the ending null
	wxASSERT(*pEnd == _T('\0')); // whm added 18Jun06, not in MFC
	pEnd = pEnd; // avoid warning
	wxChar* pBufStart = (wxChar*)pBuff;
	wxChar* ptr = pBufStart;
	wxChar* pFound = pBufStart; // pointer returned from _tcsstr()
								// (ie. strstr() or wcsstr()), null if unfound
	pFound += offset; // get the scan start location (offset will be reused below,
					  // so don't rely on it staying this present value)
	wxChar backslash[2] = { gSFescapechar,_T('\0') };
	int itemLen;

	// scan the buffer, looking for a filterable marker
	while ((pFound = wxStrstr(pFound, backslash)) != NULL)
	{
		// we have come to a backslash
		ptr = pFound;
		itemLen = ParseMarker(ptr);
		wxString mkr(ptr, itemLen); // this is the whole marker,
								   // including its backslash

		// it's potentially a marker which might be one for filtering out
		wxString mkrPlusSpace = mkr + _T(' '); // prevent spurious matches,
											   // eg. \h finding \hr
		int nFound = filterList.Find(mkrPlusSpace);
		if (nFound == wxNOT_FOUND)
		{
			// it's not in the list of markers designated as to be filtered,
			// so keep iterating
			pFound++;
			continue;
		}
		else
		{
			// this marker is to be filtered, so set up the parameters to
			// be returned etc
			offset = pFound - pBuff;
			wxASSERT(offset >= 0);
			wholeMkr = mkr;
			wholeShortMkr = wholeMkr.Left(2);

			// get its SFM characteristics, whether it has an endmarker,
			// and whether it is unknown
			SfmSet saveSet = gpApp->gCurrentSfmSet; // save current set
								// temporarily, as sfmSet may be different
			gpApp->gCurrentSfmSet = sfmSet; // install the set to be used
											// - as passed in
			wxString bareMkr = wholeMkr.Mid(1); // lop off the backslash
			USFMAnalysis* analysis = LookupSFM(bareMkr); // uses gCurrentSfmSet
			if (analysis == NULL)
			{
				// this must be an unknown marker designated for filtering by
				// the user in the GUI
				bUnknownMarker = TRUE;
				bHasEndmarker = FALSE; // unknown markers NEVER have endmarkers
				endMkr.Empty();
				gpApp->gCurrentSfmSet = saveSet; // restore earlier setting
				return offset; // return its offset
			}
			else
			{
				// this is a known marker in the sfmSet marker set
				endMkr = analysis->endMarker;
				bHasEndmarker = !endMkr.IsEmpty();
				if (bHasEndmarker)
				{
					endMkr = gSFescapechar + endMkr; // add the initial backslash
				}
				gpApp->gCurrentSfmSet = saveSet; // restore earlier setting
				// whm 24Oct2023 modification. Although the test below works OK for
				// markers like \ms here it is only because the calling chain made a call
				// to ResetUSFMFilterStructs() giving it a list of any markers whose
				// filtering status had just been changed by the USFM and Filtering tab
				// of Preferences. For consistency and clarity sake, however, I'm changing
				// the test below to test for the presence of the wholeAugmentedMarker within
				// the gCurrentFilterMarkers string.
				wxString wholeAugmentedMarker = wholeMkr + _T(" ");
				//if (analysis->filter)
				if (gpApp->gCurrentFilterMarkers.Find(wholeAugmentedMarker) != wxNOT_FOUND)
					return offset; // it's filterable, so return its offset
				else
					// it's either not filterable, or we've forgotten to update the
					// filter member of the USFMAnalysis structs prior to calling
					// this function
					return wxNOT_FOUND;
			}
		}
	}
	// didn't find a filterable marker that was not already filtered
	wholeShortMkr.Empty();
	wholeMkr.Empty();
	endMkr.Empty();
	return wxNOT_FOUND;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a copy of the wxString which is the appropriate nav text message
///             for the passed in CSourcePhrase instance (typically returned to the
///             m_inform member in the caller)
/// \param		pSrcPhrase	-> the CSourcePhrase instance which is to have its
///                            m_inform member reconstructed, modified, partly or wholely,
///                            by the set of markers changed by the user in the GUI)
/// \remarks
/// Called from: the App's AddBookIDToDoc(), the Doc's ReconstituteAfterFilteringChange(),
/// the View's OnRemoveFreeTranslationButton().
/// Re-composes the navigation text that is stored in a source phrase's m_inform member.
/// The idea behind this function is to get the appropriate m_inform text redone when
/// rebuilding the document - as when filtering changes are made, or a change of SFM set
/// which has the side effect of altering filtering settings as well, or the insertion of a
/// sourcephrase with an \id in m_markers and a 3-letter book ID code in the m_key member.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::RedoNavigationText(CSourcePhrase* pSrcPhrase)
{
	wxString strInform;
	strInform.Empty();

	// get the current m_markers contents
	wxString markersStr = pSrcPhrase->m_markers;
	if (markersStr.IsEmpty() || (markersStr.Find(gSFescapechar) == -1))
		return strInform;

	// there is something more to be handled
	wxString f(filterMkr);
	//int fltrMkrLen = f.Length(); // unused
	int markersStrLen = markersStr.Length() + 1; // allow for null at end
	const wxChar* ptr = NULL;
	int mkrLen = 0;
	int curPos = 0;
	bool bFILTERwasLastMkr = FALSE;
	while ((curPos = FindFromPos(markersStr, gSFescapechar, curPos)) != -1)
	{
		// wx version note: Since we require a read-only buffer we use GetData which just
		// returns a const wxChar* to the data in the string.
		ptr = markersStr.GetData();
		wxChar* pEnd;
		pEnd = (wxChar*)ptr + markersStrLen - 1; // whm added -1 compensates for
												 // increment of markerStrLen above
		wxASSERT(*pEnd == _T('\0')); // whm added 18Jun96
		pEnd = pEnd; // avoid warning
		wxChar* pBufStart = (wxChar*)ptr;
		mkrLen = ParseMarker(pBufStart + curPos);
		wxASSERT(mkrLen > 0);
		wxString bareMkr(ptr + curPos + 1, mkrLen - 1); // no gSFescapechar
														// (but may be an endmarker)
		curPos++; // increment, so the loop's .Find() test will advance curPos
				  // to the next marker
		wxString nakedMkr = bareMkr;
		nakedMkr = MakeReverse(nakedMkr);
		bool bEndMarker = FALSE;
		if (nakedMkr[0] == _T('*'))
		{
			// it's an endmarker
			nakedMkr = nakedMkr.Mid(1);
			bEndMarker = TRUE;
		}
		nakedMkr = MakeReverse(nakedMkr);
		wxString wholeMkr = gSFescapechar;
		wholeMkr += bareMkr;
		if (wholeMkr == filterMkr)
		{
			bFILTERwasLastMkr = TRUE; // suppresses forming nav text for
									// the next marker (coz it's filtered)
			continue; // skip \~FILTER
		}
		if (wholeMkr == filterMkrEnd)
		{
			bFILTERwasLastMkr = FALSE; // this will re-enable possible forming
									   // of nav text for the next marker
			continue; // skip \~FILTER*
		}

		// we only show navText for markers which are not endmarkers, and not filtered
		if (bFILTERwasLastMkr)
			continue; // this marker was preceded by \~FILTER,
					  // so it must not have nav text formed
		if (!bEndMarker)
		{
			USFMAnalysis* pAnalysis = LookupSFM(nakedMkr);
			wxString navtextStr;
			if (pAnalysis)
			{
				// the marker was found, so get the stored navText
				bool bInform = pAnalysis->inform;
				// only those markers whose inform member is TRUE are to be used
				// for forming navText
				if (bInform)
				{
					navtextStr = pAnalysis->navigationText;
					if (!navtextStr.IsEmpty())
					{
						//a:
						if (strInform.IsEmpty())
						{
							strInform = navtextStr;
						}
						else
						{
							strInform += _T(' ');
							strInform += navtextStr;
						}
					}
				}
			}
			else
			{
				// whm Note 11Jun05: I assume that an unknown marker should not appear in
				// the navigation text line if it is filtered. I've also modified the code
				// in AnalyseMarker() to not include the unknown marker in m_inform when
				// the unknown marker is filtered there, and it seems that would be
				// appropriate here too. If Bruce thinks the conditional call to
				// IsAFilteringUnknownSFM is not appropriate here the conditional I've
				// added should be removed; likewise the parallel code I've added near the
				// end of AnalyseMarker should be evaluated for appropriateness.
				// ( <--Bill's addition is fine, BEW 15Jun05)
				if (!IsAFilteringUnknownSFM(nakedMkr))
				{
					// the marker was not found, so form a ?mkr? string instead
					navtextStr = _T("?");
					navtextStr += gSFescapechar; // whm added 10Jun05
					navtextStr += nakedMkr;
					// BEW commented out next line. It fails for a naked marker such as
					// lb00296b.jpg which appeared in Bob Eaton's data as a picture
					// filename; what happens is that ? followed by space does not get
					// appended, but the IDE shows the result as "?\lb00296b.jpg" and in
					// actual fact the navtextStr buffer contains that plus a whole long
					// list of dozens of arbitrary memory characters (garbage) which
					// subsequently gets written out as navText - Ugh! So I've had to place
					// the required characters in the buffer explicitly.
					navtextStr += _T("? ");
				}
				// code block at goto a; copied down here to get rid of goto a; and label
				// (and gcc warning)
				if (strInform.IsEmpty())
				{
					strInform = navtextStr;
				}
				else
				{
					strInform += _T(' ');
					strInform += navtextStr;
				}
			}
		} // end block for !bEndMarker

	} // end loop for searching for all markers to be used for navText
	return strInform;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		pList	<- the list of source phrases
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange() and
/// ReconstituteAfterPunctuationChange().
/// Deletes the source phrase instances held in pList, but retains the empty list. It is
/// called during the rebuilding of the document after a filtering or punctuation change.
/// BEW added 23May09: since it is called only from the above two functions, and both of
/// those when they return to the caller will have the view updated by a RecalcLayout()
/// call with the enum parameter valoue of create_piles_create_strips, we do not need to
/// have DeletePartnerPile() called when each of the DeleteSingleSrcPhrase(() calls are
/// made in the loop below; therefore we specify the FALSE parameter for the call of the
/// latter function in order to suppress deletion of the partner pile (as RecalcLayout()
/// will do it much more efficiently, en masse, and speedily).
///
/// Note: if ever we use this function elsewhere, and need the partner pile deletion to
/// work there, then we will need to alter the signature to become:
/// (SPList*& pList, bool bDoPartnerPileDeletionAlso = TRUE) instead
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::DeleteListContentsOnly(SPList*& pList)
{
	// DeleteListContentsOnly is a useful utility in the rebuilding of the doc
	SPList::Node* pos_pList = pList->GetFirst();
	CSourcePhrase* pSrcPh;
	while (pos_pList != NULL)
	{
		pSrcPh = (CSourcePhrase*)pos_pList->GetData();
		pos_pList = pos_pList->GetNext();
		DeleteSingleSrcPhrase(pSrcPh, FALSE); // no need to bother to delete the
											 // partner pile
	}
	pList->Clear();
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString with any filtered brackets removed from around its filtered
///				information
/// \param		str		-> a wxString containing filtered information enclosed within
///							\~FILTER ...\~FILTER* filtering brackets
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange(), GetUnknownMarkersFromDoc(),
/// the View's RebuildSourceText(), DoPlacementOfMarkersInRetranslation(),
/// RebuildTargetText(), DoExportInterlinearRTF(), GetMarkerInventoryFromCurrentDoc(),
/// and CViewFilteredMaterialDlg::InitDialog().
/// Removes any \~FILTER and \~FILTER* brackets from a string. The information that was
/// previously bracketed by these markers remains intact within the string.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::RemoveAnyFilterBracketsFromString(wxString str) // whm added 6Apr05
{
	// ammended 29Apr05 to remove multiple sets of filter brackets from str. Previously the
	// function only removed the first set of brackets found in the str.
	// whm revised 2Oct05 to more properly handle the deletion of spaces upon/after the
	// removal of the filter brackets
	int mkrPos = str.Find(filterMkr);
	int endMkrPos = str.Find(filterMkrEnd);
	while (mkrPos != -1 && endMkrPos != -1 && endMkrPos > mkrPos)
	{
		// whm 8Jun12 modified for wxWidgets-2.9.3 wxStrlen_() is invalid, use wxStrlen()
		str.Remove(endMkrPos, wxStrlen(filterMkrEnd)); //str.Remove(endMkrPos, wxStrlen_(filterMkrEnd));
		// after deleting the end marker, endMkrPos will normally point to a following
		// space whenever the filtered material is medial to the string. In such cases we
		// want to also eliminate the following space. The only time there may not be a
		// space following the end marker is when the filtered material was the last item
		// in m_markers. In this case endMkrPos would no longer index a character within
		// the string after the deletion of the end marker.
		if (endMkrPos < (int)str.Length() && str.GetChar(endMkrPos) == _T(' '))
			str.Remove(endMkrPos, 1);
		// whm 8Jun12 modified for wxWidgets-2.9.3 wxStrlen_() is invalid, use wxStrlen()
		str.Remove(mkrPos, wxStrlen(filterMkr)); //str.Remove(mkrPos, wxStrlen_(filterMkr));
		// after deleting the beginning marker, mkrPos should point to the space that
		// followed the beginning filter bracket marker - at least for well formed
		// filtered material. Before deleting that space, however, we check to ensure
		// it is indeed a space.
		if (str.GetChar(mkrPos) == _T(' '))
			str.Remove(mkrPos, 1);
		// set positions for any remaining filter brackets in str
		mkrPos = str.Find(filterMkr);
		endMkrPos = str.Find(filterMkrEnd);
	}
	// change any left-over multiple spaces to single spaces
	int dblSpPos = str.Find(_T("  "));
	while (dblSpPos != -1)
	{
		str.Remove(dblSpPos, 1);
		dblSpPos = str.Find(_T("  "));
	}
	return str;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString which is a copy of the filtered SFM or USFM next found  composed of
///				\~FILTER ... \~FILTER* plus the marker and associated string content in between,
///				or an empty string if one is not found. It's just the marker which we return.
/// \param		markers	-> references the content of a CSourcePhrase instance's m_filteredInfo member
///				or the m_filteredInfo_After member
/// \param		offset	-> character offset to where to commence the Find operation for the
///						   \~FILTER marker
/// \param		nStart	<- offset (from beginning of markers, ) to the next \~FILTER instance found,
///						   if none is found it is set to the offset value (so a Left() call can
///						   extract any preceding non-filtered text stored in markers)
/// \param		nEnd	<- offset (ditto) to the first character past the matching \~FILTER*
///						   (& space) instance, if none is found it is set to the offset value
///						   (so a Mid() call can get the remainder)
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange().
/// Copies from a m_markers string the whole string representing filtered information,
/// i.e., the filtering brackets \~FILTER ... \~FILTER* plus the marker and associated
/// string content in between. Offsets are returned in nBegin and nEnd that enable the
/// function to be called repeatedly within a while loop until no additional filtered
/// material is found.
/// The nStart and nEnd values can be used by the caller, along with Mid(), to extract the
/// filtered substring (including bracketing FILTER markers); nStart, along with Left() can
/// be used by the caller to extract whatever text precedes the \~FILTER instance (eg. to
/// store it in another CSourcePhrase instance's m_markers member), and nEnd, along with
/// Mid(), can be used by the caller to extract the remainder (if any) - which could be
/// useful in the caller when unfiltering in order to update m_markers after unfiltering
/// has ceased for the current CSourcePhrase instance, or to replace post-word unfiltered
/// material from m_filteredInfo_After when unfiltering. (To interpret the nStart and nEnd
/// values correctly in the caller upon return, the returned wxString should be checked to
/// determine if it is empty or not.) The caller also can use the nEnd value to compute an
/// updated offset value for iterating the function call to find the next filtered marker.
/// BEW 20Sep10, updated for docVersion 5 - we don't check m_markers, but m_filteredInfo
/// BEW 18Aapr18 - can be used for m_filteredInfo contents or m_filteredInfo_After contents
/// but just changing the contents of the first parameter to be from the one storage
/// location or the other. Code needs no change internally
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::GetNextFilteredMarker(wxString& markers, int offset,
	int& nStart, int& nEnd)
{
	wxString mkrStr;
	mkrStr.Empty();
	if (offset < 0 || offset > 10000)
		offset = 0; // assume it's a bad offset value, so start from zero

	// find the next \~FILTER marker starting from the offset (there may be no more)
	nStart = offset; // default 'not found' value
	nEnd = offset; // ditto
	int nFound = FindFromPos(markers, filterMkr, offset);
	if (nFound == -1)
	{
		// no \~FILTER marker was found at offset or beyond
		return mkrStr;
	}
	else
	{
		// we found one, so get the metrics calculated and the marker parsed
		nStart = nFound;
		wxString theRest = markers.Mid(nStart); // \~FILTER\marker followed
												// by its content etc.
		wxString f(filterMkr); // so I can get a length calculation done
							   // (this may be localized later)
		int len = f.Length() + 1; // + 1 because \~FILTER is always
								  // followed by a space
		theRest = theRest.Mid(len); // \marker followed by its content etc
		int len2 = theRest.Length();
		// wx version note: Since we require a read-only buffer we use GetData which just
		// returns a const wxChar* to the data in the string.
		const wxChar* ptr = theRest.GetData();
		wxChar* pEnd;
		pEnd = (wxChar*)ptr + len2; // whm added 19Jun06
		wxChar* pBufStart = (wxChar*)ptr;
		wxASSERT(*pEnd == _T('\0'));// whm added 19Jun06
		wxUnusedVar(pEnd); // avoid compiler warning
		int len3 = ParseMarker(pBufStart);
		mkrStr = theRest.Left(len3);
		wxASSERT(mkrStr[0] == gSFescapechar); // make sure we got a valid marker

		// now find the end of the matching \~FILTER* endmarker - we must find this for the
		// function to succeeed; if we don't, then we must throw away the mkrStr value (ie.
		// empty it) and revert to the nStart and nEnd values for a failure
		int nStartFrom = nStart + len + len3; // offset to character after the marker
											  // in mkrStr (a space)
		nFound = FindFromPos(markers, filterMkrEnd, nStartFrom);
		if (nFound == wxNOT_FOUND)
		{
			// no matching \~FILTER* marker; this is an error condition, so bail out
			nStart = nEnd = offset;
			mkrStr.Empty();
			return mkrStr;
		}
		else
		{
			// we found the matching filter marker which brackets the end, so get offset to
			// first character beyond it (?? and its following space?? see below) & we are
			// done...
			//
			// BEW 20Sep10: in docVersion 5, not only do we store filtered stuff in
			// m_filteredInfo, but we but filter markers up against each other, so we can get
			// a sequence "\~FILTER*\~FILTER " and so we can't assume a space between these,
			// and indeed, we no longer even try to put one there; so only count a space
			// after \~FILTER* if there is indeed one there
			wxString fEnd(filterMkrEnd);
			len3 = fEnd.Length();
			nEnd = nFound + len3;
			// whm modified 7Jul12. To avoid an out of range array access error (which asserts in
			// wxidgets 2.9.3) we need to ensure that markers[nEnd] is not out of range, so I'm
			// adding the following two initial tests: !markers.IsEmpty() && markers.Len() > nEnd &&
			// to the original test.
			if (!markers.IsEmpty() && markers.Len() > (size_t)nEnd && markers[nEnd] == _T(' ')) //if (markers[nEnd] == _T(' '))
				nEnd++; // count the following space too
		}
	}
	return mkrStr;
}

// Internal code is tweaked from GetNextFilteredMarker() and the signature is changed to return
// the metadata string, and the filtered content with \mkr and any \mkr* following the content.
// Note, the first param is still "markers" - this is just a carryover from the early days when
// all filtering was stored in the m_markers member of CSourcePhrase. That was changed some years
// back to get the filtering done to the m_filteredInfo member instead - but I left the internal
// "markers" name unchanged at that time. Now we've created this new function for use with the
// additional CSourcePhrase member m_filteredInfo_After, which stores post-word filtered info
// on the same (current) CSourcePhrase instance as for pre-word filtered info. This more
// recent change is for supporting the new SFM/USFM parser for the 'word' and associated information,
// as defined by the ParseWord2() function which is used in TokenizeText() to replace use of
// ParseWord() there. At the time of writing this, ParseWord2() is not in any released version yet,
// the most recent release being 6.8.2
wxString CAdapt_ItDoc::GetNextFilteredMarker_After(wxString& markers, wxString& filteredInfo_After,
	wxString& metadata, int& offset, int& nEnd)
{

	wxString mkrStr;
	mkrStr.Empty();
	filteredInfo_After.Empty();

	// find the next \~FILTER marker starting from the offset (there may be no more)
	int nStart = offset; // default 'not found' value
	// nEnd = offset; // ditto
	int nFound = FindFromPos(markers, filterMkr, offset);
	if (nFound == -1)
	{
		// no \~FILTER marker was found at offset or beyond
		return mkrStr;
	}
	else
	{
		// we found one, so get the metrics calculated and the marker parsed
		offset = nFound;

		// Get the offset to the matching \~FILTER* marker, include it in the span along
		// with any following whitespace - and set the final value in nEnd so that when
		// this function returns, offset and nEnd can be used to remove that filtered
		// info (for unfiltering) provided that the caller determines it is to be
		// unfiltered
		int offset2 = FindFromPos(markers, filterMkrEnd, nFound + filterMkr.Length());
		if (offset2 == wxNOT_FOUND)
		{
			// There is no matching \~FILTER* endmarker in m_filteredInfo_After, so
			// leave any content in that location, and advance offset and nEnd to
			// the end of m_filteredInfo_After, and return the empty mkrStr, and the
			// caller should not again call this function for the current pSrcPhrase
			offset = markers.Length();
			nEnd = offset;
			return mkrStr;
		}
		else
		{
			// We have found a matching \~FILTER* endmarker in m_filteredInfo_After
			// at a location beyond the end of the begin marker \~FILTER; so set up
			// the appropriate nEnd value - that's the sole task for this code block
			nEnd = offset2 + filterMkrEnd.Length();

			// There may be whitespace following it - such whitespace is unwanted, so
			// so augment the nEnd value by as many characters of it are found after
			// the \~FILTER* marker ends
			wxString lastBit = markers.Mid(nEnd);
			const wxChar* constPtr = lastBit.GetData();
			wxChar* ptrBufStart = (wxChar*)constPtr;
			int nWhitesCount = ParseWhiteSpace(ptrBufStart);
			nEnd += nWhitesCount;
		}

		// Continue by copying the metadata & filtered material for return  by the signature
		// and the filtered marker itself as the return value (so the caller can determine
		// if unfiltering is required for it)
		nStart = nFound;
		wxString theRest = markers.Mid(nStart); // \~FILTER\marker followed
												// by its content etc.
		wxString f(filterMkr); // so I can get a length calculation done
							   // (this may be localized later)
		int len = f.Length() + 1; // + 1 because \~FILTER is always
								  // followed by a space
		theRest = theRest.Mid(len); // \marker followed by its content etc, with metadata
									// preceding it. We need to copy the metadata and return
									// it via the signature (so the caller can remove it and
									// use it for placement of the unfiltered stuff in the src text
		int len2 = theRest.Length();

		// BEW 18Apr17 delineate the [[after_... ^]] metadata substring, and put a
		// copy in metadata param of signature; search in theRest; this is new code
		int metadataLength = 0;
		metadata.Empty(); // start if off empty, in case we don't find any
		int offset_metaStart = theRest.Find(gpApp->strSearchForAfter);
		if (offset_metaStart == wxNOT_FOUND)
		{
			// There's no metadata apparently, so use GetNextFilteredMarker() so caller
			// can just plonk the unfiltered (if non-empty) content at the end of
			// whatever currently follows the word proper
			mkrStr = GetNextFilteredMarker(markers, offset, nStart, nEnd);
			return mkrStr;
		}
		else
		{
			// We found the start of a metadata substring
			wxString str = theRest.Mid(offset_metaStart); // str and theRest
										// should be identical, just playing safe
			wxString metaEnd = _T("^]]"); // length = 3, used below
			int offset_metaEnd = str.Find(metaEnd);
			wxASSERT(offset_metaEnd != wxNOT_FOUND);
			wxString md = wxString(str.GetData(), offset_metaEnd + 3 - offset_metaStart); // +3 for the ^]] at end
			metadata = md; // return via signature
			metadataLength = md.Length();

			// Now skip over the metadata in theRest, so that the stuff below will work
			theRest = theRest.Mid(metadataLength);
		}
		// This ends the new code, except for a couple of extra lines below

		// wx version note: Since we require a read-only buffer we use GetData which just
		// returns a const wxChar* to the data in the string.
		const wxChar* ptr = theRest.GetData();
		wxChar* pEnd;
		pEnd = (wxChar*)ptr + len2 - metadataLength; // whm added 19Jun06
				// (adds len2 = length of \~FILTER), & BEW 18Mar17 subtracts metadataLength
		wxChar* pBufStart = (wxChar*)ptr;
		wxASSERT(*pEnd == _T('\0'));// whm added 19Jun06
		wxUnusedVar(pEnd); // avoid compiler warning
		int len3 = ParseMarker(pBufStart);
		mkrStr = theRest.Left(len3);
		wxASSERT(mkrStr[0] == gSFescapechar); // make sure we got a valid marker

		// now find the end of the matching \~FILTER* endmarker - we must find this for the
		// function to succeeed; if we don't, then we must throw away the mkrStr value (ie.
		// empty it) and revert to the nStart and nEnd values for a failure
		// BEW 18Apr17 added + metadataLength to next line
		int nStartFrom = len3; // offset to the character
											  // after the marker in mkrStr (a space)
		nFound = FindFromPos(theRest, filterMkrEnd, nStartFrom);
		if (nFound == wxNOT_FOUND)
		{
			// no matching \~FILTER* marker; this is an error condition, so bail out
			nStart = nEnd = offset;
			mkrStr.Empty();
			return mkrStr;
		}
		else
		{
			// we found the matching filter marker which brackets the end, so the material
			// we wish to return to the caller is from start of theRest as far as the
			// nFound value (thereby excluding the final \~FILTER* endmarker)
			//
			// BEW 20Sep10: in docVersion 5, not only do we store filtered stuff in
			// m_filteredInfo, but we but filter markers up against each other, so we can get
			// a sequence "\~FILTER*\~FILTER " and so we can't assume a space between these,
			// and indeed, we no longer even try to put one there; so make sure it is not
			// returned to the caller if it is present - so Trim() as below
			filteredInfo_After = theRest.Mid(0, nFound);
			filteredInfo_After.Trim(); // drop any whitespace that may lurk before the \~FILTER*
		}
	}
	return mkrStr;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param	oldSet				-> indicates which SFM set was active before the user changed
///									to a different one
/// \param	newSet				-> indicates which SFM set the user changed to
/// \param	oldFilterMarkers	-> the list of markers that was filtered out, space delimited,
///									including backslashes, which were in effect when the oldSet
///									was the current set,
/// \param	newFilterMarkers	-> the list of markers to be filtered out, along with their
///									content, now that the newSet has become current
/// \param	secondPassFilterMkrs <- a list of the markers left after common ones have been
///									removed from the newFilterMarkers string -- these markers
///									are used on the second pass which does the filtering
/// \param	pass				-> an enum value, which can be first_pass or second_pass; the
///									first pass through the document does unfiltering within
///									the context of the oldSet, and the second pass does
///									filtering within the context of the newSet.
/// \remarks
/// Called from: the Doc's RetokenizeText().
/// Sets up the document's data structures for the two pass reconstitution that must be
/// done when there has been a SFM set change. The function gets all the required data
/// structures set up appropriately for whichever pass is about to be effected (The caller
/// must have saved the current SFM set gCurrentSfmSet before this function is called for
/// the first time, and it must restore it after this function is called the second time
/// and the changes effected.)
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::SetupForSFMSetChange(enum SfmSet oldSet, enum SfmSet newSet,
	wxString oldFilterMarkers, wxString newFilterMarkers,
	wxString& secondPassFilterMkrs, enum WhichPass pass)
{
	// get a MapWholeMkrToFilterStatus map filled first with the set of original filter
	// markers, then on the second pass to be filled with the new filter markers (minus
	// those in common which were removed on first pass)
	wxString mkr;
	MapWholeMkrToFilterStatus mkrMap;
	MapWholeMkrToFilterStatus* pMap = &mkrMap;

	if (pass == first_pass)
	{
		// fill the map
		GetMarkerMapFromString(pMap, oldFilterMarkers);

#ifdef _Trace_RebuildDoc
		TRACE1("first_pass    local mkrMap size = %d\n", pMap->GetSize());
#endif

		// iterate, getting each marker, adding a trailing space, and removing same from
		// each of oldFilterMarkers and newFilterMarkers if in each, but making no change
		// if not in each
		gpApp->m_FilterStatusMap.clear();
		MapWholeMkrToFilterStatus::iterator iter;
		for (iter = pMap->begin(); iter != pMap->end(); ++iter)
		{
			mkr = iter->first;
			wxString mkrPlusSpace = mkr + _T(' ');
			bool bRemoved = RemoveMarkerFromBoth(mkrPlusSpace, oldFilterMarkers,
				newFilterMarkers);

#ifdef _Trace_RebuildDoc
			TRACE2("first_pass    bRemoved = %d, mkr = %s\n", (int)bRemoved, mkr);
#endif

			// if it did not get removed from both, then we will need to unfilter this mkr
			// in the first pass - so put it in m_FilterStatusMap with a "0" string value
			// associated with the marker as the key, ready for the later
			// ReconstituteAfterFilteringChange() call in the caller
			if (!bRemoved)
			{
				(gpApp->m_FilterStatusMap)[mkr] = _T("0"); // "0" means
											// "was filtered, but now to be unfiltered"
			}
		}

		// set secondPassFilterMkrs to whatever is left after common ones have been removed
		// from the newFilterMarkers string -- these will be used on the second pass which
		// does the filtering
		secondPassFilterMkrs = newFilterMarkers;

		// set the old SFM set to be the current one; setup is complete for the first pass
		// through the doc
		gpApp->gCurrentSfmSet = oldSet;

#ifdef _Trace_RebuildDoc
		TRACE2("first_pass    gCurrentSfmSet = %d,\n\n Second pass marker set: =  %s\n", (int)oldSet, secondPassFilterMkrs);
#endif
	}
	else // this is the second_pass
	{
		// on the second pass, the set of markers which have to be filtered out are passed
		// in in the string secondPassFilterMkrs (computed on the previous call to
		// SetupForSFMSetChange()), so all we need to do here is set up m_FilterStatusMap
		// again, with the appropriate markers and an associated value of "1" for each,
		// ready for the ReconstituteAfterFilteringChange() call in the caller
		if (secondPassFilterMkrs.IsEmpty())
		{
			gpApp->m_FilterStatusMap.clear();
			goto h;
		}

		// fill the local map, then iterate through it filling m_FilterStatusMap
		GetMarkerMapFromString(pMap, secondPassFilterMkrs);

		// set up m_FilterStatusMap again
		gpApp->m_FilterStatusMap.clear();

		{	// this extra block extends for the next 28 lines. It avoids the bogus
			// warning C4533: initialization of 'f_iter' is skipped by 'goto h'
			// by putting its code within its own scope
			MapWholeMkrToFilterStatus::iterator iter;
			for (iter = pMap->begin(); iter != pMap->end(); ++iter)
			{
				(gpApp->m_FilterStatusMap)[mkr] = _T("1"); // "1" means
										// "was unfiltered, but now to be filtered"

#ifdef _Trace_RebuildDoc
				TRACE1("second_pass    m_FilterStatusMap.SetAt() =   %s    = \"1\"\n", mkr);
#endif
			}
		} // end of extra block

		// set the new SFM set to be the current one; second pass setup is now complete
	h:		gpApp->gCurrentSfmSet = newSet; // caller has done it already, or should have

#ifdef _Trace_RebuildDoc
		TRACE1("second_pass    gCurrentSfmSet = %d    (0 is UsfmOnly, 1 is PngOnly)\n", (int)newSet);
#endif
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		pMkrMap		<- pointer to a map of wholeMkr (including backslash) strings
///								derived from the str parameter, with the wholeMkr as key,
///								and value being an empty string (we don't care a hoot about
///								the value, we just want the benefits of the hashing on the key)
/// \param		str			-> a sequence of whole markers (including backslashes), with a
///								space following each, but there should not be any endmarkers
///								in str, but we'll make them begin markers if there are
/// \remarks
/// Called from: the Doc's SetupForSFMSetChange().
/// Populates a MapWholeMkrToFilterStatus wxHashMap with bare markers. No mapping associations are
/// made from this function - all are simply associated with a null string.
/// Extracts each whole marker, removes the backslash, gets rid of any final * if an endmarkers somehow
/// crept in unnoticed, and if unique, stores the bareMkr in the map; if the input string str is empty,
/// it exits without doing anything.
///
/// BEW 24Oct14, leave unchanged for USFM nested markers support - this would mean
/// the map may contain the +tag of a marker like \+tag - but we'll assume that's
/// what should happen until we find otherwise
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::GetMarkerMapFromString(MapWholeMkrToFilterStatus*& pMkrMap,
	wxString str) // BEW added 06Jun05
{
	wxChar nix[] = _T(""); // an arbitrary value, we don't care what it is
	wxString wholeMkr = str;

	// get the first marker
	wxStringTokenizer tkz(wholeMkr); // use default " " whitespace here

	while (tkz.HasMoreTokens())
	{
		wholeMkr = tkz.GetNextToken();
		// remove final *, if it has one (which it shouldn't)
		wholeMkr = MakeReverse(wholeMkr);
		if (wholeMkr[0] == _T('*'))
			wholeMkr = wholeMkr.Mid(1);
		wholeMkr = MakeReverse(wholeMkr);

		// put it into the map
		(*pMkrMap)[wholeMkr] = nix;
	};
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the passed in wholeMarker and trailing space were removed from both
///				str1 and str2, FALSE otherwise
/// \param		mkr		-> the wholeMarker (includes backslash, but no * at end) plus a trailing space
/// \param		str1	<- a set of filter markers (wholeMarkers, with a single space following each)
/// \param		str2	<- another set of filter markers (wholeMarkers, with a single space following each)
/// \remarks
/// Called from: the Doc's SetupForSFMSetChange().
/// Removes any markers (and trailing space) from str1 and from str2 which are common to
/// both strings. Used in the filtering stage of changing from an earlier SFM set to a
/// different SFM set - we wish use RemoveMarkerFromBoth in order to remove from contention
/// any markers and their content which were previously filtered and are to remain filtered
/// when the change to the different SFM set has been effected (since these are already
/// filtered, we leave them that way)
/// BEW 24Oct14, no changes for support of USFM nested markers (according to the above
/// comments, if any \+tag style of marker is in one of the sets (it would not be in both)
/// then it would not be removed - that probably is what should happen) - see doc class,
/// SetupForSFMSetChange(), the only place it is called
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::RemoveMarkerFromBoth(wxString& mkr, wxString& str1, wxString& str2)
{
	int curPos1 = str1.Find(mkr);
	wxASSERT(curPos1 >= 0); // mkr MUST be in str1, since the set of mkr strings
							// was obtained from str1 earlier
	int curPos2 = str2.Find(mkr);
	if (curPos2 != -1)
	{
		// mkr is in both strings, so remove it from both
		int len = mkr.Length();
		str1.Remove(curPos1, len);
		str2.Remove(curPos2, len);
		return TRUE;
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		dest	<- the source phrase whose flags are made to agree with src's flags
/// \param		src		-> the source phrase whose flags are copied to dest's flags
/// \remarks
/// Called from: the Doc's ReconstituteOneAfterPunctuationChange().
/// Copies the boolean values from src source phrase to the dest source phrase. The flags
/// copied are: m_bFirstOfType, m_bFootnoteEnd, m_bFootnote, m_bChapter, m_bVerse,
/// m_bParagraph, m_bSpecialText, m_bBoundary, m_bHasInternalMarkers, m_bHasInternalPunct,
/// m_bRetranslation, m_bNotInKB, m_bNullSourcePhrase, m_bHasKBEntry,
/// m_bBeginRetranslation, m_bEndRetranslation, and m_bHasGlossingKBEntry.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::CopyFlags(CSourcePhrase* dest, CSourcePhrase* src)
{
	// BEW added on 5April05, to simplify copying of CSourcePhrase flag values
	dest->m_bFirstOfType = src->m_bFirstOfType;
	dest->m_bFootnoteEnd = src->m_bFootnoteEnd;
	dest->m_bFootnote = src->m_bFootnote;
	dest->m_bChapter = src->m_bChapter;
	dest->m_bVerse = src->m_bVerse;
	// BEW 8Oct10, repurposed m_bParagraph as m_bUnused
	//dest->m_bParagraph = src->m_bParagraph;
	dest->m_bUnused = src->m_bUnused;
	dest->m_bSpecialText = src->m_bSpecialText;
	dest->m_bBoundary = src->m_bBoundary;
	dest->m_bHasInternalMarkers = src->m_bHasInternalMarkers;
	dest->m_bHasInternalPunct = src->m_bHasInternalPunct;
	dest->m_bRetranslation = src->m_bRetranslation;
	dest->m_bNotInKB = src->m_bNotInKB;
	dest->m_bNullSourcePhrase = src->m_bNullSourcePhrase;
	dest->m_bHasKBEntry = src->m_bHasKBEntry;
	dest->m_bBeginRetranslation = src->m_bBeginRetranslation;
	dest->m_bEndRetranslation = src->m_bEndRetranslation;
	dest->m_bHasGlossingKBEntry = src->m_bHasGlossingKBEntry;
}

// Returns the target text adaptation string resulting from a reparse of the m_targetStr
// member after punctuation settings were changed (the target language punctuation
// settings may have be changed or not, we don't care which is the case); the first
// parameter is the the original m_targetStr on the currently being accessed CSourcePhrase
// instance, and we reparse with target punctuation settings - so that we get the
// unpunctuated string we want in the m_key member of the instance() in pTempList which we use
// internally. We pass in the caller's CSourcePhrase instance's m_nSequNumber value in
// param 2, only in order that the reparse doesn't try deal with a value of -1; but the
// param 2 value actually makes no difference to what is computed for returning as the
// adaptation without any punctuation
wxString CAdapt_ItDoc::MakeAdaptionAfterPunctuationChange(wxString& targetStrWithPunctuation,
	int startingSequNum)
{
	wxString str = targetStrWithPunctuation;
	bool bHasFixedSpaceMkr = FALSE;
	bHasFixedSpaceMkr = IsFixedSpaceSymbolWithin(str);
	wxString adaption; adaption.Empty();
	SPList* pTempList = new SPList;
	CSourcePhrase* pSPhr = NULL;
	// TRUE in next call is bool bUseTargetTextPuncts, this call is an overload of the
	// legacy TokenizeTargetTextString() function
	int elementCount = gpApp->GetView()->TokenizeTargetTextString(pTempList, str, startingSequNum, TRUE);
	elementCount = elementCount; // avoid compiler warning
	wxASSERT(elementCount > 0); // there should be at least one CSourcePhrase instance in pTempList
	SPList::Node* pos_pTempList = pTempList->GetFirst();
	// what we do depends on whether a fixed-space conjoining is present or not
	if (bHasFixedSpaceMkr)
	{
		// we assume ~ only conjoins a pair of words, not a series of three or more; and
		// pTempList will then contain only one CSourcePhrase instance which is a
		// pseudo-merger of the two conjoined parts, so m_nSrcWords == 2
		SPList::Node* pos_partialList = pTempList->GetFirst();
		CSourcePhrase* pSP = pos_partialList->GetData();
		wxASSERT(pSP->m_nSrcWords == 2 && pTempList->GetCount() == 1);
		SPList::Node* pos_pSavedWord = pSP->m_pSavedWords->GetFirst();
		CSourcePhrase* pWordSrcPhrase = pos_pSavedWord->GetData();
		adaption = pWordSrcPhrase->m_key;
		adaption += _T("~"); // fixed space marker
		pos_pSavedWord = pSP->m_pSavedWords->GetLast();
		pWordSrcPhrase = pos_pSavedWord->GetData();
		adaption += pWordSrcPhrase->m_key;  // append the second word
	}
	else
	{
		// most of the time, control will go through this block and there will usually be
		// just a single CSourcePhrase instance in pTempList (exceptions will be when
		// dealing with a merger, or the reparse of a single instance results in 2 or more
		// due to the effect of the punctuation change)
		SPList::Node* pos_partialList = pTempList->GetFirst();
		while (pos_partialList != NULL)
		{
			CSourcePhrase* pSP = pos_partialList->GetData();
			if (adaption.IsEmpty())
			{
				adaption = pSP->m_key;
			}
			else
			{
				adaption += _T(" ") + pSP->m_key;
			}
		}
	}
	// cleanup
	pos_pTempList = pTempList->GetFirst();
	while (pos_pTempList != NULL)
	{
		pSPhr = pos_pTempList->GetData();
		DeleteSingleSrcPhrase(pSPhr, FALSE); // there is no partner pile
		pos_pTempList = pos_pTempList->GetNext();
	}
	pTempList->Clear();
	if (pTempList != NULL) // whm 11Jun12 added NULL test
		delete pTempList;
	return adaption;
}


///////////////////////////////////////////////////////////////////////////////
/// \return		FALSE if the rebuild potentially isn't done fully right internally (that
///             usually means that rebuilding one CSourcePhrase instance resulted in two
///             or more new ones being created - so we have to replace the old one with
///             the rebuilds; whereas a successful rebuild means one CSourcePhrase is
///             just changed internally and no new ones needed to be created), TRUE if
///             the rebuild was successful
/// \param		pView		-> a pointer to the View
/// \param		pList		<- the list of source phrases of the current document
///                            (i.e. m_pSourcePhrases)
/// \param		pos_callers	-> the node location which stores the passed in pSrcPhrase
/// \param		pSrcPhrase	<- the pointer to the CSourcePhrase instance on the pos_callers
///                            Node passed in as the previous parameter
/// \param		fixesStr	<- reference to the caller's storage string for accumulating
///							   a list of references to the locations where the rebuild
///							   potentially isn't quite fully right, for specific
///							   pSrcPhrase instances, if any
/// \remarks
/// Called from: the Doc's RetokenizeText().
/// Rebuilds the document after a punctuation change has been made. If the function "fails"
/// internally (ie. potentially isn't a simple rebuild, as discussed above for the return
/// value), that particular pSrcPhrase instance has to be noted with a reference to chapter
/// and verse in fixesStr so the user can later inspect the doc visually and edit at such
/// locations to restore the translation (or gloss) correctly; but while the legacy
/// function would throw away the adaptation in such a circumstance happened, this present
/// (11Oct10)refactoring will try to retain the adaptation - even if it means a new
/// CSourcePhrase is left with m_adaption and m_targetStr empty, we rely on the user's
/// manual check to then fix things if it's different than what it should be, after the
/// rebuild has finished. \So a "fail" of the rebuild means that the rebuild did not, for
/// the rebuild done on a single CSourcePhrase instance, result in a single CSourcePhrase
/// instance - but rather two or more (it is not possible for the rebuild of a single
/// instance to result in none).
///
/// ???? the next paragraph may be inaccurate -- I'm gunna reparse fully, so probably
/// we'll insert the new one or more before the old one, on every call, and delete the old
/// one, rather than messing with copying info etc -- remove the next paragraph if this is
/// indeed what I end up doing (BEW 13Jan11)
/// ???
/// Our approach is as follows: if the rebuild of each generates a single instance, we
/// re-setup the members of that passed in instance with the correct new values, (and throw
/// away the rebuilt one - fixing that one up would be too time-consuming); but if the
/// rebuild fails, we go to the bother of putting the possibly altered translation into the
/// m_adaption and m_targetStr members of the instance with the longest m_key member, and
/// other members we copy across to the first of the new instances; then insert the new
/// list into the main document's list, and throw away the original passed in one. We
/// internally keep track of how many new CSourcePhrase instances are created and how many
/// of these precede the view's m_nActiveSequNum value so we can progressively update the
/// latter and so reconstitute the phrase box at the correct location when done.
///
/// BEW ammended definition and coded the function
/// whm added to wxWidgets build 4Apr05
/// BEW 11Oct10 (actually 13Jan11)added code to base reparse on returned string from the
/// function FromSingleMakeSstr() (rather than on m_srcPhrase, because the latter would
/// ignore the stored inline markers etc); and also added code to use an overload of
/// TokenizeTextString() to parse the old m_targetStr adaptation, (whenever an adaptation
/// is present of course, this function has to be able to operate on unadapted
/// CSourcePhrase instances too), so as to extract a possibly adjusted m_adaption value to
/// use in the rebuild, and not to abandon the legacy adaptations if possible, - the final
/// result should be a much better rebuild, keeping much more (or all) of the information
/// without loss, and alerting the user to where we think a visual inspection should be
/// done in order to verify the results are acceptable - and edit if not.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::ReconstituteAfterPunctuationChange(CAdapt_ItView* pView,
	SPList*& pList, SPList::Node* pos_callers, CSourcePhrase*& pSrcPhrase,
	wxString& fixesStr)
{
	int nOriginalCount = pSrcPhrase->m_nSrcWords;
	//bool bNotInKB = FALSE; // default // set but not used
	//bool bRetranslation = FALSE; // default // set but not used
	//if (pSrcPhrase->m_bRetranslation) bRetranslation = TRUE;
	//if (pSrcPhrase->m_bNotInKB) bNotInKB = TRUE;

	SPList* pResultList = new SPList; // where we'll store pointers to parsed
			// new CSourcePhrase instances; but only use what is in it provided there is
			// only one stored there - if more than one, we delete them and retain
			// unchanged the original pSrcPhrase passed in
	bool bSucceeded = TRUE;

	// remove the CRefString entries for this instance from the KBs, or decrement its count
	// if several seen before but do restoring of KB entries within the called functions
	// (because they know whether the rebuild succeeded or not and they have the required
	// strings at hand) - but do the removal from the KB only if not a placeholder, not a
	// retranslation not specified as "not in the KB", and there is a non-empty adaptation
	if (!pSrcPhrase->m_bNullSourcePhrase && !pSrcPhrase->m_bRetranslation &&
		!pSrcPhrase->m_bNotInKB && !pSrcPhrase->m_adaption.IsEmpty())
	{
		pView->RemoveKBEntryForRebuild(pSrcPhrase);
	}
	// determine whether we are dealing with just one, or an owning one and the sublist
	// containing those it owns (note, a conjoined pair with joining by fixed space USFM
	// marker, ~ , is to be treated as a single CSourcePhrase even though formally it's a
	// pseudo-merger, so we must call IsFixedSpaceSymbolWithin() in the test and if it
	// returns TRUE, we don't enter the TRUE block below, but rather process such an
	// instance in the else block where ReconstituteOneAfterPunctuationChange() is called)
	if (pSrcPhrase->m_nSrcWords > 1 && !IsFixedSpaceSymbolWithin(pSrcPhrase))
	{
		//#ifdef _DEBUG
		//		wxLogDebug(_T("  ReconsistuteAfterPunctuationChange: 17,734 For Merger:  pSrcPhrase sn = %d  m_srcPhrase = %s"),
		//					pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str());
		//#endif

				// BEW 10Mar11, the protocol we use for mergers is the following:
				// (a) we must change the punctuation & src & tgt language members not just of the
				// merged instance, but also for each of the instances in it's m_pSavedWords
				// sublist of originals. (Why? Because the user may sometime unmerge it, and we
				// don't want to be restoring instances to be viewed, which reflect the old
				// punctuation settings.)
				// (b)Care must be exercised, merging creates another level of CSourcePhrase
				// instances, so our algorithm must avoid calling Merge() (see SourcePhrase.cpp)
				// on the instances in the saved sublist, such as m_pSavedWords. But we also want
				// to keep the converted target text, where it exists, so....
				// (c)We use FromMergerMakeSstr() to get a source text string, srcPhrase, with all
				// the markers, unfilterings, punctuations etc in their proper place;
				// (d) We use TokenizeTextString(), passing in pResultList to get returned newly
				// created CSourcePhrase instances returned, having passed in srcPhrase wxString;
				// (e) provided, and only provided, the number of elements in pResultList equals
				// the element count of pSrcPhrase->m_pSavedWords, we iterate in parallel over
				// both the latter and the CSourcePhrase instances in pResultList, and copy over
				// from the latter the changed text and punctuation strings, to the former; we
				// also obtain from the pResultList's instances, each m_targetStr contents, and
				// using the new punctuation settings (ie. making a RemovePunctuation() call with
				// the appropriate punctuation string passed in)calculate a new m_adaption value
				// for each instance, and we then transfer the m_adaption values back to the same
				// members on the equivalent CSourcePhrase instances within the
				// pSrcPhrase->m_pSavedWords list (the m_targetStr values won't have changed)
				// (f) pSrcPhrase->m_pSavedWords's contents are now up-to-date for the changed
				// punctuation settings. The owning merged CSourcePhrase instance's m_srcPhrase
				// member will not have changed (punctuation settings changes don't add or remove
				// or alter the location of punctuation and word building characters in the source
				// text, it just redefines where the boundaries are between "the words" and the
				// punctuation characters at the start and end of them. So, to get the new value
				// for the m_adaption member of the merger (ie. of pSrcPhrase), all we need do is
				// pass pSrcPhrase->m_srcPhrase through RemovePunctuation() using the final
				// parameter from_target_text so as to do it with the target language's new
				// punctuation settings (which may, or may not, have changed).
				// Once (f) is completed, the whole original merged pSrcPhrase has been
				// successfully updated to the new punctuation settings.
		SPList* pOwnedList = pSrcPhrase->m_pSavedWords; // for convenience's sake

		// placeholders can't be merged, and so won't be in the merger, so this block can
		// ignore them

		wxString srcPhrase; // for a copy of m_srcPhrase member
		wxString targetStr; // for a copy of m_targetStr member
		wxString adaption; // for a copy of m_adaption member
		wxString gloss; // for a copy of m_gloss member
		adaption.Empty();
		gloss.Empty();

		// setup the srcPhrase, targetStr and gloss strings - we must handle glosses too
		// regardless of the current mode (whether adapting or not) since rebuilding
		// affects everything
		gloss = pSrcPhrase->m_gloss; // we don't care if glosses have punctuation or not
		// Set srcPhrase string: this member has all the source punctuation, if any on this
		// word or phrase, as well as markers etc, as FromMergerMakeSstr() is docv5 aware
		//srcPhrase = pSrcPhrase->m_srcPhrase;
		srcPhrase = FromMergerMakeSstr(pSrcPhrase);
		// Set targetStr only to the punctuated m_targetStr member, because we only want
		// to deal with words, tgt punctuation and possibly fixed space marker (~) when we
		// come to reparsing the target text with target punctutation chars to see if
		// things have been changed in the target text
		targetStr = pSrcPhrase->m_targetStr;
		// calling RemovePunctuation() on this, using the target language punctuation
		// settings string, will produce an appropriate m_adaption member for the merged
		// instance
		adaption = targetStr;
		if (!adaption.IsEmpty())
		{
			pView->RemovePunctuation(this, &adaption, from_target_text);
			pSrcPhrase->m_adaption = adaption;
		}
		// Note: in case you are wondering... changing the punctuation settings, not matter
		// what kind of change is made to them, will have absolutely no effect on the
		// merger's m_srcPhrase value. The latter can't obtain new characters, nor lose
		// existing characters, by a punctuation settings change. All that can happen is
		// that the status of some characters already present will underlyingly change from
		// being word-building, to being punctuation, or vise versa. Nor can the relative
		// order of characters in m_srcPhrase be changed by a change to the punctuation
		// settings. It's only m_key and/or m_adaption which have the potential to have
		// different values after a punctuation change.

		// reparse the srcPhrase string - this will use the newly changed punctuation
		// settings, and hopefully, produce a new set of CSourcePhrase instances, with
		// same count as would be obtained from a GetCount() call on m_pSavedWords above;
		// this isn't guaranteed however, and if the count differs, we won't use the
		// results of this tokenization
		srcPhrase.Trim(TRUE); // trim right end
		srcPhrase.Trim(FALSE); // trim left end
		int numElements;
		numElements = pView->TokenizeTextString(pResultList, srcPhrase, pSrcPhrase->m_nSequNumber);
		wxASSERT(numElements > 1);
		numElements = numElements; // avoid warning

		// BEW 10Mar11, if the counts match, then we can copy data from one instance in
		// pResultsList to the corresponding instance in pSrcPhrase->m_pSavedWords, and if
		// that is the case, we get a robust conversion. Different element counts result
		// in indeterminacies in how to transfer the data appropriately. Rather than
		// guessing, we return FALSE to let fixesStr get an entry added, and the caller
		// will ensure it is shown to the user so he can visually inspect the document and
		// edit it as required at the appropriate places.

		// test to see if we have a candidate for updating successfully
		if ((int)pResultList->GetCount() == nOriginalCount)
		{
			// The number of new CSourcePhrase instances has not changed, because it
			// matches the count of the instances in pSrcPhrase->m_pSavedWords. So we can
			// update the merger.
			SPList::Node* posOwned = pOwnedList->GetFirst(); // i.e. from pSrcPhrase->m_pSavedWords list
			SPList::Node* posNew = pResultList->GetFirst(); // i.e. from the tokenization above
			bool bIsFirst = FALSE;
			bool bIsLast = FALSE;
			int count = 0;
			pSrcPhrase->m_pMedialPuncts->Clear(); // we refill it below, in the loop
			while (posOwned != NULL && posNew != NULL)
			{
				CSourcePhrase* pOwnedSrcPhrase = posOwned->GetData();
				posOwned = posOwned->GetNext();
				CSourcePhrase* pNewSrcPhrase = posNew->GetData();
				posNew = posNew->GetNext();

				count++;
				if (count == 1)
					bIsFirst = TRUE;
				if (count == nOriginalCount)
					bIsLast = TRUE;

				// Transfer m_key, m_srcPhrase, from pResultsList's instances, the latter
				// is built from the reconstituted source text, and so has no adaptation
				// information. But for m_adaption and m_targetStr for the owned
				// CSourcePhrase instances' list, we have to take the values in the
				// instances within pSrcPhrase->m_pSavedWords - their m_targetStr values
				// (for the values with punctuation), but for the m_adaption values, we'll
				// have to pass the former through RemovePunctuation() using the
				// use_target_punctuation enum value. The new values for m_precPunct,
				// m_follPunct and m_follOuter punct are more tricky - we can transfer
				// what is in each instance within pResultsList's instances, but only to
				// each of the instances in pSrcPhrase->m_pSavedWords; and as we do that
				// we have to use the bIsFirst and bIsLast flags to transfer only the
				// m_precPunct value from the first, and m_follPunct and m_follOuterPunct
				// from the last in pResultsList directly to the parent pSrcPhrase's
				// m_precPunct and m_follPunct and m_follOuterPunct members - but for all
				// others, they are "medial" to the merger, and so have to be added, in
				// order encountered, to pSrcPhrase->m_pMedialPuncts wxArrayString.
				// (m_pMedialMarkers values don't change when doing adjustments for a
				// change in the punctuation settings, so we can leave what is in
				// pSrcPhrase unchanged)
				pOwnedSrcPhrase->m_srcPhrase = pNewSrcPhrase->m_srcPhrase; // this line should be redundant
				pOwnedSrcPhrase->m_key = pNewSrcPhrase->m_key;
				wxString anAdaption;
				wxString aTargetStr = pOwnedSrcPhrase->m_targetStr; // m_targetStr shouldn't have changed
				anAdaption = aTargetStr;
				if (!anAdaption.IsEmpty())
				{
					pView->RemovePunctuation(this, &anAdaption, from_target_text);
					pOwnedSrcPhrase->m_adaption = anAdaption;
				}
				else
				{
					pOwnedSrcPhrase->m_adaption.Empty();
				}
				pOwnedSrcPhrase->m_precPunct = pNewSrcPhrase->m_precPunct;
				pOwnedSrcPhrase->m_follPunct = pNewSrcPhrase->m_follPunct;
				pOwnedSrcPhrase->SetFollowingOuterPunct(pNewSrcPhrase->GetFollowingOuterPunct());
				if (bIsFirst)
				{
					// first instance in pResultsList; anything in the pResultsList's
					// m_precPunct from the initial instance has to be copied directly
					pSrcPhrase->m_precPunct = pOwnedSrcPhrase->m_precPunct; // as set above

					// but anything in m_follPunct and/or m_follOuterPunct has to be copied
					// to pSrcPhrase->m_pMedialPuncts array instead
					wxString follPunctStr = pNewSrcPhrase->m_follPunct;
					if (!follPunctStr.IsEmpty())
					{
						pSrcPhrase->m_pMedialPuncts->Add(follPunctStr);
					}
					wxString follOuterPunctStr = pNewSrcPhrase->GetFollowingOuterPunct();
					if (!follOuterPunctStr.IsEmpty())
					{
						pSrcPhrase->m_pMedialPuncts->Add(follOuterPunctStr);
					}
					bIsFirst = FALSE; // after entered once, prevent re-entry to this block
				}
				else if (bIsLast)
				{
					// last instance in pResultsList; anything in m_follPunct and/or
					// m_follOuterPunct has to be copied direct to same members of pSrcPhrase
					pSrcPhrase->m_follPunct = pOwnedSrcPhrase->m_follPunct; // as set above
					pSrcPhrase->SetFollowingOuterPunct(pOwnedSrcPhrase->GetFollowingOuterPunct()); // as set above

					// but anything in m_precPunct in the instance from pResultsList, has to
					// be copied to pSrcPhrase->m_pMedialPuncts array
					wxString precPunctStr = pNewSrcPhrase->m_precPunct;
					if (!precPunctStr.IsEmpty())
					{
						pSrcPhrase->m_pMedialPuncts->Add(precPunctStr);
					}
				}
				else if (!bIsLast && !bIsFirst)
				{
					// neither first nor last instance in pResultsList; any punctuation in
					// such instances' m_precPuncts, m_follPuncts, and/or m_follOuterPuncts
					// has to be copied to pSrcPhrase->m_pMedialPuncts array
					wxString precPunctStr = pNewSrcPhrase->m_precPunct;
					if (!precPunctStr.IsEmpty())
					{
						pSrcPhrase->m_pMedialPuncts->Add(precPunctStr);
					}
					wxString follPunctStr = pNewSrcPhrase->m_follPunct;
					if (!follPunctStr.IsEmpty())
					{
						pSrcPhrase->m_pMedialPuncts->Add(follPunctStr);
					}
					wxString follOuterPunctStr = pNewSrcPhrase->GetFollowingOuterPunct();
					if (!follOuterPunctStr.IsEmpty())
					{
						pSrcPhrase->m_pMedialPuncts->Add(follOuterPunctStr);
					}
				}
			} // end of loop for test: while (posOwned != NULL && posNew != NULL)
		} // end of TRUE block for test:  if ((int)pResultList->GetCount() == nOriginalCount)
		else // the reparsed source text has generated a different number of CSourcePhrase instances
		{
			// we got too many or two few CSourcePhrase instances in the reparse of the
			// source text (including markers etc) from the merger, so we'll have to
			// abandon this merger; instead, just retain the pSrcPhrase passed in,
			// unchanged, - clear out pResultList, leave an entry in fixesStr and return
			// FALSE
			pView->UpdateSequNumbers(0); // make sure they are in sequence,
										 // so next call won't fail
			if (!gbIsUnstructuredData)
			{
				// sequence numbers should be up-to-date
				fixesStr += pView->GetChapterAndVerse(pSrcPhrase);
				wxString srcStr = _T(' ');
				srcStr += pSrcPhrase->m_srcPhrase;
				fixesStr += srcStr;
				fixesStr += _T("   ");
			}
			// the pResultList list was not used in this block,
			// so we can unilaterally clear it here
			SPList::Node* aPos = pResultList->GetFirst();
			CSourcePhrase* pASrcPhrase = NULL;
			while (aPos != NULL)
			{
				pASrcPhrase = (CSourcePhrase*)aPos->GetData();
				aPos = aPos->GetNext();
				DeleteSingleSrcPhrase(pASrcPhrase, FALSE); // FALSE means
					// "don't delete its partner pile" as we'll let RecalcLayout()
					// delete them all quickly en masse later
			}
			pResultList->Clear();
			if (pResultList != NULL) // whm 11Jun12 added NULL test
				delete pResultList;
			return FALSE;
		} // end of else block for test: if ((int)pResultList->GetCount() == nOriginalCount)
	} // end of block for when dealing with a merged sourcephrase
	else // the test of pSrcPhrase->m_nSrcWords yielded 1
		 // (ie. an unmerged sourcephrase)
	{
		// we are dealing with a plain vanila single-word non-owned sourcephrase in either
		// adaptation or glossing mode
		// FALSE is bIsOwned, i.e. not owned, when not owned it is visible in the layout,
		// if TRUE, it is one which is stored in the m_pSavedWords list of an unowned
		// CSourcePhrase and so is not visible in the layout
		bool bWasOK = ReconstituteOneAfterPunctuationChange(
			pView, pList, pos_callers, pSrcPhrase, fixesStr, pResultList, FALSE);

		//#ifdef _DEBUG
		//		wxLogDebug(_T("  17950 After ...One..., RETURNED bWasOK = %d  ,  pSrcPhrase sn = %d  m_srcPhrase = %s"),
		//					bWasOK, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str());
		//#endif
		if (!bWasOK)
		{
			// we got more than one in the reparse, so we are going to retain the passed
			// in pSrcPhrase unchanged
			if (!gbIsUnstructuredData)
			{
				// sequence numbers should be up-to-date
				fixesStr += pView->GetChapterAndVerse(pSrcPhrase);
				wxString srcStr = _T(' ');
				srcStr += pSrcPhrase->m_srcPhrase;
				fixesStr += srcStr;
				fixesStr += _T("   ");
			}

			// the pResultList list was not used in this block,
			// so we can unilaterally clear it here
			SPList::Node* aPos = pResultList->GetFirst();
			CSourcePhrase* pASrcPhrase = NULL;
			while (aPos != NULL)
			{
				pASrcPhrase = (CSourcePhrase*)aPos->GetData();
				aPos = aPos->GetNext();
				DeleteSingleSrcPhrase(pASrcPhrase, FALSE); // FALSE means
					// "don't delete its partner pile" as we'll let RecalcLayout()
					// delete them all quickly en masse later
			}
			pResultList->Clear();
			if (pResultList != NULL) // whm 11Jun12 added NULL test
				delete pResultList;

			return FALSE;
		}
	} // end of else block for test: if (pSrcPhrase->m_nSrcWords > 1 && !IsFixedSpaceSymbolWithin(pSrcPhrase))

	// delete the local list and its managed memory chunks - don't leak memory
	SPList::Node* aPos = pResultList->GetFirst();
	CSourcePhrase* pASrcPhrase = NULL;
	while (aPos != NULL)
	{
		pASrcPhrase = (CSourcePhrase*)aPos->GetData();
		aPos = aPos->GetNext();
		DeleteSingleSrcPhrase(pASrcPhrase, FALSE); // FALSE means
						// "don't delete its partner pile" as we'll let RecalcLayout()
						// delete them all quickly en masse later
	}
	pResultList->Clear();
	if (pResultList != NULL) // whm 11Jun12 added NULL test
		delete pResultList;

	// the 8Mar11 changes should mean that the m_nActiveSequNum will not be changed by
	// this function nor any it calls
	//gpApp->m_nActiveSequNum = nActiveSequNum; // update the view's member
											  // so all keeps in sync
	// sequence numbers should not need updating, but we'll do so for safety's sake
	pView->UpdateSequNumbers(0);

	return bSucceeded;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		bKBFilename				-> if TRUE the KB's filename is to be updated
/// \param		bKBPath					-> if TRUE the KB path is to be updated
/// \param		bKBBackupPath			-> if TRUE the KB's backup path is to be updated
/// \param		bGlossingKBPath			-> if TRUE the glossing KB path is to be updated
/// \param		bGlossingKBBackupPath	-> if TRUE the glossing KB's backup path is to be updated
/// \remarks
/// Called from: the App's LoadGlossingKB(), LoadKB(), StoreGlossingKB(), StoreKB(),
/// SaveKB(), SaveGlossingKB(), SubstituteKBBackup().
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::UpdateFilenamesAndPaths(bool bKBFilename, bool bKBPath,
	bool bKBBackupPath, bool bGlossingKBPath,
	bool bGlossingKBBackupPath)
{
	// ensure the current KB filename ends with .xml extension
	if (bKBFilename)
	{
		wxString thisFilename = gpApp->m_curKBName;
		thisFilename = MakeReverse(thisFilename);
		int nFound = thisFilename.Find(_T('.'));
		wxString extn = thisFilename.Left(nFound);
		extn = MakeReverse(extn);
		if (extn != _T("xml"))
		{
			thisFilename = thisFilename.Mid(nFound); // chop off bad extn
			thisFilename = MakeReverse(thisFilename);
			thisFilename += _T("xml"); // add xml as the extension
			gpApp->m_curKBName = thisFilename; // update to correct filename
		}
	}

	// KB Path (m_curKBPath)
	if (bKBPath)
	{
		wxString thisPath = gpApp->m_curKBPath;
		thisPath = MakeReverse(thisPath);
		int nFound = thisPath.Find(_T('.'));
		wxString extn = thisPath.Left(nFound);
		extn = MakeReverse(extn);
		if (extn != _T("xml"))
		{
			thisPath = thisPath.Mid(nFound); // chop off bad extn
			thisPath = MakeReverse(thisPath);
			thisPath += _T("xml"); // add xml as the extension
			gpApp->m_curKBPath = thisPath;
		}
	}

	// KB Backup Path (m_curKBBackupPath)
	// BEW 3Mar11, changed for .BAK rather than .BAK.xml, at Bob Eaton's request
	if (bKBBackupPath)
	{
		// this has an extension, which is always to be .BAK
		wxString thisBackupPath = gpApp->m_curKBBackupPath;
		thisBackupPath = MakeReverse(thisBackupPath); // reversed
		int nFound = thisBackupPath.Find(_T("KAB."));
		if (nFound != wxNOT_FOUND)
		{
			// found outermost (reversed) .BAK -- nothing to do except reverse again
			thisBackupPath = MakeReverse(thisBackupPath);
		}
		else
		{
			// no extension! Therefore just take the name and add .BAK
			thisBackupPath = MakeReverse(thisBackupPath);
			thisBackupPath += _T(".BAK");
		}
		gpApp->m_curKBBackupPath = thisBackupPath;
	}

	// Glossing KB Path
	if (bGlossingKBPath)
	{
		wxString thisGlossingPath = gpApp->m_curGlossingKBPath;
		thisGlossingPath = MakeReverse(thisGlossingPath);
		int nFound = thisGlossingPath.Find(_T('.'));
		wxString extn = thisGlossingPath.Left(nFound);
		extn = MakeReverse(extn);
		if (extn != _T("xml"))
		{
			thisGlossingPath = thisGlossingPath.Mid(nFound); // chop off bad extn
			thisGlossingPath = MakeReverse(thisGlossingPath);
			thisGlossingPath += _T("xml"); // add xml as the extension
			gpApp->m_curGlossingKBPath = thisGlossingPath;
		}
	}

	// Glossing KB Backup Path
	if (bGlossingKBBackupPath)
	{
		// this has an extension, which is always to be .BAK
		wxString thisGlossingBackupPath = gpApp->m_curGlossingKBBackupPath;
		thisGlossingBackupPath = MakeReverse(thisGlossingBackupPath); // reversed
		int nFound = thisGlossingBackupPath.Find(_T("KAB."));
		if (nFound != wxNOT_FOUND)
		{
			// found outermost (reversed) .BAK -- nothing to do but reverse again
			thisGlossingBackupPath = MakeReverse(thisGlossingBackupPath);
		}
		else
		{
			// no extension! Therefore just take the name and add .BAK
			thisGlossingBackupPath = MakeReverse(thisGlossingBackupPath);
			thisGlossingBackupPath += _T(".BAK");
		}
		gpApp->m_curGlossingKBBackupPath = thisGlossingBackupPath;
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		title				-> the new title to be used on the document's title bar
/// \param		nameMinusExtension	<- the same name as title, but minus any extension returned by
///										reference to the caller
/// \remarks
/// Called from: the Doc's OnNewDocument(), OnOpenDocument() and CMainFrame's OnIdle().
/// Sets or updates the main frame's title bar with the appropriate name of the current
/// document. It also suffixes " - Adapt It" or " - Adapt It Unicode" to the document title,
/// depending on which version of Adapt It is being used.
/// The extension for all documents in the wx version is .xml. This function also calls
/// the doc/view framework's SetFilename() to inform the framework of the change in the
/// document's name.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::SetDocumentWindowTitle(wxString title, wxString& nameMinusExtension)
{
	// remove any extension user may have typed -- we'll keep control ourselves
	wxString noExtnName = gpApp->MakeExtensionlessName(title);
	nameMinusExtension = noExtnName; // return to the caller the name
									 // without the final extension

	// we'll now put on it what the extension should be, according to the doc type we have
	// elected to save
	wxString extn = _T(".xml");
	title = noExtnName + extn;

	// whm Note: the m_strTitle is internal to CDocument
	// update the target platform's native storage for the doc title
	this->SetFilename(title, TRUE); // see above where default unnamedN is set -
									// TRUE means "notify views"

	// our Adapt It main window should also show " - Adapt It" or " - Adapt It Unicode"
	// after the document title, so we'll set that up by explicitly overwriting the title
	// bar's document name (Also, via the Setup Wizard, an output filename is not
	// recognised as a name by MFC and the MainFrame continues to show "Untitled", so we
	// set the window title explicitly as above)
	wxDocTemplate* pTemplate = GetDocumentTemplate();
	wxASSERT(pTemplate != NULL);
	wxString typeName, typeName2; // see John's book p149
	// BEW added Unicode for unicode build, 06Aug05
	typeName = pTemplate->GetDocumentName(); // returns the document type name as passed
											 // to the doc template constructor
	typeName2 = pTemplate->GetDescription();
	if (!typeName.IsEmpty())
	{
		typeName = _T(" - Adapt It");
#ifdef _UNICODE
		typeName += _T(" Unicode");
#endif
	}
	else
	{
		typeName = _T(" - ") + typeName; // Untitled, I think
#ifdef _UNICODE
		typeName += _T(" Unicode");
#endif
	}
	this->SetTitle(title + typeName);
	// whm added 28Sep12. Call the main frame's SetTitle()
	// also as this seems to be required on Linux for the
	// title name to change properly.
	CMainFrame* pFrame;
	pFrame = gpApp->GetMainFrame();
	pFrame->SetTitle(title + typeName); // use the frame's SetTitle too as this seems to be required on Linux
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		curOutputFilename	-> the current m_curOutputFilename value, or value
///                                    of some other filename string (eg. a renamed one)
/// \remarks
/// Called from: the Doc's BackupDocument() and DoFileSave().
/// Ensures that the m_curOutputBackupFilename ends with ".BAK". The wx version does
/// not handle the legacy .adt binary file types/extensions.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::MakeOutputBackupFilenames(wxString& curOutputFilename)
{
	// input should be the current m_curOutputFilename value, a renamed filename; the
	// function assumes that the caller's value for m_curOutputFilename, or the renamed
	// filename, is correct

	// we calculate the backup name here, .xml for the final extension is always done;
	// while it should not happen that the incoming filename has any other final extension
	// than .xml, we don't assume so and so we recalculate here to ensure .xml compliance
	wxString baseFilename = curOutputFilename;
	wxString thisBackupFilename;
	baseFilename = MakeReverse(baseFilename);
	int nFound = baseFilename.Find(_T('.'));
	wxString extn;
	if (nFound > -1)
	{
		nFound += 1;
		extn = baseFilename.Left(nFound); // include period in the extension
		thisBackupFilename = baseFilename.Mid(extn.Length());
	}
	else
	{
		// no extension
		thisBackupFilename = baseFilename;
	}
	thisBackupFilename = MakeReverse(thisBackupFilename);

	// saving will be done in XML format, so backup filenames must comply with that...

	// add the required extensions; the complying backup filename is always of form:  *.BAK
	thisBackupFilename += _T(".BAK");
	//gpApp->m_curOutputBackupFilename = thisBackupFilename + _T(".xml"); BEW removed 3Mar11
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		event	-> unused wxCommandEvent
/// \remarks
/// Called from: the Tools menu "Split Document..." command.
/// Invokes the CSplitDialog dialog.
/// BEW 29Mar10, added RemoveSelection() call, because if the command is entered and acted
/// upon immediately after, say, a Find which gets the wanted location and shows it
/// selected, a later RemoveSelection() call will try remove m_selection data which by
/// then will contain only hanging CCell pointers - giving a crash
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnSplitDocument(wxCommandEvent& WXUNUSED(event))
{
	gpApp->GetView()->RemoveSelection();
	CSplitDialog d(gpApp->GetMainFrame());
	d.ShowModal();
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		event	-> unused wxCommandEvent
/// \remarks
/// Called from: the Tools menu "Join Document..." command.
/// Invokes the CJoinDialog dialog.
/// BEW 29Mar10, added RemoveSelection() call, because if the command is entered and acted
/// upon immediately after, say, a Find which gets the wanted location and shows it
/// selected, a later RemoveSelection() call will try remove m_selection data which by
/// then will contain only hanging CCell pointers - giving a crash
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnJoinDocuments(wxCommandEvent& WXUNUSED(event))
{
	// BEW 21Aug15, Default the following flag to a TRUE value - just in case
	// collaboration mode may be in effect
	gpApp->m_bConflictResolutionTurnedOn = TRUE;
	gpApp->GetView()->RemoveSelection();
	CJoinDialog d(gpApp->GetMainFrame());
	d.ShowModal();
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		event	-> unused wxCommandEvent
/// \remarks
/// Called from: the Tools menu "Move Document..." command.
/// Invokes the CMoveDialog dialog.
/// Invokes the CSplitDialog dialog.
/// BEW 29Mar10, added RemoveSelection() call, because if the command is entered and acted
/// upon immediately after, say, a Find which gets the wanted location and shows it
/// selected, a later RemoveSelection() call will try remove m_selection data which by
/// then will contain only hanging CCell pointers - giving a crash
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnMoveDocument(wxCommandEvent& WXUNUSED(event))
{
	gpApp->GetView()->RemoveSelection();
	CMoveDialog d(gpApp->GetMainFrame());
	d.ShowModal(); // We don't care about the results of the dialog -
				   // it does all it's own work.
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a list of source phrases composing the document
/// \param		FilePath	-> the path + name of the file
/// \remarks
/// Called from: the App's LoadSourcePhraseListFromFile() and
/// CJoinDialog::OnBnClickedJoinNow().
/// In the wx version the current doc's m_pSourcePhrases list is not on the Doc, but on the
/// App. Since OnOpenDocument() always places the source phrases it retrieves from the
/// opened file into the m_pSourcePhrases list on the App, this function temporarily saves
/// those source phrases from the currently open Doc, in order to allow OnOpenDocument() to
/// save its new source phrases in m_pSourcePhrases on the App. Then, once we have the new
/// ones loaded we copy them to the list being returned, and repopulate m_pSourcePhrases
/// list with the original (open) document's source phrases.
/// I'm taking this approach rather than redesigning things at this point. Having all the
/// doc's members moved to the App was necessitated at the beginning of the wx version
/// conversion effort (because of the volatility of the doc's member pointers within the wx
/// doc-view framework). It would have been helpful to redesign some other routines
/// (OnOpenDocument and the XML doc parsing routines) to pass the list of source phrases
/// being built as a parameter rather than keeping it as a global list.
/// At any rate, here we need to juggle the source phrase pointer lists in order to
/// load a source phrase list from a document file.
///////////////////////////////////////////////////////////////////////////////
SPList* CAdapt_ItDoc::LoadSourcePhraseListFromFile(wxString FilePath)
{
	SPList* rv; // Return Value.

	CAdapt_ItDoc d; // needed to call non-static OnOpenDocument() below
	// wx version note: In the wx version the current doc's m_pSourcePhrases list
	// is not on the doc, but on the app. Since OnOpenDocument() always places the
	// source phrases it retrieves from the opened file into the m_pSourcePhrases
	// list on the App, we need to temporarily save those source phrases from the
	// currently open doc, in order to allow OnOpenDocument() to save its new
	// source phrases in m_pSourcePhrases on the App. Then, once we have the new ones
	// we can copy them to the list being returned, and repopulate m_pSourcePhrases
	// list with the original (open) document's source phrases.
	// I'm taking this approach rather than redesigning things at this point. Having
	// all the doc's members moved to the App was necessitated at the beginning of the
	// wx version conversion effort (because of the volatility of the doc's member
	// pointers within the wx doc-view framework). It would have been helpful to
	// redesign some other routines (OnOpenDocument and the XML doc parsing routines)
	// to pass the list of source phrases being built as a parameter rather than keeping
	// it as a global list.
	// At any rate, here we need to juggle the source phrase pointer lists in order to
	// load a source phrase list from a document file.

	rv = new SPList();
	rv->Clear();

	gpApp->m_bWantSourcePhrasesOnly = true;
	SPList* m_pSourcePhrasesSaveFromApp = new SPList(); // a temp list to save the
												// SPList of the currently open document
	// save the list of pointers from those on the app to a temp list
	// (the App's list to be restored later)
	for (SPList::Node* node = gpApp->m_pSourcePhrases->GetFirst();
		node; node = node->GetNext())
	{
		m_pSourcePhrasesSaveFromApp->Append((CSourcePhrase*)node->GetData());
	}
	// pointers are now saved in the temp SPList, so clear the list on the App to be ready
	// to receive the new list within OnOpenDocument()
	gpApp->m_pSourcePhrases->Clear();
	d.OnOpenDocument(FilePath, true); // OnOpenDocument loads source phrases into
								// m_pSourcePhrases on the App
	gpApp->m_bWantSourcePhrasesOnly = false;
	// copy the pointers to the list we are returning from LoadSourcePhraseListFromFile
	for (SPList::Node* node = gpApp->m_pSourcePhrases->GetFirst();
		node; node = node->GetNext())
	{
		rv->Append((CSourcePhrase*)node->GetData());
	}
	// now restore original App list
	gpApp->m_pSourcePhrases->Clear();
	for (SPList::Node* node = m_pSourcePhrasesSaveFromApp->GetFirst();
		node; node = node->GetNext())
	{
		gpApp->m_pSourcePhrases->Append((CSourcePhrase*)node->GetData());
	}
	// now clear and delete the temp save list
	m_pSourcePhrasesSaveFromApp->Clear();
	if (m_pSourcePhrasesSaveFromApp != NULL) // whm 11Jun12 added NULL test
		delete m_pSourcePhrasesSaveFromApp;
	m_pSourcePhrasesSaveFromApp = NULL;
	// lastly return the new list loaded from the file
	return rv;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress it disables the File Pack Document menu item and
/// returns immediately. It enables the menu item if there is a KB ready (even if only a
/// stub), and the document is loaded, and documents are to be saved as XML is turned on;
/// and glossing mode is turned off, otherwise the command is disabled.
/// BEW modified 13Nov09, when read-only access to project folder, don't allow pack doc
/// BEW 25Nov09, to allow pack doc but to use the m_bReadOnlyAccess flag to suppress
/// doing a project config file write and a doc save, but instead to just take the project
/// config file and doc files as they currently are on disk in order to do the pack
/// whm 12Feb12 revised to allow the Pack Document... command to be enabled when collaboration.
/// I think the "Pack Document..." menu item was mistakenly disabled when collaboration is
/// active. It should only be the "Unpack Document..." command that should be disabled when
/// when collaboration with Paratext/Bibledit is activated.
///////////////////////////////////////////////////////////////////////////////

void CAdapt_ItDoc::OnUpdateFilePackDoc(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_trialVersionNum >= 0)
	{
		event.Enable(FALSE);
		return;
	}

	// enable if there is a KB ready (even if only a stub), and the document loaded and
	// glossing mode is turned off
	if ((pApp->m_pLayout->GetStripArray()->GetCount() > 0) && pApp->m_bKBReady && !gbIsGlossing)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If Vertical Editing is in progress it disables the Unpack Document..." command on the File
/// menu, otherwise it enables the item as long as glossing mode is turned off.
/// BEW modified 13Nov09, if read-only access to project folder, don't permit unpack doc
/// whm added 7Jul11 Don't allow unpacking of documents when collaborating with an external
/// editor such as Paratext or Bibledit.
///////////////////////////////////////////////////////////////////////////////

void CAdapt_ItDoc::OnUpdateFileUnpackDoc(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_trialVersionNum >= 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// enable provided glossing mode is turned off; we want it to be able to work even if
	// there is no project folder created yet, nor even a KB and/or document; but right
	// from the very first launch
	if (!gbIsGlossing)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		event	-> unused wxCommandEvent
/// \remarks
/// Called from: the "Pack Document..." command on the File menu.
/// Packing creates a zipped (compressed *.aip file) containing sufficient information for
/// a remote Adapt It user to recreate the project folder, project settings, and unpack and
/// load the document on the remote computer. OnFilePackDoc collects six kinds of
/// information:
/// source language name; target language name; Bible book information; current output
/// filename for the document; the current project configuration file contents; the
/// document in xml format.
/// BEW 12Apr10, no changes needed for support of doc version 5
/// whm 4Feb11 modified to call a separate function DoPackDocument()
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnFilePackDoc(wxCommandEvent& WXUNUSED(event))
{
	// OnFilePackDoc(), for a unicode build, converts to UTF-8 internally, and so uses
	// CBString for the final output (config file and xml doc file are UTF-8 already).
	// DoPackDocument() assembles the raw data into the packByteStr byte buffer (CBString)
	gpApp->LogUserAction(_T("Initiated OnFilePackDoc()"));
	wxString exportPathUsed;
	exportPathUsed.Empty();
	DoPackDocument(exportPathUsed, TRUE); // TRUE = invoke the wxFileDialog
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		event	-> unused wxCommandEvent
/// \remarks
/// Called from: the "Unpack Document..." command on the File menu.
/// OnFileUnpackDoc gets the name of a packed *.aip file from the user, uncompresses it and
/// calls DoUnpackDocument() to do the remaining work of unpacking the document and loading
/// it into Adapt It ready to do work.
/// If a document of the same name already exists on the destination machine in
/// the same folder, the user is warned before the existing doc is overwritten by the document
/// extracted from the packed file.
/// The .aip files pack with the Unicode version of Adapt It cannot be unpacked with the regular
/// version of Adapt It, nor vice versa.
/// BEW 12Apr10, no changes needed for support of doc version 5
/// whm 14Jul11 revised for when navigation protection is ON for the _PACKED_INPUTS_OUTPUTS
/// folder.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnFileUnpackDoc(wxCommandEvent& WXUNUSED(event))
{
	// OnFileUnpackDoc is the handler for the Unpack Document... command on the File menu.
	// first, get the file and load it into a CBString
	wxString defaultDir;
	wxString packedDocPath;
	// BEW 21Aug15, Default the following flag to a TRUE value - just in case
	// collaboration mode may be in effect
	gpApp->m_bConflictResolutionTurnedOn = TRUE;

	// Check whether navigation protection is in effect for _PACKED_INPUTS_OUTPUTS,
	// and whether the App's m_lastPackedOutputPath is empty or has a valid path,
	// and set the defaultDir for the export accordingly.
	bool bBypassFileDialog_ProtectedNavigation = FALSE;
	if (gpApp->m_bProtectPackedInputsAndOutputsFolder)
	{
		bBypassFileDialog_ProtectedNavigation = TRUE;
		defaultDir = gpApp->m_packedInputsAndOutputsFolderPath;
	}
	else if (gpApp->m_lastPackedOutputPath.IsEmpty()
		|| (!gpApp->m_lastPackedOutputPath.IsEmpty() && !::wxDirExists(gpApp->m_lastPackedOutputPath)))
	{
		bBypassFileDialog_ProtectedNavigation = FALSE;
		defaultDir = gpApp->m_packedInputsAndOutputsFolderPath;
	}
	else
	{
		bBypassFileDialog_ProtectedNavigation = FALSE;
		defaultDir = gpApp->m_lastPackedOutputPath;
	}

	if (!bBypassFileDialog_ProtectedNavigation)
	{
		wxString message;
		message = _("Load And Unpack The Compressed Document");
		wxString filter;
		filter = _("Packed Documents (*.aip)|*.aip||");

		wxFileDialog fileDlg(
			(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
			message,
			defaultDir,
			_T(""), // file name is null string
			filter,
			wxFD_OPEN);
		// wxHIDE_READONLY was deprecated in 2.6 - the checkbox is never shown
		// GDLC wxOPEN weredeprecated in 2.8
		fileDlg.Centre();

		wxLogNull logNo; // avoid spurious messages from the system

		// open as modal dialog
		int returnValue = fileDlg.ShowModal();
		if (returnValue == wxID_CANCEL)
		{
			gpApp->LogUserAction(_T("Cancelled from OnFileUnpackDoc() at wxFileDialog()"));
			return; // user Cancelled, or closed the dialog box
		}

		packedDocPath = fileDlg.GetPath();
	}
	else
	{
		// Packed Doc folder is protected
		wxArrayString packedDocFilesIncludingPaths, packedDocFilesNamesOnly;
		// get an array list of .cct files
		packedDocPath = gpApp->m_packedInputsAndOutputsFolderPath;
		wxDir::GetAllFiles(packedDocPath, &packedDocFilesIncludingPaths, _T("*.aip"), wxDIR_FILES);
		int totFiles = (int)packedDocFilesIncludingPaths.GetCount();
		if (totFiles > 0)
		{
			int ct;
			for (ct = 0; ct < totFiles; ct++)
			{
				wxFileName fn(packedDocFilesIncludingPaths.Item(ct));
				wxString fNameOnly = fn.GetFullName();
				packedDocFilesNamesOnly.Add(fNameOnly);
			}
		}
		wxString message = _("Choose a Packed Document from the following list:\n(from the location: %s):");
		message = message.Format(message, packedDocPath.c_str());
		wxString myCaption = _T("");
		int returnValue = wxGetSingleChoiceIndex(message, myCaption,
			packedDocFilesNamesOnly, (wxWindow*)gpApp->GetMainFrame(), -1, -1, true, 250, 100);
		if (returnValue == -1)
		{
			gpApp->LogUserAction(_T("Cancelled from wxGetSingleChoiceIndex() in OnFileUnpackDoc()"));
			return; // user pressed Cancel or OK with nothing selected (list empty)
		}
		packedDocPath = packedDocPath + gpApp->PathSeparator + packedDocFilesNamesOnly.Item(returnValue); // this has just the file name
	}
	// whm Note: Since the "file" variable is created below and passed to
	// DoUnpackDocument and the DoUnpackDocument expects the file to already be
	// decompressed, we need decompress the file here before calling DoUnpackDocument.
	// We uncompress the packed file from the .aip compressed archive. It will have the
	// extension .aiz. We call DoUnpackDocument() on the .aiz file, then delete the
	// .aiz file which is of no usefulness after the unpacking and loading of the
	// document into Adapt It; we also would not want it hanging around for the user to
	// try to unpack it again which would fail because the routine would try to
	// uncompress an already uncompressed file and fail.

	// The wxWidgets version no longer needs the services of the separate freeware
	// unzip.h and unzip.cpp libraries.
	// whm 22Sep06 modified the following to use wxWidgets' own built-in zip filters
	// which act on i/o streams.
	// TODO: This could be simplified further by streaming the .aip file via
	// wxZipInputStream to a wxMemoryInputStream, rather than to an external
	// intermediate .aiz file, thus reducing complexity and the need to manipulate
	// (create, delete, rename) the external files.
	wxZipEntry* pEntry;
	// first we create a simple output stream using the zipped .aic file (pathName)
	wxFFileInputStream zippedfile(packedDocPath);
	// then we construct a zip stream on top of this one; the zip stream works as a
	// "filter" unzipping the stream from pathName
	wxZipInputStream zipStream(zippedfile);
	wxString unzipFileName;
	pEntry = zipStream.GetNextEntry(); // gets the one and only zip entry in the .aip file

	// whm 11May2020 added the following error message if pEntry is NULL
	if (pEntry == NULL)
	{
		wxString msg;
		msg = msg.Format(_(
			"Error uncompressing; Adapt It cannot read the information in the packed .aip file."));
		wxMessageBox(msg, _("Unable to unpack the packed document"), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(msg);
		return;
	}

	unzipFileName = pEntry->GetName(); // access the meta-data
	// construct the path to the .aiz file so that it goes temporarily in the project
	// folder this .aiz file is erased below after DoUnPackDocument is called on it
	packedDocPath = gpApp->m_workFolderPath + gpApp->PathSeparator + unzipFileName;
	// get a buffered output stream
	wxFFileOutputStream outFile(packedDocPath);
	// write out the filtered (unzipped) stream to the .aiz file
	outFile.Write(zipStream); // this form writes from zipStream to outFile until a
							  // stream "error" (i.e., end of file)
	if (pEntry != NULL) // whm 11Jun12 added NULL test
		delete pEntry; // example in wx book shows the zip entry data being deleted
	outFile.Close();

	// get a CFile and do the unpack
	wxFile file;
	// In the wx version we need to explicitly call Open on the file to proceed.
	if (!file.Open(packedDocPath, wxFile::read))
	{
		wxString msg;
		msg = msg.Format(_(
			"Error uncompressing; cannot open the file: %s\n Make sure the file is not being used by another application and try again."),
			packedDocPath.c_str());
		wxMessageBox(msg, _T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(msg);
		return;
	}
	if (!DoUnpackDocument(&file))//whm changed this to return bool for better error recovery
		return; // DoUnpackDocument issues its own error messages if it encounters an error

	// lastly remove the .aiz temporary file that was used to unpack from
	// leaving the compressed .aip in the work folder
	if (!wxRemoveFile(packedDocPath))
	{
		// if there was an error, we just get no unpack done, but app can continue; and
		// since we expect no error here, we will use an English message
		wxString strMessage;
		strMessage = strMessage.Format(_("Error removing %s after unpack document command."),
			packedDocPath.c_str());
		wxMessageBox(strMessage, _T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(strMessage);
		return;
	}
	// store the last packed doc's path in the App's m_lastPackedOutputPath member for storage in
	// the basic config file.
	wxFileName fn(packedDocPath);
	gpApp->m_lastPackedOutputPath = fn.GetPath();
	// Nothing else to report, the unpacked document will be displaying in the main window
	// when this returns.
	return;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the unpack operation was successful, FALSE otherwise
/// \param		pFile	-> pointer to the wxFile object being unpacked
/// \remarks
/// Called from: the Doc's OnFileUnpackDocument().
/// Does the main work of unpacking the uncompressed file received from OnFileUnpackDocument().
/// It creates the required folder structure (including project folder) or
/// makes that project current if it already exists on the destination machine, and then
/// updates its project configuration file, and stores the xml document file in whichever of
/// the Adaptations folder or one of its book folders if pack was done from a book folder,
/// and then reads in the xml document, parses it and sets up the document and view leaving
/// the user in the project and document ready to do work.
/// If a document of the same name already exists on the destination machine in
/// the same folder, the user is warned before the existing doc is overwritten by the document
/// extracted from the packed file.
/// The .aip files pack with the Unicode version of Adapt It cannot be unpacked with the regular
/// version of Adapt It, nor vice versa.
///////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItDoc::DoUnpackDocument(wxFile* pFile) // whm changed to return bool 22Jul06
{
	CAdapt_ItView* pView = gpApp->GetView();

	gpApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

	// get the file size
	int nFileSize = (int)pFile->Length();
	int nResult;

	// create a CBString with an empty buffer large enough for all this file
	CBString packByteStr;
	char* pBuff = packByteStr.GetBuffer(nFileSize + 1);

	// read in the file & close it
	int nReadBytes = pFile->Read(pBuff, nFileSize);
	if (nReadBytes < nFileSize)
	{
		wxMessageBox(_T(
			"Compressed document file read was short, some data missed so abort the command.\n"),
			_T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(_T("Compressed document file read was short, some data missed so abort the command."));
		return FALSE;
	}
	pFile->Close(); // assume no errors

	// get the length (private member) set correctly for the CBString
	packByteStr.ReleaseBuffer();

	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	// whm Note 19Jan06:
	// If the design included the addition of a warning string embedded in the compressed
	// file, and/or we wished to uncompress the data within an internal buffer, the
	// following considerations would need to be taken into account:
	// 1. Remove the Warning statement (see OnFilePackDoc) from the packByteStr which
	//    consists of the first 192 bytes of the file.
	// 2. The zlib inflate (decompression) call must be made at this point if executed on
	//    the compressed part of packByteStr expanding and uncompressing the data to a
	//    larger work buffer (CBString???), and the buffer receiving the uncompressed data
	//    needs to be used instead of the packByteStr one used below.
	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	// Start extracting info. First we want to know whether Adapt It or Adapt It Unicode
	// did the packing? If our unpacking app is not same one, warn the user and disallow
	// the unpacking (The first byte will be an ascii 1 or 2, 1 for regular app did the
	// pack, 2 if unicode app did it)
	int offset = 0;
	char chDigit[2] = { '\0','\0' };

	// if the user has used winzip to unpack the packed doc file, maybe edited it, then
	// used Winzip to zip it and then changed the extension to .aip, Winzip (possibly only
	// if it detects UTF-8 data in the file, but I'm not sure of this) adds 3 bytes to the
	// start of the file - an i followed by a double right wedge character followed by an
	// upside down question mark character (as unsigned chars these have values of 239,
	// 187, and 191, respectively). This is all that prevents Adapt It from being able to
	// correctly unpack such a document - so to make it able to do so, instead of assuming
	// that the first character is a digit, we will scan till we find the first digit
	// (which will be 1 or 2) and then proceed with our unpack.
	unsigned char aOne = 49; // ASCII for digit 1 (isdigit() depends on locale, so
							 // is unsafe to use here)
	unsigned char aTwo = 50; // ASCII for 2
	unsigned char charAtOffset = pBuff[offset];
	int limit = 7; // look at no more than first 6 bytes
	int soFar = 1;
	bool bFoundOneOrTwo = FALSE;
	while (soFar <= limit)
	{
		if (charAtOffset == aOne || charAtOffset == aTwo)
		{
			// we've successfully scanned past Winzip's inserted material
			offset = soFar - 1;
			bFoundOneOrTwo = TRUE;
			break;
		}
		else
		{
			// didn't find a 1 or 2, so try next byte
			soFar++;
			charAtOffset = pBuff[soFar - 1];
		}
	}
	if (!bFoundOneOrTwo)
	{
		// IDS_UNPACK_INVALID_PREDATA
		wxMessageBox(_T(
			"Unpack failure. The uncompressed data has more than six unknown bytes preceding the digit 1 or 2, making interpretation impossible. Command aborted."),
			_T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(_T("Unpack failure. The uncompressed data has more than six unknown bytes preceding the digit 1 or 2, making interpretation impossible. Command aborted."));
		return FALSE;
	}

	// we found a digit either at the start or no further than 7th byte from start, so
	// assume all is well formed and proceed from the offset value
	chDigit[0] = packByteStr[offset];
	offset += 6;
	packByteStr = packByteStr.Mid(offset); // remove extracted app type code
										   // char & its |*0*| delimiter

	// whm Note: The legacy logic doesn't work cross-platform! The sizeof(char) and
	// sizeof(w_char) is not constant across platforms. On Windows sizeof(char) is 1 and
	// sizeof(w_char) is 2; but on all Unix-based systems (i.e., Linux and Mac OS X) the
	// sizeof(char) is 2 and sizeof(w_char) is 4. We can continue to use '1' to indicate
	// the file was packed by an ANSI version, and '2' to indicate the file was packed by
	// the Unicode app. However, the numbers cannot signify the size of char and w_char
	// across platforms. They can only be used as pure signals for ANSI or Unicode contents
	// of the packed file. Here in DoUnpackDocument we have to treat the string _T("1") as
	// an error if we're unpacking from within a Unicode app, or the string _T("2") as an
	// error if we're unpacking from an ANSI app.
	// In OnFilePackDoc() we simply pack the file using "1" if we are packing it from an
	// ANSI app; and we pack the file using "2" when we're packing it from a Unicode app,
	// regardless of the result returned by the sizeof operator on wxChar.
	//
	int nDigit = atoi(chDigit);
	// are we in the same app type?
#ifdef _UNICODE
	// we're a Unicode app and the packed file is ANSI, issue error and abort
	if (nDigit == 1)
#else
	// we're an ASNI app and the packed file is Unicode, issue error and abort
	if (nDigit == 2)
#endif
	{
		// mismatched application types. Doc data won't be rendered right unless all text was
		// ASCII
		CUnpackWarningDlg dlg(gpApp->GetMainFrame());
		if (dlg.ShowModal() == wxID_OK)
		{
			// the only option is to halt the unpacking (there is only the one button);
			// because unicode app's config file format for punctuation is not compatible
			// with the regular app's config file (either type), and so while the doc would
			// render okay if ascii, the fact that the encapsulated config files are
			// incompatible makes it not worth allowing the user to continue
			gpApp->LogUserAction(_T("Config files incompatible in DoUnpackDocument()"));
			return FALSE;
		}
	}

	// close the document and project currently open, clear out the book mode information
	// to defaults and the mode off, store and then erase the KBs, ready for the new
	// project and document being unpacked
	pView->CloseProject();

	// extract the rest of the information needed for setting up the document
	offset = packByteStr.Find("|*1*|");
	CBString srcName = packByteStr.Left(offset);
	offset += 5;
	packByteStr = packByteStr.Mid(offset); // remove the extracted source
										   // language name & delimiter
	offset = packByteStr.Find("|*2*|");
	CBString tgtName = packByteStr.Left(offset);
	offset += 5;
	packByteStr = packByteStr.Mid(offset); // remove the extracted target
										   // language name & delimiter
	offset = packByteStr.Find("|*3*|");
	CBString bookInfo = packByteStr.Left(offset);
	offset += 5;
	packByteStr = packByteStr.Mid(offset); // remove the extracted book
										   // information & delimiter

	// offset now points at the start of the UTF-8 current output filename; if the packing
	// was done in the Unicode application, this will have to be converted back to UTF-16
	// further down before we make use of it

	// The book information has colon delimited subfields. Even in the unicode application
	// we can reliably compute from the char string without having to convert to UTF-16, so
	// do it now.
	int nFound = bookInfo.Find(':');
	wxASSERT(nFound);
	CBString theBool = bookInfo.Left(nFound);
	if (theBool == "1")
	{
		gpApp->m_bBookMode = TRUE;
	}
	else
	{
		gpApp->m_bBookMode = FALSE;
	}
	nFound++;
	bookInfo = bookInfo.Mid(nFound);
	nFound = bookInfo.Find(':');
	theBool = bookInfo.Left(nFound);
	if (theBool == "1")
	{
		gpApp->m_bDisableBookMode = TRUE;
	}
	else
	{
		gpApp->m_bDisableBookMode = FALSE;
	}
	nFound++;
	CBString theIndex = bookInfo.Mid(nFound);
	gpApp->m_nBookIndex = atoi(theIndex.GetBuffer()); // no ReleaseBuffer call
			// is needed the later SetupDirectories() call will create the book folders
			// if necessary, and set up the current book folder and its path from the
			// m_nBookIndex value

	// extract the UTF-8 form of the current output filename
	offset = packByteStr.Find("|*4*|");
	CBString utf8Filename = packByteStr.Left(offset);
	offset += 5;
	packByteStr = packByteStr.Mid(offset); // remove the extracted utf-8 filename
			// & delimiter (what remains is the project config file & document file)

	// we could be in the Unicode application, so we here might have to convert our srcName
	// and tgtName CBStrings into (Unicode) CStrings; we'll delay setting
	// m_curOutputFilename (using storeFilenameStr) to later on, to minimize the potential
	// for unwanted erasure.
#ifdef _UNICODE
	wxString sourceName;
	wxString targetName;
	wxString storeFilenameStr;
	gpApp->Convert8to16(srcName, sourceName);
	gpApp->Convert8to16(tgtName, targetName);
	gpApp->Convert8to16(utf8Filename, storeFilenameStr);
#else
	wxString sourceName = srcName.GetBuffer();
	wxString targetName = tgtName.GetBuffer();
	//wxString storeFilenameStr(utf8Filename);
	wxString storeFilenameStr = wxString::FromUTF8(utf8Filename); // whm modified 2Nov13 for ANSI builds
#endif

	// we now can set up the directory structures, if they are not already setup
	gpApp->m_sourceName = sourceName;
	gpApp->m_targetName = targetName;
	gpApp->m_bUnpacking = TRUE; // may be needed in SetupDirectories()
								// if destination machine has same project folder
	bool bSetupOK = gpApp->SetupDirectories(); // also sets KB paths and loads KBs & Guesser
	if (!bSetupOK)
	{
		gpApp->m_bUnpacking = FALSE;
		wxMessageBox(_T(
			"SetupDirectories returned false for Unpack Document.... The command will be ignored.\n"),
			_T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(_T("SetupDirectories returned false for Unpack Document.... The command will be ignored."));
		return FALSE;
	}
	gpApp->m_bUnpacking = FALSE;

	// check for the same document already in the project folder - if it's there, then ask
	// the user whether or not to have the being-unpacked-one overwrite it
	wxFile f;

	// save various current paths so they can be restored if the user bails out because of
	// a choice not to overwrite an existing document with the one being unpacked
	wxString saveMFCfilename = GetFilename(); // m_strPathName is internal to MFC's doc-view
	wxString saveBibleBooksFolderPath = gpApp->m_bibleBooksFolderPath;
	wxString saveCurOutputFilename = gpApp->m_curOutputFilename;
	wxString saveCurAdaptionsPath = gpApp->m_curAdaptationsPath;
	wxString saveCurOutputPath = gpApp->m_curOutputPath;

	// set up the paths consistent with the unpacked info
	gpApp->m_curOutputFilename = storeFilenameStr;
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
	{
		// m_strPathName is a member of MFC's Document class
		SetFilename(gpApp->m_bibleBooksFolderPath + gpApp->PathSeparator +
			gpApp->m_curOutputFilename, TRUE);
		gpApp->m_curOutputPath = gpApp->m_bibleBooksFolderPath + gpApp->PathSeparator +
			gpApp->m_curOutputFilename;
	}
	else
	{
		SetFilename(gpApp->m_curAdaptationsPath + gpApp->PathSeparator +
			gpApp->m_curOutputFilename, TRUE);
		gpApp->m_curOutputPath = gpApp->m_curAdaptationsPath + gpApp->PathSeparator +
			gpApp->m_curOutputFilename;
	}

	// if the document does not exist in the unpacking computer yet, then an attempt to get
	// its status struct will return FALSE - we need to check both possible paths
	bool bAskUser = FALSE;
	bool bItsXML = TRUE;
	if (::wxFileExists(gpApp->m_curOutputPath)) //if (f.GetStatus(m_curOutputPath,status))
	{
		// the xml document file is in the folder, so the user must be asked
		// whether to overwrite or not
		bAskUser = TRUE;
	}

	wxString s1, s2, s3, msg;
	wxFileName fn(gpApp->m_curOutputPath);
	if (bAskUser)
	{
		//IDS_UNPACK_ASK_OVERWRITE
		s1 = _(
			"There is a document of the same name in an Adapt It project of the same name on this computer.");
		s2 = s2.Format(_("\n      Document name: %s"), fn.GetFullName().c_str());
		s3 = s3.Format(_("\n      Project path : %s"), fn.GetPath().c_str());
		msg = msg.Format(_(
			"%s%s%s\nDo you want the document being unpacked to overwrite the one already on this computer?"),
			s1.c_str(), s2.c_str(), s3.c_str());
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		nResult = wxMessageBox(msg, _T(""), wxICON_QUESTION | wxYES_NO);
		if (nResult == wxYES)
		{
			// user wants the current file overwritten...
			// we have a valid status struct for it, so use it to just remove it here;
			// doing it this way we can be sure we get rid of it; we can't rely on the
			// CFile::modeCreate style bit causing the file to be emptied first because the
			// being-unpacked doc will be xml but the existing doc file on the destination
			// machine might be binary (ie. have .adt extension)
			if (bItsXML)
			{
				if (!wxRemoveFile(gpApp->m_curOutputPath))
				{
					wxString thismsg;
					thismsg = thismsg.Format(_(
						"Failed removing %s before overwrite."),
						gpApp->m_curOutputPath.c_str());
					wxMessageBox(thismsg, _T(""), wxICON_EXCLAMATION | wxOK);
					gpApp->LogUserAction(thismsg);
					goto a; // restore paths & exit, allow app to continue
				}
			}
		}
		else
		{
			// abort the unpack - this means we should restore all the saved path strings
			// before we return
		a:			SetFilename(saveMFCfilename, TRUE); //m_strPathName = saveMFCfilename;
			gpApp->m_bibleBooksFolderPath = saveBibleBooksFolderPath;
			gpApp->m_curOutputFilename = saveCurOutputFilename;
			gpApp->m_curAdaptationsPath = saveCurAdaptionsPath;
			gpApp->m_curOutputPath = saveCurOutputPath;

			// restore the earlier document to the main window, if we have a valid path to
			// it
			wxString path = gpApp->m_curOutputPath;
			path = MakeReverse(path);
			int nFound1 = path.Find(_T("lmx."));
			if (nFound1 == 0)
			{
				// m_curOutputPath is a valid path to a doc in a project's Adaptations or
				// book folder so open it again - the project is still in effect
				bool bGotItOK = OnOpenDocument(gpApp->m_curOutputPath, true);
				if (!bGotItOK)
				{
					// some kind of error -- don't warn except for a beep, just leave the
					// window blank (the user can instead use wizard to get a doc open)
					::wxBell();
				}
				//BEW 28Sep12, since we don't call ReleaseKBServer() in a pack document,
				//the project's kbserver-related variables should be intact, and so there
				//should be no need here to call SetupForKBServer()
			}
			return FALSE;
		}
	}

	// if we get to here, then it's all systems go for updating the configuration file and
	// loading in the unpacked document and displaying it in the main window

	// next we must extract the embedded project configuration file
	offset = packByteStr.Find("|*5*|");
	CBString projConfigFileStr = packByteStr.Left(offset);
	offset += 5;
	packByteStr = packByteStr.Mid(offset); // remove the extracted configuration file
					// information & delimiter & the remainder now in packByteStr is the
					// xml document file

	// construct the path to the project's configuration file so it can be saved to the
	// project folder
	wxString projectPath = gpApp->m_curProjectPath;
	projectPath += gpApp->PathSeparator;
	projectPath += szProjectConfiguration;
	projectPath += _T(".aic");

	// temporarily rename any project file of this name already in the project folder - if
	// the new one fails to be written out, we must restore this renamed one before we
	// return to the caller, but if the new one is written out we must then delete this
	// renamed one
	wxString renamedPath;
	renamedPath.Empty();
	bool bRenamedConfigFile = FALSE;
	if (::wxFileExists(projectPath))
	{
		// do the renaming
		renamedPath = projectPath;
		int len = projectPath.Length();
		renamedPath.Remove(len - 3, 3); // delete the aic extension
		renamedPath += _T("BAK"); // make it a 'backup' type temporarily in case user
								  // ever sees it in Win Explorer
		if (!::wxRenameFile(projectPath, renamedPath))
		{
			wxString message;
			message = message.Format(_(
				"Error renaming earlier configuration file with path %s."),
				projectPath.c_str());
			message += _("  Aborting the command.");
			wxMessageBox(message, _T(""), wxICON_INFORMATION | wxOK);
			gpApp->LogUserAction(message);
			goto a;
		}
		bRenamedConfigFile = TRUE;
	}

	// get the length of the project configuration file's contents (exclude the null byte)
	int nFileLength = projConfigFileStr.GetLength();

	// write out the byte string (use CFile to avoid CStdioFile's mucking around with \n
	// and \r) because a config file written by CStdioFile's WriteString() won't be read
	// properly subsequently
	wxFile ff;
	if (!ff.Open(projectPath, wxFile::write))
	{
		wxString msg;
		msg = msg.Format(_(
			"Unable to open the file for writing out the UTF-8 project configuration file, with path:\n%s"),
			projectPath.c_str());
		gpApp->LogUserAction(msg);
		wxMessageBox(msg, _T(""), wxICON_EXCLAMATION | wxOK);

		// if we renamed the earlier config file, we must restore its name before returning
		if (bRenamedConfigFile)
		{
			if (::wxFileExists(renamedPath))
			{
				// there is a renamed project config file to be restored; paths calculated
				// above are still valid, so just reverse their order in the parameter
				// block
				if (!::wxRenameFile(renamedPath, projectPath))
				{
					wxString message;
					message = message.Format(_(
						"Error restoring name of earlier configuration file with path %s."),
						renamedPath.c_str());
					message += _(
						"  Exit Adapt It and manually change .BAK to .aic for the project configuration file.");
					wxMessageBox(message, _T(""), wxICON_INFORMATION | wxOK);
					gpApp->LogUserAction(message);
					goto a;
				}
			}
		}
		goto a;
	}

	// output the configuration file's content string
	char* pBuf = projConfigFileStr.GetBuffer(); // whm moved here from outer block above
	if (!ff.Write(pBuf, nFileLength))
	{
		// notify user, and then return without doing any more
		wxString thismsg;
		thismsg = _("Writing out the project configuration file's content failed.");
		wxString someMore;
		someMore = _(
			" Exit Adapt It, and in Windows Explorer manually restore the .BAK extension on the renamed project configuration file to .aic before launching again. Beware, that configuration file may now be corrupted.");
		thismsg += someMore;
		wxMessageBox(thismsg);
		ff.Close();
		gpApp->LogUserAction(thismsg);
		goto a;
	}
	projConfigFileStr.ReleaseBuffer(); // whm added 19Jun06

	// if control got here, we must remove the earlier (now renamed) project configuration
	// file, provided that we actually did find one with the same name earlier and renamed
	// it
	if (bRenamedConfigFile)
	{
		if (!wxRemoveFile(renamedPath))
		{
			wxString thismsg;
			thismsg = _(
				"Removing the renamed earlier project configuration file failed. Do it manually later in Windows Explorer - it has a .BAK extension.");
			wxMessageBox(thismsg, _T(""), wxICON_EXCLAMATION | wxOK);
			gpApp->LogUserAction(thismsg);
			goto a;
		}
	}

	// close the file
	ff.Close();

	// empty the buffer contents which are no longer needed
	projConfigFileStr.Empty();

	// we now need to parse in the configuration file, so the source user's settings are
	// put into effect; and we reset the KB paths. The KBs have already been loaded, or
	// stubs created, so the SetupKBPathsEtc call here just has the effect of getting paths
	// set up for the xml form of KB i/o.
	gpApp->GetProjectConfiguration(gpApp->m_curProjectPath); // has flag side effect as
															// noted in comments above
	// BEW 28Sep12, if this project is a KB sharing one, then the project configuration
	// read should have set m_bIsKBServerProject to TRUE, and/or possibly
	// m_bIsGlossingKBServerProject as well; so once we have the KB's loaded,
	// we can call SetupForKBServer( as required below.

	gpApp->SetupKBPathsEtc();

	// now we can save the xml document file to the destination folder (either Adaptations
	// or a book folder), then parse it in and display the document in the main window....
	// write out the xml document file to the folder it belongs in and with the same
	// filename as on the source machine (path is given by m_curOutputPath above)
	nFileLength = packByteStr.GetLength();
	if (!ff.Open(gpApp->m_curOutputPath, wxFile::write))
	{
		wxString msg;
		msg = msg.Format(_(
			"Unable to open the xml text file for writing to doc folder, with path:\n%s"),
			gpApp->m_curOutputPath.c_str());
		wxMessageBox(msg, _T(""), wxICON_EXCLAMATION | wxOK);
		gpApp->LogUserAction(msg);
		return FALSE; // don't goto a; instead leave the new paths intact because the
				// config file is already written out, so the user can do something in the
				// project if he wants
	}
	pBuf = packByteStr.GetBuffer(); // whm moved here from outer block above (local scope)
	if (!ff.Write(pBuf, nFileLength))
	{
		// notify user, and then return without doing any more
		wxString thismsg;
		thismsg = _("Writing out the xml document file's content failed.");
		wxMessageBox(thismsg, _T(""), wxICON_EXCLAMATION | wxOK);
		ff.Close();
		gpApp->LogUserAction(thismsg);
		return FALSE;
	}
	packByteStr.ReleaseBuffer(); // whm added 19Jun06
	ff.Close();

	// empty the buffer contents which are no longer needed
	packByteStr.Empty();

	// now parse in the xml document file, setting up the view etc
	bool bGotItOK = OnOpenDocument(gpApp->m_curOutputPath, true);
	if (!bGotItOK)
	{
		// some kind of error --warn user (this shouldn't happen)
		wxString thismsg;
		thismsg = _(
			"Opening the xml document file for Unpack Document... failed. (It was stored successfully on disk. Try opening it with the Open command on the File menu.)");
		wxMessageBox(thismsg, _T(""), wxICON_EXCLAMATION | wxOK);
		// just proceed, there is nothing smart that can be done. Visual inspection of the
		// xml document file is possible in Windows Explorer if the user wants to check out
		// what is in it. A normal Open command can also be tried too.
		gpApp->LogUserAction(thismsg);
	}

	//#if defined(_KBSERVER)
		// It isn't a foregone conclusion that because the sender was sharing one or both kbs,
		// that the one who receives and unpacks the document will also want to share. He may
		// only want to inspect what was sent. So check if the sender had sharing on, and
		// give a suitable message to inform the user which kbs the sender was sharing and
		// invite him to do the same if the wants to share any editing changes he makes
	bool bForeignAdaptingSharing = FALSE;
	bool bForeignGlossingSharing = FALSE;
	if (bGotItOK && gpApp->m_bIsKBServerProject)
	{
		bForeignAdaptingSharing = TRUE;
	}
	if (bGotItOK && gpApp->m_bIsGlossingKBServerProject)
	{
		bForeignGlossingSharing = TRUE;
	}
	if (bForeignAdaptingSharing || bForeignGlossingSharing)
	{
		wxString title = _("A message about knowledge base sharing");
		wxString msg;
		if (bForeignAdaptingSharing && !bForeignGlossingSharing)
		{
			msg = _("The person who packed the document was sharing the adaptations knowledge base to a server with this URL: %s.\nIf you intent to make editing changes in the unpacked document which should be shared, you may wish to do the same.");
			msg = msg.Format(msg, gpApp->m_strKbServerIpAddr.c_str());
			wxMessageBox(msg, title, wxICON_INFORMATION | wxOK);
		}
		else if (!bForeignAdaptingSharing && bForeignGlossingSharing)
		{
			msg = _("The person who packed the document was sharing the glossing knowledge base to a server with this URL: %s.\nIf you intent to make editing changes in the unpacked document which should be shared, you may wish to do the same.");
			msg = msg.Format(msg, gpApp->m_strKbServerIpAddr.c_str());
			wxMessageBox(msg, title, wxICON_INFORMATION | wxOK);
		}
		else
		{
			// must have been sharing both kb types
			msg = _("The person who packed the document was sharing both the adapting and the glossing knowledge bases to a server with this URL: %s.\nIf you intent to make editing changes in the unpacked document which should be shared, you may wish to do the same.");
			msg = msg.Format(msg, gpApp->m_strKbServerIpAddr.c_str());
			wxMessageBox(msg, title, wxICON_INFORMATION | wxOK);
		}
	}
	//#endif

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString representing the path of the current working directory/folder
/// \remarks
/// Called from: the App's OnFileRestoreKb(), WriteConfigurationFile(),
/// AccessOtherAdaptionProject(), the View's OnRetransReport() and CMainFrame's
/// SyncScrollReceive().
/// Gets the path of the current working directory/folder as a wxString.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItDoc::GetCurrentDirectory()
{
	// In wxWidgets it is simply:
	return ::wxGetCwd();
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If Vertical Editing is in progress it disables "Receive Synchronized Scrolling Messages" item
/// on the Advanced menu and this handler returns immediately. Otherwise, it enables the
/// "Receive Synchronized Scrolling Messages" item on the Advanced menu as long as a project
/// is open.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnUpdateAdvancedReceiveSynchronizedScrollingMessages(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	// whm added 5Sep11 disable receiving of sync scroll messages during PT/BE collaboration
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// the feature can be enabled only if we are in a project
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
#ifndef __WXMSW__
	event.Enable(FALSE); // sync scrolling not yet implemented on Linux and the Mac
#endif
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		event	-> unused wxCommandEvent
/// \remarks
/// Called from: the Advanced menu's "Receive Synchronized Scrolling Messages" selection.
/// is open. Toggles the menu item's check mark on and off.
/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnAdvancedReceiveSynchronizedScrollingMessages(wxCommandEvent& event)
{
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem* pAdvancedMenuReceiveSSMsgs =
		pMenuBar->FindItem(ID_ADVANCED_RECEIVESYNCHRONIZEDSCROLLINGMESSAGES);

	// whm Note: Only log the action when the even comes from the menu item,
	// not when OnAdvancedReceiveSynchronizedScrollingMessages() is called
	// from the View's OnInitialUpdate() and elsewhere.
	if (event.GetId() == ID_ADVANCED_RECEIVESYNCHRONIZEDSCROLLINGMESSAGES)
	{
		if (!gbIgnoreScriptureReference_Receive)
			gpApp->LogUserAction(_T("Receive Synchronized Scrolling Messages OFF"));
		else
			gpApp->LogUserAction(_T("Receive Synchronized Scrolling Messages ON"));
	}

	// toggle the setting
	if (!gbIgnoreScriptureReference_Receive)
	{
		// toggle the checkmark to OFF
		if (pAdvancedMenuReceiveSSMsgs != NULL)
		{
			pAdvancedMenuReceiveSSMsgs->Check(FALSE);
		}
		gbIgnoreScriptureReference_Receive = TRUE;
	}
	else
	{
		// toggle the checkmark to ON
		if (pAdvancedMenuReceiveSSMsgs != NULL)
		{
			pAdvancedMenuReceiveSSMsgs->Check(TRUE);
		}
		gbIgnoreScriptureReference_Receive = FALSE;
	}
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Enables the "Send Synchronized Scrolling Messages" item on the Advanced menu if a project
/// is open.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnUpdateAdvancedSendSynchronizedScrollingMessages(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	// whm Note: 5Sep11 the sending of sync scroll messages during PT/BE collaboration should
	// be OK
	// the feature can be enabled only if we are in a project
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
#ifndef __WXMSW__
	event.Enable(FALSE); // sync scrolling not yet implemented on Linux and the Mac
#endif
}

///////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param		event	-> unused wxCommandEvent
/// \remarks
/// Called from: the Advanced menu's "Send Synchronized Scrolling Messages" selection.
/// is open. Toggles the menu item's check mark on and off.
/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnAdvancedSendSynchronizedScrollingMessages(wxCommandEvent& event)
{
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem* pAdvancedMenuSendSSMsgs =
		pMenuBar->FindItem(ID_ADVANCED_SENDSYNCHRONIZEDSCROLLINGMESSAGES);

	// whm Note: Only log the user action when OnAdvancedSendSynchronizedScrollingMessages()
	// is called by explicit menu action, not when it is called from other functions.
	if (event.GetId() == ID_ADVANCED_SENDSYNCHRONIZEDSCROLLINGMESSAGES)
	{
		if (!gpApp->m_bIgnoreScriptureReference_Send)
			gpApp->LogUserAction(_T("Send Synchronized Scrolling Messages OFF"));
		else
			gpApp->LogUserAction(_T("Send Synchronized Scrolling Messages ON"));
	}

	// toggle the setting
	if (!gpApp->m_bIgnoreScriptureReference_Send)
	{
		// toggle the checkmark to OFF
		if (pAdvancedMenuSendSSMsgs != NULL)
		{
			pAdvancedMenuSendSSMsgs->Check(FALSE);
		}
		gpApp->m_bIgnoreScriptureReference_Send = TRUE;
	}
	else
	{
		// toggle the checkmark to ON
		if (pAdvancedMenuSendSSMsgs != NULL)
		{
			pAdvancedMenuSendSSMsgs->Check(TRUE);
		}
		gpApp->m_bIgnoreScriptureReference_Send = FALSE;
	}
}

// Call this after some operation which, in order to be able to do it, forces the current
// doc to be saved and closed, and we want to reconstitute it afterwards - such as a
// Restore of the KB, or Retranslation report -- in Collaboration mode it is important to
// be able to do this, because the prior forced closure bypasses OnFileSave() and so no
// data is sent to the external editor, so we want a function which gets us back to where
// we were and leaves collaboration-related app members untouched.
// Returns TRUE if all was well (which it should always be, since we had it open just a
// little while before), FALSE if some internal call failed
// BEW created 24Aug11
// Used in OnFileRestoreKb(), and in OnRetranslationReport() as well

bool CAdapt_ItDoc::ReOpenDocument(
	CAdapt_ItApp* pApp,
	wxString savedWorkFolderPath,			// for setting current working directory
	wxString curOutputPath,					// includes filename
	wxString curOutputFilename,				// to help get window Title remade
	bool	 savedBookmodeFlag,				// for ensuring correct mode
	bool	 savedDisableBookmodeFlag,		// ditto
	BookNamePair* pSavedCurBookNamePair,  // for repointing at the correct struct
	int		 savedBookIndex,				// for recovering the correct folder's index
	bool	 bMarkAsDirty					// might want it instantly saveable
)
{
	wxASSERT(pApp->m_pSourcePhrases->GetCount() == 0);

	pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

	bool bOK = TRUE;
	pApp->m_acceptedFilesList.Clear();
	pApp->LogUserAction(_T("Initiated ReOpenDocument()"));

	// whm 25Aug11 Note: We do not need a wait dialog to pop up here
	// in ReOpenDocument(), since there is already a wxProgressDialog
	// showing from the caller of ReOpenDocument(). Also the
	// OnOpenDocument() call below has its own wxProgressDialog which
	// superimposes itself over the caller's progress dialog showing
	// the opening process - and when the progress dialog from
	// OnOpenDocument closes, it leaves the dialog in the caller to
	// finish its display of progress.

	// restore book mode parameters as at the time when doc was forced to close
	pApp->m_bBookMode = savedBookmodeFlag;
	pApp->m_bDisableBookMode = savedDisableBookmodeFlag;
	pApp->m_curOutputFilename = curOutputFilename;
	pApp->m_pCurrBookNamePair = pSavedCurBookNamePair;
	pApp->m_nBookIndex = savedBookIndex;

	bOK = OnOpenDocument(curOutputPath, false);
	SetFilename(curOutputPath, TRUE); // get the window Title set

	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		Get_collaboration_text_for_consistency_check(pApp);       // mrh May19 - If collaborating, we must store the pre-edit text from PT/BE
	}

	// we need a totally new layout, we can't assume piles or strips are valid
	CLayout* pLayout = pApp->GetLayout();
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#else
	pLayout->RecalcLayout(pPhrases, create_strips_and_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);
	CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
	if (gbIsGlossing)
		pApp->m_targetPhrase = pSrcPhrase->m_gloss;
	else
		// this is what got saved, so put it back there
		pApp->m_targetPhrase = pSrcPhrase->m_adaption;

	pApp->GetView()->Invalidate(); // get the layout drawn
	// get the phrase box shown
	pLayout->m_docEditOperationType = default_op; // sets (-1,-1) as box selection (all its text)
	pLayout->PlaceBox();

	// BEW added 4Sep15 restore the "Save To Knowledge Base" checkbox to enabled, similarly the
	// checkbox next to it "Force Choice For This Item". These were not re-enabled when user
	// chose an earlier snapshot to be the current document
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxPanel* pPanel = pFrame->m_pControlBar;
	// ensure the Save To Knowledge Base checkbox is enabled
	pApp->m_bSaveToKB = TRUE;
	wxCheckBox* pKBSave = (wxCheckBox*)pFrame->FindWindowById(IDC_CHECK_KB_SAVE);
	// whm modified 12Oct10 for user profiles compatibility
	if (pKBSave != NULL)
	{
		pKBSave->Enable(TRUE);
	}
	// ensure the Force Choice For This Item checkbox is enabled
	wxCheckBox* pForceChoice = (wxCheckBox*)pFrame->FindWindowById(IDC_CHECK_FORCE_ASK);
	// whm modified 12Oct10 for user profiles compatibility
	pApp->m_bForceAsk = TRUE;
	if (pForceChoice != NULL)
	{
		pForceChoice->Enable(TRUE);
	}
	pPanel->Refresh();
	// end of BEW 4Sep15 addition

	// set the doc dirty or clean
	Modify(bMarkAsDirty);
	return bOK;
}


// whm Modified 9Feb2004, to enable consistency checking of currently open document or,
// alternatively, select multiple documents from the project to check for consistency. If a
// document is open when call is made to this routine, the consistency check is completed
// and the user can continue working from the same position in the open document.
// BEW 12Apr10, no changes for support of doc version 5
// BEW 7July10, no changes for support of kbVersion 2 (but there may be changes needed in
// the DoConsistencyCheck() function which is called from several places here)
// BEW modified 26Aug11, simplify the logic of the initial choice, make closing current
// doc unnecessary (we close and auto-reopen when done), but cover 3 of the 4 legacy choices
// (ie. a: current doc only, b: all docs in Adaptations folders, c: all docs in all Bible
// books folders. Not covered? All docs in current book folder. This will be a subset of
// the response from c: instead) Also removed legacy DoConsistencyCheck(), and added an int
// nCumulativeTotal 4th param to the signature of its overloaded version, which now is the
// only version; and restored a stats dialog for when all is done
void CAdapt_ItDoc::OnEditConsistencyCheck(wxCommandEvent& WXUNUSED(event))
{
	// the 'accepted' list holds the document filenames to be used
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	// whm added 15Mar12 for read-only mode
	if (pApp->m_bReadOnlyAccess)
	{
		::wxBell();
		return;
	}

	pApp->GetView()->RemoveSelection(); // BEW 6Jun13 removed it from Layout::PlaceBox()where
			// calling it is too late (it's after a layout change, leading to a crash), to be
			// here instead
	pApp->LogUserAction(_T("Initiated OnEditConsistencyCheck()"));
	pApp->m_acceptedFilesList.Clear();
	bUserCancelled = FALSE;			// this is a global boolean
	wxArrayString arrSetNotInKB;	// list of src words and phrases for being
				// made <Not In KB> in KB
	wxArrayString arrRemoveNotInKB; // list of src words and phrases for
				// restoring normal saving after being <Not In KB> in KB

	// "grand total" progress bar indicator for the consistency check
	CStatusBar* pStatusBar = NULL;
	pStatusBar = (CStatusBar*)gpApp->GetMainFrame()->m_pStatusBar;
	pStatusBar->StartProgress(_("Performing Consistency Check"), _("Performing Consistency Check"), 4);

	/*
	// test dialogs
	{
	CSourcePhrase* pSP = pApp->m_pActivePile->GetSrcPhrase();
	CCell* pCell = LayoutDocForConsistencyCheck(pApp, pSP, pApp->m_pSourcePhrases);

	wxString titleStr = _("Inconsistency Found");
	wxString aSrcStr = _T("Ye olde bandaid solution");
	wxString aTgtStr = _T("Oh dear! Not another one!");
	bool bShowItCentered = TRUE;
	if (gbIsGlossing)
	{
		ConsChk_Empty_noTU_Dlg dlg(
			(wxWindow*)gpApp->GetMainFrame(),
			&titleStr,
			&aSrcStr,
			&aTgtStr,
			&gpApp->m_modeWordGloss,
			&gpApp->m_modeWordGlossPlusArticle,
			&gpApp->m_strNotInKB,
			&gpApp->m_strNoGloss,
			bShowItCentered);
			dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
			dlg.m_nTwoLineDepth = 2 * GetLayout()->GetTgtTextHeight();
		if (dlg.ShowModal() == wxID_OK)
		{
			;
		}
		else
		{
			return;
		}
	}
	else
	{
		ConsChk_Empty_noTU_Dlg dlg(
			(wxWindow*)gpApp->GetMainFrame(),
			&titleStr,
			&aSrcStr,
			&aTgtStr,
			&gpApp->m_modeWordAdapt,
			&gpApp->m_modeWordAdaptPlusArticle,
			&gpApp->m_strNotInKB,
			&gpApp->m_strNoAdapt,
			bShowItCentered);
			dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
			dlg.m_nTwoLineDepth = 2 * GetLayout()->GetTgtTextHeight();
		if (dlg.ShowModal() == wxID_OK)
		{
			;
		}
		else
		{
			return;
		}
	}

	// the consck_exists_notu_dlg dialog
	if (!gbIsGlossing)
	{
		conschk_exists_notu_dlg dlg(
		(wxWindow*)gpApp->GetMainFrame(),
		&titleStr,
		1,
		&aSrcStr,
		&aTgtStr,
		&gpApp->m_strNotInKB,
		TRUE);
		dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
		dlg.m_nTwoLineDepth = 2 * GetLayout()->GetTgtTextHeight();
		if (dlg.ShowModal() == wxID_OK)
		{
			;
		}
		else
		{
			return;
		}
	}

	// the consck_exists_notu_dlg dialog
	if (!gbIsGlossing)
	{
		conschk_exists_notu_dlg dlg(
		(wxWindow*)gpApp->GetMainFrame(),
		&titleStr,
		2,
		&aSrcStr,
		&aTgtStr,
		&gpApp->m_strNotInKB,
		TRUE);
		dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
		dlg.m_nTwoLineDepth = 2 * GetLayout()->GetTgtTextHeight();
		if (dlg.ShowModal() == wxID_OK)
		{
			;
		}
		else
		{
			return;
		}
	}
	{
		CConsistencyCheckDlg dlg(pApp->GetMainFrame());
		CSourcePhrase* pSrcPhrase;
		CPile* pPile = GetPile(209);
		pSrcPhrase = pPile->GetSrcPhrase();
		int nWords = pSrcPhrase->m_nSrcWords;
		MapKeyStringToTgtUnit* pMap = NULL;
		CKB* pKB = NULL;
		CTargetUnit* pTU = NULL;
		bool bGotCTU = FALSE;
		if (gbIsGlossing)
		{
			pKB = gpApp->m_pGlossingKB;
		}
		else
		{
			pKB = gpApp->m_pKB;
		}
		pMap = pKB->m_pMap[nWords - 1];
		bGotCTU = pKB->AutoCapsLookup(pMap, pTU, pSrcPhrase->m_key);

		dlg.m_bFoundTgtUnit = bGotCTU;
		dlg.m_bDoAutoFix = FALSE;
		dlg.m_pApp = gpApp;
		//dlg.m_pKBCopy = pKBCopy;
		dlg.m_pKBCopy = pKB; // not the copied KB, so don't save anything!
		dlg.m_pTgtUnit = pTU; // could be null
		dlg.m_finalAdaptation.Empty(); // initialize final chosen adaptation or gloss
		dlg.m_pSrcPhrase = pSrcPhrase;
		dlg.m_chVerse = _T("1:2");
		dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
		dlg.m_nTwoLineDepth = 2 * GetLayout()->GetTgtTextHeight();
		if (dlg.ShowModal() == wxID_OK)
		{
			;
		}
		else
		{
			return;
		}
	}

	}
	*/

	// BEW added 01Aug06 Support for Book Mode was absent in 3.2.1 and earlier, but it is
	// now added here & below.
	// BEW comment 25Aug11. The legacy function prior to this data worked as follows: it
	// gave different options depending on the contrast "a doc is currently open"
	// (Situation 1) versus "no document is currently open" (Situation 2).
	// In all cases, app member wxArrayString m_acceptedFilesList communicated to the
	// child function: DoConsistencyCheck() the names of the file or files to be checked,
	// after having the working directory set appropriately. So we had the following
	// protocols:
	// Situation 1: The user was asked if he wanted a consistency check of (a) current
	// document only, or (b) all documents in the current folder (which could be
	// Adaptations folder, or if book mode is ON, one of the Bible book folders). He was
	// asked using a dialog, with 2 radio buttons. So the "doc is currently open" scenario
	// was not able to handle all doc files in all book folders; but it *could* handle all
	// doc files in the Adaptations folder (but only when book folder mode was not on).
	// Situation 2: The assumption was, if no doc was open, that as many doc files as
	// possible would be consistency checked. However, the book mode On / Off distinction
	// introduced a modality as follows:
	// (c) If book mode was ON, then the user was asked, via a Yes/No wxMessageBox() call,
	// whether or not to check all Bible book folders. If Yes was the answer, all folders
	// get entered and all files in each are checked; if the answer was No, then the check
	// was confined to all files in the current Bible book folder.
	// (d) If book mode was OFF, the user was asked nothing, and all doc files in the
	// Adaptation folder only were checked, and any book folders, if present, were ignored.
	//
	// Now, at 25Aug11, the above protocols can be changed, as follows.
	// (1) There will be no difference between what is available when "a doc is currently
	// open" versus "no doc is currently open"; and collaboration mode will support all
	// options. (Like OnFileRestoreKb(), we can use a boolean to keep track of when we've
	// had to save and close a current document in order to be able to proceed with the
	// check, and use the boolean to tell us when we have to restore the document to its
	// earlier state after all is done.
	// (2) The only choice the user has to make is whether to do the check on "the
	// currently open document" versus "all documents". (see 3 below)
	// (3) Our code will check if Bible book mode is ON or OFF, and proceed as follows:
	// (i) Book mode ON: checks either the currently open document in whatever book folder
	// is currently active; or (for an 'all documents choice at 2') checks all documents
	// in all book folders (and ignores any documents stored in the parent Adaptations
	// folder). Or
	// (ii) Book mode OFF; checks either the currently open document in the Adaptations
	// folder, or (for an 'all documents choice at 2'), checks all documents in the
	// Adaptations folder (and ignores any documents stored in Bible book folders).

	wxString dirPath;
	if (pApp->m_bBookMode && !pApp->m_bDisableBookMode)
		dirPath = pApp->m_bibleBooksFolderPath;
	else
		dirPath = pApp->m_curAdaptationsPath;
	bool bOK;
	// whm 8Apr2021 added wxLogNull block below
	{
		wxLogNull logNo;	// eliminates any spurious messages from the system if the wxSetWorkingDirectory() call returns FALSE
		bOK = ::wxSetWorkingDirectory(dirPath); // ignore failures
	} // end of wxLogNull scope

	// BEW added 05Jan07 to enable work folder on input to be restored when done
	wxString strSaveCurrentDirectoryFullPath = dirPath;

	// get the KB entry for the current active location updated so as to avoid a spurious
	// inconsistency
	bool bNoStore = FALSE;
	bool bAttemptStoreToKB = TRUE;
	bool bSuppressWarningOnStoreKBFailure = TRUE;
	bOK = TRUE;

	// BEW 9Aug11, in the call below, param1 TRUE is bArremptStoreToKB, param2 bNoStore
	// returns TRUE to the caller if the attempted store fails for some reason, for all
	// other circumstances it returns FALSE, and param3 bSuppressWarningOnStoreKBFailure
	// is TRUE as we don't expect a failure and will ignore it if it does anyway;
	UpdateDocWithPhraseBoxContents(bAttemptStoreToKB, bNoStore, bSuppressWarningOnStoreKBFailure);

	// we create the copy of the KB or glossingKB, as the case may be, only
	// once so that we don't have to do it every time we process the contents
	// of the next Bible book folder
	CKB* pKB;
	if (gbIsGlossing)
		pKB = pApp->m_pGlossingKB;
	else
		pKB = pApp->m_pKB;
	wxASSERT(pKB != NULL);
	CKB* pKBCopy = NULL;

	int nCumulativeTotal = 0; // count source phrases processed
	int nFileCount = 0;

	// create a list to hold pointers to auto-fix records, if user checks the auto fix checkbox
	// in the dlg; one for adaptation mode, one for glossing mode
	AFList afList;
	AFGList afgList;

	wxString savedCurOutputPath = pApp->m_curOutputPath;	// includes filename
	wxString savedCurOutputFilename = pApp->m_curOutputFilename;
	//	int		 savedCurSequNum = pApp->m_nActiveSequNum;	// for resetting the box location
	bool	 savedBookmodeFlag = pApp->m_bBookMode;	// for ensuring correct mode
	bool	 savedDisableBookmodeFlag = pApp->m_bDisableBookMode;		// ditto
	int		 savedBookIndex = pApp->m_nBookIndex;
	BookNamePair* pSavedCurBookNamePair = pApp->m_pCurrBookNamePair;
	bool bDocIsClosed = FALSE; // initialize, set it at next line
	bDocIsClosed = pApp->m_pSourcePhrases->GetCount() == 0; // set bDocIsClosed
	bool bDocForcedToClose = FALSE;
	bool bConsCheckDone = TRUE;

	// next two from legacy code..., retained because I'm lazy
	wxString pathName = savedCurOutputPath;
	wxString docName = savedCurOutputFilename;

	// Put up the Choose Consistency Check Type dialog
	CChooseConsistencyCheckTypeDlg ccDlg(pApp->GetMainFrame());
	if (ccDlg.ShowModal() == wxID_OK)
	{
		// BEW 1Sep15 Whatever the user's choice for whether current doc only, or all docs,
		// the new checkbox, "Do blind fixes whenever possible" applies, or doesn't apply,
		// to either choice; it's value has been already set in app's m_bBlindFixesInConsCheck

		// handle user's choice of consistency check type
		if (ccDlg.m_bCheckOpenDocOnly)
		{
			// check open doc only (whether in Adaptations or a book folder)

			// BEW added 01Aug06, ensure the current document's contents are removed,
			// otherwise we will get a doubling of the doc data when OnOpenDocument()
			// is called because the latter will append to whatever is in
			// m_pSourcePhrases, so the latter list must be cleared to avoid the data
			// doubling bug

			// If there is a document open when the command was invoked, clobber it so
			// that it's data doesn't get mixed into the first doc to be checked
			bool bClobberedSuccessfully = ConsistencyCheck_ClobberDoc(pApp, bDocIsClosed,
				bDocForcedToClose, pStatusBar, &afList, &afgList);
			if (!bClobberedSuccessfully)
			{
				// If there was an error, afList or afgList (which depends on
				// gbIsGlossing) is cleared internally, as is m_acceptedFilesList,
				// and progress bar finished off; all that remains to do here is return
				pApp->m_bBlindFixInConsCheck = FALSE; // restore default value (BEW 1Sep15)
				return;
			}
			// This open-doc-only option is available only provided a document is
			// currently visible in the client window of the canvas
			if (!bDocIsClosed)
			{
				// Ensure that our current document is the only doc in the accepted files list
				pApp->m_acceptedFilesList.Clear();
				pApp->m_acceptedFilesList.Add(docName);

				// need a copy of pKB to check for inconsistencies in
				pKBCopy = new CKB();
				pKBCopy->Copy(*pKB);

				// do the consistency check on the doc
				nFileCount++;
				// temporarily turn the progress bar on
				if (gbIsGlossing)
				{
					bConsCheckDone = DoConsistencyCheckG(pApp, pKB, pKBCopy, afgList,
						nCumulativeTotal); // for glossing mode
				}
				else
				{
					bConsCheckDone = DoConsistencyCheck(pApp, pKB, pKBCopy, afList,
						nCumulativeTotal, arrSetNotInKB, arrRemoveNotInKB); // for adapting mode
				}
				if (!bConsCheckDone)
				{
					bUserCancelled = TRUE; // from within one of the dialogs shown
										   // during DoConsistencyCheck()
				}
				pApp->m_acceptedFilesList.Clear();
				// remove any contents added to the AutoFixRecord, or AutoFixRecordG for
				// glossing mode
				if (gbIsGlossing)
				{
					RemoveAutoFixGList(afgList);
				}
				else
				{
					RemoveAutoFixList(afList);
				}
			} // end of TRUE block for test: if (!bDocIsClosed)
			else
			{
				// no document is open - return without doing anything
				wxMessageBox(_(
					"No document is open. First have a document open, then the choice to check it will work."),
					_T(""), wxICON_EXCLAMATION | wxOK);
				// whm note 5Dec06: Since EnumerateDocFiles has not yet been called the
				// current working directory has not changed, so no need here to reset
				// it before return.
				pApp->LogUserAction(_T("User asked for current doc consistency check without a document being open."));
				pStatusBar->FinishProgress(_("Performing Consistency Check"));
				pApp->m_bBlindFixInConsCheck = FALSE; // restore default value (BEW 1Sep15)
				return;
			} // end of else block for test: if (!bDocIsClosed)
			pStatusBar->UpdateProgress(_("Performing Consistency Check"), 2, _("Checking current document"));

		} // end of TRUE block for test: if (ccDlg.m_bCheckOpenDocOnly)
		else
		{
			// check all docs -- which we check depends on book mode
			if (pApp->m_bBookMode && !pApp->m_bDisableBookMode)
			{
				// book mode is on, do the check over all books in all book folders

				// If there is a document open when the command was invoked, clobber it so
				// that it's data doesn't get mixed into the first doc to be checked
				bool bClobberedSuccessfully = ConsistencyCheck_ClobberDoc(pApp, bDocIsClosed,
					bDocForcedToClose, pStatusBar, &afList, &afgList);
				if (!bClobberedSuccessfully)
				{
					// If there was an error, afList or afgList (which depends on
					// gbIsGlossing) is cleared internally, as is m_acceptedFilesList,
					// and progress bar finished off; all that remains to do here is return
					pApp->m_bBlindFixInConsCheck = FALSE; // restore default value (BEW 1Sep15)
					return;
				}
				pApp->LogUserAction(_T("Check all docs within all book folders"));
				// DoConsistencyCheck() relies on the fact that EnumerateDocFiles() having
				// been called in prior to DoConsistencyCheck() being called will have set
				// the current working directory to be the book folder from which all the
				// documents within that folder are to be checked; because internally
				// DoConsistencyCheck()calls OnOpenDocument() and passes in, in the
				// latter's single parameter, not an absolute path as is normally the case,
				// but just the filename of a file in the currently targetted book folder.
				// [ OnOpenDocument() also computes the correct m_curOutputPath correctly
				// using the bible book path and filename variables, but we don't use that
				// because we prefer to call DoFileSave_Protected() which will also do it
				// for us as well as doing the actual saving. ]
				// DoConsistencyCheck() then, after checking each doc file in the
				// targetted folder, calls DoFileSave_Protected() and the latter, if book
				// folder mode is turned on, uses the bible book folders supporting string
				// variables to calculate the correct path for saving the checked document.
				// Because our loop across the bible book folders will alter the current
				// values of the latter, we must therefore preserve them so that we can
				// restore the current settings when the loop completes. Though we may not
				// need to, we'll also save and afterwards restore m_curOutputPath,
				// m_curOutputFilename and m_curOutputBackupFilename.

				wxString save_currentOutputPath = pApp->m_curOutputPath;
				wxString save_currentOutputFilename = pApp->m_curOutputFilename;
				wxString save_currentOutputBackupFilename = pApp->m_curOutputBackupFilename;
				int save_nBookIndex = pApp->m_nBookIndex;
				BookNamePair* save_pCurrBookNamePair = pApp->m_pCurrBookNamePair;
				wxString save_bibleBooksFolderPath = pApp->m_bibleBooksFolderPath;

				wxString bookName;
				wxString folderPath;
				BookNamePair aBookNamePair;
				BookNamePair* pBookNamePair = &aBookNamePair;
				int nMaxBookFolders = (int)pApp->m_pBibleBooks->GetCount();
				int bookIndex;

				// need a temporary copy of pKB to check for inconsistencies within that,
				// use pKB for storage of our fixes
				pKBCopy = new CKB();
				pKBCopy->Copy(*pKB);

				// loop over the Bible book folders
				pStatusBar->StartProgress(_("Checking Book"), _("Checking Book"), nMaxBookFolders);
				for (bookIndex = 0; bookIndex < nMaxBookFolders; bookIndex++)
				{
					wxString msg;
					msg = msg.Format(_T("Checking Book: %d of %d"), bookIndex, nMaxBookFolders);
					pStatusBar->UpdateProgress(_("Performing Consistency Check"), bookIndex, msg);
					pBookNamePair = ((BookNamePair*)(*pApp->m_pBibleBooks)[bookIndex]);
					folderPath = pApp->m_curAdaptationsPath + pApp->PathSeparator + pBookNamePair->dirName;
					// setting the index, book name pair, and bibleBooksFolderPath on the
					// app class ensures that the internal call in DoConsistencyCheck() to
					// the DoSaveFile_Protected() will construct the right path to the
					// folder and file for saving the checked document.
					pApp->m_nBookIndex = bookIndex;
					pApp->m_pCurrBookNamePair = pBookNamePair;
					pApp->m_bibleBooksFolderPath = folderPath;
					// clear the list of files to be processed (actually its a wxArrayString)
					pApp->m_acceptedFilesList.Clear();
					// get a list of all the document files, and set the working directory to
					// the passed in path ( DoConsistencyCheck() internally relies on this
					// being set here to the correct folder )
					bOK = pApp->EnumerateDocFiles(this, folderPath, TRUE); // TRUE in this call
												// is boolean bSuppressDialog; we don't want the
												// user to have to choose which file(s) in a
												// dialog which may be shown as many as 67
												// times, in the bookFolders loop!
					if (!pApp->m_acceptedFilesList.IsEmpty())
					{
						nFileCount += pApp->m_acceptedFilesList.GetCount();
					}
					if (gbIsGlossing)
					{
						bConsCheckDone = DoConsistencyCheckG(pApp, pKB, pKBCopy, afgList,
							nCumulativeTotal); // for glossing mode
					}
					else
					{
						bConsCheckDone = DoConsistencyCheck(pApp, pKB, pKBCopy, afList,
							nCumulativeTotal, arrSetNotInKB, arrRemoveNotInKB); // for adapting mode
					}
					if (!bConsCheckDone)
					{
						bUserCancelled = TRUE; // from within one of the dialogs shown
											   // during DoConsistencyCheck()
						break;
					}
				} // end of for loop
				pStatusBar->FinishProgress(_("Checking Book"));

				// restore path and bible book folders variables to be what they were
				// before we looped across all the book folders
				pApp->m_acceptedFilesList.Clear();
				pApp->m_curOutputPath = save_currentOutputPath; // restore the original output path
				pApp->m_curOutputFilename = save_currentOutputFilename; // ditto for the output filename
				pApp->m_curOutputBackupFilename = save_currentOutputBackupFilename;
				pApp->m_nBookIndex = save_nBookIndex;
				pApp->m_pCurrBookNamePair = save_pCurrBookNamePair;
				pApp->m_bibleBooksFolderPath = save_bibleBooksFolderPath;

				// remove any contents added to the AutoFixRecord, or AutoFixRecordG for
				// glossing mode
				if (gbIsGlossing)
				{
					RemoveAutoFixGList(afgList);
				}
				else
				{
					RemoveAutoFixList(afList);
				}
				// restore working directory
				// whm 8Apr2021 added wxLogNull block below
				{
					wxLogNull logNo;	// eliminates any spurious messages from the system if the wxSetWorkingDirectory() call returns FALSE
					bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
				} // end of wxLogNull scope

			} // end of TRUE block for test: if (pApp->m_bBookMode && !pApp->m_bDisableBookMode )
			else
			{
				// it's not book mode, do the check over all books in the Adaptations folder
				// (dirPath has been set to pApp->m_curAdaptationsPath if book mode is not
				// on, that is, to Adaptations folder)

				// BEW 13Nov13 added call below -- it was omitted by mistake back in
				// 1Aug2006!! Ross Jones found the error a few days ago. Without this
				// block, the CSourcePhrase instances of the open document in the view
				// remain in m_pSourcePhrases, so the next OnOpenDocument() call (i.e. the
				// first doc of the list in m_acceptedFilesList) gets appended to the open
				// doc, and saved as part of the appended doc (at its start)

				// If there is a document open when the command was invoked, clobber it so
				// that it's data doesn't get mixed into the first doc to be checked
				bool bClobberedSuccessfully = ConsistencyCheck_ClobberDoc(pApp, bDocIsClosed,
					bDocForcedToClose, pStatusBar, &afList, &afgList);
				if (!bClobberedSuccessfully)
				{
					// If there was an error, afList or afgList (which depends on
					// gbIsGlossing) is cleared internally, as is m_acceptedFilesList,
					// and progress bar finished off; all that remains to do here is return
					pApp->m_bBlindFixInConsCheck = FALSE; // restore default value (BEW 1Sep15)
					return;
				}
				// need a temporary copy of pKB to check for inconsistencies within that,
				// use pKB for storage of our fixes
				pKBCopy = new CKB();
				pKBCopy->Copy(*pKB);

				// Enumerate the doc files and do the consistency check
				// whm note: EnumerateDocFiles() has the side effect of changing the current
				// work directory to the passed in dirPath.

				pStatusBar->UpdateProgress(_("Performing Consistency Check"), 1, _("Starting Consistency Check"));
				bOK = pApp->EnumerateDocFiles(this, dirPath);
				if (bOK)
				{
					if (pApp->m_acceptedFilesList.GetCount() == 0)
					{
						// nothing to work on, so abort the operation
						wxMessageBox(_(
							"There are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."),
							_T(""), wxICON_EXCLAMATION | wxOK);
						pApp->LogUserAction(_T(
							"There are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."));
						// before exiting, restore the former open document,
						// if one was open formerly
						if (bDocForcedToClose)
						{
							// reopen the doc with all as it was before; bMarkAsDirty = TRUE
							bOK = ReOpenDocument(pApp, strSaveCurrentDirectoryFullPath,
								savedCurOutputPath, savedCurOutputFilename, /*savedCurSequNum,*/ savedBookmodeFlag,
								savedDisableBookmodeFlag, pSavedCurBookNamePair, savedBookIndex, TRUE);
						}
						// erase the copied CKB which is no longer needed
						if (pKBCopy != NULL)
						{
							EraseKB(pKBCopy); // don't want memory leaks!
						}
						// remove any contents added to the AutoFixRecord, or AutoFixRecordG for
						// glossing mode
						if (gbIsGlossing)
						{
							RemoveAutoFixGList(afgList);
						}
						else
						{
							RemoveAutoFixList(afList);
						}
						pStatusBar->FinishProgress(_("Performing Consistency Check"));
						return;
					}

					pStatusBar->UpdateProgress(_("Performing Consistency Check"), 2, _("Starting Consistency Check"));
					if (!pApp->m_acceptedFilesList.IsEmpty())
					{
						nFileCount += pApp->m_acceptedFilesList.GetCount();
					}
					if (gbIsGlossing)
					{
						bConsCheckDone = DoConsistencyCheckG(pApp, pKB, pKBCopy, afgList,
							nCumulativeTotal); // for glossing mode
					}
					else
					{
						bConsCheckDone = DoConsistencyCheck(pApp, pKB, pKBCopy, afList,
							nCumulativeTotal, arrSetNotInKB, arrRemoveNotInKB); // for adapting mode
						bDocForcedToClose = TRUE;	// reopen the current document
					}
					if (!bConsCheckDone)
					{
						bDocForcedToClose = TRUE;	// EDB 26 Sept 2012: DoConsistencyCheck calls ClobberDocument();
													// if the user cancelled, we need to reopen the current document
						bUserCancelled = TRUE; // from within one of the dialogs shown
											   // during DoConsistencyCheck()
					}
				} // end of TRUE block for test: if (bOK)

				pApp->m_acceptedFilesList.Clear();
				// remove any contents added to the AutoFixRecord, or AutoFixRecordG for
				// glossing mode
				if (gbIsGlossing)
				{
					RemoveAutoFixGList(afgList);
				}
				else
				{
					RemoveAutoFixList(afList);
				}
			} // end of else block for test: if (pApp->m_bBookMode && !pApp->m_bDisableBookMode )

		} // end of else block for test: if (ccDlg.m_bCheckOpenDocOnly)
	}
	else
	{
		// user cancelled
		bUserCancelled = TRUE; // this is a global boolean

		// whm note 5Dec06: Since EnumerateDocFiles has not yet been called the current
		// working directory has not changed, so no need here to reset it before
		// return.
		pApp->LogUserAction(_T("Cancelled OnEditConsistencyCheck()"));
		pStatusBar->FinishProgress(_("Performing Consistency Check"));
		pApp->m_bBlindFixInConsCheck = FALSE; // restore default value (BEW 1Sep15)
		return;
	}
	pStatusBar->UpdateProgress(_("Performing Consistency Check"), 3, _("Cleaning up..."));
	// erase the copied CKB which is no longer needed
	if (pKBCopy != NULL)
	{
		EraseKB(pKBCopy); // don't want memory leaks!
		pKBCopy = NULL;
	}

	// before exiting, restore the former open document, if one was open formerly
	if (bDocForcedToClose)
	{
		// reopen the doc with all as it was before; bMarkAsDirty = TRUE
		bOK = ReOpenDocument(pApp, strSaveCurrentDirectoryFullPath,
			savedCurOutputPath, savedCurOutputFilename, /*savedCurSequNum,*/ savedBookmodeFlag,
			savedDisableBookmodeFlag, pSavedCurBookNamePair, savedBookIndex, TRUE);
	}

	pStatusBar->UpdateProgress(_("Performing Consistency Check"), 4, _("Finishing Consistency Check"));
	// show stats
	if (!bUserCancelled)
	{
		// put up final statistics, provided user did not cancel from one
		// of the dialogs
		wxString stats;
		stats = stats.Format(_(
			"The consistency check was successful. There were %d source words and phrases  in %d  files."),
			nCumulativeTotal, nFileCount);
		// whm 15May2020 added below to supress phrasebox run-on due to handling of ENTER in CPhraseBox::OnKeyUp()
		gpApp->m_bUserDlgOrMessageRequested = TRUE;
		wxMessageBox(stats, _T(""), wxICON_INFORMATION | wxOK);
	}
	pStatusBar->FinishProgress(_("Performing Consistency Check"));
	pApp->m_bBlindFixInConsCheck = FALSE; // restore default value (BEW 1Sep15)
}

bool CAdapt_ItDoc::ConsistencyCheck_ClobberDoc(CAdapt_ItApp* pApp, bool& bDocIsClosed, bool& bDocForcedToClose,
	CStatusBar* pStatusBar, AFList* afListPtr, AFGList* afgListPtr)
{
	// save and remove open doc, if a doc is open
	if (!bDocIsClosed)
	{

		pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

	   // Save the Doc (and DoFileSave() also automatically saves, without backup,
		// both the glossing and adapting KBs)
		// BEW changed 29Apr10 to use DoFileSave_Protected() which gives better
		// protection against data loss in the event of a failure
		pStatusBar->UpdateProgress(_("Performing Consistency Check"), 1, _("Saving Current Document"));
		bool fsOK = DoFileSave_Protected(false, _T("")); // don't show progress on this task
		if (!fsOK)
		{
			// something's real wrong!
			wxMessageBox(_(
				"Could not save the current document. Consistency Check Command aborted."),
				_T(""), wxICON_EXCLAMATION | wxOK);
			// whm note 5Dec06: Since EnumerateDocFiles has not yet been called the
			// current working directory has not changed, so no need here to reset
			// it before return.
			pApp->LogUserAction(_T("Could not save the current document. Consistency Check Command aborted."));
			// remove any contents added to the AutoFixRecord, or AutoFixRecordG for
			// glossing mode
			if (gbIsGlossing)
			{
				RemoveAutoFixGList(*afgListPtr);
			}
			else
			{
				RemoveAutoFixList(*afListPtr);
			}
			pStatusBar->FinishProgress(_("Performing Consistency Check"));
			return FALSE;
		}

		// BEW added 01Aug06, ensure the current document's contents are
		// removed, otherwise we will get the CSourcePhrases of the first of
		// the listed docs that we open appended to the currently open doc's
		// data when OnOpenDocument() is called because the latter will append
		// to whatever is in m_pSourcePhrases, so the latter list must be
		// cleared to avoid the data doubling bug
		bDocForcedToClose = TRUE;
		pApp->GetView()->ClobberDocument(); // BEW 13Jul19 sets m_bDocumentDestroyed to TRUE (only DoAutoSaveDoc() uses)
		pApp->m_acceptedFilesList.Clear();
	} // end of TRUE block for test: if (!bDocIsClosed)
	//pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)
	return TRUE;
}


// Allow "Change Punctuation or Markers Placement" while document is open, but only if the
// active location's CSourcePhrase stores content in one or more of the
// m_lastAdaptionsPattern, m_tgtMkrPattern, m_glossMkrPattern, or m_punctsPattern members
// -- these were introduced at docVersion 6 (March 2012) in the 6.2.0 release
// BEW created 27Feb12
// BEW 30Sep19, changed to suppress including m_punctsPattern in the enabling test (possibly temporary)
void CAdapt_ItDoc::OnUpdateChangePunctsOrMarkersPlacement(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	bool bKBReady = FALSE;
	if (gbIsGlossing)
		bKBReady = pApp->m_bGlossingKBReady;
	else
		bKBReady = pApp->m_bKBReady;
	if (bKBReady && pApp->m_pActivePile != NULL) // whm 13Mar12 added m_pActivePile != NULL test
	{
		CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		wxASSERT(pSrcPhrase != NULL);
		if (
			!pSrcPhrase->m_lastAdaptionsPattern.IsEmpty() ||
			!pSrcPhrase->m_tgtMkrPattern.IsEmpty() ||
			!pSrcPhrase->m_glossMkrPattern.IsEmpty()
			// BEW 30Sep19  remove, since m_punctsPattern is now repurposed
			//			||
			//			!pSrcPhrase->m_punctsPattern.IsEmpty()
			)
		{
			event.Enable(TRUE);
		}
		else
		{
			event.Enable(FALSE);
		}
	}
	else
	{
		event.Enable(FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return         nothing
/// \remarks
/// Handler for the Edit menu's Change Punctuation or Markers Placement command.
/// Allow "Change Punctuation or Markers Placement" while document is open, but only if the
/// active location's CSourcePhrase stores content in one or more of the
/// m_lastAdaptionsPattern, m_tgtMkrPattern, m_glossMkrPattern, or m_punctsPattern members.
/// If the user invokes this menu item, then clear all four of the above strings. This will
/// re-expose the ambiguity in punctuation(s) or markers(s) placement inherent in the
/// document structure at this location - and result in the relevant Place... dialog or
/// dialogs being opened again, so that the user can re-place punctuation, or during an
/// export of the target text, re-place one or more medial markers, or an endmarker at the
/// end of the one or final CSourcePhrase where there is punctuation in both m_follPuncts
/// and m_follOuterPuncts - the latter situation produces an ambiguity for marker placement
/// as well.
/// BEW created 27Feb12, as part of docVersion 6 changes, for release in version 6.2.0
/// BEW 30Sep19 refactoring for USFM3, m_punctsPattern has been repurposed, so don't
/// let it be cleared. Later I may remove support for these CPhraseBox member strings
void CAdapt_ItDoc::OnChangePunctsOrMarkersPlacement(wxCommandEvent& WXUNUSED(event))
{
	CSourcePhrase* pSrcPhrase = gpApp->m_pActivePile->GetSrcPhrase();
	wxASSERT(pSrcPhrase != NULL);
	pSrcPhrase->m_lastAdaptionsPattern.Empty();
	pSrcPhrase->m_tgtMkrPattern.Empty();
	pSrcPhrase->m_glossMkrPattern.Empty();
	// BEW 30Sep19 commented out
	//pSrcPhrase->m_punctsPattern.Empty();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the application is in Free Translation mode, or
/// Vertical Editing is in progress, or it is only showing the target language text, or the
/// active KB is not in a ready state, this handler disables the "Consistency Check..."
/// item in the Edit menu, otherwise it enables the "Consistency Check..." item on the Edit
/// menu.
/// BEW modified 13Nov09, disable the consistency check menu item when the flag
/// m_bReadOnlyAccess is TRUE (it must not be possible to initiate a consistency
/// check when visiting a remote user's project folder -- it involves KB modifications
/// and that would potentially lose data added to the remote user's remote KB by him)
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItDoc::OnUpdateEditConsistencyCheck(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (pApp->m_bClipboardAdaptMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->IsEmpty())
	{
		event.Enable(FALSE);
		return;
	}
	bool bKBReady = FALSE;
	if (gbIsGlossing)
		bKBReady = pApp->m_bGlossingKBReady;
	else
		bKBReady = pApp->m_bKBReady;
	// Allow Consistency Check... while document is open
	if (bKBReady)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItDoc::RemoveAutoFixList(AFList& afList)
{
	// delete the contents of the pointer list, for adaptations mode
	if (!afList.IsEmpty())
	{
		AFList::Node* pos_afList = afList.GetFirst();
		wxASSERT(pos_afList != 0);
		while (pos_afList != 0)
		{
			AutoFixRecord* pRec = (AutoFixRecord*)pos_afList->GetData();
			pos_afList = pos_afList->GetNext();
			if (pRec != NULL) // whm 11Jun12 added NULL test
				delete pRec;
		}
	}
	afList.Clear();
}

void CAdapt_ItDoc::RemoveAutoFixGList(AFGList& afgList)
{
	// delete the contents of the pointer list, for adaptations mode
	if (!afgList.IsEmpty())
	{
		AFGList::Node* pos_afgList = afgList.GetFirst();
		wxASSERT(pos_afgList != 0);
		while (pos_afgList != 0)
		{
			AutoFixRecordG* pRec = (AutoFixRecordG*)pos_afgList->GetData();
			pos_afgList = pos_afgList->GetNext();
			if (pRec != NULL) // whm 11Jun12 added NULL test
				delete pRec;
		}
	}
	afgList.Clear();
}
// the #define for CONSCHK is near the start of Adapt_ItDoc.h, commented out
#ifdef CONSCHK
void CAdapt_ItDoc::ListBothArrays(wxArrayString& arrSetNotInKB, wxArrayString& arrRemoveNotInKB)
{
	// allow 20 entries to be shown
	wxString emptyStr = _T("");
	wxString set[9] = { emptyStr, emptyStr, emptyStr, emptyStr, emptyStr, emptyStr, emptyStr, emptyStr, emptyStr };
	wxString remove[9] = { emptyStr, emptyStr, emptyStr, emptyStr, emptyStr, emptyStr, emptyStr, emptyStr, emptyStr };
	int setMax = arrSetNotInKB.GetCount();
	int removeMax = arrRemoveNotInKB.GetCount();
	int index1 = 0;
	while (index1 < 9 && index1 < setMax)
	{
		set[index1] = arrSetNotInKB.Item(index1);
		index1++;
	}
	int index2 = 0;
	while (index2 < 9 && index2 < removeMax)
	{
		remove[index2] = arrRemoveNotInKB.Item(index2);
		index2++;
	}
	wxLogDebug(_T(" Set:	1. %s		2. %s		3. %s		4. %s		5. %s		6. %s		7. %s		8. %s		9. %s"),
		set[0].c_str(), set[1].c_str(), set[2].c_str(), set[3].c_str(), set[4].c_str(), set[5].c_str(), set[6].c_str(), set[7].c_str(), set[8].c_str());
	wxLogDebug(_T(" Remove: 1. %s		2. %s		3. %s		4. %s		5. %s		6. %s		7. %s		8. %s		9. %s"),
		remove[0].c_str(), remove[1].c_str(), remove[2].c_str(), remove[3].c_str(), remove[4].c_str(), remove[5].c_str(), remove[6].c_str(), remove[7].c_str(), remove[8].c_str());
}

#endif

// whm 23Aug2021 added support for an AutoCorrect feature for Adapt It.
// This SetupAutoCorrectHashMap() function first initializes the App members that
// are used for the Auto Correct functions by calling the App's 
// EmptyMapAndInitializeAutoCorrect() function which initializes these App values:
//		m_AutoCorrectMap.empty();
//		m_bAutoCorrectIsMalformed = FALSE;
//		m_bUsingAutoCorrect = FALSE;
//		m_longestAutoCorrectKeyLen = 0;
// When a document is opened, this function checks to see if an autocorrect.txt 
// file exists within that document's project folder. If such a file exists, it is read 
// and parsed for any valid mapping rules which, if found, are mapped to the 
// App's m_AutoCorrectMap, and the App member flag m_bAutoCorrect is set to TRUE.
// The m_bAutoCorrect map is cleared and m_bAutoCorrect set back to FALSE when 
// the document is closed, so that the map is only available while a document is open for
// a project containing the autocorrect.txt file.
// This function sets the App's m_bUsingAutoCorrect flag TRUE only if an autocorrect.txt 
// file is found in the currently open document's project folder, and that autocorrect.txt 
// file contains at least one valid replacement rule, otherwise it is set to FALSE.
// The App's m_longestAutoCorrectKeyLen is set to the length of the longest key
// string saved in the map.
// The App's m_bAutoCorrectIsMalformed flag is set to TRUE if it detects that the 
// autocorrect.txt file is malformed, i.e., it has a rule line that tries to add 
// an  auto-correct rule for an empty string on the left-hand-side of the --> symbol.
// This function is called from two places:
// (1) From the CAdapt_ItDoc::OnOpenDocument() handler - for non-collaboration documents
// (2) From the CollabUtilities.cpp's OK_btn_delayedHandler_GetSourceTextFromEditor() 
//     functionn for collaboration documents.
// whm 6May2022 modified to ensure that we don't accidentally change the case of any 
// actual Unicode characters when dealing with an upper case backslash \Uxxxx representation
// and lower case backslash \uxxxx representation.
void CAdapt_ItDoc::SetupAutoCorrectHashMap()
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// Initialize the AutoCorrect App values to defaults:
	// Always start with an empty hashmap
	pApp->EmptyMapAndInitializeAutoCorrect();

	bool bFileExistsAndOpensOK = FALSE;
	bFileExistsAndOpensOK = bFileExistsAndOpensOK; // avoid gcc "set but not used' warning
	wxString lineNumStr = _T("");

	// The path to the current project is stored in App's m_curProjectPath, so we're looking
	// for m_currProjectPath + PathSeparator + _T("autocorrect.txt");
	wxString filePath = pApp->m_curProjectPath + pApp->PathSeparator + _T("autocorrect.txt");
	if (wxFileExists(filePath))
	{
		// The autocorrect.txt file exists in this document's project folder, so open it and read its
		// content into a wxTextFile
		wxTextFile tfile;
		if (tfile.Open(filePath))
		{
			int lineNum = 0;
			bFileExistsAndOpensOK = TRUE;
			MapAutoCorrectStrings::iterator iter;
			wxString strBuf;
			wxString replaceSymbol = _T("-->");
			wxString longestKeyStr = _T("");
			wxString LHS = _T("");
			wxString convertedLHS;
			wxString RHS = _T("");
			wxString convertedRHS = _T("");
			strBuf = tfile.GetFirstLine();
			while (!tfile.Eof())
			{
				lineNum++;
				if (!strBuf.IsEmpty() && !(strBuf.GetChar(0) == _T('#'))) // bypass empty and # comment lines 
				{
					int posSymbol = strBuf.Find(replaceSymbol);
					if (posSymbol != wxNOT_FOUND)
					{
						LHS = _T("");
						convertedLHS = _T("");
						RHS = _T("");
						convertedRHS = _T("");
						if (posSymbol != 0) // if --> is at beginning of line the line is malformed (can't correct an empty string to something else!)
						{
							// Found a line containing --> so extract the left-hand-side and right-hand-side substrings from this line
							LHS = strBuf.Mid(0, posSymbol);
							wxString lcLHS = LHS;
							lcLHS.MakeLower(); // so we don't have to deal separately with \U and \u
							// The wxString constructor (below) recognizes \uxxxx sequences of hex chars
							// within the lcLHS string and automatically converts them for us to actual
							// Unicode chars within the string.
							bool bSuccessfulLHS = TRUE;
							bool bSuccessfulRHS = TRUE;
							if (lcLHS.Find(_T("\\u")) != wxNOT_FOUND)
							{
								// "\u" exists within the lcLHS string
								// In case there are other actual Unicode chars mixed in we don't pass in the lcLHS (made lower case),
								// to the ConvertBackslashUxxxxHexValsInStringToStringChars(), but pass in the original case version LHS.
								// The ConvertBackslashUxxxxHexValsInStringToStringChars() function itself must deal with any cases where 
								// any uppercase \U instances may be found as well as lower case \u instances without changing the case of 
								// any actual Unicode characters.
								convertedLHS = pApp->ConvertBackslashUxxxxHexValsInStringToStringChars(LHS, bSuccessfulLHS);
								if (!bSuccessfulLHS)
								{
									// Couldn't convert the lcLHS string so log this fact in the UserActionLog
//									wxLogDebug("Error in autocorrect.txt LHS: LHS = [%s] RHS = [%s] convertedLHS = [%s] convertedRHS = [%s]", LHS.c_str(), RHS.c_str(), convertedLHS.c_str(), convertedRHS.c_str());
									wxString msg = _T("  SetupAutoCorrectHashMap error: Could not convert left-hand-side of --> rule string: %s");
									msg = msg.Format(msg, LHS.c_str());
//									wxLogDebug(msg);
									pApp->LogUserAction(msg);
								}
							}
							else
							{
								// There are no \uxxxx within the lcLHS, so assign the original LHS (not made into lower case) to convertedLHS as is without conversion
								convertedLHS = LHS;
							}
							RHS = strBuf.Mid(posSymbol + 3);
							wxString lcRHS = RHS;
							lcRHS.MakeLower();
							if (lcRHS.Find(_T("\\u")) != wxNOT_FOUND)
							{
								// "\u" exists within the lcRHS string
								// In case there are other actual Unicode chars mixed in we don't pass in the lcRHS (made lower case),
								// to the ConvertBackslashUxxxxHexValsInStringToStringChars(), but pass in the original case version RHS.
								// The ConvertBackslashUxxxxHexValsInStringToStringChars() function itself must deal with any cases where 
								// any uppercase \U instances may be found as well as lower case \u instances without changing the case of 
								// any actual Unicode characters.
								convertedRHS = pApp->ConvertBackslashUxxxxHexValsInStringToStringChars(RHS, bSuccessfulRHS);
								if (!bSuccessfulRHS)
								{
									// Couldn't convert the lcLHS string so log this fact in the UserActionLog
//									wxLogDebug("Error in autocorrect.txt RHS: LHS = [%s] RHS = [%s] convertedLHS = [%s] convertedRHS = [%s]", LHS.c_str(), RHS.c_str(), convertedLHS.c_str(), convertedRHS.c_str());
									wxString msg = _T("  SetupAutoCorrectHashMap error: Could not convert right-hand-side of --> rule string: %s");
									msg = msg.Format(msg, RHS.c_str());
//									wxLogDebug(msg);
									pApp->LogUserAction(msg);
								}
							}
							else
							{
								// There are no \uxxxx within the lcRHS, so assign the original RHS (not made into lower case) to convertedRHS as is without conversion
								convertedRHS = RHS;
							}
							if (!bSuccessfulLHS || !bSuccessfulRHS)
							{
								strBuf = tfile.GetNextLine(); // must iterate before the continue call below otherwise we get an endless loop!
								continue; // continue parsing any other rules in the autocorrect.txt file 
							}

							// Store the substrings in our m_AutoCorrectMap on the App
							// Enter the LHS key and RHS replacement strings into the map
							wxString key = convertedLHS;
							iter = pApp->m_AutoCorrectMap.find(key);
							if (iter != pApp->m_AutoCorrectMap.end())
							{
								// key exists in the map
								pApp->m_AutoCorrectMap.insert(*iter);
							}
							else
							{
								// key not in the map
								pApp->m_AutoCorrectMap[key] = convertedRHS;
							}
						}
						else
						{
							pApp->m_bAutoCorrectIsMalformed = TRUE;
							if (lineNumStr.IsEmpty())
							{
								lineNumStr << lineNum;
							}
							else
							{
								lineNumStr += _T(", ");
								lineNumStr << lineNum;
							}
						}
					}
				}
				strBuf = tfile.GetNextLine();
			}
			tfile.Close();

			if (pApp->m_AutoCorrectMap.size() == 0)
			{
				// The m_AutoCorrectMap is still empty so set App's m_bUsingAutoCorrect to FALSE
				pApp->m_bUsingAutoCorrect = FALSE;
			}
			else
			{
				// There is at least one auto-correct rule in the map so set App's m_bUsingAutoCorrect to TRUE
				pApp->m_bUsingAutoCorrect = TRUE;
			}

			// testing below. Actual messages done in the caller Adapt_ItDoc.cpp
			//if (pApp->m_AutoCorrectMap.size() == 0) // the .size method gets the total number of keys/elements in the hashmap
			//{
			//	// autocorrect.txt file exists, but has no parseable rules within it. Log this state, but don't
			//	// bother the user about it.
			//	pApp->LogUserAction(_T("The autocorrect.txt file exists but has no auto-correct rules within it!"));
			//}
			//else
			//{
			//	// dump the map contents for testing
			//	int ct = 0;
			//	for (iter = pApp->m_AutoCorrectMap.begin(); iter != pApp->m_AutoCorrectMap.end(); ++iter)
			//	{
			//		ct++;
			//		wxLogDebug(_T("autocorrect.txt rule #%d. iter->first = %s, iter->second = %s"), ct, iter->first.c_str(), iter->second.c_str());
			//	}
			//}
		}
	}
	// inform user and user log of existence and state of any autocorrect.txt file
	if (pApp->m_bUsingAutoCorrect)
	{
		int totRules = (int)pApp->m_AutoCorrectMap.size();
		wxString msg;
		wxString userMsg;
		if (pApp->m_bAutoCorrectIsMalformed)
		{
			msg = _T("An autocorrect.txt file found for the \"%s\" project. It has %d mapping rules.");
			msg = msg.Format(msg, pApp->m_curProjectName.c_str(), totRules);
			msg += _T(" ERROR: The autocorrect.txt file is MALFORMED (empty string on left side of --> at line(s): %s)!!");
			msg = msg.Format(msg, lineNumStr.c_str());
		}
		pApp->LogUserAction(msg);
		if (pApp->m_bAutoCorrectIsMalformed)
		{
			// notify the user of the autocorrect.txt error with localizable message
			userMsg = _("A bad autocorrect.txt file was found for the \"%s\" project.\nIn that autocorrect.txt file there are no text characters on the left side of --> at line(s): %s)\nAsk your administrator to fix or remove the autocorrect.txt file from this project.");
			userMsg = userMsg.Format(userMsg, pApp->m_curProjectName.c_str(), lineNumStr.c_str());
			wxMessageBox(userMsg);
		}
//		wxLogDebug(msg);
//		wxLogDebug(userMsg);
		// Adjust the interface to show the Use Auto Correct check box in the control bar with a tick in the box.
		pApp->ConfigureModeBarForAutoCorrect();
	}
}

// whm 23Aug2021 added
// This function looks for any rules in the App'a m_AutoCorrectMap that can be applied to the
// target text that resides to the left side of the insertion point at the instant a character is
// typed. If a key-value association pair is found in the m_AutoCorrectMap hashmap, it applies that rule 
// returning the result in the third reference parameter newEditBoxLHSStr.
// This function returns TRUE if an autocorrect.txt rule was applied to the candidateEditBoxStr 
// string, otherwise it returns FALSE.
// This function takes the following parameters:
//   wxString candidateEditBoxLHSStr - a copy of the phrasebox string that is the target text string 
//     that exists to the left of the insertion point when the CPhraseBox::OnChar() handler is triggered. 
//     This candidateEditBoxLHSStr does not include the typed character being typed when OnChar() is 
//     triggered, since within OnChar() the char hasn't yet been added to the edit box text.
//   wxChar typedChar - the wxChar being typed at the time OnChar() is triggered.
//   wxString& newEditBoxLHSStr - a reference parameter that returns in newEditBoxLHSStr the string that 
//     represents the new/corrected string - up to the insertion point - after applying the auto-correct 
//     rule(s).
// NOTE: It is up to the caller, usually OnChar(), to properly handle the function's return value, and 
// if that value is TRUE, to also properly handle the returned newEditBoxLHSStr value, replacing the whole
// original candidate string residing to the left of the insertion point with the "corrected" string that
// is returned in newEditBoxLHSStr. 
bool CAdapt_ItDoc::LookUpStringInAutoCorrectMap(wxString candidateEditBoxLHSStr, wxChar typedChar, wxString& newEditBoxLHSStr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	bool bFound = FALSE;
	int numCharsToTest;
	wxString tempCandidateStrPlusTypedChar;
	// REMEMBER: we are being called from OnChar() where the typed char typedChar was not yet 
	// added to the edit box text at the insertion point.
	// The typedChar is what is triggering our autocorrect lookup, and it becomes part of what
	// we are looking up in the m_AutoCorrectMap. In fact it could be the only thing that matches
	// a key in the map for cases like [<-->‘] in which the typedChar < matches the LHS of a mapping
	// rule that corrects a < to a single curly quote ‘ char. Therefore, we add the typedChar here
	// to tempStrPlusTypedChar before checking for matching sub-strings.
	tempCandidateStrPlusTypedChar = candidateEditBoxLHSStr + typedChar;
	// We only need to test against substrings at the end of the candidateEditBoxLHSStr up to a maximum 
	// length of our longest AutoCorrect key length, or the length of our candidateEditBoxLHSStr + typedChar, 
	// string whichever is the shortest. The max length of the longest key in our map is stored in the 
	// App's m_longestAutoCorrectKeyLen member.
	if (pApp->m_longestAutoCorrectKeyLen < (int)tempCandidateStrPlusTypedChar.Length())
		numCharsToTest = pApp->m_longestAutoCorrectKeyLen;
	else
		numCharsToTest = (int)tempCandidateStrPlusTypedChar.Length();
	numCharsToTest = numCharsToTest; // avoid gcc warning "set but not used"

	wxString subStr = _T("");
	// Since the most likely key matches will be for one or two characters, we'll get substrings from the 
	// right end of the tempStrPlusTypedChar. 
	// Since we appended typedChar to the candidateEditBoxLHSStr the first subStr tested will simply be the typedChar.
	MapAutoCorrectStrings::iterator iter;
	// look up this subStr in the m_AutoCorrectMap
	// The App's m_AutoCorrectMap is a small one so it is on the stack 
	for (iter = pApp->m_AutoCorrectMap.begin(); iter != pApp->m_AutoCorrectMap.end(); ++iter)
	{
		wxString tempSecond = iter->second;
		wxString tempFirst = iter->first;
		int lengthOfCompareStr = (int)iter->first.Length();
		// get an initial subStr composed of the progressively larger sub-strings taken from the 
		// right end of the candidate string. This subStr may change as the result of an auto-correct 
		// rule being applied below, which in turn may result in an additional rule being applied as 
		// the result of the single character press that resulted in this function being called.
		if (tempCandidateStrPlusTypedChar.Right(lengthOfCompareStr) == iter->first)
		{
			bFound = TRUE;
			wxString mappedSubStr = iter->second; // for debugging
			// Do the auto-correct replacement of last matching characters on tempCandidateStrPlusTypedChar
			tempCandidateStrPlusTypedChar = tempCandidateStrPlusTypedChar.Mid(0, tempCandidateStrPlusTypedChar.Length() - lengthOfCompareStr) + iter->second;
			// Continue applying any other auto-correct rules the might apply until all rules are tried
		}

	}
	if (bFound)
	{
		newEditBoxLHSStr = tempCandidateStrPlusTypedChar;
	}

	return bFound;
}


// Returns TRUE if process runs to completion, FALSE if the user clicks the Cancel button
// in any dialog which is shown - the FALSE is then passed back to the caller,
// OnEditConsistencyCheck() to cause the whole process to be cancelled.
// This function assumes that the current directory will have already been set correctly
// before being called. This function potentially handles all doc files in a folder - which
// may be a Bible book folder, or the Adaptations folder. Which files are handled is
// decided in the caller, which lists them in the wxArrayString m_acceptedFilesList. (When
// processing just the current document, that will be all that will be in the list.) We
// loop over each document. The second parameter, and third parameters, pKB and pKBCopy are
// pointers to the same KB (either both the adapting KB, or both the glossing KB) for the
// current project's active KB (depending, of course, on whether glossing mode is on or
// off), and pKBCopy is used for finding inconsistencies, while KB updates are saved to
// pKB.
// (A prior call of EnumerateDocFiles() with the boolean parameter default TRUE has to have
// been made prior to calling this function. The boolean is for suppressing an internal
// dialog, & being TRUE this dialog is prevented from being shown - we don't want it shown
// and the user have to choose files.
// The latter call also sets the working directory, a fact which DoConsistencyCheck()
// relies on, as it calls OnOpenDocument() with only a filename as parameter, instead of an
// absolute path to that file.
// This function: (a) does not show a progress indicator (processing shortish files makes
// it 'flash' if it is visible only a short time); and
// (b) collects a CSourcePhrase count and total for the statistics dialog shown by the
// caller when the total job is done
//
// Modified, July 2003, for support of Auto Capitalization
// BEW 12Apr10, no changes needed for support of doc version 5
// BEW 17May10, moved to here from CAdapt_ItView
// BEW 8July10, updated for support of kbVersion 2, and for processing all contents of all
// the bible book folders in a loop set up in the caller (which is
// OnEditConsistencyCheck())
// BEW 11Oct10, changed to support ~ conjoining (without this fix, such joined words end
// up in map 2, instead of being in map 1)
// BEW 13Nov10, changes to support Bob Eaton's request for glosssing KB to use all maps
// BEW 26Aug11, changes to prevent false positives, made this the only function of this
// name, and added nCumulativeTotal 4th param
// BEW 29Aug11, there are now two versions of this function which differ only by name:
// DoConsistencyCheck() handles adapting mode, DoConsistencyCheckG() handles glossing mode
// BEW refactored 14Sep11, a difficult thing to grasp is the need to distinguish between
// pTU and pRefStr pointers belonging to the two different KBs passed in; we do diagnosis
// of errors in pKBCopy, but primarily make KB adjustments (which are passive while the
// checking is in progress) in just pKB; however, forcing change to <Not In KB> or
// removing a <Not In KB> designation violates this convention somewhat, because these two
// kinds of operation have to be, once made, enforced there after - and so the diagnosis
// is done in pKB, but enforcing the change(s) is done in pKBCopy as well, and passively
// also in pKB. If pKBCopy isn't changed for these kinds of change, we can't enforce that
// new document locations be synced to what should be set by comparing the earlier state
// IN THE SAME KB (ie. in pKBCopy). Therefore, we maintain
// pTU, and pRefStr, as pertaining only to the pKBCopy knowledge base instance
// but pTU_OnOrig, and pRefStr_OnOrig, for pKB's knowledge base instance
// BEW 2Nov12, fixed logic error, I'd failed to set pAutoFixRec->finalAdaptation in many
// places, resulting in the doc's adaptation getting lost.
// BEW note added 20Feb12: pCopyKB is temporary, for finding glitches, pKB is permanent,
// and changes are added within it - and so there are pKB->StoreText() calls; we allow
// kbserver support to apply to these calls, if KB sharing is turned on, and so we don't
// make use of gbConsistencyCheckCurrent to either enable or disable KB sharing during a
// consistency check. Instead, if KB sharing is ON, it continues to be on during any
// consistency check, and should fire off threads as needed, and those firings should
// therefore be well motivated firings since the KB changes are those which are wanted by
// the user. (The only pCopyKB->StoreText() calls are for support of <Not In KB> and we
// don't care about those because <Not In KB> entries are not sent to the remote kbserver.)
// BEW 23Apr15 added support for / used as a word-breaking whitespace character (in 8 places)
// BEW 1Sep15 added support for a "blind fix" checkbox option that automatically, if chosen,
// causes the location's adaptation where an inconsistency has been identified to get the
// KB's CTargetUnit's CRefString instances translation, but only provided that translation
// string (which may be an adaptation, or in DoConsistencyCheckG, a gloss) is the only
// valid entry for that CTargetUnit instance (i.e. there could be one or more pseudo-deleted
// entries, but they won't be considered; but there can only be one non-deleted entry; otherwise
// the dialog will show in the usual way)

// mrh 18Apr19 - IsAlreadyInKB() now returns a non-NULL pTU if the key search succeeds, there's no matching
// target string, but there IS a non-deleted entry.  It returns the new bool bNonDeletedNonmatch TRUE for
// this situation, and we handle it in the same block where we handle the case of matching target string
// which is deleted, but a non-deleted entry exists.  These are very similar and we should handle them the
// same way.

bool CAdapt_ItDoc::DoConsistencyCheck(CAdapt_ItApp* pApp, CKB* pKB, CKB* pKBCopy,
	AFList& afList, int& nCumulativeTotal, wxArrayString& arrSetNotInKB,
	wxArrayString& arrRemoveNotInKB)
{
	wxASSERT(pKB->IsThisAGlossingKB() == FALSE); // must be an adaptation kb for this fn version

	gbConsistencyCheckCurrent = TRUE;	// turn on Flag to inhibit placement of phrase box
										// initially when OnOpenDocument() is called
										//  like when doing a consistency check.
	CLayout* pLayout = GetLayout();
	wxASSERT(pApp != NULL);
	wxArrayString* pList = &pApp->m_acceptedFilesList;
	int nCount = pList->GetCount();
	wxString strNotInKB = pApp->m_strNotInKB;
	wxString emptyStr = _T("");
	if (nCount <= 0)
	{
		// BEW 8Julyl0, book mode is on and we are iterating through Bible book folders,
		// many of which may have no files in them yet. So we must allow for GetCount() to
		// return 0 and if so we return silently, and the loop will go on to the next
		// folder
		gbConsistencyCheckCurrent = FALSE;	// restore normal default

		return TRUE;
	}

	CStatusBar* pStatusBar = NULL;
	pStatusBar = (CStatusBar*)gpApp->GetMainFrame()->m_pStatusBar;
	pStatusBar->StartProgress(_("Consistency Check"), _("Starting Consistency Check"), nCount);

	wxASSERT(nCount > 0);
	int nTotal = 0;
	bool bBlindFix = pApp->m_bBlindFixInConsCheck;      // a nice short synonym is helpful

	bool        bUserCancelled = FALSE;                 // whm note: Caution: This bUserCancelled overrides the scope
														// of the extern global of the same name
	wxString    bookCode;
	wxString    bookName;
	wxString    chapterName;

	// mrh - If we're collaborating, We'll be changing the App variables for these during the loop, and we'll restore them at the end.
	wxString    original_bookName = pApp->m_CollabBookSelected;
	wxString    original_chapterName = pApp->m_CollabChapterSelected;

	// Also we set the flags for inconsistency resolution all FALSE, so the CConflictResActionDlg will be shown and the user can
	// make a choice for the whole consistency run:
	pApp->m_bRetainPTorBEversion = FALSE;
	pApp->m_bForceAIversion = FALSE;
	pApp->m_bUseConflictResolutionDlg = FALSE;

	bool        bOK;


	//  ****************************  iteration over the document files  ******************************

	int i;
	for (i = 0; i < nCount; i++)
	{
		wxString newName = pList->Item(i);
		wxASSERT(!newName.IsEmpty());

		//#ifdef CONSCHK
//		wxLogDebug(_T("\n\n  *** CHECKING FILE       %s\n\n"), newName.c_str());
		//#endif
				// for debugging- check pile count before & after (failure to close doc before
				// calling this function resulted in the following OnOpenDocument() call appending
				// a copy of the document's contents to itself -- the fix is to ensure
				// OnFileClose() is done in the caller before DoConsistencyCheck() is called
				// int piles = pApp->m_pSourcePhrases->GetCount();

		bOK = OnOpenDocument(newName, false);       // passing in just a filename, so we are relying
													// on the working directory having previously
													// being set in the caller at the call of
													// EnumerateDocFiles()
		wxCHECK_MSG(bOK, FALSE, _T("DoConsistencyCheck(): OnOpenDocument() failed, line 23796 in Adapt_itDoc.cpp, so check was aborted"));

		if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
		{                                           // mrh May19 - with collaboration, we need to update the App's variables for the current
													// file, so we access the PT/BE data properly
			bookCode = Get_bookCode_from_filename(newName);
			bookName = Get_bookname_from_filename(newName);
			chapterName = Get_chapter_from_filename(newName);

			pApp->m_CollabBookSelected = bookName;
			pApp->m_CollabChapterSelected = chapterName;

			Get_collaboration_text_for_consistency_check(pApp);     // and we also store the pre-edit text ready for export at the end of the loop
		}

		// update the progress bar
		wxString msg;
		msg = msg.Format(_("Checking: %s (file %d of %d)"), newName.c_str(), i, nCount);
		pStatusBar->UpdateProgress(_("Consistency Check"), i, msg);

		SetFilename(newName, TRUE);
		nTotal = pApp->m_pSourcePhrases->GetCount();
		if (nTotal == 0)
		{
			wxString str;
			str = str.Format(_T("Bad file:  %s"), newName.c_str());
			wxMessageBox(str, _T(""), wxICON_EXCLAMATION | wxOK);
		}
		nCumulativeTotal += nTotal;

		// for each document opened, get the KB entry for the current active location
		// updated so as to avoid a spurious inconsistency
		bool bNoStore = FALSE;
		bool bAttemptStoreToKB = TRUE;
		bool bSuppressWarningOnStoreKBFailure = TRUE;


		// BEW 30Jul16 Move active location now to sn = 0, because if the active location happened to
		// have been at an inconsistency, the following UpdateDoc....() call will put a single instance of
		// the inconsistency into the KB, and if it had been deliberately removed in order to allow
		// splitting the meaning, or correcting a typo occurring in many places, those inconsistencies
		// would not be recognised for what they are. So safest place is to have the active location
		// at the start - it's typically the Book Code's CSourcePhrase. ReOpenDocument() will eventually
		// restore the original doc and its state, using the sequ number from the xml
		CSourcePhrase* pSrcPhrase = NULL;
		pApp->m_nActiveSequNum = 0;
		pApp->m_pActivePile = pApp->GetView()->GetPile(0);
		pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

		// BEW 9Aug11, in the call below, param1 TRUE is bArremptStoreToKB, param2 bNoStore
		// returns TRUE to the caller if the attempted store fails for some reason, for all
		// other circumstances it returns FALSE, and param3 bSuppressWarningOnStoreKBFailure
		// is TRUE as we don't expect a failure and will ignore it if it does anyway;
		UpdateDocWithPhraseBoxContents(bAttemptStoreToKB, bNoStore, bSuppressWarningOnStoreKBFailure);

		// prepare for the loop with various initializations
		enum InconsistencyType inconsistencyType = member_exists_flag_on_PTUexists_deleted_Refstr;
		pSrcPhrase = NULL;
		int nWords;
		// for the IsAlreadyInKB() test, we pass in pSrcPhrase->adaption

		// We also have to do some of the tests in parallel on both KBs, so that we get
		// CTargetUnit and CRefString pointers in parallel from both KBs' entries when we
		// need to make parallel changes to both KBs. Slows the check, but unavoidable
		bool bIsInKB = FALSE;
		bool bIsInKB_OnOrig = FALSE;

		// These bools pertain to pKBCopy and pKB, respectively
		bool bDeleted = FALSE;
		bool bNonDeletedNonmatch = FALSE;
		bool bDeleted_OnOrig = FALSE;
		bool bNonDeletedNonmatch_OnOrig = FALSE;

		// these two, for CTargetUnit and CRefString ptrs within pKBCopy
		CTargetUnit* pTU = NULL;
		CRefString* pRefStr = NULL;
		// these two, for CTargetUnit and CRefString ptrs within pKB
		CTargetUnit* pTU_OnOrig = NULL;
		CRefString* pRefStr_OnOrig = NULL;
		// we may need two flags here too
		bool bFoundTgtUnit = FALSE;
		//bool bFoundTgtUnit_OnOrig = FALSE;

		bool bAddedToAFList = FALSE;
		wxString adaption; // scratch string for holding m_adaption's value
		wxString key; // scratch string for holding m_key's value (unadjusted for caps)
		wxString autoCapsKey; // whatever key becomes after any auto-caps adjustment is done
		bool bInconsistency = FALSE;
		AutoFixRecord* pAutoFixRec = NULL;

		SPList* pPhrases = pApp->m_pSourcePhrases;
		SPList::Node* pos_pPhrases;
		pos_pPhrases = pPhrases->GetFirst();
		wxASSERT(pos_pPhrases != NULL);
		int counter = 0;
		// loop over all CSourcePhrase instances in the m_pSourcePhrases list
		// NOTE: in this loop, I'll have as many inconsistencies as possible fixed without
		// having to put up a dialog; for these I'll still set the local inconsistencyType
		// enum variable even though it is thrown away without use. I do this in case I
		// later change my mind and want to code differently - as thinking of what enum
		// variable fits a given situation takes time and energy, and I don't want to have
		// to do that thinking more than once

		while (pos_pPhrases != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos_pPhrases->GetData();
			key = pSrcPhrase->m_key;
			adaption = pSrcPhrase->m_adaption; // could be an empty string
			pos_pPhrases = pos_pPhrases->GetNext();
			counter++;

			pApp->nCount_NonDeleted = -1; // initialized to suit a pTU 'not found' result

			// BEW added 23May16, to fix Mike's problem of lots of legacy upper-case-initial
			// source text words & phrases in the KB causing lots of bogus inconsistencies
			// when auto-capitalizing is ON. We want those just to be ignored
			int numSrcTextWords = pSrcPhrase->m_nSrcWords;
			bool bIgnoreLegacyOne = FALSE;
			if (gbAutoCaps)
			{
				// pass in key 'as is', with no case adjustment
				bIgnoreLegacyOne = pKBCopy->IgnoreLegacyUpperCaseEntry(pKBCopy, numSrcTextWords, key);
				if (bIgnoreLegacyOne)
					continue;
			}

			bFoundTgtUnit = FALSE;

			// ignore placeholders and retranslations
			if (pSrcPhrase->m_bNullSourcePhrase || pSrcPhrase->m_bRetranslation)
			{
				if (pSrcPhrase->m_bNullSourcePhrase)
				{
					pSrcPhrase->m_bNotInKB = FALSE; // ensure its off
				}
				continue;
			}

			// BEW 26Aug11 added flag, because testing whether a pTU or pRefString is not
			// found is not an adequate test - not every potential key needs to have a KB
			// presence
			bInconsistency = FALSE;
			pAutoFixRec = NULL;
			bAddedToAFList = FALSE; // set TRUE if a created AutoFixRecord is
									// Append()-ed to the passed in afList

			// check the KBCopy has the required association of key with translation
			// BEW 13Nov10, changes to support Bob Eaton's request for glosssing KB to use all maps
			nWords = pSrcPhrase->m_nSrcWords;
			pTU = NULL;
			pTU_OnOrig = NULL;
			pRefStr = NULL;
			pRefStr_OnOrig = NULL;
			bDeleted = FALSE;
			bDeleted_OnOrig = FALSE;

			// Does key have an entry (that is, a ptr to CTargetUnit, and a CRefString
			// within it which has a non-deleted string in its m_translation member which
			// matches the passed in adaption parameter's contents) in the copied adaptation
			// KB's map? (Note, this is not a test for a non-NULL pTU, it tests all the
			// way to the adaptation contents, returning TRUE only when that matches. To
			// test only for a pTU matching the key value, instead use AutoCapsLookup() )

			bIsInKB = pKBCopy->IsAlreadyInKB(nWords, key, adaption, pTU, pRefStr, bDeleted, bNonDeletedNonmatch);
			bIsInKB_OnOrig = pKB->IsAlreadyInKB(nWords, key, adaption, pTU_OnOrig, pRefStr_OnOrig, bDeleted_OnOrig, bNonDeletedNonmatch_OnOrig);

			bIsInKB_OnOrig = bIsInKB_OnOrig; // avoid warning
#ifdef CONSCHK2
//			wxLogDebug(_T("CONSCHK2: key = %s, adaption = %s, sn = %d, active sn = %d"),
//				key.c_str(), adaption.c_str(), pSrcPhrase->m_nSequNumber, gpApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber);
#endif
			// While <Not In KB> entries are expected to be rare or absent, if present
			// they are dominant - that is, if a given source text word or phrase is
			// declared to never have a KB presence, then everywhere in every document
			// that source text word needs to be made <Not In KB>. Setting it so is done
			// at one location in oneS document typically, so it is up to the Consistency
			// Check to get all other places it occurs compliant; and if a former <Not In
			// KB> entry is declared to be no longer such for a given source text word or
			// phrase, it is also our job here to enforce this decision everywhere - which
			// typically means giving "deleted" status to the CRefString storing the
			// <Not In KB> string, and undeleting the CRefString (if present) of the adaptation
			// corresponding to the source text word. To do these jobs, we have to collect
			// entries where there are, for locations in the docs, non-deleted and
			// deleted <Not In KB> entries in the KB, and store these source text words in
			// separate arrays which must persist for the whole Consistency Check.
			// Since we will know whether a pTU exists for this pSrcPhrase, we will use
			// the test functions in the CTargetUnit class rather than the equivalent in
			// the CKB class, for speed. Be careful to distinguish between what belongs to
			// pKB and what belongs to pKBCopy!!

			if (pTU != NULL)
			{
				// The first subtext checks for the pTU storing a <Not In KB> entry
				if (pTU->IsItNotInKB() && pSrcPhrase->m_bNotInKB && !pSrcPhrase->m_bHasKBEntry)
				{
					// we can't collect what might be inconsistencies, so the two boolean
					// flags, pSrcPhrase->m_bNotInKB and pSrcPhrase->m_bHasKBEntry, have to
					// be included in the test so that we know we are collecting from a
					// location in the doc where there is no inconsistency
#ifdef CONSCHK
					int beforeCount = arrSetNotInKB.GetCount();
#endif
					AddUniqueString(&arrSetNotInKB, key);
					pTU->ValidateNotInKB(); // ensure all non-<Not In KB> are deleted, since
											// it's a 'no inconsistency' location, then iterate
					pTU_OnOrig->ValidateNotInKB(); // must do in pKB's CTargetUnit ptr too
#ifdef CONSCHK
					int afterCount = arrSetNotInKB.GetCount();
//					if (afterCount > beforeCount)
//						wxLogDebug(_T("*1. Added arrSetNotInKB entry:  at sn = %d , m_key:  %s   (m_adaption:  %s)  count = %d"),
//							pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str(), afterCount);
					ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
					continue;
				}
				// do similarly for arrRemoveNotInKB if a deleted <Not In KB> is in pTU (we
				// also require m_bHasKBEntry to be set TRUE, which exludes pSrcPhrase
				// instances where the phrase box has never yet been, and so there
				// couldn't be a <Not In KB> entry there in the past anyway)
				if (pTU->IsDeletedNotInKB() && !pSrcPhrase->m_bNotInKB && pSrcPhrase->m_bHasKBEntry)
				{
					// we can't collect what might be inconsistencies, so the two boolean
					// flags have to be included in the above test so that we know were are
					// collecting from a location in the doc where there is no inconsistency
#ifdef CONSCHK
					int beforeCount = arrSetNotInKB.GetCount();
#endif
					AddUniqueString(&arrRemoveNotInKB, key);
					// since it's a 'no inconsistency' location, iterate
#ifdef CONSCHK
					int afterCount = arrRemoveNotInKB.GetCount();
//					if (afterCount > beforeCount)
//						wxLogDebug(_T("*2. Added arrRemoveNotInKB entry:  at sn = %d , m_key:  %s   (m_adaption:  %s)  count = %d"),
//							pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str(), afterCount);
					ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
					continue;
				}
			} // end of TRUE block for test: if (pTU != NULL)

			// In the following block, we must test if the source word or phrase belongs
			// to either array, arrSetNotInKB or arrRemoveNotInKB (and remember, the
			// contents of these arrays were gathered only from valid entries, and / or
			// user choices about what is valid, so these must dominate the consistency
			// issue at the current location), and do whatever is appropriate; the
			// diagnostic test must be done in pKBCopy, but parallel changes made in pKB
			// too (because otherwise pKB wouldn't get the updates it needs from this process)

			// Start with those which require setting <Not In KB>
			bool bMakeNotInKB = FALSE;
			if (gbAutoCaps)
			{
				// FALSE is for a caseless search (i.e. a and A are considered the same)
				bMakeNotInKB = arrSetNotInKB.Index(key, FALSE) != wxNOT_FOUND;
			}
			else
			{
				// bCase is default TRUE, for a case-sensitive search (i.e. a and A are different)
				bMakeNotInKB = arrSetNotInKB.Index(key) != wxNOT_FOUND;
			}
			if (bMakeNotInKB)
			{
				// found; so the current pSrcPhrase has to be made into a <Not In KB> one -
				// we retain any adaptation; if it already is one, no harm is done; if
				// there is no adaptation yet and m_bHasKBEntry is FALSE, still do it even
				// if it's a "hole"
#ifdef CONSCHK
				int beforeCount = arrSetNotInKB.GetCount();
//				wxLogDebug(_T("*3. adaption before forcing:  %s"), pSrcPhrase->m_adaption.c_str());
#endif
				if (pTU != NULL)
				{
					pTU->DeleteAllToPrepareForNotInKB();
				}
				if (pTU_OnOrig != NULL)
				{
					pTU_OnOrig->DeleteAllToPrepareForNotInKB();
				}
				pKBCopy->StoreText(pSrcPhrase, strNotInKB); // no need to support <no adaptation> for this store
				pKB->StoreText(pSrcPhrase, strNotInKB); // no need to support <no adaptation> for this store
				//pSrcPhrase->m_bHasKBEntry = FALSE;
				//pSrcPhrase->m_bNotInKB = TRUE;
#ifdef CONSCHK
				int afterCount = arrSetNotInKB.GetCount();
//				if (afterCount >= beforeCount)
//					wxLogDebug(_T("*3. Found in arrSetNotInKB entry:  forcing <Not In KB> at sn = %d , m_key:  %s   (m_adaption:  %s)  count = %d)"),
//						pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str(), afterCount);
				ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
				continue;
			}

			bool bUnmakeNotInKB = FALSE;
			if (gbAutoCaps)
			{
				// FALSE is for a caseless search (i.e. a and A are considered the same)
				bUnmakeNotInKB = arrRemoveNotInKB.Index(key, FALSE) != wxNOT_FOUND;
			}
			else
			{
				// bCase is default TRUE, for a case-sensitive search (i.e. a and A are different)
				bUnmakeNotInKB = arrRemoveNotInKB.Index(key) != wxNOT_FOUND;
			}
			if (bUnmakeNotInKB)
			{
				// Found a valid 'deleted' one, so we ensure this location has a valid
				// normal entry; we need param TRUE if we do the StoreText() call because
				// this m_adaption value could be empty. Here it is NOT appropriate to do a
				// store if m_adaption is empty and m_bHasKBEntry is FALSE, as "holes"
				// should not have storage in the KB done before the phrase box has been
				// there. BEW 6Nov12, removed test for non-empty m_adaption here, because
				// this fix needs to be done whether it's empty or not, provided
				// m_bNotInKB is TRUE
				if (pSrcPhrase->m_bNotInKB)
				{
					// Try to undelete it, provided there is a pTU instance in the KB copy
					// for here
					if (pTU != NULL)
					{
						// assume that when pTU is not NULL, so too will be pTU_OnOrig
						wxASSERT(pTU_OnOrig != NULL);
#ifdef CONSCHK
						int beforeCount = arrRemoveNotInKB.GetCount();
//						wxLogDebug(_T("*4. adaption before undeleting:  %s"), pSrcPhrase->m_adaption.c_str());
#endif
						bool bSuccess = pKBCopy->UndeleteNormalEntryAndDeleteNotInKB(pSrcPhrase,
							pTU, pSrcPhrase->m_adaption);
						bool bSuccess_OnOrig = pKB->UndeleteNormalEntryAndDeleteNotInKB(pSrcPhrase,
							pTU_OnOrig, pSrcPhrase->m_adaption);
						if (!bSuccess)
						{
							// there wasn't a deleted CRefString which was successfully
							// undeleted, so a StoreText() call is required here...
							// this may actually rectify an inconsistency which, if this
							// were not done, would be picked up in the code further below
							pApp->m_bInhibitMakeTargetStringCall = TRUE;
							pKBCopy->StoreText(pSrcPhrase, pSrcPhrase->m_adaption, TRUE);
							if (!bSuccess_OnOrig)
							{
								pKB->StoreText(pSrcPhrase, pSrcPhrase->m_adaption, TRUE);
							}
							pApp->m_bInhibitMakeTargetStringCall = TRUE;
#ifdef CONSCHK
							int afterCount = arrRemoveNotInKB.GetCount();
//							if (afterCount >= beforeCount)
//								wxLogDebug(_T("*4. Found in arrRemoveNotInKB entry:  removed <Not In KB> at sn = %d , m_key:  %s   (stored the m_adaption:  %s)  count = %d"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str(), afterCount);
							ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
							//pSrcPhrase->m_bHasKBEntry = TRUE;
							//pSrcPhrase->m_bNotInKB = FALSE;
							continue;
						}
						else
						{
							// no StoreText() call is needed, because an undelete was done
							// (and we assume the pKB one similarly succeeded)
							//wxASSERT(bSuccess);
#ifdef CONSCHK
							int afterCount = arrRemoveNotInKB.GetCount();
//							if (afterCount >= beforeCount)
//								wxLogDebug(_T("*5. Found in arrRemoveNotInKB entry:  removed <Not In KB> at sn = %d , m_key:  %s   (undeleted the m_adaption:  %s)  count = %d"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str(), afterCount);
							ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
							// no StoreText() call, so explicitly ensure the flags are
							// correct here
							pSrcPhrase->m_bHasKBEntry = TRUE;
							pSrcPhrase->m_bNotInKB = FALSE;
							continue;
						}
					}
				}
			} // end of TRUE block for test: if (bUnmakeNotInKB)

			// do any inconsistencies which remain
			if (bIsInKB)
			{
				// The adaptation at the location of the key passed to pKBCopy->IsAlreadyInKB()
				// already exists within the pKBCopy knowledge base, and is not pseudo-deleted
				if (pTU != NULL)
				{
					bFoundTgtUnit = TRUE;
				}

				if (pSrcPhrase->m_bHasKBEntry)
				{
					// there is a non-deleted adaption entry in the copied KB for the
					// passed in key; if pSrcPhrase has m_bHasKBEntry set TRUE, and it is
					// not deleted in the KB, this is consistent, so iterate
					wxASSERT(!bDeleted);
					// ensure m_bNotInKB is FALSE, both flags must never be true together
					pSrcPhrase->m_bNotInKB = FALSE;
					if (pTU != NULL && pTU->IsDeletedNotInKB())
					{
						// if there is a deleted <Not In KB> entry for this key in pKBCopy,
						// add it to the array so that subsquent same key values will
						// enforce consistency in pKB
						AddUniqueString(&arrRemoveNotInKB, key);
						// (no need to do it also for pKB, because we maintain only lists
						// done from diagnosis within pKBCopy's knowledge base)
#ifdef CONSCHK
						ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
					}
					continue;
				}
				else
				{
					// m_adaption is in the pKBCopy for this key; but
					// pSrcPhrase->m_bHasKBEntry is FALSE, so we might have an
					// inconsistency...

					// we might be in an unadapted part of the document, where there is no
					// adaptation as yet and so m_bHasKBEntry would be FALSE, and fortuitously
					// we matched in pKBCopy a source text key that earlier was given a
					// <no adaptation> adaptation which resulted in an empty string for the
					// pTU's CRefString::translation member -- this situation isn't an
					// inconsistency, so check for this and iterate if so
					if (adaption.IsEmpty())
					{
						// it might just be an unadapted "hole", or a <Not In KB> location
						// - either of which would not be inconsistencies; in the latter
						// case we have to check that the KB has a non-deleted <Not In KB>
						// here, and that the relevant flag on the doc is set TRUE, etc
						if (pSrcPhrase->m_bNotInKB == FALSE)
						{
							// it was an empty string match of a "hole" in the document, so
							// no inconsistency here
							continue;
						}
						else
						{
							// pSrcPhrase->m_bNotInKB is TRUE, so check if <Not In KB> is
							// in the KB's matched CRefString instance -- we'd get here if
							// the relevant doc flags were m_bHasKBEntry = TRUE (for the
							// empty adaptation) and also m_bNotInKB = TRUE -- an inconsistency
							// (we know pTU exists, so no need to protect with a test here)
							if (pTU->IsItNotInKB())
							{
								bool bOrigToo = FALSE;
								if (pTU_OnOrig != NULL)
								{
									bOrigToo = pTU_OnOrig->IsItNotInKB();
								}

								// this can be healed without calling a dialog, the
								// <NotIn KB> has priority
								AddUniqueString(&arrSetNotInKB, key);

								pTU->ValidateNotInKB(); // ensure all non-<Not In KB> are deleted
								if (bOrigToo)
								{
									pTU_OnOrig->ValidateNotInKB(); // do the same in the original KB too
								}

								pSrcPhrase->m_bHasKBEntry = FALSE;
								pSrcPhrase->m_bNotInKB = TRUE;
#ifdef CONSCHK
//								wxLogDebug(_T("1. No GUI, inconsistency:  preferred <Not In KB> at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
								ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
								continue;
							}
						} // end of else block for test: if (pSrcPhrase->m_bNotInKB == FALSE)
					} // end of TRUE block for test: if (adaption.IsEmpty())
					else
					{
						// m_adaption is in the KB, m_bHasKBEntry is FALSE, but
						// pSrcPhrase->m_adaption is not an empty string; this is an
						// inconsistency which we can auto-correct here & now by setting
						// the flag to agree with the KB entry, no GUI needed for this -
						// provided there is no <Not In KB> lurking in the pKBCopy's entry
						if (pTU->IsItNotInKB())
						{
							// it is, so pTU_OnOrig likewise should be the same
							bool bOrigToo = FALSE;
							if (pTU_OnOrig != NULL)
							{
								bOrigToo = pTU_OnOrig->IsItNotInKB();
							}

							// this can be healed without calling a dialog, the
							// <Not In KB> has priority
							AddUniqueString(&arrSetNotInKB, key);

							pTU->ValidateNotInKB(); // ensure all non-<Not In KB> are deleted
							if (bOrigToo)
							{
								pTU_OnOrig->ValidateNotInKB(); // do pKB's too
							}
							pSrcPhrase->m_bNotInKB = TRUE;
#ifdef CONSCHK
//							wxLogDebug(_T("2. No GUI, inconsistency:  preferred <Not In KB> at sn = %d , m_key:  %s   m_adaption:  %s"),
//							pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
							ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
							continue;
						}
						else
						{
							// nothing to be done in either pKB or pKBCopy
							pSrcPhrase->m_bHasKBEntry = TRUE; // fixed it
#ifdef CONSCHK
//							wxLogDebug(_T("3. No GUI  m_bHasKBEntry set TRUE  at sn = %d , m_key:  %s   m_adaption:  %s"),
//								pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							continue;
						}
					} // end of else block for test: if (adaption.IsEmpty())

				} // end of else block for test: if (pSrcPhrase->m_bHasKBEntry)

			} // end of TRUE block for test: if (bIsInKB)
			else
			{
				// lookup determined that there was no adaption string matched with the
				// given key value in the KB, but that could be for a variety of reasons,
				// including
				// (1) the KB adaption value was deleted (it might have been done
				// deliberately in the KB editor by the user, in order to force the option
				// to split a meaning into different meanings at different locations
				// during this consistency check) -- this is an important feature, and
				// we'll deal with it below first, it's also what the legacy dialog was
				// mostly about, but a redesign of that is called for here
				// (2) pTU exists but the expected pRefStr it should contain isn't there
				// BEW 1Sep15, added support for the user editing the one and only KB translation
				// or gloss, and then wanting an auto-fix (done blindly) to get the docs to
				// update to the new adaptation or gloss without a dialog being shown.
				// (3) pTU matching the key value was expected to exist but doesn't
				// (4) no pTU exists because the source text key has not hitherto been
				// encountered when adapting, and so this location is a "hole" -- this
				// situation isn't an inconsistency (and the lack of pTU means that no
				// <Not In KB> entry, deleted or not, can be in the KB for this key yet) -
				// so we check for (4) first, because if that is not the case, then we've
				// got an inconsistency to fix.
				// For some of these auto-fixing is possible, but where options exist the
				// user will need to be asked...

				if (!bInconsistency)
				{
					// bIsInKB is FALSE, test for a "hole" (& iterate if so, as it would
					// not be an inconsistency) -- doing as for (4) above
					if (pSrcPhrase->m_adaption.IsEmpty() && pTU == NULL && !pSrcPhrase->m_bHasKBEntry)
					{
						// this is a hole, no inconsistency here
						continue;
					}

					// we've handled all possibilities for <Not In KB> inconsistencies, the rest
					// below are for adaptation inconsistencies -- whether empty or not

										/* see the one after this, we prefer the "split adaptation" support, rather than this one
										// keep this in case we later change our mind...

										if (pTU != NULL && pRefStr != NULL && pSrcPhrase->m_adaption.IsEmpty() &&
											pSrcPhrase->m_bHasKBEntry && bDeleted)
										{
											bFoundTgtUnit = TRUE;
											wxASSERT(pTU_OnOrig != NULL && pRefStr_OnOrig == NULL && bDeleted_OnOrig);
											bFoundTgtUnit_OnOrig = TRUE;

											// This is an inconsistency. The CTargetUnit and CRefString exist, and
											// pRefStr returns non-NULL but the latter's m_bDeleted flag is TRUE, -
											// which shouldn't be the case if the doc's m_bHasKBEntry flag is TRUE.
											// There are 3 possibilies,
											// a) it should be a <no adaptation> entry (so undelete it), or
											// b) honour the deletion, and so set m_bHasKBEntry to FALSE, leaving
											// a "hole" in the document here, or
											// c) this src text shouldn't ever have a KB entry (so make it a <Not
											// In KB> entry. The dialog for
											bInconsistency = TRUE;
											inconsistencyType = member_empty_flag_on_PTUexists_deleted_Refstr;
											pAutoFixRec = new AutoFixRecord;
											pAutoFixRec->nWords = nWords;
											pAutoFixRec->key = key;
											pAutoFixRec->oldAdaptation = adaption;
											pAutoFixRec->finalAdaptation = adaption; // initialize to this value
											pAutoFixRec->incType = inconsistencyType;
											pAutoFixRec->fixAction = no_GUI_needed; // a default value
												// until such time as the dialog is shown and the user's
												// fixit choice becomes known & replaces this value

											// the dialog for this one is ConsChk_Empty_noTU_Dlg
										}
										*/
										// Lots of checks to do here -- we continue to use the m_adaption lookup above

										// remember, in the stuff below, pTU and pRefStr are in the pKBCopy
										// kb, not the pKB original; for the latter we use pTU_OnOrig, or pKB
										// itself, in our fixes (but not when diagnosing)
					if (pTU != NULL && pRefStr != NULL && pSrcPhrase->m_adaption.IsEmpty() &&
						pSrcPhrase->m_bHasKBEntry && bDeleted)
					{
						bFoundTgtUnit = TRUE;

						// This is an inconsistency. The CTargetUnit and CRefString exist, and
						// pRefStr is non-NULL but the latter's m_bDeleted flag is TRUE, -
						// which shouldn't be the case if the doc's m_bHasKBEntry flag is
						// TRUE, and the adaptation is an empty string.
						// There are 4 possibilies,
						// a) it should be a <no adaptation> entry (so undelete it), or
						// b) honour the deletion, and so set m_bHasKBEntry to FALSE, leaving
						// a "hole" in the document here, or
						// c) this src text shouldn't ever have a KB entry (it should be a
						// <Not In KB> entry, or
						// d) the user wants to "split" an empty adaptation to be different in
						// some locations in the document (ie. non-empty)

						// NOTE -- supporting d) is incompatible with supporting b) and c) if
						// we stick with just 3 dialogs; if we supported b) and c) we'd use
						// the ConsChk_Empty_noTU_Dlg.h & .cpp, which gives no support to
						// splitting the meaning; if we support splitting the meaning, then we
						// would use the revamped legacy ConsistencyCheckDlg.h & .cpp. To
						// support all 4 options here would require complicating the latter
						// dialog, or defining a fourth (similar) dialog combining what is in
						// the latter with what is in the former - and this we won't do. The
						// ability to split the meaning is more likely to be useful in real
						// situations than b) and c); so we support the revamped legacy dialog
						// here - which allows the user to at least have a <no adaptation>
						// entry put in the KB if he elects to leave the top right box empty.
						bInconsistency = TRUE;
						inconsistencyType = member_empty_flag_on_PTUexists_deleted_Refstr;
						pAutoFixRec = new AutoFixRecord;
						pAutoFixRec->nWords = nWords;
						pAutoFixRec->key = key;
						pAutoFixRec->oldAdaptation = adaption;
						pAutoFixRec->finalAdaptation = adaption; // BEW 2Nov12 initialize to this value
						pAutoFixRec->incType = inconsistencyType;
						pAutoFixRec->fixAction = no_GUI_needed; // a default value
							// until such time as the dialog is shown and the user's
							// fixit choice becomes known & replaces this value
#ifdef CONSCHK
//						wxLogDebug(_T("4. for DLG  member_empty_flag_on_PTUexists_deleted_Refstr (revamped legacy)  at sn = %d , m_key:  %s   m_adaption:  %s"),
//							pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
						// dialog for this we choose to be the revamped legacy ConsistencyCheckDlg.h
						// &.cpp (this excludes two low probability possibilities - see the Note just
						// above)
					}


					// mrh - revision here. If bNonDeletedNonmatch is TRUE, we execute the block:

					else if (pSrcPhrase->m_bHasKBEntry && pTU != NULL && pRefStr != NULL && (bDeleted || bNonDeletedNonmatch))
					{
						bFoundTgtUnit = TRUE;

						// This is the 'split adaptation' case - the only options are to
						// undelete, or to give a different adaptation (contextually
						// defined by the user eye-balling the document to figure out what
						// other adaptation is appropriate at the active location rather
						// than the one shown in the phrase box), or type something
						// different or do an edit of something shown in the list of
						// adaptations, or ignore the location entirely.
						// BEW 1Sep15, the deletion could be because the user edited the KB
						// target text, which also then makes the unedited form become
						// pseudo-deleted. Mike Hore wants these auto-fixed blindly if there
						// is only a single (unique) form associated with the source text form
						// - so we do that here, provided bBlindFix is TRUE
						if (bBlindFix)
						{
							// First, check to make sure there is but a single translation
							wxString newAdaption = _T("");
							bool bIsUnique = pKBCopy->GetUniqueTranslation(nWords, key, newAdaption);
							if (bIsUnique)
							{
								//		wxASSERT(pApp->nCount_NonDeleted == 1 -- it's usually 1 but I think not always
//								wxLogDebug("# nondeleted = %d  - newAdaption = %s", pApp->nCount_NonDeleted, newAdaption);

								// Blind fix this one, do a StoreText() on pKB, then iterate the loop
								pSrcPhrase->m_adaption = newAdaption; // StoreText() will do
															// this, but no harm to do it here
								// Get the punctuation, if any, correctly restored
								pApp->GetView()->MakeTargetStringIncludingPunctuation(pSrcPhrase, newAdaption);

								//#if defined(FWD_SLASH_DELIM)
																// BEW added 23Apr15, in case there is a merger
								pSrcPhrase->m_adaption = FwdSlashtoZWSP(pSrcPhrase->m_adaption);
								pSrcPhrase->m_targetStr = FwdSlashtoZWSP(pSrcPhrase->m_targetStr);
								//#endif
																// TRUE in StoreText call is support for a <no adaptation> empty
																// string; if has effect only if newAdaption is empty
								pApp->m_bInhibitMakeTargetStringCall = TRUE;
								pKB->StoreText(pSrcPhrase, pSrcPhrase->m_adaption, TRUE);
								pApp->m_bInhibitMakeTargetStringCall = FALSE;

								// check if it has also a non-deleted <Not In KB>
								// CRefString in pTU, if so, it would be inconsistent to
								// leave it undeleted
								// And since we have installed a replacement adaptation,
								// pSrcPhrase->m_bHasKbEntry will already be TRUE
								if (pTU_OnOrig != NULL)
								{
									if (pTU_OnOrig->IsItNotInKB())
									{
										pTU_OnOrig->DeleteOnlyNotInKB();
										pSrcPhrase->m_bNotInKB = FALSE; // ensure it is OFF
									}
								}

								continue;
							}
						}  // end TRUE block for test: if (bBlindFix)

						// If bBlindFix was not chosen in the cons.chk.type dialog, then
						// do the legacy showing of the consistency check dialog
						if (pApp->nCount_NonDeleted < 1)
						{
							bInconsistency = TRUE;
							inconsistencyType = member_exists_flag_on_PTUexists_deleted_Refstr;
							pAutoFixRec = new AutoFixRecord;
							pAutoFixRec->nWords = nWords;
							pAutoFixRec->key = key;
							pAutoFixRec->oldAdaptation = adaption;
							pAutoFixRec->finalAdaptation = adaption; // BEW 2nov12 initialize to this value
							pAutoFixRec->incType = inconsistencyType;
							pAutoFixRec->fixAction = store_nonempty_meaning;
						}
						// BEW 15Apr19 handle Mike Hore's issue, it's basically the same stuff
						else if (pApp->nCount_NonDeleted >= 1)
						{
							bInconsistency = TRUE;
							inconsistencyType = member_exists_deleted_from_KB_KB_has_translations;
							pAutoFixRec = new AutoFixRecord;
							pAutoFixRec->nWords = nWords;
							pAutoFixRec->key = key;
							pAutoFixRec->oldAdaptation = adaption;
							pAutoFixRec->finalAdaptation = adaption; // BEW 15Apr19 initialize to this value
							pAutoFixRec->incType = inconsistencyType;
							pAutoFixRec->fixAction = user_list_choice;
						}
#ifdef CONSCHK
//						wxLogDebug(_T("5. for DLG  member_exists_flag_on_PTUexists_deleted_Refstr (revamped legacy)  at sn = %d , m_key:  %s   m_adaption:  %s"),
//							pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
						// dialog for this is the revamped legacy ConsistencyCheckDlg.h &.cpp
					}

					// final possibilities -- there was no CTargetUnit returned from the
					// auto-caps lookup done in pKBCopy->IsAlreadyInKB(nWords, key, adaption,
					// pTU, pRefStr, bDeleted);
					else if (pTU == NULL)
					{
						// MH - it seems if source is coming from Paratext, we can sometimes get a completely empty source phrase.  There'll be no adaptation and no KB entry.
						//  We can ignore this, and don't need to put up any dialog.  So in this case we simply continue the loop.
						if (pSrcPhrase->m_srcPhrase.IsEmpty())
							continue;

						bFoundTgtUnit = FALSE;

						bInconsistency = TRUE;
						pAutoFixRec = new AutoFixRecord;
						pAutoFixRec->nWords = nWords;
						pAutoFixRec->key = key;
						pAutoFixRec->oldAdaptation = adaption;
						pAutoFixRec->finalAdaptation = adaption; // BEW 2nov12 initialize to this value
						pAutoFixRec->fixAction = no_GUI_needed; // a default value
							// until such time as the dialog is shown and the user's
							// fixit choice becomes known & replaces this value
						if (adaption.IsEmpty())
						{
							// pSrcPhrase says the KB has an entry for this, m_adaption is
							// empty, but there is no pTU
							// Three fixes are possible:
							// (1) a <no adaptation> entry added to the KB
							// (2) a <Not In KB> entry added to the KB (empty adaptation
							// is retained in the doc & certain flags change value,
							// eg. m_bNotInKB)
							// (3) leave this location unadapted (the fix is then that
							// m_bHasKBEntry flag needs to be reset to FALSE and nothing
							// is added to the KB)
							//
							//For the dialog for this, give a simple explanation of the
							//options, radio buttons for the 3 choices, a checkbox for the
							//"Auto-fix later instances the same way" option, a Cancel
							//button which cancels the whole consistency check, and an OK
							//button
							inconsistencyType = member_empty_flag_on_noPTU;
							pAutoFixRec->incType = inconsistencyType;
							pAutoFixRec->finalAdaptation.Empty(); // BEW added 2Nov12

#ifdef CONSCHK
//							wxLogDebug(_T("6. for DLG  member_empty_flag_on_noPTU (3 choices)  at sn = %d , m_key:  %s   m_adaption:  %s"),
//								pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							// NOTE: an AutoFixRecord instance is deleted before the next
							 // iteration if not preserved in the afList, and so it only
							 // become an "auto-fix" possibility provided such preservation
							 // happens later below before the loop end is reached

							 // the dialog for this one is ConsChk_Empty_noTU_Dlg

						} // end of TRUE block for test: if (adaption.IsEmpty())
						else if (pSrcPhrase->m_bHasKBEntry)
						{
							// pSrcPhrase->m_adaption is not empty, and the flag is TRUE, so
							// the possible fixes for this are:
							// (1) store the adaption string in the KB, and make the
							// m_targetStr member (ie. no inhibition of making m_targetStr)
							// (2) a <Not In KB> entry added to the KB (the adaptation is
							// retained in the doc, & certain flags change value, eg.
							// m_bNotInKB)
							// The dialog for this is similar to the one for above, but
							// with 2 options and showing the target text
							// (In glossing mode, option (2) is not available, so there is
							// only the one possibility - and for that a GUI is not
							// required - the glossing function is separate from this one)
#ifdef CONSCHK
//							wxLogDebug(_T("7. for DLG  member_exists_flag_on_noPTU (2 choices)  at sn = %d , m_key:  %s   m_adaption:  %s"),
//								pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							inconsistencyType = member_exists_flag_on_noPTU;
							pAutoFixRec->incType = inconsistencyType;
							pAutoFixRec->oldAdaptation = adaption; // BEW 2Nov12
							pAutoFixRec->finalAdaptation = pSrcPhrase->m_adaption; // BEW added 2Nov12

							// the dialog for this one is conschk_exists_notu_dlg
							// which has wxDesigner func, ConsistencyCheck_ExistsNoTU_DlgFunc()

						} // end of else if block for test: if (pSrcPhrase->m_bHasKBEntry)
						else
						{
							// This one is: pTU is absent, pSrcPhrase->m_bHasKBEntry is FALSE
							// but pSrcPhrase->m_adaption has a non-empty value (so it must
							// have had a formerly non-deleted KB entry). Two options: either
							// re-store it, or make it a <Not In KB> location and keep the
							// m_adaption in the document
#ifdef CONSCHK
//							wxLogDebug(_T("8. for DLG  member_exists_flag_off_noPTU (2 choices)  at sn = %d , m_key:  %s   m_adaption:  %s"),
//								pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							inconsistencyType = member_exists_flag_off_noPTU;
							pAutoFixRec->incType = inconsistencyType;
							pAutoFixRec->oldAdaptation = adaption; // BEW added 2Nov12
							pAutoFixRec->finalAdaptation = adaption; // BEW added 2Nov12
						}
					} // end of TRUE block for test: else if (pTU == NULL)

				} // end of TRUE block for test: if (!bInconsistency)

			} // end of else block for test: if (bIsInKB)

// ******* Inconsistency fixes (by AutoFixRecord or by dialog) begins here ********

			// open a dialog if we have an inconsistency, or do the fix without a dialog
			// if we match a stored auto-fix record (the latter first, if there is such)
			if (bInconsistency)
			{
				// work out if this is an auto-fix item, if so, don't show the dialog, but
				// use the stored AutoFixRecord to fix the inconsistency without user
				// intervention; note, if the passed in pAutoFixRec is matched with one
				// stored, then before control returns, the finalAdaptation and fixAction
				// members are set from the respective values in the matched one stored in
				// the afList (since it's only those in the list that the user has
				// actually, using the GUI dialogs, specified those values within)
				if (MatchAutoFixItem(&afList, pSrcPhrase, pAutoFixRec))
				{
					// we matched an auto-fix element, so do the fix automatically...
					// update the original kb (not pKBCopy)
					switch (pAutoFixRec->incType)
					{
					case member_empty_flag_on_noPTU: // fall thru
					case member_empty_flag_on_PTUexists_deleted_Refstr:
					{
						// do the fixit action
						switch (pAutoFixRec->fixAction)
						{
						case turn_flag_off:
						{
							pSrcPhrase->m_bHasKBEntry = FALSE; // we've created a "hole"
						}
						break;
						case store_empty_meaning:
						{
							//#if defined(FWD_SLASH_DELIM)
																// BEW added 23Apr15
							pAutoFixRec->finalAdaptation = FwdSlashtoZWSP(pAutoFixRec->finalAdaptation);
							//#endif
																// make a <no adaptation> entry in pKB (but not in
																// pKBCopy, because we need to be able to find
																// subsequent errors that may exist -- same below, when
																// we don't do the same fix in pKBCopy, it's for this
																// reason also)
							pApp->m_bInhibitMakeTargetStringCall = TRUE;
							pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation, TRUE);
							pApp->m_bInhibitMakeTargetStringCall = FALSE;

							// check if it has also a non-deleted <Not In KB>
							// CRefString in pTU, if so, it would be inconsistent to
							// leave it undeleted
							if (pTU_OnOrig != NULL)
							{
								if (pTU_OnOrig->IsItNotInKB())
								{
									pTU_OnOrig->DeleteOnlyNotInKB();
								}
							}
						}
						break;
						case make_it_Not_In_KB:
						{
							// this option always must update both pKB and pKBCopy kbs
							CTargetUnit* pTgtU = pKBCopy->GetTargetUnit(pSrcPhrase->m_nSrcWords, pSrcPhrase->m_key);
							CTargetUnit* pTgtU_OnOrig = pKB->GetTargetUnit(pSrcPhrase->m_nSrcWords, pSrcPhrase->m_key);
							if (pTgtU != NULL)
							{
								pTgtU->DeleteAllToPrepareForNotInKB();
							}
							if (pTgtU_OnOrig != NULL)
							{
								pTgtU_OnOrig->DeleteAllToPrepareForNotInKB();
							}
							pKBCopy->StoreText(pSrcPhrase, pApp->m_strNotInKB);
							pKB->StoreText(pSrcPhrase, pApp->m_strNotInKB);

							// ensure this src word or phrase is <Not In KB>
							// elsewhere too
							AddUniqueString(&arrSetNotInKB, key);
						}
						break;
						case store_nonempty_meaning:
						{
							//#if defined(FWD_SLASH_DELIM)
																// BEW added 23Apr15
							pAutoFixRec->finalAdaptation = FwdSlashtoZWSP(pAutoFixRec->finalAdaptation);
							//#endif
																// just requires a simple store operation ( and no store
																// in pKCopy should be done)
							pApp->m_bInhibitMakeTargetStringCall = TRUE;
							pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation);
							pApp->m_bInhibitMakeTargetStringCall = FALSE;

							// check if it has also a non-deleted <Not In KB>
							// CRefString in pTU, if so, it would be inconsistent to
							// leave it undeleted
							if (pTU_OnOrig != NULL)
							{
								if (pTU_OnOrig->IsItNotInKB())
								{
									pTU_OnOrig->DeleteOnlyNotInKB();
								}
							}
						}
						break;
						case no_GUI_needed:
						case turn_flag_on:
						case restore_meaning_to_doc:
						case user_list_choice:
						default:
						{
							// nothing to do for these here
							;
						}
						break;
						} // end of switch (pAutoFixRec->fixAction)
					} // end of case member_empty_flag_on_PTUexists_deleted_Refstr:
					break;
					case member_exists_flag_on_noPTU: // fall thru
					case member_exists_flag_off_noPTU:
					{
						// do the fixit action
						switch (pAutoFixRec->fixAction)
						{
						case store_nonempty_meaning:
						{
							//#if defined(FWD_SLASH_DELIM)
																// BEW added 23Apr15
							pAutoFixRec->finalAdaptation = FwdSlashtoZWSP(pAutoFixRec->finalAdaptation);
							//#endif
																// make a normal entry of it in pKB (but not pKBCopy)
							pApp->m_bInhibitMakeTargetStringCall = TRUE;
							pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation, TRUE);
							pApp->m_bInhibitMakeTargetStringCall = FALSE;
						}
						break;
						case make_it_Not_In_KB:
						{
							// this one always requires we update both pKB and pKBCopy
							CTargetUnit* pTgtU = pKBCopy->GetTargetUnit(pSrcPhrase->m_nSrcWords, pSrcPhrase->m_key);
							CTargetUnit* pTgtU_OnOrig = pKB->GetTargetUnit(pSrcPhrase->m_nSrcWords, pSrcPhrase->m_key);
							if (pTgtU != NULL)
							{
								pTgtU->DeleteAllToPrepareForNotInKB();
							}
							if (pTgtU_OnOrig != NULL)
							{
								pTgtU_OnOrig->DeleteAllToPrepareForNotInKB();
							}
							pKBCopy->StoreText(pSrcPhrase, pApp->m_strNotInKB);
							pKB->StoreText(pSrcPhrase, pApp->m_strNotInKB);

							// ensure this src word or phrase is <Not In KB>
							// elsewhere too
							AddUniqueString(&arrSetNotInKB, key);
#ifdef CONSCHK
							ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
						}
						break;
						case no_GUI_needed:
						case store_empty_meaning:
						case turn_flag_on:
						case turn_flag_off:
						case restore_meaning_to_doc:
						case user_list_choice:
						default:
						{
							// nothing to do for these here
							;
						}
						break;
						} // end of switch (pAutoFixRec->fixAction)
					} // end of case member_exists_flag_off_noPTU:
					break;
					case member_exists_flag_on_PTUexists_deleted_Refstr:
					case member_exists_flag_off_PTUexists_deleted_RefStr:
					case member_exists_deleted_from_KB_KB_has_translations:
					{
						// if the adaptation is null, then assume user wants it that way
						// and so store an empty string, else store whatever it is -- and
						// since the actions all involve just a StoreText() call, we don't
						// need a switch based on actionTaken in order to do what we need
						// to do
						wxString tempStr = pAutoFixRec->finalAdaptation;
						if (tempStr != pApp->m_strNotInKB)
						{
							// the user chose a normal adaptation or empty string
//#if defined(FWD_SLASH_DELIM)
								// BEW added 23Apr15
							tempStr = FwdSlashtoZWSP(tempStr);
							//#endif

															// the following call is now done internally in StoreText()
															//pApp->GetView()->RemovePunctuation(this, &tempStr, from_target_text);

															// update the original kb (not pKBCopy)
							if (tempStr.IsEmpty())
							{
								// TRUE = allow empty string storage
								pApp->m_bInhibitMakeTargetStringCall = TRUE;
								pKB->StoreText(pSrcPhrase, tempStr, TRUE);
								pApp->m_bInhibitMakeTargetStringCall = FALSE;
							}
							else
							{
								pApp->m_bInhibitMakeTargetStringCall = TRUE;
								pKB->StoreText(pSrcPhrase, tempStr);
								pApp->m_bInhibitMakeTargetStringCall = FALSE;

							}

							// check if it has also a non-deleted <Not In KB>
							// CRefString in pTU, if so, it would be inconsistent to
							// leave it undeleted
							if (pTU_OnOrig != NULL)
							{
								if (pTU_OnOrig->IsItNotInKB())
								{
									pTU_OnOrig->DeleteOnlyNotInKB();
								}
							}
							// ************* NOTE     NOTE     NOTE   ******************
							// If the same m_key value later occurs in the document at
							// a place where it has been set in an earlier session to
							// be a <Not In KB> location, then that key will be added
							// to arrSetNotInKB array, which has as a sideffect at
							// that point, that pTU_OnOrig and pTU both have
							// ValidateNotInKB() called, which makes "deleted" any
							// non-<Not In KB> entries in those CTargetUnit instances,
							// and hence while the user would expect the adaptation to
							// be in the KB as a normal empty, in this circumstance it
							// would get deleted. This only happens when an
							// inconsistency is detected in which both the key and
							// adaptation, and the key and <Not In KB> CRefString
							// entries are both non-deleted in the one pTU. Since that
							// is unlikely, and use of <Not In KB> is probably rare (I
							// think most people never use it), I'm not going to try
							// to make a fix for this problem. (Such a fix might not
							// be possible without a huge price in terms of overhead,
							// because at the time the user is choosing to make the
							// "normal save" the location which will produce the
							// conflict with that choice may be many iterations ahead,
							// and we don't want to have to both play with two array's
							// contents (arrSetNotInKB and arrRemoveNotInKB) as well
							// as analysis ahead and pre-fix such nuisance locations.)
						}
						else
						{
							// the user chose the <Not In KB> string shown in the list
							AddUniqueString(&arrSetNotInKB, tempStr);
							if (pTU != NULL)
							{
								pTU->DeleteAllToPrepareForNotInKB();
							}
							if (pTU_OnOrig != NULL)
							{
								pTU_OnOrig->DeleteAllToPrepareForNotInKB();
							}
							pKBCopy->StoreText(pSrcPhrase, strNotInKB);
							pKB->StoreText(pSrcPhrase, strNotInKB);
						}

					}  // rnf of case member_exists_deleted_from_KB_KB_has_translations:, and two other falls thru
					break;
					case flag_on_NotInKB_off_hasActiveNotInKB_in_KB:
					{
						// do the fixit action - inner switch
						switch (pAutoFixRec->fixAction)
						{
						case store_nonempty_meaning:
						{
							//#if defined(FWD_SLASH_DELIM)
																// BEW added 23Apr15
							pApp->m_bInhibitMakeTargetStringCall = TRUE;
							pAutoFixRec->finalAdaptation = FwdSlashtoZWSP(pAutoFixRec->finalAdaptation);
							pApp->m_bInhibitMakeTargetStringCall = FALSE;
							//#endif
																// make a normal entry of it in pKB (leave pKBCopy unchanged)
							pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation);

							// check if it has also a non-deleted <Not In KB>
							// CRefString in pTU, if so, it would be inconsistent to
							// leave it undeleted
							if (pTU_OnOrig != NULL)
							{
								if (pTU_OnOrig->IsItNotInKB())
								{
									pTU_OnOrig->DeleteOnlyNotInKB();
								}
							}
						} // end of case store_nonempty_meaning:
						break;
						case store_empty_meaning:
						{
							// make a normal entry of it in pKB (leave pKBCopy unchanged)
							pApp->m_bInhibitMakeTargetStringCall = TRUE;
							pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation, TRUE);
							pApp->m_bInhibitMakeTargetStringCall = FALSE;

							// check if it has also a non-deleted <Not In KB>
							// CRefString in pTU, if so, it would be inconsistent to
							// leave it undeleted
							if (pTU_OnOrig != NULL)
							{
								if (pTU_OnOrig->IsItNotInKB())
								{
									pTU_OnOrig->DeleteOnlyNotInKB();
								}
							}
						} // end of case store_empty_meaning:
						break;
						case make_it_Not_In_KB:
						{
							// no store needed, pKBCopy's pTU already has the
							// non-deleted <Not In KB> - so all we need do is get
							// the document flags to agree; we can assume same for
							// pKB's pTU_OnOrig
							bool bOnOrig = FALSE;
							if (pTU_OnOrig != NULL)
							{
								bOnOrig = TRUE;
							}
							pSrcPhrase->m_bHasKBEntry = FALSE;
							pSrcPhrase->m_bNotInKB = TRUE;

							pTU->ValidateNotInKB(); // ensure no undeleted CRefStrings other than
													// the <Not In KB> one remain undeleted
							if (bOnOrig && pTU_OnOrig->IsItNotInKB())
							{
								pTU_OnOrig->ValidateNotInKB(); // do in pKB too
							}
							// ensure this src word or phrase is <Not In KB>
							// elsewhere in this and any other docs too
							AddUniqueString(&arrSetNotInKB, key);
#ifdef CONSCHK
							ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
						} // end of case make_it_Not_In_KB:
						break;
						case no_GUI_needed:
						case turn_flag_on:
						case turn_flag_off:
						case restore_meaning_to_doc:
						case user_list_choice:
						default:
						{
							// nothing to do for these here
							;
						}
						break;
						} // end of switch (pAutoFixRec->fixAction)
					} // end of case flag_on_NotInKB_off_hasActiveNotInKB_in_KB:
					break;
					default:
					{
						// nothing to do, these are autofixed without needing any GUI
						;
					}
					break;
					} // end of switch (pAFRecord->incType)

					pApp->m_targetPhrase = pAutoFixRec->finalAdaptation; // any brief glimpse
						// of the box should show the current adaptation string
						// BEW 13Apr15 don't replace / with ZWSP for the above assignment to m_targetPhrase

				} // end of TRUE block for test: if (MatchAutoFixItem(&afList, pSrcPhrase, pAFRecord))
				else
				{
					// ********************* the DIALOGS are in this block *******************************

					// no match, so this is has to be handled with user intervention via
					// the dialogs

					// update the view to show the location where this source pile is, and
					// put the phrase box there ready to accept user input indirectly from
					// the dialog, return ptr to the phrase box's cell in the view
					CCell* pCell = LayoutDocForConsistencyCheck(pApp, pSrcPhrase, pPhrases);

					switch (pAutoFixRec->incType)
					{
					case member_empty_flag_on_noPTU:
					{
						wxMessageBox(_T("here we are!!!"));
					}
					case member_empty_flag_on_PTUexists_deleted_Refstr:
					{
						pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);   // mrh June19 - ensure phrasebox is on screen before we put the dialog up
						wxString titleStr = _("Inconsistency Found");
						wxString aSrcStr = pSrcPhrase->m_key;
						wxString aTgtStr = pSrcPhrase->m_adaption;
						pAutoFixRec->oldAdaptation = pSrcPhrase->m_adaption;; // BEW added 2Nov12
						bool bShowItCentered = TRUE;
						ConsChk_Empty_noTU_Dlg dlg(
							(wxWindow*)gpApp->GetMainFrame(),
							&titleStr,
							&aSrcStr,
							&aTgtStr,
							&gpApp->m_modeWordAdapt,
							&gpApp->m_modeWordAdaptPlusArticle,
							&gpApp->m_strNotInKB,
							&gpApp->m_strNoAdapt,
							bShowItCentered);

						// provide hooks for the phrase box location so that the dialog can
						// work out where to display itself so it does not obscure the active
						// location
						dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
						dlg.m_nTwoLineDepth = 2 * pLayout->GetTgtTextHeight();

						if (dlg.ShowModal() == wxID_OK)
						{
							// get and store the FixItAction
							pAutoFixRec->fixAction = dlg.actionTaken;
							// pAutoFixRec->finalAdaptation is already set to the empty
							// string passed in for the adaptation; however, if the user
							// elected to type a different adaptation for storage, then
							// get it now
							if (dlg.actionTaken == store_nonempty_meaning)
							{
								pAutoFixRec->finalAdaptation = dlg.m_aorgTextCtrlStr;
								//#if defined(FWD_SLASH_DELIM)
																// BEW added 23Apr15
								pAutoFixRec->finalAdaptation = FwdSlashtoZWSP(pAutoFixRec->finalAdaptation);
								//#endif
							}

							// if the m_bDoAutoFix flag is set, add this 'fix' to a list for
							// subsequent use
							if (dlg.m_bDoAutoFix)
							{
								bAddedToAFList = TRUE; // <<- BEW added 30Aug11, the new code needs it
								afList.Append(pAutoFixRec);
							}

							// do the fixit action
							switch (pAutoFixRec->fixAction)
							{
							case turn_flag_off:
							{
								pSrcPhrase->m_bHasKBEntry = FALSE; // we've created a "hole"
#ifdef CONSCHK
//								wxLogDebug(_T("9 FIX. (4 choices) turn_flag_off  at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							} // end of case turn_flag_off:
							break;
							case store_empty_meaning:
							{
								// make a <no adaptation> entry in KB (but not in
								// pKBCopy, because we need to be able to find
								// subsequent errors that may exist -- same below, when
								// we don't do the same fix in pKBCopy, it's for this
								// reason also)
								pApp->m_bInhibitMakeTargetStringCall = TRUE;
								pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation, TRUE);
								pApp->m_bInhibitMakeTargetStringCall = FALSE;

								// check if it has also a non-deleted <Not In KB>
								// CRefString in pTU, if so, it would be inconsistent to
								// leave it undeleted
								if (pTU_OnOrig != NULL)
								{
									if (pTU_OnOrig->IsItNotInKB())
									{
										pTU_OnOrig->DeleteOnlyNotInKB();
									}
								}
#ifdef CONSCHK
//								wxLogDebug(_T("10 FIX. (4 choices) store_empty_meaning  at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							} // end of case store_empty_meaning:
							break;
							case make_it_Not_In_KB:
							{
								// this option always must update both pKB and pKBCopy kbs
								CTargetUnit* pTgtU = pKBCopy->GetTargetUnit(pSrcPhrase->m_nSrcWords, pSrcPhrase->m_key);
								CTargetUnit* pTgtU_OnOrig = pKB->GetTargetUnit(pSrcPhrase->m_nSrcWords, pSrcPhrase->m_key);
								if (pTgtU != NULL)
								{
									pTgtU->DeleteAllToPrepareForNotInKB();
								}
								if (pTgtU_OnOrig != NULL)
								{
									pTgtU_OnOrig->DeleteAllToPrepareForNotInKB();
								}
								pSrcPhrase->m_bHasKBEntry = FALSE; // enable an error-less store
								pKBCopy->StoreText(pSrcPhrase, pApp->m_strNotInKB);
								pKB->StoreText(pSrcPhrase, pApp->m_strNotInKB);

								// ensure this src word or phrase is <Not In KB>
								// elsewhere too
								AddUniqueString(&arrSetNotInKB, key);
#ifdef CONSCHK
//								wxLogDebug(_T("11 FIX. (4 choices) make_it_Not_In_KB  at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
								ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
							} // end of case make_it_Not_In_KB:
							break;
							case store_nonempty_meaning:
							{
								// just requires a simple store operation ( and no store
								// in pKCopy should be done)
//#if defined(FWD_SLASH_DELIM)
									// BEW added 23Apr15
								pAutoFixRec->finalAdaptation = FwdSlashtoZWSP(pAutoFixRec->finalAdaptation);
								//#endif
								pApp->m_bInhibitMakeTargetStringCall = TRUE;
								pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation);
								pApp->m_bInhibitMakeTargetStringCall = FALSE;

								// check if it has also a non-deleted <Not In KB>
								// CRefString in pTU, if so, it would be inconsistent to
								// leave it undeleted
								if (pTU_OnOrig != NULL)
								{
									if (pTU_OnOrig->IsItNotInKB())
									{
										pTU_OnOrig->DeleteOnlyNotInKB();
									}
								}
#ifdef CONSCHK
//								wxLogDebug(_T("11 extra! FIX. (4 choices) store nonempty adaptation  at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							} // end of case store_nonempty_meaning:
							break;
							case no_GUI_needed:
							case turn_flag_on:
							case restore_meaning_to_doc:
							default:
							{
								// nothing to do for these here
								;
							}
							break;
							} // end of switch (pAutoFixRec->fixAction)
						}
						else
						{
							bUserCancelled = TRUE;
							break;
						}
					} // end of case member_empty_flag_on_PTUexists_deleted_Refstr:
					break;
					case member_exists_flag_on_noPTU:
					case member_exists_flag_off_noPTU:
					{
						pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);   // mrh June19 - ensure phrasebox is on screen before we put the dialog up
						wxString titleStr = _("Inconsistency Found");
						wxString aSrcStr = pSrcPhrase->m_key;
						wxString aTgtStr = pSrcPhrase->m_adaption;
						pAutoFixRec->oldAdaptation = pSrcPhrase->m_adaption;; // BEW added 2Nov12
						bool bShowItCentered = TRUE;
						conschk_exists_notu_dlg dlg(
							(wxWindow*)gpApp->GetMainFrame(),
							&titleStr,
							1, // selects the message: "An adaptation exists. A knowledge base entry is expected, but is absent"
							&aSrcStr,
							&aTgtStr,
							&gpApp->m_strNotInKB,
							bShowItCentered);

						// provide hooks for the phrase box location so that the dialog can
						// work out where to display itself so it does not obscure the active
						// location
						dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
						dlg.m_nTwoLineDepth = 2 * pLayout->GetTgtTextHeight();

						if (dlg.ShowModal() == wxID_OK)
						{
							// get and store the FixItAction
							pAutoFixRec->fixAction = dlg.actionTaken;
							//pAutoFixRec->finalAdaptation is already set
//#if defined(FWD_SLASH_DELIM)
							// BEW added 23Apr15
							pAutoFixRec->finalAdaptation = FwdSlashtoZWSP(pAutoFixRec->finalAdaptation);
							//#endif

														// if the m_bDoAutoFix flag is set, add this 'fix' to a list for
														// subsequent use
							if (dlg.m_bDoAutoFix)
							{
								bAddedToAFList = TRUE; // <<- BEW added 30Aug11, the new code needs it
								afList.Append(pAutoFixRec);
							}

							// do the fixit action
							switch (pAutoFixRec->fixAction)
							{
							case store_nonempty_meaning:
							{
								// make a normal entry of it in KB (but not pKBCopy)
								pApp->m_bInhibitMakeTargetStringCall = TRUE;
								pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation, TRUE);
								pApp->m_bInhibitMakeTargetStringCall = FALSE;

#ifdef CONSCHK
//								wxLogDebug(_T("12 FIX. (2 choices) store_nonempty_meaning  at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							} // e,d of case store_nonempty_meaning:
							break;
							case make_it_Not_In_KB:
							{
								// this one always requires we update both pKB and pKBCopy
								CTargetUnit* pTgtU = pKBCopy->GetTargetUnit(pSrcPhrase->m_nSrcWords, pSrcPhrase->m_key);
								CTargetUnit* pTgtU_OnOrig = pKB->GetTargetUnit(pSrcPhrase->m_nSrcWords, pSrcPhrase->m_key);
								if (pTgtU != NULL)
								{
									pTgtU->DeleteAllToPrepareForNotInKB();
								}
								if (pTgtU_OnOrig != NULL)
								{
									pTgtU_OnOrig->DeleteAllToPrepareForNotInKB();
								}
								pKBCopy->StoreText(pSrcPhrase, pApp->m_strNotInKB);
								pKB->StoreText(pSrcPhrase, pApp->m_strNotInKB);

								// ensure this src word or phrase is <Not In KB>
								// elsewhere too
								AddUniqueString(&arrSetNotInKB, key);
#ifdef CONSCHK
//								wxLogDebug(_T("13 FIX. (2 choices) make_it_Not_In_KB  at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
								ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
							} // end of case make_it_Not_In_KB:
							break;
							case no_GUI_needed:
							case store_empty_meaning:
							case turn_flag_on:
							case turn_flag_off:
							case restore_meaning_to_doc:
							default:
							{
								// nothing to do for these here
								;
							}
							break;
							} // end of switch (pAutoFixRec->fixAction)
						}
						else
						{
							bUserCancelled = TRUE;
							break;
						}
					} // end of case member_exists_flag_off_noPTU: and a fall thru
					break;
					case member_exists_flag_on_PTUexists_deleted_Refstr:
					case member_exists_flag_off_PTUexists_deleted_RefStr:
					case member_exists_deleted_from_KB_KB_has_translations:
					{
						// The revamped legacy dialog - now simplified; and if both an
						// adaptation is available and <Not In KB> is available (which
						// would be an inconsistency), we'll let the <Not In KB> be
						// listed and choosable - if chosen then we handle as a normal
						// 'not in the knowledge base' entry and 'delete' the
						// adaptation's CRefString and all others in that pTU as well,
						// except for the <Not In KB> - so we can handle this extra
						// inconsistency within the simplified dialog
						pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);   // mrh June19 - ensure phrasebox is on screen before we put the dialog up
						CConsistencyCheckDlg dlg(pApp->GetMainFrame());
						dlg.m_bFoundTgtUnit = bFoundTgtUnit;
						dlg.m_bDoAutoFix = FALSE;
						dlg.m_pApp = pApp;
						dlg.m_pKBCopy = pKBCopy;
						dlg.m_pTgtUnit = pTU; // could be null
						pAutoFixRec->oldAdaptation = pSrcPhrase->m_adaption; // BEW added 2Nov12
						dlg.m_finalAdaptation = adaption; // initialize final chosen adaptation or gloss
						dlg.m_pSrcPhrase = pSrcPhrase;
						// get the chapter and verse
						wxString chVerse = pApp->GetView()->GetChapterAndVerse(pSrcPhrase);
						dlg.m_chVerse = chVerse;

						// provide hooks for the phrase box location so that the dialog can
						// work out where to display itself so it does not obscure the active
						// location
						dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
						dlg.m_nTwoLineDepth = 2 * pLayout->GetTgtTextHeight();

						// put up the dialog

						if (dlg.ShowModal() == wxID_OK)
						{
							if (dlg.m_bIgnoreIt)
							{
								// skip rest of this block, don't change KB, don't change doc
								;
							}
							else
							{
								// get and store the FixItAction (all 4 possibilities are storage
								// actions: store_nonempty_meaning, store_empty_meaning, or
								// restore_meaning_to_doc, or user_list_choice); also get the
								// user's final string
								pAutoFixRec->fixAction = dlg.actionTaken;
								pAutoFixRec->finalAdaptation = dlg.m_finalAdaptation; // could be "<Not In KB>"
	//#if defined(FWD_SLASH_DELIM)
								if (pAutoFixRec->finalAdaptation != pApp->m_strNotInKB)
								{
									// BEW added 23Apr15
									pAutoFixRec->finalAdaptation = FwdSlashtoZWSP(pAutoFixRec->finalAdaptation);
								}
								//#endif
															// if the m_bDoAutoFix flag is set, add this 'fix' to a list for
															// subsequent use
								if (dlg.m_bDoAutoFix)
								{
									bAddedToAFList = TRUE; // <<- BEW added 30Aug11, the new code needs it
									afList.Append(pAutoFixRec);
								}

								// if the adaptation is null, then assume user wants it that way
								// and so store an empty string, else store whatever it is -- and
								// since the actions all involve just a StoreText() call, we don't
								// need a switch based on actionTaken in order to do what we need
								// to do; if "<Not In KB>" then do what's needed for that option
								wxString tempStr = pAutoFixRec->finalAdaptation;
								if (tempStr != pApp->m_strNotInKB)
								{
									// it's a normal adaptation (i.e. not <Not In KB>)
#ifdef CONSCHK
//									wxLogDebug(_T("14 FIX. (revamped legacy)  at sn = %d , m_key:  %s   STORING:  %s"),
//										pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pAutoFixRec->finalAdaptation.c_str());
#endif
									// update the original kb (not pKBCopy)
									if (tempStr.IsEmpty())
									{
										// TRUE = allow empty string storage
										pApp->m_bInhibitMakeTargetStringCall = TRUE;
										pKB->StoreText(pSrcPhrase, tempStr, TRUE);
										pApp->m_bInhibitMakeTargetStringCall = FALSE;
									}
									else
									{
										pApp->m_bInhibitMakeTargetStringCall = TRUE;
										pKB->StoreText(pSrcPhrase, tempStr);
										pApp->m_bInhibitMakeTargetStringCall = FALSE;
									}

									// check if it has also a non-deleted <Not In KB>
									// CRefString in pTU_OnOrig, if so, it would be inconsistent to
									// leave it undeleted
									if (pTU_OnOrig != NULL)
									{
										if (pTU_OnOrig->IsItNotInKB())
										{
											pTU_OnOrig->DeleteOnlyNotInKB();
										}
									}

									// ************* NOTE     NOTE     NOTE   ******************
									// If the same m_key value later occurs in the document at
									// a place where it has been set in an earlier session to
									// be a <Not In KB> location, then that key will be added
									// to arrSetNotInKB array, which has as a sideffect at
									// that point, that pTU_OnOrig and pTU both have
									// ValidateNotInKB() called, which makes "deleted" any
									// non-<Not In KB> entries in those CTargetUnit instances,
									// and hence while the user would expect the adaptation to
									// be in the KB as a normal empty, in this circumstance it
									// would get deleted. This only happens when an
									// inconsistency is detected in which both the key and
									// adaptation, and the key and <Not In KB> CRefString
									// entries are both non-deleted in the one pTU. Since that
									// is unlikely, and use of <Not In KB> is probably rare (I
									// think most people never use it), I'm not going to try
									// to make a fix for this problem. (Such a fix might not
									// be possible without a huge price in terms of overhead,
									// because at the time the user is choosing to make the
									// "normal save" the location which will produce the
									// conflict with that choice may be many iterations ahead,
									// and we don't want to have to both play with two array's
									// contents (arrSetNotInKB and arrRemoveNotInKB) as well
									// as analysis ahead and pre-fix such nuisance locations.)

								} // end of TRUE block for test: if (tempStr != pApp->m_strNotInKB)
								else
								{
									// the user chose the <Not In KB> string shown in the list
#ifdef CONSCHK
									int beforeCount = arrSetNotInKB.GetCount();
//									wxLogDebug(_T("*18. adaption (user GUI listed choice):  %s"), tempStr.c_str());
#endif
									AddUniqueString(&arrSetNotInKB, tempStr);
									if (pTU != NULL)
									{
										pTU->DeleteAllToPrepareForNotInKB();
									}
									if (pTU_OnOrig != NULL)
									{
										pTU_OnOrig->DeleteAllToPrepareForNotInKB();
									}
									pKBCopy->StoreText(pSrcPhrase, strNotInKB);
									pKB->StoreText(pSrcPhrase, strNotInKB);
#ifdef CONSCHK
									int afterCount = arrSetNotInKB.GetCount();
									if (afterCount >= beforeCount)
//										wxLogDebug(_T("*18. User GUI choice for arrSetNotInKB entry:  listed <Not In KB> at sn = %d , m_key:  %s   (m_adaption:  %s)  count = %d)"),
//											pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str(), afterCount);
									ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
								} // end of else block for test: if (tempStr != pApp->m_strNotInKB)
							} // end of else block for test: if (dlg.m_bIgnoreIt)
						} // end of TRUE block for test of ShowModal() == wxID_OK
						else
						{
							// user cancelled
							bUserCancelled = TRUE;
							break;
						}
					} // end of case member_exists_deleted_from_KB_KB_has_translations: and two falls thru
					break;
					case flag_on_NotInKB_off_hasActiveNotInKB_in_KB:
					{
						pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);   // mrh June19 - ensure phrasebox is on screen before we put the dialog up
						wxString titleStr = _("Inconsistency Found");
						wxString aSrcStr = pSrcPhrase->m_key;
						wxString aTgtStr = pSrcPhrase->m_adaption;
						pAutoFixRec->oldAdaptation = pSrcPhrase->m_adaption;; // BEW added 2Nov12
						bool bShowItCentered = TRUE;
						conschk_exists_notu_dlg dlg(
							(wxWindow*)gpApp->GetMainFrame(),
							&titleStr,
							2, // selects the message: "The knowledge base entry is <Not In KB>, the document does not agree"
							&aSrcStr,
							&aTgtStr,
							&gpApp->m_strNotInKB,
							bShowItCentered);

						// provide hooks for the phrase box location so that the dialog can
						// work out where to display itself so it does not obscure the active
						// location
						dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
						dlg.m_nTwoLineDepth = 2 * pLayout->GetTgtTextHeight();

						if (dlg.ShowModal() == wxID_OK)
						{
							// get and store the FixItAction
							pAutoFixRec->fixAction = dlg.actionTaken;
							//pAutoFixRec->finalAdaptation is already set
//#if defined(FWD_SLASH_DELIM)
							// BEW added 23Apr15
							pAutoFixRec->finalAdaptation = FwdSlashtoZWSP(pAutoFixRec->finalAdaptation);
							//#endif

														// if the m_bDoAutoFix flag is set, add this 'fix' to a list for
														// subsequent use
							if (dlg.m_bDoAutoFix)
							{
								bAddedToAFList = TRUE; // <<- BEW added 30Aug11, the new code needs it
								afList.Append(pAutoFixRec);
							}

							// do the fixit action
							switch (pAutoFixRec->fixAction)
							{
							case store_nonempty_meaning:
							{
								// make the adaptation normal entry in KB (leave pKBCopy unchanged)
								pApp->m_bInhibitMakeTargetStringCall = TRUE;
								pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation);
								pApp->m_bInhibitMakeTargetStringCall = FALSE;
								// check if it has also a non-deleted <Not In KB>
								// CRefString in pTU, if so, it would be inconsistent to
								// leave it undeleted
								if (pTU_OnOrig != NULL)
								{
									if (pTU_OnOrig->IsItNotInKB())
									{
										pTU_OnOrig->DeleteOnlyNotInKB();
									}
								}
#ifdef CONSCHK
//								wxLogDebug(_T("15 FIX. (msgNumber=2, 2 choices) store_nonempty_meaning  at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							} // end o f case store_nonempty_meaning:
							break;
							case store_empty_meaning:
							{
								// make the empty adaptation a normal entry  in KB
								pApp->m_bInhibitMakeTargetStringCall = TRUE;
								pKB->StoreText(pSrcPhrase, pAutoFixRec->finalAdaptation, TRUE);
								pApp->m_bInhibitMakeTargetStringCall = FALSE;

								// check if it has also a non-deleted <Not In KB>
								// CRefString in pTU, if so, it would be inconsistent to
								// leave it undeleted
								if (pTU_OnOrig != NULL)
								{
									if (pTU_OnOrig->IsItNotInKB())
									{
										pTU_OnOrig->DeleteOnlyNotInKB();
									}
								}
#ifdef CONSCHK
//								wxLogDebug(_T("16 FIX. (msgNumber=2, 2 choices) store_empty_meaning  at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
#endif
							} // end of case store_empty_meaning:
							break;
							case make_it_Not_In_KB:
							{
								// no store needed, KB's pTU already has the
								// non-deleted <Not In KB> - so all we need do is get
								// the document flags to agree; we can assume same for
								// pKB's pTU_OnOrig
								bool bOnOrig = FALSE;
								if (pTU_OnOrig != NULL)
								{
									bOnOrig = TRUE;
								}

								pSrcPhrase->m_bHasKBEntry = FALSE;
								pSrcPhrase->m_bNotInKB = TRUE;

								pTU->ValidateNotInKB(); // ensure no undeleted CRefStrings other than
														// the <Not In KB> one remain undeleted
								if (bOnOrig && pTU_OnOrig->IsItNotInKB())
								{
									pTU_OnOrig->ValidateNotInKB(); // do in pKB too
								}
								// ensure this src word or phrase is <Not In KB>
								// elsewhere in this and any other docs too
								AddUniqueString(&arrSetNotInKB, key);
#ifdef CONSCHK
//								wxLogDebug(_T("17 FIX. (msgNumber=2, 2 choices) make_it_Not_In_KB BY FLAG CHANGES ONLY  at sn = %d , m_key:  %s   m_adaption:  %s"),
//									pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str());
								ListBothArrays(arrSetNotInKB, arrRemoveNotInKB);
#endif
							} // end of case make_it_Not_In_KB:
							break;
							case no_GUI_needed:
							case turn_flag_on:
							case turn_flag_off:
							case restore_meaning_to_doc:
							default:
							{
								// nothing to do for these here
								;
							}
							break;
							} // end of switch (pAutoFixRec->fixAction)
						}
						else
						{
							// user cancelled
							bUserCancelled = TRUE;
							break;
						}
					} // end of case flag_on_NotInKB_off_hasActiveNotInKB_in_KB:
					break;
					default:
					{
						// nothing to do, these are autofixed without needing any GUI
						;
					}
					break;
					} // end of switch (pAFRecord->incType)
					if (bUserCancelled)
					{
						break; // break again, this time from the consistency check loop for
							   // this doc, so that code below can cancel the overall check
					}

				}  // end of else block for test: if (MatchAutoFixItem(&afList, pSrcPhrase, pAFRecord))

			} // end of TRUE block for test: if (bInconsistency)

#ifdef CONSCHK
			wxString aKey = _T("a");
			CTargetUnit* pTU_for_a = pKB->GetTargetUnit(1, aKey);
			wxString nd = _T("PRESENT");
			wxString d = _T("DELETED");
			wxString absent = _T("ABSENT");
			if (pTU_for_a == NULL)
			{
				wxLogDebug(_T("LoopEnd  sn = %d , m_key:  %s   m_adaption:  %s CRefString for \"a\": %s"),
					pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str(), absent.c_str());
			}
			else
			{
				if (pKB->IsAlreadyInKB(1, aKey, aKey))
				{
					wxLogDebug(_T("LoopEnd  sn = %d , m_key:  %s   m_adaption:  %s CRefString for \"a\": %s"),
						pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str(), nd.c_str());
				}
				else
				{
					wxLogDebug(_T("LoopEnd  sn = %d , m_key:  %s   m_adaption:  %s CRefString for \"a\": %s"),
						pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_adaption.c_str(), d.c_str());
				}
			}
#endif
			if (pAutoFixRec != NULL && !bAddedToAFList)
			{
				// always delete the local AutoFixRec instance, if we made one, but only
				// provided we don't want it preserved for doing auto-fixing by previously
				// having it added to the passed in afList earlier in the loop
				if (pAutoFixRec != NULL) // whm 11Jun12 added NULL test
					delete pAutoFixRec;
			}
			pAutoFixRec = NULL;

		}// end of while (pos_pPhrases != NULL)

	// mrh - The check on this file is done, so we need to save it.  The exact call depends on whether we're collaborating or not.

		pApp->m_pTargetBox->HidePhraseBox(); // hides all three parts of the new phrasebox

		// store to kb with a source phrase with m_bHasKBEntry flag
		// TRUE, which would cause an assert to trip
		pApp->m_pTargetBox->GetTextCtrl()->ChangeValue(_T("")); // need to set it to null str
												 // since it won't get recreated


		wxString    msgDisplayed = "";
		bool        bSavedOK = FALSE;

		if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
		{
			bSavedOK = DoCollabFileSave(_("Saving File"), msgDisplayed);
		}
		else
		{
			// BEW 9July10, added test and changed param to FALSE if doing bible book folders
			// loop, as we don't want time wasted for a progress dialog for what are probably a
			// lot of short files. DoFileSave_Protected() computes pApp->m_curOutputPath for
			// each doc file that we check in the currently accessed folder

			bSavedOK = DoFileSave_Protected(FALSE, _T(""));         // FALSE - dodn't show wait/progress dialog
		}

		if (!bSavedOK)
		{
			wxMessageBox(_("Warning: failure on document save operation."),
				_T(""), wxICON_EXCLAMATION | wxOK);
		}
		pApp->GetView()->ClobberDocument(); // BEW 13Jul19 sets m_bDocumentDestroyed to TRUE (only DoAutoSaveDoc() uses)
		//pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

		// delete the buffer containing the filled-in source text
		if (pApp->m_pBuffer != NULL)
		{
			delete pApp->m_pBuffer;
			pApp->m_pBuffer = NULL;
		}
		if (bUserCancelled)
			break; // don't do any more saves of the KB if user cancelled

	}

	// *******************   end iteration of document files for (int i=0; i < nCount; i++)  ********************

	pStatusBar->FinishProgress(_("Consistency Check"));

	gbConsistencyCheckCurrent = FALSE;	// restore normal default

// mrh - Finally if we're collaborating, we should restore the App variables for the open document. But I see the caller calls
// ReOpenDocument() which I think does all this anyway.  Still it's better practice to restore something we changed.
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		pApp->m_CollabBookSelected = original_bookName;
		pApp->m_CollabChapterSelected = original_chapterName;

		// And restore normal defaults for inconsistency resolution:
		pApp->m_bRetainPTorBEversion = FALSE;
		pApp->m_bForceAIversion = FALSE;
		pApp->m_bUseConflictResolutionDlg = FALSE;
	}

	GetLayout()->m_docEditOperationType = consistency_check_op; // sets 0,-1 'select all'

	return (!bUserCancelled);           // edb 26 Sept 2012 -- wasn't returning whether the operation cancelled
}


// the "glossing mode is on" variant
// Returns TRUE if process runs to completion, FALSE if the user clicks the Cancel button
// in any dialog which is shown - the FALSE is then passed back to the caller,
// OnEditConsistencyCheck() to cause the whole process to be cancelled
// BEW 2Nov12, fixed a bug in which adaptations got lost if the corrected entry was
// created with AutoCaps off but the check was later done with AutoCaps on
// BEW 23Apr15 added support for / used as a word-breaking whitespace character
// BEW 1Sep15 added support for a "blind fix" checkbox option that automatically, if chosen,
// causes the location's adaptation where an inconsistency has been identified to get the
// KB's CTargetUnit's CRefString instances translation, but only provided that translation
// string (which is a gloss, or in DoConsistencyCheck, an adaptation) is the only
// valid entry for that CTargetUnit instance (i.e. there could be one or more pseudo-deleted
// entries, but they won't be considered; but there can only be one non-deleted entry; otherwise
// the dialog will show in the usual way)
// BEW 1Sep15 added support for a "blind fix" checkbox option that automatically, if chosen,
// causes the location's adaptation where an inconsistency has been identified to get the
// KB's CTargetUnit's CRefString instances translation, but only provided that translation
// string (which may be an adaptation, or in DoConsistencyCheckG, a gloss) is the only
// valid entry for that CTargetUnit instance (i.e. there could be one or more pseudo-deleted
// entries, but they won't be considered; but there can only be one non-deleted entry; otherwise
// the dialog will show in the usual way)
bool CAdapt_ItDoc::DoConsistencyCheckG(CAdapt_ItApp* pApp, CKB* pKB, CKB* pKBCopy,
	AFGList& afgList, int& nCumulativeTotal)
{
	// use AutoFixRecordG, and AFGList, and m_gloss herein

	wxASSERT(pKB->IsThisAGlossingKB() == TRUE); // must be a glossing kb for this fn version

	gbConsistencyCheckCurrent = TRUE;	// turn on Flag to inhibit placement of phrase box
										// initially when OnOpenDocument() is called
	CLayout* pLayout = GetLayout();
	wxASSERT(pApp != NULL);
	wxArrayString* pList = &pApp->m_acceptedFilesList;
	int nCount = pList->GetCount();
	if (nCount <= 0)
	{
		// BEW 8Julyl0, book mode is on and we are iterating through Bible book folders,
		// many of which may have no files in them yet. So we must allow for GetCount() to
		// return 0 and if so we return silently, and the loop will go on to the next
		// folder
		gbConsistencyCheckCurrent = FALSE;	// restore normal default

		return TRUE;
	}
	wxASSERT(nCount > 0);
	int nTotal = 0;
	bool bBlindFix = pApp->m_bBlindFixInConsCheck; // a nice short synonym is helpful

	// iterate over the document files
	bool bUserCancelled = FALSE; // whm note: Caution: This bUserCancelled overrides the scope
								 // of the extern global of the same name
	int i;
	for (i = 0; i < nCount; i++)
	{
		wxString newName = pList->Item(i);
		wxASSERT(!newName.IsEmpty());

		// for debugging- check pile count before & after (failure to close doc before
		// calling this function resulted in the following OnOpenDocument() call appending
		// a copy of the document's contents to itself -- the fix is to ensure
		// OnFileClose() is done in the caller before DoConsistencyCheck() is called
		// int piles = pApp->m_pSourcePhrases->GetCount();

		bool bOK;
		bOK = OnOpenDocument(newName, false); // passing in just a filename, so we are relying
									   // on the working directory having previously
									   // being set in the caller at the call of
									   // EnumerateDocFiles()
		wxCHECK_MSG(bOK, FALSE, _T("DoConsistencyCheckG(), its OnOpenDocument() call failed, line 23,449 in Adapt_ItDoc.cpp, so check was aborted"));
		SetFilename(newName, TRUE);
		nTotal = pApp->m_pSourcePhrases->GetCount();
		if (nTotal == 0)
		{
			wxString str;
			str = str.Format(_T("Bad file:  %s"), newName.c_str());
			wxMessageBox(str, _T(""), wxICON_EXCLAMATION | wxOK);
		}
		nCumulativeTotal += nTotal;

		// for each document opened, get the KB entry for the current active location
		// updated so as to avoid a spurious inconsistency
		bool bNoStore = FALSE;
		bool bAttemptStoreToKB = TRUE;
		bool bSuppressWarningOnStoreKBFailure = TRUE;

		// BEW 9Aug11, in the call below, param1 TRUE is bArremptStoreToKB, param2 bNoStore
		// returns TRUE to the caller if the attempted store fails for some reason, for all
		// other circumstances it returns FALSE, and param3 bSuppressWarningOnStoreKBFailure
		// is TRUE as we don't expect a failure and will ignore it if it does anyway;
		UpdateDocWithPhraseBoxContents(bAttemptStoreToKB, bNoStore, bSuppressWarningOnStoreKBFailure);

		// prepare for the loop
		enum InconsistencyType inconsistencyType = member_exists_flag_on_PTUexists_deleted_Refstr;
		//enum FixItAction fixitAction = no_GUI_needed;
		CSourcePhrase* pSrcPhrase = NULL;
		int nWords;
		bool bIsInKB = FALSE;
		AutoFixRecordG* pAutoFixGRec = NULL;
		bool bDeleted = FALSE;
		bool bNonDeletedNonmatch = FALSE;
		CTargetUnit* pTU = NULL;
		CRefString* pRefStr = NULL;
		bool bFoundTgtUnit = TRUE;

		bool bAddedToAFGList = FALSE;
		wxString gloss; // scratch string for holding m_gloss's value
		wxString key; // scratch string for holding m_key's value (unadjusted for caps)
		wxString autoCapsKey; // whatever key becomes after any auto-caps adjustment is done
		bool bInconsistency = FALSE;

		SPList* pPhrases = pApp->m_pSourcePhrases;
		SPList::Node* pos_pPhrases;
		pos_pPhrases = pPhrases->GetFirst();
		wxASSERT(pos_pPhrases != NULL);
		int counter = 0;
		// loop over all CSourcePhrase instances in the m_pSourcePhrases list
		// NOTE: in this loop, I'll have as many inconsistencies as possible fixed without
		// having to put up a dialog; for these I'll still set the local inconsistencyType
		// enum variable even though it is thrown away without use. I do this in case I
		// later change my mind and want to code differently - as thinking of what enum
		// variable fits a given situation takes time and energy, and I don't want to have
		// to do that thinking more than once
		while (pos_pPhrases != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos_pPhrases->GetData();
			key = pSrcPhrase->m_key;
			gloss = pSrcPhrase->m_gloss; // could be an empty string
			pos_pPhrases = pos_pPhrases->GetNext();
			counter++;

			// BEW added 23May16, to fix Mike's problem of lots of legacy upper-case-initial
			// source text words & phrases in the KB causing lots of bogus inconsistencies
			// when auto-capitalizing is ON. We want those just to be ignored
			int numSrcTextWords = pSrcPhrase->m_nSrcWords;
			bool bIgnoreLegacyOne = FALSE;
			if (gbAutoCaps)
			{
				// pass in key 'as is', with no case adjustment
				bIgnoreLegacyOne = pKBCopy->IgnoreLegacyUpperCaseEntry(pKBCopy, numSrcTextWords, gloss);
				if (bIgnoreLegacyOne)
					continue;
			}

			bFoundTgtUnit = FALSE;

			// ignore placeholders and retranslations
			if (pSrcPhrase->m_bNullSourcePhrase || pSrcPhrase->m_bRetranslation)
			{
				if (pSrcPhrase->m_bNullSourcePhrase)
				{
					pSrcPhrase->m_bNotInKB = FALSE; // ensure its off
				}
				continue;
			}

			// BEW 26Aug11 added flag, because testing whether a pTU or pRefString is not
			// found is not an adequate test - not every potential key needs to have a KB
			// presence
			bInconsistency = FALSE;
			pAutoFixGRec = NULL;
			bAddedToAFGList = FALSE; // set TRUE if a created AutoFixRecordG is
									// Append()-ed to the passed in afgList

			// check the KBCopy has the required association of key with translation
			// BEW 13Nov10, changes to support Bob Eaton's request for glosssing KB to use all maps
			nWords = pSrcPhrase->m_nSrcWords;
			pTU = NULL;
			pRefStr = NULL;
			bDeleted = FALSE;

			// Does key have an entry (that is, a ptr to CTargetUnit, and a CRefString
			// within it which has a non-deleted string in its m_translation member which
			// matches the passed in gloss parameter's contents) in the copied glossing
			// KB's map? (Note, this is not a test for a non-NULL pTU, it tests all the
			// way to the gloss contents, returning TRUE only when that matches. To
			// test only for a pTU matching the key value, instead use AutoCapsLookup() )
			bIsInKB = pKBCopy->IsAlreadyInKB(nWords, key, gloss, pTU, pRefStr, bDeleted, bNonDeletedNonmatch);
			if (bIsInKB)
			{
				if (pTU != NULL)
				{
					bFoundTgtUnit = TRUE;
				}
				if (pSrcPhrase->m_bHasGlossingKBEntry)
				{
					// there is a non-deleted entry in the copied KB for the passed in key;
					// if pSrcPhrase has m_bHasGlossingKBEntry set TRUE, and it is not deleted in
					// the KB, this is consistent, so iterate
					wxASSERT(!bDeleted);
					continue;
				}
				else
				{
					// pSrcPhrase->m_bHasGlossingKBEntry is FALSE, so we might have an inconsistency...

					// we might be in a part of the document, where there is no
					// gloss as yet and m_bHasGlossingKBEntry would be FALSE, and fortuitously
					// we matched an earlier source text key that has been given a
					// <no gloss> adaptation which resulted in an empty string for the
					// pTU's CRefString::translation member -- this situation isn't an
					// inconsistency, so check for this and iterate if so
					if (gloss.IsEmpty())
					{
						// it was an empty string match of a "hole" in the document, so
						// no inconsistency here
						continue;
					}
					else
					{
						// pSrcPhrase->m_gloss is not an emptry string; this is an
						// inconsistency which we can auto-correct here & now by setting
						// the flag to agree with the KB entry, no GUI needed for this
						pSrcPhrase->m_bHasGlossingKBEntry = TRUE; // fixed it
						continue;
					} // end of else block for test: if (gloss.IsEmpty())

				} // end of else block for test: if (pSrcPhrase->m_bHasGlossingKBEntry)

			} // end of TRUE block for test: if (bIsInKB)
			else
			{
				// lookup determined that there was no gloss string matched with the given key
				// value in the glossing KB, but that could be for a variety of reasons,
				// including
				// (1) the KB gloss value was deleted (it might have been done
				// deliberately in the KB editor by the user, in order to force the option
				// to split a gloss into different glosses at different locations
				// during this consistency check) -- this is an important feature, and
				// we'll deal with it below first, it's also what the legacy dialog was
				// mostly about, but a redesign of that is called for here
				// (2) pTU exists but the expected pRefStr it should contain isn't there
				// (3) pTU matching the key value was expected to exist but doesn't
				// (4) no pTU exists because the source text key has not hitherto been
				// encountered when glossing, and so this location is a glossing "hole"
				// -- this situation isn't an inconsistency; so we check for (4) first,
				// because if that is not the case, then we've got an inconsistency to fix.
				// For some of these auto-fixing is possible, but where options exist the
				// user will need to be asked...

				// bIsInKB is FALSE, test for a "hole" (& iterate if so, as it would
				// not be an inconsistency) -- doing for (4) above
				if (pSrcPhrase->m_gloss.IsEmpty() && pTU == NULL && !pSrcPhrase->m_bHasGlossingKBEntry)
				{
					// this is a glossing "hole"
					continue;
				}

				// the rest below is for gloss inconsistencies -- whether empty or not

				/* see below, this is the alternative we've rejected, in favour of "splitting a gloss" support
				// keep this in case we later change our mind...

				if (pTU != NULL && pRefStr != NULL && pSrcPhrase->m_gloss.IsEmpty() &&
					pSrcPhrase->m_bHasGlossingKBEntry && bDeleted)
				{
					bFoundTgtUnit = TRUE;

					// This is an inconsistency. The CTargetUnit and CRefString exist, but
					// the latter's m_bDeleted flag is TRUE - which shouldn't be the case
					// if the doc's m_bHasGlossingKBEntry flag is TRUE. There are 3 possibilies,
					// a) it should be a <no gloss> entry (so undelete it), or
					// b) honour the deletion, and so set m_bHasGlossingKBEntry to FALSE, leaving
					// a glossing "hole" in the document here
					bInconsistency = TRUE;
					inconsistencyType = member_empty_flag_on_PTUexists_deleted_Refstr;
					pAutoFixGRec = new AutoFixRecord;
					pAutoFixGRec->nWords = nWords;
					pAutoFixGRec->key = key;
					pAutoFixGRec->oldGloss = gloss;
					pAutoFixGRec->finalGloss = gloss; // BEW 2Nov12, initialize to this value
					pAutoFixGRec->incType = inconsistencyType;
					pAutoFixGRec->fixAction = no_GUI_needed; // a default value
						// until such time as the dialog is shown and the user's
						// fixit choice becomes known & replaces this value

					// the dialog for this one is ConsChk_Empty_noTU_Dlg (and in
					// glossing mode it will have the <Not In KB> option hidden as that is
					// irrelevant for glossing)
				}
				*/
				if (pTU != NULL && pRefStr != NULL && pSrcPhrase->m_gloss.IsEmpty() &&
					pSrcPhrase->m_bHasGlossingKBEntry && bDeleted)
				{
					bFoundTgtUnit = TRUE;

					// This is an inconsistency. The CTargetUnit and CRefString exist, but
					// the latter's m_bDeleted flag is TRUE - which shouldn't be the case
					// if the doc's m_bHasGlossingKBEntry flag is TRUE, and the gloss is an
					// empty string. There are 3 possibilies,
					// a) it should be a <no gloss> entry (so undelete it), or
					// b) honour the deletion, and so set m_bHasGlossingKBEntry to FALSE,
					// leaving a glossing "hole" in the document here, or
					// c) the user wants to "split" an empty gloss to be different in
					// some locations in the dialog (ie. non-empty)

					// NOTE -- supporting c) is incompatible with supporting b) if we stick
					// with just 3 dialogs; if we supported b) we'd use the
					// ConsChk_Empty_noTU_Dlg.h & .cpp, which gives no support to splitting
					// the gloss (it's code block is commented out above); if we support
					// splitting the gloss, then we would use the revamped legacy
					// ConsistencyCheckDlg.h & .cpp. To support all 3 options here would
					// require complicating the latter dialog, or defining a fourth
					// (similar) dialog combining what is in the latter with what is in the
					// former - and this we won't do. The ability to split the gloss
					// meaning is more likely to be useful in real situations than b); so
					// we support the revamped legacy dialog here - which allows the user
					// to at least have a <no gloss> entry put in the glossing KB if he
					// elects to leave the top right box empty.
					bInconsistency = TRUE;
					inconsistencyType = member_empty_flag_on_PTUexists_deleted_Refstr;
					pAutoFixGRec = new AutoFixRecordG;
					pAutoFixGRec->nWords = nWords;
					pAutoFixGRec->key = key;
					pAutoFixGRec->oldGloss = gloss;
					pAutoFixGRec->finalGloss = gloss; // BEW 2Nov12 initialize to this value
					pAutoFixGRec->incType = inconsistencyType;
					pAutoFixGRec->fixAction = no_GUI_needed; // a default value
						// until such time as the dialog is shown and the user's
						// fixit choice becomes known & replaces this value

					// dialog for this we choose to be the revamped legacy ConsistencyCheckDlg.h
					// &.cpp (this excludes two low probability possibilities - see the Note just
					// above)
				}
				else if (pSrcPhrase->m_bHasGlossingKBEntry && pTU != NULL && pRefStr != NULL && bDeleted)
				{
					bFoundTgtUnit = TRUE;

					// this is the 'split gloss' case - the only options are to
					// undelete, or to give a different (contextually defined by the user
					// eye-balling the document to figure out what other gloss is
					// appropriate at the active location rather than the one shown in the
					// phrase box)
					// BEW 1Sep15, the deletion could be because the user edited the KB
					// target text, which also then makes the unedited form become
					// pseudo-deleted. Mike Hore wants these auto-fixed blindly if there
					// is only a single (unique) form associated with the source text form
					// - so we do that here, provided bBlindFix is TRUE
					if (bBlindFix)
					{
						// First, check to make sure there is but a single gloss
						wxString newGloss = _T("");
						bool bIsUnique = pKBCopy->GetUniqueTranslation(nWords, key, newGloss);
						if (bIsUnique)
						{
							// Blind fix this one, do a StoreText() on pKB, then iterate the loop
							pSrcPhrase->m_gloss = newGloss; // StoreText() will do
															// this, but no harm to do it here
							// (Remember, in glossing mode, there is no punctuation stripping or restoring)
							// TRUE in StoreText call is support for a <no adaptation> empty
							// string; if has effect only if newAdaption is empty
							pApp->m_bInhibitMakeTargetStringCall = TRUE;
							pKB->StoreText(pSrcPhrase, pSrcPhrase->m_gloss, TRUE);
							pApp->m_bInhibitMakeTargetStringCall = FALSE;

							continue;
						}
					}
					// If bBlindFix was not chosen in the cons.chk.type dialog, then
					// do the legacy showing of the consistency check dialog
					bInconsistency = TRUE;
					inconsistencyType = member_exists_flag_on_PTUexists_deleted_Refstr;
					pAutoFixGRec = new AutoFixRecordG;
					pAutoFixGRec->nWords = nWords;
					pAutoFixGRec->key = key;
					pAutoFixGRec->oldGloss = gloss;
					pAutoFixGRec->finalGloss = gloss; // BEW 2Nov12 initialize to this value
					pAutoFixGRec->incType = inconsistencyType;
					pAutoFixGRec->fixAction = no_GUI_needed; // a default value
						// until such time as the dialog is shown and the user's
						// fixit choice becomes known & replaces this value

					// dialog for this is the revamped legacy ConsistencyCheckDlg.h &.cpp
				}
				else if (!pSrcPhrase->m_bHasGlossingKBEntry && pTU != NULL && pRefStr != NULL && bDeleted)
				{
					bFoundTgtUnit = TRUE;

					// the flag is not set, and the pRefStr''s m_translation contents has
					// been marked as bDeleted = TRUE; the only thing possible here is
					// that really it shouldn't be deleted (in which case, it should be
					// re-stored in the KB) -- we can fix this one automatically
					bool bStored;
					bStored = pKB->StoreText(pSrcPhrase, gloss);
					bStored = bStored; // avoid warning
					continue;
				}
				// final possibilities -- there was no CTargetUnit returned from the
				// auto-caps lookup done in IsAlreadyInKB(nWords, key, gloss,
				// pTU, pRefStr, bDeleted);
				else if (pTU == NULL)
				{
					bFoundTgtUnit = FALSE;

					if (gloss.IsEmpty())
					{
						// pSrcPhrase says the glossing KB has an entry for this,
						// m_gloss is empty, but there is no pTU
						// Two fixes are possible:
						// (1) a <no gloss> entry added to the glossing KB
						// (2) leave this location unglossed (the fix is then that
						// m_bHasGlossingKBEntry flag needs to be reset to FALSE and
						// nothing is added to the glossingKB)
						inconsistencyType = member_empty_flag_on_noPTU;
						// NOTE: an AutoFixRecord instance is deleted before the next
						 // iteration if not preserved in the afList, and so it only
						 // become an "auto-fix" possibility provided such preservation
						 // happens later below before the loop end is reached

						bInconsistency = TRUE;
						pAutoFixGRec = new AutoFixRecordG;
						pAutoFixGRec->nWords = nWords;
						pAutoFixGRec->key = key;
						pAutoFixGRec->oldGloss = gloss;
						pAutoFixGRec->finalGloss = gloss; // BEW 2Nov12 initialize to this value
						pAutoFixGRec->incType = inconsistencyType;
						pAutoFixGRec->fixAction = no_GUI_needed; // a default value
						// until such time as the dialog is shown and the user's
						// fixit choice becomes known & replaces this value

						// the dialog for this one is ConsChk_Empty_noTU_Dlg with the
						// <Not In KB> option hidden

					} // end of TRUE block for test: if (gloss.IsEmpty())
					else if (pSrcPhrase->m_bHasGlossingKBEntry)
					{
						// pSrcPhrase->m_gloss is not empty, and the flag is TRUE, so
						// only one fix is possible...
						// (1) store the gloss string in the KB - and for that a GUI is
						// not required
						pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // <<-- required so we can store without an assert tripping
						bool bStored;
						bStored = pKB->StoreText(pSrcPhrase, gloss);
						bStored = bStored; // avoid warning
						continue;
					} // end of else if block for test: if (pSrcPhrase->m_bHasKBEntry)
					else
					{
						// This one is: pTU is absent, pSrcPhrase->m_bHasGlossingKBEntry is
						// FALSE but pSrcPhrase->m_gloss has a non-empty value (so it must
						// have had a formerly non-deleted glossing KB entry). We can fix
						// this without any GUI - we StoreText() it (the <Not In KB>
						// option is not supported in glossing mode, hence the one
						// possibility only)
						wxASSERT(!gloss.IsEmpty());
						bool bStored;
						bStored = pKB->StoreText(pSrcPhrase, gloss);
						bStored = bStored; // avoid warning
						continue;
					}
				} // end of TRUE block for test: else if (pTU == NULL)

			} // end of else block for test: if (bIsInKB)

// ******* Inconsistency fixes (by AutoFixRecordG or by dialog) begins here ********

			// open a dialog if we have an inconsistency, or do the fix without a dialog
			// if we match a stored auto-fix record (the latter first, if there is such)
			if (bInconsistency)
			{
				// work out if this is an auto-fix item, if so, don't show the dialog, but
				// use the stored AutoFixRecord to fix the inconsistency without user
				// intervention; note, if the passed in pAutoFixGRec is matched with one
				// stored, then before control returns, the finalGloss and fixAction
				// members are set from the respective values in the matched one stored in
				// the afgList (since it's only those in the list that the user has
				// actually, using the GUI dialogs, specified those values within)
				if (MatchAutoFixGItem(&afgList, pSrcPhrase, pAutoFixGRec))
				{
					switch (pAutoFixGRec->incType)
					{
					case member_empty_flag_on_noPTU:
					case member_empty_flag_on_PTUexists_deleted_Refstr:
					{
						// do the fixit action
						switch (pAutoFixGRec->fixAction)
						{
						case turn_flag_off:
						{
							pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // we've created a glossing "hole"
						}
						break;
						case store_empty_meaning:
						{
							// make a <no gloss> entry in KB
							//pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // enable an error-less store
							pKB->StoreText(pSrcPhrase, pAutoFixGRec->finalGloss, TRUE);
						}
						break;
						case store_nonempty_meaning:
						{
							//#if defined(FWD_SLASH_DELIM)
																// BEW added 23Apr15
							pAutoFixGRec->finalGloss = FwdSlashtoZWSP(pAutoFixGRec->finalGloss);
							//#endif
																// just requires a simple store operation ( and no store
																// in pKCopy should be done)
							pKB->StoreText(pSrcPhrase, pAutoFixGRec->finalGloss);
						}
						break;
						case no_GUI_needed:
						case turn_flag_on:
						case restore_meaning_to_doc:
						case make_it_Not_In_KB:
						default:
						{
							// nothing to do for these here
							;
						}
						break;
						} // end of switch (pAutoFixRec->fixAction)
					} // end of case member_empty_flag_on_PTUexists_deleted_Refstr:
					break;
					case member_exists_flag_on_noPTU:
					case member_exists_flag_off_noPTU:
					{
						; // nothing to do, the one option (a store) was done already
					}
					break;
					case member_exists_flag_on_PTUexists_deleted_Refstr:
					case member_exists_flag_off_PTUexists_deleted_RefStr:
					{
						// if the gloss is null, then assume user wants it that way
						// and so store an empty string, else store whatever it is -- and
						// since the actions all involve just a StoreText() call, we don't
						// need a switch based on actionTaken in order to do what we need
						// to do
						wxString tempStr = pAutoFixGRec->finalGloss;

						// update the original kb (not pKBCopy)
						//pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // makes the store call safe to do
						if (tempStr.IsEmpty())
						{
							// TRUE = allow empty string storage
							pKB->StoreText(pSrcPhrase, tempStr, TRUE);

						}
						else
						{
							//#if defined(FWD_SLASH_DELIM)
															// BEW added 23Apr15
							tempStr = FwdSlashtoZWSP(tempStr);
							//#endif
							pKB->StoreText(pSrcPhrase, tempStr);
						}

					} // end of case member_exists_flag_off_PTUexists_deleted_RefStr:
					break;
					case flag_on_NotInKB_off_hasActiveNotInKB_in_KB:
					default:
					{
						// nothing to do, these are autofixed without needing any GUI
						;
					}
					break;
					} // end of switch (pAutoFixGRec->incType)

					pApp->m_targetPhrase = pAutoFixGRec->finalGloss; // any brief glimpse
						// of the box should show the current gloss string
						// BEW 13Apr15 don't replace / with ZWSP for the above assignment to m_targetPhrase

				} // end of TRUE block for test: if (MatchAutoFixItem(&afList, pSrcPhrase, pAFRecord))
				else
				{
					// no match, so this is has to be handled with user intervention via
					// the dialogs

					// update the view to show the location where this source pile is, and
					// put the phrase box there ready to accept user input indirectly from
					// the dialog, return ptr to the phrase box's cell in the view
					CCell* pCell = LayoutDocForConsistencyCheck(pApp, pSrcPhrase, pPhrases);

					switch (pAutoFixGRec->incType)
					{
					case member_empty_flag_on_noPTU:
					case member_empty_flag_on_PTUexists_deleted_Refstr:
					{
						pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);   // mrh June19 - ensure phrasebox is on screen before we put the dialog up
						wxString titleStr = _("Inconsistency Found");
						wxString aSrcStr = pSrcPhrase->m_key;
						wxString aTgtStr = pSrcPhrase->m_gloss;
						pAutoFixGRec->oldGloss = pSrcPhrase->m_gloss; // BEW 2Nov12 initialize to this value
						bool bShowItCentered = TRUE;
						ConsChk_Empty_noTU_Dlg dlg(
							(wxWindow*)gpApp->GetMainFrame(),
							&titleStr,
							&aSrcStr,
							&aTgtStr,
							&gpApp->m_modeWordGloss,
							&gpApp->m_modeWordGlossPlusArticle,
							&gpApp->m_strNotInKB,
							&gpApp->m_strNoGloss,
							bShowItCentered);

						// provide hooks for the phrase box location so that the dialog can
						// work out where to display itself so it does not obscure the active
						// location
						dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
						dlg.m_nTwoLineDepth = 2 * pLayout->GetTgtTextHeight();

						if (dlg.ShowModal() == wxID_OK)
						{
							// get and store the FixItAction
							pAutoFixGRec->fixAction = dlg.actionTaken;
							// pAutoFixGRec->finalGloss is already set to the empty
							// string passed in for the gloss; however, if the user
							// elected to type a different gloss for storage, then
							// get it now
							if (dlg.actionTaken == store_nonempty_meaning)
							{
								pAutoFixGRec->finalGloss = dlg.m_aorgTextCtrlStr;
								//#if defined(FWD_SLASH_DELIM)
																// BEW added 23Apr15
								pAutoFixGRec->finalGloss = FwdSlashtoZWSP(pAutoFixGRec->finalGloss);
								//#endif
							}

							// if the m_bDoAutoFix flag is set, add this 'fix' to a list for
							// subsequent use
							if (dlg.m_bDoAutoFix)
							{
								bAddedToAFGList = TRUE; // <<- BEW added 30Aug11, the new code needs it
								afgList.Append(pAutoFixGRec);
							}

							// do the fixit action
							switch (pAutoFixGRec->fixAction)
							{
							case turn_flag_off:
							{
								pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // we've created a glossing "hole"
							}
							break;
							case store_empty_meaning:
							{
								// make a <no gloss> entry in KB
								pKB->StoreText(pSrcPhrase, pAutoFixGRec->finalGloss, TRUE);
							}
							break;
							case store_nonempty_meaning:
							{
								// just requires a simple store operation ( and no store
								// in pKCopy should be done)
//#if defined(FWD_SLASH_DELIM)
									// BEW added 23Apr15
								pAutoFixGRec->finalGloss = FwdSlashtoZWSP(pAutoFixGRec->finalGloss);
								//#endif
								pKB->StoreText(pSrcPhrase, pAutoFixGRec->finalGloss);
							}
							break;
							// whm 19Sep11 added the case items below to avoid g++ warnings about unused
							// enums.
							// This is based on a similar switch statement above at line 23204 where bruce
							// appears to have done the same thing.
							case no_GUI_needed:
							case turn_flag_on:
							case restore_meaning_to_doc:
							case make_it_Not_In_KB:
							default:
							{
								// nothing to do for these here
								;
							}
							break;
							} // end of switch (pAutoFixRec->fixAction)
						}
						else
						{
							bUserCancelled = TRUE;
							break;
						}
					} // end of case member_empty_flag_on_PTUexists_deleted_Refstr:
					break;
					case member_exists_flag_on_noPTU:
					case member_exists_flag_off_noPTU:
					{
						//wxString titleStr = _("Inconsistency Found");
						//wxString aSrcStr = pSrcPhrase->m_key;
						//wxString aTgtStr = pSrcPhrase->m_gloss;
						//bool bShowItCentered = TRUE;

						// no GUI for this, the only option is to store it, and we
						// don't need a GUI widget for that (it's done already)
						;
					}
					break;
					case member_exists_flag_on_PTUexists_deleted_Refstr:
					case member_exists_flag_off_PTUexists_deleted_RefStr:
					{
						// The revamped legacy dialog - now simplified
						pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);   // mrh June19 - ensure phrasebox is on screen before we put the dialog up
						CConsistencyCheckDlg dlg(pApp->GetMainFrame());
						dlg.m_bFoundTgtUnit = bFoundTgtUnit;
						dlg.m_bDoAutoFix = FALSE;
						dlg.m_pApp = pApp;
						dlg.m_pKBCopy = pKBCopy;
						dlg.m_pTgtUnit = pTU; // could be null
						dlg.m_finalAdaptation = pSrcPhrase->m_gloss; // initialize final chosen adaptation or gloss
						pAutoFixGRec->oldGloss = pSrcPhrase->m_gloss; // BEW 2Nov12 initialize to this value
						dlg.m_pSrcPhrase = pSrcPhrase;
						// get the chapter and verse
						wxString chVerse = pApp->GetView()->GetChapterAndVerse(pSrcPhrase);
						dlg.m_chVerse = chVerse;

						// provide hooks for the phrase box location so that the dialog can
						// work out where to display itself so it does not obscure the active
						// location
						dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
						dlg.m_nTwoLineDepth = 2 * pLayout->GetTgtTextHeight();

						// only glossing needs this test; really its three lines, but the code
						// works provided the height is right
						if (gbGlossingUsesNavFont)
							dlg.m_nTwoLineDepth += pLayout->GetNavTextHeight();

						// put up the dialog
						if (dlg.ShowModal() == wxID_OK)
						{
							if (dlg.m_bIgnoreIt)
							{
								// skip rest of this block, don't change KB, don't change doc
								;
							}
							else
							{
								// get and store the FixItAction (all 3 possibilities are storage
								// actions: store_nonempty_meaning, store_empty_meaning, or
								// restore_meaning_to_doc); also get the user's final string
								pAutoFixGRec->fixAction = dlg.actionTaken;
								pAutoFixGRec->finalGloss = dlg.m_finalAdaptation;
								//#if defined(FWD_SLASH_DELIM)
																// BEW added 23Apr15
								pAutoFixGRec->finalGloss = FwdSlashtoZWSP(pAutoFixGRec->finalGloss);
								//#endif
															// if the m_bDoAutoFix flag is set, add this 'fix' to a list for
															// subsequent use
								if (dlg.m_bDoAutoFix)
								{
									bAddedToAFGList = TRUE; // <<- BEW added 30Aug11, the new code needs it
									afgList.Append(pAutoFixGRec);
								}

								// if the adaptation is null, then assume user wants it that way
								// and so store an empty string, else store whatever it is -- and
								// since the actions all involve just a StoreText() call, we don't
								// need a switch based on actionTaken in order to do what we need
								// to do
								wxString tempStr = pAutoFixGRec->finalGloss;

								// update the original kb (not pKBCopy)
								if (tempStr.IsEmpty())
								{
									// TRUE = allow empty string storage
									pKB->StoreText(pSrcPhrase, tempStr, TRUE);
									// StoreText() sets m_gloss for glossing KB
								}
								else
								{
									//#if defined(FWD_SLASH_DELIM)
																	// BEW added 23Apr15
									tempStr = FwdSlashtoZWSP(tempStr);
									//#endif
																	// glossing store can have punctuation in it
									pKB->StoreText(pSrcPhrase, tempStr);
									// StoreText() sets m_gloss for glossing KB

								} // end of else block for test: if (tempStr.IsEmpty())
							} // end of else block for test: if (dlg.m_bIgnoreIt)
						} // end of TRUE block for test of ShowModal() == wxID_OK
						else
						{
							// user cancelled
							bUserCancelled = TRUE;
							break;
						}
					} // end of case member_exists_flag_off_PTUexists_deleted_RefStr:
					break;
					case flag_on_NotInKB_off_hasActiveNotInKB_in_KB:
					default:
					{
						// nothing to do, these are autofixed without needing any GUI
						;
					}
					break;
					} // end of switch (pAFRecord->incType)
					if (bUserCancelled)
					{
						break; // again, this time from the consistency check loop for
							   // this doc, so that code below can cancel the overall check
					}

				}  // end of else block for test: if (MatchAutoFixItem(&afgList, pSrcPhrase, pAFRecordG))

			} // end of TRUE block for test: if (bInconsistency)

			if (pAutoFixGRec != NULL && !bAddedToAFGList)
			{
				// always delete the local AutoFixGRec instance, if we made one, but only
				// provided we don't want it preserved for doing auto-fixing by previously
				// having it added to the passed in afList earlier in the loop
				delete pAutoFixGRec;
			}
			pAutoFixGRec = NULL;
		}// end of while (pos_pPhrases != NULL)

		// save document and KB
		pApp->m_pTargetBox->HidePhraseBox(); // hides all three parts of the new phrasebox

		// store to kb with a source phrase with m_bHasKBEntry flag
		// TRUE, which would cause an assert to trip
		pApp->m_pTargetBox->GetTextCtrl()->ChangeValue(_T("")); // need to set it to null str
												 // since it won't get recreated
		// BEW removed 29Apr10 in favour of the "_Protected" version below, to
		// give better data protection
		//bool bSavedOK = pDoc->DoFileSave(TRUE);

		// BEW 9July10, added test and changed param to FALSE if doing bible book folders
		// loop, as we don't want time wasted for a progress dialog for what are probably a
		// lot of short files. DoFileSave_Protected() computes pApp->m_curOutputPath for
		// each doc file that we check in the currently accessed folder
		bool bSavedOK = DoFileSave_Protected(FALSE, _T("")); // FALSE - dodn't show wait/progress dialog
		if (!bSavedOK)
		{
			wxMessageBox(_("Warning: failure on document save operation."),
				_T(""), wxICON_EXCLAMATION | wxOK);
		}
		pApp->GetView()->ClobberDocument(); // BEW 13Jul19 sets m_bDocumentDestroyed to TRUE (only DoAutoSaveDoc() uses)
		//pApp->m_bDocumentDestroyed = FALSE; // re-initialize (to permit DoAutoSaveDoc() to work)

		// delete the buffer containing the filed-in source text
		if (pApp->m_pBuffer != NULL)
		{
			delete pApp->m_pBuffer;
			pApp->m_pBuffer = NULL;
		}
		if (bUserCancelled)
			break; // don't do any more saves of the KB if user cancelled
	}
	// ****************  end iteration of document files for (int i=0; i < nCount; i++)  ************************

	gbConsistencyCheckCurrent = FALSE;	// restore normal default

	GetLayout()->m_docEditOperationType = consistency_check_op; // sets 0,-1 'select all'
	return TRUE;
}

// BEW created 7Sep11, to get the layout redrawn at the new box position when it has moved
// to an inconsistency found in either DoConsistencyCheck() or DoConsistencyCheckG() - the
// latter one is used in Glossing mode; return ref to CCell pointer for the top left of
// where the phrase box will be in the view, via pCell param.
CCell* CAdapt_ItDoc::LayoutDocForConsistencyCheck(CAdapt_ItApp* pApp, CSourcePhrase* pSrcPhrase,
	SPList* pPhrases)
{
	doc_edit_op op = consistency_check_op;

	// @@@ do something about this...
	int nActiveSequNum = pSrcPhrase->m_nSequNumber;
	wxASSERT(nActiveSequNum >= 0);
	pApp->m_nActiveSequNum = nActiveSequNum; // added 16Apr09, should be okay
	// and is needed because CLayout::RecalcLayout() relies on the
	// m_nActiveSequNum value being correct
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pPhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(nActiveSequNum);

	pApp->GetMainFrame()->canvas->ScrollIntoView(nActiveSequNum);
	CCell* pCell = pApp->m_pActivePile->GetCell(1); // the cell where
											 // the phraseBox is to be
	// make it look normal, don't use m_targetStr here
	pApp->m_targetPhrase = pSrcPhrase->m_adaption;

	GetLayout()->m_docEditOperationType = op; // sets 0,-1 'select all'
	pApp->GetView()->Invalidate(); // get the layout drawn
	GetLayout()->PlaceBox();
	return pCell;
}


// Return TRUE if the pRecTest passed in matches. For version 2.0 and later which supports
// glossing, pRec could contain glossing or adapting information, depending on the setting
// for the gbIsGlossing flag. Also, in support of auto capitalization; since these strings
// are coming from the sourcephrase instances in the documents, they will have upper or
// lower case as appropriate; but we will need to allow the user to just type lower case
// strings when correcting in the context of AutoCaps being turned ON, so be careful!
// BEW 12Apr10, no change needed for support of doc version 5
// BEW 17May10, moved to here from CAdapt_ItView
// BEW 13Nov10, no changes to support Bob Eaton's request for glosssing KB to use all maps
// BEW 6Sep11, changed to support revampted consistency check feature, and made a "G"
// variant for glossing mode
bool CAdapt_ItDoc::MatchAutoFixItem(AFList* pList, CSourcePhrase* pSrcPhrase,
	AutoFixRecord* pRecTest)
{
	wxASSERT(pList != NULL);
	wxASSERT(pSrcPhrase != NULL);
	if (pList->IsEmpty() || pRecTest == NULL)
		return FALSE;
	AFList::Node* pos_pList = pList->GetFirst();
	wxASSERT(pos_pList != NULL);
	while (pos_pList != NULL)
	{
		AutoFixRecord* pRec = (AutoFixRecord*)pos_pList->GetData();
		pos_pList = pos_pList->GetNext();
		if (pRec->key == pSrcPhrase->m_key && pRec->oldAdaptation == pSrcPhrase->m_adaption)
		{
			if (pRec->incType == pRecTest->incType)
			{
				// the inconsistency types are the same (and have to be for a match)
				// NOTE:
				// the passed in pRecTest won't have had it's finalAdaptation member set
				// yet and if we get a match and pass it back without setting the value
				// from the stored one which contains the user's typed value, we'll be
				// working with an always empty string! So set it now...; same applies for
				// the fixAction enum value
				pRecTest->finalAdaptation = pRec->finalAdaptation;
				pRecTest->fixAction = pRec->fixAction;
				return TRUE;
			}
		}
	}
	// if we get to here, no match was made
	return FALSE;
}

// Return TRUE if the pRecTest passed in matches. For version 2.0 and later which supports
// glossing, rpRec could contain glossing or adapting information, depending on the setting
// for the gbIsGlossing flag. Also, in support of auto capitalization; since these strings
// are coming from the sourcephrase instances in the documents, they will have upper or
// lower case as appropriate; but we will need to allow the user to just type lower case
// strings when correcting in the context of AutoCaps being turned ON, so be careful!
// BEW 6Sep11, added to support revampted consistency check feature, this is the "G"
// variant for glossing mode
// BEW 13Sep11, made final param just be the pointer, not pointer reference, because in
// the new algorithm of DoConsistencyCheck() and DoConsistencyCheckG() we have no need to
// pass back to the caller the pointer matched, (and the earlier code passed back NULL for
// a non-match, which produced failure later in the caller)
bool CAdapt_ItDoc::MatchAutoFixGItem(AFGList* pList, CSourcePhrase* pSrcPhrase,
	AutoFixRecordG* pRecTest)
{
	wxASSERT(pList != NULL);
	wxASSERT(pSrcPhrase != NULL);
	if (pList->IsEmpty() || pRecTest == NULL)
		return FALSE;
	AFGList::Node* pos_pList = pList->GetFirst();
	wxASSERT(pos_pList != NULL);
	while (pos_pList != NULL)
	{
		AutoFixRecordG* pRec = (AutoFixRecordG*)pos_pList->GetData();
		pos_pList = pos_pList->GetNext();
		if (pRec->key == pSrcPhrase->m_key && pRec->oldGloss == pSrcPhrase->m_gloss)
		{
			if (pRec->incType == pRecTest->incType)
			{
				// the inconsistency types are the same (and have to be for a match)
				// NOTE:
				// the passed in pRecTest won't have had it's finalAdaptation member set
				// yet and if we get a match and pass it back without setting the value
				// from the stored one which contains the user's typed value, we'll be
				// working with an always empty string! So set it now...; same applies for
				// the fixAction enum value
				pRecTest->finalGloss = pRec->finalGloss;
				pRecTest->fixAction = pRec->fixAction;
				return TRUE;
			}
		}
	}
	// if we get to here, no match was made
	return FALSE;
}

// BEW 24Mar10, updated for support of doc version 5 (some changes needed)
// BEW 25Mar15, some refactoring of the marker extraction code was needed because
// the original code worked right only provided two successive markers had at least
// one space between them, and that isn't a requirement of the data model - for instance
// our Hezekiah 7 document had \p\v in m_markers member of 16 CSourcePhrase instances.
// The GetMarkersAndEndMarkersFromString() function, called internally, also needed refactoring
// in a similar way, because \p\v defeated the algorithm.
void CAdapt_ItDoc::GetMarkerInventoryFromCurrentDoc()
{
	// Scans all the doc's source phrase m_markers and m_filteredInfo members and
	// inventories all the markers used in the current document, storing all unique markers
	// in m_exportBareMarkers, the full markers and their descriptions in the CStringArray
	// called m_exportMarkerAndDescriptions, and their corresponding include/exclude states
	// (boolean flags) in the CUIntArray called m_exportFilterFlagsBeforeEdit. A given
	// marker may occur more than once in a given document, but is only stored once in
	// these inventory arrays.
	// All the boolean flags in the m_exportFilterFlagsBeforeEdit array
	// are initially set to FALSE indicating that no markers are to be
	// filtered out of the export by default. If the user accesses and/or
	// changes the export options via the "Export/Filter Options" dialog
	// and thereby filters one or markers from export, then their
	// corresponding flags in the CUIntArray called m_exportFilterFlags
	// will be set to TRUE.
	// BEW 25Mar15, Note: markers which in Adapt It are considered inline binding or
	// inline non-binding are not entered into the inventory. These are not filterable
	// because to do so would remove some scripture content from being adaptable.

	// Any sfms that are currently filtered are listed with [FILTERED] prefixed
	// to the description. Unknown markers are listed with [UNKNOWN MARKER] as
	// their description. We list all markers that are used in the document, and
	// if the user excludes things illogically, then the output will reflect
	// that.
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	wxArrayString MarkerList;	// gets filled with all the currently
								// used markers including filtered ones
	wxArrayString* pMarkerList = &MarkerList;
	SPList::Node* posn;
	USFMAnalysis* pSfm;
	wxString key;
	wxString lbStr;

	//MapSfmToUSFMAnalysisStruct* pSfmMap; // unused
	//pSfmMap = pApp->GetCurSfmMap(pApp->gCurrentSfmSet);

	// Gather markers from all source phrase m_marker strings
	// BEW 24Mar10 changes for support of doc version 5: markers are now stored in
	// m_markers and in m_filteredInfo (markers and content wrapped, in the latter, with
	// \~FILTER and \~FILTER* bracketing markers). Also, in the legacy versions, free
	// translations, collected back translations, and notes, were stored likewise in
	// m_markers and wrapped with filter bracket markers, but now for doc version 5 these
	// three information types have dedicated wxString member storage in CSourcePhrase. So
	// for correct behaviour with the functionalities dependent on
	// GetMarkerInventoryFromCurrentDoc() we have to here treat those three information
	// types as logically "filtered" and supply \free & \free* wrapping markers to the
	// free translation string we recover, and \note & \note* to the note string we
	// recover, and \bt for any collected back translation string, when any of these is
	// present in m_freeTrans, m_note, and m_collectedBackTrans, respectively. We do that
	// below after the call to GetMarkersAndEndMarkersFromString(), as the latter can handle the
	// m_markers added to m_filteredInfo in the parameter list.
	posn = pList->GetFirst();
	wxASSERT(posn != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)posn->GetData();
	wxASSERT(pSrcPhrase);
	wxString str;
	str.Empty();
	wxString filtermkr = wxString(filterMkr);
	wxString filtermkrend = wxString(filterMkrEnd);
	while (posn != 0)
	{
		pSrcPhrase = (CSourcePhrase*)posn->GetData();
#if defined (_DEBUG) && !defined(NOLOGS)
		wxLogDebug(_T("%s,SrcPhrase: %s  sn = %d"), __FUNCTION__, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_nSequNumber);
#endif
		posn = posn->GetNext();
		wxASSERT(pSrcPhrase);
		// retrieve sfms used from pSrcPhrase->m_markers & m_filteredInfo, etc
		if (!pSrcPhrase->m_markers.IsEmpty() || !pSrcPhrase->GetFilteredInfo().IsEmpty())
		{
			// GetMarkersAndEndMarkersFromString() retrieves each marker and its associated
			// string and places them in the CStringList. Any Filtered markers are stored
			// as a list item bracketed by \~FILTER ... \~FILTER* markers.
			// To avoid a large CStringList developing we'll process the markers in each
			// m_markers string individually, so empty the list. Information in
			// m_freeTrans, m_note, or m_collectedBackTrans is handled after the
			// GetMarkersAndEndMarkersFromString() call
			pMarkerList->Clear();
			GetMarkersAndEndMarkersFromString(pMarkerList, pSrcPhrase->m_markers + pSrcPhrase->GetFilteredInfo(),
				pSrcPhrase->GetEndMarkers());
			if (!pSrcPhrase->GetFreeTrans().IsEmpty())
			{
				str = filtermkr + _T(" ") + _T("\\free ") + pSrcPhrase->GetFreeTrans() + _T("\\free* ") + filtermkrend;
				pMarkerList->Add(str);
				str.Empty();
			}
			if (!pSrcPhrase->GetNote().IsEmpty())
			{
				str = filtermkr + _T(" ") + _T("\\note ") + pSrcPhrase->GetNote() + _T("\\note* ") + filtermkrend;
				pMarkerList->Add(str);
				str.Empty();
			}
			if (!pSrcPhrase->GetCollectedBackTrans().IsEmpty())
			{
				str = filtermkr + _T(" ") + _T("\\bt ") + pSrcPhrase->GetCollectedBackTrans() + _T(" ") + filtermkrend;
				pMarkerList->Add(str);
				str.Empty();
			}
			wxString resultStr;
			resultStr.Empty();
			wxString displayStr;
			wxString bareMarker;
			wxString temp;
			int ct;
			for (ct = 0; ct < (int)pMarkerList->GetCount(); ct++)
			{
				resultStr = pMarkerList->Item(ct);
				bool markerIsFiltered;
				if (resultStr.Find(filterMkr) != -1)
				{
					resultStr = RemoveAnyFilterBracketsFromString(resultStr);
					markerIsFiltered = TRUE;
				}
				else
				{
					markerIsFiltered = FALSE;
				}
				resultStr.Trim(FALSE); // trim left end
				resultStr.Trim(TRUE); // trim right end
				wxASSERT(resultStr.Find(gSFescapechar) == 0);
				int strLen = resultStr.Length();
				int posm = 1; // skip initial backslash
				bareMarker.Empty();
				displayStr.Empty();
				while (posm < strLen && resultStr[posm] != _T(' ') &&
					resultStr[posm] != gSFescapechar)
				{
					bareMarker += resultStr[posm];
					posm++;
				}
				bareMarker.Trim(FALSE); // trim left end
				bareMarker.Trim(TRUE); // trim right end

				// do not include end markers in this inventory
				int aPos = bareMarker.Find(_T('*'));
				if (aPos == (int)bareMarker.Length() - 1)
					bareMarker.Remove(aPos, 1);
				wxASSERT(bareMarker.Length() > 0);
				// lookup the marker in the active USFMAnalysis struct map
				// whm ammended 11Jul05 Here we want to use the LookupSFM() routine which
				// treats all \bt... initial back-translation markers as known markers all
				// under the \bt marker with its description "Back-translation"
				// whm revised again 14Nov05. For output filtering purposes, we need to
				// treat all \bt... initial forms the same as simple \bt, in order to give
				// the user the placement options (boxed paragraphs or footnote format for
				// sfm RTF output; new table row or footnote format for interlinear RTF
				// output). Handling all backtranslation the same for the sake of these
				// placement options I think is preferable to not having the placement
				// options and being able to filter from output the possible different
				// kinds of backtranslation \bt... markers. Therefore here we will make all
				// \bt... be just simple \bt and hence only have \bt in the export options
				// list box. I've also renamed the \bt marker's description in AI_USFM.xml
				// file to read: "Back Translation (and all \bt... initial forms)".
				if (bareMarker.Find(_T("bt")) == 0)
				{
					bareMarker = _T("bt"); // make any \bt... initial forms be just
										   // \bt in the listbox
				}
				pSfm = LookupSFM(bareMarker); // use LookupSFM which properly
													// handles \bt... forms as \bt
				bool bFound = pSfm != NULL;
				lbStr = _T(' '); // prefix one initial space - looks better
								 // in a CCheckListBox
				lbStr += gSFescapechar; // add backslash
				// Since LookupSFM will find any back-translation marker of the form
				// bt... we'll use the actual bareMarker to build the list box string
				lbStr += bareMarker;
				// We don't worry about adjusting for text extent here - that is done below
				// in FormatMarkerAndDescriptionsStringArray(). Here we will just add a
				// single space as delimiter between the whole marker and its description
				lbStr += _T(' ');
				if (!bFound)
				{
					// unknown marker so make the description [UNKNOWN MARKER]
					// IDS_UNKNOWN_MARKER
					temp = _("[UNKNOWN MARKER]"); // prefix description
												  // with "[UNKNOWN MARKER]"
					lbStr = lbStr + temp;
				}
				else
				{
					if (markerIsFiltered)
					{
						// IDS_FILTERED
						temp = _("[FILTERED]"); // prefix description
												// with "[FILTERED] ..."
						lbStr += temp;
						lbStr += _T(' ');
						lbStr += pSfm->description;
					}
					else
					{
						lbStr += pSfm->description;
					}
				}
				// Have we already stored this marker?
				bool mkrAlreadyExists = FALSE;
				for (int ct = 0; ct < (int)m_exportMarkerAndDescriptions.GetCount(); ct++)
				{
					if (lbStr == m_exportMarkerAndDescriptions[ct])
					{
						mkrAlreadyExists = TRUE;
						break;
					}
				}
				if (!mkrAlreadyExists)
				{
					// BEW addition 16Aug09, to exclude \note, \bt and/or \free markers
					// when exporting either free translations or glosses as text
					if (pApp->m_bExportingFreeTranslation || pApp->m_bExportingGlossesAsText)
					{
						if (bareMarker == _T("note") ||
							bareMarker == _T("free") ||
							bareMarker == _T("bt"))
						{
							continue; // ignore any of these marker types
						}
						else
						{
							// anything else gets added to the inventory
							m_exportBareMarkers.Add(bareMarker);
							m_exportMarkerAndDescriptions.Add(lbStr);
							m_exportFilterFlags.Add(FALSE);
							m_exportFilterFlagsBeforeEdit.Add(FALSE);
						}
					}
					else
					{
						m_exportBareMarkers.Add(bareMarker);
						m_exportMarkerAndDescriptions.Add(lbStr);
						m_exportFilterFlags.Add(FALSE); // export defaults to nothing
														// filtered out
						m_exportFilterFlagsBeforeEdit.Add(FALSE); // export defaults to
																  // nothing filtered out
					}
				}
			}
		}
	}
	wxClientDC dC(pApp->GetMainFrame()->canvas);
	pApp->FormatMarkerAndDescriptionsStringArray(&dC,
		&m_exportMarkerAndDescriptions, 2, NULL);
	// last parameter in call above is 2 spaces min
	// between whole marker and its description
}

// BEW 8Oct11, simplified for collaboration (we don't bother with content strings) and we
// DO need to include \free, \note, and \bt marker (as bare markers, free, note, bt) for
// free translation export unlike the original - but we still set m_exportBareMarkers
// string with the unique markers in the doc, and we set their default filter status
// directly in the parallel wxArrayInt, m_exportFilterFlags rather than in
// m_exportFilterFlagsBeforeEdit because the user doesn't get a chance to affect the
// results with this variant
// BEW 25Mar15, added 3rd argument to GetMarkersAndEndMarkersFromString() because now endmarkers
// are not stored in m_markers, but in m_endMarkers
void CAdapt_ItDoc::GetMarkerInventoryFromCurrentDoc_For_Collab()
{
	// Scans all the doc's source phrase m_markers and m_filteredInfo members and
	// inventories all the markers used in the current document, storing all unique markers
	// in m_exportBareMarkers, the full markers in the local wxArrayString called
	// MarkerList), and their corresponding include/exclude states (boolean flags) in the
	// wxArrayInt called m_exportFilterFlags. A given marker may occur more than once in a
	// given document, but is only stored once in m_exportBareMarkers array, and maybe
	// multiple times in MarkerList from which the former is generated. All the boolean
	// flags FALSE unless the marker is filtered, in which case it is TRUE - and these
	// settings are stored in m_exportFilteredFlags
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	wxArrayString MarkerList;	// gets filled with all the currently
								// used markers including filtered ones
	wxArrayString* pMarkerList = &MarkerList;
	SPList::Node* posn;
	wxString key;

	// Gather markers from all source phrase m_marker strings BEW 24Mar10 changes for
	// support of doc version 5: markers are now stored in m_markers and in m_filteredInfo
	// (markers and content wrapped, in the latter, with \~FILTER and \~FILTER* bracketing
	// markers). Also, in the legacy versions, free translations, collected back
	// translations, and notes, were stored likewise in m_markers and wrapped with filter
	// bracket markers, but now for doc version 5 these three information types have
	// dedicated wxString member storage in CSourcePhrase. So for correct behaviour with
	// the collaboration functionality we have to here treat those three information types
	// as logically "filtered" and supply \free & \free* wrapping markers to the free
	// translation string we recover, and \note & \note* to the note string we recover, and
	// \bt for any collected back translation string, when any of these is present in
	// m_freeTrans, m_note, and m_collectedBackTrans, respectively. We do that below after
	// the call to GetMarkersAndEndMarkersFromString(), as the latter can handle the m_markers
	// added to m_filteredInfo in the parameter list. These 3 are obligatorily filtered, so
	// by adding the wrappers the code below will properly set the boolean markerIsFiltered
	// to TRUE when removing that stuff again
	posn = pList->GetFirst();
	wxASSERT(posn != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)posn->GetData();
	wxASSERT(pSrcPhrase);
	wxString str;
	str.Empty();
	wxString filtermkr = wxString(filterMkr);
	wxString filtermkrend = wxString(filterMkrEnd);
	bool markerIsFiltered;
	while (posn != 0)
	{
		pSrcPhrase = (CSourcePhrase*)posn->GetData();
		posn = posn->GetNext();
		wxASSERT(pSrcPhrase);
		// retrieve sfms used from pSrcPhrase->m_markers & m_filteredInfo, etc

		// GetMarkersAndEndMarkersFromString() retrieves each marker and its associated string
		// and places them in the CStringList. Any Filtered markers are stored as a list
		// item bracketed by \~FILTER ... \~FILTER* markers. To avoid a large CStringList
		// developing we'll process the markers in each m_markers string individually, so
		// empty the list on each iteration. Non-empty m_freeTrans, m_note, or
		// m_collectedBackTrans is handled after the GetMarkersAndEndMarkersFromString() call
		pMarkerList->Clear();
		GetMarkersAndEndMarkersFromString(pMarkerList, pSrcPhrase->m_markers + pSrcPhrase->GetFilteredInfo(),
			pSrcPhrase->GetEndMarkers());
		if (!pSrcPhrase->GetFreeTrans().IsEmpty())
		{
			str = filtermkr + _T(" ") + _T("\\free ") + pSrcPhrase->GetFreeTrans() + _T("\\free* ") + filtermkrend;
			pMarkerList->Add(str);
			str.Empty();
		}
		if (!pSrcPhrase->GetNote().IsEmpty())
		{
			str = filtermkr + _T(" ") + _T("\\note ") + pSrcPhrase->GetNote() + _T("\\note* ") + filtermkrend;
			pMarkerList->Add(str);
			str.Empty();
		}
		if (!pSrcPhrase->GetCollectedBackTrans().IsEmpty())
		{
			str = filtermkr + _T(" ") + _T("\\bt ") + pSrcPhrase->GetCollectedBackTrans() + _T(" ") + filtermkrend;
			pMarkerList->Add(str);
			str.Empty();
		}
		wxString resultStr;
		resultStr.Empty();
		wxString bareMarker;
		wxString temp;
		int ct;
		for (ct = 0; ct < (int)pMarkerList->GetCount(); ct++)
		{
			resultStr = pMarkerList->Item(ct);
			if (resultStr.Find(filterMkr) != -1)
			{
				resultStr = RemoveAnyFilterBracketsFromString(resultStr);
				markerIsFiltered = TRUE;
			}
			else
			{
				markerIsFiltered = FALSE;
			}
			resultStr.Trim(FALSE); // trim left end
			resultStr.Trim(TRUE); // trim right end
			wxASSERT(resultStr.Find(gSFescapechar) == 0);
			int strLen = resultStr.Length();
			int posm = 1; // skip initial backslash
			bareMarker.Empty();
			while (posm < strLen && resultStr[posm] != _T(' ') &&
				resultStr[posm] != gSFescapechar)
			{
				bareMarker += resultStr[posm];
				posm++;
			}
			bareMarker.Trim(FALSE); // trim left end
			bareMarker.Trim(TRUE); // trim right end

			// do not include end markers in this inventory
			int aPos = bareMarker.Find(_T('*'));
			if (aPos == (int)bareMarker.Length() - 1)
				bareMarker.Remove(aPos, 1);
			wxASSERT(bareMarker.Length() > 0);

			// Have we already stored this marker?
			bool mkrAlreadyExists = FALSE;
			int mkscount = (int)m_exportBareMarkers.GetCount();
			for (int ct = 0; ct < mkscount; ct++)
			{
				if (bareMarker == m_exportBareMarkers[ct])
				{
					mkrAlreadyExists = TRUE;
					break;
				}
			}
			if (!mkrAlreadyExists)
			{
				m_exportBareMarkers.Add(bareMarker);
				if (markerIsFiltered)
				{
					m_exportFilterFlags.Add(FALSE);
				}
				else
				{
					m_exportFilterFlags.Add(FALSE);
				}
			}
		}
	} // end of loop: while (posn != 0)    which loops over m_pSourcePhrases
}


/////////////////////////////////////////////////
///
/// Functions for support of Auto-Capitalization
///
////////////////////////////////////////////////

inline wxChar CAdapt_ItDoc::GetFirstChar(wxString& strText)
{
	// whm 11Jun12 Note: The caller SetCaseParameters() does a check to see
	// if strText is empty, and if so returns FALSE before calling this
	// function, so I'll just add a wxASSERT() statement.
	wxASSERT(!strText.IsEmpty());
	return strText.GetChar(0);
}

// takes the input character chTest, and attempts to Find() it in the CString theCharSet,
// returning TRUE if it finds it, and setting index to the character index for its position
// in the string buffer; if not found, then index will be set to -1.
bool CAdapt_ItDoc::IsInCaseCharSet(wxChar chTest, wxString& theCharSet, int& index)
{
	index = theCharSet.Find(chTest);
	if (index > -1)
	{
		// it is in the list
		return TRUE;
	}
	else
	{
		// it is not in the list
		return FALSE;
	}
}

// returns the TCHAR at the passed in offset
wxChar CAdapt_ItDoc::GetOtherCaseChar(wxString& charSet, int nOffset)
{
	wxASSERT(nOffset < (int)charSet.Length());
	return charSet.GetChar(nOffset);
}

// return TRUE if all was well, FALSE if there was an error; strText is the language word or
// phrase the first character of which this function tests to determine its case, and from
// that to set up storage for the lower or upper case equivalent character, and the relevant
// flags. strText can be source text, target text, or gloss text; for the latter two
// possibilities bIsSrcText needs to be explicitly set to FALSE, otherwise it is TRUE by
// default. This is a diagnostic function used for Auto-Capitalization support.
// BEW 25May16, refactored where chFirst, in just the source text check, may be found. The
// legacy code assumed only at the first character of strText. The refactor, provided the
// boolean (global) gbUCSrcCapitalAnywhere is TRUE (set from project config file only) allows
// the upper case chacter in the source to be anywhere within the first word of strText
// (Requested by Mike Hore, since his source has nominal prefixes, but target does not prefix
// proper nouns, and he wants things like na-Paul to be autocapitalized to Bawula)
bool CAdapt_ItDoc::SetCaseParameters(wxString& strText, bool bIsSrcText)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (strText.IsEmpty())
	{
		return FALSE;
	}
	int nOffset = -1;
	wxChar chFirst;
	if (gbUCSrcCapitalAnywhere && bIsSrcText && !gbNoSourceCaseEquivalents)
	{
		wxChar aCapitalLetter;
		int itsOffset = wxNOT_FOUND;
		// In the next call, TRUE is bIsSrcText
		bool bFoundCapital = IsUpperCaseCharInFirstWord(strText, itsOffset, aCapitalLetter, TRUE);
		if (bFoundCapital)
		{
			// We store the offset to the uppercase character globally, as the storage to KB
			// will need to know where to make the change to lower case
			gnOffsetToUCcharSrc = itsOffset;
			chFirst = aCapitalLetter;
			// Set other globals we know the value of
			gbSourceIsUpperCase = TRUE;
			gcharSrcUC = aCapitalLetter;
		}
		else
		{
			// No upper case capital letter was found in the first word. So we have lower case,
			// and we assume the lower case letter is the first in strText
			gnOffsetToUCcharSrc = wxNOT_FOUND;
			chFirst = GetFirstChar(strText);
			gcharSrcLC = chFirst;
			gbSourceIsUpperCase = FALSE;
		}
	}
	else
	{
		// Legacy situation, only first character of strText is used for the check
		chFirst = GetFirstChar(strText);
	}
	bool bIsLower;
	bool bIsUpper;
	if (bIsSrcText)
	{
		// exit prematurely if the user has not defined any source case equivalents
		if (gbNoSourceCaseEquivalents)
		{
			gbSourceIsUpperCase = FALSE; // ensures an old style lookup or store
			return FALSE;
		}

		// determine if it is a lower case source character
		// which has an upper case equivalent
		bIsLower = IsInCaseCharSet(chFirst, pApp->m_srcLowerCaseChars, nOffset);
		if (bIsLower)
		{
			// it's a lower case belonging to the source set,
			// so we don't have to capitalize it
			gbSourceIsUpperCase = FALSE;
			gcharSrcLC = chFirst;
			wxASSERT(nOffset >= 0);
			gcharSrcUC = GetOtherCaseChar(pApp->m_srcUpperCaseChars, nOffset);
		}
		else
		{
			// chFirst is not a lower case source character which has an upper case
			// equivalent, so it might be an upper case source character (having a lower
			// case equivalent), or it is of indeterminate case - in which case we treat
			// it as lower case
			bIsUpper = IsInCaseCharSet(chFirst, pApp->m_srcUpperCaseChars, nOffset);
			if (bIsUpper)
			{
				// it is an upper case source char for which there is a lower case
				// equivalent
				gbSourceIsUpperCase = TRUE;
				gcharSrcUC = chFirst;
				wxASSERT(nOffset >= 0);
				gcharSrcLC = GetOtherCaseChar(pApp->m_srcLowerCaseChars, nOffset);
			}
			else
			{
				// it has indeterminate case, so treat as lower case with zero as its
				// upper case equiv
				gbSourceIsUpperCase = FALSE;
				gcharSrcLC = chFirst;
				wxASSERT(nOffset == -1);
				gcharSrcUC = _T('\0');
			}
		}
	}
	else
	{
		// it is either gloss or adaptation data: use gbIsGlossing to determine which...
		// determine if it is a lower case character which has an upper case equivalent
		if (gbIsGlossing)
		{
			// it's gloss data
			// exit prematurely if the user has not specified any gloss case equivalents
			if (gbNoGlossCaseEquivalents)
			{
				gbNonSourceIsUpperCase = FALSE; // ensures an old style lookup or store
				gcharNonSrcUC = _T('\0'); // use the value as a test indicating failure here
				return FALSE;
			}
			bIsLower = IsInCaseCharSet(chFirst, pApp->m_glossLowerCaseChars, nOffset);
		}
		else
		{
			// it's adaptation data
			// exit prematurely if the user has not specified any target case equivalents
			if (gbNoTargetCaseEquivalents)
			{
				gbNonSourceIsUpperCase = FALSE; // ensures an old style lookup or store
				gcharNonSrcUC = _T('\0'); // use the value as a test indicating failure
				return FALSE;
			}
			bIsLower = IsInCaseCharSet(chFirst, pApp->m_tgtLowerCaseChars, nOffset);
		}
		if (bIsLower)
		{
			// it's a lower case belonging to the gloss or adaptation set,
			// so we don't have to capitalize it
			gbNonSourceIsUpperCase = FALSE;
			gcharNonSrcLC = chFirst;
			wxASSERT(nOffset >= 0);
			if (gbIsGlossing)
			{
				gcharNonSrcUC = GetOtherCaseChar(pApp->m_glossUpperCaseChars, nOffset);
			}
			else
			{
				gcharNonSrcUC = GetOtherCaseChar(pApp->m_tgtUpperCaseChars, nOffset);
			}
		}
		else // it's not lower case...
		{
			// chFirst is not a lower case adaptation or gloss character which has an upper
			// case equivalent, so it might be an upper case adaptation or gloss character
			// (having a lower case equivalent), or it is of indeterminate case - in which
			// case we treat it as lower case
			if (gbIsGlossing)
			{
				bIsUpper = IsInCaseCharSet(chFirst, pApp->m_glossUpperCaseChars, nOffset);
			}
			else
			{
				bIsUpper = IsInCaseCharSet(chFirst, pApp->m_tgtUpperCaseChars, nOffset);
			}
			if (bIsUpper)
			{
				// it is an upper case gloss or adaptation char for which there is a lower
				// case equivalent
				gbNonSourceIsUpperCase = TRUE;
				gcharNonSrcUC = chFirst;
				wxASSERT(nOffset >= 0);
				if (gbIsGlossing)
				{
					gcharNonSrcLC = GetOtherCaseChar(pApp->m_glossLowerCaseChars, nOffset);
				}
				else
				{
					gcharNonSrcLC = GetOtherCaseChar(pApp->m_tgtLowerCaseChars, nOffset);
				}
			}
			else
			{
				// it has indeterminate case, so treat as lower case with zero as
				// its upper case equiv
				gbNonSourceIsUpperCase = FALSE;
				gcharNonSrcLC = chFirst;
				wxASSERT(nOffset == -1);
				gcharNonSrcUC = _T('\0');
			}
		}
	}
	return TRUE;
}

///////////////////////////////////////
/// returns				TRUE if an upper case character is found within the first word of src, FALSE if not
/// params
/// str				->	ref to the source text string being checked for a capitalization location
/// offset			<-	0-based offset to the upper case character, if source text. We won't use this
///						function for target text - we capitalize only the initial char of tgt text.
///						If there is no such character in the first word, then return wxNOT_FOUND
///	theChar			<-	The character at offset, provided offset is != to wxNOT_FOUND, else unset
/// bIsSrcText		->	TRUE (default) if str is source text - and that's all we support at present
/// comments
/// This is a helper function for capitalizing a source text word of a phrase, or the only word, when
/// the location for the capitalizing is non-initial in the word. TThis enabling of non-initial upper
/// case discovered location is provided by the global boolean, gbUCSrcCapitalAnywhere being TRUE,
/// and there is no GUI for setting it true or false, it has to be done manually in the project config
/// file. The first word is determined by one of the following: end of string, or the first latin space
/// encountered, or failing that, a zero-width space or similar character, as in IsWhiteSpace() function
///////////////////////////////////////
bool CAdapt_ItDoc::IsUpperCaseCharInFirstWord(wxString& str, int& offset, wxChar& theChar, bool bIsSrcText)
{
	// exit prematurely if the user has not defined any source case equivalents
	if (gbNoSourceCaseEquivalents)
	{
		gbSourceIsUpperCase = FALSE; // ensures an old style lookup or store
		return FALSE;
	}
	// Exit returning FALSE if str is empty, or the feature is not turned ON )
	if (str.IsEmpty() || !gbUCSrcCapitalAnywhere)
	{
		offset = wxNOT_FOUND;
		theChar = _T('\0'); // a null
		return FALSE;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	// We only are allowing source text checks currently
	if (bIsSrcText)
	{
		int length = str.Length();
		wxChar aChar;
		int i;
		bool bIsUpper = FALSE;
		offset = wxNOT_FOUND;
		for (i = 0; i < length; i++)
		{
			aChar = str.GetChar(i);
			if (IsWhiteSpace(&aChar))
			{
				theChar = _T('\0'); // a null
				offset = wxNOT_FOUND;
				return FALSE;
			}
			int nOffset; // offset in the string of upper case characters
			bIsUpper = IsInCaseCharSet(aChar, pApp->m_srcUpperCaseChars, nOffset);
			if (bIsUpper)
			{
				offset = i;
				theChar = aChar;
				return TRUE;
			}
		}
	}
	// No success at finding the required upper case character, or not a source text check
	theChar = _T('\0'); // a null
	offset = wxNOT_FOUND;
	return FALSE;
}




/////////////////////////////////////////////////
///
/// End of functions for support of Auto-Capitalization
///
////////////////////////////////////////////////

// this is public
void CAdapt_ItDoc::DoBookName()
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	pApp->LogUserAction(_T("Initiated DoBookName()"));
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	if (pList->IsEmpty())
	{
		::wxBell();
		pApp->LogUserAction(_T("Doc is empty in DoBookName()"));
		return;
	}

	// get the bookcode
	wxString bookCode = gpApp->GetBookIDFromDoc();

	wxString titleStr = _("Set or Clear a Book Name");
	bool bShowItCentered = TRUE;
	CBookName dlg(
		(wxWindow*)gpApp->GetMainFrame(),
		&titleStr,
		&bookCode,
		bShowItCentered);
	if (dlg.ShowModal() == wxID_OK)
	{
		// nothing to do, if OK button clicked, the OnOK() handler updates app's member
		// m_bookName_Current with the user's chosen book name (which could be an empty string)
	}
	// if Cancel button chosen, the book name is not changed from it's current value in
	// the app's m_bookName_Current member
}
// Return TRUE if the character at pText is a word building character, AND the character at
// pText + 1 is a punctuation character (not including a ~ tilde in the set of punctuation
// characters) AND the character at pText + 2 is also a world building character. Otherwise,
// return FALSE.
// Usage: use when parsing from left to right (or right to left when the language is rtl
// reading) across a word. We allow a word to contain a single punctuation character
// sandwiched between word-building (alphabetic) characters. There can be more than one
// such 3-character sequence in a word, and parsing will stay within the word so long
// as each such call of this function returns TRUE. But a sequence of two or more internal
// punctuation characters within a word will be parsed as being two words - with the word
// break being at the end of such a punctuation sequence (we'd assume the punctuation
// characters would be ending punctuation for the first word being split off.)
// pEnd has to be input since if we are within 3 characters of the end of the buffer
// we make no test, but just return FALSE.
// On input, pText points at the next character of the input text being parsed, and
// ptr at the same location.
// Therefore, whenever TRUE is returned we know that the currently pointed at three
// successive characters are within a word being parsed over; when FALSE is returned
// we do not know about the next three characters.
// BEW added 11Sep16, for use in the refactored ParseWord() within TokenizeText()
bool CAdapt_ItDoc::ParseWordMedialSandwichedPunct(wxChar* pText, wxChar* pEnd, wxString& spacelessPuncts)
{
	wxASSERT(pText < pEnd);
	if ((pText + 1) >= pEnd)
	{
		return FALSE; // too close to buffer end
	}
	// Test that the character at pText is punctuation (other then ~)
	if (IsOneOf(pText, m_spacelessPuncts_NoTilde))
	{
		if (IsInWordProper(pText - 1, spacelessPuncts) && IsInWordProper(pText + 1, spacelessPuncts))
		{
			return TRUE;
		}
	}
	// If control gets to here, we've failed to identify a punctuation
	// character sandwiched by word building characters
	return FALSE;
}

// Tilde between the end of a word and the start of a new word is assumed to be a USFM
// fixed space marker, return TRUE if we identify such a sequence. We return TRUE when
// ptr points at ~ and the character either side is a word-building one
bool CAdapt_ItDoc::ParseWordMedialSandwichedUSFMFixedSpace(wxChar* pText, wxChar* pEnd, wxString& spacelessPuncts)
{
	wxASSERT(pText < pEnd);
	if ((pText + 1) >= pEnd)
	{
		return FALSE; // too close to buffer end
	}
	if (pText)
	{
		// Test that the first character, the one at pText, is a word-building one
		if (*pText == _T('~'))  // the ~ (tilde, the USFM fixed space)
		{
			// Test for whether or not it is sandwiched by wordbuilding characters
			if (IsInWordProper(pText - 1, spacelessPuncts) && IsInWordProper(pText + 1, spacelessPuncts))
			{
				return TRUE;
			}
		}
	}
	// If control gets to here, we've failed to identify a ~ character sandwiched
	// by word building characters
	return FALSE;
}

// BEW 30Sep19, added for USFM3 support of \esbe endmarker
// Returns itemLen value  for \esbe end marker if \esbe was found at 
// pChar location, otherwise returns 0 (which, in the caller, does
// not add to the len value of what was parsed so far, and ParseWord()
// would continue parsing)
//
// Public function. Used in ParseWord() only, so far, to get the
// storage of endmarker \esbe (USFM3), Bill's "study bible sidebar end" marker,
// done. A side effect is to lookup AI_USFM to get the relevant properties of
// this endmarker, so as to assign them to members of the passed in pSrcPhrase
// currently being parsed.
int CAdapt_ItDoc::StoreEsbeEndMarker(wxChar* pChar, CSourcePhrase* pSrcPhrase, int whitespaceLen)
{
	int aLength = 0;
	wxChar* ptr = pChar; // shadow pChar

	// The caller (ParseWord()) may have non-zero number of whitespace wxChars in
	// its whitespaceLen variable, declared at the begining of ParseWord(). Check
	// for this, as these precede a \esbe marker in the source text being parsed,
	// and so we must advance ptr to point at whatever follows them to get ptr
	// pointing at the \esbe marker
	if (whitespaceLen > 0)
	{
		ptr += whitespaceLen;
	}

	wxString wholeMkr = GetWholeMarker(ptr);
	wxString esbeEndMkr("\\esbe");
	if (esbeEndMkr == wholeMkr)
	{
		// There is a \esbe marker at pChar awaiting storage, and assignment of
		// relevant properties from lookup of AI_USFM.xml  to members of pSrcPhrase
		aLength = wholeMkr.Len();

		// Store it
		pSrcPhrase->AddEndMarker(wholeMkr); // handles whether m_endMarkers is empty or not

		// Next, do the AI_USFM lookup to get the needed pUsfmAnalysis struct which
		// determines which properties we assign to this pSrcPhrase which is current
		wxString bareMkr = wholeMkr.Mid(1); // remove the initial backslash, "esbe"
											// is a separate entry in AI_USFM.xml
		USFMAnalysis* pUsfmAnalysis = LookupSFM(bareMkr); // returns NULL if not found
		if (pUsfmAnalysis == NULL)
		{
			// Unexpected lookup failure. Put error notfication in LogUserAction( msg )
			// and continue, making best of bad situation
			wxString msg = _T("Lookup in AI_USFM.xml of bare endMkr esbe failed in StoreEsbeEndMarker(). Marker stored in m_endMarkers but marker properties cannot be set from pUsfmAnalysis struct. At sn= %d, m_key= %s");
			msg = msg.Format(msg, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
			gpApp->LogUserAction(msg);
			// Some minimal recovery assignments
			pSrcPhrase->m_inform = _("study Bible sidebar end");
			pSrcPhrase->m_bBoundary = TRUE;
		}
		else
		{
			// Valid UsfmAnalysis struct returned. Set pSrcPhrase's appropriate members
			if (pUsfmAnalysis->userCanSetFilter && !pUsfmAnalysis->navigationText.IsEmpty())
			{
				if (pUsfmAnalysis->inform == 1)
				{
					pSrcPhrase->m_inform = pUsfmAnalysis->navigationText;
				}
			}
		}
		pSrcPhrase->m_bBoundary = TRUE;
		pSrcPhrase->m_curTextType = none;
	}

	// Add in the whitespaceLen to aLength, to keep the iterator ptr in the caller
	// pointing where it should
	aLength += whitespaceLen;

	return aLength; // assign this to itemLen value in ParseWord(), so that ParseWord()
					// can update its len value, so that when ParseWord() exits,  its
					// caller (TokenizeText()) can accurately update the pChar position 
					// ready for the next iteration of the parsing loop. It needs to point
					// at whatever follows \esbe  -- whether whitespace or a begin-marker
}

// BEW 30Sep19, added for USFM3 support of \esbe endmarker
// Returns TRUE if \esbe is found at pChar location, otherwise FALSE
// There may be some whitespace characters preceding the marker,
// so if pointing at whitespace we parseover that keeping a count of
// its length, which we return in whitespaceLen. The function still
// returns TRUE, provided \esbe immediately follows the whitespace.
// That whitespace will get thrown away, TokenizeText does not need it.
//
//  Usage: Used by ParseWord() in the post-word parsing; if found, it
//  halts parsing, \esbe gets stored in m_endMarkers, and control then
//  updates ptr position to be after it (using len value returned
//  from ParseWord(), and that completes processing of that pSrcPhrase
bool CAdapt_ItDoc::FoundEsbeEndMkr(wxChar* pChar, int& whitespaceLen)
{
	wxChar* ptr = pChar;
	whitespaceLen = ParseWhiteSpace(ptr);
	ptr += whitespaceLen;
	// ptr now points at whatever follows any whitespace, if there was any
	if (*ptr != gSFescapechar)
	{
		whitespaceLen = 0;
		return FALSE; // pChar is not pointing at a USFM marker of any kind
	}
	wxString checkMkr = GetWholeMarker(ptr);	// returns empty string if 
												// no marker identified
	if (checkMkr.IsEmpty())
	{
		whitespaceLen = 0;
		return FALSE;
	}
	wxString esbeMkr(_T("\\esbe"));
	if (checkMkr == esbeMkr)
	{
		return TRUE; // when TRUE, caller wants the 
					 // whitespace value to be accurate
	}
	whitespaceLen = 0;
	return FALSE;
}

// BEW 12Dec22 added in order to handle word-internal punctuation (e.g. ' used for glottal stop)
// because the old parser used to parse in from both ends, but ParseAWord now only parses forwards, and so without this compensating
// function being in the while loop's set of tests, an internal punctuation character will cause a misparse that could lead to a
// serious parsing error (or worse). Return TRUE if pChar points to one punctuation character, but the characters either side are
// not punctuation characters. Sanity check: if pChar is not a punctuation character, return FALSE immediately after entry.
// BEW 20Dec22 refactor. The 'after' calculation should not be just "not punct"; it needs to be "not punct AND not whitespace"
// if it's punct or white then it is not "internal" to the word.
// BEW 26Jul23 refactored and with name change, because it sometimes gave false positives when parsing word-ending punctuation.
bool CAdapt_ItDoc::CanParseForward(wxChar* pChar, wxString spacelessPunctuation, wxChar* pEnd)
{
	// Goal: return TRUE if not parsing within word-final puncts; FALSE if parsing within word-final puncts or anything
	// which indicates parsing further would go beyond the end of the word being parsed by ParseAWord()
	wxChar* ptr = pChar; // don't change pChar by anything we do here
	if (ptr > (pEnd - 1)) // ensure that the wxChar after pChar is available
	{
		return FALSE;
	}
	// Sanity check first, no point in checking puncts if ptr is not pointing at one
	int punctsLen;
	int saveLen;
	punctsLen = ParsePuncts(ptr, pEnd, spacelessPunctuation); // internally calls ParseFinalPuncts() using a temporary copy
					// of spacelessPunctuation to which straight-quote (') has been added. This avoids a legacy error.
	saveLen = punctsLen; // save this value for use later on
	if (punctsLen == 0)
	{
		// The character at pChar is not a punctuation character, so parsing can proceed
		return TRUE; // Note: gSFescapechar at ptr is tested below, but not here - the ParseAWord() caller will halt if 
					 // backslash is at ptr when controll enters the caller
	}
	else
	{
		// The character at pChar is indeed a punctuation character. So it may be word-internal - and we
		// would then want to continue parsing over it and any other word internal ones, and then we'd want
		// to return TRUE. But we could be starting to parse into word-final puncts, and we'd therefore
		// want to halt ParseAWord() from parsing further - lest we end up with m_key having final puncts.
		// (But I do now have protection code after the ParseAWord() call that fixes such an error - and
		// it works). Anyway we'd want to return FALSE to get ParseAWord to parse no further for this 
		// pSrcPhrase's m_key content determination. So in this block we determine which is the case, and
		// if we can't, play safe at the end by returning FALSE

		// Our first test is to find out what character is at (ptr - 1). If it's part of a word (determined
		// by checking it's not a punctuation character), we potentially may be dealing with word-internal punctuation
		wxChar* pPtrBefore = (ptr - 1);
		punctsLen = ParsePuncts(pPtrBefore, pEnd, spacelessPunctuation);
		if (punctsLen > 0)
		{
			// Unexpected, and it wipes out any possibility of parsing being currently word-internal, because
			// at (ptr - 1) there should be an alphanumeric character which is word-building, therefore not a punct
			return FALSE;
		}
		// punctsLen must be 0, therefore it's possible still that ParseAWord is parsing word-internal punct(s)
		// Now we have to check what's AFTER this one or more puncts - so we need to investigate ahead of where
		// pChar is within the ParseAWord caller. To do this, first get a count of how many puncts are at pChar.
		// saveLen has that count. Advance ptr to point to whatever follows the potentially word-internal puncts
		ptr += saveLen;
		// ptr is now pointing at what is not a known (to AI) punctuation character. What's at this location?
		// (1) If it's a backslash, halt ParseAWord, we are at a marker ( begin or ending ) and either cannot be
		// within the word; so return FALSE
		// (2) It's whitespace (such as space, zwsp, other widths of space, and fixed-space): return FALSE
		// (3) If it's one of  \r or \n, these likewise need to halt the parse: return FALSE
		// (4) If it's a bar ( | ), return FALSE
		// (5) If its pEnd, return FALSE
		// Else, return TRUE. Remember, these 5 tests are being done at a location ahead of where pChar is in
		// the caller, ParseAWord(), so although the caller has the same tests, they won't return the same
		// result and so they can't tell what is the situation ahead of where pChar currently is. CanParseWord()
		// does that job on ParseAWord()'s behalf
		if (ptr == pEnd)
		{
			return FALSE;
		}
		else
		{
			if (*ptr == gSFescapechar)
			{
				return FALSE; // disallow advance
			}
			if (IsWhiteSpace(ptr))
			{
				return FALSE;
			}
			if (*ptr == _T('\r') || *ptr == _T('\n'))
			{
				return FALSE;
			}
			if (*ptr == _T('|'))
			{
				return FALSE;
			}
		} // end of the else block for test: if (ptr == pEnd)
	} // end of else block for test: if (punctsLen == 0)

	// otherwise, must return TRUE, as probably ptr is within the word being parsed
	return TRUE;
}



// BEW 23Sep22 created, for use in ParseWord() at the point where obtaining the word that is
// pointed at by pChar needs to be know in order to set pSrcPhase's m_key and m_srcPhrase members
// when control is within the span of a character attribute marker containing bar ( | ) preceding
// the attributes string which is to be chached. 
// The internal code involves a while loop, and it will exit if there is detection of space, or bar, 
// or ZWSP (the latter to accomodate Asian languages which don't used Latin spaces to delimit words),
// and so forth. Bar, in a validly set up cachable attributes marker beginMkr followed by endMkr on
// the same or later word somewhere, is handled at the entry to ParseWord(), but we have bar here
// causing break from the loop, because some input scripture text may have an errant bar not sandwiched
// by beginning and ending markers. So I've provided some 'fix it' code to normalise the markup provided
// the word before the bar is identical to the word after the bar.
wxString CAdapt_ItDoc::ParseAWord(wxChar* pChar, wxString& spacelessPuncts, wxChar* pEnd, bool& bWordNotParsed) // public
{
	wxChar* ptr = pChar; // initialise iterator

	wxASSERT(!spacelessPuncts.IsEmpty());
	wxChar zwsp = (wxChar)0x200B;
	wxChar bar = _T('|');
	//wxChar space = _T(' ');
	wxASSERT(pChar != NULL);
	wxString word = wxEmptyString; // initialise empty
	bool bNotWhitespace = !IsWhiteSpace(ptr);
	// ']' can be punctuation - that will cause the loop to be exited (correctly), or it can be word-building - in which case
	// the test for finding *ptr as _T(']') in the spaceless puncts, will not find it - so wxNOT_FOUND is returned, which means
	// the while loop will continue parsing - thereby incorporating the ] into the wordform.
	// '[',  when it is punctuation like ']' is, is also handled by the bNotPunct test.
	// BEW 12Dec22 Note: ' (ascii single straight quote character) is by default, not included in the src or target 
	// punctuation sets. This is because it often is used word-internally as a glottal stop. We want to parse over it
	// when it is word-internal. However, if the user adds ' to the punctuation sets, a word like Prub'e would be
	// misparsed. So the whole loop's condition set includes a test: IsWordInternalPunctuation(), which will catch the
	// potential error, and also do the same if some other punctuation character is word-internal ( such as '~' )
	// 
	// BEW 26Jul23 changed name from IsWordInternalPunctuation (right goal, bad algorithm) to CanParseForward - better
	// indicates the intent behind the function. The idea is that at each next wxChar which is a punct, this function
	// must search foward to find where punctuation ends, and then investigate the next character. If it's backslash,
	// or space, or \r, or \n, then return FALSE because one of those indicates we are not dealing with word-internal
	// puncts, but rather word-final puncts. My refactoring will better handle that goal. And lack of ' in spacelessPuncts
	// will be overcome by using ParsePuncts() which internally temporarily adds a straight quote ( ' ) to a copy of
	// spacelessPuncts, to get a reliable determination of being at a punct, or not.
	bool bCanProceed = CanParseForward(ptr, spacelessPuncts, pEnd);
	while (bNotWhitespace && bCanProceed && (*ptr != gSFescapechar) && (*ptr != bar) && (*ptr != zwsp) && !(ptr == pEnd))
	{
		// If there was nothing at ptr to cause a break, add *ptr to word and augment ptr
		word += *ptr;
		ptr++;
		// By using IsWhiteSpace(ptr) I get automatic zwsp support
		bNotWhitespace = !IsWhiteSpace(ptr);
		bCanProceed = CanParseForward(ptr, spacelessPuncts, pEnd);
	}
	if (word.IsEmpty())
	{
		bWordNotParsed = TRUE;  // code immediately after the function returns an empty string, will
			// deal with this situation. If pSrcPhrase's m_markers member has content, then the length
			// of such content can be used to advance ptr appropriately, and parsing continue unstopped
		//wxASSERT(!word.IsEmpty());
	}
	else
	{
		bWordNotParsed = FALSE; // maintain default, which indicates a word (or something) got parsed causing ptr to advance
	}
	return word; // returns empty string if nothing was parsed over
}
// BEW 22May23 added, call before ParseAWord()
bool CAdapt_ItDoc::IsInitialPunctPlusWhite(wxChar* pChar, wxString& spacelessPuncts, wxChar* pEnd, wxString& strReturn)
{
	wxUnusedVar(spacelessPuncts); // I read this puncts set in, just in case I want to refactor and use them
	wxChar* ptr = pChar;
	// in strInitialPuncts I added em-dash, spanish ¿ and ¡ as these are likely to occur in spanish text
	// (and I've manually added them to AI-BasicConfiguration.aic and my test project's AI-ProjectConfiguration.aic files)
	wxString strInitialPuncts = _T("<“‘\"«¿¡—");
	strReturn = wxEmptyString;
	wxString openWedge = _T('<'); // beware, "<<" is to be considered as a single punct logically, but wxChar length of 2
	int offset = wxNOT_FOUND;
	int punctCount = 0; // init
	bool bIsWhite = FALSE; // init
	offset = strInitialPuncts.Find(*ptr);
	if (offset >= 0)
	{
		// ptr is pointing at one of the initial puncts above. Return TRUE if (ptr + 1 < pEnd) AND
		// *(ptr + 1) is a whitespace character (typically latin space, but other spaces are possible, such as
		// hairspace, etc); and when TRUE, return that two-character wxString to the caller in strReturn, so
		// that the caller can store it in pSrcPhrase->m_markers, prior to ParseAWord() being called (must be
		// prior otherwise ParseAWord will exit immediately having failed to parse - leading to app crash, or
		// an assert trip in _DEBUG mode)
		punctCount++;
		if (*ptr == openWedge)
		{
			// Check if another openWedge immediately follows (and after that no newline or backslash)
			if ((ptr + 1) < pEnd && *(ptr + 1) == openWedge )
			{
				// We have "<<" at ptr
				punctCount = 2;
				strReturn << openWedge;
				strReturn << openWedge;
				wxChar* pAux = ptr + 2; 
				bIsWhite = IsWhiteSpace(pAux);
				if (bIsWhite)
				{
					strReturn << *pAux;
					return TRUE;
				}
				else
				{
					strReturn.Empty();
					return FALSE;
				}
			}
			else
			{
				// We have just a single openWedge
				punctCount = 1;
				strReturn << openWedge;
				wxChar* pAux = ptr + 1;
				if (pAux < pEnd)
				{
					bIsWhite = IsWhiteSpace(pAux);
					if (bIsWhite)
					{
						strReturn << *pAux;
						return TRUE;
					}
				}
				else
				{
					strReturn.Empty();
					return FALSE;
				}
			}
		} // end of TRUE block for test: if (*ptr == openWedge)
		else
		{
			// ptr is not pointing _T('<'), so there is definitely no second of same following at (ptr + 1)
			punctCount = 1;
			strReturn << *ptr;
			wxChar* pAux = ptr + 1;
			if (pAux < pEnd)
			{
				bIsWhite = IsWhiteSpace(pAux);
				if (bIsWhite)
				{
					strReturn << *pAux;
					return TRUE;
				}
				else
				{
					strReturn.Empty();
					return FALSE;
				}
			}
		} // end of else block for test: if (*ptr == openWedge)
	}
	// If ptr is not pointing at an opening punctuation character (for languages like Spanish which have several
	// graphemes for opening punctuation, not in the English set), it's the responsibility of the user to add them
	// to the puncts list. Best way is to do it manually to AI-BasicConfiguration.aic and the current project's 
	// AI-ProjectConfiguration.aic file before running the app. Doing it on the fly in Preferences tabbed dialog 
	// may be problematic as being new puncts, AI will try to do an Update due to Punctuation Change - which may fail.
	return FALSE;
}

// Return TRUE if a matching ) is found within the next nLimit number of characters, or backslash was found.
// Return the offset from pChar to ')'. Probably an nLimit value of 16 would suffice. If the boolean
// bAlreadyGotOpeningParen is TRUE, then TokenizeText() has already stored the ( in pSrcPhrase->m_precPunct
bool CAdapt_ItDoc::FindClosingParenthesis(wxChar* pChar, wxChar* pEnd, int& nSpanLen, int nLimit, bool bAlreadyGotOpeningParen)
{
	wxChar* ptr = pChar; // protect pChar from advancing
	int count = 0;
	nSpanLen = 0;
	wxChar endParen = _T(')');
	if (bAlreadyGotOpeningParen == FALSE)
	{
		// The ptr is pointing at (
		while (ptr < pEnd && count < nLimit)
		{
			if (*ptr == endParen)
			{
				nSpanLen = count + 1; // +1 = include the matched ')' character in the nSpan
				return TRUE;
			}
			else
			{
				// ) has not yet been found
				if (ptr >= pEnd)
				{
					nSpanLen = 0;
					return FALSE;
				}
				if (*ptr == gSFescapechar)
				{
					nSpanLen = 0;
					return FALSE;
				}
				ptr++;
				count++;
			}
		}
	}
	else
	{
		// ptr is pointing at the character following (, which, for an acceptable result,
		// must be a digit
		if (IsAnsiDigit(*ptr))
		{
			// the initial felicity condition is satisfied, now use a loop to search
			while (ptr < pEnd && count < nLimit-1) // shorten by 1 since '(' is already parsed
			{
				if (*ptr == endParen)
				{
					nSpanLen = count + 1; // +1 = include the matched ')' character in the nSpan
					return TRUE;
				}
				else
				{
					// ) has not yet been found
					if (ptr >= pEnd)
					{
						nSpanLen = 0;
						return FALSE;
					}
					if (*ptr == gSFescapechar)
					{
						nSpanLen = 0;
						return FALSE;
					}
					ptr++;
					count++;
				}
			}
		} // end of TRUE block for test: if (IsAnsiDigit(*ptr))
	}
	return FALSE; // return false if not found within nLimit, or a backslash encountered, or ptr points past pEnd
}

// Return TRUE if a matching endmarker for the beginmarker at pChar was found; return the offset from pChar
// to the backslash of the endmarker, and the length of that endmarker
bool CAdapt_ItDoc::FindMatchingEndMarker(wxChar* pChar, wxChar* pEnd, int& offsetToMatchedEndmarker, int& endMarkerLen)
{
	wxChar* ptr = pChar; // create an iterator
	wxASSERT(*pChar == gSFescapechar);
	wxASSERT(pChar < pEnd);
	offsetToMatchedEndmarker = wxNOT_FOUND; // initialize to -1
	endMarkerLen = 0; // initialize to 0
	wxString wholeMkr = GetWholeMarker(ptr);
	wxASSERT(!wholeMkr.IsEmpty());
	wxString matchingEndMkr = wxEmptyString;
	if (IsEndMarker(ptr, pEnd))
	{
		// Bad markup so reflect it in the result of the parse
		return FALSE;
	}
	matchingEndMkr += _T("*");
	endMarkerLen = (int)matchingEndMkr.Length();
	int offset = wxNOT_FOUND; // initialize
	wxString baseStr(ptr, pEnd);
	offset = baseStr.Find(matchingEndMkr);
	if (offset == wxNOT_FOUND)
	{
		// There is no matching endmarker in the text following ptr. Note, if
		// the user forgot to end a \x or \f or \fe section, this could collect
		// a heap of source text and treat it as the marker content! So to
		// avoid this, return FALSE
		offsetToMatchedEndmarker = offset;
		return FALSE;
	}
	// We found the matched endmarker, so return TRUE and the num of chars to it etc
	offsetToMatchedEndmarker = offset;
	return TRUE;
}

// BEW 3Apr20 This function returns true if \f, \x, \ef or \ex begin-marker is at
// ptr when bCheckForEndMkr is FALSE; or when \f*, \x*, \ef* of \ex* end-marker is
// at ptr when the bool is TRUE.
// This function will be used in a scanning function called: 
// bool IsWithinSpanProhibitingPlaceholderInsertion(), in support of refactoring
// for two placeholder buttons, and their Update...() handlers for determining when
// to disable or enable the GUI buttons. We get the input mkr from the caller
// by checking each pSrcPhrase->m_markers member, or pSrcPhrase->m_endMarkers
// member (using its access function), as the bCheckForEndMkr boolean directs.
// The begin markers are stored with following space in each CSrcPhrase, and the 
// end markers with final * (we no longer support PNG SFM markup).
// For begin markers, do not augment, in the caller, with a trailing space, that
// will be done here where needed.
// We call these "prohibitive" because they only belong to the code for
// determining when active pSrcPhrase belongs to a marker span which
// into which placeholder insertion is prohibited
bool CAdapt_ItDoc::IsForbiddenMarker(wxString mkr, bool bCheckForEndMkr)
{
	mkr = mkr.Trim(); // just in case  it came in with a trailing space
	if (bCheckForEndMkr)
	{
		// All these end markers are stored in m_endMarkers private member
		wxString footnoteEndMkr = _T("\\f*");
		wxString extFootnoteEndMkr = _T("\\ef*");
		wxString xRefEndMkr = _T("\\x*");
		wxString extxRefEndMkr = _T("\\ex*");
		// Check for endMarker
		int length = mkr.Len();
		wxChar charLast = mkr.GetChar(length - 1); // should be an * character
		if (charLast != _T('*'))
		{
			return FALSE; // not an inline USFM2 or USFM3 prohibitive end marker
		}
		else
		{
			if (mkr == footnoteEndMkr)
			{
				return TRUE;
			}
			if (mkr == extFootnoteEndMkr)
			{
				return TRUE;
			}
			if (mkr == xRefEndMkr)
			{
				return TRUE;
			}
			if (mkr == extxRefEndMkr)
			{
				return TRUE;
			}
		}
	}
	else
	{
		// Check for begin marker

		wxString footnoteMkr = _T("\\f ");
		wxString extFootnoteMkr = _T("\\ef ");
		wxString extxRefMkr = _T("\\ex ");
		wxString xRefMkr = _T("\\x ");

		// Check for beginMarker
		int length = mkr.Len();
		wxChar charLast = mkr.GetChar(length - 1); // should be an f or x character
		if (!(charLast == _T('f') || charLast == _T('x')))
		{
			return FALSE; // not one of the three \f , \ef, \ex  or \x markers
		}
		else
		{
			// Append a space, since all these prohibitive begin markers are stored in
			// m_markers which stores with a trailing space; need a  trailing space for
			// these tests
			mkr += _T(' ');
			if (mkr == footnoteMkr)
			{
				return TRUE;
			}
			if (mkr == extFootnoteMkr)
			{
				return TRUE;
			}
			if (mkr == xRefMkr)
			{
				return TRUE;
			}
			if (mkr == extxRefMkr)
			{
				return TRUE;
			}
		}
	}
	return FALSE; // no match
}

// BEW created 3Apr20, pass in m_markers and look for begin markers (whether
// prohibitive or not). Internally, in a loop, check each one found using
// IsForbiddenMarker() i.e. one of \f, \x \ef or \ex - these only. Return it
// in beginMkr if found. Return TRUE if one is found, FALSE if there was no 
// content in pSrcPhrase->m_markers, or no such marker could be identified from
// what was in that member of pSrcPhase.
//
// Usage: in refactoring for support of two placeholder insert buttons, we want to
// know if the active location is within a footnote span, xref span, an extended
// footnote span (\ef ... \ef*) or an extended cross-reference span (\ex ... \ex*). 
// Retranslations and Free Transation spans have begin and end booleans, and an 
// additional boolean for every CSourcePhrase in either of such spans.
// But not so for footnotes, xrefs, extended footnotes or extended xrefs. So this 
// is a helper function used only in looking for whether or not the active pile 
// lies within a span of those four types of inline spans - footnote, extended 
// footnote, cross reference or extended cross reference. The ultimate caller 
// will be a function: bool IsWithinSpanProhibitingPlaceholder(CPile* pCurrentPile) 
// - that function allows us to disable placeholder insertion within those span types.
bool CAdapt_ItDoc::FindProhibitiveBeginMarker(wxString& strMarkers, wxString& beginMkr)
{
	//CAdapt_ItApp* pApp = &wxGetApp();
	beginMkr.Empty(); // initialise to an empty string

	if (strMarkers.IsEmpty())
	{
		return FALSE;
	}
	else
	{
		// strMarkers (i.e. caller's m_markers) has content; look for one of
		// the prohibited beginMks within it, return it if found
		int offset = wxNOT_FOUND;
		offset = strMarkers.Find(gSFescapechar); // look for backslash
		if (offset == wxNOT_FOUND)
		{
			return FALSE; // there are no markers in this strMarkers
		}
		else
		{
			// There is at least one marker present in strMarkers
			wxString testMkr = wxEmptyString;
			wxString subString = strMarkers.Mid(offset); // start at backslash of first mkr
			do {
				testMkr = GetWholeMarker(subString);
				bool bIsProhibitiveMkr = IsForbiddenMarker(testMkr, FALSE); //FALSE is bCheckForEndMkr
				if (bIsProhibitiveMkr)
				{
					beginMkr = testMkr;
					return TRUE;
				}
				else
				{
					// shortenString, iterate to get another if present
					int length = testMkr.Len();
					subString = subString.Mid(length);
					if (!subString.IsEmpty())
					{
						testMkr = wxEmptyString;
						offset = subString.Find(gSFescapechar); // look for backslash
						if (offset == wxNOT_FOUND)
						{
							// No more markers present
							break;
						}
						else
						{
							subString = subString.Mid(offset);
							//now iterate loop
						}
					}
					else
					{
						break;
					}
				}
			} while (offset >= 0);
		}
	}
	return FALSE;
}

/// returns				one of the enum values as follows:
/// enum WordParseEndsAt {
///	unknownCharType,
///	endoftextbuffer,
///	whitespace,
///	closingbracket,
///	punctuationchar,
///	backslashofmkr };
/// params
/// ptr			->		pointer to the next wxChar to be parsed, when
///						parsing posts-word material (such as various kinds
///						of USFM markers, punctuation, whitespace that can
///						be ignored, or a closing ] which always halts the
///						parse - it would belong on the next CSourcePhrase
/// remarks
/// Because the post-word material can be of several kinds and be complex,
/// our parser is often doing the same set of checks at a given ptr value.
/// To keep our code more concise, this function is needed - it gets called
/// often, within the doc member function ParsePostWordStuff().
/// We don't test here for ptr pointing at a word-building character;
/// such a test can be done explicitly in the caller when appropriate
/// BEW added 12Oct16
WordParseEndsAt	CAdapt_ItDoc::FindOutWhatIsAtPtr(wxChar* ptr, wxChar* pEnd,
	bool bTokenizingTargetText)
{
	WordParseEndsAt at = unknownCharType; // initialize
	if (IsWhiteSpace(ptr)) // the most likely result
	{
		at = whitespace;
		return at;
	}
	if (IsPunctuation(ptr, bTokenizingTargetText)) // next most likely
	{
		at = punctuationchar;
		return at;
	}
	if (IsMarker(ptr)) // should be less common than punctuation
	{
		at = backslashofmkr;
		return at;
	}
	if (*ptr == _T(']')) // rare or never
	{
		at = closingbracket;
		return at;
	}
	if (ptr >= pEnd) // least likely
	{
		at = endoftextbuffer;
		return at;
	}
	return at; // must be unknownCharType if it is not any of the above
}

// BEW 8Aug17 need this as well as the ones below, for postword filtering
// Note, "Space" here may be different from a latin space, for some languages
// for example, it could be ZWSP
bool CAdapt_ItDoc::SpacePrecedes(wxChar* pChar, wxString& precedingSpace)
{
	precedingSpace = wxEmptyString; // initialize
	bool bIsWhite = IsWhiteSpace(pChar - 1);
	if (bIsWhite)
	{
		precedingSpace = *(pChar - 1);
		return TRUE;
	}
	return FALSE;
}


// BEW 23Jan17 Helper function to support filtering in post-word position,
// for ParseWord2() parser within TokenizeText()
// The function should only be called from within ParsePostWordStuff().
// It is part of the code for checking if the marker at pChar is a USFM marker
// designated for filtering (we want to store the filtered marker and content
// on this current pSrcPhrase).
bool CAdapt_ItDoc::EndmarkerPrecedes(wxChar* pChar, wxString& precedingEndmarker)
{
	precedingEndmarker = wxEmptyString; // initialize
	if (*pChar != gSFescapechar)
	{
		return FALSE; // This function should only be called when a pChar points
					  // at a begin-marker, but we test for pointing at backslash
	}
	wxChar* ptr = pChar;
	int counter = 0;
	if (*(ptr - 1) == _T('*'))
	{
		while (*(ptr - 1) != gSFescapechar)
		{
			ptr = ptr - 1;
			counter++;
			if (counter > 24)
			{
				// Something serious is amiss, no SF marker is as long as 24
				// characters, so bail out
				return FALSE;
			}
		}
		ptr = ptr - 1; // Now we are pointing at the endmarker's backslash
		precedingEndmarker = GetWholeMarker(ptr);
		return TRUE;
	}
	return FALSE;
}

// The following function should only be called from within ParsePostWordStuff(),
// and ReconstituteAfterFilteringChange()
// This function is part of the code for checking if the marker at pChar is a USFM
// marker designated for filtering (we want to store the filtered marker and content
// on this current pSrcPhrase), but we also need to know if the preceding text is
// puntuation and store that punctuation so we can construct metadata for helping
// unfiltering to properly reconstitute the original markup
bool CAdapt_ItDoc::PunctuationPrecedes(wxChar* pChar, wxString& precedingPunct, bool bTokenizingTargetText)
{
	if (*pChar != gSFescapechar)
	{
		return FALSE; // This function should only be called when a pChar points
					  // at a begin-marker, but we test for pointing at backslash
	}
	wxString aggregatePuncts; aggregatePuncts.Empty();
	size_t number = 1;
	bool bPunctPrecedes = IsPunctuation(pChar - number, !bTokenizingTargetText);
	if (bPunctPrecedes)
	{
		// There is at least one, store it and then collect any others using a loop
		aggregatePuncts = *(pChar - number);
		while (IsPunctuation(pChar - ++number, !bTokenizingTargetText))
		{
			// The following lines are equivalent to inserting each found punct char
			// at the start of the currently constituted aggregate string; so that
			// puntuation order is maintained while aggregating backwards
			wxString strCurrent = aggregatePuncts;
			aggregatePuncts.Empty();
			aggregatePuncts = *(pChar - number);
			aggregatePuncts += strCurrent;
		}
		precedingPunct = aggregatePuncts;
		return TRUE;
	}
	return FALSE;
}

// The following function should only be called from within ParsePostWordStuff()
// because it relies on ParseWordProper() having been called, and from that the
// pSrcPhrase's m_key wxString member having been set.
// This function is part of the code for checking if the marker at pChar is a USFM
// marker designated for filtering (we want to store the filtered marker and content
// on this current pSrcPhrase).
// In this function we want to know if the wxChar preceding pChar is within the word
// just parsed; that is, the preceding chararcter is not the * of an endmaker, and
// not a punctuation character either. FALSE will also be returned if the internal
// call of IsInWordProper() cannot recognise the character at pChar - 1 as a
// word-building one
bool CAdapt_ItDoc::WordPrecedes(wxChar* pChar, wxString& theWord,
	CSourcePhrase* pSrcPhrase, wxString& spacelessPuncts)
{
	if (*pChar != gSFescapechar)
	{
		return FALSE; // This function should only be called when a pChar points
					  // at a begin-marker, but we test for pointing at backslash
	}
	wxString word = pSrcPhrase->m_key; // puncts, if any, are not in this string
	if (IsInWordProper(pChar - 1, spacelessPuncts))
	{
		theWord = word;
		return  TRUE;
	}
	theWord = wxEmptyString;
	return FALSE;
}

// returns TRUE if the begin-marker at pChar should be filtered
// pChar            ->  pointer in the text being parsed, which should be pointing at a beginmarker
// bXref_Fn_orEn    <-  set true if the wholeMkr is a \x, \f, or \fe
// bIsFilterableStuff <- set true if whatever marker it is should be filtered, regardless of
//                      whether it is a \x \f or \fe or not
// wholeMkr         <-  the begin-marker at pChar (pass it back to save recalculating in the caller)
// whm 24Oct2023 modification to remove the use of the IsAFilteringSFM() function. See comments below. 
bool CAdapt_ItDoc::IsPostwordFilteringRequired(wxChar* pChar, bool& bXref_Fn_orEn, bool& bIsFilterStuff, wxString& wholeMkr)
{
	wxChar* ptr = pChar; // initialize ptr
	bIsFilterStuff = FALSE; // initialize
	bXref_Fn_orEn = FALSE;  // initialize
	wholeMkr = wxEmptyString; // initialize
	const wxString strXRef = _T("\\x");
	const wxString strFNote = _T("\\f");
	const wxString strENote = _T("\\fe");
	wxString augmentedWholeMkr = wxEmptyString;
	USFMAnalysis* pUsfmAnalysis = NULL;
	wxString tagOnly;
	wxString baseOfEndMkr;
	bool bIsNestedMkr;
	wholeMkr = GetWholeMarker(ptr);
	pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr);
	augmentedWholeMkr = gSFescapechar;
	augmentedWholeMkr += tagOnly;
	wxASSERT(augmentedWholeMkr == wholeMkr); // at this point they should be identical
	augmentedWholeMkr += _T(' ');
	// whm 24Oct2023 modification. The IsAFilteringSFM() function should NOT be used along with a
	// check of the gCurrentFilterMarkers string, since the IsAFilteringSFM() function only
	// returns the "default" filtering status of a marker as set in the AI_USFM.xml control file,
	// which does NOT change when a marker such as \s section heading is currently filtered by 
	// the USFM/Filtering tab in Preferences. Therefore I've removed the IsAFilteringSFM()
	// function from the following test. Examining the App's gCurrentFilterMarkers string for the 
	// existence of a given marker within that string, is the only way to get an accurate 
	// test of whether the given marker is currently being filtered or not.
	//if (IsAFilteringSFM(pUsfmAnalysis) &&
	//	(gpApp->gCurrentFilterMarkers.Find(augmentedWholeMkr) != -1) &&
	//	pUsfmAnalysis->inLine)
	if (gpApp->gCurrentFilterMarkers.Find(augmentedWholeMkr) != -1 &&
		pUsfmAnalysis->inLine)
	{
		bIsFilterStuff = TRUE; // this is the more general value than for xref, ftnote, endnote
		if ((wholeMkr == strXRef) || (wholeMkr == strFNote) || (wholeMkr == strENote))
		{
			// This is the more particular (and expected/common) situation for following filterable stuff
			bXref_Fn_orEn = TRUE;
		}
		return TRUE;
	}
	// Not filterable, so return FALSE
	return FALSE;
}

// BEW added 4Apr2017 for TokenizeText()
// TokenizeText fails within ParseWord() or ParseWord2() if there are only punctuation characters
// (as defacto text) in a context such as:  \ft ....... \f* at the end of an unfiltered footnote
// or similar markup. Without the present function, the puncts get put in m_prevPunct, ParseWord2()
// is called (or legacy ParseWord())and the footnote end marker wrongly in m_inlineBindingMarkers,
// and then any normal marker following which really should be in the next pSrcPhrase is parsed and
// protection code in ParseWord or ParseWord trips and aborts the app, because normal markers should
// not be handled in ParseWord() or ParseWor2().
// So we use this function to detect this circumstance, and replace the punctuation string with the
// same number of x characters, so that parsing works as expected (ie. without error).
// When this function is called, TokenizeText() should have identified a begin marker (such as \f )
// that is unfiltered, and parsed over it and its following space (or spaces), and the ptr to the text being
// parsed should then be at the start of what follows - whether it is a word, or punctuation.
bool CAdapt_ItDoc::IsPunctuationOnlyFollowedByEndmarker(wxChar* pChar, wxChar* pEnd,
	wxString& spacelessPuncts, bool bTokenizingTargetText, bool& bHasPunctsOnly, bool& bEndmarkerFollows,
	int& punctsCount)
	//int& offsetToPunctsStart, int& offsetToPunctsEnd)
{
	//offsetToPunctsStart = 0; // initialize
	//offsetToPunctsEnd = 0; // initialize
	bHasPunctsOnly = FALSE; // initialize
	bEndmarkerFollows = FALSE; // initialize

	wxChar* ptr = pChar;
	int nDataLength = (int)(pEnd - pChar);
	if (!(nDataLength > 0))
	{
		return FALSE;
	}

	/* In the loop use a switch for WordParseEndsAt
	enum WordParseEndsAt {
	unknownCharType,
	endoftextbuffer,
	whitespace,
	closingbracket,
	punctuationchar,
	backslashofmkr};
	*/
	int punctsCounter = 0;
	bool bPunctsSubstringFinished = FALSE;
	bool bMarkerIsEndmarker = FALSE;

	while (!IsInWordProper(ptr, spacelessPuncts))
	{
		// The character at ptr is not part of a word, so check out punctuation, whitespace & a marker;
		// anything else should cause a return of FALSE
		WordParseEndsAt myresult = FindOutWhatIsAtPtr(ptr, pEnd, bTokenizingTargetText);
		switch (myresult)
		{
		case unknownCharType:
		{
			return FALSE;
			break;
		}
		case endoftextbuffer:
		{
			return FALSE; // all the conditions were not satisfied before end reached
			break;
		}
		case whitespace:
		{
			bPunctsSubstringFinished = TRUE;
			ptr = ptr + 1; // point at next character
			break; // iterate
		}
		case closingbracket:
		{
			return FALSE;
			break;
		}
		case punctuationchar:
		{
			punctsCounter++;
			ptr = ptr + 1; // point at next character
			break; // iterate
		}
		case backslashofmkr:
		{
			if (punctsCounter > 0)
			{
				bPunctsSubstringFinished = TRUE;
			}
			if (IsEndMarker(ptr, pEnd))
			{
				bHasPunctsOnly = TRUE;
				bEndmarkerFollows = TRUE;
				bMarkerIsEndmarker = TRUE;
			}
			else
			{
				return FALSE;
			}
			break;
		}
		} // end of switch (myresult)
		if ((punctsCounter > 0) && bPunctsSubstringFinished && bHasPunctsOnly && bMarkerIsEndmarker)
		{
			// The hack is needed
			bEndmarkerFollows = TRUE;
			punctsCount = punctsCounter;
			return TRUE;
		}
	}

	return FALSE;
}


///////////////////////// 
// Helper code for support of USFM3's attribute-having metadata for certain markers, for
// which TokenizeText will hide the metadata in m_punctsPattern, use m_bUnused set TRUE
// when it is hiding such stuff

CAdapt_ItApp* theApp = &wxGetApp(); // quick access to the doc instance

void  CAdapt_ItDoc::ClearAttributeMkrStorage()
{
	m_bWithinMkrAttributeSpan = FALSE;
	m_bHiddenMetadataDone = FALSE;

	enumMkrTypeValue = notAttrMkr;
	m_strAttrBeginMkr = wxEmptyString;
	m_strAttrEndMkr = wxEmptyString;
	m_strMatchedMkr = wxEmptyString;
	m_cachedWordBeforeBar = wxEmptyString;
	m_nBeginMkrLen = 0;
	m_nEndMarkerLen = 0;
	m_nSpanLength = 0;

	m_cachedAttributeData.Empty();
	m_cachedWordBeforeBar.Empty();

	m_offsetToFirstBar = (size_t)wxNOT_FOUND;
	m_offsetToMatchingEndMkr = (size_t)wxNOT_FOUND;
}

// just checks in the fast-access string, and returns the marker if found 
// within the set of such markers
bool  CAdapt_ItDoc::IsAttributeBeginMarker(wxChar* ptr, wxString& beginMkr)
{
	beginMkr = wxEmptyString; // initialize
	bool bIsMkr = IsMarker(ptr);
	if (!bIsMkr)
	{
		return FALSE;
	}
	else
	{
		wxString wholeMkr = GetWholeMarker(ptr);
		wxString augmentedWholeMkr = wholeMkr + _T(' '); // prevent spurious matches
		//m_nBeginMkrLen = augmentedWholeMkr.Len();

		// Now we can lookup the fast access string for attribute-having markers 
		// or endmarkers. Check for a begin-marker of the attribute having type
		bool bFound = CheckForAttrMarker(augmentedWholeMkr, beginMkr, attrBeginMkr);
		return bFound == TRUE;
	}
}

// This function checks in the fast access string, and depending on the
// result it returns FALSE if it is not there, but if it is, it checks
// a tracking boolean on the doc, called m_bWithinMkrAttributeSpan, which
// governs when the caching code within gets to do its job. When
// m_bWithinMkrAttributeSpan is FALSE on entry, and the marker is one 
// which potentially has attributes metadata, then the code does caching
// of the information which will be required when TokenizeText() (the
// caller) has processed through to the last CSourcePhrase of the
// span up to the matching endmarker - as that is where the cached
// data will get inserted into that last CSourcePhrase instance's
// m_punctsPattern member, and m_bUnused set TRUE. But in the intervening
// CSourcePhrase instances of the span, we don't want any caching being
// done. So that's what goes on here. The function uses the internal test's
// else block to have a second try if the TRUE block fails.
// This testing is only relevant when TokenizingText() is tokenizing
// source text, the function returns FALSE if m_bTokenizingTargetText
// is TRUE. It's important to prevent the caching when the input text
// is target text, because TokenizeText is used in various places to tokenize
// target text to obtain CSourcePhrases for some purpose or other which
// are based on a string of target text words. Return the marker too.
// BEW 30Sep19 created
bool  CAdapt_ItDoc::IsAttributeMarker(wxChar* ptr)
{
	// Do this check only if we are tokenizing source text. If the tokenizer
	// is tokenizing target text (which we do for special internal needs sometimes)
	// then it's inappropriate to check for usfm3 attribute-having markers, as they
	// should have been hidden at the parse of the document's source text.
#if defined (_DEBUG)
	int halt_here = 1;
	wxUnusedVar(halt_here);
#endif

	if (m_bTokenizingTargetText)
	{
		m_bWithinMkrAttributeSpan = FALSE;
		return FALSE;
	}
	AttrMkrType whichType = notAttrMkr; // default to 'not an attribute-having marker'

	bool bIsMkr = IsMarker(ptr);
	if (!bIsMkr)
	{
		return FALSE;
	}
	// Coming to an attribute-having begin marker, the m_bWithinMkrAttributeSpan 
	// boolean will be FALSE; and coming to it's end-marker, it will be TRUE,
	// so setup blocks to get the correct processing done
	if (!m_bWithinMkrAttributeSpan)
	{
		wxString wholeMkr = GetWholeMarker(ptr);
		wxString augmentedWholeMkr = wholeMkr + _T(' '); // prevent spurious matches
		m_nBeginMkrLen = augmentedWholeMkr.Len();

		// BEW 20Apr20, we here need to distinguish between two kinds of \xt marker.
		// Before USFM3, there was only one \xt marker, and our AI code reflected that.
		// It was a marker internal to a \x ... \x* cross-reference span.
		// With the advent of USFM3 standard, another "cross ref" type of \x marker
		// was introduced, and it has an obligatory \xt* endmarker, and the content
		// of the marker span obligatorily has a bar ( | ). This conforms to cache-able
		// attributes metadata - which never is to be found internal to a cross reference
		// span, nor an extended cross reference span. The USFM3 documentation has it 
		// used in, for example, a \ca span ("alternate chapter") as default "link-href"
		// attribute with content like: \xt verse 7|MAT 6:7\xt* -- which is very different
		// than the \xt within \ex or \x unfiltered spans. So here we must check if a span
		// of \x ... \x*, or \ex .... \ex* (both of which use \xt) is being parsed. If so,
		// exit to the caller, returning FALSE. (This will prevent control getting into
		// CheckForAttrMarker() where lookup of the USFM3 attribute having mrks is done -
		// and \xt is in that fast-acccess string, and its endmarker in the other:
		// BEW 10Sep22 added to comment
		//charAttributeMkrs is fast access for begin mkrs, charAttributeEndMkts for their
		// endmarkers (Doc.cpp lines 303 and 305)
		if ((augmentedWholeMkr == wxString(_T("\\xt ")) &&
			(gpApp->m_bMkr_x_NotFiltered || gpApp->m_bExt_ex_NotFiltered)))
		{
			// This is NOT a marker for caching away from sight; its in a cross ref span
			// or extended cross reference span, so return FALSE here to bleed off this
			// attempt at caching; allowing the other kind of \xt to be recognised right
			return FALSE;
		}
//#if defined (_DEBUG)
//		if (m_pSrcPhraseBeingCreated->m_nSequNumber == 1)
//		{
//			int halt_here_now = 1;
//		}
//#endif
#if defined (_DEBUG)
		if (m_pSrcPhraseBeingCreated != NULL && m_pSrcPhraseBeingCreated->m_nSequNumber == 204)
		{
			int breakHere = 1; wxUnusedVar(breakHere); // avoid warning variable initialized but not referenced
		}
#endif

		// Now we can lookup the fast access string for attribute-having markers 
		// or endmarkers. First, check for a begin-marker of the attribute having type
		bool bFound = CheckForAttrMarker(augmentedWholeMkr, m_strMatchedMkr, attrBeginMkr);
		if (bFound)
		{
			whichType = attrBeginMkr;

			wxUnusedVar(whichType);

			m_strAttrBeginMkr = m_strMatchedMkr; // transfer it  (including the space at the end)
			m_bWithinMkrAttributeSpan = TRUE; // the span of the marker content is beginning
			m_bHiddenMetadataDone = FALSE; // use to stop clearing of the cached material
										   // until the hiding of the metadata etc has been done

			// Now remove the trailing space, and replace it with *, and store that in
			// strAttrEndMkr, so that when the parse later comes to the endmarker, we
			// can check against strAttrEndMkr to know that, after any attribute hiding is
			// done, we can then clear m_bWithinMkrAttributeSpan to FALSE
			// BEW 12Sep22 no change needed, next line correctly generates an appropriate end mkr
			m_strAttrEndMkr = ConvertToEndMarker(m_strAttrBeginMkr); // remember, the input param
																	 // ends with space
			m_nEndMarkerLen = m_strAttrEndMkr.Len();

			// Next task is to find out (a) is there attribute-having metadata somewhere 
			// ahead in the as-yet unparsed source text within the span ending at the 
			// matching endmarker; (b) store the offset to it's first bar (strBar) in
			// offsetToFirstBar, -1 if there is no bar, or the first bar lies beyond
			// the matching endmarker (ie. in some other attribute-having span); and
			// (c) store the offset to the matching endmarker from the same starting point.
			// From these offsets we can work out the extent of the metadata to be hidden,
			// and store that as a wxString in cachedAttributeData - with a copy of the
			// endmarker appended as well (later, replacing the endmarker with the stored
			// contents of cachedAttributeData will effect the restoration of the hidden
			// material in the correct place, when exporting the target text to Paratext).
			// So before this present function exits, we'll remove the cached metadata from
			// the input text stream, so that our tokenizer function doesn't get to see it.

			// The next issue is to work out which yet-to-be-created CSourcePhrase
			// instance is the one carrying the first bar character for which we obtained
			// its offset. It's that particular one that will store the metadata in its
			// m_punctsPattern member. In Gerald's 2Kings source text, the CSourcePhrase
			// could be anything from the current one, to 2 or three instances further on.
			// We simply can't count whitespaces in the input stream ahead of the current
			// ptr location, because nested quotations are likely to have a space between
			// the nested endquotes - which would mess up determining the correct pSrcPhrase
			// by a simple count of that kind. We have to allow ParseWord(), 
			// to parse out each succeeding new CSourcePhrase, and for each one, check
			// if the m_endMarkers member contains the matching endmarker.
			// (The function: bool IsThisEndMarkerStoredHere(CSourcePhrase* pSrcPhrase, 
			// wxString* pEndMkr, int& offset) will do this job.) We'll place that function
			// immediately after ParseWord(), and if it returns true, then
			// we can immediately copy the cached metadata into m_punctsPattern, and set
			// m_Unused to TRUE. Job done - at least for the parsing. We'll need more code
			// for restoring the cached metadata to its correct place when building the
			// export target text for transferring across to Paratext (or Bibledit) in
			// collaboration mode. For Adapt It's non-collaboration exports, we'll simply
			// leave the contents of m_punctsPattern be ignored. AI doesn't need that stuff.
#if defined (_DEBUG)
			if (m_pSrcPhraseBeingCreated != NULL && m_pSrcPhraseBeingCreated->m_nSequNumber == 204)
			{
				int breakHere = 1; wxUnusedVar(breakHere); // avoid warning variable initialized but not referenced
			}
#endif

			m_auxPtr = ptr; // Start the scanning from where ptr currently is (at the start
							// of the begin-marker (pointing at its backslash)
			// whm 21Sep2023 added initialization of m_offsetToFirstBar
			m_offsetToFirstBar = (size_t)wxNOT_FOUND;
			m_offsetToFirstBar = FindBarWithinSpan(m_auxPtr, m_strAttrEndMkr, m_nEndMarkerLen);
			// Use doc's pDoc->pCreatingSrcPhrase, which gets set in TokenizeText() at
			// every time new CSourcePhrase is called.
			m_offsetToMatchingEndMkr = FindEndMarkerWithinSpan(m_auxPtr, m_strAttrEndMkr,
				m_nEndMarkerLen, m_pSrcPhraseBeingCreated);

			if (m_offsetToFirstBar == wxNOT_FOUND)
			{
				// While the begin-marker is one that potentially can take attributes,
				// this one has none. So there is nothing to hide. Return FALSE.
				// BEW 6Apr20, however, check that m_pSrcPhraseBeingCreated->m_bHasInternalPunct
				// is not TRUE; because if it's TRUE then that instance would be a merger
				// in which there is internal punctuation - and that also stores into
				// m_punctsPattern, and we DON'T want to clear m_bUnused not m_punctsPattern,
				// nor clear the attribute storage
				// 
				// whm 20Sep2023 added protection against m_pSrcPhraseBeingCreated being NULL
				// or uninitialized which it was for the 642JN-DukU.sfm input data where the m_auxPtr
				// was pointing at: "\\w Yohana\\w*, se̱k-wu̱ ...", and at this point an exception
				// was thrown because m_pSrcPhraseBeingCreated was uninitialized 0xCDCDCDCD.
				if (m_pSrcPhraseBeingCreated != NULL && !m_pSrcPhraseBeingCreated->m_bHasInternalPunct)
				{
					// m_punctsPattern is not being used for storing data string for 
					// avoiding a Placement of puncts dialog - so safe to do the following clear

					m_pSrcPhraseBeingCreated->m_bUnused = FALSE;
					m_pSrcPhraseBeingCreated->m_punctsPattern.Empty(); //clear it
					ClearAttributeMkrStorage();

					return FALSE;
				}
			}
			else
			{
				// We've some atributes or alternatives metadata to deal with, to
				// get it and cache it for when it needs to be added to the CSourcePhrase
				// instance which has the | (bar). ptr has not moved, so point to where
				// the metadata is, and get its length, and then create a wxString and
				// assign it to cachedAttributeData. Also get the word (and any puncts)
				// which immediately precede the bar - beware, there might be no word
				// preceding, in chich case we cache an empty string
				m_auxPtr = ptr;
				m_auxPtr = m_auxPtr + m_offsetToFirstBar;
				wxChar* auxPtr2 = ptr + m_offsetToMatchingEndMkr; // automatic
				// Store the length of this cached string metadata
				m_nSpanLength = (size_t)(auxPtr2 - m_auxPtr);
				// Cache the metadata, pending determination of which CSourcePhrase
				// instance it needs to be stored on
				wxString strHoldThis = wxString(m_auxPtr, auxPtr2);
				
				// Get the word (and its puncts, if any) which precedes the bar
				m_cachedWordBeforeBar = CacheWordBeforeBar(m_auxPtr);

				// BEW 20Sep22 since we know what the word is prior to bar, and it has
				// to be first in the data to be put into m_chacedAttributeData, we
				// should do it here so that ParseWord() has very little extra to do
				m_cachedAttributeData = m_cachedWordBeforeBar + strHoldThis;

				// Important, we now need to append the matching end-marker to
				// what is cachedAttributeData, so that when rebuilding the text
				// for an export which exposes the cached metadata (as when exporting
				// to Paratext in collaboration mode), the rebuilding can restore the
				// metadata to its correct location by finding the endmarker and replacing
				// that with the cached material.
				m_cachedAttributeData += m_strAttrEndMkr;


#if defined (_DEBUG) && !defined(NOLOGS) // && defined (LOG_USFM3)  // line 51 is where the #define is
				wxLogDebug(_T("\n%s::%s Line: %d: Metadata for hiding: %s  SequNum = %d  SrcText = %s , At begin-marker"),
					__FILE__, __FUNCTION__, __LINE__, m_cachedAttributeData.c_str(),
					m_pSrcPhraseBeingCreated->m_nSequNumber, m_pSrcPhraseBeingCreated->m_srcPhrase.c_str());
#endif
				// We are done here. The rest is done in ParseWord()  now
				// or later in the tokenizing, when tokenizing gets to the right location
				return TRUE;  // TRUE causes the caller to set m_bWithinMkrAttributeSpan to TRUE
			}
		} // end of true block for test: if (!m_bWithinMkrAttributeSpan)
	} // end of else block for test: if (!m_bWithinMkrAttributeSpan)

	  // If control gets here, it must not have been an attribute-having marker
	return FALSE;
}
// Looks up CheckForAttrMarker fast access string, or the
// CheckForAttrEndMarker fast access string. Returns what
// was matched, and whether a begin marker or end marker type
// Returns TRUE If one from the set of USFM3 attribute-having markers
// was found
// params:
// attrMkr		->	reference to the USFM marker that the caller identified at the ptr location
// matchedMkr	<-	pass back the matched attribute-having marker, if attrMkr matches one
//					in the fast access string
// enumMkrType	->	the caller determines which fast access string needs to be looked up
// BEW 12Sep22, now that _T("\\w ") is at the start of Doc's charAttributeMks fast access string, and _T("\\w* is
// at the start of Doc's fast access string charAttributeEndMkrs (see line 303 and 305 Doc.cpp), this function
// will now work correctly in the sense that the bool returned will have the correct value
bool  CAdapt_ItDoc::CheckForAttrMarker(wxString& attrMkr, wxString& matchedMkr, AttrMkrType enumMkrType)
{
	wxString wBeginMkr_Aug(_T("\\w "));
	wxString wEndMkr_Aug(_T("\\w* "));
	bool bIsWBeginMkr = FALSE;
	bool bIsWEndMkr = FALSE;
	matchedMkr.Empty(); // ensure the caller's cache for the marker starts off empty
	if (attrMkr.IsEmpty())
	{
		// Somethings wrong, and empty string passed in, not a marker
		return FALSE;
	}
	else
	{
		if (enumMkrType == attrBeginMkr)
		{
			int offset = wxNOT_FOUND;

			// Check out \w<space> first
			if (attrMkr == wBeginMkr_Aug)
			{
				bIsWBeginMkr = TRUE;
			}
			offset = charAttributeMkrs.Find(attrMkr);
			if ((bIsWBeginMkr == TRUE) || (offset != wxNOT_FOUND))
			{
				// An attribute-having marker was matched (includes the space following)
				matchedMkr = attrMkr;
				matchedMkr = matchedMkr.Trim(); // get rid of final space

				// searches back nearest ch:vs ref, to indicate where span started somewhere
				// after the ch:vs reference; it will be 0:0 if no chapter:verse ref could
				// be determined. This m_chapterVerseAttrSpan string is used only if
				// a matching span-end marker was not found, and appears in the warning message
				wxSPListNode* pos_pSP = gpApp->m_pSourcePhrases->GetLast();
				if (pos_pSP != NULL)
				{
					CSourcePhrase* pSrcPhrase_lastCompleted = pos_pSP->GetData();
					gpApp->m_chapterVerseAttrSpan = gpApp->GetView()->GetChapterAndVerse(pSrcPhrase_lastCompleted);
#if defined (_DEBUG) && !defined(NOLOGS)
					wxLogDebug(_T("%s() line %d  ch:vs= [%s] , <> For attributes caching, returning TRUE."),
						__FUNCTION__, __LINE__, gpApp->m_chapterVerseAttrSpan.c_str());
#endif
				}
				return TRUE;
			}
			else
			{
				// Not found
				return FALSE;
			}
		} // end of TRUE block for test: if (enumMkrType == attrBeginMkr)
		else if (enumMkrType == attrEndMkr)
		{
			// Check out \w*<space>
			if (attrMkr == wEndMkr_Aug)
			{
				bIsWEndMkr = TRUE;
			}
			int offset = wxNOT_FOUND;
			offset = charAttributeEndMkrs.Find(attrMkr);
			if ((bIsWEndMkr == TRUE) || (offset != wxNOT_FOUND))
			{
				// An attribute-having end marker was matched (includes the space following)
				matchedMkr = attrMkr;
				matchedMkr = matchedMkr.Trim();
				return TRUE;
			}
		} // end of else if block for test:else if (enumMkrType == attrEndMkr)
	}
	// It's neither, so return FALSE to be safe
	return FALSE;
}

// BEW 30Sep19 refactored to support USFM3
wxString  CAdapt_ItDoc::ConvertToEndMarker(wxString strBeginMkrAndSpace)
{
	// BEW 30Sep19 changes for USFM3 - deal with the special case of
	// beginmarker \esb and its endmarker \esbe; other endmarkers will
	// end with asterisk
	if (strBeginMkrAndSpace == wxString(_T("\\esb ")))
	{
		strBeginMkrAndSpace = wxString(_T("\\esbe"));
		return strBeginMkrAndSpace;
	}
	if (strBeginMkrAndSpace == wxString(_T("\\esb")))
	{
		// If the space is absent, send back the correct endmarker
		strBeginMkrAndSpace = wxString(_T("\\esbe"));
		return strBeginMkrAndSpace;
	}
	// The rest handles all other markers...
	size_t offset = (size_t)strBeginMkrAndSpace.Find(m_strSpace);
	if (offset != wxNOT_FOUND)
	{
		wxString strToFindOnce = m_strSpace;
		wxString strToReplace = m_asterisk;
		size_t oldLength = strBeginMkrAndSpace.Len();
		// Replace first instance of a space with an asterisk
		size_t newLength = strBeginMkrAndSpace.Replace(strToFindOnce, strToReplace, FALSE);
		// In case the space was not final, find the asterisk and drop anything which follows
		newLength = strBeginMkrAndSpace.Find(strToReplace);
		newLength++; // get past the asterisk
		if (newLength < oldLength)
		{
			strBeginMkrAndSpace = strBeginMkrAndSpace.Left(newLength);
		}
		return strBeginMkrAndSpace;
	}
	else
	{
		// If the passed in string lacked a final space, make sure there
		// is no ending whitespace and then append an asterisk
		strBeginMkrAndSpace.Trim();
		strBeginMkrAndSpace += m_asterisk;
	}
	return strBeginMkrAndSpace;
}

/// Returns the offset to the next bar ( | ) in the input stream being
/// tokenized, starting from the backslash of the begin-marker which commences
/// the attribute-having span. If no bar is in the span, returns wxNOT_FOUND.
/// Params:
/// auxPtr			-> iterator; a copy of caller's ptr, we don't want ptr to 
///					   advance by anything that is done within this function
/// matchingEndMkr	-> the endmarker, including its * but no space following,
///					   which indicates the end of the span, whether or not it
///					   is a span that has attributes metadata
///	endMkeLen		   the length (of wxChar instances) of the endmarker -
///					   to make it easy to quickly construct wxStrings in the
///					   internal endless loop - until doing that builds one
///					   which causes exit from the loop, or other protections
///					   cause exit safely.
/// Comment:
/// Iterate, wxChar by wxChar across the yet-to-be-tokenized text, looking for
/// a bar ( | ) wxChar before the matching endmarker is arrived at and if
/// auxPtr gets to the endmarker, then bar is absent in the span; if bar is
/// encountered, it's location is the start of the metadata that we want to
/// squirrel away in CSourcePhrase's m_punctPattern member. The CSourcePhrase
/// which is the one to accept the metadata may not yet exist. All this function
/// does is to help define the start and end of the metadata so we can cache it
/// temporarily.
/// BEW 19Apr20 refactored. while(TRUE) is an infinite loop, and if what's expected
/// is not there, crash and no apparent reason why. So I must make it a safe loop.
/// Exit if a beginMkr is encountered; or if some other endmarker (as last resort)
/// than the matching one, is encountered
int   CAdapt_ItDoc::FindBarWithinSpan(wxChar* auxPtr, wxString matchingEndMkr, int endMkrLen)
{
	int offset = wxNOT_FOUND; // initialize to -1
	wxChar* ptr = auxPtr; // I prefer working with a copy called ptr
						  // Get ptr past the begin marker
	wxString anyEndMkr = wxEmptyString;
	wxString anyBeginMkr = wxEmptyString;
	// Start looking for the backslash of the matchingEndMkr
	while (TRUE) {
		wxString strEnd = wxString(ptr, endMkrLen);
		bool bIsEnd = IsEnd(ptr);
		if (bIsEnd)
		{
			return wxNOT_FOUND;
		}
		if (strEnd == matchingEndMkr)
		{
			// We've reached the matching endmarker without finding a bar,
			// so return wxNOT_FOUND
			return wxNOT_FOUND;
		}
		else
		{
			// Advance ptr & try again
			ptr++;
			offset++;
			if (*ptr == m_strBar)
			{
				// We've found the first bar within the span
				return ++offset; // ++offset because we started from -1
			}
		}
	}
}

/// Returns the offset to the next bar matching endmarker in the input stream being
/// tokenized, starting from the backslash of the begin-marker which commences
/// the attribute-having span.
/// Params:
/// auxPtr			-> iterator; a copy of caller's ptr, we don't want ptr to 
///					   advance by anything that is done within this function
/// matchingEndMkr	-> the endmarker, including its * but no space following,
///					   which indicates the end of the span, whether or not it
///					   is a span that has attributes metadata
/// endMkrLen		-> the length (in wxChar) of the endmarker - added so as
///					   to make it easy to quickly construct wxStrings in the
///					   internal endless loop - until doing that builds one
///					   which causes exit from the loop.
/// pCurSrcPhrase  ->  passed in only so as to have an instance for the 
///					   GUI message to grab for getting an approximate chapter
///					   and verse to report to the user
/// Comment:
/// Iterate, wxChar by wxChar across the yet-to-be-tokenized text, looking for
/// the matching endmarker. When arrived at, it's location is the end of the 
/// metadata that we want to squirrel away in CSourcePhrase's m_punctsPattern 
/// member. The CSourcePhrase which is the one to store the metadata may not 
/// yet exist. All this function does is to help define the start and end of 
/// the metadata so we can cache it temporarily.
/// BEW 20Apr20 added more protections against excessive run-on if the expected
/// matching endmarker is not found before a new begin-marker
int   CAdapt_ItDoc::FindEndMarkerWithinSpan(wxChar* auxPtr, wxString matchingEndMkr,
	int endMkrLen, CSourcePhrase* pCurSrcPhrase)
{
	//CAdapt_ItView* pView = gpApp->GetView();

	int offset = wxNOT_FOUND; // initialize
	wxChar* ptr = auxPtr; // I prefer working with a copy called ptr
						  // Get ptr past the begin marker
	ptr = ptr + m_nBeginMkrLen;
	offset = m_nBeginMkrLen; // get past mkr & space
	// Start looking for the matchingEndMkr
	while (TRUE) {

		// Did we advance past the end of the source text being parsed in
		if (IsEnd(ptr))
		{
			break;  // exit loop
		}
		wxString strEndMkr = wxString(ptr, endMkrLen);
		if (strEndMkr == matchingEndMkr)
		{
			// We've reached the matching endmarker
			// so return offset
			return offset;
		}
		else
		{
			// We need protection here against the scan going on and on past
			// the end of the span if someone has forgotten to type the
			// endmarker in the text stream. Looking at USFM3 documentation,
			// no other marker, endmarker or begin marker, occurs within the
			// metadata. So a sufficient protection is that if at the location
			// where ptr is pointing, it encounters a backslash after failing 
			// the match block above, that means the loop must be exited.
			// We should treat it as quasi-correct loop termination anyway 
			// (another endmarker or begin-marker following would still give 
			// an almost correct metadata delineation), so return the chapter 
			// & verse, and warn the user that probably the matching endmarker
			// has been omitted in the input data markup, - the error is 
			// probably nearby, somewhere later than the ch:vs in the message
			// had to be exited.
			if (*ptr == _T('\\')) // matched a marker of some kind 
			{
				break; // exit the loop
			}
			// No marker yet encountered, so advance ptr & iterate
			ptr++;
			offset++;
		}
	} // end of while (TRUE) loop
	// Didn't find a match - warn user, and put message in LogUserAction()
	wxString msg;
	msg = msg.Format(_("Failed to find the expected end-marker: %s somewhere after chapter:verse %s\nPerhaps wrongly omitted in the source text USFM markup? After sequence number %d.\n Processing can continue. But better to exit without saving, add the missing end-marker, save, then re-create the document"),
		matchingEndMkr.c_str(), gpApp->m_chapterVerseAttrSpan.c_str(), pCurSrcPhrase->m_nSequNumber);
	gpApp->LogUserAction(msg);
	long style = wxOK | wxCENTRE | wxICON_EXCLAMATION;
	wxString caption = _("Warning: end-marker omitted?");
	wxMessageDialog((wxWindow*)NULL, msg, caption, style, wxDefaultPosition);

	return offset;
}

// Test if the passed in pEndMkr is stored in the CSourcePhrase instance's m_endMarkers member
// Testing for a character marker, or similar, which has attributes
bool CAdapt_ItDoc::IsThisEndMarkerStoredHere(CSourcePhrase* pSrcPhrase, wxString* pEndMkr)
{
	wxString strEndMkrs = pSrcPhrase->GetEndMarkers();
	if (strEndMkrs.IsEmpty()) return FALSE;
	int offset = strEndMkrs.Find(*pEndMkr);
	if (offset == wxNOT_FOUND)
	{
		return FALSE;
	}
	// Must have found a match
	return TRUE;
}

bool  CAdapt_ItDoc::IsAnUnwantedDegreeSymbolPriorToAMarker(wxChar* ptr)
{
	if (*ptr == uselessDegreeChar)
	{
		// BEW 8Sep19, removed the stipulation that it only occurs before
		// certain markers. I found in the Wolof (Senegal) data that the
		// USFM configuration person for Paratext had it in front of
		// at least one word with no marker ( the word: set  in ch5 verse 10
		// of 2 Kings. So just skip it everywhere it is found.
		// Does the backslash of a marker follow it?
		//if (*(ptr + 1) == _T('\\'))
		//{
		//	return TRUE;
		//}
		return TRUE;
	}
	return FALSE;
}
/////////  End of the USFM 3 supporting code which TokenizeText() will use

// BEW 16Sep22 Needs a mild refactor, the situation at the bar could be any of these:
// word|     or    word<sp>|   or (less likely)  word<sp><sp>|  (or even more preceding spaces)
// and so two loops will be needed - one to traverse till a non-space is found at word end,
// and the the second to find when the first space is encountered preceding the word start
wxString CAdapt_ItDoc::CacheWordBeforeBar(wxChar* ptrToBar)
{
	//wxString strToCache = wxEmptyString; // initialize
	wxASSERT(*ptrToBar == m_barChar);
	wxChar* p = ptrToBar;
	bool bItsWhite = FALSE; // initialise
	wxChar* pWhite = --p; // could be pointing at space, or at last char of word
	wxChar space = _T(' ');
	int countWhites = 0;
	do {
		if (*pWhite == space)
		{
			++countWhites;
			--pWhite;
		}
		else
		{
			// don't count it, it's not white space; the count is correct as is
			break;
		}
	} while (IsWhiteSpace(pWhite));
	// reset the iterator for scanning across the word
	if (countWhites == 0)
	{
		p = ++pWhite; // point p back at the bar
	}
	else
	{ 
		p = ptrToBar; // point back at the bar
		p = p - countWhites; //back up over the counted white chars
	}
	// pWhite is now pointing to the white space immediately after the word, 
	// or to bar if countWhites is still zero
	wxChar* pWordEnd = p;
	while (TRUE)
	{
		// point to next previous character
		--p;
		bItsWhite = IsWhiteSpace(p);
		if (bItsWhite)
		{
			// Point back at the non-white following wxChar
			++p;
			break; // break out of the loop
		}
	} // end of loop
	wxString cacheThis(p, pWordEnd);
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined (FIXORDER)
	{
		wxString at_ptr_p = wxString(p, 30);
		wxString at_wordEnd = wxString(pWordEnd, 30);
		wxLogDebug(_T("CacheWordBeforeBar line %d , WORD= %s , at_ptr_p= %s , at_wordEnd= %s"),
			__LINE__, cacheThis.c_str(), at_ptr_p.c_str(), at_wordEnd.c_str());
	}
#endif
	return cacheThis;
}

// a debugging function to check initial m_nSequNumber values in the m_pSoucePhrases list
// up to a maximum of n (a digit passed in)
void CAdapt_ItDoc::LogSequNumbers_LimitTo(int nLimit, SPList* pList)
{
	// Limit it to max of 5 instances , to simplify the logging
	CSourcePhrase* sp = (CSourcePhrase*)NULL; // initialize
	if (pList == NULL)
		return;
	if (pList->IsEmpty())
		return;
	int count = pList->GetCount();
	if (count > nLimit || count > 5)
		return;
	int sequNums[5];  // our sequ number storage array
	wxUnusedVar(sequNums);
	// initialize
	sequNums[0] = -1;
	sequNums[1] = -1;
	sequNums[2] = -1;
	sequNums[3] = -1;
	sequNums[4] = -1;

	SPList::Node* pos_pList = pList->GetFirst();
	wxASSERT(pos_pList != NULL);
	int anIndex = -1;
	while (pos_pList != NULL)
	{
		sp = (CSourcePhrase*)pos_pList->GetData();
		anIndex++;
		pos_pList = pos_pList->GetNext();
		sequNums[anIndex] = sp->m_nSequNumber;
	}
	// Display to the developer
#if !defined(NOLOGS)
	wxLogDebug(_T("%s: line %d:  first %d , second %d , third %d , fourth %d , fifth %d"),
		__FUNCTION__, __LINE__, sequNums[0], sequNums[1], sequNums[2], sequNums[3], sequNums[4]);
#endif
}

// Return the word-proper, assuming there are no pre-word punctuation chars present,
// and any ending punctuation characters in the string pointed at by pEndPuncts.
// Assume also, the input word is from source text
wxString CAdapt_ItDoc::SimpleWordParser(wxString word, wxString* pEndPuncts)
{
	wxString key;
	if (word.IsEmpty())
	{
		*pEndPuncts = wxEmptyString;
		return word;
	}
	else
	{
		// We assume no preword punctuation
		wxChar first = word[0];
		wxString srcPuncts = gpApp->m_strSpacelessSourcePuncts;

		bool bInitialPunct = IsOneOf(&first, srcPuncts);
		wxUnusedVar(bInitialPunct);
		wxASSERT(bInitialPunct == FALSE);

		// append to key until punctuation reached, or until word string 
		// is exhausted
		key = wxEmptyString;

		int sizeStr = word.Len(); // will include punctuation if present at end
		wxChar aChar;
		bool bIsPunct = FALSE; // initialize
		int i;
		// This will collect 1 or more final puncts, and will return
		// in key the value which should go into pSrcPhrase.m_key
		// and *pEndPuncts will contain what should go into pSrcPhrase->m_follPuncts
		for (i = 0; i < sizeStr; i++)
		{
			// get next wxChar
			aChar = word[i];
			bIsPunct = IsOneOf(&aChar, srcPuncts);
			if (bIsPunct)
			{
				*pEndPuncts += aChar;
			}
			else
			{
				key += aChar;
			}
		}
	}
	return key;
}

// BEW 7Apr20. A helper function when scanning for the ending CSourcePhrase instance
// of a footnote, cross reference, or extended footnote - if there was a USFM markup
// error or other glitch that results in a matching endmarker for the passed in
// beginMkr not found - we want to limit the amount of "run on" - so things like \v
// \c \p \ip \s \s1 should cause a halt to define the span end.
// We might as well make it check for the matching endmarker within
// pSrcPhrase->m_bEndMarkers - that's where it should be, somewhere in the list
// Get or form the wanted endmarker in the caller; it should be the wholeMarker (no space following)
// endMkr		->	the prohibitive begin-marker found, if TRUE was returned
// pSrcPhrase	->	ptr to the CSourcePhrase instance in the loop, being examined for a match to endMkr 
// bStoppingRunOn <- FALSE if end-of-span was successfully determined by matching endMkr to its
//					corresponding same endmarker in the loop's CSourcePhrase instance. TRUE if no
//					such match was achieved and a stop to run-on was produced by other means herein
// Return TRUE when end-of-span was determined in either way - the caller can get the sequence number
// for the span end from pSrcPhrase, or that with the help of bStoppingRunOn when the latter is TRUE
bool CAdapt_ItDoc::ForceSpanEnd(wxString& endMkr, CSourcePhrase* pSrcPhrase, bool& bStoppingRunOn)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	bStoppingRunOn = FALSE; // initialise
	wxString matchEndMkr = endMkr;
	matchEndMkr.Trim(); // ensure no space trailing it
	wxString endMkrs = pSrcPhrase->GetEndMarkers();
	bool bGotAMatch = FALSE;
	wxString endMkrFound = wxEmptyString;
	if (!endMkrs.IsEmpty())
	{
		bool bFoundOne = pApp->FindProhibitiveEndMkr(pSrcPhrase, endMkrFound); // endMkrFound will
													// not be returned with a trailing space
		if (bFoundOne)
		{
			// We got one, check for a match. If matched, return TRUE to force 
			// this pSrcPhrase to be the span end
			if (matchEndMkr == endMkrFound)
			{
				endMkr = endMkrFound;
				return TRUE;
			}
		}
	}
	if (!bGotAMatch || endMkrs.IsEmpty())
	{
		// Protect from long run-on
		wxString augmentedBeginMkr = endMkr.Left(endMkr.Len() - 1); // remove the final *
		augmentedBeginMkr += _T(' ');
		// Make a fast access string for the markers which should halt the scan
		wxString haltersStr = _T("\\p \\ip \\v \\c \\s \\s1 ");
		// Check for a match of any of these
		int offset = wxNOT_FOUND; // initialise
		offset = haltersStr.Find(augmentedBeginMkr);
		if (offset >= 0)
		{
			// Gotta halt here
			bStoppingRunOn = TRUE; // Used to tell caller to reduce the ending sequNum by 1
			return TRUE;
		}
	}
	return FALSE; // Don't halt the scanning at the passed in pSrcPhrase
}

// BEW 8Apr20
// We scan the list, backwards from where the passed in pSrcPhrase is located, looking
// for the first CSourcePhrase having begin marker \f \ef or \x in its m_markers member.
// When we find that, we scan forward starting from the passed in pSrcPhrase location,
// looking for the endmarker (in m_endMarkers) which ends the span.
// Of course, this algorithm may find a span, but the span is located nowhere near the
// location where pSrcPhrase is: so we'll compare sequence numbers - pSrcPhrase is
// in such a span only if its sequence number lies between those for the start and end
// of the span - and return TRUE. We may also not find a span, in which case return FALSE
// Usage: we the span is taboo for inserting a placeholder within it - we'll use this
// function in the placeholder insertion Update...() handler to disable using the two
// buttons when control is within a footnote, extendeded footnote, or cross-ref span
// The next three functions accomplish the above.
// Note: pos_pList = pos_pList->GetPrevious() will work, but that pos_pList cannot in the same function
// be used to do pos_pList = pos_pList->GetNext(). I tried having one function with both scanning back
// and then scanning forwards, but that resulted in a C2440 error message. (Gloogling 
// that was singularly unfruitful). So I split the work into the next two functions - 
// one scans back, the other scans forward. That works sweetly.
// pSrcPhrase	->	the active pile's CSourcePhrase pointer 
// beginMkr		<-	the prohibitive begin-marker found, if TRUE was returned
// nBeginSN		<-	the m_nSequNumber value of the CSourcePhrase instance at which
//					the span commences
// If FALSE is returned, interpret that as no beginning of a prohibitive span was
// found prior to the pSrcPhrase location (other spans may exist, but we ignore them);
// and FALSE would be a sufficent reason for keeping the placeholder insertion buttons enabled)
bool CAdapt_ItDoc::FindBeginningOfSpanProhibitingPlaceholderInsertion(CSourcePhrase* pSrcPhrase,
	wxString& beginMkr, int& nBeginSN)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(!pList->IsEmpty());
	int nSequNum = pSrcPhrase->m_nSequNumber;

	SPList::Node* pos_pList = pList->Item(nSequNum);
	SPList::Node* docStartPos = pList->GetFirst();

	// Scan back to find the first srcPhrase's sequ number having one of \f \ef \x
	// begin-markers; there might be none - if so, the scan would go to the doc start
	CSourcePhrase* pSP = pSrcPhrase;

	// Initialisations
	wxString m_markersBeginMkr = wxEmptyString;
	bool bGotBeginMkr = FALSE;
	bool bFoundSpanStart = FALSE;

	//calls many many times, do a caching algorith above, which only re-calls if
	// the active pile ptr changes in value
	bGotBeginMkr = FindProhibitiveBeginMarker(pSP->m_markers, m_markersBeginMkr);
	if (bGotBeginMkr)
	{
		beginMkr = m_markersBeginMkr;
		nBeginSN = pSP->m_nSequNumber; // we've found the span start
#if defined (_DEBUG) && !defined(NOLOGS)
		wxLogDebug(_T("%s::%s Line %d, src= %s , nBeginSN= %d , m_markers= %s , beginMkr= %s  IS-AT"),
			__FILE__, __FUNCTION__, __LINE__, pSP->m_srcPhrase.c_str(), nBeginSN, pSP->m_markers.c_str(), beginMkr.c_str());
#endif
		return TRUE;
	}
	// else, if the passed in pSrcPhrase does not start such a span, loop
	// back to find the first pSP of a candidate prohibited span
	else
	{
		while (pos_pList != docStartPos)
		{
			pos_pList = pos_pList->GetPrevious();
			pSP = pos_pList->GetData();
			// Re-initialisations
			m_markersBeginMkr = wxEmptyString;
			bGotBeginMkr = FALSE;
			bFoundSpanStart = FALSE;

			wxUnusedVar(bFoundSpanStart);

			bGotBeginMkr = FindProhibitiveBeginMarker(pSP->m_markers, m_markersBeginMkr);
			if (bGotBeginMkr)
			{
				beginMkr = m_markersBeginMkr;
				nBeginSN = pSP->m_nSequNumber; // we've found the span start
//#if defined (_DEBUG)
//				wxLogDebug(_T("%s::%s Line %d, src= %s , nBeginSN= %d , m_markers= %s , beginMkr= %s  IS-EARLIER"),
//					__FILE__, __FUNCTION__, __LINE__, pSP->m_srcPhrase.c_str(), nBeginSN, pSP->m_markers.c_str(), beginMkr.c_str());
//#endif
				return TRUE;
			}
		} // end of while loop

	} // end of else block for test: if (bGotBeginMkr)

	// Not found the start of a prohibitive span
	beginMkr = wxEmptyString;
	nBeginSN = -1;
	return FALSE;
}

bool CAdapt_ItDoc::FindEndOfSpanProhibitingPlaceholderInsertion(CSourcePhrase* pSpanStart_SrcPhrase, wxString matchEndMkr, int& nEndSN)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(!pList->IsEmpty());
	int nSequNum = pSpanStart_SrcPhrase->m_nSequNumber;
	wxASSERT(!matchEndMkr.IsEmpty());

	SPList::Node* pos_pList = pList->Item(nSequNum);
	SPList::Node* docEndPos = pList->GetLast();

	int spanEndSequNum = -1;   // initialise

	// Scan forwards to find the first sequ number storing one of \f* \ef* \x* end-markers;
	// there might be none - the scan would go to the doc end, except this function will
	// check for over-run and terminate with a probably over-long but reasonable span length
	CSourcePhrase* pSP = pSpanStart_SrcPhrase;

	// Initialisations
	wxString endMarkerToMatch = matchEndMkr; // as passed in
	bool bGotSpanEnd = FALSE;
	bool bIsForbiddenEndMkr = FALSE;
	bool bFoundSpanEnd = FALSE;
	bool bStoppingRunOn = FALSE; // if TRUE, the run-on block was accessed and the proper
								 // location to end the span is at the previous pSrcPhrase
	// Check the starting location first (it must not be the CSourcePhrase instance which
	// was the span-initial one - but later - our algorithm will scan from the immediate next
	// one and forwards)
	bGotSpanEnd = ForceSpanEnd(endMarkerToMatch, pSP, bStoppingRunOn);
	if (bGotSpanEnd)
	{
		// Is it one of \f* \ef* \x* or \ex? -- checks to make a redundant confirmation that
		// we have matched only one of the four prohibitive endMarkers
		bIsForbiddenEndMkr = IsForbiddenMarker(endMarkerToMatch, TRUE); // TRUE is bCheckForEndMkr
	}
	if (bIsForbiddenEndMkr && bGotSpanEnd)
	{
		bFoundSpanEnd = TRUE;
		spanEndSequNum = pSP->m_nSequNumber; // we've found the span end (probably by matching)
		if (bStoppingRunOn)
		{
			spanEndSequNum--; // end at the previous pile
		}
//#if defined (_DEBUG)
		//		wxLogDebug(_T("%s::%s Line %d, spanEndSequNum= %d , bStoppingRunOn= %d"),
		//			__FILE__, __FUNCTION__, __LINE__, (int)spanEndSequNum, (int)bStoppingRunOn);
//#endif
		nEndSN = spanEndSequNum;
		return TRUE;
	}
	// Else, if the passed in pSrcPhrase does not end such a span, loop
	// forward to find the first pSP which stores a matching endmarker, or
	// which halts the scan because a significant begin-marker prevented run-on
	else
	{
		while (pos_pList != docEndPos)
		{
			pos_pList = pos_pList->GetNext();
			pSP = pos_pList->GetData();
			// Re-initialisations
			bGotSpanEnd = FALSE;
			bIsForbiddenEndMkr = FALSE;
			bFoundSpanEnd = FALSE;
			bStoppingRunOn = FALSE;

			bGotSpanEnd = ForceSpanEnd(endMarkerToMatch, pSP, bStoppingRunOn);
			if (bGotSpanEnd)
			{
				// Is it one of \f* \ef* \ex* or \x* ?
				bIsForbiddenEndMkr = IsForbiddenMarker(endMarkerToMatch, TRUE); // TRUE is bCheckForEndMkr
			}
			if (bIsForbiddenEndMkr && bGotSpanEnd)
			{
				bFoundSpanEnd = TRUE;
				spanEndSequNum = pSP->m_nSequNumber; // we've found the span end (probably by matching)
				if (bStoppingRunOn)
				{
					spanEndSequNum--; // end at the previous pile
				}
//#if defined (_DEBUG)
				//	wxLogDebug(_T("%s::%s Line %d, spanEndSequNum= %d , bStoppingRunOn= %d"),
				//		__FILE__, __FUNCTION__, __LINE__, (int)spanEndSequNum, (int)bStoppingRunOn);
//#endif
				nEndSN = spanEndSequNum;
				break;
			}
		}
	} // end of else block for test: if (bIsForbiddenEndMkr && bGotSpanEnd)

	if (bFoundSpanEnd)
	{
		return TRUE;
	}
	else
	{
		nEndSN = -1;
		return FALSE;
	}
}

bool CAdapt_ItDoc::IsWithinSpanProhibitingPlaceholderInsertion(CSourcePhrase* pSrcPhrase)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	int SequNumSpanStart = -1;
	int SequNumSpanEnd = -1;
	int SequNumCurLoc = pSrcPhrase->m_nSequNumber;
	wxString spanBeginMkr = wxEmptyString;
	bool bGotSpanEnd = FALSE;

	bool bFoundSpanStart = FindBeginningOfSpanProhibitingPlaceholderInsertion(pSrcPhrase, spanBeginMkr, SequNumSpanStart);
	if (!bFoundSpanStart)
	{
		return FALSE;
	}
	else
	{
		// Got a starting location, now try for the ending location

		// Gotta start at next one,
		// because \f or \ef or \x  or \ex is in the quick access string 'halters'
		// within the prevent-run-on-block within ForceSpanEnd()
		int nSequNum = SequNumSpanStart + 1;
		if (nSequNum > pApp->GetMaxIndex())
		{
			// protect from list index out-of-bounds
			nSequNum = pApp->GetMaxIndex();
			SequNumSpanEnd = nSequNum;
			return TRUE; // end is end of doc
		}
		SPList::Node* pos_pSP = pApp->m_pSourcePhrases->Item(nSequNum);
		CSourcePhrase* pSpanStart_SrcPhrase = pos_pSP->GetData();
		wxASSERT(pSpanStart_SrcPhrase != NULL);
		spanBeginMkr.Trim(); // ensure no white space at its end
		wxString matchEndMkr = spanBeginMkr += _T('*');
		bGotSpanEnd = FindEndOfSpanProhibitingPlaceholderInsertion(pSpanStart_SrcPhrase, matchEndMkr, SequNumSpanEnd);
	}
	if (bGotSpanEnd && (SequNumSpanEnd != -1))
	{
		// Check, is our SequNumCurLoc value within the bounds, including start and end of the span?
		if ((SequNumCurLoc >= SequNumSpanStart) && (SequNumCurLoc <= SequNumSpanEnd))
		{
			return TRUE;
		}
	}
	// It's not within such a span
	return FALSE;
}

int CAdapt_ItDoc::CountCharsToBar(wxChar* pStart, wxChar* pEnd)
{
	int counter = 0;
	wxChar barChar = _T('|');
	wxChar* ptr = pStart; // define the iterator
	if (ptr > pEnd)
	{
		return -1;
	}
	while (*ptr != barChar && (ptr < pEnd))
	{
		++counter;
		++pStart;
	}
	return counter;
}

bool CAdapt_ItDoc::IsOpenBracketAhead(wxChar* pChar)
{
	wxChar* ptr = pChar;
	while (IsWhiteSpace(ptr))
	{
		++ptr;
	};
	// On exit, ptr points at what follows the whites. Is it a '[' character?
	return (*ptr == _T('['));
}

bool CAdapt_ItDoc::IsClosingBracketNext(wxChar* pChar)
{
	wxChar* ptr = pChar;
	while ( IsWhiteSpace(ptr)  )
	{
		++ptr;
	};
	// On exit, ptr points at what follows the whites. Is it a ']' character?
	return (*ptr == _T(']'));
}

bool CAdapt_ItDoc::IsDetachedWJtype_endMkr_Ahead(wxChar* pChar, wxChar* pEnd, int& countOfSpaces)
{
	bool bIsAhead; // init
	wxChar* ptr = pChar;
	wxChar hairspace = (wxChar)0x200A;
	bool bBeforeEnd;
	bool bIsLatinSpace;
	bool bIsHairSpace;
	bool bIsNotOpenQuote;
	bool bIsNotMkr;
	bool bIsEndMkr;
	countOfSpaces = 0; // initialise

	bIsAhead = FALSE;
	if (ptr < pEnd)
	{
		// What could be ahead of ptr? (1) a latin space (2) a hairspace (U+200A) (3) pEnd
		// (4) a punctuation character (but NOT one which indicates belonging to the next
		// pSrcPhrase, so test !IsOpeningQuote(ptr) ). No need to consider any puncts while
		// iterating to the endMkr, except exit FALSe if opening quote encountered
		bBeforeEnd = ptr < pEnd ? TRUE : FALSE;
		bIsNotMkr = !IsMarker(ptr);
		bIsLatinSpace = *ptr == _T(' ');
		bIsHairSpace = *ptr == hairspace ? TRUE : FALSE;
		bIsNotOpenQuote = !IsOpeningQuote(ptr);
		bIsEndMkr = FALSE; // init


		while (bBeforeEnd && bIsNotMkr && bIsNotOpenQuote)
		{
			if (bIsLatinSpace || bIsHairSpace)
			{
				countOfSpaces++; // count any whitespaces parsed over
			}
			// advance ptr by one wxChar
			ptr++;

			// update the loop continuation conditions
			bBeforeEnd = ptr < pEnd ? TRUE : FALSE;
			bIsNotMkr = !IsMarker(ptr);
			// If bIsNotMkr is FALSE, then keep parsing to look for an endMkr.
			// But if a beginMkr was encountered, then none of the m_BlueEndMarkers set was
			// encountered - in which case, return FALSE (because control came to a mkr, but it could
			// not possibly be \wj* or similar from that large end marker set). On the other hand,
			// if we test and find we've come to an endMkr, the look it up to get it's 
			// pAnalysis struct. The struct will tell us if it's inLine or not, and if its a \wj* type 
			if (!bIsNotMkr) // i.e. it's a marker of some kind
			{
				// At ptr there is a marker of some kind. Could be a beginMkr, or an endMkr. Investigate
				wxString asterisk = _T("*");
				wxString wholeMkr = GetWholeMarker(ptr); // gets backslash and * if present at end
				wxASSERT(wholeMkr != wxEmptyString);
				bIsEndMkr = (wholeMkr.Find(asterisk) >= 2); // minimal endMkr has at leasts 2 chars before *
				if (bIsEndMkr)
				{
					wxString augEndMkr = wholeMkr + _T(' '); //create for use in fast access string
					wxString bareMkr = GetBareMarkerForLookup(ptr);
					USFMAnalysis* pAnalysis = LookupSFM(bareMkr);
					bool bIsInline = FALSE; // initialise
					if (pAnalysis != NULL)
					{
						if (pAnalysis->inLine)
						{
							bIsInline = TRUE;
						}
						if (bIsInline)
						{
							// It's inline, so check for presence in m_BlueEndMarkers
							// fast access string
							int offset = wxNOT_FOUND;
							offset = gpApp->m_BlueEndMarkers.Find(augEndMkr);
							if (bIsInline && (offset >= 0))
							{
								bIsAhead = TRUE;
								return bIsAhead;
							}
						}
						else
						{
							// It's not inLine. But m_BlueEndMarkers mkr set, which is quite large,
							// are all of type inLine == 1 (TRUE), and \wj* and similar type of markers
							// are inLine, so it's not 
							bIsAhead = FALSE;
							return bIsAhead;
						}
					}
					else
					{
						// The endMkr is unknown to LookupSFM(), so will not be in  m_BlueEndMarkers 
						// fast access string, so return FALSE
						bIsAhead = FALSE;
						return bIsAhead;
					}
				}
				else
				{
					// It must be a beginMkr, so return FALSE
					bIsAhead = FALSE; // already is FALSE, but this makes it clear
					return bIsAhead;
				}
			} // end of TRUE block for test: if (!bIsNotMkr) i.e. it's a marker of some kind

			bIsLatinSpace = *ptr == _T(' ');
			bIsHairSpace = *ptr == hairspace ? TRUE : FALSE;
			bIsNotOpenQuote = !IsOpeningQuote(ptr);

		} // end pf while loop: while (bBeforeEnd && !bIsNotMkr && bIsNotOpenQuote)
		
	}  // end of TRUE block for test: if (ptr < pEnd)
	return bIsAhead;
}

// BEW 25Oct22 pChar should be a digit, parse over things like 4:17, or 5:4-9. but perhaps
// do not include the final . of 5:4-9.  (Use primarily in footnotes in the input text)
// BEW 22Jun23 need to allow for more complexity after the chapVerse parse, which needs to be
// included in the parse. In 43LUKCuc.SFM from Franscisco there is, within a \x ... \x* span
// (I have to parse it, even if it is default filtered out) the following source data sequence:
// \xo 1.32-33 \xt 2Sa. 7.12-13,16; Isa. 9.7\x*
// All of that is handleable with present code, except the ",16;" substring after 7.12-13
// So I'll have to include some code at the end of ParseChVerseUnchanged to detect when a punct
// followed by more digits occurs, and when detected, parse the substring until end of the extra
// digits, and then finish off any subsequent puncts finish at a whitespace. Here goes...
// BEW 17Nov23, Gupapuyngu has a sequence:  10:4-ŋuru  which, if I don't add code to parse it
// successfully (the "-ŋuru" bit is the problem), the function would return "10:4-" causing the
// "ŋuru" to be parsed as test on the next pSrcPhrase. ParseAWord() can't handle the 10:4 due to
// the presence of punctuation (the ':'), so I've gotta get a parse done here
wxString CAdapt_ItDoc::ParseChVerseUnchanged(wxChar* pChar, wxString spacelessPuncts, wxChar* pEnd)
{
	wxChar* ptr = pChar;
	wxString chvsStr = wxEmptyString;
	wxString emptyReturn = wxEmptyString;
	if (!IsAnsiDigit(*ptr))
	{
		// First character is not a digit, so return the empty string
		return chvsStr;
	}
	// OK, can proceed, set the halter characters
	wxString chDelim = wxEmptyString;	
	wxString rangeChar = wxEmptyString;
	wxString chDelimForRange = wxEmptyString;
	wxString chARange = wxEmptyString; // intialise
	wxString firstPart = wxEmptyString;
	wxChar colon = _T(':');
	wxChar period = _T('.');
	wxChar semicolon = _T(';');
	wxChar ahyphen = _T('-');
	wxChar acomma = _T(',');
	wxChar horiz_bar = (wxChar)0x2015;
	wxChar longHyphen = (wxChar)0x2013;
	wxString partsSet = _T("abc"); //for things like 2:5a
	bool   bIsDigit = FALSE; // intialise
	bool   bIsRangeChar = FALSE; // initialise
	bool   bIsABorC = FALSE; // initialise
	bool   bExitEarly = FALSE; // initialise
	wxChar chClosingParen = _T(')'); // to extent functionality, for dealing with, e.g. 5,000) -- dont include ')' in the parse
	while ((ptr < pEnd) && (*ptr != colon) && (*ptr != period) && (*ptr != semicolon) && (*ptr != ahyphen)  && (*ptr != horiz_bar) )
	{
		bIsDigit = IsAnsiDigit(*ptr);
		bIsABorC = IsOneOf(ptr, partsSet);
		if (bIsDigit)
		{
			firstPart += *ptr;
			ptr++;
		}
		else if (bIsABorC)
		{
			firstPart += *ptr;
			ptr++;
		}
		else
		{
			// this loop must terminate (e.g. a comma will terminate it)
			break;
		}
	}
	// BEW 5Jan23 This function has to be able to correctly parse over numbers in the src text, which are NOT a part
	// of a chaper:verse type of parsing. Numbers in the text will be typically <digits> + (optional puncts + whitespace char
	// so bleed out this possibility here
	wxChar* pAux = ptr;
	int itemLen = 0;
	itemLen = ParseFinalPuncts(pAux, pEnd, spacelessPuncts);
	if (itemLen > 0)
	{
		pAux += itemLen;
	}
	// What's next, if pAux is pointing at a whitespace, then return firstPart (leave it for caller to handle final puncts)
	bool bIsWhite = IsWhiteSpace(pAux);
	if (bIsWhite)
	{
		return firstPart;
	}

	// Now get past whatever delimiter separates firstPart from what follows. ( ?secondPart? maybe)
	wxString secondPart = wxEmptyString; // initialise
	wxString allowedDelimiters = _T(":.;");
	wxString RangeSet = wxString(ahyphen) + wxString(acomma) + wxString(horiz_bar) + wxString(longHyphen);

	// Terminators for 2nd part will be whitespace or any punctuation or delimiter or a RangeSet char
	bool bIsOne = IsOneOf(ptr, spacelessPuncts);
	bool bIsDelim = IsOneOf(ptr, allowedDelimiters);
	if (bIsDelim)
	{
		chDelim = wxString(*ptr);
	}
	else
	{
		// bIsDelim might not get set to other an an empty string, if ptr does not point at
		// one of the delimiters. Bill worried about this (email, "a couple red flags" approx 28Apr23),
		// so trying to GetChar(0) further below could then crash the app. I think the way forward is
		// to provide the most commonly occurring delimiter - namelyl ':' here, for safety
		chDelim = _T(":");
	}
	bIsRangeChar = IsOneOf(ptr, RangeSet);
	if (bIsRangeChar)
	{
		rangeChar = wxString(*ptr);
	}
	bool bExitNow = FALSE;
	bExitNow = !(bIsOne || bIsDelim || bIsRangeChar);
	if (bExitNow)
	{
		// BEW 15Jul23, must not return empty string if the first block above parsed over some
		// digits, as when parsing a number in the text (eg. 19 preceding a \rq* marker, as in
		// some of Bill's Nyindou Acts text, at 3:23) Since firstPart will already have "19" in
		// it, return it if returning is wanted
		if (!firstPart.IsEmpty())
		{
			return firstPart;
		}
		else
		{
			return emptyReturn;
		}
	}
	else
	{
		// Must have found one, get past it
		/*
		if (bIsRangeChar)
		{
			//rangeChar = *ptr;
			ptr++; // now set above, get past it
		}
		else
		{
			//chDelim = *ptr; // preserve it, for constructing chvsStr later
			// now set above, so just advance over it
			ptr++;
		}
		*/
		ptr++;
	}
	// ptr should now be pointing at a digit (for the verse number, or start of a verse range), if not a range;
	// but if rangeChar is not null, then ptr could be at a chap:verse or chap,verse or chap;verse or first digit of a verse
	wxString thirdPart = wxEmptyString; // initialise
	wxString fourthPart = wxEmptyString; // initialise
	bool bIsAPunct = FALSE; // initialise
	if ( bIsRangeChar )
	{
		// ptr is past the range character, so what follows could be a chap:verse or chap,verse or 
		// chap;verse; or more likely - the first digit of a verse. We have to be able to handle
		// something like "2-1.3", and if so, all we have so far is firstPart '2', rangeChar '-' or one
		// of the other possible ones, and so what may lie ahead is the "1.3" part.  
		// OR, often after a range character, there is just a verse number - and it may have an a b or c suffix
		if (ptr < pEnd)
		{
			if ((ptr < pEnd) && IsAnsiDigit(*ptr)) // gotta have a digit to kick off
			{
				// It is a verse or chapter number, so parse over it. If it's a chapter number, then we expect a 
				// new delimiter will follow - we'll use chDelimForRange for that. It's initialised to null above
				// If we are parsing a chapter number, there will be a fourth part to deal with, for it's verse

				// This time, we have to include space (of any kind) in case what we are parsing over is a verse number
				// like the 15 in "7:15" if someone's data used a ch:vs at the end of range. Unlikely, but worth
				// catering for, because it's what we don't think will happen, that sooner or later bites us.
				while ((ptr < pEnd) && (*ptr != colon) && (*ptr != period) && (*ptr != semicolon) && (*ptr != ahyphen) && !IsWhiteSpace(ptr) && (*ptr != horiz_bar))
				{
					// BEW 1May23 control may get here after parsing "5-7," as far as the comma, but the loop test
					// allows the comma to be parsed over - and we want to avoid that. The comma, or other ending 
					// punctuation, if followed by a space, we want to return that chvsStr string only up to, but
					// not including, the comma or other punct. So a test for punct followed by whitespace needs
					// to be done here (to break from the loop) and after the loop exits as well.
					bIsAPunct = IsOneOf(ptr, spacelessPuncts);
					if (bIsAPunct && IsWhiteSpace(ptr + 1))
					{
						break;
					}
					bIsDigit = IsAnsiDigit(*ptr);
					bIsABorC = IsOneOf(ptr, partsSet);
					if (*ptr == chClosingParen)
					{
						bExitEarly = TRUE;
					} // no else here
					// whm 20Sep2023 added. In the 642JN-DukU.sfm input data there is within its intro
					// a line that has this content:
					// \io1 M-zante \ior 1-3\ior*
					// and parsing the "1-3" substring, the "1" is firstPart, the "-" is second part and
					// the "3" is the third part, and is immediately followed by the backslash of the \ior* 
					// end marker. After parsing the third part "3" we need to set bExitEarly = TRUE as is
					// done in the block above for chClosingParen, otherwise the number parsed will end up
					// being parsed as "1-3\\" with the following backslash included. This in turn will cause
					// a system assert and other issues and possibly a crash. Therefore I'm adding the following
					// block here
					if (*ptr == gSFescapechar)
					{
						bExitEarly = TRUE;
					}
					if (bIsDigit)
					{
						thirdPart += *ptr;
						ptr++;
					}
					else if (bIsABorC)
					{
						thirdPart += *ptr;
						ptr++;
					}
					else
					{
						// this loop must terminate
						break;
					}
				}
				// What did we just parse? If it was a verse, then the loop exited because of whitespace encountere
				// so check for that
				if (IsWhiteSpace(ptr) || bExitEarly || (bIsAPunct && IsWhiteSpace(ptr + 1)) )
				{
					// A ha! We just did a verse number. So construct and return chvsStr; but if bExitEarly is TRUE
					// then it's becaue ptr is pointing at a closing parenthesis after last digit parsed (e.g. when
					// parsing "5,000) ) and we don't want chvsStr to include the ')' as part of what to return
					// (rangeChar is now (BEW 27Apr23) actually a wxString containing just one character - set above)
					chvsStr = firstPart + rangeChar + thirdPart;
					return chvsStr;
				}
				else
				{
					// Sigh. It was a chapter number. Got more work to do. What's the delimiter for the verse number?
					chDelimForRange = *ptr; // BEW 27Apr23 changed to a wxString, to avoid initialising with (wxChar)0
					ptr++;
					// Now we are past the delimiter, so ptr should now be pointing at the first digit of the verse number
					while ((ptr < pEnd) && IsAnsiDigit(*ptr) && (spacelessPuncts.Find(*ptr) == wxNOT_FOUND) && !IsWhiteSpace(ptr))
					{
						bIsDigit = IsAnsiDigit(*ptr);
						bIsABorC = IsOneOf(ptr, partsSet);
						if (bIsDigit)
						{
							fourthPart += *ptr;
							ptr++;
						}
						else if (bIsABorC)
						{
							fourthPart += *ptr;
							ptr++;
						}
						else
						{
							// this loop must terminate
							break;
						}
					}
					chvsStr = firstPart + rangeChar + thirdPart + chDelimForRange + fourthPart;
					// Got the full deal. Let this fall thru to return chvsStr at function end
				} // end of else block for test: 

			} // end of TRUE block for test: if ((ptr < pEnd) && IsAnsiDigit(*ptr))
			else
			{
				// If not a digit, the return what we have
				return firstPart + rangeChar;
			}
		} // end of TRUE block for test: if (*ptr == hyphen && (ptr < pEnd) )
		else
		{
			// at the end, so just return what we have so far
			return firstPart + rangeChar;
		}
	}
	else
	{
		// It's not a hyphen, comma or horizontal bar or longHyphen; so we should be dealing with a verse number or a b or c at end of digits
		if ((ptr < pEnd) && IsAnsiDigit(*ptr))
		{
			// scanning loop here, to parse over the verse number - same halters as above. but
			// any punctuation or a whitespace should halt the loop; allow for "part of verse" marking by a b or c
			while ((*ptr != colon) && (*ptr != period) && (*ptr != semicolon)  && (ptr < pEnd))
			{
				bIsDigit = IsAnsiDigit(*ptr);
				bIsABorC = IsOneOf(ptr, partsSet);
				if (bIsDigit)
				{
					secondPart += *ptr;
					ptr++;
				}
				else if (bIsABorC)
				{
					secondPart += *ptr;
					ptr++;
				}
				else 
				{
					// this loop must terminate
					break;
				}
			}
		}
		// It's not a verse range, so contruct chvsStr and return it
		chvsStr = firstPart + chDelim + secondPart; // chDelim is now a wxString

		// We could be at a RangeSet character, such as ahyphen, acomma, or horiz_bar. Check
		// If so, parse over,  and after that parse for the range end verse; if no range char,
		// end we are done
		bool bIsRangeChar2 = IsOneOf(ptr, RangeSet);
		if (bIsRangeChar2)
		{
			int offset = RangeSet.Find(*ptr);
			if (offset == 0)
			{
				chARange = wxString(ahyphen);
				// BEW 17Nov23 this is where we must support data such as "10:4-ŋuru" in Gupapuyngu
				// or similar languages, where (typically in a footnote) the user may add a hyphen
				// followed by a suffix, ŋuru for instance, means "from" or "after". At such data,
				// the suffix will terminate at a space. So we can update here to get an auxiliary
				// pointer over the hyphen, scan to space to generate the post-hyphen substring,
				// i.e. 'ŋuru', and test that the first and last characters of the string
				// are not digits. If so, build chvsStr with -ŋuru appended and return it to caller
				wxChar* pAux = ptr; // protect ptr location
				pAux++;
				int nCount = 0;
				while (!IsWhiteSpace(pAux))
				{
					pAux++;
					nCount++;
				}
				if (nCount > 0)
				{
					// There is a potential suffix following the hyphen, so form
					// a wxString from ptr (which still points at the hyphen) and
					// the value of nCount
					wxString suffix = wxString((ptr + 1), nCount);
					int suffixLen = (int)suffix.Length();
					//wxString reversed_suffix = MakeReverse(suffix); // done 'in place'
					// Now, test that first char of suffix is not a digit, and last char is not a digit
					bool bFirstIsDigit = FALSE; // init
					bool bLastIsDigit = FALSE; // init
					bFirstIsDigit = IsAnsiDigit(*(ptr + 1));
					bLastIsDigit = IsAnsiDigit(*((ptr + 1) + suffixLen - 1));
					// Now if both bools are FALSE, we likely have a non-digits substring after the hyphen,
					// if so, generate the new value for chvsStr and return it to the caller, after
					// advancing ptr to point at the space following the suffix string
					if (!bFirstIsDigit && !bLastIsDigit)
					{
						ptr = (ptr + 1 + suffixLen);
						chvsStr += ahyphen + suffix;
						return chvsStr;
					}
				} // end of TRUE block for test: if (nCount > 0)
				else
				{
					// There is no suffix following the hyphen, so let legacy code continue its parsing
					;
				}
			}
			else
			{
				if (offset == 1)
				{
					chARange = wxString(acomma);
				}
				else
				{
					chARange = wxString(horiz_bar);
				}
			}
		
			chvsStr += chARange; // for example, we've now got 1.1-  of 1.1-4
			ptr++;

			// follow up with parsing for: either the ending verse number, use thirdPart;
			// of if this thirdPart is followed by chDelim saved earlier, the number parsed 
			// is the chapter part of another chapt:verse for the range end - and for that
			// we need a fourthPart parse block
			if ((ptr < pEnd) && IsAnsiDigit(*ptr))
			{
				thirdPart.Empty();
				// scanning loop here, to parse over the number - same halters as above. but any punctuation
				// or a whitespace should halt the loop; allow for "part of verse" marking by a b or c
				while ((*ptr != colon) && (*ptr != period) && (*ptr != semicolon) && (ptr < pEnd))
				{
					bIsDigit = IsAnsiDigit(*ptr);
					bIsABorC = IsOneOf(ptr, partsSet);

					if (bIsDigit)
					{
						thirdPart += *ptr;
						ptr++;
					}
					else if (bIsABorC)
					{
						thirdPart += *ptr;
						ptr++;
					}
					else
					{
						// this loop must terminate
						break;
					}
				}
				chvsStr += thirdPart; // so far we'd have this much:  20:11-21
			}
			// BEW 1Jan23 addition to the unchanged above stuff. We need to determine if what we just
			// parsed over was a range-ending verse, or the chapter part of a range-ending chap:verse
			if (*ptr == chDelim.GetChar(0)) // assuming the delimiter for first part would also be used in a final chap<delim>verse
			{
				// It's the chapter part of a final chap:verse type of ending of range
				chvsStr += chDelim;
				ptr++; // point at what should be the first digit of the range end's verse number
				if ((ptr < pEnd) && IsAnsiDigit(*ptr))
				{
					fourthPart.Empty();
					// scanning loop here, to parse over the number - same halters as above. but any punctuation
					// or a whitespace should halt the loop; allow for "part of verse" marking by a b or c
					while ((*ptr != colon) && (*ptr != period) && (*ptr != semicolon) && (ptr < pEnd))
					{
						bIsDigit = IsAnsiDigit(*ptr);
						bIsABorC = IsOneOf(ptr, partsSet);

						if (bIsDigit)
						{
							fourthPart += *ptr;
							ptr++;
						}
						else if (bIsABorC)
						{
							fourthPart += *ptr;
							ptr++;
						}
						else
						{
							// this loop must terminate
							break;
						}
					}
					chvsStr += fourthPart; // so far we'd have this much:  20:11-21:25, which is all of it
				}
			}

		} // end of TRUE block for test: if (bIsRangeChar2)

	} // end of else block for test: if (bIsRangeChar)
	// BEW 22Jun23 extra code for an additional digit substring separated from chvsStr by a punctuation char
	// First, the test:
	wxString strExtra = wxEmptyString;
	bool bNextIsPunct = FALSE; // init
	int offset = wxNOT_FOUND; // init
	wxChar aChar = *ptr; // is aChar a punctuation character?
	offset = spacelessPuncts.Find(aChar);
	bNextIsPunct = offset >= 0 ? TRUE : FALSE;

	if (ptr < (pEnd - 4) && bNextIsPunct && IsAnsiDigit(*(ptr + 2)))
	{
		// There is extra material to parse and append to the chvrStr value. This is a very rare situation,
		// and probably it is enough just to find a following whitespace, measure the span, create strExtra
		// and append it.
		wxChar* pAux = ptr;
		wxChar spaceChar = _T(' ');
		int counter = 0;
		while (*pAux != spaceChar)
		{
			pAux++;
			counter++;
		}
		strExtra = wxString(ptr, counter);
		
		// Puncts parsed over by the above do not get stored separately in pSrcPhrase puncts storage,
		// they are a part of the chvsStr, and if the user wanted to change them, a reparse of the source
		// document would be necessary
		if (!strExtra.IsEmpty())
		{
			chvsStr << strExtra;
			// update ptr 
			ptr += counter;
		}
	} // end of the TRUE block for test: if (ptr < (pEnd - 4) && bNextIsPunct && IsAnsiDigit(*(ptr + 2)))

	return chvsStr;
}

// BEW 13Dec22 takes the currently active pSrcPhrase as input, and provided its m_nSequNumber
// value is greater than zero (thereby ensuring a previous pSourcePhrase exists), calculates
// what the previous pSrcPhrase is, and returns it. Returns NULL if there was error or no
// space to get a previous one. Later on 13Dec22, became clear that I don't need this. TokenizeText's
// propagation code always has available the current pSrcPhrase, and the previous one, pLastSrcPhrase,
// so I'll comment this function out. It may be useful later some time.
/*
CSourcePhrase* CAdapt_ItDoc::GetPreviousSrcPhrase(CSourcePhrase* pSrcPhrase)
{
	// this is a moodification of GetPrevSafeSrcPhrase() from View class, 
	// for use in TokenizeText()'s TextType colour support
	CAdapt_ItApp* pApp = &wxGetApp();
	CSourcePhrase* pSP;
	wxASSERT(pApp != NULL);
	wxASSERT(pSrcPhrase);
	int sn = pSrcPhrase->m_nSequNumber;
	if (sn > 0)
	{
		
		SPList::Node* pos_pSP = pApp->m_pSourcePhrases->Item(sn);

		pos_pSP = pos_pSP->GetPrevious();
		if (pos_pSP == NULL)
		{
			return (CSourcePhrase*)NULL;
		}
		pSP = pos_pSP->GetData();
		wxASSERT(pSP);
	}
	else
	{
		// No room for a previous pSP
		return (pSP = NULL);
	}
	return pSP;
}
*/

// BEW 13Dec22 get the last one in m_markers, as this sets the TextType
// BEW 8Jun23, uninitialised  wxfirst; causes garbage when first = reversedMkrs.GetChar(0);
// further down is attempted. Need to use a string, and do Left() -- that fixed it.
// BEW 6Jul23 there was no taking into account that \v would be followed by a verse number,
// so refactored to handle that possibility
wxString CAdapt_ItDoc::GetLastBeginMkr(wxString mkrs)
{
	if (mkrs.IsEmpty())
	{
		return wxEmptyString;
	}
	// How many markers are there? We can get a count using gSFescapechar in wxString::Replace(), replacing 
	// gSFescapechar with itself.
	wxString beginMkr;
	wxString revMkr;
	wxString backslash = _T("\\");
	size_t backslashCount = mkrs.Replace(backslash, backslash); // bReplaceAll is default TRUE
	wxString reversedMkrs = MakeReverse(mkrs);
	int offset = wxNOT_FOUND;
	offset = reversedMkrs.Find(backslash);
	if (backslashCount == 1)
	{
		// There is only one marker
		revMkr = reversedMkrs.Left(offset + 1); // +1 so as to grab the backslash
		beginMkr = MakeReverse(revMkr);
		return beginMkr;
	}
	if (backslashCount > 1)
	{
		if (offset > 0)
		{
			// There is a 'last' one, get it, reverse it, and return it
			// BEW 6Jun23 beware, the last marker may be a \v, and m_markers will also have after
			// it: space verseNum space, and so simply doing .Left() is not enough. We must reverse
			// the left material, and then do GetWholeMarker(), to extract the beginMkr from the
			// space and verseNum and final space.
			revMkr = reversedMkrs.Left(offset + 1); // +1 so as to grab the backslash
			beginMkr = MakeReverse(revMkr);
			wxChar space = _T(' ');
			offset = wxNOT_FOUND;
			offset = beginMkr.Find(space);
			if (offset >= 2) // a minimal width beginMkr is a backslash and one ascii character, eg: \v
			{
				// It found the after-marker space, so the marker is to its left
				beginMkr = beginMkr.Left(offset);
			}
#if defined(_DEBUG)
//			wxLogDebug(_T("GetLastBeginMkr line %d: Returning last(the only) beginMkr= [%s]"), __LINE__, beginMkr.c_str());
#endif
			return beginMkr;
		}
		else
		{
			// offset is wxNOT_FOUND, so no backslash was found - no marker present in mkrs
			return wxEmptyString;
		}
	}
	// whm 6Jul2023 GCC has warning flag that in this function "control reaches end of non-void function" so
	// I'm adding a return wxEmptyString statement here at end of function.
	return wxEmptyString;
}

// BEW 2Aug23 get the priority beginMkr from m_markers, to set the TextType
// BEW 31Aug23, Bill's research indicates that GetLastBeginMkr(wxString mkrs) does not give correct priority
// if the priority is always a \v marker when there are more than one markers in m_markers, eg. for "\\q\n\\v 23"
// Bill says the \q marker should be the one that determines the textType etc. So I'm refactoring this function
// to conform. Priority will be the first, when there are more than one in m_markers.
// whm 2Sep2023 revised. It is not sufficient to get either the first or last begin marker from the incoming
// mkrs string. The "priority" one can occur first or last or in between depending on the marker context.
// The incoming mkrs string could be comething like "\\c 1\r\n\\ms " or "\\q\r\n\\v 23". In the first string
// "\\ms" should be the priority marker for textType "major sect head". In the second string "\\q" should be
// the priority marker for textType "poetry". Hence, The priority one needs to be the one that should set the 
// m_curTextType and m_inform members for the current source phrase, whose marker context is being examined.
// Note: The AnalyzeMarker() function does set 
wxString CAdapt_ItDoc::GetPriorityBeginMkr(wxString mkrs)
{
	if (mkrs.IsEmpty())
	{
		return wxEmptyString;
	}
	// How many markers are there? We can get a count using gSFescapechar in wxString::Replace(), replacing 
	// gSFescapechar with itself.
	wxString beginMkr;
	wxString revMkr;
	wxString backslash = _T("\\");
	wxString firstMkr;

	firstMkr = wxEmptyString; // init
	size_t backslashCount = mkrs.Replace(backslash, backslash); // bReplaceAll is default TRUE
	wxString reversedMkrs = MakeReverse(mkrs);
	int offset = wxNOT_FOUND;
	offset = reversedMkrs.Find(backslash);

	if (backslashCount == 1)
	{
		// There is only one marker, so get it
		revMkr = reversedMkrs.Left(offset + 1); // +1 so as to grab the backslash
		beginMkr = MakeReverse(revMkr);
		return beginMkr;
	}
	if (backslashCount > 1)
	{
		int mkrsLen = mkrs.Length();
		int index;
		wxChar indexedChar;
		for (index = 0; index < mkrsLen; index++)
		{
			indexedChar = mkrs[index].GetValue();
			if (!IsWhiteSpace(&indexedChar))
			{
				firstMkr << indexedChar;
			}
			else
			{
				// once a whitespace char is reached, break from the loop
				break;
			}
		}

		// sanity check
		bool bIsEndMkr = FALSE;

		offset = firstMkr.Find(_T('*'));
		bIsEndMkr = offset >= 0 ? TRUE : FALSE;

		if (!firstMkr.IsEmpty() && firstMkr.GetChar(0) == _T('\\') && !bIsEndMkr)
		{
			// Not empty, and backslash is its first character, and there is no '*' in the marker - 
			// so it's a beginMkr, and is the first marker in mkrs
			return firstMkr;
		}


	} // end of TRUE block for test: if (backslashCount > 1)

	// whm 6Jul2023 GCC has warning flag that in this function "control reaches end of non-void function" so
	// I'm adding a return wxEmptyString statement here at end of function.
	return wxEmptyString;
}

// BEW 5Dec22 I want a quick way, for use in ParseWord() when checking out post-word punctuation,
// to know when pChar is pointing at a beginMarker. And to save a separate call, since I have
// to call GetWholeMarker() internally here, I might as well return it to the caller. It will
// be wxEmptyString if pChar does not point to a marker. If it does point to a marker, find out
// internally if it's and endMkr or not, and return the value in bIsEndMkr
bool CAdapt_ItDoc::IsBeginMarker(wxChar* pChar, wxChar* pEnd, wxString& wholeMarker, bool& bIsEndMkr)
{
	wxChar* ptr = pChar;
	bIsEndMkr = FALSE; // init
	wholeMarker = wxEmptyString; // init
	if (ptr >= pEnd)
	{
		return FALSE;
	}
	if (*ptr != gSFescapechar) // sanity check
	{
		// pAux is not pointing at a marker of any kind
		return FALSE;
	}
	else
	{
		// ptr is pointing at a marker, get it
		wholeMarker = GetWholeMarker(ptr);
		if (wholeMarker == wxEmptyString)
		{
			return FALSE;
		}
		int offset = wxNOT_FOUND; // init
		wxString asterisk = _T("*");
		offset = wholeMarker.Find(asterisk);
		if (offset == wxNOT_FOUND)
		{
			bIsEndMkr = FALSE;
			return TRUE; // it's a beginMkr
		}
		// must have found *, so it's an endmarker
		bIsEndMkr = TRUE;
	}
	return FALSE;
}

wxString CAdapt_ItDoc::MakeWordAndExtras(wxChar* ptr, int itemLen) // BEW added 3May23
{
	if (itemLen == 0)
	{
		return wxEmptyString;
	}
	wxString wordAndExtras;
	wordAndExtras = wxString(ptr, itemLen);
	return wordAndExtras;
}

int CAdapt_ItDoc::ScanToNextMarker(wxChar* pChar, wxChar* pEnd)
{
	wxChar* ptr = pChar;
	if (ptr >= pEnd)
	{
		return 0;
	}
	int count = 0;
	while (ptr < (pEnd - 3)) // -3 because minimal endMkr has at least 3 chars
	{
		if (*ptr == gSFescapechar)
		{
			// The backslash of a marker was matched, get the marker
			wxString wholeMkr = GetWholeMarker(ptr);
			if (wholeMkr != wxEmptyString)
			{
				// so far so far, so good. Our marker needs to be an endMarker
				bool bIsEndMkr = IsEndMarker(ptr, pEnd);
				if (bIsEndMkr)
				{
					// Great, could be something like \w* or another endMkr for something
					// in m_inlineBindingMarkers (see app, 23,856++). We don't actually need
					// to know if it is inLine or not, because this function is called only
					// in order to get the the endMkr which ends a span started by | (bar)
					int mkrLen = wholeMkr.Len();
					count += mkrLen;
					break;
				}
				else
				{
					// Not an endmarker. Unexpected, but we will squirrel away what we've
					// scanned over, and leave off the beginMkr
					return count;
				}
			}
			else
			{
				// No marker can be an empty string, so return 0
				return 0;
			}
		}
		else
		{
			// no marker is at ptr
			count++;
			ptr++;
		}
	} // end of while loop: while (ptr < (pEnd - 2))
	return count;
}

// BEW added 4May23 -- removes m_key, returns the rest - of course, usually 'the rest' is just an empty string
// but when the end puncts and endMkrs are mixed together, it could be a far from empty.
// In version 10, the key string is in pSrcPhrase's m_key, but the caller must supply which string
// is the one to remove the initial key content - as there are 5 possible candidates.
// 
// whm 31Oct2023 modified. This function needs to be smarter and be able to handle the situation
// where the fromThisStr that is coming in from a m_srcSinglePatter that has a marker at the 
// beginning of the string, such as "\\fig At" that will be the case when we're rebuilding the source 
// text at the time a previously unfiltered \fig marker is now being filtered again, and the function
// call FromSingleMakeSstr() calls this GetPostwordExtras() function.
// Before this change the calculation of the key length keyLen assumes that the m_key part of the
// incoming string is at the beginning of the fromThisStr. However, when it consists of "\\fig <m_key>"
// that assumption is NOT correct, hence this function needs to be able to ingnore the marker string
// "\\fig " and determine if there are "extras" in the actual m_key part of the incoming string.
// whm 13Feb2024 This GetPostwordExtras() is no longer used in the refactored FromSingleMakeSstr2() function.
wxString CAdapt_ItDoc::GetPostwordExtras(CSourcePhrase* pSrcPhrase, wxString fromThisStr)
{
	wxString extras = wxEmptyString;
	// sanity test
	if (pSrcPhrase == NULL)
	{
		return extras;
	}
	wxString key = pSrcPhrase->m_key;
	// Empty keys are are not allowed, do sanity test
	if (key.IsEmpty())
	{
		return extras;
	}
	// whm 31Oct2023 here's where the function needs to be smarter and ignore a "\\fig " part
	// of the fromThisStr.
	int keyLen = 0;
	size_t mkrLen = 0;
	if (fromThisStr.Find(gSFescapechar) != wxNOT_FOUND)
	{
		wxString wholeMkr;
		wholeMkr = GetWholeMarker(fromThisStr); // assumed the marker is at beginning of string
		if (!wholeMkr.IsEmpty())
		{
			mkrLen = wholeMkr.Length();
			if (fromThisStr.Length() > mkrLen)
			{
				// check for space following wholeMkr
				if (fromThisStr.GetChar(mkrLen) == _T(' '))
				{
					mkrLen++;
				}
			}
		}
		// if fromThisStr has marker plus any following space, mkrLen is the length of that part
		// and used below to further offset the extraction of any extras. The extras that gets
		// returned when a begin marker is present will be the left over from any actual 
		// punctuation changes made to the m_key member by user.
	}
	// whm 22Jan2024 modified. When a pSrcPhrase was the result of parsing a "(30).>>" value
	// the m_precPunct is "(", the m_srcSinglePattern is "30).>>" and the m_key is "(30)". When
	// this GetPostwordExtras() is called before this modification it would return ">>" leaving
	// out the full stop before the >> chars. I assume the full stop should be included in the
	// extras that are returned, but that is not the case with the pre-modification code. It
	// uses the keyLen of m_key which is 4, and calls fromThisStr.Mid(mkrLen + keyLen) where
	// the fromThisStr is the input string from m_srcSinglePattern which is "30).>>" with the
	// result that extras is ">>" rather than ".>>" It would seem more accurate to either prefix 
	// any m_precPunct value back to the fromThisStr first, then call:
	//    fromThisStr.Mid(mkrLen + keyLen) 
	// or, use the m_srcPhrase value as input to the GetPostWordExtras() function instead of 
	// the m_srcSinglePattern value. If we use the m_srcPhrase value as input, we can then do 
	// a find of the m_key within the m_srcPhrase string to get a index position into 
	// m_srcPhrase, then knowing the length of m_key do a Mid operation to get truly what the 
	// extras are beyond the m_key value. Since the m_precPunct may have some unexpected
	// complications I'm not forseeing, I will try the latter approach using m_srcPhrase rather
	// than the fromThisStr (m_srcSinglePattern) value.
	keyLen = key.Length();
	//extras = fromThisStr.Mid(mkrLen + keyLen); // mkrLen if non-zero skips over marker + space
	int posKeyWord = pSrcPhrase->m_srcPhrase.Find(key);
	extras = pSrcPhrase->m_srcPhrase.Mid(posKeyWord + keyLen);
	return extras;
}

// whm 13Nov2023 added the following function to update the filter status fields in the 
// .usfmstruct file that was created for the newly created document from the input source text
// made just before the TokenizeText() function is called to tokenize the input text and filter
// any markers designated to be filtered by the settings in the USFM and Filtering tab of
// Preferences.
// The following function uses the gCurrentFilterMarkers string to add or update the last colon
// delimited field in the .sfmstruct file, making the field ":1" if the marker is present in the
// App's gCurrentFilterMarkers, or making it ":0" if the marker is NOT present in 
// gCurrentFilterMarkers. It also updates the m_UsfmStructArr string elements with the same filter
// status data, so that the in-memory array is immediately accessible with the current filter
// status of all markers making up the document.
// Note: The SetupUsfmStructArrayAndFile() should be called BEFORE the call to TokenizeText[String]()
// and this UpdateCurrentFilterStatusOfUsfmStructFileAndArray() should be called AFTER the call to
// TokenizeText[String](), and after any filtering changes have been processed within the 
// ReconstituteAfterFilteringChange() function.
void CAdapt_ItDoc::UpdateCurrentFilterStatusOfUsfmStructFileAndArray(wxString usfmStructFileNameAndPath)
{
	// The incoming parameter has the full path to the usfm struct file that we will update.
	// Open the file as a wxTextFile
	wxTextFile file(usfmStructFileNameAndPath);
	bool bOK;
	bOK = file.Open();
	if (!bOK)
	{
		wxString msg = _T("Could NOT OPEN input path / name at : % s");
		msg = msg.Format(msg, usfmStructFileNameAndPath.c_str());
		gpApp->LogUserAction(msg);
	}
	else
	{
		// Read each line in the file and add/update the filter status according to whether
		// the marker at the beginning of the line is within the App's gCurrentFilterMarkers
		// using ":1" if the marker is present, ":0" if not present.
		int ct;
		wxString lineStr;
		wxString newLineStr;
		wxString mkr;
		wxString colon = _T(":");
		wxString space = _T(" ");
		wxString strUpToFirstColon = wxEmptyString;
		wxString strAfterFirstColon = wxEmptyString;
		wxString strBetweenFirstAndSecondColons = wxEmptyString;
		wxString strAfterSecondColon = wxEmptyString;
		int nLines = file.GetLineCount();
		// Empth the m_UsfmStructArr array, and reload it with the updated filter status
		// information
		m_UsfmStructArr.Clear();
		for (ct = 0; ct < nLines; ct++)
		{
			lineStr = file.GetLine(ct);
			// Each line in the usfm struct file starts with a marker, and each marker is
			// followed by either a space or a colon, for example, a usfm struct file BEFORE
			// it gets any filter status field might look like this:
			// \c 10:0
			// \v 52:155
			// \c 11:0
			// \ms:47
			// \mr:13
			// \s:32
			// \r:43
			// \p:0
			// \v 1:127
			// After the update is done below each line will have a filter status field by
			// adding a second colon ':' followed by a "0" or "1" to indicate the marker's
			// current filter status.
			// If the usfm struct file was previously updated, the file would already have
			// the filter status fields, and the current update will not add another colon
			// field, but will simply update the existing "0" or "1" to reflect the current
			// status of the marker according to its presence in gCurrentFilteredMarkers.
			if (!lineStr.IsEmpty())
			{
				// Extract the marker at the beginning of the lineStr which exists before the 
				// first colon.
				int posColon = lineStr.Find(colon);
				wxASSERT(posColon != wxNOT_FOUND);
				if (posColon != wxNOT_FOUND)
				{
					mkr = lineStr.Mid(0, posColon);
					strUpToFirstColon = lineStr.Mid(0, posColon);
					strAfterFirstColon = lineStr.Mid(posColon+1);
					// The mkr may be a chapter or verse marker that would be followed by a space 
					// and a number, so remove any space and number to have a whole marker
					int posSpace = mkr.Find(space);
					if (posSpace != wxNOT_FOUND)
					{
						mkr = mkr.Mid(0, posSpace);
						mkr.Trim(TRUE);
						mkr.Trim(FALSE); // mkr is now a whole marker, minus any extraneous whitespace
					}
					// Is the mkr present in gCurrentFilteredMarkers? 
					// each marker in gCurrentFilteredMarkers is followed by a space delimiter
					// so make sure we call Find() looking for a space augmented marker.
					wxString augmentedMkr = mkr + space;
					bool bMkrIsFiltered;
					if (gpApp->gCurrentFilterMarkers.Find(augmentedMkr) >= 0)
					{
						bMkrIsFiltered = TRUE;
					}
					else
					{
						bMkrIsFiltered = FALSE;
						// The filter status is 0, add/update the lineStr accordingly
					}

					int posSecondColon = strAfterFirstColon.Find(colon);
					if (bMkrIsFiltered)
					{
						// The filter status is 1, add/update the lineStr accordingly
						// If there is a second colon in strAfterFirstColon, the lineStr
						// already has a filter status field.
						if (posSecondColon != wxNOT_FOUND)
						{
							// A filter status field exists, so update its field to "1"
							strBetweenFirstAndSecondColons = strAfterFirstColon.Mid(0, posSecondColon);
							strAfterSecondColon = strAfterFirstColon.Mid(posSecondColon+1);
							newLineStr = strUpToFirstColon + colon + strBetweenFirstAndSecondColons + colon + _T("1");
						}
						else
						{
							// A filter status field doesn't exist, so add one as ":1"
							newLineStr = strUpToFirstColon + colon + strAfterFirstColon + _T(":1");
						}
					}
					else
					{
						// The filter status is "0", add/update the lineStr accordingly
						// If there is a second colon in strAfterFirstColon, the lineStr
						// already has a filter status field.
						if (posSecondColon != wxNOT_FOUND)
						{
							// A filter status field exists, so update its field to "0"
							strBetweenFirstAndSecondColons = strAfterFirstColon.Mid(0, posSecondColon);
							strAfterSecondColon = strAfterFirstColon.Mid(posSecondColon+1);
							newLineStr = strUpToFirstColon + colon + strBetweenFirstAndSecondColons + colon + _T("0");
						}
						else
						{
							// A filter status field doesn't exist, so add one as ":0"
							newLineStr = strUpToFirstColon + colon + strAfterFirstColon + _T(":0");
						}

					} // end of if (posColon != wxNOT_FOUND)
					// Update the lineStr in the file. In a wxTextFile we remove the old line and 
					// insert the new/edited line at the same location we deleted the old line.
					file.RemoveLine(ct);
					file.InsertLine(newLineStr, ct);
					// While we're at it, update the m_UsfmStructArr by adding newLineStr to it
					m_UsfmStructArr.Add(newLineStr);
				} // end of if (posColon != wxNOT_FOUND)
			} // end of if (!lineStr.IsEmpty())
		}  // end of for (ct = 0; ct < nLines; ct++)

		// write changes back to the file.
		file.Write();
	} // end of else block of if (!bOK)
}

// This function takes an existing string filterStr of filtered material and if there are
// multiple filtered markers in filterStr, it checks the ordering of the markers against
// the first set of markers encountered following the ChVs context of the m_UsfmStrucArr array.
// Each filtered element within the filterStr may have one or more markers and/or EOL chars 
// prefixing it as in the following example (one continuous string spread over 4 lines below
// for clarity):
// filterStr == "
// \\~FILTER \\ms Jises, iy are lau handru?\\~FILTER*
// \\~FILTER \\mr (Kalan 11:1-16:20)\\~FILTER*
// \\c 11 \\~FILTER \\s Jon ta alomwa suni oro lau tan ala atou Jises\\~FILTER*
// \\~FILTER \\r (Luk 7:18-35)\\~FILTER*"
// in which the "\\c 11" chapter marker was swept up in the filtering process of the "\\s ..."
// marker when \s was filtered in ReconstituteAfterFilteringChange() function.
// Any such swept up marker should always remain associated with and prefixed to the following
// filtered marker during its storage in m_filteredInfo and when the marker (\s in this case)
// and associated text are unfiltered. Hence, in the above case, the \c 11 marker should be
// unfiltered along with the \s marker when it is unfiltered, both in 
// ReconstituteAfterFilteringChange() and when rebuilding the source text. This ensures that
// a correct ordering is kept for these swept up markers when they are unfiltered.
// 
// This function reorders the marker material within filterStr if necessary to make the 
// filtered material ordering conform with the ordering of the corresponding markers within 
// the m_UsfmStructArr array. The ChVs input parameter simply allows the comparison of markers 
// to begin at the chapter and verse where the marker being filtered/unfiltered is located.
// This function does the following:
// 1. To narrow down its search, it first locates the chapter:verse reference using
//    the context indicated by the ChVs incoming parameter. This is necessary since
//    it would be likely that other sequences of filtered markers occur in other parts
//    of the text.
// 2. Once the context is located within the array, this function starts comparing the
//    markers in the m_UsfmStructArr array with the markers in the filterStr, noting
//    the position of identical markers within the filterStr, until all markers in the
//    filterStr have been found and their relative positions determined. 
// 3. If the positions are sequential, no reordering is needed and the incoming filterStr
//    is simply returned unchanged to the caller.
// 4. If one or more filtered markers are out of order, as compared to their occurring
//    sequence within the m_UsfmStructArr array, the filtered marker strings are reordered 
//    to the order needed to conform to the markers in the m_UsfmStructArr array, i.e., the
//    order the markers were in the original input text when the document was first created.
// 5. The parts of the filtered strings (and any swept up markers preceding them) are 
//    separated into 3 parallel wxArrayString arrays: markersPrecedingFilteredOnes,
//    filteredMkrsArrayWithFilterBrackets and filteredMkrsArray. These arrays should always
//    have the same number of elements even though the markersPredcedingFilteredOnes is likely 
//    to have most if not all of its array string elements be empty strings (it will only 
//    have a non-empty string element when the filtered string has a swept up marker such as
//    a \c n marker and/or other markers that immediately preceded the filtered marker that
//    follows it.
// 6. A check is made to see if the filterabelMkrsArray elements are in the same sequential
//    order as the markers in the same part of the usfmstruct file. If the ordering is out-of
//    order, then reordering is required, otherwise the function simply returns the filterStr
//    unchanged.
// 7. When reordering is required, it is done by prefixing to the first two parallel arrays'
//    items a zero padded index number (6-digit field) representing index location line 
//    number, as found in the original m_UsfmStructArr array, prefixing it to the item in the 
//    filteredMkrsArrayWithFilterBrackets array, and the markersPrecedingFilteredOnes array,
//    and then sorting the array using the wxArrayString::Sort() method. 
// 8. Once the two parallel arrays have been sorted into ascending order the zero padded index 
//    number is removed from the items in the filteredMkrsArrayWithFilterBrackets and 
//    array, and the markersPrecedingFilteredOnes array, and newOrderedStr is returned to the
//    caller having the reordered filtered elements (including their preceding swept up markers).
// This function is called in two locations within the ReconstituteAfterFilteringChange() function.
// whm 8Feb2024 revised to ensure that this function works OK when filterStr contains filtered
// material that may have one or more swept up markers preceding a \~FILTER ...\~FILTER* element.
wxString CAdapt_ItDoc::ReorderFilterMaterialUsingUsfmStructData(wxString filterStr, wxString ChVs, wxArrayString m_UsfmStructArr)
{
	wxString newOrderedStr;
	newOrderedStr.Empty();
	wxString ch, vs;
	// Parse the ch and vs from the incoming ChVs parameter value
	bool bNeededReordering = FALSE;
	bool bNoColonInRef = FALSE;
	bNoColonInRef = bNoColonInRef; // avoid gcc warning set but not used warning
	wxString colon = _T(":");
	if (!ChVs.IsEmpty())
	{
		int posColon = ChVs.Find(colon);
		if (posColon != wxNOT_FOUND)
		{
			ch = ChVs.Mid(0, posColon);
			vs = ChVs.Mid(posColon + 1);
		}
		else
		{
			// There is no colon in ch:vs so assume its just a ch number
			bNoColonInRef = TRUE;
			ch = ChVs;
		}
	}
	int totStructArrLines = 0;
	totStructArrLines = (int)m_UsfmStructArr.GetCount();
	wxString arrLine;
	wxString marker;
	wxString numChars;
	wxString filterStatus;
	int lineIndex = 0;
	wxString chapter = _T("\\c ") + ch;
	wxString verse = _T("\\v ") + vs;
	// Scan the m_UsfmStructArr array to find the ch:vs reference specified in the incoming parameter ChVs
	bool bRefFound = FALSE;
	bool bMkrFound = FALSE;
	bool bChFound = FALSE;
	bool bVsFound = FALSE;
	while (lineIndex < totStructArrLines && !bRefFound)
	{
		arrLine = m_UsfmStructArr.Item(lineIndex);
		ParseUsfmStructLine(arrLine, marker, numChars, filterStatus);
		if (marker.Find(chapter) != wxNOT_FOUND)
		{
			bChFound = TRUE;
		}
		if (bChFound && marker.Find(verse) != wxNOT_FOUND)
		{
			bVsFound = TRUE;
		}
		if (bChFound && bVsFound)
		{
			bRefFound = TRUE;
		}
		lineIndex++;
	}
	// whm 12Feb2024 added the following after noticing that markers at the beginning of
	// the first chapter line including \ms \mr and \s when all filtered, were not being
	// reordered. The reason was that ChVs was "0:0" which set bRefFound to FALSE and had
	// the lineIndex at the end of the file. The solution is when incoming ChVs is "0:0"
	// we unilaterally set bRefFound to TRUE and set the lineIndex to a value near the
	// beginning of the file - at lineIndex 1 just past the \id line.
	if (ChVs == _T("0:0"))
	{
		// We haven't seen a \c or \v marker yet and so ChVe is "0:0"
		bRefFound = TRUE;
		lineIndex = 1; // Start the scan at line 1 (just past any \id line)

	}
	// We expect that the m_UsfmStructArr array would contain both a chapter and a verse 
	// reference, or at least a chapter marker.
	if (bRefFound || (!bRefFound && bChFound))
	{
		// Get the markers from filterStr. 
		wxArrayString markersPrecedingFilteredOnes;
		markersPrecedingFilteredOnes.Clear();
		wxArrayString filteredMkrsArray;
		filteredMkrsArray.Clear();
		wxArrayString filteredMkrsArrayWithFilterBrackets;
		filteredMkrsArrayWithFilterBrackets.Clear();
		wxArrayInt IndexPosOfMkrInStructArr;
		IndexPosOfMkrInStructArr.Clear();
		// The GetFilteredAndSweptUpMarkersFromString() function creates two arrays, one with the filtered indicating
		// bracketed markers \~FILTER ... \~FILTER* called filteredMkrsArrayWithFilterBrackets, and the
		// other parallel array filteredMkrsArray which only contains the whole markers.
		// Here the two arrays should always be in parallet, with the same number of items, and the items
		// in the same order, the order they were found in the incoming filterStr.
		GetFilteredAndSweptUpMarkersFromString(filterStr, 
			markersPrecedingFilteredOnes, // this array contains swept up markers that order before the filteredMkrsArrayWithFilterBrackets
			filteredMkrsArrayWithFilterBrackets, 
			filteredMkrsArray);
		// Continue scanning from lineIndex position determined above, down through the m_UsfmStructArr 
		// array, checking successive m_UsfmStructArr's array markers for their existence in filterStr. 
		// When the marker is found in m_UsfmStructArr at a particular index position, record that index 
		// position position in the IndexPosOfMkrInStructArr array, and change the index position value
		// to a string number padded with up to 6 prefixed zeros using wxString::Format(), and prefix 
		// this zero-padded string number to the corresponding filteredMkrsArrayWithFilterBrackets array 
		// for subsequent sorting of the array of \~FILTER ... \~FILTER* elements using the built-in 
		// wxStringArray::Sort() command. 
		size_t countFilteredMkrsArray = filteredMkrsArray.GetCount();
		if (countFilteredMkrsArray > 0)
		{
			for (int i = 0; i < (int)countFilteredMkrsArray; i++)
			{
				wxString mkr = filteredMkrsArray.Item(i);
				mkr.Trim(TRUE);
				mkr.Trim(FALSE);
				bMkrFound = FALSE;
				int offset = mkr.Find(_T(" "));
				if (offset > 0)
				{
					// There is a space within the marker string which indicates the marker is followed
					// by its associated text - as would be the case for markers taken from a filtered
					// string enclosed by \~FILTER ... \~FILTER* markers - , so remove the associated 
					// text, leaving only the marker.
					mkr = mkr.Mid(0, offset);
					mkr.Trim();
				}
				// Now, scan from the lineIndex starting position, down thru the m_UsfmStructArr array 
				// until the marker is found, recording its found index position in the IndexPosOfMkrInArr 
				// array. We want to scan from the same starting position when searching for each successive 
				// marker, to use a local tempLineIndex to avoid changing the starting position lineIndex.
				int tempLineIndex = lineIndex;
				wxString tempArrayLine;
				wxString tempMarker;
				wxString delimMkr;
				delimMkr = mkr + _T(":");
				while (!bMkrFound && tempLineIndex < totStructArrLines)
				{
					tempArrayLine = m_UsfmStructArr.Item(tempLineIndex);
					int posdelMkr = tempArrayLine.Find(delimMkr);
					if (posdelMkr != wxNOT_FOUND)
					{

						IndexPosOfMkrInStructArr.Add(tempLineIndex);
						wxString paddedBracketMkr;
						paddedBracketMkr = filteredMkrsArrayWithFilterBrackets.Item(i);
						wxString paddedPrecOnes;
						paddedPrecOnes = markersPrecedingFilteredOnes.Item(i);
						wxString padding = wxString::Format("%06d", tempLineIndex);
						// Prefix the padding to the parallel arrays' items
						paddedBracketMkr = padding + paddedBracketMkr;
						paddedPrecOnes = padding + paddedPrecOnes;
#if defined(_DEBUG)
						wxLogDebug(_T("Mkr index: %d padded value = %s paddedBracketMkr = %s"), tempLineIndex, padding.c_str(), paddedBracketMkr.c_str());
#endif
						// Replace the item in the parallel arrays with its padded counterpart
						filteredMkrsArrayWithFilterBrackets.RemoveAt(i);
						filteredMkrsArrayWithFilterBrackets.Insert(paddedBracketMkr, i);
						markersPrecedingFilteredOnes.RemoveAt(i);
						markersPrecedingFilteredOnes.Insert(paddedPrecOnes, i);

						bMkrFound = TRUE;
					}
					tempLineIndex++;
				}
			}
			// whm 3Feb2024 modification/addition. Need a sanity check here. While filtering a \fig marker
			// after having un-filtered it, I got a crash due to IndexPosOfMkrInStructArr.Item(i) below
			// being "out of range", i.e., the number of items in the array was 1 but the 
			// countFilteredMkrsArray in the for loop below was 2. The number of items in the 
			// IndexPosOfMkrInStructArray should always be the same as set in the while block above. 
			// However, to avoid an out of bounds error, we should check if the number of items in the 
			// array countIndexPosOfMkrInStructArr is equal to the countFilteredMkrsArray value; if not 
			// we will set the bNeededReordering flag to FALSE and log the situation to flag to the 
			// programmer that womething went wrong.
			size_t countIndexPosOfMkrInStructArr = IndexPosOfMkrInStructArr.GetCount();
			if (countIndexPosOfMkrInStructArr != countFilteredMkrsArray)
			{
				// Soomething went wrong above. We need to bail out of the function without attempting to
				// reorder the markers.
				wxString msg = _T("***ARRAY INDEX OUT OF RANGE: In ReorderFilterMaterialUsingUsfmStructData().\n   The countIndexPosOfMkrInStructArr was %d but the countFilteredMkrsArray was %d\n   filterStr was: %s\n***Unable to Reorder filter markers!");
				msg = msg.Format(msg, countIndexPosOfMkrInStructArr, countFilteredMkrsArray, filterStr.c_str());
				wxLogDebug(msg);
				gpApp->LogUserAction(msg);
				return filterStr;
			}
			// Check whether the position values in the IndexPosOfMkrInArr are in sequential order or not.
			// If they are in sequential order we don't need to do any reordering and can set bNeededReordering
			// to FALSE - returning the original filterStr unchanged.
			// If the position values are not in sequential order, we need to reorder the filtered material 
			// in filterStr to agree with the ordering of the markers in the m_UsfmStructArr array.
			int nLastPosValue = -1;
			int nCurrPosValue = 0;
			for (int i = 0; i < (int)countFilteredMkrsArray; i++)
			{
				nCurrPosValue = IndexPosOfMkrInStructArr.Item(i);
				if (nCurrPosValue < nLastPosValue)
				{
					bNeededReordering = TRUE;
					break;
				}
				nLastPosValue = nCurrPosValue;
			}
			if (bNeededReordering)
			{
				wxLogDebug(_T("Filter string needs reordering!"));
				// Sort the filteredMkrsArrayWithFilterBrackets and markersPrecedingFilteredOnes arrays. 
				// The Sort commend sorts to the correct ordering due to the prefixed number index string 
				// padded with leading zeros. The order after sorting represents their index order within 
				// the larger m_UsfmStructArr array.
				filteredMkrsArrayWithFilterBrackets.Sort();
				markersPrecedingFilteredOnes.Sort();
				
#if defined(_DEBUG)
				wxString filterItem;
				wxString precMkrItem;
				for (int i = 0; i < (int)countFilteredMkrsArray; i++)
				{
					filterItem = filteredMkrsArrayWithFilterBrackets.Item(i);
					precMkrItem = markersPrecedingFilteredOnes.Item(i);
					wxLogDebug(_T("filterItem %d is: %s precMkrItem is: %s"), i, filterItem.c_str(), precMkrItem.c_str());
				}
#endif
				// Finally, remove the zero-padded prefix on the bracketed filtered items
				// and create the newOrderedStr
				for (int i = 0; i < (int)countFilteredMkrsArray; i++)
				{
					wxString paddedBracketMkr;
					paddedBracketMkr = filteredMkrsArrayWithFilterBrackets.Item(i);
					wxString paddedPrecMkr;
					paddedPrecMkr = markersPrecedingFilteredOnes.Item(i);
					wxString unPaddedStr = paddedBracketMkr.Mid(6);
					wxString unPaddedMkrStr = paddedPrecMkr.Mid(6);
#if defined(_DEBUG)
					wxLogDebug(_T("unPaddedStr = %s"), unPaddedStr.c_str());
#endif
					filteredMkrsArrayWithFilterBrackets.RemoveAt(i);
					filteredMkrsArrayWithFilterBrackets.Insert(unPaddedStr, i);
					markersPrecedingFilteredOnes.RemoveAt(i);
					markersPrecedingFilteredOnes.Insert(unPaddedMkrStr, i);

					newOrderedStr  = newOrderedStr + unPaddedMkrStr + unPaddedStr;
				}
			}
			else
			{
				wxLogDebug(_T("Filter string does NOT need reordering!"));
			}
		}
	}
	if (bNeededReordering)
		return newOrderedStr;
	else
		return filterStr;
}

int CAdapt_ItDoc::GetLowestIntInArrayAboveThisValue(wxArrayInt arrInt, int aboveThisValue)
{
	int lowestIntValue = 2147483647;
	int totItems = arrInt.GetCount();
	if (totItems == 0)
		return 0;
	for (int i = 0; i < totItems; i++)
	{
		if (arrInt.Item(i) > aboveThisValue && arrInt.Item(i) < lowestIntValue)
		{
			lowestIntValue = arrInt.Item(i);
		}
	}
	return lowestIntValue;
}

// whm 6Jan2024 added.
// whm 6Jan2024 Testing shows that doing an augment operation += as follows:
//	pSrcPhrase->m_markers += tokBuffer in various places in TokenizeText()
// sometimes results
// in a marker getting duplicated within m_markers.
// To eliminate any such duplication including any duplication of whitespace
// I've written a new function RemoveDuplicateMarkersFromMkrString() that will 
// remove any duplicate markers found in m_markers. If the first marker in 
// m_markers has following whitespace, and any following duplicate marker also 
// has the same whitespace, the whitespace of the duplicate is also removed. 
// If the initial marker has no following whitespace, but a duplicate marker 
// does have some following whitespace, only the duplicate marker is
// removed - leaving its white space. However, if leaving the duplicate marker's
// whitespace leaves doubled CRLFCRLF EOL sequence or doubled space "  " in
// m_markers, then the doubled EOL and doubled spaces are changed to single
// instances in m_markers. 
wxString CAdapt_ItDoc::RemoveDuplicateMarkersFromMkrString(wxString markerStr)
{
	if (markerStr.IsEmpty())
		return markerStr;

	wxString mkrStr = markerStr;
	int lineCount;
	wxString tempStr;
	tempStr.Empty();
	wxArrayString MarkersList;
	wxArrayString NewMarkersListNoDups;
	MarkersList.Clear();
	int mkrPos = (int)mkrStr.Find(gSFescapechar);
	if (mkrPos == wxNOT_FOUND)
	{
		// The m_markers has content, but there are no markers in it. This would 
		// be an error, so the best we can do is to just return the string and
		// let the caller deal with it.
		return mkrStr;
	}
	else
	{
		// The mkrStr has markers, so accumulate them along with their following whitespace
		// into an array MarkersList.
		GetMarkersAndFollowingWhiteSpaceFromString(MarkersList, mkrStr);
		lineCount = (int)MarkersList.GetCount();
		// Now copy each element from MarkersList that doesn't already exist in the
		// NewMarkersListNoDups array
		for (int i = 0; i < lineCount; i++)
		{
			wxString itemStr = MarkersList.Item(i);
			wxString itemStrNoWS = itemStr;
			itemStrNoWS.Trim(TRUE); // TRUE - trim following whitespace
			bool bItemStrHasWhiteSp = FALSE;
			bool bDupItemHasWhiteSp = FALSE;
			if (itemStr != itemStrNoWS)
				bItemStrHasWhiteSp = TRUE;
			int newListTot = (int)NewMarkersListNoDups.GetCount();
			bool bItemFound = FALSE;
			wxString dupesWhiteSp;
			dupesWhiteSp.Empty();
			for (int j = 0; j < newListTot; j++)
			{
				// Compare the markers without following whitespace
				wxString newItemStr = NewMarkersListNoDups.Item(j);
				wxString newItemStrNoWS = newItemStr; 
				newItemStrNoWS.Trim(TRUE); // TRUE - trim followin whitespace
				if (newItemStrNoWS == itemStrNoWS)
				{
					// The original marker (minus following whitespace) is already in 
					// NewMarkersListNoDups, so set bItemFound to TRUE
					bItemFound = TRUE;
					// Did the marker item in the new array have following whitespace?
					if (newItemStr != newItemStrNoWS)
					{
						bDupItemHasWhiteSp = TRUE;
						int lenDupItemNoWS = newItemStrNoWS.Length();
						dupesWhiteSp = newItemStr.Mid(lenDupItemNoWS);
					}
				}
			}
			if (!bItemFound)
			{
				// Add itemStr to the NewMarkersListNoDups array
				// If itemStr has no whitespace, but duplicate item did have whitespace
				// we probably should suffix the original marker itemStr with the same
				if (!bItemStrHasWhiteSp && bDupItemHasWhiteSp)
					NewMarkersListNoDups.Add(itemStr + dupesWhiteSp);
				else
					NewMarkersListNoDups.Add(itemStr);
			}
		}
	}
	// Recreate the mkrStr from what is now in the NewMarkersList array
	lineCount = (int)NewMarkersListNoDups.GetCount();
	for (int i = 0; i < lineCount; i++)
	{
		tempStr += NewMarkersListNoDups.Item(i);
	}

	// Now remove any doubled white spaces
	tempStr.Replace(_T("\r\n\r\n"), _T("\r\n"), TRUE); // TRUE - replace all EOL duplicates
	tempStr.Replace(_T("  "), _T(" "), TRUE); // TRUE - replace all space duplicates

	if (!tempStr.IsEmpty())
		return tempStr;
	else
		return mkrStr;
}

wxString CAdapt_ItDoc::RemoveEndMkrsFromExtras(wxString extras) // BEW added 4May23
{
	if (extras.IsEmpty())
	{
		return extras; // empty string
	}
#if defined (_DEBUG) && !defined(NOLOGS)
	if (!extras.IsEmpty())
	{
		int halt_here = 1; wxUnusedVar(halt_here); // avoid warning variable initialized but not referenced
	}
#endif
	// Search for each gSFescapechar, and each marker will end in '*', trash the substrings so delineated
	// and return what's left. There may be no punctuation characters, so it's quite possible that the
	// empty string will be what gets returned.
	wxString str = extras;
	wxString accum = wxEmptyString; // accumute puncts in here
	wxString remainder = wxEmptyString; // what's left after each iteration of the loop
	wxString backslash = gSFescapechar;
	wxString asterisk = _T("*"); // USFM assumed
	int offset = wxNOT_FOUND; // -1
	int starOffset = wxNOT_FOUND;
	int mkrLen = 0; // init
	offset = str.Find(backslash); 
	while (offset != wxNOT_FOUND)
	{
		// Find where the asterisk is
		starOffset = str.Find(asterisk);
		wxASSERT(starOffset > offset);
		mkrLen = starOffset - offset + 1; // +1 because we want to point past the '*'
		str = str.Remove(offset, mkrLen);
		// str is now shorter, for another iteration we must test str for another backslash
		offset = str.Find(backslash);
		starOffset = wxNOT_FOUND;
	}
	// All endMkrs are now removed, str is now whatever is left over - which would be nothing if
	// there were no punctuation characters in str, otherwise, its a string of one or more puncts only
	return str;
}

// BEW added 4May23 'Q' in the name means "Query". Check that each of the final puncts in extras wxString
// are all present, or distributed between, m_follPunct and m_follOuterPunct members of pSrcPhrase. No
// residue means, not one or more unmatched - either in extras, or in the punct locations. Return TRUE
// if the matchups succeed, otherwise FALSE. If FALSE is returned, a more clever matching function will need
// to be used. If TRUE is returned, then extras qualifies as the correct post-word punctuation & markers mix.
// Note: extras must be obtained by a prior call of GetPostwordExtras(CSourcePhrase* pSrcPhrase, wxString fromThisStr);
// and extras may contain endmarkers in their proper places. To make the matchup testing work, need a further 
// function to remove any endmarkers present in the extras string, to be called prior to this one. Return extrasLen
// to the caller, so that a FALSE value returned can be interpretted correctly: if extrasLen is greater than 0,
// then the puncts matchups left a residue unmatched. Of course returning TRUE means no residue unmatched, so
// make sure the interpretation is correct by asserting that extrasLen is greater than zero.
// BEW 8May23 added bEndPunctsModified, for when the user edits punct, or does so in PT source project of 
// collaboration; because a more clever function needs to work out what the final puncts & markers mix should be
bool CAdapt_ItDoc::Qm_srcPhrasePunctsPresentAndNoResidue(CSourcePhrase* pSrcPhrase, wxString extras, int& extrasLen, 
		wxString& residue, bool& bEndPunctsModified)
{
	// The callers at higher levels will have used spacelessPuncts to determine what to store as punctuation
	// characters, so we don't here need to check that what we are dealing with are indeed punctuation chars
	residue = wxEmptyString; // init
	//wxString saveExtras = extras;
	//wxString save_m_srcPhrase = pSrcPhrase->m_srcPhrase;
	//endMkrsOnly = wxEmptyString; // init
	wxString threeWedgesAndSpace = _T(">> >"); // This sequence occurs in Nyindrou Matthew source text, support it
	// ====== more possibilities, from Nyindrou John's gospel - it's easier to handle these a substrings
	wxString threeWedges_singleFirst = _T("> >>"); // many instances
	wxString twoWedges_afterEndMkr = _T(" >>"); // likely after \f* for instance
	wxString afterNestedQuotes = _T(">> > >>"); // only once in John, at 19:20
	// ===== end of more possibilities

	wxString twoWedges = _T(">>"); // ending puncts which are not single characters need to be checked first
	bEndPunctsModified = FALSE; // init
	wxASSERT(pSrcPhrase != NULL);
#if defined (_DEBUG) //&& !defined(NOLOGS)
	//wxLogDebug(_T("%s() line %d , Starting... sequNum = %d , extras=[%s] , pSrcPhrase m_srcPhrase=[%s]"),
	//	__FUNCTION__, __LINE__, pSrcPhrase->m_nSequNumber , extras.c_str(), pSrcPhrase->m_srcPhrase.c_str());
	if (pSrcPhrase->m_nSequNumber >= 267)
	{
		int halt_here = 1; wxUnusedVar(halt_here); // avoid warning variable initialized but not referenced
	}
#endif
	if (extras.IsEmpty())
	{
		// The test above will have extras with all end markers removed, but if there's no puncts, 
		// m_srcSinglePattern will contain just the endmarkers - so won't be empty. When this is the
		// case we need to flag the caller to the fact. Do that by getting the length of the markers, and
		// returning that value in extrasLen
		residue = wxEmptyString;
		extrasLen = 0;
		return TRUE; // m_srcSinglePattern is correct 'as is'
	}
	else
	{
		// extras has one or more puncts -- and all markers removed, provided RemoveEndMkrsFromExtras(wxString extras) was
		// called before calling this Qm_srcPhrasePunctsPresentAndNoResidue() function. Now attend to the task of trying
		// for a no-residue matching of the puncts in extras string, with what pSrcPhrase stores in m_follPunct and
		// also in m_follOuterPunct. Beware, there could be one or more spaces mixed in too.
		// Merge the two punct locations into one string
		wxString allPuncts = pSrcPhrase->m_follPunct;
		allPuncts += pSrcPhrase->GetFollowingOuterPunct();
		// Trim both ends, to keep things simple as possible; but any internal spaces we'll skip over if we encounter
		// any when looping
		allPuncts.Trim(); // RHS
		allPuncts.Trim(FALSE); // LHS

		// whm 22Jan2024 modification. When rebuilding a source text in which a pSrcPhrase has the following member
		// contents after having parsed the sequence "(30).>>" the pSrcPhrase members on note are:
		//   m_key: "(30)"
		//   m_srcPhrase: "(30).>>"
		//   m_precPunct: "("
		//   m_follPunct: ".>>"
		//   m_follOuterPunct: "" [empty]
		//   m_srcSinglePattern: "30).>>"
		//   m_oldKey: "(30)"
		// Testing shows that the current "dumb" version of Qm_srcPhrasePunctsPresentAndNoResidue() is not able to
		// handle the above scenario that were we might have "(somenumber).>>"
		// It would seem to me that we could check the conditions mentioned in the purpose of this more directly
		// and return TRUE for such situations where m_follOuterPunct is empty and the m_follPunct does match the
		// incoming extras string. Hence, I will here implement that shortcut:
		if (allPuncts == extras)
		{
			residue.Empty();
			bEndPunctsModified = FALSE; // remains FALSE
			extrasLen = 0; 
			return TRUE;
		}

		wxString strExtras = extras;
		int offset = wxNOT_FOUND; // -1
		int allOffset = wxNOT_FOUND; // -1   for searching in allPuncts string
		int strExtrasLen = strExtras.Length();
		int allPunctsLen = allPuncts.Length(); // can't be guaranteed that these two lengths are equal
		allPunctsLen = allPunctsLen; // avoid gcc warning set but not used warning

		// Bleed out ending puncts which are not a single character; >> is the only such in our default puncts set;
		// BEW 13Jul23, however, there are rare longer substrings which must be checked for first, ">> >" etc -- see above
		// longest first... Since there are 5 possibilities, rather than nested if/else calls, I'll give each
		// possibility a const int value, and process with a switch
		const int nNoMatch = 0;
		const int nTwoWedges = 1;
		const int nTwoWedges_afterEndMkr = 2;
		const int nThreeWedgesAndSpace = 3;
		const int nThreeWedges_singleFirst = 4;
		const int nAfterNestedQuotes = 5;
		int nValue = -1; // init

		// whm 1Oct2023 modified. It's not kosher to have an assignement within 
		// the conditional expressions as was done in the orginal coding.
		// Doing so is flagged with a warning by the VS and Gcc compilers.
		// So I've modified the tests below to put the offset calc within 
		// the test TRUE blocks rather than within the conditional expressions.
		/*
		offset = strExtras.Find(afterNestedQuotes);
		if (offset >= 0)
		{
			// _T(">> > >>") was found in strExtras
			nValue = 5;
		}
		else if ( (offset = strExtras.Find(threeWedges_singleFirst) >= 0) )
		{
			// _T("> >>") was found in strExtras
			nValue = 4;
		}
		else if ((offset = strExtras.Find(threeWedgesAndSpace) >= 0) )
		{
			// _T(">> >") was found in strExtras
			nValue = 3;
		}
		else if ((offset = strExtras.Find(twoWedges_afterEndMkr) >= 0) )
		{
			// _T(" >>") was found in strExtras
			nValue = 2;
		}
		else if ((offset = strExtras.Find(twoWedges) >= 0))
		{
			// _T(">>") was found in strExtras
			nValue = 1;
		}
		else
		{
			nValue = 0; // noMatch case, ">>" is not in strExtras
		}
		*/

		if (strExtras.Find(afterNestedQuotes) != wxNOT_FOUND)
		{
			offset = strExtras.Find(afterNestedQuotes);
			// _T(">> > >>") was found in strExtras
			nValue = 5;
		}
		else if (strExtras.Find(threeWedges_singleFirst) != wxNOT_FOUND)
		{
			offset = strExtras.Find(threeWedges_singleFirst);
			// _T("> >>") was found in strExtras
			nValue = 4;
		}
		else if (strExtras.Find(threeWedgesAndSpace) != wxNOT_FOUND)
		{
			offset = strExtras.Find(threeWedgesAndSpace);
			// _T(">> >") was found in strExtras
			nValue = 3;
		}
		else if (strExtras.Find(twoWedges_afterEndMkr) != wxNOT_FOUND)
		{
			offset = strExtras.Find(twoWedges_afterEndMkr);
			// _T(" >>") was found in strExtras
			nValue = 2;
		}
		else if (strExtras.Find(twoWedges) != wxNOT_FOUND)
		{
			offset = strExtras.Find(twoWedges);
			// _T(">>") was found in strExtras
			nValue = 1;
		}
		else
		{
			nValue = 0; // noMatch case, ">>" is not in strExtras
		}


		switch (nValue)
		{
		case nAfterNestedQuotes:
		{
			// _T(">> > >>") was found in strExtras, is it also in allPuncts? 
			allOffset = allPuncts.Find(afterNestedQuotes);
			if (allOffset >= 0)
			{
				// _T(">> > >>") was also found in allPuncts, remove from both strExtras and allPuncts
				allPuncts.Remove(allOffset, 7);
				strExtras.Remove(offset, 7);
				strExtrasLen = strExtras.Length();
				allPunctsLen = allPuncts.Length();
				// don't return, post-switch loop has work to do
			}
			else
			{
				// _T(">> > >>") was not found in allPuncts - no match, need smarter algorithm
				residue << twoWedges;
				extrasLen = strExtrasLen;
				bEndPunctsModified = TRUE;
				return FALSE;
			}
			break;
		}
		case nThreeWedges_singleFirst:
		{
			// _T("> >>") was found in strExtras, is it also in allPuncts?
			allOffset = allPuncts.Find(threeWedges_singleFirst);
			if (allOffset >= 0)
			{
				// _T(">> > >>") was also found in allPuncts, remove from both strExtras and allPuncts
				allPuncts.Remove(allOffset, 4);
				strExtras.Remove(offset, 4);
				strExtrasLen = strExtras.Length();
				allPunctsLen = allPuncts.Length();
				// don't return, post-switch loop has work to do
			}
			else
			{
				// _T("> >>") was not found in allPuncts - no match, need smarter algorithm
				residue << threeWedges_singleFirst;
				extrasLen = strExtrasLen;
				bEndPunctsModified = TRUE;
				return FALSE;
			}
			break;
		}
		case nThreeWedgesAndSpace:
		{
			// _T("> >>") was found in strExtras, is it also in allPuncts?
			allOffset = allPuncts.Find(threeWedgesAndSpace);
			if (allOffset >= 0)
			{
				// _T(">> >") was also found in allPuncts, remove from both strExtras and allPuncts
				allPuncts.Remove(allOffset, 4);
				strExtras.Remove(offset, 4);
				strExtrasLen = strExtras.Length();
				allPunctsLen = allPuncts.Length();
				// don't return, post-switch loop has work to do
			}
			else
			{
				// _T(">> >") was not found in allPuncts - no match, need smarter algorithm
				residue << threeWedgesAndSpace;
				extrasLen = strExtrasLen;
				bEndPunctsModified = TRUE;
				return FALSE;
			}
			break;
		}
		case nTwoWedges_afterEndMkr:
		{
			// _T(" >>") was found in strExtras, is it also in allPuncts?
			allOffset = allPuncts.Find(twoWedges_afterEndMkr);
			if (allOffset >= 0)
			{
				// _T(" >>") was also found in allPuncts, remove from both strExtras and allPuncts
				allPuncts.Remove(allOffset, 3);
				strExtras.Remove(offset, 3);
				strExtrasLen = strExtras.Length();
				allPunctsLen = allPuncts.Length();
				// don't return, post-switch loop has work to do
			}
			else
			{
				// _T(" >>") was not found in allPuncts - no match, need smarter algorithm
				residue << twoWedges_afterEndMkr;
				extrasLen = strExtrasLen;
				bEndPunctsModified = TRUE;
				return FALSE;
			}
			break;
		}
		case nTwoWedges:
		{
			// _T(">>") was found in strExtras, is it also in allPuncts?
			allOffset = allPuncts.Find(twoWedges);
			offset = extras.Find(twoWedges);
#if defined (_DEBUG) && !defined(NOLOGS)
			wxLogDebug(_T("%s() line %d , Starting... sequNum = %d , extras=[%s] , pSrcPhrase m_srcPhrase=[%s], offset = %d , allOffset = %d"),
				__FUNCTION__, __LINE__, pSrcPhrase->m_nSequNumber, extras.c_str(), pSrcPhrase->m_srcPhrase.c_str(), offset, allOffset);
			if (pSrcPhrase->m_nSequNumber >= 20)
			{
				int halt_here = 1; wxUnusedVar(halt_here); // avoid warning variable initialized but not referenced
			}
#endif
			if (allOffset >= 0)
			{
				// _T(">>") was also found in allPuncts, remove from both strExtras and allPuncts
				allPuncts.Remove(allOffset, 2);
				strExtras.Remove(offset, 2);
				strExtrasLen = strExtras.Length();
				allPunctsLen = allPuncts.Length();
				// don't return, post-switch loop has work to do
				break;
			}
			else
			{
				// _T(">>") was not found in allPuncts - no match, however a single > could
				// occur, and picking that up would happen in the loop for matching single
				// end puncts - so don't return here
				break; // from the switch
			}
		}
		case nNoMatch:
		{
			break; // ">>" is not in strExtras, but a single '>' could be matched from the punctuation set
		}
		} // end of switch

		// base our by-characters loop on what's in the copy of extras string, possibly shortened by removal of >> above
		wxChar space = _T(' ');
		wxChar aChar;
		//wxChar aCharInAllPuncts;
		// Update the lengths, in case >> was matched above
		strExtrasLen = strExtras.Length();
		allPunctsLen = allPuncts.Length(); // these two lengths may be unequal
		// Our loop algorithm is to remove whatever we match up, from both strExtras and allPuncts, until there
		// is nothing left (or only spaces left - we'll get rid of those by doing Trim() when done )
		// .Find() works correctly whether passing in wxChar or wxString for the search
#if defined (_DEBUG) //&& !defined(NOLOGS)
		if (pSrcPhrase->m_nSequNumber >= 16298 )
		{
			int halt_here = 1; wxUnusedVar(halt_here); // avoid warning variable initialized but not referenced
		}
#endif
		while (strExtrasLen > 0)
		{
			aChar = strExtras[0]; // every time one is removed, we must test the first of what remains
			if (aChar == space)
			{
				// Remove the space, decrease strExtrasLen by 1, and iterate (we parse over any embedded spaces)
				strExtras = strExtras.Mid(1);
				strExtrasLen--;
				continue; // iterate over the space, doesn't matter if allPuncts has a matching space or not
			}
			// Search for a match to aChar, within the allPuncts string
			allOffset = wxNOT_FOUND;
			allOffset = allPuncts.Find(aChar);
			if (allOffset != wxNOT_FOUND)
			{
				// a wxChar matching the contents of aChar was found within allPuncts. Remove this from both strings
				// and then update the length of the strings that remain, and keep iterating
				// NOTE: an assumption here is that two puncts in sequence have not been flipped in
				// their order - if they have been, then this should result in a non-empty residue, and the
				// caller will then invoke the function UpdateSrcSinglePattern() to use a matching algorithm
				// which would succeed if there are not more or fewer puncts than in m_srcSinglePattern
				allPuncts.Remove(allOffset, 1);
				strExtras.Remove(0, 1);
				// Update lengths for next iteration
				strExtrasLen = strExtras.Length();
				allPunctsLen = allPuncts.Length(); // these two lengths may be unequal
			} // end of TRUE block for test: if (allOffset != wxNOT_FOUND)
			else
			{
				// strExtras has the search character, but allPuncts lacks it.
				// A more clever algorithm is needed: ( UpdateSingleSrcPattern() ). 
				// Update needed variables & return FALSE
				residue << aChar;
				extrasLen = strExtrasLen;
				bEndPunctsModified = TRUE;
				return FALSE;
			} // end of the else block for test: if (allOffset != wxNOT_FOUND)
 
		} // the while loop ends
#if defined (_DEBUG) // && !defined(NOLOGS)
		if (pSrcPhrase->m_nSequNumber >= 16298)
		{
			int halt_here = 1; wxUnusedVar(halt_here); // avoid warning variable initialized but not referenced
		}
#endif
		// If control get to here, both strings should be either empty, or contain whitespace - typically space(s)
		// Trim() to remove any whites
		allPuncts.Trim();
		strExtras.Trim(); // it should have length 0 now
//		wxASSERT(strExtras.Length() == 0);

		if (strExtras.IsEmpty() && allPuncts.IsEmpty())
		{
			// We successfully matched everything, return TRUE
			extrasLen = 0; // and residue should still be empty
			wxASSERT(residue.IsEmpty());
			// BEW 25Aug23 added: all was matched, so m_srcPhrase should not have changed
			return TRUE;
		}
		else
		{
			// unexpected error -warn developer
			wxLogDebug(_T("%s() line %d , Unexpected error - all puncts matched but something remains: strExtras=[%s] , allPuncts=[%s]"),
				__FUNCTION__, __LINE__, strExtras.c_str(), allPuncts.c_str());
			residue << strExtras;
			bEndPunctsModified = TRUE;
			return FALSE;
		}
	} // end of else block for test: if (extras.IsEmpty())
}

// BEW added 10May23 for updating m_srcSinglePattern when puncts have changes
// When this function gets called within FromSingleMakeSstr(), m_srcSinglePattern's oldKey value will
// already have been updated to whatever is the new m_key value; so it's the rest we deal with here
// BEW 7Sep23 added wxString ref Sstr to signature, since we build a Sstr internally, we need to
// pass it back to the caller for the caller to store and/or use 
bool CAdapt_ItDoc::UpdateSingleSrcPattern(CSourcePhrase* pSrcPhrase, wxString& Sstr, bool bTokenizingTargetText)
{
	wxUnusedVar(bTokenizingTargetText); // avoid compiler warning unreferenced formal parameter

	// bTokenizingTargetText defaults to FALSE
	if (pSrcPhrase == NULL)
	{
		return FALSE;
	}
	// BEW 5Sep23 added this bit. Reason is as follows. Helpers uses AnalyseSstr() to help generate
	// a Tstr which has mrks and puncts mixed correctly, to avoid using a Placement dialog. It
	// analyses Sstr as stored in pSrcPhrase->m_srcSinglePattern (SourcePhrase.h 367) using the
	// function AnalyseSstr(). UpdateSingleSrcPattern() is called when the user manually changes
	// the punctuation inventory of the source text at a pSrcPhrase. That makes our stored
	// Doc.cpp member, m_tgtMkrPattern become incorrect - its mix of puncts and mkrs is no longer
	// in sync with the users punctuation changes. We can force automatic recalculation of
	// m_tgtMkrPattern by checking if it exists, and if so, emptying it. We do it here only because
	// this UpdateSingleSrcPattern() function is only called when Qm_srcPhrasePunctsPresentAndNoResidue()
	// has failed (it has a residue which is non-empty) to match the puncts inventory due to changes.
	// So an empty m_tgtMkrPattern value will auto-cause the needed rectification of its value, when
	// the target text is next exported by some function - doesn't matter which does the export.
	if (!pSrcPhrase->m_tgtMkrPattern.IsEmpty())
	{
		pSrcPhrase->m_tgtMkrPattern.Empty();
	}

	CAdapt_ItApp* pApp = &wxGetApp();  wxUnusedVar(pApp); // avoid warning variable initialized but not referenced
	Sstr.Empty();
	wxString buildStr;
	buildStr = wxEmptyString; // build in this a string which, when done, will be returned as Tstr

	wxString bindingType; wxString normalType; wxString nonbindingType;
	bindingType = wxEmptyString; normalType = wxEmptyString; nonbindingType = wxEmptyString;
	// Our protocol for endMkrs storage is, in left to right order:
	// (1) one or more inlineBindingMkrs, then (2) one or more from pSrcPhrase->m_markers, and lastly
	// (3) sometimes one of the inlineNonbinding endMkrs (e.g \wj* "words of Jesus") which we do not
	// expect to ever be followed by a punctuation character other than \r\n or \n of legacy OSX \s
	// Our protocol in this function involves some guesswork, because we have to guess where each
	// punct should be located relative to the three endMkr types. We handle it this way:
	// Inventory the ending puncts, collecting from m_follPunct and appending any in m_follOuterPunct;
	// count how many total.
	// Get an inventory of endMkrs - left to right order, from binding ones, then m_markers ones, and
	// finally any stored in nonbinding endMkrs storage. Count how many backslashes are present.
	// Then work from right to left, to make best guesses for assigning puncts from the puncts inventory
	// to follow relevant endMkrs. We are helped, I think, by the following observations. (a) I expect
	// an inline nonbinding endMkr to never be followed by an ending punct (but if there is one, we
	// should steal from end of the inventory of punct, to assign that one). Normal ending puncts are
	// expected to come from what's in m_follPunct (but that may include one that follows an inline
	// binding Mkr), so we can check how many puncts remain, and delay deciding until we find out
	// how many inline binding endMkrs there are. If there are none, then all the rest of the puncts
	// belong as following the word. If there is one or more inline binding endMks, there is usually
	// only one such, and it's unlikely these have a following punct - so if only one punct remains,
	// assume it goes after the 'normal' endMkrs provided this does not reduce the remainder of the
	// puncts to zero: eg. a situation like,  \k*.\f*<rest of puncts>
	// There's no way we can eliminate guesswork from these protocols, but the above may well generate
	// correct Sstr values in several contexts.

	int offset = wxNOT_FOUND; wxUnusedVar(offset); // avoid compiler warning variable initialized but not referenced
	bool bOuterPunctHasContent = FALSE;
	bOuterPunctHasContent = bOuterPunctHasContent; // avoid gcc warning set but not used warning
	bool bNormalEndPunctsHasContent = FALSE;
	int  nTotalEndPuncts = 0; // init
	wxString backslash = _T("\\");
	wxString twoWedges = _T(">>");
	// There are only two end-puncts storages, m_follPunct and m_follOuterPunct, inventory these first
	wxString strNormalEndPuncts = pSrcPhrase->m_follPunct;
	int nNormalEndPuncts = strNormalEndPuncts.Length();
	if (nNormalEndPuncts > 0)
	{
		bNormalEndPunctsHasContent = TRUE;
	}
	// check if m_follOuterPunct has any ending puncts
	int nOuterPuncts = 0;
	wxString strOuterPunct = wxEmptyString;
	strOuterPunct = pSrcPhrase->GetFollowingOuterPunct();
	if (!strOuterPunct.IsEmpty())
	{
		// Keeping m_follOuterPunct content separate from m_follPunct may help accuracy of our algorithm
		bOuterPunctHasContent = TRUE;
		nOuterPuncts = strOuterPunct.Length();
	}
	nTotalEndPuncts = nNormalEndPuncts + nOuterPuncts;

	// Next, get the inventory of endMkrs, left to right order, as individual substrings for
	// each marker type. Keeping separate types makes our algorithm easier to get right
	int nBindingLen; int nNormalLen; int nNonbindingLen; // spans for each endMkr
	wxUnusedVar(nBindingLen); // avoid gcc warning set but not used warning
	wxUnusedVar(nNonbindingLen); // avoid gcc warning set but not used warning
	nBindingLen = 0; nNormalLen = 0; nNonbindingLen = 0; // initialisations
	int nTotalEndMkrs;
	nTotalEndMkrs = 0; // init
	nTotalEndMkrs = nTotalEndMkrs; // avoid gcc warning set but not used warning

	bindingType = pSrcPhrase->GetInlineBindingEndMarkers();
	int numBinding = 0; // count how many there are
	if (!bindingType.IsEmpty())
	{
		nBindingLen = bindingType.Length(); // one or more consecutive inline binding endMkrs
		numBinding = bindingType.Replace(backslash, backslash); // how many there are
	}
	// That gives needed values for decisions in the context of one or more inlineBindingEndMkrs
	// 
	// Next, do the same for nonbindingType endMkrs
	nonbindingType = pSrcPhrase->GetInlineNonbindingEndMarkers();
	int numNonbinding = 0; // count how many there are
	if (!nonbindingType.IsEmpty())
	{
		nNonbindingLen = nonbindingType.Length(); // one (or more, but unlikely) inline nonbinding endMkrs
		numNonbinding = nonbindingType.Replace(backslash, backslash); // how many there are
	}
	// That gives needed values for decisions in the context of one or more inlineNonbindingEndMkrs

	// Finally, do the same for 'normalType' endMkrs - those that get saved in pSrcPhrase->m_endMarkers
	normalType = pSrcPhrase->GetEndMarkers();
	int numNormal = 0; // count how many there are
	if (!normalType.IsEmpty())
	{
		nNormalLen = normalType.Length(); // one or more non-inline (normal) endMkrs
		numNormal = normalType.Replace(backslash, backslash); // how many there are
	}
	// That gives us 6 pieces of information: 3 endmkrs, and the spans of each one present.
	// There may be none of the three endMkrs, or some, or three; and each may be a singleton
	// or more than one. non-binding one is likely a singleton, or absent. binding one usually
	// is a singleton, but easily may be two (or three together, but that is unlikely - we hope)
	nTotalEndMkrs = numBinding + numNormal + numNonbinding;

// ********* ANALYSIS *********

	// Now it's time to do analysis. Starting with the nonbinding endMkrs information; the last thing
	// to add will be the source text keyword, before storing the resulting Sstr in m_srcStringPattern
	if (numNonbinding > 0 && nOuterPuncts > 0)
	{
		// Both conditions have to be TRUE. numNonbinding zero means any outer puncts have
		// to be considered as right-most in the 'normal' inventory of ending puncts (can't append
		// a following punct character to an absent marker). The logic here is simple, there's at
		// least one final punct, and it's after a marker from the set in which \wj* occurs, just
		// append what puncts are there
		buildStr = nonbindingType;
		buildStr << strOuterPunct;	
	}
	else
	{
		if (!nonbindingType.IsEmpty())
		{
			buildStr = nonbindingType; // set the endMkr, without following puncts

		}
	}
	// We didn't need to steal any final puncts from nTotalEndPuncts. All the puncts remaining are
	// from pSrcPhrase->m_follPunct; unfortunately we never gave CSourcePhrase an m_bindingPunct
	// member, so if there is one or more inline binding endMkrs, we have to guess whether to pull
	// one from the start of nTotalEndPuncts, if there are at least >= 2 end puncts available; or
	// assume the inline endMkr(s) has none. I think the way to proceed would be as follows. If
	// nTotalEndPuncts is >= 3, then maybe the first should be given as associated with the last
	// inline binding endMkr; otherwise, likely they all belong after the last 'normal' endMkr; or if
	// there are lots of puncts, and there are more than two successive endMkrs, probably put the first
	// of those that remain, as after the first of those endMkrs. Not likely that more than 2 'normal'
	// endMkrs will occur. Here goes...

	// (1) When there are no initial inline binding endMkrs (there could be one or more normal endMkrs)
	// normalType has the contents of m_endMarkers
	if (bindingType.IsEmpty())
	{
		// There are no binding endMkrs on pSrcPhrase, so we need not consider placing any punct after
		// such and before 'normal' endMkrs. Consider blocks for zero, one, or more normal endMkrs
		if (numNormal == 0) // no normal endMkrs (m_endMarkers is empty)
		{
			// All the puncts attach directly to the end of the base word - no guesswork here,
			// so insert them at the start of buildStr
			if (bNormalEndPunctsHasContent)
			{
				buildStr = strNormalEndPuncts + buildStr;
			}
			// if test was FALSE, we've no endPuncts to distribute 
			// Note, we don't set Str until the very end, and we leave it to the caller to
			// add m_key at the start, and to deposit the final string in m_srcStringPattern
		}
		else if (numNormal == 1) // one normal endMkr from m_endMarkers e.g. \f*
		{
			// there is one endMkr, append the normal endPuncts, if any, to it
			if (bNormalEndPunctsHasContent)
			{
				buildStr = (normalType + strNormalEndPuncts) + buildStr; // e.g. buildStr becomes \f*.” or \f*.>>
			}
		}
		else if (numNormal == 2 && nNormalEndPuncts > 2) // two normal endMkrs from m_endMarkers
		{
			// Two final endMkrs, each may have final punctuation, or neither has, or last one of the two has. Guessing begins
			// I'll assume that only 2 logical endpuncts follow an endMkr - thats 2 characters, or 3 if one is ">>"
			int howMany = nNormalEndPuncts;
			if (howMany > numNormal)
			{
				// More endPuncts than endMkrs - give first endPunct to follow first endMkr,  the rest after 2nd endMkr
				wxString endMkr1 = wxEmptyString;
				wxString endMkr2 = wxEmptyString;
				endMkr1 = GetWholeMarker(normalType);
				int lenMkr1 = endMkr1.Length();
				if (lenMkr1 > 0)
				{
					endMkr2 = normalType.Mid(lenMkr1);
				}
				wxASSERT(!endMkr2.IsEmpty());
				wxChar first = strNormalEndPuncts[0].GetValue();
				wxString strRemainderPuncts = strNormalEndPuncts.Mid(1);
				wxString subStr; // empty by default
				subStr = endMkr1 + first;
				subStr << endMkr2;
				subStr << strRemainderPuncts;

				buildStr = subStr + buildStr;
			}
			else if (howMany == numNormal)
			{
				// There are two endPuncts, and two endMkrs; best would be both follow 2nd  endMkr - this covers ">>" possibility
				if (bNormalEndPunctsHasContent)
				{
					buildStr = (normalType + strNormalEndPuncts) + buildStr; // probably okay
				}
				else
				{
					// no end puncts to place, so just insert the endMrks
					buildStr = normalType + buildStr;
				}
			}
			else if (howMany < numNormal)
			{
				// There are fewer endPuncts than endMkrs - so unwise to distribute any, put them all after the endMkr pair
				if (bNormalEndPunctsHasContent)
				{
					buildStr = (normalType + strNormalEndPuncts) + buildStr; // probably okay
				}
				else
				{
					// no puncts to place
					buildStr = normalType + buildStr;
				}
			}
		}
		else if (numNormal >= 3) // three or more endMkrs from m_endMarkers
		{
			// Three endMkrs - probably extremely rare. Go for simplest possibility, attach
			// all puncts after the last of the three
			if (bNormalEndPunctsHasContent)
			{
				buildStr = (normalType + strNormalEndPuncts) + buildStr; // it's guess only
			}
			else
			{
				// no puncts to place
				buildStr = normalType + buildStr;
			}
		}
		Sstr = buildStr;
		return TRUE;
	} // end of TRUE block for test: if (bindingType.IsEmpty())

	// Next, the more complex case: normal endMkrs, one or more inline binding endMkrs, and various
	// numbers of final puncts - none, some, many

	// (2) When there are one or more initial inline binding endMkrs, and one or more normal endMkrs, and
	// 	   some puncts - none or some or many
	// normalType has the contents of m_endMarkers
	if ( !bindingType.IsEmpty()) // there are binding endMkrs - one or more
	{
		// How many binding endMkrs are there?
		int nNumBindingEndMkrs = 0; // init
		nNumBindingEndMkrs = bindingType.Replace(backslash, backslash);
		wxASSERT(nNumBindingEndMkrs >= 1);
		// How many normal endMkrs are there? Could be none, one, or more than one
		int nNumNormalEndMkrs = normalType.Replace(backslash, backslash); wxUnusedVar(nNumNormalEndMkrs); // avoid compiler warning variable initialized but not referenced
		// Get the inline binding mkrs in pSrcPhrase. Usually only one, sometimes
		// could be two, three would be extremely rare. Use wxArrayString for safety.
		// We know there are endMkrs, we there is at least one bindingEndMkr, we know
		// there could be puncts; and there could be normal end mkrs from m_markers;
		// but we don't know the order in the mix of all 3 of these things - gotta guess
		wxArrayString arrBindingEMkrs;
		int index;
		wxString aBindingEMkr;
		wxString strBindingMkrs = bindingType; // I'll consume from LHS string in the loop
		int nSingleEMkrLen = 0;
		for (index = 0; index < nNumBindingEndMkrs; index++)
		{
			aBindingEMkr = GetWholeMarker(strBindingMkrs);
			nSingleEMkrLen = aBindingEMkr.Length();
			if (aBindingEMkr.IsEmpty())
			{
				break; // somethings wrong, there are fewer than expected, work with how many are identified
			}
			arrBindingEMkrs.Add(aBindingEMkr);
			// remove the one found
			strBindingMkrs = strBindingMkrs.Mid(nSingleEMkrLen);
		}
		// nTotalEndPuncts has to be reset by collecting puncts from m_follPunct (only, m_follOuterPunct done above)
		wxString strEndPuncts = pSrcPhrase->m_follPunct;
		nTotalEndPuncts = strEndPuncts.Length();

		// There are normal endMkrs too, so we need to consider placing puncts with either kind of endMkr -
		// both binding endMks and 'normal' endMkrs. Consider blocks for zero, one, or more normal endMkrs;
		// and various numbers of final puncts. 
		if (numNormal == 0) // no normal endMkrs (m_endMarkers is empty), but there are inline binding endMkr/s
		{
			// All the puncts attach directly to the end of the binding endMkr, but if there are more than
			// one binding endMkrs, then probably we should distribute ending puncts, if their count allows
			// (remember ">>" counts as one, if present
			// so insert them at the start of buildStr
			if (nNumBindingEndMkrs == 1 && nTotalEndPuncts == 0)
			{
				// There is only one binding endMkr, but no normal endMkrs (m_endMarkers is empty) 
				// and no puncts to place; so just insert the endMkr
				buildStr = arrBindingEMkrs.Item(0) + buildStr;
			}
			else
			{
				// We Know that entering else must be due to nTotalEndPuncts being > 0.
				// So just add them all after the first (inline binding) endMkr - no guessing here
				buildStr = arrBindingEMkrs.Item(0) + strEndPuncts + buildStr;
			}
		} // end of TRUE block for test: if (numNormal == 0)
		else if (numNormal == 1)
		{
			// There is at least one bindingEndMkr, and only a single 'normal' endMkr in m_endMarkers; 
			// maybe zero, one, or more ending puncts - the number of puncts is in nTotalEndPunts.
			// The issue here is whether to put the first punct, if any exist, as belonging to the end
			// of the binding endMkr? Answer is 'no' if there is only a single binding endMkr, but
			// two binding endMkrs in sequence is problematic. I think we'll associate the ending puncts
			// as following the single normal endMkr, except when the puncts count is > 2 (or >3 if
			// ">>" (logically, one punct) is present in strEndPuncts
			bool bTwoWedgesPresent = strEndPuncts.Find(twoWedges) >= 0 ? TRUE : FALSE;
			bool bSeveralPuncts = FALSE; // init
			if ((bTwoWedgesPresent && nTotalEndPuncts > 3) || nTotalEndPuncts > 2 )
			{
				bSeveralPuncts = TRUE; // okay, we can "afford" to put the first punct with the binding
									   //  endMkr and the rest can follow the single 'normal' endMkr
			}
			if (bSeveralPuncts)
			{
				// Pull off the first punct from strEndPuncts, and the remainder go after the normal endMkr
				// Beware, the first punct might be ">>"
				wxString firstPunct;
				wxString theRest;
				if (bTwoWedgesPresent)
				{
					firstPunct = strEndPuncts.Left(2);
					theRest = strEndPuncts.Mid(2); // rest of the final puncts
				}
				else
				{
					firstPunct = strEndPuncts.Left(1);
					theRest = strEndPuncts.Mid(1); // rest of the final puncts
				}
				wxString buildBits = bindingType; // the one or more binding endMkrs ( e.g. \k*\i* or more)
										// these are character format markers, and unlikely to have punctuation
										// between them
				buildBits << firstPunct;
				buildBits << normalType; // the one 'normal' endMkr (e.g \f* )
				buildBits << theRest;
				buildStr = buildBits + buildStr;
			}
			else
			{
				// Not enough puncts to divide them up
				wxString buildBits = bindingType; // the one or more binding endMkrs
				buildBits << strEndPuncts; // all the puncts - could be emptyString
				buildStr = buildBits + buildStr;
			}
		} // end of true block for test: else if (numNormal == 1)
		else if (numNormal > 1)
		{
			// I think I've covered the likely possibilities. So this block can be a
			// catch all. Three or more binding endMkrs? Unlikely. Two or more 'normal'
			// endMkrs - a reasonable possibility, so divide puncts up if able, if not
			// able, just add them and all puncts after the last such endMkr.
			// Get the last end marker using: wxString GetLastEndMarker(wxString mkrs)
			bool bTwoWedgesPresent = strEndPuncts.Find(twoWedges) >= 0 ? TRUE : FALSE;
			// Get the normal end puncts - these from m_endMarkers - grab, if possible
			// the last punct, and put it after the first of these normal endMkrs, and
			// the rest of the following puncts can go after the last normal endMkr
			wxString strLastEMkr = GetLastEndMarker(normalType);
			int nLastEMkrLen = strLastEMkr.length();
			wxString strInitialEMkrs = normalType.Left(nNormalLen - nLastEMkrLen);

			// If enough final puncts, grab the first for placing earlier
			bool bSeveralPuncts = FALSE; // init
			if ((bTwoWedgesPresent && nTotalEndPuncts > 3) || nTotalEndPuncts > 2)
			{
				bSeveralPuncts = TRUE; // okay, put the first punct after the strLastEMkr
									   // and the of the puncts at end of 'normal' endMkrs
			}
			if (bSeveralPuncts)
			{
				// Pull off the first punct from strEndPuncts, and the remainder go after
				//  the normal endMkrs Beware, the first final punct may be ">>"
				wxString firstPunct;
				wxString theRest;
				if (bTwoWedgesPresent)
				{
					firstPunct = strEndPuncts.Left(2);
					theRest = strEndPuncts.Mid(2); // rest of the final puncts
				}
				else
				{
					firstPunct = strEndPuncts.Left(1);
					theRest = strEndPuncts.Mid(1); // rest of the final puncts
				}
				wxString buildBits = strInitialEMkrs; // the initial set of endMkrs (excluding last one)
				buildBits << firstPunct;
				buildBits << strLastEMkr;
				buildBits << theRest;
				buildStr = buildBits + buildStr;
			}  // end of TRUE block for test: if (bSeveralPuncts)
			else
			{
				// Too risky to divide off the first punct, so just add the lot after
				// normalType
				wxString buildBits = normalType;
				buildBits << strEndPuncts;
				buildStr = buildBits + buildStr;
			} // end of else block for test: if (bSeveralPuncts)

		} // end of TRUE block for test: else if (numNormal > 1)

		Sstr = buildStr;
		return TRUE;
	} // end of TRUE block for test: if (bindingType.IsEmpty())

	Sstr = buildStr; // return this to caller via signature, and return TRUE as function result

	return TRUE;
}

// Take the pSrcPhrase stored m_srcSinglePattern stored string, before any changed puncts have a chance to alter its
// internal punctuation substrings, and cut it up and store the bits in arrays with substring 'old' in their names,
// so that another function can do similarly with new pSrcPhrase members with possibly changed puncts, so that both
// sets of arrays can be checked for changes, and copying of new punct values where appropriate, to form an altere
// m_srcSinglePattern that stays unchanged until such time as user again wants to changes src puncts, and does so
bool CAdapt_ItDoc::CreateOldSrcBitsArr(CSourcePhrase* pSrcPhrase, wxArrayString& oldSrcBitsArr, wxString& spacelessPuncts)
{
	wxString srcPattern = wxEmptyString; // init
	srcPattern = pSrcPhrase->m_srcSinglePattern;
	srcPattern.Trim(); // remove any final whitespace
	if (srcPattern.IsEmpty())
	{
		oldSrcBitsArr.Empty();
		return FALSE;
	}
	// First, remove the initial key substring, otherwise we'd get doubling of it'
	srcPattern = GetPostwordExtras(pSrcPhrase, srcPattern);

	// Make the buffer for parsing thru, from srcPattern passed in
	const wxChar* pBuffer = srcPattern.GetData();
	wxChar* ptr = (wxChar*)pBuffer;	// ptr is not constant, point to start of text
	wxChar* pBufStart = ptr;        // preserve start address for use in testing for buffer beginning
	int length = srcPattern.Length();
	wxChar* pEnd = (wxChar*)(ptr + length);
	int index = 0;  wxUnusedVar(index); // avoid compiler warning variable initialized but not referenced
	// In the old pattern, puncts and markers are visible in their correct places in the pattern. 

	// Find first punct, and subsequent, filling arrays with values. srcPattern could contain ">>" - beware
	wxChar aChar; wxUnusedVar(aChar); // avoid compiler warning variable initialized but not referenced
	wxChar* pCurrLocn; // use this to preserve where ptr got to when a closing punct was found
	wxUnusedVar(pCurrLocn);
	wxChar* pKickOffLocn; // where to start the scanning when current found punct's substring is appended to OldSrcBitsArr
					   // (our loop does not remove wxChars as we scan)
	int offset = wxNOT_FOUND; // init
	wxString accum = wxEmptyString; // init
	wxChar chWedge = _T('>'); // two consecutive is a logical single character - if one found then check ptr + 1
	wxChar follChar;
	wxChar prevChar;
	wxString subStr;
	pKickOffLocn = pBufStart;
	bool bAsteriskLast = FALSE;  wxUnusedVar(bAsteriskLast); // avoid compiler warning variable initialized but not referenced
	wxChar chAsterisk = _T('*'); wxUnusedVar(chAsterisk); // avoid compiler warning variable initialized but not referenced

	while (ptr < pEnd)
	{
		wxChar aChar = *ptr;
		offset = spacelessPuncts.Find(aChar);
		if (offset == wxNOT_FOUND)
		{
			// aChar does not contain a punctuation character, keep iterating till we find one, or get to pEnd
			ptr++;
			if (ptr == pEnd)
			{
				break;
			}
		} // end of TRUE block for test: if (offset == wxNOT_FOUND)
		else
		{
			// we found a punctuation character - check for whitespace immediately preceding, store the substring
			// parsed over so far, in oldSrcBitsArr
			pCurrLocn = ptr;

			// Deal with potential for ">>" first, and it may have a whitespace preceding it, and check if * is preceding too
			if (aChar == chWedge)
			{
				if (ptr < pEnd)
				{
					// Found '>', is there another following
					follChar = *(ptr + 1);
					if (follChar == chWedge)
					{
						// We've come to a ">>" closing pair of wedges

						// Check for a preceding whitespace at ptr - 1, to include in strAccum,
						// but if ptr == pBufStart, then we may be a punct preceding doc end,
						// so protect accordingly; we want to accumulate the punct, but ptr-1
						// is out of bounds
						if (ptr >= pBufStart)
						{
							if ((ptr - 1) < pBufStart)
							{
								// Cannot search back, so don't look for a previous whitespace.
								// Just accumulate the found punct
								accum << *ptr;

							}  // end of TRUE block for test: if ((ptr - 1) < pBufStart)
							else
							{
								prevChar = *(ptr - 1);
								bool bIsWhite = IsWhiteSpace(ptr - 1);

								if (bIsWhite)
								{
									// Keep the whitespace with the ">>" pair, preceding the pair
									accum = prevChar;
									accum << chWedge;
									accum << follChar;
									ptr++; // get ptr poining past the first '>'
								}
								else
								{
									// There is no whitespace preceding the ">>"
									accum = chWedge;
									accum << follChar;
								}
							} // end of else block for test: if ((ptr - 1) < pBufStart)
							ptr++;  // advance ptr past the currently found ending punct					

							// How far have we advanced ptr?
							int spanLen = (int)(ptr - pKickOffLocn);
							subStr = wxString(pKickOffLocn, spanLen); // this is what we store in oldSrcBitsArr for this iteration
							int index_of_Add = oldSrcBitsArr.Add(subStr);
							wxUnusedVar(index_of_Add);
#if defined (_DEBUG)
							wxLogDebug(_T("CreateOldSrcBitsArr(), Doc.cpp line= %d ,array filling: old spanLen= %d , subStr= [%s], index_of_Add= %d "),
									__LINE__, spanLen, subStr.c_str(), index_of_Add);
#endif
							if (ptr == pEnd)
							{
								break;
							}
							// Prepare for next iteration
							pKickOffLocn = ptr;  // where we start for next iteration of the loop
							accum.Empty();
							pCurrLocn = ptr;
							subStr.Empty();

						} // end of TRUE block for test: if (ptr > pBufStart)

					} // end of TRUE block for test: if (follChar == chWedge) i.e. ">>" at pt

				} // end of the TRUE block for test: if (ptr < pEnd)

			} // end of TRUE block for test: if (aChar == chWedge)
			else
			{
				// aChar is not chWedge
				 
				// Check for a preceding whitespace at ptr - 1, to include in strAccum,
				// but if ptr == pBufStart, then we may be a punct preceding doc end,
				// so protect accordingly; we want to accumulate the punct, but ptr-1
				// is out of bounds
				if (ptr >= pBufStart)
				{
					if ((ptr - 1) < pBufStart)
					{
						// Cannot search back, so don't look for a previous whitespace.
						// Just accumulate the found punct
						accum << *ptr;

					} // end of TRUE block for test: if ((ptr - 1) < pBufStart)
					else
					{
						prevChar = *(ptr - 1);
						bool bIsWhite = IsWhiteSpace(ptr - 1);

						if (bIsWhite)
						{
							accum = prevChar;
							accum << *ptr;
						}
						else
						{
							// There is no whitespace preceding the current ending punct
							accum << *ptr;
						}
					} // end of else block for test: if ((ptr - 1) < pBufStart)
					ptr++; // advance ptr past the currently found ending punct

					// How far have we advanced ptr?
					int spanLen = (int)(ptr - pKickOffLocn);
					subStr = wxString(pKickOffLocn, spanLen); // this is what we store in oldSrcBitsArr for this iteration
					int index_of_Add = oldSrcBitsArr.Add(subStr);
					wxUnusedVar(index_of_Add);
#if defined (_DEBUG)
					wxLogDebug(_T("CreateOldSrcBitsArr(), Doc.cpp line= %d ,array filling: old spanLen= %d , subStr= [%s], index_of_Add= %d "),
						__LINE__, spanLen, subStr.c_str(), index_of_Add);
#endif
					if (ptr == pEnd)
					{
						break;
					}
					// Prepare for next iteration
					pKickOffLocn = ptr;  // where we start for next iteration of the loop, ptr is past the current end punct
					accum.Empty();
					pCurrLocn = pKickOffLocn;
					subStr.Empty();
				} // end of TRUE block for test: if (ptr > pBufStart)

			} // end of else block for test: if (aChar == chWedge)

		}  // end of else block for test: if (offset == wxNOT_FOUND)

	} // end of while loop: while (ptr < pEnd)

	return TRUE;
}
// Return TRUE if chFirst is the start of an alphabetic word or digit
bool CAdapt_ItDoc::WordBeginsHere(wxChar chFirst, wxString spacelessPuncts)
{
	// We deem the first character of a word to have been passed in, if chFirst is:
	// 1. Not a backslash (therefore, not a marker of any kind, not beginMkr nor endMkr), AND
	// 2. Not a punctuation character from the spacelessPuncts inventory
	int offset = wxNOT_FOUND;
	offset = spacelessPuncts.Find(chFirst);
	if (offset >= 0)
	{
		// it's punctuation
		return FALSE;
	}
	if (chFirst == _T('\\'))
	{
		// It's the beginning of a USFM marker
		return FALSE;
	}
	// If neither, then it's the start of a word
	return TRUE;
}

// BEW 13Jun23 created, for use in refactored TokenizeText() to prevent markers like \f or inline ones
// from being wrongly put into tokBuffer, thereby removing them from the propagation mechanism using
// pLastSrcPhrase for the values which need to change - colour, textType, etc
bool CAdapt_ItDoc::IsRedOrBindingOrNonbindingBeginMkr(wxChar* pChar, wxChar* pEnd)
{
	if (pChar > (pEnd - 3))
	{
		return FALSE;
	}
	if (*pChar != gSFescapechar)
	{
		return FALSE;
	}
	wxChar* ptr = pChar;
	int offset = wxNOT_FOUND; // init
	wxString wholeMkr = wxEmptyString;
	wxString augWholeMkr = wxEmptyString;
	wholeMkr = GetWholeMarker(ptr);
	bool bIsBeginMkr = TRUE; wxUnusedVar(bIsBeginMkr); // avoid compiler warning variable initialized but not referenced
	wxString asterisk = _T("*");
	offset = wholeMkr.Find(asterisk);
	if (offset >= 0)
	{
		// it's an endMkr
		return FALSE;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	augWholeMkr = wholeMkr + _T(' ');
	offset = wxNOT_FOUND;
	offset = pApp->m_RedBeginMarkers.Find(augWholeMkr);
	if (offset >= 0)
	{
		return TRUE;
	}
	offset = wxNOT_FOUND;
	offset = pApp->m_charFormatMkrs.Find(augWholeMkr); // same marker set as m_inlineBindingMarkers, eg. \it \k etc
	if (offset >= 0)
	{
		return TRUE;
	}
	offset = wxNOT_FOUND;
	offset = pApp->m_inlineNonbindingMarkers.Find(augWholeMkr);
	if (offset >= 0)
	{
		return TRUE;
	}
	// If no match of wholeMkr to any of the above fast-access strings, then it's probably blue - like \v etc
	// Yep, the above is what we need to get chapNum:verseNum shown in m_inform when list begin mkrs precede \v
	return FALSE;
}

// ======= contentless markup support ======

/*
// whm 17Jan2024 removed the EnterEmptyMkrsLoop() function. The use of IsEmptyMkr() function is 
// sufficient test along with bIsToBeFiltered flag as to whether to enter the long block of code
// in TokenizeText() that deal with empty content markers.
//
// BEW 11Aug23, These following are in support of parsing contentless USFM beginMkrs, and elimination of
// any encountered ".." or "..." (the latter, when successive periods are generated by Paratext,
// appear to be limited to only two of three, so I'll code accordingly)

// BEW 11Aug23, I've fought the AI code for weeks, to robustly parse contentless markup, and failed.
// So I'm taking control. When IsMarker(ptr) returns TRUE, I'll make a test, and if true, use a new
// parsing loop that is not in the app yet - dedicated to parsing contentless markers. \v will require
// special attention, to get a following verseNumber handled right, but we must not allow the following:
// "\v versNum<whitespace>\v" as it causes the verseNumNext after 2nd \v to parse verseNumNext as srcText.
// 
// whm 24Oct2023 modified to remove use of the IsAFilteringSFM() function. See comments below.
// whm 12Jan2024 refactored to simplify and fix some errors. Removed the code that attempted to deal with
// empty list item \li \li1 \li2 etc. These are adequately handled as empty markers. 
// Removed the special poetry handling block from this function which allows the empty markers loop 
// back in TokenizeText() to create source phrases for each empty poetry marker.
bool CAdapt_ItDoc::EnterEmptyMkrsLoop(wxChar* pChar, wxChar* pEnd)
{
	// whm 9Jan2024 testing set EnterEmptyMkrsLoop to always FALSE and compare the result
	// only difference in the Hezekiah file was there was no empty pSrcPhrase created for
	// the \fe* end marker which was dropped out entirely. The following \v 12 was still
	// missing at the beginning of the verse text following the \fe*.
	//return FALSE;

	wxChar* ptr = pChar; // protect pChar
	// Entry allowed when a beginMkr is at pChar, and the beginMkr is contentless; but not allowed when
	// after the beginMkr (or after the verseNum if it's \v,) there is parseable content - e.g. words
	if (*ptr != gSFescapechar)
		return FALSE; // and skip the loop for parsing empty mkrs
	wxString wholeMkr = GetWholeMarker(ptr);
	wxASSERT(!wholeMkr.IsEmpty());

	// BEW 16Aug23 The \p marker is a special case. It often is an empty beginMkr in among markers which have
	// parseable content, and when that is the case, we don't want entry to the contentless markers parsing
	// loop to happen. However, if control is within that loop already, we would treat contentless \p like
	// any other empty one; but \p can have parsable words following, in which case we would want control to
	// leave the contentless markers loop, so that legacy parsing code can work to parse the words. The only
	// thing lacking then is to prevent entry into the contentless markers if wholeMkr is \p; the other
	// possibilities are catered for already. Same logic for \c marker - it has a chapterNumber, but never
	// any following parseable words, so it too should not cause entry to the contentless mkrs loop.
	// (But when control is already in the loop and either is encountered, each has a dedicated parsing block.)
	// BEW 28Aug23 there are 17 markers in the fast-access m_paragraphMkrs string, 5 of which do not start with
	// "\p". So I'll change the following simple 3-element if test to utilize m_paragraphMkrs. Only \c is not
	// in that set.
	//if (wholeMkr == _T("\\p") || wholeMkr == _T("\\c") || wholeMkr == _T("\\m"))
	wxString augWholeMkr = wholeMkr + _T(' '); // add space
	int offset = -1;
	bool bIsInParagraphSet = FALSE; // init
	offset = gpApp->m_paragraphMkrs.Find(augWholeMkr);
	if (offset >= 0)
	{
		// wholeMkr is a member of the paragraph set of USFM beginMkrs
		bIsInParagraphSet = TRUE;
	}
	if (wholeMkr == _T("\\c") || bIsInParagraphSet)
	{
		// These 'paragraph' type of markers are not allowed to cause entry (these include \m \mi \cls \b and \nb)
		return FALSE;
	}
	// BEW 21Aug23, some beginMkrs are in the app's gCurentFilterMarkers fast-access set. Control must not
	// enter the empty mkrs parsing loop if a BeginMkr is to be filtered, because that loop knows nothing
	// about filtering. E.g. \x is by default, filtered out. And it may have an empty beginMkr in its span.
	// E.g. in 02EXONYNT.SFM, at 4:3 is the following: \v 3 \x - \xo 4.3 \xt \x* Laban ...
	// \xt is empty, and would cause entry to the empty mkrs loop and an eventual crash at ParseAWord().
	// So test for mkrs to be filtered, and if so, return FALSE to keep control in the legacy parsing code
	bool bIsToBeFiltered = FALSE;
	//bool bCanFilterIt = FALSE; // whm 24Oct2023 not needed
	//USFMAnalysis* pUsfmAnalysis = NULL; // init // whm 24Oct2023 not needed
	//wxString bareMkr = wholeMkr.Mid(1); // remove initial backslash
	int myOffset = -1;
	// whm 12Jan2024 modification. The check for existence in gCurrentFilterMarkers below should
	// use the augWholeMkr instead of the bareMkr to avoid false positives.
	//myOffset = gpApp->gCurrentFilterMarkers.Find(bareMkr);
	myOffset = gpApp->gCurrentFilterMarkers.Find(augWholeMkr);
	bIsToBeFiltered = myOffset != -1;
	// whm 24Oct2023 modification. The IsAFilteringSFM() function should NOT be used along with a
	// check of the gCurrentFilterMarkers string, since the IsAFilteringSFM() function only
	// returns the "default" filtering status of a marker which does NOT change when a marker
	// is currently being filtered by the USFM/Filtering tab in Preferences. For example, a marker 
	// such as \s section heading is not filtered by default as set within the AI_USFM.xml 
	// control file where its setting is filter="0". That setting never changes even when the \s
	// marker is set to be filtered within the USFM/Filtering tab in Preferences.
	//  
	// Therefore I've removed the IsAFilteringSFM() function from the following test. We should
	// only test the bIsToBeFiltered boolean value which was determined above by examining the
	// App's gCurrentFilterMakers string. Therefore, in the code below we only need check the 
	// value of the bIsToBeFiltered boolean and return FALSE if that variable is FALSE.
	//pUsfmAnalysis = LookupSFM(bareMkr);
	//if (pUsfmAnalysis != NULL)
	//{
	//	bCanFilterIt = IsAFilteringSFM(pUsfmAnalysis);
	//	if (bIsToBeFiltered && bCanFilterIt)
	//	{
	//		// disallow entry to the empty mkrs parsing loop
	//		return FALSE;
	//	}
	//}
	if (bIsToBeFiltered)
	{
		// disallow entry to the empty mkrs parsing loop
		return FALSE;
	}

	// whm 12Jan2024 removed the list item disallowing block. The bProcessEmptyMarker block 
	// back in TokenizeText() is able to handle empty list item markers, for example \li \li1 \li2 etc,
	// making them have empty source phrases in the document. the empty.

	// BEW 21Aug23, the possibility of entering the loop causes a misparse when any \q or \q# beginMkr
	// which is empty before a following verse marker; so have to tried like listIndex markers above,
	// and return FALSE to keep from the poetry mkr causing loop entry. All poetry mkrs are length 3 or 4,
	// except \q is length 2.
	//
	// whm 12Jan2024 removed the poetry block. This block caused empty poetry markers to accumulate
	// in the next source phrase - not what we want. By commenting out this block it allows the empty
	// markers loop to create source phrases for each empty poetry marker.

	wxString mkrTag = wholeMkr.Mid(1); // remove backslash
	int mkrLen = wholeMkr.Length();
	bool bEnterLoop = FALSE; // init
	wxChar period = _T('.');
	int numberLen = 0; // for parsing over a verse or chapter number if \c or \v

	// [BEW] The empty markers could be very many, from the set of blue begin markers, or red begin markers 
	// (but not the embedded ignore markers like \ft \fr etc - but those will be absent if the beginMkr is 
	// contentless).
	// These are some which may occur: \ide \rem \h \toc1 \toc2 \toc3 \mt1 \c 1 \s1 \p \v 1 \s1 \p \q1 \q2 \q3 etc
	// What matters?
	// a) There may be periods:  \q1 ...  \v 28   or  \p ... or \p .. which we'll have to parse over and forget
	// b) The next marker may be on the same line (\p \v 5 \v 6 \v 7 ) or the next ( \q1<newline>\q2 )
	// c) A marker may be followed by space, or by newline
	// d) A verse marker requires we parse the verseNum, at get m_inform string, similarly \c & chapterNum
	// How do we know a beginMkr is empty? Answer: after the marker (or for \v verseNum after the verseNum)
	// there is only one or rarely two whitespaces (space or newline) and then a backslash
	//	
	// When should we return FALSE to have control utilize the legacy parsing code? Answer: when, after the
	// marker (or after verseNum if its \v marker), there is only some whitespace, and then no backslash.
	// In the empty USFM data, no punctuation occurs. (In AI, there are only words, puncts, markers, and whites)
	// So the lack of backslash tells us when to decline to enter the emptyMkrs loop; and when in the loop,
	// when to break out of it. Within the loop, control stays there and creates new pSrcPhrases until either
	// words begin, or the end of source text is reached.
	//
	// Note: LookupUSFM() is not required for figuring out when to enter, or break out of the loop - backslash
	// is mainly significant for that. Within the loop, we won't have src or tgt words to display, so the presence
	// of a pSrcPhrase will only be seen by the text in m_inform - and for that we need LookupUSFM()'s data

#if defined(_DEBUG)

#endif

	// This function does not parse, so pChar stays constant; and pSrcPhrase is ignored
	// 
	// BEW 16Aug23 error here, the + 1 causes error; e.g. src data such as: empty \s1 as in:  \s1<newline>\p<newline>
	// If we keep +1 we parse over the <newline> and ptr will point at the backslash of \p and then in later code
	// below which assumes there is pre-next-marker whitespace, there will not be whitespace, and the test below:
	// if (ptr < pEnd && bIsEmptyMkr && numWhites != 0) will fail because numWhites is zero at that point. And that is
	// the vital test for entry into the contentless mkrs while loop, bEnterLoop remains FALSE, and control goes to the
	// legacy parsing code which the mishandles contentless markers - markers get lost, verseNum gets handled as
	// parsable srcText to appear as m_key, etc. So don't have +1 here, and I'll have to adjust the code below a bit
	//ptr += mkrLen + 1; // +1 for an obligatory post-mkr white (either space or newline)
	ptr += mkrLen;

	// BEW 16Aug23 use pAux so as to safeguard ptr location
	wxChar* pAux = ptr + 1;
	// Paratext may have added two or three periods ( .. or ...) - these do not affect the decision, but
	// if present they have to be skipped over to check what follows them
	//if (*ptr == period)
	int nCountPeriods = 0;
	if (*pAux == period)
	{
		pAux++; //ptr++;
		nCountPeriods++;
		// is there a second?
		//if (*ptr == period)
		if (*pAux == period)
		{
			pAux++; // ptr++;
			nCountPeriods++;
			// is there a third?
			//if (*ptr == period)
			if (*pAux == period)
			{
				pAux++; // ptr++;
				nCountPeriods++;
			}
		}
		// BEW 16Aug23 restore ptr to where pAux got to
		ptr += (1 + nCountPeriods); // ptr here, should be pointing at whitespace, not backslash
	} // end of TRUE block for test: if (pAux == period)

	// We've skipped a periods sequence - these can occur in lots of markers, but never in \v content
	
	// After ptr, there may be a backslash, or some more whites then a backslash - so count spaces at ptr
	int numWhites = CountWhitesSpan(ptr, pEnd);
	// BEW 16Aug23 preserve ptr location
	wxChar* pSavePtr = ptr;
	pAux = ptr;

	// ptr += numWhites;
	
	// pAux now points after the marker and its following one (or maybe more) whitespace. We can't make a
	// decision whether or not to enter the contentless loop, if pAux is pointing at the chapterNum of \c
	// or verseNum of \v. So we have to determine if wholeMkr is \c or \v, and if either, then get past
	// the number (ParseNumber() is easiest way) and the following white(s), and then we can test for
	// presence or not of backslash following - if so, it's contentless and we need to enter the loop.
	if (wholeMkr == _T("\\v") || wholeMkr == _T("\\c"))
	{
		//Get to the number
		pAux += numWhites;

		//numberLen = ParseNumber(ptr);
		numberLen = ParseNumber(pAux);
		if (numberLen > 0)
		{
			//ptr += numberLen;
			pAux += numberLen;
		}
		if (IsWhiteSpace(pAux))
		{
			numWhites += ParseWhiteSpace(pAux);
		}
	}
	if (pAux > pSavePtr)
	{
		ptr = pSavePtr;
		ptr += numWhites;
		ptr += numberLen;
	}
	else
	{
		// pAux == pSavePtr so this else is entered when no \v n or \c n markers were parsed above
		// so any numWhites here would be from the CountWhites() call above counting whitespace 
		// after wholeMkr.
		ptr = pSavePtr; // unneeded but harmeless since ptr == pSavePtr here
		ptr += numWhites; // whm 12Jan2024 added to remove space after wholeMkr before IsEmptyMkr() call below
	}
	numWhites = 0; // ready for IsEmptyMkr()'s numWhites value returned via signature

	// Now test for whether or not the wholeMkr is an empty one or not
	int nPeriodsInWhitesLen = 0;
	bool bIsEmptyMkr = IsEmptyMkr(ptr, numWhites, pEnd, nPeriodsInWhitesLen);
	// whm 15Jan2024 Here we just get a return bool value, so we don't actually do anything with
	// the nPeriodsInWhitesLen. That job will be for the IsEmptyMkr() calls in TokenizeText() to
	// handle.

	// Now we can make our decision to enter the emptyMkrs loop, or have control remain in TokenizeText's
	// main (and inner) loops. bEnterLoop is currently FALSE
	// whm 12Jan2024 removed the test below and assignment of numWhites to augment ptr because ptr is already pointing
	// at the gSFexcapechar!!!
	if (ptr < pEnd && bIsEmptyMkr) // if (ptr < pEnd && bIsEmptyMkr && numWhites != 0)
	{
		//ptr += numWhites; // get past the <space> or newline (don't need to, but while developing,
			// the assert here is a useful check that ptr is now pointing a the backslash of next beginMkr
		wxASSERT(*ptr == gSFescapechar);

		bEnterLoop = TRUE;
		m_bWithinEmptyMkrsLoop = TRUE;
	}
	return bEnterLoop;
}

*/

/* BEW 15Aug23 removed this function, it produced a mess, and turns out to be not needed
// BEW 12Aug23 created. pChar has to be at the backslash of a beginMkr, if not so, return FALSE
bool CAdapt_ItDoc::ExitEmptyMkrsLoop(wxChar* pChar, wxChar* pEnd, wxString spacelessPuncts)
{
	wxChar* ptr = pChar;
	bool bExitLoop = FALSE;
	if (*ptr != gSFescapechar)
	{
		return bExitLoop;
	}
	// When should we return TRUE to have control utilize the legacy parsing code? Answer: when, after the
	// marker (or after verseNum if its \v marker), there is maybe some whitespace, and then no backslash,
	// and there is punctuation, or a wxChar which is parseable content.
	// (In AI, there are only words, puncts, markers, and whites)
	// So the lack of backslash tells us when to exit the emptyMkrs loop. In AI, we can detect parseable
	// content following a beginMkr only by presence of words or parseable digits, or punctuation. There is
	// no simple way to test for presence of a word, we can only do it by testing for the absence of something
	// at the test ptr location: it won't be a whitespace, nor a backslash; but it may be punctuation.

	// Note: LookupUSFM() is not required for figuring out when to break out of the loop - as above, backslash
	// is mainly significant for that.

	// This function does not parse, so pChar stays constant; and pSrcPhrase is ignored
	wxString wholeMkr = GetWholeMarker(ptr);
	wxASSERT(!wholeMkr.IsEmpty());
	wxString mkrTag = wholeMkr.Mid(1); // remove backslash
	int mkrLen = wholeMkr.Length();
	bool bEnterLoop = FALSE; // init
	int numberLen = 0;
	wxChar period = _T('.');
	ptr += mkrLen + 1; // +1 for an obligatory post-mkr white (either space or newline)
	// We would expect that users who are in the legacy parsing code, would not retain .. or ...
	// as Paratext adds randomly to some empty markers, but Bill tells me that sometimes they
	// do because they don't know what the dots are there and are afraid to remove them in case
	// they break something undocumented. So I'll retain the periods skipping tests.
	if (*ptr == period)
	{
		ptr++;
		// is there a second?
		if (*ptr == period)
		{
			ptr++;
			// is there a third?
			if (*ptr == period)
			{
				ptr++;
			}
		}
	}
	// After ptr, there may be a backslash, or some more whites then a backslash or not - so count 
	// spaces at ptr; but \c or \v is special - there will be a number to parse over in order to decide.
	int numWhites = CountWhitesSpan(ptr, pEnd); // usually returns 0 in this context, but not always
	ptr += numWhites;
	// handle \v or \c, if warranted
	// ptr now points after the marker and its following one (or maybe more) whitespace. We can't make a
	// decision whether or not to exit the contentless loop, if ptr was pointing at the chapterNum of \c
	// or verseNum of \v. So we have to determine if wholeMkr is \c or \v, and if either, then get past
	// the number (ParseNumber() is easiest way) and the following white(s), and then we can test for
	// presence or not of backslash following - if IsEmptyMkr() is FALSE, then bExitLoop = TRUE, else
	// stay in the loop for parsing contentless beginMkrs.
	if (wholeMkr == _T("\\v") || wholeMkr == _T("\\c"))
	{
		//Get past the number
		numberLen = ParseNumber(ptr);
		if (numberLen > 0)
		{
			ptr += numberLen;
		}
	}
	numWhites = 0; // for number of whites after the chapter or verse number
	int nPeriodsInWhitesLen = 0;
	bool bIsEmptyMkr = IsEmptyMkr(ptr, nWhitesLen, pEnd, nPeriodsInWhitesLen);
	if (numWhites > 0)
	{
		// something stopped the parse of whitespace chars
		ptr += numWhites; // what's now at ptr - if it's backslash, stay in the loop
	}

	// Now we can make our decision to exit the emptyMkrs loop, or have control remain in it.
	// bExitLoop is currently FALSE
	wxChar chAt = *ptr;
	if ( (ptr < pEnd && *ptr != gSFescapechar && !bIsEmptyMkr) || 
		 ( (ptr < pEnd && !IsWhiteSpace(ptr)) || (spacelessPuncts.Find(chAt) >= 0)) )
	{
		bExitLoop = TRUE;
		//if ((*ptr != gSFescapechar || (spacelessPuncts.Find(chAt) >= 0)) && !IsWhiteSpace(ptr))
		//{
		//	bExitLoop = TRUE;
		//}
	}
	return bExitLoop;
}
*/
	// IsTextAtPChar is required for our new parsing loop. Call when pChar points at a beginMkr, whether from
	// the Blue beginMkr set, or the Red beginMkr set, but not from the EmbeddedIgnore beginMkr set (\f etc).
	// Out parsing loop will want to check when what's at pChar is actually a contententless beginMkr, and while
	// more than one thing will be tested, a key sub-test is that IsTextAtPChar is not parseable word or number
	// src data. If two or 3 periods are detected, we parse ptr over those (but not storing them), and return
	// in pNewPtr what new pChar* value should be updated to in the caller. E.g. \p<space>... should become 
	// \p<space> and pNewPtr set to be after the <space>

bool CAdapt_ItDoc::IsTextAtPChar(wxChar* pChar, wxChar* pEnd, wxString spacelessPuncts, wxChar*& pNewPtr) // <<-- remove later, its not needed
{
	pNewPtr = NULL; // init (if unset, then there were no .. or ... sequences in the test span
	wxChar* ptr = pChar;
	int offset = -1; wxUnusedVar(offset); // avoid compiler warning variable initialized but not referenced
	bool bIsPunct = FALSE; wxUnusedVar(bIsPunct); // avoid compiler warning variable initialized but not referenced
	bool bIs1Period = FALSE; wxUnusedVar(bIs1Period);
	bool bIs2Periods = FALSE; wxUnusedVar(bIs2Periods);
	bool bIs3Periods = FALSE; wxUnusedVar(bIs3Periods); // avoid compiler warning variable initialized but not referenced
	wxString periods1 = _T(".");
	wxString periods2 = _T("..");
	wxString periods3 = _T("...");
	wxString strPeriods = wxEmptyString;
	// First, check if ptr has come to one, two or three periods. That only happens for contentless markup,
	// so bleed out this possibility first, and return FALSE after advancing ptr over them
	if (*ptr == _T('.'))
	{ 
		// ptr is at a period, or maybe at two or three - check; treat all 3 possibilites alike,
		// because period is not text, and it does not constitute initial punctuation before a word or
		// or before a parseable non-verseNumber digits string
		int nPeriodCount = 1;
		wxChar* pAux = ptr + 1; // point at next char
		if (*pAux == _T('.'))
		{
			// we've found .. so far
			bIs2Periods = TRUE;

			// Check next char, for a third period
			// whm 23Sep2023 corrected the if () below had assignment = instead of equality test == 
			if (*(pAux + 1) == _T('.'))
			{
				// there is a 3rd period
				nPeriodCount = 3;
				strPeriods = periods3;
			}
			else
			{
				nPeriodCount = 2;
				strPeriods = periods2;
			}
		}
		else
		{
			// one period is all there is
			bIs1Period = TRUE;
			strPeriods = periods1;
		}
		wxASSERT(!strPeriods.IsEmpty());
		// When periods are at ptr - the calling loop should stop scanning when pNewPtr is NOT
		// null, (int)(pNewPtr - pChar) will give the length of the periods, so add to len after
		// updating ptr to pNewPtr, and throwing away the periods before returning the adjusted
		// len to TokText(), and that should force the next beginMkr to be on next pSrcPhrase
		pNewPtr = (ptr + nPeriodCount);
		return FALSE; // because after 1,2 or 3 periods, ptr is not at any words content

	} // end of TRUE block for test: if (*ptr == _T('.'))
	else
	{
		// ptr is not pointing at a period, or 2 or 3 of them.
		// This function does not scan. It only checks what's at ptr. It gets called from a
		// scanning loop, and if the loop advances ptr to a word or non-verseMkr digits, then
		// the control will break from the caller's loop, and return TRUE; otherwise the loop
		// will loop over the contentless markup - until a marker of sufficient weight stops
		// the accumulation of contentless markers in m_markers. Getting to \v will always
		// force a new pSrcPhrase, and parsing of the verseNumber.
		if ((ptr < pEnd) && (*ptr != gSFescapechar) && !IsWhiteSpace(ptr) && (spacelessPuncts.Find(*ptr) == wxNOT_FOUND))
		{
			// ptr is not at doc end, and ptr is not at a backslash, nor is at whitespace, nor at punctuation
			// which is not . or .. or ... So all conditions for the caller to keep scanning are fulfilled,
			// so return FALSE
			return FALSE;
		}
		else
		{
			// Found subtests, any one of 2nd, 3rd or 4th failing we have to give
			// guidance to the calling loop.
			if (*ptr == gSFescapechar)
			{
				// This is very important. Reaching a backslash means we have come to a marker
				// before getting to the start of a word, so the caller must determine what to
				// do - it might be the backslash of a \v marker, not yet parsed; or one later
				// on that lies ahead of characters scanned over - the caller has to decide 
				return FALSE;
			}
			if (IsWhiteSpace(ptr))
			{
				// Ambiguous situation. The whitespace may be a verseNumber after an earlier parsed 
				// \v marker,  or it might be a \v marker at the start of the caller's loop; or
				// it might be whitespace before a word or a word with beginning punctuation, eg. “
				// Let the caller work out what to do.
				return FALSE;
			}
			else
			if (spacelessPuncts.Find(*ptr) >= 0)
			{
				// We know *p cannot be pointing at a period - we bled that option out above. So
				// we can assume that ptr is pointing at a word-initial punctuation character.
				// So return TRUE
				; //  wxNO_OP; whm removed since gcc says "statement had no effect"
			}
		}
	}
	return TRUE;
}

// BEW added 11Jul23 for use inParsePostWordPunctsAndEndMkrs(), return the string of consecutive
// m_key values, space-separated, from the pSrcPhrase at indexFirst, and ending at indexLast
wxString CAdapt_ItDoc::GetAccumulatedKeys(SPList* pList, int indexFirst, int indexLast)
{
	// nHowMany ??
	int nHowMany = indexLast - indexFirst + 1; // e.g. 3,4,5,6,7 is 5; 7-3 = 4, so +1 makes 5
	wxUnusedVar(nHowMany);
	wxString strAccumulated;
	strAccumulated = wxEmptyString;
	int index;
	index = indexFirst;
	SPList::Node* pos_pList = pList->Item(index);

	CSourcePhrase* pSP;
	wxString key;
	pSP = (CSourcePhrase*)pos_pList->GetData();
	key = pSP->m_key;
	wxChar chSpace;
	chSpace = _T(' ');
	strAccumulated << key;
	strAccumulated << chSpace;

	pos_pList = pos_pList->GetNext();
	index++;

	while (index < indexLast)
	{
		pSP = (CSourcePhrase*)pos_pList->GetData();
		key = pSP->m_key;
		wxChar chSpace;
		chSpace = _T(' ');
		strAccumulated << key;
		strAccumulated << chSpace;

		index++;
		pos_pList = pList->Item(index);
	}
	return strAccumulated;
}

// BEW 14Aug23, parses over whites at pChar and returns TRUE if backspace follows, and the 
// length of span up to but not including the backslash; else FALSE and return -1 for nWhitesLen
// - a backslash must be at least one white further on than pChar
// 
// whm 12Jan2024 modified to be called BEFORE creation of a new CSourcePhrase. This modification
// requires that pChar be pointing at a marker on entry. 
// This function now detects whether the marker at pChar is a chapter \c n marker or a verse \v n
// marker, and if so, it parses over the marker and following number before testing if there is
// a following backslash or pEnd. Once the marker is fully parsed over, it determines if a 
// backslash or pEnd follows. If so, then it is an empty marker.
// 
// whm 15Jan2024 observation and further modifications.
// Observation: I noticed that the presence of periods after a \p marker would prevent the
// IsEmptyMkr() from correctly determining whether the marker at pChar was really an empty
// marker when the \p marker was followed by .. or ... etc. 
// Modifications made 15Jan2024: 
// I decided to modify IsEmptyMkr() to look past any periods that occurred prior to 
// any EOL whitespace chars, and ignore them for purpposes of determining whether the
// marker was an empty one or not. In the process of ignoring any periods encountered, I
// also felt it would be good to return to the caller via reference parameter some bool
// and int variables that would signal to the caller of the presence of bogus periods 
// that need to be dealt with by the caller, and how many were encountered before any 
// EOLs or backslash or pEnd, as well as the total length of the whites following the
// marker with bogus periods. The reference variables returned are:
//    bool bHasBogusPeriods - there are bogus periods to process for the m_paragraphMkrs
//		marker and/or chapter marker that is excluded from being treated as an empty marker.
//    int nWhitesLenIncludingBogusPeriods - the number of whites + bogus periods following
//		the marker. 
//    int nPeriodsInWhitesLen - the number of periods within the whites followoing the 
//		marker.
// These variables returned by IsEmptyMkr() will inform TokenizeText() that there are 
// bogus periods to process (skip over/ignore) in the main TokenizeText() body for the 
// paragraph class marker and/or chapter marker being parsed in the main body. 
// They also inform the code in the if (bProcessEmptyMarker) TRUE block of the same 
// situation, so it can also process any bogus peiods that were found in empty markers
// that are non-paragraph and/or non-chapter markers.
// Note: The empty markers processing block no longer has a while loop within it, but is
// now a much more compact block that begins at the TRUE block of if (bProcessEmptyMarker)
// just after the call of this IsEmptyMkr() function.
// This IsEmptyMkr() function is now called only once within TokenizeText().
bool CAdapt_ItDoc::IsEmptyMkr(wxChar* pChar, wxChar* pEnd, 
	bool& bHasBogusPeriods, int& nWhitesLenIncludingBogusPeriods, int& nPeriodsInWhitesLen)
{
	wxChar* p = pChar;
	nWhitesLenIncludingBogusPeriods = 0;
	nPeriodsInWhitesLen = 0;
	int nFollowingWhitesLen = 0;
	int itemLen = 0;
	wxString chapterMkr = _T("\\c");
	wxString verseMkr = _T("\\v");
	if (IsMarker(p))
	{
		itemLen = ParseMarker(p);
		wxString mkr = wxString(p, itemLen);
		if (mkr == chapterMkr || mkr == verseMkr)
		{
			// it's a \c or \v marker so parse the following space and number
			p += itemLen;
			itemLen = ParseWhiteSpace(p);
			p += itemLen;
			itemLen = ParseNumber(p);
		}
		// update p to point past the marker 
		p += itemLen;
	}
	// parse through any following whitespace
	// whm 15Jan2024 modified. 
	// At this point after parsing the marker there may be a space followed by one or
	// more periods before reaching a following backslash character (of a following marker).
	// To accurately determine if this marker is "empty" or not we need to count, but pass
	// over any periods we encounter on the way as we look for a following backslash.
	// We will assume that any such bogus periods would occur BEFORE a following EOL, 
	// otherwise they should probably be considered part of some text following the
	// marker on a new line and thus would be part of some ellipsis or other punctuation
	// in the text itself.
	// First parse over the normally occurring space after the marker. This could include
	// EOLs but not periods, within the whitespace parsed by ParseWhiteSpace(p).
	nWhitesLenIncludingBogusPeriods = ParseWhiteSpace(p);
	wxString whitesStr = wxString(p, nWhitesLenIncludingBogusPeriods);
	wxString period = _T(".");
	wxString eolCR = _T("\r");
	wxString eolLF = _T("\n");
	bool bNeedToCheckForPeriods = FALSE;
	// Check whether the whitesStr contains any EOLs, if so we need not deal with any
	// periods following the marker. If not, however, we need to check further after
	// the whitesStr location if there are any periods before the following EOLs or
	// a backslash (of a marker).
	if (whitesStr.Find(eolCR) != wxNOT_FOUND && whitesStr.Find(eolLF) != wxNOT_FOUND)
	{
		// There is at least one EOL char present within the whitesStr after the marker,
		// so we need not check for periods since, if they exist, they would be on a
		// subsequent line of text and we shouldn't count such periods as bogus.
		bNeedToCheckForPeriods = FALSE;
		// nWhitesLen is not changed in this block, but we increment p to point past it
		p += nWhitesLenIncludingBogusPeriods;
	}
	else
	{
		// There are no EOL chars present within the whitesStr after the marker,
		// so we need to advance p over the whitespeace and check further to see 
		// if the next character(s) is/are period(s).
		p += nWhitesLenIncludingBogusPeriods; // point past the whitesLen following the marker
		if (p < pEnd && *(p) == period)
		{
			// There is at least one period following the marker BEFORE any EOL or
			// or backslash, so set flag to count them
			bHasBogusPeriods = TRUE;
			bNeedToCheckForPeriods = TRUE;
		}
		if (bNeedToCheckForPeriods)
		{
			int countPs = 0;
			while (p < pEnd && *p == period)
			{
				countPs++;
				p++;
			}
			nPeriodsInWhitesLen = countPs;
			nWhitesLenIncludingBogusPeriods += nPeriodsInWhitesLen; // includ in nWhitesLen the number of periods
			//p += nPeriodsInWhitesLen; // point past the periods
			// There may be more whitespace or EOLs after the periods before reaching a
			// backslash or pEnd
			nFollowingWhitesLen = ParseWhiteSpace(p);
			p += nFollowingWhitesLen;
		}
	}

	// Return the total length in nWhitesLen including spaces EOLs and any periods
	// The caller can use the returned value of nWhitesLen to locate the following
	// backslash marker directly.
	// The caller can use the returned value of nPeriodsInWhitesLen to determine
	// whether periods need to be removed by the caller and properly process its
	// ptr value in ignoring the periods and increment the ptr to the next location
	nWhitesLenIncludingBogusPeriods = nWhitesLenIncludingBogusPeriods + nPeriodsInWhitesLen + nFollowingWhitesLen;

	// p += nWhitesLen; // p was incremented in the blocks above past any whitespace (including 
	// any embedded bogus periods)

	// Finally, we can now determine whether it is an empty marker or not.
	if (*p == gSFescapechar || p == pEnd) // whm 12Jan2024 added pEnd test
	{
		// Yes, it's an empty marker
		return TRUE;
	}
	else
	{
		// No, it's not an empty marker, after whitespace(s) there is not the backslash of a beginMkr
		nWhitesLenIncludingBogusPeriods = 0; // -1;
		m_bWithinEmptyMkrsLoop = FALSE;
	}
	return FALSE;
}

// whm 17Jan2024 added to iterate the ptr past bogus periods when the ptr is
// pointing at a period.
void CAdapt_ItDoc::IteratePtrPastBogusPeriods(wxChar*& ptr, wxChar* pEnd, int& nPeriods)
{
	int numP = 0;
	while (ptr < pEnd && *ptr == _T('.'))
	{
		ptr++;
		numP++;
	}
	nPeriods = numP;
}

/*
bool CAdapt_ItDoc::SkipParseAWord(wxChar* pChar, wxChar* pEnd)
// BEW 28Jul23 removed, not a viable solution - I'll eliminate successive puncts as found, in loop at 19443
// BEW 26Jul23, if \h or some other marker in source text which is content-less yet, except for markers * verse numbers,
// has \h or some other followed by space and then some successive periods (seen in data so far .. or ... and is rare), then
// allowing ParseAWord() to parse the periods will, because they are puncts, not advance ptr leading to an assert.
// This Skip... function is a hack to get ptr advance safely past the ParseAWord() call. Use it when LookupSFM()
// finds a \h or other marker, with successive periods only. Put their count in the new member variable
// doc::m_nHowManyPeriods - as this boolean and count will be required just prior to the call of ParseAWord().
// BEW 27Jul23 Bill has found other .sfm files with bogus periods string (usually ...), for various other markers:
// they are Paratext-produced, undocumented, and a nuisance. He's found so far, \pi, \m, \q1, \, and \b.
// So I am generalizing SkepParseAWord to test not just \h, but every marker. I've put a new Doc.h wxString called
// m_strSkipMkr to use for storing the marker that exhibits a periods sequence, so ParseWord() can store the correct
// marker in m_markers when doing a skip of ParseAWord()
bool CAdapt_ItDoc::SkipParseAWord(wxChar* pChar, wxChar* pEnd)
{
	wxChar* ptr = pChar;
#if defined (_DEBUG)
	wxString atPChar = wxString(pChar, 24);
	wxLogDebug(_T("SkipParseAWord(), line %d , ENTERED, next 24 atPChar= [%s]"), __LINE__, atPChar.c_str());
#endif
	m_bSkipRequired = FALSE; //int, Doc.h member bool for storing what is returned here
	// Sanity test:  on entry, pChar must be pointing at gSFescapechar, and getting the marker at ptr gets
	// \h  If that is not the marker, then we don't test for periods, and return FALSE and 0 for how many periods
	if (ptr < (pEnd - 8) && *ptr == gSFescapechar) // pEnd - 8 ensures there's space for a beginMkr at doc end
	{
		// Okay so far
		m_nHowManyPeriods = 0; // init to default value
		m_strSkipMkr = wxEmptyString; // init
		int mkrLen = 0; // init
		wxChar period = _T('.');
		wxString wholeMkr;
		int offset = wxNOT_FOUND;
		wxChar asterisk = _T('*');
		wxChar last;
		wholeMkr = GetWholeMarker(ptr);
		wxASSERT(!wholeMkr.IsEmpty());
		mkrLen = wholeMkr.Length();
		last = wholeMkr.GetChar(mkrLen - 1);
		if (last == asterisk)
		{
			// ptr is pointing at the backslash of an endMkr, so return FALSE
			return FALSE;
		}
		// Okay, we know we are dealing with a beginMkr. BeginMkrs have a width
		// and must be followed by a single space before their content starts,
		// so advance ptr to point at the content
		ptr += mkrLen + 1;
		// Store the beginMkr, pending possible use in ParseWord()
		m_strSkipMkr = wholeMkr; // let ParseWord add the extra space if storing it to m_markers
		if (*ptr != period)
		{
			// content needs to start with a period, to qualify for testing for two or more
			m_nHowManyPeriods = 0;
			m_strSkipMkr.Empty();
			return FALSE;
		}
		else
		{
			// It's a beginMkr, where the content starts with period. Check for two or more. 
			//wxChar* pSavePtr = ptr;
			// Loop over successive characters, keep looping so long as period is found, and halt
			// the loop when whitespace is found. Count how many. Result could be 0, or non-zero.
			// Beware, period/s may be followed by non-periods before whitespace ends the loop, so
			// count also how many iterations there were till whitespace ends the loop. If the
			// Count of iterations exceeds the count of periods, then return FALSE, so that
			// ParseAWord() can parse the periods and following characters.
			int countIterations = 0;
			int countPeriods = 0;
			while (!IsWhiteSpace(ptr))
			{
				countIterations++;
				if (*ptr == period)
				{
					countPeriods++;
				}
			} // end of while loop
			// If the periods span end with whitespace, the loop will exit with a count of the periods.
			// If there is non-period content following the periods, ParseAWord() can handle that
			// without choking, and the non-period content gives a larger span for countIterations than
			// the span for countPeriods. Test for countIterations span equalling countPeriods span. If
			// the same length, return TRUE and set nHowManyPeriods to countPeriods. 
			// Be aware: when doing the skip in ParseWord(), nHowManyPeriods length does not contain
			// the width of the beginMkr, nor +1 for the whitespace following the marker. But that
			// information can be recovered from m_strSkipMkr, provided ParseWord() reads m_bSkipRequired
			// as TRUE
			if (countIterations == countPeriods)
			{
				// Give Doc.h the values needed at the current pSrcPhrase when ParseAWord is about to be called
				m_nHowManyPeriods = countPeriods;
				m_bSkipRequired = TRUE; // ParseWord() will read this value, and do the skip functionality
#if defined (_DEBUG)
				wxLogDebug(_T("SkipParseAWord(), line %d , countPeriods %d , m_bSkipRequired= %d , for Mkr= [%s], countIterations= %d"),
					__LINE__, countPeriods, (int)m_bSkipRequired, m_strSkipMkr.c_str(), countIterations);
#endif
				return TRUE;
			}
		} // end of else block for test: if (*ptr != period)
	} // end of TRUE block for test: if (ptr < (pEnd - 6) && *ptr == gSFescapechar)

	// Making the hack failed, or looking for find successive periods only is not warranted
	m_nHowManyPeriods = 0;
	m_strSkipMkr.Empty();
	m_bSkipRequired = FALSE; // ParseWord() will read this value and not skip
	return FALSE;
}
*/
/*  BEW 19Nov22 I don't think I need this - deprecate - we handle instead in ParseWord()
// BEW 19Nov22 Added, for use in RemovePunctuation() because we do NOT want to remove '(' or '{' or '['
// in RemovePunctuation() when there is no space before or after any of these. We want to be able to
// store in the KB a string like  "word(plural" or "word(word1 word2" when these are from   "word(plural)" 
// or "word(word1 word2)". what makes them "internal" is that the wxChar either side is not a punctuation
// character - and that will be the basis of our test
bool CAdapt_ItDoc::IsOpenParenBraceBracketWordInternal(wxChar* pChar, wxChar* pEnd, wxString punctsSet)
{
	// no loop involved, we call this on every wxChar scanned in its caller
	wxChar* ptr = pChar;
	if (ptr < pEnd)
	{
		wxChar paren = _T('('); wxChar brace = _T('{'); wxChar bracket = _T('[');
		wxChar* pLast = (ptr - 1); wxChar* pNext = (ptr + 1);
		bool bLastIsPunct = punctsSet.Find(*pLast) >= 0 ? TRUE : FALSE;
		bool bNextIsPunct = punctsSet.Find(*pNext) >= 0 ? TRUE : FALSE;

		if ( (*ptr != paren) && (*ptr != brace) && (*ptr != bracket) )
		{
			// It's none of these 3 so return FALSE
			return FALSE;
		}
		else
		{
			// One of them is pointed at by ptr - test the most likely first, probably { is least likely
			if (*ptr == paren)
			{
				// ptr points at '(', return FALSE if either boolean (or both) is TRUE
				if (bLastIsPunct || bNextIsPunct)
				{
					return FALSE;
				}
			}
			else if (*ptr == brace)
			{
				// ptr points at '{', do as above
				if (bLastIsPunct || bNextIsPunct)
				{
					return FALSE;
				}
			}
			else
			{
				// must be that ptr points at '['
				if (bLastIsPunct || bNextIsPunct)
				{
					return FALSE;
				}
			}
		}
		// If control gets to here, it qualifies for not being removed in RemovePuncts(), it's word-internal
	}
	return TRUE;
}
*/

int CAdapt_ItDoc::ParsePreWord(wxChar* pChar,
	wxChar* pEnd,
	CSourcePhrase* pSrcPhrase,
	wxString& spacelessPuncts, // caller determines whether it's src set or tgt set
	wxString& inlineNonbindingMrks, // fast access string for \wj \qt \sls \tl \fig
	wxString& inlineNonbindingEndMrks, // for their endmarkers \wj* etc
	bool& bIsInlineNonbindingMkr,
	bool& bIsInlineBindingMkr,
	bool bTokenizingTargetText)
{
	// BEW 30Sep19 With the separation of ParsePreWord() from legacy ParseWord, each
	// of these has some unreferenced variables. To avoid compiler variables, use 
	// wxUnusedVar() for those which are not now referenced
	wxUnusedVar(inlineNonbindingEndMrks);
#if defined (_DEBUG) && !defined(NOLOGS)
	if (pSrcPhrase->m_nSequNumber >= 1)
	{
		int halt_here = 1; wxUnusedVar(halt_here);
	}
	wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_key= [%s] , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
		__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
	wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

	int len = 0;
	wxChar* ptr = pChar;
	bool bAllowPunctChangeBlock = FALSE;
	// BEW 14Jul14, prior to this date, ParseWord would parse over any trailing whitespace
	// at the end of the "word" (meaning, and markers and endmarkers, and preceeding and
	// following and/or following outer, punctuation, and any internal to such structures
	// spaces, and any outer punctuation such as curly quotes outside of curly quotes), but
	// from now on we want the length value returned to the caller to just be the length of
	// the parsed material as far as the START of the trailing whitespace which delimits the
	// boundary between two successive "words" - because we want the called, TokenizeText()
	// at the start of its parse loop to intercept and store in pSrcPhrase->m_srcWordBreak
	// wxString member whatever the whitespace(s) char(s) is/are which precede each word.
	// By storing them, we can use them to restore the whitespace types in the translation
	// text at USFM marked up translation export time. So our approach below is to look for
	// each place where len is returned, and prior to it, insert code which will backtrack
	// the ptr till it points at the first character of any immediately preceding whitespace,
	// and decrement the len value accordingly, and then return it.

	int itemLen;
	wxString emptyStr = _T("");
	wxString aSpace = _T(" ");
	wxString usfmFixedSpace = _T("~"); // USFM fixedspace symbol
	USFMAnalysis* pUsfmAnalysis = NULL;
	wxString bareMkr;
	wxString bareEndMkr;
	wxString wholeMkr;
	wxString wholeEndMkr;
	wxString wholeMkrPlusSpace;
	bool bExitParseWordOnReturn = FALSE;
	wxUnusedVar(bExitParseWordOnReturn);
	int nFound = wxNOT_FOUND;
	bool bHasPrecPunct = FALSE;
	//bool bHasOpeningQuote = FALSE; // set but not used
	bool bParsedInlineBindingMkr = FALSE;
	wxString finalPunctBeforeFixedSpaceSymbol;
	wxString precedingPunctAfterFixedSpaceSymbol;
	finalPunctBeforeFixedSpaceSymbol.Empty();
	precedingPunctAfterFixedSpaceSymbol.Empty();
	CSourcePhrase* pSrcPhrWord1 = NULL;
	wxUnusedVar(pSrcPhrWord1);
	CSourcePhrase* pSrcPhrWord2 = NULL;
	wxUnusedVar(pSrcPhrWord2);
	int nHowManyWhites = 0;
	wxUnusedVar(nHowManyWhites);
	//wxChar* pMaybeWhitesStart = NULL; // set but not used
	wxChar* pMaybeWhitesEnd = NULL;
	wxUnusedVar(pMaybeWhitesEnd);
	wxString wordBuildersForPreWordLoc;
	wxString wordBuildersForPostWordLoc; wordBuildersForPostWordLoc.Empty();
	// next pair for use with the second word in a conjoined pair, when a punct is being
	// restored to word-building status
	wxString wordBuildersFor2ndPreWordLoc;
	wxString wordBuildersFor2ndPostWordLoc; wordBuildersFor2ndPostWordLoc.Empty();
	// next pair for use with the second word in a conjoined pair, when a word-building
	// character has just been made a punct character
	wxString newPunctFrom2ndPreWordLoc;
	wxString newPunctFrom2ndPostWordLoc; newPunctFrom2ndPostWordLoc.Empty();
	// BEW 24Oct14 added next two lines for USFM nested marker support when parsing
	wxString tagOnly;
	bool bIsNestedMkr = FALSE;
	wxString baseOfEndMkr;

	// BEW 23Mar23 pass an isolate backslash on to let ParseWord() handle it before ParseAWord() gets called
	if ((*ptr == gSFescapechar) && (*(ptr + 1) == _T(' ')))
	{
		len = 0;
		return len;
	}
	if (pSrcPhrase->m_nSequNumber >= 3)
	{
		int halt_here = 1; wxUnusedVar(halt_here);
	}

// #if defined (_DEBUG) && defined (LOGMKRS)
//		wxLogDebug(_T("1. Within %s::%s(), line %d , m_bWithinMkrAttributeSpan = %d"),
//			__FILE__, __FUNCTION__, __LINE__, (int)m_bWithinMkrAttributeSpan);
////#endif
	// BEW added test 21Mar17
	if (len == 0 && ptr == pEnd)
	{
		return len;
	}
#if defined (_DEBUG) && !defined(NOLOGS)
	if (pSrcPhrase->m_nSequNumber >= 3)
	{
		int halt_here = 1;
		wxUnusedVar(halt_here);
	}
#endif
//#if defined (_DEBUG) && !defined(NOLOGS)
	//	wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
	//		__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
//#endif
	wxString aMkr = wxEmptyString;
	bool bIsInlineBeginMkr = FALSE;

	// BEW 24Jun23, control getting to this point with bIsInlineNonbindingMkr TRUE is not much tested
	// because few are the markers of that set; \sls or \+sls use used much in some docs, where a second
	// language of the OT is used in the NT (somtimes in footnote, but can be elsewhere). Earlier, these
	// begin markers will have been lookedup, and stored in m_inlineNonbindingMarkers of pSrcPhrase. ptr
	// will have been moved on, and no longer points at the marker. The test:if (bIsInlineNonbindingMkr)
	// is TRUE, the legacy block at 16998 will be entered, LookupUSFM() called at a non-mkr location, and
	// would crasth the app. So a bit of preventive code is needed here.
	if (bIsInlineNonbindingMkr)
	{
		// check ptr is pointing at the backslash of a marker, if not, reset the boolean to FALSE
		if (*pChar != gSFescapechar)
		{
			bIsInlineNonbindingMkr = FALSE;
		}
	}

	if (bIsInlineNonbindingMkr)
	{
		// BEW 30Sep19 bleed out the \fig special case
		bool bIsFigure = (aMkr == _T("\\fig"));
		if (bIsInlineBeginMkr && bIsFigure)
		{
			wxString wholeMkr = aMkr;
			wxASSERT(!wholeMkr.IsEmpty());
			wxString wholeMkrPlusSpace = wholeMkr + aSpace;
			itemLen = wholeMkr.Len() + 1;
			// store the whole marker, and a following space
			pSrcPhrase->SetInlineNonbindingMarkers(wholeMkrPlusSpace);
			ptr += itemLen;
			len += itemLen;
			wxASSERT(pSrcPhrase->m_bSpecialText == TRUE);
			wxASSERT(pSrcPhrase->m_bFirstOfType == TRUE);
			wxASSERT(pSrcPhrase->m_curTextType == noType);
			itemLen = 0; // it's the len variable that is returned, not itemLen
		}
		else
		{
			// legacy code

			// The first possibility to deal with is that we may be pointing at an inline
			// non-binding begin marker, there are 5 such, \wj \qt \sls \tl \fig, and the caller will
			// have provided a boolean telling us we are pointing at one.

			// BEW 30Sep19 The case where marker is \fig has been excluded here because of the 
			// addition of the TRUE block above.
			//
			// BEW 24Oct14, the caller knows about nested markers too, and \+wj etc are in the
			// appropriate rapid access strings, so can be looked up directly
			// we are pointing at one of these first four markers, handle this situation...

			// BEW 13Mar20 refactoring needed below, for the \jmp ... \jmp* markers, and \+jmp ... \+jmp*
			// markers. These pairs need to be stored alike (in m_markers and m_endMarkers), not in
			// m_inlineNonbindingMarkers and m_inlineNonbindingEndMarkers storage, because those markers
			// are (correctly) NOT in the fast-access strings for binding or non-binding markers or
			// endmarkers, so they qualify for storage in the same places the \f ... \f*, and \x ... \x*
			// get stored.
			// Furthermore, when the embedded pair occur, \+jmp ... \+jmp*, the parser must not treat
			// them like it does the non-embedded pair, \jmp ... \jmp*. Embedding is a problem for the
			// parser, for the \+jmp ... \+jmp*, and AI_USFM only has an entry for \jmp and endmkr \jmp*.
			// So, differentiating behaviours is up TokenizeText() and its called functions to do with
			// some internal code hacks.
			// The behaviour wanted  for the embedded pair is that the filtered status is not obtained
			// by a lookup of AI_USFM, after removal of the +, because that only makes \+jmp behave
			// the same as \jmp, where \jmp is default filtered, and inform and navigationText are
			// empty strings. Instead, presence of + will be used to set an app boolean: m_bIsEmbeddedJmpMkr
			// to TRUE - and with that we can do tests that allow code hacks at various places so as to
			// get behaviours different from those for \jmp ... \jmp*. 
			// So, for the embedded marker pair, we want \+jmp and \+jmp* to take on the behaviours of their
			// parent spans - whether filtered or not, and whether a footnote, or a cross reference span.
			//
			// Also, we alter the looked up struct (have to use \jmp, \+jmp is not in AI_USFM.xml) to add
			// inform="1", and navigationText="jmp-link" - so that if the parent span is NOT filtered, 
			// the navigation text whiteboard will write memaningful content for the user's benefit.
			//
			// charAttributeMkrs and charAttributeEndMkrs fast access strings are not changed, and these
			// have both \jmp and \+jmp in the one, and their matching endmarkers in the other. This is
			// necessary because these two fast access strings govern the caching, or non-caching, or
			// of any attributes metadata - done near the beginning of TokenizeText() so that when hiding
			// of cached metadata is required, the metadata is available in members of the doc class.
			// This caching and subsequent hiding of bar-initial metadata operates independently of
			// decisions about marker storage and behaviour differences - for embedded versus non-embedded.
			//
			// When there is no embedding, that is, \jmp and \jmp* are used, the behaviours for these
			// are taken from the struct returned by a lookup of AI_USFM.xml - which returns whether
			// or not the marker content is to be filtered out, and inform and navigationText are empty.
			// The app's Preferences.. Filtering & USFM page shows the setting for \jmp
			gpApp->m_bIsEmbeddedJmpMkr = FALSE; // initialize
#if defined (_DEBUG) && !defined(NOLOGS)
			if (pSrcPhrase->m_nSequNumber >= 6)
			{
				int halt_here = 1;
				wxUnusedVar(halt_here);
			}
#endif
			pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr); // BEW 24Oct14 overload
			wxASSERT(pUsfmAnalysis != NULL); // must not be an unknown marker
			// In the release version, force a document creation error, and hence a halt with a warning
			if (pUsfmAnalysis == NULL)
			{
				return -1; // unexpected error, all inLine markers are known to Adapt It
			}
			// BEW 24Oct14, use the two new params of LookupSFM to construct the marker which
			// is to be stored
			if (baseOfEndMkr.IsEmpty())
			{
				// It's not an endmarker; good, as ParseWord() is the handler of end markers
				if (bIsNestedMkr)
					bareMkr = _T('+');
				else
					bareMkr.Empty();
				bareMkr += pUsfmAnalysis->marker; // bareMkr is now mkr or +mkr, for whatever mkr is
			}
			wholeMkr = gSFescapechar + bareMkr;
			wholeMkrPlusSpace = wholeMkr + aSpace; // begin markers are handled by ParsePreWord()

			// BEW 14Mar20 add a hack here to deal with differentiating \+jmp from \jmp
			// according to the protocols in the extended comment 30 lines above
			if (!aMkr.IsEmpty() && bIsInlineBeginMkr && (pUsfmAnalysis->marker == _T("jmp")))
			{
				// If control enters here, the code just above will have produced either \jmp
				// or the nested variant, \+jmp  Which is the case?  We will store \jmp
				// in the CSourcePhrase member provided for "inline non-binding markers";
				// but \+jmp in m_markers because it is almost certainly in a footnote span
				// (or endnote span) or a cross-reference span - and these and their internal
				// markers are stored in m_markers. Similarly, endmarkers will be stored
				// differently, \jmp* in "inline non-binding end markers" member, but \+jmp
				// in m_endMarkers
				// We must bleed the \jmp & \+jmp cases here, because they belong in the
				// charAttributeMkrs fast access string used below
				if (bIsNestedMkr)
				{
					wxASSERT(aMkr == wxString(_T("\\+jmp")));
					gpApp->m_bIsEmbeddedJmpMkr = TRUE;

				}
				else
				{

					wxASSERT(aMkr == wxString(_T("\\jmp")));
					gpApp->m_bIsEmbeddedJmpMkr = FALSE;
				}
				// okay, use the gpApp->m_bIsEmbeddedJmpMkr value in the block below
#if defined (_DEBUG) && defined (LOGMKRS)
								wxLogDebug(_T("4. Within %s::%s(), line %d , m_bWithinMkrAttributeSpan = %d"),
									__FILE__, __FUNCTION__, __LINE__, (int)m_bWithinMkrAttributeSpan);
#endif
			}
			bareMkr = emptyStr;


			// BEW 30Sep19, we need to take USFM3 character attribute markers into
			// consideration, such as \ef and \ef* and others, but handle\jmp or \+jmp 
			// differently; because when storing these we treat them as belonging to the
			// inline non-binding markers set - except for the \+jmp ... \+jmp pair,
			// which take their cue from where their parent spans are stored
			wxASSERT((inlineNonbindingMrks.Find(wholeMkrPlusSpace) != wxNOT_FOUND)
				|| (charAttributeMkrs.Find(wholeMkrPlusSpace) != wxNOT_FOUND));

			// In the release version, force a document creation error, and hence a halt with a warning
			if (!gpApp->m_bIsEmbeddedJmpMkr &&
				((inlineNonbindingMrks.Find(wholeMkrPlusSpace) == wxNOT_FOUND)
					&& (charAttributeMkrs.Find(wholeMkrPlusSpace) == wxNOT_FOUND)))
			{
				return -1; // unexpected error, the beginMkr is not in either fast access string
			}

			itemLen = wholeMkr.Len();
			// store the whole marker, and a following space
			if (gpApp->m_bIsEmbeddedJmpMkr)
			{
				pSrcPhrase->m_markers += wholeMkrPlusSpace;;
			}
			else
			{
				wxString currContents = pSrcPhrase->GetInlineNonbindingMarkers();
				currContents += wholeMkrPlusSpace;
				pSrcPhrase->SetInlineNonbindingMarkers(currContents);
			}
			wxUnusedVar(inlineNonbindingMrks); // avoid compiler warning

			// point past the inline non-binding marker, or \+jmp marker, and then
			// parse over the white space following it, and point past that too
			ptr += itemLen;
			len += itemLen;
			itemLen = ParseWhiteSpace(ptr);
			ptr += itemLen;
			len += itemLen;
			wxASSERT(ptr < pEnd);
			// In the release version, force a document creation error, and hence a halt with a warning
			if (ptr > pEnd)
			{
				return -1; // ptr out of bounds error
			}

		} // end of else block for test: if (bIsInlineBeginMkr && bIsFigure)
#if defined (_DEBUG) && !defined(NOLOGS)
		wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

	} // end of TRUE block for test: if (bIsInlineNonbindingMkr)
	else
	{
		// we are not pointing at one of the five inline non-binding begin-markers
		pSrcPhrase->SetInlineNonbindingMarkers(emptyStr);
	}
#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
	wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

	// What might ptr be pointing at now? One of the following 3 possibilities?:
	// 1. punctuation which needs to be stored in m_precPunct, or
	// 2. an inlineBindingMkr, such as \k or \w etc, or
	// 3. the first character of the word to be stored as m_key in pSrcPhrase
	// 
	// The first to check for is punctuation, then inlineBindingMkr; however, if the
	// bIsInlineBindingMkr flag was passed in as TRUE, then there won't be punctuation
	// preceding the inlineBindingMkr which ptr points at - so we must check the flag and
	// deal with that marker now (because there might be bad USFM markup with punctuation
	// following such a marker, so we'll handle that and put things back together in
	// correct order in an export, if the markup is indeed incorrect in this way)
	itemLen = 0;
	if (bIsInlineBindingMkr && *ptr == gSFescapechar) // BEW8Jun23 added backslash test, don't enter if ptr pointing at the word
	{
#if defined (_DEBUG) && !defined(NOLOGS)
		// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
		wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
		wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

		// The signature said that ptr is pointing at an inLine binding marker;
		// so which is it?
		pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr); // BEW 24Oct14 overload
		wxASSERT(pUsfmAnalysis != NULL); // must not be an unknown marker
		// In the release version, force a document creation error, and hence a halt with a warning
		if (pUsfmAnalysis == NULL)
		{
			return -1; // the inline binding beginMkr is unknown to AI_USFM, which  should not happen
		}
		bareMkr = emptyStr;
		// BEW 24Oct14, use the two new params of LookupSFM to construct the marker which
		// is to be stored
		if (baseOfEndMkr.IsEmpty())
		{
			// It's not an endmarker
			if (bIsNestedMkr)
				bareMkr = _T('+');
			else
				bareMkr.Empty();
			bareMkr += pUsfmAnalysis->marker;
		}
		wholeMkr = gSFescapechar + bareMkr; // it's reconstructed
		wholeMkrPlusSpace = wholeMkr + aSpace;
		wxASSERT(pUsfmAnalysis->inLine == TRUE);
		// In the release version, force a document creation error, and hence a halt with a warning
		if (pUsfmAnalysis->inLine == FALSE)
		{
			return -1; // should be inLine, but isn't. This is a major unexpected error - parse must fail.
		}
		itemLen = wholeMkr.Len();

		// store the whole marker, and a following space
		pSrcPhrase->SetInlineBindingMarkers(wholeMkrPlusSpace);
		bParsedInlineBindingMkr = TRUE;

		// point past the inline binding marker, and then parse over the white space
		// following it, and point past that too - provided it's possible
		if (itemLen > 0 && (ptr + itemLen) < pEnd)
		{
			ptr += itemLen;
			len += itemLen;
			itemLen = ParseWhiteSpace(ptr);
			ptr += itemLen;
			len += itemLen;
		}
		//wxASSERT(ptr < pEnd);
#if defined (_DEBUG) && !defined(NOLOGS)
		// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
		wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

		// In the release version, force a document creation error, and hence a halt with a warning
		if (ptr > pEnd)
		{
			return -1;
		}
	} // end of TRUE block for test: if (bIsInlineBindingMkr)

	itemLen = 0; // ptr has been advanced, so reset itemLen to 0 pending discovery
				 // of what might lie ahead, if not yet at the beginning of the word proper

	// What might ptr be pointing at now? If the above block actually stored a marker,
	// then we'd expect to be pointing at the word proper's first character. But...
	// there may be incorrect markup, and punctuation could be next. And if we didn't
	// enter the above block, then punctuation could be next, and then an inline binding
	// marker could follow that, so the following 3 possibilities still apply:
	// 1. punctuation which needs to be stored in m_precPunct, or
	// 2. an inlineBindingMkr, such as \k or \w etc, or
	// 3. the first character of the word to be stored as m_key in pSrcPhrase
	// 4. BEW added 3Aug17 - there are other possibilities, especially if the doc has
	// straight quotes - detached straight quotes may not be broken at the correct
	// place, so perhaps " follows, or " followed by \x - \xo ..... \x*, or that same
	// with a space between the " and \x - and without some refactoring these would
	// cause text error or losses in an export subsequently done. So beware, & give
	// extra smarts - both below and in ParseWord2().

	// The first to check for is punctuation, then inlineBindingMkr

	// First, parse over any 'detached' preceding punctuation, bearing in mind it may have
	// sequences of single and/or double opening quotation marks with one or more spaces
	// between each. We want to accumulate all such punctuation, and the spaces in-place,
	// into the precPunct CString. We assume only left quotations and left wedges can be
	// set off by spaces from the actual word and whatever preceding punctuation is on it.
	// We make the same assumption for punctuation following the word - but in that case
	// there should be right wedges or right quotation marks. We'll allow ordinary
	// (vertical) double quotation, and single quotation if the latter is being considered
	// to be punctuation, even though this weakens the integrity of out algorithm - but it
	// would only be compromised if there were sequences of vertical quotes with spaces
	// both at the end of a word and at the start of the next word in the source text data,
	// and this would be highly unlikely to ever occur in published source text.

	while (IsOpeningQuote(ptr) || IsWhiteSpace(ptr))
	{
#if defined (_DEBUG) && !defined(NOLOGS)
		// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
		wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
		wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

		// check if a straight quote is in the preceding punctuation - setting the boolean
		// true will help us decide if a straight quote following the word belongs to the
		// word as final punctuation, or to the next word as opening punctuation.
		bool bStraightQuote = IsStraightQuote(ptr);
		if (bStraightQuote)
		{
			// m_bHasPrecedingStraightQuote is a public boolean of CAdapt_ItDoc class
			// which gets cleared to default FALSE at the start of each new verse, and
			// also after having been used to help decide who owns a straight quote
			// which was detected following the word being parsed
			m_bHasPrecedingStraightQuote = TRUE;
		}

		// These if-else blocks gets us over a single preceding quote or possibly a space
		// which detaches one; we exit this prelim block - we could be at the word proper,
		// or at a character markup marker (there are dozens) like \w or \em etc, with
		// ptr pointing at what follows, and len augmented by one. Any further parsing
		// prior to handing control over to ParseWord() occurs here a little further down
		if (IsWhiteSpace(ptr))
		{
			// whm 17Jan2024 revised to correctly parse over EOL white space since
			// EOLs are now normally \r\n together, then store in m_prePunct the EOLs
			// if present or normalize to Latin space
			itemLen = ParseWhiteSpace(ptr);
			if (itemLen >= 2 && *ptr == _T('\r') && *(ptr + 1) == _T('\n'))
			{
				pSrcPhrase->m_precPunct += _T("\r\n");
			}
			else
			{
				// if not EOLs then normalise to Latin space
				pSrcPhrase->m_precPunct += _T(' ');
			}
			ptr += itemLen; // point past the whitespace
			len += itemLen;
		}
		else
		{
			// It's an opening quote, whether straight, single, or double - so store it
			// 
			// BEW 12Oct22 this is a while loop, but a series of spaces allow potential
			// access to a detached ] closing bracket - which must NOT be put into m_precPunct.
			// Protect against that, as ParseWord deals with ] instances
			wxChar chWhatever = *ptr;
			if (chWhatever == _T(']'))
			{
				// Disallow store, exit from ParsePreWord()
				return len;
			}
			else
			{
				pSrcPhrase->m_precPunct += *ptr++;
				len++;
			}
		}
		// len++; // len is now incremented in the if and else blocks above
#if defined (_DEBUG) && !defined(NOLOGS)
		// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
		wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

		// BEW 3Aug17 Jakarta workshop participants ran into problems with markup
		// word.' " \x - \xo etc
		// because of two parsing errors: (1) breaking word parsing preceding the "
		// and (2) within the word parsing function there is no accounting for the
		// possibility that a non-inlineBindingMarker (such as \x or \v or \f etc)
		// might follow. It the latter happens we need to refactor here so that
		// returning from the word parse happens at such a marker, and if possible
		// back up ptr over any whitespace parsed over, to facilitate the next
		// CSourcePhrase parse starting at the delimiting space. (The problem
		// resulted in the \x getting stored wrongly in the iBM attribute, so
		// that an export would produce "\x -   in the text string, and if x-ref
		// was for being filtered then all subsequent words in the export would be
		// omitted from the data until a standalone \x* was encountered - which
		// could be far away, or not exist at all
		if (IsMarker(ptr)) // immediately following a quote or whitespace
		{
			// Markers which are valid in this context, prior to the call of
			// ParseWord() (which handles all post-word markers and puncts), could
			// be character attribute ones -- these we call inline binding markers
			// so test for these - we are doing this while embedded in the outer
			// loop as there may be more than one in sequence. Non-binding begin
			// markers are of sufficient weight that if one is encountered it
			// should cause signing off on the present pSrcPhrase - such as \v
			// after a newline ('\n'), for these we want to get the various verse
			// marker info params in pSrcPhrase set, and the \v at the next line's start.
			wxString aWholeMkr = GetWholeMarker(ptr);
			wxString augmentedMkr = aWholeMkr + _T(' ');
			int offset = wxNOT_FOUND;
			// BEW 21Mar23 the legacy code here assumed that if it was not an inline binding marker,
			// then control shoule exit ParsePreWord and pass the marker along to ParseWord. Ouch,
			// ParseWord calls ParseAWord() and if there is a gSFescapechar in the internal while
			// loop, ParseAWord will fail - finding no text at all. Can't have that. Bill's Nyindou
			// data, uses a lot of \rq ... \rq* "Inline quotation reference" markup, for showing
			// tyically Old Testament quotes right justified in the printed/published doc.
			// The \rq and \rq* markers are in the "Red" fast access marker sets. So handle these
			// now, and only go on to inlineBindingMarkers if none of the (large) Red marker sets
			// is found. ParseWord() should handle \rq* fine, as it handles all ending markers. 
			// We only need to handle \rq here.
			offset = gpApp->m_RedBeginMarkers.Find(augmentedMkr);
			if (offset >= 0)
			{
				// We found one of the red fast-access begin mkrs set (could be \rq or one of
				// very many other possible markers)
#if defined (_DEBUG) && !defined(NOLOGS)
				wxLogDebug(_T("%s::%s(), line %d : Found Red begin marker:  %s"), __FILE__, __FUNCTION__, __LINE__, aWholeMkr.c_str());
#endif
				// Store the augmented begin mkr in pSrcPhrase->m_markers, update len, and return to caller
				int length = augmentedMkr.Length();
				len += length;
				// whm 25Jan2024 added. This section of code detects what marker directly follows an
				// opening quote or whitespace. The existing code only checks for m_RedBeginMarkers 
				// at the test above. The m_RedBeginMarkers ALSO contain m_inlineNonbindingMarkers such
				// as footnote key words \fk ...\fk* that might come directly after an opening quote
				// as in Nyindrou Revelation, where there are some instances of "<<\fk <keyword>\fk*>>..."
				// Therefore, we need to also check here whether the marker is in the 
				// m_inlineNonbindingMarkers set and, if so, we need to store such markers in the 
				// pSrcPhrase->m_inlineBindingMarkers and NOT in its m_markers member. We also should
				// return a bIsInlineBindingMkr flag to TRUE before we return len to the caller.
				bIsInlineBindingMkr = gpApp->m_inlineBindingMarkers.Find(augmentedMkr) != wxNOT_FOUND;
				if (bIsInlineBindingMkr)
				{
					pSrcPhrase->AppendToInlineBindingMarkers(augmentedMkr);
				}
				else
				{
					pSrcPhrase->m_markers += augmentedMkr;
				}
				// ParseWord() can now be called next, to handle the marker's content safely
				return len;
			}

			// BEW 22Mar23 we've maybe parsed over some precPunct characters, so there might be a marker
			// following. In Bill's Revelation document, <<\fk a\fk*>> occurs, or similar, so ptr may
			// be pointing at, say, \fk or some other marker (but not \p or \v as these do not follow
			// preceding punctuation). So test, and store the marker, if present.
			if (*ptr == gSFescapechar)
			{
				// there's a beginMkr to handle
				wxString aWholeMkr = GetWholeMarker(ptr);
				wxString augmentedMkr = aWholeMkr + _T(' ');
				int mkrLen = aWholeMkr.Length();
				// whm 24Jan2024 modification/correction. At this point we need to check if the
				// marker is an inline binding marker, and if so store it in m_inlineBindingMarkers
				// instead of m_markers. Discovered this issue when parsing "<<\em Jesus\em*..." 
				// text, and the \em got wrongly stored here in m_markers, so we need the test
				// for inline binding markers here before and store the marker in the right place
				// and only else, put it in m_markers. I'll use the m_charFormatMkrs list here
				// since it has 5 more markers than the m_inlineBindingMarkers - including
				// has no \\png \\addpn \\qt \\sls and \\sup.
				if (gpApp->m_charFormatMkrs.Find(augmentedMkr) != wxNOT_FOUND)
				{
					// It's a char format marker and also an inline binding begin marker,
					// both have the same inventory of begin markers! Probably use the Append...
					// function form here.
					pSrcPhrase->AppendToInlineBindingMarkers(augmentedMkr);
				}
				else
				{
					pSrcPhrase->m_markers += augmentedMkr; // begin-markers must have a trailing space
				}
				// whm 17Jan2024 modification. Although begin-markers normally have a trailing space
				// TokenizeText() can be called on a portion of text in which the last marker could
				// be \p at the end of the file without any trailing space. To be safe then and get
				// an accurate len value I'll add below a ParseSpace() call and use its actual return
				// value which may be zero
				int whitespaceLen = 0;
				whitespaceLen = ParseWhiteSpace(ptr);
				len += mkrLen + whitespaceLen;
				ptr += mkrLen + whitespaceLen;
#if defined (_DEBUG) && !defined(NOLOGS)
				if (pSrcPhrase->m_nSequNumber >= 1)
				{
					int halt_here = 1;
					wxUnusedVar(halt_here);
				}
#endif
				return len;
			}
#if defined (_DEBUG) && !defined(NOLOGS)
			wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

			// Finally, if a Red begin marker was not found, and no other beginMkr was found,
			// then do the legacy code following which tests for inlineBinding begin markers
			offset = gpApp->m_inlineBindingMarkers.Find(augmentedMkr);
			wxChar* pTemp = ptr;
			int aWhiteSpanLength = 0;
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
			if (offset == wxNOT_FOUND)
			{
				// What ptr is pointing at is a marker, which is NOT one of
				// the inline binding marker set - so it could be \x or \f or \v etc
				// in which case ParsePreWord() should exit here, after backing
				// up over any white spaces just parsed over.
				while (aWhiteSpanLength < len && pTemp > pChar)
				{
					pTemp--;
					if (IsWhiteSpace(pTemp))
					{
						aWhiteSpanLength++;
					}
					else
					{
						break; // break from this whitespace backing up loop
					}
				} // end of backing up loop
				// Adjust ptr and len values
				if (aWhiteSpanLength > 0)
				{
					ptr = ptr - (size_t)aWhiteSpanLength;
					len = len - aWhiteSpanLength;
				}
				bIsInlineNonbindingMkr = FALSE; // it's passed by ref, so clear the value
				bIsInlineBindingMkr = FALSE; // ditto
#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
				wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
				return len;
			} // end of TRUE block for test: if (offset == wxNOT_FOUND)

		} // end of TRUE block for test: if (IsMarker(ptr)) // immediately following a quote or whitespace
	}
	// when control reaches here, we may be pointing at further punctuation having
	// iterated across some data in the above loop, or be pointing at the first character
	// of the word, or be pointing at the backslash of an inline binding marker - so
	// handle these possibilities.
	// BEW 30Sep19 -- the above is not fully correct in USFM 3. The sequence:
	// \qt <whitespace> \v <a word> will bring control to this test, with ptr
	// pointing at the \v marker, and it is NOT appropriate to assume it must
	// be an inline marker. So we must make a test here to check for a verse
	// marker, and if it is, handle it appropriately - but if not, then the
	// legacy assumptions apply (presumably). The "tryagain" goto is for the
	// situation where a verse marker follows one like \qt  If that is not
	// the situation, the ptr will still be pointing at a character attribute
	// begin-marker, and we deal with that further below
tryagain:
#if defined (_DEBUG) && !defined(NOLOGS)
	wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
		__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

	if (IsMarker(ptr))
	{
		int nMkrLen = 0;

		// its a marker of some kind
		if (IsVerseMarker(ptr, nMkrLen))
		{
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
			wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

			wxString tokBuffer;
			tokBuffer.Empty();
			wxString temp;
			wxChar gSFescapechar = _T('\\');

			tokBuffer += gSFescapechar;
			tokBuffer += _T("v");
			ptr += 2; // point past the \v marker

			itemLen = ParseWhiteSpace(ptr);
			AppendItem(tokBuffer, temp, ptr, itemLen); // add number (or range eg. 3-5) to buffer

			itemLen = ParseNumber(ptr);
			AppendItem(tokBuffer, temp, ptr, itemLen);

			pSrcPhrase->m_bVerse = TRUE; // set the flag to signal start of a new verse
			ptr += itemLen; // point past verse number

			// set pSrcPhrase attributes
			pSrcPhrase->m_bVerse = TRUE;

			itemLen = ParseWhiteSpace(ptr); // past white space after the marker
			AppendItem(tokBuffer, temp, ptr, itemLen);  // add it to the buffer
			ptr += itemLen; // point past the white space
#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			goto tryagain;
		}
#if defined (_DEBUG) && !defined(NOLOGS)
		wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

		// Ok, probably we are pointing at an inline marker; non-inlines were handled 
		// by the caller - TokenizeText(), so this is one with inLine TRUE, that is, an 
		// inline binding marker; beware, we can have \k \w word\w*\k*, and so we could 
		// be pointing at the first of a pair of them, so we can't assume there will be 
		// only one every time
		while (IsMarker(ptr))
		{
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			// Parse across as many as there are, and the obligatory white space following
			// each - normalizing \n or \r to a space at the same time
			pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr); // BEW 24Oct14 overload
			// BEW 3Aug11 added == NULL block to handle an unknown marker
			if (pUsfmAnalysis == NULL)
			{
				// should not be an unknown marker, but might be if legacy SFM is mixed in
				// - if so, do the best we can - put it in m_markers and carry on parsing
				wxString aWholeMkr = GetWholeMarker(ptr);
				aWholeMkr += aSpace;
				itemLen = aWholeMkr.Len();
				pSrcPhrase->m_markers += aWholeMkr;
				bParsedInlineBindingMkr = FALSE;
			}
			else
			{
				// it's a known marker; but it might be not inline - so check 
				// and store accordingly
				bareMkr = emptyStr;
				// BEW 24Oct addition - as done above in other places
				if (baseOfEndMkr.IsEmpty())
				{
					// It's not an endmarker, so it's one we need to consider further
					if (bIsNestedMkr)
						bareMkr = _T('+');
					else
						bareMkr.Empty();
					bareMkr += pUsfmAnalysis->marker;
				}
				else
				{
					// It's an endmarker -- ParseWord() handles these
					// itemLen may be non-zero, so augment len and ptr
					// before returning
					if (itemLen != 0)
					{
						len += itemLen;
						ptr += itemLen;

						bIsInlineNonbindingMkr = FALSE; // it's passed by ref, so clear the value
						bIsInlineBindingMkr = FALSE; // ditto

						return len;
					}
				}
				wholeMkr = gSFescapechar + bareMkr;
				wholeMkrPlusSpace = wholeMkr + aSpace;
				if (wholeMkr == _T("\\bt"))
				{
					// It's one of our custom markers
					pSrcPhrase->SetCollectedBackTrans(wholeMkrPlusSpace);
					itemLen = wholeMkr.Len();
					bParsedInlineBindingMkr = FALSE;
				}
				else
				{
					itemLen = wholeMkr.Len(); // presumably itemLen is the length
							// of the begin-marker, of character attribute type,
							// but we can't rule out USFM3's new markers, so test further
							// if some kind of wholeMkr was found
					if (itemLen > 2)
					{
						// BEW 30Sep19 USFM3 adds inLine markers for things like 
						// extended footnotes or notes, extended sidebar text,
						// and various other things. For instance \ef .... and \ef*
						// for extended footnotes - these take \f's inner markers
						// for content, so should parse like \f to \f*, and get stored
						// in m_markers and \ef* in m_endMarkers. Legacy code here
						// shoved whatever the wholeMkr is into the binding mkrs storage,
						// which is dissonant with the fact that such extra USFM3 markers,
						// while inLine TRUE, are neither binding type, nor non-binding
						// type (and they are not listed in the fast access strings either)
						// and so the appropriate thing to do here is test for binding again		
						int offset = gpApp->m_inlineBindingMarkers.Find(wholeMkrPlusSpace);
						if (offset != wxNOT_FOUND)
						{
							// store the whole marker, and a following space
							pSrcPhrase->AppendToInlineBindingMarkers(wholeMkrPlusSpace);
							bParsedInlineBindingMkr = TRUE;
						}
						// BEW 13Sep22 offset was wxNOT_FOUND, then move on, the test of
						// itemLen > 0 a few lines below might sort it out
					}

				} // end of else block for test: if (wholeMkr == _T("\\bt"))
#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
				wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			} // end of else block for test: if (pUsfmAnalysis == NULL)
#if defined (_DEBUG) && !defined(NOLOGS)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			// point past the inline or binding marker, or the unknown marker, or 
			// USFM3 inline special extended markup marker,
			// and then parse over the white space following it too
			if (bParsedInlineBindingMkr)
			{
				ptr += itemLen;
				len += itemLen;
				bParsedInlineBindingMkr = FALSE; // prepare for next loop iteration

			}
			else if (itemLen > 0)
			{
				// There's a marker of some kind to advance over, but not an inline
				// binding one, so augment ptr and len; default the storage of it
				// to be in m_markers
				ptr += itemLen;
				len += itemLen;
				pSrcPhrase->m_markers += wholeMkrPlusSpace;
			}
			// Deal with any whitespace that we expect to be following the marker
			itemLen = ParseWhiteSpace(ptr);
			ptr += itemLen;
			len += itemLen;
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
			wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

			wxASSERT(ptr < pEnd);
			if (ptr > pEnd)
			{
				return -1; // serious error, make caller terminate the app
			}
		}  // end of marker(s)-handling loop: while (IsMarker(ptr))

		// Once control gets to here, ptr should be pointing at the first character of the
		// actual word for saving in m_key of pSrcPhrase; we don't expect punctuation
		// after a binding inline marker, but because of the possibility of user markup
		// error, we'll allow it. It's not that we can't deal with it; it's just
		// inappropriate markup. So we won't have a wxASSERT() here. Also, when
		// ParseWord() is being called to rebuild a doc after user changed punctuation
		// settings, this can produce exceptions (see below) to the expectation we are now
		// at the start of the word to be parsed.

	} // end of TRUE block for label + test: tryagain:	if (IsMarker(ptr))
  // the goto call is at line 16689 above - it's ignored if \v is not encountered
  // within ParsePreWord()
	else
	{
		// the legacy parser's code still applies here - to finish parsing over any
		// non-quote punctuation which precedes the word

		// BEW 4Apr17 add a wrapping test to make sure defacto 'placeholder' text which
		// is just a lot of punctuation characters followed by an endmarker, is not parsed
		// in the normal way - that causes an app crash.
		// If there is no content between the markers, parsing is well behaved, so we
		// don't have to use this hack to protect that as well, in fact we'll make use
		// of it.
		// This hack is needed in TokenizeText() to prevent ....... type of content
		// (i.e. all punctuation characters, no word) as content between, say, \fr and
		// a \f* which is following the punctuation, from producing a crash of the app.
		// Data was from Kari Valkama (Psalms)
		bool bHasPunctsOnly = FALSE;
		bool bEndmarkerFollows = FALSE;
		int nCountOfPuncts = 0;

#if defined (_DEBUG) && !defined(NOLOGS)
		if (pSrcPhrase->m_nSequNumber >= 3)
		{
			int halt_here = 1; wxUnusedVar(halt_here);
		}
		wxLogDebug(_T("ParsePreWord: line %d Starting refactored bit:  sn= %d , bIsinlinwBindingMkr= %d"),
			__LINE__, pSrcPhrase->m_nSequNumber, (int)bIsInlineBindingMkr);
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
		wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

		if (IsPunctuationOnlyFollowedByEndmarker(ptr, pEnd,
			m_spacelessPuncts, bTokenizingTargetText, bHasPunctsOnly,
			bEndmarkerFollows, nCountOfPuncts))
		{
			// The adjusting hack is required, so do it......
			// Refactor. The puncts should go into m_follPunct, m_key stay
			// empty, and then \f* into m_endMarkers.
			// (Embedded \xt in non-filtered footnote should just not be filtered,
			// so that is something further for me to fix after this local refactor)
			if (bHasPunctsOnly && bEndmarkerFollows)
			{
				wxString punctsStr(ptr, nCountOfPuncts);
				pSrcPhrase->m_follPunct += punctsStr;
				ptr = ptr + (size_t)nCountOfPuncts;
			}
			else
			{
				// Control should never need to enter this block if the test function,
				// IsPunctuationOnlyFollowedByEndmarker() returned TRUE. But just in case,
				// the safest thing to do is to jump ptr over the punctuation substring -
				// because no content between the marker and endmarker parses successfully
				ptr = ptr + (size_t)nCountOfPuncts;
			}
			len += nCountOfPuncts;
#if defined (_DEBUG) && !defined(NOLOGS)
			wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

			// The parsing is able to go on, and it might end up unexpectedly trying to
			// deal with a \v or similar marker - which should not happen within
			// ParseWord2(). We handle that after this block is exited, by an IsMarker() test
		}
		else
		{
			// The legacy code is in this block
#if defined (_DEBUG) && !defined(NOLOGS)
// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxString pointsAt = wxString(ptr, 20);
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d  pointsAt=%s"),
				__FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource, pointsAt.c_str());
#endif
#if defined (_DEBUG) && !defined(NOLOGS)
			wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

			// BEW 5Oct/22 the while test is only allowed provided there were no inline
			// markers handled above, either binding one or non-binding. Without extra
			// protection added here, *ptr pointing at '[' will put the [ into
			// m_precPunct (where it ulimately may go, but doing that here will advance
			// ptr past the [ and make handing of [  in TokenizeText fail to find
			// the opening [, with the result that it's to-be-matched ] becomes unmatchable
			// and this will cause a serious parsing error. So wrap here with a test
			if (!(bIsInlineNonbindingMkr || bIsInlineBindingMkr))
			{
#if defined (_DEBUG) && !defined(NOLOGS)
				// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
				wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

				// If one or the other kind of marker, or both, were handled earlier,
				// don't let this while loop be entered. Use this loop to get past any
				// unhandled word-final punctuation, or ( or { which should be in m_precPunct
				while (!IsEnd(ptr) && (nFound = spacelessPuncts.Find(*ptr)) >= 0)
				{
					// The test checks to see if the character at the location of ptr belongs to
					// the set of source language punctuation characters (with space excluded from
					// the latter) - as long as the nFound value is positive we are parsing over
					// punctuation characters
					// BEW 13Oct22 but beware, closing ] bracket is typically a punctuation character,
					// or it could be detached, and in both those cases we do NOT want ] to be put
					// into m_precPunct. Coming to a ] should end the parse and return len to 
					// TokenizeText() so that ptr can be updated, and the following ParseWord() then
					// will have ptr correctly pointing at the ] character
					wxChar chWhatever = *ptr;
					if (chWhatever == _T(']'))
					{
						// Disallow store, exit from ParsePreWord()
						return len;
					}
					else if (chWhatever == _T('('))
					{
						pSrcPhrase->m_precPunct += *ptr++;
						len++;
						return len;
					}
					else if (chWhatever == _T('{'))
					{
						pSrcPhrase->m_precPunct += *ptr++;
						len++;
						return len;
					}
					else
					{
						// found a punct, iterate
						pSrcPhrase->m_follPunct += *ptr++;
						len++;
					}
#if defined (_DEBUG) && !defined(NOLOGS)
					wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif
				}
			}
		}
		// BEW 22Mar23, after the loop, whitespace may be next - check and parse over it
		int numWhiteSpaces = CountWhitesSpan(ptr, pEnd);
		if (numWhiteSpaces > 0)
		{
			ptr += numWhiteSpaces;
			len += numWhiteSpaces;
		}
#if defined (_DEBUG) && !defined(NOLOGS)
		if (pSrcPhrase->m_nSequNumber >= 3)
		{
			int halt_here = 1; wxUnusedVar(halt_here);
		}
#endif

		// BEW 27Mar23 if ptr points at newline followed by gSFescapechar, then the newline
		// should be put in precWordDelim, the beginMkr parsed over, len updated, and control should
		// exit to let ParseWord() then handle what follows the beginMkr - but make sure its a beginMkr
		//wxChar aNewline = *ptr;
		//wxChar aBackslash = *(ptr + 1);
		if (*ptr == _T('\n') && (*(ptr + 1)) == gSFescapechar)
		{
			wxChar* pAux = ptr + 1;
			wxString wholeMkr = GetWholeMarker(pAux);
			if (!wholeMkr.IsEmpty())
			{
				bool bIsEndMkr = IsEndMarker(pAux, pEnd);
				if (!bIsEndMkr)
				{
					// The marker is not an endmkr, so the backslash at pAux is for a beginMkr,
					// and those are to be handled here, as ParseWord() is not designed to
					// parse beginMkrs (ParseAWord() would assert)
					int length = wholeMkr.Length();
					wxString aSrcWordBreak = _T('\n');
					pSrcPhrase->SetSrcWordBreak(aSrcWordBreak);
					len += (length + 1);
					pSrcPhrase->m_markers += wholeMkr;
					pSrcPhrase->m_markers.Append(_T(' '));
					return len;
				}
			}
		}
#if defined (_DEBUG) && !defined(NOLOGS)
		wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

		// BEW 5Oct22 added the next bool, for use further down
		bAllowPunctChangeBlock = FALSE; // default, disallow unless wordBuiders... is non-empty

		// Handle the undoing of the above block's code when the user has changed his mind and
		// reverted punctuation character(s) to being word-building ones
		// 
		// BEW 24Oct22, for data like: bīʼ\it Bʉʼka ndə haʼ nɔ.\it* where \it turns on italics
		// ( it's an inLine binding marker) and on this or a later pSrcPhrase \it* turns the
		// italics back off, my refactored code produced an assert trip in ParseAWord in
		// ParseWord(), in the following way. SquirrelAwayMovedFormerPuncts() wrongly caches the
		// 4 characters "bīʼ" (4 because ī is a 2-char composite) in wordBuildersForPreWordLoc,
		// and len and ptr get updated to point to the \it marker, but control is sent back to
		// tokenize text. Then ParseWord() gets called, but what we want is that ParseAWord()
		// will parse the "bīʼ" string, so it's not empty. What we get however, is on entry to
		// ParseAWord(), ptr is pointing at \it (a marker) not the 'B' of "bīʼ". And pointing
		// at a marker within ParseAWord() is a cause for parsing no futher, so control does
		// not get to parse over anything, and so the 'word' being parsed is an empty string,
		// which makes the assert at function end trip.
		// What's the solution? Squirreling...() should NOT be done when a document is being
		// created from the OnNewDocument() call of Doc.cpp, squirreling is only relevant to
		// whenever the user makes a punct into a wordbuilding char, or vise versa - and that
		// is not something that can be done at doc creation time. There is an app boolean:
		// m_bParsingSource which will be TRUE while an input .txt, or .SFM, or .PTX, file
		// is being used for doc creation. So we can use that here to provide an alternate
		// control path, to avoid the Squirrel...() function, and allow ParseAWord() to
		// successfully parse until the \it or \k or whatever character-style begin mkr is reached.
		if (!gpApp->m_bParsingSource)
		{
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
			wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif

			wordBuildersForPreWordLoc = SquirrelAwayMovedFormerPuncts(ptr, pEnd, spacelessPuncts);
			// if we actually squirreled some away, then we must advance ptr over them, and update
			// len value
			if (!wordBuildersForPreWordLoc.IsEmpty())
			{
				bAllowPunctChangeBlock = TRUE; // use at test on line 17,148 below
			}

			if (!wordBuildersForPreWordLoc.IsEmpty())
			{
				size_t theirLength = wordBuildersForPreWordLoc.Len();
				ptr += theirLength;
				len += theirLength;
				// we will insert that prior to the word where theWord wxString is created below,
				// and for when dealing with ~ fixedspaced conjoining, where wxString firstWord is
				// defined
			}
		}
#if defined (_DEBUG) && !defined(NOLOGS)
		wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

		// BEW 25May17 It is possible for control within an unfiltered space to
		// get to this point, and actually have ptr pointing at an endmarker, such
		// as \f* followed by whitespace which in turn is followed by \v  or \li or
		// \li1 etc. \v or \li etc are non-inLine markers, but code in this outer
		// block thinks we've yet to come to the word-proper, so we have to
		// detect this contradiction, and provide code here to parse and correctly
		// store any endmarkers in m_endMarkers, and then exit ParseWord2() with
		// ptr pointing at whitespace preceding the non-inline markers, and return
		// to TokenizeText() with correct len and ptr values because parsing for
		// the current pSrcPhrase is done
		// BEW 25May17 Added this block, see above commment, to handle unexpected
		// non-inline marker being encountered
		if (IsMarker(ptr))
		{
			// Deal with any endmarkers...
			if (IsEndMarker2(ptr)) // TRUE if it's an endMkr at ptr
			{
				// Time to return from ParseWord() correctly, deal with what remains
				// for storage on the present pSrcPhrase before doing so
				pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr); // BEW 24Oct14 overload
				if ((pUsfmAnalysis->inLine == TRUE) && gpApp->m_bParsingSource) // BEW 24Oct22 added 2nd subtest
				{
					// It's an endmarker
					if (bIsNestedMkr)
						bareMkr = _T('+');
					else
						bareMkr.Empty();
					bareMkr += baseOfEndMkr;
					bareMkr += _T('*');

					wholeMkr = gSFescapechar + bareMkr;
					itemLen = wholeMkr.Length();
					pSrcPhrase->AddEndMarker(wholeMkr);
					pSrcPhrase->m_srcPhrase += pSrcPhrase->m_follPunct;
					if (!pSrcPhrase->m_follPunct.IsEmpty() && pSrcPhrase->m_follPunct != _T(","))
					{
						pSrcPhrase->m_bBoundary = TRUE;
					}
					ptr = ptr + (size_t)itemLen; // BEW 5Oct22 this line was commented out (wrongly)
					len += itemLen;
					bIsInlineNonbindingMkr = FALSE; // it's passed by ref, so clear the value
					bIsInlineBindingMkr = FALSE; // ditto

					return len;
				}

			} // end of TRUE block for test: if (IsEndMarker2(ptr))
			else
			{
#if defined (_DEBUG) && !defined(NOLOGS)
				wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

				// Don't allow this block if parsing the source text, because we want control
				// to get entry to ParseWord() so that it's child call of ParseAWord() gets
				// the chance to be called
				if (!gpApp->m_bParsingSource)
				{
					// other non-inline markers require immediate return, the unknown marker will be on next pSrcPhase
					pSrcPhrase->m_srcPhrase += pSrcPhrase->m_follPunct;
					if (!pSrcPhrase->m_follPunct.IsEmpty() && pSrcPhrase->m_follPunct != _T(","))
					{
						pSrcPhrase->m_bBoundary = TRUE;
					}
					bIsInlineNonbindingMkr = FALSE; // it's passed by ref, so clear the value
					bIsInlineBindingMkr = FALSE; // ditto

					return len;
				}
				// BEW 22Mar23 It's quite possible that ptr is now pointing at a beginMkr, for example
				// \rq or some other marker from the Red fast-access set of beginMkrs. Check, and handle
				// any such here - if a whitespace preceds the beginMkr, it will have been parsed over
				// at 17,622 above. Store the Red mkr in pSrcPhrase->m_markers (with following space)
				// and then return len.
				if (*ptr == gSFescapechar)
				{
					// a begin-marker is at ptr
					wxString aWholeMkr = GetWholeMarker(ptr);
					wxString augmentedMkr = aWholeMkr + _T(' ');
					int offset = wxNOT_FOUND;
					offset = gpApp->m_RedBeginMarkers.Find(augmentedMkr);
					if (offset >= 0)
					{
						// We found one of the red fast-access begin mkrs set (could be \rq or one of
						// very many other possible markers)
#if defined (_DEBUG) && !defined(NOLOGS)
						wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif
						// Store the augmented begin mkr in pSrcPhrase->m_markers, update len, and return to caller
						int length = augmentedMkr.Length();
						len += length;
						pSrcPhrase->m_markers += augmentedMkr;
						// ParseWord() can now be called next, to handle the marker's content safely
						return len;
					}
					// BEW 22Mar23 there may be following markers NOT from the Red set at ptr, perhaps \p,
					// could be a \n, and then \v - because they are begin markers, they must get parsed
					// over to allow ptr to get to the verse number, which ParseWord() can handle safely
					if (*ptr == gSFescapechar)
					{
						// Further non-red beginMkr(s) follow, maybe separated by space or newline (each
						// is whitespace). Check, parse, and return the updated len value
						wxString wholeMkr = GetWholeMarker(ptr);
						wxString paragraph = _T("\\p");
						if (wholeMkr == paragraph)
						{
							pSrcPhrase->m_markers += paragraph;
							len += 2;
							ptr += 2;
							// check for following whitespace
							int whites = CountWhitesSpan(ptr, pEnd);
							if (whites > 0)
							{
								wxChar chFinalWhite = *(ptr + (whites - 1)); // the last may be \n not space
								len += whites;
								ptr += whites;
								pSrcPhrase->m_markers += chFinalWhite; // either \n or space or some other whitespace
							}
						}
						// that handles \p or \p<space> or \p\n etc
						// There may be a verse marker next. Check and handle
						if (*ptr == gSFescapechar)
						{
							// A beginMkr follows at ptr
							wxString wholeMkr = GetWholeMarker(ptr);
							wxString verse = _T("\\v");
							if (wholeMkr == verse)
							{
								pSrcPhrase->m_markers += verse;
								len += 2;
								ptr += 2;
								// we don't need to worry about what follows \v
								// as ParseWord() will handle that fine
								return len;
							}
						}
						else
						{
							// not a marker next, so return len
							return len;
						}
#if defined (_DEBUG) && !defined(NOLOGS)
						wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

					}
				}
			} // end of else block for test: if (IsEndMarker2(ptr))

		} // end of TRUE block for test: if (IsMarker(ptr))

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined (LOGMKRS)
		if (pSrcPhrase->m_nSequNumber >= 3)
		{
			int halt_here = 1; wxUnusedVar(halt_here);
		}
		wxLogDebug(_T("ParsePreWord: passed Squirrel...(), line %d , sn= %d , bIsinlinwBindingMkr= %d"),
			__LINE__, pSrcPhrase->m_nSequNumber, (int)bIsInlineBindingMkr);
#endif
		// When the above loop exits, and any squirreling required has been done, ptr may
		// be pointing at the word, or at a preceding inline binding marker, like \k (for
		// keyword) or \w (for a wordlist word) or various other markers - many of which
		// are character formatting ones, like italics (\it), etc -- so handle the
		// possibility of one or more inline binding markers here within this else block,
		// so that when the else block is exited, we are pointing at the first character of
		// the actual word
		if (IsMarker(ptr))
		{
			// we are pointing at an inline marker - it must be one with inLine TRUE and
			// TextType none and not one of the 5 mentioned above, that is, an inline
			// binding marker
			// (beware, we can have \k \w word\w*\k*, and so we could be pointing at the
			// first of a pair of them, so we can't assume there will be only one every
			// time)
			while (IsMarker(ptr))
			{
				// parse across as many as there are, and the obligatory white space
				// following each - normalizing \n or \r to a space at the same time
				pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr); // BEW 24Oct14 overload
				if (pUsfmAnalysis == NULL)
				{
					// must not be an unknown marker, tell the user to fix the input data
					// and try again
					wxString wholeMkr2 = GetWholeMarker(ptr);
					wxString msgStr;
					msgStr = msgStr.Format(
						_("Adapt It does not recognise this marker: %s which is in the input file.\nEdit the input file in a word processor, save, and then retry creating the document.\nAdapt It will now abort."),
						wholeMkr2.c_str());
					wxMessageBox(msgStr, _T(""), wxICON_ERROR | wxOK);
					gpApp->LogUserAction(msgStr);
					// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
					wxKill(::wxGetProcessId(), wxSIGKILL); // abort();
					return 0;
				}
				bareMkr = emptyStr;
				// BEW 24Oct addition - as done above in other places
				if (baseOfEndMkr.IsEmpty())
				{
					// It's not an endmarker
					if (bIsNestedMkr)
						bareMkr = _T('+');
					else
						bareMkr.Empty();
					bareMkr += pUsfmAnalysis->marker;
				}
				else
				{
					// It's an endmarker
					if (bIsNestedMkr)
						bareMkr = _T('+');
					else
						bareMkr.Empty();
					bareMkr += pUsfmAnalysis->endMarker; // or, += tagOnly
				}
				wholeMkr = gSFescapechar + bareMkr;
				wholeMkrPlusSpace = wholeMkr + aSpace;
				if (pUsfmAnalysis->inLine == FALSE)
				{
					// It's not an inline marker, so ParseWord() must be exited here;
					// we should also back up over whitespace if any precedes ptr,
					// so that TokenizeText can store whatever is the whitespace
					// preceding the next CSourcePhrase instance
					int whitespaceCount = 0;
					wxChar* aPtr = ptr;
					bool bIsWhite = FALSE;
					do {
						//aPtr = --aPtr; // whm 10Feb2018 Note: This is non-standard syntax and generates a gcc warning "operation on 'aPtr' may be undefined"
						aPtr--; // point at previous wide character
						bIsWhite = IsWhiteSpace(aPtr);
						if (bIsWhite)
						{
							whitespaceCount++;
						}
					} while (bIsWhite);
					len = len - whitespaceCount;
					ptr = ptr - (size_t)whitespaceCount;
					pSrcPhrase->m_srcPhrase += pSrcPhrase->m_follPunct;
				}
				itemLen = wholeMkr.Len();
#if defined (_DEBUG) && !defined(NOLOGS)
				wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

				// store the whole marker, and a following space
				pSrcPhrase->AppendToInlineBindingMarkers(wholeMkrPlusSpace);
				bParsedInlineBindingMkr = TRUE;

				// point past the inline binding marker, and then parse over the white
				// space following it, and point past that too
				ptr += itemLen;
				len += itemLen;
				itemLen = ParseWhiteSpace(ptr);
				ptr += itemLen;
				len += itemLen;
				wxASSERT(ptr < pEnd);
				if (ptr > pEnd)
				{
					return -1;
				}
			}
			// once control gets to here, ptr should be pointing at the first character of
			// the actual word for saving in m_key of pSrcPhrase ... well, usually.
		}
	} // end of else block for test: if (IsMarker(ptr))

		// determine if we've found preceding punctuation
	if (pSrcPhrase->m_precPunct.Len() > 0)
	{
		bHasPrecPunct = TRUE;
	}
	wxUnusedVar(bHasPrecPunct);
#if defined (_DEBUG) && !defined(NOLOGS)
	wxLogDebug(_T("ParsePreWord: line %d , sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
		__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

	// this is where the first character of the word possibly starts...

	// BEW 31Jan11, it is possible that a dynamic punctuation change has just made one or
	// more of the former word-initial character/characters into punctuation
	// characters, and if that is the case, then our algorithm won't handle it without
	// something extra here if control has just parsed over an inline binding marker - so
	// test for this and do additional checks, removing any punctuation characters from
	// where ptr is pointing if they are in the being-used punctuation set, and moving
	// them to the m_precPunct member, and setting bHasPrecPunct if any such are moved.
	// [Note: removing a punctuation character from the punctuation set dynamically isn't a
	// problem, as it returns then to the word-building set, and when parsing the
	// reconstituted string, the parser will halt earlier, so that the non-word-building
	// character(s) are at the new starting point for the word proper - for this scenario,
	// no new code is needed.]
	// Note: when we put the new punctuation character into m_precPunct, we are producing
	// a connundrum for later on if the user changes his mind about that character's
	// punctuation status, because in the presence of an inline binding marker, the former
	// punctuation character then becomes pre-marker rather than pre-word, so we'll need
	// additional code (it's above, where pre-word non-quote puncts have finished being
	// parsed over) for that situation which will squirrel such characters away and
	// restore them to word-initial position later on when the word is actually defined
	if (bAllowPunctChangeBlock && bParsedInlineBindingMkr) // BEW 5Oct22 added subtest bAllowPunctChangeBlock
	{
		int offset = wxNOT_FOUND;
		while ((offset = spacelessPuncts.Find(*ptr)) != wxNOT_FOUND)
		{
			// we've a newly-defined initial punctuation character to move to m_precPunct
			bHasPrecPunct = TRUE;
			wxUnusedVar(bHasPrecPunct);

			// BEW 13Oct22, beware, if [ and ] were word-building, and have just been returned
			// to being punctuation (their normal state). if ptr points at either, (and it must
			// be the case that they are not detached - ie. not separated from the word by
			// whitespace before ] or after [ ) then we will want [ stored in m_precPunct, and
			// in the case of ] encountered, ] stored in m_follPunct. Refactor here accordingly.
			wxChar chWhatever = *ptr;
			bool bIsOpening = (chWhatever == _T('['));
			bool bIsClosing = (chWhatever == _T(']'));
			if (bIsOpening || bIsClosing)
			{
				// Now whichever it is must be stored in the appropriate pSrcPhrase member;
				// and we augment ptr and len, to keep TokenizeText ptr in sync
				if (bIsOpening)
				{
					// BEW 22Oct22 if chWhatever is already in m_precPunct, don't add another
					wxString strPrecPuncts = pSrcPhrase->m_precPunct;
					int offset = wxNOT_FOUND; wxString openBrkt = _T("[");
					offset = strPrecPuncts.Find(openBrkt);
					if (offset == wxNOT_FOUND)
					{
						// '[' is not already in m_precPunct, so can add one

						pSrcPhrase->m_precPunct += _T('[');
					}
					else if (chWhatever != _T('['))
					{
						pSrcPhrase->m_precPunct += chWhatever;
					}
				}
				else
				{
					// must be the other
					wxASSERT(bIsClosing);
					pSrcPhrase->m_follPunct += chWhatever;
				}
				ptr++;
				len++;
			}
			else
			{
				// It's neither [ nor ], so do the legacy choice, add it to m_precPunct, 
				// augment ptr and len prior to returning
				pSrcPhrase->m_precPunct += *ptr;
				ptr++;
				len++;
			}
		}
	}
#if defined (_DEBUG) && !defined(NOLOGS)
	wxLogDebug(_T("ParsePreWord: line %d , END sn= %d , m_srcPhrase= %s , m_markers= [%s] , m_targetStr= %s"),
		__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_targetStr.c_str());
#endif

	bIsInlineNonbindingMkr = FALSE; // it's passed by ref, so clear the value
	bIsInlineBindingMkr = FALSE; // ditto

	return len;
}


///////////////////////////////////////////////////////////////////////////////
/// \return		the number of characters parsed over
/// \param		pChar			-> a pointer to the next character to be parsed (it
///                                could be the first character of theWord, or
///                                preceding punctuation, or an inline non-binding
///                                marker, or an inline binding marker)
/// \param      pEnd            -> pointer to first char past the end of the buffer
/// \param		pSrcPhrase	   <-> ptr to the CSourcePhrase instance we are building
/// \param	spacelessPuncts     -> punctuation characters set used herein, spaces removed
/// \param	boundarySet	        -> same as spacelessSrcPunct but also with comma removed
/// \param inlineNonbindingMrks -> space-delimited markers, \wj \qt \sls \tl \fig
///	\param bIsInlineNonbindingMkr -> TRUE if pChar points at one of the above 5 mkrs
///	\param bIsInlineBindingMkr  -> TRUE if pChar points at any of the other lineline
///	                               markers (but not any from the footnote or
///	                               crossReference set, which start with \f or \x,
///	                               respectively)
/// \remarks
/// Called from: the Doc's TokenizeText(), the View's RemovePunctuation(),
/// DoExportSrcOrTgtRTF(), ProcessAndWriteDestinationText().
/// Parses a word of ordinary text, intelligently handling (and accumulating) characters
/// defined as punctuation, and dealing with any inline markers and endmarkers. The legacy
/// version of this function tried to intelligently handle sequences of straight
/// singlequote and straight doublequote following the word; but we no longer do that - we
/// assume good USFM markup, and expect either chevrons or curly quotes, not straight ones
/// - but we'll handle straight ones in sequence following the word only while no space
/// occurs between them - after that, any further one will be assumed to be at the start
/// of the next CSourcePhrase instance (if that is a bad assumption, the user can edit the
/// source text to make the quotes curly ones, and then the parse will be redone right).
///
/// BEW 11Oct10, changed for docVersion5, to support inline markers and following
/// punctuation which may occur both before and after endmarkers. Also, entry to
/// ParseWord() is potentially earlier - as soon as an inline marker is encountered which
/// is neither \f nor \x; and more processing is done within the function rather than
/// returning strings to the caller for the caller to set up the pSrcPhrase from what is
/// returned. We leave m_markers for the caller to add to pSrcPhrase, since we've already
/// collected it's contents in the tokBuffer string; so here we just support the following
/// protocols and the variations mentioned below - in order of occurrence:
/// (1) Preceding theWord (theWord is whatever punctuation-less word we want to parse)
/// a)m_markers (in caller) b)m_inlineNonbindingMkrs c) m_precPunct d) m_inlineBindingMkrs
/// (2) Following theWord:
/// a)m_inlineBindingEndMkrs b) m_follPunct c) m_endMarkers d) m_follOuterPunct
/// e) m_inlineNonbindingEndMarkers
/// We expect information after theWord to comply with the order above. However, we parse
/// without comment the following variations:
/// (i) following punctuation preceding a) -- but we'll export in the above order
/// (ii) inline non-binding endmarkers which occur preceding d) -- but we'll export in the
/// above order
/// Note: the parser now supports ~ USFM fixed space conjoining of a word pair (but not
/// sequences or 3 words or more), and it will parse punctuation before or after (or both)
/// the ~ symbol and also any inline binding marker or endmarker occuring with either of
/// the conjoined words. The word~word conjoined pair are treated as a pseudo-merger.
/// Therefore, if the user does not want to retain the conjoining he can undo the merger
/// and he's just have two normal CSourcePhrase instances in sequence, storing those two
/// words separately, and punctuation on each where it should be. To restore the conjoining
/// would require selecting the two words and doing an "Edit Source Text" operation to
/// restore ~ to its place between them.
/// We also support [ and ] brackets delimiting material considered possibly
/// non-canonical. The parent, TokenizeText(), handles [, but we must handle ] within
/// ParseWord(). If ] is encountered (but we don't check within ~ conjoined pairs because
/// it is not a reasonable assumption that ] would occur between such a conjoining) then
/// we must immediately halt parsing, as that wordform and markers and puncts, etc, is
/// then deemed finished, so that on return to TokenizeText() ptr will be pointing at the
/// ] character, and then the latter function will do the parse of the closing ] symbol -
/// assigning it to an orphan CSourcePhrase, storing it in its m_follPunct member. This
/// protocol for handling ] works the same way regardless of whether or not the ]
/// character is designated a punctuation character - we treat it as if it was, even if not.
/// BEW 24Oct14 changes made for support of USFM nested markers (of form \+tag )
/// BEW 19Jul16 see comments re ] above, ]"<newline>\s caused a parse crash (actually assert
/// got tripped), so I need to have TokenizeText() handle puncts after the ] by parsing
/// over them to whitespace or marker following, and store the puncts after the ] on its
/// CSourcePhrase instance.
/// BEW 29May17 minor refactoring to support \xt, \xot etc within \f ... \f* or other
/// inline nonbinding marker spans (but x-ref inner markers in a footnote is the reason
/// prompting the changes - these are allowed in USFM markup, though not illustrated
/// within the ICAP USFM documentation) These changes backported from ParseWord2().
/// BEW 6Sep19 a refactoring hack in support of USFM3 attribute- or alternative- having
/// metadata for a small set of markers, to be hidden from the parse; but itemLen returning
/// the count of the word chars + skipped over metadata, but skipping the metadata
/// for m_srcPhrase and m_key -- Adapt It doesn't want that stuff (but PT8 does, if present)
/// whm 28Sep2023 added a pBuffStart parameter to determine initial buffers start for when
/// collecting context for warning message.
/// whm 24Oct2023 removed the wxASSERT(*ptr == chBar), and moved the 'if (*ptr == chBar)'
/// block to an outer block where it could be reached for attribute marker processing, and
/// storage of hidden attribute metadata in the pSrcPhrase->m_punctsPattern member and
/// setting of pSrcPhrase->m_bUnused = TRUE. 
/// Also removed IsAFilteringSFM() test from the bIsToBeFiltered test for early return from 
/// ParseWord(), and removed IsAFilteringSFM from tests in IsPostwordFilteringRequired(), 
/// EnterEmptyMkrsLoop(), and ContainsMarkerToBeFiltered() - replacing them with tests for 
/// existence of the marker in the gCurrentFilterMarkers instead. IsAFilteringSFM() wasn't 
/// reliable for testing the current filter status of a marker in those contexts.
///////////////////////////////////////////////////////////////////////////////
int CAdapt_ItDoc::ParseWord(wxChar* pChar,
	const wxChar* pBufStart, // whm 28Sep2023 added to determine initial buffer start
	wxChar* pEnd,
	CSourcePhrase* pSrcPhrase,
	wxString& spacelessPuncts, // caller determines whether it's src set or tgt set
	wxString& inlineNonbindingMrks, // fast access string for \wj \qt \sls \tl \fig
	wxString& inlineNonbindingEndMrks, // for their endmarkers \wj* etc
	bool& bIsInlineNonbindingMkr,
	bool& bIsInlineBindingMkr,
	bool bTokenizingTargetText)
{
	wxUnusedVar(inlineNonbindingEndMrks); // avoid compiler warning unreferenced formal parameter

	// BEW 30Sep19 Because I've split off ParsePreWord()'s code from the legacy ParseWord()
	// function, some variable are now unused. I'll use wxUnusedVar() for them so as to
	// avoid compiler warnings
	wxUnusedVar(bIsInlineBindingMkr);
	wxUnusedVar(bIsInlineNonbindingMkr);
	wxUnusedVar(inlineNonbindingMrks);

	// BEW 3Jun23 added next two lines, so that the jump to label elseBlock will meld
	// safely with the code which follows the skip over location; next 3 are Doc.h members
	CAdapt_ItApp* pApp = &wxGetApp();
	pApp->bSkipOverParseAWord = FALSE; // init, if goes TRUE, we want a jump to around 34447
	pApp->pSavePtr_forSkip = NULL; // use non NULL value for kickoff into code after ParseAWord()
	pApp->nSaveLen_forSkip = 0; // init, if we jump with a diffent ptr value, gotta keep the len value agreeing

	int len = 0;
	wxChar* ptr = pChar;
	int whitespaceLen = 0; // used for getting length of any whitespace characters
						  // preceding a USFM3 \esbe "study Bible sidebar endmarker"
						  // This is to allow users to place the marker inline, or
						  // after newline(s), and the parser will accept either -
						  // storing it to m_endMarkers of the current pSrcPhrase.
						  // It's value is returned in the signature of the function:
						  // bool FoundEsbeEndMarker(wxChar* pChar, int& whitespaceLen)
	wxString precPunct = pSrcPhrase->m_precPunct; // BEW added 25Aug23

#if defined (_DEBUG) && !defined(NOLOGS)
	{
		wxString pointsAt = wxString(ptr, 16);
		wxLogDebug(_T("ParseWord() line %d , Before ParseNumber() , ptr-> [%s]"), __LINE__, pointsAt.c_str());
		if (pSrcPhrase->m_nSequNumber >= 18)
		{
			int halt_here = 1; wxUnusedVar(halt_here);
		}
	}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
	if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
	{
		wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str() );
	}
#endif

	// BEW 8Sep23 In Nyindrou Bill came across this:  (666). before start of footnote, and it was parsed as
	// (666:. before the footnote. : instead of )  Fix that. Whitespace may preceed, so check for its
	// length so that the if test can have correct pointer values
	// BEW9Sep23 my first attempt worked, but it made parsing data like (9:9-13) fail when something internally
	// not a digit before the next ) is found, gets clobbered - asserts tripping in Nyindrou docs again. So
	// I'm trying a new way: keep bKeepPtrFromAdvancing set as default FALSE, let therefore ParsePreWord() gobble
	// the _T('(') that was start of (666), use *(ptr - 1) being an open parenthesis cause entry in the test,
	// and reject the parse if one of : or - or . or , are found before the matching closing parentheses.
	//if (pNewPtr < pEnd && *pNewPtr == _T('(') && IsAnsiDigit(*(pNewPtr + 1))) <<-- old way, when initial open paren not gobbled

	{ // scoped block starts
		//int nwhites = CountWhitesSpan(ptr, pEnd);
		wxChar* pNewPtr = ptr; //+ nwhites;
		if (pNewPtr < pEnd && *(pNewPtr - 1) == _T('(') && IsAnsiDigit(*pNewPtr))
		{
			len = 0;
			//wxChar colon = _T(':'); wxChar hyphen = _T('-'); wxChar period = _T('.'); wxChar semicolon = _T(',');

			// The above test is not sufficient, we can obtain the correct result only by parsing over
			// the digits, and then finding the next character is a matching _T(')') for the opening parenthesis.
			wxChar* pAux = pNewPtr; // protect pNewPtr from advance until the above condition is satisfied
			int numDigits = 0;
			numDigits = ParseNumber(pAux); // parse from the first digit to the end of digits
			if (numDigits > 0)
			{
				pAux += numDigits; // point at the wxChar following the digits
			}
			if (*pAux == _T(')'))
			{
				// success, the digits are followed by the matching closed parenthesis
				// BEW 14Feb24 we must put the ")", at the start of pSrcPhrase->m_follPunct so that
				// code below which removes puncts does not leave m_follPunct empty; which would mess
				// up MakeTargetStringIncludingPunctuation() to lack the ')' on pSrcPhrase->m_targetStr
				if (pSrcPhrase->m_follPunct.IsEmpty())
				{
					pSrcPhrase->m_follPunct = _T(')');
				}
				else
				{
					pSrcPhrase->m_follPunct += _T(')');
				}

				wxString strResult = wxString(pNewPtr, (numDigits + 1));
				len += (numDigits + 1);
				pNewPtr += (numDigits + 1); // pNewPtr now points at whatever follows _T(')') character
				// No markers involved, and no puncts within the (  ) parentheses, but puncts may follow
				// which belong to the pSrcPhrase - check and append them to form m_srcPhrase correctly
				// Since '(' got gobbled by ParsePreWord(), we have to restore it for m_key, etc
				pSrcPhrase->m_key = _T("(") + strResult;
				pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
				// BEW 13Feb24 setting m_key to have prefixed open parenthesis (a punctuation character)
				// is going to cause parsing error downstream, unless either we don't do so, or we 
				// permit it only temporarily, and then remove the ( and ) with a RemovePunctuation() call
				// using src text puncts set. Do the latter.
				CAdapt_ItDoc* pDoc = pApp->GetDocument();
				CAdapt_ItView* pView = pApp->GetView();
				int nSrcPunctsSet = 0; // we want src puncts, for use in RemovePunctuation
				wxString strSrcKey = pSrcPhrase->m_key;
				pView->RemovePunctuation(pDoc, &strSrcKey, nSrcPunctsSet);
				// Now fix m_key to have no wrapping parentheses
				pSrcPhrase->m_key = strSrcKey;
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 18)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s]  **FIXED** m_key has no parentheses"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif
				// Handle any puncts which might follow the closing parenthesis
				int punctsLen = ParseFinalPuncts(pNewPtr, pEnd, spacelessPuncts);
				if (punctsLen > 0)
				{
					wxString punctsStr = wxString(pNewPtr, punctsLen);
					pSrcPhrase->m_srcPhrase = pSrcPhrase->m_srcPhrase + punctsStr;
					// BEW 19Oct23, I forgot to append punctsStr to m_follPunct, do so here
					pSrcPhrase->m_follPunct += punctsStr;
					len += punctsLen;
					pNewPtr += punctsLen; // points at <space> before following word, when ParseWord()
					// returns, using len value, ptr wil be updated to point at same place
				}
#if defined (_DEBUG) && !defined(NOLOGS)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , After ParseNumber(). Returning len = %d,  ptr-> [%s]"),
						__LINE__, len, pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 18)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 19Oct23, the parenthesized number may not just have following puncts, but the pSrcPhrase
				// may be the last in a "red" mkr span, such as \f ....to.....\f*, and the \f* is not yet parsed.
				// Returning here without dealing with it will cause red run-on, and \f* will not get its pSrcPhrase
				// to have "end fn" in m_inform. So add here the test for following endMkr (get them all, if more than
				// one - e.g. \fk*\f* is a real possibility) advance ptr after storing in m_endMarkers and updated len
				// etc.
				ptr = pNewPtr;
				wxString wholeMkr; bool bIsAnEndMkr;
				wholeMkr = wxEmptyString;
				if (*ptr == gSFescapechar)
				{
					// a marker follows, is it an endMkr?
					wholeMkr = GetWholeMarker(ptr);
					int wholeMkrLen = wholeMkr.Length(); // whm 21Oct2023 added to prevent exception dur to uninitialized variable used below
					if (!wholeMkr.IsEmpty())
					{
						bIsAnEndMkr = IsEndMarker(ptr, pEnd);
						if (bIsAnEndMkr)
						{
							// collect the end mkrs, any binding ones first, then normals - like  \f*, then non-binding ones, like \wj*
							// (this is done elsewhere later in ParseWord() so check if I can copy the needed code to here, yep, can do )
							bool bWhiteAfterEndMkr;
							bool bIsANewline;
							bool bIsABeginMkr;
							// If any of those 3  goes TRUE, update len etc and return it to caller; but while they stay FALSE, we can
							// process (a) a binding endMkr like \fk* or \k* etc; then (b) any normal ones, like \f*, then (c) any
							// nonbinding ones, like \wj*. Deal with that set of ordered possibilities. Assume only 1 of each.
							bWhiteAfterEndMkr = FALSE;
							bIsANewline = FALSE;
							bIsABeginMkr = FALSE;
							wxString augWholeEndMkr;

							augWholeEndMkr = wholeMkr + _T(' ');
							wxChar* pAux = ptr + wholeMkrLen;
							int offset;
							offset = gpApp->m_charFormatEndMkrs.Find(augWholeEndMkr);
							if (offset >= 0)
							{
								// It's an inline binding endmkr, such as \it*
								wxString myCharEndMkrs = pSrcPhrase->GetInlineBindingEndMarkers(); // have to use accessor
								myCharEndMkrs << wholeMkr; // append the whole endMkr
								pSrcPhrase->SetInlineBindingEndMarkers(myCharEndMkrs); // set the new value
								// We have parsed over and stored the binding endMkr, so update len 
								len += wholeMkrLen;
								pAux += wholeMkrLen;
								// get ptr pointing at pAux, then don't use pAux again in this block
								ptr = pAux;	// ptr now points where pAux points
							}
							// If at ptr there is a beginMkr, go no further, and return len to the caller
							bIsAnEndMkr = IsEndMarker(ptr, pEnd);
							bWhiteAfterEndMkr = ParseWhiteSpace(ptr);
							if (!bIsAnEndMkr || bWhiteAfterEndMkr)
							{
								return len;
							}
							// soldier on, check for the endMkr being one of the m_RedMarkers set
							offset = -1; // init
							wholeMkr = GetWholeMarker(ptr);
							if (!wholeMkr.IsEmpty())
							{
								wholeMkrLen = wholeMkr.Length();
								bool bIsEndMkr = IsEndMarker(ptr, pEnd);
								if (bIsEndMkr)
								{
									augWholeEndMkr = wholeMkr + _T(' ');
									wxChar* pAux = ptr + wholeMkrLen; // pAux points at what follows the endMkr
									// Check for augWholeEndMkr being one of the m_RedMarkers set, eg. \f*
									offset = -1; // init
									offset = pApp->m_RedEndMarkers.Find(augWholeEndMkr);
									if (offset >= 0)
									{
										// It's an endMkr of the Red set, parse over it etc
										int nCountWhites = ParseWhiteSpace(pAux);
										// Is it followed by whitespace? how many?
										if (nCountWhites > 0)
										{
											bWhiteAfterEndMkr = TRUE;
										}
										// Is it followed by newline?
										bIsANewline = (*pAux == _T('\n') || (*pAux == _T('\r') && *(pAux + 1) == _T('\n')));
										// Is it followed by a beginMkr?
										bIsABeginMkr = FALSE; // init
										bIsAnEndMkr = IsEndMarker(pAux, pEnd);
										if (!bIsAnEndMkr)
										{
											bIsABeginMkr = TRUE;
										}
										// We know now what follows the endMkr, so after we deal with it, we can know whether or
										// not to return updated len value to caller, or test if a nonbinding endMkr follows
										wxString myEndMkrs = pSrcPhrase->GetEndMarkers(); // gets contents of m_endMarkers
										myEndMkrs << wholeMkr; // append the new whole endMkr
										pSrcPhrase->SetEndMarkers(myEndMkrs); // update m_endMarkers storage
										len += wholeMkrLen;
										ptr += wholeMkrLen; // ptr now points at where pAux points
										wxASSERT(ptr == pAux);
										// Are we done? any of these 3 being TRUE indicates parsing further is not valid
										if (bWhiteAfterEndMkr || bIsANewline || bIsABeginMkr)
										{
											return len;
										}
										// Is there a further endMkr? One from the nonbinding set? E.g. \wj*
										if (*ptr == gSFescapechar)
										{
											wholeMkr = GetWholeMarker(ptr);
											if (!wholeMkr.IsEmpty())
											{
												wholeMkrLen = wholeMkr.Length();
												augWholeEndMkr = wholeMkr + _T(' ');
												offset = -1; // init
												offset = gpApp->m_inlineNonbindingEndMarkers.Find(augWholeEndMkr);
												if (offset >= 0)
												{
													// It's one of the 10 known inline nonbinding endMkrs
													// and len, and store the endMkr in m_endMarkers then return len
													wxString myEndMkrs = pSrcPhrase->GetInlineNonbindingEndMarkers();
													myEndMkrs << wholeMkr;
													pSrcPhrase->SetInlineNonbindingEndMarkers(myEndMkrs);
													len += wholeMkrLen;
													ptr += wholeMkrLen;
													// after a non-binding endMkr there is no possibility of a
													// further endMkr, so control can just fall thru the return len call

												} // end of TRUE block for test: if (offset >= 0)
											} // end of TRUE block for test: if (*ptr == gSFescapechar)
										} // end of TRUE block for test: if (!wholeMkr.IsEmpty())

									} // end of TRUE block for test: if (offset >= 0)
								} // end of TRUE block for test: if (bIsEndMkr)
							}  // end of TRUE block for test: if (!wholeMkr.IsEmpty())

						} // end of TRUE block for test: if (bIsAnEndMkr)
					} // end of TRUE block for test: if (!wholeMkr.IsEmpty())
					
				} // end of TRUE block for test: if (*ptr == gSFescapechar)

			} // end of TRUE block for test: if (*pAux == _T(')'))
			// whm 21Oct2023 modified. An input test having something like "(300 kina)" would go into an infinite loop
			// creating duplicate pSrcPhrases until crashing due memory full situation. The crash results from not having
			// the code necessary to handle a non-numerical text content after the number and before the closing parenthesis.
			// So, I added an 'else if' block here to increment the len value by any numDigits that were parsed by ParseNumber() 
			// above, otherwise when no closing parenthesis follows the digits parsed, the len value will still be zero
			// even though ParseNumber() may have parsed some digits as when parsing "(300 kina)..." in which ParseNumber()
			// parsed the "300" returning a value of 3 to mumDigits, but since no closing parenthesis ')' follows the numDigits
			// value here would be lost and the result would be an infinite loop where ParseNumber() gets called in an infinite
			// loop each iteration creating a new source phrase. Also, I added the code necessary to update the pSrcPhrase->m_key
			// and pSrcPhrase->m_srcPhrase, as well as parse any final puncts after the number.
			else if (numDigits > 0)
			{
#if defined (_DEBUG) && defined (NOPAREN)
			if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
			{
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
			}
#endif
				len += numDigits;
				wxString strResult = wxString(pNewPtr, numDigits);
				pNewPtr += numDigits;
				pSrcPhrase->m_key = _T("(") + strResult;
				pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
				int punctsLen = ParseFinalPuncts(pNewPtr, pEnd, spacelessPuncts);
				if (punctsLen > 0)
				{
					wxString punctsStr = wxString(pNewPtr, punctsLen);
					pSrcPhrase->m_srcPhrase = pSrcPhrase->m_srcPhrase + punctsStr;
					// BEW 19Oct23, I forgot to append punctsStr to m_follPunct, do so here
					pSrcPhrase->m_follPunct += punctsStr;
					len += punctsLen;
					pNewPtr += punctsLen; // points at <space> before following word, when ParseWord()
					// returns, using len value, ptr wil be updated to point at same place
				}
			}
			// force a new pSrcPhrase, this one is finished
			return len;
		} // end of TRUE block for test: if (pNewPtr < pEnd && *(pNewPtr - 1) == _T('(') && IsAnsiDigit(*pNewPtr))
	} // scoped block ends

	// BEW 25Aug23, source data of this kind [including the ( and ) parentheses]: (2t) (2toea) (2 kina) (5MB) etc
	// currently get parsed as two pSrcPhrases: "(2" and then "t)" because our number parser, ParseChVerseUnchanged()
	// will parse only as far as the non-digit, and then the rest will go on a new pSrcPhrase. So here I'm building
	// a way to parse this kind of data for a single pSrcPhrase. The idea is that if "(<digit> is recognised, the
	// code will search for the matching ")" closing parenthesis, and accept all that's between provided that the
	// character prior to the ")" is not a digit.
	// This block needs to be early, because a few places further down will grab and store a "(" open parenthesis
	// making this code block fail to produce a result
	//bool bNextIsDigit;
	//bNextIsDigit = IsAnsiDigit(*(ptr + 1));
	bool bFoundParen;
	bFoundParen = FALSE; // init
	bool bLastIsDigit;
	bLastIsDigit = FALSE; // init
	int nSpanLen; int nLimit;
	nLimit = 16; // hopefully is enough. (, ), a space, one digit, one non-digit 
				   // is 5 characters, leaves another 11 available - for another digit and alpha
	wxString strTotal;
	wxString strContents;
	bool bAlreadyGotOpeningParen;
	bAlreadyGotOpeningParen = precPunct == _T("(") ? TRUE : FALSE;
	if ( (*ptr == _T('(') && !bAlreadyGotOpeningParen) || bAlreadyGotOpeningParen )
	{
#if defined (_DEBUG) && !defined(NOLOGS)
		{
			wxString pointsAt = wxString(ptr, 16);
			wxLogDebug(_T("ParseWord() line %d, PARENTHESES, ptr-> [%s]"), __LINE__, pointsAt.c_str());
			if (pSrcPhrase->m_nSequNumber >= 8)
			{
				int halt_here = 1; wxUnusedVar(halt_here);
			}
		}
#endif
#if defined (_DEBUG) //&& defined (NOPAREN)
		if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
		{
			wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
		}
#endif

		// search for the closing parenthesis, within 16 following characters
		bFoundParen = FindClosingParenthesis(ptr, pEnd, nSpanLen, nLimit, bAlreadyGotOpeningParen);
		if (bFoundParen)
		{
#if defined (_DEBUG) && !defined(NOLOGS)
			{
				wxString pointsAt = wxString(ptr, 16);
				wxLogDebug(_T("ParseWord() line %d , bFoundParen was TRUE , ptr-> [%s]"), __LINE__, pointsAt.c_str());
				if (pSrcPhrase->m_nSequNumber >= 8)
				{
					int halt_here = 1; wxUnusedVar(halt_here);
				}
			}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
			if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
			{
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
			}
#endif
			// Finding ) is not enough. The result is only acceptable if the character
			// preceding the closing parenthesis is NOT a digit
			wxChar* pPrev;
			pPrev = (ptr + nSpanLen - 2);
			bLastIsDigit = IsAnsiDigit(*pPrev);
			if (!bLastIsDigit)
			{
				// The character prior to the closing ) parenthesis is NOT a digit, so
				// the outcome is a successful parse. Update pSrcPhrase and len, and
				// return len to TokenizeText() to force a new pSrcPhrase for what follows
				strTotal = wxString(ptr, nSpanLen);
				if (bAlreadyGotOpeningParen)
				{
					// ( is already in pSrcPhrase->m_precPunct
					wxChar openParen = pSrcPhrase->m_precPunct.GetChar(0);
					int newlen;
					newlen = strContents.Length();
					newlen = newlen; // avoid gcc warning set but not used warning
					pSrcPhrase->m_follPunct = strTotal.GetChar(nSpanLen - 1);
					strContents = strContents.Left(nSpanLen - 1); // remove the ) at the end
					pSrcPhrase->m_key = strContents;
					pSrcPhrase->m_srcPhrase = openParen + strTotal;
				}
				else
				{
					strContents = strTotal.Mid(1); // remove the ( character
					int newlen;
					newlen = strContents.Length();
					strContents = strContents.Left(newlen - 1); // remove the ) at the end
					pSrcPhrase->m_precPunct = strTotal.GetChar(0);
					pSrcPhrase->m_follPunct = strTotal.GetChar(nSpanLen - 1);
					pSrcPhrase->m_key = strContents;
					pSrcPhrase->m_srcPhrase = strTotal;
				}
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
				}
#endif
				len = nSpanLen;
				ptr += len;
				return len; // return to TokenizeText(), to get a new pSrcPhrase
			}

			// If bLastIsDigit is TRUE, ptr will not advance and control will exit the
			// block to test IsAnsiDigit() next - to parse numbers etc not enclosed by ( ... )
		}
	} // end of TRUE block for test: if (*ptr == _T('(') && bNextIsDigit)
						   
						   
//	wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
#if defined (_DEBUG) && !defined(NOLOGS)
	wxString pointsAt = wxString(ptr, 20);
	wxLogDebug(_T("ParseWord() START, line %d : sequNum= %d , ptr->%s "), __LINE__, pSrcPhrase->m_nSequNumber, pointsAt.c_str());
	if (pSrcPhrase->m_nSequNumber >= 4)
	{
		int halt_here = 1; wxUnusedVar(halt_here);
	}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
	if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
	{
		wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
	}
#endif

	// BEW 28Nov22 For data like ibaib|ibaib where the bar followed by same word is a markup error
	// (it does absolutely nothing useful) we want to remove the "|ibaib" part to "heal" the input
	// doc programmatically. I have code for this - but much further down, so more recent code additions
	// just below cause a misparse. A bar causes ParseAWord() to immediatly exit, so we need the 
	// bogus bar code moved up to here.

	// BEW 25Jul23 moved it up from following the ParseAWord() call, as unhandled bar info crashes
	// ParseAWord(). Do it here as a bleeding functionality, if ptr points at a charAttributeMkr
	// on entry.
	wxString theWord2;
	theWord2 = wxEmptyString;
	wxChar chBar = _T('|');
	if (*ptr != gSFescapechar)
	{
		// whm 31Oct2023 modification needed. The if (*pAux == chBar) block below could never be TRUE 
		// at its original location WITHIN the TRUE block of the outer else if (*ptr == gpEscapechar) block.
		// Therefore, if (*pAux == chBar) block needs to be here, within this outer if (*ptr != gSFescapechar) 
		// block if it is to be reachable. If left within its original location it's execution is
		// skipped and that was leading to the "Warning: Unrecognized Markers..." message. Moreover,
		// at its original location, the ScanToNextMarker() code within this block was never getting to 
		// do its work.
		// Hence, as of this date, I have moved the following if (*pAux == chBar) test and block to 
		// here where it can be reached - and I've moved some initializations and done some 
		// coding modifications to make it work here.
		
		// whm 31Oct2023 the following if (*ptr == chBar) block is no longer relevant for the
		// parsing of hidden metadata within an charAttributeMarker. The (*ptr == chBar) block
		// might, however, be executed in the event that the text has an isolated bar '|' character
		// within the text for some other reason/purpose. 
		// NOTE: I created a unit test to see how the existing code below handles the olde and usfm
		// obsolete bar '|' character code markings such as |i this is italic|r, and this is |b bold|r
		// etc. Results: when non-attribute markup is being processed, the bar '|' character and 
		// everything past that point until a following marker gets put into the hidden storage location
		// pSrcPhrase->m_punctsPattern. Clearly that kind of handling of a bar character is not desirable
		// here within ParseWord() now that TokenizeText() handles char attribute marker metadata hiding.
		// 
		// TODO: Rework the following code block to be more forgiving and perhaps substitute some 
		// appropriate usfm markup for the bar code character markup, such as:
		//	\em …\em* for emphasis text.
		//	Syntax \em_text...\em*
		//	\bd …\bd* bold text
		//	Syntax \bd_text...\bd*
		//	\it …\it* italic text
		//	Syntax \it_text...\it
		//	\bdit …\bdit* boldand italic text
		//	Syntax \bdit_text...\bdit*
		//	\no …\no* normal text
		//	Syntax \no_text...\no*
		//	May be used when a larger paragraph element is set in an alternate font style(e.g.italic), 
		//    and a selected section of text should be displayed in normal text.
		//	\sc …\sc* small - cap text
		//	Syntax \sc_text...\sc *
		//	\sup …\sup * superscript text
		//	Typically for use in critical edition footnotes.
		// TODO: Above mods in the block below
		// whm 17Jan2024 if the current marker is a \free marker it may be followed by "|@number@|"
		// we don't want the block below to be entered
		if (*ptr == chBar && (ptr + 1) != pEnd && *(ptr + 1) != _T('@')) // if (*pAux == chBar)
		{
			// whm 31Oct2023 The following code moved here from within the else if (*ptr == gSFescapechar)
			// block below.
			// 
			// Remove any bad markup, such as word|word where 'word' is the same both sides of the bar,
			// returning so that the bogus markup is parsed over but forgotten.
			// Then, if bar is followed by some valid character attribute markup, process through to
			// saving the contents in m_punctsPattern		
			wxChar* pAux = ptr; // leave ptr pointing at the bar
			wxChar* pWhitePtr = NULL;
			wxChar* pBar = ptr; // BEW 6Jan23 need this for hunting to the next mkr
			// we need to save the post-bar pointer location, for use in the code below. Use pAuxSave
			wxChar* pAuxSave = ptr;
			if (pAuxSave < pEnd)
			{
				pAuxSave++; // this is the start of the post-bar text
			}
			// Use pAux in this block, don't want to advance ptr if fixing the above markup error
			// Advance pAux to the next whitespace, and set pWhitePtr to point at it
			while ((pAux < pEnd) && !IsWhiteSpace(pAux))
			{
				pAux++;
			}
			pWhitePtr = pAux; // This is the space after theWord, perhaps - following code determines true or false

			// make a string of what's between pAux and pWhitePtr
			wxString afterStr = wxString(pAuxSave, (size_t)(pWhitePtr - pAuxSave));
			// Now check if afterStr is identical to theWord. If so, we have bogus markup, and
			// we can now fix it (parsing over the bar and afterStr and ignoring these in
			// the len value to be returned to TokenizeText()
			if (afterStr == theWord2)
			{
				// It's bogus markup. Fix it.
				int theWord2Length = theWord2.Length();
				if (len == 0)
				{
					// We've not counted the chars in theWord yet, so do so
					len = theWord2Length;
				}
				wxASSERT(len == theWord2Length);
				// Get ptr updated to point at pWhitePtr in the input text, and ptr in caller to
				// also be beyound the "|ibaib" ( or whatever ), otherwise, returning from ParseWord()
				// will start a new pSrcPhrase pointing at "|ibaib<space..... which will cause
				// ParseAWord() to exit empty, and it's wxASSERT to trip (in Release version, a crash)
				ptr = pWhitePtr;
				len += (1 + len); // '1' included to get past the bar
				return len; // go back to TokenizeText(), the bogus markup should now be fixed
			}

			// We are not correcting something like abaib|abaib, so scan to the end of endMkr (if the scan
			// gets to a beginMkr, return the count, without including the beginMkr width)
			ptr = pBar;
			int nScannedWidth = ScanToNextMarker(pBar, pEnd);
			if (nScannedWidth > 0)
			{
				// squirrel the span away in pSrcPhrase->m_punctsPattern, and set m_bUnused = TRUE
				wxString contents = wxString(pBar, nScannedWidth);
				len += nScannedWidth;
				pSrcPhrase->m_punctsPattern = contents;
				pSrcPhrase->m_bUnused = TRUE;
				return len;
			}
			else
			{
				pSrcPhrase->m_punctsPattern.Empty();
				// don't send len zero to TokenizeText. Since we started by pointing at a bar,
				// increase len by 1, to give TokenizeText() a chance to advance without a crash
				len += 1;
				return len;
			}

		} // end of TRUE block for test: if (*pAux == chBar)
		
		// is there a bar, but with a word preceding? Set theWord to whatever precedes the bar
		bool bWordNotParsed = FALSE;
		theWord2 = ParseAWord(ptr, spacelessPuncts, pEnd, bWordNotParsed);
		int theWord2Len;
		theWord2Len = theWord2.Length();
		wxChar chAfter = *(ptr + theWord2Len); // is it a bar?
		// if chAfter is indeed a bar, we can check in the else if block for worthless markup 
		// like abaib|abaib and remove it - thereby healing the doc of that kind of error
		if (chAfter != chBar)
		{
			// unexpected, the only safe thing to do is to let the else if block deal with it,
			// and we set theWord back to an empty string
			theWord2.Empty();
		}
	}
	else if (*ptr == gSFescapechar)
	{
		int itemLen;
		itemLen = 0; // init
		int offset;
		offset = wxNOT_FOUND; // init
		wxString theMkr;
		theMkr = GetWholeMarker(ptr);
		wxString augTheMkr;
		augTheMkr = theMkr + _T(' ');
		bool bIsCharAttributeMkr;
		bIsCharAttributeMkr = FALSE; // init
		bIsCharAttributeMkr = bIsCharAttributeMkr; // avoid gcc warning set but not used warning
		offset = charAttributeMkrs.Find(augTheMkr); // if found, it's guaranteed to be a beginMkr
#if defined (_DEBUG) && defined (NOPAREN)
		if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
		{
			wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
		}
#endif
		if (offset >= 0)
		{
			// We've a character attribute begin mkr to deal with, to hide the bar-initial data
			// in pSrcPhrase's m_punctsPattern member, and set repurposed m_bUnused to TRUE
			itemLen = augTheMkr.Length();
			len = itemLen;
			ptr += len;
			itemLen = 0;
			// in case there is more than one space following theMkr, count any extra spaces before
			// the bar, skip over them to leave ptr pointing at the bar, but increase len by the
			// number of spaces beyond one.
			itemLen = CountSpaces(ptr, pEnd);
			if (itemLen > 0)
			{
				len += itemLen;
				ptr += itemLen;
			}
			itemLen = 0;
			// whm 24Oct2023 modification. At this point there is always going to be some \fig caption
			// text BEFORE the chBar. The USFM documentation gives two \fig examples of this. 
			// The first example has the following text string for \fig:
			// \v 18 At once they left their nets and went with him.\fig At once they leftCRLF
			// their nets.|src="avnt016.jpg" size="span" ref="1.18"\fig*
			// The \fig and associated text - when filtered in AI - has the above filtered string 
			// stored like this:
			//"\\fig At once they left\r\ntheir nets.|src=\"avnt016.jpg\" size=\"span\" ref=\"1.18\"\\fig* "
			// Now, since ptr is pointing at the first word "At..." past the marker, there are at this
			// point 6 more words that must be parsed before reaching the chBar character.
			// Therefore, the following wxASSERT() was not appropriate here as it will asssert for each
			// word we encounter/parse before reaching the chBar character. Moreover, the rest of the
			// code below is not appropriate for this block especially the if (*pAux == chBar) test and 
			// block below which was moved this date back to TokenizeText() AFTER the ParseWord() call.
			//wxASSERT(*ptr == chBar);
			// 
			// whm 31Oct2023 Now, since we've just parsed one of the charAttributeMkrs, to make the code
			// back in TokenizeText() - after ParseWord() exits - work properly, we need to call 
			// SetInlineNonbindingMarkers(theMkr) here, while we're dealing with the \fig begin 
			// marker. Here within ParseWord() we've only detected whether the \fig marker is present, 
			// and are storing "\\fig" in pSrcPhrase's m_inlineNonbindingMarkers member.
			pSrcPhrase->SetInlineNonbindingMarkers(augTheMkr);
			// NOTE: When we get to the last word of the attribute marker's caption text we'll need to
			// call the SetInlineNonbindingEndMarkers() function, but that will happen elsewhere.


			/*
			// whm 31Oct2023 The following code items for handling char attribute marker bar '|' content
			// are no longer handled here within ParseWord() but back within TokenizeText() AFTER the ParseWord()
			// function call. See notes above.

			// Remove any bad markup, such as word|word where 'word' is the same both sides of the bar,
			// returning so that the bogus markup is parsed over but forgotten.
			// Then, if bar is followed by some valid character attribute markup, process through to
			// saving the contents in m_punctsPattern		
			wxChar* pAux = ptr; // leave ptr pointing at the bar
			wxChar* pWhitePtr = NULL;
			wxChar* pBar = ptr; // BEW 6Jan23 need this for hunting to the next mkr
			// we need to save the post-bar pointer location, for use in the code below. Use pAuxSave
			wxChar* pAuxSave = ptr;
			if (pAuxSave < pEnd)
			{
				pAuxSave++; // this is the start of the post-bar text
			}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
			{
				wxString pointsAt = wxString(ptr, 16);
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , ptr->[%s]"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
				if (pSrcPhrase->m_nSequNumber >= 4)
				{
					int halt_here = 1; wxUnusedVar(halt_here);
				}
			}
#endif
			*/

			// whm 31Oct2023 The following code items for handling char attribute marker bar '|' content
			// are no longer handled here within ParseWord() but back within TokenizeText() AFTER the ParseWord()
			// function call. See notes above.
			/*
			if (*pAux == chBar)
			{

				// Use pAux in this block, don't what to advance ptr if fixing the above markup error
				// Advance pAux to the next whitespace, and set pWhitePtr to point at it
				while ((pAux < pEnd) && !IsWhiteSpace(pAux))
				{
					pAux++;
				}
				pWhitePtr = pAux; // This is the space after theWord, perhaps - following code determines true or false						

				// make a string of what's between pAux and pWhitePtr
				wxString afterStr = wxString(pAuxSave, (size_t)(pWhitePtr - pAuxSave));
				// Now check if afterStr is identical to theWord. If so, we have bogus markup, and
				// we can now fix it (parsing over the bar and afterStr and ignoring these in
				// the len value to be returned to TokenizeText()
				if (afterStr == theWord2)
				{
					// It's bogus markup. Fix it.
					int theWord2Length = theWord2.Length();
					if (len == 0)
					{
						// We've not counted the chars in theWord yet, so do so
						len = theWord2Length;
					}
					wxASSERT(len == theWord2Length);
					// Get ptr updated to point at pWhitePtr in the input text, and ptr in caller to 
					// also be beyound the "|ibaib" ( or whatever ), otherwise, returning from ParseWord()
					// will start a new pSrcPhrase pointing at "|ibaib<space..... which will cause
					// ParseAWord() to exit empty, and it's wxASSERT to trip (in Release version, a crash)
					ptr = pWhitePtr;
					len += (1 + len); // '1' included to get past the bar
					return len; // go back to TText(), the bogus markup should now be fixed
				}

				// We are not correcting something like abaib|abaib, so scan to the end of endMkr (if the scan
				// gets to a beginMkr, return the count, without including the beginMkr width)
				ptr = pBar;
				int nScannedWidth = ScanToNextMarker(pBar, pEnd);
				if (nScannedWidth > 0)
				{
					// squirrel the span away in pSrcPhrase->m_punctsPattern, and set m_bUnused = TRUE
					wxString contents = wxString(pBar, nScannedWidth);
					len += nScannedWidth;
					pSrcPhrase->m_punctsPattern = contents;
					pSrcPhrase->m_bUnused = TRUE;
					return len;
				}
				else
				{
					pSrcPhrase->m_punctsPattern.Empty();
					// don't send len zero to TokenizeText. Since we started by pointing at a bar,
					// increase len by 1, to give TokenizeText() a chance to advance without a crash
					len += 1;
					return len;
				}

			} // end of TRUE block for test: if (*pAux == chBar)
			*/

		} // end of the TRUE block for test: if (offset >= 0)
	} // end of the TRUE block for test: if (*ptr == gSFescapechar)
#if defined (_DEBUG) && defined (NOPAREN)
	if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
	{
		wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
	}
#endif

	// BEW 14Jul14, prior to this date, ParseWord would parse over any trailing whitespace
	// at the end of the "word" (meaning, and markers and endmarkers, and preceeding and
	// following and/or following outer, punctuation, and any internal to such structures
	// spaces, and any outer punctuation such as curly quotes outside of curly quotes), but
	// from now on we want the length value returned to the caller to just be the length of
	// the parsed material as far as the START of the trailing whitespace which delimits the
	// boundary between two successive "words" - because we want the called, TokenizeText()
	// at the start of its parse loop to intercept and store in pSrcPhrase->m_srcWordBreak
	// wxString member whatever the whitespace(s) char(s) is/are which precede each word.
	// By storing them, we can use them to restore the whitespace types in the translation
	// text at USFM marked up translation export time. So our approach below is to look for
	// each place where len is returned, and prior to it, insert code which will backtrack
	// the ptr till it points at the first character of any immediately preceding whitespace,
	// and decrement the len value accordingly, and then return it.

	int itemLen = 0;
	wxString emptyStr = _T("");
	wxString aSpace = _T(" ");
	wxString usfmFixedSpace = _T("~"); // USFM fixedspace symbol
	USFMAnalysis* pUsfmAnalysis = NULL;
	wxUnusedVar(pUsfmAnalysis);

	wxString bareMkr;
	wxString bareEndMkr;
	wxString wholeMkr;
	wxString wholeEndMkr;
	wxString wholeMkrPlusSpace;
	bool bExitParseWordOnReturn = FALSE; wxUnusedVar(bExitParseWordOnReturn); // avoid compiler warning variable initialized but not referenced
	int nFound = wxNOT_FOUND; wxUnusedVar(nFound); // avoid compiler warning variable initialized but not referenced
	bool bHasPrecPunct = FALSE; wxUnusedVar(bHasPrecPunct); // avoid compiler warning variable initialized but not referenced
	//bool bHasOpeningQuote = FALSE; // set but not used
	bool bParsedInlineBindingMkr = FALSE;
	wxUnusedVar(bParsedInlineBindingMkr);

	//wxString finalPunctBeforeFixedSpaceSymbol;
	//wxString precedingPunctAfterFixedSpaceSymbol;
	//finalPunctBeforeFixedSpaceSymbol.Empty();
	//precedingPunctAfterFixedSpaceSymbol.Empty();
	//CSourcePhrase* pSrcPhrWord1 = NULL;
	//CSourcePhrase* pSrcPhrWord2 = NULL;
	int nHowManyWhites = 0; wxUnusedVar(nHowManyWhites); // avoid compiler warning variable initialized but not referenced
	//wxChar* pMaybeWhitesStart = NULL; // set but not used
	wxChar* pMaybeWhitesEnd = NULL; wxUnusedVar(pMaybeWhitesEnd); // avoid compiler variable initialized but not referenced
	wxString wordBuildersForPreWordLoc;
	wxString wordBuildersForPostWordLoc; wordBuildersForPostWordLoc.Empty();
	// next pair for use with the second word in a conjoined pair, when a punct is being
	// restored to word-building status
	wxString wordBuildersFor2ndPreWordLoc;
	wxString wordBuildersFor2ndPostWordLoc; wordBuildersFor2ndPostWordLoc.Empty();
	// next pair for use with the second word in a conjoined pair, when a word-building
	// character has just been made a punct character
	//wxString newPunctFrom2ndPreWordLoc;
	//wxString newPunctFrom2ndPostWordLoc; newPunctFrom2ndPostWordLoc.Empty();
	// BEW 24Oct14 added next two lines for USFM nested marker support when parsing
	wxString tagOnly;
	bool bIsNestedMkr = FALSE;
	wxUnusedVar(bIsNestedMkr);

	wxString baseOfEndMkr;

	// BEW added test 21Mar17
	if (len == 0 && ptr == pEnd)
	{
		return len;
	}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
	{
		wxString pointsAt = wxString(ptr, 20);
		if (pSrcPhrase->m_nSequNumber >= 30)
		{
			int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
		}
	}
#endif

	// BEW 30Dec22, revised comment 17May23: check doc member boolean, m_bWidowedParenth for TRUE, (it's TRUE when 
	// ptr in TokenizeText() is pointing at space and followed by an isolated open parenthesis character and
	// typically followed by a newline. The problem is that if ParseAWord() has to deal with that, it immediately 
	// asserts because ParseAWord() has found nothing. 
	// But ParseAWord() is called again much further down - so fix it here, or else another assert trip will happen
	// later. We want the next pSrcPhrase to point at the start of the next src text line - which may start with
	// a beginMkr, such as \v - though what it starts with is irrelevant to the issue to solve here. 
	// TokenizeText has to determine the problem exists, and set a doc member boolean, m_bWidowedParenth, dedicated 
	// to this issue alone. Encapsulate the solution in the TRUE block of its test, and make sure than the
	// boolean is cleared to FALSE afterwards.
	m_bWidowedParenth = FALSE; // init
	wxChar chOpenParenth = _T('(');
#if defined (_DEBUG) && defined (NOPAREN)
	if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
	{
		wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
	}
#endif

	// whm 18Aug2023 modified following if test to also check for CR at ptr+2 since text coming from Paratext during
	// collaboration has EOL's as CRLF "\r\n". Testing for '\r' OR '\n' at ptr+2 will test TRUE for either '\n' or "\r\n"
	// following a chOpenParenth '(' at ptr+1.
	if ((*ptr == aSpace) && (*(ptr + 1) == chOpenParenth) && ((*(ptr + 2) == _T('\r')) || (*(ptr + 2) == _T('\n'))))
	{
		m_bWidowedParenth = TRUE;
	}
	if (m_bWidowedParenth)
	{
		pSrcPhrase->m_precPunct = chOpenParenth;
		// Make the '(' character visible in the GUI, even though pSrcPhrase->m_key is, and must remain, empty
		pSrcPhrase->m_srcPhrase = chOpenParenth;
		// Find out the distance from ptr to the next newline, since the data in which this problem occurs
		// only has the ( character near line end, and only space (or spaces, or perhaps no spaces) follow until
		// newline is encountered. However much there is after the ( character is in the document src text being
		// parsed, so to keep in sync with TokenizeText, we want to return a len value which includes the newline,
		// so that the next pSrcPhrase will be generated for whatever follows on the next data line - perhaps \v
		wxChar newline = _T('\n');
		int counter = 0;
		wxChar* pAux;
		pAux = ptr;
		while (*pAux != newline)
		{
			pAux++;
			counter++;
		}
		//len = counter + 1; // we want the newline included in the len value ?? do we
		len = counter; // we don't want the newline included in the len value
		m_bWidowedParenth = FALSE; // gotta turn it back off before returning a len value to TokenizeText()
		return len;
	}

#if defined (_DEBUG) && !defined(NOLOGS)
		pointsAt = wxString(ptr, 16);
	wxLogDebug(_T("ParseWord() line %d , m_curChapter= [%s], pSrcPhrase->m_nSequNumber %d , len %d , pointsAt=%s"), 
		__LINE__, pApp->m_curChapter.c_str(), pSrcPhrase->m_nSequNumber, len, pointsAt.c_str());
#endif
#if defined (_DEBUG) && defined (NOPAREN)
	if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
	{
		wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
	}
#endif

	if (m_bWidowedBracket)
	{
		// Control gets here without any explicit check for a previous \p marker, but it should suffice
		// that the previous character is '['  Try it. Yep, but we also need to check that ptr points at newline,
		// or at space following by newline - if not true, the [ is not widowed and if so, don't return a len
		// value to TokenizeText() here
		if (*(ptr - 1) == _T('['))
		{
			// len starts off as zero here
			wxChar openBracket = *(ptr - 1);
			// So far, so good
			wxChar newline = _T('\n');
			wxChar space = _T(' ');
			wxChar* pAux = ptr;
			if (*pAux == newline)
			{
				pSrcPhrase->m_precPunct = openBracket;
				pSrcPhrase->m_srcPhrase = openBracket;
				ptr++;
				len = 1; // to count the newline - never return new as zero to TokenizeText()
				m_bWidowedBracket = FALSE; // clear, in case another isolate [ comes up
				return len;
			}
			else
			{
				if (*pAux == space && *(pAux + 1) == newline)
				{
					// if this test fails, ptr has not changed in value; if it succeeds, its okay to augment ptr
					pSrcPhrase->m_precPunct = openBracket;
					pSrcPhrase->m_srcPhrase = openBracket;
					ptr += 2;
					len = 2;
					m_bWidowedBracket = FALSE; // clear, in case another isolate [ comes up
					return len;
				}
			}
		}
		m_bWidowedBracket = FALSE; // must clear, even if this attempt fails
	}

	// we are now at the first character of the word (or phrase)
	// BEW 17Jul23 we no longer use these, except bMatchedFixSpaceSymbol is used, with permanent FALSE, initialized here
	//wxChar* pWordProper = ptr;
	// the next four variables are for support of words separated by ~ fixed space symbol
	//wxChar* pEndWordProper = NULL;
	//wxChar* pSecondWordBegins = NULL;
	//wxChar* pSecondWordEnds = NULL;
	bool bMatchedFixedSpaceSymbol = FALSE;

	// BEW 6Sep19 preserve this ptr location for USFM3 support, in the skip
	// done after the parser (either one) finishes. We'll find the bar (|)
	// character starting our search from here
	//m_pPreservePreParseWordLocation = ptr;

	//wxString inlineBindingEndMkrBeforeFixedSpace;  // moved to be earlier because of the done: goto jump
	//wxString inlineBindingMkrAfterFixedSpace;      // ditto

	wxString theWord = wxEmptyString; // intialise - used in the caching support
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
	{
		wxString pointsAt = wxString(ptr, 20);
		//		wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , ptr->%s"),
		//			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pointsAt.c_str());
		if (pSrcPhrase->m_nSequNumber >= 3)
		{
			int halt_here = 1; wxUnusedVar(halt_here);
		}
	}
#endif

	// BEW 9Sep19 For support of USFM 3 attribute marker hiding. Test here if the word
	// at ptr is within the cached word string at m_cachedWordBeforeBar. If it is, then
	// probably we are at the CSourcePhrase where bar ( | ) is, and where we'll hide
	// the cached metadata at m_cachedAttributeData within this CSourcePhrase instance's
	// m_punctsPattern wxString. To make sure the match of the word above is not bogus,
	// the function here that determines that the strings agree, should also search forward
	// to verify that there is a bar ( | ) character before a space is encountered. If all's
	// well, then we have to find the place in this ParseWord() where to jump ptr to in
	// order to 'hide' the metadata, do the caching to m_punctsPattern, and add the length of
	// the cached data to len, and then have processing continue in ParseWord to handle
	// the endmarker store and any puncts etc which occur after that.
	bool bSkipLegacyParsingBlock = FALSE; // initialize - ensure entry to the legacy parsing block
					// even when control is within a marker attributes caching span

	bool bThisIsIt = FALSE; // initialise
//	wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
	if (m_bWithinMkrAttributeSpan && !bSkipLegacyParsingBlock) // BEW added 30Sep19
	{
		// Check if ptr has arrived at the CSourcePhrase which is the one
		// on which the metadata is to be "hidden" from being seen in the GUI	

		// The way to test of control has reached the being-built pSrcPhrase which is to store
		// the cache string that TokenizeText's call of bool IsAttributeMarker() has produced is:
		// 1. get the word at ptr and store in a temporary wxString
		// 2. check for a match with the word in Doc's m_cachedWordBeforeBar
		// 3. If there was no match, then the pile ptr is not yet pointing at the cache location, 
		//   so let the pile pointer advance
		// 4. If there is a match, then the current pile is the one for doing the caching (i.e.
		//    assigning the cache string to m_punctPattern, setting m_bUnused to TRUE.Also store
		//    endmarker, set m_key and m_srcPhrase, get correct len value calculated, and then
		//    clean up - which clears out the cached stuff and sets m_bWithinMkrAttributeSpan FALSE
		wxChar* pAux = ptr;
		wxChar* savePtr = ptr; // preserve the location of the start of the pre-bar info, we will
							   // need it later when we've finalized len value, and we want to
							   // check if punctuation follows. If it does, it goes in m_follPunct
							   // on the current pSrcPhrase
#if defined (_DEBUG) && !defined(NOLOGS)
		{
			wxString pointsAt = wxString(ptr, 20);
			wxString precedingPuncts = pSrcPhrase->m_precPunct;
			wxString m_mkrs = pSrcPhrase->m_markers;
			wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , beginMkr stored:  %s , pSrcPhase->m_precPunct = %s : ptr->%s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->GetInlineBindingMarkers().c_str(), precedingPuncts.c_str(), pointsAt.c_str());
			if (pSrcPhrase->m_nSequNumber >= 3)
			{
				int halt_here = 1; wxUnusedVar(halt_here);
			}
		}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
		if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
		{
			wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
		}
#endif
		wxString tempStr = wxEmptyString; // initialise
		while (!IsWhiteSpace(pAux) && (*pAux != m_strBar))
		{
			tempStr += *pAux;
			++pAux;
		}
		//wxASSERT(!tempStr.IsEmpty()); // BEW 5Nov22, Don't assert. ptr may already be pointing at bar
		// in which case tempStr would be empty, because control is already where the while loop is 
		// trying to get to.

		// Check for a match with m_cachedWordBeforeBar BEW 5Nov22 commented out assert above,
		// and added check for non-empty tempstr to next test. bThisIsIt is to be TRUE only
		// when we've matched temptStr to m_cachedWordBeforeBar
		if (!tempStr.IsEmpty() && tempStr == m_cachedWordBeforeBar)
		{
			bThisIsIt = TRUE;
		}
		if (bThisIsIt)
		{
			int nWordLen = (int)m_cachedWordBeforeBar.Len();
			len += nWordLen;

			// BEW 6Apr20 we don't allow the m_punctsPattern member to
			// have content at a pSrcPhrase which we want to store
			// cached attributes data on - unless, of course, the source
			// text at that point only has a single word - in which case
			// the cached data must be stored in m_punctsPattern, otherwise
			// it would get lost. 
			// (For mergers with internal punctuation, it will have content 
			// unrelated to the cached metadata.) Which should win? 
			// The caching of metadata has to win, because otherwise that
			// metadata information would get lost.
			if (pSrcPhrase->m_bHasInternalPunct)
			{
				// Get rid of that stuff
				pSrcPhrase->m_punctsPattern.Empty();
				pSrcPhrase->m_bHasInternalPunct = FALSE;
				pSrcPhrase->m_bUnused = FALSE;
			}

			// Save the metadata in pSourcePhrase's m_punctsPattern
			pSrcPhrase->InsertCachedAttributesMetadata(m_cachedAttributeData);
			// Now, this data which is bar and what follows up to the 
			// beginning of the relevant endmarker, is hidden away and 
			// takes no further part in what the user sees in the GUI, 
			// but is available for restoration in the appropriate place 
			// when preparing a collaboration export for transfer of the
			// target text to Paratext or Bibledit
			pSrcPhrase->m_bUnused = TRUE; // flag the CSourcePhrase to be one with
					// metadata squirreled away in m_punctsPattern. Building an
					// export text for transfer to Paratext 8 (or Bibledit) will use this; 
					// nothing else in the AI code will use it

			m_bHiddenMetadataDone = TRUE;  // TRUE prevents the block at 33,203 approx
					// from being entered prematurely, it can be entered to  get
					// the ptr adjustment done only when the cached data has
					// been put into m_punctsPattern

			// BEW 27Sep22 Unless we do it here, the pSrcPhrase will not get m_key
			// and m_srcPhrase members filled with their content. Do it here.
			// The needed wxString content is in the doc's m_cachedWordBeforeBar member
			theWord = m_cachedWordBeforeBar;
			//			wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
			pSrcPhrase->m_key = m_cachedWordBeforeBar;
			if (!pSrcPhrase->m_precPunct.IsEmpty())
			{
				// just in case there is preceding punctuation that somehow got to be present
				pSrcPhrase->m_srcPhrase = pSrcPhrase->m_precPunct;
			}
			pSrcPhrase->m_srcPhrase += theWord;
			// We are done with the hiding of the metadata, and we have set m_key, and m_srcPhrase

			// Now we need to get TokenizeText's current len value updated, and the endMarker stored
			pSrcPhrase->AddEndMarker(m_strAttrEndMkr);

			// Deal with the len value to return to TokenizeText(). len value is such that
			// len += m_nSpanLength will get ptr pointing at the endMkr, so to prevent the
			// endMkr causing a problem for TokenizeText(), we must increase the len value
			// by a further width-of-the-endMkr
			len += m_nSpanLength; // that will move ptr in the TokenizeText() caller
									// to get its ptr pointing at the start of the endmarker
			len += m_nEndMarkerLen;

			ClearAttributeMkrStorage(); // clears data ptrs and sets m_bWithinMkrAttributeSpan to FALSE

			// BEW 27Sep22 this is an appropriate place, when m_bWithinMkrAttributeSpan is TRUE,
			// to return len to the caller ( TokenizeText() )
			wxASSERT(len > 0);

			// BEW 11Nov22 there might be punctuation after the endMkr, check it out. If there is,
			// store it on m_follPunct; doing that does not increase len value
			itemLen = 0;
			ptr = savePtr + len; // should get ptr pointing at what follows the endMkr
			itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
			if (itemLen > 0)
			{
				wxString finalPuncts = wxString(ptr, itemLen);
				pSrcPhrase->m_follPunct += finalPuncts;
				pSrcPhrase->m_srcPhrase += finalPuncts;
				len += itemLen; // so TText caller will point past the final puncts
			}
			// Incidently, ParsePreWord() stores a \w<sp> augmented begin mkr in m_inlineBindingMarkers
//			wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
			return len;
		} // end of TRUE block for test: if (bThisIsIt)

	} // end of TRUE block for test:  if (m_bWithinMkrAttributeSpan && !bSkipLegacyParsingBlock)

	if (m_bWithinMkrAttributeSpan && !bThisIsIt)
	{
		// Control is within the attribute span, but there are more words than one preceding the bar, 
		// and the one at which ptr points is earlier than the one on which the cache data will be stored;
		// so handle these prior words in this block

		wxChar* saveThisPtr = ptr;
		int theWordLen = 0; // BEW 27Sep22 added, initialise
		len = 0; // reset, (it must NOT be at 0 when ParseWord() exits! If it is, we get an infinite loop of
				 // new piles without ptr advancement! )

		if (m_bWithinMkrAttributeSpan)
		{
			// First, if itemLen is non-zero from last pile, reset to 0
			if (itemLen > 0)
			{
				itemLen = 0;
			}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
			{
				wxString pointsAt = wxString(ptr, 20);
				if (pSrcPhrase->m_nSequNumber >= 18)
				{
					int halt_here = 2; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
				}
			}
#endif
			// BEW 17Oct22 don't try parsing with ParseAWord() if ptr is pointing at whitespace prior
			// to the word we want to parse over. Check for whitespace, deal with it, and then we
			// can do the call to ParseAWord(). Do the insurance...
			itemLen = ParseWhiteSpace(ptr);
			if (itemLen > 0)
			{
				ptr += itemLen;
				len += itemLen;
			}
			if (*ptr == _T('(') || *ptr == _T('{') || *ptr == _T('['))
			{
				pSrcPhrase->m_precPunct += *ptr;
				ptr++;
				len++;
			}
			// OK, now ParseAWord() won't immediately return an empty string, because of preceding whitespace or [ { or ( as punct
#if defined (_DEBUG) && defined (NOPAREN)
			if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
			{
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
			}
#endif

			bool bWordNotParsed = FALSE; // init, BEW 3Aug23, will be set TRUE if ParseAWord could not
					// parse over something, so as to fail to advance ptr. Handling the failure will
					// be moved to a code block immediately after ParseAWord returns an empty string.
					//  bWordNotParsed referenced bool, default FALSE, was added as 4th param of signature
			theWord = ParseAWord(ptr, spacelessPuncts, pEnd, bWordNotParsed); // BEW 23Sep22 created ParseAWord() specifically
						// for use here (but it is public access so could be of use elsewhere)
						// The assumptions here are that attributes markers are inline, and
						// they wrap (like inlineBindingMarkers) a word or phrase which lacks
						// punctuation, or if punctuation is present, it has already been
						// parsed over, and so ParseAWord() does not check for puncts in
						// pre-word position - and if they occur, they would halt the parse (unless
						// TokenizeText() removed them before ParseAWord() is entered. 
						// ptr is unchanged by the ParseAWord() call.
			if (bWordNotParsed == TRUE)
			{
				wxBell();
				if (!pSrcPhrase->m_markers.IsEmpty())
				{
					// get the length of m_markers content, use it to return len value
					// to cause ptr advancement, and a new pSrcPhrase initiated
					int mkrsLen; int oldLen;
					mkrsLen = pSrcPhrase->m_markers.Length();
					oldLen = len;
					oldLen = oldLen; // avoid gcc warning set but not used warning
					ptr += mkrsLen;
					len += mkrsLen;
#if defined (_DEBUG) && !defined (NOLOGS)
					wxString atPtr;
					atPtr = wxString(ptr, 16);
					if ((ptr + 16) < pEnd)
					{
						wxLogDebug(_T(" ParseWord(), line %d , sn= %d , oldLen= %d , newLen= %d, m_markers= [%s], atPtr= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, oldLen, len, pSrcPhrase->m_markers.c_str(), atPtr.c_str());
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s  Returning"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
					}
#endif
					return len;
				}
				else
				{
					// m_markers is empty; ParseAWord() not having just parsed a word (or some text content)
					// now is unexpected if the USFM markup is valid; so probably there is a markup issue
					// to be resolved. Here, temporarily, have the assert that formerly ParseAWord() had
					wxASSERT(!theWord.IsEmpty());   // later, replace with code to inform the user of the error and its context
				} // and of else block for test: if (!pSrcPhrase->m_markers.IsEmpty())

			} // end of TRUE block for test: if (bWordNotParsed == TRUE)
			//wxASSERT(!theWord.IsEmpty());
			// reset itemLen and get ptr pointing past this word
			theWordLen = theWord.Length();
			itemLen = theWordLen;
			len = itemLen;
			ptr = saveThisPtr + len;
			// But there will be white space following, so get len past any whites
			itemLen = 0;
			itemLen = ParseWhiteSpace(ptr);
			if (itemLen > 0)
			{
				ptr += itemLen;
			}
			itemLen = 0; // ready for re-use
			saveThisPtr = NULL; // finished with it
		}
		//		wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
#if defined (_DEBUG) && defined (NOPAREN)
		if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
		{
			wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
		}
#endif
	} // end of TRUE block for test: if (m_bWithinMkrAttributeSpan && !bThisIsIt)

	bSkipLegacyParsingBlock = FALSE;   // was set TRUE, but I'll use added subtests below to skip unwanted blocks

	if (!bSkipLegacyParsingBlock)
	{
		// The legacy parsing block when not dealing with an attribute marker span, except where
		// a subtest allows

		// We've come to the word proper. We now parse over it. Punctuation might be within it
		// (eg. boy's) - so we parse to a space or backslash or other determinate indicator of
		// the end of the word - such as word final punctuation. How do we distinguish medial
		// from final punctuation? We'll assume that medial punctuation is never a backslash,
		// is most likely to be a single punctuation character (such as a hyphen), or the ~
		// USFM fixedspace character, and that medial space never occurs. So for a punctuation
		// character to be medial, the next character must not be white space nor backslash,
		// and usually it won't be another punctuation character either - but we'll allow one
		// or more of the latter to be medial provided the punctuation character sequence
		// doesn't terminate at a backslash or whitespace. The intention of this section of the
		// parser is to get ptr to point at the first character following the end of the word -
		// which could be punctuation, whitespace, or an inline binding endmarker, or a ]
		// bracket - a later section of this word parser function will deal with those
		// post-word possibilities.
		wxChar* pPunctStart = NULL; wxUnusedVar(pPunctStart); // avoid compiler warning variable initialized but not referenced
		wxChar* pPunctEnd = NULL; wxUnusedVar(pPunctEnd); // avoid compiler warning variable initialized but not referenced
		bool bStartedPunctParse = FALSE; wxUnusedVar(bStartedPunctParse); // avoid compiler warning variable initialized but not referenced
		// Better ~ parsing requires we parse word1<puncts2>~<puncts3>word2 when there is a ~
		// fixed space symbol conjoining, within a dedicated function -- and we need a test to
		// determine when ~ is present which gives TRUE or FALSE even though ptr is still
		// pointing at word1 -- so we'll need a function returning bool to parse over word1 and
		// its following <punct2> substring (the latter may be empty) to get to the ~ and
		// return TRUE if ~ is indeed present. Then we can return what we've found, and use the
		// returned bool to have a block in which a 'completion' function parses over
		// <punct3> and word2, ending with ptr pointing at the first character following word2
		// (it could be punctuation, a space, or a marker). Then we can have an else block to
		// do the word parse when no ~ is present. When either block ends, parsing can continue
		// with what follows word, or what follows word2 when there is ~ conjoining. (It is too
		// late to detect the ~ only after the word-parsing loop has been exitted, because we
		// won't be able at that time to get the second word of the conjoined pair parsed.) We
		// don't need any more than 2 extra local variables to store information parsed as
		// side-effects of our test function, and from the completion function. Just
		// inlineBindingEndMkrBeforeFixedSpace, and inlineBindingMkrAfterFixedSpace.
//		wxString inlineBindingEndMkrBeforeFixedSpace;  // moved to be earlier
//		wxString inlineBindingMkrAfterFixedSpace;      // moved to be earlier
		wxChar* savePtr = ptr;
		int nChangeInLenValue = 0;  wxUnusedVar(nChangeInLenValue); // avoid compiler warning variable initialized but not referenced
		wxChar* pAux = NULL; // initialise

		// in the next call, if ~ is found, ptr returns pointing at whatever follows it, but
		// if ~ is not found, then ptr returns pointing at whatever pEndWordProper points at
		// (which is usually space, or endmarker, or punctuation)
		bMatchedFixedSpaceSymbol = FALSE; // initialise
		if (!m_bWithinMkrAttributeSpan)
		{
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
			{
				wxString pointsAt = wxString(ptr, 20);
				if (pSrcPhrase->m_nSequNumber >= 2)
				{
					int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
				}
			}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
			if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
			{
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
			}
#endif
			//			wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

			pAux = ptr; // BEW 29Sep22 refactoring here, as IsFixedSpaceAhead was created
						// long ago, and sloppily. Even though it returns FALSE, ptr got incremented
						// past the beginMkr without that being handled, and then subsequent parsing
						// found an endMkr (in this case it was \wj* ) which then looked like an errant
						// endMarker in the input data. Gotta fix this, when FALSE is returned, ptr
						// must NOT have been advanced. So use pAux for input, and probably some
						// refactoring of IsFixedSpaceAhead() is also warranted.
			//bMatchedFixedSpaceSymbol = FALSE; // IsFixedSpaceAhead(pAux, pEnd, pWordProper, pEndWordProper, <<-- removed BEW 16Jul23, called here only
				//finalPunctBeforeFixedSpaceSymbol, inlineBindingEndMkrBeforeFixedSpace,
				//wordBuildersForPostWordLoc, spacelessPuncts,
				//bTokenizingTargetText); // the punctuationSet passed in has all spaces removed

//			wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

			// BEW 29Sep22 insurance...
			if (!bMatchedFixedSpaceSymbol)
			{
				// sanity insurance...
				if (pAux != savePtr)
				{
					ptr = savePtr; // makes sure there's no advance of ptr when ~ is absent, 
								   // and consequently the len value has not changed (it maybe was 0,
								   // and so will still be 0. len with value 0 must NEVER be returned
								   // to TokenizeText() - else new pStrPhrases generated until crash
				}
				// BEW 4Nov22 a temporary hack to rescue the legacy code from disaster, for data like:
				// "ensel\w*ayn" followed by space. Presently, "ayn" gets assumed to be word-build
				// characters, from punctuation changed by user, and it is not so. The ayn is stored
				// in wordBuildersForPostWordLoc - and that causes a misparse later on. So empty it
				// here.And then refactor - word-builders support is NOT warranted in TokenizeText(),
				// it's ReconstituteAfterPunctuationChange() that does that job.
				wordBuildersForPostWordLoc.Empty();
			}
			else
			{
				//BEW 16Jul23 refactoring, removing call of IsFixedSpaceAhead(), ~ will be supported differently in 6.11.0
				/*
				// BEW 30Sep22, ~ was found, when this is the case, pAux will be returned pointing
				// to the wxChar immediately after the ~ character, and the returned strings can
				// be relied on for length calculations. pAux will have been advanced beyond savePtr,
				// so work out where it now points and update savePtr to point there, and calculate
				// the new len value for what's done so far.
				wxASSERT((int)(pAux - savePtr) > 0);
				nChangeInLenValue = pAux - savePtr;
				len += nChangeInLenValue;
				*/
				savePtr = pAux;
				ptr = pAux;
				// BEW 4Nov22 see above block
				wordBuildersForPostWordLoc.Empty();
			}
		} // end of TRUE block for test: if (!m_bWithinMkrAttributeSpan)
//		wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);


		if (!(bMatchedFixedSpaceSymbol && !m_bWithinMkrAttributeSpan))
		{
			// a conjoining ~ was not found ahead
#if defined (_DEBUG) && !defined(NOLOGS)
			{
				wxString pointsAt = wxString(ptr, 16);
				wxString followingPuncts = pSrcPhrase->m_follPunct;
				wxString precedingPuncts = pSrcPhrase->m_precPunct;
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , follPunct= [%s] , precPunct= [%s], pointsAt= [%s]"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), followingPuncts.c_str(), precedingPuncts.c_str(), pointsAt.c_str());
				if (pSrcPhrase->m_nSequNumber >= 18)
				{
					int halt_here = 1; wxUnusedVar(halt_here);
				}
			}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
			if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
			{
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
			}
#endif
			// Legacy comment: it's not ~ conjoined words, so the word parsing loop begins instead, and ptr
			// will be pointing at the first character past the end of the word (which could
			// be following punctuation for the word), or at a ] if there was no following
			// punctuation for the word, or at buffer end (there could be former punctuation,
			// but now reverted to word-building characters, in wordBuildersForPostWordLoc
			// too, which are being held over for placement on the end of the word once we've
			// defined its string below somewhere

			// BEW 9Jun23 added bool, so we can track when control has parsed digits or chapVerse,
			// and we need to suppress a second augmenting of ptr and len when control has come
			// to 34,918 (approx) having parsed instead using ParseAWord. Not doing this, we
			// double the augment and ptr points into the following context - eg, into a word - 
			// making an error
			bool bFromDigitsUpdatedPtr;
			bFromDigitsUpdatedPtr = FALSE; // the value we'd want if control parsed a word using ParseAWord()

			int nChangeInLenValue = 0; // initialise
			if (!m_bWithinMkrAttributeSpan)
			{
				// BEW 27Sep22, legacy code block - retain unchanged for now (it would produce
				// a len value of 0 to return to TokenizeText(), causing an infininite loop
				// of new CSourcePhrase instances until memory filled, if this code was
				// called when m_bWithinMkrAttributeSpan is TRUE). (When m_bWithinMkrAttributeSpan
				// is TRUE, the new len value is calculated in the block where ParseAWord() is 
				// called, higher up)
				int oldLen = len;
				wxUnusedVar(oldLen);
				nChangeInLenValue = ptr - savePtr;
				len += nChangeInLenValue;
			}
		//wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

			// BEW 27Sep22
			// The following is the legacy comment. Handling of opening and closing [] () {}
			// needs a coherent refactoring to handle these alike, as punctuation, and to
			// divorce the support for them from esbe marker support, wordBuilders... etc
			// and those changes will result in different comments...

			// (Legacy comment) we might have come to a closing bracket, ], and if so we must parse no further
			// but sign off on the current CSourcePhrase, and return to the caller so that
			// its ptr value will point at the ] symbol.

			if (m_bWithinMkrAttributeSpan == TRUE)
			{
				if (pSrcPhrase->m_punctsPattern.IsEmpty())
				{
					// BEW 27Sep22, set up here what's required for setting m_key and m_srcPhrase
					// when m_bWithinMkrAttributeSpan is TRUE. In this TRUE context, esbe markup, brackets,
					// and the like, are not pertinent. But at the pile which has gotten the cached string
					// already entered into m_punctsPattern, this block is not to be entered. We need to
					// get m_key and m_srcPhrase set up where the inserting of the attributes cache string
					// gets done.
					// 
					// (Later the TRUE block just above will be extensively
					// refactored, because brackets etc should be handled as punctuation)

					pSrcPhrase->m_key = theWord;
					// now m_srcPhrase except for ending punctuation - of which there is none present
					if (!pSrcPhrase->m_precPunct.IsEmpty())
					{
						pSrcPhrase->m_srcPhrase = pSrcPhrase->m_precPunct;
					}
					pSrcPhrase->m_srcPhrase += theWord;
					wxASSERT(theWord != m_cachedWordBeforeBar); // when there is a match, that's when to handle the endMkr
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str() , pSrcPhrase->m_targetStr.c_str());
					}
#endif

					// BEW 14Feb24, the above lines prepend a m_precPunct, and there's no check if
					// m_follPunct has content, and we add it, then m_targetStr would lack punct(s) 
					// that it should have. Do check
					if (!pSrcPhrase->m_follPunct.IsEmpty())
					{
						pSrcPhrase->m_srcPhrase += pSrcPhrase->m_follPunct;
					}

					// BEW 27Sep22 this is an appropriate place, when m_bWithinMkrAttributeSpan is TRUE,
					// to return len to the caller ( TokenizeText() ), otherwise, control will go many
					// hundreds of lines further on without doing anything useful. (Recall, the markers
					// supported when m_bWithinMkrAttributeSpan is TRUE are inline and mostly of type
					// inlineBinding, and so we don't expect to have to check for, or deal with, following
					// punctuation here.)
					wxASSERT(len > 0);
					itemLen = 0;
#if defined (_DEBUG) && !defined(NOLOGS) // && defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 20);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , pointsAt= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 8)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr  RETURNING"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
					}
#endif
					return len;
				}
//wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

			} //  end of TRUE block for test: if (m_bWithinMkrAttributeSpan == TRUE)

			// BEW 30Sep19, if we've come to an endmarker \esbe, then that 
			// requires we end the parse, but only after we've stored the \esbe in m_endMarkers
			// and augmented ptr and len appropriately to point past the \esbe
			// BEW 29Sep22 pull out the \esbe marker support, do it first (in bleeding order) here, as
			// it deals with it and leaves just the handling of [ or ] to be done next. whitespaceLen
			// will be 0 except when \esbe was located after one or more whitespace characters - and in
			// the latter circumstance, whitespaceLen (a ref value computed internally) has to be
			// accurate, in order to update ptr and len when returning control to TokenizeText()
			// BEW 17Jul23 remove this, no longer need to support pEndWordProper
			//* BEW 20Jul23 restore this block, it may be required, for \esbe support, it's only in m_RedEndMarkers
			else
			{
				bool bFoundEsbe = FoundEsbeEndMkr(ptr, whitespaceLen);
				if (bFoundEsbe)
				{
					// BEW 30Sep19, It did find a trailing \esbe endmarker - so 
					// handle it before returning
					{
						int itsLen = 0;
						// scoping block -- we'll have one of these at about a half dozen places
						bool bEsbeEndMkr = FoundEsbeEndMkr(ptr, whitespaceLen); // do nothing if returns false
						if (bEsbeEndMkr)
						{
							itsLen = StoreEsbeEndMarker(ptr, pSrcPhrase, whitespaceLen);
							len += itsLen;
							ptr += itsLen;
							return len;
						}
						return len;
					}
				}
			} // end of else block for test: if (m_bWithinMkrAttributeSpan == TRUE)
			//*/

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
			{
				wxString pointsAt = wxString(ptr, 20);
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , pointsAt= [%s]"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pointsAt.c_str());
				if (pSrcPhrase->m_nSequNumber >= 8)
				{
					int halt_here = 1; wxUnusedVar(halt_here);
				}
			}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
			if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
			{
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
			}
#endif

			//	wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

			// BEW 10Oct22, this legacy calc of theWord will yield an empty string if nChangeInLenValue
			// is zero because there was no fixed-space caused advance of what ptr points at. So test
			// for empty string, and if so, parse using ParseAWord().
			
			// BEW 17Jul23 we no longer use pWordProper -
			//theWord = wxString(pWordProper, nChangeInLenValue);
			//if (theWord.IsEmpty())
			if (pSrcPhrase->m_key.IsEmpty())
			{
				// BEW 7Oct22, when not having found fixed space marker ~, ptr may be pointing  at some whitespace
				//  before the next word. Parse over any prior whitespace here, otherwise, ParseAWord will exit
				//  immediately because encountering whitespace causes exit of the parse loop.
				wxString strWord = wxEmptyString;
				itemLen = 0;
				itemLen = ParseWhiteSpace(ptr);
				if (itemLen > 0)
				{
					ptr += itemLen;  // get ptr past any whitespaces
					len += itemLen;  // keep in sync with TokenizeText()
				}
				itemLen = 0;
				int strWordLen = 0;
				wxChar openParen = _T('('); wxChar closedParen = _T(')');
				wxChar openBrace = _T('{'); wxChar closedBrace = _T('}');
				wxChar openBracket = _T('['); wxChar closedBracket = _T(']');

				// BEW 22Dec22, detached (or non-detached) \wj* (or similar endMkr type) give us connyptions, because
				// these have to be detected and stored on the current pSrcPhrase, not the next (where they would be
				// considered as "unexpected endMr" and generate a warning info message). \wj* is such, and it can be
				// very common in input src text when building the doc; but what precedes it can be quite a number of
				// short strings. I've got most covered now, but one remains in 41MATBVM.SFM. The user has some words
				// enclosed by parentheses, and those are followed by comma, then space, then the \wj* marker which
				// has to be stored and parsed over before we return len to TokenizeText. The opening parenthesis is
				// never a problem. The matching closing parenthesis IS a problem. Currently, if I let control go
				// into the block a little below for dealing with () or {} or [], control will return len to TText()
				// at the space before \wj*. NOT good. So I'll have to deal with the following potential substrings:
				// (a) closing parenthesis (the condition for entering  this new block), (b) possible punct/s 
				// (c) possible whitespace (no support for U+2000A hairspace needed, as these markers get hidden so
				// the gui never sees the space), (d) a marker, and it needs to be an endMkr of the inLine 
				// non-binding type. So, here goes...
				if (*ptr == closedParen)
				{
					wxChar* pAux = ptr; // we can't commit until we know we have a \wj* or similar endMkr to deal with
					int parenLen = 1;
					pAux += parenLen;
					// Puncts may follow
					int punctsLen = ParseFinalPuncts(pAux, pEnd, spacelessPuncts); // could be zero
					pAux += punctsLen;
					int spacesLen = CountSpaces(pAux, pEnd); // could be zero
					pAux += spacesLen;
					bool bIsBackslash = *pAux == gSFescapechar ? TRUE : FALSE;
					if (bIsBackslash)
					{
						// pAux points at a marker, what kind?
						wxString wholeMkr = GetWholeMarker(pAux);
						int mkrLen = wholeMkr.Len();
						if (!wholeMkr.IsEmpty())
						{
							bool bIsEndMkr = IsEndMarker(pAux, pEnd);
							if (bIsEndMkr)
							{
								// Use a fast access string
								int offset = wxNOT_FOUND; // initialise
								wxString augmentEMkr = wholeMkr + _T(' ');
								offset = gpApp->m_BlueEndMarkers.Find(augmentEMkr);
								if (offset >= 0)
								{
									// It's one of them, not necessarily \wj*, but we'll store whatever it is.
									// Being in the m_BlueEndMarkers set, means it's inLine TRUE, so storage will
									// be not to pSrcPhrase->m_endMarkers, but to pSrcPhrase->m_inlineNonbindingEndMarkers
									wxString strNonBEMkrs = pSrcPhrase->GetInlineNonbindingEndMarkers();
									wxString strStoreThis = _T(" ") + wholeMkr;

									strNonBEMkrs += strStoreThis;
									pSrcPhrase->SetInlineNonbindingEndMarkers(strNonBEMkrs);
									// TokenizeText needs len value increased to keep in sync
									int gapLen = 0;
									gapLen = (int)(pAux - ptr);

									// Add up all the lengths, and update ptr and len
									len += gapLen + mkrLen + spacesLen + parenLen;
									ptr += itemLen + mkrLen + spacesLen + parenLen;
									gapLen = 0;
									itemLen = 0;

									// Are there following puncts, parse these too
									itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
									if (itemLen > 0)
									{
										wxString extraPuncts = wxString(ptr, itemLen);
										pSrcPhrase->m_follPunct += extraPuncts;
										pSrcPhrase->m_srcPhrase += extraPuncts;// so user can see it in GUI layout
										len += itemLen;
										ptr += itemLen;
										itemLen = 0;
									}
									// Appropriate to return len to TokenizeText() here
									return len;

								} // end of TRUE block for test: if (offset >= 0)
								// BEW 14Nov22. Beware. Don't parse over a '\n', it will cause ParseAWord() to assert, 
								// or release build to crash; if in either case a beginMkr follows ?? BEW 22Dec22 I'm
								// pretty certain this restriction no longer applies. The comment can stand for now.	
#if defined (_DEBUG)  && !defined(NOLOGS) //&& defined(WHERE)
								{
									wxString pointsAt = wxString(ptr, 16);
									wxLogDebug(_T("ParseWord() line %d , m_curChapter= [%s], pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , pointsAt= [%s]"),
										__LINE__, pApp->m_curChapter.c_str(), pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pointsAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 8)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
								}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
								if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
								{
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
								}
#endif

								return len;
							} // end of TRUE block for test: if (bIsEndMkr)
							else
							{
								// Must be a beginMkr, so gotta return len to TokenizeText()
								ptr += parenLen + punctsLen;
								len += parenLen + punctsLen;
								return len;
							}
						} // end of TRUE block for test: if (!wholeMkr.IsEmpty())
						else
						{
							// wholeMkr was empty, so return at the space
							ptr += parenLen + punctsLen;
							len += parenLen + punctsLen;
							return len;
						}
					} // end of TRUE block for test: if (bIsBackslash)
					else
					{
						// return  updated len value to TokenizeText()
						ptr += parenLen + punctsLen;
						len += parenLen + punctsLen;
						return len;
					}
				} // end of TRUE block for test: if (*ptr == closedParen)

				// BEW 13Oct22, if after ParsePreWord() exits, it may have exited with ptr pointing at a detached ']'
				// and len was 0, so that ptr did not advance. That will lead above to nChangInLenValue set to 0, and
				// that in turn makes the calculation of theWord be an empty string.There will be no whites to parse over,
				// if ParseAWord(ptr) is called in such a scenario, it generates an empty word - and it's internal wxASSERT
				// trips. The solution is to test for the detached ], it's detached if the preceding wxChar is whitespace.
				// If so, set theWord to contain ] as m_key and m_srcPhrase and advance ptr over it, etc
				if ((*ptr == _T(']')) && IsWhiteSpace((ptr - 1)))
				{
					strWord = _T(']');
				}
				else
				{
					// BEW 17Oct22 control may be about to start parsing word by word through a phrase, and control
					// could be pointing at whitespace/s before the actualy non-space data commences. If we don't
					// parse over any such whitespace, then ParseAWord() will return an empty string - no future in that!
					// Or in debug mode, an assert will trip.
					itemLen = ParseWhiteSpace(ptr);
					if (itemLen > 0)
					{
						ptr += itemLen;
						len += itemLen;
					}
					// BEW 21Oct22, the input source data may contain data like this:
					// \v 21 \wj [Bɔŋ muu.] \wj*
					// where the important thing to note is that '[' (which is normally a punctuation character), 
					// immediately precedes the word (  Bɔŋ  ) that we want to parse over. The problem is, if
					// control enters ParseAWord() with ptr pointing at the '[' character, then ParseAWord's internal
					// loop will detect the initial punctuation and think that parsing is over, since punctuation is
					// a loop-halting condition (one of several). So what then? We here need to check for '[' (and
					// also '{' or '(' being prior to the word - and parse over any such one, storing it in m_precPunct
					// and advancing ptr by 1, and len by 1 too. Handle that here...
#if defined (_DEBUG)  && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 8)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					if (!m_bTokenizingTargetText)
					{
						// BEW 20Nov11, Don't do this if tokenizing target text for the "new CSourcePhrase" with sequNum
						// 0 from which bits will be taken for use in MakeTargetStringIncludingPunctuation(). Why? Because
						// when dealing with adaptations like aWord(singular), ParseAWord() will parse "aWord" and
						// ptr will than be pointing at the open parenthesis. This next block would then store
						// the '(' in m_precPunct, and that removes the '(' from the adaptation text, resulting
						// in a misparse of the adaptation - it generates "aWord" followed by space and "singular" to go
						// into the KB, but what is wanted is that the KB would get: aWord(singular as the adaptation
						// to be saved. And the closing ')' will then be obtained from m_follPunct; but if we did
						// not protect this block, also the closing ')' would not show in the GUI layout either.
						if (*ptr == openParen || *ptr == openBrace || *ptr == openBracket)
						{
							pSrcPhrase->m_precPunct += *ptr;
							ptr++;
							len++;
						}
					}
					// Now it's safe to call ParseAWord()
//					wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d, Before IsAnsiDigit() test: pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 1)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					// BEW 25Oct22 ptr might be in a footnote, where things like 4:17 or 5:12-14 might occur. Currently, if
					// our parser were allowed to parse such things, we'd get a mess: 4:17 would end up as two piles, first with
					// "4::" and the second with "17"  and a range would be worse! So I've made a function to treat these data
					// bits as units. 
					// BEW 22Jun23 beware, book abbrevions like 3John, 2Sa. 1Cor, etc all begin with a digit, but must be
					// parsed with ParseAWord(), so need to add to the test here to suppress entry when (ptr + 1) is neither
					// punctuation, whitespace, not a digit.
					// BEW 25Aug23, I may repurpose these - they are no longer used - for now, I'll just comment them out
					/*
					bool bNextIsPunct; bool bNextIsWhite; bool bNextIsDigit;
					bNextIsPunct = FALSE; bNextIsWhite = FALSE; bNextIsDigit = FALSE; // initialisations
					wxChar* pNext = (ptr + 1);
					int myOffset = wxNOT_FOUND; // init
					myOffset = spacelessPuncts.Find(*pNext);
					bNextIsPunct = myOffset >= 0 ? TRUE : FALSE;
					bNextIsWhite = IsWhiteSpace(pNext);
					bNextIsDigit = IsAnsiDigit(*pNext);
					*/

					if (IsAnsiDigit(*ptr))
					{
						// BEW 5Sep23 a 'bleeding' block for when control encounters a digit-initial string, like 2CO, or 1JN,
						// in the sn=0 pSrcPhrase's block - providing that block is for parsing the \id line. We want to 
						// prevent splitting of, say, 2CO into sn= 0, with m_key "2" and sn= 1 with m_key "CO". There may be
						// several digit-initial string we want to parse as wholes. Here is an example from Nyindrou 2 Corinth
						// \id 2CO NT1160 Nyindrou - Kowak/Martin 02/26/01 12:04 PM
						// which has 3 of the 7 pSrcPhrases starting with a digit.
						{
							len = 0;
							wxString strContent;
							strContent = wxEmptyString;
							// What's shared by all pSrcPhrases in the \id line? Certainly not the sequNumber - the comment
							// above says that therer will be 7 strings to be parsed as wholes. Only \id is shared by all.
							// whm 20Jan2024 comment. The following block will only work for the first word after an \id
							// marker. Hence, it will only work for a USFM Scripture 3-letter abbreviation that begins with
							// an ansi digit such as 1CO, 2CO  1KI etc. It won't catch any ansi-digit subsequent words in
							// the \id line since the \id marker is only stored within the pSrcPhrase->m_markers member of
							// the first word after the \id line.
							if (pSrcPhrase->m_markers == _T("\\id "))
							{
								// *ptr is a digit, so parse to the next space, and make that a m_key and m_srcPhrase on
								// it's pSrcPhrase
								len = ScanToWhiteSpace(ptr, pEnd);
								// Make the content wanted
								strContent = wxString(ptr, len);
								pSrcPhrase->m_key = strContent;
								pSrcPhrase->m_srcPhrase = strContent;
								ptr += len;
								return len;
							}
						}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							wxLogDebug(_T("ParseWord() line %d, Before ParseDate() test: pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 1)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						// BEW 17Nov23 added call of ParseNumberHyphenSuffix() to handle data like "24-tja" or "14-nha" before
						// ParseDate() gets a chance to misparse such info. The latter would wrongly produce "24" then 
						// "-tja" on a following pSrcPhrase. If structure constraint is not satisfied, this function returns
						// an empty string - and if so, let ParseDate() have a go instead.
						wxString strNumHyphSuffix;
						strNumHyphSuffix = ParseNumberHyphenSuffix(ptr, pEnd, spacelessPuncts);
						if (!strNumHyphSuffix.IsEmpty())
						{
							strWord = strNumHyphSuffix;
						} // end of TRUE block for test: if (!strNumHyphSuffix.IsEmpty())
						else
						{

							// BEW 16Jun23 added facility to scan a date such as 15/12/2023 and variants, if false returned, the
							// do ParseChVerseUnchanged(). Both the latter, and ParseDate(), start with *ptr at an ansi digit
							int dateLen;
							dateLen = ParseDate(ptr, pEnd, spacelessPuncts); // if error, returns -1, okay if dateLen is +ve
							bool bValidDate;
							bValidDate = dateLen > 0 ? TRUE : FALSE;
							if (bValidDate)
							{
								strWord = wxString(ptr, dateLen);
							}
							else
							{
								// Call this instead
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
								{
									wxString pointsAt = wxString(ptr, 16);
									wxLogDebug(_T("ParseWord() line %d, Before ParseChVerseUnchanged() test: pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 1)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
								}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
								if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
								{
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
								}
#endif

								strWord = ParseChVerseUnchanged(ptr, spacelessPuncts, pEnd);
							}

						} // end of else block for test: if (!strNumHyphSuffix.IsEmpty())

						// ParseNumberHyphenSuffix(), if it has returned a valid result string,
						// must set strWord to the result string before control gets to here 
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							wxLogDebug(_T("ParseWord() line %d, After ParseChVerseUnchanged(): m_curChapter= [%s], pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
								__LINE__, pApp->m_curChapter.c_str(), pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 1)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

//wxLogDebug(_T("LEN+PTR line %d , len %d , 20 at ptr= [%s]"), __LINE__, len, wxString(ptr, 20).c_str() );
												// set m_key and m_srcPhrase
						int strWordLen = strWord.Length();
						pSrcPhrase->m_key = strWord;
						pSrcPhrase->m_srcPhrase = strWord;
						ptr += strWordLen;
						len += strWordLen;
						// NOLOGS wxLogDebug(_T("LEN+PTR line %d ,  len %d , 20 at ptr= [%s]"), __LINE__, len, wxString(ptr, 20).c_str());
						bFromDigitsUpdatedPtr = TRUE; // suppress doubling the ptr and len advance at 35756++ approx

						// BEW 29May23, after a chapter/verse number in a footnote, there may be an
						// explict \fr* endMkr; code following ParseAWord() would deal with this endMkr,
						// but after ParseChVerseUnchanged() returns, ParseAWord() is not called. So we
						// should check for \fr* here (it's in the m_RedEndMarkers set), and deal with it.
						// \fr*, if present, should abutt the end of the chapVerse strWord

						// Test if ptr points at a marker's backslash (after chapVerse or digits, we
						// can be sure these have not been bracketed by inline binding mkr and endMkr)
						if (*ptr == gSFescapechar)
						{
							// some kind of marker, beginMkr or endMkr we don't know yet, follows strWord
							wxString wholeMkr = GetWholeMarker(ptr);
							if (!wholeMkr.IsEmpty())
							{
								bool bIsEndMkr;
								bIsEndMkr = IsEndMarker(ptr, pEnd);
								wxString augEndMkr = wxEmptyString;
								if (bIsEndMkr)
								{
									augEndMkr = wholeMkr + _T(" ");
									// Is it a Red end marker - this will pick up \fr*, or \f*, or any
									// other of similar type of endMkr after chVerse string or digits
									int offset = wxNOT_FOUND;
									offset = gpApp->m_RedEndMarkers.Find(augEndMkr);
									if (offset >= 0)
									{
										// Found a candidate endMkr. Parse over, store in m_endMarkers, update ptr, 
										// and return len; but don't forget to here assign strWord above to
										// both m_markers of pSrcPhrase, and to m_srcPhrase. (Parsing numbers is typically
										// done in a footnote or cross-reference, so unlikely to have following puncts.
										// But numbers may occur elsewhere, not in a footnote or x-ref span, and then they
										// might have following punctuation - so check, and add it before returning. Also,
										// the punctuation may be detached in the sense that white space character precedes,
										// so that has to be allowed for too - because once we return len, the current pSrcPhrase
										// is done with and anything after ptr will apply to the next pSrcPhrase
										int wholeMkrLen = wholeMkr.Length();
										wxString currEndMkrs = pSrcPhrase->GetEndMarkers();
										currEndMkrs << wholeMkr;
										pSrcPhrase->SetEndMarkers(currEndMkrs);
										// We parsed and stored an endMkr, so update ptr and len for its width as well
										ptr += wholeMkrLen;
										len += wholeMkrLen;
										// NOLOGS wxLogDebug(_T("LEN+PTR line %d ,  len %d , 20 at ptr= [%s]"), __LINE__, len, wxString(ptr, 20).c_str());
										wxChar* pSavePtr = ptr; // preserve, as ptr may turn out to be pointing at location for returning
										// len is uptodate here too, next section of code will not increase it unless we determine its
										// part of detached following punctuation. So far, there are no final puncts to add to m_follPunct
										// nor to m_srcPhrase of pSrcPhrase.
										pApp->pSavePtr_forSkip = ptr; // This one will be used, if bSkipOverParseAWord is set TRUE below
											// (we use both to meld ptr location into what follows the ParseAWord() call, when the
											// goto jump to the label elseBlock is requested )
										pApp->nSaveLen_forSkip = len; // keep ptr value and len in sync

										// Check for post-word whitespace(s)
										wxChar* pAux = ptr; // init to where ptr is

										bool bFinalPunctsAbbutWordIfPresent = FALSE; // init
										itemLen = 0;
										itemLen = CountWhitesSpan(ptr, pEnd);
										wxString strWhites = wxEmptyString;
										int whitesLen = 0;
										wxString strFollPuncts = wxEmptyString;
										int follPunctsLen = 0;

										if (itemLen > 0)
										{
											// There is one or more whitespaces. This could be a detachment situation
											strWhites = wxString(ptr, itemLen);
											whitesLen = strWhites.Length();
											// set pAux to point at what follows the whitespace(s)
											pAux += whitesLen; // pAux now points at whatever follows the whites
//wxLogDebug(_T("LEN+PTR line %d ,  len %d , 20 at ptr= [%s]"), __LINE__, whitesLen, wxString(pAux, 20).c_str());
										}
										else
										{
											bFinalPunctsAbbutWordIfPresent = TRUE;
										}
										// Now check what follows the whitespace(s), if its puncts, they may
										// belong on the current pSrcPhase in m_follPunct, and need to be
										// added to m_srcPhrase (and the whites preceding as well, if there are any)
										wxChar chNext = *pAux; // character that pAux is pointing at
										int offset2 = wxNOT_FOUND; // init
										offset2 = spacelessPuncts.Find(chNext);
										bool bBeginningPuncts = FALSE; wxUnusedVar(bBeginningPuncts); // avoid compiler warning variable initialized but not referenced
										if (offset2 != wxNOT_FOUND)
										{
											// Punctuation follows, get its span
											follPunctsLen = ParseFinalPuncts(pAux, pEnd, spacelessPuncts);
											strFollPuncts = wxString(pAux, follPunctsLen);

											// We will distinguish between detached puncts, verses puncts
											// which follow whitespace (including \n newline) and puncts
											// which likely belong at the start of a new pSrcPhrase
											// (a weakness here is that in exotic languages which distinguish
											// exotic characters distinguish between pre-word and post-word,
											// we'll not be able to be certain we get it right for them).
											// We will, however, stipulate that 'detached' means only a single
											// white character is between the word proper, and a following punct;
											// and we'll further stipulate that only a single punct follows.
											// However, if there's no intervening space, so that the following
											// punct(s) abutt the word proper, then we'll allow more than one
											// to follow.
											int offset3 = wxNOT_FOUND;
											offset3 = m_strInitialPuncts.Find(chNext);
											if (offset3 != wxNOT_FOUND)
											{
												// chNext is actually a beginning punctuation character, so return here;
												// the whitespace is where pSavePtr points; and len is uptodate there;
												// and m_key and m_srcPhrase are uptodate there too
												bFromDigitsUpdatedPtr = FALSE; // restore default
//wxLogDebug(_T("LEN+PTR line %d ,  len %d , 20 at ptr= [%s]"), __LINE__, len, wxString(pAux, 20).c_str());
												return len;
											}
											else
											{
												// The parsed puncts are final ones, if belonging to spacelessPuncts, but
												// but exotic puncts may, or may not, be final ones. So here we'll implement
												// out conditions for "detached". By definition, "detached" means "not abutting
												// the word"; and normally there's only one whitespace, but allow for more,
												// and only one following punct after the white(s); and whitespace must follow 
												// the punct - and after pointing ptr at that post-punct white is where we return
												if (!bFinalPunctsAbbutWordIfPresent && (whitesLen >= 1) && (follPunctsLen == 1))
												{
													// update pSrcPhrase and len before returning
													pSrcPhrase->m_srcPhrase << strWhites;
													pSrcPhrase->m_srcPhrase << strFollPuncts;
													pSrcPhrase->m_follPunct << strWhites;
													pSrcPhrase->m_follPunct << strFollPuncts;
													len += whitesLen; // however many whitespace and one final punct
													ptr = pSavePtr + whitesLen;
													len += follPunctsLen;
													ptr += follPunctsLen;
//wxLogDebug(_T("LEN+PTR line %d ,  len %d , 20 at ptr= [%s]"), __LINE__, len, wxString(ptr, 20).c_str());
													bFromDigitsUpdatedPtr = FALSE; // restore default
													return len; // don't test for whitespace following, assume this is right place to return
												}
												else
													if (!bFinalPunctsAbbutWordIfPresent && (whitesLen == 1) && (follPunctsLen == 2) && (*(pAux + 1) == _T('>')))
													{
														// Assume that two following puncts, and the second being '>', that the first is also '>'
														// because in the default puncts set, >> is the only double ending punct
														pSrcPhrase->m_srcPhrase << strWhites;
														pSrcPhrase->m_srcPhrase << strFollPuncts;
														pSrcPhrase->m_follPunct << strWhites;
														pSrcPhrase->m_follPunct << strFollPuncts;
														len += 3; // one whitespace and two final puncts, probably ">>"
														ptr = pSavePtr + 3;
//wxLogDebug(_T("LEN+PTR line %d ,  len %d , 20 at ptr= [%s]"), __LINE__, len, wxString(ptr, 20).c_str());
														bFromDigitsUpdatedPtr = FALSE; // restore default
														return len; // don't test for whitespace following, assume this is right place to return
													}
											} // end of else block for test: if (offset3 != wxNOT_FOUND) -- puncts probably final type

										} // end of TRUE block for test: if (offset2 != wxNOT_FOUND) -- found puncts

										if (bFinalPunctsAbbutWordIfPresent && (whitesLen == 0))
										{
											// Deal with them; these no preceding whitespace, and after the puncts, we
											// return len after updating pSrcPhase members
											wxChar chNext = *pAux;
											int offset2 = wxNOT_FOUND; // init
											offset2 = spacelessPuncts.Find(chNext);
											bool bBeginningPuncts = FALSE; wxUnusedVar(bBeginningPuncts); // avoid compiler warning variable initialized but not referenced
											if (offset2 != wxNOT_FOUND)
											{
												// Punctuation follows, get its span
												follPunctsLen = ParseFinalPuncts(pAux, pEnd, spacelessPuncts);
												strFollPuncts = wxString(pAux, follPunctsLen);

												int offset3 = wxNOT_FOUND;
												offset3 = m_strInitialPuncts.Find(chNext);
												if (offset3 != wxNOT_FOUND)
												{
													// chNext is actually a beginning punctuation character, so return here;
													// the whitespace is where pSavePtr points; and len is uptodate there;
													// and m_key and m_srcPhrase are uptodate there too
													bFromDigitsUpdatedPtr = FALSE; // restore default
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
													return len;
												}
												else
												{
													// The parsed puncts are final ones, if belonging to spacelessPuncts, but
													// but exotic puncts may, or may not, be final ones. We only need to 
													// distinguish between single char punct, or >> - and if >> is present,
													// we will assume it is first - it's unlikely to have another after it
													if (follPunctsLen == 1)
													{
														// update pSrcPhrase and len before returning
														pSrcPhrase->m_srcPhrase << strFollPuncts;
														pSrcPhrase->m_follPunct << strFollPuncts;
														len += 1; // one whitespace and one final punct
														ptr = pSavePtr + 1;
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
														bFromDigitsUpdatedPtr = FALSE; // restore default
														return len; // don't test for whitespace following, assume this is right place to return
													}
													else
													{
														if ((follPunctsLen == 2) && (*pAux == _T('>')) && (*(pAux + 1) == _T('>')))
														{
															// There are two consecutive '>' characters
															// (in the default puncts set, >> is the only doubled ending punct)
															pSrcPhrase->m_srcPhrase << strFollPuncts;
															pSrcPhrase->m_follPunct << strFollPuncts;
															len += 2; // no whitespace but two closingwedges, i.e. ">>"
															ptr = pSavePtr + 2;
//wxLogDebug(_T("LEN+PTR line %d ,  len %d , 20 at ptr= [%s]"), __LINE__, len, wxString(ptr, 20).c_str());
															bFromDigitsUpdatedPtr = FALSE; // restore default
															return len; // don't test for whitespace following, assume this is right place to return
														}
													}
												} // end of else block for test: if (offset3 != wxNOT_FOUND) -- puncts probably final type

											} // end of TRUE block for test: if (offset2 != wxNOT_FOUND)
										} // end of TRUE block for test: if (bFinalPunctsAbbutWordIfPresent && (whitesLen == 0) )

										// Continue parsing? Probably Latin space is next (or newline), if so 
										// return len here to force TokenizeText to create a new pSrcPhrase. If 
										// not then let parsing in ParseWord() continue from where ptr is
										if (ptr < pEnd && (*ptr == _T(' ') || *ptr == _T('\n'))) // BEW 14Jun23 added OR plus test for newline
										{
											bFromDigitsUpdatedPtr = FALSE; // restore default
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
											return len;
										}
										// If we didn't return, then goto the else block below. But we want to jump to
										// a harmonious location so that control parsing on from there will start with the
										// correct ptr location, and len value
										ptr = gpApp->pSavePtr_forSkip;
										gpApp->bSkipOverParseAWord = TRUE;

										goto elseBlock;
									} // end of TRUE block for test: if (offset >= 0) -- found red end mkr

								} // end of TRUE block for test: if (bIsEndMkr)

							} // end of TRUE block for test: if (!wholeMkr.IsEmpty()) 
						} // end of TRUE block for test:  if (*pAux = gSFescapechar)

					} // end of TRUE block for test: if (IsAnsiDigit(*ptr))
					else
					{
						// BEW 23Mar23 Bill wants a \v which gets it's 'v' tag lost, so it's an isolate '\\',
						// to be handled benignly. If I don't, ParseAWord() will cause an infinite loop
						// until app crashes. 6.10.7 showed it with it's missing ch:vs string corrected
						// and in m_inform, so I need to support that too.
						if ((*ptr == gSFescapechar) && (*(ptr + 1) == _T(' ')) && gpApp->m_bParsingSource)
						{
							// Store it on the pSrcPhrase
							pSrcPhrase->m_key == _T('\\');
							pSrcPhrase->m_srcPhrase = _T('\\');
							// Move past it
							len += 1;
							ptr += 1;
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
							// Now locate this pSrcPhrase in the m_pSourcePhrases list, and use view's
							// GetChapterAndVerse(CSourcePhrase* pSourcePhrase_lastCompeted) which returns
							// a ch:vs wxString, to search for which chapter and verse the current instance
							// belongs to, by searching back for a non-empty m_chapterVerse string in an
							// earlier pSrcPhrase instance. When found, assume the isolate backslash is
							// a mistyped \v marker for the next verse, i.e. ch:(vs + 1), and display that
							// in m_inform.
							// No need!! I tested the above, and the smarts for doing the right thing are
							// still in our code somewhere, so no more to do here, except return len value
							bFromDigitsUpdatedPtr = FALSE; // restore default
							return len;
						}
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
#if defined (_DEBUG) && !defined(NOLOGS)
						if (pSrcPhrase->m_nSequNumber >= 3)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						wxString strReturn;
						strReturn = wxEmptyString;
						bool bIsAtPtr = IsInitialPunctPlusWhite(ptr, spacelessPuncts, pEnd, strReturn);
						if (bIsAtPtr)
						{
							// There is either << followed by a whitespace character to be stored in m_precPunct, or
							// a word-initial type of punct followed by a whitespace (likewise to go in m_precPunct);
							// provided there is not a backslash or newline following the whitespace. Failure to parse
							// these pre-word strings will result in ParseAWord() failing to advance, or asserting
							int strReturnLen = strReturn.Length();
							if (strReturnLen >= 2)
							{
								pSrcPhrase->m_precPunct << strReturn;
								ptr += strReturnLen;  // could be << followed by space; otherwise of length 2
								len += strReturnLen;
								wxASSERT(ptr < pEnd);
							}
						}
#if defined (_DEBUG) //&& !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							//wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
							//	__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 451) // whm break
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif					
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						bool bWordNotParsed = FALSE;
						strWord = ParseAWord(ptr, spacelessPuncts, pEnd, bWordNotParsed); // any foll puncts are included

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_adaption=[%s], m_markers=[%s] , pointsAt= [%s]"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_adaption.c_str(), pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 1)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif
						if (bWordNotParsed == TRUE)
						{
							wxBell();
							if (!pSrcPhrase->m_markers.IsEmpty())
							{
								// get the length of m_markers content, use it to return len value
								// to cause ptr advancement, and a new pSrcPhrase initiated
								int mkrsLen; int oldLen;
								mkrsLen = pSrcPhrase->m_markers.Length();
								oldLen = len;
								oldLen = oldLen; // avoid gcc warning set but not used warning
								ptr += mkrsLen;
								len += mkrsLen;
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
								{
									wxString pointsAt = wxString(ptr, 16);
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_adaption=[%s], m_markers=[%s] , pointsAt= [%s]"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_adaption.c_str(), pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 1)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
								}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
								if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
								{
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
								}
#endif

								return len;
							}
							else
							{
								// m_markers is empty; ParseAWord() not having just parsed a word (or some text content)
								// now is unexpected if the USFM markup is valid; so probably there is a markup issue
								// to be resolved. Here, temporarily, have the assert that formerly ParseAWord() had
								//wxASSERT(!theWord.IsEmpty());   // later, replace with code to inform the user of the error and its context
								// 
								// whm 28Sep2023 modified by changing the wxASSERT(!theWord.IsEmpty()) to a more informative
								// message, and an entry sent to the user log. This code addition required the addition of
								// the pBuffStart parameter to the ParseWord() function to avoid trying to collect text earlier
								// than the pBuffStart of the document.

								wxString strApproxLocation;
								const wxChar* pDocStart = pBufStart;
								wxChar* pLocBefore;
								wxChar* pLocAfter;
								if ((ptr - 60) > const_cast<wxChar*>(pDocStart))
								{
									pLocBefore = (ptr - 60);
								}
								else
								{
									pLocBefore = const_cast<wxChar*>(pDocStart);
								}
								if ((ptr + 60) < pEnd)
								{
									pLocAfter = (ptr + 60);
								}
								else
								{
									pLocAfter = pEnd;
								}
								size_t width = (size_t)(pLocAfter - pLocBefore);
								if (width > 120)
								{
									width = 120;
								}
								strApproxLocation = wxString(pLocBefore, width);
								
								// whm 28Sep2023 added a chapter:verse reference to the warning msg.
								// Get the chapter and verse of the current context for the warning.
								// Internally GetSourcePhraseByIndex() scans backwards till it finds the
								// information needed, or comes to doc start. Here we need to start with 
								// the m_nSequNumber before the current one, since the current one won't
								// yet be stored in the App's pSrcPhrases list, otherwise the GetSourcePhraseByIndex()
								// function would generate an index error.
								CSourcePhrase* pSP = pApp->GetSourcePhraseByIndex(pSrcPhrase->m_nSequNumber - 1);
								wxString cv = _T("");
								if (pSP != NULL)
									cv = pApp->GetView()->GetChapterAndVerse(pSP);
								if (cv.IsEmpty())
									cv = _("Unknown location");
								// whm 21Sep2023 modified the wxMessagBox below to have a more useful msg for users.
								wxString wholeBeginMkr;
								int posAsterisk = wholeEndMkr.Find(_T("*"));
								if (posAsterisk != wxNOT_FOUND)
								{
									wholeBeginMkr = wholeEndMkr.Mid(0, posAsterisk);
								}
								wxString msg = _("Warning: While loading the source text file at chapter:verse %s, unexpected markers, spaces and/or punctuation were encountered.\nThey occur within the span:\n\n%s");
								msg = msg.Format(msg, cv.c_str(), strApproxLocation.c_str());
								wxString msg2;
								msg2 = _("When Adapt It encounters \"Unexpected\" markers, spaces and/or punctuation, it can indicate that leading spaces have interferred with Adapt It's ability to recognize certain end punctuation and/or where it should be stored.\nUnexpected markers may indicate the use of markers inappropriately - such as target references \\xt ... \\xt* embedded within other marker content such as footnotes. The result may be markers appearing within the text, or punctuation that appears as a separate word in the display rather than being bound to some text.\n\nFix the input source text file, then re-load to re-create the document.\n\nDo you want to continue loading the file?");
								msg2 = _T("\n\n") + msg2;
								msg = msg + msg2;
								wxString title = _T("Warning: Unexpected markers, spaces and/or punctuation in chapter:verse %s");
								title = title.Format(title, cv.c_str());
								int response = 0;
								response = wxMessageBox(msg, title, wxICON_WARNING | wxYES_NO | wxNO_DEFAULT);
								if (response == wxNO)
								{
									wxString responseStr = _("User selected No");
									pApp->LogUserAction(responseStr);
									pApp->LogUserAction(msg);
									wxString stopMsg = _("Adapt It will now stop running.\n\nWhen you have fixed the input text, run Adapt It again and try loading the edited text into Adapt.");
									wxMessageBox(stopMsg, responseStr, wxOK);
									pApp->LogUserAction(stopMsg);
									wxKill(::wxGetProcessId(), wxSIGKILL); // Calling wxKill() on the current process is a quiet way to terminate.
								}
								else
								{
									wxString responseStr = _("User selected Yes");
									pApp->LogUserAction(responseStr);
									pApp->LogUserAction(msg);
									wxString continueMsg = _T("Adapt It will continuing trying to load the input text.\n\nIf the input text completes loading, be sure to check it at chapter:verse %s for proper formatting.");
									continueMsg = continueMsg.Format(continueMsg, cv.c_str());
									wxMessageBox(continueMsg, responseStr, wxOK);
									pApp->LogUserAction(continueMsg);
								}

							} // and of else block for test: if (!pSrcPhrase->m_markers.IsEmpty())

						} // end of TRUE block for test: if (bWordNotParsed == TRUE)

#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						// BEW 25Jul23, a check and possible hack may be required for the returned value of strWord.
						// Internally, ParseAWord(), in its parsing loop, calls IsWordInternalPunctuation() for each
						// character parsed. The latter is supposed to return TRUE when one or more puncts are internal
						// to a word - but the code is flawed, and it's quite possible to get TRUE returned when there
						// are no word-internal puncts, but just word-final ones. Data such as this: mari.' "<newline>
						// returns strWord with value:  mari.'  And this is made pSrcPhrase's m_key value. Ouch. Puncts
						// don't belong on the m_key. Two ways to fix: 1. refactor  IsWordInternalPunctuation() to be
						// correct in every circumstance. (I can't see any way to do it reliably.) or 2. Reverse strWord
						// parse over all puncts, get them into a string, get its length, use Mid() to chuck away the
						// puncts, reverse back to normal order - leaving a valid strWord with no final puncts. 
						// 2. is what I willl do - here, before any other post-word processing gets a chance to do something
						// with or to the strWord rescued value.
						int strWdLength;
						strWdLength = strWord.Length();
						const wxChar* p = strWord.GetData();
						wxChar* pBufBegin = (wxChar*)p; // pBufBegin is not const
						wxChar* pBufEnd = pBufBegin + strWdLength;
						strWord = MakeReverse(strWord); // done 'in place'
						int revPunctsLen;
						revPunctsLen = 0;
						revPunctsLen = ParsePuncts(pBufBegin, pBufEnd, spacelessPuncts);
						bool bRemovedSome = FALSE;
						if (revPunctsLen > 0)
						{
							strWord = strWord.Mid(revPunctsLen);
							bRemovedSome = TRUE;
						}
						strWord = MakeReverse(strWord);
						if (bRemovedSome)
						{
							// BEW 18Aug23 only show this log message if some puncts were removed
							wxLogDebug(_T("Puncts_in_key_removed, line %d, strWord= [%s]"), __LINE__, strWord.c_str());
						}
					} // end of else block for test: if (IsAnsiDigit(*ptr))
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

				} // end of else block for test: if ((*ptr == _T(']')) && IsWhiteSpace((ptr - 1)))
				theWord = strWord;
				strWordLen = strWord.Length();
				pSrcPhrase->m_key = strWord;
				// m_key is the base for m_srcPhrase, the latter will have puncts (possibly detached) added
				pSrcPhrase->m_srcPhrase = strWord; // we don't want parsing functions to work on an empty m_srcPhrase
				// BEW 8Jun23, TokenizeText(), at about lines +/- 19388, may set content in m_precPunct, and it may
				// include following whitespace before the word (i.e. detached). Check for non-empty, and insert it
				// at the start of m_srcPhrase - as ParseWord is concerned with post-word stuff, so nothing below
				// will get it displayed if I don't do it here
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_adaption=[%s], m_markers=[%s] , pointsAt= [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_adaption.c_str(), pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 1)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 10Aug23, need to check that if m_precPunct has content, that that content does no have
				// whitespace preceding the first punct in the m_precPunct string. If we allow it to persist, it
				// ruins setting (when adapting) a valid pSrcPhrase->m_targetStr value, as that initial space or
				// newline causes StoreText() to misbehave, with the disasterous result that user typed additions in the
				// phrasebox are lost, and then TAB or Enter to advance the phrasebox leave behind the old copied src
				// text value - this is how Mike's reported issue happens. Solution here should be simply do Trim(FALSE)
				pSrcPhrase->m_precPunct = pSrcPhrase->m_precPunct.Trim(FALSE);

				if (!pSrcPhrase->m_precPunct.IsEmpty())
				{
					pSrcPhrase->m_srcPhrase = pSrcPhrase->m_precPunct + pSrcPhrase->m_srcPhrase;
				}
				if (bFromDigitsUpdatedPtr == FALSE)
				{
					// BEW 9Jun23 don't update here, if updating after digits or chapVerse has already
					// been done. The flag will be FALSE if ParseAWord() has just parsed above, and that's
					// when augmenting here is needed.
					len += strWordLen;
					ptr += strWordLen;
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
				}
				else
				{
					bFromDigitsUpdatedPtr = FALSE; // restore default
				}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_adaption=[%s], m_markers=[%s] , pointsAt= [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_adaption.c_str(), pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 1)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				/*
				// BEW 12Jul23 testing GetAccumulatedKeys(), since it only is used if there is an unknown marker; used
				// unittest: __nyindrou_MAT_chs_1_and_2.txt, and this test produced: [tubu Jises Krais nadu Debit ]  from 1:1
				#if defined (_DEBUG)
								{
									if (pSrcPhrase->m_nSequNumber == 560)
									{
										wxString str;
										str = GetAccumulatedKeys(pApp->m_pSourcePhrases, 560, 565);
										wxLogDebug(_T("GetAccumulatedKeys() line %d , str= [%s]"), __LINE__, str.c_str());
									}
								}
				#endif
				*/
			elseBlock:
				if ((pApp->bSkipOverParseAWord == TRUE) && (pApp->pSavePtr_forSkip != NULL))
				{
					// These values enable ptr and len to be correct, if we dealt with parsing digits or chapVerse
					// and control did not take one of the provided return blocks, & so we want to let parsing continue
					// in the code which follows this block (code from which we jumped will have m_key & m_srcPhrase
					// values set already, also m_markers and m_endMarkers if there were preceding or following mkrs)
					ptr = pApp->pSavePtr_forSkip;
					len = pApp->nSaveLen_forSkip;
					// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
										// now clear these CAdapt_ItDoc members to initialisation values, to be available for another pSrcPhrase
										// to use if needed
					pApp->bSkipOverParseAWord = FALSE;
					pApp->pSavePtr_forSkip = NULL;
					pApp->nSaveLen_forSkip = 0;
				}

				// BEW 6Dec23 old data from Madagascar has a word followed by space and then colon. Left unhandled,
				// the space will cause return to TokenizeText, and in the next pSrcPhrase, the colon gets handled 
				// as preceding punctuation, and there is no text to span over in ParseAWord(), and the latter then
				// asserts. We need to identify when after ParseAWord() has parsed a word, a <space><punct> sequence
				// has those two characters pulled into the current pSrcPhrase as an addition to m_follPunct, provided
				// whitespace follows the <punct>. Don't generalize, to any punct, stick with just colon and semicolon
				// - because these occur detached in the test data. But omit the space for what's stored on pSrcPhrase,
				// as that a m_srcPhrase value containing space followed by punctuation would be a problem
				// BEW 10Jan22 Bill's MAT Nyindrou doc (46-MATlid.usfm) has the same issue in 3:4, a <space>. before
				// \f*, the <space> needs to be ignored, and we need to allow ptr + 2 to be whitespace, or gSFescapechar
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , m_srcPhrase= [%s] , len= %d , m_adaption=[%s] , pointsAt= [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_srcPhrase.c_str(), len,
						pSrcPhrase->m_adaption.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 1)
					{
						// m_bChapter set TRUE at TokText 19,087; m_bVerse set TRUE at 19475; 
						// m_bFirstOfType at 19532 & 19562 & 19586; \c is deliberately not included in the
						// m_RedBeginMarkers fast-access set, so that Propagation from special on last
						// source phrase is facilitated when special mkrs - eg. \ms, \r, etc follow \c
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 25Jul23, one more test as a favour to Bill'a friend Charles, who has used some
				// straight quotes, detached, at line end. E.g. a sequence like  word.' " followed by newline.
				// Our parser, without extra help here, will see the space between ' and " as indicating the
				// place to close off the current pSrcPhrase. That then leaves "<sp>"<newline> to be parsed
				// for the next pSrcPhrase, control typically then gets past \p<newline> and then to \v 24
				// and ParseAWord() chokes at the presentation of a \v marker, asserting. So I'll hack a
				// solution here. 1. We don't want the space between ' and " to cause next pSrcPhrase create.
				// 2. We DO want <sp>" to be parsed as belonging to the pSrcPhrase current. Or, <sp>' if word." '<newline>
				// 3. We will store the <sp>" - adding those two to m_follPunct, update ptr & len by 2.
				// 4. This is a problem at line end, so the diagnostic test will include CR or LF or CRLF
				// 5. Then after updating ptr and len, return len to caller
				{ //scoping block
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_adaption=[%s], m_markers=[%s] , pointsAt= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_adaption.c_str(), pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 1)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					wxChar* pAux;
					pAux = ptr;
					// pAux may be pointing at one or more word-final puncts, get them if present
					int numberOfPuncts = ParsePuncts(pAux, pEnd, spacelessPuncts);
					if (numberOfPuncts > 0)
					{
						wxString strFinalPuncts;
						int finalPunctsLen;
						finalPunctsLen = 0;
						strFinalPuncts = wxString(pAux, numberOfPuncts);
						finalPunctsLen = strFinalPuncts.Length();
						pSrcPhrase->m_follPunct << strFinalPuncts;
						pSrcPhrase->m_srcPhrase << strFinalPuncts;
						ptr = pAux;
						ptr += finalPunctsLen;
						len += finalPunctsLen;
						pAux = ptr;
					}
					if (pAux < pEnd && *pAux == _T(' ') && (*(pAux + 1) == _T('\"') || *(pAux + 1) == _T('\'')) &&
						(*(pAux + 2) == _T('\r') || *(pAux + 2) == _T('\n') || (*(pAux + 2) == _T('\r') && *(pAux + 3) == _T('\n'))))
					{
						wxString twoOnly;
						twoOnly = wxString(pAux, 2);
						pSrcPhrase->m_follPunct << twoOnly;
						pSrcPhrase->m_srcPhrase << twoOnly;
						ptr += 2;
						len += 2;
						return len;
					}
				} // end scoping block
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 11Jul23, added further test. After ParseAWord() has just parsed a word, and len and ptr
				// have been updated so that ptr points at what immediately follows, it could be a beginMkr.
				// For example, this kind of data: ....oro loke\f (2:1) Iri aloh.....
				// TotenizeText()'s code prior to ParsePreWord followed by ParseWord() does not parse over
				// a word,  such as "loke" - that job belongs to ParseWord(). And \f , a beginMkr, must not be 
				// left unparsed so as to induce a serious parsing error in following code, because following 
				// code is designed to parse post-word puncts, endMkrs, whitespaces. What then: since TokText
				// can't handle the loke, and ParseWord() will choke if \f is attempted for storage on the same
				// pSrcPhrase that is for "loke" in m_key, we have to return the updated len value immediately
				// so that the "\f..." information gets dealt with by a new pSrcPhrase instance. Do here.
				if (*ptr == gSFescapechar)
				{
					bool bIsBeginMkr;
					bIsBeginMkr = FALSE; // init
					wxString wholeMkr; // returned by reference
					bool bIsEndMkr; // returned by reference
					bIsBeginMkr = IsBeginMarker(ptr, pEnd, wholeMkr, bIsEndMkr);
					if (ptr < pEnd && !wholeMkr.IsEmpty() && bIsBeginMkr && !bIsEndMkr)
					{
						// Control is at a location where after the word, a beginMkr is present
						// (the next pSrcPhrase must deal with it, not here now)
						return len;
					}
				} // end of TRUE block for test: if (*ptr == gSFescapechar)
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_adaption=[%s], m_markers=[%s] , pointsAt= [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_adaption.c_str(), pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 1)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 14Jul23, Nyindrou JHN exposed the need for another set of bleeding small parses. The Nyindou
				// data exposing this need is when the end of a line of source text finishes with <punct><space>( followed
				// by CR (\c), LF (\n), or CRLF) or <space>( followed by CR (\c), LF (\n), or CRLF). 
				// John's gospel in Nyindrou has 4 instances  (all were: ".space(" at line end). 
				// It we don't bleed/parse these here, we'd need to do it in  ParsePostWordPuncts() instead,
				// and that is complex enough already. Otherwise, a new pSrcPhrase will be created with ptr
				// pointing at "\n\\v ...." and \v is a beginMkr, and so when ParseAWord eventually gets called,
				// the \v beginMkr will cause an immediate trip of its internal assert.
				// So fix this here, will.
				// The source text data has:  ".space("   or   ".>>space("   so need ParseFinalPuncts()
				//  And for good measure, include '{' and '[' possibilities in the fix as well.
				{ // start scoping block
					wxChar* pAux; pAux = ptr;
					wxChar* pSavePtr; pSavePtr = ptr;
					int saveLen; saveLen = len;
					wxString strPuncts; strPuncts = wxEmptyString; // init
					int itemLen; itemLen = 0; // init
					wxString str1;
					int str1Len; str1Len = 0; // init
					// whm 23Sep2023 added initializations for ch2 and ch3 below because compiler was warning
					// warning C4701: potentially uninitialized local variable 'ch2' used, and
					// warning C4701 : potentially uninitialized local variable 'ch3' used
					wxChar ch2; ch2 = _T(' ');
					wxChar ch3; ch3 = _T(' ');
					// wxChar ch4; // whm 23Sep2023 remove unused variable
					bool bstr1OK; bstr1OK = FALSE; // init
					bool bch2OK; bch2OK = FALSE; // init
					bool bch3OK; bch3OK = FALSE; // init
					bool bch4OK; bch4OK = FALSE; // init

					wxChar chSpace; chSpace = _T(' ');
					int offset; offset = wxNOT_FOUND; // init
					offset = offset; // avoid gcc warning set but not used warning

					// First set of tests, having punct or puncts at pAux
					// initial puncts could be . or .>>  (or other combinations?)
					str1Len = ParseFinalPuncts(pAux, pEnd, spacelessPuncts);
					str1 = wxString(pAux, str1Len);
					itemLen += str1Len;
					pAux += itemLen; // new points at whatever follows the puncts, perhaps space

					if (str1Len > 0)
					{
						bstr1OK = TRUE;

						// Now handle what follows: whitespace, ( or { or [, and then newline
						if (*pAux == chSpace)
						{
							ch2 = chSpace;
							bch2OK = TRUE;
						}
						if (*(pAux + 1) == _T('('))
						{
							ch3 = _T('(');
							bch3OK = TRUE;
						}
						else if (*(pAux + 1) == _T('{'))
						{
							ch3 = _T('{');
							bch3OK = TRUE;
						}
						else if (*(pAux + 1) == _T('['))
						{
							ch3 = _T('[');
							bch3OK = TRUE;
						}
						else
						{
							bch3OK = FALSE; // char at (pAux + 1) is not ( nor { nor [
						}
						// If the 4th character is CR, or LF, or CRLF
						if (*(pAux + 2) == _T('\r') || *(pAux + 2) == _T('\n') || (*(pAux + 2) == _T('\r') && *(pAux + 3) == _T('\n')))
						{
							bch4OK = TRUE;
						}
						// Now use the booleans to test for all TRUE
						if (bstr1OK == TRUE && bch2OK == TRUE && bch3OK == TRUE && bch4OK == TRUE)
						{
							strPuncts << str1; strPuncts << ch2; strPuncts << ch3;
							int punctsLen = strPuncts.Length();
							ptr = pSavePtr + punctsLen;
							len = saveLen + punctsLen;

							pSrcPhrase->m_follPunct << strPuncts;
							pSrcPhrase->m_srcPhrase << strPuncts;
							return len; // what follows ptr location is the newline, and then typically a \v beginMKR (or a word)
						} // end of TRUE block for test: if (bch1OK == TRUE && bch2OK == TRUE && bch3OK == TRUE && bch4OK == TRUE)

					} // end of TRUE block for test: if (str1Len > 0)
					else
					{
						// There is no initial punct character; deal with the other options here;
						// for post-word data like:  "space(" followed by newline, or same but { or [ instead of the ( character
						// Now handle what follows: whitespace, ( or { or [, and then newline
						str1 = wxEmptyString;
						if (*(pAux) == chSpace)
						{
							ch2 = chSpace;
							bch2OK = TRUE;
						}
						if (*(pAux + 1) == _T('('))
						{
							ch3 = _T('(');
							bch3OK = TRUE;
						}
						else if (*(pAux + 1) == _T('{'))
						{
							ch3 = _T('{');
							bch3OK = TRUE;
						}
						else if (*(pAux + 1) == _T('['))
						{
							ch3 = _T('[');
							bch3OK = TRUE;
						}
						else
						{
							bch3OK = FALSE; // char at (pAux + 1) is not ( nor { nor [
						}
						// If the 4th character is a newline (Windows CRLF will be handled ok by the test or CR or LF)
						// This test is required, but we don't parse past the 3rd character, better for next pSrcPhrase
						if (*(pAux + 2) == _T('\r') || *(pAux + 2) == _T('\n') || (*(pAux + 2) == _T('\r') && *(pAux + 3) == _T('\n')))
						{
							bch4OK = TRUE;
						}
						// Now use the booleans to test for all TRUE
						if (bch2OK == TRUE && bch3OK == TRUE && bch4OK == TRUE)
						{
							strPuncts << ch2; strPuncts << ch3;
							itemLen = 2;
							ptr = pSavePtr;
							ptr += itemLen;
							len = saveLen;
							len += itemLen;
							pSrcPhrase->m_follPunct << strPuncts;
							pSrcPhrase->m_srcPhrase << strPuncts;
							return len; // what follows ptr location is the newline, and then typically a \v beginMKR (or a word)
						} // end of TRUE block for test: if (bch2OK == TRUE && bch3OK == TRUE && bch4OK == TRUE)

					} // end of else block for test: if (str1Len > 0) - i.e. first chars are not puncts
				} // end scoping block
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 23Jun23 added test, so that before calling ParsePostWordPuncts in the situation where
				// ptr points at whitespace after setting up the m_key and m_srcPhrase values by code above
				// this point, and after the whitespace is a character which is a preceding punctuation for the
				// next pSrcPhrase, then the start of the whitespace is the right place to force the new pSrcPhrase
				// by returning len here. This will fix the following problem. Input src text:  Sakaria “aju”
				// And if ParsePostWordPuncts() gets to work on that pair, we end up with two pSrcPhrases as follows:
				//  Sakaria““ aju”   which is quite wrong.
				wxChar* pNext; wxChar chNext; int anoffset;
				pNext = (ptr + 1); chNext = *pNext; anoffset = wxNOT_FOUND;
				anoffset = m_strInitialPuncts.Find(chNext);

				// BEW 29Jun23 added WordBeginsHere() test, returns TRUE if chNext is not backslash nor punctuation
				// (This addition should speed up parsing, as most words in a source text don't have following endMkr or punct)
				if (ptr < pEnd && IsWhiteSpace(ptr) && (anoffset >= 0 || WordBeginsHere(chNext, spacelessPuncts)))
				{
					// Then at the start of the whitespace which ptr points at, is where TokText should begin
					// the next pSrcPhrase
					return len;
				}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_adaption=[%s], m_markers=[%s] , pointsAt= [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_adaption.c_str(), pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 1)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s  calling ParsePostWordPunctsAndEndMkrs()"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				ptr = ParsePostWordPunctsAndEndMkrs(ptr, pEnd, pSrcPhrase, itemLen, spacelessPuncts);
				len += itemLen;
				//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
				{
					// BEW 18Jul23, it's possible that the returned ptr is pointing at a beginMkr, like \f for instance.
					// Check this out, and return len immediately; otherwise we risk presenting the beginMkr to ParseAWord()
					// and it would immediately assert.
					wxString wholeMkr; wholeMkr = wxEmptyString; // init
					bool bIsEndMkr; bIsEndMkr = FALSE;
					itemLen = 0;
					// BEW 19Jul23 in the 41MATAAAP.SFM file, at chapter 18 verse 35's end, is a \fig ... \fig*
					// span which, in that source text, has a preceding space before the \fig beginMkr. Not
					// returning here to TokenizeText's early code where \fig gets processed, leads to ParseAWord()
					// asserting. So test for space followed by \fig, and if so, the return len so that TokText will
					// have ptr->space before \fig
					if (ptr < pEnd && *ptr == _T(' ') && *(ptr + 1) == gSFescapechar)
					{
						// Return immediately if at ptr + 1 is a \fig beginMkr
						wxString wholeMkr; wholeMkr = GetWholeMarker((ptr + 1));
						if (wholeMkr == _T("\\fig"))
						{
							return len;
						}
					}
					if (ptr < pEnd && IsBeginMarker(ptr, pEnd, wholeMkr, bIsEndMkr) && !bIsEndMkr)
					{
						return len;
					}
				}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_adaption=[%s], m_markers=[%s] , pointsAt= [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_adaption.c_str(), pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 1)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 1Jan23 is pSrcPhrase within an unfiltered inline span, such as for \f to \f*
				// This current pSrcPhrase might be the last in such a span. If it is, ptr will be
				// pointing at, say, \f*; or if there is a nested endmarker, to something like \fq*\f*
				// The colour / TextType propagation code following ParseWord(), when the next pSrcPhrase
				// looks for relevant endMkr/endMkrs here, by interrogating pLastSrcPhrase, it needs to find them.
				// If not stored, IsTextTypeChangingEndMarker(pLastSrcPhrase) will return FALSE, and that in turn
				// will keep the red colour persisting (for perhaps hundreds os subsequent inspired text words).
				// Check for relevant endMkrs - grab them, and if a inline one is last, like \f*, store them;
				// we do it here because immediately following puncts will have been collected already
				bool bParsedEndMaterial;
				bParsedEndMaterial = FALSE; // initialise
				bParsedEndMaterial = bParsedEndMaterial; // avoid gcc warning set but not used warning
				if (m_bIsWithinUnfilteredInlineSpan == TRUE)
				{
					if (*ptr == gSFescapechar)
					{
						// A marker follows; parse them if they are endMkrs, their width will add to len value.
						// consider that the endMkr may be inline binding, normal, or even inline non-binding.
						// There may be more than one endmarker to deal with, and there could be intervening
						// punctuation, so refactor here - and a similar block follows which also needs same
						// treatment
						; // BEW 2May23, nothing to do here, code further down is sufficient
					}
				}
				// BEW 9Jan23, when the beginMkr was something like \rq, we need a block with a while loop
				// like just above, to handle when looking at the prev pSrcPhrase which needs to deal with
				// the matching endMkr, like \rq*  Such markers need to be present when looking at the prev
				// pSrcPhrase, so that the short span (e.g. Exodus 3:15, or a bit longer) gets its \pq*
				// The m_endMarkers member, like in the block above, is where the storage is. The above
				// block won't suffice, because for Red Markers, m_bIsWithinUnfilteredInlineSpan will be FALSE,
				// and so the above block gets skipped.
				wxString aWholeMkr;
				wxString augEndMkr;
				bool     bIsOneEndMkr;
				int mkrLen;
				mkrLen = 0; // init
				aWholeMkr = wxEmptyString; // init
				augEndMkr = wxEmptyString; // init
				bIsOneEndMkr = FALSE; // init

				// REFACTOR loop over & store all endMkrs on the current pSrcPhrase, m_bIsWithinUnfilteredInlineSpan 
				// will be TRUE within a foonote, \fqa and \fqa* are valid footnote internal markers "footnote alternate translation"
				if (*ptr == gSFescapechar)
				{
					// BEW 23Mar23, refactor, augEndMkr here is needed for the test later, and here
					aWholeMkr = GetWholeMarker(ptr);
					bIsOneEndMkr = IsEndMarker(ptr, pEnd);
					if (bIsOneEndMkr)
					{
						augEndMkr = aWholeMkr + _T(' ');
					}
					if (m_bIsWithinUnfilteredInlineSpan)
					{
						// markers like \f*, \fq*, \fqa*, are all in the m_RedEndMarkers fast-access set.
						// These can only appear, if markup is correct, when _bIsWithinUnfilteredInlineSpan
						// has been set TRUE at the pSrcPhrase which contains the \f beginMkr. So don't loop
						// if the boolean is false.
						// The pertinent fast-access string for the loop below is pApp->m_RedEndMarkers
						// BEW 13Jul23 I say below, "Loop over every endMkr possible" - so I can't confine
						// the testing to just red endMkrs. I have to include blue end mkrs, and also
						// inline non-binding endMkrs too. If none of these supply a match, then break happens

						int offset; offset = wxNOT_FOUND; // init
// LOOP BEGINS
						while (bIsOneEndMkr == TRUE)
						{
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
							{
								wxString pointsAt = wxString(ptr, 16);
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , m_srcPhrase= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_srcPhrase.c_str(), len,
									pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
							if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
							{
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
							}
#endif

							// BEW13Jul23 gotta re-initialise bIsOneEndMkr to FALSE at the start of each iteration,
							// otherwise finding the same endMkr will go on endlessly
							bIsOneEndMkr = FALSE;

							// Loop over every endMkr possible here, and when done, if space or newline follows then
							// here is the place to update len and ptr and return len to the caller when done here
							// if (!augEndMkr.IsEmpty() && gpApp->m_RedEndMarkers.Find(augEndMkr) != wxNOT_FOUND)
							offset = gpApp->m_RedEndMarkers.Find(augEndMkr);
							if (!augEndMkr.IsEmpty() && offset != wxNOT_FOUND) // != -1 if Find() found a red one
							{
								// Control enters here only when an augmented endMkr of the Red set has been found,
								// and the loop iterates so long as subsequent endmarkers belong to the Red endMkrs set
								// and get parsed herein
								mkrLen = aWholeMkr.Length(); // need the value so we can update len and ptr per iteration
								// Red endMkrs are stored in m_endMarkers (protected, so need to use accessors)
								wxString endMarkers;
								endMarkers = pSrcPhrase->GetEndMarkers(); // might be empty at first iteration
								endMarkers << aWholeMkr;
								pSrcPhrase->SetEndMarkers(endMarkers);

								// Update ptr and len
								len += mkrLen;
								ptr += mkrLen;

								// Prepare for next iteration
								if (*ptr != gSFescapechar)
								{
									// another mkr (endMkr or beginMkr) does not immediately follow. Don't break
									// from the loop here, because need a check for sloppy markup between suceessive
									// endMkrs. This happens in Nyindrou MAT data, at chapter 10: 4 where there is the
									// sequence:   "ta Rom.\fk*<space>\f*<space> ma Judas Iskariyot, ndramak"...
									// So put a test here, for a latin space followed by a further endMkr, if so,
									// then parse over the <space>, don't save the space in pSrcPhrase, and iterate 
									// the the loop. This "heals" the sloppy markup (i.e. removes the inter-endMkr space)
									// Beware: after whitespace there may be a beginMkr for next pSrcPhase, or begin-punct
									// on the next word; so I have to here verify that if after whitespace there is a
									// backslash, it's an endMkr for the current pSrcPhrase.
									itemLen = 0;
									itemLen = ParseWhiteSpace(ptr);
									wxChar* pAux;
									bool bAnotherEndMkr;
									bAnotherEndMkr = FALSE; // init
									bool bAnotherBackslash;
									bAnotherBackslash = FALSE; // init
									// If there is no whitespace ( space or newline) at ptr, and no backslash at ptr
									// then there may be punctuation between the markers. Check it out
									if (itemLen == 0)
									{
										// Handle any between-endMkrs puncts, here
										int punctsLen;
										punctsLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
										if (punctsLen > 0)
										{
											// There is at least one punct character at ptr
											wxString strPuncts;
											strPuncts = wxString(ptr, punctsLen);
											pSrcPhrase->m_follPunct << strPuncts;
											pSrcPhrase->m_srcPhrase << strPuncts;
											ptr += punctsLen;
											len += punctsLen;
										}
									} // end of TRUE block for test: if (itemLen == 0)
									else
									{
										// itemLen > 0. So there is some white space ptr, investigate further
										pAux = (ptr + itemLen);
										// The only option that would keep control within the loop, is that
										// at pAux is an endMkr. Otherwise, break out
										bAnotherBackslash = *pAux == gSFescapechar;
										bAnotherEndMkr = IsEndMarker(pAux, pEnd);
										if (bAnotherBackslash && bAnotherEndMkr)
										{
											// Yep, it's sloppy markup, an unwanted short span of inter-endMkr whitespace.
											// We will heal it. We parse over it, but store nothing in pSrcPhrase. And 
											// advance ptr so that the loop can parse the 'another' endMkr just found
											ptr += itemLen;
											len += itemLen;
											itemLen = 0;
										}
										else
										{
											// Not an endMkr or not a backslash, so break out
											mkrLen = 0;
											break;
										} // end of else block for test: if (bAnotherBackslash && bAnotherEndMkr)

									} // end of else block for test: if (itemLen == 0)
								}
								offset = wxNOT_FOUND;
								mkrLen = 0; // init
								aWholeMkr = wxEmptyString; // init
								augEndMkr = wxEmptyString; // init
								aWholeMkr = GetWholeMarker(ptr);
								if (aWholeMkr.IsEmpty())
								{
									break;
								}
								bIsOneEndMkr = IsEndMarker(ptr, pEnd);
								if (bIsOneEndMkr)
								{
									augEndMkr = aWholeMkr + _T(' ');
								}
								// Ready now for iterating loop

							} // end of TRUE block for test: if (!augEndMkr.IsEmpty() && gpApp->m_RedEndMarkers.Find(augEndMkr) != wxNOT_FOUND)
							else
							{
								// Not an endMkr from the Red set. Try non-binding set 
								offset = gpApp->m_inlineNonbindingEndMarkers.Find(augEndMkr);
								if (!augEndMkr.IsEmpty() && offset != wxNOT_FOUND)
								{
									// It's one of the markers in the inline nonbinding markers set
									mkrLen = aWholeMkr.Length();
									wxString nonbindingEndMkrs;
									nonbindingEndMkrs = pSrcPhrase->GetInlineNonbindingEndMarkers();
									nonbindingEndMkrs << aWholeMkr;
									pSrcPhrase->SetInlineNonbindingEndMarkers(nonbindingEndMkrs);

									// Update ptr and len
									len += mkrLen;
									ptr += mkrLen;

									// Prepare for next iteration
									if (*ptr != gSFescapechar)
									{
										// another mkr (endMkr or beginMkr) does not immediately follow. Don't break
										// from the loop here, because need a check for sloppy markup between suceessive
										// endMkrs. This happens in Nyindrou MAT data, at chapter 10: 4 where there is the
										// sequence:   "ta Rom.\fk*<space>\f*<space> ma Judas Iskariyot, ndramak"...
										// So put a test here, for a latin space followed by a further endMkr, if so,
										// then parse over the <space>, don't save the space in pSrcPhrase, and iterate 
										// the the loop. This "heals" the sloppy markup (i.e. removes the inter-endMkr space)
										// Beware: after whitespace there may be a beginMkr for next pSrcPhase, or begin-punct
										// on the next word; so I have to here verify that if after whitespace there is a
										// backslash, it's an endMkr for the current pSrcPhrase.
										itemLen = 0;
										itemLen = ParseWhiteSpace(ptr);
										wxChar* pAux;
										bool bAnotherEndMkr;
										bAnotherEndMkr = FALSE; // init
										bool bAnotherBackslash;
										bAnotherBackslash = FALSE; // init
										// If there is no whitespace ( space or newline) at ptr, and no backslash at ptr
										// then there may be punctuation between the markers. Check it out
										if (itemLen == 0)
										{
											// Handle any between-endMkrs puncts, here
											int punctsLen;
											punctsLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
											if (punctsLen > 0)
											{
												// There is at least one punct character at ptr
												wxString strPuncts;
												strPuncts = wxString(ptr, punctsLen);
												pSrcPhrase->m_follPunct << strPuncts;
												pSrcPhrase->m_srcPhrase << strPuncts;
												ptr += punctsLen;
												len += punctsLen;
											}
										} // end of TRUE block for test: if (itemLen == 0)
										else
										{
											// itemLen > 0. So there is some white space ptr, investigate further
											pAux = (ptr + itemLen);
											// The only option that would keep control within the loop, is that
											// at pAux is an endMkr. Otherwise, break out
											bAnotherBackslash = *pAux == gSFescapechar;
											bAnotherEndMkr = IsEndMarker(pAux, pEnd);
											if (bAnotherBackslash && bAnotherEndMkr)
											{
												ptr += itemLen;
												len += itemLen;
												itemLen = 0;
											}
											else
											{
												// Not an endMkr or not a backslash, so break out
												mkrLen = 0;
												break;
											} // end of else block for test: if (bAnotherBackslash && bAnotherEndMkr)

										} // end of else block for test: if (itemLen == 0)
									}
									offset = wxNOT_FOUND;
									mkrLen = 0; // init
									aWholeMkr = wxEmptyString; // init
									augEndMkr = wxEmptyString; // init
									aWholeMkr = GetWholeMarker(ptr);
									if (aWholeMkr.IsEmpty())
									{
										break;
									}
									bIsOneEndMkr = IsEndMarker(ptr, pEnd);
									if (bIsOneEndMkr)
									{
										augEndMkr = aWholeMkr + _T(' ');
									}
									// Ready now for iterating loop

								} // end of the TRUE block for test: if (!augEndMkr.IsEmpty() && offset != wxNOT_FOUND) - for inline nonbinding
								else
								{
									// Test for one other possibility, blue end marker
									offset = gpApp->m_BlueEndMarkers.Find(augEndMkr);
									if (!augEndMkr.IsEmpty() && offset != wxNOT_FOUND)
									{
										// It's one of the markers in the blue end markers set
										mkrLen = aWholeMkr.Length();
										wxString endMkrs;
										endMkrs = pSrcPhrase->GetEndMarkers();
										endMkrs << aWholeMkr;
										pSrcPhrase->SetEndMarkers(endMkrs);

										// Update ptr and len
										len += mkrLen;
										ptr += mkrLen;

										// Prepare for next iteration
										if (*ptr != gSFescapechar)
										{
											itemLen = 0;
											itemLen = ParseWhiteSpace(ptr);
											wxChar* pAux;
											bool bAnotherEndMkr;
											bAnotherEndMkr = FALSE; // init
											bool bAnotherBackslash;
											bAnotherBackslash = FALSE; // init
											if (itemLen == 0)
											{
												// Handle any between-endMkrs puncts, here
												int punctsLen;
												punctsLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
												if (punctsLen > 0)
												{
													// There is at least one punct character at ptr
													wxString strPuncts;
													strPuncts = wxString(ptr, punctsLen);
													pSrcPhrase->m_follPunct << strPuncts;
													pSrcPhrase->m_srcPhrase << strPuncts;
													ptr += punctsLen;
													len += punctsLen;
												}
											} // end of TRUE block for test: if (itemLen == 0)
											else
											{
												// itemLen > 0. So there is some white space ptr, investigate further
												pAux = (ptr + itemLen);
												// The only option that would keep control within the loop, is that
												// at pAux is an endMkr. Otherwise, break out
												bAnotherBackslash = *pAux == gSFescapechar;
												bAnotherEndMkr = IsEndMarker(pAux, pEnd);
												if (bAnotherBackslash && bAnotherEndMkr)
												{
													ptr += itemLen;
													len += itemLen;
													itemLen = 0;
												}
												else
												{
													// Not an endMkr or not a backslash, so break out
													mkrLen = 0;
													break;
												} // end of else block for test: if (bAnotherBackslash && bAnotherEndMkr)

											} // end of else block for test: if (itemLen == 0)
										}
										offset = wxNOT_FOUND;
										mkrLen = 0; // init
										aWholeMkr = wxEmptyString; // init
										augEndMkr = wxEmptyString; // init
										aWholeMkr = GetWholeMarker(ptr);
										if (aWholeMkr.IsEmpty())
										{
											break;
										}
										bIsOneEndMkr = IsEndMarker(ptr, pEnd);
										if (bIsOneEndMkr)
										{
											augEndMkr = aWholeMkr + _T(' ');
										}
										// Ready now for iterating loop
									} // end of the else block for test: if (!augEndMkr.IsEmpty() && offset != wxNOT_FOUND) - for blue endMkrs
								} // end of else block for test: if (!augEndMkr.IsEmpty() && offset != wxNOT_FOUND)
							} // end of else block for test: if (!augEndMkr.IsEmpty() && offset != wxNOT_FOUND)
						} // end of while loop: while ( bIsAnEndMkr)
// LOOP END
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

					} // end of TRUE block for test: if (m_bIsWithinUnfilteredInlineSpan)

					// what here? At loop end or control broke from the loop before it ended.
					// Probably here is where to return updated len, and ptr to caller. If
					// at ptr there is space or newline. If not, it's still safer to 
					// len here - as the user may have a next word immediately after the last
					// endMkr parsed by the loop.
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					return len;

				} // end of TRUE block for test: if (*ptr == gSFescapechar)

				// Give m_srcPhrase it's initial value, and add following puncts for get a value for m_srcPhrase.
				// (When parsing target text words, the chunks are small - so pEnd is at the end of the word chunk
				// and the addition of following puncts typically will bring ptr to be pointing at pEnd)
				if (pSrcPhrase->m_srcPhrase.IsEmpty())
				{
					itemLen = 0;
					wxString finalPuncts = wxEmptyString;
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					wxString curEndMkrs; wxString myMkr; int myMkrLen;
					bool bStoredEndMkr; wxString curOuterPuncts;
					bStoredEndMkr = FALSE; // initialise
					bool bStoredBindingEndMkr;
					bStoredBindingEndMkr = FALSE; // initialise
					bool bStoredNonbindingEndMkr;
					bStoredNonbindingEndMkr = FALSE;
					wholeMkr = wxEmptyString; // init
					wxString myEndMkr;
					myEndMkr = wxEmptyString;
					if (*ptr == gSFescapechar)
					{
						// BEW 23Mar23, handle data like this from Bill's Nyindrou revelation .SFM file,
						// <<\fk a\fk*>> where here, 'a' is parsed over, and ptr points at  \fk*>> followed by space.
						// If we have an endmkr, we want to hide it in m_endMarkers (use accessors) and then use
						// ParseFinalPuncts() below to get the ">>" pair, add them to m_srcPhrase, and we can test 
						// for a following space and if present after updating len we can return it to TokenizeText 
						myEndMkr = GetWholeMarker(ptr);
						myMkrLen = myEndMkr.Length();
						if (IsEndMarker(ptr, pEnd))
						{
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
							{
								wxString pointsAt = wxString(ptr, 16);
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
							if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
							{
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
							}
#endif

							// It's an endmkr. It might be an inlineBinding mkr, or normal non-inline one, or 
							// an inlineNonbinding mkr - each has a different storage
							pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr); // BEW 24Oct14 overload
							// In the release version, force a document creation error, and hence a halt with a warning
							wxASSERT(pUsfmAnalysis != NULL); // not an unknown marker
							bareMkr = emptyStr; // init, declared at 33260
							wxString hackedMkr;
							hackedMkr = wxEmptyString;
							bool bHackIt = FALSE;
							if (baseOfEndMkr.IsEmpty())
							{
								// Crazy, so hack around it - we know it's an endmarker, and what it is
								if (myMkrLen > 2)
								{
									hackedMkr = wxString(ptr, myMkrLen);
									wxASSERT(hackedMkr == wholeMkr);
									bHackIt = TRUE;
								}
							}
							else
							{
								// baseOfEndMkr is not empty, it should be the same as tagOnly
								// build up the endMkr bit by bit
								if (tagOnly == baseOfEndMkr)
								{
									if (bIsNestedMkr)
										bareMkr = _T('+');  // if nested, start with "+"
									else
										bareMkr.Empty(); // else start empty
									bareMkr << pUsfmAnalysis->marker; // if marker is em, result is either +em or em
									bareMkr += _T('*'); // now it's eiher +em* or em*
									myEndMkr = gSFescapechar + bareMkr; // now it's \+em* or \em*, hence it's reconstructed
								}
							}
							if (bHackIt == TRUE)
							{
								myEndMkr = hackedMkr; // insurance, if LookupUSFM messed up
							}
							wholeMkrPlusSpace = myEndMkr + aSpace; // construct the fast-access string
							int offset;
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
							{
								wxString pointsAt = wxString(ptr, 16);
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
							if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
							{
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
							}
#endif

							if (pUsfmAnalysis->inLine == FALSE)
							{
								// must be an endMkr to be stored in m_endMarkers
								curEndMkrs = pSrcPhrase->GetEndMarkers(); // could be empty
								curEndMkrs += myEndMkr;
								pSrcPhrase->SetEndMarkers(curEndMkrs);
								bStoredEndMkr = TRUE;
								int wholeMkrLen = myEndMkr.Length();
								len += wholeMkrLen;
								ptr += wholeMkrLen;
								// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
																// an unknown marker will have no AI-USFM presence, so control should come into this block for such
							}
							else
							{
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
								{
									wxString pointsAt = wxString(ptr, 16);
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 5)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
								}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
								if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
								{
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
								}
#endif

								// inLine is TRUE, check Red ones, if not there, then inlineNonbinding, if not there
								//then inlineBinding, and if none of those, then it must be an unknown marker so
								// store it in m_endMarkers and for m_inform bracket with ? before an after
								offset = gpApp->m_RedEndMarkers.Find(wholeMkrPlusSpace);
								if (offset >= 0)
								{
									// It's one of the very large 'Red' set, which begins with \f* as it's common;
									// and markers in this set are to be stored in m_markers (for begin ones) and
									// in m_endMarkers (for end markers)  \+nd and \+nd* are in the red set too
									curEndMkrs = pSrcPhrase->GetEndMarkers(); // could be empty
									curEndMkrs += myEndMkr;
									pSrcPhrase->SetEndMarkers(curEndMkrs); // puts it in pSrcPhrase->m_endMarkers
									bStoredBindingEndMkr = FALSE;
									bStoredNonbindingEndMkr = FALSE;

									int mkrLen = myEndMkr.Length();
									len += mkrLen;
									ptr += mkrLen;
									// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
								}
								else
								{
									// could be dhar format type, or nonbinding type, or unknown type
									offset = gpApp->m_charFormatEndMkrs.Find(wholeMkrPlusSpace);
									if (offset >= 0)
									{
										// \em* is in this marker set, as are lots of other inline binding ones
										// BEW 1May23 added \fk and \fk* to the m_charFormatMkrs and m_charFormatEndMkrs sets
										// Note, for storing on pSrcPhrase, we use m_inlineBindingMarkers, and 
										// m_inlineBindingEndMarkers, don't get confused by there being a fast access
										// string called m_inlineBindingMarkers in Adapt_It.cpp, because we make no use
										// of the latter in Adapt It so far.
										wxString strBinding = pSrcPhrase->GetInlineBindingEndMarkers(); // probably empty
										strBinding += myEndMkr;
										pSrcPhrase->SetInlineBindingEndMarkers(strBinding);
										bStoredBindingEndMkr = TRUE;
									}
									else
									{
										// not in the binding mkrs set, so must be in the nonbinding set
										offset = gpApp->m_inlineNonbindingEndMarkers.Find(wholeMkrPlusSpace);
										wxASSERT(offset >= 0);
										if (offset >= 0)
										{
											wxString strNonbinding = pSrcPhrase->GetInlineNonbindingEndMarkers();
											strNonbinding += myEndMkr;
											pSrcPhrase->SetInlineNonbindingEndMarkers(strNonbinding);
											bStoredNonbindingEndMkr = TRUE;
										}
										else
										{
											// if control enters here, it's inline, but not red, nor binding, nor non-binding
											bStoredNonbindingEndMkr = FALSE;
											// and let the following code jump over the unknown endMkr so that
											// parsing will continue
										}
									}
									int mkrLen = myEndMkr.Length();
									len += mkrLen;
									ptr += mkrLen;
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
																		// Punctuation may follow, so don't return before checking for final puncts
								} // end of else block for test: if (offset >= 0)
							} // end of else block for test: if (pUsfmAnalysis->inLine == FALSE) i.e. it's inLine
							bStoredEndMkr = TRUE;
							// BEW 30May23 some final punctuation may follow the endMkr, check, and if so, parse
							// it and store in pSrcPhrase->m_follPunct, and update len & ptr
							itemLen = 0;
							itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
							if (itemLen > 0)
							{
								// One or more puncts follow the endMkr, parse, store, update ptr & len etc
								// Then check if we should return len to TokenizeText() to force a new pSrcPhrase
								wxString endingPuncts;
								endingPuncts = wxString(ptr, itemLen);
								pSrcPhrase->m_follPunct << endingPuncts;
								// m_srcPhrase may have been set (but probably not), or not. Check, if it's empty
								// then set to m_key and add endingPuncts
								if (pSrcPhrase->m_srcPhrase.IsEmpty())
								{
									pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
									pSrcPhrase->m_srcPhrase << endingPuncts;
								}
								else
								{
									// not empty
									pSrcPhrase->m_srcPhrase << endingPuncts;
								}
								int endingPunctsLen = endingPuncts.Length();
								ptr += endingPunctsLen;
								len += endingPunctsLen;
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
							}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
							{
								wxString pointsAt = wxString(ptr, 16);
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif
							// Should we return?
							if (ptr < pEnd && *ptr == _T(' '))
							{
								return len;
							}

						} // end of TRUE block for test: if (IsEndMarker(ptr, pEnd))
					} // end of TRUE block for test: if (*ptr == gSFescapechar)
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					// BEW 23May23 Handle detached punctuation, wrapped by whitespace. Steve White's data contains
					// ':' for example, preceded by nonbreaking space (U+00A0 nbsp), or later on, ». preceded by nbsp
					// And the  ParseFinalPuncts(), encountering nbsp, would correctly return itemLen zero. The 
					// ParseFinalPuncts() call then has the itemLen test fail, and control goes over our code for
					// handling the <nbsp>: followed  by whitespace. So we need to bleed that out here, and return 
					// the new len value, storing the <nbsp>: sequencee in m_follPunct - to keep it on the current pSrcPhrase
					bool bItsWhite;
					bItsWhite = IsWhiteSpace(ptr); // this call handles kinds of white, including nbsp
					if (bItsWhite)
					{
						// One of more puncts may follow: e.g. ':' or "»." So we will need to parse over the whitespace,
						// until something non-white is encountered, then at that point there is a char in spacelessPuncts
						// that halted  the parse over, then we loop over the puncts until we encounter another white space.
						// The string produced by that has, except for the halt-producing white space, is "detached", do
						// we store it in m_follPunct, update ptr and len, and then return len in this block
						wxString strFirstWhite = *ptr;
						wxChar* pAux;
						pAux = ptr + 1; // point pAux at what follows chFirstWhite
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 12);
							wxString auxPointsAt = wxString(pAux, 12);
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , auxPointsAt= [%s]  , pointsAt= [%s]"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, auxPointsAt.c_str(), pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 5)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						if (pAux < (pEnd - 3)) // make sure there's space for a couple of puncts, and another whitespace
						{
							int offset = wxNOT_FOUND; // -1, init
							offset = spacelessPuncts.Find(*pAux);
							if (offset != wxNOT_FOUND)
							{
								// so far, so good. What's at pAux is a punctuation character. Parse over how many there are
								//itemLen = 0;
								bool bIsDetachedPunct;
								bIsDetachedPunct = FALSE; // init
								//int nSpacesCount;
								//nSpacesCount = 0;
								wxString morePuncts;
								morePuncts = wxEmptyString;
								int nHowMany;
								nHowMany = 0;
								nHowMany = ParseFinalPuncts(pAux, pEnd, spacelessPuncts);
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
								{
									wxString pointsAt = wxString(ptr, 16);
									wxString auxPointsAt = wxString(pAux, 16);
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , nHowMany = %d , len= %d , auxPointsAt= [%s]  , pointsAt= [%s]"),
										__LINE__, pSrcPhrase->m_nSequNumber, nHowMany, len, auxPointsAt.c_str(), pointsAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 5)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
								}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
								if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
								{
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
								}
#endif

								if (nHowMany > 0)
								{
									// We have parsed over wxChars in spacelessPuncts, nHowMany is the count
									morePuncts = wxString(pAux, nHowMany); // if detached, we'll store morePuncts & the initial space
									wxChar* pAux2;
									pAux2 = pAux + nHowMany;
									// pAux2 now points at whatever follows the puncts we parsed over.
									// If it's a whitespace, then we have a detached puncts situation
									bool bWhiteFollows;
									bWhiteFollows = IsWhiteSpace(pAux2);
									if (bWhiteFollows)
									{
										// We have a detached puncts situation
										int nSpan = 1 + nHowMany; // 1 is the first whitespace (could be nbsp or other white)
										len += nSpan; // update len
										wxString strAddThese = strFirstWhite; // we store the space or nbsp along with the other puncts
										strAddThese << morePuncts;
										// In m_follPunct store the one white plus the puncts scanned over, same for m_srcPhrase
										pSrcPhrase->m_follPunct << strAddThese;
										pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;  // RHS already set at ParseAWord() call
										pSrcPhrase->m_srcPhrase << strAddThese;
										bIsDetachedPunct = TRUE;
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
										{
											wxString pointsAt = wxString(ptr, 16);
											wxString auxPointsAt = wxString(pAux2, 12);
											wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , bIsDetachedPunct %d , len= %d , auxPointsAt= [%s]  , pointsAt= [%s]"),
												__LINE__, pSrcPhrase->m_nSequNumber, (int)bIsDetachedPunct, len, auxPointsAt.c_str(), pointsAt.c_str());
											if (pSrcPhrase->m_nSequNumber >= 5)
											{
												int halt_here = 1; wxUnusedVar(halt_here);
											}
										}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
										if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
										{
											wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
												__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
										}
#endif

										// reset ptr
										ptr += nSpan; // ptr now points at the whitespace following the puncts & len agrees
												// or it might be the case that a newline follows the puncts; either way, it's
												// time to return len as this pSrcPhrase is finished
										// BEW 26May24 a detached punct may precede an endMkr, so don't return here if
										// the OR clause is a simple check if ptr is pointing at a whitespace char, because
										// the character that makes following punct be "detached" is precisely the one ptr
										// is pointing at. So best to remove the OR clause so control can get to my
										// refactorings for deling with complex markups as in Steve White's 46-MATfuh.SFM data
										if (bIsDetachedPunct && (*ptr == _T('\n'))) // || IsWhiteSpace(ptr)))
										{
											// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
											return len;
										}
									} // end of TRUE block for test: if (bWhiteFollows)
								} // end of TRUE block for test: if (nHowMany > 0) - how many whitespaces
							} // end of TRUE block for test: if (offset != wxNOT_FOUND)
						} // end of TRUE block for test: if (pAux < (pEnd - 3))
					} // end of TRUE block for test: if (bItsWhite)

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , ON_GOING, m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					//wxLogDebug(_T("Log Line = %d"), __LINE__);

					wxChar space; wxString wholeMkr; bool bIsEndMkr; bool bIsBeginMkr; int saveLen; wxChar* pAux;
					int newLen; int nSpacesCount; wxString extraSpaces; wxString morePuncts; int nHowMany;

					// Check out if ptr is pointing at final punctuation characters, whether a char or short string
					itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
					if (itemLen > 0)
					{
						//wxLogDebug(_T("Log Line = %d"), __LINE__);
						finalPuncts = wxString(ptr, itemLen);
						// Add initial puncts, if any exist in m_precPunct, and set m_srcPhrase
						if (pSrcPhrase->m_precPunct.IsEmpty())
						{
							// BEW 27Mar23 we have 2 possible storage locations on pSrcPhrase for the 
							// finalPuncts string parsed over, depending on whether an endMkr was 
							// stored or not, and whether or not bStoredBindingEndMkr is TRUE
							if (bStoredEndMkr && bStoredBindingEndMkr)
							{
								pSrcPhrase->m_follPunct += finalPuncts;
							}
							else if (bStoredEndMkr || (bStoredEndMkr && bStoredNonbindingEndMkr))
							{
								// stored an endMkr or a non-binding one, so following puncts belong in m_follOuterPunct
								curOuterPuncts = pSrcPhrase->GetFollowingOuterPunct();
								curOuterPuncts += finalPuncts;
								pSrcPhrase->SetFollowingOuterPunct(curOuterPuncts);
							}
							else
							{
								pSrcPhrase->m_follPunct += finalPuncts;
							}
							pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key + finalPuncts;
							//wxLogDebug(_T("Log Line = %d"), __LINE__);
						} // end of TRUE block for test: if (pSrcPhrase->m_precPunct.IsEmpty())
						else
						{
							if (bStoredEndMkr)
							{
								// stored an endMkr, so following puncts belong in m_follOuterPunct
								curOuterPuncts = pSrcPhrase->GetFollowingOuterPunct();
								curOuterPuncts += finalPuncts;
								pSrcPhrase->SetFollowingOuterPunct(curOuterPuncts);
							}
							else
							{
								pSrcPhrase->m_follPunct += finalPuncts;
							}
							pSrcPhrase->m_srcPhrase = pSrcPhrase->m_precPunct + pSrcPhrase->m_key + finalPuncts;
							//wxLogDebug(_T("Log Line = %d"), __LINE__);
						} // end of else block for test: if (pSrcPhrase->m_precPunct.IsEmpty())
						ptr += itemLen;
						len += itemLen;
						// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 4)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						// If final puncts was a ">>" string, and an endMkr was stored, then return if
						// ptr now points at a space (otherwise, more tests may apply below)
						if (bStoredEndMkr && (finalPuncts == _T(">>")) && (*ptr == _T(' ')))
						{
							// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
							return len;
						}

						// close if (itemLen > 0) TRUE block here?? , moved up from long way down, at 35461
					} // end of TRUE block for test: if (itemLen > 0)  -- from ParseFinalPuncts(ptr, pEnd, spacelessPuncts) call
					else
					{
						// There are no final puncts to be added, but there may be contents in m_precPunct
						if (pSrcPhrase->m_precPunct.IsEmpty())
						{
							pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
						}
						else
						{
							pSrcPhrase->m_srcPhrase = pSrcPhrase->m_precPunct + pSrcPhrase->m_key;
						}
					} // end of else block for test: if (itemLen > 0)

//wxLogDebug(_T("Log Line = %d"), __LINE__);
					// BEW 10Apr23 various other unusual markups (e.g. in Nyindrou scripture books) can be
					// handled here. Collaboration exposes extra parsing failures, needing fixing.
					// Two common ones, are at line ends (after ParseAWord() has parsed a word any 
					// immediately following puncts have been parsed and added to pSrcPhase->m_follPunct.
					// Error 1. ptr pointing at "<space>(\n\\v<space>....."  i.e. space then '(' at line end
					// Error 2. ptr pointing at "<space>[\n\\v<space>....."  i.e. space then '[' at line end
					// (to be complete, I could put code here for space then '{' at line end, but as it's 
					// unlikely I won't until someone hollers its needed)
					// The test will be longer, but the minimal necessary characters should be parsed over, 
					// because we are dealing with stuff to put in pSrcPhrase->m_follPunct, and we want the
					// next pSrcPhrase to handle the tokenizing of the whitespace followed by verse mkr
					space = _T(' ');
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 4)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					// BEW 13Apr23 handle <space> followed by '(' at line end
					wxString strExtra2;
					if (*ptr == space && *(ptr + 1) == _T('(') && IsWhiteSpace(ptr + 2))
					{
						strExtra2 = _T(" (");
						pSrcPhrase->m_follPunct += strExtra2;
						pSrcPhrase->m_srcPhrase += strExtra2;
						len += 2;
						ptr += 2; // this line unneeded, but it documents the advance of ptr past 2 wxChars
// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
						// no augmenting of m_key is to be done here
						return len;
					}
					// BEW 17Apr23 handle <space> followed by '(' at line end
					if (*ptr == space && *(ptr + 1) == _T('[') && IsWhiteSpace(ptr + 2))
					{
						strExtra2 = _T(" [");
						pSrcPhrase->m_follPunct += strExtra2;
						pSrcPhrase->m_srcPhrase += strExtra2;
						// [ and ] are special, if not followed by a word, we keep it on a single pSrcPhrase
						if (pSrcPhrase->m_key.IsEmpty())
						{
							pSrcPhrase->m_key = _T("[");
						}
						len += 2;
						ptr += 2;
						// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
						return len;
					}

					// What comes next? maybe space, maybe and endMkr, maybe a beginMkr, maybe space followed by more punctuation
					// provide such punctuation is not curly initial quote (because the latter would signal the start of the
					// next pSrcPhrase and hence a return of len is due). Work thru the options....

					wholeMkr = wxEmptyString; // init
					bIsBeginMkr = FALSE; // init
					saveLen = 0; // init
					pAux = NULL; // init
					// If at a beginMkr, must return len to TokenizeText()
					bIsBeginMkr = IsBeginMarker(ptr, pEnd, wholeMkr, bIsEndMkr);
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 4)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					//wxLogDebug(_T("Log Line = %d"), __LINE__);
					bool bIsABeginningMarker;
					bIsABeginningMarker = FALSE;
					if (bIsBeginMkr)
					{
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
												// BeginMkrs get dealt with in TorkenizeText, so return len
						return len;
					}
					else
					{
						// Not at a beginMarker, is one of those at ptr+ 1 ? If so, return len to TokenizeText
						// BEW 5Jan23 reinit to FALSE because somehow the FALSE value above is not being retained,
						// and IsBeginMarker (ptr = 1, empty, false) is returning TRUE (204) - this might mess
						// parsing up, so first get it back to FALSE
//wxLogDebug(_T("Log Line = %d"), __LINE__);
						bIsABeginningMarker = IsBeginMarker(ptr + 1, pEnd, wholeMkr, bIsEndMkr);
						if (*ptr == space && bIsABeginningMarker)
						{
							// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
														// return len now
							return len;
						}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 4)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif	
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						// BEW 9May23 a whitespace, one or more, before pEnd should not have 
						// ParseOverAndIgnoreWhiteSpace(pAux, pEnd, newLen) called, because it would
						// increase the len value by however many doc-ending whites are present, giving
						// headaches for exporting the src text - we don't what any such spaces stored;
						// but we must parse over them to finish off the doc parse, so put a block here
						// to handle this problem. numSpaces above has how many there are. We'll remove
						// any such later after ParseWord() has returned
						int numWhiteSpaces = ParseWhiteSpace(ptr);
						//wxLogDebug(_T("Log Line = %d"), __LINE__);
						if (numWhiteSpaces > 0)
						{
							wxChar* pAux = ptr + numWhiteSpaces;
							if (pAux == pEnd)
							{
								// There are 1 or more whites at end of srctext parsed in
								len += numWhiteSpaces;
								// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
								return len;
							}
						}

						// Now we are able to consider if the space at ptr is preceding additional punctuation belonging
						// to the current pSrcPhrase. This will involve testing for punctuation, but beware, there may
						// be punctuation present, but it might be opening curly quote - which of course would belong to 
						// the next pSrcPhrase, so test accordingly. (This is the block that should handle the _HEZ_7 
						// fragment: "travel!’ ” \qs Isaiah" that Bill told me about.)
						bool bIsOpeningQuote = IsOpeningQuote(ptr + 1);
						bool bNotBeginMkr = !bIsBeginMkr;
						//bool bSpaceAtPtr = *ptr == space ? TRUE : FALSE; <<-- BEW 17Dec22, weird, when ptr points at 
								// ascii/latin space, the equality test yields FALSE, not TRUE. So try counting ascii spaces
								// as so far it always yields a correct space count 
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , ptr->%s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 4)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						int numSpaces = CountSpaces(ptr, pEnd); // BEW 17Dec22 try this way for the next line's test
//wxLogDebug(_T("Log Line = %d   numSpaces = %d  FROM CountSpaces"), __LINE__, numSpaces);

						if ((numSpaces > 0) && bNotBeginMkr && !bIsOpeningQuote)
						{
							saveLen = len;
							pAux = ptr;
							wxChar* savePtr = ptr;
							newLen = len;
							//wxLogDebug(_T("Log Line = %d"), __LINE__);
														// The next call will git pAux past the space, leaving pAux pointing at what follows - 
														// potentially one or more following puncts - such as ”
							newLen = ParseOverAndIgnoreWhiteSpace(pAux, pEnd, newLen); // pAux and newLen are updated within
							// Restore ptr
							ptr = savePtr;
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
							{
								wxString pointsAt = wxString(ptr, 16);
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , newLen= %d , m_markers=[%s] , ptr->%s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), newLen, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 4)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
							if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
							{
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
							}
#endif

							//wxLogDebug(_T("Log Line = %d"), __LINE__);
							if (newLen > saveLen)
							{
								nSpacesCount = newLen - saveLen;
								extraSpaces = wxEmptyString;
								if (nSpacesCount > 0)
								{
									extraSpaces = wxString(ptr, nSpacesCount);
									// BEW 27Mar23 error here, failed to add nSpacesCount to len, do so now
									// For example, when parsing "ndra-in.> >>\n\\s " ptr gets to here pointing
									// at [sp]>>\n\\s and so there's an extra space parsed over, then below,
									// at 34133, ParseFinalPuncts would then parse the ">>" substring
									len += nSpacesCount; // keep len in sync with newLen above
// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
								}
								//wxLogDebug(_T("Log Line = %d"), __LINE__);
																// check for puncts at pAux
								itemLen = 0;
								// BEW 5Jan23, ptr may be pointing at initial curly quote or doublequote, or
								// at Mike Hore's use of grave (U+0060) as an opening quote; Parsing over these
								// would extend parsing into what belongs in the next pSrcPhrase - so put
								// protective check wrapper for the ParseFinalPuncts() call here
								if (IsOpeningQuote(pAux) || (*pAux == (wxChar)0x0060))
								{
									// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
									return len;
								}
								itemLen = ParseFinalPuncts(pAux, pEnd, spacelessPuncts);
								bool bIsDetachedPunct;
								bIsDetachedPunct = FALSE; // init
//wxLogDebug(_T("Log Line = %d"), __LINE__);
								if (itemLen > 0)
								{
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
									{
										wxString pointsAt = wxString(ptr, 16);
										wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
											__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
										if (pSrcPhrase->m_nSequNumber >= 4)
										{
											int halt_here = 1; wxUnusedVar(halt_here);
										}
									}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
									if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
									{
										wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
											__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
									}
#endif

									//wxLogDebug(_T("Log Line = %d"), __LINE__);
									morePuncts = wxString(pAux, itemLen);
									nHowMany = morePuncts.Len();
									if (nHowMany > 0)
									{
										int nLenFromPtr = nSpacesCount + nHowMany;
										len += nLenFromPtr;
										ptr += nLenFromPtr;
										// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
										pSrcPhrase->m_follPunct << extraSpaces;
										pSrcPhrase->m_follPunct << morePuncts;
										pSrcPhrase->m_srcPhrase << extraSpaces;
										pSrcPhrase->m_srcPhrase << morePuncts;
										bIsDetachedPunct = TRUE;
									}
									else
									{
										ptr += nHowMany;
										len += nHowMany;
										// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
										pSrcPhrase->m_follPunct << morePuncts;
										pSrcPhrase->m_srcPhrase << morePuncts;

									}
									//wxLogDebug(_T("Log Line = %d HANDLED DETACHED"), __LINE__);
								}
								// BEW 23May23 put code here for returning after handling
								// detached final punctuation, if appropriate, i.e. if space
								// or newline follows ptr, and we know the punct(s) are detached
								// BEW 26May23 removed OR clause, because if ptr does not point at
								// a newline, then our code further below must be allowed its chance
								if (bIsDetachedPunct && (*ptr == _T('\n'))) //|| IsWhiteSpace(ptr)) ) 
								{
									// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
									return len;
								}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
								{
									wxString pointsAt = wxString(ptr, 16);
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , bIsDetachedPunct %d , ptr->%s"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, (int)bIsDetachedPunct, pointsAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 4)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
								}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
								if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
								{
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
								}
#endif

								// BEW 25May23 another possibility is that the detached punct 
								// or puncts is/are followed by an endMkr, such as \f*, 
								// if it was \f* it would not make sense for there to be punctuation
								// following it; so we'll test for \f* followed by whitespace, and
								// if true, then return with ptr pointing at the whitespace, and len 
								// agreeing. But after the endmarker there may be other things than
								// whitespace; there may be newline, or a beginMkr - each such must
								// close of the current pSrcPhrase, after dealing with the parse &
								// data storage
								// BEW 26May23, removed subtest for *ptr being a backslash, because
								// bDetachedPunct is FALSE, then control will exit this block and the
								// next test will be for a beginMkr. Here we are wanting to handle any
								// complexities which involve endmarkers, and possibly some punctuation
//wxLogDebug(_T("Log Line = %d  if (bIsDetachedPunct)"), __LINE__);
								if (bIsDetachedPunct)
								{
									int saveLength = len;
									wxString wholeMkr = GetWholeMarker(ptr);
									int wholeMkrLen = wholeMkr.Length();
									bool bIsEndMkr = IsEndMarker(ptr, pEnd);
									wxString augWholeEndMkr;
									bool bWhiteAfterEndMkr;
									if (bIsEndMkr)
									{
										augWholeEndMkr = wholeMkr + _T(' '); // can test for RedEndMarkers, 
																// and/or inlineNonbinding endMkrs, like \wj*
										wxChar* pAux = ptr + wholeMkrLen;
										bWhiteAfterEndMkr = IsWhiteSpace(pAux);
										// BEW 26May23 add the other possibilities for what pAux might be.
										// ptr is earlier, and we must test for what it points to for
										// parsing the endMkr
										bool bIsANewline;
										bool bIsABeginMkr;
										wxString strMkrFound;
										bool bIsEndMkr;
										bIsABeginMkr = IsBeginMarker(pAux, pEnd, strMkrFound, bIsEndMkr);
										bIsANewline = (*pAux == _T('\n'));
										//wxLogDebug(_T("Log Line = %d"), __LINE__);
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
										if (bIsDetachedPunct)
										{
											wxString pointsAt = wxString(ptr, 16);
											wxString auxPointsAt = wxString(pAux, 16);
											wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , auxPointsAt=[%s] , ptr->%s"),
												__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, auxPointsAt.c_str(), pointsAt.c_str());
											if (pSrcPhrase->m_nSequNumber >= 4)
											{
												int halt_here = 1; wxUnusedVar(halt_here);
											}
										}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
										if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
										{
											wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
												__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
										}
#endif

										// Now the test is three possibilities separated by OR
										if (bWhiteAfterEndMkr || bIsANewline || bIsABeginMkr)
										{
											//wxLogDebug(_T("Log Line = %d  WHITE/NEWLINE/BEGINMKR"), __LINE__);
																						// There are three possibilities. Most likely, the endMkr is one
																						// of the Red set, such as \f*. Less likely, an the endMkr is an
																						// inlineNonbindingEndMarker - this is a small set, for the likes of \wj*
																						// and the third possibility is it may be a character formatting endMkr.
																						// Whichever is the case, we will return with len updated to where the
																						// endMrk ends - at whitespace, or newline, or a beginMkr
											int offset = wxNOT_FOUND;
											offset = gpApp->m_RedEndMarkers.Find(augWholeEndMkr);
											if (offset >= 0)
											{
												// the wholeMkr is an endmarker of the m_RedEndMarkers set, and
												// followed by a whitespace character, save the endmkr, update ptr
												// and len, and store the endMkr in m_endMarkers then return len
												wxString myEndMkrs = pSrcPhrase->GetEndMarkers();
												myEndMkrs << wholeMkr;
												pSrcPhrase->SetEndMarkers(myEndMkrs);
												len = saveLength + wholeMkrLen;
												ptr += wholeMkrLen; // ptr now points where pAux points
												if (bWhiteAfterEndMkr || bIsANewline || bIsABeginMkr)
												{
													// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
													return len;
												}
											}
											// If there was no return done, then check for an inlineNon-binding endMkr
											offset = gpApp->m_inlineNonbindingEndMarkers.Find(augWholeEndMkr);
											if (offset >= 0)
											{
												// It's one of the 10 known inline nonbinding endMkrs
												// and len, and store the endMkr in m_endMarkers then return len
												wxString myEndMkrs = pSrcPhrase->GetInlineNonbindingEndMarkers();
												myEndMkrs << wholeMkr;
												pSrcPhrase->SetInlineNonbindingEndMarkers(myEndMkrs);
												len = saveLength + wholeMkrLen;
												ptr += wholeMkrLen; // ptr now points where pAux points
												if (bWhiteAfterEndMkr || bIsANewline || bIsABeginMkr)
												{
													// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
													return len;
												}
											}
											//wxLogDebug(_T("Log Line = %d"), __LINE__);
																						// If no return there may be an endmarker for character formatting, test for that
											offset = gpApp->m_charFormatEndMkrs.Find(augWholeEndMkr);
											if (offset >= 0)
											{
												// It's an inline binding endmkr, such as \it*
												wxString myCharEndMkrs = pSrcPhrase->GetInlineBindingEndMarkers();
												myCharEndMkrs << wholeMkr;
												pSrcPhrase->SetInlineBindingEndMarkers(myCharEndMkrs);
												len = saveLength + wholeMkrLen;
												// don't need to update ptr, but no harm in doing so
												ptr += wholeMkrLen;	// ptr now points where pAux points
												if (bWhiteAfterEndMkr || bIsANewline || bIsABeginMkr)
												{
													// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
													return len;
												}
											}
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
											{
												wxString pointsAt = wxString(ptr, 16);
												wxString auxPointsAt = wxString(pAux, 4);
												wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , *NO RETURN* m_key= %s , len= %d , auxPointsAt=[%s] , ptr->%s"),
													__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, auxPointsAt.c_str(), pointsAt.c_str());
												if (pSrcPhrase->m_nSequNumber >= 4)
												{
													int halt_here = 1; wxUnusedVar(halt_here);
												}
											}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
											if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
											{
												wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
													__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
											}
#endif

											// If control gets thru all tests without returning, then probably there is
											// one or more characters of final punctuation at pAux, so just in case,
											// put parsing code for that here; and after dealing with that, or if there is
											// no punctuation to deal with at pAux, return len anyway, because a new
											// pSrcPhrase must commence
											wxChar chAtAuxPtr = *pAux;
											int offset2 = wxNOT_FOUND; // init
											offset2 = spacelessPuncts.Find(chAtAuxPtr);
											//wxLogDebug(_T("Log Line = %d"), __LINE__);
											if (offset2 >= 0)
											{
												// There are some final puncts to deal with
												int numPuncts = ParseFinalPuncts(pAux, pEnd, spacelessPuncts);
												wxASSERT(numPuncts > 0); // consternation if I found one, and parsing produced none!
												// Puncts have to be added to pSrcPhrase->m_follPunct, and to pSrcPhrase->m_srcPhrase
												wxString strPuncts = wxString(pAux, numPuncts);
												pSrcPhrase->m_follPunct << strPuncts;
												pSrcPhrase->m_srcPhrase << strPuncts;
												len += numPuncts;
												ptr = pAux + numPuncts; // BEW 16Jun23 added
// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
//wxLogDebug(_T("Log Line = %d RETURN"), __LINE__);
												return len;
											}
											else
											{
												// No final puncts at pAux
// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
												return len;
											}
										} // end of TRUE block for test: if (bWhiteAfterEndMkr)
									} // end of TRUE block for test: if (bIsEndMkr)

								} // end of TRUE block for test: if (bIsDetachedPunct && (*(ptr - 1) == gSFescapechar))
							} // end of TRUE block for test: if (newLen > saveLen)
						} // end of TRUE block for test: if (*ptr == space && !bBeginMkr && !IsOpeningQuote)
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 4)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						//wxLogDebug(_T("Log Line = %d  HERE IS TOO FAR"), __LINE__);
												// BEW 26Dec22 check again for a begin mkr here, if so, return len to TokenizeText
						bool bIsBeginMkr = ((*ptr == gSFescapechar) && !IsEndMarker(ptr, pEnd)) ? TRUE : FALSE;
						if (bIsBeginMkr)
						{
							// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
							return len;
						}

						int  nHowManyPrecedingPuncts = 0; // init  (these two for the \wj* search)
						bool bWJ_or_Similar_Is_Ahead = FALSE; // init
						int  countOfSpaces = 0; // init
						// BEW 20Dec22 there may be a detached \wj* endMkr following whitespace, to deal with
						// so it's storage is on the current pSrcPhrase - if so, and we didn't deal with it,
						// TokenizeText would see it as a markup error, and tell the user that its an
						// unexpected endMkr (at the pSrcPhrase which will follow the current one).
						wxChar* pGapStart = ptr; // use LHS for working out the gap to where the endMkr starts, if we find one
						wxChar* pGapEnd = pGapStart; // initialise
						nHowManyPrecedingPuncts = 0; // init

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 4)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						bWJ_or_Similar_Is_Ahead = IsDetachedWJtype_endMkr_Ahead(ptr, pEnd, nHowManyPrecedingPuncts);
						countOfSpaces = 0;
						// nHowManyPrecedingPuncts is unreliable if bWJ_or_Similar_Is_Ahead was returned FALSE
						if (bWJ_or_Similar_Is_Ahead)
						{
							// Skip if the test was FALSe
							countOfSpaces = nHowManyPrecedingPuncts;
						}
						else
						{
							nHowManyPrecedingPuncts = 0; // restore default zero
						}
						// If bWJ_or_Similar_Is_Ahead is TRUE, it's likely only a latin space precedes the \wj* endMkr.
						// It's possible that the user's markup may have put a U+200A hairspace preceding it - if so,
						// our functions will cope with that. However, since the \wj* will be stored out of sight from
						// the user in the GUI layout, a preceding latin space is sufficient. If there is no space of
						// either kind preceding, then the \wj* is not "detached", and code further down handles that scenario

						// Hunt for a possible \wj* or similar, preceded by at least one space or U+200A hairspace
						// If there was no whitespace before \wj* or similar inLine endMkr, then such an endMkr type will
						// have been parsed and stored in pSrcPhrase->m_inlineNonbindingEndMarkers
						if ((ptr < pEnd) && bWJ_or_Similar_Is_Ahead && (nHowManyPrecedingPuncts > 0))
						{
							// Make sure m_srcPhrase is set to at least m_key, plus any existing preceding
							// puntuation characters, else on return to TokenizeText() ll that appears 
							// may be just some punctuation characters!
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
							{
								wxString pointsAt = wxString(ptr, 16);
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 4)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
							if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
							{
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
							}
#endif

							wxString key = pSrcPhrase->m_key;
							int keyLen = key.Len();

							wxString srcPhrase = pSrcPhrase->m_srcPhrase;
							if (srcPhrase.IsEmpty())
							{
								pSrcPhrase->m_srcPhrase = pSrcPhrase->m_precPunct;
								pSrcPhrase->m_srcPhrase += pSrcPhrase->m_key;
							}
							int srcPhraseLen = srcPhrase.Len();
							wxASSERT(srcPhraseLen >= keyLen);

							// One more possibility for the current pSrcPhrase. There may be
							// something like \wj* following, and maybe spaces prior to it. If
							// so, we need to do similary to above. The ParseWord() parser already
							// handles \wj*, so why here too? Here, because these present code
							// blocks are dealing with endMrks (inline or not) which could precede
							// a \wj* mkr. While this would be an unexpected coincidence, not
							// allowing for it is to invite a parsing and GUI mess sometime when
							// the coincidence happens. When \wj* abbuts something to the left,
							// other parser code handles it. We only need be concerned here with
							// space or spaces to the left of \wj* (or similar type of endMkr)
							wxChar* pKeepHere = ptr;
							//int countOfSpaces = CountSpaces(ptr, pEnd);
							countOfSpaces = nHowManyPrecedingPuncts;

							wxChar* ptr = pKeepHere + countOfSpaces;
							wxString wholeMkr = GetWholeMarker(ptr);
							int mkrLen = wholeMkr.Len();
							if (!wholeMkr.IsEmpty())
							{
								bool bIsEndMkr = IsEndMarker(ptr, pEnd);
								if (bIsEndMkr)
								{
									// Use a fast access string
									int offset = wxNOT_FOUND; // initialise
									wxString augmentEMkr = wholeMkr + _T(' ');
									offset = gpApp->m_BlueEndMarkers.Find(augmentEMkr);
									if (offset >= 0)
									{
										// It's one of them, not necessarily \wj*, but we'll store whatever it is.
										// Being in the m_BlueEndMarkers set, means it's inLine TRUE, so storage will
										// be not to pSrcPhrase->m_endMarkers, but to pSrcPhrase->m_inlineNonbindingEndMarkers
										wxString strNonBEMkrs = pSrcPhrase->GetInlineNonbindingEndMarkers();
										wxString strStoreThis = _T(" ") + wholeMkr; // default, but reset to be U+2008 if not latin space

										// BEW 19Dec22, check for prior space or 200A hairspace here; if hairspace precedes the endMkr
										// we must use that for the whitespace wxChar to be stored with wholeMkr, rather than latin space
										wxChar chBeforeEndMkr = (wxChar)0; // same as _T('\0'), initialise 
										chBeforeEndMkr = *(ptr - 1); // it's not necessarily a space of some kind, could be punct
										wxString strPriorChar;
										if (chBeforeEndMkr != _T('\0'))
										{
											if (chBeforeEndMkr == (wxChar)0x200A)  // a hairspace
											{
												// Use hairspace instead of latin space
												strStoreThis = (wxChar)0x200A + wholeMkr;
											}
										}
										strNonBEMkrs += strStoreThis;
										pSrcPhrase->SetInlineNonbindingEndMarkers(strNonBEMkrs);
										// TokenizeText needs len value increased to keep in sync
										pGapEnd = ptr;
										itemLen = 0;
										itemLen = (int)(pGapEnd - pGapStart);
										len += itemLen + mkrLen;
										ptr += itemLen + mkrLen;
										// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
										itemLen = 0;

										// Are there following puncts, parse these too
										itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
										if (itemLen > 0)
										{
											wxString extraPuncts = wxString(ptr, itemLen);
											pSrcPhrase->m_follPunct += extraPuncts;
											pSrcPhrase->m_srcPhrase += extraPuncts;// so user can see it in GUI layout
											len += itemLen;
											ptr += itemLen;
											// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
											itemLen = 0;
										}


									} // end of TRUE block for test: if (offset >= 0)
									// BEW 14Nov22. Beware. Don't parse over a '\n', it will cause ParseAWord() to assert, 
									// or release build to crash; if in either case a beginMkr follows ?? BEW 22Dec22 I'm
									// pretty certain this restriction no longer applies. The comment can stand for now.	
									return len;
								} // end of TRUE block for test: if (bIsEndMkr)

							} // end of TRUE block for test: if (!wholeMkr.IsEmpty()) -- correct indent

						} // end of TRUE block for test: if ((ptr < pEnd) && bWJ_or_Similar_Is_Ahead && (nHowManyPrecedingPuncts > 0)) -- correct indent
						else
						{
							// BEW 16Nov22, There is no following \wj* (or similar), after one or more spaces. So here we should return
							// len to TokenizeText(). But first, check for following punctuation, if present then parse over it,
							// add it to pSrcPhrase->m_follPunct, and to m_srcPhrase, and update len by the number of characters in
							// the puncts string, then return len. OR, ptr might be in a footnote span or similar, and ptr points at \f*
							// or similar endMkr. Check for that too, because if that's so, control must continue on to the enfmkrs
							// while loop further down.

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
							{
								wxString pointsAt = wxString(ptr, 16);
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 4)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
							if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
							{
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
							}
#endif

							// Check for ptr pointing at a span's endMkr
							bool bEndMkrHere; // init
							bEndMkrHere = IsEndMarker(ptr, pEnd);
							if (!bEndMkrHere)
							{
								int offset = wxNOT_FOUND;
								offset = spacelessPuncts.Find(*ptr);
								if (offset >= 0)
								{
									// the .Find() call found punctuation character pointed to by ptr, so parse over these
									itemLen = 0;

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
									{
										wxString pointsAt = wxString(ptr, 16);
										wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
											__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
										if (pSrcPhrase->m_nSequNumber >= 4)
										{
											int halt_here = 1; wxUnusedVar(halt_here);
										}
									}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
									if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
									{
										wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
											__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
									}
#endif

									itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
									if (itemLen > 0)
									{
										wxString finalPunctuation = wxString(ptr, itemLen);
										wxASSERT(itemLen >= 1);
										// Add the puncts string to pSrcPhrase->m_srcPhrase, and m_follPunct
										pSrcPhrase->m_srcPhrase += finalPunctuation;
										pSrcPhrase->m_follPunct += finalPunctuation;
										len += itemLen;
										itemLen = 0;
										// No need to update ptr, len will give TokenizeText the span width to add to its local ptr
									}
									return len;
								}
							} // end of TRUE block for test: if (!bEndMkrHere)
						} // end of else block for test: if ((ptr < pEnd) && bWJ_or_Similar_Is_Ahead && (nHowManyPrecedingPuncts > 0)) -- correct indent

					} // end of else block for test: if (bIsBeginMkr)

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 4)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					if (ptr == pEnd)
					{
						return len;
					}
					// BEW 29Nov22, in some special situations, particularly parsing a footnote after \ft marker,
					// there may be punctuation and/or whitespace before the final \f* is reached. If there is
					// whitespace, then without a protecting hack here, the whitepace will cause len to be returned
					// to TokenizeText(), and a new pSrcPhrase will be generated but ptr will point not to a beginMkr,
					// but to \f*. This is an error situation, because when ParseWord() gets called, ParseAWord() will
					// immediately assert (or in Release version, the app will crash or get into an infinite loop)
					// because of len being set to zero and the parser cannot advance.
					// The solution is to avoid responding to a whitespace prior to \f* (or other inline end marker)
					// as a "return len to caller" situation. Instead, detect the problem and parse on and over the
					// inline \f* or whatever end mkr is there. We don't need to test for the marker being inLine,
					// just identifying it as an endMkr is sufficient. Do the len increment, store the endMkr in
					// pSrcPhrase->m_endMarkers, etc - then return len to Tok...Text(). When control is in an inLine
					// span, such as a footnote or xref, the Doc member boolean: m_bIsWIthinUnfilteredInlineSpan will
					// be TRUE. We need  to use that here in the test for entry to our hack. 
//					wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

					// BEW 29Nov22, we have (much further below) a while loop that parses successive endMkrs - e.g, a
					// nested inline binding endmarker in an unfiltered span, which is followed by an endmarker such as \f*
					// The TRUE block following the m_bIsWithinUnfilteredInlineSpan is TRUE test, is designed only for 
					// handling something like \f* as the next endMkr. So to get control to use the while loop, we
					// have to prevent nested endmarker from here causing a misparse (which would crash the app).
					// So here we an put some code to advance pAux to the next endMkr, and if it is inline binding type,
					// we don't enter the block which tests m_bIsWithinUnfilteredInlineSpan for TRUE
					// BEW 2Dec22 need to not enter this block, which advances pointer to an endmarker (which might
					// turn out to be a beginMkr if we are trying to deal with multiple final quotes), so add to
					// the entry test to protect
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 4)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

				} // end of TRUE block for test: if (pSrcPhrase->m_srcPhrase.IsEmpty())

				// ParseAWord() may have exited at a whitespace following theWord, but some users will include a following
				// endMrk - but with a whitespace preceding the \endmkr*. If we don't take this into account, then something like
				// "God \nd*" would cause God to be on the current pSrcPhrase, and then \nd* commencing the text of the next pSrcPhrase -
				// which is a parsing error. The current pSrcPhrase needs to keep and store the <whitespace>\nd* I think USFM 
				// stipulates English space char, rather than things like zwsp for the space before a marker - so I'll assume
				// _T(' '), but the \endMrk* could  be inline binding, or an ordinary one, so I'll take those 2 options into
				// account because each has its own storage on the pSrcPhrase.
				//wxChar* pKeepWordEnd = ptr; // needed?, I'll do a few tests here
				int nCurLen = len;

				wxString strPuncts1 = wxEmptyString; // init
				int nPuncts1 = 0; // init
				nPuncts1 = nPuncts1; // avoid gcc warning set but not used warning

				wxString strCountedSpaces1 = wxEmptyString; // init

				wxString strInlineBindingEM1 = wxEmptyString;
				wxString strToAdd1 = wxEmptyString;
				wxString strEndMkrs1 = wxEmptyString;
				int      nInlineBindingEMLen1 = 0;
				nInlineBindingEMLen1 = nInlineBindingEMLen1; // avoid gcc warning set but not used warning
				wxString strFirstPuncts = wxEmptyString; // init
				wxString strIBEM = wxEmptyString; // init


				// BEW 18Nov22, our parser misparses data like you(plur) or they(more than one) etc, because '(' is
				// a punctuation character, and m_key and m_srcPhrase are set above to "you", ParseAWord() has exited
				// with ptr pointing at (you) - which, unless we do something to prevent it, will be on the next pSrcPhrase.
				// For my first attempt at a hack, I'll make a test for felicity conditions for a jump to the label parenth:
				// at about 33195 give or take. I'm jumping because I have existing code for parsing such things after where
				// the label is. So I may get this solved on the cheap, with this jump.
				wxChar chOpenParen = _T('(');
				if (ptr < pEnd && (spacelessPuncts.Find(chOpenParen) >= 0) && (*ptr == chOpenParen) && (*(ptr - 1) != _T(' ')))
				{
					// If ptr is not at the doc end, and ( is a punctuation character, and ptr points to a '(' character, and
					// the character preceding the '(' is not a space character, then jump
					goto parenth;
				}
				//				wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 4)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// Next test, is there space or spaces before an \endMkr* that needs the endmarker added to pSrcPhrase
				// and the \endMkr* added to which of pSourcePhrase's storage locations it belongs. Options are for inline 
				// binding, inline nonbinding, or normal endmarkers. We need to preserve state as we go, because we'll
				// try as far as a \wj* with following puncts, but we'll advance over valid endpoints most likely as we go.
				// We try first for what might follow the word - punctuation before a binding endmarker is crazy, but we
				// must allow for it.
				// Are there following puncts, parse these
				itemLen = 0;
				itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
				if (itemLen > 0)
				{
					// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
					strPuncts1 = wxString(ptr, itemLen);
					// Store the puncts in m_follPunct, on pSrcPhrase
					pSrcPhrase->m_follPunct += strPuncts1;
					// BEW 23Dec22, By now, any precPuncts are on the currente pSrcPhase->m_srcPhrase string, so just 
					// add the extra
					//if (pSrcPhrase->m_srcPhrase.IsEmpty())
					//{
					//	pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
					//	pSrcPhrase->m_srcPhrase += strPuncts1;
					//}
					//else
					//{
					pSrcPhrase->m_srcPhrase += strPuncts1;
					//}
					nPuncts1 = itemLen;
					nCurLen += itemLen;
					ptr += itemLen;
					itemLen = 0;
				}
				// BEW 25Nov22 When ParseWord() is being used for creating the doc, pEnd is a long way ahead until right
				// at the end of the input text. But ParseWord() also gets called, to parse of small bits of adaptation
				// data, one per pile, and that involves an internal call of ParseWord() too. In the latter case,
				// it's highly likely that ParseFinalPuncts gets all of the rest of the data needed for that particular
				// pSrcPhrase, so that here, ptr and pEnd are identical. Before this, I was not testing here for
				// ptr == pEnd, and the consequence of that was that ParseWord continued on, len was reduce to have
				// ptr point at the ending punctuation (ouch), and returning len to TokenizeText() resulted in a bogus
				// new pile being added at the (small) doc end, to handle the punct/s pointed at, and that made them
				// become initial puncts on the bogus new pSrcPhrase added. So, fix this here...
//				wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
				if (ptr == pEnd)
				{
					// Nothing more to parse over, so return len to TText() immediately
					return len;
				}

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 4)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				bool bIsBeginMkr;
				bool bFoundEndMkr;
				bool bIsEndMkr;

				bIsBeginMkr = FALSE;
				if (*ptr == gSFescapechar)
				{
					wxString wholeMarker = GetWholeMarker(ptr);
					int offset = -1;
					offset = wholeMarker.Find(_T('*'));
					if (offset == wxNOT_FOUND)
					{
						bIsBeginMkr = TRUE;
					}
				}
				if (bIsBeginMkr)
				{
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = [%d] , m_key= [%s] , len= %d , m_markers= [%s] , pointsAt [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					return len;
				}
				else
				{
					// If not a beginMkr, is a space at ptr? If so, return len here. But check first that
					// the space here (or spaces) is not followed by an endMkr (such as a detached \wj* )
					// because an endMkr will necessarily belong to the current pSrcPhrase in m_endMarkers,
					// so check it out, and skip the return if so, and let control continue to check for
					// \wj* (or any other endMkr of that inLine endMkr set)
					bool bItsAnEndMkr;
					// First, use pAux so that ptr is not changed while the investigating happens
					// Get over any whitespaces
					wxChar* pAux = ptr;
					itemLen = 0;
					itemLen = CountSpaces(pAux, pEnd); // also counts any hairspaces (U+200A)
										// (itemLen will be 0 if ptr was already pointing at a marker)
					pAux += itemLen; // pAux now points at what's after the counted spaces, is it an endMkr?
					bItsAnEndMkr = FALSE; // init
					if (*pAux == gSFescapechar)
					{
						// A marker is at pAux. Check it out. We only want to know if it's an endMkr at this
						// stage, code below will deal with what type of endMkr it is. If it's an endMkr,
						// that's enough to tell us to skip returning to TokenizeText() here
						bItsAnEndMkr = IsEndMarker(pAux, pEnd);
					}
					if (bItsAnEndMkr)
					{
						// The spaces moved over have to be used to update ptr and len
						ptr += itemLen;
						len += itemLen;
						pAux = NULL; // don't need it anymore here
						itemLen = 0; // re-initialise
					}
					else
					{
						// It's not an endMkr, so must be a beginMkr, so return len to TokenizeText()
						// BEW 5Jan22 if ptr points at not space, but newline, that should be good reason
						// to return len here too

						// whm 7Jul2023 detected faulty logic in commented out if test below. The end-of-line
						// sequence for the Windows platform is \r\n and not simply \n. Hence the original test
						// below that only tests for \n will not adequately test of an EOL sequent on Windows.
						// In the Nyindrou Matthew SFM input file the line endings regularly have \r\n, and the
						// original test didn't return len at this point in code execution when parsing reaches
						// an EOL. This later causes some extraneous characters and final punctuation to be 
						// embedded within the xml document. For example, at sn 88 in the Nyindrou matthew SFM
						// input file the ptr is pointing at "\r\n..." following the parsed word "kandrah."
						// By adding the \r to the test below the ParseWord() function returns with a length of
						// 8 here below, rather than continuing on to about line 39740 where a wxString named 
						// theWord is created at the pointer with length1 of 10 which ends up making the m_srcPhrase
						// member become "kandrah.\r\n" and later it becomes "kandrah.\r\n." instead of what it
						// should be "kandrah."
						//if (*ptr == _T(' ') || *ptr == _T('\n'))
						if (*ptr == _T(' ') || *ptr == _T('\n') || *ptr == _T('\r'))
						{
							return len;
						}
					}
				}
				// now we are sure if we have a marker at ptr, it isn't a begin marker - e.g. \f
				bool bFoundAtLeastOne;
				bFoundAtLeastOne = FALSE; // init

				// BEW 12Dec22 control can come here, for processing endmarkers in the whole loop about 30 lines
				// below, but with ptr not actually pointing at the gSFescapechar of, say, an endline binding 
				// endMkr (such as \nd* 'name of deity' marker), because there is one or more spaces prior to
				// that marker, not parsed over. So get ptr past any spaces here. This situation is caused by
				// data like \nd Nya Prub'e \nd* (in 41MATAAAP.SFM from Steve White), the space after the Prub'e
				// is the culprit.
				int aSpacesCount;
				aSpacesCount = CountSpaces(ptr, pEnd); // in helpers.cpp
				if (aSpacesCount > 0)
				{
					ptr += aSpacesCount;
					len += aSpacesCount;
					itemLen = 0; // just making sure it won't bite us
				}

				bIsEndMkr = IsEndMarker(ptr, pEnd);
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 4)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				if (bIsEndMkr)
				{
					bFoundEndMkr = TRUE;
					bFoundAtLeastOne = TRUE; // provided this is TRUE, return updated len when all are parsed
				}
				else
				{
					bFoundEndMkr = FALSE;
					bFoundAtLeastOne = FALSE; // provided this is TRUE, return updated len when all are parsed
				}
				// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());

								// OK, if bFoundEndMrk at ptr is TRUE, enter the loop and keep iterating 
								// until no more are at the updated ptr location. 
				while (bFoundEndMkr)
				{
					// There are 3 tests, each is tried, but only 1 or none can find a following endmarker
					// on each iteration. When an iteration finds none, bFoundEndMkr will be FALSE, and
					// the loop will exit
					//bFoundEndMkr = FALSE; 
//					wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , ptr-> [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					if ((ptr < pEnd) && IsEndMarker(ptr, pEnd))
					{
						// ptr is pointing at the backslash of a marker, check it out - is it an endMarker, what type?
						// Normalise to a single space for storage on pSrcPhrase if the user has typed several. We are 
						// expecting, first of all, a binding endMkr 
						wxString wholeMkr = GetWholeMarker(ptr); // includes \ and * if present
						int mkrLen = wholeMkr.Len();
						// Is it an endmkr?
						wxChar chLast = wholeMkr.Last();
						if (chLast == _T('*'))
						{
							// It's an endmkr. How we store it on pSrcPhrase depends on its type. Check that out.
							bFoundEndMkr = TRUE;

							wxString augmentEndMkr = wholeMkr + _T(' ');
							wxString bareMkr = GetBareMarkerForLookup(ptr);
							USFMAnalysis* pAnalysis = LookupSFM(bareMkr);
							bool bIsInline = FALSE; // initialise
							if (pAnalysis->inLine)
							{
								bIsInline = TRUE;
							}
							// If it's inline, so could be inline binding (e.g \w \t \i etc) or nonbinding (e.g \wj );
							// otherwise store in m_endMarkers
							int offset = wxNOT_FOUND;
							wxString endMkr = wholeMkr; // initialise
							//wxString augmentedEndMkr = wxEmptyString; // init  BEW 28Jun23 oops, its set above, don't clobber it

							bool bIsBindingEndMkr = FALSE;
							wxString strToAdd1 = wxEmptyString; // init
							if (bIsInline && bFoundEndMkr)
							{
								offset = gpApp->m_charFormatEndMkrs.Find(augmentEndMkr);
								if (offset >= 0)
								{
									bIsBindingEndMkr = TRUE;
								}
							}
							if (bIsInline && bIsBindingEndMkr)
							{
								// belongs to the set which include nd* pn* wg* \qt* etc  These are inline binding type
								// The most common situation, store the space (if in the input) and the endMkr on pSrcPhrase
								// in m_inlineBindingEndMarkers
								wxChar chPrevious = *(ptr - 1); // the character prior to the endmarker
								bool bPriorIsSpace = FALSE; // init
								if (chPrevious == _T(' '))
								{
									bPriorIsSpace = TRUE;
								}
								if (bPriorIsSpace)
								{
									strToAdd1 = _T(" ") + wholeMkr; // only save one space
								}
								else
								{
									strToAdd1 = wholeMkr;
								}
								nInlineBindingEMLen1 = wholeMkr.Len();
								strInlineBindingEM1 = pSrcPhrase->GetInlineBindingEndMarkers();
								pSrcPhrase->SetInlineBindingEndMarkers(strInlineBindingEM1 + strToAdd1);
								// increase len by the length of the endmarker, to keep sync for TokenizeText()
								len += mkrLen;
								ptr += mkrLen; // gotta point past the stored endMkr

								// BEW 21Jun23, if ptr is pointing at whitespace, then return len to TText()
								// to initiate a new pSrcPhrase being created; provided that after the whitespace
								// there is not another endMkr to deal with
								bool bItsAnEndMkr = FALSE;
								if (*(ptr + 1) == gSFescapechar)
								{
									// There's a marker of some kind following the whitespace. Is it another
									// endMkr?
									wxChar* pAux = (ptr + 1);
									wxString wholemkr = GetWholeMarker(pAux);
									bItsAnEndMkr = IsEndMarker(pAux, pEnd);
								}
								if (IsWhiteSpace(ptr) && !bItsAnEndMkr)
								{
									return len;
								}

								// BEW 22Dec22 41MATBVM.SFM at one place has a space after \it*, and I have
								// not catered for that here yet. If I don't do so, then control will return len
								// to TokenizeText() at the space, and a following endMkr (such as \f*) will then
								// be an unexpected "end marker" for the next pSrcPhase, which will trigger a
								// warning message to the user, with helpful info. (But cancelling the msg, the
								// parser will parse on. App doesn't halt. Anyway, prevent this by parsing over
								// any whitespace if it there is an endmarker after the white stuff.
								wxChar* pAux = ptr;
								itemLen = 0;
								bool bBeginMrkFollows = FALSE; // init
								itemLen = CountSpaces(pAux, pEnd);
								if (itemLen > 0)
								{
									pAux += itemLen;
									if (*pAux == gSFescapechar)
									{
										// There's a marker after the whitespace(s). If it's an endMkr then
										// we want a later block to handle identification and storage etc
										bBeginMrkFollows = !IsEndMarker(pAux, pEnd);
										if (bBeginMrkFollows)
										{
											ptr += itemLen;
											len += itemLen;
											itemLen = 0;
											return len;
										}
										else
										{
											// The marker following is an endMkr, so must be stored on the current
											// pSrcPhrase, so update for the spaces parsed over, and let a lower
											// processing block deal with the more-outer endmarker (e.g. \f* )
											ptr += itemLen;
											len += itemLen;
											itemLen = 0;
											pAux = NULL;
										}
									}
								}
								bFoundEndMkr = TRUE; // <-- this keeps the loop looping
								// Are there following puncts, parse these
								// BEW 23Dec22 by this stage, m_srcPhrase has content, including
								// any m_precPunct characters before the word, so just add myPuncts
								itemLen = 0;
								itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
								if (itemLen > 0)
								{
									wxString myPuncts = wxString(ptr, itemLen);
									// Store the puncts in m_follPunct, on pSrcPhrase
									pSrcPhrase->m_follPunct += myPuncts;
									//if (pSrcPhrase->m_srcPhrase.IsEmpty())
									//{
									//	pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
									//	pSrcPhrase->m_srcPhrase += myPuncts;
									//}
									//else
									//{
									pSrcPhrase->m_srcPhrase += myPuncts;
									//}
									len += itemLen;
									nCurLen = len;
									ptr += itemLen;
									itemLen = 0;
								}

							} // end of TRUE block for test: if (bIsInline && bIsBinding)
						} // end of the TRUE block for test: if (chLast == _T('*'))
					} //end of the TRUE block for test: if ((ptr < pEnd) && IsEndMarker(ptr, pEnd))
//					wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , ptr-> [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					// There may be a following endMkr, such as the one from the Red set, eg \f*
					// so if the test says an endmarker follows, test the m_RedEndMarkers set
					if ((ptr < pEnd) && IsEndMarker(ptr, pEnd))
					{
						wxString wholeMkr = GetWholeMarker(ptr); // includes \ and * if present
						int mkrLen = wholeMkr.Len();
						// Is it an endmkr?
						wxChar chLast = wholeMkr.Last();
						if (chLast == _T('*'))
						{
							// It's an endmkr
							wxString augmentedEndMkr = wholeMkr + _T(' ');
							int offset = wxNOT_FOUND;
							offset = gpApp->m_RedEndMarkers.Find(augmentedEndMkr);
							if (offset >= 0)
							{
								// It's one of the Red endmkrs (often, \f* for example)
								// there may be a preceding space, or not. Handle both possibilities
								wxChar chPrevious = *(ptr - 1); // the character prior to the endmarker
								bool bPriorIsSpace = FALSE; // init
								wxString strToAdd = wxEmptyString; // init
								if (chPrevious == _T(' '))
								{
									bPriorIsSpace = TRUE;
								}
								if (bPriorIsSpace)
								{
									strToAdd = _T(" ") + wholeMkr; // only save one space
								}
								else
								{
									strToAdd = wholeMkr;
								}
								wxString currEndMkrs = pSrcPhrase->GetEndMarkers();
								currEndMkrs += strToAdd;
								pSrcPhrase->SetEndMarkers(currEndMkrs);
								// update len, ptr, etc
								len += mkrLen;
								ptr += mkrLen;
								bFoundEndMkr = TRUE; // <-- this keeps the loop looping
							} // end of TRUE block for test: if (offset >= 0)
							// Are there following puncts, parse these
							itemLen = 0;
							itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
							if (itemLen > 0)
							{
								wxString myPuncts = wxString(ptr, itemLen);
								// Store the puncts in m_follPunct, on pSrcPhrase
								pSrcPhrase->m_follPunct += myPuncts;
								pSrcPhrase->m_srcPhrase += myPuncts;

								len += itemLen;
								nCurLen = len;
								ptr += itemLen;
								itemLen = 0;
							} // end of the TRUE block for test: else if ((ptr < pEnd) && IsEndMarker(ptr, pEnd))
						} // end of TRUE block for test: if (chLast == _T('*'))
					} // end of the TRUE block for test: else if ((ptr < pEnd) && IsEndMarker(ptr, pEnd))
// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , ptr-> [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					// 3rd possibility: now test for \wj* or similar (not detached)
					if ((ptr < pEnd) && IsEndMarker(ptr, pEnd))
					{
						wxString wholeMkr = GetWholeMarker(ptr); // includes \ and * if present
						int mkrLen = wholeMkr.Len();
						// Is it an endmkr?
						wxChar chLast = wholeMkr.Last();
						if (chLast == _T('*'))
						{
							// It's an endmkr
							wxString augmentedEndMkr = wholeMkr + _T(' ');
							int offset = wxNOT_FOUND;
							// Testing for \wj* or others from that set, does not require a 
							// prior test of the marker being inLine. Presence in the 
							// m_inlineNonBindingEndMarkers marker set is enough
							offset = gpApp->m_inlineNonbindingEndMarkers.Find(augmentedEndMkr);
							if (offset >= 0)
							{
								// It's one of the inline non-binding endmkrs (often, \wj* for example)
								// there may be a preceding space, or not. Handle both possibilities
								wxChar chPrevious = *(ptr - 1); // the character prior to the endmarker
								bool bPriorIsSpace = FALSE; // init
								bool bPriorIsHairspace = FALSE; // init
								wxChar hairspace = (wxChar)0x200A;
								wxString strToAdd = wxEmptyString; // init
								if (chPrevious == _T(' '))
								{
									bPriorIsSpace = TRUE;
								}
								if (chPrevious == hairspace)
								{
									bPriorIsHairspace = TRUE;
								}

								if (bPriorIsSpace)
								{
									strToAdd = _T(" ") + wholeMkr; // only save one space
								}
								else if (bPriorIsHairspace)
								{
									strToAdd = hairspace + wholeMkr;
								}
								else
								{
									strToAdd = wholeMkr;
								}
								// \wj* and similar type markers are each inLine, and are to be stored on
								// the current pSrcPhrase in its member: m_inlineNonbindingEndMarkers
								wxString currNonbindingEndMkrs = pSrcPhrase->GetInlineNonbindingEndMarkers();
								currNonbindingEndMkrs += strToAdd;
								pSrcPhrase->SetInlineNonbindingEndMarkers(currNonbindingEndMkrs);
								// update len, ptr, etc
								len += mkrLen;
								ptr += mkrLen;
								bFoundEndMkr = TRUE; // <-- this keeps the loop looping
							} // end of TRUE block for test: if (offset >= 0)
						} // end of TRUE block for test: if (chLast == _T('*'))

						// Are there following puncts, parse these
						itemLen = 0;
						itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
						if (itemLen > 0)
						{
							wxString myPuncts = wxString(ptr, itemLen);
							// Store the puncts in m_follPunct, on pSrcPhrase
							// BEW 23Dec22 preceding puncts & m_key & possibly some following
							// puncts are already set for this pSrcPhrase->m_srcPhrase, so just 
							// add any extras
							pSrcPhrase->m_follPunct += myPuncts;
							//if (pSrcPhrase->m_srcPhrase.IsEmpty())
							//{
							//	pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
							//	pSrcPhrase->m_srcPhrase += myPuncts;
							//}
							//else
							//{
							pSrcPhrase->m_srcPhrase += myPuncts;
							//}
							len += itemLen;
							nCurLen = len;
							ptr += itemLen;
							itemLen = 0;
						}
					} // end of the TRUE block for test: else if( (ptr < pEnd) && IsEndMarker(ptr, pEnd) ) - \wj* etc
//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());

					// BEW 23Nov22 one more thing. There may be a mis-spelled endMkr, so it's "unknown".
					// We can't leave it unhandled because it will lead to ParseWord()'s ParseAWord() function
					// immediately returning - which would, in a Release version, cause an app crash. (In _DEBUG
					// build, it makes ParseAWord() trip the wxASSERT() line). So here I'll add the RED END code
					// above, but testing that with a bogus marker will return wxNOT_FOUND. I'll use that to
					// handle the failure, advance over the bogus marker, store it in m_endMarkers, update len etc.
					// And also some kind of message box to show, to warn that the input src data has the unknown
					// marker, and if possible the chapter & verse where it occurs. Let's see...
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						if (pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					bool bIsBogusEndMkr = FALSE; // init
					if ((ptr < pEnd) && IsEndMarker(ptr, pEnd))
					{
						wxString wholeMkr = GetWholeMarker(ptr); // includes \ and * if present
						int mkrLen = wholeMkr.Len();
						// Is it an endmkr?
						wxChar chLast = wholeMkr.Last();
						if (chLast == _T('*'))
						{
							// It's an endmkr
#if defined (_DEBUG) && !defined(NOLOGS)
							if (pSrcPhrase->m_nSequNumber >= 4)
							{
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
							if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
							{
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
							}
#endif

							// BEW 12Dec22 beware, we don't want a message about an unknown end marker to show, if
							// the endmarker is one of the \f set, or \x set. So bleed these out here.
							wxChar chFirst = wholeMkr.GetChar(0);
							wxChar chSecond = wholeMkr.GetChar(1);
							if (!((chFirst == gSFescapechar) && (chSecond == _T('f') || chSecond == _T('x'))))
							{
								// Construct and put up the warning message
								wxString augmentedEndMkr = wholeMkr + _T(' ');
								int offset = wxNOT_FOUND;

								// BEW 21Jun23 refactor: check if the above augmentedEndMr is found in one of the 3 
								// relevant fast-access mkr sets, that should be sufficient test - if not in one
								// then it's a bogus endMkr, and a message is appropriate to warn the user
								bool bIsInRedEMkrs; bool bIsInCharFormatEMkrs; bool bIsInNonBindingEMkrs;
								bIsInRedEMkrs = FALSE; bIsInCharFormatEMkrs = FALSE; bIsInNonBindingEMkrs = FALSE; // inits
								offset = gpApp->m_RedEndMarkers.Find(augmentedEndMkr);
								if (offset >= 0) { bIsInRedEMkrs = TRUE; };
								offset = gpApp->m_charFormatEndMkrs.Find(augmentedEndMkr);
								if (offset >= 0) { bIsInCharFormatEMkrs = TRUE; };
								offset = gpApp->m_inlineNonbindingEndMarkers.Find(augmentedEndMkr);
								if (offset >= 0) { bIsInNonBindingEMkrs = TRUE; };

								if (!bIsInRedEMkrs)
								{
									if (!bIsInCharFormatEMkrs)
									{
										if (!bIsInNonBindingEMkrs)
										{
											// in none of these fast-access marker sets, so is bogus end mkr
											bIsBogusEndMkr = TRUE;
											bFoundEndMkr = FALSE; // FALSE will cause break from iterating the loop
										}
										else
										{
											bFoundEndMkr = TRUE; // <-- this keeps the loop looping
										}
									}
									else
									{
										bFoundEndMkr = TRUE; // <-- this keeps the loop looping
									}
								}
								else
								{
									bFoundEndMkr = TRUE; // <-- this keeps the loop looping
								}

								if (bIsBogusEndMkr)
								{
									// It's a bogus end marker.  We have to store it somewhere - so m_endMarkers would
									// be the natural place. But not on the current pSrcPhrase, it would belong in the
									// m_endMarkers of the previous pSrcPhrase. So get the previous one now.
									CSourcePhrase* pSrcPhrase_lastCompleted;
									pSrcPhrase_lastCompleted = NULL; // init
									wxString chvs;
									chvs = wxEmptyString; // init
									wxSPListNode* pos_pSP = gpApp->m_pSourcePhrases->GetLast(); // last changes with every TText loop iteration
									if (pos_pSP != NULL)
									{
										pSrcPhrase_lastCompleted = pos_pSP->GetData();
										chvs = gpApp->GetView()->GetChapterAndVerse(pSrcPhrase_lastCompleted);
#if defined (_DEBUG) && !defined(NOLOGS)
										wxLogDebug(_T("ParseWord() line %d Storing ch:vs: %s "), __LINE__, gpApp->m_chapterVerseAttrSpan.c_str());
										if (pSrcPhrase->m_nSequNumber >= 2)
										{
											int halt_here = 1;
										}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
										if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
										{
											wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
												__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
										}
#endif

										wxString lastCurrEndMkrs = pSrcPhrase_lastCompleted->GetEndMarkers();
										lastCurrEndMkrs += wholeMkr;
										// Store in the most neutral place, which would be m_endMarkers
										pSrcPhrase_lastCompleted->SetEndMarkers(lastCurrEndMkrs);
										// update len, ptr, to point past the bogus (stored)endMkr, which
										// was identified when parsing for the current pSrcPhrase
										len += mkrLen;
										ptr += mkrLen;
									} // end of TRUE block for test: if (pos_pSP != NULL)
									if (bIsBogusEndMkr)
									{
										// Now warn the user that the src file he's loading in
										// has a bogus endMrk, what it is, where it is (easy to do)
										// and what to do. (He should let the parse complete, but not
										// save the doc. Exit the doc. Open the src text input file in
										// a text editor, look for the bogus marker, correct it, save,
										// then retry the src text load in AI.)

										wxString strLastSrc = wxEmptyString;
										wxString strLastTgt = wxEmptyString;
										wxString msg = wxEmptyString; //init
										wxString title = wxEmptyString; // init
										title = _("Unexpected or isolated end marker"); // localisable
										if (pSrcPhrase_lastCompleted != NULL)
										{
											strLastSrc = pSrcPhrase_lastCompleted->m_srcPhrase;
											strLastTgt = pSrcPhrase_lastCompleted->m_targetStr;
											if (!strLastTgt.IsEmpty())
											{
												// wxASSERT(!strLastSrc.IsEmpty() && !strLastTgt.IsEmpty()); 
												msg += _("The input source text was mis-parsed, causing an isolated end marker: %s , in the ");
												msg += _("chapter:verse: %s    Adapt It will not fail if you ignore this warning. ");
												msg += _("We recommend you let the input document finish loading, but do not save it. ");
												msg += _("Instead, close Adapt It. Open your input source file in a text editor. ");
												msg += _("Find the unexpected end marker, fix the USFM markup there, save, then open ");
												msg += _("Adapt It again and retry loading the fixed document. Error after: [%s,%s]");
												msg = msg.Format(msg, wholeMkr.c_str(), chvs.c_str(), strLastSrc.c_str(), strLastTgt.c_str());
											}
											else
											{
												msg += _("The input source text was mis-parsed, causing an isolated end marker: %s , in the ");
												msg += _("chapter:verse: %s    Adapt It will not fail if you ignore this warning. ");
												msg += _("We recommend you let the input document finish loading, but do not save it. ");
												msg += _("Instead, close Adapt It. Open your input source file in a text editor. ");
												msg += _("Find the unexpected end marker, fix the USFM markup there, save, then open ");
												msg += _("Adapt It again and retry loading the fixed document.");
												msg = msg.Format(msg, wholeMkr.c_str(), chvs.c_str());
											}
											gpApp->m_bUserDlgOrMessageRequested = TRUE; // whm 15May2020 added to supress phrasebox run-on
											wxMessageBox(msg, title, wxICON_WARNING | wxOK);
											gpApp->LogUserAction(msg);
										} // end of TRUE block for test: if (pSrcPhrase_lastCompleted != NULL)	
									} // end of TRUE block for test: if (bIsBogusEndMkr)
									//else
									//{
									//	break;
									//}
								} // end of TRUE block for test: if (bIsBogusEndMkr)
								//else
								//{
								//	break;
								//}
							} // end of TRUE block for test: if ( !((chFirst == gSFescapechar) && (chSecond == _T('f') || chSecond == _T('x'))) )
							else
							{
								bFoundEndMkr = FALSE; // causes break from loop  
							}

						} // end of TRUE block for test: if (chLast == _T('*'))
						else
						{
							bFoundEndMkr = FALSE; // causes break from loop 
						}
					} // end of the TRUE block for test: else if ((ptr < pEnd) && IsEndMarker(ptr, pEnd))
					else
					{
						bFoundEndMkr = FALSE; // causes break from loop 
					}

				} // end of the while loop for test: while(bFoundEndMkr)
// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , pointsAt= [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// When control gets here, the loop has been exited. And if there was a bogus endMkr,
				// a warning to the user has been given.
				if (bFoundAtLeastOne && !bFoundEndMkr)
				{
					return len;
				}

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 4)
					{
						int halt_here = 1;
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 20Dec22, Removed IsDetachedWJtype_endMkr_Ahead(ptr, pEnd, nHowManyPrecedingPuncts; block from here.
				// Removed if ((ptr < pEnd) && bWJ_or_Similar_Is_Ahead && (nHowManyPrecedingPuncts > 0)) "Hunt" block from here
				// Move both blocks up to near ParseAWord after following puncts checked for

				wxChar* pSavePtr;

				pSavePtr = ptr; // we may need to restore ptr to here in what follows
				pSavePtr = pSavePtr; // avoid gcc warning set but not used warning
// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());

				//bool bWasInlineEndMkr = FALSE; // initialise
				//bool bWasInlineBindingEndMkr = FALSE;

				// BEW 5Nov22 the while loop in ParseAWord has a number of tests, and any one of those going FALSE causes
				// exit of the loop, and return from the ParseAWord() function, and setting strWord to something non-empty.
				// If it is empty, then in _DEBUG mode, an assert will trip before the function exits. Here is the loop's tests:
				// while (bNotWhitespace && (spacelessPuncts.Find(*ptr) == -1) && (*ptr != gSFescapechar) && (*ptr != bar) && (*ptr != zwsp) && !(ptr == pEnd))
				// So we can deal with these exit possibilities here. The idea is to deal with what must be stored on the
				// current pSrcPhrase, because once we return len to the TokenizeText caller, the next entry to ParseWord()
				// will be at a new pSrcPhrase. The first one to deal with the possibility that ptr is pointing at gSFescapechar
				// which will cause the empty string wxASSERT to trip if the marker is a beginMkr, but if the marker is an endMkr
				// then a word will have been parsed over, and theWord set above will be non-empty. The first test then is to
				// check if ptr points at an inline binding endmarker. They cling to the word, so if present, add it to the
				// appropriate storage on pSrcPhrase, parse over, update ptr and len, and proceed to the next possibility. BUT,
				// the data from Steve White (41MATAAAP.SFV - which has some markup errors) has punctuation preceding \w*, so
				// this forces a code addition for that possibility.

				// BEW7Nov22 first to deal with is ptr pointing at data like this, after parsing over "Gilalia": \w Gilalia.\w*
				// This requires new code, because the legacy ParseWord() did not expect punctuation before \w*  I'll add
				// additional tests because \w is inline binding mkr, and after the \w* there may be further puncts and/or
				// further normal endMkrs. Any whitespace arrived at will halt proceedings and well return the updated len
				// value to TokenizeText, after doing any needed storage to the current pSrcPhrase - unless an endMkr such
				// as \wj* also lies beyond one or more spaces - in which case we deal with that as well. (And it may have
				// puncts following too - if so, parse them too.)
				itemLen = 0;
#if defined (_DEBUG) && !defined(NOLOGS) // && defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 4)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				//				wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

								// The next call parses over puncts, ending the loop when one of a host of conditions terminates
								// the loop.
				itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
				strFirstPuncts = wxEmptyString;
				strIBEM = wxEmptyString;

				if (itemLen != 0)
				{
					// we have one or more puncts, preserve temporarily in strFirstPuncts - pending more investigation
					strFirstPuncts = wxString(ptr, itemLen);
					//ptr += itemLen; <-- don't increase ptr for things which will get stored on the pSrcPhrase
				}
				// strFirstPuncts is either empty, or one or more punctuation chars
				// What's next. After a word, there might be an inline binding mkr to be parsed over, and added to
				// pSrcPhrase->m_inlineBindingEndMarkers (private, so use accessors)
				bool bIsAnEndMkr;

				bIsAnEndMkr = IsEndMarker(ptr, pEnd);
#if defined (_DEBUG) && !defined(NOLOGS) // && defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , len= %d , m_markers=[%s] , ptr-> [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());
				if (bIsAnEndMkr)
				{
					// Is it an inline binding endmarker?
					wxString bareMkr = GetBareMarkerForLookup(ptr); // strips \ and * and if + follows \ it removes it
					USFMAnalysis* pAnalysis = LookupSFM(bareMkr);
					if (pAnalysis != NULL)
					{
						bool bIsInline = pAnalysis->inLine;
						//bool bIsBinding = FALSE; // initialise
						wxString endMkr = wxString(gSFescapechar) + bareMkr + wxString(_T("*")); // we store this if ducks line up
						wxString augEndMkr = endMkr + wxString(_T(" ")); // add space for the lookup
						int offset = gpApp->m_charFormatEndMkrs.Find(augEndMkr);
						if (bIsInline && offset != wxNOT_FOUND)
						{
							strIBEM = pSrcPhrase->GetInlineBindingEndMarkers();
							// It's a char attributes type of marker, things like \w* or \jmp* etc
							// Carry state forward
							//bWasInlineBindingEndMkr = TRUE;

							// Gotta store strFirstPuncts on pSrcPhrase, if it not empty. It won't be empty if itemLen is > 0
							if (itemLen > 0)
							{
								pSrcPhrase->m_follPunct += strFirstPuncts; // storage on pSrcPhrase, so don't advance len value
								strFirstPuncts.Empty();
							}
							// now append the inline binding endMkr, update ptr, update len
							strIBEM += endMkr;
							int length = endMkr.Len();
							wxUnusedVar(length);

							pSrcPhrase->SetInlineBindingEndMarkers(strIBEM); // storage on pSrcPhrase, don't advance len value
							// we are done for handling things like \w* or \k* etc; ptr points at what follows the endMkr, len is correct too
						}
					} // end of TRUE block for test: if (pAnalysis != NULL) -- kcorrect indent level
					// No else block because here or after the inner test, because we don't
					// want ptr to advance if there was no inline binding endMkr stored

				} // end of TRUE block for test: if (bIsAnEndMkr) -- correct indent level
// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());

				// Now, if whitespace is next, then need to return len to TokenizeText because this current
				// pSrcPhrase is done with
				if (ptr < pEnd && IsWhiteSpace(ptr))
				{
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , m_markers=[%s] , ptr->%s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pSrcPhrase->m_markers.c_str(), pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 4)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str() );
					}
#endif
					return len;
				}
				else
				{
					// Continue, looking for more puncts and endmarkers, till next whitespace - the first extra
					// of puncts or endmarker, if they exist, will be stored in m_follPuncts, and m_endMarkers;
					// and any puncts subsequent need to be stored in m_follOuterPuncts
					pSavePtr = ptr; // we have a new starting point for the next tests
					itemLen = 0;

					// BEW 9Nov22, this next bit is a hack to handle markup errors like ibaib|ibaib and iposel|iposel
					// where whitespace follows such sequences. They are clear errors, becuase there is nothing following
					// the bar except a repeat of what precedes the bar - so I'll clean up to remove the bar from each
					// and the copy of the prebar word, provided whitespace follows, rather than puncts or endmarker.
					// When puncts or endmarker follow, we need to keep parsing
					if (!theWord.IsEmpty())
					{
						//						wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
												// nothing to do here (BEW23Dec22), except log the fact that control went thru here
					} // end of TRUE block for test: if (!theWord.IsEmpty())

				} // end of the else block for test: if (ptr < pEnd && IsWhiteSpace(ptr)) -- correct indent level

//				wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

				// TODO ?? any more checks to put here ?? Dunno of any so far (BEW 23Dec22)

				// BEW 18Oct22, ParseAWord may have exited because ptr came to the punctuation character '(' parenthesis.
				// TokenizeText() will not have 'seen' the ( character, because a document word preceeds. So check and
				// do what's necessary to support something like:  word(singular person) or word(sg)  - note, we can't
				// assume that the ( ) pair will not contain text with space.
				// Similarly for wrapping by braces, or brackets. Provide a supporting block for each
parenth:
				bool bOpenParenIsPunct = (spacelessPuncts.Find(openParen) != wxNOT_FOUND);
				bool bOpenBraceIsPunct = (spacelessPuncts.Find(openBrace) != wxNOT_FOUND);
				bool bOpenBracketIsPunct = (spacelessPuncts.Find(openBracket) != wxNOT_FOUND);
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , ptr->%s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 4)
					{
						int halt_here = 1;
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 21Oct, handle data like word(word or words), word{word or words}, word[word or words], so we support
				// wrapping with parentheses, braces, or brackets
				if ((*ptr == openParen) && bOpenParenIsPunct)
				{
					wxChar* pAux = ptr;
					unsigned int count = 0;
					// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
					{
						wxString pointsAt = wxString(ptr, 16);
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , bTokenizingTargetText = %d , ptr->%s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, (int)bTokenizingTargetText, pointsAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 4)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
					if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
					{
						wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
							__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
					}
#endif

					bool bCloseParenAhead = IsClosedParenthesisAhead(pAux, count, pEnd, pSrcPhrase, bTokenizingTargetText);
					if (bCloseParenAhead)
					{
						wxASSERT(count > 0);
						wxString strExtraStuff = wxString(ptr, (size_t)count);
						// Append the material to pSrcPhrase->m_key, store the ')' in m_follPunct, update m_srcPhrase & len, return len
						pSrcPhrase->m_key += strExtraStuff;
						pSrcPhrase->m_srcPhrase += strExtraStuff;
						int nExtraLen = strExtraStuff.Len();
						len += nExtraLen;
						ptr += nExtraLen;
						if (bTokenizingTargetText == FALSE)
						{
							// RemovePunctuation(), when adapting the source, will call ParseWord() with
							// bTokenizingTargetText set TRUE, but without protection this next line would add a
							// second ')' after the final closing ')'. Actually, I think RemovePunctuation() is
							// the culprit (I think I fixed it there), but no harm in this if block staying as is
							pSrcPhrase->m_follPunct = closedParen;
							pSrcPhrase->m_srcPhrase += closedParen;
						}
						// Update ptr and len, to point just past the ')' character
						ptr += 1;
						len += 1;
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
						{
							wxString pointsAt = wxString(ptr, 16);
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , m_srcPhrase= [%s] , len= %d , ptr-> [%s]"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_srcPhrase.c_str(), len, pointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 2)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
						if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
						{
							wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
						}
#endif

						// We don't expect punctuation to follow the ')', but who knows? Some monkey may
						// put some there
						itemLen = 0;
						itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
						if (itemLen > 0)
						{
							wxString finalPuncts = wxString(ptr, itemLen);
							pSrcPhrase->m_follPunct += finalPuncts;
							pSrcPhrase->m_srcPhrase += finalPuncts; // for the gui to show them
							len += itemLen;
							itemLen = 0;
						}
						// We are done, return control to TokenizeText()
						count = 0;
						return len;

					} // end of TRUE block for test: if (bCloseParenAhead)
					else
					{
						// No qualifying closing ')' is ahead, so be content to stop at the first whitespace
						if (!pSrcPhrase->m_nSequNumber == 0)
						{
							// When control is in RemovePunctuation(), it calls ParseWord() on the target text, 
							// on a temporary pSrcPhase on the heap, with m_nSequNumber set to 0. When that is
							// the case, we don't need to call this block. (If we did, ptr would get to pEnd, not
							// to a whitespace
							GetLengthToWhitespace(ptr, count, pEnd);
							// If failed. A warning message will be shown to the user, and lodged also in LogUserAction,
							// and the message will include the m_key value of the pSrcPhrase passed in.
							// There are 3 possible reasons for the failure. Most likely, the input src text for the
							// document lacks a closing parentheses at this pSrcPhrase. Or the length of the ( )
							// enclosed material exceeds a max of 99 characters without ')' being found, or scanning
							// encountered the end of the input source text of the document before ')' was found.
							// BEW 20Oct22 I've added some "healing" code, when the input source data being parsed
							// has an opening parenthesis, with content following, but a user error in formulating
							// the input data has resulted in no closing ')' being present. The "healing" will read
							// as far as the first whitespace after the '(', and use that length to sign off on the
							// content, and here a closing ')' should then be put in pSrcPhrase->m_follPunct, etc.
							// To detect this state, FALSE has been returned, but count value is non-zero - being 
							// the distance to the first space after the initial '('. Then return to TokenizeText()
#if defined (_DEBUG)  && !defined(NOLOGS) //&& defined(WHERE)
							{
								wxString pointsAt = wxString(ptr, 16);
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , len= %d , ptr->%s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), len, pointsAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 4)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
							if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
							{
								wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
							}
#endif

							if (count > 0)
							{
								wxString strExtras = wxString(ptr, count);
								pSrcPhrase->m_follPunct = closedParen;
								pSrcPhrase->m_key += strExtras;
								pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key; // need this line, otherwise GUI does not
																				// show any source for this pile
								pSrcPhrase->m_srcPhrase += pSrcPhrase->m_follPunct; // m_follPunct has the closing )
										// so we need to append it for showing the parsed and healed pile correctly
								ptr += count;
								len += count;
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
								{
									wxString pointsAt = wxString(ptr, 16);
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_srcPhrase= %s , len= %d , ptr->%s"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_srcPhrase.c_str(), len, pointsAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 4)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
								}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
								if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
								{
									wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
								}
#endif

								count = 0;
								// This corrected pSrcPhrase is done, so return to TokenizeText immediately
								// NOTE: this block, since halting the parse at first whitespace, would parse
								// over any punctuation characters encountered - resulting in them being
								// included in the span
								return len;
							}
						}
					}
					//					wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

				} // end of TRUE block for test: if ((*ptr == openParen) && bOpenParenIsPunct) -- correct indent level

				// BEW now handle wrapping by braces
				else
				{
					// BEW 21Oct22, handling { } wrapping, or [ ] wrapping, uses almost identical code - only
					// some string names and the wrapping character literals change. So I'll remove comments
					// in the blocks for { } and [ ]. If you want details, look above at the block for ( ).

					if ((*ptr == openBrace) && bOpenBraceIsPunct)
					{
						wxChar* pAux = ptr;
						unsigned int count = 0;
						bool bCloseBraceAhead = IsClosedBraceAhead(pAux, count, pEnd, pSrcPhrase, bTokenizingTargetText);
						if (bCloseBraceAhead)
						{
							wxASSERT(count > 0);
							wxString strExtraStuff = wxString(ptr, (size_t)count);
							pSrcPhrase->m_key += strExtraStuff;
							pSrcPhrase->m_srcPhrase += strExtraStuff;
							int nExtraLen = strExtraStuff.Len();
							len += nExtraLen;
							ptr += nExtraLen;
							ptr += 1;
							len += 1;
							itemLen = 0;
							itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
							if (itemLen > 0)
							{
								wxString finalPuncts = wxString(ptr, itemLen);
								pSrcPhrase->m_follPunct += finalPuncts;
								pSrcPhrase->m_srcPhrase += finalPuncts; // for the gui to show them
								len += itemLen;
								itemLen = 0;
							}
							// We are done, return control to TokenizeText()
							count = 0;
							return len;
						} // end of TRUE block for test: if (bCloseBraceAhead)
						else
						{
							if (!pSrcPhrase->m_nSequNumber == 0)
							{
								GetLengthToWhitespace(ptr, count, pEnd);
								if (count > 0)
								{
									wxString strExtras = wxString(ptr, count);
									pSrcPhrase->m_follPunct = closedBrace;
									pSrcPhrase->m_key += strExtras;
									pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
									pSrcPhrase->m_srcPhrase += pSrcPhrase->m_follPunct;
									ptr += count;
									len += count;
									return len;
								}
							}
							count = 0;
						} // end of else block for test: if (bCloseBraceAhead)

					} // end of the TRUE block for test: if ((*ptr == openBrace) && bOpenBraceIsPunct) -- correct indent level
					else
					{
						if ((*ptr == openBrace) && bOpenBraceIsPunct)
						{
							wxChar* pAux = ptr;
							unsigned int count = 0;
							bool bCloseBraceAhead = IsClosedBraceAhead(pAux, count, pEnd, pSrcPhrase, bTokenizingTargetText);
							if (bCloseBraceAhead)
							{
								wxASSERT(count > 0);
								wxString strExtraStuff = wxString(ptr, (size_t)count);
								pSrcPhrase->m_key += strExtraStuff;
								if (bTokenizingTargetText == FALSE)
								{
									pSrcPhrase->m_follPunct = closedBrace;
								}
								ptr += count + 1;
								len += count + 1;
							}
							else
							{
								if (!pSrcPhrase->m_nSequNumber == 0)
								{
									GetLengthToWhitespace(ptr, count, pEnd);
									if (count > 0)
									{
										wxString strExtras = wxString(ptr, count);
										pSrcPhrase->m_follPunct = closedBrace;
										pSrcPhrase->m_key += strExtras;
										pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
										pSrcPhrase->m_srcPhrase += pSrcPhrase->m_follPunct;
										ptr += count;
										len += count;
										return len;
									}
								}
								count = 0;
							}

						} // end of the TRUE block for test: if ((*ptr == openBrace) && bOpenBraceIsPunct)
						else
						{
							// deal with closing bracket
							if ((*ptr == openBracket) && bOpenBracketIsPunct)
							{
								wxChar* pAux = ptr;
								unsigned int count = 0;
								bool bCloseBracketAhead = IsClosedBracketAhead(pAux, count, pEnd, pSrcPhrase, bTokenizingTargetText);
								if (bCloseBracketAhead)
								{
									wxASSERT(count > 0);
									wxString strExtraStuff = wxString(ptr, (size_t)count);
									int nExtraLen = strExtraStuff.Len();
									pSrcPhrase->m_key += strExtraStuff;
									pSrcPhrase->m_srcPhrase += strExtraStuff;
									len += nExtraLen;
									ptr += nExtraLen;
									ptr += 1;
									len += 1;
									itemLen = 0;
									itemLen = ParseFinalPuncts(ptr, pEnd, spacelessPuncts);
									if (itemLen > 0)
									{
										wxString finalPuncts = wxString(ptr, itemLen);
										pSrcPhrase->m_follPunct += finalPuncts;
										pSrcPhrase->m_srcPhrase += finalPuncts; // for the gui to show them
										len += itemLen;
										itemLen = 0;
									}
									// We are done, return control to TokenizeText()
									count = 0;
									return len;
								}
								else
								{
									// dealing with closed bracket
									if (!pSrcPhrase->m_nSequNumber == 0)
									{
										GetLengthToWhitespace(ptr, count, pEnd);
										if (count > 0)
										{
											wxString strExtras = wxString(ptr, count);
											pSrcPhrase->m_follPunct = closedBracket;
											pSrcPhrase->m_key += strExtras;
											pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
											pSrcPhrase->m_srcPhrase += pSrcPhrase->m_follPunct;
											ptr += count;
											len += count;
											return len;
										}
										count = 0;
									}
								}

							} // end of the TRUE block for test: if ((*ptr == openBracket) && bOpenBracketIsPunct)

						} // end of the else block for test: if ((*ptr == openBrace) && bOpenBraceIsPunct)

					} // end of else block for test: if ((*ptr == openBrace) && bOpenBraceIsPunct) -- correct indent level

				} // end of else block for test: if ((*ptr == openParen) && bOpenParenIsPunct) -- correct indent level

//wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxString followingPuncts = pSrcPhrase->m_follPunct;
					wxString precedingPuncts = pSrcPhrase->m_precPunct;
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , follPuncts = [%s] , pSrcPhase->m_precPunct = [%s] : ptr-> [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), followingPuncts.c_str(), precedingPuncts.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif 
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// Now set pEndWordProper to point at what follows
				//pEndWordProper = ptr; // BEW 17Jul23 we no longer support pEndWordProper

				// Check if TokenizeText stored any m_precPunct contents, if so then add them, and set m_srcPhrase
				// so that the GUI will show the parsed over key contents. Neither will change the location of ptr
				if (pSrcPhrase->m_precPunct.IsEmpty())
				{
					pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
				}
				else
				{
					pSrcPhrase->m_srcPhrase = pSrcPhrase->m_precPunct + pSrcPhrase->m_key;
				}
				//				wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxString followingPuncts = pSrcPhrase->m_follPunct;
					wxString precedingPuncts = pSrcPhrase->m_precPunct;
					wxLogDebug(_T("ParseWord() line %d : pSrcPhrase->m_nSeqNumber = %d ,  m_key= [%s] , follPuncts = [%s] , pSrcPhase->m_precPunct = [%s] : ptr-> [%s]"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), followingPuncts.c_str(), precedingPuncts.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
				}
#endif

				// BEW 14Oct22, following puncts have been added (if any) preceding puncts were handled by TokenizeText()
				// pSrcPhrase->m_key and m_srcPhrase have been set correctly; and ptr and len are correctly augmented, so
				// now return to TText() so it can handle the pSrcPhrase now parsed over
				// Oops, returning here unilaterally got the theWord handled and into GUI right; but when there is no ]
				// ahead, this unilateral return makes words with no detached brackets wrapping them, get misparsed -
				// final punct gets missed and a new bogus pSrcPhrase made and the final punct is on next one, and at
				// doc end there is an empty pSrcPhrase. So to protect, only return here when there is a ] following with
				// only one or more spaces intervening.
				bool bEndBracketNext = IsClosingBracketNext(ptr);
				if (bEndBracketNext)
				{
					return len;
				}
			} // end of the TRUE block for test:  if (theWord.IsEmpty()) -- correct indent level

			else
			{
				// theWord was not empty, and may have found ~ or ]
				pSrcPhrase->m_key = theWord;

				int strWordLen = theWord.Length();
				len += strWordLen;
				ptr += strWordLen;
				// NOLOGS wxLogDebug(_T("LEN+PTR line %d , m_markers= [%s], len %d , 20 at ptr= [%s]"), __LINE__, pSrcPhrase->m_markers.c_str(), len, wxString(ptr, 20).c_str());

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxString followingPuncts = pSrcPhrase->m_follPunct;
					wxString precedingPuncts = pSrcPhrase->m_precPunct;
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , follPuncts = %s , pSrcPhase->m_precPunct = %s : ptr->%s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), followingPuncts.c_str(), precedingPuncts.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 4)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// BEW 17Jul23 we no longer support pEndWordProper
				// Now set pEndWordProper to point at what follows
				//pEndWordProper = ptr;
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxString followingPuncts = pSrcPhrase->m_follPunct;
					wxString precedingPuncts = pSrcPhrase->m_precPunct;
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , follPuncts = %s , pSrcPhase->m_precPunct = %s : ptr->%s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), followingPuncts.c_str(), precedingPuncts.c_str(), pointsAt.c_str());
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str());
				}
#endif

				// now m_srcPhrase except for ending punctuation
				if (!pSrcPhrase->m_precPunct.IsEmpty())
				{
					pSrcPhrase->m_srcPhrase = pSrcPhrase->m_precPunct;
				}
				pSrcPhrase->m_srcPhrase += theWord;

#if defined (_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
				{
					wxString pointsAt = wxString(ptr, 16);
					wxString followingPuncts = pSrcPhrase->m_follPunct;
					wxString precedingPuncts = pSrcPhrase->m_precPunct;
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , follPuncts = %s , pSrcPhase->m_precPunct = %s : ptr->%s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), followingPuncts.c_str(), precedingPuncts.c_str(), pointsAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 4)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
				if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
				{
					wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
				}
#endif
			} // end of the else block for test: if (theWord.IsEmpty()) -- correct indent level
//			wxLogDebug(_T(" ParseWord(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

#if defined(_DEBUG) && !defined(NOLOGS) //&& defined(WHERE)
			{
				wxString pointsAt = wxString(ptr, 16);
				wxString followingPuncts = pSrcPhrase->m_follPunct;
				wxString precedingPuncts = pSrcPhrase->m_precPunct;
				wxLogDebug(_T("ParseWord() ENDING line %d , len %d , pSrcPhrase->m_nSequNumber = %d , m_key= [%s] , follPuncts = [%s] , pSrcPhase->m_precPunct = [%s] : pointsAt= [%s]"),
					__LINE__, pSrcPhrase->m_nSequNumber, len, pSrcPhrase->m_key.c_str(), followingPuncts.c_str(), precedingPuncts.c_str(), pointsAt.c_str());
				if (pSrcPhrase->m_nSequNumber >=5)
				{
					int halt_here = 1; wxUnusedVar(halt_here);
				}
			}
#endif
#if defined (_DEBUG) && defined (NOPAREN)
			if (pSrcPhrase->m_nSequNumber >= 17 && pSrcPhrase->m_nSequNumber < 19)
			{
				wxLogDebug(_T("ParseWord() line %d , pSrcPhrase->m_nSequNumber = %d , m_key= %s , m_targetStr= %s"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_targetStr.c_str());
			}
#endif

			// BEW 15Jul23:  BEYOND THIS POINT IS RELIC PARSER CODE - intended for conjoining support and 
			// last gasp parsing if nothing before has worked -- remove it, it's not robust enough to retain

		} // end of else block for test: if (bMatchedFixedSpaceSymbol && !m_bWithinMkrAttributeSpan)

	} // BEW16Jul23 closed off else block for test: if (bMatchedFixedSpaceSymbol && !m_bWithinMkrAttributeSpan)

	return len;
}


///////////////////////////////////////////////////////////////////////////////
/// \return		the number of elements/tokens in the list of source phrases (pList)
/// \param		nStartingSequNum	-> the initial sequence number
/// \param		pList				<- list of CSourcePhrase instances, each populated with
///                                    a word token
/// \param		rBuffer				-> the buffer from which words are tokenized and stored
///									   as CSourcePhrase instances in pList
/// \param		nTextLength			-> the initial text length
/// \param      bTokenizingTargetText -> default FALSE, set TRUE if rBuffer contains target
///                                    text which is to be parsed, using target punctuation,
///                                    so as to make use of its smarts in separating text,
///                                    punctuation and inline markers
/// \remarks
/// Called from: the Doc's OnNewDocument(), the View's TokenizeTextString(),
/// DoExtendedSearch(), DoSrcOnlyFind(), DoTgtOnlyFind(), DoSrcAndTgtFind().
/// Intelligently parses the input text (rBuffer) and builds a list of CSourcePhrase
/// instances from the tokens. All the input text's source phrases are analyzed in the
/// process to determine each source phrase's many attributes and flags, stores any
/// filtered information in its m_filteredInfo member.
/// BEW Feb10, updated for support of doc version 5 (changes were needed)
/// BEW 11Oct10, updated for doc version 5 additional changes (better inline marker
/// support) quite significantly - somewhat simplifying TokenizeText() but completely
/// rewriting the ParseWord() function it calls -- and the latter potentially consumes more
/// data on each call. TokenizeText also reworked to handle text colouring better.
/// BEW 24Oct14, various changes (mostly to called functions within) for support
/// of USFM nested markers
/// BEW 24Oct14 changes made for support of USFM nested markers (of form \+tag )
/// BEW 19Jul16 The character sequence ]"<newline>\s caused a parse crash (actually assert
/// got tripped), so I need to have TokenizeText() handle puncts after the ] by parsing
/// over them to whitespace or marker following, and store the puncts after the ] on its
/// CSourcePhrase instance.
/// BEW 30Sep19 several changes to fix code logic, and add functionality to hide USFM3
/// attributes metadata (the stuff from bar to matching endmarker) on the member
/// m_punctsPattern of pLastSrcPhrase, and set its m_bUnused boolean to TRUE. (Both these
/// members have been unused for years, so using them now saves a bump of the docVersion)
///
/// TODO - currently, order information about what precedes a word and what follows it is
/// lost. A useful change is refactor to fix this, as much as possible
/// whm 24Oct2023 modifications to remove calls to IsAFilteringSFM(pUsfmAnalysis) as
/// un-reliable in this context, as well as all references to the bCanFilterIt boolean.
/// More reliable is examining the contents of the gCurrentFilterMarkers string.
/// whm 17Jan2024 more radical refactoring of TokenizeText() especially its handling
/// of empty content markers.
///////////////////////////////////////////////////////////////////////////////
int CAdapt_ItDoc::TokenizeText(int nStartingSequNum, SPList* pList, wxString& rBuffer,
	int nTextLength, bool bTokenizingTargetText)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CLayout* pLayout = pApp->GetLayout(); // BEW 30Sep19 added
	// BEW added another member boolean to CAdapt_ItDoc instance, to help with detached ] when ParseWord() parses
	m_bClosingBracketIsNext = FALSE; // initialise, goes TRUE on when ParseWord() forces a new pSrcPhrase for
									 // carrying the ] as m_key and m_srcPhrase, restore FALSE when the ] is done with
	m_bWithinEmptyMkrsLoop = FALSE; // set TRUE when entering, FALSE when exiting
//#if defined (_DEBUG)
	// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
	//wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
//#endif

	// This enum type can be used to direct execution after a parsing function
	// to do a branch or continue within a (while) loop. The enum types are:
	//  noBranching - when no redirection of code execution is needed after function execution
	//	break_from_loop - when previous function exited with need of a break after function execution
	//	continue_to_top_of_loop - when previous function exited with need of a continue after function execution
	// whm TODO: implement this in some separate parsing routines to simplify TokenizeText()
	//PostFunctionExecutionBranchingType postFunctionBranchingType = noBranching;

	// whm 17Jan2024 added the following 3 variable initializations. 
	// I may decide not to use these outside the IsEmptyMkr() function and within 
	// the if (bProcessEmptyMarker) TRUE block after the IsEmptyMkr() call. 
	bool bHasBogusPeriods = FALSE;
	int nWhitesLenIncludingBogusPeriods = 0;
	int nPeriodsInWhitesLen = 0;

	wxString chapterMkr = _T("\\c");
	wxString verseMkr = _T("\\v");

	// whm 12Jan2024 added the following boolean to inform TokenizeText after execution over 
	// the finishup: jump label that execution has come from an inner empty markers loop or
	// other inner markers loop where the itemLen value was used/changed.
	// This bool will inform the code following the finishup: jump label that the itemLen
	// value there should be re-initialized to zero, since it did not come from the previous
	// call of ParseWord(). 
	bool bComingFromInnerMarkerLoop = FALSE;

	// BEW 24Oct14 added next three lines
	bool bIsNestedMkr = FALSE;
	wxString tagOnly;
	wxString baseOfEndMkr;
	wxString theptrPointsAt;
	m_bIsInFigSpan = FALSE; // initialize, used in propagating textType and m_bSpecialText
	m_bTokenizingTargetText = bTokenizingTargetText; // set the member boolean, so
				// that IsInWordProper()  can get hold of the current value of the flag

	// BEW added 10Jul14, store delimiter(s) which precede the being-parsed current word
	wxString precWordDelim;
	theptrPointsAt == wxEmptyString; // init

	// whm Note: I'm declaring a local tokBuffer, in place of the buffer that MFC had on the doc
	// and previously the wx version had on the App. This is in attempt to get beyond the string
	// corruption problems. (undated comment, but probably about 2004)
	wxString tokBuffer;
	tokBuffer.Empty();

	// BEW 11Oct10, for carrying a post-ParseWord() decision forward to Pre-ParseWord()
	// location on next iteration
	bool bEnded_f_fe_x_span = FALSE;

	// for support of parsing in and filtering a pre-existing free translation (it has to
	// have CSourcePhrase instances have their m_bStartFreeTrans, m_bEndFreeTrans &
	// m_bHasFreeTrans members set TRUE at appropriate places)
	bool bFreeTranslationIsCurrent = FALSE;
	int nFreeTransWordCount = 0;

	wxString spacelessPuncts;
	if (bTokenizingTargetText)
	{
		spacelessPuncts = MakeSpacelessPunctsString(pApp, targetLang);
	}
	else
	{
		spacelessPuncts = MakeSpacelessPunctsString(pApp, sourceLang);
	}
	// populate the member string, m_spacelessPuncts, so that the function
	// IsInWordProper(), returning boolean, can use it when a parse is being done
	// (and ensure that ~ the fixed-space USFM marker, is in the character set --
	// because we treat it like a punctuation character because of where we store
	// it and strip it off, etc, and only in word~word(~word) structures do we
	// handle it as a non-punctuation character).
	// Put it also into app's m_punctuation[0] and m_punctuation[1] which these days
	// no longer contain any spaces, so just append.
	// Also use a similar mechanism to force " to be treated as a punctuation
	// character. (Leave ' as a glottal by default, only make it punctuation if user
	// lists it in the Punctuation tab of Preferences...)
	// ALso create a copy of the puncts but lacking a fixed space (tilde character ~)
	m_spacelessPuncts = spacelessPuncts; // m_spacelessPuncts is a doc member wxString
	int offsettotilde = wxNOT_FOUND;
	wxString aTilde = _T('~');
	offsettotilde = m_spacelessPuncts.Find(aTilde);
	if (offsettotilde == wxNOT_FOUND)
	{
		m_spacelessPuncts_NoTilde = m_spacelessPuncts;
		m_spacelessPuncts += aTilde; // add it to the character set of punctuation
									 // characters if it is not already there
	}
	else
	{
		m_spacelessPuncts_NoTilde = m_spacelessPuncts.Remove(offsettotilde, 1);
	}
	wxString boundarySet = spacelessPuncts;
	while (boundarySet.Find(_T(',')) != -1)
	{
		boundarySet.Remove(boundarySet.Find(_T(',')), 1);
	}

	// if the user is inputting plain text unstructured, we do not want to destroy any
	// paragraphing by the normalization process. So we test for this kind of text (if
	// there is no \id at file start, and also none of \v \vn \vt \c markers in the text,
	// then we assume it is not a sfm file) and if it is such, then we add a \p and a space
	// (paragraph marker) following every newline; and later if the user exports the source
	// or target text, we check if it was a plain text unstructured file by looking for (1)
	// no \id marker on the first sourcephrase instance, and no instances of \v \vn or \vt
	// in any sourcephrase in the document - if it matches these conditions, we test for \p
	// markers and where such is found, change the preceding space to a newline in the
	// output.
	bool bIsUnstructured = IsUnstructuredPlainText(rBuffer);

	// if unstructured plain text, add a paragraph marker after any newline, to preserve
	// user's paragraphing updating nTextLength for each one added
	int nDerivedLength = nTextLength;
	if (bIsUnstructured)
	{
		// BEW changed 1Nov12, a string of words with no CR or LF except at the end,
		// causes a buffer overrun of the iterator in a call within AddParagraphMarkers(),
		// so avoid this by Trim(ing off) any CRLF or CR or LF at the end first
		rBuffer = rBuffer.Trim();
		// whm 30May2019 Bruce requested that paragraph markers \p not be added to the
		// text being tokenized when the App's m_bClipboardAdaptMode flag is TRUE.
		// Bruce should verify that this change doesn't adversely affect the TokenizeText()
		// fuction, and that it does what he wants when adapting unstructured text from the clipboard.
		// BEW, yep, the change is harmless.
		if (!pApp->m_bClipboardAdaptMode)
		{
			AddParagraphMarkers(rBuffer, nDerivedLength);
		}
		wxASSERT(nDerivedLength >= nTextLength);
	}

	// continue with the parse
	int nTheLen;
	if (bIsUnstructured)
	{
		nTheLen = nDerivedLength; // don't use rBuffer.GetLength() - as any newlines
		// don't get counted; Bruce commented out the next line 10May08, but I've left it
		// there because I've dealt with and checked that other code agrees with the code
		// as it stands.
		// BEW 30Jan11, I really think this should be commented out, but in the light of
		// Bill's comment, I'll compromise -- only do this is nDerivedLength and
		// nTextLength are different & the former more than the latter) -- anyway, I doubt
		// that it matters either way any more
		if (nDerivedLength > nTextLength)
		{
			++nTheLen; // make sure we include space for a null
		}
	}
	else
	{
		nTheLen = nTextLength; // nTextLength was probably m_nInputFileLength in
							   // the caller, which already counts the null at the end
	}

	wxString aPlus = wxString(_T("+")); // BEW 30Sep19 used for removal of + from nested markers
	wxString lookupStr = wxEmptyString; // initialize, use for making an editable copy of the
				// string augmentedWholeMkr or similar, as the latter is used for marker matching
				// in searches, but AI_USFM.xml lookups require no '+' if the marker is a
				// nested one
	// BEW 28Jul23 added next two, for elimination of bogus "..." or ".." strings originating
	// from Paratext when supplying a contentless USFM structure as source text.
	// whm 20Jan2024 removed these:
	//wxString strThreePeriods; wxString strTwoPeriods;
	//strThreePeriods = _T(" ...");
	//strTwoPeriods = _T(" ..");

	// ****************** Set up the parsing buffer *******************************
	// 
	// whm revision: I've modified OverwriteUSFMFixedSpaces and
	// OverwriteUSFMDiscretionaryLineBreaks to use a write buffer internally, and moved
	// them out of TokenizeText, so now we can get along with a read-only buffer here in
	// TokenizeText
	const wxChar* pBuffer = rBuffer.GetData();
	int itemLen = 0;
	wxChar* ptr = (wxChar*)pBuffer;		 // point to start of text
	wxChar* pBufStart = ptr;	 // preserve start address for use in testing for
								 // contextually defined sfms
	wxChar* pEnd = pBufStart + rBuffer.Length(); // bound past which we must not go
	wxASSERT(*pEnd == _T('\0')); // ensure there is a null there
	wxString temp;		// small working buffer in which to build a string
	tokBuffer.Empty();
	int	 sequNumber = nStartingSequNum - 1;
	CSourcePhrase* pLastSrcPhrase = (CSourcePhrase*)NULL; // initially there isn't one

	//bool bHitMarker; // set but not used
	USFMAnalysis* pUsfmAnalysis = NULL; // whm added 11Feb05
	bool bIsFreeTransOrNoteOrBackTrans = FALSE;
	bool bIsForeignBackTrans = FALSE;
	// BEW added 11Oct10, two booleans for helping with inline mkrs other than \f & \x
	bool bIsInlineNonbindingMkr = FALSE;
	bool bIsInlineBindingMkr = FALSE;
	bool bIsCharAttrMkr = FALSE;

	// BEW 13Jul11, added support via bool bEmptyUSFM flag, for parsing to CSourcePhrase
	// instances the kind of empty usfm generated by Paratext, \v 1 \v 2 \v 3 etc.
	// Formerly this would parse to a single CSourcePhrase with all markers in its
	// m_markers member. That was unhelpful, we now support one per verse with m_key and
	// m_srcPhrase empty strings.
	bool bEmptyUSFM = FALSE; // initialize
	// BEW 30Sep19 reverting to storing filtered source text data on the pSrcPhrase
	// which comes next after the span to be filtered is removed and prepared for
	// storage on the 'next' pSrcPhrase - the one which is created at the next iteration
	// of the outer loop. If the filtered span goes to the doc end, then we need a
	// boolean which is true when the attempt to store in m_filteredInfo must be delayed
	// delayed till the loop iterates, but at doc end, control exits the loop, and so
	// the bool needs to be initialized here- outside the loop, and it is true when 
	// control leaves the loop, then a new 'empty, dummy' pSrcPhrase needs to be created
	// and appended to the end of the list of CSourcePhrase instances, and that one
	// gets the data prepared for filtering appended to its m_filteredInfo member.
	// The boolean is defined now, and a caching wxString after it:
	bool bDelayStoringFilteredInfo = FALSE;
	wxString strCacheDelayedFilteredContent = wxEmptyString;
	// BEW 30Dec22 make sure a Doc member variables are initialised to FALSE
	m_bWidowedParenth = FALSE;
	m_bWidowedBracket = FALSE;
	// whm 10Feb2024 The following variables are used to help determine if there is a following
	// filtereable marker which is to be filtered during this Tokenizing of the input text. 
	// If a filterable marker follows and it is currently to be filtered, any intervening
	// chapter or verse, any/all whitespace and/or non-filterable, non-content markers that
	// may be surrounding the chapter or verse marker becomes swept up material that is to
	// be prefixed to the upcoming marker-to-be-filtered marker and associated text, all
	// of which will be stored in the m_filteredInfo member. For example, let's assume
	// the ptr is pointing at the following:
	//   "\r\n\\c 2\r\n\\s1 Godzilla on the rampage!..."
	// In this example case the ptr is pointing at whitespace "\r\n" that occurs before a chapter 
	// \c 2 marker, AND the following filterable marker and associated text is (with preceding 
	// whitespace) "\r\n\\s1 Godzilla on the rampage!". We collect all the stuff preceding the
	// marker-to-be-filtered - including whitespace and any chapter/verse or empty markers - and 
	// store that stuff in sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered, and set the 
	// boolean value bParseSweptUpMatterBeforeMarkerToBeFiltered to inform TokenizeText() that
	// there is swept up stuff to be handled.
	// We store the sweptUpStuff... along with the following marker-being-filtered in the
	// current pSrcPhrase->m_filteredInfo member - the sweptUpStuff prefixed to the bracketed
	// to-be-filtered marker and its associated text, and set the boolean value 
	// bParseSweptUpMatterBeforeMarkerToBeFiltered to TRUE.
	// These variables are set by the IsNextFilterableMkrToBeFiltered() function call below in 
	// the outer while (ptr < pEnd) loop between the if (IsWhiteSpace(ptr)) and 
	// itemLen = ParseWhiteSpace(ptr) calls.
	wxString sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered; // whm 10Feb2024 added.
	sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered.Empty();
	bool bParseSweptUpMatterBeforeMarkerToBeFiltered = FALSE; // whm 10Feb2024 modified var name
	bool bContinueTwice;
	bContinueTwice = FALSE;
	// whm 17Jan2024 changed the following variable name. I need a more definitive and self-documenting
	// variable name than bEmptySWBK! ): bSuppressBackwardSearchForWordBreakChar is more informative.
	bool bSuppressBackwardSearchForWordBreakChar; // set true when no backwards search for a src word break character is wanted
	bSuppressBackwardSearchForWordBreakChar = FALSE; // initialise
	wxString ptrPointsAt;
	bKeepPtrFromAdvancing = FALSE; // init
	wxChar* pVerseMkrAtPtr; // BEW added 3Jul23, set at top of IsVerseMarker() TRUE block
	wxUnusedVar(pVerseMkrAtPtr);

	// ****************** The parsing loop commences... ***************************

	while (ptr < pEnd)
	{
		// ****************** Create new pSrcPhrase for parsed data ***************
		// we are not at the end, so we must have a new CSourcePhrase instance ready
		// BEWARE - for doc version 5, if the end of the buffer has endmarkers, pSrcPhrase
		// will receive them, but there will be empty m_key and m_srcPhrase members - we
		// have to test for this possibility and when it happens, move the endmarkers to
		// the preceding CSourcePhrase's m_endMarkers member, then delete the empty last
		// CSourcePhrase instance which then is no longer needed (provided it's
		// m_precPunct member is also empty, if not, we have to leave it to carry that
		// punctuation)
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)NULL;
		if (bContinueTwice)
		{
			bContinueTwice = FALSE;
		}
		itemLen = 0; // since starting a new pSrcPhrase
		pSrcPhrase = new CSourcePhrase;
		wxASSERT(pSrcPhrase != NULL);
		sequNumber++;
		pSrcPhrase->m_nSequNumber = sequNumber; // number it in sequential order
		pSrcPhrase->bHasPostWordMetadata = FALSE; // BEW 19Oct23 initialize to FALSE, else bogus "204" counts as a TRUE value

		//bParsedNewlineBeforeChapterOrVerseMarker = FALSE; // initialise // whm 22Aug2023 note: this bool is never used
		//m_firstVerseNum.Empty(); // must start out empty for each new pSrcPhrase  & set its
					// value when the inner parsing loop first comes to tokBuffer with a \v mkr,
					// then when loop iterations come to the next tokBuffer (or m_markers) with
					// a \v marker, get it's verse number and if greater than m_firstVerseNum,
					// then close off and append the current pSrcPhrase to pList* after ParseWord()


#if defined (_DEBUG) && !defined(NOLOGS)
		wxString pointsAt = wxString(ptr, 20);
		wxLogDebug(_T("\nTokenizeText() START while LOOP, line %d : new sequNum= %d , pointsAt->%s"),
			__LINE__, pSrcPhrase->m_nSequNumber, pointsAt.c_str());

#endif
#if defined (_DEBUG) && !defined(NOLOGS)
		if (pSrcPhrase->m_nSequNumber >= 17)
		{
			bool bWithinInlineSpan = m_bIsWithinUnfilteredInlineSpan; // doc member, I want to know it's value at each new pSrcPhrase
			wxUnusedVar(bWithinInlineSpan);
			if (pLastSrcPhrase == NULL)
			{
				wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= [%s] , m_inform= [%s]"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_inform.c_str());
				int halt_here = 1; wxUnusedVar(halt_here);
			}
			else
			{
				wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= [%s] , m_curChapter= [%s] , m_inform= [%s]"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), pSrcPhrase->m_inform.c_str());
				int halt_here = 1; wxUnusedVar(halt_here);
			}
		}
#endif


#if defined (_DEBUG) && !defined(NOLOGS)
		// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
		//wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
#endif
		// BEW 3Sep19 added next line, for support of USFM3
		// whm 20Sep2023 moved the following initialization here from within the commented out block
		// below. The m_pSrcPhraseBeingCreated pointer needs to be initialized to pSrcPhrase, otherwise
		// it is uninitialized as 0xCDCDCDCD when it is used within the IsAttributeMarker() function.
		m_pSrcPhraseBeingCreated = pSrcPhrase;  //(LHS is in USFM3Support.h)
												// BEW 30Sep19 added next block

/* 
		BEW 9Sep2023 this turned out to work, but it clobbered parsing of things like (9:9-13), gotta find another way
		-- probably allow ParsePreWord() to gobble the initial '(', and the code at top of ParseWord then accepts entry
		if *(ptr -  1) is '(', and don't set bKeepPtrFromAdvancing temporarily to TRUE so as to skip allow ParsePreWord()

		// BEW 3Sep19 added next line, for support of USFM3
		m_pSrcPhraseBeingCreated = pSrcPhrase;  //(LHS is in USFM3Support.h)
												// BEW 30Sep19 added next block

		// BEW 8Sep23 In Nyindrou Bill came across this:  (666). before start of footnote, and it was parsed as
		// (666:. before the footnote. : instead of )  Fix that. Whitespace may preceed, so check for its
		// length so that the if test can have correct pointer values
		{ // scoped block starts
			int nwhites = CountWhitesSpan(ptr, pEnd);
			wxChar* pNewPtr = ptr + nwhites;
			if (pNewPtr < pEnd && *pNewPtr == _T('(') && IsAnsiDigit(*(pNewPtr + 1)))
			{
				// we want to cause ParsePreWord() to be skipped, when this test is
				// TRUE, so that the same test at the top of ParseWord() will not have
				// lost the initial _T('(') of something like (666). before ParseWord()
				// gets its chance to parse it right. We can do this in this way:
				bKeepPtrFromAdvancing = TRUE;
			}
		} // scoped block ends
*/

		// Try correct "<<" followed by space before a word. We dont want the word's << punctuation
		// to be a detached pSrcPhrase storing only "<<"  ptr should be pointing at the first '<' as
		// nothing has been parsed over for pSrcPhrase as yet
		wxChar anOpenWedge = _T('<');
		wxChar aSpace = _T(' ');
		if (*ptr == aSpace && *(ptr + 1) == anOpenWedge)
		{
			// Get past the space, so that the next block can deal with the <<
			ptr++;
			itemLen++;
		}
		if ((*ptr == anOpenWedge) && (*(ptr + 1) == anOpenWedge) && (*(ptr + 2) == aSpace))
		{
			// we've a 3-char sequence that needs fixing
			pSrcPhrase->m_precPunct = _T("<<");
			// skip over the << and its following space
			itemLen += 3;
			ptr += 3;
		}

		wxString endWedges = wxString(ptr, 3); // are the next 3 characters _T(" >>")
		if (endWedges == _T(" >>"))
		{
			// This is to handle a markup error users may often make, putting a space before ending
			// punctuation detached from the word-end by a single space. We will finish off this
			// pSrcPhrase and start another if the 4th wxChar is a whitespace, and we'll try correct
			// the markup error - the >> belongs on the previous pSrcPhrase, in it's m_follPunct member
			wxChar chNext = *(ptr + 3);
			bool bIsWhite;
			bIsWhite = IsWhiteSpace(&chNext);
			if (bIsWhite && pLastSrcPhrase != NULL)
			{
				pLastSrcPhrase->m_follPunct += _T(">>");
				// add the >> to m_srcPhrase as well, then
				// skip over the space followed by >>
				pLastSrcPhrase->m_srcPhrase += _T(">>");
				itemLen += 3;
				ptr += 3;
				// force creation of a new pSrcPhase
				continue; // 1st continue in TokenizeText()
			}
		}

		// BEW 29Dec22, one of the test files recevied from the field, "04-JHN-NY-test" had a couple of problems for
		// our parser which uses ParseAWord(). The first problem was that < << >> and > were used througout, for punctuations
		// from around 2013, which, if not changed to curlies, ‘ “ ” and ’ would require me to write a heap of additional
		// code to handle a legacy markup not likely to be used these days. I fixed that by using a little CC file to convert
		// them to the curly quotes. (the CC file is called wedges2curlies.cct). This is it:
		// "<<" > "“"
		// ">>" > "”"
		// "<" > "‘"
		// ">" > "’"
		// The second problem was that about a half dozen places in the file, the user had a line-ending open parenthesis,
		// preceded by space, and followed by space. Here's a little file of sample data illustrating that:
		//  anyu iri. ( 
		//  \v 24 kabin Herot le ai.)
		// The problem here is that '(' is a punctuation character, and if ParseAWord(ptr, spacelessPuncts, pEnd) is
		// called with ptr pointing at punctuation character, the parse of a 'word' returns empty string, which causes
		// ParseAWord to wxASSERT.
		// I've worked out a solution for the source text parse, but it invoves a pSrcPhrase which has ( as the m_srcPhrase 
		// value, and empty m_key.
#if defined (_DEBUG) // && !defined(NOLOGS) // && defined (LOGMKRS)
		wxString mypointsAt = wxString(ptr, 16);
//		wxLogDebug(_T("TokText line %d in TokenizeText(), sn= %d , bWithinAttrSpan= %d , pointsAt= [%s] "),
//			__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bWithinMkrAttributeSpan, mypointsAt.c_str());
//		wxLogDebug(_T("pSrcPhrase->m_nSequNumber %d"),pSrcPhrase->m_nSequNumber);
		if (pSrcPhrase->m_nSequNumber >= 565) // 441) // whm break
		{
			int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
		}
#endif

		wxChar chOpenParen; chOpenParen = _T('(');
		wxChar chPrecSpace; chPrecSpace = _T(' ');
		// What's diagnostic (and essential) is that a space (or hairspace, U+200A) precedes the open parenthesis 
		// character. What follows could be space or no space, and then a newline (this is diagnostic for the test too)
		if ((*ptr == chPrecSpace) && (*(ptr + 1) == chOpenParen))
		{
			// BEW 30Dec22 potentially there could be a problem of a widowed '(' character. The above test will pick up
			// far too many non-problematic initial parentheses, such as for data: <space>(Kristen), so more if/then
			// tests are require here so that only a true "data problem" is identified which requires setting
			// m_bWidowedParenth to TRUE

			// The above is the outer test, if it returns TRUE we must do the inner test, to ensure that after the ( character
			// there will be a newline next, or perhaps space then newline. It's the newline which completes the diagnostics,
			// because it guarantees the ( character is on it's own line, and must have its own pSrcPhrase with m_key empty 
			wxChar newline = _T('\n');
			wxChar space = _T(' ');
			wxChar* pAux = ptr;
			if ((*(pAux + 2) == newline) ||
				(*(pAux + 2) == space && *(pAux + 3) == newline))
			{
				// TRUE returned from this inner test means that ( is indeed a widowed open parenthesis
				// on it's own line, and this is what it takes to set the boolean TRUE. ParseWord()
				// will then deal with it at line 32137++
				m_bWidowedParenth = TRUE; // Early in ParseWord() the solution will be implemented 
			}
		}

		precWordDelim.Empty(); // BEW added 10Jul14, it should be emptied before we break
							   // out each 'next' parsed word
#if defined (_DEBUG) //&& !defined(NOLOGS) // && defined (LOGMKRS)
		mypointsAt = wxString(ptr, 6);
//		wxLogDebug(_T("TokText line %d in TokenizeText(), sn= %d , bWithinAttrSpan= %d , pointsAt= [%s] "),
//			__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bWithinMkrAttributeSpan, mypointsAt.c_str());
		//if (pSrcPhrase->m_nSequNumber >= 565) // whm break
		if (mypointsAt.Find(_T(" later")) != wxNOT_FOUND) // whm break
		{
			int halt_here = 1; wxUnusedVar(halt_here);
		}
#endif
		//wxChar* pSavePtr = ptr;

		// The normal situation, when we are not adding "???" to m_key and m_srcPhrase
		// BEW 10Mar23 need a boolean here to record if a \n gets parsed over; the FindWordBreakChar()
		// call below parses **backwards**, so if \n is here pointed at by ptr, the while that call
		// will find and save the \n in the wordBreakChar variable, but pSrcPhrase won't know about
		// the \n if we don't record the fact that if here gets parsed over.
		if (IsWhiteSpace(ptr))
		{

			// whm 10Feb2024 The following variables and IsNextFilterableMkrToBeFiltered() function
			// call are used to help determine if there is a following filtereable marker which is 
			// to be filtered during this Tokenizing of the input text. 
			// If a filterable marker follows and it is currently to be filtered, any intervening
			// chapter or verse, any/all whitespace and/or non-filterable, non-content markers that
			// may be surrounding the chapter or verse marker becomes swept up material that is to
			// be prefixed to the upcoming marker-to-be-filtered marker and associated text, all
			// of which will be stored in the m_filteredInfo member. For example, let's assume
			// the ptr is pointing at the following:
			//   "\r\n\\c 2\r\n\\s1 Godzilla on the rampage!..."
			// In this example case the ptr is pointing at whitespace "\r\n" that occurs before a chapter 
			// \c 2 marker, AND the following filterable marker and associated text is (with preceding 
			// whitespace) "\r\n\\s1 Godzilla on the rampage!". We collect all the stuff preceding the
			// marker-to-be-filtered - including whitespace and any chapter/verse or empty markers - and 
			// store that stuff in sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered, and set the 
			// boolean value bParseSweptUpMatterBeforeMarkerToBeFiltered to inform TokenizeText() that
			// there is swept up stuff to be handled.
			// We store the sweptUpStuff... along with the following marker-being-filtered in the
			// current pSrcPhrase->m_filteredInfo member - the swept up stuff returned in the
			// sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered reference parameter are then to be
			// prefixed to the bracketed to-be-filtered marker and its associated text, and in such cases
			// the function sets the boolean value bParseSweptUpMatterBeforeMarkerToBeFiltered to TRUE.
			// These variables are initialized below just before the IsNextFilterableMkrToBeFiltered() 
			// function call here in the outer while (ptr < pEnd) loop between the if (IsWhiteSpace(ptr)) 
			// and itemLen = ParseWhiteSpace(ptr) calls.
			// When the IsNextFilterableMkrToBeFiltered() function returns TRUE, the nLenSweptUpStuff is 
			// assigned to itemLen so that the ptr will advance past any swept up material in the
			// ptr += itemLen; call below.
			int nLenSweptUpStuff = 0;
			sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered.Empty();
			if (IsNextFilterableMkrToBeFiltered(ptr, pEnd, sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered, nLenSweptUpStuff))
			{
				bParseSweptUpMatterBeforeMarkerToBeFiltered = TRUE; // whm 10Feb2024 modified var name
				itemLen = nLenSweptUpStuff; // advance ptr to point past the swept up stuff and point at following marker to be filtered
			}
			else
			{
				// The ptr still points at the whitespace so parse it.
				// [BEW] advance pointer past the white space (\n or inter-word spaces, of whatever kind, now
				// have to be stored on the pSrcPhrase, so they can be restored at export, so add
				// code below, with precWordDelim as the intermediate storage wxString, and add it
				// to pSrcPhrase->m_srcWordBreak wxString
				//wxChar chWhat;
				itemLen = ParseWhiteSpace(ptr);

			}
			// int cnt = 0; // see comment below for reason to remove the cnt variable
			// 
			// whm 22Aug2023 Note: The if (itemLen == 1) test below misses all instances where
			// the EOL encountered here is "\r\n", because when "\r\n" is encountered the
			// ParseWhiteSpace(ptr) call above will return a value of 2 to itemLen.
			// Also, the bParseNewlineBeforeVerseMarker bool within the following test is never
			// tested for or used in code anywhere else within the code base so setting it to
			// a TRUE value here is pointless. I'm commenting the if test block below from the
			// code.
			/*
			if (itemLen == 1)
			{
				bParsedNewlineBeforeChapterOrVerseMarker = FALSE; // init to false  // whm 22Aug2023 note: this bool is never used
				if (*ptr == _T('\n') && *(ptr + 1) == gSFescapechar && *(ptr + 2) == _T('v') && *(ptr + 3) == _T(' '))
				{
					// set the bool true for a sequence ptr ->"\n\\v "  and use the boolean when parsing \v<space>
					// and we want to get the \n into m_markers without a Trim() removing it or changing it to space
					bParsedNewlineBeforeChapterOrVerseMarker = TRUE; // whm 22Aug2023 note: this bool is never used
				}
				else if ( (*ptr == _T('\r')) && (*(ptr+1) == _T('\n')) && *(ptr + 2) == gSFescapechar 
						&& *(ptr + 3) == _T('v') && *(ptr + 4) == _T(' '))
				{
					bParsedNewlineBeforeChapterOrVerseMarker = TRUE; // whm 22Aug2023 note: this bool is never used
					cnt = 1;
				}
			}
			*/
			// whm 17Jan2024 modified to ptr += itemLen;
			// whm 10Feb2024 comment: itemLen will point past whitespace, or past any swept up whitespace and
			// markers from the IsNextFilterableMkrToBeFiltered() call above.
			//ptr += (itemLen + cnt); // in Windows, before backslash might be \r\n 
			ptr += itemLen;

			/*
			// Here below is a test that will set bParsedNewlineBeforeChapterOrVerseMarker to TRUE when
			// a \v marker immediately follows an EOL of '\n' or "\r\n"
			bParsedNewlineBeforeChapterOrVerseMarker = FALSE; // initialize for every test // whm 22Aug2023 note: this bool is never used
			if ((itemLen == 1 && *ptr == _T('\n') && *(ptr + 1) == gSFescapechar && *(ptr + 2) == _T('v') && *(ptr + 3) == _T(' ')) 
				|| (itemLen == 2 && *ptr == _T('\r') && *(ptr + 1) == _T('\n') && *(ptr + 2) == gSFescapechar && *(ptr + 3) == _T('v') && *(ptr + 4) == _T(' ')) )
			{
				// Set the bool TRUE if ptr points at: "\n\\v " or "\r\n\\v "
				bParsedNewlineBeforeChapterOrVerseMarker = TRUE; // whm 22Aug2023 note: this bool is never used
			}
			*/

		} // This block just ended is vital. It gets ptr pointing at a backslash, so that tests below don't fail.

		// BEW 10Jul14 added next 3 lines
		// BEW 23Apr15, signature *ptr,itemLen results in the wxChar at ptr being repeated
		// itemLen times. That's not what I want. signature should be ptr,itemLen, which
		// then copies as many wxChars as itemLen value, starting from ptr's wxChar
		//wxString aDelimiter(*ptr, itemLen); <<-- wrong
		//wxString aDelimiter = wxString((pSavePtr - 1), 1); // right  // BEW 16Dec22 use preceding char to that at pSavePtr
		//precWordDelim = aDelimiter; // intermediate location, in case we need to change or reuse later
		if (pSrcPhrase->m_nSequNumber > 0 && !bSuppressBackwardSearchForWordBreakChar)
		{
			// BEW 16Apr23 don't search back for what's not there, only do this when m_nSequNum is greater than zero
			// BEW 18Apr23 why bSuppressBackwardSearchForWordBreakChar? Consider data like the 'not in original manuscript' being indicated (eg. as in Nyindrou Mark 16:9)
			// by this sequence: "\\p [\\v 9 Eme ma..." <- there is no whitespace (such as '\n' or ' ') preceding the \v marker. Typically
			// we want our input tokenizing to start a new pSrcPhrase at a newline or space, because doing so means the the inner parsing loop
			// which repeats searching for a mkr will not succeed and exit at ptr pointing at space or newline, and then control is in the outer 
			// loop and another continue will force the iteration of a new pSrcPhrase -which is what we'd want after the [ has been parsed. But
			// a new pSrcPhrase will try to search backwards for the whitespace before the \v marker, and there is none. So we have to butt
			// the [ up to the word "Eme" with nothing between. So the search for a src word break to put into precWordDelim has to be
			// suppressed, as it would find the wrong whitespace. So bSuppressBackwardSearchForWordBreakChar set TRUE is used to suppress that backwards search. That
			// allows the abutting to take place, and with the help of bContinueTwice TRUE, to force the [ to be on its own pSrcPhrase
			// in m_key and m_srcPhrase. (The matching ], much later, will be handled by ParseWord() as simple following punctuation.)

			precWordDelim = FindWordBreakChar(ptr, pBufStart);
			pSrcPhrase->SetSrcWordBreak(precWordDelim);
		}
		else
		{
			if (bSuppressBackwardSearchForWordBreakChar)
			{
				bSuppressBackwardSearchForWordBreakChar = FALSE; // used at 18,886 inner while loop's test,
									// and at 18,711, and set TRUE only at 19,321
			}
		}

		// The person doing PT8 configuring has, in some source text, left the "degree"
		// (as in temperature) symbol immediately preceding some markers - a pain in the
		// butt as they are deprecated in PT and mess with AI. So skip any that we come
		// across when parsing. (BEW 6Sep19, Gerald Harding's (Senegal) 2Kings data has 
		// them for example. Here should be an appropriate place to skip ptr over it.
		// It's UTF16 \u00b0
		bool bUnwwantedChar = IsAnUnwantedDegreeSymbolPriorToAMarker(ptr);
		if (bUnwwantedChar)
		{
			// If found, skip it
			ptr++;
		}
#if defined (_DEBUG) && !defined(NOLOGS) // && defined (LOGMKRS)
		mypointsAt = wxString(ptr, 20);
		wxLogDebug(_T("TokText line %d in TokenizeText(), sn= %d , bWithinAttrSpan= %d , pointsAt= [%s] "),
			__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bWithinMkrAttributeSpan, mypointsAt.c_str());
		if (pSrcPhrase->m_nSequNumber >= 17)
		{
			int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
		}
#endif
		// 25Jun23 Handle  ".... pe. (“Kokata ...." here, otherwise, ParsePreWord will swallow
		// '(', leaving ParseWord() to handle “Kokata -- to an inevitable fail because a preceding
		// punct will halt ParseAWord() - and ptr will not advance (it asserts in _DEBUG mode)
		// resulting in an infinite loop till crash. So here, handled the (“ pair, parsing over etc
		// (I'll generalise to ( followed by any punct of the "initial" puncts set)
		// BEW 18Aug23 refactored this block, earlier code made no sense
		bool b2ndIsInitialPunct;
		b2ndIsInitialPunct = FALSE; // init
		// 2nd needs to be a beginning punct, not just any arbitrary punct
		b2ndIsInitialPunct =  m_strInitialPuncts.Find(*(ptr + 1)) >= 0;
		if (*ptr == _T('(') && b2ndIsInitialPunct)
		{			
			wxChar* pAux = (ptr + 1);
			wxChar chAtAux = *pAux; // which begin-punct in “‘\"[(<{«¿¡—  is being pointed at
			pSrcPhrase->m_precPunct << _T('(');
			pSrcPhrase->m_precPunct << chAtAux;
			// at this point, m_key and m_srcPhrase should still be empty; values will be
			// added in ParseWord() and m_precPunct used there to prefix to m_srcPhrase
			ptr += 2; // advance ptr to point past the "(“" 2-char substring
			itemLen = 0;
		}
		
#if defined (_DEBUG) && !defined(NOLOGS) // && defined (LOGMKRS)
		mypointsAt = wxString(ptr, 16);
		wxLogDebug(_T("TokText line %d in TokenizeText(), sn= %d , bWithinAttrSpan= %d , pointsAt= [%s] "),
			__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bWithinMkrAttributeSpan, mypointsAt.c_str());
		if (pSrcPhrase->m_nSequNumber == 440)
		{
			int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
		}
#endif
		// BEW 7Oct22 we need to support [ bracket here in TokenizeText() because
		// that function deals with all the pre-word material, including open bracket, [
		// It's ParseWord() which must handle close bracket, and significant additions to
		// ParseWord will be required to handle the 3 potentialities: ] is a word-building
		// wxChar (not punctuation), or ] is punctuation (as is normally the case), or ]
		// should be handled as 'detached' - so it's the content in m_key and m_srcPhrase
		// on its own pSrcPhrase - which should follow at the end of what ParseWord() parses
		// over. What happens is complicated by the options available to the user for placing
		// a ] into the text. The legacy code caused the app to crash when ] followed the
		// just-parsed-over word. This problem was reported from the field via Kevin Bradford
		// in September 2022.
		if (*ptr == _T('['))
		{
			// we've come to an opening bracket, [
			wxChar chOpenBracket = *ptr; // temp store the [ character


			// BEW 6Oct22, refactoring, so that we don't have an isolate [ on a pile, unless
			// there is at least one space following it (we ignore extras if present, they are
			// of no value to the document parsing)
			bool bOpenBracketIsNotPunctuation = IsOpeningBracketWordBuilding(spacelessPuncts); // TRUE if 
																		// [ is not in spacelessPuncts
			bool bWhiteSpaceFollows = FALSE; // initialise

			itemLen = 0; // reset, 17434 probably set itemLen to 1 and it's been used to update ptr, so can reset 0

			bWhiteSpaceFollows = IsWhiteSpace(ptr + 1);
			// (1) If there is white space following, we'll handle the [ as pseudo text, even if it's punctuation
			// and store it on the current pSrcPhrase, putting it into m_key and m_srcPhrase, and declining
			// to put it into m_precPunct.
			// (2) If the [ is a word-building character (i.e. not punctuation), then add it to m_key and m_srcPhrase
			// and advance ptr, and let ParseWord handle any other following characters of the 'word'.
			// (3) If neither of the above, then it's punctuation and we'll add it to m_precPunct, and then
			// let ParseWord() do any further parsing.
			if (bWhiteSpaceFollows)
			{
				++ptr; // get past the [
				++itemLen;
				int countWhites = ParseWhiteSpace(ptr);
				// advance ptr, to point at what follows the whitespace/s
				ptr += countWhites;
				itemLen += countWhites;

				// Store the [ in m_key and m_srcPhrase, so it will appear in the interlinear layout
				pSrcPhrase->m_key = chOpenBracket;
				pSrcPhrase->m_srcPhrase = chOpenBracket;

				// We want this pSrcPhrase to be a 'detached' one, so we must add it
				// to the doc list, pList
				pList->Append(pSrcPhrase);
				// make this one become the 'last one' of the next iteration
				pLastSrcPhrase = pSrcPhrase;
#if defined (_DEBUG) && !defined(NOLOGS)
				wxLogDebug(_T("TokText: line %d, sequNum = %d , m_srcPhrase= [%s] , chapter:verse = [%s], iterating by continue"),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_chapterVerse.c_str());
#endif
				// Now iterate the TokenizeText() parsing loop, so that a new pSrcPhrase instance
				// is created, to deal with what follows the white space/s
				bWhiteSpaceFollows = FALSE;
				continue;  //  gotta continue; otherwise parsing will halt at this sn's pile - 2nd continue in TokenizeText()

			} // end of TRUE block for test: if (bWhiteSpaceFollows)
			else
			{
#if defined (_DEBUG) && !defined(NOLOGS) //&& defined (LOGMKRS)
				wxLogDebug(_T("TokText() line %d ELSE block for pointing at '[', sn for CSourcePhrase in TokenizeText()= %d , bWithinAttrSpan= %d"),
					__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bWithinMkrAttributeSpan);
				if (pSrcPhrase->m_nSequNumber >= 5)
				{
					int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
				}

#endif				// Options 2 or 3 must apply
				if (bOpenBracketIsNotPunctuation)
				{
					// [ is a word-building character, so it belongs as first char in each of
					// m_key and m_srcPhrase. Then pass control on to ParsePreWord() and then
					// ParseWord() to fill out the rest of m_key and m_srcPhrase - on this current pSrcPhrase
					pSrcPhrase->m_key = chOpenBracket;
					pSrcPhrase->m_srcPhrase = chOpenBracket;
					itemLen = 0; // reset
					ptr++; // point past the [ so that ParseWord()'s input pChar will be correct 

				} // end of the TRUE block for test: if (bOpenBracketIsNotPunctuation)
				else
				{
					wxChar ch = *ptr;
					if (ch != _T(']')) // protection, in case the context has ptr pointing at ']' - don't put that into m_precPunct!
					{
						// [ must be punctuation, and so we need to store it in m_precPunct. Other punctuation may
						// follow (such as opening quote or double-quote, or ", or in Spanish, the inverted question mark,
						// and so forth. Or the word proper may be next wxChar. So we pass control on to ParseWord to
						// fill out the rest of m_key and compute what m_srcPhrase is to be
						pSrcPhrase->m_precPunct += *ptr;
						itemLen = 0; // reset
						ptr++; // point past the [ so that ParseWord()'s input pChar will be correct
					}

				} // end of the else block for test: if (bOpenBracketIsNotPunctuation), i.e. it's punctuation
//				wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

			} // end of else block for test: if (bWhiteSpaceFollows)
		} // end of TRUE block for test: if (*ptr == _T('['))

		// are we at the end of the text?
		if (IsEnd(ptr) || ptr >= pEnd)
		{
			// check for an incomplete CSourcePhrase, it may need endmarkers moved, etc
			if (pSrcPhrase != NULL)
			{
				if (pSrcPhrase->m_key.IsEmpty())
				{
					if (!pSrcPhrase->GetEndMarkers().IsEmpty())
					{
						// there are endmarkers which belong on the previous instance, so
						// transfer them
						if (pLastSrcPhrase != NULL)
						{
							pLastSrcPhrase->SetEndMarkers(pSrcPhrase->GetEndMarkers());
						}
					}
				}
			}
			// BEW added 05Oct05
			if (bFreeTranslationIsCurrent)
			{
				// we default to always turning off a free translation section at the end
				// of the document if it hasn't been done already
				if (pLastSrcPhrase != NULL)
				{
					pLastSrcPhrase->m_bEndFreeTrans = TRUE;
				}
			}
			// delete only if there is nothing in m_precPunct
			if (pSrcPhrase->m_precPunct.IsEmpty())
			{
				DeleteSingleSrcPhrase(pSrcPhrase, FALSE); // don't try partner pile deletion
			}
			tokBuffer.Empty();
			break; // 1st break in TokenizeText()
		}
		// BEW 11Oct10, use an inner loop... rather than gotos
		// are we pointing at a standard format marker?
//		wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"),
//			__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
		// BEW 18Apr23 add subtest !bSuppressBackwardSearchForWordBreakChar to the while test; when the bool is TRUE we
		// want to clobber iterating for another beginMkr, so that control returns to the
		// outer loop, and we can there use bContinueTwice set TRUE to force a new pSrcPhrase
		// to be created
		// BEW 11Jun23 don't remove the bool in the test. When SWBK is set with content ( from >= 1)
		// it will always be empty. sn = 0 is different, it helps only there
		wxString strPointsAt;
		bool bIsToBeFiltered;
		bIsToBeFiltered = FALSE; // BEW 18Aug23 init to FALSE, otherwise it's 205 which is bogus TRUE
		// BEW 14Aug23 here is where to declare booleans to use in contentless USFM parsing loop
		bool bProcessEmptyMarker;
		bool bExitEmptyMkrsLoop;

		while (!bSuppressBackwardSearchForWordBreakChar && IsMarker(ptr))
		{

#if defined (_DEBUG) && !defined (NOLOGS)
			{
				wxString strPointAt = wxString(ptr, 16);
				wxLogDebug(_T("TokTxt() line  %d , m_markers= [%s] , m_curChapter= [%s] , chapter:verse= [%s], pointsAt= [%s]  Mkr loop BEGINS "),
					__LINE__, pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
				if (pSrcPhrase->m_nSequNumber == 19)
				{
					int halt_here = 1; wxUnusedVar(halt_here);
				}
			}
#endif
			// BEW 14Aug23 here is where the alternate parsing loop should be, for contentless markers.
			// Control should stay in the alternate loop, creating new pSrcPhrases as in-loop parsing
			// takes place, and exit the loop only when ptr reaches pEnd, or bool ExitEmptyMkrsLoop
			// returns TRUE (at a backslash). Entry to the loop only happens at a beginMkr where the
			// test bool EnterEmptyMkrsLoop returns TRUE.

			// ptr is at a beginMkr, so test for entry and set up the alternate parsing loop
			bExitEmptyMkrsLoop = FALSE; // init
			wxString atMkr = wxEmptyString;
			wxString mkrTag = wxEmptyString;
			wxString paragraphMkr = _T("\\p");
			wxString subtitle = _T("\\s");
			wxString subtitleOne = _T("\\s1");
			wxString strVerseNum = wxEmptyString; wxString strChapterNum = wxEmptyString;
			//wxChar* pAux = NULL; bool bIsEmptyMkr = FALSE; // init
			int nMkrLen = 0; 
			//int verseNumLen = 0; 
			//int chapterNumLen = 0;
			int itemLen = 0;  
			//int nWhitesLen = 0;
			wxString mkrNumber = wxEmptyString; // init
			wxString str_m_markers_store = wxEmptyString; // init
//#if defined (_DEBUG)
			// probably safe to initialise to chapter 1 (comment this out after \c is handled)
//			pApp->m_curChapter = _T("1"); 
//			pApp->m_curChapter += _T(':'); // get the "1:" part of "1:verseNum" in m_chapterVerse ready
//#endif

#if defined (_DEBUG) && !defined (NOLOGS)
			{
				wxString ptrAt;
				ptrAt = wxString(ptr, 20);
				wxLogDebug(_T("TokText()  BEFORE EMPTY MKRS LOOP ENTRY, line %d, sn= %d, m_markers= [%s], pointsAt= [%s] "),
					__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
				if (pSrcPhrase->m_nSequNumber == 440)
				{
					int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
				}
			}
#endif
			// whm 17Jan2024 removed the EnterEmptyMkrsLoop() function call. We can simply use the IsEmptyMkr()
			// function combined with a determination of bIsToBeFiltered flag below as determination of whether
			// to enter the empty marker block below.
			//bProcessEmptyMarker = EnterEmptyMkrsLoop(ptr, pEnd);

			//bool bVerseOrChaptMkr = FALSE;

			// whm 17Jan2024 Removed the EnterEmptyMkrsLoop() function and its call above, 
			// and instead called directly the IsEmptyMkr() function here as well as set a
			// bIsToBeFiltered boolean basen on whether the marker is within the 
			// gCurrentFilterMarkers string. If the marker is within gCurrentFilterMarkers
			// then we exclude it from proceding into the bProcessEmptyMarker TRUE block 
			// below. Otherwise, paragraph markers which are normally empty like \p can
			// get treated within the empty markers block below and outside that block
			// in other parts of TokenizeText().
			// NOTE: This is the first place in TokenizeText() where we parse and extract 
			// the marker at the ptr. The current pSrcPhrase instance has no members yet 
			// assigned. 
			int awholemkrlen = ParseMarker(ptr);
			wxString aWholeMkr = wxString(ptr, awholemkrlen);
			wxString augWholeMkr;
			augWholeMkr = aWholeMkr + _T(' ');
			// whm 20Jan2024 added check if augWholeMkr is an AI custom marker \free \note 
			// or \bt... marker - which are obligatorily filtered.
			bool bIsForeignBackTransMkr = FALSE;
			bIsToBeFiltered = (pApp->gCurrentFilterMarkers.Find(augWholeMkr) != wxNOT_FOUND);
			if (!bIsToBeFiltered)
			{
				bIsToBeFiltered = IsMarkerFreeTransOrNoteOrBackTrans(augWholeMkr, bIsForeignBackTransMkr);
			}
			int nEmptyMkrPeriodsInWhitesLen = 0; // used only in next line below and inside the if (bEngerEmptyMkrsLoop) below
			int nEmptyWhitesFollowingMkr = 0; // used only in next line below and inside the if (bEngerEmptyMkrsLoop) below
			if (IsEmptyMkr(ptr, pEnd, bHasBogusPeriods, nWhitesLenIncludingBogusPeriods, nPeriodsInWhitesLen)
				&& !bIsToBeFiltered)
			{
				bProcessEmptyMarker = TRUE;
				//bEmptyUSFM = TRUE; // whm temporary until can remove this bEmptyUSFM flag
				// If the marker that ptr is pointing at is within the m_paragraphMkrs set
				// or is a chapter marker, we set bProcessEmptyMarker to FALSE so that
				// the marker gets processed by the main routines of TokenizeText() rather
				// than the empty markers block below. The reference parameters set in the
				// IsEmptyMkr() function call above will inform TokenizeText() about the
				// presence of any bogus periods to deal with there. Other non-paragraph
				// and non chapter markers that go into the empty markers block below will
				// have any bogus periods skipped for such markers below - also being
				// informed there of bogus periods by the reference parameters in the
				// IsEmptyMkr() function call above.
				if (pApp->m_paragraphMkrs.Find(augWholeMkr) != wxNOT_FOUND || aWholeMkr == chapterMkr)
				{
					// Don't process a paragraph marker from the App's m_paragraphMkrs set 
					// nor a chapter marker within the bProcessEmptyMarker TRUE block below.
					// Instead process such markers in the main part of TokenizeText().
					bProcessEmptyMarker = FALSE;
					bEmptyUSFM = FALSE; // whm temporary until can remove this bEmptyUSFM flag
				}
			}
			else
			{
				bProcessEmptyMarker = FALSE;
				//bEmptyUSFM = FALSE; // whm temporary until can remove this bEmptyUSFM flag
			}

#if defined (_DEBUG) // && !defined (NOLOGS)
			{
				wxString ptrAt;
				ptrAt = wxString(ptr, 20);
//				wxLogDebug(_T("TokText() tested ENTER EMPTY MKRS LOOP, line %d, BOOL bProcessEmptyMarker= %d, sn= %d, m_markers= [%s], pointsAt= [%s]"),
//					__LINE__, (int)bProcessEmptyMarker, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
				if (pSrcPhrase->m_nSequNumber >= 153)
				{
					int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
				}
			}
#endif
			// whm 17Jan2024 changed name of test below from bEnterEmptyMkrProcessing to bProcessEmptyMarker
			if (bProcessEmptyMarker) 
			{
				// whm 17Jan2024 Removed the while loop below. The bProcessEmptyMarker should no 
				// longer be a loop but should process only one empty marker at a time here within 
				// TokenizeText().
				// With this change verse and chapter markers won't get processed as empty markers
				// but will get processed in the main body of TokenizeText().
				// Also, we can process ALL other empty markers in one if else block by calling
				// LookupSFM() on the marker
				// Also Change the boolean name from bProcessEmptyMarker to bEnterEmptyMkrProcessing.
				//while (ptr < pEnd && !bExitEmptyMkrsLoop)
				//{
					// Any beginMkr may be the last empty one in a contentless span, so the exit command
					// needs to happen when IsEmptyMkr() is FALSE
					// The most significant tests are for \v, and then for \c - as these result in
					// the only information the user sees in the GUI, the m_inform chapter:verse m_inform value
					atMkr = GetWholeMarker(ptr);
					nMkrLen = atMkr.Length();
					mkrTag = atMkr.Mid(1); // remove initial backspace
					// We don't yet know what marker it is; start with dealing with a \v marker, this will require
					// stealing code from IsVerseMarker()'s block, 
					wxChar* pAux = ptr; // maintain ptr pointing at marker, then update it below
					pAux += nMkrLen;
					if (atMkr == verseMkr || atMkr == chapterMkr)
					{
						// for a verseMkr or even a chapterMkr we need to parse of following space and number
						int spLen = ParseWhiteSpace(pAux);
						pAux += spLen;
						nMkrLen += spLen;
						int numLen = ParseNumber(pAux);
						pAux += numLen;
						nMkrLen += numLen;
					}
					// whm 17Jan2024 After removing the inner while (ptr < pEnd && !bExitEmptyMkrsLoop)
					// we can deal with only one marker at a time here within the if (bProcessEmptyMarker) 
					// empty markers TRUE block. All markers can be dealt with together without having
					// separate blocks for some and a catch-all block for others
					// This change will mean that the verse and chapter markers will only be dealt with 
					// in the main body of TokenizeText() and never within this empty markers block.
					
					// whm 19Jan2024 Now that we deal with only one empty marker for each pass through
					// the main TokenizeText() loop, we need to know here if this current empty marker
					// is the first one encountered after having processed a non-empty marker. I think
					// we can make use of the bEmptyUSFM flag to determine that situation. If the
					// bEmptyUSFM flag is FALSE at this point it means that this is the first empty
					// marker after a non-empty one was processed and appended to the pList. 
					// This information is needed because TokenizeText() will have already created a
					// new pSrcPhrase near its beginning which will be essentially empty at the point
					// here where we've detected the empty marker. We don't want to create a new
					// pSrcPhrase is such cases but use the one TokenizeText() has already propared.
					// So, the test below for bEmptyUSFM signals that we should make use of the
					// already created pSrcPhrase.
					if (bEmptyUSFM == FALSE)
					{
						// The last pSrcPhrase was not created as a non-empty marker source phrase
						// so we need to avoid creating a new pSrcPhrase here.
						bEmptyUSFM = TRUE; // Now we are dealing with an empty marker
					}
					else
					{
						// bEmptyUSFM was already true indicating that the the last marker was also 
						// an empty marker and had its own pSrcPhrase. Here we need a new pSrcPhrase 
						// for the  current empty marker.
						
						// whm 12Jan2024 added. There is code in TokenizeText() after the ParseWord() call 
						// that has an if (pLastSrcPhrase != NULL) which runs for over 400 lines and attempts 
						// to  correctly propagate type changes, etc. It depends on an updated pLastSrcPhrase
						// pointer, so we must update pLastSrcPhrase here before creating a new pSrcPhrase
						// below.
						pLastSrcPhrase = pSrcPhrase;

						// Create a new pSrcPhrase for this empty marker on the heap which can be appended
						// to pList
						sequNumber = pList->GetCount(); // we are working at end of what's been parsed so far
						pSrcPhrase = new CSourcePhrase; // index number is always 1 less than the count
														// so count value is sequNum for the new pSrcPhrase
						pSrcPhrase->m_nSequNumber = sequNumber;
					}

					wxString mkrsStr = wxEmptyString;
					if (nEmptyMkrPeriodsInWhitesLen > 0)
					{
						wxChar* pAux2 = ptr;
						// Need to get the string for m_markers with periods removed
						for (int i = 0; i < nEmptyWhitesFollowingMkr; i++)
						{
							if (*pAux2 != _T('.'))
								mkrsStr += *pAux2;
							pAux2++;
						}
						pSrcPhrase->m_markers = mkrsStr;
					}
					else
					{
						// No periods present so build m_markers from the length of nMkrLen + nEmptyWhitesFollowingMkr
						// whm 23Jan2024 modification. The assignment of the empty marker to m_markers below should be
						// a += operation rather than a = operation. Otherwise, when we have multiple successive empty
						// markers, some previous ones already in m_markers get wiped out.
						//pSrcPhrase->m_markers = wxString(ptr, nMkrLen + nEmptyWhitesFollowingMkr);
						pSrcPhrase->m_markers += wxString(ptr, nMkrLen + nEmptyWhitesFollowingMkr);
					}

					// BEW had a block in the main body of TokenizeText after pList->Append(pSrcPhrase)
					// which had if (bEmptyUSFM) and if TRUE it emptied the tokBuffer and had code to
					// "ensure there is always a final space at end of m_markers when parsing
					// contentless USFM data". I'm putting that code here and commenting it out back
					// in the main TokenizeText() body.
					tokBuffer.Empty();
					if (!pSrcPhrase->m_markers.IsEmpty() &&
						pSrcPhrase->m_markers.GetChar(pSrcPhrase->m_markers.Len() - 1) != _T(' '))
					{
						pSrcPhrase->m_markers += _T(' ');
					}

					USFMAnalysis* pUsfmAnalysis = LookupSFM(mkrTag); // the "bareMkr" version
					if (pUsfmAnalysis != NULL)
					{
						// It's a known marker

						// Calculate the string to be stored in pSrcPhrase->m_markers
						// We leave any periods out of the construction of the str_m_markers_store
						// by reducing the length calculation by the nPeriodsInWhitesLen value in
						// the statement below.

						// Set GUI important values on pSrcPhrase (current)
						pSrcPhrase->m_inform = pUsfmAnalysis->navigationText;
						pSrcPhrase->m_bSpecialText = pUsfmAnalysis->special;
						pSrcPhrase->m_curTextType = pUsfmAnalysis->textType;

					}
					else
					{
						// It's an unknown marker
						// Set GUI important values on pSrcPhrase (current)
						pSrcPhrase->m_inform = _T("?") + atMkr + _T("?");
						pSrcPhrase->m_bSpecialText = TRUE;
						pSrcPhrase->m_curTextType = none;
					}


					// Advance pAux to point at the backslash (or pEnd) that follows
					ptr += nMkrLen + nEmptyWhitesFollowingMkr - nEmptyMkrPeriodsInWhitesLen; // ptr skips over any bogus periods

					// We can now bypass parsing and jup to the finishup label when
					// eventually the pSrcPhrase will get appended to the pList
					//pList->Append(pSrcPhrase);
					//AdjustSequNumbers(0, pList); // ensure correct sequence numbers 

					bComingFromInnerMarkerLoop = TRUE;
					goto finishup;

					// whm 12Jan2024 added. If the current marker is at pEnd, control should 
					// go to finishup after the ParseWord() call
					//if (ptr >= pEnd)
					//{
					//	goto finishup;
					//}



					/*
					if (atMkr == verseMkr)
					{
						int break_here = 0; wxUnusedVar(break_here);
						// whm 12Jan2024 observation and modifications
						// Here within the inner while loop of the bProcessEmptyMarker, successive iterations
						// need to check whether the current marker encountered within the loop are "empty"
						// or not, and if empty, a new CSourcePhrase needs to be created. The old code,
						// however, created a new CSourcePhrase BEFORE it was determined whether the newly
						// encountered marker was empty or not. This could result in an un-initialized
						// pSrcPhrase at the end of a parsed file that can cause crashes in the code there.
						// I think it would be better to call a slightly modified IsEmptyMkr() function BEFORE 
						// creating the new CSourcePhrase, and so we're only create the new CSourcePhrase when 
						// actually needed. 
						// So, we'll call IsEmptyMkr() here.
						// Note: The nWhitesLen returned in the IsEmptyMkr() call below will be the span of 
						// whites following the marker at ptr up to the next backslash or pEnd.
						//int nPeriodsInWhitesLen = 0;
						//bIsEmptyMkr = IsEmptyMkr(ptr, nWhitesLen, pEnd, nPeriodsInWhitesLen);
						// Any periods found in nPeriodsInWhitesLen in above call will be skipped
						// over in the TRUE block of the test below.
						// For a \v n marker it isn't likely there would be bogus periods from 
						// Paratext. If present they would something like this: \v n ...\r\n <text...>
						// where the periods would follow a space following the verse number n and
						// occur before an EOL sequence. Not impossible, but if it happens we deal with
						// below.

						// whm 17Jan2024 removed test. This empty markers code block is now only entered 
						// when bIsEmptyMkr is TRUE and bIsToBeFiltered is FALSE.
						//if (bIsEmptyMkr == TRUE)
						//{
							// whm 12Jan2024 modified and clarified the parsing code below
							pAux = ptr; // protext ptr location
							int nTotMkrLen = 0; // accumulate sub-lengths in this
							itemLen = 0;
							itemLen = nMkrLen; // length of the "\\v" part of verse marker
							nTotMkrLen += itemLen;
							pAux += itemLen;
							// Get to the verse number
							itemLen = ParseWhiteSpace(pAux); // parse the whitespace before verse number
							nTotMkrLen += itemLen;
							pAux += itemLen;
							itemLen = ParseNumber(pAux); // parse the number n of the \v n marker
							verseNumLen = itemLen;
							strVerseNum = wxString(pAux, verseNumLen); // make the verse number n into a string
							nTotMkrLen += itemLen;
							pAux += itemLen; // pAux now points just past the n of the \v n marker
							// Calculate the string to be stored in pSrcPhrase->m_markers
							// We leave any periods out of the construction of the str_m_markers_store
							// by reducing the length calculation by the nPeriodsInWhitesLen value in
							// the statement below.

							str_m_markers_store = wxString(ptr, nTotMkrLen + nEmptyWhitesFollowingMkr - nEmptyMkrPeriodsInWhitesLen); // Include the whitespace after verseNum


							// whm 12Jan2024 added. The code in TokenizeText() after the finishup: label has
							// an if (pLastSrcPhrase != NULL) which runs for over 400 lines and attempts to 
							// correctly propagate type changes, etc. It depends on an updated pLastSrcPhrase
							// pointer, so we must update pLastSrcPhrase here before creating a new pSrcPhrase
							// below.
							pLastSrcPhrase = pSrcPhrase;

							// The current pSrcPhrase is about to be done. But pSrcPhrase here in the alternate
							// parsing loop does not yet exist - we've got to create a new one on the heap,
							// which can be appended to pList
							sequNumber = pList->GetCount(); // we are working at end of what's been parsed so far
							pSrcPhrase = new CSourcePhrase; // index number is always 1 less than the count
															// so count value is sequNum for the new pSrcPhrase
							pSrcPhrase->m_nSequNumber = sequNumber;
#if defined(_DEBUG)
							if (pSrcPhrase->m_nSequNumber >= 134)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
#endif

							// Set GUI important values on pSrcPhrase (current)
							pSrcPhrase->m_chapterVerse = pApp->m_curChapter; // was set to n: form
							pSrcPhrase->m_chapterVerse += strVerseNum; // append the verse number from above
							pSrcPhrase->m_bVerse = TRUE;
							// don't set m_inform too, causes doubling up
							// 
							// whm 12Jan2024 added
							if (!tokBuffer.IsEmpty())
							{
								// The chapter marker in tokBuffer here was delayed from the chapter processing
								// empty marker block, to get prefixed here on the verse content in the 
								// str_m_markers_store.
								str_m_markers_store = tokBuffer + str_m_markers_store;
								tokBuffer.Empty();
							}

							// Store beginMkr and the whitespace following it, in m_markers
							pSrcPhrase->m_markers = str_m_markers_store; // BEW 18Aug23 not append, just assign to avoid accumulating

							// Advance pAux to point at the backslash (or pEnd) that follows
							pAux += nWhitesLen; // augment pAux by the value returned from IsEmptyMkr(pAux, nWhitesLen, pEnd) above

							// ptr has to be pointed where pAux is, for the next beginMkr and its new pSrcPhrase
							ptr = pAux;

							itemLen = 0; // whm 12Jan2024 added

							// Now we must add pSrcPhrase to the pList, m_pSourcePhrases
							pList->Append(pSrcPhrase);
							AdjustSequNumbers(0, pList); // ensure correct sequence numbers

							// whm 12Jan2024 added. If the current marker is at pEnd, control should go to finishup
							if (ptr >= pEnd)
							{
								bComingFromInnerMarkerLoop = TRUE;
								goto finishup;
							}

#if defined (_DEBUG)
							{
								wxString ptrAt;
								ptrAt = wxString(ptr, 20);
								wxLogDebug(_T("TokText() EMPTY MKRS LOOP, line %d, sn= %d, Appending %s, m_markers= [%s], ptr-> [%s]"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_chapterVerse.c_str(),pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 177)
								{
									int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
								}
							}
#endif
						//} // end of TRUE block for test: if (bIsEmptyMkr == TRUE)
						
						// whm 17Jan2024 removed. The empty markers block is only entered when bIsEmptyMkr is TRUE
						else
						{
							// bIsEmptyMkr is FALSE, control should not stay in in the empty
							// markers parsing loop
							bExitEmptyMkrsLoop = TRUE;
							bProcessEmptyMarker = FALSE;
							//ptr += itemLen; // BEW 21Aug23, I forgot to update it, what went into m_markers was itemLen + 1,
							//				// so itemLen is how much to increase ptr
#if defined (_DEBUG)
							{
								wxString ptrAt;
								ptrAt = wxString(ptr, 20);
								wxLogDebug(_T("TokText() LEAVING EMPTY MKRS LOOP, line %d, sn= %d, m_markers= [%s], ptr-> [%s]"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
								}
							}
#endif
							// BEW 19Aug23 better than break, send control to parsing; label, as the marker has content
							// and so ParsePreWord() and then ParseWord() can do their thing
							//
							// whm 12Jan2024 modification. No, for a verse marker with text content, it needs to be
							// processed by IsVerseMarker(), so break out of this inner while loop of the empty marker
							// block, in order for the verse marker to get proper parsing.
							//goto parsing;
							break; // leave the loop
						} // end of else block for test: if (bIsEmptyMkr == TRUE)
						

					} // end of else block for test: if (atMkr == verseMkr)
					
					// BEW 16Aug23, rather than nesting using "else if" blocks, and because the mkr can be
					// determined quickly, I think it's simpler to use a sequence of if() tests (at least
					// for the commonly occurring ones, \c, \p, \s or \s1, \q or \q1 or \q2 or \q3 )
					//
					// whm 12Jan2024 observation and modification. 
					// Observation: Previously a chapter marker \c n will only be encountered within this 
					// empty markers loop if a previous empty marker was encountered that started entry 
					// into this loop.
					// That previous empty marker triggered the creation of an empty source phrase and that
					// empty source phrase contains its marker within its m_markers member. Therefore there 
					// should be no m_markers content carried over to this chapter marker block here. That's
					// the reason there is no tokBuffer in use within this empty markers while loop.
					// However, I think we may well need one here since here we are encountering a chapter
					// marker \c n. The modification I think should be to parse through the chapter marker
					// and its following number, and carry it over via something like the tokBuffer for the
					// chapter marker to be stored on the next empty marker, or (should there not be an 
					// empty marker and we break out of this loop - the chapter marker should be stored on
					// the next source phrase created outside this loop.
					// The Reasoning:
					// I think a chapter \c n marker should never be considered an empty marker, and in any
					// case it should not trigger the creation of a new pSrcPhrase. It is always accumulated
					// into the m_markers of the next successive source phrase during parsing.
					// 
					// whm 17Jan2024 UPDATE: I'm removing the inner while loop and only dealing with one
					// marker at a time here within the if (bEnterEntryMkrsLoop) empty markers TRUE block.
					// This change will mean that the chapter marker will only be dealt with in the main
					// body of TokenizeText() and never within this empty markers block.
					if (atMkr == chapterMkr)
					{
						int break_here = 0; wxUnusedVar(break_here);
						// whm 12Jan2024 modified to not create a new source phrase for the chapter maker
						// just parse it and store the chapter marker within tokBuffer.

						// Note: The nWhitesLen returned in the IsEmptyMkr() call below will be the span of 
						// whites following the marker at ptr up to the next backslash or pEnd.
						//int nPeriodsInWhitesLen = 0;
						//bIsEmptyMkr = IsEmptyMkr(ptr, nWhitesLen, pEnd, nPeriodsInWhitesLen);
						// whm TODO: process any periods found in nPeriodsInWhitesLen in above call
											
						// bIsEmptyMkr is TRUE if between pAux and the next backslash (or pEnd) there is 
						// only whitespace, eg. newline before backslash or <space>newline before backslash
						// \c is always a contentless marker
						// 
						// whm 17Jan2024 removed test. This empty markers code block is now only entered 
						// when bIsEmptyMkr is TRUE and bIsToBeFiltered is FALSE.
						//if (bIsEmptyMkr == TRUE)
						//{
							// whm 12Jan2024 modified to not create a new source phrase for the chapter maker
							// just parse it and store the chapter marker within tokBuffer.
							pAux = ptr; // protect ptr location
							int nTotMkrLen = 0; // accumulate sub-lengths in this
							itemLen = 0;
							itemLen = nMkrLen; // length of the "\\c" part of chapter marker
							nTotMkrLen += itemLen;
							pAux += itemLen;
							// Get to the chapter number
							itemLen = ParseWhiteSpace(pAux); // parse the shitespace before chapter number
							nTotMkrLen += itemLen;
							pAux += itemLen;
							itemLen = ParseNumber(pAux); // parse the number n of the \c n marker
							chapterNumLen = itemLen;
							strChapterNum = wxString(pAux, chapterNumLen); // make the chapter number n into a string
							nTotMkrLen += itemLen;
							pAux += itemLen; // pAux now points just past the n of the \c n marker
							// Calculate the string to be stored in pSrcPhrase->m_markers
							// We leave any periods out of the construction of the str_m_markers_store
							// by reducing the length calculation by the nPeriodsInWhitesLen value in
							// the statement below.
							str_m_markers_store = wxString(ptr, nTotMkrLen + nEmptyWhitesFollowingMkr - nEmptyMkrPeriodsInWhitesLen); // Include the whitespace after chapterNum

#if defined(_DEBUG)
							if (pSrcPhrase->m_nSequNumber >= 134)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
#endif
							// whm 12Jan2024 removed the creation of a new source phrase from this chapter 
							// parsing block. The chapter marker gets stored on a following pSrcPhrase via
							// the tokBuffer assignment below.
							
							// Set the App's m_curChapter data for use in following parsed verses
							pApp->m_curChapter = strChapterNum;
							pApp->m_curChapter += _T(':');  // e.g. only get ready the "1:" part of "1:<versNum>"

							tokBuffer.Empty(); // need to initialize this upon encountering a chapter marker within this loop
							tokBuffer = str_m_markers_store; // to carry the chapter marker to the next source phrase that is created

							// whm 12Jan2024 the following assignments to pSrcPhrase members are delayed until the
							// next new pSrcPhrase is created. The chapter marker and chapter-related settings are
							// assigned there, since we haven't created a separate source phrase just for the chapter 
							// marker.
							//pSrcPhrase->m_chapterVerse = pApp->m_curChapter; // was set to n: form
							//pSrcPhrase->m_bChapter = TRUE;
							// don't set m_inform here, it causes doubling up
							//pSrcPhrase->m_markers = str_m_markers_store; // BEW 18Aug23 not append, just assign to avoid accumulating

							// Advance pAux to point at the backslash that follows
							pAux += nWhitesLen; // get value returned from IsEmptyMkr(pAux, nWhitesLen, pEnd) above

							// ptr has to be pointed there too, for the next beginMkr and its new pSrcPhrase
							ptr = pAux;

							itemLen = 0; // whm 12Jan2024 added

							// whm 12Jan2024 removed the creation of a new source phrase from this chapter parsing 
							// block
							// 
							// Now we must add pSrcPhrase to the pList, m_pSourcePhrases
							//pList->Append(pSrcPhrase);
							//AdjustSequNumbers(0, pList); // ensure correct sequence numbers

							// [BEW comment] I think, for \c, which is always contentless but never has 
							// following words, the best thing here would be continue
							// 
							// whm 12Jan2024 note: The tokBuffer will have the chapter number
							// TODO: check that it gets processed at the next source phrase creation
							// either here within the empty markers while loop, or back in the parsing section
							// of TokenizeText().
							continue; // stay in the loop for working on the (new) pSrcPhrase to be created now
						//} // end of TRUE block for test: if (bIsEmptyMkr == TRUE)
						
						// whm 17Jan2024 removed. The empty markers block is only entered when bIsEmptyMkr is TRUE
						else
						{
							// bIsEmptyMkr is FALSE, should not happen for \c, we want to stay in the loop
							bExitEmptyMkrsLoop = FALSE;
							bProcessEmptyMarker = FALSE;
#if defined (_DEBUG)
							{
								wxString ptrAt;
								ptrAt = wxString(ptr, 20);
								wxLogDebug(_T("TokText() \\c NOT LEAVING EMPTY MKRS LOOP, line %d, sn= %d, m_markers= [%s], ptr-> [%s]"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 4)
								{
									int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
								}
							}
#endif
						} // end of else block for test: if (bIsEmptyMkr == TRUE)
						

					} // end of TRUE block for test: if (atMkr == chapterMkr)

					// \p is frequent, and commonly empty, so do this next
					if (atMkr == paragraphMkr)
					{
						// whm 12Jan2024 observation and modifications
						// Here within the inner while loop of the bProcessEmptyMarker, successive iterations
						// need to check whether the current marker encountered within the loop are "empty"
						// or not, and if empty, a new CSourcePhrase needs to be created. The old code,
						// however, created a new CSourcePhrase BEFORE it was determined whether the newly
						// encountered marker was empty or not. This could result in an un-initialized
						// pSrcPhrase at the end of a parsed file that can cause crashes in the code there.
						// I think it would be better to call a slightly modified IsEmptyMkr() function BEFORE 
						// creating the new CSourcePhrase, and so we're only create the new CSourcePhrase when 
						// actually needed. 
						// So, we'll call IsEmptyMkr() here.
						// Note: The nWhitesLen returned in the IsEmptyMkr() call below will be the span of 
						// whites following the marker at ptr up to the next backslash or pEnd.
						//int nPeriodsInWhitesLen = 0;
						//bIsEmptyMkr = IsEmptyMkr(ptr, nWhitesLen, pEnd, nPeriodsInWhitesLen);
						// whm TODO: process any periods found in nPeriodsInWhitesLen in above call

						// whm 17Jan2024 removed test. This empty markers code block is now only entered 
						// when bIsEmptyMkr is TRUE and bIsToBeFiltered is FALSE.
						//if (bIsEmptyMkr == TRUE)
						//{
							pAux = ptr; // protect ptr location
							itemLen = 0; // accumulate sub-lengths in this
							pAux += nMkrLen;
							itemLen += nMkrLen; // adds 2 for \p
							// Calculate the string to be stored in pSrcPhrase->m_markers
							// We leave any periods out of the construction of the str_m_markers_store
							// by reducing the length calculation by the nPeriodsInWhitesLen value in
							// the statement below.

							// whm 17Jan2024 TODO: Since the nEmptyWhitesFollowingMkr is determined before we
							// enter into the if (bProcessEmptyMarker) TRUE block, and we are using
							// the nEmptyWhitesFollowingMkr value which has already been determined by the 
							// IsEmptyMkr() call before the head of this block, we don't need to
							// do the parsing above which determines the itemLen, we just need to
							// deal with any adjustments needed when bogus periods are present as 
							// indicated in a non-zero value in nEmptyMkrPeriodsInWhitesLen.
							str_m_markers_store = wxString(ptr, nMkrLen + nEmptyWhitesFollowingMkr - nEmptyMkrPeriodsInWhitesLen); // Include the whitespace after \p (often newline)
								
							// whm 12Jan2024 added. The code in TokenizeText() after the finishup: label has
							// an if (pLastSrcPhrase != NULL) which runs for over 400 lines and attempts to 
							// correctly propagate type changes, etc. It depends on an updated pLastSrcPhrase
							// pointer, so we must update pLastSrcPhrase here before creating a new pSrcPhrase
							// below.
							pLastSrcPhrase = pSrcPhrase;

							// The current pSrcPhrase is about to be done. But pSrcPhrase here in the alternate
							// parsing loop does not yet exist - we've got to create a new one on the heap,
							// which can be appended to pList
							sequNumber = pList->GetCount(); // we are working at end of what's been parsed so far
							pSrcPhrase = new CSourcePhrase; // index number is always 1 less than the count
															// so count value is sequNum for the new pSrcPhrase
							pSrcPhrase->m_nSequNumber = sequNumber;

#if defined(_DEBUG)
							if (pSrcPhrase->m_nSequNumber >= 134)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
#endif

							// Set GUI important values on pSrcPhrase (current)
							pSrcPhrase->m_inform = _T("paragraph"); // what we'd get if we did LookupSFM()
							pSrcPhrase->m_bSpecialText = FALSE; // causes blue
							pSrcPhrase->m_curTextType = verse;

							// whm 12Jan2024 added
							if (!tokBuffer.IsEmpty())
							{
								// The info in the tokBuffer here in the empty markers loop would only be
								// a chapter marker from the \c chapter processing block here in the loop.
								// We need to save the chapter marker here on this non-chapter non-verse 
								// empty source phrase. We also need to process the chapter info here.
								pSrcPhrase->m_chapterVerse = pApp->m_curChapter; // was set to n: form
								pSrcPhrase->m_bChapter = TRUE;
								// chapter marker in tokBuffer here gets prefixed to content in str_m_markers_store
								str_m_markers_store = tokBuffer + str_m_markers_store;
								// must empty the tokBuffer now
								tokBuffer.Empty();
							}

							// Store \p and the whitespace following it, in m_markers
							pSrcPhrase->m_markers = str_m_markers_store; // BEW 18Aug23 not append, just assign to avoid accumulating

							// Advance pAux to point at the backslash (or pEnd) that follows
							pAux += nWhitesLen; // augment pAux by the value returned from IsEmptyMkr(pAux, nWhitesLen, pEnd) above

							// ptr has to also be pointed where pAux is, for the next beginMkr and its new pSrcPhrase
							ptr = pAux;

							itemLen = 0; // whm 12Jan2024 added

							// Now we must add pSrcPhrase to the pList, m_pSourcePhrases
							pList->Append(pSrcPhrase);
							AdjustSequNumbers(0, pList); // ensure correct sequence numbers 

							// whm 12Jan2024 added. If the current marker is at pEnd, control should go to finishup
							if (ptr >= pEnd)
							{
								bComingFromInnerMarkerLoop = TRUE;
								goto finishup;
							}

						//} // end of TRUE block for test: if (bIsEmptyMkr == TRUE)
						
						// whm 17Jan2024 removed. The empty markers block is only entered when bIsEmptyMkr is TRUE
						else
						{
							// bIsEmptyMkr is FALSE, so probably words, rather than backslash, is at ptr
							// so need to leave the contentless mkrs parsing loop
							bExitEmptyMkrsLoop = TRUE;
							bProcessEmptyMarker = FALSE;
#if defined (_DEBUG)
							{
								wxString ptrAt;
								ptrAt = wxString(ptr, 20);
								wxLogDebug(_T("TokText() LEAVING EMPTY MKRS LOOP, line %d, sn= %d, m_markers= [%s], ptrAt= [%s]"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 177)
								{
									int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
								}
							}
#endif
							// BEW 19Aug23 better than break, send control to parsing; label, as the marker has content
							// and so ParsePreWord() and then ParseWord() can do their thing
							goto parsing;

						} // end of else block for test: if (bIsEmptyMkr == TRUE)
						

					} // end of the TRUE block for test: if (atMkr == paragraphMkr)

					// Next, \s or \s1 is common, handle these. Different lengths, so work out
					// nMkrLen here first, and the navText value
					wxString navText = wxEmptyString; // init
					if (atMkr == subtitleOne)
					{
						nMkrLen = 3;
						navText = _T("sect head L1");
					}
					else if (atMkr == subtitle)
					{
						nMkrLen = 2;
						navText = _T("sect head");
					}
					if (atMkr == subtitleOne || atMkr == subtitle)
					{
						// whm 12Jan2024 observation and modifications
						// Here within the inner while loop of the bProcessEmptyMarker, successive iterations
						// need to check whether the current marker encountered within the loop are "empty"
						// or not, and if empty, a new CSourcePhrase needs to be created. The old code,
						// however, created a new CSourcePhrase BEFORE it was determined whether the newly
						// encountered marker was empty or not. This could result in an un-initialized
						// pSrcPhrase at the end of a parsed file that can cause crashes in the code there.
						// I think it would be better to call a slightly modified IsEmptyMkr() function BEFORE 
						// creating the new CSourcePhrase, and so we're only create the new CSourcePhrase when 
						// actually needed. 
						// So, we'll call IsEmptyMkr() here.
						// Note: The nWhitesLen returned in the IsEmptyMkr() call below will be the span of 
						// whites following the marker at ptr up to the next backslash or pEnd.
						//int nPeriodsInWhitesLen = 0;
						//bIsEmptyMkr = IsEmptyMkr(ptr, nWhitesLen, pEnd, nPeriodsInWhitesLen);
						// whm TODO: process any periods found in nPeriodsInWhitesLen in above call

						//if (bIsEmptyMkr == TRUE)
						//{
							pAux = ptr; // protect ptr location
							itemLen = 0; // accumulate sub-lengths in this
							pAux += nMkrLen;
							itemLen += nMkrLen; // adds 2 or 3 for \s or \s1
							// Calculate the string to be stored in pSrcPhrase->m_markers
							// We leave any periods out of the construction of the str_m_markers_store
							// by reducing the length calculation by the nPeriodsInWhitesLen value in
							// the statement below.

							// whm 17Jan2024 TODO: Since the nEmptyWhitesFollowingMkr is determined before we
							// enter into the if (bProcessEmptyMarker) TRUE block, and we are using
							// the nEmptyWhitesFollowingMkr value which has already been determined by the 
							// IsEmptyMkr() call before the head of this block, we don't need to
							// do the parsing above which determines the itemLen, we just need to
							// deal with any adjustments needed when bogus periods are present as 
							// indicated in a non-zero value in nEmptyMkrPeriodsInWhitesLen.
							str_m_markers_store = wxString(ptr, nMkrLen + nEmptyWhitesFollowingMkr - nEmptyMkrPeriodsInWhitesLen); // Include the whitespace after \s1 or \s (often newline)
								
							// whm 12Jan2024 added. The code in TokenizeText() after the finishup: label has
							// an if (pLastSrcPhrase != NULL) which runs for over 400 lines and attempts to 
							// correctly propagate type changes, etc. It depends on an updated pLastSrcPhrase
							// pointer, so we must update pLastSrcPhrase here before creating a new pSrcPhrase
							// below.
							pLastSrcPhrase = pSrcPhrase;

							// The current pSrcPhrase is about to be done. But pSrcPhrase in the alternate
							// parsing loop does not yet exist - we've got to create a new one on the heap,
							// which can be appended to pList
							sequNumber = pList->GetCount(); // we are working at end of what's been parsed so far
							pSrcPhrase = new CSourcePhrase; // index number is always 1 less than the count
															// so count value is sequNum for the new pSrcPhrase
							pSrcPhrase->m_nSequNumber = sequNumber;

#if defined(_DEBUG)
							if (pSrcPhrase->m_nSequNumber >= 134)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
#endif

							pSrcPhrase->m_inform = navText; // what we'd get if we did LookupSFM()

							// whm 12Jan2024 added
							if (!tokBuffer.IsEmpty())
							{
								// The info in the tokBuffer here in the empty markers loop would only be
								// a chapter marker from the \c chapter processing block here in the loop.
								// We need to save the chapter marker here on this non-chapter non-verse 
								// empty source phrase. We also need to process the chapter info here.
								pSrcPhrase->m_chapterVerse = pApp->m_curChapter; // was set to n: form
								pSrcPhrase->m_bChapter = TRUE;
								// chapter marker in tokBuffer here gets prefixed to content in str_m_markers_store
								str_m_markers_store = tokBuffer + str_m_markers_store;
								// must empty the tokBuffer now
								tokBuffer.Empty();
							}

							// Store beginMkr and the whitespace following it, in m_markers
							pSrcPhrase->m_markers = str_m_markers_store; // BEW 18Aug23 not append, just assign to avoid accumulating
							// \s1 and \s are subheading mkrs, so are "special text"
							pSrcPhrase->m_bSpecialText = TRUE; // causes red
							pSrcPhrase->m_curTextType = noType;

							// Advance pAux to point at the backslash that follows
							pAux += nWhitesLen; // get value returned from IsEmptyMkr(pAux, nWhitesLen, pEnd)
												// above (it might be more than one whitespace - though unlikely)

							// ptr has to also be pointed where pAux is, for the next beginMkr and its new pSrcPhrase
							ptr = pAux;

							itemLen = 0; // whm 12Jan2024 added

							// Now we must add pSrcPhrase to the pList, m_pSourcePhrases
							pList->Append(pSrcPhrase);
							AdjustSequNumbers(0, pList); // ensure correct sequence numbers 

							// whm 12Jan2024 added. If the current marker is at pEnd, control should go to finishup
							if (ptr >= pEnd)
							{
								bComingFromInnerMarkerLoop = TRUE;
								goto finishup;
							}

						//} // end of TRUE block for test: if (bIsEmptyMkr == TRUE)
						
						
						else
						{
							// probably something parseable follows the mkr, so exit loop
							bExitEmptyMkrsLoop = TRUE;
							bProcessEmptyMarker = FALSE;
#if defined (_DEBUG)
							{
								wxString ptrAt;
								ptrAt = wxString(ptr, 20);
								wxLogDebug(_T("TokText() LEAVING EMPTY MKRS LOOP, line %d, sn= %d, m_markers= [%s], ptrAt= [%s]"),
									__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
								}
							}
#endif
							// BEW 19Aug23 better than break, send control to parsing; label, as the marker has content
							// and so ParsePreWord() and then ParseWord() can do their thing
							goto parsing;

						}
						

					} // end of TRUE block for test: if (atMkr == subtitleOne || atMkr == subtitle)

					if (ptr < pEnd && *ptr == gSFescapechar && atMkr.GetChar(1) == _T('q'))
					{
#if defined (_DEBUG)
						{
							wxString ptrAt;
							ptrAt = wxString(ptr, 20);
							wxLogDebug(_T("TokText() QUOTES in LOOP, line %d, sn= %d, m_markers= [%s], ptrAt= [%s]"),
								__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 6)
							{
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
						}
#endif
						// if there's space and at ptr there is \q type of marker (there are about 17 in
						// the fast-access set m _poetryTypeMkrs), then handle any of these. \q is the only 
						// one of length 2, many are length 3 (including \q1, \q2 which are common) and
						// some are length 3. All have textType 2, which is 'poetry' enum, and navText
						// for pSrcPhase->m_inform, such as "poetry" of "poetry L1" for \q1, or "poetry L2"
						// for \q2, etc. Because there is not just one textType, we must use LookupSfm()
						// to get a pSfmAnalysis struct to get the correct textType.
						USFMAnalysis* pUsfmAnalysis = LookupSFM(mkrTag);
						if (pUsfmAnalysis != NULL)
						{
							// whm 12Jan2024 observation and modifications
							// Here within the inner while loop of the bProcessEmptyMarker, successive iterations
							// need to check whether the current marker encountered within the loop are "empty"
							// or not, and if empty, a new CSourcePhrase needs to be created. The old code,
							// however, created a new CSourcePhrase BEFORE it was determined whether the newly
							// encountered marker was empty or not. This could result in an un-initialized
							// pSrcPhrase at the end of a parsed file that can cause crashes in the code there.
							// I think it would be better to call a slightly modified IsEmptyMkr() function BEFORE 
							// creating the new CSourcePhrase, and so we're only create the new CSourcePhrase when 
							// actually needed. 
							// So, we'll call IsEmptyMkr() here.
							// Note: The nWhitesLen returned in the IsEmptyMkr() call below will be the span of 
							// whites following the marker at ptr up to the next backslash or pEnd.
							//int nPeriodsInWhitesLen = 0;
							//bIsEmptyMkr = IsEmptyMkr(ptr, nWhitesLen, pEnd, nPeriodsInWhitesLen);
							// whm TODO: process any periods found in nPeriodsInWhitesLen in above call

							//if (bIsEmptyMkr == TRUE)
							//{
								// Values needed for when we define a new pSrcPhrase instance:
								navText = pUsfmAnalysis->navigationText;

								pAux = ptr; // protect ptr location
								itemLen = 0; // accumulate sub-lengths in this
								pAux += nMkrLen; // could be 2,3,or 4, leaving pAux pointing past mkr's tag
								itemLen += nMkrLen;
								// Calculate the string to be stored in pSrcPhrase->m_markers
								// We leave any periods out of the construction of the str_m_markers_store
								// by reducing the length calculation by the nPeriodsInWhitesLen value in
								// the statement below.
								str_m_markers_store = wxString(ptr, nMkrLen + nEmptyWhitesFollowingMkr - nEmptyMkrPeriodsInWhitesLen); // Include the whitespace after the poetry mkr

								// whm 12Jan2024 added. The code in TokenizeText() after the finishup: label has
								// an if (pLastSrcPhrase != NULL) which runs for over 400 lines and attempts to 
								// correctly propagate type changes, etc. It depends on an updated pLastSrcPhrase
								// pointer, so we must update pLastSrcPhrase here before creating a new pSrcPhrase
								// below.
								pLastSrcPhrase = pSrcPhrase;

								// Filling out pSrcPhrase, and calculating m_inform, and storing mkr
								// in current pSrcPhrase is about to be done. But pSrcPhrase in the alternate
								// parsing loop does not yet exist - we've got to create a new one on the heap,
								// which can be appended to pList
								sequNumber = pList->GetCount(); // we are working at end of what's been parsed so far
								pSrcPhrase = new CSourcePhrase; // index number is always 1 less than the count
																// so count value is sequNum for the new pSrcPhrase
								pSrcPhrase->m_nSequNumber = sequNumber;

#if defined(_DEBUG)
								if (pSrcPhrase->m_nSequNumber >= 134)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
#endif
								// Now we are ready to check if the \s or \s1 marker is empty or not
								
								pSrcPhrase->m_inform = navText; // what we'd get if we did LookupSFM()

								// whm 12Jan2024 added
								if (!tokBuffer.IsEmpty())
								{
									// The info in the tokBuffer here in the empty markers loop would only be
									// a chapter marker from the \c chapter processing block here in the loop.
									// We need to save the chapter marker here on this non-chapter non-verse 
									// empty source phrase. We also need to process the chapter info here.
									pSrcPhrase->m_chapterVerse = pApp->m_curChapter; // was set to n: form
									pSrcPhrase->m_bChapter = TRUE;
									// chapter marker in tokBuffer here gets prefixed to content in str_m_markers_store
									str_m_markers_store = tokBuffer + str_m_markers_store;
									// must empty the tokBuffer now
									tokBuffer.Empty();
								}

								// Store beginMkr and the whitespace following it, in m_markers
								pSrcPhrase->m_markers = str_m_markers_store; // BEW 18Aug23 not append, just assign to avoid accumulating
								// \q, ]q1, ]q2 etc are 'poetry' text, textType 2, equivalent to 'verse' which is textType 1
								pSrcPhrase->m_bSpecialText = FALSE; //
								pSrcPhrase->m_curTextType = poetry;

								// Advance pAux to point at the backslash that follows
								pAux += nWhitesLen; // get value returned from IsEmptyMkr(pAux, nWhitesLen, pEnd)
													// above (it might be more than one whitespace - though unlikely)
								// itemLen holds the span comprising all the bits parsed

								// ptr has to also be pointed where pAux is, for the next beginMkr and its new pSrcPhrase
								ptr = pAux;

								itemLen = 0; // whm 12Jan2024 added

								// Now we must add pSrcPhrase to the pList, m_pSourcePhrases
								pList->Append(pSrcPhrase);
								AdjustSequNumbers(0, pList); // ensure correct sequence numbers 
															 // (not necesary but good insurance)
								// whm 12Jan2024 added. If the current marker is at pEnd, control should go to finishup
								if (ptr >= pEnd)
								{
									bComingFromInnerMarkerLoop = TRUE;
									goto finishup;
								}

							//} // end of TRUE block for test: if (bIsEmptyMkr == TRUE)
							
							
							else
							{
								// probably something parseable follows the mkr, so exit loop
								bExitEmptyMkrsLoop = TRUE;
								bProcessEmptyMarker = FALSE;
#if defined (_DEBUG)
								{
									wxString ptrAt;
									ptrAt = wxString(ptr, 20);
									wxLogDebug(_T("TokText() LEAVING EMPTY MKRS LOOP, line %d, sn= %d, m_markers= [%s], ptrAt= [%s]"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 4)
									{
										int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
									}
								}
#endif
								// BEW 19Aug23 better than break, send control to parsing; label, as the marker has content
								// and so ParsePreWord() and then ParseWord() can do their thing
								goto parsing;

							} // end of else block for test: if (bIsEmptyMkr == TRUE)
							

						} // end of TRUE block for test: if (pUsfmAnalysis != NULL)
					} // end of TRUE block for test: if (ptr < pEnd && *ptr == gSFescapechar && atMkr.GetChar(1) == _T('q'))

					// 
					// whm 17Jan2024 TODO: Check if the following block is still needed after eliminating
					// the empty markers while test.
					// 
					// Finally, provide a catch all block for any empty mkr not handled above. Need LookupSFM()
					// to get pUsfmAnalysis struct for access to navText, whether red or not (i.e. m_bSpecialText),
					// textType, and what to show using m_inform. In 43LUKTBIB.SFM, the remaining empty markers are:
					// \ide (encoding) \rem ('comment', textType note) \h \toc1 \toc2 \toc3 \m. Other src docs may have
					// many others in addition - the idea is to catch them all here. Don't allow \v here, as it
					// was handled above for this pSrcPhrase. Nor \c, as like \v it too is followed by a number which
					// must not be parsed as m_key text.
					bVerseOrChaptMkr = FALSE;
					if ( (ptr < pEnd && *ptr == gSFescapechar && !atMkr.IsEmpty() && (atMkr == _T("\\v")) ) || (atMkr == _T("\\c")) )
					{
							bVerseOrChaptMkr = TRUE; // dont' entry TRUE block of next test 
					}
					// BEW 18Aug23 Dissallow entry to the following test's TRUE block if a following mkr is \v or \c
					// - which keeps control within the contentless parsing loop
					if (ptr < pEnd && *ptr == gSFescapechar && !atMkr.IsEmpty() && !bVerseOrChaptMkr)
					{
						// If there's space to work, and at ptr there is a begin marker, then handle all such. 
						// Because there is not just one textType for such a diverse set, we must use LookupSfm()
						// to get a pSfmAnalysis struct to get the correct textType, etc. atMkr has the wholeMkr,
						// nMkrLen has its length, mkrTag has the marker minus the initial gSFescapechar.
						USFMAnalysis* pUsfmAnalysis = LookupSFM(mkrTag); // the "bareMkr" version
						if (pUsfmAnalysis != NULL)
						{
							// whm 12Jan2024 observation and modifications
							// Here within the inner while loop of the bProcessEmptyMarker, successive iterations
							// need to check whether the current marker encountered within the loop are "empty"
							// or not, and if empty, a new CSourcePhrase needs to be created. The old code,
							// however, created a new CSourcePhrase BEFORE it was determined whether the newly
							// encountered marker was empty or not. This could result in an un-initialized
							// pSrcPhrase at the end of a parsed file that can cause crashes in the code there.
							// I think it would be better to call a slightly modified IsEmptyMkr() function BEFORE 
							// creating the new CSourcePhrase, and so we're only create the new CSourcePhrase when 
							// actually needed. 
							// So, we'll call IsEmptyMkr() here.
							// Note: The nWhitesLen returned in the IsEmptyMkr() call below will be the span of 
							// whites following the marker at ptr up to the next backslash or pEnd.
							//int nPeriodsInWhitesLen = 0;
							//bIsEmptyMkr = IsEmptyMkr(ptr, nWhitesLen, pEnd, nPeriodsInWhitesLen);
							// whm TODO: process any periods found in nPeriodsInWhitesLen in above call

							//if (bIsEmptyMkr == TRUE)
							//{
								// Values needed for when we define a new pSrcPhrase instance:
								navText = pUsfmAnalysis->navigationText;
								bool bIsSpecialText = pUsfmAnalysis->special;

								pAux = ptr; // protect ptr location
								itemLen = 0; // accumulate sub-lengths in this
								pAux += nMkrLen; // leaves pAux pointing past mkr's tag
								itemLen += nMkrLen;
								// Calculate the string to be stored in pSrcPhrase->m_markers
								// We leave any periods out of the construction of the str_m_markers_store
								// by reducing the length calculation by the nPeriodsInWhitesLen value in
								// the statement below.
								str_m_markers_store = wxString(ptr, nMkrLen + nEmptyWhitesFollowingMkr - nEmptyMkrPeriodsInWhitesLen); // Include the whitespace after the mkr's tag

								// whm 12Jan2024 added. The code in TokenizeText() after the finishup: label has
								// an if (pLastSrcPhrase != NULL) which runs for over 400 lines and attempts to 
								// correctly propagate type changes, etc. It depends on an updated pLastSrcPhrase
								// pointer, so we must update pLastSrcPhrase here before creating a new pSrcPhrase
								// below.
								pLastSrcPhrase = pSrcPhrase;

								// The current pSrcPhrase is about to be done. But pSrcPhrase in the alternate
								// parsing loop does not yet exist - we've got to create a new one on the heap,
								// which can be appended to pList
								sequNumber = pList->GetCount(); // we are working at end of what's been parsed so far
								pSrcPhrase = new CSourcePhrase; // index number is always 1 less than the count
																// so count value is sequNum for the new pSrcPhrase
								pSrcPhrase->m_nSequNumber = sequNumber;

#if defined(_DEBUG)
								if (pSrcPhrase->m_nSequNumber >= 134)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
#endif
								pSrcPhrase->m_inform = navText; // what we'd get if we did LookupSFM()

								// whm 12Jan2024 added
								if (!tokBuffer.IsEmpty())
								{
									// The info in the tokBuffer here in the empty markers loop would only be
									// a chapter marker from the \c chapter processing block here in the loop.
									// We need to save the chapter marker here on this non-chapter non-verse 
									// empty source phrase. We also need to process the chapter info here.
									pSrcPhrase->m_chapterVerse = pApp->m_curChapter; // was set to n: form
									pSrcPhrase->m_bChapter = TRUE;
									// chapter marker in tokBuffer here gets prefixed to content in str_m_markers_store
									str_m_markers_store = tokBuffer + str_m_markers_store;
									// must empty the tokBuffer now
									tokBuffer.Empty();
								}
								// Store beginMkr and the whitespace following it, in m_markers
								pSrcPhrase->m_markers = str_m_markers_store; // BEW 18Aug23 not append, just assign to avoid accumulating

								pSrcPhrase->m_bSpecialText = bIsSpecialText;
								pSrcPhrase->m_curTextType = pUsfmAnalysis->textType;

								// Advance pAux to point at the backslash that follows
								pAux += nWhitesLen; // get value returned from IsEmptyMkr(pAux, nWhitesLen, pEnd)
													// above (it might be more than one whitespace - though unlikely)
								// itemLen holds the span comprising all the bits parsed

								// ptr has to also be pointed where pAux is, for the next beginMkr and its new pSrcPhrase
								ptr = pAux;

								itemLen = 0; // whm 12Jan2024 added

								// Now we must add pSrcPhrase to the pList, m_pSourcePhrases
								pList->Append(pSrcPhrase);
								AdjustSequNumbers(0, pList); // ensure correct sequence numbers 
															 // (not necesary but good insurance)
								// whm 12Jan2024 added. If the current marker is at pEnd, control should go to finishup
								if (ptr >= pEnd)
								{
									bComingFromInnerMarkerLoop = TRUE;
									goto finishup;
								}

							//} // end of TRUE block for test: if (bIsEmptyMkr == TRUE)
							
							
							else
							{
								// probably something parseable follows the mkr, so exit loop
								bExitEmptyMkrsLoop = TRUE;
								bProcessEmptyMarker = FALSE;
#if defined (_DEBUG)
								{
									wxString ptrAt;
									ptrAt = wxString(ptr, 20);
									wxLogDebug(_T("TokText() LEAVING EMPTY MKRS LOOP, line %d, sn= %d, m_markers= [%s], ptrAt= [%s]"),
										__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), ptrAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 4)
									{
										int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
									}
								}
#endif
							} // end of else block for test: if (bIsEmptyMkr == TRUE)
							

						} // end of TRUE block for test: if (pUsfmAnalysis != NULL)
						// whm 12Jan2024 added. 
						// We have to account for when pUsfmAnalysis is NULL here. If we don't, for example we're looking at an
						// unknown marker such as \yy, the program will get into an infinite loop and not get past ptr pointing 
						// at "\\yy..."
						// An appropriate new pSrcPhrase needs to be created for the empty unknown marker, even when 
						// pUsfmAnalysis is NULL, so I'll copy the appropriate code from the if (pUsfmAnalysis != NULL) block 
						// above and put it in an else block below
						else // whm 12Jan2024 added
						{
							// whm 12Jan2024 observation and modifications
							// Here within the inner while loop of the bProcessEmptyMarker, successive iterations
							// need to check whether the current marker encountered within the loop are "empty"
							// or not, and if empty, a new CSourcePhrase needs to be created. The old code,
							// however, created a new CSourcePhrase BEFORE it was determined whether the newly
							// encountered marker was empty or not. This could result in an un-initialized
							// pSrcPhrase at the end of a parsed file that can cause crashes in the code there.
							// I think it would be better to call a slightly modified IsEmptyMkr() function BEFORE 
							// creating the new CSourcePhrase, and so we're only create the new CSourcePhrase when 
							// actually needed. 
							// So, we'll call IsEmptyMkr() here.
							// Note: The nWhitesLen returned in the IsEmptyMkr() call below will be the span of 
							// whites following the marker at ptr up to the next backslash or pEnd.
							//int nPeriodsInWhitesLen = 0;
							//bIsEmptyMkr = IsEmptyMkr(ptr, nWhitesLen, pEnd, nPeriodsInWhitesLen);
							// whm TODO: process any periods found in nPeriodsInWhitesLen in above call

							//if (bIsEmptyMkr == TRUE)
							//{
								// whm 12Jan2024 note: In this else block pUsfmAnalysis is NULL so we 
								// will set some reasonalbe default values for TextType, navText and 
								// the bIsSpecialText flag
								navText = _T("?") + atMkr + _T("?");
								bool bIsSpecialText = TRUE; // make anyi unknown marker red

								pAux = ptr; // protect ptr location
								itemLen = 0; // accumulate sub-lengths in this
								pAux += nMkrLen; // leaves pAux pointing past mkr's tag
								itemLen += nMkrLen;
								// Calculate the string to be stored in pSrcPhrase->m_markers
								// We leave any periods out of the construction of the str_m_markers_store
								// by reducing the length calculation by the nPeriodsInWhitesLen value in
								// the statement below.
								str_m_markers_store = wxString(ptr, nMkrLen + nEmptyWhitesFollowingMkr - nEmptyMkrPeriodsInWhitesLen); // Include the whitespace after the mkr's tag

								// whm 12Jan2024 added. The code in TokenizeText() after the finishup: label has
								// an if (pLastSrcPhrase != NULL) which runs for over 400 lines and attempts to 
								// correctly propagate type changes, etc. It depends on an updated pLastSrcPhrase
								// pointer, so we must update pLastSrcPhrase here before creating a new pSrcPhrase
								// below.
								pLastSrcPhrase = pSrcPhrase;

								// The current pSrcPhrase is about to be done. But pSrcPhrase in the alternate
								// parsing loop does not yet exist - we've got to create a new one on the heap,
								// which can be appended to pList
								sequNumber = pList->GetCount(); // we are working at end of what's been parsed so far
								pSrcPhrase = new CSourcePhrase; // index number is always 1 less than the count
																// so count value is sequNum for the new pSrcPhrase
								pSrcPhrase->m_nSequNumber = sequNumber;

#if defined(_DEBUG)
								if (pSrcPhrase->m_nSequNumber >= 134)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
#endif
								pSrcPhrase->m_inform = navText; // "?" + atMkr + "?" for an empty unknown marker here

								// whm 12Jan2024 added
								if (!tokBuffer.IsEmpty())
								{
									// The info in the tokBuffer here in the empty markers loop would only be
									// a chapter marker from the \c chapter processing block here in the loop.
									// We need to save the chapter marker here on this non-chapter non-verse 
									// empty source phrase. We also need to process the chapter info here.
									pSrcPhrase->m_chapterVerse = pApp->m_curChapter; // was set to n: form
									pSrcPhrase->m_bChapter = TRUE;
									// chapter marker in tokBuffer here gets prefixed to content in str_m_markers_store
									str_m_markers_store = tokBuffer + str_m_markers_store;
									// must empty the tokBuffer now
									tokBuffer.Empty();
								}
								// Store beginMkr and the whitespace following it, in m_markers
								pSrcPhrase->m_markers = str_m_markers_store; // BEW 18Aug23 not append, just assign to avoid accumulating

								pSrcPhrase->m_bSpecialText = bIsSpecialText;
								pSrcPhrase->m_curTextType = TextTypeEnumValue;

								// Advance pAux to point at the backslash that follows
								pAux += nWhitesLen; // get value returned from IsEmptyMkr(pAux, nWhitesLen, pEnd)
													// above (it might be more than one whitespace - though unlikely)
								// itemLen holds the span comprising all the bits parsed

								// ptr has to also be pointed where pAux is, for the next beginMkr and its new pSrcPhrase
								ptr = pAux; // whm 12Jan2024 Note: Advancing ptr here in else block prevents infinite loop

								itemLen = 0; // whm 12Jan2024 added

								// Now we must add pSrcPhrase to the pList, m_pSourcePhrases
								pList->Append(pSrcPhrase);
								AdjustSequNumbers(0, pList); // ensure correct sequence numbers 
															 // (not necesary but good insurance)
								// whm 12Jan2024 added. If the current marker is at pEnd, control should go to finishup
								if (ptr >= pEnd)
								{
									bComingFromInnerMarkerLoop = TRUE;
									goto finishup;
								}

							//} // end of TRUE block for test: if (bIsEmptyMkr == TRUE)
							
							
							else
							{
								// probably something parseable follows the unknown mkr, so exit loop
								bExitEmptyMkrsLoop = TRUE;
								bProcessEmptyMarker = FALSE;
							} // end of else block for test: if (bIsEmptyMkr == TRUE)
							

						} // end of else block for test: if (pUsfmAnalysis != NULL)

					} // end of TRUE block for test: if (ptr < pEnd && *ptr == gSFescapechar && !atMkr.IsEmpty() && !bVerseOrChaptMkr)
					else
					{
						// Check for bVerseOrChaptMkr TRUE. If so, the verse marker must be parsed, so a continue
						// call is appropriate; same with a chapter mkr
						if (bVerseOrChaptMkr == TRUE)
						{
							continue; // these markers use ParseNumber() to parse over verseNum or chapterNum
						}
						else if (ptr >= pEnd)
						{
							// We are at document end, so break and let legacy code finish the app up
							// (or alternatively, I could do: go to finishup: label - try 2nd option)
							//break:
							bComingFromInnerMarkerLoop = TRUE;
							goto finishup;
						}
						else if (*ptr != gSFescapechar)
						{
							// probably there's something parsable by the legacy code, try goto parsing
							goto parsing;
						}
						else if (atMkr.IsEmpty())
						{
							// No marker findable - probably safest thing is to go to ParseWord()
							goto parsing;
						}
						// if none of these was done, best bet might be to just break from the
						// loop, and see what happens
						break;
					}
					*/

				//} // end of while loop: while (ptr < pEnd && !bExitEmptyMkrsLoop)
//#if defined (_DEBUG)
//			{
//			wxString ptrAt;
//			ptrAt = wxString(ptr, 20);
//			wxLogDebug(_T("TokText() after EMPTY MKRS LOOP, line %d, sn= %d, m_markers= [%s], chapter:verse= [%s], pointsAt= [%s]"),
//				__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_chapterVerse.c_str(), ptrAt.c_str());
//			if (pSrcPhrase->m_nSequNumber >= 714)
//			{
//				int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced // What do we do here on?
//			}
//			}
//#endif

			} // end of TRUE block for test:  if (bProcessEmptyMarker)

			// whm 28Sep203 added next line to reset the m_bWithinEmptyMkrsLoop flag back to FALSE now that we're
			// exiting the empty markers loop. The failure to reset this flag to FALSE was causing havoc within the
			// PlacePhraseBox() function where it was tested there and found to be TRUE at that location which then
			// forced a bypass of the DoGetSuitableText_ForPlacePhraseBox() call. This I believe was causing the 
			// phrasebox to be prematurely emptied when control there got to the the following line:
			// a: pApp->m_targetPhrase = str;
			// where str would be an empty string due to the DoGetSuitableText_ForPlacePhraseBox() call being bypassed
			// Note: I can't really understand why the test for m_bWithinEmptyMkrsLoop was being made within the
			// PlacePhraseBox() function, and may decide to remove that test there as being unlikely to ever be 
			// pertinent to what happens in PlacePhraseBox(). But, in the meantime, at least resetting the 
			// m_bWithinEmptyMkrsLoop to FALSE here should prevent the test in PlacePhraseBox() from causing the
			// phrasebox to be prematurely emptied when clicking the phrasebox to certain locations.
			m_bWithinEmptyMkrsLoop = FALSE;

			// BEW 14Aug23 comment: legacy parsing code for markers having content starts here
			// Put here chapter mkr test block first, so that pApp->m_curChapter 
			// can get a value before testing for verse mkr
			if (IsChapterMarker(ptr))
			{
#if defined (_DEBUG) && !defined (NOLOGS)
				{
					wxString strPointAt = wxString(ptr, 16);
					wxLogDebug(_T("TokText() line  %d , starting IsChapterMkr TRUE block , chapter:verse= [%s], strPointAt= [%s]"),
						__LINE__, pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
					}
				}
#endif

				// it's a chapter marker
				tokBuffer << gSFescapechar;
				tokBuffer << _T("c");
				ptr += 2; // point past the \c marker

				itemLen = ParseWhiteSpace(ptr);
				AppendItem(tokBuffer, temp, ptr, itemLen); // add white space to buffer
				ptr += itemLen; // point at chapter number

				itemLen = ParseNumber(ptr);
				AppendItem(tokBuffer, temp, ptr, itemLen); // add chapter number to buffer
				pApp->m_curChapter = temp;

				// Track the chapter if logging is wanted
				if (pApp->m_bMakeDocCreationLogfile) // turn this ON in docPage of the Wizard or the GetSourceTextFromEditor dialog
				{
					if (pApp->m_bParsingSource)
					{
						pApp->m_chapterNumber_for_ParsingSource = pApp->m_curChapter;
					}
				}

				pApp->m_curChapter += _T(':'); // get it ready to append verse numbers
				ptr += itemLen; // point past chapter number

				// set pSrcPhrase attributes
				pSrcPhrase->m_bChapter = TRUE;

				itemLen = ParseWhiteSpace(ptr); // parse white space following the number
				AppendItem(tokBuffer, temp, ptr, itemLen); // add it to buffer
				ptr += itemLen; // point past it
#if defined (_DEBUG) && !defined (NOLOGS)
				{
					wxString strPointAt = wxString(ptr, 16);
					wxLogDebug(_T("TokText() line  %d , m_markers= [%s] , m_curChapter= [%s] , chapter:verse= [%s], pointsAt= [%s]"),
						__LINE__, pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
				// BEW 14Apr23, the contents of tokBuffer will get lost in the continuation
				// if no verse or chapter marker follows. If it's \s next, then control goes
				// to LookupSFM() and the code after that makes no use of tokBuffer, and then
				// what goes into m_marker would be the \s, and control moves on to ParsePreWord()
				// etc. So I need to check for tokBuffer non-empty here, and if so, then
				// append to m_markers, clear tokBuffer, and only then can continue be called
				if (!tokBuffer.IsEmpty())
				{
					pSrcPhrase->m_markers += tokBuffer;
#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokText() line  %d , tokBuffer sets m_markers= [%s], ITERATES, chapter:verse= [%s], pointsAt= [%s]"),
							__LINE__, pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
					tokBuffer.Empty();
				}
				continue; // iterate inner loop to check if another marker follows - 3rd continue in TokenizeText()

			}  // end of TRUE block for test: else if (IsChapterMarker(ptr))
			else
			{
				bIsFreeTransOrNoteOrBackTrans = FALSE; // clear before checking which marker it is
				bIsForeignBackTrans = FALSE;
				bIsInlineNonbindingMkr = FALSE; // ensure it is initialized
				bIsInlineBindingMkr = FALSE; // ensure it is initialized

				//	wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"),__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
				// BEW 11JUn23 added next bool
				bool bIsVerseMkrParsed;
				bIsVerseMkrParsed = FALSE; // init  --set TRUE if, later, we parse a \v marker

				int nMkrLen = 0;
				wxString aWholeMkr;
				// its a marker of some kind
				aWholeMkr = wxEmptyString;
				int awholemkrlen;
				awholemkrlen = 0;
				int offset;
				offset = wxNOT_FOUND;
				offset = offset; // avoid gcc warning set but not used warning
				int nWhiteLen;
				nWhiteLen = 0;
				wxString strWhites;
				strWhites = wxEmptyString;

#ifdef _DEBUG
				{
					wxString strPointAt = wxString(ptr, 16);
					//wxLogDebug(_T("TokTxt() line  %d , m_markers= [%s] , m_curChapter= [%s] , chapter:verse= [%s], pointsAt= [%s]  Inner loop before while "),
//						__LINE__, pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif

				// BEW 1Jul23 The ! before IsRedOrBindingOrNonbindingBeginMkr(ptr, pEnd) subtest is critical.
				// if not present, this loop is entered and it takes the ptr forward, and the test after the
				// loop (which tests if ptr is a verse marker) gets skipped - which results in m_chaptVerse
				// not geting a chance to be set, for showing in the nav whiteboard area of the GUI
				while (ptr < pEnd && *ptr == gSFescapechar && !IsRedOrBindingOrNonbindingBeginMkr(ptr, pEnd))
				{
					bool bIsBeginMkr;
					bool bIsEndMkr;
					bool bAttrMkr; wxUnusedVar(bAttrMkr); // avoid compiler warning variable initialized but not referenced
					wxString anAugBeginMkr;
					awholemkrlen = ParseMarker(ptr);
					aWholeMkr = wxString(ptr, awholemkrlen);
					anAugBeginMkr = aWholeMkr + _T(' ');
#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokTxt() line  %d , m_markers= [%s] , m_curChapter= [%s] , m_inform= [%s], pointsAt= [%s]  Loop (Red or Nonbinding)"),
							__LINE__, pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), pSrcPhrase->m_inform.c_str(), strPointAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
					bIsBeginMkr = IsBeginMarker(ptr, pEnd, aWholeMkr, bIsEndMkr);
					if (!bIsBeginMkr)
					{
						break; // BEW added 1Jul23, as the data: ptr pointing at \fk* was causing an infinite loop - 2nd break in TokenizeText
					}
					// If the first is a beginMkr, and subsequent ones also will be
					if (bIsBeginMkr == TRUE && !bIsEndMkr)
					{
						int offset;
						offset = -1;

						// BEW 22Aug23 if a filterable marker, to be filtered, is in aWholeMkr (e.g \x ) after
						// a \v marker, we need to get control out of this loop here, because following is the
						// loop for IsVerseMarker(), and \x not being \v, control will then go to the place 
						// where LookupSFM() is done - it will then be recognised as filterable and is for filtering
						// and the filtering will get done. If we don't break here, the \x will get swallowed by
						// ParsePreWord() which works to prevent a beginMkr (e.g. \x ) from being passed along to
						// ParseWord() to cause a crash at ParseAWord(). So if filtering is needed, do it here.
						// This situation arose in 02EXONYNT.SFM at 4:3 in this line:
						// \v 3 \x - \xo 4.3 \xt \x* Laban .....
						// BEW 23Aug23, refactoring elsewhere has, I think, made this block unnecessary
						// 
						// whm 20Jan2024 BEW's conclusion above that the filtering code block below is
						// unnecessary is NOT accurate. We do need the filtering block here, otherwise some
						// filter markers like the \free ...\free* in the augmented Hezekiah text are missed
						// and without the following block they get treated like regular markers, the \free
						// marker gets stored in m_markers, etc. So, I'm reinstating the block below.

						if (!aWholeMkr.IsEmpty())
						{
							wxString myAugMkr = aWholeMkr + _T(' ');
							// whm 20Jan2024 added check if augWholeMkr is an AI custom marker \free \note 
							// or \bt... marker - which are obligatorily filtered.
							bool bIsForeignBackTransMkr = FALSE;
							bIsToBeFiltered = (pApp->gCurrentFilterMarkers.Find(myAugMkr) != wxNOT_FOUND);
							if (!bIsToBeFiltered)
							{
								bIsToBeFiltered = IsMarkerFreeTransOrNoteOrBackTrans(myAugMkr, bIsForeignBackTransMkr);
							}
							if (bIsToBeFiltered)
							{
#if defined (_DEBUG) //&& !defined (NOLOGS)
								{
									wxString strPointAt = wxString(ptr, 16);
									//wxLogDebug(_T("TokTxt() line  %d , m_markers= [%s] , m_curChapter= [%s] , m_inform= [%s], strPointAt= [%s]  Inner loop BEGINS "),
									//	__LINE__, pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), pSrcPhrase->m_inform.c_str(), strPointAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 451)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
								}
#endif
								itemLen = 0;
								itemLen = ParseFilteringSFM(aWholeMkr, ptr, pBufStart, pEnd);
								wxString temp = wxEmptyString;
								temp = GetFilteredItemBracketed(ptr, itemLen);
								// whm 20Jan2024 corrected. The AddToFilteredInfo should be done
								// to the pLastSrcPhrase and not pSrcPhrase.
								//pSrcPhrase->AddToFilteredInfo(temp);
								pLastSrcPhrase->AddToFilteredInfo(temp);
								ptr += itemLen;
								// whm 20Jan2024 added ParseWhiteSpace() and increment of ptr past white space.
								itemLen = ParseWhiteSpace(ptr);
								// whm 20Jan2024 added storage of word break char after removal of filtered marker.
								// We add the word break to the pSrcPhrase, which is this current one, the one
								// that is after the pLastSrcPhrase where the storage of the filtered marker was 
								// stored.
								if (itemLen > 0)
								{
									precWordDelim = *ptr; // the post-mkr space in swbk needs to be replaced by whatever
									// whitespace char follows the marker
									pSrcPhrase->SetSrcWordBreak(precWordDelim);
									pSrcPhrase->m_precPunct += precWordDelim;
								}
								ptr += itemLen;
								bKeepPtrFromAdvancing = TRUE; // causes ParsePreWord() to be skipped - might help or might not
								break;
							}
						}
						
						// BEW 21Jul23 addition...
						// ptr points to a beginMkr, but the marker belongs to the charAttributeMkrs fast-access
						// string, we must NOT allow ptr to advance in this block. Why? because after the beginMkr
						// and it's following space, there will be a bar ( | ) character which signals data which
						// is to collected up to the matching endMkr which has to be stored in pSrcPhrase's 
						// m_punctsPattern member; and if ptr advances here (by storing the beginMkr), ptr will point
						// at the "|<...content...}\endMkr* which ParseWord() won't then handle, leading 
						// to ParseAWord() asserting (or in release mode, an app infinite loop)
						offset = -1; // init again
						offset = charAttributeMkrs.Find(anAugBeginMkr);
						if (offset >= 0)
						{
							// its one of those in the character attribute markers set, so 
							// break from the while loop without advancing ptr
							break; // 3rd break in TokenizeText()
						}
						// Parse and store beginMkrs, until we get to a \v marker, run out of markers to test
						// Parse each, and its following whitespace (space or \n typically), by appending to
						// tokBuffer
						awholemkrlen = ParseMarker(ptr);
						aWholeMkr = wxString(ptr, awholemkrlen);
						wxString augWholeMkr;
						augWholeMkr = aWholeMkr + _T(' ');
						// BEW 31Jul23 I need to bleed out ptr pointing at a \v marker here. Otherwise, if ..
						// or ... followed by whitespace occurs, dealing with the bogus periods could get
						// the \v mkr lost
						if (aWholeMkr == verseMkr)
						{
							// As far as I know, Paratext does not put bogus period strings (2 or 3) in
							// \v when the source data is contentless; so causing \v to be parsed should
							// be safe (to send control to ParseWord() ) because \v will be followed by
							// a parse-able verse number. Doing break here will send ptr to the block
							// testing if (IsVerseMarker(ptr,&nCount)) which is what we want (I think)
							break; // 4th break in TokenizeText()
						}
						wxChar chPrevious; wxUnusedVar(chPrevious); // avoid compiler warning variable initialized but not referenced
						bool bPrevIsNewline; wxUnusedVar(bPrevIsNewline); // avoid compiler warning variable initialized but not referenced

						// BEW 3Jun23 when seqNum is 0 or small, we may be dealing with \id, \h, \mt, \mt#, \ip etc
						// and these are no inline, not binding, not nonnbinding, but should be coloured RED!
						// It's blue at the moment, as I need to test here for inclusion in m_RedBeginMarkers 
						// and colour the text red accordingly, and store the marker in m_markers, etc
						//int offset; 
						offset = wxNOT_FOUND; // init
						offset = pApp->m_RedBeginMarkers.Find(augWholeMkr);
						if (offset >= 0)
						{
							// It's one of the red set - handle it and set colour and textType
							// Start with \id
							if (aWholeMkr == _T("\\id"))
							{
								pSrcPhrase->m_curTextType = identification;
								pSrcPhrase->m_bFirstOfType = TRUE;
								pSrcPhrase->m_bBoundary = TRUE;
								pSrcPhrase->m_bSpecialText = TRUE;
								//pSrcPhrase->m_markers += augWholeMkr; // include the space for beginMkrs
								//ptr += awholemkrlen;
							}

						} // end of TRUE block for test: if (offset >= 0)

						// BEW 1Jul23, we need to set m_bIsWithinUnfilteredInlineSpan to TRUE if aWholeMkr
						// is _T("\\f")
						if (aWholeMkr == _T("\\f") && *(ptr + 2) == _T(' '))
						{
							m_bIsWithinUnfilteredInlineSpan = TRUE;
							pSrcPhrase->m_bFootnote = TRUE;  // At about 21910 m_bFoornote being TRUE
																// will set all the other footnote values
							//pSrcPhrase->m_bFootnoteEnd = FALSE; // these 3 not needed here
							//pSrcPhrase->m_bFirstOfType = TRUE;
							//pSrcPhrase->m_bBoundary = TRUE;
						}
						wxChar period;
						period = _T('.');
						int wholeMkrLength;
						wholeMkrLength = 0;
						wxString strTest;
						strTest = wxEmptyString;
						if (aWholeMkr != verseMkr)
						{
							// We have found a beginMkr, but it is not \v (could be \m or \li1 or \q1 or \p etc)
							tokBuffer += aWholeMkr; 
							// BEW 23Aug23, unilateral addition of a space could lead to error, if the marker
							// in the source text is not followed by a space. E.g. \p is often followed by newline
							// (or maybe \r\n on Windows), so we should instead parse to get whatever the following
							// character is, and append that to tokBuffer, to keep input data in sync with ptr
							//tokBuffer << _T(" "); // needs a following space
							wholeMkrLength = aWholeMkr.Length();
							wxChar* pAux2;
							pAux2 = ptr + wholeMkrLength;
							wxChar chNext; bool bCRisnext;
							bCRisnext = FALSE; // init
							bCRisnext = bCRisnext; // avoid gcc warning: set but not used
							chNext = *pAux2; // chNext is what should be appended to tokBuffer
							chNext = chNext; // avoid gcc warning: set but not used
							// whm 7Sep2023 modified the next 3 if tests below to ensure that if EOL is "\r\n" that 
							// "\r\n" gets put into tokBuffer and m_markers, otherwise m_markers can end up with a 
							// mixture of "\r" and "\r\n" EOLs within it, which when MakeXML() is called the EOLs 
							// of the xml document are a mixture of EOLs and not consistently "\r\n".
							/*
							if (chNext == _T('\r'))
							{
								bCRisnext = TRUE; // collab will have \r next, non-collab would point at \n
							}
							if (bCRisnext)
							{
								tokBuffer += chNext; // when bCRisnext is FALSE, tokBuffer already has aWholeMkr (see 41871) 
							}
							// BEW 6Jul23 Don't lose the marker, add it to m_markers
							pSrcPhrase->m_markers += tokBuffer;
							if (bCRisnext)
							{
								ptr += awholemkrlen + 2; // + because we parsed over '\r' and then one char more
							}
							else
							{
								ptr += awholemkrlen + 1; // +1 because we parsed over whatever wxChar follows aWholeMkr
							}
							*/
							int eolLen = 0;
							if (IsWhiteSpace(pAux2))
							{
								eolLen = ParseWhiteSpace(pAux2);
								wxString whiteStr = wxString(pAux2, eolLen);
								tokBuffer += whiteStr;
							}
							// whm 6Jan2024 modification.
							// Testing (of Hezekiah text file) indicates the when input text has a \b stanza break or 
							// a \tr table row marker, the marker gets doubled within m_markers.
							// When \b was previously put in m_marker above as "\\b\r\n" the tokBuffer at this point
							// also has something like "\\b\r\n\\nc " revealing that the m_markers content would
							// be doubled when the following line "augments" (+=) m_markers with tokBuffer content. 
							// 
							// whm 6Jan2024 Testing shows that doing an augment operation += sometimes results
							// in a marker getting duplicated within m_markers.
							// To eliminate any such duplication including any duplication of whitespace
							// I've written a new function RemoveDuplicateMarkersFromMkrString() that will 
							// remove any duplicate markers found in m_markers. If the first marker in 
							// m_markers has following whitespace, and any following duplicate marker also 
							// has the same whitespace, the whitespace of the duplicate is also removed. 
							// If the initial marker has no following whitespace, but a duplicate marker 
							// does have some following whitespace, only the duplicate marker is
							// removed - leaving its white space. However, if leaving the duplicate marker's
							// whitespace leaves doubled CRLFCRLF EOL sequence or doubled space "  " in
							// m_markers, then the doubled EOL and doubled spaces are changed to single
							// instances in m_markers. 
							pSrcPhrase->m_markers += tokBuffer;

							// whm 12Jan2024 modification. tokBuffer should be emptied once it has been assigned
							// to m_markers.
							tokBuffer.Empty();

							// whm 23Jan2024 temporary removal of the following RemoveDuplicateMarkersFromMkrString()
							// since when processing multiple adjacent empty markers, the m_markers member CAN
							// have duplicates
							// TODO: ensure removal does not result in duplicate marker in non-empty marker text!!!
							//pSrcPhrase->m_markers = RemoveDuplicateMarkersFromMkrString(pSrcPhrase->m_markers);

							ptr += awholemkrlen + eolLen;
							
							wxChar* pAux;
							pAux = ptr;
#if defined (_DEBUG) && !defined (NOLOGS)
							{
								wxString strPointAt = wxString(ptr, 16);
								wxLogDebug(_T("TokText() line  %d, m_markers= [%s] , m_curChapter= [%s], chapter:verse= [%s], pointsAt= [%s] "), __LINE__,
									pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif
							// BEW 23Aug23, bad test - second member should be IsWhiteSpace() because quite
							// often \p type marker is followed by \r, or \n or \r\n besides just latin space
							//if (pAux < pEnd && *pAux == _T(' ') && *(pAux + 1) == period)
							// 
							// whm 9Jan2024 modified test below by removing the IsWhiteSpace(pAux) part of
							// the test. The whitespace was already unilaterally parsed over above when eolLen
							// was calculated and ptr/pAux incremented. With the extra IsWhiteSpace() call in
							// the test, it would fail to detect the existence of a period after the \p marker
							// within a "\\p .." sequence.
							//if (pAux < pEnd && IsWhiteSpace(pAux) && *(pAux + 1) == period)
							// 
							// whm 17Jan2024 replaced the old if block below with a call to 
							// IteratePtrPastBogusPeriods(ptr) here. The precWordDelim setting 2 lines
							// is done farther below after a parse of space/EOLs after any periods are
							// skipped over.
							int nPeriods = 0;
							IteratePtrPastBogusPeriods(ptr, pEnd, nPeriods);

							/*
							if (pAux < pEnd && *(pAux + 1) == period)
							{
								// Matched space followed by a period - a period after a beginMkr is unlikely,
								// except in contentless source text originating from Paratext, where ... or ..
								// sometimes appears after the marker. So check out for ..., and failing that, 
								// for .. and if either is found, eliminate either by advancing ptr the necessary
								// distance, don't update len, and continue in the parsing.
								// whm 9Jan2024 the code below fails to detect the "\\p ..\r\n" sequence because
								// pAux is pointing at the first period and so the strTest strings end up being
								// suffixed by parts of the EOL sequence as "..\r\n" in the first test and "..\r"
								// in the second test. Then each test: strTest == strThreePeriods and
								// strTest == strTwoPeriods both fail due to presence of \rn and \r suffixed to
								// strTest. We could do a .Trim() of strTest, but I think a while loop would work
								// better and catch any number of periods after the \p marker
								//strTest = wxString(pAux, 4); // for space followed by ...
								//if (strTest == strThreePeriods)
								//{
								//	// At pAux, <space>...  so remove all four, because whitespace will follow the ...
								//	ptr += 4;
								//}
								//else
								//{
								//	strTest = wxString(pAux, 3);
								//	if (strTest == strTwoPeriods)
								//	{
								//		// At pAux, <space>..  so remove all three, because whitespace will follow the ..
								//		ptr += 3;
								//	}
								//}
								while (pAux < pEnd && *pAux == period && !IsWhiteSpace(pAux))
								{
									pAux++;
									ptr++;
								}
								precWordDelim = *ptr; // the post-mkr space in swbk needs to be replaced by whatever
														 // whitespace char follows the periods string
								pSrcPhrase->SetSrcWordBreak(precWordDelim);
#if defined (_DEBUG) && !defined (NOLOGS)						
									if (pSrcPhrase->m_nSequNumber >= 2)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
#endif						
							} // end of TRUE block for test: if (pAux < pEnd && *ptr == _T(' ') && *(ptr + 1) == period)
							*/

#if defined (_DEBUG) && !defined (NOLOGS)
							{
								wxString strPointAt = wxString(ptr, 16);
								wxLogDebug(_T("TokTxt() line  %d , aWholeMkr= [%s], m_markers= [%s], chapter:verse= [%s], pointsAt= [%s] "),
									__LINE__, aWholeMkr.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here; wxUnusedVar(halt_here);
								}
							}
#endif
							// BEW 23Jun23, ptr will now be pointing at the whitespace (space or newline) after aWholeMkr, 
							// (ptr + 1) could be the start of: \v number text, or could be a '[' bracked followed by text.
							// The \v next scenario is most likely, so handle first. If not \v, then try the '[' option.
							// 
							// whm 24Aug2023 note: On 23Aug2023 BEW changed the if test below adding test for chAtAuxPtr == _T('\r')
							// but that won't catch a \v following the 2 char EOL sequence "\r\n", so I've created an alternative
							// test which is commented out below the if test. I decided not to make my version the active version
							// since a comparison of the xml docs - one created with my version compared to BEW's version - showed
							// no xml difference when parsing Nyindrou Matthew even though the test if TRUE for non-collab, but
							// FALSE for collab scenarios. There is no difference in the end since I think the code in the outer
							// if block is essentially the same as the code of the inner else block (lines 41860 ff) except for
							// the break statement there.
							//
							// whm 23Jan2024 UPDATE. Tracing through the code I see that the ptr was already advanced past all
							// whitespace back up at the block where eoldLen was used to increment the ptr PAST the whitespace.
							// Therefore at this point in execution the ptr is NOT at whitespace. So I've simplified the test
							// below to test for whether the ptr/pAux is pointing at a verse marker. If so the TRUE block is
							// entered - but should NOT advance the ptr any further so the code there needs to be commented out
							//
							//wxChar* auxPtr = ptr;
							//wxChar chAtAuxPtr = *auxPtr; wxUnusedVar(chAtAuxPtr); // avoid compiler warning variable initialized but not referenced
							//if ((auxPtr < pEnd) &&
							//	(((*auxPtr == _T(' ') || *auxPtr == _T('\n')) && *(auxPtr + 1) == gSFescapechar && *(auxPtr + 2) == _T('v'))
							//	|| ((*auxPtr == _T(' ') || (*auxPtr == _T('\r') && *(auxPtr + 1) == _T('\n')))
							//		&& *(auxPtr + 2) == gSFescapechar && *(auxPtr + 3) == _T('v'))) )
							int mLen = 0;
							if (ptr < pEnd && IsVerseMarker(ptr, mLen))
							{
								// whm 23Jan2024 commented out this code block because the ptr was not at 
								// whitespace as explained above.
								// 
								//// A verse marker follows either space or newline; so put the whitespace 
								//// into tokBuffer and update ptr, and 
								//nWhiteLen = ParseWhiteSpace(ptr);
								//strWhites = wxString(ptr, nWhiteLen);
								//tokBuffer += strWhites;
								//ptr += nWhiteLen;
								;
							}
							else
							{

								// E.g Control may get here in the following scenarios; ptr was pointing at:
								//    \p \v verseNum <text>  or  \p <newline> \v verseNum <text> -- handled in TRUE block above
								//    \p [Aepo e'i remẽ, e'i.  etc ....]  -- handle here
								// Prior to this refactor, the closing ]  showed up in the layout, the [ got lost
								wxChar* pAux = ptr;
								wxChar chSecond = *(pAux + 1);
								wxChar chThird = *(pAux + 2);
								int anoffset = wxNOT_FOUND;
								int anItemLen; anItemLen = 0;
								anoffset = spacelessPuncts.Find(chThird);


#if defined (_DEBUG) && !defined (NOLOGS)
								{
									wxString strPointAt = wxString(ptr, 16);
									wxLogDebug(_T("TokText() line  %d , chapter:verse= [%s], aWholeMkr= [%s], m_markers= [%s] , strPointAt= [%s] "),
										__LINE__, pSrcPhrase->m_chapterVerse.c_str(), aWholeMkr.c_str(), pSrcPhrase->m_markers.c_str(), strPointAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 5)
									{
										int halt_here; wxUnusedVar(halt_here);
									}
								}
#endif
								if ((chSecond == _T('[') || chSecond == _T('(')) && !IsWhiteSpace(pAux + 2) && anoffset == wxNOT_FOUND && chThird != gSFescapechar)
								{
									wxString whichWhite = *ptr; // could  be space or newline
									wxString strExtras = whichWhite + chSecond; // we parse only past the '[' or '('
									if (!tokBuffer.IsEmpty())
									{
										tokBuffer << whichWhite;
										pSrcPhrase->m_markers += tokBuffer; // make sure any content is not lost
										tokBuffer.Empty();
									}
									// We want to store the [ or ( as preceding punctuation, so that ParseWord() can
									// later pull it out and show it preceding the word which follows
									pSrcPhrase->m_precPunct << chSecond;
									// update ptr, since we've parsed over a white and a [
									anItemLen += 2;
									ptr += anItemLen;
									break; // from the inner loop, to hasten getting to ParseWord() - 5th break in TokenizeText()
								}
								else
								{
									// Add the whitespace(s) to tokBuffer,  and update ptr to point past the whites,
									// staying in the inner loop
									nWhiteLen = ParseWhiteSpace(ptr);
									strWhites = wxString(ptr, nWhiteLen);
									tokBuffer += strWhites;

									// whm 17Jan2024 moved the precWordDelim assignment here from the earlier location
									// that now calls the IteratePtrPastBogusPeriods(ptr) function. The old code block
									// following that new function, attempted to deal with bogus periods, but is now 
									// commented out being replaced by the new function. Within the commented out
									// code block were the following two lines that assigne a char value to precWordDelim
									// and store it on pSrcPhrase. Those two lines are moved here.
									if (nWhiteLen > 0)
									{
										precWordDelim = *ptr; // the post-mkr space in swbk needs to be replaced by whatever
										// whitespace char follows the marker
										pSrcPhrase->SetSrcWordBreak(precWordDelim);
									}

									ptr += nWhiteLen;

									//BEW 23Aug23, control can get here, with ptr already pointing at a next \v marker,
									// and if so, we DON'T want to stay in the inner loop, instead we want to break
									// out so that the test below: if (IsVerseMarker(ptr, nMkrLen))
									// can process the verse marker
									if (*ptr == gSFescapechar && *(ptr + 1) == _T('v'))
									{
										// ptr is at a \v mamrker
										break; // 6th break in TokenizeText()
									}
								} // end of else block for test:
								  // if ((chSecond == _T('[') || chSecond == _T('(')) && !IsWhiteSpace(pAux + 2) && anoffset == wxNOT_FOUND && chThird != gSFescapechar)

							} // end of else block for complex test:
							  // if (auxPtr < pEnd && (chAtAuxPtr == _T(' ') || chAtAuxPtr == _T('\n') || chAtAuxPtr == _T('\r'))
							  // && *(auxPtr + 1) == gSFescapechar && *(auxPtr + 2) == _T('v'))

						} // end of TRUE block for test: if (offset == wxNOT_FOUND)
						else
						{
							// we have found a \v marker
							break; // ptr is now at a \v marker, so the test below can handle it and set m_inform etc - 7th break in TokenizeText()
						}
					} // end of TRUE block for test: if (bIsBeginMkr == TRUE && !bIsEndMkr)

				} // end of loop: while (ptr < pEnd && *ptr == gSFescapechar && IsRedOrBindingOrNonbindingBeginMkr(ptr, pEnd))
#if defined (_DEBUG) && !defined (NOLOGS)
				{
					wxString strPointAt = wxString(ptr, 16);
					wxLogDebug(_T("TokText() line  %d ,Before verseMkr block: chapter:verse= [%s], aWholeMkr= [%s], m_markers= [%s] , strPointAt= [%s] "),
						__LINE__, pSrcPhrase->m_chapterVerse.c_str(), aWholeMkr.c_str(), pSrcPhrase->m_markers.c_str(), strPointAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here; wxUnusedVar(halt_here);
					}
				}
#endif
				if (IsVerseMarker(ptr, nMkrLen))
				{
					// starting a new verse, clear the following flag to FALSE so that it
					// has a chance to work helpfully for the parse of this verse
					m_bHasPrecedingStraightQuote = FALSE;
					pVerseMkrAtPtr = ptr;

#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokText() line  %d , chapter:verse= [%s], aWholeMkr= [%s], m_markers= [%s] , strPointAt= [%s] "),
							__LINE__, pSrcPhrase->m_chapterVerse.c_str(), aWholeMkr.c_str(), pSrcPhrase->m_markers.c_str(), strPointAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here; wxUnusedVar(halt_here);
						}
					}
#endif
					// its a verse marker
					if (nMkrLen == 2)
					{
						tokBuffer += gSFescapechar;
						tokBuffer += _T("v");
						ptr += 2; // point past the \v marker
					}
					else
					{
						tokBuffer += gSFescapechar;
						tokBuffer += _T("vn");
						ptr += 3; // point past the \vn marker (Indonesia branch)
					}
					itemLen = ParseWhiteSpace(ptr);
					// temp returns the string at ptr with length itemLen, and the same string
					// is appended to tokBuffer as well (usually we just want tokBuffer, but
					// temp is available if we need the substring at ptr for any other purpose)
					AppendItem(tokBuffer, temp, ptr, itemLen); // add white space to buffer
					ptr += itemLen; // point at verse number or verse string eg. "3b"
					//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"),__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());

					itemLen = ParseNumber(ptr);

					AppendItem(tokBuffer, temp, ptr, itemLen); // add number (or range eg. 3-5) to buffer

					pSrcPhrase->m_chapterVerse = pApp->m_curChapter; // set to n: form
					pSrcPhrase->m_chapterVerse += temp; // append the verse number
					// BEW 3Aug23 added, set tokBuffer in m_markers, replacing any prior content
					// 
					// whm 6Jan2024 Testing shows that doing an augment operation += sometimes results
					// in a marker getting duplicated within m_markers.
					// To eliminate any such duplication including any duplication of whitespace
					// I've written a new function RemoveDuplicateMarkersFromMkrString() that will 
					// remove any duplicate markers found in m_markers. If the first marker in 
					// m_markers has following whitespace, and any following duplicate marker also 
					// has the same whitespace, the whitespace of the duplicate is also removed. 
					// If the initial marker has no following whitespace, but a duplicate marker 
					// does have some following whitespace, only the duplicate marker is
					// removed - leaving its white space. However, if leaving the duplicate marker's
					// whitespace leaves doubled CRLFCRLF EOL sequence or doubled space "  " in
					// m_markers, then the doubled EOL and doubled spaces are changed to single
					// instances in m_markers. 
					pSrcPhrase->m_markers += tokBuffer;
					// whm 23Jan2024 temporary removal of the following RemoveDuplicateMarkersFromMkrString()
					// since when processing multiple adjacent empty markers, the m_markers member CAN
					// have duplicates
					// TODO: ensure removal does not result in duplicate marker in non-empty marker text!!!
					//pSrcPhrase->m_markers = RemoveDuplicateMarkersFromMkrString(pSrcPhrase->m_markers);

					wxString theVerseNumber = temp; // BEW 22Aug23 added for preserving the number, temp is unhelpful to remember
#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokText() line  %d , chapter:verse= [%s], aWholeMkr= [%s], m_markers= [%s] , strPointAt= [%s] "),
							__LINE__, pSrcPhrase->m_chapterVerse.c_str(), aWholeMkr.c_str(), pSrcPhrase->m_markers.c_str(), strPointAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here; wxUnusedVar(halt_here);
						}
					}
#endif
					tokBuffer.Empty(); // prevent duplication if more mkrs added

					// Track the verse number if logging is wanted
					if (pApp->m_bMakeDocCreationLogfile) // turn this ON in docPage of the Wizard or the GetSourceTextFromEditor dialog
					{
						if (pApp->m_bParsingSource)
						{
							pApp->m_verseNumber_for_ParsingSource = temp;
						}
					}

					pSrcPhrase->m_bVerse = TRUE; // set the flag to signal start of a new verse
					ptr += itemLen; // point past verse number

					// set pSrcPhrase attributes
					pSrcPhrase->m_bVerse = TRUE;
					//pSrcPhrase->m_inform = pSrcPhrase->m_chapterVerse;
					pSrcPhrase->m_bFirstOfType = TRUE;
					// whm 27Jan2024 removed the following setting of pSrcPhrase->m_bBoundary to TRUE. If the source
					// phrase that contains the verse marker in m_markers has m_bBoundary TRUE that prevents the user
					// from extending a source line selection via ALT+RightArrow or SHIFT+Click. The version 6.10.7
					// did NOT set m_bBoundary to TRUE here and its source line selection mechanism works OK.
					//pSrcPhrase->m_bBoundary = TRUE;
					//pSrcPhrase->m_key = temp;			// No no! temp holds the verse number, this is NEVER 
					//pSrcPhrase->m_srcPhrase = temp;   // assigned to m_key nor to m_srcPhrase

					bIsToBeFiltered = FALSE; // we never filter sacred content
					bKeepPtrFromAdvancing = FALSE;

#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokTxt() in IsVerseMkr TRUE block: line  %d , verseNum= [%s] , m_curChapter= [%s] , m_inform= [%s], m_chapterVerse= [%s], m_srcPhrase= [%s] ,strPointAt= [%s] "),
							__LINE__, theVerseNumber.c_str(), pApp->m_curChapter.c_str(), pSrcPhrase->m_inform.c_str(),
							pSrcPhrase->m_chapterVerse.c_str(), pSrcPhrase->m_srcPhrase.c_str(), strPointAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 13)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
					}
#endif
					// BEW 31Jul23 when working with contentless src text, having set pSrcPhrase values for \v as above,
					// control will keep trying to find a 'next' beginMkr (eg. after a \p ) and it will find that and 
					// that marker's content gets handled - leading to what was just done being 'lost' to the .xml
					// So I need to force the pSrcPhrase to get added to the SPList. Using the finishup goto label will
					// suffice provided I calculate a correct itemLen value first
					// whm 17Jan2024 removed the following itemLen assignment as useless since it is soon replaced by
					// the following itemLen assitnment past the commented out code BEW made 23Aug23.
					//itemLen = pSrcPhrase->m_markers.Length();
#if defined (_DEBUG) && !defined (NOLOGS)
					wxString spanAtPtr;
					spanAtPtr = wxString(ptr, itemLen + 1); // +1 because ptr may be pointing at one whitespace
					wxLogDebug(_T("TText() line %d , Set m_marker [%s], in Verse Mkr Parsing TRUE block: pointsAt= [%s]"),
						__LINE__, pSrcPhrase->m_markers.c_str(), spanAtPtr.c_str());
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
					}
#endif
					/* BEW 23Aug23 hopefully this bit is no longer required, it caused premature parsing truncation after sn = 0
					if (itemLen > 0 && (pSrcPhrase->m_markers.Find(_T("\\v ")) >= 0))
					{
						// If m_markers has content, and the marker just filled out was a \v beginMkr,
						// then force TokenizeText to assign this current pSrcPhrase to the m_pSourcePhrases SPList*
						// and then whatever \v or other marker may follow, it will be on a new pSrcPhrase
						tokBuffer.Empty();
						int len;
						//goto parsing;
						len = (int)(ptr - pVerseMkrAtPtr) + itemLen;
						ptr = pVerseMkrAtPtr + itemLen; // redundant, but useful when debugging
						// Force a new pSrcPhrase, which should handle any filtering if a filterable marker follows 
						return len;
					}
					*/
					// BEW 22Aug23 comment: If tokeBuffer just above was not emptied at the setting of m_markers,
					// so that the test at 41680 failed to sent control to ParseWord() (ie. goto parsing;), then
					// adding to tokBuffer more content would likely cause problems
					itemLen = ParseWhiteSpace(ptr); // past white space after the marker
					AppendItem(tokBuffer, temp, ptr, itemLen);  // add it to the buffer
					ptr += itemLen; // point past the white space

					// whm 17Jan2024 added IteratePtrPastBogusPeriods(ptr) here and 
					// remove if block below, except retain the precWordDelim setting 2 lines
					// inside the if block.
					int nPeriods = 0;
					IteratePtrPastBogusPeriods(ptr, pEnd, nPeriods);

					// Store the "\\v versenum " text in pSrcPhrase->m_markers
					wxString save_m_markers; // preserve what we parsed over,

					// BEW 10 Jul23 there is a potential error if I unilaterally append tokBuffer, because
					// m_markers may have received a beginMkr earlier (e.g. \q ) and that same marker will
					// have been put into tokBuffer - so we'd get doubling, even though \q occurs once.
					// So append only after first checking for contents and empty m_markers if the same
					// marker is within tokBuffer
					int offset;
					if (!pSrcPhrase->m_markers.IsEmpty())
					{
						wxString mkrsContent;
						mkrsContent = pSrcPhrase->m_markers;
						/*
						// BEW 7Aug23 check if pSrcPhrase->m_markers already has a \v marker.
						// If so, do not parse another - otherwise the already got one will get lost
						// and not be seen in the GUI display
						wxString verseMkr;
						if (!pSrcPhrase->m_markers.IsEmpty())
						{
							verseMkr = GetWholeMarker(ptr);
							if (verseMkr == _T("\\v"))
							{
								int offset;
								offset = -1;
								// Is there already a \v in m_markers?
								offset = pSrcPhrase->m_markers.Find(verseMkr);
								if (offset >= 0)
								{
									// m_markers already stores a \v marker, so disallow parsing
									// of another. Instead, send control to ParseWord() using goto
									goto parsing;
								}
							}
						} // end of TRUE block for test: if (!pSrcPhrase->m_markers.IsEmpty())
						*/
						// BEW comment 6Sep23, regarding the issue of chapter 2 and chapter 7 getting lost
						// when a paragraph marker follows chapter marker, I changed to use GetLastBeginMkr() to see
						// if that made a difference to the parsing. It didn't. So I reverted back to using 
						// GetPriorityBeginMkr().
						offset = wxNOT_FOUND;
						wxString firstMkr;
						firstMkr = GetPriorityBeginMkr(mkrsContent); // BEW 31Aug23, // Bill wants firstMkr to set the type etc					
						offset = tokBuffer.Find(firstMkr);

						//wxString lastMkr;
						//lastMkr = GetLastBeginMkr(mkrsContent);
						//offset = tokBuffer.Find(lastMkr);

						if (offset >= 0)
						{
							// clear m_markers before appending, to avoid duplication
							pSrcPhrase->m_markers.Empty();
						}
					}
					pSrcPhrase->m_markers += tokBuffer;
					// BEW 10Jul23, if m_markers contains the sequence _T(" \n") then remove the space
					// before the newline
					wxString strTwoWhites;
					strTwoWhites = _T(" \n");
					offset = pSrcPhrase->m_markers.Find(strTwoWhites);
					if (offset >= 0)
					{
						// get rid of the latin space
						pSrcPhrase->m_markers = pSrcPhrase->m_markers.Remove(offset, 1);
					}
					save_m_markers = pSrcPhrase->m_markers; // need this content below
					pSrcPhrase->m_bFirstOfType = TRUE;

					tokBuffer.Empty();  // BEW 3Aug23, commented out, BEW 6Sep23 reinstated emptying it - probably safer
					// 
//					wxLogDebug(_T("*** TokenizeText(), line %d , sn= %d ,  SAVING  pSrcPhrase->m_markers = %s  ***"),
//						__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
					// BEW 4Apr23 at sn = 0, the material added to m_markers was not being retained, because
					// tokBuffer is emptied just above, but then used in 18974 and (especially) 18998. So
					// I added wxString save_m_markers to preserve what was parsed over, and used it in those
					// two locations
#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokText() line  %d , chapter:verse= [%s], aWholeMkr= [%s], m_markers= [%s] , pointsAt= [%s] "),
							__LINE__, pSrcPhrase->m_chapterVerse.c_str(), aWholeMkr.c_str(), pSrcPhrase->m_markers.c_str(), strPointAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here; wxUnusedVar(halt_here);
						}
					}
#endif

					// BEW 13Jul11, this is where we check for setting bEmptyUSFM to TRUE, so
					// as to support parsing of Paratext's minimal USFM which has no content --
					// for that kind of input, ptr would here be pointing at the next \v or \vn
					// marker -- so check for this, or pointing at end of the text, and if so,
					// turn on the flag
					if (ptr >= pEnd || (*ptr == _T('\\') && *(ptr + 1) == _T('v')))
					{
						//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= [%s]  TESTED TRUE for \v at ptr"),
						//    __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
						bEmptyUSFM = TRUE;
						pSrcPhrase->m_key.Empty();
						pSrcPhrase->m_srcPhrase.Empty();
						pSrcPhrase->m_markers = save_m_markers; // need this, as tokBuffer was cleared above
						pSrcPhrase->m_bFirstOfType = TRUE;
						// break out of the inner loop now, because ptr will be pointing at
						// the next \v and if control goes back to the if (IsMarker(ptr))
						// test, we'll just keep accumulating each marker into the one
						// m_markers member of the current pSrcPhrase, instead of going to the
						// outer loop, saving it and creating a new one etc
//						wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
						break; // 8th break in TokenizeText()
					}
					else
					{
						// BEW 28Mar23 formerly this else block only had bEmptyUSFM set to FALSE,
						// (the intent of a TRUE value is to prevent control entering ParseWord).
						// The problem is that as it stands, if control enters this else block,
						// a parsed over \v followed by space and verse number with following space
						// (in tokBuffer) does not get added to m_markers, when m_nSequNumber is 0
						bEmptyUSFM = FALSE;
						// BEW 28Mar23 added - see comment above
						if (pSrcPhrase->m_nSequNumber == 0)
						{
							//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
							pSrcPhrase->m_key.Empty(); // still empty, at sn = 0
							pSrcPhrase->m_srcPhrase.Empty(); // ditto
							pSrcPhrase->m_markers = save_m_markers; // don't lose what we parsed over
							pSrcPhrase->m_bFirstOfType = TRUE;
							//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
						}
					}
#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokText() line  %d , chapter:verse= [%s], aWholeMkr= [%s], m_markers= [%s] , strPointAt= [%s] "),
							__LINE__, pSrcPhrase->m_chapterVerse.c_str(), aWholeMkr.c_str(), pSrcPhrase->m_markers.c_str(), strPointAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here; wxUnusedVar(halt_here);
						}
					}
#endif
					// BEW added 05Oct05
					if (bFreeTranslationIsCurrent)
					{
						// we default to always turning off a free translation section at a new
						// verse if a section is currently open -- this prevents assigning a
						// free translation to the rest of the document if we come to where no
						// free translations were assigned in another project's adaptations
						// which we are inputting
						if (pLastSrcPhrase)
						{
							pLastSrcPhrase->m_bEndFreeTrans = TRUE;
						}
					}
					//					wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokTxt() line  %d , bContinueTwice = %d , pointsAt= [%s] End of block IsVerseMkr - iterate by continue"),
							__LINE__, (int)bContinueTwice, strPointAt.c_str());
					}
#endif
					continue; // iterate inner loop to check if another marker follows - 4th continue in TokenizeText()

				} // end of TRUE block for test: if (IsVerseMarker(ptr, nMkrLen))

				// ********************************** do LookupSFM ***************************************
				else
				{

					// Neither verse nor chapter, but some other marker

					// BEW 24Oct14, LookupSFM() has been made USFM nested marker aware.
					// If an unknown marker, pUsfmAnalysis will be NULL; if it's a nested
					// marker, the non-nested equivalent will be constructed internally for
					// the lookup and used, likewise, if its an endmarker, * will be removed
					// as well. However, we should only be encountering legacy content
					// begin-markers here in TokenizeText()
#if defined (_DEBUG) && !defined(NOLOGS)
					wxString strPointAt = wxString(ptr, 16);
					wxLogDebug(_T("TokTxt() line  %d , sequNum = %d, LookupSFM() block, chapter:verse= [%s], strPointAt= [%s]"),
						__LINE__, (int)pSrcPhrase->m_nSequNumber, pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
					}
#endif
					wxString wholeMkr; wxString augWholeMkr; 
					// BEW 30Sep19 the lookup now returns a pUsfmAnalysis modified for
					// the ptr being at a \fig marker: modifications are:
					// 'special' set to TRUE, 'bdryOnLast' set TRUE, 'inform' set TRUE,
					// and navigationText set to _T("illustration")
					// whm 23Sep2023 Note: The attributes of the \fig marker are more
					// appropriately set in the AI_USFM.xml control file which I've done
					// as of this date. Also set navigationText to "figure" which I think
					// is better and more mnemonic to users for \fig.
					bIsToBeFiltered = FALSE; // init
					bIsCharAttrMkr = FALSE;  // init

					// BEW 27Jul23, add protection. If markup is  \q1 "Jo iyah...., in the inner loop the \q1 will
					// be detected and stored, and the loop will try find any additional following beginMkr - but
					// there won't be one, so it tries to lookup a marker by testing non-marker verse content - which
					// of course will fail, and pUsfmAnalyis will be NULL, and things will then go very wrong.
					if (*ptr != gSFescapechar)
					{
						goto parsing;
					}
					pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr);
					//	wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), 
					//	__LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
					if (pUsfmAnalysis != NULL && *ptr == gSFescapechar)
					{
						wholeMkr = GetWholeMarker(ptr);
						wxASSERT(!wholeMkr.IsEmpty());
						augWholeMkr = wholeMkr + _T(' ');
						lookupStr = augWholeMkr;
#if defined (_DEBUG) 
						// Verify
						int verifyOffset;
						verifyOffset = wholeMkr.Find(tagOnly);
						wxASSERT(verifyOffset >= 0);
#endif
						if (!wholeMkr.IsEmpty())
						{
							// Testing for bIsToBeFiltered needs to be done. If TRUE, then we must ensure
							// that ptr does not advance until control reaches the filtering code lower down
#if defined (_DEBUG) //&& !defined(NOLOGS)
							//wxLogDebug(_T("TokText() line %d wholeMkr= [%s], gpApp->gCurrentFilterMarkers= [%s]"),
							//	__LINE__, wholeMkr.c_str(), gpApp->gCurrentFilterMarkers.c_str());
							if (pSrcPhrase->m_nSequNumber >= 1060)
							{
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
#endif
							// whm 20Jan2024 added check if augWholeMkr is an AI custom marker \free \note 
							// or \bt... marker - which are obligatorily filtered.
							bool bIsForeignBackTransMkr = FALSE;
							bIsToBeFiltered = (pApp->gCurrentFilterMarkers.Find(augWholeMkr) != wxNOT_FOUND);
							if (!bIsToBeFiltered)
							{
								bIsToBeFiltered = IsMarkerFreeTransOrNoteOrBackTrans(augWholeMkr, bIsForeignBackTransMkr);
							}
						}
#if defined (_DEBUG) && !defined (NOLOGS)
						{
							wxString strPointAt = wxString(ptr, 16);
							wxLogDebug(_T("TokTxt() line  %d , bIsToBeFiltered %d; wholeMkr= [%s], m_markers= [%s] , m_curChapter= [%s], strPointAt= [%s] "),
								__LINE__, (int)bIsToBeFiltered, wholeMkr.c_str(), pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), strPointAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 5)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
						}
#endif						
						wxChar period;
						period = _T('.');
						wxString strTest;
						strTest = wxEmptyString;
						if (wholeMkr != verseMkr)
						{
							// The marker is not \v (could be \m or \li1 or \q1 or \p or \x etc)
							// BEW 23Aug23, at this point, tokBuffer might be empty, and if so
							// we must not unilaterally add a space.
							// Also, the code for checking it bToBeFiltered for TRUE is above,
							// so we don't want to add wholeMkr to m_markers something which
							// is going to be filtered out, so refactor here with care...
							if (bIsToBeFiltered)
							{
								// We must not do anything here that results in wholeMkr being added to tokBuffer
								// or to m_markers; parsing must not advance ptr until the filtering has been done
								int debugBreak = 0; wxUnusedVar(debugBreak);
								// TODO anything to do here? I don't think so -- e.g. \x must still be pointed at
								// when control reaches the filtering code, a long way below
							}
							else
							{
								// This block can parse, but with care - don't append a latin space
								// to an empty pSrcPhrase->m_markers; also wholeMkr is not going to be filtered out
								tokBuffer.Trim(FALSE); // remove any initial white space
								if (pSrcPhrase->m_markers.IsEmpty())
								{
									if (!tokBuffer.IsEmpty())
									{
										// There is something to add to m_markers, do so and clear tokBuffer
										pSrcPhrase->m_markers = tokBuffer;
									
										int mmkrsLen;
										mmkrsLen = pSrcPhrase->m_markers.Length();
										ptr += mmkrsLen; // advance ptr (including initial whitespace if present)

										tokBuffer.Empty();
									}
								}
								else
								{
									// pSrcPhrase->m_markers has content; tokBuffer may have some more to append,
									// or it might be empty. If empty, no harm in unilaterally appending
									
									// BEW 6Jul23 Don't lose the marker, add it to m_markers if non-empty
									// ptr should have earlier been advanced to point past pSrcPhrase->m_markers
									// so just advance ptr by how long tokBuffer is.
									// 
									// whm 6Jan2024 modification.
									// Testing (of Hezekiah text file) indicates the when input text has a \b stanza break or 
									// a \tr table row marker, the marker gets doubled within m_markers.
									// When \b was previously put in m_marker above as "\\b\r\n" the tokBuffer at this point
									// also has something like "\\b\r\n\\nc " revealing that the m_markers content would
									// be doubled if the following line "augments" (+=) m_markers with tokBuffer content. 
									// 
									// whm 6Jan2024 Testing shows that doing an augment operation += sometimes results
									// in a marker getting duplicated within m_markers.
									// To eliminate any such duplication including any duplication of whitespace
									// I've written a new function RemoveDuplicateMarkersFromMkrString() that will 
									// remove any duplicate markers found in m_markers. If the first marker in 
									// m_markers has following whitespace, and any following duplicate marker also 
									// has the same whitespace, the whitespace of the duplicate is also removed. 
									// If the initial marker has no following whitespace, but a duplicate marker 
									// does have some following whitespace, only the duplicate marker is
									// removed - leaving its white space. However, if leaving the duplicate marker's
									// whitespace leaves doubled CRLFCRLF EOL sequence or doubled space "  " in
									// m_markers, then the doubled EOL and doubled spaces are changed to single
									// instances in m_markers.
									//  
									// whm 9Jan2024 testing in Hezekiah when parsing and red marker \ms1 is being
									// parsed here, the \ms1 marker has not yet been added to tokBuffer, and 
									// moreover the content of tokBuffer was same as m_markers both having "\\b\r\n"
									// in them. To avoid dropping the \ms1 marker and properly increment the ptr below
									// The solution needs to do the following:
									// 1. Empty tokBuffer if it is not empty and has the same duplicate content as 
									//    m_markers.
									// 2. Add the marker to the tokBuffer so that the content of tokBuffer is solely
									//    the wholeMkr - which ptr is currently pointing at. This will then result
									//    in a proper increment value for ptr that just advances past the marker.
									// The above solution I think will also help reduce or eliminate marker duplication
									// within the m_markers member. However, I'm leaving the call of 
									// RemoveDuplicateMarkersFromMkrString() below in place, as it doesn't cause
									// any change in m_markers if there is no duplication.
									if (!tokBuffer.IsEmpty() && tokBuffer == pSrcPhrase->m_markers)
									{
										tokBuffer.Empty();
									}
									tokBuffer = augWholeMkr; // need the augmented marker here to provide space following marker

									pSrcPhrase->m_markers += tokBuffer;
									pSrcPhrase->m_markers = RemoveDuplicateMarkersFromMkrString(pSrcPhrase->m_markers);
									// whm 23Jan2024 modification/correction. Just above, tokBuffer is filled with the augWholeMkr
									// so that the contents of tokBuffer now ends with a space. The original code below then
									// gets the length of tokBuffer - including the space - into tbLen. Then tbLen is used to
									// increment the ptr, but that is wrong for any following EOL sequence of \r\n, and it leaves
									// the ptr pointing at the \n instead of past the whitespace at the following word or marker.
									// Therefore, I've modified the code below to increment ptr properly by the actual length of
									// the wholeMkr and then by the actual length of following whitespace. This failure had many
									// negative ramifications for a text full of empty contentless markers in which most markers 
									// are followed by EOL \r\n chars rather than words or single spaces.
									//int tbLen;
									//tbLen = tokBuffer.Length(); // whm 9Jan2024 note: tbLen will now always be the length of the marker
									//ptr += tbLen; // advance ptr (including initial whitespace if present in tokBuffer)
									int nMkrLen = (int)wholeMkr.Length();
									ptr += nMkrLen;
									int nWhitesLen = ParseWhiteSpace(ptr);
									ptr += nWhitesLen;

									// whm 12Jan2024 modification. tokBuffer should be emptied once it has been assigned
									// to m_markers.
									tokBuffer.Empty();
								}

							}
#if defined (_DEBUG) && !defined (NOLOGS)
							{
								wxString strPointAt = wxString(ptr, 16);
								wxLogDebug(_T("TokText() line  %d , bIsToBeFiltered %d; wholeMkr= [%s], m_markers= [%s] , m_curChapter= [%s], pointsAt= [%s] "),
									__LINE__, (int)bIsToBeFiltered, wholeMkr.c_str(), pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), strPointAt.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
							}
#endif						
							// whm 17Jan2024 Note: The old bogus period handling routine below was not
							// reached here because ptr is still pointing at the backslash of the
							// marker at this point.
							// Here is not an appropriate place to call IteratePtrPastBogusPeriods(ptr) 
							// either for the same reason. I will call IteratePtrPastBogusPeriods()
							// later after the marker and following space have been parsed and the 
							// ptr is updated to point to whatever follows the "\\p " marker and following
							// space.
							// Hence, I have removed the if block below that attempted to remove bogus
							// periods. 
							// Also we wait until the marker has been parsed and ptr updated just
							// past the space following the marker before assigning the precWordDelim 
							// character

							/*
							wxChar* pAux;
							pAux = ptr;
							if (pAux < pEnd && *pAux == _T(' ') && *(pAux + 1) == period && !pSrcPhrase->m_markers.IsEmpty())
							{
								// Matched space followed by a period - a period after a beginMkr is unlikely,
								// except in contentless source text originating from Paratext, where ... or ..
								// sometimes appears after the marker. So check out for ..., and failing that, 
								// for .. and if either is found, eliminate either by advancing ptr the necessary
								// distance, don't update len, and continue in the parsing.
								// whm 9Jan2024 the code below fails to detect the "\\p ..\r\n" sequence because
								// pAux is pointing at the first period and so the strTest strings end up being
								// suffixed by parts of the EOL sequence as "..\r\n" in the first test and "..\r"
								// in the second test. Then each test: strTest == strThreePeriods and
								// strTest == strTwoPeriods both fail due to presence of \rn and \r suffixed to
								// strTest. We could do a .Trim() of strTest, but I think a while loop would work
								// better and catch any number of periods after the \p marker
								//strTest = wxString(pAux, 4); // for space followed by ...
								//if (strTest == strThreePeriods)
								//{
								//	// At pAux, <space>...  so remove all four, because whitespace will follow the ...
								//	ptr += 4;
								//}
								//else
								//{
								//	strTest = wxString(pAux, 3);
								//	if (strTest == strTwoPeriods)
								//	{
								//		// At pAux, <space>..  so remove all three, because whitespace will follow the ..
								//		ptr += 3;
								//	}
								//}
								while (pAux < pEnd && *pAux == period && !IsWhiteSpace(pAux))
								{
									pAux++;
									ptr++;
								}
								precWordDelim = *ptr; // the post-mkr space in swbk needs to be replaced by whatever
														 // whitespace char follows the periods string
								pSrcPhrase->SetSrcWordBreak(precWordDelim);
#if defined (_DEBUG) //&& !defined (NOLOGS)
								{
									wxString strPointAt = wxString(ptr, 16);
									wxLogDebug(_T("TokTxt() line  %d , m_markers= [%s] , m_curChapter= [%s], strPointAt= [%s] "),
										__LINE__, pSrcPhrase->m_markers.c_str(), pApp->m_curChapter.c_str(), strPointAt.c_str());
									if (pSrcPhrase->m_nSequNumber >= 5)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
								}
#endif						
							} // end of TRUE block for test: if (pAux < pEnd && *ptr == _T(' ') && *(ptr + 1) == period)
							*/

						} // end of TRUE block for test: if (wholeMkr != verseMkr && !bIsToBeFiltered)

					} // end of TRUE block for test: if (pUsfmAnalysis != NULL && *ptr == gSFescapechar)
					// whm 20Jan2024 added else block here for treating an unknown marker that is not an empty marker
					else
					{
						// The pUsfmAnalysis was NULL at the previous LookupSFM() call so, we are dealing with an 
						// unknown marker which is NOT an empty marker (otherwise it would have been detected as an
						// empty marker much earlier in TokenizeText() where the if (IsEmptyMkr(), ptr...) call was
						// made.
						if (*ptr == gSFescapechar)
						{
							wholeMkr = GetWholeMarker(ptr);
							wxASSERT(!wholeMkr.IsEmpty());
							augWholeMkr = wholeMkr + _T(' ');
							if (!bIsToBeFiltered)
							{
								tokBuffer += augWholeMkr; // add our unknown marker tokBuffer
								tokBuffer.Trim(FALSE); // remove any initial white space
								
								if (pSrcPhrase->m_markers.IsEmpty())
								{
									// There is something to add to m_markers, do so and clear tokBuffer
									pSrcPhrase->m_markers = tokBuffer;

									int mmkrsLen;
									mmkrsLen = pSrcPhrase->m_markers.Length();
									ptr += mmkrsLen; // advance ptr (including initial whitespace if present)

									tokBuffer.Empty();
								}
								else
								{
									// pSrcPhrase->m_markers has content; tokBuffer may have some more to append,
									if (!tokBuffer.IsEmpty() && tokBuffer == pSrcPhrase->m_markers)
									{
										tokBuffer.Empty();
									}
									tokBuffer = augWholeMkr; // need the augmented marker here to provide space following marker

									pSrcPhrase->m_markers += tokBuffer;
									pSrcPhrase->m_markers = RemoveDuplicateMarkersFromMkrString(pSrcPhrase->m_markers);
									int tbLen;
									tbLen = tokBuffer.Length(); // whm 9Jan2024 note: tbLen will now always be the length of the marker
									ptr += tbLen; // advance ptr (including initial whitespace if present in tokBuffer)

									// whm 12Jan2024 modification. tokBuffer should be emptied once it has been assigned
									// to m_markers.
									tokBuffer.Empty();
								}

								// parse the whitespace following the marker to prepare for going to parsing
								int spAfterMkr = ParseWhiteSpace(ptr);
								if (spAfterMkr > 0)
								{
									precWordDelim = *ptr; // the post-mkr space in swbk needs to be replaced by whatever
									// whitespace char follows the marker
									pSrcPhrase->SetSrcWordBreak(precWordDelim);
									pSrcPhrase->m_precPunct += precWordDelim;
								}
								ptr += spAfterMkr;
								// It's an unknown marker
								// Set GUI important values on pSrcPhrase (current)
								pSrcPhrase->m_inform = _T("?") + atMkr + _T("?");
								pSrcPhrase->m_bSpecialText = TRUE;
								pSrcPhrase->m_curTextType = none;
								goto parsing;
							}
						}
					}

					// BEW 30Sep19 the one-line test with three subtest below

#if defined (_DEBUG) && !defined(NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 18);
						//wxLogDebug(_T("TokTxt() line  %d , sequNum = %d , bIsToBeFiltered %d, BEFORE SkipParseAWord(), strPointAt= [%s]"),
						//	__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)bIsToBeFiltered, strPointAt.c_str());
						wxLogDebug(_T("TokTxt() line %d, m_marker= [%s], bIsToBeFiltered = %d , chapter:verse= [%s], strPointAt= [%s]"),
							__LINE__, pSrcPhrase->m_markers.c_str(), (int)bIsToBeFiltered, pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
					}
#endif
					wxString whichMkr;
					if (!m_bWithinMkrAttributeSpan && !bIsUnstructured && !bIsToBeFiltered)
					{
						// BEW 21Jul23, moved the attributes support (i.e. bar after beginMkr) to
						// here, it was being untried after I moved the chapter block to precede
						// the verse block. Added 3rd subtest: !bIsToBeFiltered, because filtering
						// is done below and hiding attributes data makes no sense if it's marker
						// is gunna be filtered out up to (and including) the matching endMkr
						bool bHidingNeeded = FALSE;
#if defined (_DEBUG) && !defined (NOLOGS)
						{
							wxString strPointAt = wxString(ptr, 16);
							wxLogDebug(_T("TokTxt() line  %d , m_marker= [%s], bIsToBeFiltered = %d , pointsAt= [%s] "),
								__LINE__, pSrcPhrase->m_markers.c_str(), (int)bIsToBeFiltered, strPointAt.c_str());
						}
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
#endif
						if (*ptr == gSFescapechar)
						{ 
							// BEW 20Jul23, handle \fig as a special case. It's an attribute marker, but maybe intended for
							// filtering out - and the filtering out code is a long way below
							int offset;
							bool bFoundOne;// TRUE if we find a member of the charAttributeMkrs string
							wxUnusedVar(bFoundOne); // avoid gcc warning: set but not used
							//int anOffset;

							//anOffset = -1;
							//anOffset = gpApp->gCurrentFilterMarkers.Find(lookupStr);

							//bIsToBeFiltered = anOffset != -1; // sets bIsToBeFiltered

							// If it's for hiding the metadata, we can't do the hiding
							// if further down the marker will be filtered out (e.g.
							// a \fig ... \fig* span, is default filtered out). So we
							// need to check here to find out if it will be filtered,
							// because the filtering out is done before control gets to
							// ParseWord()
							wxString wholeMkr;
							wholeMkr = GetWholeMarker(ptr);
							wxASSERT(!wholeMkr.IsEmpty());
							wxString augmentedWholeMkr;
							augmentedWholeMkr = wholeMkr;
							augmentedWholeMkr += _T(' ');
							// If it is a nested marker, like \+jmp then the + will
							// advsersely affect a string .Find() for the augmented
							// marker, as AI_USFM does not have separate entries for
							// nested markers with the + So we have to check for
							// the + and remove it before doing the Find()
							
							// whm 20Jan2024 added check if augWholeMkr is an AI custom marker \free \note 
							// or \bt... marker - which are obligatorily filtered.
							bool bIsForeignBackTransMkr = FALSE;
							bIsToBeFiltered = (pApp->gCurrentFilterMarkers.Find(augmentedWholeMkr) != wxNOT_FOUND);
							if (!bIsToBeFiltered)
							{
								bIsToBeFiltered = IsMarkerFreeTransOrNoteOrBackTrans(augmentedWholeMkr, bIsForeignBackTransMkr);
							}

							// In the next call, 3rd param bool bRemoveAll is  default FALSE
							// causing it to search for first incidence of aPlus and remove
							// that one only, if it exists in the passed in string
							lookupStr = augmentedWholeMkr; // lookupStr declared at 18510
							lookupStr = RemoveSubstring(lookupStr, aPlus); // remove aPlus ( '+' )
							augmentedWholeMkr = lookupStr;

							bHidingNeeded = IsAttributeMarker(ptr);
							if (bHidingNeeded)
							{
#if defined (_DEBUG) && !defined (NOLOGS)
								{
									wxString strPointAt = wxString(ptr, 16);
									//wxLogDebug(_T("TokTxt() line  %d ,  bIsToBeFiltered = %d , strPointAt= [%s] "),
									//	__LINE__, (int)bIsToBeFiltered, strPointAt.c_str());
									wxLogDebug(_T("TokText() line  %d , m_marker= [%s], bIsToBeFiltered = %d , strPointAt= [%s] "),
										__LINE__, pSrcPhrase->m_markers.c_str(), (int)bIsToBeFiltered, strPointAt.c_str());
								}
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
								}
#endif
								// BEW 20Jul23 this block is for handling \fig, on the assumption
								// it is listed in the charAttributeMkrs fast-access string (see Doc,cpp 
								// about line 313).  \fig is default filtered, so don't do hiding of bar-initial
								// data, if bIsToBeFiltered is TRUE, because filtering removes it from being
								// able to contribute an entry to pSrcPhrase->m_punctsPattern
								if (!bIsToBeFiltered)
								{
									offset = wxNOT_FOUND;
									offset = charAttributeMkrs.Find(augmentedWholeMkr);
									if (offset != wxNOT_FOUND)
									{
										// It is a beginMkr of the charAttribute type 
										bIsInlineBindingMkr = FALSE;
										bIsInlineNonbindingMkr = FALSE;
										bIsCharAttrMkr = TRUE;
										bFoundOne = TRUE;
										bKeepPtrFromAdvancing = TRUE;
										// The only charAttributeMkr (i.e an begin-marker) we are considering
										// here is \fig  There are a few reasons:
										// (0) must handle before any parsing moves ptr beyond pointing at backslash
										// (1) these markers do not change the TextType, except for \fig which
										// needs to cause a type change at the pSrcPhrase which commences the caption's
										// span of CSourcePhrases (to 'noType' enum value), and therefore the
										// member m_bSpecialText needs to be set TRUE, if \fig was the marker
										// found. The current pSrcPhrase needs its m_bSpecialText set TRUE if
										// the felicity conditions are satisfied, because it is the first of
										// the caption's span in USFM 3.0 (but not in earlier versions of USFM)
										// (2) The end of the span of caption CSourcePhrase instances needs to
										// be reset to verse (default) when \fig* is later encountered.
										// IsTextTypeChangingEndMarker(pSrcPhrase) does that job below in the
										// 'propagation' code, after ParseWord() has done its job.
										// (3) Other markups that involve inline span involve m_marker and
										// m_endMarker members; these are \f and \x and \fe, and they are
										// handled adequately from TokenizeText's legacy code.
										wxString aMkr = wxEmptyString;
										bool bIsCharacterAttrMkr = IsAttributeBeginMarker(ptr, aMkr);
										bool bIsFigure = (aMkr == _T("\\fig"));
										whichMkr = aMkr;

										//if (bIsCharacterAttrMkr && bIsFigure && !bKeepPtrFromAdvancing) // BEW 25Jul23 added 3rd subtest
										if (bIsCharacterAttrMkr && bIsFigure) // whm 31Oct2023 removed 3rd subtest
										{
											// Set m_inform and m_bSpecialText, because this marker
											// is \fig at the beginning of a figure's caption text
											// whm 31Oct2023 I initially on 23Sep2023 commented out the following 
											// 4 lines which change some of the attributes for the \fig marker which
											// is by default filtered. Although these are normally set properly in 
											// the AI_USFM.xml, when unfiltering the \fig marker, non-default values 
											// are needed. Although the desired non-default values could be set by
											// calling other functions, that may not have been done, so as of this 
											// date I'm re-enabling the assignments below.
											pSrcPhrase->m_inform = pUsfmAnalysis->navigationText; // set it to "figure"
											pSrcPhrase->m_bSpecialText = TRUE;
											pSrcPhrase->m_bFirstOfType = TRUE;
											pSrcPhrase->m_curTextType = noType;
											// BEW 21Jul23 - I dunno if this legacy comment still applies - testing will tell
											// ParsePreWord() will need a tweak to handle \fig as
											// a special (bleed out) case; ParseWord() will need
											// no change, and then the propagation code following
											// ParseWord() will need tweaking also to handle \fig
											// as a (bleeding) special case
										}
										// When it's not \fig, it can be one of several others, so bIsCharAttrMkr can be
										// made use of when in ParsePhreWord(), and after that, in ParseWord()

									} // end of else block of test: if (offset != wxNOT_FOUND)
								} // end of TRUE block for test: if (!bIsToBeFiltered)
								// No else block  because we don't stored bar data if filtering is to be done
#if defined (_DEBUG) && !defined (NOLOGS)
								{
									wxString strPointAt = wxString(ptr, 16);
									wxLogDebug(_T("TokText() line  %d , m_markers= [%s], bIsToBeFiltered = %d , strPointAt= [%s] "),
										__LINE__, pSrcPhrase->m_markers.c_str(), (int)bIsToBeFiltered, strPointAt.c_str());
								}
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
								}
#endif
								if (!bIsToBeFiltered)
								{
									// Okay, if it's not going to be filtered, so bar contents can 
									// be hidden when control enters ParseWord(), then set bools
									m_bWithinMkrAttributeSpan = TRUE;
									m_bHiddenMetadataDone = FALSE;
								}
								else
								{
									// It's to be filtered out, so we don't want the
									// attributes metadata to be hidden
									m_bWithinMkrAttributeSpan = FALSE;
									m_bHiddenMetadataDone = FALSE;
								}

								// BEW 16Dec22 need some refactoring here. If IsAttributeBeginMarker() returns
								// TRUE (e.g for \fig ... \fig* span, or \f ... \f* span, etc), we must not
								// let the TRUE value be using in the test for entry to the filtering code block
								// mush below - because allowing such entry, if bar ( | ) is encountered, the
								// ParseWord()'s ParseAWord() call will assert. Here we just clear the storage,
								// getting ready for ParseWord to deal with adding to m_punctsPattern (around 37153)
								bool bItsABeginMarkerForAttributes = IsAttributeBeginMarker(ptr, whichMkr);
								if (bItsABeginMarkerForAttributes)
								{
									// Get rid of any left-over earlier-cached attributes metadata
									if (m_bWithinMkrAttributeSpan)
									{
										ClearAttributeMkrStorage(); // clears, and also sets 
															// m_bWithinMkrAttributeSpan to FALSE
										// Need pSrcPhrase to clear the m_punctsPattern string, which is the cache store
										pSrcPhrase->m_punctsPattern.Empty();
										pSrcPhrase->m_bUnused = FALSE; // ensures it's bit-flag (22) is 0
									}
								} // ParseWord() deals with hiding attributes, at its entry

							} // end of TRUE block for test: if (bHidingNeeded)
							else
							{
								// Either it is going to be filtered, or there is nothing
								// to hide, or there is no span to worry about
								m_bWithinMkrAttributeSpan = FALSE;
								m_bHiddenMetadataDone = FALSE;
							}
						} // end of TRUE block for test: if (*ptr == gSFescapechar)

					} // end of TRUE block for test: if (!m_bWithinMkrAttributeSpan && !bIsUnstructured && !bIsToBeFiltered)

					// whm revised this block 11Feb05 to support USFM and SFM Filtering. When
					// TokenizeText encounters previously filtered text (enclosed within
					// \~FILTER ... \~FILTER* brackets), it strips off those brackets so that
					// TokenizeText can evaluate anew the filtering status of the marker(s)
					// that had been embedded within the filtered text. If the markers and
					// associated text are still to be filtered (as determined by examining 
					// whether the marker is present within the App's gCurrentFilterMarkers
					// string, the filtering brackets are added again. If the markers should 
					// no longer be filtered, they and their associated text are processed 
					// normally.

					// BEW comment 11Oct10, this block handles filtering. In the legacy
					// version of TokenizeText() propagation of TextType was also handled
					// here, resulting in a spagetti mishmash of code. I've taken out the
					// propagation code and put it after the ParseWord() call, so that what is
					// done here is simpler - just handling any needed filtering.

					// BEW 11Oct10, A note about how we handle inline markers, other than those
					// beginning with \f (footnote type) or \x (crossReference type), is
					// appropriate. While not a USFM distinction, for Adapt It's purposes we
					// view these as coming in two subtypes - binding ones (these bind more
					// closely to the word than punctuation, eg \k \k*, \w \w*, etc) and
					// non-binding ones (only 5, \wj \wj*, \tl \tl*, \sls \sls*, \qt \qt*, and
					// \fig \fig*) which are 'outer' to punctuation - that is, punctuation
					// binds more closely to the word than these. We want ParseWord() to handle
					// parsing once any of the non-\f and non-\x inline markers are
					// encountered, and we don't want any of these to insert its TextType value
					// into the document in m_curTextType anywhere at all, in doc version 5. So
					// we check for these marker subtypes and process accordingly if any such
					// has just been come to. Such markers are never filtered nor filterable,
					// we just want to ignore them as much as possible, but reconstitute them
					// correctly to the exported text when an export has been requested. Also,
					// these are the marker types which very often have endmarkers, and we want
					// ParseWord() to take over all processing of endmarkers, so that
					// TokenizeText() only deals with beginmarkers. In doc version 5 it never
					// happens now that an endmarker will be stored in m_markers (in the legacy
					// parser, that was not true).
					// BEW 25Feb11, added code to use pUsfmAnalysis looked up to set
					// m_curTextType and m_bSpecialText which were forgottten here
					// BEW 24Oct14, the rapid access strings for binding markers-
					// m_inlineBindingMarkers, now contains a \+tag variant for each \tag
					// marker; similarly and the two strings m_inlineNonbindingMarkers and
					// m_inlineNonbindingEndMarkers likewise contain marker and nested marker
					// variants - so these permit rapid lookup of nested markers; but other
					// marker types (which never can be nested) do not have \+tag variants in
					// their rapid access collections. Beware, and code accordingly....

					wholeMkr = GetWholeMarker(ptr);
					int wholeMkrLen = wholeMkr.Length();
					wxString augmentedWholeMkr = wholeMkr + _T(' '); // prevent spurious matches
					wxString bareMkr = wholeMkr.Mid(1); // chop off the initial backslash
#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokText() line %d, chapter:verse= [%s], m_marker= [%s], bIsToBeFiltered = %d , strPointAt= [%s] "),
							__LINE__, pSrcPhrase->m_chapterVerse.c_str(), pSrcPhrase->m_markers.c_str(), (int)bIsToBeFiltered, strPointAt.c_str());
					}
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
					}
#endif
					// BEW 17Apr23 Nyindrou Luke 24:39-40 has a '[' after the end of verse 39's text,
					// and before the line which starts \v 40. What occurs there is \p<space>[\n\v 40 Eme..."
					// The sequence beginMkr<space[\n\v does not currently parse, so we want to handle a
					// beginMkr followed by space followed by [ followed by newline and then a gSFescapechar,
					// (for the test - including some context of course), and we want the [ to end up on
					// it's own pSrcPhrase, so the next iteration's pSrcPhrase will be for ptr pointing at
					// the "newline then \v .... etc". Note: when control gets to here, tokBuffer may have
					// some as-yet unassigned content for m_markers.
					wxChar* pSavedPtr;
					pSavedPtr = ptr;
					int nSaveItemLen; wxUnusedVar(nSaveItemLen);
					int anItemLen; // use if we parse over some content
					anItemLen = 0; // initialise
					bool bIsEndMkr = FALSE; // init
					bool bIsBeginMkr = IsBeginMarker(ptr, pEnd, wholeMkr, bIsEndMkr);
					nSaveItemLen = itemLen; // in case tokBuffer has some content pending assigning to m_markers
					if (!wholeMkr.IsEmpty())
					{
						anItemLen += wholeMkrLen;
#if defined (_DEBUG) && !defined (NOLOGS)
						{
							wxString strPointAt = wxString(ptr, 16);
							wxLogDebug(_T("TokTxt() line  %d , chapter:verse= [%s], bIsBeginMkr = %d, m_markers= [%s], wholeMkr = %s, strPointAt= [%s]  Inner loop BEGINS "),
								__LINE__, pSrcPhrase->m_chapterVerse.c_str(), (int)bIsBeginMkr, pSrcPhrase->m_markers.c_str(), wholeMkr.c_str(), strPointAt.c_str());
						}
#endif
						pSavedPtr = ptr; // this won't have moved in value
#if defined (_DEBUG) && !defined (NOLOGS)
						{
							if (pSrcPhrase->m_nSequNumber >= 5)
							{
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
						}
#endif
						// BEW 5Jun23, if the above block was entered at ptr pointing at a begin mkr, it will
						// have parsed over it and saved in m_markers**, and dealt with any puncts for m_precPunct.
						// ptr may now be pointing at another beginMkr, such as a character format beginMkr, so
						// if a marker follows, LookupSFM has to be done here to get its identity and width etc
						// BEW 20Nov23, ** in comment above: Unilateral saving of a beginMkr in m_markers must only
						// apply to non-inline beginMks, and non-attributeMkrs. If data like: \k Jesus Krais\k*,
						// occurs, where \k belongs to the gpApp->m_charFormatMkrs inlinemarkers set, the \k being
						// put into m_markers is a storage error. Fix this, shortly after LookupSFM is called a
						// few lines further down.
						if (*ptr == gSFescapechar)
						{
							pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr);
							if (pUsfmAnalysis != NULL)
							{
								// A marker exists at ptr, we just want to be sure it's not an endMkr
								// so we test for that next.
								// In this block we only store '[' if that's what pAux is pointing at, as
								// we need to be sure that ParseWord() does not get called to handle a
								// begin marker (except in some exceptional cases - which it supports)
								wholeMkr = GetWholeMarker(ptr);
								augmentedWholeMkr = wholeMkr + _T(' ');
								wholeMkrLen = wholeMkr.Length();
#if defined (_DEBUG) //&& !defined (NOLOGS)
								{
									wxString strPointAt = wxString(ptr, 16);
									//wxLogDebug(_T("TokText() line  %d , m_markers= [%s] , chapter:verse= [%s], pointsAt= [%s] , 2ndLookup wholeMkr=[%s]"),
									//	__LINE__, pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str(), wholeMkr.c_str());
									if (pSrcPhrase->m_nSequNumber >= 198)
									{
										int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
									}
								}
#endif
								wxChar* pAux = ptr;
								if (!IsEndMarker(ptr, pEnd))
								{
									// BEW 20Nov23, add a block here, for data like ptr pointing at: \k Jesus Krais\k*,
									// BeginMkrs from the m_charFormatMkrs set, or m_inlineNonbindingMarkers set must be
									// stored in the special locations on pSrcPhrase specific to them; m_inlineBindingMarkers
									// and m_inlineNonbindingMarkers, repectively
									int offset = wxNOT_FOUND;
									offset = pApp->m_charFormatMkrs.Find(augmentedWholeMkr);
									if (offset >= 0 && pSrcPhrase->m_markers.IsEmpty())
									{
										// It's one of the several markers like \k \it etc, textType 
										// 'none' - binding ones
										bIsInlineBindingMkr = TRUE;
										bIsInlineNonbindingMkr = FALSE;
										bIsCharAttrMkr = FALSE;
										// We have enough info to store it, do so
										if (bIsInlineBindingMkr && !bIsCharAttrMkr)
										{
											int nAugMkrLen = wholeMkrLen + 1; // +1 for the following space
											wxString strInlineBindingBeginMkrs;
											strInlineBindingBeginMkrs = pSrcPhrase->GetInlineBindingMarkers();
											strInlineBindingBeginMkrs += augmentedWholeMkr;
											pSrcPhrase->SetInlineBindingMarkers(strInlineBindingBeginMkrs);
											// Update ptr (whm removed the (size_t) cast on the call below)
											ptr += nAugMkrLen;
											// whm 22Jan2024 modified. At this point the marker is bIsInlineBindingMkr TRUE
											// and an inline binding marker like \fk has been parsed over with the ptr
											// pointing after the following space at what follows, and what follows should
											// likely be a text word. Therefore there should be a break call at this point
											// in order for ParseWord() to be able to parse the word(s) following this 
											// inline binding marker. This addition fixed the garbled parsing of the \fk
											// marker
											break; // whm 22Jan2024 added to break back to ParsePreWord() and ParseWord().
										}
									}
									/* 
										// BEW 20Nov23 commented out this block, because it's relevant only if an
										// inlineNonbindingBeginMkr precedes a m_inlineBindingMkr like \k --
										// and what makes this reasonable is that the above test:
										// if (offset >= 0 && pSrcPhrase->m_markers.IsEmpty())
										// has a subtest for m_markers being empty - because it's unlikely that
										// an inline binding beginMkr would be preceded by something like \wj
										// when the m_markers member is empty. If this assumption is violated,
										// then remove this commenting out
									else
									{
										// It's not 'binding' type, check if it's 'non-binding' type
										offset = pApp->m_inlineNonbindingMarkers.Find(augmentedWholeMkr);
										if (offset != wxNOT_FOUND)
										{
											// It's a nonbinding type
											bIsInlineBindingMkr = FALSE;
											bIsInlineNonbindingMkr = TRUE;
											bIsCharAttrMkr = FALSE;

											// BEW 6May23, we have to retest for inline binding beginMkr here.
											// Why? Because the source text parse may have come to an
											// inline nonbinding beginMkr (which very conceivably would precede
											// a following inline binding beginMkr. I have such data, and it
											// led to the inline binding beginMkr being placed by ParsePreWord()
											// in the default location, m_markers, in which it definitely does NOT belong.
											// ParsePreWord will handle the inline binding beginMkr correctly if we
											// here determine that something like the \k of  \k .... \k* (keyword)
											// is the next beginMkr and so bIsInlineBindingMkr will be set TRUE.
											// (ParsePreWord() is not marker-order-sensitive, fortunately)
											int inlineNBMrkLen = augmentedWholeMkr.Length(); // for, say, \wj<space> that's 4
											wxChar* pAux = (ptr + inlineNBMrkLen); // pAux might now be pointing at a binding beginMkr
											if (*pAux == gSFescapechar)
											{
												wxString myBeginMkr = GetWholeMarker(pAux);
												// use bool CAdapt_ItDoc::IsEndMarker2(wxChar* pChar)
												if (!myBeginMkr.IsEmpty())
												{
													bool bIsNotEndMkr = !IsEndMarker2(pAux);
													if (bIsNotEndMkr)
													{
														// It's a beginMkr
														wxString augBeginMkr = myBeginMkr + _T(' '); // for fast-access test
														int offset3 = wxNOT_FOUND; wxUnusedVar(offset3); // avoid compiler warning variable initialized but not referenced
														bool bIsMyInlineBindingMkr = gpApp->m_charFormatMkrs.Find(augBeginMkr);
														if (bIsMyInlineBindingMkr)
														{
															// TRUE, it belongs to the marker set that has \k \it etc
															bIsInlineBindingMkr = TRUE;
														}
														// If bIsInlineBindingMkr was not set TRUE here, then ParsePreWord() would
														// probably "lose it", and it would get picked up as a member of m_markers,
														// leading to m_srcSinglePattern not having it, when it should
													}
												}
											}
										}
										// BEW 9Jan2023 I need to check the m_RedBeginMarkers set, that's where \rq is. m_RedEndMarkers has \rq*
										// There are a heap of markers in these red sets, they are not necessarily inLine; but a not 'verse or 'poetry'
										else
										{
											offset = pApp->m_RedBeginMarkers.Find(augmentedWholeMkr);
											if (offset != wxNOT_FOUND)
											{
												// these markers are not for 'sacred' text, but for things like \rq etc, they store like \f would
												bIsInlineBindingMkr = FALSE;
												bIsInlineNonbindingMkr = FALSE;
												// m_bInRedSet = TRUE; // set the doc member bool; not filterable BEW24Aug23 remove, unused
												bIsCharAttrMkr = FALSE;
											}
											else
											{
												// It's not a character formatting mkr
												// It's not a 'binding' type of mkr
												// It's not a 'non-binding' type of mkr
												// It's not one of the Red set
												// So let the legacy code decide what to do
												bIsInlineBindingMkr = FALSE;
												bIsInlineNonbindingMkr = FALSE;
												bIsCharAttrMkr = FALSE;
											}
										}
									} // end of the else block for test: if (offset >= 0) - for char format mkrs
									*/
									// it's a beginMkr
									pAux += wholeMkrLen; // point pAux past the beginMkr, space should follow
									// Test: are the next two characters   <space>[
									if (*pAux == _T(' ') && *(pAux + 1) == _T('['))
									{
										// There are two possibilities not yet handled by our parser. 
										// Possibility 1: *(pAux + 2) == _T('\n') ---- i.e. the [ is immediately prior to line end
										// Possibility 2: *(pAux + 2) == gSFescapechar ---- i.e. there is another marker after this one
										// This block can handle both, so test for either being true
										// 
										// whm 20Jan2024 modification. The input texts are now normalized to always have
										// the two EOL chars \r\n. Therefore the if test below will fail because pAux is
										// pointing at a space and pAux + 1 is pointing at a '[' char. If EOLs are at 
										// pAux + 2 it would be \r and not \n of the sequence \r\n. To be safe, I'll 
										// modify the test to detect either \r or \n at the position pAus + 2 immediately 
										// after the '[' at pAux + 1. 
										//if (*(pAux + 2) == _T('\n') || *(pAux + 2) == gSFescapechar)
										if (*(pAux + 2) == _T('\r') || *(pAux + 2) == _T('\n') || *(pAux + 2) == gSFescapechar)
										{
											// handle  these
											wxString strExtras = _T(" ["); // we parse only over the '['
											if (!tokBuffer.IsEmpty())
											{
												pSrcPhrase->m_markers += tokBuffer; // make sure any content is not lost
												tokBuffer.Empty();
											}
											pSrcPhrase->m_key = _T("[");
											pSrcPhrase->m_srcPhrase = _T("[");
											anItemLen += 2;
											// don't put [ in pSrcPhase->m_follPunct or m_precPunct, as we'd cause doubling of [
											ptr += anItemLen;
											bContinueTwice = TRUE;
											if (*(pAux + 2) == gSFescapechar)
											{
												// set bSuppressBackwardSearchForWordBreakChar to TRUE. This is the only place we set it TRUE, we use it
												// to suppress searching for whitespace immediately before a beginMkr, and
												// we clear it to default FALSE when a new pSrcPhrase is generated
												bSuppressBackwardSearchForWordBreakChar = TRUE;
											}
											continue; // repeat inner loop where the while loop will break as it will be false - 5th continue in TokenizeText()
										}
										else
										{
											// no change yet, continue parsing
											ptr = pSavedPtr;
										}
									} // end of TRUE block for test: if (*pAux == _T(' ') && *(pAux + 1) == _T('['))
								} // end of TRUE block for test: if (!IsEndMarker(ptr, pEnd))

							} // end of TRUE block for test: if (pUsfmAnalysis != NULL)
						} // end of TRUE block for test: if (*ptr == gSFescapechar)
					} // end of TRUE block for test: if (!wholeMkr.IsEmpty())
#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokText() line  %d, chapter:verse= [%s], m_markers= [%s],  bIsToBeFiltered = %d , pointsAt= [%s] "),
							__LINE__, pSrcPhrase->m_chapterVerse.c_str(), pSrcPhrase->m_markers.c_str(), (int)bIsToBeFiltered, strPointAt.c_str());
					}
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
					}
#endif
					// BEW 11Oct10, the block for detecting an inline marker which is not
					// one of the \f set nor one of the \x set..., or the \e set (\ef, \ex).
					// if the test succeeds, then in the block we set needed flags and then
					// break out of the inner loop
					//
					// BEW 25Feb11, we don't want to hand off \va ...\va*, (verse alternate)
					// nor \vp ...\vp* (verse published) to ParsePreWord() - which will correctly
					// handle them as inline binding markers, but leave the number as adaptable
					// text in the view; 
					// instead, 
					// these are default filtered in the AI_USFM.xml file, so we have to test
					// for them here and skip this block if either ov these was what bareMkr is
					// (only if the user unfilters them should their number be seeable and adaptable)
					//
					// BEW 30Sep19 on the fourth line, add test for bareMkr not beginning with
					// "\e" so as to let USSFM3 extended markers \ef (extended footnote) or
					// extend cross ref \ex also cause the TRUE block to be skipped. But beware,
					// the character inline binding marker, \em begins with 'e', so 3rd line
					// needs extra test to return TRUE if bareMkr is em - to bleed out confusion
					// with the subsequent initial 'e' subtest.
#if defined (_DEBUG) && !defined (NOLOGS)
					{
						wxString strPointAt = wxString(ptr, 16);
						wxLogDebug(_T("TokText() line  %d, m_markers= [%s], chapter:verse= [%s], pointsAt= [%s] , after 2ndLookup"),
							__LINE__, pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_chapterVerse.c_str(), strPointAt.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
					}
#endif
					if (pUsfmAnalysis != NULL			// indicates the marker is a USFM2 or 3 one
						&& (pUsfmAnalysis->inLine		// the main subtest, is it inLine?
							|| bareMkr.Find(_T("em")) == 0) // // bleed out \em, as it's inLine too
						&& bareMkr.Find('f') != 0 && bareMkr.Find('x') != 0 && bareMkr.Find('e') != 0
						// The 3 subtests above each return TRUE provided the marker is not beginning
						// with f, x, or e. So, encountering \f, \x, or \ef, or \ex, will cause one
						// of these subtests to fail, and so the TRUE block below will be skipped.
						// Although those four are inLine, we want to deal with them here in
						// TokenizeText() because we want to store them in m_markers. (Their endmarkers,
						// and \esbe as well, will be dealt with in or after ParseWord().)
						&& bareMkr.Find(_T("va")) != 0 && bareMkr.Find(_T("vp")) != 0
						// The two subtests above each return TRUE provided the marker is
						// not \va nor \vp -- these two are inline, but exceptions because
						// where these occur in data is immediately after \v, and so we
						// want these to be stored after \v in m_markers. So for \va or \vp,
						// the test should fail, and the code further below in TokenizeText()
						// will deal with them. The actual assignment of content to m_markers
						// happens after ParseWord() has completed, the markers content is
						// accumulated in tokBuffer
						)
					{
						// inline markers are known to USFM, so pUsfmAnalysis will not be
						// false; the test succeeds if it is not an unknown marker, and is an
						// inline marker, but not one of the inline markers which begin with
						// \x or \f or \e and neither is it \va nor \vp. Any marker that gets
						// through those tests is one which we immediately hand off in this
						// block for ParsePreWord() and then ParseWord() to deal with.
						//
						// BEW 24Oct14, none of \x \f \va or \vp can never be a nested marker,
						// and so if ptr is pointing at the + of a nested marker, we want to
						// hand any such off to ParsePreWord() then ParseWord() immediately too,
						// so no change
						// needed here - and the test using m_inlineNonbindindMarkers just
						// below will correctly find any such, since they are included in
						// this rapid access string for lookup purposes
						// BEW 30Sep19 In USFM3, \q is an inLine marker taking an endmarker \q*

						// the hand-off takes place outside the loop, so set the flags we need
						// to know beforehand, they are needed for ParsePreWord()'s signature
						bIsInlineNonbindingMkr = FALSE; // default
						bIsInlineBindingMkr = FALSE;    // default
						// Check for an endmarker that failed to be parse - the
						// way to handle this should be to parse it and append it
						// to an appropriate member in the previous CSourcePhrase
						// instance.
						wxString wholeEndMkr = wxEmptyString; // initialize
						bool bIsAnEndMkr = FALSE; // initialize
						int myOffset = wxNOT_FOUND;
						myOffset = wholeMkr.Find(wxString(_T('*')));
						if (myOffset != wxNOT_FOUND)
						{
							// The whole mkr contains *, so is an endmarker -- this is
							// a parsing error because the endmarker should have been
							// included in the parse done by ParseWord() for the previous
							// CSourcePhrase instance, because it's ParseWord which handles
							// post-word endmarkers
							wholeEndMkr = wholeMkr;
							bIsAnEndMkr = TRUE;
						}
						//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"),
						//__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

						// Test for what kind of marker; binding or non-binding or char attribute mkr; 
						// but in the case it was an unexpected end marker - deal with that
						if (bIsAnEndMkr && !m_bWithinMkrAttributeSpan)
						{
							int previousLocation = pSrcPhrase->m_nSequNumber;
							wxString strPrevKey = _T("unknown"); // whm 21Sep2023 changed to "unknown"
							wxString strPrevAdaption = _T("unknown"); // whm 21Sep2023 changed to "unknown"
							// BEW 29Sep22 Note: pSrcPhrase here may be a just-created instance
							// which has nothing more than a sequNum set, because it is yet to be
							// filled out with parsed data. Such a pSrcPhrase will not have a presence
							// in m_pSourcePhrases list, nor will there be a partner pile created for
							// it in the PileList. Control has gotten here because of an error in parsing,
							// so it's that that needs to be fixed. Or the parsing code needs a fix.

							pLayout->ClearPostWordDataPointers();

							// BEW 27Sep22 add safe code if an errant endmarker is found
							if (pSrcPhrase->m_nSequNumber >= 13)
							{
								// set sequNum for previous CSourcePhrase instance
								pLayout->m_nSequNum_LastSrcPhrase = pSrcPhrase->m_nSequNumber - 1;
								// BEW 29Sep22, if pSrcPhrase is a just-created one, then it will
								// have no presence in m_pSourcePhrases nor a pile ptr in the pile list.
								// So while the above line generates a sequNum value, trying to get that
								// pile will fail - returning NULL.
							}
							else
							{
								pLayout->m_nSequNum_LastSrcPhrase = 0; // safe, if the document exists
							}
							wxString strApproxLocation;
							//int badMkrLength = wholeEndMkr.Len();
							CPile* pPile = this->GetPile(pLayout->m_nSequNum_LastSrcPhrase);
							if (pPile != NULL)
							{
								// BEW 29Sep22 - can't do this block if pPile was returned NULL, but there
								// is likely a data error, or parsing error, that caused entry to the above
								// code, that needs to be sorted out
								CSourcePhrase* pLastSrcPhrase = pPile->GetSrcPhrase();
								previousLocation = pSrcPhrase->m_nSequNumber;
								strPrevKey = pLastSrcPhrase->m_key;
								strPrevAdaption = pLastSrcPhrase->m_adaption;
							}
							// BEW15Dec22 try to provide an approximate src string for the error - 30 chars either side
							// of the ptr value, or less if near start of end of input doc
							// whm 21Sep2023 extended the approx location to be 120 chars wide - 60 either side.
							wxChar* pDocStart = pBufStart;
							wxChar* pLocBefore;
							wxChar* pLocAfter;
							if ((ptr - 60) > pDocStart)
							{
								pLocBefore = (ptr - 60);
							}
							else
							{
								pLocBefore = pDocStart;
							}
							if ((ptr + 60) < pEnd)
							{
								pLocAfter = (ptr + 60);
							}
							else
							{
								pLocAfter = pEnd;
							}
							size_t width = (size_t)(pLocAfter - pLocBefore);
							if (width > 120)
							{
								width = 120;
							}
							strApproxLocation = wxString(pLocBefore, width);

							// whm 28Sep2023 added a chapter:verse reference to the warning msg.
							// Get the chapter and verse of the current context for the warning.
							// Internally GetSourcePhraseByIndex() scans backwards till it finds the
							// information needed, or comes to doc start. Here we need to start with 
							// the m_nSequNumber before the current one, since the current one won't
							// yet be stored in the App's pSrcPhrases list, otherwise the GetSourcePhraseByIndex()
							// function would generate an index error.
							CSourcePhrase* pSP = pApp->GetSourcePhraseByIndex(pSrcPhrase->m_nSequNumber - 1);
							wxString cv = _T("");
							if (pSP != NULL)
								cv = pApp->GetView()->GetChapterAndVerse(pSP);
							if (cv.IsEmpty())
								cv = _("Unknown location");
							// whm 21Sep2023 modified the wxMessagBox below to have a more useful msg for users.
							wxString wholeBeginMkr;
							int posAsterisk = wholeEndMkr.Find(_T("*"));
							if (posAsterisk != wxNOT_FOUND)
							{
								wholeBeginMkr = wholeEndMkr.Mid(0,posAsterisk);
							}
							// whm 30Sep2023 removed the strPrevKey, strPrevAdaption, previousLocation from message below as they were never clear/definitive in my tests.
							wxString msg = _("Warning: While loading the source text file at chapter:verse %s, unexpected markers, %s ... %s , were encountered.\nThey occur at sequence number: %d, and within the span:\n\n%s.");
							//wxString msg = _("Warning: While loading the source text file at chapter:verse %s, unexpected markers, %s ... %s , were encountered.\nThey occur in the pile following the one with source: %s and target: %s\n at sequence number: %d, and within the span:\n\n%s\n\nFix the input source text file, then re-load to re-create the document.");
							//msg = msg.Format(msg, cv.c_str(), wholeBeginMkr.c_str(), wholeEndMkr.c_str(), strPrevKey.c_str(), strPrevAdaption, previousLocation, strApproxLocation.c_str());
							msg = msg.Format(msg, cv.c_str(), wholeBeginMkr.c_str(), wholeEndMkr.c_str(), previousLocation, strApproxLocation.c_str());
							wxString msg2;
							msg2 = _("When Adapt It encounters \"Unexpected\" markers, it means that either Adapt It doesn't recognize the markers, or they are not located where Adapt It would expect them within the text.\nYou should avoid putting punctuation between consecutive end markers. Put any final punctuation after consecutive end markers.\n\nFix the input source text file, then re-load to re-create the document.\n\nDo you want to continue loading the file?");
							msg2 = _T("\n\n") + msg2;
							msg = msg + msg2;
							wxString title = _T("Warning: Unexpected Markers in chapter:verse %s");
							title = title.Format(title, cv.c_str());
							int response = 0;
							response = wxMessageBox(msg, title, wxICON_WARNING | wxYES_NO | wxNO_DEFAULT);
							if (response == wxNO)
							{
								wxString responseStr = _("User selected No");
								pApp->LogUserAction(responseStr);
								pApp->LogUserAction(msg);
								wxString stopMsg = _("Adapt It will now stop running.\n\nWhen you have fixed the input text, run Adapt It again and try loading the edited text into Adapt.");
								wxMessageBox(stopMsg, responseStr, wxOK);
								pApp->LogUserAction(stopMsg);
								wxKill(::wxGetProcessId(), wxSIGKILL); // Calling wxKill() on the current process is a quiet way to terminate.
							}
							else
							{
								wxString responseStr = _("User selected Yex");
								pApp->LogUserAction(responseStr);
								pApp->LogUserAction(msg);
								wxString continueMsg = _T("Adapt It will continuing trying to load the input text.\n\nIf the input text completes loading, be sure to check it at chapter:verse %s for proper formatting.");
								continueMsg = continueMsg.Format(continueMsg, cv.c_str());
								wxMessageBox(continueMsg, responseStr, wxOK);
								pApp->LogUserAction(continueMsg);
							}
						} // end of TRUE block for test: if (bIsAnEndMkr && !m_bWithinMkrAttributeSpan)
						else
						{
							// Not an endmarker. 
							// BEW 28Apr20 refactored the tests; 21Jul23

							//m_bInRedSet = FALSE; // init  BEW 9Jan23, it's a doc.h member bool, 
								// set only when augmented beginMkr is in m_RedBeginMarkers BEW 24Aug23 removed, it's unused 
							bIsCharAttrMkr = FALSE; // init
							// HERE following we just set booleans, we don't parse
#if defined (_DEBUG) && !defined(NOLOGS)
							if (pSrcPhrase->m_nSequNumber >= 13)
							{
								//wxString ptrPointsAt;
								ptrPointsAt = wxString(ptr, 16);
								wxLogDebug(_T("TokText(), line %d : sequNum = %d , m_markers= [%s], wholeMkr= [%s] , m_curTextType = %d, m_key = [%s] , ptrPointsAt= [%s]"),
									__LINE__, (int)pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), wholeMkr.c_str(), (int)pSrcPhrase->m_curTextType,
									pSrcPhrase->m_key.c_str(), ptrPointsAt.c_str());
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
#endif
							int offset = wxNOT_FOUND;
							offset = charAttributeMkrs.Find(augmentedWholeMkr); // \w, \fig, etc
							if (offset >= 0)
							{
								if (offset != wxNOT_FOUND)
								{
									// it's one of the beginMkrs in the character attributes set
									bIsInlineBindingMkr = FALSE;
									bIsInlineNonbindingMkr = FALSE;
									bIsCharAttrMkr = TRUE; // set the doc member bool, filterable
								}
								else
								{
									// It's not one of the markers in charAttributeMkrs, so check out
									// the formatting markers fast access string
									offset = pApp->m_charFormatMkrs.Find(augmentedWholeMkr);
									if (offset >= 0)
									{
										// It's one of the several markers like \k \it etc, textType 
										// 'none' - binding ones
										bIsInlineBindingMkr = TRUE;
										bIsInlineNonbindingMkr = FALSE;
										bIsCharAttrMkr = FALSE;
									}
									else
									{
										// It's not 'binding' type, check if it's 'non-binding' type
										offset = pApp->m_inlineNonbindingMarkers.Find(augmentedWholeMkr);
										if (offset != wxNOT_FOUND)
										{
											// It's a nonbinding type
											bIsInlineBindingMkr = FALSE;
											bIsInlineNonbindingMkr = TRUE;
											bIsCharAttrMkr = FALSE;

											// BEW 6May23, we have to retest for inline binding beginMkr here.
											// Why? Because the source text parse may have come to an
											// inline nonbinding beginMkr (which very conceivably would precede
											// a following inline binding beginMkr. I have such data, and it
											// led to the inline binding beginMkr being placed by ParsePreWord()
											// in the default location, m_markers, which it definitely does NOT belong.
											// ParsePreWord will handle the inline binding beginMkr correctly if we
											// here determine that something like the \k of  \k .... \k* (keyword)
											// is the next beginMkr and so bIsInlineBindingMkr will be set TRUE.
											// (ParsePreWord() is not marker-order-sensitive, fortunately)
											int inlineNBMrkLen = augmentedWholeMkr.Length(); // for, say, \wj<space> that's 4
											wxChar* pAux = (ptr + inlineNBMrkLen); // pAux might now be pointing at a binding beginMkr
											if (*pAux == gSFescapechar)
											{
												wxString myBeginMkr = GetWholeMarker(pAux);
												// use bool CAdapt_ItDoc::IsEndMarker2(wxChar* pChar)
												if (!myBeginMkr.IsEmpty())
												{
													bool bIsNotEndMkr = !IsEndMarker2(pAux);
													if (bIsNotEndMkr)
													{
														// It's a beginMkr
														wxString augBeginMkr = myBeginMkr + _T(' '); // for fast-access test
														int offset3 = wxNOT_FOUND; wxUnusedVar(offset3); // avoid compiler warning variable initialized but not referenced
														bool bIsMyInlineBindingMkr = gpApp->m_charFormatMkrs.Find(augBeginMkr);
														if (bIsMyInlineBindingMkr)
														{
															// TRUE, it belongs to the marker set that has \k \it etc
															bIsInlineBindingMkr = TRUE;
														}
														// If bIsInlineBindingMkr was not set TRUE here, then ParsePreWord() would
														// probably "lose it", and it would get picked up as a member of m_markers,
														// leading to m_srcSinglePattern not having it, when it should
													}
												}
											}
										}
										// BEW 9Jan2023 I need to check the m_RedBeginMarkers set, that's where \rq is. m_RedEndMarkers has \rq*
										// There are a heap of markers in these red sets, they are not necessarily inLine; but a not 'verse or 'poetry'
										else
										{
											offset = pApp->m_RedBeginMarkers.Find(augmentedWholeMkr);
											if (offset != wxNOT_FOUND)
											{
												// these markers are not for 'sacred' text, but for things like \rq etc, they store like \f would
												bIsInlineBindingMkr = FALSE;
												bIsInlineNonbindingMkr = FALSE;
												// m_bInRedSet = TRUE; // set the doc member bool; not filterable BEW24Aug23 remove, unused
												bIsCharAttrMkr = FALSE;
											}
											else
											{
												// It's not a character formatting mkr
												// It's not a 'binding' type of mkr
												// It's not a 'non-binding' type of mkr
												// It's not one of the Red set
												// So let the legacy code decide what to do
												bIsInlineBindingMkr = FALSE;
												bIsInlineNonbindingMkr = FALSE;
												bIsCharAttrMkr = FALSE;
											}
										}
									} // end of the else block for test: if (offset >= 0) - for char format mkrs

								} // end of else block for testing for one in m_inlineNonbindingMarkers
							} // end of TRUE block for test: if (offset >= 0) - for charAttributeMkrs

							// In TokenizeText() the embedded marker \+jmp, when ParsePreWord() is called, 
							// \+jmp will be handled differently than expected in regards to where it is 
							// stored - it will be put into m_markers, and its endmarker (as handled by 
							// ParseWord()) into m_endMarkers, on the relevant CSourcePhrase instance for each

						} // end of else block for test: if (bIsAnEndMkr && !m_bWithinMkrAttributeSpan)

#if defined(_DEBUG) && !defined(NOLOGS)
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							//wxString ptrPointsAt;
							ptrPointsAt = wxString(ptr, 16);
							wxLogDebug(_T("TokText(), line %d, BREAKING OUT of else block, sequNum= %d, wholeMkr= [%s], m_curTextType= %d, m_key= [%s] , pointsAt= [%s]"),
								__LINE__, (int)pSrcPhrase->m_nSequNumber, wholeMkr.c_str(), (int)pSrcPhrase->m_curTextType,
								pSrcPhrase->m_key.c_str(), ptrPointsAt.c_str());
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
#endif
						break; // break out of the inner loop, to get to ParsePreWord() etc - 9th break in TokenizeText()

					}   // end of TRUE block for the mult-subtest above:
						//if (pUsfmAnalysis != NULL && pUsfmAnalysis->inLine etc

					bool bIsWholeMkr = TRUE;
					bIsNestedMkr = IsNestedMarkerOrMarkerTag(&wholeMkr, tagOnly, baseOfEndMkr, bIsWholeMkr);
					wxUnusedVar(bIsNestedMkr);
					wxUnusedVar(bIsWholeMkr);
					// Prepare the correct lookup marker string
					augmentedWholeMkr = gSFescapechar;
					augmentedWholeMkr += tagOnly;
					augmentedWholeMkr += _T(' ');
					//					wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
#if defined (_DEBUG) && !defined(NOLOGS)
					if (pSrcPhrase->m_nSequNumber >= 2)
					{
						if (pLastSrcPhrase != NULL)
						{
							int sequNumLast = pLastSrcPhrase->m_nSequNumber;
							wxString lastKey = pLastSrcPhrase->m_key;
							wxLogDebug(_T("TokenizeText line %d,  sequNumLast %d,  lastKey: %s"), __LINE__, sequNumLast, lastKey.c_str());

							//wxLogDebug(_T("TokenizeText line %d: gCurrentFilterMarkers: %s "), __LINE__, gpApp->gCurrentFilterMarkers.c_str());
							int halt_here = 1;
						}
					}
#endif
					wxString pointsAt; wxString wholeMkrAtPtr; wxString pointsAtFirst; wxString pointsAtPtr;
					wxString strAuxPointsAt; wxString fMkr; wxString feMkr; wxString xMkr; wxString exMkr;

					pUsfmAnalysis = LookupSFM(ptr, tagOnly, baseOfEndMkr, bIsNestedMkr);

					// BEW 30Sep19 Bill has changed the \fig properties to have m_inform
					// supported (should  show "illustration")
					// whm 23Sep2023 update to above comment. The \fig properties are now
					// fully set within the AI_USFM.xml control file. The navigationText
					// is also now "figure" which is shorter for nav text and more mnemonic
					// for users.

					// BEW 30Sep19 the one-line test with three subtest below
					// Testing for bIsToBeFiltered needs to be done. If TRUE, then we must ensure
					// that ptr does not advance until control reaches the filtering code lower down
					// whm 20Jan2024 added check if augWholeMkr is an AI custom marker \free \note 
					// or \bt... marker - which are obligatorily filtered.
					bool bIsForeignBackTransMkr = FALSE;
					bIsToBeFiltered = (pApp->gCurrentFilterMarkers.Find(augmentedWholeMkr) != wxNOT_FOUND);
					if (!bIsToBeFiltered)
					{
						bIsToBeFiltered = IsMarkerFreeTransOrNoteOrBackTrans(augmentedWholeMkr, bIsForeignBackTransMkr);
					}
#if defined (_DEBUG) && !defined(NOLOGS)
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						if (pLastSrcPhrase != NULL)
						{
							int sequNumLast = pLastSrcPhrase->m_nSequNumber;
							wxString lastKey = pLastSrcPhrase->m_key;
							wxLogDebug(_T("TokenizeText line %d,  sequNumLast %d, bIsToBeFiltered= %d,  lastKey: %s"), 
								__LINE__, sequNumLast, (int)bIsToBeFiltered, lastKey.c_str());

//wxLogDebug(_T("TokenizeText line %d: gCurrentFilterMarkers: %s "), __LINE__, gpApp->gCurrentFilterMarkers.c_str());
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
					}
#endif
					// BEW 5Jun23 Steve White's 46-MATfuh.SFM doc manifests several other possibilites for
					// some code needed here. One is when at \p marker, followed by space and then preceding
					// punctuation. E.g \p —\tl Hosanna\tl*
					// The long hypen is preceding punctuation for the Hosanna pSrcPhrase, and if I don't
					// take care of it here (it needs to be put into m_precPunct), AI will shove it in
					// m_follPunct - which constitutes a bogus punctuation movement.

					// BEW 21Jul23 added 2nd subtest, skip advancing ptr when about to filter.
					// BEW 25Jul23 added 3rd subtest, skip advancing ptr when about to have ParseWord() 
					// handle saving bar data to pSrcPhrase's m_punctsPattern member
					if (bIsBeginMkr && !bIsToBeFiltered && !bKeepPtrFromAdvancing)
					{
						// We have a marker pointed at, and it's a beginMkr, typically what follows is space
						// or newline (e.g. \p\n before a \v marker).  BEW 29Jun23, but there are 3 locations
						// for beginMkr storage. Most neutral is indeed, m_markers - put it there only if it
						// is not either one of the m_charFormatMarkers set, (inline binding ones), or the
						// m_inlineNonbindingMarkers set.
						{ // scoping block
							wxString strNextWhite; // store whatever whitespace follows the beginMkr
							strNextWhite = *(ptr + wholeMkrLen); // often a space, but a newline ('\n') is also legal USFM

							wxString myAugWholeMkr;
							myAugWholeMkr = wholeMkr + _T(' ');
							int offset; offset = -1;
							offset = pApp->m_charFormatMkrs.Find(myAugWholeMkr);
							if (offset >= 0)
							{
								// it's an inline binding beginMkr
								wxString inlineBindingMkrs;
								inlineBindingMkrs = pSrcPhrase->GetInlineBindingMarkers();
								inlineBindingMkrs += wholeMkr;
								inlineBindingMkrs << strNextWhite; // append space or newline after a beginMkr
								pSrcPhrase->SetInlineBindingMarkers(inlineBindingMkrs);
							}
							else
							{
								// maybe it's a nonbinding one, like \wj ("words of Jesus mkr")
								// BEW 20Jul23 I removed \fig & \fig* from the inline nonbinding mrks sets,
								// because \fig is a marker or type charAttributeMkr & \fig* belongs to
								// charAttributeEndMkr string. These have to have no ptr advancement when
								// ptr points at a beginMkr from the charAttributeMkr set, because it might
								// be a marker for filtering out (it is, by default), and filtering happens
								// affter the inner loop's LookupSFM() call, and if not for filtering out,
								// then it has to be dealt with even further down in the inner loop where
								// the tests for attribute makers are handled, because they contain bar ( | )
								// data following the beginMkr, for hiding in pSrcPhrase's m_punctsPattern member
								offset = -1;
								offset = pApp->m_inlineNonbindingMarkers.Find(myAugWholeMkr);
								if (offset >= 0)
								{
									// It's one of the small set of non-binding inline mkrs
									wxString inlineNonbindingMkrs;
									inlineNonbindingMkrs = pSrcPhrase->GetInlineNonbindingMarkers();
									inlineNonbindingMkrs += wholeMkr;
									inlineNonbindingMkrs << strNextWhite; // append space  or newline after a beginMkr
									pSrcPhrase->SetInlineNonbindingMarkers(inlineNonbindingMkrs);
								}
								else
								{
									// Must be one of the m_BlueMarkers beginMkrs - put it in m_markers
									pSrcPhrase->m_markers += wholeMkr;
									pSrcPhrase->m_markers << strNextWhite; // append space  or newline after a beginMkr
								}
							}
							// update ptr to point past the beginMkr
							ptr += wholeMkrLen;
							// ptr does not now point at a beginMkr, check, and if so goto isnull to get
							// quickly to ParsePreWord() and then ParseWord(). But if a beginMkr follows,
							// or filtering of the marker and content is about to happen, then continue on
							// (filtering commences about a hundred or so lines further on)
							if (*ptr != gSFescapechar && !bIsToBeFiltered) // BEW 21Jul23 added 2nd subtest
							{
								goto isnull;
							}
						}
						anItemLen += 1; // for parsing over the whitespace after a beginMkr
						ptr += 1; // keep anItemLen and ptr in sync
						// ptr now points at whatever follows the beginMkr and its following whitespace (space or \n)
						// BEW 20Jul23, just in case there were two or more white spaces, check for more and parse
						// over them without storing them (this 'heals' sloppy whitespace markup in this context)
						wxChar* pAux; int whitesLen; wxUnusedVar(pAux); // avoid compiler warning variable initialized but not referenced
						{
							wxChar* pAux = ptr;
							whitesLen = 0;
							whitesLen = CountSpaces(pAux, pEnd);
							if (whitesLen > 0)
							{
								pAux += whitesLen;
								// update ptr
								ptr = pAux;
							}
						}

						// ParseFinalPuncts() can be used for puncts preceding a word, it halts at \ ( [ { etc
						// BEW 8Jun23, Beware, preceding punct normally abutts the word, but in SteveWhite's source text,
						// there are lots of detached puncts - many of which are preceding the word. So in the
						// if (nPunctsSpan > 0) TRUE block below, count any whitespaces after ptr is updated, and 
						// append them too
#if defined (_DEBUG) && !defined (NOLOGS)
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
#endif
						int nPunctsSpan = ParseFinalPuncts(ptr, pEnd, spacelessPuncts); // <<- NOTE, puncts, can be pre-word 
						if (nPunctsSpan > 0)
						{
							// Store the punct(s) in m_precPunct, and advance ptr and anItemLen, staying in
							// the current pSrcPhrase
							pSrcPhrase->m_precPunct += wxString(ptr, nPunctsSpan);
							ptr += nPunctsSpan;
							anItemLen += nPunctsSpan;
							// Check for whitespace(s) before the word, append the too if any are present
							int numWhites = CountWhitesSpan(ptr, pEnd);
							if (numWhites > 0)
							{
								wxString strWhites = wxString(ptr, numWhites);
								pSrcPhrase->m_precPunct << strWhites;
								ptr += numWhites;
							}
						}
					} // end of TRUE block for test: if (bIsBeginMkr  && !bIsToBeFiltered)

					if (wholeMkr == wxString("\\ex"))
					{
						if (!bIsToBeFiltered)
						{
							// Don't filter \x0 \xr \xt etc, whether or not \x is marked in
							// Preferences as "to be filtered"
							gpApp->m_bExt_ex_NotFiltered = TRUE;
						}
					}
					if (wholeMkr == wxString("\\x"))
					{
						if (!bIsToBeFiltered)
						{
							// Don't filter \x0 \xr \xt etc, whether or not \x is marked in
							// Preferences as "to be filtered"
							gpApp->m_bMkr_x_NotFiltered = TRUE;
						}
					}
					// whm 22Jul2023 separated declaration below from assignment making two lines
					// avoids GCC error "jump to label 'isnull' ... crosses initialization of bool bCanFilterIt"
					// Initialise these bools to FALSE
					// whm 24Oct2023 modification. The bCanFilterIt bool value is determined by calling
					// the IsAFilteringSFM() function below, but the IsAFilteringSFM() function should
					// not be used here to determine the current filtering status of any marker. 
					// See comments and fuller description below.
					//bool bCanFilterIt;
					//bCanFilterIt = FALSE;
					// whm 22Jul2023 separated declaration below from assignment making two lines
					// avoids GCC error "jump to label 'isnull' ... crosses initialization of bool bInUnfileterdInlineSpan"
					bool bInUnfilteredInlineSpan;
					bInUnfilteredInlineSpan = FALSE;
					bInUnfilteredInlineSpan = bInUnfilteredInlineSpan; // avoid gcc warning set but not used warning

					// Might be an unknown marker, eg. \yy - if so pUsfmAnalysis is NULL - so
					// test and jump to further down -- so that \yy ends up in m_markers, and
					// not somewhere else
					pointsAt = wxEmptyString;
					wholeMkrAtPtr = wxEmptyString; pointsAtFirst = wxEmptyString; pointsAtPtr = wxEmptyString;
					strAuxPointsAt = wxEmptyString; fMkr = wxEmptyString; feMkr = wxEmptyString;
					xMkr = wxEmptyString; 
					exMkr = wxEmptyString;
#if defined (_DEBUG) && !defined (NOLOGS)
					// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
					wxLogDebug(_T("TokText(), line %d : app->m_bParsingSource = %d"), __LINE__, (int)gpApp->m_bParsingSource);
					if (pSrcPhrase->m_nSequNumber >= 5)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
#endif
					// BEW 19Jul23 don't goto isnull if filtering (which is further below and 
					// would be skipped) is wanted. Alternatively, if bKeepPtrFromAdvancing is TRUE
					// then we want to get to ParseWord() where the char attributes mkr processing is done,
					// as quickly as possible - so we'd want to goto the label "parsing" here
					if (bIsToBeFiltered == FALSE)
					{
						// This should only be a test yielding TRUE, when the 
						// beginMkr is unknown to AI_USFM.xml
						if (pUsfmAnalysis == NULL)
						{
							goto isnull;
						}
						else if (bKeepPtrFromAdvancing == TRUE)
						{
							goto parsing; // this sends control to just preceding ParsePreWord(), and then ParseWord() follows
						}
					}
					bool bIsAMkr;
					bIsAMkr = IsMarker(ptr);
					bool bNotEndMkr;
					bNotEndMkr = !IsEndMarker2(ptr);
					bool bInLine;
					bInLine = (bool)pUsfmAnalysis->inLine;
					bool bNotForFiltering;
					bNotForFiltering = !bIsToBeFiltered;

					wholeMkrAtPtr = GetWholeMarker(ptr);
//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());

					// BEW 9Jan20 Bleed out beginMkrs like \rq (which we default to filtering out, but if I've set project
					// to have it unfiltered (and I can do so according to AI_USFM.xml), then I need to support it.
					// When ptr points at \rq<space> augmentedWholeMkr will be "\\rq<space>" but I can reset that here
					// to make sure. bIsAMkr will be TRUE, bInLine is FALSE, bNotForFiltering is TRUE, and
					// wholeMkrAtPtr is "\\rq"
					if (bIsAMkr && bNotEndMkr && bNotForFiltering)
					{
						// that test is not explicit enough, gotta get more detail - specifically, is it a beginMkr from
						// the pApp->m_RedBeginMarkers fast-access set?
						int offset = wxNOT_FOUND; // init
						itemLen = 0;
						wxString augMkr = wholeMkrAtPtr + _T(' ');
						offset = pApp->m_RedBeginMarkers.Find(augMkr);
						if (offset != wxNOT_FOUND)
						{
							// the marker belongs to the Red mkr set, we store these like \f  and \f*, in m_markers and m_endMarkers
							// for the matching endmarker, e.g. \rq  and  span ends at \rq*
							// It will be ParseWord()'s job to deal with \rq* etc
							pSrcPhrase->m_markers += augMkr;
							itemLen = wholeMkrAtPtr.Len();
							itemLen += 1; // for the following <space>
							ptr += itemLen;
							itemLen = 0;
							pSrcPhrase->m_bSpecialText = TRUE;
							//pSrcPhrase->m_inform = _("x-ref to source"); // NOTE: "x-ref to source" is m_inform for \rq ... \rq* rightMarginReference (TType 32)
							pSrcPhrase->m_bBoundary = TRUE;
#if defined (_DEBUG) && !defined(NOLOGS)
							if (pSrcPhrase->m_nSequNumber >= 5)
							{
								//wxString ptrPointsAt;
								ptrPointsAt = wxString(ptr, 16);
								wxLogDebug(_T("TokText(), line %d, sequNum= %d, m_markers= [%s], wholeMkr= [%s], m_curTextType = %d, m_key= [%s], pointsAt= [%s] goto parsing"),
									__LINE__, (int)pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str(), wholeMkr.c_str(), (int)pSrcPhrase->m_curTextType,
									pSrcPhrase->m_key.c_str(), ptrPointsAt.c_str());
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
#endif
							// jump to ParsePreWord() to get quickly to ParseWord(), with ptr pointing at the word following the beginMkr
							goto parsing;
						}
					}

					// BEW 2Dec22 need to refactor here. testing for bIsToBeFiltered set TRUE.
					// Currently, if bIsToBeFiltered being FALSE, will set m_bIsWithinUnfilteredInlineSpan to TRUE.
					// But that conclusion does not logically follow, and it can cause havoc in ParseWord().
					// A further check is required. wholeMkrAtPtr has to be one which can potentially filtered
					// and is about to be the start of an unfiltered span. Such markers are \f \fe \x \ex.
					// So check for one of these; all these are inLine type, we want m_bIsWithinUnfilteredInlineSpan
					// to be FALSE except when wholeMkrAtPtr is the beginning of a span due to one of these
					fMkr = _T("\\f"); feMkr = _T("\\fe"); xMkr = _T("\\x"); exMkr = _T("\\ex");
					if (!m_bIsWithinUnfilteredInlineSpan)
					{
						// We are at a new pSrcPhrase which is not within an unfiltered inline span. We may be about to
						// enter such a span - so check it out...
						if (wholeMkrAtPtr == fMkr || wholeMkrAtPtr == feMkr || wholeMkrAtPtr == xMkr || wholeMkrAtPtr == exMkr)
						{
							if (bIsToBeFiltered)
							{
								// Can't generate a span for the user to see and deal with if it's gunna be hidden by filtering
								m_bIsWithinUnfilteredInlineSpan = FALSE;
							}
							else
							{
								// The marker is inLine, it's not to be filtered, and it's one of the ones which are now
								// about to create an unfiltered span for the user to deal with, eg. \f to \f*
								m_bIsWithinUnfilteredInlineSpan = TRUE;
							}
						}
						else
						{
							// it's not a span-creating beginMkr, so the bool stays false
							m_bIsWithinUnfilteredInlineSpan = FALSE;
						}
#if defined (_DEBUG) && !defined(NOLOGS)
						if (pSrcPhrase->m_nSequNumber >= 13)
						{
							wxLogDebug(_T("TokText(), line %d, sequNum = %d , wholeMkrAtPtr= [%s] , m_curTextType = %d, m_key= [%s]"),
								__LINE__, (int)pSrcPhrase->m_nSequNumber, wholeMkrAtPtr.c_str(),
								(int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str());
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
#endif
					}
					else
					{
						// Control is currently within an unfiltered inline span, so leave it stand - control needs to parse
						// over, for successive pSrcPhrase instances created, markers like \fv, ]fr, .... \ft, up to \f*.
						// In ParseWord(), getting to the matching endMkr, will encounter code which turns
						// m_bIsWithinUnfilteredInlineSpan back to FALSE.
						;
					}
//wxLogDebug(_T("TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());

					wxChar* pSavePtr;
					pSavePtr = ptr;
					if (bIsAMkr && bNotEndMkr && bInLine && bNotForFiltering && m_bIsWithinUnfilteredInlineSpan)
					{
#if defined (_DEBUG) && !defined(NOLOGS)
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							wxLogDebug(_T("TokText(), line %d : m_bIsWithinUnfilteredInlineSpan = %d , sequNum = %d , wholeMkrAtPtr= %s , m_curTextType = %d, m_key= [%s]"),
								__LINE__, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_nSequNumber, wholeMkrAtPtr.c_str(),
								(int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str());
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
#endif
						m_strUnfilteredInlineBeginMarker = gSFescapechar + tagOnly; // e.g. \f or \fig etc

						// BEW 28Sep22 code additions for handling when \f does not have any data before
						// a following \fv marker. Or in other places within the footnote.; 
						wxString augmentedMkr = wholeMkrAtPtr + _T(' ');

						if (pUsfmAnalysis->inLine && (augmentedMkr == _T("\\f ")))
						{
							// Need to set m_bFootnote
							pSrcPhrase->m_bFootnote = TRUE;
						}
						itemLen = 0;

						int aug_mkr_len = augmentedMkr.Length();
						// move ptr to point past "\f " <<-- oops, this was cause of severe misparsing...
						// BEW 1Dec22 need to use pAux here, we don't want ptr increasing when all we are wanting
						// to do is to get to the next beginMkr to end the span for \f to next beginMkr
						wxChar* pAux = ptr; // protect ptr from bogus advance
						pAux += (size_t)aug_mkr_len; // includes the following space

						// There may be some more white spaces, parse over them
						int nExtraWhites = ParseWhiteSpace(pAux);
						if (nExtraWhites > 0)
						{
							itemLen += nExtraWhites;
							pAux += nExtraWhites;
						}
						// What's next at ptr? If it's either a word or symbol or punctuation, then we have a normal
						// footnote with something in the way of text content before another marker such as \fv
						// But if another inner footnote marker is immediately next, then we need to insert ???
						wxString wholeMkr = wxEmptyString; // initialise
						bool bMkrFound;
						bMkrFound = FALSE; // intialise
						bMkrFound = IsMarker(pAux);
						//int mkrLen = 0; // init
						wxChar* pAuxPointsAt;
						pAuxPointsAt = pAux;
#if defined (_DEBUG) && !defined(NOLOGS)
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							//wxString ptrPointsAt;
							ptrPointsAt = wxString(ptr, 16);
							wxLogDebug(_T("TokText(), line %d, sequNum= %d , m_bSpecialText= %d , m_curTextType= %d, m_key= [%s]"), __LINE__,
								(int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str());
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
#endif
						// Finding the next mkr only determines a halting point. ??? is to be put before that, 
						// and after \f<sp>, so code below needs refactoring....
						// The test should be that \f was found, and a footnote internal beginMkr is at is end of
						// the span (which pAux should be pointing at), for ??? insertion to be warranted.
						if (bMkrFound)
						{
							wxChar plus2;
							plus2 = *(pSavePtr + 2);
							if (wholeMkrAtPtr == _T("\\f") && plus2 == _T(' '))
							{
								// It's a \f marker followed by a space, so now we know ??? insertion is warranted
								ptr = pSavePtr; // point ptr back to start of "\f" marker
								pAux = ptr;

								// get pAux to insertion point, prior to following mkr
								pAux += 3;
								itemLen = 0;
								// if control failed the if test above, so that control is going to the else
								// block, the jump will have happened by now. So here we can restore ptr
								// to where pAux currently is.
								ptr = pAux;

								// Now, insert the ??? string, set m_key and m_srcPhrase, up
								pSrcPhrase->m_key = gpApp->m_strQuestions;
								pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
								int lenQuestions = 3;
								itemLen += lenQuestions;
								// point ptr back at \f
								ptr = pSavePtr;
								//	wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"),
								//	__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

								goto parsing; // the label precedes the call of ParsePreWord()
							}
							else
							{
								// we may be in a \ft<space> span, with ptp pointing at \f* If so, then
								// there is no content for \ft, and we need to insert ??? here
								wholeMkr = GetWholeMarker(pAuxPointsAt); // should be \f*
								wxChar secondChar = wholeMkr.GetChar((size_t)1);
								int aMkrLen = wholeMkr.Len();
								itemLen = 0;
								// Are we at the last part of the footnote span, the one which ends with
								// \f* endMkr? Check if it needs ??? insertion, and if there's a space
								// prior to the \f*, don't return to caller but include it in the span
								if (((secondChar == _T('f')) || (aMkrLen >= 3)) && (wholeMkr == _T("\\f*")))
								{
									pSrcPhrase->m_key = gpApp->m_strQuestions;
									pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
									itemLen += aMkrLen;
									ptr += aMkrLen;  // The \f* width is dealt with
#if defined (_DEBUG) && !defined (NOLOGS)						
									{
										pointsAt = wxString(ptr, 16);
										wxLogDebug(_T("TokenizeText(), line %d , sn= %d , pointsAt= [%s] , m_bIsWithinUnfilteredInlineSpan = %d"),
											__LINE__, pSrcPhrase->m_nSequNumber, pointsAt.c_str(), (int)m_bIsWithinUnfilteredInlineSpan);
										if (pSrcPhrase->m_nSequNumber >= 2)
										{
											int halt_here = 1; wxUnusedVar(halt_here);
										}
									}
#endif
									// we have to parse over any following puncts (after \f*) and store them, 
									//  add ???, and its width of 3, and NOT pass control on to
									// ParsePreWord() nor to ParseWord(), but instead to pass control to the
									// finishup: label, which follows the ParseWord() call. So we have to here do
									// the parsing that ParseWord() would have done if ??? was real input data
									wxString endMkrs = pSrcPhrase->GetEndMarkers();
									endMkrs += _T("\\f*");
									pSrcPhrase->SetEndMarkers(endMkrs);
									itemLen += 3; // for width of of the questions added above (should now be 3 + 3 = 6)
									ptr += 3; // make agree

									// BEW 1Dec22, ptr should now follow \f*, and we can now get any following puncts. This worked
									// for a while, but suddenly, the counting is wonky at this point, without any code
									// being changed. The itemLen count is 6 (correct) but the ptr is pointing
									// not at the '.' after the \f*. but at the '*' itself. This is crazy, I've no
									// idea why this discepancy happens. I'll have to resort to an ugly hack. I will
									// check if ptr points at '*', and if so, advance ptr by one - leaving all other params
									// unchanged. That way, if the code suddenly reverts to the earlier correct state, this
									// hack will be bypassed, if the current wrong ptr value persists, the hack will fix it.
									if (*ptr == _T('*'))
									{
										ptr = (ptr + 1); // the hack ( brk pt here would alert to control ending this hack block)
									}
									int nPunctsCount = 0;
									nPunctsCount = ParsePuncts(ptr, pEnd, gpApp->m_strSpacelessSourcePuncts);
									if (nPunctsCount > 0)
									{
										wxString punctsStr = wxString(ptr, nPunctsCount);
										pSrcPhrase->m_follPunct += punctsStr;
										itemLen += nPunctsCount;
										ptr += nPunctsCount;

										pSrcPhrase->m_srcPhrase += punctsStr; // gotta make sure the GUI shows the puncts
									}
									m_bIsWithinUnfilteredInlineSpan = FALSE; // BEW added 2Dec22, as few places restore it to FALSE

//									wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

									bComingFromInnerMarkerLoop = TRUE;
									goto finishup; // follows the call of ParseWord()

								} // end of TRUE block for test: if (((secondChar == _T('f')) || (mkrLen >= 3)) && (wholeMkr == _T("\\f*")))

							}
						} // end of TRUE block for test: if ( bMkrFound )
					} // end of TRUE block for test: if (bIsAMkr && bNotEndMkr && bInLine && bNotForFiltering && m_bIsWithinUnfilteredInlineSpan)
					else
					{
						
#if defined (_DEBUG) && !defined (NOLOGS)
						if (pSrcPhrase->m_nSequNumber >= 13)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
#endif
//wxLogDebug(_T("TokText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
						wholeMkrAtPtr = GetWholeMarker(ptr);
						bool bIsAMkr = IsMarker(ptr);
						bool bNotEndMkr = !IsEndMarker2(ptr);
						bool bInLine = (bool)pUsfmAnalysis->inLine;
						bool bNotForFiltering = !bIsToBeFiltered;

						m_bIsWithinUnfilteredInlineSpan = FALSE;

// NOLOGS					wxLogDebug(_T("TokText(), line %d , sn= %d , wholeMkrAtPtr= [%s] , m_markers= [%s], bIsAMkr %d, bNotEndMkr %d, bInLine %d"),
//						__LINE__, pSrcPhrase->m_nSequNumber, wholeMkrAtPtr.c_str(), pSrcPhrase->m_markers.c_str(), (int)bIsAMkr, (int)bNotEndMkr, (int)bInLine );

											// Is ptr now at an InLine marker which is in an unfiltered span's
											// endmarker and now m_bIsWithinUnfilteredInlineSpan should be turned back
											// off now (i.e. to FALSE) -- for example, when ptr is at \f*
						if (bIsAMkr && bNotEndMkr && bInLine && bNotForFiltering && m_bIsWithinUnfilteredInlineSpan)
						{
							// Turn it back off provided the backslash and tag match what
							// was stored in m_strUnfilteredInlineBeginMarker
							wxString endMkrMinusAsterisk;
							endMkrMinusAsterisk = gSFescapechar + baseOfEndMkr;
							if (m_strUnfilteredInlineBeginMarker == endMkrMinusAsterisk)
							{
								// Clear, this span is done, so set up for a possible another later
								m_bIsWithinUnfilteredInlineSpan = FALSE;
								m_strUnfilteredInlineBeginMarker = wxEmptyString;
							}
							// BEW 18Apr20 Turn off gpApp->m_bExt_ex_NotFiltered = TRUE
							// when the matching endMarker's pSrcPhrase is reached
							if (gpApp->m_bExt_ex_NotFiltered == TRUE)
							{
								gpApp->m_bExt_ex_NotFiltered = FALSE;
							}
							// Same turn off if \x* has been reached
							if (gpApp->m_bMkr_x_NotFiltered == TRUE)
							{
								gpApp->m_bMkr_x_NotFiltered = FALSE;
							}
						} // end of TRUE block for test:   --- filtering stuff
						  // if (bIsAMkr && bNotEndMkr && bInLine && bNotForFiltering && m_bIsWithinUnfilteredInlineSpan)
					}
					//	wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());

					// BEW 30Sep19, Bill's change Or to be AND didn't fix it. My logic was wrong.
					// He made the change to fix an issue with parsing \h
					// I need to heavily refactor this part of the app.
					// whm 25Aug2018 changed || to && for proper logic - cf use in IsPostwordFilteringRequired()
					// whm 24Oct2023 see comments below. The IsAFilteringSFM() function's return value has
					// been mis-understood and should not be used to indicate the current filtering status of
					// a USFM marker!!
					//if ((IsAFilteringSFM(pUsfmAnalysis) && bIsToBeFiltered) && !m_bIsWithinUnfilteredInlineSpan)
#if defined (_DEBUG) && !defined (NOLOGS)
					if (pSrcPhrase->m_nSequNumber >= 26)
					{
						//wxLogDebug(_T("TokenizeText line %d: gCurrentFilterMarkers: %s "), __LINE__, gpApp->gCurrentFilterMarkers.c_str());
						int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
					}
#endif
					// And check what pUsfmAnalysis struct is. bCanFilterIt is returning false here 
					// 
					// whm 24Oct2023 change: The pUsfmAnalysis' filter member does not reliably indicate
					// whether a marker is currently filtered or not, but only indicates what the
					// DEFAULT filtering state of the marker is as defined in the AI_USFM.xml control
					// file. The IsAFilteringSFM() function returns the boolean state of the 
					// pUsfmAnalysis->filter member of the struct which doesn't changes unless the
					// AI_USFM.xml file's filter property is changed. 
					// To get a reliable current filter status of a given marker that is filterable, 
					// the gCurrentFilterMarkers string should be examined. 
					// The IsAFilteringSFM(pUsfmAnalysis) function call below does NOT give any 
					// indication of what the "current filter status" is of the marker now being 
					// examined here in TokenizeText().
					// Therefore as of this date, I have removed the IsAFilteringSFM(pUsfmAnalysis)
					// function call below, and all references to the bCanFilterIt boolean.
					// bCanFilterIt = IsAFilteringSFM(pUsfmAnalysis);

					// If the marker is \ex, its inner markers will be those of a \x...\x* span,
					// which is okay of the latter span is not marked for filtering out. But
					// default is to filter it out, and so if \ex is not to be filtered, we must
					// ensure that \x0, \xr, \xt. etc - do not wrongly get filtered out
					// BEW 16Dec20 added 2nd test and OR logic, because bIsToBeFiltered and bCanFilterIt must
					// be allowed to carry their TRUE values thru to the filter code below for markers other
					// than \x or \ex
					// whm modified the declarations and assignments below to declare the bool variables on
					// one line and do the assignments on a second line
					bool bFirstTest;
					bFirstTest = (wholeMkr == _T("\\ex") && gpApp->m_bExt_ex_NotFiltered == TRUE);
					bool bSecondTest;
					bSecondTest = (wholeMkr == _T("\\x") && gpApp->m_bMkr_x_NotFiltered == TRUE);

					if (bFirstTest || bSecondTest) // BEW 16Dec20 added 2nd test
					{
						bIsToBeFiltered = FALSE;
						// bCanFilterIt = FALSE; // whm 24Oct2023 removed
					}
					// Code following is for versions 6.9.4 and earlier
					if (bIsToBeFiltered)
					{
						m_bIsWithinUnfilteredInlineSpan = FALSE;
						bInUnfilteredInlineSpan = FALSE;
					}
#if defined (_DEBUG) && !defined (NOLOGS)
					if (pSrcPhrase->m_nSequNumber >= 2)
					{
						//wxLogDebug(_T("TokenizeText line %d: gCurrentFilterMarkers: %s "), __LINE__, gpApp->gCurrentFilterMarkers.c_str());
						int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
					}
#endif 
					// Outermost test...
					// whm 24Oct2023 removed the bCanFilterIt test. See comments elsewhere.
					//if (bIsToBeFiltered && bCanFilterIt)
					if (bIsToBeFiltered)
					{
						// This is the block for filtering a span of source text out,
						// to store it in m_filteredInfo in the CSourcePhrase instance
						// which commences the filter span.

						// If the span is associated with an attribute having
						// marker such as \w ( inlineBindingMkr, for a glossary entry)
						// or \fig ( for a figure in the printed text), and some others,
						// TokenizeText() will have gathered and cached metadata for hiding
						// the information from bar ( | ) to the matching endmarker, and
						// appending a copy of the endmarker as well, for use later for
						// locating where to restore the metadata in an export needing it.
						//
						// But when filtering, we will want to have the attributes 
						// metadata "in place", rather than having it hidden in the
						// span's last CSourcePhrase instance's m_punctsPattern member.
						// So we must test for filtering of the small set of attributes-having
						// markers, and if we are wanting to filter one, then we'll grab the
						// whole span before m_punctsPattern has a chance to hide anything,
						// and since filtering removes the need for the cached metadata to
						// persist, we clear out that cached stuff and its temporary on-the-heap
						// CSourcePhrase instance as well, so that there's no confusion from 
						// that stuff hanging around unused. 
						// So we'll code in bleeding order - get the special cases out of the way
						// first, and the general stuff handled last.
#if defined (_DEBUG) && !defined(NOLOGS)
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							wxLogDebug(_T("TokText(), FILTERING... line %d, sequNum= %d , m_bSpecialText= %d , m_curTextType= %d, m_key = [%s]"), __LINE__,
								(int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str());
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
#endif
						// bIsToBeFiltered is TRUE, so determine if the marker is one from
						// the set of attributes-having markers, and that tokenizing source
						// text is in operation
						wxString whichMkr = wxEmptyString;
						//wxUnusedVar(whichMkr); // wwhichMkr in the call below is the one checkedd for
						bool bItsSourceText = !m_bTokenizingTargetText;

						// Ready for the filtering code...
						if (bItsSourceText)
						{
							wxString temp = wxEmptyString;
							itemLen = 0; // initialize
#if defined (_DEBUG) && !defined (NOLOGS)
							wxString atPtrHere;
							atPtrHere = wxString(ptr, 22);
							wxLogDebug(_T("TokText() entering ParseFilteringSFM, line %d, 22 chars atPtrHere= [%s]"), __LINE__, atPtrHere.c_str());
							if (pSrcPhrase->m_nSequNumber >= 13)
							{
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
#endif
							// Obtain the string to be filtered out
							itemLen = ParseFilteringSFM(wholeMkr, ptr, pBufStart, pEnd);

							// get filtered text bracketed by \~FILTER and \~FILTER*
							temp = GetFilteredItemBracketed(ptr, itemLen);

							// BEW 30Sep19, storing will be to the next pSrcPhrase's
							// m_filteredInfo member. It doesn't yet exist, so we
							// cache temp, and set bDelayStoringFilteredInfo to TRUE,
							// and then at next iteration of the outer loop, we
							// append the cached data to m_filteredInfo. If the loop
							// exits before the next pSrcPhrase can be created, it is
							// created after the loop finishes, and a pile ptr added
							// to Layout's m_pileList, so that a green wedge and
							// m_inform text ("Filtered Info Carrier") are displayed
							// in the nav text region at doc end
							strCacheDelayedFilteredContent = temp; // temp is local and can now die
							bDelayStoringFilteredInfo = TRUE; // BEW 17Dec22 need this TRUE value, because
							// if strCacheDelayedFilteredContent wxString is non-empty when control gets
							// to doc end, the an extra pSrcPhrase will be automatically created to have
							// a place to store it - see Doc lines 20,702++ for where that's done

							// BEW 16Dec22 move the AddToFilteredInfo() call to here, since strCacheDelayedFilteredContent
							// has its content now, there is no point in delaying storage till the next
							// pSrcPhrase - provided we advance ptr to point beyond what we've filtered & stored
							// BEW 24Jul23 - what's been filtered should be stored not on pSrcPhrase, but on
							// pLastSrcPhrase, it should then work better if later the beginMkr is removed from
							// the gCurrentFilterMarkers list
							if (pLastSrcPhrase != NULL)
							{
								if (bParseSweptUpMatterBeforeMarkerToBeFiltered)
								{
									// There is swept up material to prefix to the bracketed filtered marker
									// That was determined by the IsNextFilterableMkrToBeFiltered() earlier
									// in TokenizeText(). 
									// The swept up material may contain whitespace, and/or other markers such as
									// \c n, \v n \p and other empty markers that are contained in the variable:
									// sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered.
									// Here we prefix that swept up material to strCacheDelayedFilteredContent
									// before the pLastSrcPhrase->AddToFilteredInto() call below.
									strCacheDelayedFilteredContent = sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered + strCacheDelayedFilteredContent;
									// We now reset the variables
									sweptUpWhiteSpaceAndMarkersPrecedingMkrBeingFiltered.Empty();
									bParseSweptUpMatterBeforeMarkerToBeFiltered = FALSE;
								}
								//pSrcPhrase->AddToFilteredInfo(strCacheDelayedFilteredContent);
								pLastSrcPhrase->AddToFilteredInfo(strCacheDelayedFilteredContent);
							}
							// ptr has to be updated by itemLen characters added; wholeMkr got
							// removed along with its content; and will be stored to m_filteredInfo
							ptr += itemLen;
							strCacheDelayedFilteredContent = wxEmptyString; // Gotta clear it, otherwise, if it's
								// not empty when parse gets to doc end, it will be added again on a "Filtered Info Carrier"
								// programmatically added extra pSrcPhrase
							itemLen = 0; // BEW added 24Aug23

							// We don't know  what lies beyond the endmarker, but it's handled further down.
							// if after some whitespace there is a backslash, then continue; to iterate the loop.
							// Otherwise, probably words follow
							int aCount;
							aCount = 0;
							aCount = ParseWhiteSpace(ptr); // parse any white space following it,
															// return 0  if not pointing at whitespace
							//wxUnusedVar(aCount); // avoid compiler warning
							// BEW 24Aug23 dont advance ptr, but make aCount available if wanted below
							tokBuffer.Empty();

							/* BEW 24Aug23 unneeded, these values already set
							if (*ptr == _T('\n') || *(ptr - 1) == _T('\n') || *(ptr - 1) == _T(' ') || *ptr == gSFescapechar)
							{
								pSrcPhrase->m_curTextType = verse;
								pSrcPhrase->m_bSpecialText = FALSE;
								pSrcPhrase->m_bFirstOfType = TRUE;
								pSrcPhrase->m_bBoundary = TRUE;
							}
							*/
#if defined (_DEBUG) && !defined(NOLOGS)
							wxLogDebug(_T("TokText(), FILTERING DONE: line %d : sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = %s , m_precPunct = %s , m_markers = %s"),
								__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType,
								pSrcPhrase->m_key.c_str(), pSrcPhrase->m_precPunct.c_str(), pSrcPhrase->m_markers.c_str());
							if (pSrcPhrase->m_nSequNumber >= 16)
							{
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
#endif
							// BEW 23Aug23, it's probably unhelpful to iterate this inner loop using continue; in every
							// context. For instance, if after any whites there is not a backslash, but rather words to
							// be parsed, (or if \x to \x* just got filtered out - which is likely to be followed by words)
							// we would want to break from the loop. But if after whites is a backslash, then continue;
							// would be appropriate. So sort these possibilities out...
							{ //scope block
								wxChar* pAux = ptr + aCount; // typically aCount is 1, for the one space prior to words
									// unless there is a lurking backslash, which would require iterating the inner loop
								if ( (*pAux == gSFescapechar) || (*ptr == gSFescapechar))
								{
									// BEW 28Aug23 There is a lurking backslash!  So advance ptr to it, otherwise, control
									// when continue is called, goes to the while loop at 40835 which tests for a beginMkr
									// at start of inner loop, but ptr still pointing at space or newline, the loop will
									// exit immediately; bContinueTwice will be FALSE, bKeepPtrFromAdvancing will be FALSE,
									// and so control goes to ParsePreWord() and then ParseWord() where the initial backslash
									// of the marker causes ParseAWord() to fail, and the text that should be parsed is not
									// parsed, and instead "empty-key" shows. This error sequence starts here, if ptr
									// points at space or newline and we don't parse over that whitespace.
									if (*pAux == gSFescapechar)
									{
										wxString strACount;
										strACount = wxString(ptr, aCount);
										pSrcPhrase->m_precPunct += strACount;
										ptr += aCount; // point ptr at the beginMkr, (we are not here trying to get a new pSrcPhrase)
									}
									continue; // iterate the inner loop - 6th continue in TokenizeText()
								}
								else
								{
									// words probably follow, so break from the loop
									// send control to ParsePreWord() and then ParseWord()
									goto parsing;
								}
							} // end scopeblock
						} // end of TRUE block for test: if (bItsSourceText)
						else
						{
							// It's not source text...
							wxString temp = wxEmptyString;

							// Ready for the filtering code...
							itemLen = 0; // initialize
#if defined (_DEBUG) && !defined(NOLOGS)
							wxLogDebug(_T("TokText(), line %d : NOT SOURCE TEXT, sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = %s"), __LINE__,
								(int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str());
#endif

							// Obtain the string to be filtered out
							itemLen = ParseFilteringSFM(wholeMkr, ptr, pBufStart, pEnd);

							// BEW 30Sep19,  The legacy code follows...

							// get filtered text bracketed by \~FILTER and \~FILTER*
							bIsFreeTransOrNoteOrBackTrans = IsMarkerFreeTransOrNoteOrBackTrans(
								augmentedWholeMkr, bIsForeignBackTrans);
							if (bIsForeignBackTrans)
							{
								// it's a back translation type of marker of foreign origin (extra
								// chars after the t in \bt) so we just tuck it away in
								// m_filteredInfo
								temp = GetFilteredItemBracketed(ptr, itemLen);
							}
							else if (bIsFreeTransOrNoteOrBackTrans)
							{
								// whm 27Jan2024 TODO: Should the following call's 4th param be pLastSrcPhrase???
								// TODO:
								SetFreeTransOrNoteOrBackTrans(wholeMkr, ptr, (size_t)itemLen, pSrcPhrase);
								wxString aTempStr(ptr, itemLen);
								temp = aTempStr; // don't need to wrap with \~FILTER etc, get just
													// enough for the code below to set the value between |@ and @|
							}
							else
							{
								// other filterable markers go in m_filteredInfo, and have to be
								// wrapped with \~FILTER and \~FILTER* and put into m_filteredInfo
								temp = GetFilteredItemBracketed(ptr, itemLen);
							}

							//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
							// We may be at some free translation's anchor pSrcPhrase, having just
							// set up the filter string to be put into m_markers; and if so, this
							// string will contain a count of the number of following words to
							// which the free translation applies; and this count will be
							// bracketted by |@ (bar followed by @) at the start and @|<space> at
							// the end, so we can search for these and if found, we extract the
							// number string and remove the whole substring because it is only
							// there to inform the parse operation and we don't want it in the
							// constructed document. We use the count to determine which pSrcPhrase
							// later encountered is the one to have its m_bEndFreeTrans member set
							// TRUE.
							int nFound = temp.Find(_T("|@"));
							if (nFound != -1)
							{
								// there is some free translation to be handled
								int nFound2 = temp.Find(_T("@| "));
								wxASSERT(nFound2 - nFound < 10); // characters between can't be
																	// too big a number
								wxString aNumber = temp.Mid(nFound + 2, nFound2 - nFound - 2);
								nFreeTransWordCount = wxAtoi(aNumber);
								wxASSERT(nFreeTransWordCount >= 13);

								// now remove the substring
								temp.Remove(nFound, nFound2 + 3 - nFound);

								// now check for a word count value of zero -- we would get this if
								// the user, in the project which supplied the exported text data,
								// free translated a section of source text but did not supply any
								// target text (if a target text export was done -- the same can't
								// happen for source text of course). When such a \free field
								// occurs in the data, there will be no pSrcPhrase to hang it on,
								// because the parser will just collect all the empty markers into
								// m_markers; so when we get a count of zero we should throw away
								// the propagated free translation & let the user type another if
								// he later adapts this section
								if (nFreeTransWordCount == 0)
								{
									temp.Empty();
								}
							} // end of TRUE block for test: if (nFound != -1)
// wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

							// BEW added 05Oct05; CSourcePhrase class has new bool attributes in
							// support of notes, backtranslations and free translations, so we have
							// to set these at appropriate places in the parse.
							if (!bIsFreeTransOrNoteOrBackTrans || bIsForeignBackTrans)
							{
								// other filtered stuff needs to be saved here (not later), it has
								// been wrapped with \~FILTER and \~FILTER*; there is no need to
								// use a delimiting space between the filter markers
								// whm 20Jan2024 corrected. The AddToFilteredInfo should be done
								// to the pLastSrcPhrase and not pSrcPhrase.
								//pSrcPhrase->AddToFilteredInfo(temp);
								pLastSrcPhrase->AddToFilteredInfo(temp);
							}
							if (wholeMkr == _T("\\note"))
							{
								pSrcPhrase->m_bHasNote = TRUE;
							}
							if (bFreeTranslationIsCurrent)
							{
								// a free translation section is current
								if (wholeMkr == _T("\\free"))
								{
									// we've arrived at the start of a new section of free
									// translation -- we should have already turned it off, but
									// since we obviously haven't we'll do so now
									if (nFreeTransWordCount != 0)
									{
										bFreeTranslationIsCurrent = TRUE; // turn on this flag to
											// inform parser in subsequent iterations that a new
											// one is current
										if (pLastSrcPhrase->m_bEndFreeTrans == FALSE)
										{
											pLastSrcPhrase->m_bEndFreeTrans = TRUE; // turn off
																					// previous section
										}

										// indicate start of new section
										pSrcPhrase->m_bHasFreeTrans = TRUE;
										pSrcPhrase->m_bStartFreeTrans = TRUE;
									}
									else
									{
										// we are throwing this section away, so turn off the flag
										bFreeTranslationIsCurrent = FALSE;
										if (pLastSrcPhrase->m_bEndFreeTrans == FALSE)
										{
											pLastSrcPhrase->m_bEndFreeTrans = TRUE; // turn off
																					// previous section
										}
									}
								}
								else
								{
									// for any other marker, if the section is not already turned
									// off, then just propagate the free translation section to
									// this sourcephrase too
									pSrcPhrase->m_bHasFreeTrans = TRUE;
								}
							} // end of the TRUE block for test: if (bFreeTranslationIsCurrent)
							else
							{
								// no free translation section is currently in effect, so check to
								// see if one is about to start
								if (wholeMkr == _T("\\free"))
								{
									bFreeTranslationIsCurrent = TRUE; // turn on this flag to inform
											// parser in subsequent iterations that one is current
									pSrcPhrase->m_bHasFreeTrans = TRUE;
									pSrcPhrase->m_bStartFreeTrans = TRUE;
								}
							}  // end of the else block for test: if (bFreeTranslationIsCurrent)

							ptr += itemLen;

							// legacy code ends
#if defined (_DEBUG) && !defined(NOLOGS)
							wxLogDebug(_T("TokText(), line %d, sequNum= %d, m_bSpecialText= %d , m_curTextType= %d, m_key= [%s], m_precPunct= [%s], m_markers = [%s], chapter:verse= [%s]"),
								__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str(),
								pSrcPhrase->m_precPunct.c_str(), pSrcPhrase->m_markers.c_str(), pSrcPhrase->m_chapterVerse.c_str());
							if (pSrcPhrase->m_nSequNumber >= 5)
							{
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
#endif
						}  // end of else block for test: if (bItsSourceText)

	//					wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

					} // end of filtering TRUE block for test: if (bIsToBeFiltered)

					else
					{
						// BEW 30Sep19, Either the marker is not to be for filtering, 
						// (by checking in the gCurrentFilterMarkers fast access string), 
						// or it's not one that can be filtered (by checking in pUsfmAnalysis)
						// BEW 30Sep19  Attribute hiding, if to be done, is done in ParseWord()
						// so there is nothing to be added here for USFM 3.0
					isnull:

											// BEW 30Sep19, since control will go to ParsePreWord() which needs
											// to know correct values for the booleans:
											// bIsInlineBindingMkr and bIsInlineNonbindingMkr, we have to get
											// those set here now - otherwise their default FALSE value will
											// cause such markers to be wrongly stored on m_markers. 
						bool bFoundOne = FALSE;
//#if defined (_DEBUG)
						// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
						//wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
//#endif

						// Is it one of the binding ones? If not, is it one of the
						// non-binding ones, like \wj 'words of Jesus' etc
						// We check only the begin-markers, ParseWord()
						// handle the endmarkers for these inline ones.
						int offset = wxNOT_FOUND;
						itemLen = 0;
						if (IsMarker(ptr))
						{
#if defined (_DEBUG) && !defined(NOLOGS)
							wxString at; at = wxString(ptr, 16);
							wxLogDebug(_T("TokText(), line %d : sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = [%s], m_precPunct = [%s] , m_markers = [%s] , at=[%s]"),
								__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType,
								pSrcPhrase->m_key.c_str(), pSrcPhrase->m_precPunct.c_str(), pSrcPhrase->m_markers.c_str(), at.c_str());
							if (pSrcPhrase->m_nSequNumber >= 2)
							{
								int halt_here = 1;
							}
#endif
							wxString theMkr = GetWholeMarker(ptr);
							wxString mkrPlusSpace = theMkr + _T(' ');
							offset = gpApp->m_inlineBindingMarkers.Find(mkrPlusSpace);
							if (offset != wxNOT_FOUND)
							{
								// It is a beginmarker of the inline binding type (what USFM calls
								// 'Special Markers')
								bIsInlineBindingMkr = TRUE;
								bIsInlineNonbindingMkr = FALSE; // can't be both at same time
								bFoundOne = TRUE;
							}
						} // end of TRUE block for test: if (IsMarker(ptr))
						//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());

						// For other marker types, see next comment. If we found one, ptr must
						// still be pointing at it on entry to ParsePreWord() - in which case
						// the next block must be skipped, so ParsePreWord() can re-form the
						// marker and store it wherever it should go
#if defined (_DEBUG) && !defined(NOLOGS)
						wxLogDebug(_T("TokText(), line %d : sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = [%s], m_precPunct = [%s] , m_markers = [%s]"),
							__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType,
							pSrcPhrase->m_key.c_str(), pSrcPhrase->m_precPunct.c_str(), pSrcPhrase->m_markers.c_str());
						if (pSrcPhrase->m_nSequNumber >= 2)
						{
							int halt_here = 1;
						}
#endif
						if (!bFoundOne)
						{
							// BEW added comment 21May05: marker is not for filtering, so the marker's
							// contents (if any) will be visible and adaptable. The code here will
							// ensure the marker is added to the tokBuffer variable, and eventually be
							// saved in m_markers; but for endmarkers we have to suppress their use
							// for display in the navigation text area - we must do that job in
							// AnalyseMarker() below - after the ParseWord() call.

							// BEW 11Jun23, ptr is still pointing at the marker to be parsed. Check if it is
							// a \v marker, and if it is, set bool bIsVerseMkrParsed to TRUE, so that a little
							// further down we parse over the <space><verseNumber><space>, and add it to tokBuffer below
							if (ptr < pEnd && *ptr == gSFescapechar && *(ptr + 1) == _T('v'))
							{
								bIsVerseMkrParsed = TRUE;
							}
							itemLen = ParseMarker(ptr); // BEW 24Oct14, handles USFM nested markers too
							AppendItem(tokBuffer, temp, ptr, itemLen);
							// advance pointer past the marker
							ptr += itemLen;
							//	wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());

#if defined (_DEBUG) && !defined(NOLOGS)
							{
								ptrPointsAt = wxString(ptr, 16);
								wxLogDebug(_T("TokText(), NON-SRC FILTERING ENDS, line %d : sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key= [%s], m_precPunct= [%s] , m_markers= [%s]"),
									__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText,
									(int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_precPunct.c_str(), pSrcPhrase->m_markers.c_str());
								if (pSrcPhrase->m_nSequNumber >= 5)
								{
									int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
								}
							}
#endif
							itemLen = 0;
						} // end of TRUE block for test: if (!bFoundOne)
						else
						{
							goto parsing;
						}

					}  // end of else block for test: if (bIsToBeFiltered)

					itemLen = ParseWhiteSpace(ptr); // parse white space following it

					// whm 17Jan2024 moved the precWordDelim assignment here from the earlier location
					// that now calls the IteratePtrPastBogusPeriods(ptr) function. The old code block
					// following that new function, attempted to deal with bogus periods, but is now 
					// commented out being replaced by the new function. Within the commented out
					// code block were the following two lines that assigne a char value to precWordDelim
					// and store it on pSrcPhrase. Those two lines are moved here.
					if (itemLen > 0)
					{
						precWordDelim = *ptr; // the post-mkr space in swbk needs to be replaced by whatever
												 // whitespace char follows the marker
						pSrcPhrase->SetSrcWordBreak(precWordDelim);
					}

					AppendItem(tokBuffer, temp, ptr, itemLen); // add it to buffer
					ptr += itemLen; // advance ptr past its following whitespace
						// to get to the verse number, or whatever else if not a verse mkr

					// whm 17Jan2024 added IteratePtrPastBogusPeriods(ptr) here and 
					// remove if block below, except retain the precWordDelim setting 2 lines
					// inside the if block.
					int nPeriods = 0;
					IteratePtrPastBogusPeriods(ptr, pEnd, nPeriods);

					if (bIsVerseMkrParsed && IsAnsiDigit(*ptr))
					{
						// \v was just parsed, and ptr advanced to point at the verse number
#if defined (_DEBUG) && !defined(NOLOGS)
						{
							ptrPointsAt = wxString(ptr, 16);
							wxLogDebug(_T("TokText(), line= %d, sequNum= %d, m_bSpecialText= %d, m_key= [%s], chapter:verse= [%s], m_markers= [%s], pointsAt= [%s]"),
								__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText,
								pSrcPhrase->m_key.c_str(), pSrcPhrase->m_chapterVerse.c_str(), pSrcPhrase->m_markers.c_str(), ptrPointsAt.c_str());
							if (pSrcPhrase->m_nSequNumber >= 5)
							{
								int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
							}
						}
#endif
						itemLen = ParseNumber(ptr);
						AppendItem(tokBuffer, temp, ptr, itemLen); // add it to buffer
						ptr += itemLen;
						itemLen = 0;
						itemLen = ParseWhiteSpace(ptr);
						AppendItem(tokBuffer, temp, ptr, itemLen); // add it to buffer
						ptr += itemLen;
						pSrcPhrase->m_markers += tokBuffer;
						itemLen = 0;
						tokBuffer.Empty();
					}
					itemLen = 0; // fixes the above bug
//#if defined (_DEBUG)
					// BEW 24Oct22 track the pApp->m_bParsingSource value, where goes TRUE and back to FALSE
					//wxLogDebug(_T("%s::%s(), line %d : app->m_bParsingSource = %d"), __FILE__, __FUNCTION__, __LINE__, (int)gpApp->m_bParsingSource);
//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
//#endif

					// BEW added 15Aug12: a \p after an empty verses marker, can cause control
					// to come here without closing off the empty pSrcPhrase after accumulating
					// the \p into the m_markers member of the pSrcPhrase which still has
					// nothing in its m_key member -- so if ptr is pointing at a following \v
					// marker, force the break here from the inner loop so that the empty
					// verse's CSourcePhrase instance does not get 'lost' by being absorbed
					// into the m_markers of the next verse's first CSourcePhrase instance.
					// Otherwise iterate the inner loop
					if (ForceAnEmptyUSFMBreakHere(tokBuffer, pSrcPhrase, ptr))
					{
						// three conditions for returning TRUE, the main idea being that ptr
						// is pointing at a \v marker - if that's not the case, control will
						// skip this block
						bEmptyUSFM = TRUE; // this protects control from entering ParseWord()
											// further below when we break from the inner loop
						pSrcPhrase->m_key.Empty();
						pSrcPhrase->m_srcPhrase.Empty();
						pSrcPhrase->m_markers = tokBuffer;
						// whm 12Jan2024 modification. tokBuffer should be emptied once it has been assigned
						// to m_markers.
						tokBuffer.Empty();
						pSrcPhrase->m_bFirstOfType = TRUE;
#if defined (_DEBUG) && !defined(NOLOGS)
						ptrPointsAt = wxString(ptr, 18);
						wxLogDebug(_T("%s::%s(), line %d : sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = %s"), __FILE__, __FUNCTION__, __LINE__,
							(int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str());
						if (pSrcPhrase->m_nSequNumber >= 7)
						{
							int halt_here = 1;
						}
#endif
						break; // 10th break in TokenizeText()
					}
					//					wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());
#if defined (_DEBUG) && !defined (NOLOGS)
					if (pSrcPhrase->m_nSequNumber >= 2)
					{
						int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
					}
#endif
					// BEW 31Dec22 handle a widowed [ bracket following a \p marker, sets doc boolean m_bWidowedBracket if test succeeds

					wxChar newLine;
					newLine = _T('\n');
					if ((pSrcPhrase->m_key.IsEmpty() && *ptr == _T('[') && (*(ptr + 1) == newLine)) ||
						(*(ptr + 1) == _T(' ') && *(ptr + 2) == newLine) ||
						(*(ptr + 1) == _T(' ') && *(ptr + 2) == _T('\r') && *(ptr + 3) == _T('\n')))
					{
						if (*(ptr - 3) == gSFescapechar && (GetWholeMarker(ptr - 3) == _T("\\p")))
						{
							// set the boolean
							m_bWidowedBracket = TRUE; // ParseWord will deal with the [ near its start
							// Control is in the TokText's inner loop, we need to break so that control
							// can venture on to ParseWord()
							break; // 11th break in TokenizeText()
						}
						else
						{
							continue; // 7th continue in TokenizeText()
						}
					}
					else
					{

#if defined (_DEBUG) && !defined(NOLOGS)
						ptrPointsAt = wxString(ptr, 16);
						wxLogDebug(_T("TokText(), line %d, sequNum= %d , m_bSpecialText= %d , m_curTextType= %d, m_key= [%s], m_precPunct= [%s] , m_markers= [%s]"),
							__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType,
							pSrcPhrase->m_key.c_str(), pSrcPhrase->m_precPunct.c_str(), pSrcPhrase->m_markers.c_str());
						if (pSrcPhrase->m_nSequNumber >= 5)
						{
							int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
						}
#endif
						if (bIsVerseMkrParsed == FALSE)
						{
							continue; // iterate the inner loop to check if another marker follows - 8th continue in TokenizeText()
						}
						else
						{
							// we parsed a verse marker and verse number, no marker follows that
							// except possibly an inline binding one - but ParsePreWord() can handle that
							break; // from inner loop, for control to move on to ParsePreWord() - 12th break in TokenizeText()
						}
					}

				} // end of else block for test: if (IsVerseMarker(ptr, nMkrLen))

			}  // end of else block for test: if (IsChapterMarker(ptr))

		} // END of inner loop, while (!bSuppressBackwardSearchForWordBreakChar && IsMarker(ptr))
#if defined (_DEBUG) //&& !defined(NOLOGS)
		{
			ptrPointsAt = wxString(ptr, 16);
			//wxLogDebug(_T("TokText(), line %d : sequNum = %d , m_srcPhrase = [%s] , m_curTextType = %d, m_key = [%s] , m_markers= [%s], at=[%s]"), __LINE__,
			//	(int)pSrcPhrase->m_nSequNumber, pSrcPhrase->m_srcPhrase.c_str(), (int)pSrcPhrase->m_curTextType,
			//	pSrcPhrase->m_key.c_str(), pSrcPhrase->m_markers.c_str(), ptrPointsAt.c_str());
			if (pSrcPhrase->m_nSequNumber >= 28) // whm break
			{
				int halt_here = 1; wxUnusedVar(halt_here);
			}
		}
#endif
		if (bContinueTwice)
		{
			if (bSuppressBackwardSearchForWordBreakChar)
			{
				// Gotta append it to the m_pSourcePhrases list, else it will get lost from the doc
				pList->Append(pSrcPhrase);
				// make this one become the 'last one' of the next iteration
				pLastSrcPhrase = pSrcPhrase;
			}
			// Back in the outer loop, if two continues requested, this one will
			// force a new pSrcPhrase, and handle any following beginMkr, etc
			// ( bContinueTwice is set TRUE at line 19,294 , and iniating a new pSrcPhrase clears it to FALSE))
			continue; // 9th continue in TokenizeText()
		}

		// Back in the outer loop now. We have one of the following situations:
		// (1) ptr is not pointing at an inline marker that we need to handle within
		// ParseWord(), so it may be pointing at punctuation or a word of text to be
		// parsed. BEWARE, if ptr-> punct, the punct may be followed by a mkr to be filtered
		// e.g.  \f*:\x  <<-- the : needs to go in m_follOuterPuncts of current CSourcePhrase
		// (2) ptr is pointing at an inline marker we need to handle within ParseWord()
		// because these can have non-predictable interactions with punctuation,
		// especially punctuation which follows the wordform, and ParseWord() has the
		// smarts for dealing with nearly all the possibilities that may occur. (Usually
		// no ordinary marker will occur between the inline one and the word proper, but
		// \f*:\x - \xo ... violates this; so TokenizeText() must handle this, not
		// ParseWord() - and if the : gets to ParsePreWord() then the game is over! Error!!
		// (3) ptr is pointing at a [ opening bracket which needs to be stored on the
		// current pSrcPhrase (in its m_precPunct member, along with any following space
		// if one is present in the input file after the [ bracket) along with any
		// m_markers content already accumulated - we must do that before parsing further
		// because 'further' would then belong to the next CSourcePhrase instance
		// (4) bEmptyUSFM flag is TRUE, in which case we bypass ParseWord and create a
		// contentless CSourcePhrase to carry the verse marker (and chapter marker too if
		// the verse is verse 1)
		// (5) ptr is pointing at a word, or punctuation which precedes the word
		// (6) we might be forcing a new pSrcPhase, as when [ precedes a beginMkr
#if defined (_DEBUG) && !defined(NOLOGS)
		ptrPointsAt = wxString(ptr, 18);
		wxLogDebug(_T("TokText(), line %d, sequNum= %d , m_bSpecialText= %d , m_curTextType= %d, m_key= [%s], m_precPunct= [%s] , ptrPointsAt= [%s]"),
			__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType,
			pSrcPhrase->m_key.c_str(), pSrcPhrase->m_precPunct.c_str(), ptrPointsAt.c_str());
		if (pSrcPhrase->m_nSequNumber >= 2)
		{
			int halt_here = 1;
		}
#endif
		if (bEmptyUSFM)
		{
			// BEW added 13Jul11, new parsing block which bypasses ParseWord() and which
			// supports parsing of Paratext's contentless USFM markup for a book or chapter
			pSrcPhrase->m_curTextType = verse;
		}
		else
		{
			// legacy/standard parsing block... which calls ParsePreWord() and then ParseWord()...

			// the TokenizeText() caller determines whether spacelessPuncts contains the
			// m_punctuation[0] source puncts set, or m_punctuation[1] target set; typically,
			// it is the source set, but we do use an override of the TokenizeTextString()
			// with a boolean at the end, when we explicitly want to parse target text - in
			// that case, the boolean is TRUE and the target puncts set get passed to
			// TokenizeText() which then removes spaces (whichever set it receives, it removes
			// spaces before passing the punctuation characters themselves to TokenizeText())
			// - if any functions within ParseWord() require space to be in the passed-in set
			// of punctuation characters, they can add an explicit space when they first run

#if defined (_DEBUG) && defined(DEBUG_ZWSP) && !defined(NOLOGS)
			// Show Unicode values for next 12 characters
			wxChar ch0 = *ptr;
			wxChar ch1 = *(ptr + 1);
			wxChar ch2 = *(ptr + 2);
			wxChar ch3 = *(ptr + 3);
			wxChar ch4 = *(ptr + 4);
			wxChar ch5 = *(ptr + 5);
			wxChar ch6 = *(ptr + 6);
			wxChar ch7 = *(ptr + 7);
			wxChar ch8 = *(ptr + 8);
			wxChar ch9 = *(ptr + 9);
			wxChar ch10 = *(ptr + 10);
			wxChar ch11 = *(ptr + 11);
			wxString s0 = ch0;
			wxString s1 = ch1;
			wxString s2 = ch2;
			wxString s3 = ch3;
			wxString s4 = ch4;
			wxString s5 = ch5;
			wxString s6 = ch6;
			wxString s7 = ch7;
			wxString s8 = ch8;
			wxString s9 = ch9;
			wxString s10 = ch10;
			wxString s11 = ch11;
			s0 = MakeUNNNN(s0);
			s1 = MakeUNNNN(s1);
			s2 = MakeUNNNN(s2);
			s3 = MakeUNNNN(s3);
			s4 = MakeUNNNN(s4);
			s5 = MakeUNNNN(s5);
			s6 = MakeUNNNN(s6);
			s7 = MakeUNNNN(s7);
			s8 = MakeUNNNN(s8);
			s9 = MakeUNNNN(s9);
			s10 = MakeUNNNN(s10);
			s11 = MakeUNNNN(s11);
			wxLogDebug(_T("TWELVE: (0) %s (1) %s (2) %s (3) %s (4) %s (5) %s (6) %s (7) %s (8) %s (9) %s (10) %s (11) %s"),
				s0.c_str(), s1.c_str(), s2.c_str(), s3.c_str(), s4.c_str(), s5.c_str(), s6.c_str(), s7.c_str(), s8.c_str(), s9.c_str(), s10.c_str(), s11.c_str());
#endif
			//			wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_markers= %s"), __LINE__, pSrcPhrase->m_nSequNumber, pSrcPhrase->m_markers.c_str());

		parsing:
#if defined (_DEBUG) //&& !defined(NOLOGS)
			//theptrPointsAt = wxString(ptr, 16);
			//wxLogDebug(_T("TokText(), line %d : sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = [%s], m_precPunct = [%s] , m_markers = [%s] , pointsAt= [%s]"),
			//	__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str(),
			//	pSrcPhrase->m_precPunct.c_str(), pSrcPhrase->m_markers.c_str(), theptrPointsAt.c_str());
			if (pSrcPhrase->m_nSequNumber == 760)
			{
				int halt_here = 1; wxUnusedVar(halt_here);
			}
#endif
			// BEW 25Jul23 ParsePreWord() causes \fig (a char attribute mkr) - and maybe other begin mkrs
			// to be parsed over. But members of charAttributeMkrs must not have ptr advance, because
			// ParseWord(), as its first task, is to check for ptr pointing at gSFescapechar, and if so,
			// to test for a char attribute beginMkr being at ptr, so that any needed hiding of bar-initial
			// data can be accomplished, hiding it in pSrcPhrase->m_punctsPattern, then return len. So here,
			// block any possibility of ptr advancing if bKeepPtrFromAdvancing is TRUE
			if (!bKeepPtrFromAdvancing)
			{
				// skip, if the bool was TRUE
				itemLen = ParsePreWord(ptr, pEnd, pSrcPhrase, spacelessPuncts, pApp->m_inlineNonbindingMarkers,
					pApp->m_inlineNonbindingEndMarkers, bIsInlineNonbindingMkr, bIsInlineBindingMkr, bTokenizingTargetText);

#if defined (_DEBUG) && !defined (NOLOGS)
				// whm 16Jun2023 separated the declaration of wxChar* auxPtr from its assignment/initialization below, to 
				// resolve compiler error from GCC: "jump to label 'finishup'...crosses initialization of wxChar* auxPtr"
				wxChar* auxPtr;
				auxPtr = ptr + itemLen;
				wxLogDebug(_T("ITEMLEN+PTR line %d ,  len %d , 20 at ptr= [%s]"), __LINE__, itemLen, wxString(auxPtr, 20).c_str());
#endif
				// BEW 15Sep22 if ParsePreWord() actually advanced control's ptr, then before we hand over
				// further below to ParseWord() to handle the word parsing, final punctuations, and endmarkers
				// and alse - if control is within a caching span, to complete the storage of cache data when it
				// has been identified, within ParseWord(), as not cached yet and needs to be, to get that done
				if (itemLen > 0)
				{
					// itemLen is non-zero, advance of ptr needs to be done here, and reset itemLen to 0, so that
					// ParseWord() will have ptr pointing where it needs to be, at the entry of ParseWord()
					ptr = ptr + (size_t)itemLen;
					itemLen = 0; // re-initialize, for ParseWord()
				}
#if defined (_DEBUG) //&& !defined (NOLOGS)
				{
					wxString pointsAt;
					if (ptr + 14 < pEnd)
					{
						pointsAt = wxString(ptr, 16);
						//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , pointsAt= [%s]"),
						//	__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, pointsAt.c_str());
					}
					if (pSrcPhrase->m_nSequNumber >= 391)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
				}
#endif
			} // end of TRUE block for test: if (!bKeepPtrFromAdvancing)
		// Below is the Legacy ParseWord().
		// BEW 1Dec22 the legacy one is superior to my now thrown away ParseWord2() - the latter never got completed.
		// The Legacy one, now heavily refactored better, can still handle punctuation changing to word-building char, or vise
		// versa, and ~ fixed space, and does pretty well at post-word mixes of endmarkers and punctuation, plus USFM3 support
//#if defined (_DEBUG)
		//wxLogDebug(_T("TokenizeText: line %d  , entering ParseWord():  itemLen = %d , ptr->%s , sn= %d , precPunct= %s , m_markers= %s"),
		//	__LINE__, itemLen, (wxString(ptr, 15)).c_str(), pSrcPhrase->m_nSequNumber, pSrcPhrase->m_precPunct.c_str(), pSrcPhrase->m_markers.c_str());
		//if (pSrcPhrase->m_nSequNumber >= 1)
		//{
		//	int halt_here = 1; wxUnusedVar(halt_here);
		//}
//#endif
// ******************************** Parse Word () *************************

			itemLen = ParseWord(ptr, pBufStart, pEnd, pSrcPhrase, spacelessPuncts, // whm 28Sep2023 added pBufStart to signature
				pApp->m_inlineNonbindingMarkers,
				pApp->m_inlineNonbindingEndMarkers,
				bIsInlineNonbindingMkr, bIsInlineBindingMkr,
				bTokenizingTargetText);

			//		wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

		finishup: // BEW 3Nov22 added, to bypass ParsePreWord() and ParseWord() when doing ??? insertion to the doc
			
			// whm 12Jan2024 added the following boolean to inform TokenizeText after execution over 
			// the finishup: jump label that execution has come from an inner empty markers loop or
			// other inner markers loop where the itemLen value was used/changed.
			// This bool will inform the code following the finishup: jump label that the itemLen
			// value there should be re-initialized to zero, since it did not come from the previous
			// call of ParseWord(). 
			if (bComingFromInnerMarkerLoop)
			{
				itemLen = 0;
				bComingFromInnerMarkerLoop = FALSE;
			}

//#if defined (_DEBUG)
		//wxLogDebug(_T("TokenizeText: line %d  , finished ParseWord(),  itemLen = %d , ptr->%s , sn=%d , precPunct= %s , follPunct= %s"),
		//	__LINE__, itemLen, (wxString(ptr, 12)).c_str(), pSrcPhrase->m_nSequNumber, pSrcPhrase->m_precPunct.c_str(), pSrcPhrase->m_follPunct.c_str());
//#endif
#if defined (_DEBUG) //&& !defined (NOLOGS)
			if (pSrcPhrase->m_nSequNumber >= 440)
			{
				int halt_here = 1; wxUnusedVar(halt_here);
			}
#endif

#if defined (_DEBUG) && !defined(NOLOGS)
			{
				ptrPointsAt = wxString(ptr, 25);
				wxLogDebug(_T("TokText() AFTER PARSEWORD, line %d, sequNum = %d, itemLen= %d , m_bSpecialText= %d , m_curTextType= %d, m_key = [%s] , m_markers= [%s]"),
					__LINE__, (int)pSrcPhrase->m_nSequNumber, itemLen, (int)pSrcPhrase->m_bSpecialText,
					(int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_markers.c_str());
				if (pSrcPhrase->m_nSequNumber >= 1)
				{
					int halt_here = 1;
				}
			}
#endif
			if (itemLen == -1)
			{
				// There has been a significant parsing error, don't continue, but force
				// TokenizeText() to abort by returning -1 here 
				wxString msg = _T("TokenizeText() at line %d detected that ParseWord() returned a -1 value for itemLen. This indicates a serious doc input parsing error of sufficient gravity to crash the app while trying to create the document using OnNewDocument().");
				msg = msg.Format(msg, __LINE__);
				// add to UsageLog_bruce.txt  and shorten as it's now over 4MB, (shortening has to be done manually, periodically) 
				// It's LogUserAction(wxString msg) that automatically adds msg to the m_userLogFile
				gpApp->LogUserAction(msg);
				return itemLen;
			}
#if defined(_DEBUG) && !defined(NOLOGS)
			wxString strParsed = pSrcPhrase->m_srcPhrase;
			wxString keyParsed = pSrcPhrase->m_key;
			int aSequNum = pSrcPhrase->m_nSequNumber;
			wxString strComingNext = wxString(ptr, (ptr + 20L));
			wxLogDebug(_T("TokenizeText(), line %d : after ParseWord(), sn = %d ,  m_key: %s ,  pSrcPhrase->m_srcPhrase: %s , pSrcPhrase->m_targetStr= %s, pSrcPhrase->m_adaption= %s , m_precPunct= %s ,  ptr-> %s"),
				__LINE__, aSequNum, keyParsed.c_str(), strParsed.c_str(), pSrcPhrase->m_targetStr.c_str(), pSrcPhrase->m_adaption.c_str(), pSrcPhrase->m_precPunct.c_str(), strComingNext.c_str());
#endif

			// BEW 3May23 get the pre-ParseWord src text using the itemLen value, and store it in Doc.h's m_srcWordAndExtrasArr,
			// which is a new public wxArrayString doc class member
			// BEW 6May23 added 3rd subtext, checking that m_srcSinglePattern is empty. Reason? The contents of m_srcSinglePattern
			// should remain inviolate for the life of the document. Users may change ending puncts, etc, but with algorithmic
			// marker placements in complex post-word mix of puncts and markers, the algorithms should work well, even when puncts
			// get changed, provided m_srcSinglePattern does not change, or if all before versus after puncts are matched with
			// no residue as the matched ones are removed. Setting it is only do-able here, so once its done, it
			// needs to stay unchanged. (It's updateable perhaps if the user manually makes puncts changes.)
			wxString strWordAndExtras = wxEmptyString;
			if (itemLen > 0 && bTokenizingTargetText == FALSE && pSrcPhrase->m_srcSinglePattern.IsEmpty())
			{
				// Here we handle setting m_srcSinglePattern, for the text being source text.
				// Don't enter if bTokenizingTargetText is TRUE, it needs it's own dedicated 'get' functionality.
				//  ( tokenizing the source text is done in MakeTargetStringIncludingPunctuation() -- see view.cpp )
				// Note: this function must not be called after the ptr += itemLen line which follows
				strWordAndExtras = MakeWordAndExtras(ptr, itemLen);
				strWordAndExtras.Trim(); // remove any final whitespace(s)
				// BEW 3May23, I get the wanted values, for each pSrcPhrase, but need a storage location on pSrcPhrase.
				// 4May23 I've implemented document VERSION_NUMBER 10
				// 
				// whm 24Jan2024 modified. I've noticed that a freshly created document often doesn't have
				// an m_oldKey value in its xml and when this happens it fouls up source exports and probably 
				// other things. There is no valid reason I can see for testing for docVersion >= 10 below. A
				// freshly tokenized new document should always have its m_oldKey set to be the same as the 
				// m_key, otherwise how could subsequently comparing the m_key with the m_oldKey detect any
				// user changes after the document is created?
				// Therefore I'm commenting out the if (docVersion >= 10 ...) part of the test below.
				//int docVersion = GetCurrentDocVersion();
				//if (docVersion >= 10 && pSrcPhrase->m_nSrcWords < 2)
				if (pSrcPhrase->m_nSrcWords < 2)
				{
					// It's not a merger, so store in pSrcPhrase's new m_srcSinglePattern member
					pSrcPhrase->m_srcSinglePattern = strWordAndExtras; // the pSrcPhrase->m_key value will start the string
					// BEW 10May23, exporting src text will call RebuildSourceText() and for user-edited m_key value we need
					// to have available the m_oldKey value (for comparison) so as to know if an edit of m_srcSinglePattern
					// is needed in the rebuild. Today I added support for pSrcPhrase->m_oldKey to the document's xml. 
					// So here I need to store pSrcPhrase->m_key in pSrcPhrase->m_oldKey
					pSrcPhrase->m_oldKey = pSrcPhrase->m_key;
#if defined (_DEBUG) && !defined (NOLOGS)
					wxLogDebug(_T("TokenizeText(), line %d : MakeWordAndExtras: strWordAndExtras= [%s], sn = %d , bTokenizingTargetText = %d , m_oldKey= [%s]"),
						__LINE__, strWordAndExtras.c_str(), (int)aSequNum, (int)bTokenizingTargetText, pSrcPhrase->m_oldKey.c_str());
					if (pSrcPhrase->m_nSequNumber >= 4)
					{
						int halt_here = 1; wxUnusedVar(halt_here); // avoid compiler warning variable initialized but not referenced
					}
#endif
				}
			} // end of TRUE block for test: if (itemLen > 0 && bTokenizingTargetText == FALSE)

#if defined (_DEBUG) && !defined (NOLOGS)
			wxLogDebug(_T("After ParseWord:  line %d , sequNum= %d, itemLen= %d , 16 chars at ptr= [%s]  Before ptr update"),
				__LINE__, pSrcPhrase->m_nSequNumber, itemLen, wxString(ptr, 16).c_str());
			if (pSrcPhrase->m_nSequNumber >= 1)
			{
				int halt_here = 1;
			}
#endif

#if defined (_DEBUG) // && !defined (NOLOGS)
			//wxLogDebug(_T("After ParseWord: ITEMLEN+PTR line %d , len %d , 20 at ptr= [%s]  Before ptr update"), __LINE__, itemLen, wxString(ptr, 20).c_str());
			if (pSrcPhrase->m_nSequNumber >= 322)
			{
				int halt_here = 1; wxUnusedVar(halt_here);
			}
#endif
			// itemLen can arrive here with a value > 0 so protect ptr from incrementing past pEnd
			//
			// whm 29Jan2024 modified the following test. The second part ot the test && ptr + itemLen < pEnd should
			// be && ptr + itemLen <= pEnd where <= is used instead of just < test. Otherwise it is possible when
			// the string parsed was a word whose last char is at pEnd, the ptr would not be advanced and TokenizeText(0
			// would then get into an infinite loop trying continually to parse that last word and ptr never getting
			// incremented. Therefore, I've changed the < to <= in the second part of the test below.
			if (itemLen > 0 && ptr + itemLen <= pEnd) //if (itemLen > 0 && ptr + itemLen < pEnd)
			{
				ptr += itemLen; // advance ptr over what we parsed
			}

// NOLOGS   wxLogDebug(_T("After ParseWord: ITEMLEN+PTR line %d , len %d , 20 at ptr= [%s]  After ptr update"), __LINE__, 0, wxString(ptr, 20).c_str());


#if defined (_DEBUG) && !defined(NOLOGS)
			ptrPointsAt = wxString(ptr, 15);
			wxLogDebug(_T("%s::%s(), line %d : sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = %s"), __FILE__, __FUNCTION__, __LINE__,
				(int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str());
			if (pSrcPhrase->m_nSequNumber >= 3)
			{
				int halt_here = 1;
			}
#endif
			// We do NormalizeToSpaces() only on the string of standard format markers which
			// we store on sourcephrase instances in m_markers, it's not needed elsewhere in
			// CSourcePhrase storage members.
			//pSrcPhrase->m_markers = NormalizeToSpaces(pSrcPhrase->m_markers);
			tokBuffer.Empty();

			// ************ Even Newer Propagation Code Starts Here BEW 13Dec22 ******************
#if defined (_DEBUG) && !defined(NOLOGS)
			{
				ptrPointsAt = wxString(ptr, 25);
				wxLogDebug(_T("\nTokText() NEW Propagation STARTS, line %d : sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = %s , m_markers=%s"),
					__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText,
					(int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str(), pSrcPhrase->m_markers.c_str());
				if (pSrcPhrase->m_nSequNumber >= 1)
				{
					int halt_here = 1;
				}
			}
#endif

			// BEW 31May23 How propagation works. Hopefully these comments will make the functionality intelligible.
			// 1. it looks back, not forward, so looks at values in pLastSrcPhrase (if it is not NULL)
			// 2. It copies pLastSrcPhrase->m_bSpecialText value, and pLastSrcPhrase->m_curTextType to the current pSrcPhrase
			//    when propagating the settings forward unchanged to the current pSrcPhrase
			// 3. Sometimes instead of copying, it changes the textType (to verse textType, after certain endMkrs)
			// 4. The propagation code makes use of pApp's various fast access strings, for decision making. For example,
			//    m_EmbeddedIgnoreEndMarkers = _T("\\fv* \\ft* \\fr* \\fqa* \\fq* \\fdc* \\fm* \\xop* \\xot* \\xnt* \\xdc* ")
			//    any endMkr from this set would be "inline" but we store them in pSrcPhrase->m_endMarkers neveretheless,
			//    but although in the m_RedEndMarkers fast-access set, we do not allow these to change the textType nor m_bSpecialText value
			// 5. Today, I made a new function:  wxString GetLastEndMarker(wxString endMkrs), which grabs the last in 
			//    pLastSrcPhrase->m_endMarkers, for choice-making - it's the last which determines what the propagation values should be.
			// 6. What endMkrs change the textType and m_bSpecialText value? Ones like \f* or \x* These cause a boolean to
			//    become TRUE, which (on pLastSrcPhrase) sets that as the last in the span, and then the next pSrcPhrase will be 'verse'
			// 7. The Doc class tracks the inline span, e.g. between \f and \f*, using a boolean member: m_bIsWithinUnfilteredInlineSpan

			bool bTextTypeChanges = FALSE;
			nFirstSequNumOfSpan = 0; // initialize (BEW 13Dec22) this variable is now a Doc member, 
									 // it should not be reinitialized at every new pSrcPhrase of a \fig span
			// BEW 30Sep19 Handle the \fig marker and it's span and endmarker, as a
			// special case - we want an unfiltered \fig ... \fig* span to appear in
			// the GUI with the "illustration" caption text showing, but as m_bSpecialText
			// set TRUE (to get the default red color, or whatever user has changed it to)
			// and the navigation text to show "illustration". In USFM 3, any attributes-
			// having metadata will have been automatically hidden already (i.e. bar (|)
			// to the start of the endmarker, and m_bUnused set TRUE to indicate there is
			// metadata hidden in pSrcPhrase->m_punctsPattern
			// 
			// whm 23Sep2023 update to above comment. The attributes for \fig are now fully
			// set within the AI_USFM.xml control file where they should have been set, including
			// setting the special attribute to 1 (TRUE) and navigationText to "figure" which
			// I think is shorter for nav text and more mnemonic for users.
			// 
			//wxString aBeginMarker = pSrcPhrase->GetInlineNonbindingMarkers();
			// BEW 1Aug23 refactored next bit, I had aBeginMarker set to the whole inline fast-access string. Ouch!
			wxString aBeginMarker;
			aBeginMarker = wxEmptyString; // init
			// whm 31Oct2023 correction was needed back in ParseWord(), because currently the 
			// pSrcPhrase's m_inlineNonbindingMarkers member is empty when TokenizeText() is 
			// parsing to unfilter a previously filtered \fig marker which was stored in
			// the pSrcPhrase->m_filteredInfo member. So, currently the strNBMkrs string ends
			// up being empty in the code below. Therefore, I'm making modifications in
			// ParseWord() to ensure that the pSrcPhrase->m_inlineNonbindingMarkers member
			// gets the \\fig begin marker stored in it. Also further below it is evident
			// that the pSrcPhrase->m_inlineNonbindingEndMarkers member of the last caption
			// word needs to have the \\fig* end marker stored within it as well. 
			wxString strNBMkrs = pSrcPhrase->GetInlineNonbindingMarkers();
			wxString augmentedFigStr = _T("\\fig ");
			wxString figEndMkr = _T("\\fig*");
			int anoffset;
			// whm 31Oct2024 commented out the following. m_bIsInFigSpan is init at beginning 
			// of TokenizeText() and must not be set FALSE here but only after tokenizing the 
			// last \fig span word, or within the end marker detection block below.
			//m_bIsInFigSpan = FALSE; // init, it's a Doc member boolean
			anoffset = -1; // init
			anoffset = strNBMkrs.Find(augmentedFigStr);
			if (anoffset >= 0)
			{
				// \fig<space> is in the non-binding set of inline markers
				aBeginMarker = augmentedFigStr.Trim(); // chop off final <space>
				if (!aBeginMarker.IsEmpty())
				{
					if (pSrcPhrase->m_bFirstOfType && pSrcPhrase->m_bSpecialText && (pSrcPhrase->m_curTextType == noType))
					{
						pSrcPhrase->m_bBoundary = TRUE;
						//bTextTypeChanges = TRUE; // BEW 3Jul23 irrelevant for \fig*, which is inline non-binding
						m_bIsInFigSpan = TRUE;
						nFirstSequNumOfSpan = pSrcPhrase->m_nSequNumber;
						m_bIsWithinUnfilteredInlineSpan = TRUE; // BEW 13Dec22 added
					}
					//	wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , fig span starts"), 
					//		__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
				} // at start of span, so we need to propagate the m_bSpecialText value
			}

			// SubsequentCSourcePhrases need to check here, until endmarker is reached
			if (m_bIsInFigSpan && pSrcPhrase->m_nSequNumber > nFirstSequNumOfSpan)
			{
				// whm 31Oct2023 refactored this block to detect if we are at the attribute bar '|' character
				// and if so, complete the parsing of the rest of attribute marking bar and the "hidden" meta
				// data that exists between the bar and the attribute end marker, i.e., \\fig*.
				// I want to do the parsing of the hidden metadata here so we can store it on the current
				// pSrcPhrase->m_punctsPattern member, and not call ParseWord() again which would
				// create a new (but empty) instance of pSrcPhrase, and store the hidden metadata there.
				int ctWhiteSp = 0;
				// wxChar charWhiteSpace; // unused
				wxChar* tempPtr = ptr;
				while (IsWhiteSpace(ptr))
				{
					ctWhiteSp++;
					ptr++;
				}
				wxString strWhiteSpaceChars;
				strWhiteSpaceChars = wxString(tempPtr, ctWhiteSp);

				// whm 31Oct2023 Note: much of the code below is copied from code in ParseWord() at the test 
				// if (*ptr == chBar), which is now mostly commented out. 
				wxChar chBar = _T('|');
				if (*ptr == chBar)
				{
					// TODO: Copy from ParseWord() the code to fix bogus markup such as word|word where 'word' is 
					// the same both sides of the bar.
					int len = 0; // local length of scanned string below.
					wxChar* pBar = ptr; // BEW 6Jan23 need this for hunting to the next mkr
					// 
					// We are not correcting something like abaib|abaib, so scan to the end of endMkr (if the scan
					// gets to a beginMkr, return the count, without including the beginMkr width)
					ptr = pBar;
					int nScannedWidth = ScanToNextMarker(pBar, pEnd); // pEnd is still pointing at end of string being parsed in fig span
					if (nScannedWidth > 0)
					{
						// squirrel the span away in pSrcPhrase->m_punctsPattern, and set m_bUnused = TRUE
						wxString contents = wxString(pBar, nScannedWidth);
						len += nScannedWidth;
						pSrcPhrase->m_punctsPattern = contents;
						pSrcPhrase->m_bUnused = TRUE;
						// return len; // not appropriate here in TokenizeText()
						int offset = wxNOT_FOUND;
						offset = contents.Find(figEndMkr);
						if (offset != wxNOT_FOUND)
						{
							// [BEW comment] This previous instance is the CSourcePhrase which ends the  \fig .... \fig* span; 
							// so for the current one revert to 'verse' and m_bSpecialText FALSE
							// whm update to above comment: We are storing the hidden meta data for the attribute span on the
							// current pSrcPhrase. It is also the pSrcPhrase where the m_bBoundary should be set TRUE.
							pSrcPhrase->m_bSpecialText = FALSE;
							pSrcPhrase->m_curTextType = verse;
							pSrcPhrase->m_bFirstOfType = TRUE; // TextType has changed

							// And make the last a boundary, and turn off first of type to make sure it's off there
							//pLastSrcPhrase->m_bBoundary = TRUE;
							//pLastSrcPhrase->m_bFirstOfType = FALSE;
							pSrcPhrase->m_bBoundary = TRUE;
							pSrcPhrase->m_bFirstOfType = FALSE;

							// And clear the boolean which declares we are parsing within a \fig ... \fig* span
							m_bIsInFigSpan = FALSE;
							nFirstSequNumOfSpan = 0; // re-initialize

							// whm 31Oct2023 we should add the char attribute end marker to the 
							// pSrcPhrase->m_inlineNonbindingEndMarkers member for the filtering
							// code to work properly if/when the char attribute end marker gets
							// filtered out again.
							pSrcPhrase->SetInlineNonbindingEndMarkers(figEndMkr);
						}
						ptr += len; // point past the
					}
					else // nScannedWidth == 0
					{
						pSrcPhrase->m_punctsPattern.Empty();
						// don't send len zero to TokenizeText. Since we started by pointing at a bar,
						// increase len by 1, to give TokenizeText() a chance to advance without a crash
						//len += 1; // not relevant here
						//return len; // not appropriate here in TokenizeText()
					}
					// No need to store the \fig* end marker in the pLastSrcPhrase as was done in the
					// following code block. We can verify that the end marker exists in the App's
					// m_inlineNonbindingEndMarkers = _T("\\wj* \\sls* \\tl* \\+wj* \\+qt* \\+sls* \\+tl* \\fig* \\+fig* ")
					// and if so, then go ahead and set the pSrcPhrase, pLastSrcPhrase and other assignments
					// within the else block below since we are at the end of the attribute marker span.

				}
				
				/* // whm 31Oct2023 The code in this section is now not needed or parts have been copied above with 
				// modifications.

				// Since this is a span, pLastSrcPhrase will exist; but it's not relevant to propagation changing
				wxString strInlineNonBindingEndMkr = pLastSrcPhrase->GetInlineNonbindingEndMarkers();
				if (strInlineNonBindingEndMkr.IsEmpty())
				{
					// no change in propagation
					//pLastSrcPhrase->m_bSpecialText = TRUE;
					pLastSrcPhrase->m_curTextType = noType;
				}
				else
				{
#if defined (_DEBUG) && !defined(NOLOGS)
					wxLogDebug(_T("TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d"),
						__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType);
					if (pSrcPhrase->m_nSequNumber >= 1)
					{
						int halt_here = 1; wxUnusedVar(halt_here);
					}
#endif
					int offset = wxNOT_FOUND;
					offset = strInlineNonBindingEndMkr.Find(figEndMkr);
					if (offset != wxNOT_FOUND)
					{
						// This previous instance is the CSourcePhrase which ends the  \fig .... \fig* span; 
						// so for the current one revert to 'verse' and m_bSpecialText FALSE
						pSrcPhrase->m_bSpecialText = FALSE;
						pSrcPhrase->m_curTextType = verse;
						pSrcPhrase->m_bFirstOfType = TRUE; // TextType has changed

						// And make the last a boundary, and turn off first of type to make sure it's off there
						pLastSrcPhrase->m_bBoundary = TRUE;
						pLastSrcPhrase->m_bFirstOfType = FALSE;

						// And clear the boolean which declares we are parsing within a \fig ... \fig* span
						m_bIsInFigSpan = FALSE;
						nFirstSequNumOfSpan = 0; // re-initialize
					}
				} // end of else block for test: if (strInlineNonBindingEndMkr.IsEmpty())
				*/

			} // end of TRUE block for test: if (m_bIsInFigSpan && pSrcPhrase->m_nSequNumber > nFirstSequNumOfSpan)
#if defined (_DEBUG) && !defined(NOLOGS)
			wxString ptrAt = wxString(ptr, 20);
			wxLogDebug(_T("TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d, ptrAt= [%s]"),
				__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, ptrAt.c_str());
			if (pSrcPhrase->m_nSequNumber >= 1)
			{
				int halt_here = 1; wxUnusedVar(halt_here);
			}
#endif
			// BEW 13Dec22 - the code above is now correct, only a few small changes, and int nFirstSequNumOfSpan moved to be member on Doc.h

			bool bIsUnknownMkr = FALSE; // init
			bIsUnknownMkr = bIsUnknownMkr; // avoid gcc warning set but not used warning
			// Set TextType and m_bSpecialText according to what the type and special text
			// value are for the last marker in tokBuffer. We have to handle beginMkrs first,
			// and further down, endMkrs which typically end some kind of span
#if defined (_DEBUG) && !defined(NOLOGS)
			// BEW 10Jun23 removed most logging, at LastBeginMkr has logging, issue is that
			// Steve Whites's 46MATfuh.SFM source text parses in lots of verse number in
			// the source text line, rather than in navigation whiteboard. I want to be
			// able to locate where each printed out log of last marker exists.
			// BEW 1Aug23 although this log code does not look at last marker in m_markers, we do need to not take the last
			// as definitive; because \v followed by \p doesn't deliver what we want, we want more smarts - find \v and if not there
			// then take whatever is first marker in m_markers - I'll implement this protocol asap
			// I've made a useful new number parser, wxString ParseNumberInStr( wxString <a string having the first digit a number> )
			int sn = pSrcPhrase->m_nSequNumber; wxUnusedVar(sn); // avoid compiler warning variable initialized but not referenced
			wxString srcPhrase = pSrcPhrase->m_srcPhrase;
			wxString verseNumber = _T("0");
			wxString strMarkers = pSrcPhrase->m_markers;
			int offset = wxNOT_FOUND;
			wxString strVerseMkr = _T("\\v ");
			if (!strMarkers.IsEmpty())
			{
				offset = strMarkers.Find(strVerseMkr);
				int verseLen;
				verseLen = 0; // init
				wxString strAtVerse; wxString strAtNumber;
				strAtVerse = wxEmptyString;
				strAtNumber = wxEmptyString;
				if (offset >= 0)
				{
					// Found "\\v " 3 characters at offset
					strAtVerse = strMarkers.Mid(offset);
					strAtNumber = strAtVerse.Mid(3); // 3 for width of \v<space>
					// The number could be 1, 2, or 3 digits long, need a ParseNumberInStr(wxString strVerse)

					verseNumber = ParseNumberInStr(strAtNumber);
					//verseNumber = strMarkers.Mid(offset, 5);
				}
			}
			// NOLOGS			wxLogDebug(_T("TokText() LOGGING ONLY, m_markers: doc line %d, m_markers= [%s] ,  sequNum %d , m_srcPhrase= [%s] , verseNumber %s"),
			//						__LINE__, strMarkers.c_str(), sn, srcPhrase.c_str(), verseNumber.c_str());
#endif
			//wxString wholeBeginMkr = GetLastBeginMkr(pSrcPhrase->m_markers); // BEW 31Aug23 Bill wants first marker to be given priority
			wxString wholeBeginMkr = GetPriorityBeginMkr(pSrcPhrase->m_markers); // BEW 31Aug23, reinstated.
					// If only one, gets it; if more than one in m_markers, gets whatever is first, 
					// if its an endMkr, returns wxEmptyString
			// Is it augmented? Quickest way is to Trim() and then add space
			wholeBeginMkr.Trim(); // default trims the RHS
			wxString augWholeBeginMkr = wholeBeginMkr + _T(' ');

//			wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

			// BEW changed test below, because control may be at a pSrcPhrase which stores an endMkr
			// such as \f*. So we want control to enter the block below so AnalyseMarker can sort things out.
			wxString endMkrs = pSrcPhrase->GetEndMarkers();
			wxString strLastEndMkr = wxEmptyString; // init
			if (!endMkrs.IsEmpty())
			{
				strLastEndMkr = GetLastEndMarker(endMkrs);
				wxASSERT(!strLastEndMkr.IsEmpty());
			}
			bool bEndedffexspanUsedToChangedTextType = FALSE; // init
			bEndedffexspanUsedToChangedTextType = bEndedffexspanUsedToChangedTextType; // avoid gcc warning set but not used warning

			if (!wholeBeginMkr.IsEmpty() || !strLastEndMkr.IsEmpty()) // BEW 15Jun23 added 2nd subtest
			{
#if defined (_DEBUG) && !defined(NOLOGS)
				wxLogDebug(_T("TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d"),
					__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType);
				if (pSrcPhrase->m_nSequNumber >= 1)
				{
					int halt_here = 1; wxUnusedVar(halt_here);
				}
#endif
				// set TextType and m_bSpecialText according to what the type and special text
				// value are for the last marker in pSrcPhrase->m_markers (obtained above)
				if ((wholeBeginMkr.Find(gSFescapechar) != wxNOT_FOUND) || !strLastEndMkr.IsEmpty())
				{
					// m_markers doesn't store endmarkers in docversion 5, so we know it must
					// be a beginmarker, or an empty string; if it is a beginmarker, it might
					// be an unknown (ie. not defined in AI_USFM.xml) marker, such as \y, and
					// so we must detect any such and ensure the text they mark is coloured
					// with the current m_bSpecialText = TRUE colour (default is red)
					bTextTypeChanges = FALSE; // initialize

					if (wholeBeginMkr.Find(gSFescapechar) != wxNOT_FOUND)
					{
						wxString bareMkr = wholeBeginMkr.Mid(1); // remove initial backslash
						int length = wholeBeginMkr.Len();
						const wxChar* pChar2 = wholeBeginMkr.GetData();
						wxChar* pBufStart = (wxChar*)pChar2; // LHS is non-constant

						// in the next call NULL is returned if bareMkr is an unknown marker
						USFMAnalysis* pUsfmAnalysis = LookupSFM(bareMkr);
						// the AnalyseMarker() call looks up the characteristics of the marker
						// and assigns TextType, returns m_bSpecialText value, puts appropriate
						// text into the m_inform member, deals appropriately with
						// pUsfmAnalysis being NULL (returns TRUE, and TextType noType is
						// assigned and m_inform gets the marker bracketted with ? and ? before
						// and after) etc
						// BEW 24Oct14, no change to AnalyseMarker() is needed for support of
						// UFSM nested markers, because the above LookupSFM() works for them
						// too, and returns the pUsfmAnalysis for the associated non-nested
						// marker, and that is what is passed in here
						// BEW 30Sep19 refactoring for USFM3.0, I want \fig unfiltered to be
						// shown in red (m_bSpecialText TRUE), so a couple of the old \\fig 
						// config values need updating - 'special' & 'inform' reset as TRUE
						// etc, so I've added update code in LookupSFM()'s three variants to
						// fix this 
						if (pUsfmAnalysis != NULL)
						{
							// It's a marker which is not unknown, i.e. pUsfmAnalysis points to its struct

							// check for a poetry marker, set the bContainsPoetryMarker flag if we find one
							bool bContainsPoetryMarker = FALSE;
							if (pApp->m_poetryMkrs.Find(augWholeBeginMkr) != wxNOT_FOUND)
							{
								// wholeBeginMkr is a poetry marker (\v may follow, so use the flag
								// later to prevent poetry TextType from being overridden by verse)
								bContainsPoetryMarker = TRUE;
								bContainsPoetryMarker = bContainsPoetryMarker; // avoid gcc warning set but not used warning
							}
							// Analyse the wholeBeginMkr itself, using its short data buffer.
							// Internally it will set pSrcPhrase->m_curTextType if appropriate,
							// for example, to enum value 'verse', but if bContainsPoetryMarker is TRUE,
							// the test just below will override 'verse' with 'poetry'
#if defined (_DEBUG) && !defined(NOLOGS)
							wxLogDebug(_T("TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d, has poetryMkr %d"),
								__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText,
								(int)pSrcPhrase->m_curTextType, (int)bContainsPoetryMarker);
							if (pSrcPhrase->m_nSequNumber >= 1)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
#endif
							pSrcPhrase->m_bSpecialText = AnalyseMarker(pSrcPhrase, pLastSrcPhrase, pBufStart, length, pUsfmAnalysis);
						}
						else
						{
							// UsfmAnalysis is NULL, so if it's a marker, it's unkown type, so dont change textType
							bIsUnknownMkr = TRUE;
						}
					} // end of TRUE block for test: if (wholeBeginMkr.Find(gSFescapechar) != wxNOT_FOUND)
					else if (!strLastEndMkr.IsEmpty())
					{
						int length = strLastEndMkr.Len();
						const wxChar* pChar2 = strLastEndMkr.GetData();
						wxChar* pBufStart = (wxChar*)pChar2; // LHS is non-constant
						wxString wholeEndMkr = wxEmptyString; // init
#if defined (_DEBUG) && !defined(NOLOGS)
						wxString atBuffStart = wxString(pBufStart, length - 2);
						wxLogDebug(_T("TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d , atPtr= [%s]"),
							__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText,
							(int)pSrcPhrase->m_curTextType, atBuffStart.c_str());
						if (pSrcPhrase->m_nSequNumber >= 1)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
#endif
						if (*pBufStart == gSFescapechar)
						{
							wholeEndMkr = wxString(pBufStart, length);
							bool bIsFootnoteEnd = FALSE; // init
							if (!wholeEndMkr.IsEmpty())
							{
								wxString theMkrs;
								theMkrs = pSrcPhrase->GetEndMarkers();
								int offset = wxNOT_FOUND; // init
								wxString fnEndStr = _T("\\f*");
								offset = theMkrs.Find(fnEndStr);
								if (offset >= 0)
								{
									// Found \f* in pSrcPhrase->m_endMarkers
									bIsFootnoteEnd = TRUE;
								}
							}
							if (bIsFootnoteEnd)
							{
								pSrcPhrase->m_inform = _("end fn"); // localizable
								pSrcPhrase->m_bFootnoteEnd = TRUE;
								m_bIsWithinUnfilteredInlineSpan = FALSE; // BEW 14Dec22 added
							}

						} // end of TRUE block for test: if (pUsfmAnalysis != NULL)
					} // end of TRUE block for test: if (!strLastEndMkr.IsEmpty())

				} // end of TRUE block for test: if (wholeBeginMkr.Find(gSFescapechar) != wxNOT_FOUND)

			} // end of TRUE block for test: if (!wholeBeginMkr.IsEmpty() && !bEndedffexspanUsedToChangedTextType)
#if defined (_DEBUG) && !defined(NOLOGS)
			wxString atPtr = wxString(ptr, 16);
			wxLogDebug(_T("TokenizeText(), line %d , sn= %d , atPtr= [%s] , m_bSpecialText = %d , m_curTextType = %d"),
				__LINE__, pSrcPhrase->m_nSequNumber, atPtr.c_str(), (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType);
			if (pSrcPhrase->m_nSequNumber >= 1)
			{
				int halt_here = 1; wxUnusedVar(halt_here);
			}
#endif
			// m_bFootnote is set TRUE only on the first pSrcPhrase of the footnote span
			//if (m_bIsWithinUnfilteredInlineSpan && pSrcPhrase->m_bFootnote == TRUE) <<-- incorrect test (I think)
			if (pSrcPhrase->m_bFootnote == TRUE)
			{
#if defined (_DEBUG) && !defined (NOLOGS)
				{
					wxString strPointAt = wxString(ptr, 12);
					wxLogDebug(_T("TokTxt() line  %d , m_bIsWithinUnfilteredInlineSpan = %d , bSuppressBackwardSearchForWordBreakChar = %d , bContinueTwice = %d , strPointAt= [%s] "),
						__LINE__, (int)m_bIsWithinUnfilteredInlineSpan, (int)bSuppressBackwardSearchForWordBreakChar, (int)bContinueTwice, strPointAt.c_str());
					if (pSrcPhrase->m_nSequNumber >= 1)
					{
						int halt_here; wxUnusedVar(halt_here);
					}
				}
#endif
				// The current pSrcPhrase is the start of a footnote span, so set appropriate values
				pSrcPhrase->m_bSpecialText = TRUE;
				pSrcPhrase->m_curTextType = footnote;
				pSrcPhrase->m_bFirstOfType = TRUE;
				pSrcPhrase->m_bBoundary = TRUE;
				pSrcPhrase->m_inform = _("footnote"); // localizable

				bTextTypeChanges = TRUE; // BEW 14Dec22 added
				m_bIsWithinUnfilteredInlineSpan = TRUE; // BEW 14Dec22 added
				//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d  in block: pSrcPhrase->m_bFootnote == TRUE"),
				//	__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
			}
			else
			{

				// BEW 3Nov22, the legacy propagation code...  This will use pSrcPhrase and pLastSrcPhrase
				// implement the decisions regarding propagation made above...
				bool bTextTypeChangeBlockEntered = FALSE;
#if defined (_DEBUG) && !defined(NOLOGS)
				wxString atPtr = wxString(ptr, 16);
				wxLogDebug(_T("TokText() LEGACY Propg'n STARTS, line %d , sn= %d , atPtr= [%s] , m_bSpecialText = %d , m_curTextType = %d  in else at 21622"),
					__LINE__, pSrcPhrase->m_nSequNumber, atPtr.c_str(), (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType);
				if (pSrcPhrase->m_nSequNumber >= 1)
				{
					int halt_here = 1; wxUnusedVar(halt_here);
				}
#endif
				if (pLastSrcPhrase != NULL)
				{
//					wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

					// propagate or change the TextType and m_bSpecialText
					if (bTextTypeChanges)
					{
						// text type and specialText value are set above, so this block won't
						// change the value established above shortly after the ParseWord() call
						// returns; & we must restore the default value for the flag
						//bTextTypeChanges = FALSE;
						bTextTypeChangeBlockEntered = TRUE; // BEW 3Jul23 earlier, to start a footnote span
					}
					// BEW 24Oct14, next call supports USFM nested markers
					else
					{
#if defined (_DEBUG) && !defined(NOLOGS)
						wxLogDebug(_T("TokText() Calling IsTextTypeChangingEndMarker(pLastSrcPhrase), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d"),
							__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType);
						if (pSrcPhrase->m_nSequNumber >= 1)
						{
							int halt_here = 1; wxUnusedVar(halt_here);
						}
#endif
						wxString typeChangingEndMkr;
						typeChangingEndMkr = wxEmptyString; // init
						bool bIsChanger;
						bIsChanger = IsTextTypeChangingEndMarker(pLastSrcPhrase, typeChangingEndMkr); // BEW 14Dec22, use
								// pLastSrcPhrase because internally fast access strings are tested, and
								// it pLastSrcPhrase has things like \f* \fe* \x* or \ex*, then
								// fast access strings are tested, and if the relevant endMkr is found
								// TRUE will be returned, and m_bIsWithinUnfilteredInlineSpan cleared to FALSE

						if (bIsChanger == FALSE)
						{
							// If pSrcPhrase is carrying filtered info, use that as a flag to reconstitue verse TextType
							if (!(pSrcPhrase->GetFilteredInfo()).IsEmpty())
							{
								wxString filteredInfo;
								filteredInfo = pSrcPhrase->GetFilteredInfo();
								wxString bkSlashr;
								bkSlashr = _T("\\r");
								if (filteredInfo.Find(bkSlashr) != wxNOT_FOUND)
								{
									bIsChanger = TRUE;
								}
							}
							else
							{
								// other criteria for switching the textType.

#if defined (_DEBUG) && !defined(NOLOGS)
								wxString atPtr = wxString(ptr, 16);
								wxLogDebug(_T("TokenizeText(), line %d , sn= %d , atPtr= [%s] , m_bSpecialText = %d , m_curTextType = %d"),
									__LINE__, pSrcPhrase->m_nSequNumber, atPtr.c_str(), (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType);
								if (pSrcPhrase->m_nSequNumber >= 1)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
#endif
								// BEW 5Jul23, a common thing in source data is that in a succession of blue text words, 
								// (m_specialText is false & verse or poetry is textType), we come to a need to change
								// to Red text, such as when encountering a subheading (in the m_RedBeginMarkers set),
								// or to a \r reference, like "\\r (Luk 2:1-7)" followed by whitespace character, or
								// others of the (large) red beginMarkers fast-access set. We've no processing block yet 
								// for dealing with these possibilities. Do it here.
								// And since we need to check pLastSrcPhrase, don't do anything here if sequNum is 0,
								// because when that is the current pSrcPhrase, pLastSrcPhrase is NULL. Note,
								// we are here dealing with beginMkrs, which start off a colour change from blue to red. 
								int offset; offset = wxNOT_FOUND; // init
								offset = offset; // avoid gcc warning set but not used warning
								wxString bareMkr;
								if (pLastSrcPhrase != NULL)
								{
									// On the current pSrcPhrase instance, changing special to FALSE, or not special to 
									// special = TRUE, is governed by what's in pSrcPhrase's m_markers - and in particular
									// what's the last marker in m_markers if there is more than one. If m_markers is
									// empty, then no change of textType and colouring is possible, in that case, skip
									// BEW added Trim(FALSE) at Bill's suggestion in case m_markers has only a space
									pSrcPhrase->m_markers.Trim(FALSE);
									if (!pSrcPhrase->m_markers.IsEmpty())
									{
										wxString wholeMkr;
										int wholeMkrLen;
										//wholeMkr = GetLastBeginMkr(pSrcPhrase->m_markers); // BEW 31Aug23, Bill wants firstMkr to be used
										wholeMkr = GetPriorityBeginMkr(pSrcPhrase->m_markers); // BEW 31Aug23, reinstated; gets first in m_markers

										wxASSERT(!wholeMkr.IsEmpty() && wholeMkr.GetChar(0) == gSFescapechar);
										wholeMkrLen = wholeMkr.Length();

										if (pLastSrcPhrase->m_bSpecialText == FALSE)
										{
											// pLastSrcPhrase has blue text, textType verse				
											bareMkr = wholeMkr.Mid(1); // remove initial backslash
											USFMAnalysis* pUsfmAnalysis;
											pUsfmAnalysis = LookupSFM(bareMkr);
											if (pUsfmAnalysis != NULL)
											{
												// The beginMkr is a known marker in the m_RedBeginMarkers set
#if defined (_DEBUG) && !defined(NOLOGS)
												wxString atPtr = wxString(ptr, 16);
												wxLogDebug(_T("TokText(), line %d , sn= %d , atPtr= [%s] , m_bSpecialText = %d , m_curTextType = %d , wholeMkr= [%s]"), __LINE__,
													 pSrcPhrase->m_nSequNumber, atPtr.c_str(), (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, wholeMkr.c_str());
												if (pSrcPhrase->m_nSequNumber >= 4)
												{
													int halt_here = 1; wxUnusedVar(halt_here);
												}
#endif
												// BEW 1Sep23 error, can't use ptr in the AnalyseMarker call, ptr points to <sp>word... lots of stuff
												// and so the call crashes. The buffer we are working with is a tiny one, for "\\li" its just 3 characters,
												// - the wholeMkr buffer, so change ptr to be address-of-wholeMkr.GetChar(0) i.e. the backslash of \li
												// whm 5Sep2023 changed the next three lines which produced a bad pointer pFirstChar.
												//wxChar chFirst; wxChar* pFirstChar;
												//chFirst = wholeMkr[0].GetValue();
												//pFirstChar = &chFirst;
												const wxChar* pFirstChar = wholeMkr.GetData();
												wxChar* pBufStart = (wxChar*)pFirstChar;
												pSrcPhrase->m_bSpecialText = AnalyseMarker(pSrcPhrase, pLastSrcPhrase, pBufStart, wholeMkrLen, pUsfmAnalysis);
												// Does the text type of 'special text' value change? If so set bTextTypeChanges to TRUE
												// (not sure if this test is necessary, but probably worth doing until found otherwise)
												if ((pLastSrcPhrase->m_curTextType != pSrcPhrase->m_curTextType) ||
													(pLastSrcPhrase->m_bSpecialText != pSrcPhrase->m_bSpecialText))
												{
													bTextTypeChanges = TRUE;
												}
											} // end of TRUE block for test: if (pUsfmAnalysis != NULL)
										}  // end of the TRUE block for test: if (bLastSrcPhrase->m_bSpecialText == FALSE)
										else
										{
											// bLastSrcPhrase->m_bSpecialText is TRUE, so we may be changing to FALSE and textType verse
											// whm 22Aug2023 note. In Nyindrou Matthew input during non-collab at sn="544" there is
											// in m_markers: "\\ch 1 \n\\ms " where the last marker is \ms and AnalyseMarker() above
											// correctly assigned pSrcPhrase->m_curTextType to sectionHead. However, the test below
											// detects that m_markers has a \ch marker within it and the test as is will incorrectly
											// change the pSrcPhrase->m_curTextType from sectionHead to pLastSrcPhrase->m_curTextType
											// which was noType which we don't want here. The test below needs to be modified or removed
											// altogether. I can change the test below to determine whether the current wholeMkr that is
											// being examined (\ms) comes after the \ch marker, and refrain from propagating the
											// pLastSrcPhrase->m_curTextType value over to pSrcPhrase.
											// The wholeMkr was determined by calling GetLastBeginMkr(pSrcPhrase->m_markers) within this
											// scope above, so we can use that variable to only propagate the values from pLastSrcPhrase
											// if the wholeMkr is located does not come after the \ch marker.
											int posLastBeginMkr = pSrcPhrase->m_markers.Find(wholeMkr);
											int posChMkr = pSrcPhrase->m_markers.Find(_T("\\c"));
											//if (!pSrcPhrase->m_markers.IsEmpty() && pSrcPhrase->m_markers.Find(_T("\\c")) != wxNOT_FOUND
											//	&& pLastSrcPhrase->m_bSpecialText)
											if (!pSrcPhrase->m_markers.IsEmpty() && posChMkr != wxNOT_FOUND && !(posLastBeginMkr > posChMkr)
												&& pLastSrcPhrase->m_bSpecialText)
											{
												// Don't let a \c marker stop propagation of previous special text and textType other than verse
												pSrcPhrase->m_bSpecialText = pLastSrcPhrase->m_bSpecialText;
												pSrcPhrase->m_curTextType = pLastSrcPhrase->m_curTextType;
											}
											else
											{
												// Check if we are changing back to textType verse, and m_bSpecialText = FALSE
												bareMkr = wholeMkr.Mid(1); // remove initial backslash
												USFMAnalysis* pUsfmAnalysis;
												pUsfmAnalysis = LookupSFM(bareMkr);
												if (pUsfmAnalysis != NULL)
												{
													// The beginMkr is a known marker in the m_RedBeginMarkers set
													pSrcPhrase->m_bSpecialText = AnalyseMarker(pSrcPhrase, pLastSrcPhrase, pBufStart, wholeMkrLen, pUsfmAnalysis);
													// Does the text type of 'special text' value change? If so set bTextTypeChanges to TRUE
													// (not sure if this test is necessary, but probably worth doing until found otherwise)
													if ((pLastSrcPhrase->m_curTextType != pSrcPhrase->m_curTextType) ||
														(pLastSrcPhrase->m_bSpecialText != pSrcPhrase->m_bSpecialText))
													{
														bTextTypeChanges = TRUE;
													}
												}
											}
										} // end of the else block for test: if (bLastSrcPhrase->m_bSpecialText == FALSE)

									} // end of the TRUE block for test: if (!pSrcPhrase->m_markers.IsEmpty())
									else
									{
										// When pSrcPhrase->m_markers is empty, the pLastSrcPhrase values must propagate,
										// whether blue or red
										pSrcPhrase->m_bSpecialText = pLastSrcPhrase->m_bSpecialText;
										pSrcPhrase->m_curTextType = pLastSrcPhrase->m_curTextType;

									} // of the else block for test: if (!pSrcPhrase->m_markers.IsEmpty())

								} //  end of TRUE block for test: if (pLastSrcPhrase != NULL)

							} // end of else block for test: if (!(pSrcPhrase->GetFilteredInfo()).IsEmpty())
						} // end of TRUE block for test: if (bIsChanger == FALSE)

#if defined (_DEBUG) && !defined(NOLOGS)
						{
							wxString atPtr = wxString(ptr, 15);
							wxLogDebug(_T("TokText() before: if (bIsChanger ..., line %d , sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = [%s] , bIsChanger = %d , atPtr= [%s]"),
								__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText,
								(int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str(), (int)bIsChanger, atPtr.c_str());
							if (pSrcPhrase->m_nSequNumber >= 1)
							{
								int halt_here = 1;
							}
						}
#endif	
						bool bIsFootnoteEnd = FALSE; // init
						bool bSetFromLastSPhr; // BEW added 30May23
						bSetFromLastSPhr = FALSE; // init
						// BEW 28Jun23, add a test to set bSetFromLastSPhr TRUE if change block was entered
						if (bTextTypeChangeBlockEntered == TRUE)
						{
							bSetFromLastSPhr = TRUE;
						}
						// BEW 3Jul23 added !typeChangingEndMkr.IsEmpty(), as it indicates one of the 5 spans
						// is to be ending properly in this block
						if ((bIsChanger && !typeChangingEndMkr.IsEmpty()) || bIsFootnoteEnd)
						{
#if defined (_DEBUG) && !defined(NOLOGS)
							wxLogDebug(_T("TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d"),
								__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType);
							if (pSrcPhrase->m_nSequNumber >= 2)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
#endif
							// the test is TRUE if pSrcPhase in its m_endMarkers member contains one
							// or \f* \ef* \fe* \x* or \ex*; we set the bEnded_f_fe_x_span flag here only,
							// because it is the next word to be parsed that actually has the changed
							// TextType value etc - the TRUE value of the flag is detected above after
							// ParseWord() returns, and causes default to verse TextType and
							// m_bSpecialText FALSE - and subsequent code then may change it if
							// necessary.
							// BEW 24Oct14, if the endmarker is a nested one, it will not change
							// the text type, so internally test for + after backslash and if exists
							// then return FALSE
							bEnded_f_fe_x_span = TRUE; // <<-- the only place it is set TRUE
							// propagation from pLastSrcPhrase to pSrcPhrase is required here, because
							// this one's TextType isn't changed

							// BEW 3Feb23, m_markers may have \io1 marker when intro material is being processed.
							// we don't want the code below to cause reversion to verse and m_bSpecialText set FALSE.
							// Set a bool here to be used to skip reverting to verse, etc, in such a context
							bool bSkipRedPropagation;
							bSkipRedPropagation = FALSE; // initialise
							if (!pSrcPhrase->m_markers.IsEmpty())
							{
								wxString srch;
								srch = _T("\\io1");
								int offset;
								offset = pSrcPhrase->m_markers.Find(srch);
								if (offset != wxNOT_FOUND)
								{
									// such a marker is present in m_markers, so do protection
									bSkipRedPropagation = TRUE;
								}
							}
							if (bSkipRedPropagation == FALSE)
							{
								pSrcPhrase->m_bSpecialText = pLastSrcPhrase->m_bSpecialText;
								pSrcPhrase->m_curTextType = pLastSrcPhrase->m_curTextType;
								bSetFromLastSPhr = TRUE;
							}
#if defined (_DEBUG) && !defined(NOLOGS)
							wxString atPtr = wxString(ptr, 16);
							wxLogDebug(_T("TokeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d , atPtr= [%s]"),
								__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText,
								(int)pSrcPhrase->m_curTextType, atPtr.c_str());
							if (pSrcPhrase->m_nSequNumber >= 1)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
#endif
							// BEW 14Dec22 moved the following from much earlier, where it never got called,
							// to here. I think the CSourcePhrase pointer to use is the current pSrcPhrase
							// if my grasp of the logic is correct - it should be the instance which
							// is after the previous which has all the parameters, from the call of
							// IsTextTypeChangingEndMarker() above
							if (bEnded_f_fe_x_span && bSkipRedPropagation == FALSE)
							{
#if defined (_DEBUG) && !defined(NOLOGS)
								wxLogDebug(_T("TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d"),
									__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType);
								if (pSrcPhrase->m_nSequNumber >= 1)
								{
									int halt_here = 1; wxUnusedVar(halt_here);
								}
#endif
								// this block re-establishes verse type, and m_bSpecialText FALSE, after a
								// footnote, endnote or crossReference has ended
								pSrcPhrase->m_curTextType = verse;
								pSrcPhrase->m_bSpecialText = FALSE;
								bEnded_f_fe_x_span = FALSE; // once the TRUE value is used, it must default
															// back to FALSE
								bTextTypeChanges = TRUE;
								pSrcPhrase->m_bFirstOfType = TRUE;
								bEndedffexspanUsedToChangedTextType = TRUE;
							}

							//							wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , after bEnded_f_fe_x_span used "),
							//								__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

														// Finally, we have to do one task which in the legacy parser was done in
														// AnalyseMarker(). If \f* is stored on pSrcPhrase, then we have to set
														// the flag m_bFootnoteEnd to TRUE (so that CPile::DrawNavTextInfoAndIcons(
														// wxDC* pDC) can add the "end fn" text to pSrcPhrase->m_inform, for
														// display in the nav text area of the view) -- note, \fe in m_endMarkers
														// can only be the PNG SFM 1998 footnote endmarker, not USFM endnote
														// beginmarker) likewise \F must be from the same 1998 set if found there
														//
														// BEW 3Mar15, refactored to have the "end fn" entered into the m_inform
														// member of this pSrcPhrase here, rather than by DrawNavTextInfoAndIcons()
														// because if the nav text is wiped and a doc redraw is not done (it can
														// happen) then the "end fn" disappears. Marking the end of the footnote
														// was requested by Wolfgang Stradner in 12 March 2009.

#if defined (_DEBUG) && !defined(NOLOGS)
							wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d  BEFORE \"end fn\" Block, bIsChanger = %d"),
								__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)bIsChanger); // whm 10Jul2023 added last param (int)bIsChanger)
							if (pSrcPhrase->m_nSequNumber >= 1)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
#endif
							// BEW 24Dec22 any punctuation chars following a \f* should be TextType verse
							// that is, blue colour (or whatever is the current setting for verse text); so
							// check for puncts after \f*, and have them coloured same as verse enum
							bIsFootnoteEnd = (pLastSrcPhrase->GetEndMarkers().Find(_T("\\f*")) != wxNOT_FOUND) ? TRUE : FALSE;

							if (bIsFootnoteEnd ||
								(pLastSrcPhrase->GetEndMarkers().Find(_T("\\ef*")) != wxNOT_FOUND) ||
								(pLastSrcPhrase->GetEndMarkers().Find(_T("\\fe*")) != wxNOT_FOUND) ||
								(pLastSrcPhrase->GetEndMarkers().Find(_T("\\x*")) != wxNOT_FOUND) ||
								(pLastSrcPhrase->GetEndMarkers().Find(_T("\\ex*")) != wxNOT_FOUND))
							{
								if (bIsFootnoteEnd)
								{

									pLastSrcPhrase->m_bFootnoteEnd = TRUE;
									// Note: it's localizable if somebody wants to bother
									pLastSrcPhrase->m_inform = _("end fn"); // there won't be anything else in m_inform
																		// at the end of the footnote, so no need to append
									pLastSrcPhrase->m_bBoundary = TRUE;

									m_bIsWithinUnfilteredInlineSpan = FALSE;
									pSrcPhrase->m_bFirstOfType = TRUE;
									pSrcPhrase->m_curTextType = verse;
									pSrcPhrase->m_bSpecialText = FALSE;

									bSetFromLastSPhr = TRUE;
#if defined (_DEBUG) && !defined(NOLOGS)
									wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , AFTER footnote end,  setting correct values, bIsChanger = %d"),
										__LINE__, pSrcPhrase->m_nSequNumber, (int)bIsChanger);
									if (pSrcPhrase->m_nSequNumber >= 1)
									{
										int halt_here = 1; wxUnusedVar(halt_here);
									}
#endif
								} // end of the TRUE block for ending a footnote span
								else
								{
									// Handle the other four possibilities
									if (pLastSrcPhrase->GetEndMarkers().Find(_T("\\ef*")) != wxNOT_FOUND)
									{
										pLastSrcPhrase->m_inform = _("end note");
										pLastSrcPhrase->m_bBoundary = TRUE;
										m_bIsWithinUnfilteredInlineSpan = FALSE;
										pSrcPhrase->m_bFirstOfType = TRUE;
										pSrcPhrase->m_curTextType = verse;
										pSrcPhrase->m_bSpecialText = FALSE;
										bSetFromLastSPhr = TRUE;
									}
									else if (pLastSrcPhrase->GetEndMarkers().Find(_T("\\fe*")) != wxNOT_FOUND)
									{
										pLastSrcPhrase->m_bFootnoteEnd = TRUE;
										pLastSrcPhrase->m_inform = _("end endnote");
										pLastSrcPhrase->m_bBoundary = TRUE;
										m_bIsWithinUnfilteredInlineSpan = FALSE;
										pSrcPhrase->m_bFirstOfType = TRUE;
										pSrcPhrase->m_curTextType = verse;
										pSrcPhrase->m_bSpecialText = FALSE;
										bSetFromLastSPhr = TRUE;
									}
									else if (pLastSrcPhrase->GetEndMarkers().Find(_T("\\x*")) != wxNOT_FOUND)
									{
										pLastSrcPhrase->m_inform = _("end crossReference");
										pLastSrcPhrase->m_bBoundary = TRUE;
										m_bIsWithinUnfilteredInlineSpan = FALSE;
										pSrcPhrase->m_bFirstOfType = TRUE;
										pSrcPhrase->m_curTextType = verse;
										pSrcPhrase->m_bSpecialText = FALSE;
										bSetFromLastSPhr = TRUE;
									}
									else if (pLastSrcPhrase->GetEndMarkers().Find(_T("\\ex*")) != wxNOT_FOUND)
									{
										pLastSrcPhrase->m_inform = _("end ext xref note");
										pLastSrcPhrase->m_bBoundary = TRUE;
										m_bIsWithinUnfilteredInlineSpan = FALSE;
										pSrcPhrase->m_bFirstOfType = TRUE;
										pSrcPhrase->m_curTextType = verse;
										pSrcPhrase->m_bSpecialText = FALSE;
										bSetFromLastSPhr = TRUE;
									}
								}  // end of the else block for ending a footnote span
							} // end of the TRUE block for ending 5 types of spans
						} // end of the TRUE block for test: 
						  // if ( (bIsChanger && !typeChangingEndMkr.IsEmpty()) || bIsFootnoteEnd)
						else
						{
							// don't propagate values from pLastSrcPhrase if the TRUE block for
							// bTextTypeChanges was entered - when that block is entered, a new
							// TextType and possibly a change of m_bSpecialText value is commencing
							// and we don't want the new values wiped out here by overwriting with
							// those from pLastSrcPhrase
							if (bTextTypeChangeBlockEntered && !bSetFromLastSPhr)
							{
								pSrcPhrase->m_bSpecialText = pLastSrcPhrase->m_bSpecialText;
								pSrcPhrase->m_curTextType = pLastSrcPhrase->m_curTextType;
							}
#if defined (_DEBUG) && !defined(NOLOGS)
							wxString atPtr = wxString(ptr, 16);
							wxLogDebug(_T("TokText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d , m_bSpecialText = %d , m_curTextType = %d , atPtr= [%s]"),
								__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan, (int)pSrcPhrase->m_bSpecialText,
								(int)pSrcPhrase->m_curTextType, atPtr.c_str());
							if (pSrcPhrase->m_nSequNumber >= 1)
							{
								int halt_here = 1; wxUnusedVar(halt_here);
							}
#endif
						} // end of the else block for test: if ( (bIsChanger && !typeChangingEndMkr.IsEmpty()) || bIsFootnoteEnd)

					}  // end of the else block for test: if (bTextTypeChanges)

					//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"),
					//	__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

				} // end of TRUE block (4 tabs) for test: if (pLastSrcPhrase != NULL) -- correct

			} // end of else block for test: if (pSrcPhrase->m_bFootnote == TRUE)

			// ************ New Propagation Code Ends Here ******************

			// BEW added 30May05, to remove any initial space that may be in m_markers
			// from the parse
			// whm 9Jun12 in wxWidgets 2.9.3 if GetChar(0) is called on an empty m_markers
			// string there is a debug assert generated from c:\Program Files\Microsoft Visual
			// Studio 9.0\VC\include\xstring. I've eleminated the unnecessary if () part and
			// just call the pSrcPhrase->m_markers.Trim(FALSE) statement
			//if (pSrcPhrase->m_markers.GetChar(0) == _T(' '))
			pSrcPhrase->m_markers.Trim(FALSE);

			// BEW Nov 2016  ParseWord2() now does it internally - a more natural place
			// BEW 11Oct10, Handle setting of the m_bBoundary flag here, rather than in
			// ParseWord() itself
			if (!pSrcPhrase->m_follPunct.IsEmpty() ||
				!pSrcPhrase->GetFollowingOuterPunct().IsEmpty())
			{
				wxChar anyChar;
				if (!pSrcPhrase->m_follPunct.IsEmpty())
				{
					anyChar = pSrcPhrase->m_follPunct[0]; // any char of punct will do
					if (boundarySet.Find(anyChar) != wxNOT_FOUND)
					{
						// we found a non-comma final punctuation character on this word, so we
						// have to set a boundary here
						pSrcPhrase->m_bBoundary = TRUE;
						// if this pSrcPhrase stores a conjoined word pair using USFM fixed
						// space symbol ~ then the boundary flag on the last child in the
						// m_pSavedWords member also needs to be set
						/* BEW 17Jul23 we no longer support the legacy way of fixed space supporting code
						if (IsFixedSpaceSymbolWithin(pSrcPhrase) )
						{
							SPList::Node* pos_pSavedWords = pSrcPhrase->m_pSavedWords->GetLast();
							CSourcePhrase* pWord2 = pos_pSavedWords->GetData();
							pWord2->m_bBoundary = TRUE;
						}
						*/
					}
				}
				//				wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

				if (!pSrcPhrase->GetFollowingOuterPunct().IsEmpty())
				{
					anyChar = (pSrcPhrase->GetFollowingOuterPunct())[0];
					if (boundarySet.Find(anyChar) != wxNOT_FOUND)
					{
						// we found a non-comma final punctuation character on this word, so we
						// have to set a boundary here
						pSrcPhrase->m_bBoundary = TRUE;
						// if this pSrcPhrase stores a conjoined word pair using USFM fixed
						// space symbol ~ then the boundary flag on the last child in the
						// m_pSavedWords member also needs to be set
						/* BEW 17Jul23 we no longer support the legacy way of fixed space supporting code
						if (IsFixedSpaceSymbolWithin(pSrcPhrase) )
						{
							SPList::Node* pos_pSavedWords = pSrcPhrase->m_pSavedWords->GetLast();
							CSourcePhrase* pWord2 = pos_pSavedWords->GetData();
							pWord2->m_bBoundary = TRUE;
						}
						*/
					}
				}
			}

			// get rid of any final spaces which make it through the parse -- shouldn't be any
			// now, but no harm in doing the check etc
			pSrcPhrase->m_follPunct.Trim(TRUE); // trim right end
			pSrcPhrase->m_follPunct.Trim(FALSE); // trim left end

			// BEW 11Oct10, do trim for the new m_follOuterPunct member
			wxString follOuterPunct = pSrcPhrase->GetFollowingOuterPunct();
			if (!follOuterPunct.IsEmpty())
			{
				follOuterPunct.Trim(TRUE); // trim right end
				follOuterPunct.Trim(FALSE); // trim left end
				pSrcPhrase->SetFollowingOuterPunct(follOuterPunct);
			}
#if defined (_DEBUG) && !defined(NOLOGS)
			{
				ptrPointsAt = wxString(ptr, 16);
				wxLogDebug(_T("TokText(), line %d , sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = %s , atPtr= [%s]"), __LINE__,
					(int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str(), ptrPointsAt.c_str());
				if (pSrcPhrase->m_nSequNumber >= 1)
				{
					int halt_here = 1;
				}
			}
#endif			

			// BEW 28May17 refactored the rest of the code in this block, because it was
			// causing a crash due to pSrcPhrase being deleted herein at sequ number zero
			//
			// BEW added comment 11Oct10, the comment below was for the legacy parser, but it
			// is still apt if the new ParseWord() returns leaving some punctuation at the end
			// of the buffer - unlikely, but we can't rule it out. So keep this stuff.
			//
			// If endmarkers are at the end of the buffer, code further up will have put them
			// into the m_endMarkers member of pLastSrcPhrase, and any punctuation following
			// that would be in the m_precPunt member of pSrcPhrase, but if the buffer end has
			// been reached, m_key in pSrcPhrase will be empty. So, providing m_precPunct is
			// empty, pSrcPhrase is not a valid CSourcePhrase instance. We need to check and
			// remove it.
			bool bPrecedingPunctIsEmpty;
			bPrecedingPunctIsEmpty = pSrcPhrase->m_precPunct.IsEmpty();
			bool bHasNonEndMarkers;
			bHasNonEndMarkers = !pSrcPhrase->m_markers.IsEmpty();
			wxString someFilteredInfo;
			someFilteredInfo = pSrcPhrase->GetFilteredInfo(); // could be empty
			bool bHasFilteredInfo;
			bHasFilteredInfo = !someFilteredInfo.IsEmpty();

			/*
			// whm 12Jan2024 removed the following two if tests below entirely. 
			// I'm removing the following test since it removes a perfectly valid pSrcPhrase
			// that has an empty m_key member because it got here after being created as an
			// empty marker. As an empty marker it also would mainly have the marker within
			// its m_markers member. The test below ends up calling DeleteSingleSrcPhrase()
			// on such pSrcPhrase.
			//
			// TODO: BEW will need to fix the test block below if commenting it out breaks
			// something in the free translation mode or some other situation.
			//
			//if (pSrcPhrase->m_key.IsEmpty() && bPrecedingPunctIsEmpty)
			if (pSrcPhrase->m_key.IsEmpty() && bPrecedingPunctIsEmpty && !bHasNonEndMarkers)
			{
				if ((ptr >= pEnd))
				{
					DeleteSingleSrcPhrase(pSrcPhrase, FALSE); // FALSE means 'don't try to
															  // delete a partner pile'
					pSrcPhrase = NULL;
					break;
				}
			}
			*/

			/*
			// whm 12Jan2024 removed the if test below entirely. 
			// I'm removing the following test since it removes a perfectly valid pSrcPhrase
			// that has an empty m_key member because it got here after being created as an
			// empty marker. As an empty marker it also would mainly have the marker within
			// its m_markers member. The test below ends up calling DeleteSingleSrcPhrase()
			// on such pSrcPhrase.
			//
			// TODO: BEW will need to fix the test block below if commenting it out breaks
			// something in the free translation mode or some other situation.
			//
			// But a complication is the possibility of filtered information at the end of the
			// parse buffer - it would be in the m_filteredInfo member. Our solution for this
			// complication is: don't remove the pSrcPhrase here - so if parsing a source text
			// file, the widow CSourcePhrase will just remain at the document end but be
			// unseen, while if we are parsing just-edited source text in OnEditSourceText(),
			// we can leave the widow there after moving endmarkers off it, because
			// OnEditSourceText() will later call
			// TransportWidowedFilteredInfoToFollowingContext() and if there is a following
			// context, the transfer can be done, but if not, we must just leave the source
			// phrase there in the document to carry the filtered information.
			//
			// A further complication of similar kind is when the user types in non-endmarker
			// information at the end of the string. When editing the source text, this will
			// end up in m_markers but m_key will be empty, and so we need to leave it to
			// TransportWidowedFilteredInfoToFollowingContext() to handle transfer of this
			// information to the following context, or if there is no following context, in
			// this case we abandon the marker info typed because it would make no sense to
			// keep it - that's what to do whether we are at the document end when parsing in a
			// new source text USFM text file, or when editing source text - the
			// gbVerticalEditInProgress global boolean can help in testing for this.
			if (pSrcPhrase->m_key.IsEmpty() && bPrecedingPunctIsEmpty)
			{
				if ((!bHasFilteredInfo && !bHasNonEndMarkers) ||
					(!bHasFilteredInfo && bHasNonEndMarkers && !gbVerticalEditInProgress))
				{
					CSourcePhrase* pWord2;
					SPList::Node* pos_pSavedWords;
					if (bFreeTranslationIsCurrent)
					{
						// we default to always turning off a free translation section at the end
						// of the document if it hasn't been done already
						if (pLastSrcPhrase != NULL)
						{
							if (pLastSrcPhrase->m_bEndFreeTrans == FALSE)
							{
								pLastSrcPhrase->m_bEndFreeTrans = TRUE;

								// BEW 11Oct10, and for ~ fixedspace support, set the same flag in
								// the last child instance
								if (IsFixedSpaceSymbolWithin(pLastSrcPhrase))
								{
									pos_pSavedWords = pLastSrcPhrase->m_pSavedWords->GetLast();
									pWord2 = pos_pSavedWords->GetData();
									pWord2->m_bEndFreeTrans = TRUE;
								}
								break;
							}
						}
					}
					else
					{
						// remove it if it is not a carrier for filtered information in its
						// m_filteredInfo member (see the more detailed explanation above) nor
						// non-endmarkers information in its m_markers member; OR, it has no
						// filtered information but it does have non-endmarkers in m_markers
						// but vertical edit (ie. we aren't in OnEditSourceText()) is not
						// current (ie. we are creating a document by parsing in a USFM plain
						// text file). The other possibilities can be left for
						// TransportWidowedFilteredInfoToFollowingContext() in
						// OnEditSourceText() to work out, and do deletion of of the carrier if
						// warranted.
						if (ptr >= pEnd)
						{
							DeleteSingleSrcPhrase(pSrcPhrase, FALSE); // FALSE means 'don't try to
																	  // delete a partner pile'
							pSrcPhrase = NULL;
							break;
						}
					}
				}
			} // end of TRUE block for test: if (pSrcPhrase->m_key.IsEmpty() && pSrcPhrase->m_precPunct.IsEmpty()) -- correct level, 3 tabs
			*/

		} // end of else block for text: if (bEmptyUSFM)

//backToVerse:  BEW 27Apr23 commented this out, as the goto for it is only one and in a section of old text now commented out (21,249 Doc.cpp)
		//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
#if defined (_DEBUG) && !defined(NOLOGS)
		wxString atPtr = wxString(ptr, 16);
		wxLogDebug(_T("TokenizeText(), line %d , sn= %d , APPENDING to pList , m_bSpecialText = %d , m_curTextType = %d , atPtr= [%s]"),
			__LINE__, pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, atPtr.c_str());
		if (pSrcPhrase->m_nSequNumber >= 1)
		{
			int halt_here = 1; wxUnusedVar(halt_here);
		}
#endif

		// store the pointer in the SPList (in order of occurrence in text)
		if (pSrcPhrase != NULL)
		{
			pList->Append(pSrcPhrase);

			// whm 17Jan2024 I'm commenting out the following code which is now 
			// redundant along with the purpose of having the bEmptyUSFM flag.
			// The tokBuffer is emptied in the if (bProcessingEmptyMarker) TRUE
			// block, and m_markers is also ensured to end with a space there.
			// whm 19Jan2024 reinstating code below until bEmptyUSFM flag is 
			// adequately deal with and removed.
			// whm TODO: rework flow control to be able to remove bEmptyUSFM flag
			// /*
			// BEW added 13Jul11, to support tokenizing contentless USFM from Paratext
			if (bEmptyUSFM)
			{
				tokBuffer.Empty();
				bEmptyUSFM = FALSE; // next verse may have content, so be ready
									// for that possibility
				// ensure there is always a final space at end of m_markers when parsing
				// contentless USFM data
				if (!pSrcPhrase->m_markers.IsEmpty() &&
					pSrcPhrase->m_markers.GetChar(pSrcPhrase->m_markers.Len() - 1) != _T(' '))
				{
					pSrcPhrase->m_markers += _T(' ');
				}
			}
			// */
		}
		// BEW 7Nov22, check that pSrcPhrase->m_scrPhrase is not empty, when m_key has content. Fix if so
		if (!pSrcPhrase->m_key.IsEmpty() && pSrcPhrase->m_srcPhrase.IsEmpty())
		{
			pSrcPhrase->m_srcPhrase = pSrcPhrase->m_key;
		}

		// make this one be the "last" one for next time through
		pLastSrcPhrase = pSrcPhrase; // note: pSrcPhrase might be NULL
		//wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"), __LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);
#if defined (_DEBUG) && !defined(NOLOGS)
		{
			ptrPointsAt = wxString(ptr, 15);
			wxLogDebug(_T("%s::%s(), line %d :@@@ ** pLastSrcPhrase now set **: sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = %s"), __FILE__, __FUNCTION__, __LINE__,
				(int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str());
			if (pSrcPhrase->m_nSequNumber >= 3)
			{
				int halt_here = 1;
			}
		}
#endif			

		// If logging is wanted, update with this entry
		// whm 6Apr2020 modified to use new doc creation logging routine
		// Calls to the LogDocCreationData() here use an input parameter composed of
		// a wxString containing the m_srcPhrase, m_nSequNumber, the chapter number, 
		// the verse number, since we are merely logging data for each source phrase/word
		// being parsed during document loading. 
		// If there is a parse failure, it happened after the last m_srcPhrase in
		// this file. The log file is stored in the folder _LOGS_EMAIL_REPORTS in work folder
		// if logging is turned ON
		if (pApp->m_bMakeDocCreationLogfile) // turn this ON in docPage of the Wizard or in GetSourceTextFromEditor dialog; it is OFF by default
		{
			if (pApp->m_bParsingSource) //if (pApp->m_bSetupDocCreationLogSucceeded && pApp->m_bParsingSource) // m_bSetupDocCreationLogSucceeded no longer used
			{
				wxString strLine = strLine.Format(_T("%s %d %s:%s"),
					pSrcPhrase->m_srcPhrase.c_str(), pSrcPhrase->m_nSequNumber, pApp->m_chapterNumber_for_ParsingSource.c_str(), pApp->m_verseNumber_for_ParsingSource.c_str());
				pApp->LogDocCreationData(strLine);
			}
		}

		// BEW added 31Oct16  If ptr has reached pEnd, we don't want to iterate and try
		// build another CSourcePhrase - so test and break out if so
		if (ptr >= pEnd)
		{
			break; // 13th (last) break in TokenizeText()
		}
#if defined (_DEBUG) && !defined(NOLOGS)
		ptrPointsAt = wxString(ptr, 16);
		wxLogDebug(_T("TokText(), line %d : while loop ENDS: sequNum = %d , m_bSpecialText = %d , m_curTextType = %d, m_key = %s , m_markers=%s, ptrPointsAt= [%s]"),
			__LINE__, (int)pSrcPhrase->m_nSequNumber, (int)pSrcPhrase->m_bSpecialText, (int)pSrcPhrase->m_curTextType, pSrcPhrase->m_key.c_str(),
			pSrcPhrase->m_markers.c_str(), ptrPointsAt.c_str());
		if (pSrcPhrase->m_nSequNumber >= 1)
		{
			int halt_here = 1; wxUnusedVar(halt_here);
		}
#endif
		//		wxLogDebug(_T(" TokenizeText(), line %d , sn= %d , m_bIsWithinUnfilteredInlineSpan = %d"),
		//			__LINE__, pSrcPhrase->m_nSequNumber, (int)m_bIsWithinUnfilteredInlineSpan);

	} // end of while (ptr < pEnd)
	
	// fix the sequence numbers, so that they are in sequence with no gaps, from the
	// beginning
	tokBuffer.Empty();
	// The next call does nothing if pList is empty
	AdjustSequNumbers(nStartingSequNum, pList);
	// There may be nothing in the list, check, and if so, return 0
	if (pList->IsEmpty())
		return 0;

	/*
	// ensure pSrcPhrase->m_srcPhrase has no trailing spaces (a few CR LFs at the end
	// of the plain text input file find their way into the trailing text of the last
	// pSrcPhrase's m_srcPhrase member - so easiest thing to do is just clobber them here
	SPList::Node* pos_pList = pList->GetLast();
	CSourcePhrase* pSrcPhraseVeryLast = NULL;
	pSrcPhraseVeryLast = pos_pList->GetData();
	// whm 12Jan2024 modification.
	// I observerd that the pSrcPhraseVeryLast could be undefined in some circumstances
	// so I'm protecting the code below against that possibility.
	// Since my refactoring stores filtered into on a previous source phrase and not on
	// a following source phrase as wes previously the case, I doubt there would ever
	// be any filtered info that needs to be cached and delayed to be put on an extra
	// source phrase at the end of the pList. But, still need to protect against accessing
	// an undefined or NULL pSrcPhraseVeryLast.
	if (pSrcPhraseVeryLast != NULL)
	{
		pSrcPhraseVeryLast->m_srcPhrase.Trim();

		// If delayed data-for-filtering is pending, create an empty CSourcePhrase on heap
		// and store it in its m_filteredInfo member, and append to pList after giving it
		// the correct sequence number
		CSourcePhrase* pDummyLastSrcPhrase = NULL;
		if (bDelayStoringFilteredInfo)
		{
			int sequNum = pSrcPhraseVeryLast->m_nSequNumber;
			pDummyLastSrcPhrase = new CSourcePhrase;
			wxASSERT(pDummyLastSrcPhrase != NULL);
			sequNum++;
			pDummyLastSrcPhrase->m_nSequNumber = sequNum;
			if (strCacheDelayedFilteredContent.IsEmpty())
			{
				delete pDummyLastSrcPhrase;
			}
			else
			{
				pDummyLastSrcPhrase->SetFilteredInfo(strCacheDelayedFilteredContent);
				pList->Append(pDummyLastSrcPhrase);
				wxString navText = _("Filtered Info Carrier");
				pDummyLastSrcPhrase->m_inform = navText;
				// Create a linked CPile ptr instance, and append to Layout's m_pileList
				CPile* pPile = pLayout->CreatePile(pDummyLastSrcPhrase);
				pLayout->GetPileList()->Append(pPile);
				// Note: Associating with a valid pPile means that CPile's test using
				// bool CPile::HasFilterMarker() - which tests for a non-empty
				// m_filteredInfo member, and also for a non-empty m_inform member
				// will cause a green wedge to be build in the nav text whiteboard area.
				// Though m_key and m_srcPhrase are empty, those cues should make it
				// clear to the user that that CSourcePhrase instance exists and carries
				// important information
			}

			bDelayStoringFilteredInfo = FALSE; // unnecessary, but harmless
		}
	}
	*/

	return pList->GetCount();
}
