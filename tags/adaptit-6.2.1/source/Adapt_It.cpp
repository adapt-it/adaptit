/////////////////////////////////////////////////////////////////////////////
/// \project		adaptit
/// \file			Adapt_It.cpp
/// \author			Bill Martin
/// \date_created	05 January 2004
/// \date_revised	29 April 2009
/// \copyright		2008 Bruce Waters, Bill Martin, SIL International
/// \license		The Common Public License or The GNU Lesser General Public
///                 License (see license directory)
/// \description This is the implementation file for the CAdapt_ItApp class and the
/// AIModalDialog class. The CAdapt_ItApp class initializes Adapt It's application and gets
/// it running. Most of Adapt It's global enums, structs and variables are declared either
/// as members of the CAdapt_ItApp class or in this source file's global space. The
/// AIModalDialog class provides Adapt It with a modal dialog base class which turns off
/// Idle and UIUpdate processing while the dialog is being shown. \derivation The
/// CAdapt_ItApp class is derived from wxApp, and inherits its support for the
/// document/view framework. The AIModalDialog class is derived from wxDialog.
/////////////////////////////////////////////////////////////////////////////


#if defined(__GNUG__) && !defined(__APPLE__) //The GNU C++ compiler defines this.
// Testing it is equivalent to testing (__GNUC__ && __cplusplus).
    #pragma implementation "Adapt_It.h"
#endif


// For compilers that support precompilation, includes "wx.h".
#include <wx/wxprec.h>

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
// Include your minimal set of headers here, or wx.h
#include <wx/wx.h>
#endif

// wxWidgets library includes
#include <wx/docview.h>	// includes wxWidgets doc/view framework
#include "Adapt_ItCanvas.h"
#include "Adapt_It_Resources.h"
#include <wx/snglinst.h> // for wxSingleInstanceChecker in OnInit
#include <wx/config.h> // for wxConfig in OnInit
#include <wx/fileconf.h> // for wxFileConfig in Oninit
#include <wx/datetime.h> // for wxDateTime in OnInit
#include <wx/filesys.h> // for wxFileName
#include <wx/utils.h> // for ::wxDirExists, ::wxSetWorkingDirectory, etc
#include <wx/textfile.h> // for wxTextFile
#include <wx/encconv.h> // for wxEncodingConverter
#include <wx/fontmap.h> // for wxFontMapper
#include <wx/printdlg.h> // for print data and page setup data
#include <wx/dir.h> // for wxDir
#include <wx/hashmap.h> // for equivalent to MFC's CMapStringToOb* pMap in DoKBIntegrityCheck()
#include <wx/datstrm.h> // for wxDataOutputStream() and wxDataInputStream()
#include <wx/wfstream.h> // for wxFileOutputStream() and wxFileInputStream()
#include <wx/txtstrm.h> // for wxTextOutputStream()
#include <wx/cmdline.h> // for wxCmdLineParser
#include <wx/wizard.h> // for wxWizard
#include <wx/fdrepdlg.h> // for wxFindReplaceDialog
#include <wx/fontenum.h> // for wxFontEnumerator
#include <wx/progdlg.h> // for wxProgressDialog
#include <wx/busyinfo.h>
#include <wx/propdlg.h> // for wxPropertySheetDialog
#include <wx/stdpaths.h> // for GetResourcesDir and GetLocalizedResourcesDir
#include <wx/tooltip.h>
#include <wx/process.h> // for wxProcess::Exists()
#include <wx/toolbar.h> // (to allow wxWidgets to select an appropriate toolbar class)
#include <wx/tbarbase.h> // (the base class)


// the next are for wxHtmlHelpController (wxWidgets chooses the appropriate help controller
// class)
#include <wx/filesys.h>
#include <wx/fs_arc.h>
#include <wx/html/helpctrl.h> //(wxHTML based help controller: wxHtmlHelpController)
#include <wx/cshelp.h> // for wxHelpControllerHelpProvider

#include <wx/html/htmlwin.h> // for display of the "Help for Administrators.htm" file from the Administrator menu

#include <wx/display.h> // for wxDisplay

#include <wx/dynlib.h> // for wxDynamicLibrary and ECDriver.dll on Windows
#include <wx/filepicker.h> // for wxDirPickerCtrl
#include <wx/log.h> // for wxLogStream
#include <wx/timer.h> // for wxTimer
#include <wx/tokenzr.h>
#include <wx/stockitem.h> // for ::wxGetStockLabel()

#ifdef __WXGTK__
#include <wx/dcps.h> // for wxPostScriptDC
#else
#include <wx/dcprint.h> // for wxPrinterDC
#endif

// The following include is Copyright (c) 2005 by Dan Moulding Dan Moulding and used
// under the LGPL. The vld.h header usage is described in an article on The Code
// Project called "Memory Leak Detection". It generates better memory leak detection
// reporting under Visual Studio.
//
// Note: The Visual Leak Detector (vld) and how it works are found at:
// http://www.codeproject.com/KB/applications/visualleakdetector.aspx
// Note: Downloads from codeproject.com now require you set up a user account with password.
// Its code is not compiled into the program in release versions, but vld.h need only be
// included when memory leaks are detected by the debugger's Output report, and it is not
// obvious what is the cause of the leak from the report.
//
// Steps I did to make this work with VC 8.0:
// 1. copied vld.h and vldapi.h to the Visual Studio's VC include folder at:
//    C:\Program Files\Microsoft Visual Studio 8\VC\include
// 2. copied vld.lib, vldmt.lib, and vldmtdll.lib to the Visual Studio's VC lib folder at:
//    C:\Program Files\Microsoft Visual Studio 8\VC\lib
// 3. Uncomment the #include "vld.h" at the end of this comment to include vld.h in
//    debug builds.
// 4. VLD in 2010 is better, much much faster, etc. http://vld.codeplex.com for the
// download, and documentation is at http://vld.codeplex.com/documentation
//
// If Visual Studio reports "memory leaks detected" and the source of leak is unclear,
// uncomment the following include, recompile, run and exit the program for a more
// detailed report of the memory leaks:
#ifdef __WXMSW__
//#include "vld.h"
#endif

// Other includes
#include "AIPrintout.h"
#include "Adapt_It.h"
#include "ReadOnlyProtection.h"
#include "MainFrm.h"
#include "Adapt_ItDoc.h"
#include "Adapt_ItView.h"
#include "AdaptitConstants.h"
#include "KB.h"
#include "helpers.h"
#include "CollabUtilities.h"
#include "FontPage.h"
#include "PhraseBox.h"
#include "LanguagesPage.h"
#include "UsfmFilterPage.h"
#include "PunctCorrespPage.h"
#include "CaseEquivPage.h"
#include "OpenExistingProjectDlg.h"
#include "ProjectPage.h"
#include "DocPage.h"
#include "scrollingwizard.h" // whm added 13Nov11 - needs to be included before "StartWorkingWizard.h" below
#include "StartWorkingWizard.h"
#include "TargetUnit.h"
#include "RefString.h"
#include "CCTabbedDialog.h"
#include "WhichFilesDlg.h" // renamed from original "RestoreKBDlg.h"
#include "SourcePhrase.h"
#include "Pile.h"
#include "TransformToGlossesDlg.h"
#include "EarlierTranslationDlg.h"
#include "Cell.h"
#include "WhichBook.h"
#include "BString.h"
#include "XML.h"
#include "NoteDlg.h"
#include "ViewFilteredMaterialDlg.h"
#include "WaitDlg.h"
#include "ConsistentChanger.h"
#include "ChooseLanguageDlg.h"
#include "Layout.h"
#include "AdminMoveOrCopy.h"
#include "FreeTrans.h"
#include "Notes.h"
#include "Retranslation.h"
#include "Placeholder.h"
#include "ExportFunctions.h"
//#include "Uuid_AI.h" // for testing, then comment out
#include "NavProtectNewDoc.h"
#include "AdminEditMenuProfile.h"
//#include "Usfm2Oxes.h" // BEW removed 15Jun11 until we support OXES
#include "CorGuess.h"
#include "SetupEditorCollaboration.h"
#include "GetSourceTextFromEditor.h"
#include "AssignLocationsForInputsAndOutputs.h"
#include "HtmlFileViewer.h"
#include "convauto.h"
#include "KBExportImportOptionsDlg.h"
#include "ClientServerConnection.h"

// wx docs say: "By default, the DDE implementation is used under Windows. DDE works within one computer only.
// If you want to use IPC between different workstations you should define wxUSE_DDE_FOR_IPC as 0 before
// including this header [<wx/ipc.h>]-- this will force using TCP/IP implementation even under Windows."
#ifdef useTCPbasedIPC
#define wxUSE_DDE_FOR_IPC 0
#endif
#include <wx/ipc.h> // for wxServer, wxClient and wxConnection


// Added for win32 API calls required to determine if Paratext is running on a windows host - KLB
#ifdef __WXMSW__
	#include <windows.h>
	#include <tlhelp32.h>
	#include <tchar.h>
#endif

#if !wxUSE_WXHTML_HELP
    #error "This program can't be built without wxUSE_WXHTML_HELP set to 1"
#endif // wxUSE_WXHTML_HELP

// BEW added to on 18Jul09, the final set of booleans for support of printing
extern bool gbIsBeingPreviewed;
extern bool gbSuppressPrecedingHeadingInRange;
extern bool gbIncludeFollowingHeadingInRange;
extern int	gnFromChapter;
extern int	gnFromVerse;
extern int	gnToChapter;
extern int	gnToVerse;

/// This global is defined in TransferMarkersDlg.cpp.
extern bool gbPropagationNeeded;

/// This global is defined in TransferMarkersDlg.cpp.
extern TextType gPropagationType;

/// This global is defined in FontPage.cpp
extern bool gbLTRLayout;

/// This global is defined in FontPage.cpp
extern bool gbRTLLayout;

/// BEW added 23May05, for support of returning to the previous context's TextType value
/// after an inline section with TextType none, or after a footnote (since the latter can
/// be embedded inline within verse, poetry, headings, subtitles, section headings, etc).
TextType gPreviousTextType; // moved here to global space in the Doc

/// A compatibility struct for the source language font, which is only used to hold the
/// Logfont info used by MFC and which is stored within Adapt It's config files. Many of
/// the values stored in the fontInfo structs are not used by the wxWidgets version, but
/// are read and written back out to the config files to maintain backward compatibility.
fontInfo SrcFInfo;

/// A compatibility struct for the target language font, which is only used to hold the
/// Logfont info used by MFC and which is stored within Adapt It's config files. Many of
/// the values stored in the fontInfo structs are not used by the wxWidgets version, but
/// are read and written back out to the config files to maintain backward compatibility.
fontInfo TgtFInfo;

/// A compatibility struct for the navigation language font, which is only used to hold the
/// Logfont info used by MFC and which is stored within Adapt It's config files. Many of
/// the values stored in the fontInfo structs are not used by the wxWidgets version, but
/// are read and written back out to the config files to maintain backward compatibility.
fontInfo NavFInfo;

/// A global instance of PageOffsets. Used for saving top and bottom logical coord offsets
/// for printing pages, stored in m_pagesList. The pgOffsets are populated in the
/// PaginateDoc() function in the CAdapt_ItView and AIPrintout classes.
PageOffsets pgOffsets;

// wxList definitions
#include <wx/listimpl.cpp>

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called POList.
WX_DEFINE_LIST(POList);

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called CCellList.
WX_DEFINE_LIST(CCellList);

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called KPlusCList.
WX_DEFINE_LIST(KPlusCList);

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called ProfileItemList.
WX_DEFINE_LIST(ProfileItemList);

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called SubMenuItemList.
WX_DEFINE_LIST(SubMenuItemList);


/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called MainMenuItemList.
WX_DEFINE_LIST(MainMenuItemList);

/// Length of the byte-order-mark (BOM) which consists of the three bytes 0xEF, 0xBB and
/// 0xBF in UTF-8 encoding.
#define nBOMLen 3

/// Length of the byte-order-mark (BOM) which consists of the two bytes 0xFF and 0xFE in
/// UTF-16 encoding.
#define nU16BOMLen 2

// globals

/// This global is defined in Adapt_ItView.cpp.
extern bool gbVerticalEditInProgress; // defined in Adapt_ItView.cpp
			// (for vertical edit functionality)

/// This global is defined in Adapt_ItView.cpp.
extern bool gbAdaptBeforeGloss; // defined in Adapt_ItView.cpp
			// (for vertical edit functionality)

/// BEW added 01Oct06, so that calling WriteProjectSettingsConfiguration() which is called
/// at the end, now, of OnNewDocument() and OnOpenDocument(), does not get called in
/// OnNewDocument() when gbPassedAppInitialization is FALSE, since the latter function call
/// is called by the framework within ProcessShellCommand() which is called from within
/// InitInstance() - and since the m_bBookMode defaults to FALSE, and m_nBookIndex defaults
/// to -1 at every launch, this MFC call of OnNewDocument() would otherwise unlaterally
/// turn off book mode which was on when the app last exitted. We can't have this happen,
/// so we use this new flag to suppress the config file write for the project settings
/// until we are actually in the wizard (and hence passed all the initializations).
bool gbPassedAppInitialization = FALSE;

/// When TRUE gbUpdateDocTitleNeeded causes OnIdle() to update the window title if the open
/// attempt failed, otherwise the failed doc name remains in the window's title bar. Note,
/// since OnOpenRecentFile always returns TRUE, we have to unilaterally cause OnIdle to do
/// the update of the title to ensure we catch the failures.
bool gbUpdateDocTitleNeeded = FALSE; // is set only by a failed MRU document open

/// This global is defined in DocPage.cpp.
extern bool gbReachedDocPage; // BEW added 10Nov05  (see DocPage.cpp, & OnInitDialog())

/// This global is defined in PhraseBox.cpp.
extern bool gbCameToEnd; // see PhraseBox.cpp

/// This global boolean is used to inform functions involved in opening documents whether
/// the file is being opened via the OnMRUFile() function, i.e., due to the user attempting
/// to open the file from the MRU list. If the file no longer exists and is an XML one, we
/// use the bool TRUE value to give the user a nice informative message and avoid ugly
/// error messages, and allow him to try again. TRUE if while the OnMRUFile() function is
/// active due to the user attempting to open a file from the MRU list (if the file no
/// longer exists and is an XML one, we use the bool TRUE value to give the user a nice
/// informative message and avoid ugly error messages, and allow him to try again.
bool gbTryingMRUOpen = FALSE;

/// This global is defined in SplitDialog.cpp. (It has nothing to do with window
/// splitting, but is for splitting the document's list of source phrase instances into
/// two or more shorter lists, and hence into two or more shorter documents)
extern bool gbIsDocumentSplittingDialogActive; // see SplitDialog.cpp

/// This global is defined in PhraseBox.cpp.
extern bool gbSuppressStoreForAltBackspaceKeypress;

/// This global is defined in MainFrm.cpp.
extern bool gbIgnoreScriptureReference_Receive;

/// This global is defined in MainFrm.cpp.
extern bool gbIgnoreScriptureReference_Send;

/// This global is defined in MainFrm.cpp.
extern SPList* gpDocList;

// The following declarations moved here from the View's global space

///BEW added 11Oct05 to support hiliting the cell under the clicked green wedge, or note
///icon.
CPile* gpGreenWedgePile;

/// BEW added 11Oct05, to allow clicked wedge's topmost cell in the layout to be given
/// background highlighting, so user has visual feedback as to which pile the View Filtered
/// Material dialog pertains to.
CPile* gpNotePile;

/// BEW added 17Sep05, to support adjusting the dialog position according to where the
/// click on the wedge or note icon was (because the phrase box might be a long way away -
/// even off screen). The point is in screen coords, as set at start of OnLButtonDown().
wxPoint gptLastClick;

// BEW added 24Jun05; globals for free translation support

///GDLC removed 2010-02-12 because it is no longer used anywhere
/// BEW added 27Jun05 for free trans support, make sure it is always FALSE when
/// OnLButtonDown() is entered. Default FALSE, TRUE if pile pointer is NULL on
/// GetPrevPile() call.
//bool gbBundleStartIteratingBack;

/// GDLC 2010-02-13 gnOffsetInMarkersStr and gnLengthInMarkersStr moved to CFreeTrans

//GDLC 2010-02-12,16
// The arrays gpCurFreeTransSectionPileArray and gpFreeTransArray were changed to
// member variables of CFreeTrans; as was the pointer gpFirstPile; the pointer
// gpLastPile was deleted because it is no longer used anywhere.

/// The contents of App's m_punctuation[1] string with spaces removed.
wxString gSpacelessTgtPunctuation;

/// Suppress the calling of SetupCurrentFreeTransSection() when the Shorten or Lengthen
/// button has been pressed (otherwise it wipes out the action of the button)
bool gbSuppressSetup;

/// whm added 13Apr07, a flag to ensure that the warning about hacked character data being
/// detected is only issued once - upon first detection of such data in config files and/or
/// data files.
bool gbHackedDataCharWarningGiven = FALSE;

/// BEW added 29Apr06, so that Remove Free Translation button in ViewFilteredMaterial
/// dialog can be used to delete the free translation and its markers, and then a
/// subsequent <Prev, Next> or Advance clicked without that click inserting an empty \free
/// \free* filtered marker pair in the location just left (which had its free translation
/// just removed) - this, of course, only is relevant while Free Trans Mode is turned on.
bool gbFreeTranslationJustRemovedInVFMdialog = FALSE;

/// Save m_bSuppressTargetHighlighting flag's value while the 'Accept Changes Without
/// Stopping' toggle is ON. When the latter is ON, the app's m_bSuppressTargetHighlighting
/// value must be TRUE, otherwise MFC's lazy window updates get out of synch with updates
/// of the pointers on which the layout relies and the app crashes. This does not happen if
/// no highlighting takes place. The original setting for highlighting is restored when the
/// toggle command is turned back off.
bool gbSaveHilightingSetting = FALSE; // *** NOTE *** in version 6 & higher, this protection might not be needed - noone has checked as yet

// The above declarations moved here from the View's global space

/// For support of book folders mode and the option of binary or xml intput/output when
/// doing the Transform Adaptations to Glosses operation - which needs to work whether book
/// mode is currently on or not and whether book folders are present or not, (and for any
/// possible mix of xml or binary kb files and document files; in fact, the same
/// considerations about file type and book folders mode are relevant to any operation
/// involving the enumerated set of documents - so also relevant to restoring the knowledge
/// base from the existing documents and reporting retranslations). TRUE if the current
/// project's Adaptations folder contains Bible book folders (whether or not book mode is
/// currently on) (for XML or binary, a local Boolean will suffice).
bool gbHasBookFolders = FALSE; //

// for support of auto-capatalization

/// whm added 12Aug04 Initial flag for auto-cap support possible. This flag keeps track of
/// initial checkbox on "Define Any Lower To Upper Case Equivalences" Wizard panel/Dialog
/// that reads: [ ]Check here if the source text contains both capital letters (upper case)
/// and small letters (lower case). The remaining controls on the panel do not appear
/// unless this checkbox is checked. This value is now stored in the
/// AI-ProjectConfiguration.aic file.
bool gbSrcHasUcAndLc = FALSE;

/// Switch for turning auto-capitalization support on or off.
bool gbAutoCaps = FALSE;

/// Refers to first character of the source word or phrase; TRUE if the source is upper
/// case, otherwise FALSE.
bool gbSourceIsUpperCase = FALSE;

/// Refers to first character of the contents of the phrase box, which may contain a gloss
/// or an adaptation depending on the value of gbIsGlossing.
bool gbNonSourceIsUpperCase = FALSE;

/// if the source has an initial UC character and the first KB lookup fails, then a KB
/// lookup is done with UC first character, and if found this flag is set TRUE.
bool gbMatchedKB_UCentry = FALSE;

/// Set TRUE if source language is caseless, or user does not define any case equivalences.
bool gbNoSourceCaseEquivalents = FALSE;

/// Set TRUE if user does not define any case equivalences for the target language.
bool gbNoTargetCaseEquivalents = FALSE;

/// Set TRUE if user does not define any case equivalences for the gloss language.
bool gbNoGlossCaseEquivalents = FALSE;

/// Store first character of adaption or gloss when it is lower case.
wxChar gcharNonSrcLC;

/// Store first character of adaption or gloss when it is upper case.
wxChar gcharNonSrcUC;

/// Store first lwr case char of source text word or phrase (after punct stripped).
wxChar gcharSrcLC;

/// Store first upr case char of source text word or phrase (after punct stripped).
wxChar	gcharSrcUC;

/// Use to suppress the message box asking if the src language has upper/lower case
/// distinction, when the flag is being restored to TRUE from reading the project's config
/// file.
bool gbSuppressAutoCapsAsk = FALSE;

/// This global is defined in OpenExistingProjectDlg.cpp.
extern bool gbExcludeCurrentProject;

/// This global is defined in Adapt_ItView.cpp.
extern bool gbGlossingUsesNavFont;

/// This global is defined in Adapt_ItView.cpp.
//extern bool gbRemovePunctuationFromGlosses; << BEW removed 13Nov10, it's nowhere set TRUE

/// This global is defined in Adapt_ItView.cpp.
extern int gnSelectionLine;

/// This global is defined in Adapt_ItView.cpp.
extern int gnSelectionStartSequNum;

/// This global is defined in Adapt_ItView.cpp.
extern int gnSelectionEndSequNum;

/// This global is defined in Adapt_ItView.cpp.
extern bool gbPrintFooter;

// next two are for version 2.0 which includes the option of a 3rd line for glossing

/// This global is defined in Adapt_ItView.cpp.
extern bool	gbIsGlossing; // when TRUE, the phrase box and its line have glossing text

/// This global is defined in Adapt_ItView.cpp.
extern bool	gbGlossingVisible; // TRUE makes Adapt It revert to Shoebox functionality only

// When FALSE back slash characters found anywhere in a text are interpreted as
// introducing standard format markers (the default). When TRUE back slash characters may
// be interpreted as word-building characters. When the gbSfmOnlyAfterNewlines flag is
// TRUE, any standard format marker escape characters which do not follow a newline are
// not assumed to belong to a sfm, and so we treat them in such cases as ordinary
// word-building characters (on the assumption we are dealing with a hacked legacy
// encoding in which the escape character is an alphabetic glyph in the font)

// BEW 8Jun10, removed support for checkbox "Recognise standard format
// markers only following newlines"
//bool gbSfmOnlyAfterNewlines = FALSE;

/// Defined as the backslash character.
/// NOTE: Older versions of Adapt It allowed the user to designate the character to be
/// used, but in all recent versions, gSFescapechar is always defined as the backslash
/// character. For cross-platform considerations, the gSFescapechar is handled totally
/// apart from the wxWidgets PathSeparator.
wxChar gSFescapechar = _T('\\'); // standard format escape char, default is backslash

/// TRUE while there is no m_targetBox created, during setup of the view. It is used to
/// prevent premature merges, and at 6May09, also to suppress the interpretation of a null
/// active pile pointer being due to having reached the doc end (because at initial launch
/// we can have a null active pile due to the sequence number starting with value -1)
bool gbDoingInitialSetup = FALSE;

/// A global pointer to the application instance.
CAdapt_ItApp* gpApp;

/// ANSI version is always left to right (LTR) reading; this flag can only be changed in
/// the NRoman version, using the extra Layout menu. When TRUE text is right to left (RTL)
/// layout.
bool gbRTL_Layout = FALSE;

/// For ANSI version, no bloating of the size of the phrase box is needed, but for an
/// unknown reason, the CRichEditCtrl's vertical size is smaller than required for showing
/// all the text; adding in external and internal leadings helps (at expense of making the
/// line height too large, but is not enough because the style is diff. So I'll the sum of
/// the ext & int leadings to the box height, and +4 to allow for the thicker boundary at
/// top and bottom.
int gnVerticalBoxBloat = 0;

/// TRUE if <New Project> selected in the Wizard, otherwise FALSE.
bool gbWizardNewProject = FALSE;

/// Global pointer to the help controller instance.
wxHtmlHelpController* m_pHelpController = (wxHtmlHelpController*)NULL;

/// Global pointer to the help controller instance.
//wxHelpController* m_pHelpController = (wxHelpController*)NULL;

/// This global is defined in Adapt_ItView.cpp.
extern short gnExpandBox;  // see start of Adapt_ItView.cpp for explanation of these

/// This global is defined in Adapt_ItView.cpp.
extern short gnNearEndFactor;

/// This global is defined in Adapt_ItView.cpp.
extern	bool gbLegacySourceTextCopy; // defined in Adapt_ItView.cpp, to govern
			// the default phrase box text

/// Pointer to the Start Working Wizard instance.
CStartWorkingWizard* pStartWorkingWizard = (CStartWorkingWizard*)NULL;

/// Pointer to the project page instance
CProjectPage* pProjectPage = (CProjectPage*)NULL;

/// Pointer to the languages page instance
CLanguagesPage* pLanguagesPage = (CLanguagesPage*)NULL;

/// Pointer to the Wizard's font page instance
CFontPageWiz* pFontPageWiz = (CFontPageWiz*)NULL;

/// Pointer to the Wizard's punct correspondence page instance
CPunctCorrespPageWiz* pPunctCorrespPageWiz = (CPunctCorrespPageWiz*)NULL;

/// Pointer to the Wizard's case equivalences page instance
CCaseEquivPageWiz* pCaseEquivPageWiz = (CCaseEquivPageWiz*)NULL;

/// Pointer to the Wizard's usfmFilterPage instance
CUsfmFilterPageWiz*	pUsfmFilterPageWiz = (CUsfmFilterPageWiz*)NULL;

/// Pointer to the doc page instance
CDocPage* pDocPage = (CDocPage*)NULL;

/// Pointer to the Preferences usfmFilterPage instance
CUsfmFilterPagePrefs* pUsfmFilterPageInPrefs = (CUsfmFilterPagePrefs*)NULL;

/// Contains the sequence number for the last auto save operation; -1 if auto save is
/// turned off.
int nSequNumForLastAutoSave;

/// Indicates whether a document is being opened via the MRU list. Its value is set to TRUE
/// in the main frame's OnMRUFile() function.
bool gbViaMostRecentFileList = FALSE;

/// This global is defined in PhraseBox.cpp.
extern int nCurrentSequNum;

/// A global that indicates whether it is possible to open a file from the MRU list. It is
/// set TRUE if m_bDisableBookMode is TRUE when SetupDirectories() is called (the post MRU
/// file click is the time when this is significant, because there is not enough info to
/// recreate the folder path if books.xml failed on input or parse).
bool gbAbortMRUOpen = FALSE;

// Bible books folders support - folder name defaults for when there is no "books.XML" file
// in work folder. NT and OT book name string constants, for GUI - especially setting up a
// folder for every Bible book, and the 67th will be "Other Texts" for all non-scripture
// work.

/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _00BK = _("Genesis");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _01BK = _("Exodus");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _02BK = _("Leviticus");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _03BK = _("Numbers");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _04BK = _("Deuteronomy");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _05BK = _("Joshua");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _06BK = _("Judges");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _07BK = _("Ruth");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _08BK = _("1 Samuel");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _09BK = _("2 Samuel");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _10BK = _("1 Kings");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _11BK = _("2 Kings");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _12BK = _("1 Chronicles");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _13BK = _("2 Chronicles");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _14BK = _("Ezra");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _15BK = _("Nehemiah");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _16BK = _("Esther");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _17BK = _("Job");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _18BK = _("Psalms");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _19BK = _("Proverbs");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _20BK = _("Ecclesiastes");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _21BK = _("Song of Songs");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _22BK = _("Isaiah");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _23BK = _("Jeremiah");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _24BK = _("Lamentations");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _25BK = _("Ezekiel");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _26BK = _("Daniel");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _27BK = _("Hosea");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _28BK = _("Joel");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _29BK = _("Amos");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _30BK = _("Obadiah");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _31BK = _("Jonah");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _32BK = _("Micah");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _33BK = _("Nahum");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _34BK = _("Habakkuk");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _35BK = _("Zephaniah");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _36BK = _("Haggai");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _37BK = _("Zechariah");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _38BK = _("Malachi");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _39BK = _("Matthew");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _40BK = _("Mark");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _41BK = _("Luke");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _42BK = _("John");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _43BK = _("Acts");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _44BK = _("Romans");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _45BK = _("1 Corinthians");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _46BK = _("2 Corinthians");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _47BK = _("Galatians");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _48BK = _("Ephesians");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _49BK = _("Philippians");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _50BK = _("Colossians");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _51BK = _("1 Thessalonians");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _52BK = _("2 Thessalonians");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _53BK = _("1 Timothy");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _54BK = _("2 Timothy");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _55BK = _("Titus");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _56BK = _("Philemon");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _57BK = _("Hebrews");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _58BK = _("James");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _59BK = _("1 Peter");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _60BK = _("2 Peter");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _61BK = _("1 John");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _62BK = _("2 John");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _63BK = _("3 John");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _64BK = _("Jude");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _65BK = _("Revelation");
/// Bible books folders support - folder name defaults for when there is no "books.XML" file in work folder.
const wxChar* _66BK = _("Other Texts");

// now the book codes

/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _00BKCODE = _("GEN");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _01BKCODE = _("EXO");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _02BKCODE = _("LEV");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _03BKCODE = _("NUM");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _04BKCODE = _("DEU");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _05BKCODE = _("JOS");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _06BKCODE = _("JDG");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _07BKCODE = _("RUT");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _08BKCODE = _("1SA");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _09BKCODE = _("2SA");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _10BKCODE = _("1KI");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _11BKCODE = _("2KI");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _12BKCODE = _("1CH");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _13BKCODE = _("2CH");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _14BKCODE = _("EZR");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _15BKCODE = _("NEH");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _16BKCODE = _("EST");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _17BKCODE = _("JOB");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _18BKCODE = _("PSA");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _19BKCODE = _("PRO");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _20BKCODE = _("ECC");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _21BKCODE = _("SNG");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _22BKCODE = _("ISA");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _23BKCODE = _("JER");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _24BKCODE = _("LAM");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _25BKCODE = _("EZK");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _26BKCODE = _("DAN");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _27BKCODE = _("HOS");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _28BKCODE = _("JOL");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _29BKCODE = _("AMO");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _30BKCODE = _("OBA");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _31BKCODE = _("JON");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _32BKCODE = _("MIC");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _33BKCODE = _("NAH");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _34BKCODE = _("HAB");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _35BKCODE = _("ZEP");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _36BKCODE = _("HAG");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _37BKCODE = _("ZEC");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _38BKCODE = _("MAL");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _39BKCODE = _("MAT");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _40BKCODE = _("MRK");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _41BKCODE = _("LUK");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _42BKCODE = _("JHN");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _43BKCODE = _("ACT");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _44BKCODE = _("ROM");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _45BKCODE = _("1CO");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _46BKCODE = _("2CO");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _47BKCODE = _("GAL");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _48BKCODE = _("EPH");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _49BKCODE = _("PHP");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _50BKCODE = _("COL");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _51BKCODE = _("1TH");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _52BKCODE = _("2TH");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _53BKCODE = _("1TI");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _54BKCODE = _("2TI");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _55BKCODE = _("TIT");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _56BKCODE = _("PHM");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _57BKCODE = _("HEB");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _58BKCODE = _("JAS");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _59BKCODE = _("1PE");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _60BKCODE = _("2PE");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _61BKCODE = _("1JN");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _62BKCODE = _("2JN");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _63BKCODE = _("3JN");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _64BKCODE = _("JUD");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _65BKCODE = _("REV");
/// Bible books folders support - 3-letter book code defaults for when there is no "books.XML" file in work folder.
const wxChar* _66BKCODE = _("OTX");

wxString dummyBack = _("&Finish"); // the wxstd.mo file doesn't seem to have
			// this wizard button for localizing, so I add it here
wxString dummyFinish = _("< &Back"); // the wxstd.mo file doesn't seem to have
			// this wizard button for localizing, so I add it here

// support for USFM and SFM Filtering

/// An array of wxStrings which, when parsed by ParseAndFillStruct(), is used as default
/// standard format marker style definitions if, for some reason, the program cannot find
/// the AI_USFM.xml control file.
/// The default data strings can be produced automatically by making the following
/// temporary changes in the code:
/// 1. Temporarily uncomment the #define Output_Default_Style_Strings line at the
/// beginning of XML.h file.
/// 2. Copy the current AI_USFM_full.xml file from the project's xml folder to the "Adapt
/// It Work" folder (this file which contains the full style information and from which the
/// AI_USFM.xml file for distribution to users is produced via the UsfmXml.cct and
/// UsfmXmlTidy.cct changes operations). While the Output_Default_Strings define is active,
/// running the Adapt It program (Debug) up through the appearance of the Start Working
/// Wizard causes the routines in XML.cpp to read the full AI_USFM_full.xml file (instead
/// of AI_USFM.xml) and produce the temporary AI_USFM_full.txt file which simply contains
/// the Unix-format default strings ready to paste into the code block below.
/// 3. Copy the strings from the AI_USFM_full.txt file and paste them here for
/// recompilation. Note that the last line of the file contains the number of usfm strings
/// which should be equivalent to the calculation of gnDefaultSFMs =
/// sizeof(defaultSFM)/sizeof(wxString) below. Also, Remember to remove the last comma from
/// the last string item once it is pasted into this array initialization list.
/// 4. Comment out the #define Output_Default_Style_Strings line at the beginning of XML.h
/// file so that the application won't continue to produce the temporary AI_USFM_full.txt
/// file in the work folder, but will instead revert back to using the normal (abbreviated)
/// AI_USFM.xml file on program startup.
const wxString defaultSFM[] =
{
_T("id::File identification (BOOKID, FILENAME, EDITOR, MODIFICATION DATE):1:1::::1::1:id:11::id - File - Identification:0:1:65535::::::3::::::__normal:id::1:"),
_T("ide::File encoding information:1::1::::1:::0::ide - File - Encoding:0:1:65535::::::3::::::__normal:ide::1:"),
_T("h::Running header text for a book (basic):1:1:1:1::1:1:1:hdr:10::h - File - Header:0:9:::::::3::::::_vernacular_base:h:::"),
_T("h1::Running header text:1::1:1::1:1:1:hdr:10::h1 - File - Header:0:9:::::::1::::::h:h1:::"),
_T("h2::Running header text, left side of page:1::1:1::1:1:1:hdr-left:10::h2 - File - Left Header:0:9:::::::0::::::h1:h2:::"),
_T("h3::Running header text, right side of page:1::1:1::1:1:1:hdr-rght:10::h3 - File - Right Header:0:9:::::::2::::::h1:h3:::"),
_T("rem::Comments and remarks:1::1:1::1:1:1:comment:34::rem - File - Remark:0:9:16711680::::::0::::::_notes_base:rem:::"),
_T("sts::Status of this file:1::1:1::1:1:1:comment:34::rem - File - Status:0:9:16711680::::::0::::::_notes_base:sts:::"),
_T("restore::Project restore information:1::1::::1:::34::restore - File - Restore Information:0:12:16711680::::::3::::::__normal:restore:::"),
_T("lit::For a comment or note inserted for liturgical use:1::1:1::1:1:1:lit-note:34::lit - Special Text - Liturgical note:0:12:::1::::2::::::p:lit:1:1:"),
_T("nt::Note::1:1:1::1:1:1:note:34::nt - Note:0:9:16711680::::::0::::::_notes_base:nt:::"),
_T("nc::Note centered::1:1:1::1:1:1:note:34::nc - Note centered:0:9:16711680::::::1::::::nt:nc:::"),
_T("c::Chapter number (basic):1:1:::::1:1::1:1:c - Chapter Number:0:18:::1::::1:8:4::::_heading_base:p:1:1:"),
_T("ca:ca*:Second (alternate) chapter number (for coding dual versification; useful for places where different traditions of chapter breaks need to be supported in the same translation):1::1:1:::1:::1::ca...ca* - Chapter Number - Alternate:1:16:2263842::1::::3::::::::::"),
_T("cl::Chapter label used for translations that add a word such as 'Chapter' before chapter numbers (e.g. Psalms). The subsequent text is the chapter label.:1::1:1:::1:::1::cl - Chapter - Publishing Label:0:18:::1::::1:8:4::::_heading_base:p:1:1:"),
_T("cp::Published chapter number (this is a chapter marking that would be used in the published text):1::1:1:::1:::1::cp - Chapter Number - Publishing Alternate:0:18:16711680::1::::1:8:4::::_heading_base:p:1:1:"),
_T("cd::Chapter Description (Publishing option D, e.g. in Russian Bibles):1:::1:::1:1:chapter descr:1::cd - Chapter - Description:0:11:::::::3:8:4::::_heading_base:p:1:1:"),
_T("v::A verse number (basic):1:1:::::1:1::1::v - Verse Number:1:10:16711935::1:::1:3::::::::::"),
_T("vt::Verse text:1:1:::::1:1::1::vt - Verse text vt:1:12::::::1:3::::::::::"),
_T("vn::Verse number:1:1:::::1:1::1::vn - Verse number vn:1:10:16711935::1:::1:3::::::::::"),
_T("va:va*:Second (alternate) verse number (for coding dual numeration in Psalms; see also NRSV Exo 22.1-4):1::1:1:1:::::1::va...va* - Verse Number - Alternate:1:10:2263842::1:::1:3::::::::::"),
_T("vp:vp*:Published verse marker - this is a verse marking that would be used in the published text:1::1:1:1:::::1::vp...vp* - Verse Number - Publishing Alternate:1:10:16711680::1:::1:3::::::::::"),
_T("mt::The main title of the book (if single level):1:1::1::1:1:1:main title:4:1:mt - Title - Major Title Level 1:0:20:::1::::1:8:4::::_heading_base:c:1:1:"),
_T("mt1::The main title of the book (if multiple levels) (basic):1:::1::1:1:1:main title L1:4:1:mt1 - Title - Major Title Level 1:0:20:::1::::1:2:4::::_heading_base:c:1:1:"),
_T("mt2::A secondary title usually occurring before the main title (basic):1:::1::1:1:1:secondary title L2:5:1:mt2 - Title - Major Title Level 2:0:16::1:::::1::2::::_heading_base:mt:1:1:"),
_T("mt3::A secondary title occurring after the main title:1:::1::1:1:1:secondary title L3:5:1:mt3 - Title - Major Title Level 3:0:14:::1::::1:2:2::::_heading_base:c:1:1:"),
_T("mt4::A small secondary title sometimes occuring within parentheses:1:::1::1:1:1:secondary title L4:5:1:mt4 - Title - Major Title level 4:0:12:::::::1:2:2::::_heading_base:c:1:1:"),
_T("st::Secondary title::1::1::1:1:1:secondary title:5:1:st - Secondary title:0:16:::1::::1::2::::_heading_base:mt:1:1:"),
_T("mte::The main title of the book repeated at the end of the book (if single level):1:::1::1:1:1:main title at end:4:1:mte - Title - [Uncommon] Major Title Ending Level 1:0:20:::1::::1:8:4::::_heading_base::1::"),
_T("mte1::The main title of the book repeated at the end of the book (if multiple levels):1:::1::1:1:1:main title at end L1:4:1:mte1 - Title - [Uncommon] Major Title Ending Level 1:0:20:::1::::1:8:4::::_heading_base::1::"),
_T("mte2::A secondary title occurring before or after the 'ending' main title:1:::1::1:1:1:secondary title at end L2:5:1:mte2 - Title - [Uncommon] Major Title Ending Level 2:0:16::1:::::1::2::::_heading_base::1::"),
_T("div::Division heading::1::1::1:1:1:division head:3:1:div - Division heading:0:16:::1::::1:6:3::::s:dvrf:1:1:"),
_T("bn::Psalms book number::1::1::1:1:1:Psalm book number:0:1:bn - Psalms book number:0:11:::1::::1:6:3::::s:br:1:1:"),
_T("ms::A major section division heading, level 1 (if single level) (basic):1:::1::1:1:1:major sect head:3:1:ms - Heading - Major Section Level 1:0:14:::1::::1:16:4::::_heading_base:mr:1:1:"),
_T("ms1::A major section division heading, level 1 (if multiple levels):1:::1::1:1:1:major sect head L1:3:1:ms1 - Heading - Major Section Level 1:0:14:::1::::1:16:4::::_heading_base:mr:1:1:"),
_T("ms2::A major section division heading, level 2:1:::1::1:1:1:major sect head L2:3:1:ms2 - Heading - Major Section Level 2:0:14:::1::::1:16:4::::_heading_base:mr:1:1:"),
_T("ms3::A major section division heading, level 3:1:::1::1:1:1:major sect head L3:3:1:ms3 - Heading - Major Section Level 3:0:14::1:::::1:16:4::::_heading_base:mr:1:1:"),
_T("s::A section heading, level 1 (if single level) (basic):1:1::1::1:1:1:sect head:3:1:s - Heading - Section Level 1:0:12:::1::::1:8:4::::_heading_base:p:1:1:"),
_T("s1::A section heading, level 1 (if multiple levels):1:::1::1:1:1:sect head L1:3:1:s1 - Heading - Section Level 1:0:12:::1::::1:8:4::::_heading_base:p:1:1:"),
_T("s2::A section heading, level 2 (e.g. Proverbs 22-24):1:::1::1:1:1:sect head L2:3:1:s2 - Heading - Section Level 2:0:12::1:::::1:8:4::::_heading_base:p:1:1:"),
_T("s3::A section heading, level 3 (e.g. Genesis 'The First Day'):1:::1::1:1:1:sect head L3:3:1:s3 - Heading - Section Level 3:0:12::1:::::0:6:3::::_heading_base:p:1:1:"),
_T("s4::A section heading, level 4:1:::1::1:1:1:sect head L4:3:1:s4 - Heading - Section Level 4:0:12::1:::::0:6:3::::_heading_base:p:1:1:"),
_T("sr::A section division references range heading:1:::1::1:1:1:sect head range refs:3:1:sr - Heading - Section Range References:0:12:::1::::1::4::::_heading_base:p:1:1:"),
_T("sx::Extra heading 1::1::1::1:1:1:sect head extra 1:3:1:sx - Extra heading 1:0:12:::1::::1:6:3::::_heading_base:p:1:1:"),
_T("sz::Extra heading 2::1::1::1:1:1:sect head extra 2:3:1:sz - Extra heading 2:0:12::1:::::1:6:3::::_heading_base:p:1:1:"),
_T("sp::A heading, to identify the speaker (e.g. Job) (basic):1:1::1::1:1:1:speaker:0:1:sp - Heading - Speaker:0:12::1:::::0:8:4::::_heading_base:q:1:1:"),
_T("d::A Hebrew text heading, to provide description (e.g. Psalms):1:::1::1:1:1:descr title:1:1:d - Heading - Descriptive Title - Hebrew Subtitle:0:12::1:::::1:4:4::::_heading_base:q:1:1:"),
_T("di::Descriptive title (Hebrew subtitle)::1::1::1:1:1:descr title:1:1:di - Descr title or Heb subtitle di:0:12::1:::::1:4:4::::_heading_base:q:1:1:"),
_T("hl::Hebrew letter::1:1:1:::1:::0::hl - Hebrew letter:0:12:::::::1:4:4::::_heading_base:q:1:1:"),
_T("r::Parallel reference(s) (basic):1:1:1:1::1:1:1:ref:33::r - Heading - Parallel References:0:12::1:::::1::4::::_heading_base:p:1:1:"),
_T("dvrf::Division reference::1:1:1::1::1:div-ref:0::dvrf - Division ref:0:12::1:::::1::3::::_heading_base:p:1:1:"),
_T("mr::A major section division references range heading (basic):1::1:1::1::1:mjr-sect-refs:0::mr - Heading - Major Section Range References:0:12::1:::::1::4::::ms:p:1:1:"),
_T("br::Psalms book reference::1:1:1::1::1:Ps-bk-ref:0::br - Psalms book ref:0:12::1:::::1::4::::r:c:1:1:"),
_T("x:x*:A list of cross references (basic):1::1:1:1:1:1:1:x-refs:33::x...x* - Cross Reference:4:10:::::::0::::::_notes_base:x:::"),
_T("xo:xo*:The cross reference origin reference (basic):1::1::1:1::::33::xo - Cross Reference - Origin Reference:1:10:::1::::3::::::::::"),
_T("xt:xt*:The cross reference target reference(s), protocanon only (basic):1::1::1:1::::33::xt - Cross Reference - Target References:1:10:::::::3::::::::::"),
_T("xk:xk*:A cross reference keyword:1::1::1:1::::33::xk - Cross Reference - Keyword:1:10::1:::::3::::::::::"),
_T("xq:xq*:A cross-reference quotation from the scripture text:1::1::1:1::::33::xq - Cross Reference - Quotation:1:10::1:::::3::::::::::"),
_T("xot:xot*:Cross-reference target reference(s), Old Testament only:1::1::1:1::::33::xot...xot* - Cross Reference - OT Target Refs (optional):1:12:::::::3::::::::::"),
_T("xnt:xnt*:Cross-reference target reference(s), New Testament only:1::1::1:1::::33::xnt...xnt* - Cross Reference - NT Target Refs (optional):1:12:::::::3::::::::::"),
_T("xdc:xdc*:Cross-reference target reference(s), Deuterocanon only:1::1::1:1::::33::xdc...xdc* - Cross Reference - DC Target Refs:1:10:::::::3::::::::::"),
_T("rr::Right margin reference::1:1:1::1::1:rt-marg-ref:32::rr - Right margin ref:0:9::1:::::2::::::qr:rr:::"),
_T("rq:rq*:A cross-reference indicating the source text for the preceding quotation:1::1:1::1::1:x-ref to source:32::rq...rq* - Cross Reference - Inline Quotation References:1:10::1:::::2::::::::::"),
_T("@::Cross reference, origin reference::1:1:1::1::1:x-refs orig:33::@ - Cross ref origin ref:1:10:::1::::3::::::::::"),
_T("xr::Cross reference target references::1:1:1::1::1:x-refs tgt:33::xr - Cross ref target ref:1:10:::::::3::::::::::"),
_T("p::Paragraph text, with first line indent (basic):1:1:::::1:1:paragraph:1:1:p - Paragraph - Normal - First Line Indent:0:12:::::::3:::::.125:_body_text:p:::"),
_T("pi::Paragraph text, level 1 indent (if sinlge level), with first line indent; often used for discourse (basic):1:1:::::1:1:para indented:1:1:pi - Paragraph - Indented - Level 1 - First Line Indent:0:12:::::::3:::.25:.25:.125:p:pi:::"),
_T("pi1::Paragraph text, level 1 indent (if multiple levels), with first line indent; often used for discourse:1::::::1:1:para indented L1:1:1:pi1 - Paragraph - Indented - Level 1 - First Line Indent:0:12:::::::3:::.25:.25:.125:pi:pi1:::"),
_T("pi2::Paragraph text, level 2 indent, with first line indent; often used for discourse:1::::::1:1:para indented L2:1:1:pi2 - Paragraph - Indented - Level 2 - First Line Indent:0:12:::::::3:::.5:.25:.125:pi1:pi2:::"),
_T("pi3::Paragraph text, level 3 indent, with first line indent; often used for discourse:1::::::1:1:para indented L3:1:1:pi3 - Paragraph - Indented - Level 3 - First Line Indent:0:12:::::::3:::.75:.25:.125:pi2:pi3:::"),
_T("pgi::Indented paragraph::1:::::1:1:para indented:1:1:pgi - Indented paragraph:0:12:::::::3:::.25:.25:.125:p:pgi:::"),
_T("ph::Paragraph text, with level 1 hanging indent (if single level):1::::::1:1:para hang indent:1:1:DEPRECATED ph - Paragraph - Hanging Indent - Level 1:0:12:::::::3:::.5::-.25:_body_text:ph:::"),
_T("ph1::Paragraph text, with level 1 hanging indent (if multiple levels):1::::::1:1:para hang indent L1:1:1:DEPRECATED ph1 - Paragraph - Hanging Indent - Level 1:0:12:::::::3:::.5::-.25:ph:ph1:::"),
_T("ph2::Paragraph text, with level 2 hanging indent:1::::::1:1:para hang indent L2:1:1:DEPRECATED ph2 - Paragraph - Hanging Indent - Level 2:0:12:::::::3:::.75::-.25:ph1:ph2:::"),
_T("ph3::Paragraph text, with level 3 hanging indent:1::::::1:1:para hang indent L3:1:1:DEPRECATED ph3 - Paragraph - Hanging Indent - Level 3:0:12:::::::3:::1::-.25:ph2:ph3:::"),
_T("phi::Paragraph text, indented with hanging indent:1::::::1:1:para indent hang indent:1:1:DEPRECATED phi - Paragraph - Indented - Hanging Indent:0:12:::::::3:::1:::_body_text:phi:::"),
_T("m::Paragraph text, with no first line indent (may occur after poetry) (basic):1:1:::::1:1:paragraph margin:1:1:m - Paragraph - Margin - No First Line Indent:0:12:::::::3::::::p:m:::"),
_T("pmo::Embedded text opening:1::::::1:1:para embedded text opening:1:1:pmo - Paragraph - Embedded Text Opening:0:12:::::::3:::.25:.25::pm:pm:::"),
_T("mi::Paragraph text, indented, with no first line indent; often used for discourse:1:1:::::1:1:para indent no 1st line indent:1:1:mi - Paragraph - Indented - No First Line Indent:0:12:::::::3:::.25:.25::pi:mi:::"),
_T("pc::Paragraph spanning chapters::1::1:::1:1:para spans chapters:1:1:pc - Paragraph spanning chapters:0:12:::::::3::::::m:pc:::"),
_T("pc::Paragraph text, centered (for Inscription):1::::::1:1:para centered inscription:1:1:pc - Paragraph - Centered (for Inscription):0:12:::::::1::::::_body_text:pc:::"),
_T("pr::Paragraph text, right aligned:1::::::1:1:para right aligned:1:1:DEPRECATED pr - Paragraph - Right Aligned:0:12:::::::2::::::p:pr:::"),
_T("pt::Preface title::1::1::1:1:1:preface title:0:1:pt - Preface title:0:14:::1::::1::6::::_heading_base:pp:1:1:"),
_T("ps::Preface section heading::1::1::1:1:1:preface sect head:0:1:ps - Preface sect heading:0:12:::1::::1:4:2::::s:pp:1:1:"),
_T("ps::Paragraph text, no break with next paragraph text at chapter boundary:1:::1:::1:1:para spans chapters:1:1:OBSOLETE ps - Paragraph - No Break with Next Paragraph:0:12:::::::3::::::m:ps:::"),
_T("psi::Paragraph text, indented, with no break with next paragraph text (at chapter boundary):1::::::1:1:para spans chapters indent:1:1:OBSOLETE psi - Paragraph - Indented - No Break with Next:0:12:::::::3:::.25:.25:.125:pi:pi:::"),
_T("pp::Preface paragraph::1::1::1:1:1:preface paragraph:0:1:pp - Preface paragraph:0:10:::::::3:::::.125:p:pp:::"),
_T("pq::Preface poetry::1::1::1:1:1:preface poetry:0:1:pq - Preface poetry:0:10:::::::3:::.5:::q:pq:::"),
_T("pm::Preface continue at margin::1::1::1:1:1:preface at margin:0:1:pm - Preface continue at margin:0:10:::::::3::::::m:pm:::"),
_T("pm::Embedded text paragraph:1:::::1:1:1:paragraph embedded text:1:1:pm - Paragraph - Embedded Text:0:12:::::::3:::.25:.25:.125:p:pm:::"),
_T("pmc::Embedded text closing:1:::::1:1:1:para embedded text closing:1:1:pmc - Paragraph - Embedded Text Closing:0:12:::::::3:::.25:.25::pm:pmc:::"),
_T("pmr::Embedded text refrain (e.g. Then all the people shall say, 'Amen!'):1:::::1:1:1:para embedded text refrain:1:1:pmr - Paragraph - Embedded Text Refrain:0:12:::::::2:::.25:.25::pm:p:::"),
_T("nb::Paragraph text, with no break from previous paragraph text (at chapter boundary) (basic):1::::::1:1:para no break:1:1:nb - Paragraph - No Break with Previous Paragraph:0:12:::::::3::::::m:p:::"),
_T("cls::Closure of an Epistle:1::::::1:1:Epistle close:1::cls - Paragraph - Closure of an Epistle:0:12:::::::2::::::p:cls:1:1:"),
_T("q::Poetry text, level 1 indent (if single level):1:1:::::1:1:poetry:2:1:q - Poetry - Indent Level 1 - Single Level Only:0:12:::::::3:::1.25::-1:_body_text:q:::"),
_T("q1::Poetry text, level 1 indent (if multiple levels) (basic):1::::::1:1:poetry L1:2:1:q1 - Poetry - Indent Level 1:0:12:::::::3:::1.25::-1:q:q1:::"),
_T("q2::Poetry text, level 2 indent (basic):1:1:::::1:1:poetry L2:2:1:q2 - Poetry - Indent Level 2:0:12:::::::3:::1.25::-.75:q:q2:::"),
_T("q3::Poetry text, level 3 indent:1:1:::::1:1:poetry L3:2:1:q3 - Poetry - Indent Level 3:0:12:::::::3:::1.25::-.5:q2:q3:::"),
_T("q4::Poetry text, level 4 indent:1:1:::::1:1:poetry L3:2:1:q4 - Poetry - Indent Level 4:0:12:::::::3:::1.25::-.25:q3:q4:::"),
_T("qc::Poetry text, centered:1:1:::::1:1:poetry centered:2:1:qc - Poetry - Centered:0:12:::::::1::::::q:qc:::"),
_T("qr::Poetry text, Right Aligned:1:1:::::1:1:poetry right margin:2:1:qr - Poetry - Right Aligned:0:12:::::::2::::::q:qr:::"),
_T("qa::Poetry text, Acrostic marker/heading:1:::1:::1:1:acrostic hdg:2:1:qa - Poetry - Acrostic Heading/Marker:0:12::1:::::3::::::_heading_base:q:1:1:"),
_T("qac:qac*:Poetry text, Acrostic markup of the first character of a line of acrostic poetry:1::::1::1:::2::qac...qac* - Poetry Text - Acrostic Letter:1:12::1:::::3::::::::::"),
_T("qs:qs*:Poetry text, Selah:1:::1:1::1:::6::qs...qs* - Poetry Text - Selah:1:12::1:::::3::::::::::"),
_T("qm::Poetry, left margin::1:::::1:1:poetry margin:2:1:qm - Poetry left margin:0:12:::::::3::::::q:qm:::"),
_T("qm::Poetry text, embedded, level 1 indent (if single level):1::::::1:1:poetry embed:2:1:qm - Poetry - Embedded Text - Indent Level 1 - Single Level Only:0:12:::::::3:::1::-.75:q:qm:::"),
_T("qm1::Poetry text, embedded, level 1 indent (if multiple levels):1::::::1:1:poetry embed L1:2:1:qm1 - Poetry - Embedded Text - Indent Level 1:0:12:::::::3:::1::-.75:qm:qm1:::"),
_T("qm2::Poetry text, embedded, level 2 indent:1::::::1:1:poetry embed L2:2:1:qm2 - Poetry - Embedded Text - Indent Level 2:0:12:::::::3:::1::-.5:qm1:qm2:::"),
_T("qm3::Poetry text, embedded, level 3 indent:1::::::1:1:poetry embed L3:2:1:qm3 - Poetry - Embedded Text - Indent Level 3:0:12:::::::3:::1::-.25:qm2:qm3:::"),
_T("f:f*:A Footnote text item (basic):1:1::1:1:1:1:1:footnote:9::f...f* - Footnote:4:10:::::::0::::::_notes_base:f:::"),
_T("fe::Footnote (end)::1:::::1:::1::fe - Footnote end PNG:1:10:::::::3::::::::::"),
_T("fe:fe*:An Endnote text item:1:::1:1:1:1:1:endnote:9::fe...fe* - Endnote:4:10:::::::0::::::_notes_base:fe:::"),
_T("fr:fr*:The origin reference for the footnote (basic):1::::1:1:1:::9::fr - Footnote - Reference:1:10:::1::::3::::::::::"),
_T("fk:fk*:A footnote keyword (basic):1::::1:1:1:::9::fk - Footnote - Keyword:1:10::1:1::::3::::::::::"),
_T("fq:fq*:A footnote scripture quote or alternate rendering (basic):1::::1:1:1:::9::fq - Footnote - Quotation or Alternate Rendering:1:10:::::::3::::::::::"),
_T("fqa:fqa*:A footnote alternate rendering for a portion of scripture text:1::::1:1:1:::9::fqa - Footnote - Alternate Translation Rendering:1:10::1:::::3::::::::::"),
_T("fl:fl*:A footnote label text item, for marking or 'labelling' the type or alternate translation being provided in the note.:1::::1:1:1:::9::fl - Footnote - Label Text:1:10::1:1::::3::::::::::"),
_T("fp:fp*:A Footnote additional paragraph marker:1::::1:1:1:::9::fp - Footnote Paragraph Mark:1:10:::::::3::::::::::"),
_T("ft:ft*:Footnote text, Protocanon (basic):1::::1:1:1:::9::ft - Footnote - Text:1:10:::::::3::::::::::"),
_T("fdc:fdc*:Footnote text, applies to Deuterocanon only:1::::1:1:1:::9::fdc...fdc* - Footnote - DC text:1:10:::::::3::::::::::"),
_T("fv:fv*:A verse number within the footnote text:1::::1:1::::9::fv...fv* - Footnote - Embedded Verse Number:1:10:::1:::1:3::::::::::"),
_T("fm:fm*:An additional footnote marker location for a previous footnote:1::::1:1::::9::fm - Footnote - Additional Caller to Previous Note:1:10::::::1:3::::::::::"),
_T("F::Footnote (end)::1:::::1:::1::F - Footnote end PNG:1:10:::::::3::::::::::"),
_T("qt:qt*:For Old Testament quoted text appearing in the New Testament (basic):1::::1::1:1:Quotation:1::qt...qt* - Special Text - Quoted Text - OT in NT:1:12::1:::::3::::::::::"),
_T("nd:nd*:For name of deity (basic):1::::1:::::6::nd...nd* - Special Text - Name of Deity:1:12::::1:::3::::::::::"),
_T("tl:tl*:For transliterated words:1::::1:::::6::tl...tl* - Special Text - Transliterated Word:1:12::1:::::3::::::::::"),
_T("dc:dc*:Deuterocanonical/LXX additions or insertions in the Protocanonical text:1::::1:::::6::dc...dc* - Special Text - Deuterocanonical/LXX Additions:1:12::1:::::3::::::::::"),
_T("bk:bk*:For the quoted name of a book:1::::1:::::6::bk...bk* - Special Text - Quoted book title:1:12::1:::::3::::::::::"),
_T("sig:sig*:For the signature of the author of an Epistle:1::::1:::::6::sig...sig* - Special Text - Author's Signature (Epistles):1:12::1:::::3::::::::::"),
_T("pn:pn*:For a proper name:1::::1:::::6::pn...pn* - Special Text - Proper Name:1:12:::1:1:::3::::::::::"),
_T("wj:wj*:For marking the words of Jesus:1::::1:::::1::wj...wj* - Special Text - Words of Jesus:1:12:255::::::3::::::::::"),
_T("k:k*:For a keyword:1::::1:::::6::k...k* - Special Text - Keyword:1:12::1:1::::3::::::::::"),
_T("sls:sls*:To represent where the original text is in a secondary language or from an alternate text source:1::::1:::::1::sls...sls* - Special Text - Secondary Language or Text Source:1:12::1:::::3::::::::::"),
_T("ord:ord*:For the text portion of an ordinal number:1::::1:::::6::ord...ord* - Special Text - Ordinal number text portion:1:12::::::1:3::::::::::"),
_T("add:add*:For a translational addition to the text:1::::1:1:1:1:addl material:0::add...add* - Special Text - Translational Addition:1:12::1:1::::3::::::::::"),
_T("no:no*:A character style, use normal text:1::::1:::::1::no...no* - Character - Normal Text:1:12:::::::3::::::::::"),
_T("bd:bd*:A character style, use bold text:1::::1:::::6::bd...bd* - Character - Bold Text:1:12:::1::::3::::::::::"),
_T("it:it*:A character style, use italic text:1::::1:::::6::it...it* - Character - Italic Text:1:12::1:::::3::::::::::"),
_T("bdit:bdit*:A character style, use bold + italic text:1::::1:::::6::bdit...bdit* - Character - BoldItalic Text:1:12::1:1::::3::::::::::"),
_T("em:em*:A character style, use emphasized text style:1::::1:::::6::em...em* - Character - Emphasized Text:1:12::1:::::3::::::::::"),
_T("sc:sc*:A character style, for small capitalization text:1::::1:::::6::sc...sc* - Character - Small Caps:1:12:::::1::3::::::::::"),
_T("pro:pro*:For indicating pronunciation in CJK texts:1::1:1:1:::::6::pro...pro* - Special Text - CJK Pronunciation:1:10:::::::3::::::::::"),
_T("imt::Introduction main title, level 1 (if single level) (basic):1:::1::1:1:1:intro main title:0:1:imt - Introduction - Major Title Level 1:0:14:::1::::1:8:4::::_intro_base:ip:1:1:"),
_T("imt1::Introduction major title, level 1 (if multiple levels):1:::1::1:1:1:intro major title L1:0:1:imt1 - Introduction - Major Title Level 1:0:14:::1::::1:8:4::::imt:ip:1:1:"),
_T("imt2::Introduction major title, level 2:1:::1::1:1:1:intro major title L2:0:1:imt2 - Introduction - Major Title Level 2:0:13::1:::::1:6:3::::imt1:ip:1:1:"),
_T("imt3::Introduction major title, level 3:1:::1::1:1:1:intro major title L3:0:1:imt3 - Introduction - Major Title Level 3:0:12:::1::::1:2:2::::imt2:ip:1:1:"),
_T("imt4::Introduction major title, level 4 (usually within parenthesis):1:::1::1:1:1:intro major title L4:0:1:imt4 - Introduction - Major Title Level 4:0:12::1:::::1:2:2::::imt3:ip:1:1:"),
_T("imte::Introduction major title at introduction end, level 1 (if single level):1:::1::1:1:1:intro major title at end:0:1:imte - Introduction - [Uncommon] Major Title at Introduction End Level 1:0:20:::1::::1:8:4::::imt:ie:::"),
_T("imte1::Introduction major title at introduction end, level 1 (if multiple levels):1:::1::1:1:1:intro major title at end:0:1:imte1 - Introduction - [Uncommon] Major Title at Introduction End Level 1:0:20:::1::::1:8:4::::imt:ie:::"),
_T("imte2::Introduction major title at introduction end, level 2:1:::1::1:1:1:intro major title at end:0:1:imte2 - Introduction - [Uncommon] Major Title at Introduction End Level 2:0:16::1:::::1:8:4::::imt:ie:::"),
_T("is::Introduction section heading, level 1 (if single level) (basic):1:1::1::1:1:1:intro sect head:0:1:is - Introduction - Section Heading Level 1:0:12:::1::::1:8:4::::s:ip:1:1:"),
_T("is1::Introduction section heading, level 1 (if multiple levels):1:::1::1:1:1:intro sect head L1:0:1:is1 - Introduction - Section Heading Level 1:0:12:::1::::1:8:4::::is:ip:1:1:"),
_T("is2::Introduction section heading, level 2:1:::1::1:1:1:intro sect head L2:0:1:is2 - Introduction - Section Heading Level 2:0:12:::1::::1:8:4::::is1:ip:1:1:"),
_T("ip::Introduction prose paragraph (basic):1:1::1::1:1:1:intro paragraph:0:1:ip - Introduction - Paragraph:0:10:::::::3:::::.125:_intro_base:ip:::"),
_T("ipi::Introduction prose paragraph, indented, with first line indent:1:1::1::1:1:1:intro paragraph indented:0:1:ipi - Introduction - Indented Para - first line indent:0:10:::::::3:::.25:.25:.125:ip:ipi:::"),
_T("ipq::Introduction prose paragraph, quote from the body text:1:::1::1:1:1:intro para quote:0:1:ipq - Introduction - Paragraph - quote from text:0:10::1:::::3:::.25:.25:.125:ip:ipq:::"),
_T("ipr::Introduction prose paragraph, right aligned:1:::1::1:1:1:intro para right align:0:1:ipr - Introduction - Paragraph - right aligned:0:10::1:::::2:::.25:.25::ip:ipr:::"),
_T("iq::Introduction poetry text, level 1 (if single level):1:1::1::1:1:1:intro poetry:0:1:iq - Introduction - Poetry Level 1:0:10::1:::::3:::1::-.75:ip:iq:::"),
_T("iq1::Introduction poetry text, level 1 (if multiple levels):1:::1::1:1:1:intro poetry L1:0:1:iq1 - Introduction - Poetry Level 1:0:10:::::::3:::1::-.75:iq:iq1:::"),
_T("iq2::Introduction poetry text, level 2:1:1::1::1:1:1:intro poetry L2:0:1:iq2 - Introduction - Poetry Level 2:0:10:::::::3:::1::-.5:iq:iq2:::"),
_T("iq3::Introduction poetry text, level 3:1:::1::1:1:1:intro poetry L3:0:1:iq3 - Introduction - Poetry Level 3:0:10:::::::3:::1::-.25:iq:iq3:::"),
_T("im::Introduction prose paragraph, with no first line indent (may occur after poetry):1:1::1::1:1:1:intro para no indent:0:1:im - Introduction - Paragraph - no first line indent:0:10:::::::3::::::ip:im:::"),
_T("imi::Introduction prose paragraph text, indented, with no first line indent:1:1::1::1:1:1:intro para no indent:0:1:imi - Introduction - Indented Para - no first line indent:0:10:::::::3:::.25:.25::ipi:imi:::"),
_T("ili::A list entry, level 1 (if single level):1:::1::1:1:1:intro list L1:0:1:ili - Introduction - List Entry - Level 1:0:12:::::::3:::.625::-.375:_list_base:ili:::"),
_T("ili1::A list entry, level 1 (if multiple levels):1:::1::1:1:1:intro list L1:0:1:ili1 - Introduction - List Entry - Level 1:0:12:::::::3:::.5::-.25:ili:ili1:::"),
_T("ili2::A list entry, level 2:1:::1::1:1:1:intro list L2:0:1:ili2 - Introduction - List Entry - Level 2:0:12:::::::3:::.75::-.25:ili1:ili2:::"),
_T("imq::Introduction prose paragraph, quote from the body text, with no first line indent:1:::1::1:1:1:intro para quote no indent:0:1:imq - Introduction - Paragraph - quote from text - no first line indent:0:10::1:::::3:::.25:.25::imi:imq:::"),
_T("ib::Introduction blank line:1::1:1::1::::0:1:ib - Introduction - Blank Line:0:12:::::::3::::::_intro_base:ib:::"),
_T("iot::Introduction outline title (basic):1:::1::1:1:1:intro outline title:0:1:iot - Introduction - Outline Title:0:12:::1::::1:8:4::::imt:io1:1:1:"),
_T("io::Introduction outline text, level 1 (if single level):1:1::1::1:1:1:intro outline:0:1:io - Introduction - Outline Level 1:0:10:::::::3:::.5:::_intro_base:io:::"),
_T("io1::Introduction outline text, level 1 (if multiple levels) (basic):1:1::1::1:1:1:intro outline L1:0:1:io1 - Introduction - Outline Level 1:0:10:::::::3:::.5:::io:io1:::"),
_T("io2::Introduction outline text, level 2:1:1::1::1:1:1:intro outline L2:0:1:io2 - Introduction - Outline Level 2:0:10:::::::3:::.75:::io1:io2:::"),
_T("io3::Introduction outline text, level 3:1:1::1::1:1:1:intro outline L3:0:1:io3 - Introduction - Outline Level 3:0:10:::::::3:::1:::io2:io3:::"),
_T("io4::Introduction outline text, level 4:1:1::1::1:1:1:intro outline L4:0:1:io4 - Introduction - Outline Level 4:0:10:::::::3:::1.25:::io3:io4:::"),
_T("ior:ior*:Introduction references range for outline entry; for marking references separately:1:::1:1:1::::6::ior...ior* - Introduction - Outline References Range:1:10:::::::3::::::::::"),
_T("iex::Introduction explanatory or bridge text (e.g. explanation of missing book in Short Old Testament):1:::1::1:1:1:intro explain text:0:1:iex - Introduction - Explanatory or Bridge Text:0:10:::::::3:4:4:::.125:ip:iex:::"),
_T("iqt:iqt*:For quoted scripture text appearing in the introduction:1:::1:1:1::::6::iqt...iqt* - Special Text - Quoted Scripture Text in Introduction:1:12::1:::::3::::::::::"),
_T("ie::Introduction ending marker:1::1:::1:1:::0::ie - Introduction - End Marker:8:12:::::::3:12:4:1.5:1.5::_intro_base:ie:::"),
_T("li::A list entry, level 1 (if single level):1::::::1:1:list item:1:1:li - List Entry - Level 1:0:12:::::::0:::.625::-.375:_list_base:li:::"),
_T("li1::A list entry, level 1 (if multiple levels):1::::::1:1:list item L1:1:1:li1 - List Entry - Level 1:0:12:::::::0:::.5::-.25:li:li1:::"),
_T("li2::A list entry, level 2:1::::::1:1:list item L2:1:1:li2 - List Entry - Level 2:0:12:::::::0:::.75::-.25:li1:li2:::"),
_T("li3::A list entry, level 3:1::::::1:1:list item L3:1:1:li3 - List Entry - Level 3:0:12:::::::0:::1::-.25:li2:li3:::"),
_T("li4::A list entry, level 4:1::::::1:1:list item L4:1:1:li4 - List Entry - Level 4:0:12:::::::0:::1.25::-.25:li3:li4:::"),
_T("qh::List or Genealogy::1:::::1:1:list item:1:1:qh - List or Genealogy:0:12:::::::0:::.625::-.375:q:qh:::"),
_T("tr::A new table row:1::::::1:1:table row:1:1:tr - Table - Row:0:12:::::::0:::.5::-.25:_body_text:tr:::"),
_T("tr1::A table Row:1::::::1:1:table row L1:1:1:OBSOLETE tr1 - Table - Row - Level 1:0:12:::::::0:::.5::-.25:tr:tr1:::"),
_T("tr2::A table Row:1::::::1:1:table row L2:1:1:OBSOLETE tr2 - Table - Row - Level 2:0:12:::::::0:::.75::-.25:tr1:tr2:::"),
_T("th1::A table heading, column 1:1::::::1:::1::th1 - Table - Column 1 Heading:1:12::1:::::0::::::::::"),
_T("th2::A table heading, column 2:1::::::1:::1::th2 - Table - Column 2 Heading:1:12::1:::::0::::::::::"),
_T("th3::A table heading, column 3:1::::::1:::1::th3 - Table - Column 3 Heading:1:12::1:::::0::::::::::"),
_T("th4::A table heading, column 4:1::::::1:::1::th4 - Table - Column 4 Heading:1:12::1:::::0::::::::::"),
_T("thr1::A table heading, column 1, right aligned:1::::::1:::1::thr1 - Table - Column 1 Heading - Right Aligned:1:12::1:::::2::::::::::"),
_T("thr2::A table heading, column 2, right aligned:1::::::1:::1::thr2 - Table - Column 2 Heading - Right Aligned:1:12::1:::::2::::::::::"),
_T("thr3::A table heading, column 3, right aligned:1::::::1:::1::thr3 - Table - Column 3 Heading - Right Aligned:1:12::1:::::2::::::::::"),
_T("thr4::A table heading, column 4, right aligned:1::::::1:::1::thr4 - Table - Column 4 Heading - Right Aligned:1:12::1:::::2::::::::::"),
_T("tc1::A table cell item, column 1:1::::::1:::1::tc1 - Table - Column 1 Cell:1:12:::::::0::::::::::"),
_T("tc2::A table cell item, column 2:1::::::1:::1::tc2 - Table - Column 2 Cell:1:12:::::::0::::::::::"),
_T("tc3::A table cell item, column 3:1::::::1:::1::tc3 - Table - Column 3 Cell:1:12:::::::0::::::::::"),
_T("tc4::A table cell item, column 4:1::::::1:::1::tc4 - Table - Column 4 Cell:1:12:::::::0::::::::::"),
_T("tcr1::A table cell item, column 1, right aligned:1::::::1:::1::tcr1 - Table - Column 1 Cell - Right Aligned:1:12:::::::2::::::::::"),
_T("tcr2::A table cell item, column 2, right aligned:1::::::1:::1::tcr2 - Table - Column 2 Cell - Right Aligned:1:12:::::::2::::::::::"),
_T("tcr3::A table cell item, column 3, right aligned:1::::::1:::1::tcr3 - Table - Column 3 Cell - Right Aligned:1:12:::::::2::::::::::"),
_T("tcr4::A table cell item, column 4, right aligned:1::::::1:::1::tcr4 - Table - Column 4 Cell - Right Aligned:1:12:::::::2::::::::::"),
_T("gm::Glossary main entry::1::1::1:1:1:glossary main entry:0:1:gm - Glossary main entry:0:12:::::::3::::::_body_text:gp:::"),
_T("gs::Glossary subentry::1::1::1:1:1:glossary subentry:0:1:gs - Glossary subentry:0:12:::::::3::::::gm:gp:::"),
_T("gd::Glossary definition::1::1:1:1:1:1:glossary definition:0:1:gd - Glossary definition:1:12:::::::3::::::::::"),
_T("gp::Glossary paragraph::1::1::1:1:1:glossary paragraph:0:1:gp - Glossary paragraph:0:12:::::::3::::::_body_text:gp:::"),
_T("tis::Topical index heading (level 1)::1::1:::1:1:topical index L1:0:1:tis - Topical index heading L1:0:12:::::::3::::::_heading_base:tpi:::"),
_T("tpi::Topical index heading (level 2)::1::1:::1:1:topical index L2:0:1:tpi - Topical index heading L2:0:12:::::::3::::::tis:tps:::"),
_T("tps::Topical index heading (level 3)::1::1:::1:1:topical index L3:0:1:tps - Topical index heading L3:0:12:::::::3::::::tpi:tir:::"),
_T("tir::Topical index reference::1::1:::1:1:topical index reference:0:1:tir - Topical index ref:0:12:::::::3::::::_body_text:tir:::"),
_T("w:w*:A wordlist text item:1::::1::1:::6::w...w* - Peripheral Ref - Wordlist Entry:1:12:::::::3::::::::::"),
_T("wr:wr*:A Wordlist text item:1::::1::1:::6::OBSOLETE wr...wr* - Auxiliary - Wordlist/Glossary Reference:1:12::1:::::3::::::::::"),
_T("wh:wh*:A Hebrew wordlist text item:1::::1::1:::6::wh...wh* - Peripheral Ref - Hebrew Wordlist Entry:1:12:::::::3::::::::::"),
_T("wg:wg*:A Greek Wordlist text item:1::::1::1:::6::wg...wg* - Peripheral Ref - Greek Wordlist Entry:1:12:::::::3::::::::::"),
_T("ndx:ndx*:A subject index text item:1::::1::1:::6::ndx...ndx* - Peripheral Ref - Subject Index Entry:1:12:::::::3::::::::::"),
_T("periph::Periheral content division marker which should be followed by an additional division argument/title.:1:::1:::1:1:Periph matter div:0::periph - Peripherals - Content Division Marker:0:14:33023::1::::3:16:4::::_peripherals_base:periph:::"),
_T("p1::Front or back matter text paragraph, level 1 (if multiple levels):1:::::1:1:1:Periph matter para L1:0:1:p1 - Periph - Front/Back Matter Paragraph Level 1:0:12:::::::3:::::.125:_peripherals_base:p1:::"),
_T("p2::Front or back matter text paragraph, level 2 (if multiple levels):1:::1::1:1:1:Periph matter para L2:0:1:p2 - Periph - Front/Back Matter Paragraph Level 2:0:12:::::::3:::.125::.125:_peripherals_base:p2:::"),
_T("k1::Concordance main entry text or keyword, level 1:1:::::1:1:1:conc main entry/keyword L1:0:1:k1 - Periph - Concordance Keyword Level 1:0:12:::::::3::::::_peripherals_base:k1:::"),
_T("k2::Concordance main entry text or keyword, level 2:1:::::1:1:1:conc main entry/keyword L2:0:1:k2 - Periph - Concordance Keyword Level 2:0:12:::::::3::::::_peripherals_base:k2:::"),
_T("xtSee:xtSee*:Concordance and Names Index markup for an alternate entry target reference.:1:::1:::1:::0::xtSee - Concordance and Names Index - Alternate Entry Target Reference:1:12:16711680:1:::::3::::::::::"),
_T("xtSeeAlso:xtSeeAlso*:Concordance and Names Index markup for an additional entry target reference.:1:::1:::1:::0::xtSeeAlso - Concordance and Names Index - Additional Entry Target Reference:1:12:16711680:1:::::3::::::::::"),
_T("pub::Front matter publication data:1:::1:::1:::0::OBSOLETE pub Peripherals - Front Matter Publication Data:0:10:::::::3::::::_peripherals_base:pub:::"),
_T("toc::Front matter table of contents:1:::1:::1:::0::OBSOLETE toc Peripherals - Front Matter Table of Contents:0:10:::::::3::::::_peripherals_base:toc:::"),
_T("toc1::Long table of contents text:1:::1:::1:::0::toc1 - File - Long Table of Contents Text:0:12:16384:1:1::::3::::::_peripherals_base:toc1:::"),
_T("toc2::Short table of contents text:1:::1:::1:::0::toc2 - File - Short Table of Contents Text:0:12:16384:1:::::3::::::_peripherals_base:toc2:::"),
_T("toc3::Book Abbreviation:1:::1:::1:::0::toc3 - File - Book Abbreviation:0:12:128:1:1::::3::::::_peripherals_base:toc3:::"),
_T("pref::Front matter preface:1:::1:::1:::0::OBSOLETE pref Peripherals - Front Matter Preface:0:10:::::::3::::::_peripherals_base:pref:::"),
_T("intro::Front matter introduction:1:::1:::1:::0::OBSOLETE intro Peripherals - Front Matter Introduction:0:10:::::::3::::::_peripherals_base:intro:::"),
_T("conc::Back matter concordance:1:::1:::1:::0::OBSOLETE conc Peripherals - Back Matter Concordance:0:10:::::::3::::::_peripherals_base:conc:::"),
_T("glo::Back matter glossary:1:::1:::1:::0::OBSOLETE glo Peripherals - Back Matter Glossary:0:10:::::::3::::::_peripherals_base:glo:::"),
_T("idx::Back matter index:1:::1:::1:::0::OBSOLETE idx Peripherals - Back Matter Index:0:10:::::::3::::::_peripherals_base:idx:::"),
_T("maps::Back matter map index:1:::1:::1:::0::OBSOLETE maps Peripherals - Back Matter Map Index:0:10:::::::3::::::_peripherals_base:maps:::"),
_T("cov::Other peripheral materials - cover:1:::1:::1:::0::OBSOLETE cov Peripherals - Other - Cover:0:10:::::::3::::::_peripherals_base:cov:::"),
_T("spine::Other peripheral materials - spine:1:::1:::1:::0::OBSOLETE spine Peripherals - Other - Spine:0:10:::::::3::::::_peripherals_base:spine:::"),
_T("pubinfo::Publication information - Lang,Credit,Version,Copies,Publisher,Id,Logo:1:::1:::1:::0::OBSOLETE pubinfo - Publication - Information:0:12:16711680::::::3::::::__normal:pubinfo:::"),
_T("pb::Page Break used for new reader portions and children's bibles where content is controlled by the page:1::::::1:1:new page:0:1:pb - Break - Page Break:0:12:::::::3::::::p:p:::"),
_T("b::Poetry text stanza break (e.g. stanza break) (basic):1::::::1:1:stanza break:2::b - Poetry - Stanza Break (Blank Line):0:12:::::::0::::::_body_text:b:::"),
_T("hr::Horizontal rule::1:1:::1:1:::0::hr - Horizontal rule:8:12:::::::3:4:4::::_body_text:hr:::"),
_T("fig:fig*:Illustration [Columns to span, height, filename, caption text]:1::1:1:1::1:::0::fig...fig* - Auxiliary - Figure/Illustration/Map:1:12:::::::3::::::::::"),
_T("loc::Picture location::1:1::::1:::0::loc - Picture location:0:12:::::::3::::::_body_text:loc:::"),
_T("cap::Picture caption::1:1:1::1:1:1:picture caption:0::cap - Picture caption:0:12:::::::3::::::_body_text:cap:::"),
_T("cat::Picture catalog number::1:1::::1:::0::cat - Picture catalog number:0:12:::::::3::::::_body_text:cat:::"),
_T("des::Picture description::1:1::::1:::0::des - Picture description:0:12:::::::3::::::_body_text:des:::"),
_T("px::Paragraph extra 1::1:::::1:1:para extra 1:1:1:px - Paragraph extra 1:0:12:::::::3::::::p:px:::"),
_T("pz::Paragraph extra 2::1:::::1:1:para extra 2:1:1:pz - Paragraph extra 2:0:12:::::::3::::::p:pz:::"),
_T("qx::Poetry extra 1::1:::::1:1:poetry extra 1:2:1:qx - Poetry extra 1:0:12:::::::3::::::q:qx:::"),
_T("qz::Poetry extra 2::1:::::1:1:poetry extra 2:2:1:qz - Poetry extra 2:0:12:::::::3::::::q:qz:::"),
_T("addpn:addpn*:For chinese words to be dot underline and underline:1::::1::1:::1::(addpn...addpn*) - Special Text for Chinese:1:12::1:1:1:::3::::::::::"),
_T("efm:efm*:ID or Caller for an extended (study) note. Used within a source project duplicte (target) text when autoring study material.:1::1:::1:1:::0::efm - Study Note - ID/Caller:1:10:255::1::::3::::::::::"),
_T("ef:ef*:A Study Note text item:1::1:::1:1:::0::ef...ef* - Study Note:1:12:::::::3::::::::::"),
_T("bt::Back-translation (and all \bt... initial forms):1:1:1:::1::1:back-trans:0::bt - Back-translation:1:11:16711680::::::3::::::::::"),
_T("free:free*:Free translation:1:1:1:::1::1:free-trans:0::free - Free translation:1:11:4194500::::::3::::::::::"),
_T("note:note*:Adapt It note:1:1:1:::1::1:note:0::note - Adapt It note:1:10:16711680::::::3::::::::::"),
_T("__normal::Normal:1:1:1:::::::0::Normal:0:11:::::::3:::::::__normal:::"),
_T("_src_lang_interlinear::Source Language Interlinear Text:1:1:1:::::::0::Source Language:0:11:::::::0::::::__normal:_src_lang_interlinear::1:"),
_T("_tgt_lang_interlinear::Target Language Interlinear Text:1:1:1:::::::0::Target Language:0:11:::::::0::::::__normal:_tgt_lang_interlinear::1:"),
_T("_gls_lang_interlinear::Gloss Language Interlinear Text:1:1:1:::::::0::Gloss Language:0:11:::::::0::::::__normal:_gls_lang_interlinear::1:"),
_T("_nav_lang_interlinear::Navigation Language Interlinear Text:1:1:1:::::::0::Navigation Language:0:11:::::::0::::::__normal:_nav_lang_interlinear::1:"),
_T("_hdr_ftr_interlinear::Header-Footer Interlinear Text:1:1:1:::::::0::Hdr-Ftr Interlinear:7:9:::::::0::::::__normal:_hdr_ftr_interlinear:::"),
_T("_small_para_break::Small Paragraph Break:1:1:1:::::::0::Small Para Break:0:4:::::::3::::::__normal:_small_para_break:::"),
_T("_body_text::Body Text:1:1:1:::::::0::_BodyText_Base:0:11:::::::3::::::_vernacular_base:_body_text:::"),
_T("_heading_base::Heading Base:1:1:1:::1::::0::_Heading_Base:0:12:::::::1:6::.1:.1::_vernacular_base:_heading_base:1:1:"),
_T("_intro_base::Intro Base:1:1:1:::1::::0::_Intro_Base:0:11::1:::::3::::::_vernacular_base:_intro_base:::"),
_T("_list_base::List Base:1:1:1:::1::::0::_List_Base:0:12:::::::3::::::_vernacular_base:_list_base:::"),
_T("_notes_base::Notes Base:1:1:1:::1::::0::_Notes_Base:0:9:::::::0::::::_vernacular_base:_notes_base:::"),
_T("_peripherals_base::Peripherals Base:1:1:1:::1::::0::_Peripherals_Base:0:10:::::::3::::::_vernacular_base:_peripherals_base:::"),
_T("_vernacular_base::Vernacular Base:1:1:1:::::::0::_Vernacular_Base:0:11:::::::3::::::__normal:_vernacular_base:::"),
_T("_annotation_ref::Annotation Reference:1:1:1:::::::0::_annotation_reference:1:10:4210943:::::1:0::::::::::"),
_T("_annotation_text::Annotation Text:1:1:1:::::::0::_annotation_text:0:10:::::::0::::::__normal:_annotation_text:::"),
_T("_dft_para_font::Default Paragraph Font:1:1:1:::::::0::Default Paragraph Font:5:10:::::::3::::::::::"),
_T("_footnote_caller::Footnote Caller:1:1:1:::::::0::Footnote Caller:3:10:16711680:::::1:3::::::::::"),
_T("_normal_table::Normal Table:1:1:1:::::::0::Normal Table:2:10:::::::0:::::::_normal_table:::"),
_T("_table_grid::Table Grid:1:1:1:::::::0::Table Grid:2:10:::::::0::::::_normal_table:_table_grid:::"),
_T("_footer::Footer:1:1:1:::::::0::footer:6:10:::::::0::::::_body_text:_footer:::"),
_T("_header::Header:1:1:1:::::::0::header:7:9:::::::0::::::_body_text:_header:::"),
_T("_horiz_rule::Horizontal Rule:1:1:1:::::::0::Horizontal rule:8:10:::::::3:::::::_horiz_rule:::"),
_T("_single_boxed_para::Single Boxed Paragraph:1:1:1:::::::0::Single Boxed Paragraph:9:10:::::::3::::::__normal:_single_boxed_para:::"),
_T("_double_boxed_para::Double Boxed Paragraph:1:1:1:::::::0::Double Boxed Paragraph:9:10:::::::3::::::__normal:_double_boxed_para:::"),
_T("_unknown_para_style::Unknown Paragraph Style Marker:1:1:1:::::::0::Unknown Para Style Marker:0:12:255::::::0::::::_body_text:_unknown_para_style:::"),
_T("_unknown_char_style::Unknown Character Style Marker:1:1:1:::::::0::Unknown Char Style Marker:1:12:255::::::0::::::::::"),
_T("_hidden_note::Hidden Note:1:1:1:::::::0::Hidden Note:10:10:8388608:1:::::3:2::::.3:p:_hidden_note:::")
};

/// The actual count of default Unix-style strings contained in the defaultSFM string
/// array. This number is calculated dynamically here, but is also calculated by
/// uncommenting the #define Output_Default_Style_Strings line at the beginning of XML.h
/// file (see instructions in documentation for the defaultSFM[] string array). The number
/// is automatically produced as the last line of string output written to AI_USFM_full.txt
/// file when Output_Default_Style_Strings is defined in XML.h.
const int gnDefaultSFMs = sizeof(defaultSFM)/sizeof(wxString); // In version 4.1.3 the
			// gnDefaultSFMs value is 283, but it will change as UBS adds markers to USFM

// whm added 10Sep10
/// An array of wxStrings which, when parsed by SetupDefaultUserProfiles(), is used as
/// default list of User Workflow Profile dialog item definitions. There definitions are
/// used only if, for some reason, the program cannot find the AI_UserProfiles.xml control
/// file.
const wxString defaultProfileItems[] =
{
	// Note: In the strings below, the itemText field must use the & ALT-key shortcut as well as the
	// accelerator substrings, i.e., \tCtrl-A. However, since this is not xml, we don't use any
	// xml "entities", i.e., &amp; &lt; or &gt; for '&', '<' and '>' within the itemText strings.
	// Since the descriptionProfileN strings are administrator editable, it is possible that an administrator
	// might edit into the string one of the entity characters '<', '>', '&', ''', or '"'. While these
	// strings are internal within the program we retain their character representations in order to
	// facilitate accurate comparisons of the descriptionProfileN strings. When the descriptionProfileN
	// string data is about to be written to xml, however, we replace the entitity chars with their xml
	// entity representations.
	//
	// The ReportMenuAndUserProfilesInconsistencies() function compares the data
	// stored in the m_pUserProfiles struct on the heap with those that are used in the
	// defaultProfileItems string array below. It uses wxLogDebug() calls and even an assert
	// in some cases to alert the programmer of any significant differences/inconsistencies.
	//
	// whm 6Jan12 Note: Changed the version number in the first string of the defaultProfileItems[]
	// array below to use the appVerStr constant defined near the beginning of the Adapt_It.h file.
	_T("UserProfilesSupport:profileVersion=\"1.0\":applicationCompatibility=\"") + appVerStr + _T("\":adminModified=\"No\"")
		_T(":definedProfile1=\"Novice\":descriptionProfile1=\"The Novice profile hides most of the menu items and other interface items that are not needed for basic adaptation work. The default Novice profile can be further customized to suit the preferences of the administrator.\"")
		_T(":definedProfile2=\"Experienced\":descriptionProfile2=\"The Experienced profile hides a number of menu items, but makes visible consistency checking, restoring the KB, packing/unpacking of documents and all export possibilities. The default Experienced profile can be further customized to suit the preferences of the administrator.\"")
		_T(":definedProfile3=\"Skilled\":descriptionProfile3=\"The Skilled profile hides a few menu items, but makes visible all the Experienced user items plus free translation mode, glossing mode, editing of the source text, and all the Preferences tab pages. The default Skilled profile can be further customized to suit the preferences of the administrator.\"")
		_T(":definedProfile4=\"Custom\":descriptionProfile4=\"The Custom profile can use one of the other profiles as a starting point and further customize the Custom profile to suit the preferences of the administrator.\":"),
	_T("MENU:itemID=\"ID_SAVE_AS\":itemType=\"subMenu\":itemText=\"Save &As...\tCtrl-A\":itemDescr=\"File menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_FILE_PACK_DOC\":itemType=\"subMenu\":itemText=\"Pack Document...\":itemDescr=\"File menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_FILE_UNPACK_DOC\":itemType=\"subMenu\":itemText=\"Unpack Document...\":itemDescr=\"File menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_FILE_CHANGEFOLDER\":itemType=\"subMenu\":itemText=\"Change Folder...\":itemDescr=\"File menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_FILE_BACKUP_KB\":itemType=\"subMenu\":itemText=\"&Backup Knowledge Base\":itemDescr=\"File menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_EDIT_SOURCE_TEXT\":itemType=\"subMenu\":itemText=\"Edit &Source Text...\tCtrl-Q\":itemDescr=\"Edit menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_EDIT_CONSISTENCY_CHECK\":itemType=\"subMenu\":itemText=\"Consist&ency Check...\":itemDescr=\"Edit menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_EDIT_MOVE_NOTE_FORWARD\":itemType=\"subMenu\":itemText=\"Move Note Forward\tCtrl-3\":itemDescr=\"Edit menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_EDIT_MOVE_NOTE_BACKWARD\":itemType=\"subMenu\":itemText=\"Move Note Backward\tCtrl-2\":itemDescr=\"Edit menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_VIEW_TOOLBAR\":itemType=\"subMenu\":itemText=\"&Toolbar\":itemDescr=\"View menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_VIEW_MODE_BAR\":itemType=\"subMenu\":itemText=\"&Mode Bar\":itemDescr=\"View menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_VIEW_STATUS_BAR\":itemType=\"subMenu\":itemText=\"&Status Bar\":itemDescr=\"View menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_COPY_SOURCE\":itemType=\"subMenu\":itemText=\"Copy Sourc&e\":itemDescr=\"View menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_MARKER_WRAPS_STRIP\":itemType=\"subMenu\":itemText=\"&Wrap At Standard Format Markers\":itemDescr=\"View menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_UNITS\":itemType=\"subMenu\":itemText=\"&Units of Measurement...\":itemDescr=\"View menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_CHANGE_INTERFACE_LANGUAGE\":itemType=\"subMenu\":itemText=\"Change Interface Language...\":itemDescr=\"View menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"wxID_REPLACE\":itemType=\"subMenu\":itemText=\"Find and &Replace...\tCtrl-H\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_TOOLS_DEFINE_CC\":itemType=\"subMenu\":itemText=\"&Load Consistent Changes...\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_UNLOAD_CC_TABLES\":itemType=\"subMenu\":itemText=\"&Unload Consistent Changes\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_USE_CC\":itemType=\"subMenu\":itemText=\"Use &Consistent Changes\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ACCEPT_CHANGES\":itemType=\"subMenu\":itemText=\"&Accept Changes Without Stopping\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_TOOLS_DEFINE_SILCONVERTER\":itemType=\"subMenu\":itemText=\"&SIL Converters...\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_USE_SILCONVERTER\":itemType=\"subMenu\":itemText=\"Use S&IL Converter\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_TOOLS_KB_EDITOR\":itemType=\"subMenu\":itemText=\"&Knowledge Base Editor...\tCtrl-K\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_TOOLS_AUTO_CAPITALIZATION\":itemType=\"subMenu\":itemText=\"Use Automatic Capitalization\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_TOOLS_SPLIT_DOC\":itemType=\"subMenu\":itemText=\"Split Document...\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_TOOLS_JOIN_DOCS\":itemType=\"subMenu\":itemText=\"Join Documents...\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_TOOLS_MOVE_DOC\":itemType=\"subMenu\":itemText=\"Move Document...\":itemDescr=\"Tools menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_FILE_EXPORT_SOURCE\":itemType=\"subMenu\":itemText=\"Export &Source Text...\":itemDescr=\"Export-Import menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_FILE_EXPORT\":itemType=\"subMenu\":itemText=\"&Export Translation Text...\":itemDescr=\"Export-Import menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_FILE_EXPORT_TO_RTF\":itemType=\"subMenu\":itemText=\"Export Interlinear &Text...\":itemDescr=\"Export-Import menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_EXPORT_GLOSSES\":itemType=\"subMenu\":itemText=\"Export &Glosses As Text...\":itemDescr=\"Export-Import menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_EXPORT_FREE_TRANS\":itemType=\"subMenu\":itemText=\"Export Free Translation...\":itemDescr=\"Export-Import menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	// whm commented out 15Jun11 as per Bruce's request. OXES support not implemented until a future date
	//_T("MENU:itemID=\"ID_EXPORT_OXES\":itemType=\"subMenu\":itemText=\"Export &Open XML for Editing Scripture (OXES)...\":itemDescr=\"Export-Import menu\":adminCanChange=\"1\":"),
	//_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	//_T("/PROFILE:"),
	//_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	//_T("/PROFILE:"),
	//_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	//_T("/PROFILE:"),
	//_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	//_T("/PROFILE:"),
	//_T("/MENU:"),
	_T("MENU:itemID=\"ID_FILE_EXPORT_KB\":itemType=\"subMenu\":itemText=\"Export Knowledge &Base...\":itemDescr=\"Export-Import menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_IMPORT_TO_KB\":itemType=\"subMenu\":itemText=\"&Import to Knowledge Base...\":itemDescr=\"Export-Import menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_MENU_IMPORT_EDITED_SOURCE_TEXT\":itemType=\"subMenu\":itemText=\"Import Edited Source Text...\":itemDescr=\"Export-Import menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_SEE_GLOSSES\":itemType=\"subMenu\":itemText=\"See Glosses\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_GLOSSING_USES_NAV_FONT\":itemType=\"subMenu\":itemText=\"Glossing Uses Navigation Text's Font\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_TRANSFORM_ADAPTATIONS_INTO_GLOSSES\":itemType=\"subMenu\":itemText=\"Transform Adaptations Into Glosses...\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_DELAY\":itemType=\"subMenu\":itemText=\"Delay...\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_BOOKMODE\":itemType=\"subMenu\":itemText=\"Storing Documents in Book Folders\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_FREE_TRANSLATION_MODE\":itemType=\"subMenu\":itemText=\"Free Translation Mode\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_TARGET_TEXT_IS_DEFAULT\":itemType=\"subMenu\":itemText=\"Use Target Text As Default Free Translation\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT\":itemType=\"subMenu\":itemText=\"Use Gloss Text As Default Free Translation\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_REMOVE_FILTERED_FREE_TRANSLATIONS\":itemType=\"subMenu\":itemText=\"Remove Free Translations\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_COLLECT_BACKTRANSLATIONS\":itemType=\"subMenu\":itemText=\"Collect Back Translations...\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_REMOVE_FILTERED_BACKTRANSLATIONS\":itemType=\"subMenu\":itemText=\"Remove Back Translations\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_USETRANSLITERATIONMODE\":itemType=\"subMenu\":itemText=\"Use Transliteration Mode\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_SENDSYNCHRONIZEDSCROLLINGMESSAGES\":itemType=\"subMenu\":itemText=\"Send Synchronized Scrolling Messages\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ADVANCED_RECEIVESYNCHRONIZEDSCROLLINGMESSAGES\":itemType=\"subMenu\":itemText=\"Receive Synchronized Scrolling Messages\":itemDescr=\"Advanced menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_ALIGNMENT\":itemType=\"subMenu\":itemText=\"Layout Window Right To Left\tCtrl-1\":itemDescr=\"Layout menu\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_NONE\":itemType=\"preferencesTab\":itemText=\"Fonts\":itemDescr=\"Tab in Preferences dialog\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_NONE\":itemType=\"preferencesTab\":itemText=\"Backups and Misc\":itemDescr=\"Tab in Preferences dialog\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_NONE\":itemType=\"preferencesTab\":itemText=\"Auto-Saving\":itemDescr=\"Tab in Preferences dialog\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_NONE\":itemType=\"preferencesTab\":itemText=\"Punctuation\":itemDescr=\"Tab in Preferences dialog\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_NONE\":itemType=\"preferencesTab\":itemText=\"Case\":itemDescr=\"Tab in Preferences dialog\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_NONE\":itemType=\"preferencesTab\":itemText=\"Units\":itemDescr=\"Tab in Preferences dialog\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_NONE\":itemType=\"preferencesTab\":itemText=\"USFM and Filtering\":itemDescr=\"Tab in Preferences dialog\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"IDC_CHECK_SINGLE_STEP\":itemType=\"modeBar\":itemText=\"Automatic\":itemDescr=\"Checkbox in Modebar\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"IDC_CHECK_FORCE_ASK\":itemType=\"modeBar\":itemText=\"Force Choice For This Item\":itemDescr=\"Checkbox in Modebar\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"IDC_EDIT_DELAY\":itemType=\"modeBar\":itemText=\"Delay\":itemDescr=\"Text box in mode bar\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"IDC_CHECK_ISGLOSSING\":itemType=\"modeBar\":itemText=\"Glossing\":itemDescr=\"Checkbox in Modebar\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_BUTTON_DELETE_ALL_NOTES\":itemType=\"toolBar\":itemText=\"Delete All Notes\":itemDescr=\"Delete all the notes currently in the document\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_EDIT_CUT\":itemType=\"toolBar\":itemText=\"Cu&t\tCtrl-X\":itemDescr=\"Cut the selection and put it on the Clipboard\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_EDIT_COPY\":itemType=\"toolBar\":itemText=\"&Copy\tCtrl-C\":itemDescr=\"Copy the selection and put it on the Clipboard\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_EDIT_PASTE\":itemType=\"toolBar\":itemText=\"&Paste\tCtrl-V\":itemDescr=\"Insert Clipboard contents\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"wxID_PRINT\":itemType=\"toolBar\":itemText=\"&Print...\tCtrl-P\":itemDescr=\"Print the active document\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"wxID_HELP\":itemType=\"toolBar\":itemText=\"&Help Topics\tShift-Ctrl-/\":itemDescr=\"Display Adapt It program help topics\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("MENU:itemID=\"ID_NONE\":itemType=\"wizardListItem\":itemText=\"<New Project>\":itemDescr=\"First List Item in Choose A Project page of Wizard\":adminCanChange=\"1\":"),
	_T("PROFILE:userProfile=\"Novice\":itemVisibility=\"0\":factory=\"0\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Experienced\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Skilled\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("PROFILE:userProfile=\"Custom\":itemVisibility=\"1\":factory=\"1\":"),
	_T("/PROFILE:"),
	_T("/MENU:"),
	_T("/UserProfilesSupport:")
};

// whm 26Apr11added wxString arrays below for AI-PT collaboration
// Array of all book ids. (from Paratext's canon.cs source file)
wxString AllBookIds[] = {
    _T("GEN"),
    _T("EXO"),
    _T("LEV"),
    _T("NUM"),
    _T("DEU"),
    _T("JOS"),
    _T("JDG"),
    _T("RUT"),
    _T("1SA"),
    _T("2SA"), // 10

    _T("1KI"),
    _T("2KI"),
    _T("1CH"),
    _T("2CH"),
    _T("EZR"),
    _T("NEH"),
    _T("EST"),
    _T("JOB"),
    _T("PSA"),
    _T("PRO"), // 20

    _T("ECC"),
    _T("SNG"),
    _T("ISA"),
    _T("JER"),
    _T("LAM"),
    _T("EZK"),
    _T("DAN"),
    _T("HOS"),
    _T("JOL"),
    _T("AMO"), // 30

    _T("OBA"),
    _T("JON"),
    _T("MIC"),
    _T("NAM"),
    _T("HAB"),
    _T("ZEP"),
    _T("HAG"),
    _T("ZEC"),
    _T("MAL"),
    _T("MAT"), // 40

    _T("MRK"),
    _T("LUK"),
    _T("JHN"),
    _T("ACT"),
    _T("ROM"),
    _T("1CO"),
    _T("2CO"),
    _T("GAL"),
    _T("EPH"),
    _T("PHP"), // 50

    _T("COL"),
    _T("1TH"),
    _T("2TH"),
    _T("1TI"),
    _T("2TI"),
    _T("TIT"),
    _T("PHM"),
    _T("HEB"),
    _T("JAS"),
    _T("1PE"), // 60

    _T("2PE"),
    _T("1JN"),
    _T("2JN"),
    _T("3JN"),
    _T("JUD"),
    _T("REV"),
    _T("TOB"),
    _T("JDT"),
    _T("ESG"),
    _T("WIS"), // 70

    _T("SIR"),
    _T("BAR"),
    _T("LJE"),
    _T("S3Y"),
    _T("SUS"),
    _T("BEL"),
    _T("1MA"),
    _T("2MA"),
    _T("3MA"),
    _T("4MA"), // 80

    _T("1ES"),
    _T("2ES"),
    _T("MAN"),
    _T("PS2"),
    _T("ODA"),
    _T("PSS"),
    _T("JSA"),  // actual variant text for JOS, now in LXA text
    _T("JDB"),  // actual variant text for JDG, now in LXA text
    _T("TBS"),  // actual variant text for TOB, now in LXA text
    _T("SST"),  // actual variant text for SUS, now in LXA text // 90

    _T("DNT"),  // actual variant text for DAN, now in LXA text
    _T("BLT"),  // actual variant text for BEL, now in LXA text
	_T("XXA"),
	_T("XXB"),
	_T("XXC"),
	_T("XXD"),
	_T("XXE"),
	_T("XXF"),
	_T("XXG"),
	_T("FRT"), // 100

	_T("BAK"),
	_T("OTH"),
    _T("3ES"),   // Used previously but really should be 2ES
    _T("EZA"),   // Used to be called 4ES, but not actually in any known project
    _T("5EZ"),   // Used to be called 5ES, but not actually in any known project
    _T("6EZ"),   // Used to be called 6ES, but not actually in any known project
	_T("INT"),
	_T("CNC"),
	_T("GLO"),
	_T("TDX"), // 110

	_T("NDX"),
    _T("DAG"),
    _T("PS3"),
    _T("2BA"),
    _T("LBA"),
    _T("JUB"),
    _T("ENO"),
    _T("1MQ"),
    _T("2MQ"),
    _T("3MQ"), // 120

    _T("REP"),
    _T("4BA"),
    _T("LAO"),
};


// Array of the English names of all books - from Paratext source canon.cs
wxString AllBookNames[] = {
    _("Genesis"),
    _("Exodus"),
    _("Leviticus"),
    _("Numbers"),
    _("Deuteronomy"),
    _("Joshua"),
    _("Judges"),
    _("Ruth"),
    _("1 Samuel"),
    _("2 Samuel"),

    _("1 Kings"),
    _("2 Kings"),
    _("1 Chronicles"),
    _("2 Chronicles"),
    _("Ezra"),
    _("Nehemiah"),
    _("Esther (Hebrew)"),
    _("Job"),
    _("Psalms"),
    _("Proverbs"),

    _("Ecclesiastes"),
    _("Song of Songs"),
    _("Isaiah"),
    _("Jeremiah"),
    _("Lamentations"),
    _("Ezekiel"),
    _("Daniel (Hebrew)"),
    _("Hosea"),
    _("Joel"),
    _("Amos"),

	_("Obadiah"),
    _("Jonah"),
    _("Micah"),
    _("Nahum"),
    _("Habakkuk"),
    _("Zephaniah"),
    _("Haggai"),
    _("Zechariah"),
    _("Malachi"),
    _("Matthew"),

	_("Mark"),
    _("Luke"),
    _("John"),
    _("Acts"),
    _("Romans"),
    _("1 Corinthians"),
    _("2 Corinthians"),
    _("Galatians"),
    _("Ephesians"),
    _("Philippians"),

	_("Colossians"),
    _("1 Thessalonians"),
    _("2 Thessalonians"),
    _("1 Timothy"),
    _("2 Timothy"),
    _("Titus"),
    _("Philemon"),
    _("Hebrews"),
    _("James"),
    _("1 Peter"),

	_("2 Peter"),
    _("1 John"),
    _("2 John"),
    _("3 John"),
    _("Jude"),
    _("Revelation"),
    _T("Tobit"),
    _T("Judith"),
    _T("Esther Greek"),
    _T("Wisdom of Solomon"),

	_T("Sirach (Ecclesiasticus)"),
    _T("Baruch"),
    _T("Letter of Jeremiah"),
    _T("Song of 3 Young Men"),
    _T("Susanna"),
    _T("Bel and the Dragon"),
    _T("1 Maccabees"),
    _T("2 Maccabees"),
    _T("3 Maccabees"),
    _T("4 Maccabees"),

	_T("1 Esdras (Greek)"),
    _T("2 Esdras (Latin)"),
    _T("Prayer of Manasseh"),
    _T("Psalm 151"),
    _T("Odes"),
    _T("Psalms of Solomon"),
    _T("Joshua A. *obsolete*"),
    _T("Judges B. *obsolete*"),
    _T("Tobit S. *obsolete*"),
    _T("Susanna Th. *obsolete*"),

    _T("Daniel Th. *obsolete*"),
    _T("Bel Th. *obsolete*"),
	_T("Extra A"),
	_T("Extra B"),
	_T("Extra C"),
	_T("Extra D"),
	_T("Extra E"),
	_T("Extra F"),
	_T("Extra G"),
	_T("Front Matter"),

	_T("Back Matter"),
	_T("Other Matter"),
    _T("3 Ezra *obsolete*"),
    _T("Apocalypse of Ezra"),
    _T("5 Ezra"),
    _T("6 Ezra"),
	_T("Introduction"),
	_T("Concordance "),
	_T("Glossary "),
	_T("Topical Index"),

	_T("Names Index"),
    _T("Daniel Greek"),
    _T("Psalms 152-155"),
    _T("2 Baruch (Apocalypse)"),
    _T("Letter of Baruch"),
    _T("Jubilees"),
    _T("Enoch"),
    _T("1 Meqabyan"),
    _T("2 Meqabyan"),
    _T("3 Meqabyan"),
    _T("Reproof"),

    _T("4 Baruch"),
    _T("Laodiceans")
};

/*
// whm removed since the app now gets its default menu structure from a temporary
// instance of the wxDesigner's AIMenuBarFunc().
//
// Note: An array of top level menu names is available from the App's GetToopLevelMenuName()
// function.

// whm added 10Sep10
/// An array of wxStrings which, when parsed by ParseMenuStructureStrings(), is used as
/// default list of User Workflow Profile dialog item definitions. There definitions are
/// used only if, for some reason, the program cannot find the AI_UserProfiles.xml control
/// file. Note: This menu structure is complete - it also includes the "Administrator"
/// menu items which are not included in the AI_UserProfiles.xml file.
const wxString defaultMenuStructure[] =
{
	// Note: In the strings below, the attribute fields should be identical to what the normal default
	// strings are that are used within the AIMenuBarFunc() produced by wxDesigner. Hence, the subMenuID
	// field should contain the exact menu item identifiers; the subMenuLabel should contain the exact
	// menu label strings - including any accelerators (i.e., "\tCtrl-A") and ampersands preceding the
	// short cut ALT+key letters; the subMenuHelp should be the same as what is in wxDesigner; and the
	// subMenuKind should accurately indicate whether the menu item is wxITEM_NORMAL, wxITEM_CHECK
	// or wxITEM_SEPARATOR. Cut and paste of strings from the AIMenuBarFunc() in Adapt_It_wdr.cpp helps
	// ensure exact copy - but Note: quote marks here need to be escaped with a backslash!
	//
	// The ReportMenuAndUserProfilesInconsistencies() function compares the data
	// stored in the m_pAI_MenuStructure struct on the heap with those that are used in the
	// defaultMenuStructure string array below. It uses wxLogDebug() calls to alert the
	// programmer of any significant differences/inconsistencies.
	_T("MENU_STRUCTURE:"),
	_T("MAIN_MENU:mainMenuID=\"ID_FILE_MENU\":mainMenuLabel=\"&File\":"),
	_T("SUB_MENU:subMenuID=\"wxID_NEW\":subMenuLabel=\"&New\\tCtrl-N\":subMenuHelp=\"Create a new document\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_OPEN\":subMenuLabel=\"&Open...\\tCtrl-O\":subMenuHelp=\"Open an existing document\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_SAVE\":subMenuLabel=\"&Save\\tCtrl-S\":subMenuHelp=\"Save the active document\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_SAVE_AS\":subMenuLabel=\"Save &As...\\tCtrl-A\":subMenuHelp=\"Save the document with different xml format, or different filename\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_CLOSE\":subMenuLabel=\"&Close\":subMenuHelp=\"Close the active document\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_PACK_DOC\":subMenuLabel=\"Pack Document...\":subMenuHelp=\"Pack document for transfer to another computer\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_UNPACK_DOC\":subMenuLabel=\"Unpack Document...\":subMenuHelp=\"Unpack a document that was packed on another computer\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_PRINT\":subMenuLabel=\"&Print...\\tCtrl-P\":subMenuHelp=\"Print the active document\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_PREVIEW\":subMenuLabel=\"Print Pre&view\":subMenuHelp=\"Show what printed pages will look like (without printing)\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_PAGE_SETUP\":subMenuLabel=\"P&age Setup...\":subMenuHelp=\"Change the printing options\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_STARTUP_WIZARD\":subMenuLabel=\"Start &Working...\\tCtrl-W\":subMenuHelp=\"Show the sequence of dialog windows used for accessing a project and working on documents\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_CLOSEKB\":subMenuLabel=\"Close Pro&ject\\tCtrl-J\":subMenuHelp=\"Save the knowledge base and document, then close this project\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_CHANGEFOLDER\":subMenuLabel=\"Change Folder...\":subMenuHelp=\"Change to a different book folder for document storage (book mode must be ON)\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_SAVEKB\":subMenuLabel=\"Save &Knowledge Base\":subMenuHelp=\"Update the knowledge base file for this project\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_BACKUP_KB\":subMenuLabel=\"&Backup Knowledge Base\":subMenuHelp=\"Make a new knowledge base backup immediately\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_RESTORE_KB\":subMenuLabel=\"&Restore Knowledge Base...\":subMenuHelp=\"Use all the saved documents to rebuild the knowledge base file\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_EXIT\":subMenuLabel=\"E&xit\":subMenuHelp=\"Quit the application; prompts to save documents\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("/MAIN_MENU:"),
	_T("MAIN_MENU:mainMenuID=\"ID_EDIT_MENU\":mainMenuLabel=\"&Edit\":"),
	_T("SUB_MENU:subMenuID=\"wxID_UNDO\":subMenuLabel=\"&Undo\\tCtrl-Z\":subMenuHelp=\"Undo the last action\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EDIT_CUT\":subMenuLabel=\"Cu&t\\tCtrl-X\":subMenuHelp=\"Cut the selection and put it on the Clipboard\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EDIT_COPY\":subMenuLabel=\"&Copy\\tCtrl-C\":subMenuHelp=\"Copy the selection and put it on the Clipboard\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EDIT_PASTE\":subMenuLabel=\"&Paste\\tCtrl-V\":subMenuHelp=\"Insert Clipboard contents\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_GO_TO\":subMenuLabel=\"&Go To...\\tCtrl-G\":subMenuHelp=\"Go to a specific chapter and verse\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EDIT_SOURCE_TEXT\":subMenuLabel=\"Edit &Source Text...\\tCtrl-Q\":subMenuHelp=\"Edit the selected source text\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EDIT_CONSISTENCY_CHECK\":subMenuLabel=\"Consist&ency Check...\":subMenuHelp=\"Check all translations with those in the knowledge base for consistency\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EDIT_MOVE_NOTE_FORWARD\":subMenuLabel=\"Move Note Forward\\tCtrl-3\":subMenuHelp=\"Move the note forward in the document to the next word or phrase\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EDIT_MOVE_NOTE_BACKWARD\":subMenuLabel=\"Move Note Backward\\tCtrl-2\":subMenuHelp=\"Move the note backward in the document to the previous word or phrase\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_PREFERENCES\":subMenuLabel=\"Pre&ferences...\":subMenuHelp=\"Adapt It settings\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("/MAIN_MENU:"),
	_T("MAIN_MENU:mainMenuID=\"ID_VIEW_MENU\":mainMenuLabel=\"&View\":"),
	_T("SUB_MENU:subMenuID=\"ID_VIEW_TOOLBAR\":subMenuLabel=\"&Toolbar\":subMenuHelp=\"Show or hide the toolbar\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_VIEW_STATUS_BAR\":subMenuLabel=\"&Status Bar\":subMenuHelp=\"Show or hide the status bar\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_VIEW_COMPOSE_BAR\":subMenuLabel=\"&Compose Bar\":subMenuHelp=\"Show or hide the bar for composing text\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_COPY_SOURCE\":subMenuLabel=\"Copy Sourc&e\":subMenuHelp=\"Copy source text to phrase box as default translation\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_MARKER_WRAPS_STRIP\":subMenuLabel=\"&Wrap At Standard Format Markers\":subMenuHelp=\"Start a new strip whenever a standard format marker is encountered\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_UNITS\":subMenuLabel=\"&Units of Measurement...\":subMenuHelp=\"Units to be used when printing\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_CHANGE_INTERFACE_LANGUAGE\":subMenuLabel=\"Change Interface Language...\":subMenuHelp=\"Change the language of the program interface. You may need to restart Adapt It for the change to take effect\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("/MAIN_MENU:"),
	_T("MAIN_MENU:mainMenuID=\"ID_TOOLS_MENU\":mainMenuLabel=\"&Tools\":"),
	_T("SUB_MENU:subMenuID=\"wxID_FIND\":subMenuLabel=\"&Find...\\tCtrl-F\":subMenuHelp=\"Find text in source or target or both, or special search\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_REPLACE\":subMenuLabel=\"Find and &Replace...\\tCtrl-H\":subMenuHelp=\"Replace in target text\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_TOOLS_DEFINE_CC\":subMenuLabel=\"&Load Consistent Changes...\":subMenuHelp=\"Define and load one or more consistent changes tables\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_UNLOAD_CC_TABLES\":subMenuLabel=\"&Unload Consistent Changes\":subMenuHelp=\"Unload any loaded consistent changes tables\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_USE_CC\":subMenuLabel=\"Use &Consistent Changes\":subMenuHelp=\"Use the consistent changes when copying source text\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ACCEPT_CHANGES\":subMenuLabel=\"&Accept Changes Without Stopping\":subMenuHelp=\"Accept the changed source text as the translation and continue on\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_TOOLS_DEFINE_SILCONVERTER\":subMenuLabel=\"&SIL Converters...\":subMenuHelp=\"Load an SIL Converter\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_USE_SILCONVERTER\":subMenuLabel=\"Use S&IL Converter\":subMenuHelp=\"Use a loaded SIL Converter\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_TOOLS_KB_EDITOR\":subMenuLabel=\"&Knowledge Base Editor...\\tCtrl-K\":subMenuHelp=\"Display dialog for editing the knowledge base\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_TOOLS_AUTO_CAPITALIZATION\":subMenuLabel=\"Use Automatic Capitalization\":subMenuHelp=\"Use automatic capitalization when copying source text\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_RETRANS_REPORT\":subMenuLabel=\"Re&translation Report...\":subMenuHelp=\"Output a file listing all retranslations\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_TOOLS_SPLIT_DOC\":subMenuLabel=\"Split Document...\":subMenuHelp=\"Split the document into two or more documents\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_TOOLS_JOIN_DOCS\":subMenuLabel=\"Join Documents...\":subMenuHelp=\"Join two or more documents into a single document\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_TOOLS_MOVE_DOC\":subMenuLabel=\"Move Document...\":subMenuHelp=\"Move documents between the Adaptations folder and a book folder location\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("/MAIN_MENU:"),
	_T("MAIN_MENU:mainMenuID=\"ID_EXPORT_IMPORT_MENU\":mainMenuLabel=\"E&xport-Import\":"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_EXPORT_SOURCE\":subMenuLabel=\"Export &Source Text...\":subMenuHelp=\"Export the source language text as a *.txt file type\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_EXPORT\":subMenuLabel=\"&Export Translation Text...\":subMenuHelp=\"Export the target language translation as a *.txt file type\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_EXPORT_TO_RTF\":subMenuLabel=\"Export Interlinear &Text...\":subMenuHelp=\"Export the Source and Target languages in interlinear form as an *.rtf file type\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EXPORT_GLOSSES\":subMenuLabel=\"Export &Glosses As Text...\":subMenuHelp=\"Export the glossing lines' contents as text\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EXPORT_FREE_TRANS\":subMenuLabel=\"Export Free Translation...\":subMenuHelp=\"Collect all the free translation sections' contents, adding standard format markers, and export\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	//_T("SUB_MENU:subMenuID=\"ID_EXPORT_OXES\":subMenuLabel=\"Export &Open XML for Editing Scripture (OXES)...\":subMenuHelp=\"Export the translation text according to the OXES version 1 standard\":subMenuKind=\"wxITEM_NORMAL\":"),
	//_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_FILE_EXPORT_KB\":subMenuLabel=\"Export Knowledge &Base...\":subMenuHelp=\"Export knowledge base in standard format or LIFT format\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_IMPORT_TO_KB\":subMenuLabel=\"&Import to Knowledge Base...\":subMenuHelp=\"Extend knowledge base by importing dictionary records\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("/MAIN_MENU:"),
	_T("MAIN_MENU:mainMenuID=\"ID_ADVANCED_MENU\":mainMenuLabel=\"&Advanced\":"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_SEE_GLOSSES\":subMenuLabel=\"See Glosses\":subMenuHelp=\"Make glossing line visible on screen\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_GLOSSING_USES_NAV_FONT\":subMenuLabel=\"Glossing Uses Navigation Text's Font\":subMenuHelp=\"Use the navigation text font for glossing text\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_TRANSFORM_ADAPTATIONS_INTO_GLOSSES\":subMenuLabel=\"Transform Adaptations Into Glosses...\":subMenuHelp=\"Transform adaptations from another project into the current project's glosses\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_DELAY\":subMenuLabel=\"Delay...\":subMenuHelp=\"Slow automatic insertions down to a speed suitable for reading along\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_BOOKMODE\":subMenuLabel=\"Storing Documents in Book Folders\":subMenuHelp=\"Turn on, or off, storage of documents to book folders\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_FREE_TRANSLATION_MODE\":subMenuLabel=\"Free Translation Mode\":subMenuHelp=\"Turn on, or off, typing of free translations in the Compose Bar and displaying them in the main window\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_TARGET_TEXT_IS_DEFAULT\":subMenuLabel=\"Use Target Text As Default Free Translation\":subMenuHelp=\"Turn on, or off, composition of a default free translation from the existing target text\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT\":subMenuLabel=\"Use Gloss Text As Default Free Translation\":subMenuHelp=\"Turn on, or off, composition of a default free translation from the existing gloss text\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_REMOVE_FILTERED_FREE_TRANSLATIONS\":subMenuLabel=\"Remove Free Translations\":subMenuHelp=\"Removes all the filtered free translations in the document\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_COLLECT_BACKTRANSLATIONS\":subMenuLabel=\"Collect Back Translations...\":subMenuHelp=\"Collect adaptations, or glosses, and store them with a back translation marker as filtered material\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_REMOVE_FILTERED_BACKTRANSLATIONS\":subMenuLabel=\"Remove Back Translations\":subMenuHelp=\"Deletes all the filtered back translations in the document\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_USETRANSLITERATIONMODE\":subMenuLabel=\"Use Transliteration Mode\":subMenuHelp=\"Select this item to use SIL Converters in transliteration mode\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_SENDSYNCHRONIZEDSCROLLINGMESSAGES\":subMenuLabel=\"Send Synchronized Scrolling Messages\":subMenuHelp=\"Select this item to cause applications such as Paratext and TW to automatically scroll to the same location\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ADVANCED_RECEIVESYNCHRONIZEDSCROLLINGMESSAGES\":subMenuLabel=\"Receive Synchronized Scrolling Messages\":subMenuHelp=\"Select this item to cause Adapt It to scroll to the same location being displayed in other applications such as Paratext and TW\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("/MAIN_MENU:"),
	_T("MAIN_MENU:mainMenuID=\"ID_LAYOUT_MENU\":mainMenuLabel=\"&Layout\":"),
	_T("SUB_MENU:subMenuID=\"ID_ALIGNMENT\":subMenuLabel=\"Layout Window Right To Left\\tCtrl-1\":subMenuHelp=\"Layout text in window from right to left\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("/MAIN_MENU:"),
	_T("MAIN_MENU:mainMenuID=\"ID_HELP_MENU\":mainMenuLabel=\"&Help\":"),
	_T("SUB_MENU:subMenuID=\"wxID_HELP\":subMenuLabel=\"&Help Topics\\tShift-Ctrl-/\":subMenuHelp=\"List Help topics\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ONLINE_HELP\":subMenuLabel=\"Online Help (Requires Internet Access)\":subMenuHelp=\"Get Adapt It Help from the Internet in your browser\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_REPORT_A_PROBLEM\":subMenuLabel=\"Report a problem...\":subMenuHelp=\"Send a bug or problem report to the Adapt It developers\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_GIVE_FEEDBACK\":subMenuLabel=\"Give feedback...\":subMenuHelp=\"Give the developers feedback on your use of Adapt It\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_HELP_USE_TOOLTIPS\":subMenuLabel=\"Use Tooltips\":subMenuHelp=\"Select this item to turn on or turn off tooltip help messages\":subMenuKind=\"wxITEM_CHECK\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"wxID_ABOUT\":subMenuLabel=\"&About Adapt It...\":subMenuHelp=\"Display program information, version number and copyright\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("/MAIN_MENU:"),
	_T("MAIN_MENU:mainMenuID=\"ID_ADMINISTRATOR_MENU\":mainMenuLabel=\"Ad&ministrator\":"),
	_T("SUB_MENU:subMenuID=\"ID_CUSTOM_WORK_FOLDER_LOCATION\":subMenuLabel=\"&Custom Work Folder Location...\":subMenuHelp=\"Point Adapt It at a work folder in a non-standard location, and use that work folder until pointed elsewhere\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_LOCK_CUSTOM_LOCATION\":subMenuLabel=\"&Lock Custom Location\":subMenuHelp=\"Make the custom work folder location permanent until explicitly changed\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_UNLOCK_CUSTOM_LOCATION\":subMenuLabel=\"&Unlock Custom Location\":subMenuHelp=\"Make the custom work folder location persist only until the end of the session\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_LOCAL_WORK_FOLDER_MENU\":subMenuLabel=\"&Restore Default Work Folder Location\":subMenuHelp=\"Point at the local machine's default work folder\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_SET_PASSWORD_MENU\":subMenuLabel=\"Set &Password...\":subMenuHelp=\"Set a password, it will be stored in the clear in the basic configuration file\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_MOVE_OR_COPY_FOLDERS_OR_FILES\":subMenuLabel=\"&Move Or Copy Folders Or Files...\\tShift-Ctrl-M\":subMenuHelp=\"Dialog for moving folders or files, or copying them, into a destination folder\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_ASSIGN_LOCATIONS_FOR_INPUTS_OUTPUTS\":subMenuLabel=\"&Assign Locations For Inputs and Outputs...\":subMenuHelp=\"Opens a dialog in which folder locations for inputs and outputs can be assigned, protecting users from navigating the file system\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"menuSeparator\":subMenuLabel=\"\":subMenuHelp=\"\":subMenuKind=\"wxITEM_SEPARATOR\":"),
	_T("/SUB_MENU:"),
	_T("SUB_MENU:subMenuID=\"ID_EDIT_USER_MENU_SETTINGS_PROFILE\":subMenuLabel=\"User &Workflow Profiles...\":subMenuHelp=\"Choose which menu items the user can access\":subMenuKind=\"wxITEM_NORMAL\":"),
	_T("/SUB_MENU:"),
	_T("/MAIN_MENU:"),
	_T("/MENU_STRUCTURE:")
};
*/

////////////////////////////////////////////////////////////////////////////////////////
/// \return     pointer to a BookNamePair struct whose members have been assigned
/// \param      pPair      <- the struce whose members are assigned values
/// \param      dirNm      -> the book's folder name used for actual folder/dir creation
/// \param      seeNm      -> the book's visible name (localizable) for the interface
/// \param      bookcode   -> three-letter code for the book (should be same as used on \id line)
/// \remarks
/// Called from: SetupDefaultBooksArray(). Assigns the members of the BookNamePair struct
/// pointed to by pPair with the values pointed to by the function's parameters.
////////////////////////////////////////////////////////////////////////////////////////
BookNamePair* MakePair(BookNamePair*& pPair, wxChar* dirNm, wxChar* seeNm, wxChar* bookcode)
{
	pPair->dirName = dirNm;
	pPair->seeName = seeNm;
	pPair->bookCode = bookcode;
	return pPair;
}

/// A global scratch pointer. Instances of BookNamePair are stored in the m_pBibleBooks
/// pointer array.
BookNamePair* gpBookNamePair;

/// A global scratch pointer. Instances of USFMAnalysis are stored in the m_pUsfmStylesMap,
/// m_pPngStylesMap, and m_pUsfmAndPngStylesMap (of type MapSfmToUSFMAnalysisStruct).
USFMAnalysis* gpUsfmAnalysis;

/// A global scratch pointer. Instances of UserProfileItem are stored in the ProfileItemList
/// and are used in setting up user workflow profiles
//UserProfileItem* gpUserProfileItem;

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pBookStructs  <- the array of void pointers to hold the pointers to book
///                              structs
/// \remarks
/// Called from: the App's OnInit() if, on app startup, the app cannot find the books.xml
/// file. SetupDefaultBooksArray() is called in order to establish a default list of
/// books/divisions for the application to use in the event that a books.xml file is not
/// available.
/////////////////////////////////////////////////////////////////////////////////////////
void SetupDefaultBooksArray(wxArrayPtrVoid* pBookStructs)
{
	wxArrayPtrVoid singles;
	wxArrayPtrVoid codes;
	SetupSinglesArray(&singles);
	SetupBookCodesArray(&codes);
	for (int i = 0; i < 67; i++)
	{
		wxChar* book = (wxChar*)singles[i];
		wxChar* itsCode = (wxChar*)codes[i];
		gpBookNamePair = new BookNamePair;
		pBookStructs->Add((void*)MakePair(gpBookNamePair,book,book,itsCode));
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pBooks  <- the array of void pointers to hold the pointers to book structs
/// \remarks
/// Called from: the App's SetupDefaultBooksArray().  SetupDefaultBooksArray() in turn is only
/// called if the app cannot find the books.xml file.
////////////////////////////////////////////////////////////////////////////////////////
void SetupSinglesArray(wxArrayPtrVoid* pBooks)
{
	//pBooks->SetSize(68,10); // space for all 67, with a bit to spare, and nGrowBy of 10
	pBooks->Add((void*)_00BK);
	pBooks->Add((void*)_01BK);
	pBooks->Add((void*)_02BK);
	pBooks->Add((void*)_03BK);
	pBooks->Add((void*)_04BK);
	pBooks->Add((void*)_05BK);
	pBooks->Add((void*)_06BK);
	pBooks->Add((void*)_07BK);
	pBooks->Add((void*)_08BK);
	pBooks->Add((void*)_09BK);
	pBooks->Add((void*)_10BK);
	pBooks->Add((void*)_11BK);
	pBooks->Add((void*)_12BK);
	pBooks->Add((void*)_13BK);
	pBooks->Add((void*)_14BK);
	pBooks->Add((void*)_15BK);
	pBooks->Add((void*)_16BK);
	pBooks->Add((void*)_17BK);
	pBooks->Add((void*)_18BK);
	pBooks->Add((void*)_19BK);
	pBooks->Add((void*)_20BK);
	pBooks->Add((void*)_21BK);
	pBooks->Add((void*)_22BK);
	pBooks->Add((void*)_23BK);
	pBooks->Add((void*)_24BK);
	pBooks->Add((void*)_25BK);
	pBooks->Add((void*)_26BK);
	pBooks->Add((void*)_27BK);
	pBooks->Add((void*)_28BK);
	pBooks->Add((void*)_29BK);
	pBooks->Add((void*)_30BK);
	pBooks->Add((void*)_31BK);
	pBooks->Add((void*)_32BK);
	pBooks->Add((void*)_33BK);
	pBooks->Add((void*)_34BK);
	pBooks->Add((void*)_35BK);
	pBooks->Add((void*)_36BK);
	pBooks->Add((void*)_37BK);
	pBooks->Add((void*)_38BK);
	pBooks->Add((void*)_39BK);
	pBooks->Add((void*)_40BK);
	pBooks->Add((void*)_41BK);
	pBooks->Add((void*)_42BK);
	pBooks->Add((void*)_43BK);
	pBooks->Add((void*)_44BK);
	pBooks->Add((void*)_45BK);
	pBooks->Add((void*)_46BK);
	pBooks->Add((void*)_47BK);
	pBooks->Add((void*)_48BK);
	pBooks->Add((void*)_49BK);
	pBooks->Add((void*)_50BK);
	pBooks->Add((void*)_51BK);
	pBooks->Add((void*)_52BK);
	pBooks->Add((void*)_53BK);
	pBooks->Add((void*)_54BK);
	pBooks->Add((void*)_55BK);
	pBooks->Add((void*)_56BK);
	pBooks->Add((void*)_57BK);
	pBooks->Add((void*)_58BK);
	pBooks->Add((void*)_59BK);
	pBooks->Add((void*)_60BK);
	pBooks->Add((void*)_61BK);
	pBooks->Add((void*)_62BK);
	pBooks->Add((void*)_63BK);
	pBooks->Add((void*)_64BK);
	pBooks->Add((void*)_65BK);
	pBooks->Add((void*)_66BK);
	// Access using code like this:
	// Int16 index = some value;
	// wxChar* bookP = (wxChar*)(*m_pBibleBooks)[index];
	// or wxString aBookName = (wxChar*)(*m_pBibleBooks)[index];
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pBookCodes  <-  the array of void pointers to hold the pointers to book
///                             codes
/// \remarks
/// Called from: the App's SetupDefaultBooksArray(). SetupDefaultBooksArray() in turn is
/// only called if the app cannot find the books.xml file.
////////////////////////////////////////////////////////////////////////////////////////
void SetupBookCodesArray(wxArrayPtrVoid* pBookCodes)
{
	//pBookCodes->SetSize(68,10); // space for all 67, with a bit to spare, and nGrowBy of 10
	pBookCodes->Add((void*)_00BKCODE);
	pBookCodes->Add((void*)_01BKCODE);
	pBookCodes->Add((void*)_02BKCODE);
	pBookCodes->Add((void*)_03BKCODE);
	pBookCodes->Add((void*)_04BKCODE);
	pBookCodes->Add((void*)_05BKCODE);
	pBookCodes->Add((void*)_06BKCODE);
	pBookCodes->Add((void*)_07BKCODE);
	pBookCodes->Add((void*)_08BKCODE);
	pBookCodes->Add((void*)_09BKCODE);
	pBookCodes->Add((void*)_10BKCODE);
	pBookCodes->Add((void*)_11BKCODE);
	pBookCodes->Add((void*)_12BKCODE);
	pBookCodes->Add((void*)_13BKCODE);
	pBookCodes->Add((void*)_14BKCODE);
	pBookCodes->Add((void*)_15BKCODE);
	pBookCodes->Add((void*)_16BKCODE);
	pBookCodes->Add((void*)_17BKCODE);
	pBookCodes->Add((void*)_18BKCODE);
	pBookCodes->Add((void*)_19BKCODE);
	pBookCodes->Add((void*)_20BKCODE);
	pBookCodes->Add((void*)_21BKCODE);
	pBookCodes->Add((void*)_22BKCODE);
	pBookCodes->Add((void*)_23BKCODE);
	pBookCodes->Add((void*)_24BKCODE);
	pBookCodes->Add((void*)_25BKCODE);
	pBookCodes->Add((void*)_26BKCODE);
	pBookCodes->Add((void*)_27BKCODE);
	pBookCodes->Add((void*)_28BKCODE);
	pBookCodes->Add((void*)_29BKCODE);
	pBookCodes->Add((void*)_30BKCODE);
	pBookCodes->Add((void*)_31BKCODE);
	pBookCodes->Add((void*)_32BKCODE);
	pBookCodes->Add((void*)_33BKCODE);
	pBookCodes->Add((void*)_34BKCODE);
	pBookCodes->Add((void*)_35BKCODE);
	pBookCodes->Add((void*)_36BKCODE);
	pBookCodes->Add((void*)_37BKCODE);
	pBookCodes->Add((void*)_38BKCODE);
	pBookCodes->Add((void*)_39BKCODE);
	pBookCodes->Add((void*)_40BKCODE);
	pBookCodes->Add((void*)_41BKCODE);
	pBookCodes->Add((void*)_42BKCODE);
	pBookCodes->Add((void*)_43BKCODE);
	pBookCodes->Add((void*)_44BKCODE);
	pBookCodes->Add((void*)_45BKCODE);
	pBookCodes->Add((void*)_46BKCODE);
	pBookCodes->Add((void*)_47BKCODE);
	pBookCodes->Add((void*)_48BKCODE);
	pBookCodes->Add((void*)_49BKCODE);
	pBookCodes->Add((void*)_50BKCODE);
	pBookCodes->Add((void*)_51BKCODE);
	pBookCodes->Add((void*)_52BKCODE);
	pBookCodes->Add((void*)_53BKCODE);
	pBookCodes->Add((void*)_54BKCODE);
	pBookCodes->Add((void*)_55BKCODE);
	pBookCodes->Add((void*)_56BKCODE);
	pBookCodes->Add((void*)_57BKCODE);
	pBookCodes->Add((void*)_58BKCODE);
	pBookCodes->Add((void*)_59BKCODE);
	pBookCodes->Add((void*)_60BKCODE);
	pBookCodes->Add((void*)_61BKCODE);
	pBookCodes->Add((void*)_62BKCODE);
	pBookCodes->Add((void*)_63BKCODE);
	pBookCodes->Add((void*)_64BKCODE);
	pBookCodes->Add((void*)_65BKCODE);
	pBookCodes->Add((void*)_66BKCODE);
	// Access using code like this:
	// Int16 index = some value;
	// or wxString aBookCode = ((*m_pBibleBooks)[index]).bookCode;
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the input string is "1", FALSE if the input string is "0".
/// \param      temp  -> input string representing either "1" or "0"
/// \remarks
/// Called from: the App's ParseAndFillStruct() which fills out the members of a
/// USFMAnalysis struct. GetBoolValueFromStr1orStr0() and ParseAndFillStruct() are only
/// called if the app cannot find the AI_USFM.xml file and it must use
/// SetupDefaultStylesMap() to establish its internal list of USFM styles.
///////////////////////////////////////////////////////////////////////////////////////
bool GetBoolValueFromStr1orStr0(wxString temp)
{
	// WX version helper for ParseAndFillStruct below
	if (temp == _T("1"))
		return TRUE;
	else if (temp == _T("0"))
		return FALSE;
	else
	{
		wxASSERT(FALSE);
		return TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSFM        <-  pointer to the USFMAnalysis struct whose members are
///                             to be assigned
/// \param      defaultSFM  ->  The Unix-like default string representing the fields
///                             of a USFMAnalysis struct separated by colon ":" chars
/// \remarks
/// Called from: the App's SetupDefaultStylesMap() which fills out the members of a
/// USFMAnalysis struct. GetBoolValueFromStr1orStr0() and ParseAndFillStruct() are only
/// called if the app cannot find the AI_USFM.xml file and it must use
/// SetupDefaultStylesMap() to establish its internal map of USFM styles.
/////////////////////////////////////////////////////////////////////////////////////
void ParseAndFillStruct(USFMAnalysis*& pSFM, wxString defaultSFM)
{
	// parse the defaultSFM line and assign its fields to the appropriate
	// fields of the USFMAnalysis struct
	wxString temp = _T("");
	USFMAnalysisField fieldEnum = marker; //int fieldEnum = 0;
	int intValOfEnum = (int)marker;
	bool msgGiven = FALSE;
	for (int i = 0; i < (int)defaultSFM.Length(); i++)
	{
		if (defaultSFM[i] != _T(':'))
			temp += defaultSFM[i];
		else
		{
			// we're at the end of a field
			// empty non-string fields are assumed to represent a value of "0"
			if (temp == _T("")
				&& !(fieldEnum == marker || fieldEnum == endMarker
				     || fieldEnum == description || fieldEnum == navigationText
					 || fieldEnum == styleName || fieldEnum == basedOn
					 || fieldEnum == nextStyle))
				temp = _T("0");
			// in the switch below:
			// strings are directly assigned the field contents
			// booleans are cast from their integral value to bool
			// enums are cast from their integral value to their enum type
			switch (fieldEnum)
			{
				case marker:           pSFM->marker = temp; break;
				case endMarker:        pSFM->endMarker = temp; break;
				case description:      pSFM->description = temp; break;
				case usfm:             pSFM->usfm = GetBoolValueFromStr1orStr0(temp); break;
				case png:              pSFM->png = GetBoolValueFromStr1orStr0(temp); break;
				case filter:           pSFM->filter = GetBoolValueFromStr1orStr0(temp); break;
				case userCanSetFilter: pSFM->userCanSetFilter = GetBoolValueFromStr1orStr0(temp); break;
				case inLine:           pSFM->inLine = GetBoolValueFromStr1orStr0(temp); break;
				case special:          pSFM->special = GetBoolValueFromStr1orStr0(temp); break;
				case bdryOnLast:       pSFM->bdryOnLast = GetBoolValueFromStr1orStr0(temp); break;
				case inform:           pSFM->inform = GetBoolValueFromStr1orStr0(temp); break;
				case navigationText:   pSFM->navigationText = temp; break;
				case textType:         pSFM->textType  = (TextType)wxAtoi(temp); break;
				case wrap:             pSFM->wrap = GetBoolValueFromStr1orStr0(temp); break;
				case styleName:        pSFM->styleName = temp; break;
				case styleType:        pSFM->styleType = (StyleType)wxAtoi(temp); break;
				case fontSize:         pSFM->fontSize = wxAtoi(temp); break;
				case color:            pSFM->color = wxAtoi(temp); break;
				case italic:           pSFM->italic = GetBoolValueFromStr1orStr0(temp); break;
				case bold:             pSFM->bold = GetBoolValueFromStr1orStr0(temp); break;
				case underline:        pSFM->underline = GetBoolValueFromStr1orStr0(temp); break;
				case smallCaps:        pSFM->smallCaps = GetBoolValueFromStr1orStr0(temp); break;
				case superScript:      pSFM->superScript = GetBoolValueFromStr1orStr0(temp); break;
				case justification:    pSFM->justification = (Justification)wxAtoi(temp); break;
				case spaceAbove:       pSFM->spaceAbove = wxAtoi(temp); break;
				case spaceBelow:       pSFM->spaceBelow = wxAtoi(temp); break;
				case leadingMargin:    pSFM->leadingMargin = (float)wxAtof(temp); break;   // float
				case followingMargin:  pSFM->followingMargin = (float)wxAtof(temp); break; // float
				case firstLineIndent:  pSFM->firstLineIndent = (float)wxAtof(temp);break;  // float
				case basedOn:          pSFM->basedOn = temp; break;
				case nextStyle:        pSFM->nextStyle = temp; break;
				case keepTogether:     pSFM->keepTogether = GetBoolValueFromStr1orStr0(temp); break;
				case keepWithNext:     pSFM->keepWithNext = GetBoolValueFromStr1orStr0(temp); break;
				default:
					{
						// This shouldn't happen. It would be an internal error due to
						// incorrectly formatted default strings in defaultSFM[] above
						// If there is a serious problem this could be called 266 times,
						// so only give it once.
						if (!msgGiven)
						{
							wxMessageBox(_T("The defaultSFM[] array is incorrectly formatted!!\n"));
						}
						msgGiven = TRUE;
					}
			}
			intValOfEnum++;
			fieldEnum = (USFMAnalysisField)intValOfEnum;
			temp = _T("");
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnInit(). It is only called if the app cannot find the
/// AI_USFM.xml file and it must use SetupDefaultStylesMap() to establish its internal map
/// of USFM styles. When AI_USFM.xml is available (the usual case) the m_pUsfmStylesMap,
/// m_pPngStylesMap, and m_pUsfmAndPngStylesMap are populated by the AtSFMEndTag() function
/// in XML.cpp, rather than by this SetupDefaultStylesMap() function.
/////////////////////////////////////////////////////////////////////////////////////////
void SetupDefaultStylesMap()
{
    // Note: This function is only called when AI_USFM.xml is not available for some
    // reason. When AI_USFM.xml is available (the usual case) the m_pUsfmStylesMap,
    // m_pPngStylesMap, and m_pUsfmAndPngStylesMap are populated by the AtSFMEndTag()
    // function in XML.cpp, rather than here. Any changes to the filling of the
    // CMapStringToOb routines below shold also be carried over to the AtSFMEndTag()
    // routine in XML.cpp We don't want duplicate entries in any of the three maps, so
    // we'll always do a lookup first, and only add a marker if it doesn't already exist in
    // the given map.
	for (int i = 0; i < gnDefaultSFMs; i++)
	{
		gpUsfmAnalysis = new USFMAnalysis;
		// whm Note: The object pointed at by gpUsfmAnalysis will not ordinarily
		// need to be deleted by calling delete on the gpUsfmAnalysis "scratch"
		// pointer, because each such object created here will be handed off to
		// another data structure which will eventually be responsible for
		// object deletion of the objects it owns in OnExit(). It need only be
		// deleted directly if it cannot be handed off to an appropriate data
		// structure (see below).
		//
		// set the gpUsfmAnalysis struct attributes from the parsed defaultSFM
		// strings values
		ParseAndFillStruct(gpUsfmAnalysis,defaultSFM[i]);
		wxString bareMkr = gpUsfmAnalysis->marker;
		int posn = bareMkr.Find(_T('*')); // do we have an end marker?
		if (posn >= 0 && bareMkr[bareMkr.Length() -1] == _T('*'))
		{
			bareMkr = bareMkr.Mid(0,posn-1); // strip off asterisk for attribute lookup
		}
		// map the parsed struct to the appropriate map on the heap
		MapSfmToUSFMAnalysisStruct::iterator iter;
		if (gpUsfmAnalysis->usfm)
		{
			iter = gpApp->m_pUsfmStylesMap->find(bareMkr);
			if (iter == gpApp->m_pUsfmStylesMap->end())
			{
				// key doesn't already exist in the map, so add it
				(*gpApp->m_pUsfmStylesMap)[bareMkr] = gpUsfmAnalysis;
			}
			// for UsfmAndPng map put the Usfm marker there as priority
			iter = gpApp->m_pUsfmAndPngStylesMap->find(bareMkr);
			if (iter == gpApp->m_pUsfmAndPngStylesMap->end())
			{
				// key doesn't already exist in the map, so add it
				(*gpApp->m_pUsfmAndPngStylesMap)[bareMkr] = gpUsfmAnalysis;
			}

		}
		if (gpUsfmAnalysis->png)
		{
			iter = gpApp->m_pPngStylesMap->find(bareMkr);
			if (iter == gpApp->m_pPngStylesMap->end())
			{
				// key doesn't already exist in the map, so add it
				(*gpApp->m_pPngStylesMap)[bareMkr] = gpUsfmAnalysis;
			}
			// for UsfmAndPng map put the Usfm marker there only if unique
			iter = gpApp->m_pUsfmAndPngStylesMap->find(bareMkr);
			if (iter == gpApp->m_pUsfmAndPngStylesMap->end())
			{
				// key doesn't already exist in the map, so add it
				(*gpApp->m_pUsfmAndPngStylesMap)[bareMkr] = gpUsfmAnalysis;
			}
		}
		if (!gpUsfmAnalysis->usfm && !gpUsfmAnalysis->png)
		{
			// the marker is neither usfm nor png and therefore not stored in
			// any of the three possible maps, so we must delete it
			delete gpUsfmAnalysis;
		}
		else
		{
			gpApp->m_pMappedObjectPointers->Add(gpUsfmAnalysis);
		}
		gpUsfmAnalysis = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      <- pUserProfiles  a pointer to the UserProfiles struct that is being populated
/// \remarks
/// Called from: the App's OnInit(), ReportMenuAndUserProfilesInconsistencies(), and
/// CAdminEditMenuProfile::InitDialog. It is called in OnInit() to set up a
/// factoryUserProfiles struct on the heap for use in AdminEditMenuProfile class.
/// It is also called if the app cannot find the AI_UserProfiles.xml file and it must
/// use SetupDefaultUserProfiles() to establish its internal representation of any user
/// selected User Workflow Profile.
/// When AI_UserProfiles.xml is available (the usual case) the m_pUserProfiles is
/// populated by the AtPROFILEEndTag() function in XML.cpp, rather than by this
/// SetupDefaultUserProfiles() function. After setting up the pUserProfiles struct
/// this function also calls GetAndAssignIdValuesToUserProfilesStruct().
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetupDefaultUserProfiles(UserProfiles*& pUserProfiles)
{

	// testing below !!!
	//wxArrayString defaultProfItems;
	//defaultProfItems.Add(_T("Save &As...\tCtrl-A"));
	//defaultProfItems.Add(::wxGetTranslation(defaultProfItems.Item(0)));
	//defaultProfItems.Add(_("Save &As...\tCtrl-A"));
	//defaultProfItems.Add(_T("source"));
	//defaultProfItems.Add(_("source"));
	//int testCt;
	//int testTot = defaultProfItems.GetCount();
	//for (testCt = 0; testCt < testTot; testCt++)
	//	wxLogDebug(defaultProfItems.Item(testCt));
	//int junk;
	//junk = 1;
	// Note: testing shows that we can use ::wxGetTranslation() as long as we use the
	// exact & and \tCtrl-key embellishments.
	// testing above !!!

	wxString field = _T("");
	int nDefaultUserProfileItems;
	UserProfileItem* pUserProfileItem = NULL;
	nDefaultUserProfileItems = sizeof(defaultProfileItems)/sizeof(wxString);
	int i;
	for (i = 0; i < nDefaultUserProfileItems; i++)
	{
		// scan and parse each defaultProfileItems line
		field.Empty();
		int ct, totct;
		wxString lineStr;
		lineStr = defaultProfileItems[i];
		totct = defaultProfileItems[i].Length();
		for (ct = 0; ct < totct; ct++)
		{
			// defaultProfileItems[i] represents a whole string line of concatenated tags, attributes and values
			if (lineStr.GetChar(ct) != _T(':'))
			{
				field += lineStr.GetChar(ct);
			}
			else
			{
				// we're at the end of a field and field contains the string token
				// up to, but not including the : delimiter.
				// If the field doesn't have an '=' in it, it should be an all-caps
				// tag name; if it has an '=' in it, the field should contain an
				// attribute name followed by the '=' with the attribute's value
				// within quote marks, i.e., attributeName="value".
				// Parse the field into its parts
				if (field.Find(_T("=")) == wxNOT_FOUND)
				{
					// No '=' in the field so field itself should be a tag name
					// Test for most common ones first - profile and menu.
					if (field == wxString::FromAscii(profile))
					{
						;
					}
					else if (field == wxString::FromAscii(end_profile))
					{
						;
					}
					else if (field == wxString::FromAscii(menu))
					{
						pUserProfileItem = new UserProfileItem;
						pUserProfileItem->itemID = _T("");
						pUserProfileItem->itemIDint = -1;
						pUserProfileItem->itemType = _T("");
						pUserProfileItem->itemText = _T("");
						pUserProfileItem->itemDescr = _T("");
						pUserProfileItem->adminCanChange = _T("");
						pUserProfileItem->usedProfileNames.Clear();
					}
					else if (field == wxString::FromAscii(end_menu))
					{
						pUserProfiles->profileItemList.Append(pUserProfileItem);
					}
					else if (field == wxString::FromAscii(userprofilessupport))
					{
						pUserProfiles = new UserProfiles;
						pUserProfiles->profileVersion = _T("");
						pUserProfiles->applicationCompatibility = _T("");
						pUserProfiles->adminModified = _T("");
						pUserProfiles->definedProfileNames.Clear();
						pUserProfiles->descriptionProfileTexts.Clear();
						pUserProfiles->profileItemList.Clear();
					}
					else if (field == wxString::FromAscii(end_userprofilessupport))
					{
						;
					}
				}
				else
				{
					// field has an '=' char in it so it should be an attribute/value
					// representation
					wxString attrStr;
					wxString valueStr;
					attrStr = field.Mid(0,field.Find(_T("=")));
					attrStr.Trim(FALSE);
					attrStr.Trim(TRUE);
					valueStr = field.Mid(field.Find(_T("=")));
					valueStr.Replace(_T("="),_T(""));
					valueStr.Replace(_T("\""),_T(""));
					valueStr.Trim(FALSE);
					valueStr.Trim(TRUE);
					if (attrStr == wxString::FromAscii(profileVersion))
					{
						wxASSERT(pUserProfiles != NULL);
						pUserProfiles->profileVersion = valueStr;
					}
					else if (attrStr == wxString::FromAscii(applicationCompatibility))
					{
						wxASSERT(pUserProfiles != NULL);
						pUserProfiles->applicationCompatibility = valueStr;
					}
					else if (attrStr == wxString::FromAscii(adminModified))
					{
						wxASSERT(pUserProfiles != NULL);
						pUserProfiles->adminModified = valueStr;
					}
					else if (attrStr.Find(wxString::FromAscii(definedProfile)) == 0)
					{
						wxASSERT(pUserProfiles != NULL);
						// whm 24May11 Note: we need to call ::wxGetTranslation to get the localized string for the definedProfile
						pUserProfiles->definedProfileNames.Add(::wxGetTranslation(valueStr)); // whm changed 24May11 to use localization
						//pUserProfiles->definedProfileNames.Add(valueStr);
					}
					else if (attrStr.Find(wxString::FromAscii(descriptionProfile)) == 0)
					{
						wxASSERT(pUserProfiles != NULL);
						// Note: we keep entity characters in their non xml form here, i.e.,
						// '<', '>', '&', ''', and '"' remain as it.
						// whm 24May11 Note: we need to call ::wxGetTranslation to get the localized string for the descriptionProfile
						pUserProfiles->descriptionProfileTexts.Add(::wxGetTranslation(valueStr)); // whm changed 24May11 to use localization
						//pUserProfiles->descriptionProfileTexts.Add(valueStr);
					}
					else if (attrStr == wxString::FromAscii(itemID))
					{
						wxASSERT(pUserProfileItem != NULL);
						pUserProfileItem->itemID = valueStr;
					}
					else if (attrStr == wxString::FromAscii(itemType))
					{
						wxASSERT(pUserProfileItem != NULL);
						pUserProfileItem->itemType = valueStr;
					}
					else if (attrStr == wxString::FromAscii(itemText))
					{
						wxASSERT(pUserProfileItem != NULL);
						// whm 24May11 Note: we need to call ::wxGetTranslation to get the localized string for the itemText
						wxString tempS = ::wxGetTranslation(valueStr); // whm changed 24May11 to use localization
						// change any embedded tab 0x09 char to explicit "\\t"
						int posn = tempS.Find('\t');
						if (posn != wxNOT_FOUND)
						{
							tempS.Remove(posn,1);
							tempS.insert(posn,_T("\\t"));
						}
						pUserProfileItem->itemText = tempS;
						//pUserProfileItem->itemText = valueStr;
					}
					else if (attrStr == wxString::FromAscii(itemDescr))
					{
						wxASSERT(pUserProfileItem != NULL);
						// whm 24May11 Note: we need to call ::wxGetTranslation to get the localized string for the itemDescr
						pUserProfileItem->itemDescr = ::wxGetTranslation(valueStr); // whm changed 24May11 to use localization
						//pUserProfileItem->itemDescr = valueStr;
					}
					else if (attrStr == wxString::FromAscii(itemAdminCanChange))
					{
						wxASSERT(pUserProfileItem != NULL);
						pUserProfileItem->adminCanChange = valueStr;
					}
					else if (attrStr == wxString::FromAscii(itemUserProfile))
					{
						wxASSERT(pUserProfileItem != NULL);
						// whm 24May11 Note: we need to call ::wxGetTranslation to get the localized string for the itemUserProfile
						pUserProfileItem->usedProfileNames.Add(::wxGetTranslation(valueStr)); // whm changed 24May11 to use localization
						//pUserProfileItem->usedProfileNames.Add(valueStr);
					}
					else if (attrStr == wxString::FromAscii(itemVisibility))
					{
						wxASSERT(pUserProfileItem != NULL);
						pUserProfileItem->usedVisibilityValues.Add(valueStr);
					}
					else if (attrStr == wxString::FromAscii(factory))
					{
						wxASSERT(pUserProfileItem != NULL);
						pUserProfileItem->usedFactoryValues.Add(valueStr);
					}
				}

				field.Empty(); // ready for next field
			}
		}
		// We're at the end of a parsed line
	}
	GetAndAssignIdValuesToUserProfilesStruct(pUserProfiles);
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the compareUserProfiles and baseUserProfiles differ in the significant
///             profile items that they share in common, FALSE if those items are the same
/// \param      <- compareUserProfiles  a pointer to the UserProfiles struct whose profile items
///                 are being checked/compared
/// \param      <- baseUserProfiles  a pointer to the UserProfiles struct whose profile items
///                 are the basis against which the compareUserProfiles items are being compared
/// \remarks
/// Called from: the App's UpdateAdminModifiedLineToYesOrNo().
/// Determines if the current user profile m_pUserProfiles (compareUserProfiles) differs from
/// the factory profile m_pFactoryUserProfiles (baseUserProfiles). It only check for differences in
/// profile items that the two profiles (compareUserProfiles and baseUserProfiles) have in common.
/// It ignores any profile items that are present but are not shared in common. This allows
/// upgrades to be done where different profile items might be present/absent in the course
/// of an upgrade to a newer, or downgrade to an older version of the application and the
/// AI_UserProfiles.xml file.
/////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::CommonItemsInProfilesDiffer(UserProfiles* compareUserProfiles, UserProfiles* baseUserProfiles)
{
	// whm 22Oct10 rewrote to allow for different numbers of items in baseUserProfiles
	// and compareUserProfiles. See MapChangesInUserProfiles().
	bool bTheyDiffer = FALSE;
	// Strategy:
	// There is an m_pFactoryUserProfiles (baseUserProfiles) struct created in OnInit()
	// that we can use for comparison with the current compareUserProfiles. This comparison
	// ignores the adminModified attributes and others which are not editable by the
	// administrator. If CommonItemsInProfilesDiffer() returns FALSE it means that the
	// compareUserProfiles struct essentially contains only baseUserProfiles (i.e., factory)
	// data.

	wxASSERT(compareUserProfiles != NULL);
	wxASSERT(baseUserProfiles != NULL);

	if (compareUserProfiles != NULL && baseUserProfiles != NULL)
	{
		// we use a temporary map tempMap to associate the necessary attribute
		// items with their associated values.
		MapProfileChangesToStringValues tempMap;
		MapProfileChangesToStringValues::iterator iter;

		// Enter all compareUserProfiles items into our tempMap
		// First enter all of compareUserProfiles->descriptionProfileTexts into the map
		int descCt;
		int descTot = (int)compareUserProfiles->descriptionProfileTexts.GetCount();
		for (descCt = 0; descCt < descTot; descCt++)
		{
			// enter all of compareUserProfiles->descriptionProfileTexts into the map
			wxString key = wxString::FromAscii(descriptionProfile);
			key << descCt + 1; // add the numerical suffix as string "1", "2", "3", or "4"
			iter = tempMap.find(key);
			if (iter != tempMap.end())
			{
				// key exists in the map
				tempMap.insert(*iter);
			}
			else
			{
				// key not in the map
				tempMap[key] = compareUserProfiles->descriptionProfileTexts[descCt];
			}
		}
		// Next, enter all of compareUserProfiles->profileItemList items into the tempMap
		ProfileItemList::Node* tpos;
		int count;
		int t_tot = (int)compareUserProfiles->profileItemList.GetCount();
		for(count = 0; count < t_tot; count++)
		{
			tpos = compareUserProfiles->profileItemList.Item(count);
			UserProfileItem* ptItem;
			ptItem = tpos->GetData();
			wxASSERT(ptItem != NULL);
			int ct;
			int ct_t;
			ct_t = (int)ptItem->usedVisibilityValues.GetCount();
			for (ct = 0; ct < ct_t; ct++)
			{
				wxString key = ptItem->itemText + _T(":") + ptItem->usedProfileNames[ct]; // key is itemText + ':' + name of the profile, i.e., "Save As...:Novice"
				iter = tempMap.find(key);
				if (iter != tempMap.end())
				{
					// key exists in the map
					tempMap.insert(*iter);
				}
				else
				{
					// key not in the map
					tempMap[key] = ptItem->usedVisibilityValues[ct];
				}
			}
		}
		// dump the map contents for testing
		//for( iter = tempMap.begin(); iter != tempMap.end(); ++iter )
		//{
		//	wxLogDebug(_T("iter->first = %s, iter->second = %s"),iter->first.c_str(),iter->second.c_str());
		//}

		// Now go through all items of the baseUserProfiles struct, and do a lookup to see if
		// each item is in the map. If so, check the map's associated value. If the map's
		// associated value is different, then we immediately return TRUE.
		int appCt;
		int appTot = (int)baseUserProfiles->descriptionProfileTexts.GetCount();
		int nAppItemsNotAmongTempItems = 0;
		int nTempItemsNotAmongAppItems = (int)compareUserProfiles->descriptionProfileTexts.GetCount() + (4*(int)compareUserProfiles->profileItemList.GetCount());
		for (appCt = 0; appCt < appTot; appCt++)
		{
			wxString key = wxString::FromAscii(descriptionProfile);
			key << appCt + 1; // add the numerical suffix as string "1", "2", "3", or "4"

			iter = tempMap.find(key);
			if (iter != tempMap.end())
			{
				// key exists in the map
				wxString keyTemp = iter->first;
				wxString valueTemp = iter->second;
				wxString appDescrText = baseUserProfiles->descriptionProfileTexts.Item(appCt);
				// check if the valueTemp differs from the appDescrText
				if (valueTemp != appDescrText)
				{
					bTheyDiffer = TRUE;
					return bTheyDiffer;
				}
				nTempItemsNotAmongAppItems--; // decrement from total tempUserProfile items - remainder at end is the significant total
			}
			else
			{
				// key not in the map
				nAppItemsNotAmongTempItems++;
			}
		}
		ProfileItemList::Node* apos;
		MapProfileChangesToStringValues::iterator a_iter;
		int a_tot = (int)baseUserProfiles->profileItemList.GetCount();
		for(count = 0; count < a_tot; count++)
		{
			apos = baseUserProfiles->profileItemList.Item(count);
			UserProfileItem* paItem;
			paItem = apos->GetData();
			wxASSERT(paItem != NULL);
			int ct;
			int ct_a;
			ct_a = (int)paItem->usedVisibilityValues.GetCount();
			for (ct = 0; ct < ct_a; ct++)
			{
				wxString key = paItem->itemText + _T(":") + paItem->usedProfileNames[ct]; // key is itemText + ':' + name of the profile, i.e., "Save As...:Novice"
				iter = tempMap.find(key);
				if (iter != tempMap.end())
				{
					// key exists in the map
					wxString keyTemp = iter->first;
					wxString valueTemp = iter->second;
					wxString appVisibility = paItem->usedVisibilityValues.Item(ct);
					// check if the valueTemp differs from the appDescrText
					if (valueTemp != appVisibility)
					{
						bTheyDiffer = TRUE;
						return bTheyDiffer;
					}
					nTempItemsNotAmongAppItems--; // decrement from total tempUserProfile items - remainder at end is the significant total
				}
				else
				{
					// key not in the map
					nAppItemsNotAmongTempItems++;
				}
			}
		}
		// dump the map contents for testing
		//for( a_iter = m_mapProfileChangesToStringValues.begin(); a_iter != m_mapProfileChangesToStringValues.end(); ++a_iter )
		//{
		//	wxLogDebug(_T("a_iter->first = %s, a_iter->second = %s"),a_iter->first.c_str(),a_iter->second.c_str());
		//}
	}
	return bTheyDiffer;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      <- pUserProfiles  a pointer to the UserProfiles struct whose profile items
///                 are being modified
/// \remarks
/// Called from the App's OnInit(), SetupDefaultUserProfiles(), and CAdminEditMenuProfile::InitDialog().
/// Scans through pUserProfiles and assigns the itemIDint values by looking them up in the
/// m_mapMenuLabelStrToIdInt and assigning the mapped int values to the itemIDint member of
/// the UserProfileItem part of pUserProfiles.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetAndAssignIdValuesToUserProfilesStruct(UserProfiles*& pUserProfiles)
{
	// Use the map m_mapMenuLabelStrToIdInt
	wxASSERT(pUserProfiles != NULL);

	// scan through pUserProfiles and assign the int id values by looking them up in the
	// m_mapMenuLabelStrToIdInt and assigning the mapped int values to the itemIDint
	// member of the UserProfileItem part of pUserProfiles
	if (pUserProfiles != NULL)
	{
		ProfileItemList::Node* pos;
		int count;
		int item_count = (int)pUserProfiles->profileItemList.GetCount();
		for(count = 0; count < item_count; count++)
		{
			pos = pUserProfiles->profileItemList.Item(count);
			UserProfileItem* pItem;
			pItem = pos->GetData();
			if (pItem->itemType == _T("subMenu"))
			{

				// pItem->itemText is the string we want to look up, but remove decorations
				wxString itemTextPlain = pItem->itemText; //RemoveMenuLabelDecorations(pItem->itemText);
				// Note: UserProfiles data does not list menuSeparators so itemTextPlain
				// will never be menuSeparator
				// now look up the mapped int value
				MapMenuLabelStrToIdInt::iterator iter;

				// Note: the \t chars in the xml and internal strings become \\t literals
				// and need to be changed to \t to work in the menus.
				wxString labelStr = itemTextPlain;
				labelStr.Replace(_T("\\t"),_T("\t"));

				iter = m_mapMenuLabelStrToIdInt.find(labelStr);
				int itemId = -1;
				if (iter != m_mapMenuLabelStrToIdInt.end())
				{
					// we found an associated value for the plain menu label
					itemId = (int)iter->second;
				}
				else
				{
					// no mapping was found - this shouldn't happen
					wxASSERT(FALSE);
					;
				}
				pItem->itemIDint = itemId;
			}
		}
	}

}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing (but three wxString parameter values passed back by reference)
/// \param      -> AIuserProfilesWorkFolderPath path and name of AI_UserProfiles.xml in the work folder
/// \param      -> profileVersionStr the string value of the profileVersion attribute in the xml file
/// \param      -> applicationCompatibilityStr the string value of the applicationCompatibility attribute
///                 in the xml file
/// \param      -> adminModifiedStr the string value of the adminModified attribute in the xml file, i.e.,
///                 which is "Yes" or "No"
/// \remarks
/// Called from the App's OnInit(), SetupDefaultUserProfiles(), and CAdminEditMenuProfile::InitDialog().
/// Opens and reads the AI_UserProfiles.xml file at the AIuserProfilesWorkFolderPath path,
/// and retrieves the string values associated with these three attribute values: profileVersion,
/// applicationCompatibility, and adminModified. It returns them in the parameters passed by
/// reference.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetVersionAndModInfoFromProfilesXMLFile(wxString AIuserProfilesWorkFolderPath,
		wxString& profileVersionStr,wxString& applicationCompatibilityStr,wxString& adminModifiedStr)
{
	wxTextFile f;
	bool bUserProfilesFileExists = wxFileExists(AIuserProfilesWorkFolderPath);
	if (bUserProfilesFileExists)
	{
		// Read the existing xml file into memory using wxTextFile, so we can retrieve the
		// xml comments at the beginning of the file and compare the data in memory and
		// make changes there before saving the file back to disk
		bool bOpenedOK;
		bOpenedOK = f.Open(m_userProfileFileWorkFolderPath);
		if (bOpenedOK)
		{
			// The AI_UserProfiles.xml file is now in memory and accessible line-by-line through textFile.
			bool bFoundprofileVersion = FALSE;
			wxString lineStr;
			for (lineStr = f.GetFirstLine(); !f.Eof() && !bFoundprofileVersion; lineStr = f.GetNextLine())
			{
				int chPos;
				// does this line have our itemTextStr?
				chPos = lineStr.Find(wxString::FromAscii(profileVersion));
				if (chPos != wxNOT_FOUND)
				{
					bFoundprofileVersion = TRUE;
					wxString str = lineStr;
					int beginQPos, endQPos;
					beginQPos = str.Find(_T("\""));
					wxASSERT(beginQPos != wxNOT_FOUND);
					str = str.Mid(beginQPos+1);
					endQPos = str.Find(_T("\""));
					wxASSERT(endQPos != wxNOT_FOUND);
					str = str.Mid(0,endQPos);
					profileVersionStr = str;
					break;
				}
			}
			bool bFoundapplicationCompatibility = FALSE;
			for (lineStr = f.GetFirstLine(); !f.Eof() && !bFoundapplicationCompatibility; lineStr = f.GetNextLine())
			{
				int chPos;
				// does this line have our itemTextStr?
				chPos = lineStr.Find(wxString::FromAscii(applicationCompatibility));
				if (chPos != wxNOT_FOUND)
				{
					bFoundapplicationCompatibility = TRUE;
					wxString str = lineStr;
					int beginQPos, endQPos;
					beginQPos = str.Find(_T("\""));
					wxASSERT(beginQPos != wxNOT_FOUND);
					str = str.Mid(beginQPos+1);
					endQPos = str.Find(_T("\""));
					wxASSERT(endQPos != wxNOT_FOUND);
					str = str.Mid(0,endQPos);
					applicationCompatibilityStr = str;
					break;
				}
			}
			bool bFoundadminModified = FALSE;
			for (lineStr = f.GetFirstLine(); !f.Eof() && !bFoundadminModified; lineStr = f.GetNextLine())
			{
				int chPos;
				// does this line have our itemTextStr?
				chPos = lineStr.Find(wxString::FromAscii(adminModified));
				if (chPos != wxNOT_FOUND)
				{
					bFoundadminModified = TRUE;
					wxString str = lineStr;
					int beginQPos, endQPos;
					beginQPos = str.Find(_T("\""));
					wxASSERT(beginQPos != wxNOT_FOUND);
					str = str.Mid(beginQPos+1);
					endQPos = str.Find(_T("\""));
					wxASSERT(endQPos != wxNOT_FOUND);
					str = str.Mid(0,endQPos);
					adminModifiedStr = str;
					break;
				}
			}
		}
		f.Close();
	}

}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if backup copy was successful, FALSE if the copy process failed
/// \param      -> AIuserProfilesWorkFolderPath path and name of AI_UserProfiles.xml in the work folder
/// \param      <- backupPathNameUsed the string value returned of the backup file name generated for the
///                 backup, i.e., of the form AI_UserProfiles_Old_nn.xml where nn is 01, 02, 03, etc.
/// \remarks
/// Called from the App's OnInit().
/// Makes a backup copy of the user's AI_UserProfiles.xml file naming it to AI_UserProfiles_Oldnn.xml
/// where nn is a numerical 01, 02, 03, etc., to avoid overwriting a previous backup. The backup copy
/// is made in the user's work folder (m_userProfileFileWorkFolderPath). This function does not remove
/// the original AI_UserProfiles.xml file at m_userProfileFileWorkFolderPath.
/////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::BackupExistingUserProfilesFileInWorkFolder(wxString AIuserProfilesWorkFolderPath, wxString& backupPathNameUsed)
{
	bool bBackupOK = TRUE;
	bool bExists;
	bExists = ::wxFileExists(AIuserProfilesWorkFolderPath);
	wxASSERT(bExists == TRUE);
	if (bExists)
	{
		wxString backupName;
		backupName = GetUniqueIncrementedFileName(AIuserProfilesWorkFolderPath,incrementViaNextAvailableNumber,FALSE,2,_T("_Old_"));
		// We should now have a backup name that does not yet exist as a file in the work folder.
		// Now copy the existing AI_UserProfiles.xml to the backupName (backupName is full path + filename).
		bool bCopiedOK;
		bCopiedOK = ::wxCopyFile(AIuserProfilesWorkFolderPath,backupName); // overwrite is default but shouldn't be one there with name backupName
		if (!bCopiedOK)
		{
			bBackupOK = FALSE;
		}
		backupPathNameUsed = backupName; // to return to caller via reference
	}
	return bBackupOK;
}


/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      <- pMenuStructure  a pointer to the AI_MenuStructure struct that is being populated
/// \param      <- m_mapMenuLabelStrToIdInt a mapping of menu id strings to their menu id int values
/// \remarks
/// Called from: the App's OnInit().
/// It represents Adapt It's default menu structure as derived from a temporary version of AI's
/// menu bar (without being configured for any user profiles). Assumes pMenuStructure is NULL
/// on entry to this function. While setting up the default menu structure, this function also
/// populates the m_mapMenuLabelStrToIdInt map which is used in the
/// GetAndAssignIdValuesToUserProfilesStruct().
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetupDefaultMenuStructure(AI_MenuStructure*& pMenuStructure, MapMenuLabelStrToIdInt& m_mapMenuLabelStrToIdInt)
{
	wxASSERT(pMenuStructure == NULL);
	AI_MainMenuItem* pMainMenuItem = NULL;
	AI_SubMenuItem* pSubMenuItem = NULL;

	pMenuStructure = new AI_MenuStructure;
	wxASSERT(pMenuStructure != NULL);
	// create a temporary AI menu bar on the heap from the wxDesigner's AIMenuBarFunc() function.
	// This represents the default menu bar, as it does not get changed to accommodate the
	// current user profile by ConfigureInterfaceForUserProfile()
	wxMenuBar* pMenuBar;
	pMenuBar = AIMenuBarFunc();
	wxASSERT(pMenuBar != NULL);

	MapMenuLabelStrToIdInt::iterator iter;
	//m_mapMenuLabelStrToIdInt.clear(); // don't call .clear() here because we've already populated the map
	// with the untranslated menu label string-to-int associations via the earlier call of 
	// SetupUnTranslatedMapMenuLabelStrToIdInt() in OnInit(). Here below we further populate the map
	// with the translated menu label strings associating them with their ID ints.

	if (pMenuBar == NULL)
	{
		wxASSERT(FALSE);
		wxLogDebug(_T("The pointer to the temporary AI menu bar is NULL\n -   aborting the SetupDefaultMenuStructure() function"));
		return;
	}
	int ct;
	int mbct = pMenuBar->GetMenuCount(); // get the number of top level menu items
	for (ct = 0; ct < mbct; ct++)
	{
		wxMenu* pmbMainMenuItem = pMenuBar->GetMenu(ct); // AI menu bar
		wxASSERT(pmbMainMenuItem != NULL);
		if (pmbMainMenuItem != NULL)
		{
			pMainMenuItem = new AI_MainMenuItem;
			wxASSERT(pMainMenuItem != NULL);
			// initialize the new pMainMenuItem's members
			pMainMenuItem->mainMenuIDint = -1;
			//pMainMenuItem->mainMenuID = _T("");
			pMainMenuItem->mainMenuLabel = _T("");
			pMainMenuItem->aiSubMenuItems.Clear();

			// get values for pMainMenuItem's members from the temp AI menu bar pMenuBar
			wxString mbMainMenuText = pMenuBar->GetMenuLabel(ct); // includes accelerator chars
			pMainMenuItem->mainMenuLabel = mbMainMenuText;
			// For some reason a wxMenu item (top level or sub menu item) does not have a
			// GetId() method. Only a wxMenuItem has a GetId() method. Hence, we have to
			// determine the int ID of a main menu item in a round-about way.

			pMainMenuItem->mainMenuIDint = GetTopLevelMenuID(mbMainMenuText); // Note: a top level menu cannot be menuSeparator
			//pMainMenuItem->mainMenuID = // we can get along without this string representation mainMenuID
			// Consider: When the compiled all of the menu item IDs are determined and those const int values
			// are used at run time. They don't change during execution or even from session to session of a
			// given build/release of the application. So we should be able to ignore them in our AI_MenuStructure
			// especially since the mainMenuIDint value never changes.

			// insert the main menu id string/int association into the m_mapMenuLabelStrToIdInt if none already exists
			// Note: we remove menu decorations since we want to be able to look up the plain label in
			// the map
			wxString mainMenuItemLabelPlain = mbMainMenuText; //RemoveMenuLabelDecorations(mbMainMenuText);
			iter = m_mapMenuLabelStrToIdInt.find(mainMenuItemLabelPlain);
			if (iter != m_mapMenuLabelStrToIdInt.end())
			{
				// key exists in the map
				m_mapMenuLabelStrToIdInt.insert(*iter); // associates (any new) pMainMenuItem->mainMenuIDint value with the keyCopy
			}
			else
			{
				// key not in the map
				// The [] index operator can be used either of two ways in assignment statement
				m_mapMenuLabelStrToIdInt[mainMenuItemLabelPlain] = pMainMenuItem->mainMenuIDint; // clearest
				// or, the following is equivalent, but not so clear
				//pThisMap->operator[](mbMainMenuText) = pMainMenuItem->mainMenuIDint;
				// NOTE: The docs say of the wxHashMap::operator[] "Use it as an array subscript.
				// The only difference is that if the given key is not present in the hash map,
				// an element with the default value_type() is inserted in the table."
			}

			int i;
			int imbct;
			imbct = pmbMainMenuItem->GetMenuItemCount(); // AI menu bar
			for (i = 0; i < imbct; i++)
			{
				wxMenuItemList pmbSubMenuItems = pmbMainMenuItem->GetMenuItems(); // AI menu bar
				wxMenuItemList::Node* mbListNode; // AI menu bar
				mbListNode = pmbSubMenuItems.Item(i); // AI menu bar
				wxMenuItem* pmbSubMenuItem = mbListNode->GetData(); // AI menu bar
				wxASSERT(pmbSubMenuItem != NULL);
				pSubMenuItem = new AI_SubMenuItem;
				// initialize pSubMenuItem's members
				wxASSERT(pSubMenuItem != NULL);
				//pSubMenuItem->subMenuID = _T("");
				pSubMenuItem->subMenuIDint = -1;
				pSubMenuItem->subMenuLabel = _T("");
				pSubMenuItem->subMenuHelp = _T("");
				pSubMenuItem->subMenuKind = _T("");

				// get values for pSubMenuItem's members from the temp AI menu bar pMenuBar's
				// pmbSubMenuItem objects
				//pSubMenuItem->subMenuID = // we can get along without this string representation mainMenuID
				// Consider: When the compiled all of the menu item IDs are determined and those const int values
				// are used at run time. They don't change during execution or even from session to session of a
				// given build/release of the application. So we should be able to ignore them in our AI_MenuStructure
				// especially since the mainMenuIDint value never changes.
				pSubMenuItem->subMenuIDint = pmbSubMenuItem->GetId(); // GetId() returns -2 for menu separator
				pSubMenuItem->subMenuLabel = pmbSubMenuItem->GetItemLabel();
				pSubMenuItem->subMenuHelp = pmbSubMenuItem->GetHelp();
				pSubMenuItem->subMenuKind = GetMenuItemKindAsString(pmbSubMenuItem->GetKind());
				// insert the sub menu id string/int association into the m_mapMenuLabelStrToIdInt if none already exists
				// Note: we remove menu decorations since we want to be able to look up the plain label in
				// the map
				wxString subMenuItemLabelPlain = pSubMenuItem->subMenuLabel; //RemoveMenuLabelDecorations(pSubMenuItem->subMenuLabel);
				if (pSubMenuItem->subMenuKind == _T("wxITEM_SEPARATOR"))
					subMenuItemLabelPlain = _T("menuSeparator");

				// Note: the \t chars in the xml and internal strings become \\t literals
				// and need to be changed to \t to work in the menus.
				wxString labelStr = subMenuItemLabelPlain;
				subMenuItemLabelPlain.Replace(_T("\\t"),_T("\t"));

				iter = m_mapMenuLabelStrToIdInt.find(subMenuItemLabelPlain);
				if (iter != m_mapMenuLabelStrToIdInt.end())
				{
					// key exists in the map
					m_mapMenuLabelStrToIdInt.insert(*iter); // associates (any new) pNewTU value with the keyCopy
				}
				else
				{
					// key not in the map
					// The [] index operator can be used either of two ways in assignment statement
					m_mapMenuLabelStrToIdInt[subMenuItemLabelPlain] = pSubMenuItem->subMenuIDint; // clearest
					// or, the following is equivalent, but not so clear
					//pThisMap->operator[](keyCopy) = pSubMenuItem->subMenuIDint;
					// NOTE: The docs say of the wxHashMap::operator[] "Use it as an array subscript.
					// The only difference is that if the given key is not present in the hash map,
					// an element with the default value_type() is inserted in the table."
				}
				// add pSubMenuItem to the pMainMenuItem's aiSubMenuItems list
				pMainMenuItem->aiSubMenuItems.Append(pSubMenuItem);
			}
			pMenuStructure->aiMainMenuItems.Append(pMainMenuItem);
		}
	}

	// Note: calling delete on pMenuBar is sufficient; because of its hierarchy of ownership
	// all of its child objects get destroyed automatically.
	delete pMenuBar;
	pMenuBar = (wxMenuBar*)NULL;
}

// This function's code borrowed brom SetupDefaultMenuStructure(). In this function, however, we do not
// build any AI_MenuStructure, but simply populate the m_mapMenuLabelStrToIdInt map with the untranslated
// unlocalized menu strings. Hence this function is called before any non-English locale catalog is loaded
// in OnInit().
void CAdapt_ItApp::SetupUnTranslatedMapMenuLabelStrToIdInt(MapMenuLabelStrToIdInt& m_mapMenuLabelStrToIdInt)
{
	wxMenuBar* pMenuBar;
	pMenuBar = AIMenuBarFunc();
	wxASSERT(pMenuBar != NULL);

	MapMenuLabelStrToIdInt::iterator iter;
	m_mapMenuLabelStrToIdInt.clear(); // OK to call clear() here

	if (pMenuBar == NULL)
	{
		wxASSERT(FALSE);
		wxLogDebug(_T("The pointer to the temporary AI menu bar is NULL\n -   aborting the SetupDefaultMenuStructure() function"));
		return;
	}
	int ct;
	int mbct = pMenuBar->GetMenuCount(); // get the number of top level menu items
	for (ct = 0; ct < mbct; ct++)
	{
		wxMenu* pmbMainMenuItem = pMenuBar->GetMenu(ct); // AI menu bar
		wxASSERT(pmbMainMenuItem != NULL);
		if (pmbMainMenuItem != NULL)
		{
			//pMainMenuItem = new AI_MainMenuItem;
			//wxASSERT(pMainMenuItem != NULL);
			//// initialize the new pMainMenuItem's members
			//pMainMenuItem->mainMenuIDint = -1;
			////pMainMenuItem->mainMenuID = _T("");
			//pMainMenuItem->mainMenuLabel = _T("");
			//pMainMenuItem->aiSubMenuItems.Clear();

			// get values for pMainMenuItem's members from the temp AI menu bar pMenuBar
			wxString mbMainMenuText = pMenuBar->GetMenuLabel(ct); // includes accelerator chars
			//pMainMenuItem->mainMenuLabel = mbMainMenuText;
			// For some reason a wxMenu item (top level or sub menu item) does not have a
			// GetId() method. Only a wxMenuItem has a GetId() method. Hence, we have to
			// determine the int ID of a main menu item in a round-about way.

			//pMainMenuItem->mainMenuIDint = GetTopLevelMenuID(mbMainMenuText); // Note: a top level menu cannot be menuSeparator
			//pMainMenuItem->mainMenuID = // we can get along without this string representation mainMenuID
			// Consider: When the compiled all of the menu item IDs are determined and those const int values
			// are used at run time. They don't change during execution or even from session to session of a
			// given build/release of the application. So we should be able to ignore them in our AI_MenuStructure
			// especially since the mainMenuIDint value never changes.

			// insert the main menu id string/int association into the m_mapMenuLabelStrToIdInt if none already exists
			// Note: we remove menu decorations since we want to be able to look up the plain label in
			// the map
			wxString mainMenuItemLabelPlain = mbMainMenuText; //RemoveMenuLabelDecorations(mbMainMenuText);
			iter = m_mapMenuLabelStrToIdInt.find(mainMenuItemLabelPlain);
			if (iter != m_mapMenuLabelStrToIdInt.end())
			{
				// key exists in the map
				m_mapMenuLabelStrToIdInt.insert(*iter); // associates (any new) pMainMenuItem->mainMenuIDint value with the keyCopy
			}
			else
			{
				// key not in the map
				// The [] index operator can be used either of two ways in assignment statement
				m_mapMenuLabelStrToIdInt[mainMenuItemLabelPlain] = GetTopLevelMenuID(mbMainMenuText); //pMainMenuItem->mainMenuIDint; // clearest
				// or, the following is equivalent, but not so clear
				//pThisMap->operator[](mbMainMenuText) = pMainMenuItem->mainMenuIDint;
				// NOTE: The docs say of the wxHashMap::operator[] "Use it as an array subscript.
				// The only difference is that if the given key is not present in the hash map,
				// an element with the default value_type() is inserted in the table."
			}

			int i;
			int imbct;
			imbct = pmbMainMenuItem->GetMenuItemCount(); // AI menu bar
			for (i = 0; i < imbct; i++)
			{
				wxMenuItemList pmbSubMenuItems = pmbMainMenuItem->GetMenuItems(); // AI menu bar
				wxMenuItemList::Node* mbListNode; // AI menu bar
				mbListNode = pmbSubMenuItems.Item(i); // AI menu bar
				wxMenuItem* pmbSubMenuItem = mbListNode->GetData(); // AI menu bar
				wxASSERT(pmbSubMenuItem != NULL);
				//pSubMenuItem = new AI_SubMenuItem;
				//// initialize pSubMenuItem's members
				//wxASSERT(pSubMenuItem != NULL);
				////pSubMenuItem->subMenuID = _T("");
				//pSubMenuItem->subMenuIDint = -1;
				//pSubMenuItem->subMenuLabel = _T("");
				//pSubMenuItem->subMenuHelp = _T("");
				//pSubMenuItem->subMenuKind = _T("");

				// get values for pSubMenuItem's members from the temp AI menu bar pMenuBar's
				// pmbSubMenuItem objects
				//pSubMenuItem->subMenuID = // we can get along without this string representation mainMenuID
				// Consider: When the compiled all of the menu item IDs are determined and those const int values
				// are used at run time. They don't change during execution or even from session to session of a
				// given build/release of the application. So we should be able to ignore them in our AI_MenuStructure
				// especially since the mainMenuIDint value never changes.
				//pSubMenuItem->subMenuIDint = pmbSubMenuItem->GetId(); // GetId() returns -2 for menu separator
				//pSubMenuItem->subMenuLabel = pmbSubMenuItem->GetItemLabel();
				//pSubMenuItem->subMenuHelp = pmbSubMenuItem->GetHelp();
				//pSubMenuItem->subMenuKind = GetMenuItemKindAsString(pmbSubMenuItem->GetKind());
				// insert the sub menu id string/int association into the m_mapMenuLabelStrToIdInt if none already exists
				// Note: we remove menu decorations since we want to be able to look up the plain label in
				// the map
				wxString subMenuItemLabelPlain = pmbSubMenuItem->GetItemLabel(); //pSubMenuItem->subMenuLabel; //RemoveMenuLabelDecorations(pSubMenuItem->subMenuLabel);
				if (GetMenuItemKindAsString(pmbSubMenuItem->GetKind()) == _T("wxITEM_SEPARATOR")) //if (pSubMenuItem->subMenuKind == _T("wxITEM_SEPARATOR"))
					subMenuItemLabelPlain = _T("menuSeparator");

				// Note: the \t chars in the xml and internal strings become \\t literals
				// and need to be changed to \t to work in the menus.
				wxString labelStr = subMenuItemLabelPlain;
				subMenuItemLabelPlain.Replace(_T("\\t"),_T("\t"));

				iter = m_mapMenuLabelStrToIdInt.find(subMenuItemLabelPlain);
				if (iter != m_mapMenuLabelStrToIdInt.end())
				{
					// key exists in the map
					m_mapMenuLabelStrToIdInt.insert(*iter); // associates (any new) pNewTU value with the keyCopy
				}
				else
				{
					// key not in the map
					// The [] index operator can be used either of two ways in assignment statement
					m_mapMenuLabelStrToIdInt[subMenuItemLabelPlain] = pmbSubMenuItem->GetId(); //pSubMenuItem->subMenuIDint; // clearest
					// or, the following is equivalent, but not so clear
					//pThisMap->operator[](keyCopy) = pSubMenuItem->subMenuIDint;
					// NOTE: The docs say of the wxHashMap::operator[] "Use it as an array subscript.
					// The only difference is that if the given key is not present in the hash map,
					// an element with the default value_type() is inserted in the table."
				}
				// add pSubMenuItem to the pMainMenuItem's aiSubMenuItems list
				//pMainMenuItem->aiSubMenuItems.Append(pSubMenuItem);
			}
			//pMenuStructure->aiMainMenuItems.Append(pMainMenuItem);
		}
	}

	// Note: calling delete on pMenuBar is sufficient; because of its hierarchy of ownership
	// all of its child objects get destroyed automatically.
	delete pMenuBar;
	pMenuBar = (wxMenuBar*)NULL;
}

/*
// The following version of SetupDefaultMenuStructure() was based on collecting the
// necessary data from the defaultMenuStructure[] array of strings in the App. This
// version was replaced by another version (see above) that collects the same data
// but does so from a temporary AI menu bar, thus eliminating the need to store the
// redundant defaultMenuStructure[] array.
/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      <- pMenuStructure  a pointer to the AI_MenuStructure struct that is being populated
/// \remarks
/// Called from: the App's OnInit() and CAdminEditMenuProfile::InitDialog. It is only
/// called if the app cannot find the AI_UserProfiles.xml file and it must use
/// SetupDefaultMenuStructure() to establish its internal representation of the default
/// menu structure. When AI_UserProfiles.xml is available (the usual case) the
/// m_pAI_MenuStructure is populated by the AtPROFILEEndTag() function in XML.cpp,
/// rather than by this SetupDefaultMenuStructure() function.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetupDefaultMenuStructure(AI_MenuStructure*& pMenuStructure)
{
	wxString field = _T("");
	int nDefaultMenuStructureItems;
	AI_MainMenuItem* pMainMenuItem = NULL;
	AI_SubMenuItem* pSubMenuItem = NULL;
	nDefaultMenuStructureItems = sizeof(defaultMenuStructure)/sizeof(wxString);
	int i;
	for (i = 0; i < nDefaultMenuStructureItems; i++)
	{
		// scan and parse each defaultProfileItems line
		field.Empty();
		int ct;
		for (ct = 0; ct < (int)defaultMenuStructure[i].Length(); ct++)
		{
			// defaultMenuStructure[i] represents a whole string line of concatenated tags, attributes and values
			wxString lineStr;
			lineStr = defaultMenuStructure[i];
			if (lineStr.GetChar(ct) != _T(':'))
			{
				field += lineStr.GetChar(ct);
			}
			else
			{
				// we're at the end of a field and field contains the string token
				// up to, but not including the : delimiter.
				// If the field doesn't have an '=' in it, it should be an all-caps
				// tag name; if it has an '=' in it, the field should contain an
				// attribute name followed by the '=' with the attribute's value
				// within quote marks, i.e., attributeName="value".
				// Parse the field into its parts
				if (field.Find(_T("=")) == wxNOT_FOUND)
				{
					// No '=' in the field so field itself should be a tag name
					if (field == wxString::FromAscii(sub_menu))
					{
						pSubMenuItem = new AI_SubMenuItem;
						pSubMenuItem->subMenuID = _T("");
						pSubMenuItem->subMenuLabel = _T("");
						pSubMenuItem->subMenuHelp = _T("");
						pSubMenuItem->subMenuKind = _T("");
					}
					else if (field == wxString::FromAscii(end_sub_menu))
					{
						wxASSERT(pSubMenuItem != NULL);
						wxASSERT(pMainMenuItem != NULL);
						pMainMenuItem->aiSubMenuItems.Append(pSubMenuItem);
						pSubMenuItem = (AI_SubMenuItem*)NULL; // ready for the next use
					}
					else if (field == wxString::FromAscii(main_menu))
					{
						pMainMenuItem = new AI_MainMenuItem;
						pMainMenuItem->mainMenuID = _T("");
						pMainMenuItem->mainMenuLabel = _T("");
						pMainMenuItem->aiSubMenuItems.Clear();
					}
					else if (field == wxString::FromAscii(end_main_menu))
					{
						wxASSERT(pMenuStructure != NULL);
						wxASSERT(pMainMenuItem != NULL);
						pMenuStructure->aiMainMenuItems.Append(pMainMenuItem);
						pMainMenuItem = (AI_MainMenuItem*)NULL; // ready for the next use
					}
					else if (field == wxString::FromAscii(menuStructure))
					{
						pMenuStructure = new AI_MenuStructure;
						pMenuStructure->aiMainMenuItems.Clear();
					}
					else if (field == wxString::FromAscii(end_menuStructure))
					{
						;
					}
				}
				else
				{
					// field has an '=' char in it so it should be an attribute/value
					// representation
					wxString attrStr;
					wxString valueStr;
					attrStr = field.Mid(0,field.Find(_T("=")));
					attrStr.Trim(FALSE);
					attrStr.Trim(TRUE);
					valueStr = field.Mid(field.Find(_T("=")));
					valueStr.Replace(_T("="),_T(""));
					valueStr.Replace(_T("\""),_T(""));
					valueStr.Trim(FALSE);
					valueStr.Trim(TRUE);
					if (attrStr == wxString::FromAscii(subMenuID))
					{
						wxASSERT(pSubMenuItem != NULL);
						pSubMenuItem->subMenuID = valueStr;
					}
					else if (attrStr == wxString::FromAscii(subMenuLabel))
					{
						wxASSERT(pSubMenuItem != NULL);
						pSubMenuItem->subMenuLabel = valueStr;
					}
					else if (attrStr == wxString::FromAscii(subMenuHelp))
					{
						wxASSERT(pSubMenuItem != NULL);
						pSubMenuItem->subMenuHelp = valueStr;
					}
					else if (attrStr == wxString::FromAscii(subMenuKind))
					{
						wxASSERT(pSubMenuItem != NULL);
						pSubMenuItem->subMenuKind = valueStr;
					}
					else if (attrStr == wxString::FromAscii(mainMenuLabel))
					{
						wxASSERT(pMainMenuItem != NULL);
						pMainMenuItem->mainMenuLabel = valueStr;
					}
					else if (attrStr == wxString::FromAscii(mainMenuID))
					{
						wxASSERT(pMainMenuItem != NULL);
						pMainMenuItem->mainMenuID = valueStr;
					}
				}

				field.Empty(); // ready for next field
			}
		}
		// We're at the end of a parsed line
	}
}
*/

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      <- pUserProfiles  a pointer to the UserProfiles struct that is being destroyed
/// \remarks
/// Called from: the App's OnInit(), OnExit(), CAdminEditMenuProfile's InitDialog(), and
/// its class destructor and ReportMenuAndUserProfilesInconsistencies().
/// It deallocates the memory of the profileItemList items, and finally of the pUserProfiles
/// itself.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DestroyUserProfiles(UserProfiles*& pUserProfiles)
{
	if (pUserProfiles != NULL)
	{
		ProfileItemList::Node* pos;
		int count;
		int item_count = (int)pUserProfiles->profileItemList.GetCount();
		for(count = 0; count < item_count; count++)
		{
			pos = pUserProfiles->profileItemList.Item(count);
			UserProfileItem* pItem;
			pItem = pos->GetData();
			//wxLogDebug(_T("Deleting UserProfileItem %s"),pItem->itemText.c_str());
			delete pItem;
			pItem = (UserProfileItem*)NULL;
		}
		pUserProfiles->profileItemList.Clear();
		//wxLogDebug(_T("Deleting m_pUserProfiles - end"));
		delete pUserProfiles;
		pUserProfiles = (UserProfiles*)NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      <- pMenuStructure  a pointer to the AI_MenuStructure struct that is
///                 being destroyed
/// \remarks
/// Called from: the App's OnExit().
/// It deallocates the memory of the individual main menu items and sub menu items,
/// and finally of the pMenuStructure itself.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DestroyMenuStructure(AI_MenuStructure*& pMenuStructure)
{
	if (pMenuStructure != NULL)
	{
		MainMenuItemList::Node* mmpos;
		int ct_mm;
		int total_mm = (int)pMenuStructure->aiMainMenuItems.GetCount();
		for(ct_mm = 0; ct_mm < total_mm; ct_mm++)
		{
			mmpos = pMenuStructure->aiMainMenuItems.Item(ct_mm);
			AI_MainMenuItem* pmmItem;
			pmmItem = mmpos->GetData();
			wxASSERT(pmmItem != NULL);

			SubMenuItemList::Node* smpos;
			int ct_sm;
			int total_sm = (int)pmmItem->aiSubMenuItems.GetCount();
			for (ct_sm = 0; ct_sm < total_sm; ct_sm++)
			{
				smpos = pmmItem->aiSubMenuItems.Item(ct_sm);
				AI_SubMenuItem* psmItem;
				psmItem = smpos->GetData();
				wxASSERT(psmItem != NULL);
				//wxLogDebug(_T("Deleting submenu Item %s"),psmItem->subMenuLabel.c_str());
				delete psmItem;
				psmItem = (AI_SubMenuItem*)NULL;
			}
			pmmItem->aiSubMenuItems.Clear();
			//wxLogDebug(_T("Deleting mainmenu Item %s"),pmmItem->mainMenuLabel.c_str());
			delete pmmItem;
			pmmItem = (AI_MainMenuItem*)NULL;
		}
		pMenuStructure->aiMainMenuItems.Clear();
		//wxLogDebug(_T("Deleting m_pAI_MenuStructure - end"));
		delete pMenuStructure;
		pMenuStructure = (AI_MenuStructure*)NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE on success, FALSE if a problem occurred
/// \param      -> fullFilePath  path and file name of the AI_UserProfiles.xml file being
///                 accessed (may be the one in work folder or setup install folder)
/// \remarks
/// Called from the App's OnEditUserMenuSettingsProfiles() after User Workflow
/// Profiles editing, and from the App's OnInit() to upgrade (or downgrade) a
/// modified AI_UserProfiles.xml file to a newer (or older) version after a
/// version update.
/// SaveUserProfilesMergingDataToXMLFile() saves edits of user profiles to the
/// wxTextFile representing AI_UserProfiles.xml file on disk.
/// The AI_UserProfiles.xml file is fairly small (only about 45kb) so we
/// open it as a wxTextFile (into memory), make necessary changes according
/// to the current m_pUserProfiles and write it back out in a single write
/// operation. If AI_UserProfiles.xml doesn't exist we create a new wxTextFile
/// and call BuildUserProfileXMLFile() passing our new wxTextFile to that
/// function to create one anew. We can do double duty with this function:
/// (1) Save edits made by an administrator to the User Workflow Profiles dialog
/// back to the AI_UserProfiles.xml file located in the work folder, or
/// (2) Merge the edits of a modified existing AI_UserProfiles.xml file into
/// a newer version of AI_UserProfiles.xml that was installed as an AI version
/// update since the last running of the application.
/// The path established in OnInit() to the AI_UserProfiles.xml file is stored
/// in the m_userProfileFileWorkFolderPath member variable.
/////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::SaveUserProfilesMergingDataToXMLFile(wxString fullFilePath)
{
	// Note: fullFilePath can be the user's work folder, or the install setup folder
	wxTextFile textFile;

	// Does AI_UserProfiles.xml exist in the work folder
	bool bUserProfilesFileExists = wxFileExists(fullFilePath);
	wxString userProfileFileSetupInstallPath = m_xmlInstallPath + PathSeparator + _T("AI_UserProfiles.xml");

	bool bThisIsAnUpgradeOfProfileFile;
	if (fullFilePath == userProfileFileSetupInstallPath)
		bThisIsAnUpgradeOfProfileFile = TRUE;
	else
		bThisIsAnUpgradeOfProfileFile = FALSE;

	if (!bUserProfilesFileExists)
	{
		// No AI_UserProfiles.xml file exists at the fullFilePath location
		// This shouldn't happen in the case we are being called to merge a newer AI_UserProfiles.xml
		// file with a modified AI_UserProfiles.xml in the user's work folder, but for safety sake:
		if (bThisIsAnUpgradeOfProfileFile)
		{
			// The fullFilePath pointed to a AI_UserProfiles.xml file in the install setup
			// folder, but no AI_UserProfiles.xml exist there. There is nothing to merge
			// and we don't want to create one there since that is the job of the AI installation
			// process, so just return FALSE from SaveUserProfilesMergingDataToXMLFile(). Any
			// error/warning messages are the responsibility of the caller.
			return FALSE;
		}
		wxString msg = _("The AI_UserProfiles.xml file was not located at the following path:\n   %s\nA new AI_UserProfiles.xml file will be created there.");
		msg = msg.Format(msg,fullFilePath.c_str());
		wxMessageBox(msg,_T(""),wxICON_WARNING);
		// Construct a new AI_UserProfiles.xml file from our internal data
		textFile.Create(fullFilePath); // Create() must only be called when the file doesn't exist - verified above
		// Note textFile is empty at this point
		bool bOK;
		bOK = textFile.Open(fullFilePath);
		wxCHECK_MSG(bOK, FALSE, _T("SaveUserProfilesMergingDataToXMLFile() didn't open textFile in !bUserProfilesFileExists block"));
		BuildUserProfileXMLFile(&textFile);
		// Write the modified wxText file back out to disk
		bOK = textFile.Write(); // no need to do anything special for Unicode
		wxCHECK_MSG(bOK, FALSE, _T("SaveUserProfilesMergingDataToXMLFile() textFile.Write() failed in !bUserProfilesFileExists block"));
	}
	else
	{
		// Read the existing xml file into memory using wxTextFile, so we don't have
		// to recreate the whole xml file. All we need to do is to compare the data in
		// memory with the xml file which is in memory as a wxTextFile, and make changes
		// there before saving the file back to disk.
		// Note: fullFilePath may point to the AI_UserProfiles.xml in the setup folder (when
		// merging changes into an upgraded AI_UserProfiles.xml), or it may point to the
		// AI_UserProfiles.xml in the user's work folder (when doing a normal save/merge of
		// changes made in the User Workflow Profiles dialog).
		bool bOpenedOK;
		bOpenedOK = textFile.Open(fullFilePath);
		if (!bOpenedOK)
		{
			wxString msg = _("Unable to open the AI_UserProfiles.xml file at the following path:\n   %s\nChanges to user workflow profiles will not be saved.\nEnsure that the AI_UserProfiles.xml file is not open in another program, then try again.");
			msg = msg.Format(msg,fullFilePath.c_str());
			wxMessageBox(msg,_T(""),wxICON_WARNING);
			return FALSE;
		}
		else
		{
			// The AI_UserProfiles.xml file is now in memory and accessible line-by-line through the
			// methods of wxTextFile.
			// Note: The AI_UserProfiles.xml file was read from the user's work folder and parsed into
			// the m_pUserProfiles struct prior to the calling of SaveUserProfileMergingDataToXMLFile().
			// (whether in InitDialog in the AdminEditMenuProfile class or in the App's OnInit). Therefore,
			// the AI_UserProfiles.xml file (just read above into memory as a wxTextFile) is either
			// identical in structure to the xml file on disk (when saving edits) or similar if not
			// identical in structure (for version upgrade). If identical, the process below should
			// account for all changes. If we are merging changes into a newer AI_UserProfiles.xml file
			// from the setup folder, there may be more candidate profile items in the setup folder's
			// version than in the current work folder's version. Those will simply retain their
			// existing defaul values. If the setup folder's version has fewer candidate profile items (not
			// likely) and a change was made for one of those now-missing items, the change will simply be
			// ignored. During editing in AdminEditMenuProfile dialog, only small parts of the xml data
			// would be modified as a result of the editing process. An administrator could have edited
			// the following from within the dialog:
			// 1. The UserProfiles' wxArrayString of descriptionProfileTexts (4 items, one for each profile)
			//    may have been edited (total of 4 strings of varying length).
			// 2. The UserProfileItem's wxArrayString of usedVisibilityValues (4 items, one for each profile
			//    x 67 profile items) may have been edited (total of 268 1-character strings of the form
			//    "1" or "0".
			// Note: When an administrator only changes the profile selected, but not any individual profile
			// item visibility checkboxes, he does not make any changes to AI_UserProfiles.xml (his change of
			// profile is simply recorded in the project config file.
			//
			// Our approach will be to go through our map of profile changes (m_mapProfileChangesToStringValues)
			// and change the individual lines in our wxTextFile that need to be changed to reflect the
			// administrator's edits. When finished we simply write the wxTextFile back to disk replacing
			// the existing AI_UserProfiles.xml file. If we read AI_UserProfiles.xml from the setup folder,
			// we don't write it back there, but we write it to the current work folder, replacing the
			// older version that was there - which will now have the new version number in its
			// applicationCompatibility attribute matching the one copied from the setup folder.
			// In order to write a wxTextFile to a different location than where we got it in the Open()
			// call, there doesn't appear to be a way to change the writing path, so we will create a new
			// wxTextFile instance, copy all lines from the one we've changed to it and write this new file
			// and simply close the original instance without writing it back to the setup folder.
			//
			// The map key values can be:
			//    1. A contatenation of the string values of itemText + ":" + userProfile for a given
			//       UserProfileItem, for example: "Save As...:Novice"
			//    2. A key may also be the string "descriptionProfileN" where N is 1, 2, 3, or 4 for
			//       those top level items, for example "description3"
			// The key maps to a variable length string for the descriptionProfileN key, and to a
			// "1" or a "2" string for UserProfileItems visibility items.
			wxString keyFromMap;
			wxString valueFromMap;
			MapProfileChangesToStringValues::iterator iter;
			for( iter = m_mapProfileChangesToStringValues.begin(); iter != m_mapProfileChangesToStringValues.end(); ++iter )
			{
				keyFromMap = iter->first;
				valueFromMap = iter->second;
				wxLogDebug(_T("iter->first = %s, iter->second = %s"),keyFromMap.c_str(),valueFromMap.c_str());
				wxString itemTextStr,userProfileStr,descriptionProfileN;
				int colonPos = keyFromMap.Find(_T(':'));
				if (colonPos != wxNOT_FOUND)
				{
					// the keyFromMap is of the form itemText:Novice
					itemTextStr = keyFromMap.Mid(0,colonPos);
					userProfileStr = keyFromMap.Mid(colonPos + 1);
					// in the wxTextFile we search for the line that has itemText="itemTextStr" and
					// from that line we step through each succeeding line until we come to a line
					// that has <PROFILE userProfile="userProfileStr"
					// from that line we get the next line, i.e., itemVisibility="x" and replace
					// the "x" part with the "valueFromMap" (see ReplaceVisibilityStrInwxTextFile).
					int linePos;
					linePos = ReplaceVisibilityStrInwxTextFile(&textFile,itemTextStr,userProfileStr,valueFromMap);
					if (linePos == wxNOT_FOUND)
					{
						// unable to save the field in the wxTextFile
						wxASSERT(FALSE); // notify programmer
						return FALSE;
					}
				}
				else
				{
					// the keyFromMap is of the form descriptionProfileN where N is 1, 2, 3, or 4.
					descriptionProfileN = keyFromMap;
					// In the wxTextFile we search for the line that has descriptionProfileN="str"
					// and we replace the "str" with "valueFromMap".
					// Note: Entity chars are replaced by their xml mandated form (xml_lt, xml_gt,
					// xml_amp, xml_apos, and xml_quote and xml_tab) in ReplaceDescriptionStrInwxTextFile() below.
					int linePos;
					linePos = ReplaceDescriptionStrInwxTextFile(&textFile,descriptionProfileN,valueFromMap);
					if (linePos == wxNOT_FOUND)
					{
						// unable to save the field in the wxTextFile
						wxASSERT(FALSE); // notify programmer
						return FALSE;
					}
				}
			}
			// Lastly, we update the wxTextFile line that contains the attribute: adminModified="" is
			// changed to either adminModified="Yes" or adminModified="No", depending on whether the
			// above edits changed the data to differ from the factory defaults.
			UpdateAdminModifiedLineToYesOrNo(&textFile);
		}
		// Write the modified wxText file back out to disk.
		// Note: If bThisIsAnUpgradeOfProfileFile is TRUE, we don't write the file back to its
		// original setup up folder location, but instead create a new wxTextFile, copy the contents
		// of the one we've modified and write the upgraded one to the user's work folder.
		if (bThisIsAnUpgradeOfProfileFile)
		{
			// This is an upgrade operation, so create a new wxTextFile
			wxTextFile newTextFile;
			// wxTextFile::Create() fails when there already exists the file of the same name
			// so we first remove the existing one in the work folder
			wxASSERT(!m_userProfileFileWorkFolderPath.IsEmpty());
			bool bRemovedFile = FALSE;
			wxString msg = _("Adapt It could not upgrade AI_UserProfiles.xml (modified) with the newer version from the last Adapt It installation.\nAI_UserProfiles.xml may be in use by another program.");
			wxString titleMsg;
			if (wxFileExists(m_userProfileFileWorkFolderPath))
			{
				bRemovedFile = wxRemoveFile(m_userProfileFileWorkFolderPath);
				// tell user if we couldn't remove the work folder's AI_UserProfiles.xml
				if (!bRemovedFile)
				{
					// error message
					titleMsg = _("Unable to remove existing AI_UserProfiles.xml file");
					// msg = _("Adapt It could not upgrade AI_UserProfiles.xml (modified) with the newer version from the last Adapt It installation.\nAI_UserProfiles.xml may be in use by another program.");
					wxMessageBox(msg,titleMsg,wxICON_WARNING);
					return FALSE;
				}
			}
			bool bCreatedOK, bOpenedOK;
			bCreatedOK = newTextFile.Create(m_userProfileFileWorkFolderPath);
			wxCHECK_MSG(bCreatedOK, FALSE, _T("SaveUserProfilesMergingDataToXMLFile() newTextFile.Create() failed in bThisIsAnUpgradeOfProfileFile block"));
			bOpenedOK = newTextFile.Open();
			wxCHECK_MSG(bOpenedOK, FALSE, _T("SaveUserProfilesMergingDataToXMLFile() newTextFile.Open() failed in bThisIsAnUpgradeOfProfileFile block"));
			if (newTextFile.IsOpened())
			{
				// now copy the lines from textFile to newTextFile
				int ct;
				int nLines = textFile.GetLineCount();
				for (ct = 0; ct < nLines; ct++)
				{
					wxString lineStr = textFile.GetLine(ct);
					newTextFile.AddLine(lineStr);
				}
				// save the newTextFile
				bool bWriteOK;
				bWriteOK = newTextFile.Write();
				wxASSERT(bWriteOK != FALSE);
				if (!bWriteOK)
				{
					// error message
					titleMsg = _("Unable to create a new AI_UserProfiles.xml file");
					//msg = _("Adapt It could not upgrade AI_UserProfiles.xml (modified) with the newer version from the last Adapt It installation.\nAI_UserProfiles.xml may be in use by another program.");
					wxMessageBox(msg,titleMsg,wxICON_WARNING);
					return FALSE;
				}
				newTextFile.Close();
			}
			else
			{
				// error message
				titleMsg = _("Unable to create a new AI_UserProfiles.xml file");
				//msg = _("Adapt It could not upgrade AI_UserProfiles.xml (modified) with the newer version from the last Adapt It installation.\nAI_UserProfiles.xml may be in use by another program.");
				wxMessageBox(msg,titleMsg,wxICON_WARNING);
				return FALSE;
			}

		}
		else
		{
			// This is a normal save of edits that have been done in the User Workflow Profile
			// dialog, so write it back to its same location
			textFile.Write(); // no need to do anything special for Unicode
			textFile.Close();
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      -> tempUserProfiles  pointer to the UserProfiles* being compared
/// \param      -> appUserProfiles  pointer to the UserProfiles* the tempUserProfiles
///                 if being compared with to determine changes
/// \remarks
/// Called from the App's OnInit(), and from CAdminEditMenuProfile::OnOK().
/// Populates the App's m_mapProfileChangesToStringValues with user profile changes the user
/// has made to descriptionProfileTexts and/or to UserProfileItems' usedVisibilityValues.
/// The map is used to make changes in the wxTextFile representation of AI_UserProfiles.xml
/// before writing it back to disk in SaveUserProfilesMergingDataToXMLFile().
/// Note: the caller is responsible to call m_mapProfileChangesToStringValues.clear(),
/// to start a fresh map of changes.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::MapChangesInUserProfiles(UserProfiles* tempUserProfiles, UserProfiles* appUserProfiles)
{
	// whm 21Oct10 rewritten so that tempUserProfiles and appUserProfiles can have different counts for their
	// ->descriptionProfileTexts.GetCount() and different counts for their ->profileItemList.GetCount()
	// calls. This will avoid problems for when MapChangesInUserProfiles() is called in OnInit() in the
	// process of upgrading or downgrading versions which involve AI_UserProfiles.xml files having
	// different numbers of these items.
	// Strategy: Fill a temporary map with all items from tempUserProfiles. Then go through all items
	// in the appUserProfiles struct and lookup each item from appUserProfiles to see if it is already
	// in the map of tempUserProfiles items. If it is compare the data of those "common" items only.
	// For those which have changes, enter only the changes in the m_mapProfileChangesToStringValues map.
	// In the process, keep track of how many items were not in common and report that number back through
	// a return value or reference parameter.
	wxASSERT(tempUserProfiles != NULL);
	wxASSERT(appUserProfiles != NULL);

	if (tempUserProfiles != NULL && appUserProfiles != NULL)
	{
		MapProfileChangesToStringValues tempMap;
		MapProfileChangesToStringValues::iterator iter;
		//m_mapProfileChangesToStringValues.clear();
		// Note: The clear() method must be invoked in the caller if a fresh map of changes is desired.

		// Enter all tempUserProfiles items into our tempMap
		// First enter all of tempUserProfiles->descriptionProfileTexts into the map
		int descCt;
		int descTot = (int)tempUserProfiles->descriptionProfileTexts.GetCount();
		for (descCt = 0; descCt < descTot; descCt++)
		{
			// enter all of tempUserProfiles->descriptionProfileTexts into the map
			wxString key = wxString::FromAscii(descriptionProfile);
			key << descCt + 1; // add the numerical suffix as string "1", "2", "3", or "4"
			iter = tempMap.find(key);
			if (iter != tempMap.end())
			{
				// key exists in the map
				tempMap.insert(*iter);
			}
			else
			{
				// key not in the map
				tempMap[key] = tempUserProfiles->descriptionProfileTexts[descCt];
			}
		}
		// Next, enter all of tempUserProfiles->profileItemList items into the tempMap
		ProfileItemList::Node* tpos;
		int count;
		int t_tot = (int)tempUserProfiles->profileItemList.GetCount();
		for(count = 0; count < t_tot; count++)
		{
			tpos = tempUserProfiles->profileItemList.Item(count);
			UserProfileItem* ptItem;
			ptItem = tpos->GetData();
			wxASSERT(ptItem != NULL);
			int ct;
			int ct_t;
			ct_t = (int)ptItem->usedVisibilityValues.GetCount();
			for (ct = 0; ct < ct_t; ct++)
			{
				wxString key = ptItem->itemText + _T(":") + ptItem->usedProfileNames[ct]; // key is itemText + ':' + name of the profile, i.e., "Save As...:Novice"
				iter = tempMap.find(key);
				if (iter != tempMap.end())
				{
					// key exists in the map
					tempMap.insert(*iter);
				}
				else
				{
					// key not in the map
					tempMap[key] = ptItem->usedVisibilityValues[ct];
				}
			}
		}
		// dump the map contents for testing
		//for( iter = tempMap.begin(); iter != tempMap.end(); ++iter )
		//{
		//	wxLogDebug(_T("iter->first = %s, iter->second = %s"),iter->first.c_str(),iter->second.c_str());
		//}

		// Now go through all items of the appUserProfiles struct, and do a lookup to see if
		// each item is in the map. If so, check the map's associated value. If the map's
		// associated value is different, then add that item to the App's
		// m_mapProfileChangesToStringValues map. If any of the appUserProfiles items are
		// not found in the map, we can ignore them, but just get a count of how many such
		// ignored items we encountered.

		int appCt;
		int appTot = (int)appUserProfiles->descriptionProfileTexts.GetCount();
		int nAppItemsNotAmongTempItems = 0;
		int nTempItemsNotAmongAppItems = (int)tempUserProfiles->descriptionProfileTexts.GetCount() + (4*(int)tempUserProfiles->profileItemList.GetCount());
		for (appCt = 0; appCt < appTot; appCt++)
		{
			wxString key = wxString::FromAscii(descriptionProfile);
			key << appCt + 1; // add the numerical suffix as string "1", "2", "3", or "4"

			iter = tempMap.find(key);
			if (iter != tempMap.end())
			{
				// key exists in the map
				wxString keyTemp = iter->first;
				wxString valueTemp = iter->second;
				wxString appDescrText = appUserProfiles->descriptionProfileTexts.Item(appCt);
				// check if the valueTemp differs from the appDescrText
				if (valueTemp != appDescrText)
				{
					// add item to m_mapProfileChangesToStringValues, our App's map of differences/changes
					MapProfileChangesToStringValues::iterator a_iter;
					a_iter = m_mapProfileChangesToStringValues.find(keyTemp);
					if (a_iter != m_mapProfileChangesToStringValues.end())
					{
						// key exists in the map
						m_mapProfileChangesToStringValues.insert(*a_iter);
					}
					else
					{
						// key not in the map
						m_mapProfileChangesToStringValues[keyTemp] = valueTemp;
					}
				}
				nTempItemsNotAmongAppItems--; // decrement from total tempUserProfile items - remainder at end is the significant total
			}
			else
			{
				// key not in the map
				nAppItemsNotAmongTempItems++;
			}
		}
		ProfileItemList::Node* apos;
		MapProfileChangesToStringValues::iterator a_iter;
		int a_tot = (int)appUserProfiles->profileItemList.GetCount();
		for(count = 0; count < a_tot; count++)
		{
			apos = appUserProfiles->profileItemList.Item(count);
			UserProfileItem* paItem;
			paItem = apos->GetData();
			wxASSERT(paItem != NULL);
			int ct;
			int ct_a;
			ct_a = (int)paItem->usedVisibilityValues.GetCount();
			for (ct = 0; ct < ct_a; ct++)
			{
				wxString key = paItem->itemText + _T(":") + paItem->usedProfileNames[ct]; // key is itemText + ':' + name of the profile, i.e., "Save As...:Novice"
				iter = tempMap.find(key);
				if (iter != tempMap.end())
				{
					// key exists in the map
					wxString keyTemp = iter->first;
					wxString valueTemp = iter->second;
					wxString appVisibility = paItem->usedVisibilityValues.Item(ct);
					// check if the valueTemp differs from the appDescrText
					if (valueTemp != appVisibility)
					{
						// add item to m_mapProfileChangesToStringValues, our App's map of differences/changes
						a_iter = m_mapProfileChangesToStringValues.find(keyTemp);
						if (a_iter != m_mapProfileChangesToStringValues.end())
						{
							// key exists in the map
							m_mapProfileChangesToStringValues.insert(*a_iter);
						}
						else
						{
							// key not in the map
							m_mapProfileChangesToStringValues[keyTemp] = valueTemp;
						}
					}
					nTempItemsNotAmongAppItems--; // decrement from total tempUserProfile items - remainder at end is the significant total
				}
				else
				{
					// key not in the map
					nAppItemsNotAmongTempItems++;
				}
			}
		}
		// dump the map contents for testing
		//for( a_iter = m_mapProfileChangesToStringValues.begin(); a_iter != m_mapProfileChangesToStringValues.end(); ++a_iter )
		//{
		//	wxLogDebug(_T("a_iter->first = %s, a_iter->second = %s"),a_iter->first.c_str(),a_iter->second.c_str());
		//}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     a VersionComparison enum with possible values of sameAppVersion,
///             runningAppVersionIsNewer, runningAppVersionIsOlder, or profileVersionDiffers
/// \param      -> oldProfileVersion  string representing the existing profileVersion attribute
///                 value
/// \param      -> oldApplicationCompatibility  string representing the existing
///                 applicationCompatibility value
/// \remarks
/// Called from the App's OnInit().
/// Starting with AI version 6.0.0, the application checks the profileVersion and applicationCompatibility
/// version numbers of any existing AI_UserProfiles.xml file in the Adapt It (Unicode) Work folder against
/// the corresponding numbers of the running application. The version number of the existing AI_UserProfiles.xml
/// are represented in the oldProfileVersion and oldApplicationCompatibility incoming parameters. The
/// running application's corresponding numbers are set as #define constants at the beginning of Adapt_It.h.
/// When an Adapt It user upgrades to a newer version of the application, the installer places the latest version
/// of AI_UserProfiles.xml in the setup folder, but the installer does not copy it at install time to the
/// Adapt It (Unicode) Work folder. Each time the Adapt It application runs, however, this function compares
/// the version numbers of the running application with those of the existing AI_UserProfiles.xml file in the Adapt It
/// (Unicode) Work folder. The running application determines whether the newer version should be copied to
/// overwrite the older existing version, or be merged with the older existing version. This function returns
/// an enum VersionComparison which informs the caller whether comparison of version numbers is: sameAppVersion,
/// runningAppVersionIsNewer, runningAppVersionIsOlder (all comparing the 6.x.x version numbers), or
/// profileVersionDiffers in the case that the profileVersion 1.x version differs (regardless of the 6.x.x
/// versions are).
/////////////////////////////////////////////////////////////////////////////////////////
enum VersionComparison CAdapt_ItApp::CompareRunningVersionWithWorkFolderVersion(wxString oldProfileVersion, wxString oldApplicationCompatibility)
{
	// parse the oldApplicationCompatibility string into int parts
	int nWorkFolderProfileMajV, nWorkFolderProfileMinV;
	int nRunningAppProfileMajV, nRunningAppProfileMinV;
	// get the part of the profileVersion number of the running application
	nRunningAppProfileMajV = PROFILE_VERSION_MAJOR_PART;
	nRunningAppProfileMinV = PROFILE_VERSION_MINOR_PART;
	// parse out the parts of the profileVersioin number of the AI_UserProfiles.xml of
	// the work folder from the incoming oldProfileVersion parameter
	wxString tempStr,intStr;
	tempStr = oldProfileVersion;
	tempStr.Trim(FALSE);
	tempStr.Trim(TRUE);
	intStr = tempStr.Mid(0,tempStr.Find(_T('.')));
	nWorkFolderProfileMajV = wxAtoi(intStr);
	tempStr = tempStr.Mid(tempStr.Find(_T('.'))+1);
	intStr = tempStr.Mid(0,tempStr.Find(_T('.')));
	nWorkFolderProfileMinV = wxAtoi(intStr);
	// Is the running app's profileVersion the same as the work folder's profileVersion?
	// If so, no problem - continue checking the applicationCompatibility version numbers.
	// If the app's profileVersion differs from the work folder's profileVersion we return
	// profileVersionDiffers to the caller.
	if (nRunningAppProfileMajV == nWorkFolderProfileMajV && nRunningAppProfileMinV == nWorkFolderProfileMinV)
	{
		// nothing special need be done, continue checking the applicationCompatibility version
		;
	}
	else if (nRunningAppProfileMajV != nWorkFolderProfileMajV || nRunningAppProfileMinV != nWorkFolderProfileMinV)
	{
		return profileVersionDiffers;
	}

	int nWorkFolderAppCompatMajV, nWorkFolderAppCompatMinV, nWorkFolderAppCompatBuiV;
	int nRunningAppCompatMajV, nRunningAppCompatMinV, nRunningAppCompatBuiV;
	// get the parts of the version number of the running application
	nRunningAppCompatMajV = VERSION_MAJOR_PART;
	nRunningAppCompatMinV = VERSION_MINOR_PART;
	nRunningAppCompatBuiV = VERSION_BUILD_PART;
	// parse out the parts of the version number of the AI_UserProfiles.xml of the work folder
	// from the incoming oldApplicationCompatibility parameter
	tempStr = oldApplicationCompatibility;
	tempStr.Trim(FALSE);
	tempStr.Trim(TRUE);
	intStr = tempStr.Mid(0,tempStr.Find(_T('.')));
	nWorkFolderAppCompatMajV = wxAtoi(intStr);
	tempStr = tempStr.Mid(tempStr.Find(_T('.'))+1);
	intStr = tempStr.Mid(0,tempStr.Find(_T('.')));
	nWorkFolderAppCompatMinV = wxAtoi(intStr);
	tempStr = tempStr.Mid(tempStr.Find(_T('.'))+1);
	intStr = tempStr.Mid(0,tempStr.Find(_T('.')));
	nWorkFolderAppCompatBuiV = wxAtoi(intStr);

	// Is the running app's version the same as the work folder's version?
	// If so, no merge is necessary (caller will simply copy and overwrite the
	// existing older AI_UserProfiles.xml in the work folder). Return FALSE.
	if (nRunningAppCompatMajV == nWorkFolderAppCompatMajV && nRunningAppCompatMinV == nWorkFolderAppCompatMinV && nRunningAppCompatBuiV == nWorkFolderAppCompatBuiV)
	{
		return sameAppVersion;
	}
	// If we get here the running version is either older or newer than the work folder version.
	//
	// Is the running app's version older than the work folder's version?
	// This might happen if the user installed and reverted to running an older
	// version in the 6.x.x series for some reason (after having installed a
	// newer version). In this case we can't really guarantee that the older
	// application will be able to successfully deal with a newer
	// AI_UserProfiles.xml file. So, we return FALSE to get the caller to
	// rename the work folder's copy of AI_UserProfiles.xml to
	// AI_UserProfiles_old.xml and copy the newer AI_UserProfiles.xml from
	// the setup folder to the work folder.
	if (nRunningAppCompatMajV < nWorkFolderAppCompatMajV)
	{
		return runningAppVersionIsOlder;
	}
	else if (nRunningAppCompatMinV < nWorkFolderAppCompatMinV)
	{
		return runningAppVersionIsOlder;
	}
	else if (nRunningAppCompatBuiV < nWorkFolderAppCompatBuiV)
	{
		return runningAppVersionIsOlder;
	}
	// If we get here the running version must be newer
	//
	// Is the running app's version newer than the work folder's version?
	// If so, we should merge the setup folder's newer AI_UserProfiles.xml with
	// the work folder's older AI_UserProfiles.xml file. Return TRUE.
	wxASSERT(nRunningAppCompatMajV > nWorkFolderAppCompatMajV || nRunningAppCompatMinV > nWorkFolderAppCompatMinV || nRunningAppCompatBuiV > nWorkFolderAppCompatBuiV);
	// the defaul bMerge value is TRUE;
	return runningAppVersionIsNewer;
}

/// \return     a wxString representing the running applications version number in 6.x.x format
/// \remarks
/// Called from the App's OnInit() and from ReportMenuAndUserProfilesInconsistencies().
/// Forms a wxString from the app's version constants that are #defined at the
/// beginning of Adapt_It.h. The constants are: VERSION_MAJOR_PART, VERSION_MINOR_PART,
/// and VERSION_BUILD_PART.
/////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetAppVersionOfRunningAppAsString()
{
	wxString str;
	str.Empty();
	str << VERSION_MAJOR_PART;
	str += _T('.');
	str << VERSION_MINOR_PART;
	str += _T('.');
	str << VERSION_BUILD_PART;
	return str;
}

/// \return     a wxString representing the running applications profile version in 1.x format
/// \remarks
/// Called from the App's OnInit() and from ReportMenuAndUserProfilesInconsistencies().
/// Forms a wxString from the app's profile version constants that are #defined at
/// the beginning of Adapt_It.h. The constants are: PROFILE_VERSION_MAJOR_PART
/// and PROFILE_VERSION_MINOR_PART.
/////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetProfileVersionOfRunningAppAsString()
{
	wxString str;
	str.Empty();
	str << PROFILE_VERSION_MAJOR_PART;
	str += _T('.');
	str << PROFILE_VERSION_MINOR_PART;
	return str;
}

/*
enum wxLanguage
{
    // wxLanguage symbol		//	enum	Canonical Description in
    //						val	Name	    Plain English
    //					info->CanonicalName   info->Description
    // user's default/preffered language as got from OS:
    wxLANGUAGE_DEFAULT,			//	0	en_US
    // unknown language, if wxLocale::GetSystemLanguage fails:
    wxLANGUAGE_UNKNOWN,			//	1	null	null

    wxLANGUAGE_ABKHAZIAN,		//	2	ab	Abkhazian
    wxLANGUAGE_AFAR,			//	3	aa	Afar
    wxLANGUAGE_AFRIKAANS,		//	4	af_ZA	Afrikaans
    wxLANGUAGE_ALBANIAN,		//	5	sq_AL	Albanian
    wxLANGUAGE_AMHARIC,			//	6	am	Amharic
    wxLANGUAGE_ARABIC,			//	7	ar	Arabic
    wxLANGUAGE_ARABIC_ALGERIA,	//	8	ar_DZ	Arabic (Algeria)
    wxLANGUAGE_ARABIC_BAHRAIN,	//	9	ar_BH	Arabic (Bahrain)
    wxLANGUAGE_ARABIC_EGYPT,		//	10	ar_EG Arabic (Egypt)
    wxLANGUAGE_ARABIC_IRAQ,		//	11	ar_IQ	Arabic (Iraq)
    wxLANGUAGE_ARABIC_JORDAN,		//	12	ar_JO	Arabic (Jordan)
    wxLANGUAGE_ARABIC_KUWAIT,		//	13	ar_KW	Arabic (Kuwait)
    wxLANGUAGE_ARABIC_LEBANON,	//	14	ar_LB Arabic (Lebanon)
    wxLANGUAGE_ARABIC_LIBYA,		//	15	ar_LY	Arabic (Libya)
    wxLANGUAGE_ARABIC_MOROCCO,	//	16	ar_MA	Arabic (Morocco)
    wxLANGUAGE_ARABIC_OMAN,		//	17	ar_OM	Arabic (Oman)
    wxLANGUAGE_ARABIC_QATAR,		//	18	ar_QA	Arabic (Qatar)
    wxLANGUAGE_ARABIC_SAUDI_ARABIA,	//	19	ar_SA	Arabic (Saudi Arabia)
    wxLANGUAGE_ARABIC_SUDAN,		//	20	ar_SD	Arabic (Sudan)
    wxLANGUAGE_ARABIC_SYRIA,		//	21	ar_SY	Arabic (Syria)
    wxLANGUAGE_ARABIC_TUNISIA,	//	22	ar_TN	Arabic (Tunisia)
    wxLANGUAGE_ARABIC_UAE,		//	23	ar_AE	Arabic (Uae)
    wxLANGUAGE_ARABIC_YEMEN,		//	24	ar_YE	Arabic (Yemen)
    wxLANGUAGE_ARMENIAN,		//	25	hy	Armenian
    wxLANGUAGE_ASSAMESE,		//	26	as	Assamese
    wxLANGUAGE_AYMARA,			//	27	ay	Aymara
    wxLANGUAGE_AZERI,			//	28	az	Azeri
    wxLANGUAGE_AZERI_CYRILLIC,	//	29	az_Cyrl	Azeri (Cyrillic)
    wxLANGUAGE_AZERI_LATIN,		//	30	az_Latn	Azeri (Latin)
    wxLANGUAGE_BASHKIR,			//	31	ba	Bashkir
    wxLANGUAGE_BASQUE,			//	32	eu_ES	Basque
    wxLANGUAGE_BELARUSIAN,		//	33	be_BY	Belarusian
    wxLANGUAGE_BENGALI,			//	34	bn	Bengali
    wxLANGUAGE_BHUTANI,			//	35	dz	Bhutani // not in IANA
    wxLANGUAGE_BIHARI,			//	36	bh	Bihari
    wxLANGUAGE_BISLAMA,			//	37	bi	Bislama
    wxLANGUAGE_BRETON,			//	38	br	Breton
    wxLANGUAGE_BULGARIAN,		//	39	bg_BG	Bulgarian
    wxLANGUAGE_BURMESE,			//	40	my	Burmese
    wxLANGUAGE_CAMBODIAN,		//	41	km	Cambodian // not in IANA
    wxLANGUAGE_CATALAN,			//	42	ca_ES	Catalan
    wxLANGUAGE_CHINESE,			//	43	zh_TW	Chinese
    wxLANGUAGE_CHINESE_SIMPLIFIED,	//	44	zh_CN	Chinese (Simplified)
    wxLANGUAGE_CHINESE_TRADITIONAL,	//	45	zh_TW	Chinese (Traditional)
    wxLANGUAGE_CHINESE_HONGKONG,	//	46	zh_HK	Chinese (Hongkong)
    wxLANGUAGE_CHINESE_MACAU,		//	47	zh_MO	Chinese (Macau)
    wxLANGUAGE_CHINESE_SINGAPORE,	//	48	zh_SG	Chinese (Singapore)
    wxLANGUAGE_CHINESE_TAIWAN,	//	49	zh_TW	Chinese (Taiwan)
    wxLANGUAGE_CORSICAN,		//	50	co	Corsican
    wxLANGUAGE_CROATIAN,		//	51	hr_HR	Croatian
    wxLANGUAGE_CZECH,			//	52	cs_CZ	Czech
    wxLANGUAGE_DANISH,			//	53	da_DK	Danish
    wxLANGUAGE_DUTCH,			//	54	nl_NL	Dutch
    wxLANGUAGE_DUTCH_BELGIAN,		//	55	nl_BE	Dutch (Belgian)
    wxLANGUAGE_ENGLISH,			//	56	en_GB	English
    wxLANGUAGE_ENGLISH_UK,		//	57	en_GB	English (U.K.)
    wxLANGUAGE_ENGLISH_US,		//	58	en_US	English (U.S.)
    wxLANGUAGE_ENGLISH_AUSTRALIA,	//	59	en_AU	English (Australia)
    wxLANGUAGE_ENGLISH_BELIZE,	//	60	en_BZ	English (Belize)
    wxLANGUAGE_ENGLISH_BOTSWANA,	//	61	en_BW	English (Botswana)
    wxLANGUAGE_ENGLISH_CANADA,	//	62	en_CA	English (Canada)
    wxLANGUAGE_ENGLISH_CARIBBEAN,	//	63	en_CB	English (Caribbean)
    wxLANGUAGE_ENGLISH_DENMARK,	//	64	en_DK	English (Denmark)
    wxLANGUAGE_ENGLISH_EIRE,		//	65	en_IE	English (Eire)
    wxLANGUAGE_ENGLISH_JAMAICA,	//	66	en_JM	English (Jamaica)
    wxLANGUAGE_ENGLISH_NEW_ZEALAND,	//	67	en_NZ	English (New Zealand)
    wxLANGUAGE_ENGLISH_PHILIPPINES,	//	68	en_PH	English (Philippines)
    wxLANGUAGE_ENGLISH_SOUTH_AFRICA,	//	69	en_ZA	English (South Africa)
    wxLANGUAGE_ENGLISH_TRINIDAD,	//	70	en_TT	English (Trinidad)
    wxLANGUAGE_ENGLISH_ZIMBABWE,	//	71	en_ZW	English (Zimbabwe)
    wxLANGUAGE_ESPERANTO,		//	72	eo	Esperanto
    wxLANGUAGE_ESTONIAN,		//	73	et_EE	Estonian
    wxLANGUAGE_FAEROESE,		//	74	fo_FO	Faeroese
    wxLANGUAGE_FARSI,			//	75	fa_IR	Farsi
    wxLANGUAGE_FIJI,			//	76	fj	Fiji
    wxLANGUAGE_FINNISH,			//	77	fi_FI	Finnish
    wxLANGUAGE_FRENCH,			//	78	fr_FR	French
    wxLANGUAGE_FRENCH_BELGIAN,	//	79	fr_BE	French (Belgian)
    wxLANGUAGE_FRENCH_CANADIAN,	//	80	fr_CA	French (Canadian)
    wxLANGUAGE_FRENCH_LUXEMBOURG,	//	81	fr_LU	French (Luxembourg)
    wxLANGUAGE_FRENCH_MONACO,		//	82	fr_MC	French (Monaco)
    wxLANGUAGE_FRENCH_SWISS,		//	83	fr_CH	French (Swiss)
    wxLANGUAGE_FRISIAN,			//	84	fy	Frisian
    wxLANGUAGE_GALICIAN,		//	85	gl_ES	Galician
    wxLANGUAGE_GEORGIAN,		//	86	ka	Georgian
    wxLANGUAGE_GERMAN,			//	87	de_DE	German
    wxLANGUAGE_GERMAN_AUSTRIAN,	//	88	de_AT	German (Austrian)
    wxLANGUAGE_GERMAN_BELGIUM,	//	89	de_BE	German (Belgium)
    wxLANGUAGE_GERMAN_LIECHTENSTEIN,	//	90	de_LI	German (Liechtenstein)
    wxLANGUAGE_GERMAN_LUXEMBOURG,	//	91	de_LU	German (Luxembourg)
    wxLANGUAGE_GERMAN_SWISS,		//	92	de_CH	German (Swiss)
    wxLANGUAGE_GREEK,			//	93	el_GR	Greek
    wxLANGUAGE_GREENLANDIC,		//	94	kl_GL	Greenlandic
    wxLANGUAGE_GUARANI,			//	95	gn	Guarani
    wxLANGUAGE_GUJARATI,		//	96	gu	Gujarati
    wxLANGUAGE_HAUSA,			//	97	ha	Hausa
    wxLANGUAGE_HEBREW,			//	98	he_IL	Hebrew
    wxLANGUAGE_HINDI,			//	99	hi_IN	Hindi
    wxLANGUAGE_HUNGARIAN,		//	100	hu_HU	Hungarian
    wxLANGUAGE_ICELANDIC,		//	101	is_IS	Icelandic
    wxLANGUAGE_INDONESIAN,		//	102	id_ID	Indonesian
    wxLANGUAGE_INTERLINGUA,		//	103	ia	Interlingua
    wxLANGUAGE_INTERLINGUE,		//	104	ie	Interlingue
    wxLANGUAGE_INUKTITUT,		//	105	iu	Inuktitut
    wxLANGUAGE_INUPIAK,			//	106	ik	Inupiak
    wxLANGUAGE_IRISH,			//	107	ga_IE	Irish
    wxLANGUAGE_ITALIAN,			//	108	it_IT	Italian
    wxLANGUAGE_ITALIAN_SWISS,		//	109	it_CH	Italian (Swiss)
    wxLANGUAGE_JAPANESE,		//	110	ja_JP	Japanese
    wxLANGUAGE_JAVANESE,		//	111	jw	Javanese
    wxLANGUAGE_KANNADA,			//	112	kn	kannada
    wxLANGUAGE_KASHMIRI,		//	113	ks	Kashmiri
    wxLANGUAGE_KASHMIRI_INDIA,	//	114	ks_IN	Kashmiri (India)
    wxLANGUAGE_KAZAKH,			//	115	kk	Kazakh
    wxLANGUAGE_KERNEWEK,		//	116	kw_GB	Kernewek
    wxLANGUAGE_KINYARWANDA,		//	117	rw	Kinyarwanda
    wxLANGUAGE_KIRGHIZ,			//	118	ky	Kirghiz
    wxLANGUAGE_KIRUNDI,			//	119	rn	Kirundi
    wxLANGUAGE_KONKANI,			//	120	kok	Konkani // canonical is null kok is IANA code
    wxLANGUAGE_KOREAN,			//	121	ko_KR	Korean
    wxLANGUAGE_KURDISH,			//	122	ku	Kurdish
    wxLANGUAGE_LAOTHIAN,		//	123	lo	Laothian
    wxLANGUAGE_LATIN,			//	124	la	Latin
    wxLANGUAGE_LATVIAN,			//	125	lv_LV	Latvian
    wxLANGUAGE_LINGALA,			//	126	ln	Lingala
    wxLANGUAGE_LITHUANIAN,		//	127	lt_LT	Lithuanian
    wxLANGUAGE_MACEDONIAN,		//	128	mk_MK	Macedonian
    wxLANGUAGE_MALAGASY,		//	129	mg	Malagasy
    wxLANGUAGE_MALAY,			//	130	ms_MY	Malay
    wxLANGUAGE_MALAYALAM,		//	131	ml	Malayalam
    wxLANGUAGE_MALAY_BRUNEI_DARUSSALAM,	//	132	ms_BN	Malay (Brunei Darussalam)
    wxLANGUAGE_MALAY_MALAYSIA,	//	133	ms_MY	Malay (Malaysia)
    wxLANGUAGE_MALTESE,			//	134	mt_MT	Maltese
    wxLANGUAGE_MANIPURI,		//	135	mni	Manipuri // canonical is null mni is IANA code
    wxLANGUAGE_MAORI,			//	136	mi	Maori
    wxLANGUAGE_MARATHI,			//	137	mr_IN	Marathi
    wxLANGUAGE_MOLDAVIAN,		//	138	mo	Moldavian
    wxLANGUAGE_MONGOLIAN,		//	139	mn	Mongolian
    wxLANGUAGE_NAURU,			//	140	na	Nauru
    wxLANGUAGE_NEPALI,			//	141	ne	Nepali
    wxLANGUAGE_NEPALI_INDIA,		//	142	ne_IN	Nepali (India)
    wxLANGUAGE_NORWEGIAN_BOKMAL,	//	143	nb_NO	Norwegian (Bokmal)
    wxLANGUAGE_NORWEGIAN_NYNORSK,	//	144	nn_NO	Norwegian (Nynorsk)
    wxLANGUAGE_OCCITAN,			//	145	oc	Occitan
    wxLANGUAGE_ORIYA,			//	146	or	Oriya
    wxLANGUAGE_OROMO,			//	147	om	(Afan) Oromo
    wxLANGUAGE_PASHTO,			//	148	ps	Pashto, Pushto
    wxLANGUAGE_POLISH,			//	149	pl_PL	Polish
    wxLANGUAGE_PORTUGUESE,		//	150	pt_PT	Portuguese
    wxLANGUAGE_PORTUGUESE_BRAZILIAN,	//	151	pt_BR	Portuguese (Brazilian)
    wxLANGUAGE_PUNJABI,			//	152	pa	Punjabi
    wxLANGUAGE_QUECHUA,			//	153	qu	Quechua
    wxLANGUAGE_RHAETO_ROMANCE,	//	154	rm	Rhaeto-Romance
    wxLANGUAGE_ROMANIAN,		//	155	ro_RO	Romanian
    wxLANGUAGE_RUSSIAN,			//	156	ru_RU	Russian
    wxLANGUAGE_RUSSIAN_UKRAINE,	//	157	ru_UA	Russian (Ukraine)
    wxLANGUAGE_SAMOAN,			//	158	sm	Samoan
    wxLANGUAGE_SANGHO,			//	159	sg	Sangho
    wxLANGUAGE_SANSKRIT,		//	160	sa	Sanskrit
    wxLANGUAGE_SCOTS_GAELIC,		//	161	gd	Scots Gaelic
    wxLANGUAGE_SERBIAN,			//	162	sr	Serbian // both null in wx; values from IANA
    wxLANGUAGE_SERBIAN_CYRILLIC,	//	163	sr_YU	Serbian (Cyrillic)
    wxLANGUAGE_SERBIAN_LATIN,		//	164	sr_YU	Serbian (Latin)
    wxLANGUAGE_SERBO_CROATIAN,	//	165	sh	Serbo-Croatian
    wxLANGUAGE_SESOTHO,			//	166	st	Sesotho
    wxLANGUAGE_SETSWANA,		//	167	tn	Setswana
    wxLANGUAGE_SHONA,			//	168	sn	Shona
    wxLANGUAGE_SINDHI,			//	169	sd	Sindhi
    wxLANGUAGE_SINHALESE,		//	170	si	Sinhalese
    wxLANGUAGE_SISWATI,			//	171	ss	Siswati
    wxLANGUAGE_SLOVAK,			//	172	sk_SK	Slovak
    wxLANGUAGE_SLOVENIAN,		//	173	sl_SI	Slovenian
    wxLANGUAGE_SOMALI,			//	174	so	Somali
    wxLANGUAGE_SPANISH,			//	175	es_ES	Spanish
    wxLANGUAGE_SPANISH_ARGENTINA,	//	176	es_AR	Spanish (Argentina)
    wxLANGUAGE_SPANISH_BOLIVIA,	//	177	es_BO	Spanish (Bolivia)
    wxLANGUAGE_SPANISH_CHILE,		//	178	es_CL	Spanish (Chile)
    wxLANGUAGE_SPANISH_COLOMBIA,	//	179	es_CO	Spanish (Colombia)
    wxLANGUAGE_SPANISH_COSTA_RICA,	//	180	es_CR	Spanish (Costa Rica)
    wxLANGUAGE_SPANISH_DOMINICAN_REPUBLIC,	//	181	es_DO	Spanish (Dominican republic)
    wxLANGUAGE_SPANISH_ECUADOR,	//	182	es_EC	Spanish (Ecuador)
    wxLANGUAGE_SPANISH_EL_SALVADOR,	//	183	es_SV	Spanish (El Salvador)
    wxLANGUAGE_SPANISH_GUATEMALA,	//	184	es_GT	Spanish (Guatemala)
    wxLANGUAGE_SPANISH_HONDURAS,	//	185	es_HN	Spanish (Honduras)
    wxLANGUAGE_SPANISH_MEXICAN,	//	186	es_MX	Spanish (Mexico)
    wxLANGUAGE_SPANISH_MODERN,	//	187	es_ES	Spanish (Modern)
    wxLANGUAGE_SPANISH_NICARAGUA,	//	188	es_NI	Spanish (Nicaragua)
    wxLANGUAGE_SPANISH_PANAMA,	//	189	es_PA	Spanish (Panama)
    wxLANGUAGE_SPANISH_PARAGUAY,	//	190	es_PY	Spanish (Paraguay)
    wxLANGUAGE_SPANISH_PERU,		//	191	es_PE	Spanish (Peru)
    wxLANGUAGE_SPANISH_PUERTO_RICO,	//	192	es_PR	Spanish (Puerto Rico)
    wxLANGUAGE_SPANISH_URUGUAY,	//	193	es_UY	Spanish (Uruguay)
    wxLANGUAGE_SPANISH_US,		//	194	es_US	Spanish (U.S.)
    wxLANGUAGE_SPANISH_VENEZUELA,	//	195	es_VE	Spanish (Venezuela)
    wxLANGUAGE_SUNDANESE,		//	196	su	Sundanese
    wxLANGUAGE_SWAHILI,			//	197	sw_KE	Swahili
    wxLANGUAGE_SWEDISH,			//	198	sv_SE	Swedish
    wxLANGUAGE_SWEDISH_FINLAND,	//	199	sv_FI	Swedish (Finland)
    wxLANGUAGE_TAGALOG,			//	200	tl_PH	Tagalog
    wxLANGUAGE_TAJIK,			//	201	tg	Tajik
    wxLANGUAGE_TAMIL,			//	202	ta	Tamil
    wxLANGUAGE_TATAR,			//	203	tt	Tatar
    wxLANGUAGE_TELUGU,			//	204	te	Telugu
    wxLANGUAGE_THAI,			//	205	th_TH	Thai
    wxLANGUAGE_TIBETAN,			//	206	bo	Tibetan
    wxLANGUAGE_TIGRINYA,		//	207	ti	Tigrinya
    wxLANGUAGE_TONGA,			//	208	to	Tonga
    wxLANGUAGE_TSONGA,			//	209	ts	Tsonga
    wxLANGUAGE_TURKISH,			//	210	tr_TR	Turkish
    wxLANGUAGE_TURKMEN,			//	211	tk	Turkmen
    wxLANGUAGE_TWI,				//	212	tw	Twi
    wxLANGUAGE_UIGHUR,			//	213	ug	Uighur
    wxLANGUAGE_UKRAINIAN,		//	214	uk_UA	Ukrainian
    wxLANGUAGE_URDU,			//	215	ur	Urdu
    wxLANGUAGE_URDU_INDIA,		//	216	ur_IN	Urdu (India)
    wxLANGUAGE_URDU_PAKISTAN,	//	217	ur_PK	Urdu (Pakistan)
    wxLANGUAGE_UZBEK,			//	218	uz	Uzbek
    wxLANGUAGE_UZBEK_CYRILLIC,	//	219	uz	Uzbek (Cyrillic)
    wxLANGUAGE_UZBEK_LATIN,		//	220	uz	Uzbek (Latin)
    wxLANGUAGE_VIETNAMESE,		//	221	vi_VN	Vietnamese
    wxLANGUAGE_VOLAPUK,			//	222	vo	Volapuk
    wxLANGUAGE_WELSH,			//	223	cy	Welsh
    wxLANGUAGE_WOLOF,			//	224	wo	Wolof
    wxLANGUAGE_XHOSA,			//	225	xh	Xhosa
    wxLANGUAGE_YIDDISH,			//	226	yi	Yiddish
    wxLANGUAGE_YORUBA,			//	227	yo	Yoruba
    wxLANGUAGE_ZHUANG,			//	228	za	Zhuang
    wxLANGUAGE_ZULU,			//	229	zu	Zulu

    // for custom, user-defined languages:
    wxLANGUAGE_USER_DEFINED		//	230	null	null
};
*/

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: The App's ChooseInterfaceLanguage(), and CLanguagesPage::InitDialog(). An
/// array consisting of triplets of full language names, the wxWidgets language enum
/// symbols, and the short canonical name (used for subdirectories). Used to correlate full
/// language names, enum symbols and canonical names. Note: This language data is taken
/// from the void wxLocale::InitLanguagesDB() function in the wxWidgets intl.cpp library
/// source file.
////////////////////////////////////////////////////////////////////////////////////////
LangInfo langsKnownToWX[] =
{
    { _("(Use system default language) [%s]"), wxLANGUAGE_DEFAULT, _T("default") },	// 0

    // Note: I've added a couple three-letter short canonical forms from the IANA language
    // registry which may be found at:
    // http://www.iana.org/assignments/language-subtag-registry

    { _T("Abkhazian"), wxLANGUAGE_ABKHAZIAN, _T("ab") },							// 2
	{ _T("Afar"), wxLANGUAGE_AFAR, _T("aa") },										// 3
	{ _T("Afrikaans"), wxLANGUAGE_AFRIKAANS, _T("af_ZA") },							// 4
    { _T("Albanian"), wxLANGUAGE_ALBANIAN, _T("sq_AL") },							// 5
    { _T("Amharic"), wxLANGUAGE_AMHARIC, _T("am") },								// 6
    { _T("Arabic"), wxLANGUAGE_ARABIC, _T("ar") },									// 7
    { _T("Arabic (Algeria)"), wxLANGUAGE_ARABIC_ALGERIA, _T("ar_DZ") },				// 8
    { _T("Arabic (Bahrain)"), wxLANGUAGE_ARABIC_BAHRAIN, _T("ar_BH") },				// 9
    { _T("Arabic (Egypt)"), wxLANGUAGE_ARABIC_EGYPT, _T("ar_EG") },					// 10
    { _T("Arabic (Iraq)"), wxLANGUAGE_ARABIC_IRAQ, _T("ar_IQ") },					// 11
    { _T("Arabic (Jordan)"), wxLANGUAGE_ARABIC_JORDAN, _T("ar_JO") },				// 12
    { _T("Arabic (Kuwait)"), wxLANGUAGE_ARABIC_KUWAIT, _T("ar_KW") },				// 13
    { _T("Arabic (Lebanon)"), wxLANGUAGE_ARABIC_LEBANON, _T("ar_LB") },				// 14
    { _T("Arabic (Libya)"), wxLANGUAGE_ARABIC_LIBYA, _T("ar_LY") },					// 15
    { _T("Arabic (Morocco)"), wxLANGUAGE_ARABIC_MOROCCO, _T("ar_MA") },				// 16
    { _T("Arabic (Oman)"), wxLANGUAGE_ARABIC_OMAN, _T("ar_OM") },					// 17
    { _T("Arabic (Qatar)"), wxLANGUAGE_ARABIC_QATAR, _T("ar_QA") },					// 18
    { _T("Arabic (Saudi Arabia)"), wxLANGUAGE_ARABIC_SAUDI_ARABIA, _T("ar_SA") },	// 19
    { _T("Arabic (Sudan)"), wxLANGUAGE_ARABIC_SUDAN, _T("ar_SD") },					// 20
    { _T("Arabic (Syria)"), wxLANGUAGE_ARABIC_SYRIA, _T("ar_SY") },					// 21
    { _T("Arabic (Tunisia)"), wxLANGUAGE_ARABIC_TUNISIA, _T("ar_TN") },				// 22
    { _T("Arabic (Uae)"), wxLANGUAGE_ARABIC_UAE, _T("ar_AE") },						// 23
    { _T("Arabic (Yemen)"), wxLANGUAGE_ARABIC_YEMEN, _T("ar_YE") },					// 24
	{ _T("Armenian"), wxLANGUAGE_ARMENIAN, _T("hy") },								// 25
	{ _T("Assamese"), wxLANGUAGE_ASSAMESE, _T("as") },								// 26
	{ _T("Aymara"), wxLANGUAGE_AYMARA, _T("ay") },									// 27
	{ _T("Azeri"), wxLANGUAGE_AZERI, _T("az") },									// 28
	{ _T("Azeri (Cyrillic)"), wxLANGUAGE_AZERI_CYRILLIC, _T("az_Cyrl") },			// 29
	{ _T("Azeri (Latin)"), wxLANGUAGE_AZERI_LATIN, _T("az_Latn") },					// 30
	{ _T("Bashkir"), wxLANGUAGE_BASHKIR, _T("ba") },								// 31
    { _T("Basque"), wxLANGUAGE_BASQUE, _T("eu_ES") },								// 32
    { _T("Belarusian"), wxLANGUAGE_BELARUSIAN, _T("be_BY") },						// 33
    { _T("Bengali"), wxLANGUAGE_BENGALI, _T("bn") },								// 34
	{ _T("Bhutani"), wxLANGUAGE_BHUTANI, _T("dz") },								// 35 // in IANA registry under "Dzongkha" (uses Tibt script)
	{ _T("Bihari"), wxLANGUAGE_BIHARI, _T("bh") },									// 36
	{ _T("Bislama"), wxLANGUAGE_BISLAMA, _T("bi") },								// 37
    { _T("Breton"), wxLANGUAGE_BRETON, _T("br") },									// 38
    { _T("Bulgarian"), wxLANGUAGE_BULGARIAN, _T("bg_BG") },							// 39
	{ _T("Burmese"), wxLANGUAGE_BURMESE, _T("my") },								// 40
	{ _T("Cambodian"), wxLANGUAGE_CAMBODIAN, _T("km") },							// 41 // in IANA registry under "Central Khmer" (uses Khmr script)
    { _T("Catalan"), wxLANGUAGE_CATALAN, _T("ca_ES") },								// 42
    { _T("Chinese"), wxLANGUAGE_CHINESE, _T("zh_TW") },								// 43
    { _T("Chinese (Simplified)"), wxLANGUAGE_CHINESE_SIMPLIFIED, _T("zh_CN") },		// 44
    { _T("Chinese (Traditional)"), wxLANGUAGE_CHINESE_TRADITIONAL, _T("zh_TW") },	// 45
    { _T("Chinese (Hongkong)"), wxLANGUAGE_CHINESE_HONGKONG, _T("zh_HK") },			// 46
    { _T("Chinese (Macau)"), wxLANGUAGE_CHINESE_MACAU, _T("zh_MO") },				// 47
    { _T("Chinese (Singapore)"), wxLANGUAGE_CHINESE_SINGAPORE, _T("zh_SG") },		// 48
    { _T("Chinese (Taiwan)"), wxLANGUAGE_CHINESE_TAIWAN, _T("zh_TW") },				// 49
	{ _T("Corsican"), wxLANGUAGE_CORSICAN, _T("co") },								// 50
    { _T("Croatian"), wxLANGUAGE_CROATIAN, _T("hr_HR") },							// 51
    { _T("Czech"), wxLANGUAGE_CZECH, _T("cs_CZ") },									// 52
    { _T("Danish"), wxLANGUAGE_DANISH, _T("da_DK") },								// 53
    { _T("Dutch"), wxLANGUAGE_DUTCH, _T("nl_NL") },									// 54
	{ _T("Dutch (Belgian)"), wxLANGUAGE_DUTCH_BELGIAN, _T("nl_BE") },				// 55
    { _T("English"), wxLANGUAGE_ENGLISH, _T("en_GB") },								// 56
    { _T("English (U.K.)"), wxLANGUAGE_ENGLISH_UK, _T("en_GB") },					// 57
    { _T("English (U.S.)"), wxLANGUAGE_ENGLISH_US, _T("en_US") },					// 58
    { _T("English (Australia)"), wxLANGUAGE_ENGLISH_AUSTRALIA, _T("en_AU") },		// 59
    { _T("English (Belize)"), wxLANGUAGE_ENGLISH_BELIZE, _T("en_BZ") },				// 60
    { _T("English (Botswana)"), wxLANGUAGE_ENGLISH_BOTSWANA, _T("en_BW") },			// 61
    { _T("English (Canada)"), wxLANGUAGE_ENGLISH_CANADA, _T("en_CA") },				// 62
    { _T("English (Caribbean)"), wxLANGUAGE_ENGLISH_CARIBBEAN, _T("en_CB") },		// 63
    { _T("English (Denmark)"), wxLANGUAGE_ENGLISH_DENMARK, _T("en_DK") },			// 64
    { _T("English (Eire)"), wxLANGUAGE_ENGLISH_EIRE, _T("en_IE") },					// 65
    { _T("English (Jamaica)"), wxLANGUAGE_ENGLISH_JAMAICA, _T("en_JM") },			// 66
    { _T("English (New Zealand)"), wxLANGUAGE_ENGLISH_NEW_ZEALAND, _T("en_NZ") },	// 67
    { _T("English (Philippines)"), wxLANGUAGE_ENGLISH_PHILIPPINES, _T("en_PH") },	// 68
    { _T("English (South Africa)"), wxLANGUAGE_ENGLISH_SOUTH_AFRICA, _T("en_ZA") },	// 69
    { _T("English (Trinidad)"), wxLANGUAGE_ENGLISH_TRINIDAD, _T("en_TT") },			// 70
    { _T("English (Zimbabwe)"), wxLANGUAGE_ENGLISH_ZIMBABWE, _T("en_ZW") },			// 71
    { _T("Esperanto"), wxLANGUAGE_ESPERANTO, _T("eo") },							// 72
    { _T("Estonian"), wxLANGUAGE_ESTONIAN, _T("et_EE") },							// 73
	{ _T("Faeroese"), wxLANGUAGE_FAEROESE, _T("fo_FO") },							// 74
    { _T("Farsi"), wxLANGUAGE_FARSI, _T("fa_IR") },									// 75
	{ _T("Fiji"), wxLANGUAGE_FIJI, _T("fj") },										// 76
    { _T("Finnish"), wxLANGUAGE_FINNISH, _T("fi_FI") },								// 77
    { _T("French"), wxLANGUAGE_FRENCH, _T("fr_FR") },								// 78
    { _T("French (Belgian)"), wxLANGUAGE_FRENCH_BELGIAN, _T("fr_BE") },				// 79
    { _T("French (Canadian)"), wxLANGUAGE_FRENCH_CANADIAN, _T("fr_CA") },			// 80
    { _T("French (Luxembourg)"), wxLANGUAGE_FRENCH_LUXEMBOURG, _T("fr_LU") },		// 81
    { _T("French (Monaco)"), wxLANGUAGE_FRENCH_MONACO, _T("fr_MC") },				// 82
    { _T("French (Swiss)"), wxLANGUAGE_FRENCH_SWISS, _T("fr_CH") },					// 83
	{ _T("Frisian"), wxLANGUAGE_FRISIAN, _T("fy") },								// 84
    { _T("Galician"), wxLANGUAGE_GALICIAN, _T("gl_ES") },							// 85
    { _T("Georgian"), wxLANGUAGE_GEORGIAN, _T("ka") },								// 86
    { _T("German"), wxLANGUAGE_GERMAN, _T("de_DE") },								// 87
    { _T("German (Austrian)"), wxLANGUAGE_GERMAN_AUSTRIAN, _T("de_AT") },			// 88
    { _T("German (Belgium)"), wxLANGUAGE_GERMAN_BELGIUM, _T("de_BE") },				// 89
    { _T("German (Liechtenstein)"), wxLANGUAGE_GERMAN_LIECHTENSTEIN, _T("de_LI") },	// 90
    { _T("German (Luxembourg)"), wxLANGUAGE_GERMAN_LUXEMBOURG, _T("de_LU") },		// 91
    { _T("German (Swiss)"), wxLANGUAGE_GERMAN_SWISS, _T("de_CH") },					// 92
    { _T("Greek"), wxLANGUAGE_GREEK, _T("el_GR") },									// 93
	{ _T("Greenlandic"), wxLANGUAGE_GREENLANDIC, _T("kl_GL") },						// 94
	{ _T("Guarani"), wxLANGUAGE_GUARANI, _T("gn") },								// 95
	{ _T("Gujarati"), wxLANGUAGE_GUJARATI, _T("gu") },								// 96
	{ _T("Hausa"), wxLANGUAGE_HAUSA, _T("ha") },									// 97
    { _T("Hebrew"), wxLANGUAGE_HEBREW, _T("he_IL") },								// 98
    { _T("Hindi"), wxLANGUAGE_HINDI, _T("hi_IN") },									// 99
    { _T("Hungarian"), wxLANGUAGE_HUNGARIAN, _T("hu_HU") },							// 100
    { _T("Icelandic"), wxLANGUAGE_ICELANDIC, _T("is_IS") },							// 101
    { _T("Indonesian"), wxLANGUAGE_INDONESIAN, _T("id_ID") },						// 102
	{ _T("Interlingua"), wxLANGUAGE_INTERLINGUA, _T("ia") },						// 103
	{ _T("Interlingue"), wxLANGUAGE_INTERLINGUE, _T("ie") },						// 104
	{ _T("Inuktitut"), wxLANGUAGE_INUKTITUT, _T("iu") },							// 105
	{ _T("Inupiak"), wxLANGUAGE_INUPIAK, _T("ik") },								// 106
	{ _T("Irish"), wxLANGUAGE_IRISH, _T("ga_IE") },									// 107
    { _T("Italian"), wxLANGUAGE_ITALIAN, _T("it_IT") },								// 108
    { _T("Italian (Swiss)"), wxLANGUAGE_ITALIAN_SWISS, _T("it_CH") },				// 109
    { _T("Japanese"), wxLANGUAGE_JAPANESE, _T("ja_JP") },							// 110
	{ _T("Javanese"), wxLANGUAGE_JAVANESE, _T("jw") },								// 111
	{ _T("kannada"), wxLANGUAGE_KANNADA, _T("kn") },								// 112
	{ _T("Kashmiri"), wxLANGUAGE_KASHMIRI, _T("ks") },								// 113
	{ _T("Kashmiri (India)"), wxLANGUAGE_KASHMIRI_INDIA, _T("ks_IN") },				// 114
	{ _T("Kazakh"), wxLANGUAGE_KAZAKH, _T("kk") },									// 115
	{ _T("Kernewek"), wxLANGUAGE_KERNEWEK, _T("kw_GB") },							// 116
	{ _T("Kinyarwanda"), wxLANGUAGE_KINYARWANDA, _T("rw") },						// 117
	{ _T("Kirghiz"), wxLANGUAGE_KIRGHIZ, _T("ky") },								// 118
	{ _T("Kirundi"), wxLANGUAGE_KIRUNDI, _T("rn") },								// 119
	{ _T("Konkani"), wxLANGUAGE_KONKANI, _T("kok") },								// 120 // wx's canonicalName is null; IANA registry uses 3-letter code kok
    { _T("Korean"), wxLANGUAGE_KOREAN, _T("ko_KR") },								// 121
    { _T("Kurdish"), wxLANGUAGE_KURDISH, _T("ku") },								// 122
    { _T("Kyrgyz"), wxLANGUAGE_KIRGHIZ, _T("ky") },									// 118 // same as Kirghiz (wxLANGUAGE_KIRGHIZ)
	{ _T("Laothian"), wxLANGUAGE_LAOTHIAN, _T("lo") },								// 123
	{ _T("Latin"), wxLANGUAGE_LATIN, _T("la") },									// 124
    { _T("Latvian"), wxLANGUAGE_LATVIAN, _T("lv_LV") },								// 125
	{ _T("Lingala"), wxLANGUAGE_LINGALA, _T("ln") },								// 126
    { _T("Lithuanian"), wxLANGUAGE_LITHUANIAN, _T("lt_LT") },						// 127
    { _T("Macedonian"), wxLANGUAGE_MACEDONIAN, _T("mk_MK") },						// 128
	{ _T("Malagasy"), wxLANGUAGE_MALAGASY, _T("mg") },								// 129
    { _T("Malay"), wxLANGUAGE_MALAY, _T("ms_MY") },									// 130
	{ _T("Malayalam"), wxLANGUAGE_MALAYALAM, _T("ml") },							// 131
	{ _T("Malay (Brunei Darussalam)"), wxLANGUAGE_MALAY_BRUNEI_DARUSSALAM, _T("ms_BN") },	// 132
	{ _T("Malay (Malaysia)"), wxLANGUAGE_MALAY_MALAYSIA, _T("ms_MY") },				// 133
	{ _T("Maltese"), wxLANGUAGE_MALTESE, _T("mt_MT") },								// 134
	{ _T("Manipuri"), wxLANGUAGE_MANIPURI, _T("mni") },								// 135 // wx's canonicalName is null; IANA registry uses 3-letter code mni
	{ _T("Maori"), wxLANGUAGE_MAORI, _T("mi") },									// 136
	{ _T("Marathi"), wxLANGUAGE_MARATHI, _T("mr_IN") },								// 137
	{ _T("Moldavian"), wxLANGUAGE_MOLDAVIAN, _T("mo") },							// 138
    { _T("Mongolian"), wxLANGUAGE_MONGOLIAN, _T("mn") },							// 139
	{ _T("Nauru"), wxLANGUAGE_NAURU, _T("na") },									// 140
	{ _T("Nepali"), wxLANGUAGE_NEPALI, _T("ne") },									// 141
	{ _T("Nepali (India)"), wxLANGUAGE_NEPALI_INDIA, _T("ne_IN") },					// 142
    { _T("Norwegian Bokmal"), wxLANGUAGE_NORWEGIAN_BOKMAL, _T("nb_NO") },			// 143
    { _T("Norwegian Nynorsk"), wxLANGUAGE_NORWEGIAN_NYNORSK, _T("nn_NO") },			// 144
	{ _T("Occitan"), wxLANGUAGE_OCCITAN, _T("oc") },								// 145
	{ _T("Oriya"), wxLANGUAGE_ORIYA, _T("or") },									// 146
	{ _T("(Afan) Oromo"), wxLANGUAGE_OROMO, _T("om") },								// 147
	{ _T("Pashto, Pushto"), wxLANGUAGE_PASHTO, _T("ps") },							// 148
    { _T("Polish"), wxLANGUAGE_POLISH, _T("pl_PL") },								// 149
    { _T("Portuguese"), wxLANGUAGE_PORTUGUESE, _T("pt_PT") },						// 150
    { _T("Portuguese (Brazilian)"), wxLANGUAGE_PORTUGUESE_BRAZILIAN, _T("pt_BR") },	// 151
    { _T("Punjabi"), wxLANGUAGE_PUNJABI, _T("pa") },								// 152
	{ _T("Quechua"), wxLANGUAGE_QUECHUA, _T("qu") },								// 153
	{ _T("Rhaeto-Romance"), wxLANGUAGE_RHAETO_ROMANCE, _T("rm") },					// 154
    { _T("Romanian"), wxLANGUAGE_ROMANIAN, _T("ro_RO") },							// 155
    { _T("Russian"), wxLANGUAGE_RUSSIAN, _T("ru_RU") },								// 156
    { _T("Russian (Ukraine)"), wxLANGUAGE_RUSSIAN_UKRAINE, _T("ru_UA") },			// 157
	{ _T("Samoan"), wxLANGUAGE_SAMOAN, _T("sm") },									// 158
	{ _T("Sangho"), wxLANGUAGE_SANGHO, _T("sg") },									// 159
	{ _T("Sanskrit"), wxLANGUAGE_SANSKRIT, _T("sa") },								// 160
	{ _T("Scots Gaelic"), wxLANGUAGE_SCOTS_GAELIC, _T("gd") },						// 161
    { _T("Serbian"), wxLANGUAGE_SERBIAN, _T("sr") },								// 162 // wxLANGUATE_SERVIAN not in InitLanguagesDB() returns null; IANA registry has code sr
	{ _T("Serbian (Cyrillic)"), wxLANGUAGE_SERBIAN_CYRILLIC, _T("sr_YU") },			// 163
	{ _T("Serbian (Latin)"), wxLANGUAGE_SERBIAN_LATIN, _T("sr_YU") },				// 164
	{ _T("Serbo-Croatian"), wxLANGUAGE_SERBO_CROATIAN, _T("sh") },					// 165
	{ _T("Sesotho"), wxLANGUAGE_SESOTHO, _T("st") },								// 166
	{ _T("Setswana"), wxLANGUAGE_SETSWANA, _T("tn") },								// 167
	{ _T("Shona"), wxLANGUAGE_SHONA, _T("sn") },									// 168
	{ _T("Sindhi"), wxLANGUAGE_SINDHI, _T("sd") },									// 169
	{ _T("Sinhalese"), wxLANGUAGE_SINHALESE, _T("si") },							// 170
	{ _T("Siswati"), wxLANGUAGE_SISWATI, _T("ss") },								// 171
    { _T("Slovak"), wxLANGUAGE_SLOVAK, _T("sk_SK") },								// 172
    { _T("Slovenian"), wxLANGUAGE_SLOVENIAN, _T("sl_SI") },							// 173
	{ _T("Somali"), wxLANGUAGE_SOMALI, _T("so") },									// 174
    { _T("Spanish"), wxLANGUAGE_SPANISH, _T("es_ES") },								// 175
    { _T("Spanish (Argentina)"), wxLANGUAGE_SPANISH_ARGENTINA, _T("es_AR") },		// 176
    { _T("Spanish (Bolivia)"), wxLANGUAGE_SPANISH_BOLIVIA, _T("es_BO") },			// 177
    { _T("Spanish (Chile)"), wxLANGUAGE_SPANISH_CHILE, _T("es_CL") },				// 178
    { _T("Spanish (Colombia)"), wxLANGUAGE_SPANISH_COLOMBIA, _T("es_CO") },			// 179
    { _T("Spanish (Costa Rica)"), wxLANGUAGE_SPANISH_COSTA_RICA, _T("es_CR") },		// 180
    { _T("Spanish (Dominican republic)"), wxLANGUAGE_SPANISH_DOMINICAN_REPUBLIC, _T("es_DO") },	// 181
    { _T("Spanish (Ecuador)"), wxLANGUAGE_SPANISH_ECUADOR, _T("es_EC") },			// 182
    { _T("Spanish (El Salvador)"), wxLANGUAGE_SPANISH_EL_SALVADOR, _T("es_SV") },	// 183
    { _T("Spanish (Guatemala)"), wxLANGUAGE_SPANISH_GUATEMALA, _T("es_GT") },		// 184
    { _T("Spanish (Honduras)"), wxLANGUAGE_SPANISH_HONDURAS, _T("es_HN") },			// 185
    { _T("Spanish (Mexico)"), wxLANGUAGE_SPANISH_MEXICAN, _T("es_MX") },			// 186
    { _T("Spanish (Modern)"), wxLANGUAGE_SPANISH_MODERN, _T("es_ES") },				// 187
    { _T("Spanish (Nicaragua)"), wxLANGUAGE_SPANISH_NICARAGUA, _T("es_NI") },		// 188
    { _T("Spanish (Panama)"), wxLANGUAGE_SPANISH_PANAMA, _T("es_PA") },				// 189
    { _T("Spanish (Paraguay)"), wxLANGUAGE_SPANISH_PARAGUAY, _T("es_PY") },			// 190
    { _T("Spanish (Peru)"), wxLANGUAGE_SPANISH_PERU, _T("es_PE") },					// 191
    { _T("Spanish (Puerto Rico)"), wxLANGUAGE_SPANISH_PUERTO_RICO, _T("es_PR") },	// 192
    { _T("Spanish (Uruguay)"), wxLANGUAGE_SPANISH_URUGUAY, _T("es_UY") },			// 193
    { _T("Spanish (U.S.)"), wxLANGUAGE_SPANISH_US, _T("es_US") },					// 194
    { _T("Spanish (Venezuela)"), wxLANGUAGE_SPANISH_VENEZUELA, _T("es_VE") },		// 195
    { _T("Sundanese"), wxLANGUAGE_SUNDANESE, _T("su") },							// 196
    { _T("Swahili"), wxLANGUAGE_SWAHILI, _T("sw_KE") },								// 197
    { _T("Swedish"), wxLANGUAGE_SWEDISH, _T("sv_SE") },								// 198
    { _T("Swedish (Finland)"), wxLANGUAGE_SWEDISH_FINLAND, _T("sv_FI") },			// 199
    { _T("Tagalog"), wxLANGUAGE_TAGALOG, _T("tl_PH") },								// 200
	{ _T("Tajik"), wxLANGUAGE_TAJIK, _T("tg") },									// 201
    { _T("Tamil"), wxLANGUAGE_TAMIL, _T("ta") },									// 202
    { _T("Tatar"), wxLANGUAGE_TATAR, _T("tt") },									// 203
	{ _T("Telugu"), wxLANGUAGE_TELUGU, _T("te") },									// 204
    { _T("Thai"), wxLANGUAGE_THAI, _T("th_TH") },									// 205
	{ _T("Tibetan"), wxLANGUAGE_TIBETAN, _T("bo") },								// 206
	{ _T("Tigrinya"), wxLANGUAGE_TIGRINYA, _T("ti") },								// 207
	{ _T("Tonga"), wxLANGUAGE_TONGA, _T("to") },									// 208
	{ _T("Tsonga"), wxLANGUAGE_TSONGA, _T("ts") },									// 209
    { _T("Turkish"), wxLANGUAGE_TURKISH, _T("tr_TR") },								// 210
	{ _T("Turkmen"), wxLANGUAGE_TURKMEN, _T("tk") },								// 211
	{ _T("Twi"), wxLANGUAGE_TWI, _T("tw") },										// 212
	{ _T("Uighur"), wxLANGUAGE_UIGHUR, _T("ug") },									// 213
    { _T("Ukrainian"), wxLANGUAGE_UKRAINIAN, _T("uk_UA") },							// 214
	{ _T("Urdu"), wxLANGUAGE_URDU, _T("ur") },										// 215
	{ _T("Urdu (India)"), wxLANGUAGE_URDU_INDIA, _T("ur_IN") },						// 216
	{ _T("Urdu (Pakistan)"), wxLANGUAGE_URDU_PAKISTAN, _T("ur_PK") },				// 217
	{ _T("Uzbek"), wxLANGUAGE_UZBEK, _T("uz") },									// 218
	{ _T("Uzbek (Cyrillic)"), wxLANGUAGE_UZBEK_CYRILLIC, _T("uz") },				// 219 // no script indicated; canonicalName could be uz__Cyrl [see Azeri above]
	{ _T("Uzbek (Latin)"), wxLANGUAGE_UZBEK_LATIN, _T("uz") },						// 220 // no script indicated; canonicalName could be uz_Latn [see Azeri above]
	{ _T("Vietnamese"), wxLANGUAGE_VIETNAMESE, _T("vi_VN") },						// 221
	{ _T("Volapuk"), wxLANGUAGE_VOLAPUK, _T("vo") },								// 222
	{ _T("Welsh"), wxLANGUAGE_WELSH, _T("cy") },									// 223
	{ _T("Wolof"), wxLANGUAGE_WOLOF, _T("wo") },									// 224
	{ _T("Xhosa"), wxLANGUAGE_XHOSA, _T("xh") },									// 225
	{ _T("Yiddish"), wxLANGUAGE_YIDDISH, _T("yi") },								// 226
	{ _T("Yoruba"), wxLANGUAGE_YORUBA, _T("yo") },									// 227
	{ _T("Zhuang"), wxLANGUAGE_ZHUANG, _T("za") },									// 228
	{ _T("Zulu"), wxLANGUAGE_ZULU, _T("zu") },										// 229
	// wxLANGUAGE_UNKNOWN needs to be here at the end of the array so we can search the array
	// using a while loop while langsKnownToWX[ct].name != NULL.
    { NULL, wxLANGUAGE_UNKNOWN, NULL}												// 1
};

// whm 12Oct10 added this class. It didn't seem worth the bother to put it into
// separate source files, since it is a very minimal override of wxToolBar for
// the basic purpose of implementing a GetToolBarToolsList() getter. We need this
// in ConfigureToolBarForUserProfile() to configure AI's toolbar for user profiles.
// Begin AIToolBar class definition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IMPLEMENT_DYNAMIC_CLASS(AIToolBar, wxToolBar)

AIToolBar::AIToolBar()
{
}

AIToolBar::AIToolBar(wxWindow* parent, wxWindowID id, const wxPoint& pos,
	const wxSize& size, long style,	const wxString& name)
	: wxToolBar(parent, id, pos, size, style, name)
{
}

AIToolBar::~AIToolBar()
{
}

// This is our only derived method - a getter for
// the actual list of tool bar items
wxToolBarToolsList AIToolBar::GetToolBarToolsList()
{
	return m_tools;
}
// enf of AIToolBar class declaration !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// beginning of AIModalDialog class implementation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// whm Note: The AIModalDialog class exists as a base dialog class for Adapt It modal
// dialogs. AIModalDialog functions practically identical to its own base class wxDialog.
// It simply overrides ShowModal and the class destructor in order to suspend wxIdleEvent
// processing while the dialog is being displayed/modal, and restores idle processing when
// the dialog is destroyed. Suspending idle events helps to prevent crashes due to
// time-triggered events such as autosave that, if performed, encounter bad pointers

/////////////////////////////////////////////////////////////////////////////////////
/// \remarks
/// Constructor for the AIModalDialog class.
/// Used as a base class for all Adapt It dialogs which are invoked as modal dialogs.
/////////////////////////////////////////////////////////////////////////////////////
AIModalDialog::AIModalDialog( wxWindow *parent, const wxWindowID id, const wxString& title,
			const wxPoint& pos, const wxSize& size, const long windowStyle ) :
			wxScrollingDialog(parent, id, title, pos, size, windowStyle)
{
}

////////////////////////////////////////////////////////////////////////////////////////
/// \remarks
/// Destructor for the AIModalDialog class.
/// Used as the base class destructor all Adapt It dialogs which are invoked as modal
/// dialogs. This destructor calls the wxIdleEvent::SetMode(wxIDLE_PROCESS_ALL), and the
/// wxUpdateUIEvent::SetMode(wxUPDATE_UI_PROCESS_ALL), which allows the application to
/// resume its normal idle processing once the AIModalDialog based dialog closes.
/////////////////////////////////////////////////////////////////////////////////////////
AIModalDialog::~AIModalDialog()
{
	// override of wxDialog's destructor to start up idle processing again
	wxIdleEvent::SetMode(wxIDLE_PROCESS_ALL);
	wxUpdateUIEvent::SetMode(wxUPDATE_UI_PROCESS_ALL);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \remarks
/// Override of the wxScrollingDialog's ShowModal() method.
/// This override effectively turns off the wxIdleEvent and wxUpdateUIEvent idle processing
/// while any AIModalDialog based dialog is being shown in modal fashion.
////////////////////////////////////////////////////////////////////////////////////////
int AIModalDialog::ShowModal()
{
	// override of wxDialog's ShowModal() method to stop all idle processing including
	// processing of UI events while the modal dialog is displaying.
	wxIdleEvent::SetMode(wxIDLE_PROCESS_SPECIFIED);
	wxUpdateUIEvent::SetMode(wxUPDATE_UI_PROCESS_SPECIFIED);
	return wxScrollingDialog::ShowModal();
}
// end of AIModalDialog class !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

IMPLEMENT_APP(CAdapt_ItApp)
// This is used in the application class implementation file to make the
// application class known to wxWidgets for dynamic construction.
// Use this instead of MyApp myApp;

BEGIN_EVENT_TABLE(CAdapt_ItApp, wxApp)
	// OnIdle() handler was moved to CMainFrame. Having it here in
	// the App was causing File | Exit and x App cancel to become
	// unresponsive. Same code works fine there.

	// File Menu handlers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	EVT_MENU(wxID_NEW, CAdapt_ItApp::OnFileNew)

	// whm added the following 10Apr11 for AI-PT collaboration
	//EVT_MENU(ID_MENU_GET_SOURCE_FROM_PT, CAdapt_ItApp::OnGetSourceTextFromPT)
	//EVT_UPDATE_UI(ID_MENU_GET_SOURCE_FROM_PT, CAdapt_ItApp::OnUpdateGetSourceTextFromPT)
	//EVT_MENU(ID_MENU_TRANSFER_TRANS_TO_PT, CAdapt_ItApp::OnTransferTransToPT)
	//EVT_UPDATE_UI(ID_MENU_TRANSFER_TRANS_TO_PT, CAdapt_ItApp::OnUpdateTransferTransToPT)

	// OnFileOpen is in the Doc
	EVT_MENU(wxID_PAGE_SETUP,CAdapt_ItApp::OnFilePageSetup)
	EVT_UPDATE_UI(wxID_PAGE_SETUP, CAdapt_ItApp::OnUpdateFilePageSetup)
	EVT_UPDATE_UI(ID_FILE_STARTUP_WIZARD, CAdapt_ItApp::OnUpdateFileStartupWizard)
	EVT_MENU(ID_FILE_BACKUP_KB, CAdapt_ItApp::OnFileBackupKb)
	EVT_UPDATE_UI(ID_FILE_BACKUP_KB, CAdapt_ItApp::OnUpdateFileBackupKb)
	EVT_MENU(ID_FILE_RESTORE_KB, CAdapt_ItApp::OnFileRestoreKb)
	EVT_UPDATE_UI(ID_FILE_RESTORE_KB, CAdapt_ItApp::OnUpdateFileRestoreKb)
	EVT_MENU(ID_FILE_CHANGEFOLDER, CAdapt_ItApp::OnFileChangeFolder)
	EVT_UPDATE_UI(ID_FILE_CHANGEFOLDER, CAdapt_ItApp::OnUpdateFileChangeFolder)
	EVT_MENU(ID_FILE_EXPORT_KB, CAdapt_ItApp::OnFileExportKb)
	EVT_UPDATE_UI(ID_FILE_EXPORT_KB, CAdapt_ItApp::OnUpdateFileExportKb)
	//EVT_MENU_RANGE(wxID_FILE1, wxID_FILE9, CAdapt_ItApp::OnOpenRecentFile)// renamed to
	    //OnMRUFile and moved to CMainFrame

    // We must not associate OnExit with wxID_EXIT. If we do, OnExit() executes immediately
    // upon selection of File|Exit causing all sorts of problems. Rather we must allow
    // OnExit() to be called by the doc/view framework after it has deleted the current doc
    // and view. Otherwise, if this handler below is enabled, the app won't exit without
    // crashing in the process.
	//EVT_MENU(wxID_EXIT, OnExit)

	// Edit Menu handlers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	// OnEditUndo is in the View
	// OnUpdateEditUndo is in the View
	// OnEditCut is in the View
	// OnUpdateEditCut is in the View
	// OnEditCopy is in the View
	// OnUpdateEditCopy is in the View
	// OnEditPaste is in the View
	// OnUpdateEditPaste is in the View
	// OnGoTo is in the View
	// OnUpdateGoTo is in the View
	// OnEditPunctCorresp is in the View  // incorporated into Edit|Preferences
	// OnUpdateEditPunctCorresp is in the View  // incorporated into Edit|Preferences
	// OnEditSourceText is in the View
	// OnUpdateEditSourceText is in the View
	// OnEditConsistencyCheck is in the View
	// OnUpdateEditConsistencyCheck is in the View
	// Lower to Upper Case Equivalences... removed as a separate menu item from Edit
	// menu (now handled by Edit Preferences)
	// OnEditPreferences is in the View
	// OnUpdateEditPreferences is in the View

	// View Menu handlers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//OnViewToolBar is in the MainFrame
	//OnUpdateViewToolBar is in the MainFrame
	//OnViewStatusBar is in the MainFrame
	//OnUpdateViewStatusBar is in the MainFrame
	//OnViewComposeBar is in the MainFrame
	//OnUpdateViewComposeBar is in the MainFrame
	//OnCopySource is in the View
	//OnUpdateCopySource is in the View // not in MFC version
	//OnFitWindow is in the View
	//OnMarkerWrapsStrip is in the View
	//OnUpdateMarkerWrapsStrip is in the View
	//OnUnits is in the View
	//OnUpdateUnits is in the View

	// Tools Menu handlers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//OnFind is in the View
	//OnUpdateFind is in the View
	//OnReplace is in the View
	//OnUpdateReplace is in the View
	EVT_MENU(ID_TOOLS_DEFINE_CC, CAdapt_ItApp::OnToolsDefineCC)
	EVT_UPDATE_UI(ID_TOOLS_DEFINE_CC, CAdapt_ItApp::OnUpdateLoadCcTables)
	EVT_MENU(ID_UNLOAD_CC_TABLES, CAdapt_ItApp::OnToolsUnloadCcTables)
	EVT_UPDATE_UI(ID_UNLOAD_CC_TABLES, CAdapt_ItApp::OnUpdateUnloadCcTables)
	//OnUseConsistentChanges is in the View
	//OnUpdateUseConsistentChanges is in the View
	//OnAcceptChanges is in the View
	//OnUpdateAcceptChanges is in the View
	//OnToolsKbEditor is in the View
	//OnUpdateToolsKbEditor is in the View

	// Note: Automatic capitalization is no longer a separate menu item
	// now that there is a tab in Edit / Preferences for Capitalization
	EVT_MENU(ID_TOOLS_AUTO_CAPITALIZATION, CAdapt_ItApp::OnToolsAutoCapitalization)
	EVT_UPDATE_UI(ID_TOOLS_AUTO_CAPITALIZATION, CAdapt_ItApp::OnUpdateToolsAutoCapitalization)
	//OnRetransReport is in the View
	//OnUpdateRetransReport is in the View

	// Advanced Menu handlers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//OnAdvancedSeeGlosses is in the View
	//OnUpdateAdvancedEnableglossing  is in the View
	//OnAdvancedGlossingUsesNavFont  is in the View
	//OnUpdateAdvancedGlossingUsesNavFont  is in the View
	EVT_MENU(ID_ADVANCED_TRANSFORM_ADAPTATIONS_INTO_GLOSSES, CAdapt_ItApp::OnAdvancedTransformAdaptationsIntoGlosses)
	EVT_UPDATE_UI(ID_ADVANCED_TRANSFORM_ADAPTATIONS_INTO_GLOSSES, CAdapt_ItApp::OnUpdateAdvancedTransformAdaptationsIntoGlosses)
	EVT_MENU(ID_ADVANCED_BOOKMODE, CAdapt_ItApp::OnAdvancedBookMode)
	EVT_UPDATE_UI(ID_ADVANCED_BOOKMODE, CAdapt_ItApp::OnUpdateAdvancedBookMode)
	//OnAdvancedDelay  is in the View
	//OnUpdateAdvancedDelay  is in the View

	// Help menu handlers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	//OnAppAbout is in CMainFrame in wxWidgets version

	// Administrator menu handlers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	EVT_MENU(ID_CUSTOM_WORK_FOLDER_LOCATION, CAdapt_ItApp::OnCustomWorkFolderLocation)
	EVT_UPDATE_UI(ID_CUSTOM_WORK_FOLDER_LOCATION, CAdapt_ItApp::OnUpdateCustomWorkFolderLocation)
	EVT_MENU(ID_SET_PASSWORD_MENU, CAdapt_ItApp::OnSetPassword)
	EVT_UPDATE_UI(ID_SET_PASSWORD_MENU, CAdapt_ItApp::OnUpdateSetPassword)
	EVT_MENU(ID_LOCAL_WORK_FOLDER_MENU, CAdapt_ItApp::OnRestoreDefaultWorkFolderLocation)
	EVT_UPDATE_UI(ID_LOCAL_WORK_FOLDER_MENU, CAdapt_ItApp::OnUpdateRestoreDefaultWorkFolderLocation)
	EVT_MENU(ID_LOCK_CUSTOM_LOCATION, CAdapt_ItApp::OnLockCustomLocation)
	EVT_UPDATE_UI(ID_LOCK_CUSTOM_LOCATION, CAdapt_ItApp::OnUpdateLockCustomLocation)
	EVT_MENU(ID_UNLOCK_CUSTOM_LOCATION, CAdapt_ItApp::OnUnlockCustomLocation)
	EVT_UPDATE_UI(ID_UNLOCK_CUSTOM_LOCATION, CAdapt_ItApp::OnUpdateUnlockCustomLocation)
	EVT_MENU(ID_MOVE_OR_COPY_FOLDERS_OR_FILES, CAdapt_ItApp::OnMoveOrCopyFoldersOrFiles)
	EVT_UPDATE_UI(ID_MOVE_OR_COPY_FOLDERS_OR_FILES, CAdapt_ItApp::OnUpdateMoveOrCopyFoldersOrFiles)
	EVT_MENU(ID_ASSIGN_LOCATIONS_FOR_INPUTS_OUTPUTS, CAdapt_ItApp::OnAssignLocationsForInputsAndOutputs)
	EVT_UPDATE_UI(ID_ASSIGN_LOCATIONS_FOR_INPUTS_OUTPUTS, CAdapt_ItApp::OnUpdateAssignLocationsForInputsAndOutputs)
	EVT_MENU(ID_SETUP_EDITOR_COLLABORATION, CAdapt_ItApp::OnSetupEditorCollaboration)
	EVT_UPDATE_UI(ID_SETUP_EDITOR_COLLABORATION, CAdapt_ItApp::OnUpdateSetupEditorCollaboration)
	//EVT_MENU(ID_PASSWORD_PROTECT_COLLAB_SWITCHING, CAdapt_ItApp::OnPasswordProtectCollaborationSwitching)
	//EVT_UPDATE_UI(ID_PASSWORD_PROTECT_COLLAB_SWITCHING, CAdapt_ItApp::OnUpdatePasswordProtectCollaborationSwitching)
	EVT_MENU(ID_MENU_TEMP_TURN_OFF_CURRENT_PROFILE, CAdapt_ItApp::OnTempRestoreUserProfiles) // whm added 14Feb12
	EVT_UPDATE_UI(ID_MENU_TEMP_TURN_OFF_CURRENT_PROFILE, CAdapt_ItApp::OnUpdateTempRestoreUserProfiles) // whm added 14Feb12
	EVT_MENU(ID_EDIT_USER_MENU_SETTINGS_PROFILE, CAdapt_ItApp::OnEditUserMenuSettingsProfiles)
	EVT_UPDATE_UI(ID_EDIT_USER_MENU_SETTINGS_PROFILE, CAdapt_ItApp::OnUpdateEditUserMenuSettingsProfiles)
	EVT_MENU(ID_MENU_HELP_FOR_ADMINISTRATORS, CAdapt_ItApp::OnHelpForAdministrators)
	EVT_UPDATE_UI(ID_MENU_HELP_FOR_ADMINISTRATORS, CAdapt_ItApp::OnUpdateHelpForAdministrators)

	EVT_TIMER(wxID_ANY, CAdapt_ItApp::OnTimer)

	//EVT_WIZARD_PAGE_CHANGING(IDC_WIZARD,CAdapt_ItApp::WizardPageIsChanging)
	//EVT_WIZARD_FINISHED(-1,CAdapt_ItApp::OnWizardFinish) // not needed, can handle directly
	// by checking the return bool value of RunWizard.
END_EVENT_TABLE()

/////////////////////////////////////////////////////////////////////////////
// NOTE: Under wxWidgets I've changed the following from static TCHAR arrays to
// just wxStrings, since all the methods in wxWidgets are efficient
// and sufficiently UNICODE aware with wxStrings.
//
// whm I've decided that the literal strings that are used to identify parts of
// the configuration files should NOT be localizable. Therefore, I've used the _T()
// literal string macro (which makes them ignored for translation when GetText
// and/or PoEdit collects the translatable strings for localization). Reason: If
// these strings are localized, they would create a situation in which the config
// files would only be readable by others using the same localized interface
// version of Adapt It. This might become a problem if say a team using the
// French interface were to pack up their Adapt It documents and sent them to a
// consultant who is using a different interface version of Adapt It. Packed
// files would not be compatible except for unpacking on machines using the
// same language interface version.

/// The name used internally within the project settings configuration file.
wxString szProjectSettings = _T("ProjectSettings"); // don't need \n now
/// The name used internally within the basic settings configuration file.
wxString szBasicSettings = _T("Settings"); // don't need \n now

/// The name of the project configuration file without the .aic extension.
wxString szProjectConfiguration = _T("AI-ProjectConfiguration");

/// The name of the basic configuration file without the .aic extension.
wxString szBasicConfiguration = _T("AI-BasicConfiguration");

/// The name of the administrator basic configuration file without the .aic extension.
/// This name is used for a modified basic configuration file stored at a custom location
/// when the administrator is accessing someone's work folder stored on the
/// administrator's local machine at a non-standard folder location. The idea is not to
/// modify the original basic configuration file with the name given by
/// szBasicConfiguration because the latter will be what the someone else will want to be
/// unchanged when/if that work folder is checked out of DVCS to that someone else's machine
wxString szAdminBasicConfiguration = _T("AI-AdminBasicConfiguration");

/// The name of the administrator project configuration file without the .aic extension.
/// This name is used for a modified project configuration file stored in a project folder
/// at a custom location when the administrator is accessing it. The idea is not to
/// modify the original project configuration file with the name given by
/// szProjectConfiguration because the latter will be what the someone else will want to be
/// unchanged when/if that work folder is checked out of DVCS to that someone else's machine
wxString szAdminProjectConfiguration = _T("AI-AdminProjectConfiguration");

/// The name that introduces the properties of the source font within both
/// the basic and project configuration files.
wxString szSourceFont = _T("SourceFont"); // don't need \n now

/// The name that introduces the properties of the target font within both
/// the basic and project configuration files.
wxString szTargetFont = _T("TargetFont"); // don't need \n now

/// The name that introduces the properties of the navigation font within both
/// the basic and project configuration files.
wxString szNavTextFont = _T("NavTextFont"); // don't need \n now

/// The label that identifies the following number as a "negative height" value
/// for the current font being described in the basic and project configuration
/// files. See the PointSizeToNegHeight() and NegHeightToPointSize() helper
/// functions in help.cpp for information on how a "negative height" value is
/// converted to a standard point size.
wxString szHeight = _T("Height");

/// The label that identifies the following number as a font "Width". This number
/// is not used in the wxWidgets version of Adapt It. It is set to zero if the
/// wx version creates the configuration file, or preserves any existing Width
/// value when loading a configuration file created by an MFC version of Adapt It.
wxString szWidth = _T("Width");

/// The label that identifies the following number as a font "Escapement".
/// This number is not used in the wxWidgets version of Adapt It. It is set to
/// zero if the wx version creates the configuration file, or preserves any
/// existing Escapement value when loading a configuration file created by an
/// MFC version of Adapt It.
wxString szEscapement = _T("Escapement");

/// The label that identifies the following number as a font "Orientation".
/// This number is not used in the wxWidgets version of Adapt It. It is set to
/// zero if the wx version creates the configuration file, or preserves any
/// existing Orientation value when loading a configuration file created by an
/// MFC version of Adapt It.
wxString szOrientation = _T("Orientation");

/// The label that identifies the following number as a font "Weight".
/// The wx version converts this value internally to its own enum value
/// for wxLIGHT (400-499), wxNORMAL (500-699), or wxBOLD (700 or more).
/// For compatability with the MFC version, the wx version writes the
/// numerical value only (as strings) in the configuration files.
wxString szWeight = _T("Weight");

/// The label that identifies the following number as font "Italic" if
/// "1", or normal if "0". The wx version converts this value internally
/// to its own enum value for wxITALIC or wxNORMAL.
/// For compatability with the MFC version, the wx version writes the
/// numerical value only (as strings) in the configuration files.
wxString szItalic = _T("Italic");

/// The label that identifies the following number as font "StrikeOut".
/// This number is not used in the wxWidgets version of Adapt It. It is set to
/// zero if the wx version creates the configuration file, or preserves any
/// existing StrikeOut value when loading a configuration file created by an
/// MFC version of Adapt It.
wxString szStrikeOut = _T("StrikeOut");

/// The label that identifies the following number as font "Underline" if
/// "1", or normal if "0". The wx version converts this value internally
/// to its own boolean values of TRUE for Underline, FALSE otherwise.
/// For compatability with the MFC version, the wx version writes the
/// numerical value only (as strings) in the configuration files.
wxString szUnderline = _T("Underline");

/// The label that identifies the following number as bitmap composite for
/// font "PitchAndFamily". The wx version is only interested in the font
/// family part of this composite value, which it determines by masking
/// out the 4 low order bits of the value. Only the font family values are
/// used within the wx version. The font "pitch" value is stored for later
/// composition again with the "family" value for saving the composite in
/// the configuration files.
/// For compatability with the MFC version, the wx version writes the
/// numerical value only (as strings) in the configuration files.
wxString szPitchAndFamily = _T("PitchAndFamily");

/// The label that identifies the following number as a font "FontEncoding". The wx version
/// makes use of this value for ANSI builds. It is not included in a configuration file
/// created by the MFC version. Note: setting the font encoding of the actual font is done
/// after CharSet value is read from the config file because, if the config file was
/// produced by the MFC app, it won't have this szFontEncoding field, but ig will have the
/// CharSet value.
wxString szFontEncoding = _T("FontEncoding");

/// The label that identifies the following number as a font "CharSet". The wx version
/// retains the CharSet value mainly for backwards compatibility with the MFC version's
/// configure files. Note: It is when the CharSet value is read from the configuration file
/// that font encoding is established for the font in ANSI builds (if the congig file has a
/// FontEncoding value. The wx version uses its MapMFCCharsetToWXFontEncoding(), and
/// MapWXFontEncodingToMFCCharset() functions to map values to and from the closest font
/// encoding equivalents that it knows about.
wxString szCharSet = _T("CharSet");

/// The label that identifies the following number as font "OutPrecision". This number is
/// not used in the wxWidgets version of Adapt It. It is set to 3 (OUT_OUTLINE_PRECIS) as
/// its default for TrueType fonts if the wx version creates the configuration file, or
/// preserves any existing OutPrecision value when loading a configuration file created by
/// an MFC version of Adapt It.
wxString szOutPrecision = _T("OutPrecision");

/// The label that identifies the following number as font "ClipPrecision". This number is
/// not used in the wxWidgets version of Adapt It. It is set to 2 (CLIP_STROKE_PRECIS) as
/// its default if the wx version creates the configuration file, or preserves any existing
/// ClipPrecision value when loading a configuration file created by an MFC version of
/// Adapt It.
wxString szClipPrecision = _T("ClipPrecision");

/// The label that identifies the following number as font "Quality". This number is not
/// used in the wxWidgets version of Adapt It. It is set to 0 (ANTIALIASED_QUALITY) as its
/// default if the wx version creates the configuration file, or preserves any existing
/// Quality value when loading a configuration file created by an MFC version of Adapt It.
wxString szQuality = _T("Quality");

/// The label that identifies the following string as font "FaceName". The wx version
/// attempts to set the FaceName of its fonts using this string value stored in the
/// configurations files by calling the font's SetFaceName() method. It SetFaceName() does
/// not succeed, the application calls the font's GetFaceName() method to have the system
/// decide on a suitable font.
wxString szFaceName = _T("FaceName");

//wxString szSystem = _("System"); // unused

/// The label that identifies the following number as a font "Color". The wx version uses
/// its Int2wxColour(), and WxColour2Int() functions to map values to and from the the
/// numerical color equivalent values. Note:
/// A font's color is handled in objects of the wxFontData class rather than in the wxFont
/// class.
wxString szColor = _T("Color");

// stuff I am not yet using is below
//wxString szWordWrap = _("WordWrap"); // unused
//wxString szTabStops = _("TabStops"); // unused

// entry names for the settings info

/// The label that identifies the following string as the project's "SourceLanguageName".
/// This value is written in the "Settings" part of the basic configuration file and in the
/// "ProjectSettings" part of the project configuration file. Adapt It stores this path in
/// the App's m_sourceName member variable.
wxString szSourceLanguageName = _T("SourceLanguageName"); // stored in the App's m_sourceName

/// The label that identifies the following string as the project's "TargetLanguageName".
/// This value is written in the "Settings" part of the basic configuration file and in the
/// "ProjectSettings" part of the project configuration file. Adapt It stores this path in
/// the App's m_targetName member variable.
wxString szTargetLanguageName = _T("TargetLanguageName");

/// The label that identifies the following string as the project's "GlossesLanguageName".
/// This value is written in the "Settings" part of the basic configuration file and in the
/// "ProjectSettings" part of the project configuration file. Adapt It stores this path in
/// the App's m_glossesName member variable.
wxString szGlossesLanguageName = _T("GlossesLanguageName");

// whm added following 10May10 for KB LIFT XML Export support
/// The label that identifies the following string as the project's "SourceLanguageCode".
/// This value is written in the "ProjectSettings" part of the project configuration file.
/// Adapt It stores this path in the App's m_sourceLanguageCode member variable.
wxString szSourceLanguageCode = _T("SourceLanguageCode"); // stored in the App's m_sourceName

// whm added following 10May10 for KB LIFT XML Export support
/// The label that identifies the following string as the project's "TargetLanguageCode".
/// This value is written in the "ProjectSettings" part of the project configuration file.
/// Adapt It stores this string in the App's m_targetLanguageCode member variable.
wxString szTargetLanguageCode = _T("TargetLanguageCode");

// whm added following 10May10 for KB LIFT XML Export support
/// The label that identifies the following string as the project's "GlossesLanguageCode".
/// This value is written in the "ProjectSettings" part of the project configuration file.
/// Adapt It stores this string in the App's m_glossesLanguageCode member variable.
wxString szGlossesLanguageCode = _T("GlossesLanguageCode");

/// The label that identifies the following string as the project's "TargetLanguageName".
/// This value is written in the "Settings" part of the basic configuration file. After
/// validating this path to ensure its validity on the local machine, Adapt It stores this
/// path in the App's m_workFolderPath member variable.
wxString szAdaptitPath = _T("AdaptItPath");

/// The label that identifies the following string as the project's "ProjectName". This
/// value is written in the "Settings" part of the basic configuration file. Adapt It
/// stores this name in the App's m_curProjectName member variable.
wxString szCurProjectName = _T("ProjectName");

/// The label that identifies the following string as the project's "ProjectFolderPath".
/// This value is written in the "ProjectSettings" part of the project configuration file.
/// Adapt It stores this path in the App's m_curProjectPath member variable.
wxString szCurLanguagesPath = _T("ProjectFolderPath");

/// The label that identifies the following string as the project's "DocumentsFolderPath".
/// This value is written in the "ProjectSettings" part of the project configuration file.
/// Adapt It stores this path in the App's m_curAdaptionsPath member variable.
wxString szCurAdaptionsPath = _T("DocumentsFolderPath");

/// The label that identifies the following string as the project's "KnowledgeBaseName".
/// This value is written in the "ProjectSettings" part of the project configuration file.
/// Adapt It stores this name in the App's m_curKBName member variable.
wxString szCurKBName = _T("KnowledgeBaseName");

/// The label that identifies the following string as the project's "KnowledgeBasePath".
/// This value is written in the "ProjectSettings" part of the project configuration file.
/// Adapt It stores this path in the App's m_curKBName member variable.
wxString szCurKBPath = _T("KnowledgeBasePath");

/// The label that identifies the following string as the project's "KBBackupPath". This
/// value is written in the "ProjectSettings" part of the project configuration file. Adapt
/// It stores this path in the App's m_curKBBackupPath member variable.
wxString szCurKBBackupPath = _T("KBBackupPath");

// BEGINNING of Last...Path variables below

/// The label that identifies the following string as the project's
/// "LastNewDocumentFolder". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastSourceInputPath member variable.
wxString szLastSourceInputPath = _T("LastNewDocumentFolder");

/// The label that identifies the following string as the project's
/// "LastSourceTextExportPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastSourceOutputPath member variable.
wxString szLastSourceOutputPath = _T("LastSourceTextExportPath");

/// The label that identifies the following string as the project's
/// "LastSourceTextRTFExportPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastSourceRTFOutputPath member variable.
wxString szLastSourceRTFOutputPath = _T("LastSourceTextRTFExportPath");

/// The label that identifies the following string as the project's
/// "LastKBExportPath". This value is written in the "BasicSettings" part
/// of the basic configuration file. Adapt It stores this path in the
/// App's m_lastKbOutputPath member variable.
/// The old config label "KB_ExportPath" is retained for reading older
/// config files.
wxString szLastKBExportPath = _T("LastKBExportPath"); // new label for 6.x.x and later
wxString szKBExportPath = _T("KB_ExportPath"); // old label - retain for reading older config files

/// The label that identifies the following string as the project's
/// "LastKBLIFTExportPath". This value is written in the "BasicSettings"
/// part of the basic configuration file. Adapt It stores this path in the
/// App's m_lastKbLiftOutputPath member variable.
wxString szLastKBLIFTExportPath = _T("LastKBLIFTExportPath"); // stored in the App's m_lastKbLiftOutputPath
wxString szKBLIFTExportPath = _T("KB_LIFT_ExportPath"); // old label used only in development but retained to avoid warning

/// The label that identifies the following string as the project's
/// "RetranslationReportPath". This value is written in the "BasicSettings"
/// part of the basic configuration file. Adapt It stores this path in the
/// App's m_lastRetransReportPath member variable.
wxString szLastRetranslationReportPath = _T("LastRetranslationReportPath"); // new label for 6.x.x and later
wxString szRetranslationReportPath = _T("RetranslationReportPath"); // old label - retain for reading older config files

/// whm 6Aug11 Note: The m_lastRtfOutputPath is no longer used, but is
/// replaced by more specific variables that are stored in project config files.
/// We keep the szRTFExportPath label in config reading routines however, since
/// we want to be able to recognize when an old basic config file is being read
/// that will have this field - we read it but just ignore it.
wxString szRTFExportPath = _T("RTFExportPath");

/// The label that identifies the following string as the project's
/// "LastInterlinearRTFOutputPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastInterlinearRTFOutputPath member variable.
wxString szLastInterlinearRTFOutputPath = _T("LastInterlinearRTFOutputPath");

/// The label that identifies the following string as the project's
/// "LastGlossesExportPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastGlossesOutputPath member variable.
wxString szLastGlossesOutputPath = _T("LastGlossesTextExportPath");

/// The label that identifies the following string as the project's
/// "LastGlossesRTFExportPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastGlossesRTFOutputPath member variable.
wxString szLastGlossesRTFOutputPath = _T("LastGlossesTextRTFExportPath");

/// The label that identifies the following string as the project's
/// "LastFreeTranslationsExportPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastFreeTransOutputPath member variable.
wxString szLastFreeTransOutputPath = _T("LastFreeTransExportPath");

/// The label that identifies the following string as the project's
/// "LastFreeTranslationsRTFExportPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastFreeTransRTFOutputPath member variable.
wxString szLastFreeTransRTFOutputPath = _T("LastFreeTransRTFExportPath");

/// The label that identifies the following string as the application's
/// "LastCCTablePath". This value is written in the "Settings" part of
/// the basic configuration file. Adapt It stores this path in the
/// App's m_lastCcTablePath member variable.
/// The old "DefaultCCTablePath" label is recognized for reading of older
/// config files.
wxString szLastCCTablePath = _T("LastCCTablePath");
wxString szDefaultTablePath = _T("DefaultCCTablePath");

/// The label that identifies the following string as the application's
/// "LastPackedDocumentPath". This value is written in the "Settings"
/// part of the basic configuration file. Adapt It stores this path in the
/// App's m_lastPackedOutputPath member variable.
wxString szLastPackedDocumentPath = _T("LastPackedDocumentPath");

/// The label that identifies the following string as the application's
/// "LastDocumentPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastDocPath member variable.
wxString szLastDocPath = _T("LastDocumentPath");

/// The label that identifies the following string as the application's
/// "LastExportPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path
/// in the App's m_lastTargetOutputPath member variable. The old
/// "LastExportPath" label is recognized for reading of older config
/// files.
wxString szLastTargetOutputPath = _T("LastTargetExportPath"); // new 6.x.x label for config files
wxString szLastExportPath = _T("LastExportPath"); // old pre-6.x.x label for reading old config files

/// The label that identifies the following string as the application's
/// "LastTargetRTFExportPath". This value is written in the "ProjectSettings"
/// part of the project configuration file. Adapt It stores this path in the
/// App's m_lastTargetRTFOutputPath member variable.
wxString szLastTargetRTFOutputPath = _T("LastTargetRTFExportPath");
// END of Last...Path variables

/// The label that identifies the following string as the project's
/// "FoldersProtectedFromNavigation". This value is written in the "ProjectSettings" part
/// of the project configuration file. Adapt It stores this path in the App's
/// m_foldersProtectedFromNavigation member variable.
wxString szFoldersProtectedFromNavigation = _T("FoldersProtectedFromNavigation");

// the following ones relate to view parameters

// The label that identifies the following string encoded number as the application's
// "MaxToDisplay". This value is written in the "Settings" part of the basic configuration
// file. Adapt It stores this value in the App's m_nMaxToDisplay member variable.
// BEW retained 21Mar09, but now it stores doc count of CSourcePhrase instances, no use
// made of it though - for backwards compatibility of config files
wxString szMaxToDisplay = _T("MaxToDisplay"); // stored in the App's m_nMaxToDisplay

/// The label that identifies the following string encoded number as the application's
/// "MinPrecedingContext". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_nPrecedingContext member
/// variable.
/// Jul 09 deprecated: retained for config file backwards compatibility
wxString szMinPrecContext = _T("MinPrecedingContext");

/// The label that identifies the following string encoded number as the application's
/// "MinFollowingContext". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_nFollowingContext member
/// variable.
/// Jul 09 deprecated: retained for config file backwards compatibility
wxString szMinFollContext = _T("MinFollowingContext");

/// The label that identifies the following string encoded number as the application's
/// "Leading". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this path in the App's m_curLeading member variable.
wxString szLeading = _T("Leading");

/// The label that identifies the following string encoded number as the application's
/// "LeftMargin". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this path in the App's m_curLMargin member  variable.
wxString szLeftMargin = _T("LeftMargin");

/// The label that identifies the following string encoded number as the application's
/// "InterpileGapWidth". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this path in the App's m_curGapWidth member  variable.
wxString szGapWidth = _T("InterpileGapWidth");

/// The label that identifies the following string encoded number as the application's
/// "SuppressFirstLine". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It used this value to suppress the "no punctuation" source
/// text line when strips had a max of five lines - two source, two target, and one gloss.
/// Deprecated July09. This is not used anymore, but must be retained in order to maintain
/// backwards compatibility of the configuration files
wxString szSuppressFirst = _T("SuppressFirstLine");

/// The label that identifies the following string encoded number as the application's
/// "SuppressLastLine". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It used this value to suppress the "no punctuation" target
/// text line when strips had a max of five lines - two source, two target, and one gloss.
/// Deprecated July09. This is not used anymore, but must be retained in order to maintain
/// backwards compatibility of the configuration files
wxString szSuppressLast = _T("SuppressLastLine");

/// The label that identifies the following string encoded number as the application's
/// "HidePunctuationFlag". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_bHidePunctuation member
/// variable.
wxString szHidePunctuation = _T("HidePunctuationFlag");

/// The label that identifies the following string encoded number as the application's
/// "SpecialTextColor". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_specialTextColor member
/// variable.
wxString szSpecialTextColor = _T("SpecialTextColor");

/// The label that identifies the following string encoded number as the application's
/// "RetranslationTextColor". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_reTranslnTextColor member
/// variable.
wxString szReTranslnTextColor = _T("RetranslationTextColor");

/// The label that identifies the following string encoded number as the application's
/// "TargetDifferencesTextColor". This value is not written in the "Settings" part of the
/// basic configuration file. Adapt It stores this path in the App's m_tgtDiffsTextColor
/// member variable.
wxString szTgtDiffsTextColor = _T("TargetDifferencesTextColor");

/// The label that identifies the following string encoded number as the application's
/// "PhraseBoxExpansionMultiplier". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this path in the App's gnExpandBox member
/// variable.
wxString szPhraseBoxExpansionMultiplier = _T("PhraseBoxExpansionMultiplier");

/// The label that identifies the following string encoded number as the application's
/// "TooNearEndMultiplier". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's gnNearEndFactor member
/// variable.
wxString szTooNearEndMultiplier = _T("TooNearEndMultiplier");

/// The label that identifies the following string encoded number as the application's
/// "LegacyCopyForPhraseBox". This value is written in the "ProjectSettings" part of the
/// project configuration file. Adapt It stores this path in the App's
/// gbLegacySourceTextCopy member variable.
wxString szLegacyCopyForPhraseBox = _T("LegacyCopyForPhraseBox");

// Next two were for old punct, for when source & target are not differentiated

/// A label now unused, that was used in old versions for punctuation. It is only retained
/// for reading legacy config files safely. Deprecated.
wxString szPunctuation = _T("Punctuation");

/// A label now unused, that was used in old versions for punctuation. It is only retained
/// for reading legacy config files safely. Deprecated.
wxString szPunctAsWordBuilding = _T("PunctuationAsWordBuilding");

// Next four were for newer variables but currently unused, for when source and target
// punctuation are potentially differentiated

/// A label now unused, that was used in old versions for punctuation. It is only retained
/// for reading legacy config files safely. Deprecated.
wxString szSrcPunctuation = _T("SourcePunctuation");

/// A label now unused, that was used in old versions for punctuation. It is only retained
/// for reading legacy config files safely. Deprecated.
wxString szSrcPunctAsWordBuilding = _T("SourcePunctAsWordBuilding");

/// A label now unused, that was used in old versions for punctuation. It is only retained
/// for reading legacy config files safely. Deprecated.
wxString szTgtPunctuation = _T("TargetPunctuation");

/// A label now unused, that was used in old versions for punctuation. It is only retained
/// for reading legacy config files safely. Deprecated.
wxString szTgtPunctAsWordBuilding = _T("TargetPunctAsWordBuilding");

/// The label that identifies the following string as the application's
/// "PunctuationPairs(stores space for an empty cell)". This value is written in the
/// "Settings" part of the basic configuration file. Adapt It stores this punctuation in
/// the App's m_punctPairs global array. The application uses the PunctPairsToString() and
/// StringToPunctPairs() functions to manipulate the pairs of punctuation data.
wxString szPunctPairs = _T("PunctuationPairs(stores space for an empty cell)");

/// The label that identifies the following string as the application's
/// "PunctuationTwoCharacterPairs". Used only in the Unicode version This value is written
/// in the "Settings" part of the basic configuration. file. Adapt It stores this
/// punctuation in the App's m_twopunctPairs global array. The application uses the
/// TwoPunctPairsToString() and StringToTwoPunctPairs() functions to manipulate the pairs
/// of punctuation data.
wxString szTwoPunctPairs = _T("PunctuationTwoCharacterPairs");
#ifdef _UNICODE

/// The label that identifies the following string as the application's
/// "PunctuationPairsSourceSet(stores space for an empty cell)". This value is written in
/// the "Settings" part of the basic configuration file. Adapt It stores this punctuation
/// in the App's m_twopunctPairs global string. The application uses the
/// PunctPairsToTwoStrings() and TwoStringsToPunctPairs() functions to manipulate the pairs
/// of punctuation data, punctuation data for the source language used here.
wxString szPunctPairsSrc = _T("PunctuationPairsSourceSet(stores space for an empty cell)");

/// The label that identifies the following string as the application's
/// "PunctuationTwoCharacterPairsSourceSet(ditto)". This value is written in the "Settings"
/// part of the basic configuration file. Adapt It stores this punctuation in the App's
/// m_twopunctPairs global string. The application uses the TwoPunctPairsToTwoStrings() and
/// TwoStringsToTwoPunctPairs() functions to manipulate the pairs of punctuation data,
/// punctuation data for the source language used here.
wxString szTwoPunctPairsSrc = _T("PunctuationTwoCharacterPairsSourceSet(ditto)");

/// The label that identifies the following string as the application's
/// "PunctuationPairsTargetSet(stores space for an empty cell)". This value is written in
/// the "Settings" part of the basic configuration file. Adapt It stores this punctuation
/// in the App's m_twopunctPairs global string. The application uses the
/// PunctPairsToTwoStrings() and TwoStringsToPunctPairs() functions to manipulate the pairs
/// of punctuation data, punctuation data for the target language used here.
wxString szPunctPairsTgt = _T("PunctuationPairsTargetSet(stores space for an empty cell)");

/// The label that identifies the following string as the application's
/// "PunctuationTwoCharacterPairsTargetSet(ditto)". This value is written in the "Settings"
/// part of the basic configuration file. Adapt It stores this punctuation in the App's
/// m_twopunctPairs global string. The application uses the TwoPunctPairsToTwoStrings() and
/// TwoStringsToTwoPunctPairs() functions to manipulate the pairs of punctuation data,
/// punctuation data for the target language used here.
wxString szTwoPunctPairsTgt = _T("PunctuationTwoCharacterPairsTargetSet(ditto)");
#endif

/// The label that identifies the following string encoded number as the application's
/// "StatusBarIsVisible". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_bStatusBarVisible member
/// variable.
wxString szStatusBarIsVisible = _T("StatusBarIsVisible");

/// The label that identifies the following string encoded number as the application's
/// "ToolBarIsVisible". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_bToolBarVisible member
/// variable.
wxString szToolBarIsVisible = _T("ToolBarIsVisible");

/// The label that identifies the following string encoded number as the application's
/// "ModeBarIsVisible". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_bModeBarVisible member
/// variable.
wxString szModeBarIsVisible = _T("ModeBarIsVisible");

/// The label that identifies the following string encoded number as the application's
/// "SuppressWelcome". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_bSuppressWelcome member
/// variable.
wxString szSuppressWelcome = _T("SuppressWelcome");

/// The label that identifies the following string encoded number as the application's
/// "UsePrefixExportTypeOnFilename". This value is written in the "Settings" part of
/// the basic configuration file. Adapt It stores this value as a boolean TRUE or
/// FALSE in the App's m_bUsePrefixExportTypeOnFilename member variable.
wxString szUsePrefixExportTypeOnFilename = _T("UsePrefixExportTypeOnFilename");

/// The label that identifies the following string encoded number as the application's
/// "UseSuffixExportDateTimeOnFilename". This value is written in the "Settings" part of
/// the basic configuration file. Adapt It stores this value as a boolean TRUE or
/// FALSE in the App's m_bUseSuffixExportDateTimeOnFilename member variable.
wxString szUseSuffixExportDateTimeOnFilename = _T("UseSuffixExportDateTimeOnFilename");

/// The label that identifies the following string encoded number as the application's
/// "UsePrefixExportProjectNameOnFilename". This value is written in the "Settings" part of
/// the basic configuration file. Adapt It stores this value as a boolean TRUE or
/// FALSE in the App's m_bUsePrefixExportProjectNameOnFilename member variable.
wxString szUsePrefixExportProjectNameOnFilename = _T("UsePrefixExportProjectNameOnFilename");

/// The label that identifies the following string encoded number as the application's
/// "SuppressTargetHighlighting". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's
/// m_bSuppressTargetHighlighting member variable.
wxString szSuppressTargetHighlighting = _T("SuppressTargetHighlighting");

/// The label that identifies the following string encoded number as the application's
/// "AutoInsertionsHighlightColor". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this path in the App's
/// m_AutoInsertionsHighlightColor member variable. Adapt It uses the WxColour2Int() and
/// Int2wxColour() helper functions to convert between the integer and wx color enum
/// symbols.
wxString szAutoInsertionsHighlightColor = _T("AutoInsertionsHighlightColor");

/// The label that identifies the following string encoded number as the application's
/// "GuessHighlightColor". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this path in the App's
/// m_GuessHighlightColor member variable. Adapt It uses the WxColour2Int() and
/// Int2wxColour() helper functions to convert between the integer and wx color enum
/// symbols.
wxString szGuessHighlightColor = _T("GuessHighlightColor");

/// The label that identifies the following string encoded number as the application's
/// "UseStartupWizardOnLaunch". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_bUseStartupWizardOnLaunch
/// member variable.
wxString szUseStartupWizardOnLaunch = _T("UseStartupWizardOnLaunch");

/// The label that identifies the following string encoded number as the application's
/// "BackupKnowledgeBase(Boolean)". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this path in the App's m_bAutoBackupKB member
/// variable.
wxString szBackupKBFlag = _T("BackupKnowledgeBase(Boolean)");

/// The label that identifies the following string encoded number as the application's
/// "TimeSpanForDocument - minutes". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this path in the App's m_timeSettings member
/// variable.
wxString szTS_DOC_MINS = _T("TimeSpanForDocument - minutes");

/// The label that identifies the following string encoded number as the application's
/// "TimeSpanForDocument - seconds". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It no longer makes use of the seconds time span value.
wxString szTS_DOC_SECS = _T("TimeSpanForDocument - seconds");

/// The label that identifies the following string encoded number as the application's
/// "TimeSpanForKB - minutes". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_timeSettings member
/// variable.
wxString szTS_KB_MINS = _T("TimeSpanForKB - minutes");

/// The label that identifies the following string encoded number as the application's
/// "TimeSpanForKB - seconds". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It no longer makes use of the seconds time span value.
wxString szTS_KB_SECS = _T("TimeSpanForKB - seconds");

/// The label that identifies the following string encoded number as the application's
/// "NoAutoSaveFlag(Boolean)". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_bNoAutoSave member
/// variable.
wxString szNoAutoSaveFlag = _T("NoAutoSaveFlag(Boolean)");

/// The label that identifies the following string encoded number as the application's
/// "DocumentTimeSpanButtonIsON(Boolean)". This value is written in the "Settings" part of
/// the basic configuration file. Adapt It stores this path in the App's m_bIsDocTimeButton
/// member variable.
wxString szIsDocTimeButtonFlag = _T("DocumentTimeSpanButtonIsON(Boolean)");

/// The label that identifies the following string encoded number as the application's
/// "PhraseBoxMovesForSave". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_nMoves member variable.
wxString szPhraseBoxMoves = _T("PhraseBoxMovesForSave");

/// The label that identifies the following string encoded number as the application's
/// "ColorOfNavigationText". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_navTextColor member
/// variable. Adapt It uses the WxColour2Int() and Int2wxColour() helper functions to
/// convert between the integer and wx color enum symbols.
wxString szNavTextColor = _T("ColorOfNavigationText");

/// The label that identifies the following string encoded number as the application's
/// "FitWithinWindowFlag(Boolean)". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It no longer uses this variable.
wxString szFitFlag = _T("FitWithinWindowFlag(Boolean)"); // unused as of version 2.4.0

/// The label that identifies the following string encoded number as the application's
/// "MarkersWrapStripsFlag(Boolean)". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this path in the App's m_bMarkerWrapsStrip
/// member variable.
wxString szMarkerWrapsFlag = _T("MarkersWrapStripsFlag(Boolean)");

/// The label that identifies the following string encoded number as the application's
/// "BackupDocumentFlag". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this path in the App's m_bBackupDocument member
/// variable.
wxString szBackupDocument = _T("BackupDocumentFlag");

// whm added 3Sep10 for user workflow profile support
/// The label that identifies the following string encoded number as the application's
/// "WorkflowProfile". This value is written in the "Settings" part of the basic
/// and project configuration files. Adapt It stores this path in the App's
/// m_nWorkflowProfile member variable.
wxString szWorkflowProfile = _T("WorkflowProfile");

// whm added 15Apr11 for Paratext collaboration support
// The label that identifies the following string encoded number as the application's
// "CollaboratingWithParatext". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a boolean in the App's
// m_bCollaboratingWithParatext member variable.
wxString szCollaboratingWithParatext = _T("CollaboratingWithParatext");

// whm added 15Apr11 for Paratext collaboration support
// The label that identifies the following string encoded number as the application's
// "CollaboratingWithBibledit". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a boolean in the App's
// m_bCollaboratingWithBibledit member variable.
wxString szCollaboratingWithBibledit = _T("CollaboratingWithBibledit");

// whm added 15Apr11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabProjectForSourceInputs". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_CollabProjectForSourceInputs member variable.
wxString szCollabProjectForSourceInputs = _T("CollabProjectForSourceInputs");

// whm added 15Apr11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabProjectForTargetExports". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_CollabProjectForTargetExports member variable.
wxString szCollabProjectForTargetExports = _T("CollabProjectForTargetExports");

// whm added 30Jun11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabProjectForFreeTransExports". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_CollabProjectForFreeTransExports member variable.
wxString szCollabProjectForFreeTransExports = _T("CollabProjectForFreeTransExports");

// whm added 30Jun11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabAIProjectName". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_CollabAIProjectName member variable.
wxString szCollabAIProjectName = _T("CollabAIProjectName");

// whm added 4Apr12 for Paratext/Bibledit collaboration support.
// The label that identifies the following string as the application's
// "CollaborationEditor". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_collaborationEditor member variable.
wxString szCollaborationEditor = _T("CollaborationEditor");

// whm added 30Jun11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabExpectsFreeTrans". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_bCollaborationExpectsFreeTrans member variable.
wxString szCollabExpectsFreeTrans = _T("CollabExpectsFreeTrans");

// whm added 27Apr11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabBookSelected". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_CollabBookSelected member variable.
wxString szCollabBookSelected = _T("CollabBookSelected");

// whm added 27Jul11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabByChapterOnly". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a boolean in the App's
// m_bCollabByChapterOnly member variable.
wxString szCollabByChapterOnly = _T("CollabByChapterOnly");

// whm added 27Apr11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabChapterSelected". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_CollabChapterSelected member variable.
wxString szCollabChapterSelected = _T("CollabChapterSelected");

// whm added 4Sep11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabSourceLangName". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_CollabSourceLangName member variable.
wxString szCollabSourceLangName = _T("CollabSourceLangName");

// whm added 4Sep11 for Paratext/Bibledit collaboration support.
// The label that identifies the following string encoded number as the application's
// "CollabTargetLangName". This value is written in the "ProjectSettings" part
/// of the project configuration file.  Adapt It stores this value as a wxString in the App's
// m_CollabTargetLangName member variable.
wxString szCollabTargetLangName = _T("CollabTargetLangName");

/// The label that identifies the following string as an int, either 0 or 1 storing the flag
/// value which indicates whether the "Change Paratext/Bibledit Projects" button is password
/// protected in the "Setup Paratext/Bibledit Collaboration" dialog.
//wxString szCollabSwitchingPasswordProtected = _T("CollabSwitchingPasswordProtected");

/// The label that identifies the following string as a password which can be used to
/// control access to the "Change Paratext/Bibledit Projects" button in the Get Source Text
/// from Paratext/Bibledit Project" dialog. An administrator can set this password via
/// the "Set password for collaboration switching..." button in the "Setup Paratext/Bibledit
/// Collaboration" dialog.
//wxString szCollabSwitchingPassword = _T("CollabSwitchingPassword");

// window position and size

/// The label that identifies the following string encoded number as the application's
/// "TopLeftX". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this value in the App's m_ptViewTopLeft.x member variable.
wxString szTopLeftX = _T("TopLeftX");

/// The label that identifies the following string encoded number as the application's
/// "TopLeftY". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this value in the App's m_ptViewTopLeft.y member variable.
wxString szTopLeftY = _T("TopLeftY");

/// The label that identifies the following string encoded number as the application's
/// "WinSizeCX". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this value in the App's m_szView.x member variable.
wxString szWSizeCX = _T("WinSizeCX");

/// The label that identifies the following string encoded number as the application's
/// "WinSizeCY". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this value in the App's m_szView.y member variable.
wxString szWSizeCY = _T("WinSizeCY");

// restoring earlier doc location

/// The label that identifies the following string encoded number as the application's
/// "LastActiveSequenceNumber". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's nLastActiveSequNum member
/// variable.
wxString szLastActiveSequNum = _T("LastActiveSequenceNumber");

/// The label that identifies the following string encoded number as the application's
/// "IsMainWindowMaximized". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_bZoomed member variable.
wxString szZoomed = _T("IsMainWindowMaximized");

// The label that identifies the following string as the application's
// "CustomWorkFolderPath". This value is written in the "Settings" part of the Project
// configuration file. Adapt It stores this path in the App's m_customWorkFolderPath member
// variable. The contents of this variable are used when the App's boolean member
// m_bLockedCustomWorkFolderPath is TRUE. (The same variable is used when the administrator
// temporarily points Adapt It at a custom work folder location, but we don't track such
// usage because the flag m_bLockedCustomWorkFolderPath is FALSE when that is the case)
wxString szCustomWorkFolderPath = _T("CustomWorkFolderPath");

// The label that identifies the following string as the application's
// "m_bLockedCustomWorkFolderPath" boolean value. This value is written in the "Settings" part
// of the Basic configuration file. Adapt It stores this boolean in the App's
// m_bUseCustomWorkFolderPath member variable. When m_bLockedCustomWorkFolderPath is TRUE,
// the work folder location is taken from the contents of the CustomWorkFolderLocation file
// stored in the default work folder, and assigned to the variable m_customWorkFolderPath.
wxString szLockedCustomWorkFolderPath = _T("LockedCustomWorkFolderPath");

// print margins, etc

/// The label that identifies the following string encoded number as the application's
/// "UseInchesForMeasuring". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_bIsInches member
/// variable.
wxString szLoEnglishFlag = _T("UseInchesForMeasuring");

/// The label that identifies the following string encoded number as the application's
/// "UsePortraitOrientation". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_bIsPortraitOrientation
/// member variable.
wxString szUsePortraitOrientation = _T("UsePortraitOrientation");

/// The label that identifies the following string encoded number as the application's
/// "TopPrintMargin". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_marginTop and
/// m_marginTopMM member variable.
wxString szMarginTop = _T("TopPrintMargin");

/// The label that identifies the following string encoded number as the application's
/// "BottomPrintMargin". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_marginBottom and
/// m_marginBottomMM member variable.
wxString szMarginBottom = _T("BottomPrintMargin");

/// The label that identifies the following string encoded number as the application's
/// "LeftPrintMargin". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_marginLeft and
/// m_marginLeftMM member variable.
wxString szMarginLeft = _T("LeftPrintMargin");

/// The label that identifies the following string encoded number as the application's
/// "RightPrintMargin". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_marginRight and
/// m_marginRightMM member variable.
wxString szMarginRight = _T("RightPrintMargin");

/// The label that identifies the following string encoded number as the application's
/// "LastUsedPageWidth". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_pageWidth and
/// m_pageWidthMM member variable.
wxString szLastPageWidth = _T("LastUsedPageWidth");

/// The label that identifies the following string encoded number as the application's
/// "LastUsedPageLength". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_pageLength and
/// m_pageLengthMM member variable.
wxString szLastPageLength = _T("LastUsedPageLength");

/// The label that identifies the following string encoded number as the application's
/// "PaperSizeCode". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_paperSizeCode member
/// variable.
wxString szPaperSizeCode = _T("PaperSizeCode");

/// The label that identifies the following string encoded number as the application's
/// "RTL_Layout". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this value in the App's m_bRTL_Layout member variable.
wxString szRTL_Layout = _T("RTL_Layout");

// support for user-assignable SFM escape char

/// The label that identifies the following string encoded number as the application's
/// "SFMescapeChar". This value is no longer used in Adapt I, but is retained for backward
/// compatibility of configuration files.
wxString szSFMescapechar = _T("SFMescapeChar");

/// The label that identifies the following string encoded number as the application's
/// "SFMafterNewlines". Adapt It stores this value in the App's gbSfmOnlyAfterNewlines
/// member variable.
wxString szSFMafterNewlines = _T("SFMafterNewlines");

#ifdef _RTL_FLAGS
// NR version support

/// The label that identifies the following string encoded number as the application's
/// "SourceIsRTL". Adapt It stores this value in the App's m_bSrcRTL member  variable.
/// The label is used only for the Unicode version.
wxString szRTLSource = _T("SourceIsRTL");

/// The label that identifies the following string encoded number as the application's
/// "TargetIsRTL". Adapt It stores this value in the App's m_bTgtRTL member  variable.
/// The label is used only for the Unicode version.
wxString szRTLTarget = _T("TargetIsRTL");

/// The label that identifies the following string encoded number as the application's
/// "NavTextIsRTL". Adapt It stores this value in the App's m_bNavTextRTL member  variable.
/// The label is used only for the Unicode version.
wxString szRTLNavText = _T("NavTextIsRTL");
#endif

// support for auto-capitalization

/// The label that identifies the following string as the application's
/// "LowerCaseSourceLanguageChars". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this value in the App's m_srcLowerCaseChars
/// global variable.
wxString szLowerCaseSourceChars = _T("LowerCaseSourceLanguageChars");

/// The label that identifies the following string as the application's
/// "UpperCaseSourceLanguageChars". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this value in the App's m_srcUpperCaseChars
/// global variable.
wxString szUpperCaseSourceChars = _T("UpperCaseSourceLanguageChars");

/// The label that identifies the following string as the application's
/// "LowerCaseTargetLanguageChars". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this path in the App's m_tgtLowerCaseChars
/// global variable.
wxString szLowerCaseTargetChars = _T("LowerCaseTargetLanguageChars");

/// The label that identifies the following string as the application's
/// "UpperCaseTargetLanguageChars". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this value in the App's m_tgtUpperCaseChars
/// global variable.
wxString szUpperCaseTargetChars = _T("UpperCaseTargetLanguageChars");

/// The label that identifies the following string as the application's
/// "LowerCaseGlossLanguageChars". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this value in the App's m_glossLowerCaseChars
/// global variable.
wxString szLowerCaseGlossChars = _T("LowerCaseGlossLanguageChars");

/// The label that identifies the following string as the application's
/// "UpperCaseGlossLanguageChars". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this value in the App's m_glossUpperCaseChars
/// global variable.
wxString szUpperCaseGlossChars = _T("UpperCaseGlossLanguageChars");

/// The label that identifies the following string encoded value as the application's
/// "AutoCapitalizationFlag". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's gbAutoCaps global variable.
wxString szAutoCapitalization = _T("AutoCapitalizationFlag");

/// The label that identifies the following string encoded value as the application's
/// "SourceHasUpperCaseAndLowerCase". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this value in the App's gbSrcHasUcAndLc
/// global variable.
wxString szSrcHasUcAndLc = _T("SourceHasUpperCaseAndLowerCase");// added in wx version
			// for Case page simplification

// version 3.x support for USFM and SFM Filtering

/// The label that identifies the following string encoded value as the application's
/// "UseSFMarkerSet". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's gProjectSfmSetForConfig
/// global variable.
wxString szUseSFMarkerSet = _T("UseSFMarkerSet");

/// The label that identifies the following string encoded value as the application's
/// "UsfmOnly". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this value in the App's gProjectSfmSetForConfig global enum
/// variable.
wxString szUsfmOnly = _T("UsfmOnly");

/// The label that identifies the following string encoded value as the application's
/// "PngOnly". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this value in the App's gProjectSfmSetForConfig global enum
/// variable.
wxString szPngOnly = _T("PngOnly");

/// The label that identifies the following string encoded value as the application's
/// "UsfmAndPng". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this value in the App's gProjectSfmSetForConfig global enum
/// variable.
wxString szUsfmAndPng = _T("UsfmAndPng");

/// The label that identifies the following string encoded value as the application's
/// "UseFilterMarkers". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's
/// gProjectFilterMarkersForConfig global variable.
wxString szUseFilterMarkers = _T("UseFilterMarkers");

/// The label that identifies the following string encoded value as the application's
/// "ChangeFixedSpaceToRegularSpace". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this value in the App's
/// m_bChangeFixedSpaceToRegularSpace global variable.
wxString szChangeFixedSpaceToRegSpace = _T("ChangeFixedSpaceToRegularSpace");

// version 2.4.0 support for user-defined font size in dialogs The label that identifies
// the following string encoded value as the application's "FontSizeForDialogs(points)".
// This value is written in the "Settings" part of the basic configuration file. Adapt It
// stores this value in the App's m_dialogFontSize global variable.
wxString szFontSizeForDialogs = _T("FontSizeForDialogs(points)");

// support for named Bible book folders (plus "Other Texts" catchall folder) for storing
// docs The label that identifies the following string encoded value as the application's
// "BookModeFlag". This value is written in the "Settings" part of the basic configuration
/// file. Adapt It stores this value in the App's m_bBookMode global variable.
wxString szBookMode = _T("BookModeFlag");

/// The label that identifies the following string encoded value as the application's
/// "BookIndexValue". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_bBookMode global
/// variable.
wxString szBookIndex = _T("BookIndexValue");

// BEW 30Apr10, this flag is deprecated. We read it but do nothing with it, and no longer
// write it in a project config file
wxString szSaveAsXML = _T("SaveAsXML");

// rde: added support for calling EncConverters to pre-process a target word whm: the
// followng three wxString values can remain defined whether or not the USE_SIL_CONVERTERS
// define is set:

/// The label that identifies the following string encoded value as the application's
/// "SilConverterName". This value is written in the "Settings" part of the basic
/// configuration file. Adapt It stores this value in the App's m_strSilEncConverterName
/// global variable.
wxString szSilConverterName = _T("SilConverterName"); // string

/// The label that identifies the following string encoded value as the application's
/// "SilConverterDirectionForward". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this value in the App's
/// m_bSilConverterDirForward global variable.
wxString szSilConverterDirForward = _T("SilConverterDirectionForward");   // bool

/// The label that identifies the following string encoded value as the application's
/// "SilConverterNormalizeOutput". This value is written in the "Settings" part of the
/// basic configuration file. Adapt It stores this value in the App's
/// m_eSilConverterNormalizeOutput global variable.
wxString szSilConverterNormalize = _T("SilConverterNormalizeOutput");

/// The label that identifies the following string as a password which can be used to make
/// the Administrator menu become visible at the end of the menu bar. (A checkbox in the
/// View tab of Preferences is where an administrator can request the menu be shown or hid)
wxString szAdministratorPassword = _T("AdministratorPassword");

/// The label that identifies the following string encoded number as the application's
/// "UseAdaptationsGuesser". Adapt It stores this value in the App's m_bUseAdaptationsGuesser
/// member  variable.
wxString szUseAdaptationsGuesser = _T("UseAdaptationsGuesser");

/// The label that identifies the following string encoded number as the application's
/// "GuessingLevel". Adapt It stores this value in the App's m_nGuessingLevel
/// member  variable.
wxString szGuessingLevel = _T("GuessingLevel");

/// The label that identifies the following string encoded number as the application's
/// "AllowCConUnchangedGuesserOutput". Adapt It stores this value in the App's
/// m_bAllowGuesseronUnchangedCCOutput.
/// member  variable.
wxString szAllowCConUnchangedGuesserOutput = _T("AllowCConUnchangedGuesserOutput");

// Note: ecDriverDynamicLibrary.Load() is called in OnInit()
wxDynamicLibrary ecDriverDynamicLibrary;
wxDynamicLibrary ptSharedDynamicLibrary;

#if defined(__WXMSW__)
const wxChar *LIB_NAME = _T("ECDriver.dll");
#elif defined(__UNIX__)
const wxChar *LIB_NAME = _T("/lib/ecdriver.so");
#else
#error "Cannot load wxDynamicLibrary ecdriver on this platform.";
#endif

const wxChar *PT_LIB_NAME = _T("ParatextShared.dll");

// whm Note: constants must be static and integral types to be initialized within a class
const wxChar *FUNC_NAME_EC_IS_INSTALLED = _T("IsEcInstalled");
const wxChar *FUNC_NAME_EC_SELECT_CONVERTER_AW = _T("EncConverterSelectConverter");
const wxChar *FUNC_NAME_EC_INITIALIZE_CONVERTER_AW = _T("EncConverterInitializeConverter");
const wxChar *FUNC_NAME_EC_CONVERTER_DESCRIPTION_AW = _T("EncConverterConverterDescription");
const wxChar *FUNC_NAME_EC_CONVERT_STRING_AW = _T("EncConverterConvertString");

/// The label that identifies the following string encoded value as the application's
/// "DoAdaptingBeforeGlossing_InVerticalEdit". This value is written in the
/// "ProjectSettings" part of the basic configuration file. Adapt It stores this value in
/// the App's gbAdaptBeforeGloss global variable.
wxString szDoAdaptingBeforeGlossing_InVerticalEdit =
	_T("DoAdaptingBeforeGlossing_InVerticalEdit");   // bool -- for vertical edit settings

/* this following code from AdminMoveOrCopy class is tested below at lines 5470++
wxString BuildChangedFilenameForCopy(wxString* pFilename);
wxString BuildChangedFilenameForCopy(wxString* pFilename)
{
	wxString newFilename = _T("");
	//wxFileName fn(m_strDestFolderPath,*pFilename);
	wxFileName fn(*pFilename);
	wxString extn = _T("");
	bool bHasExtension = FALSE;
	if (fn.HasExt())
	{
		extn = fn.GetExt();
		bHasExtension = TRUE; // to handle when only the . of an extension is present
	}
	wxString name = fn.GetName();
	wxString reversed = MakeReverse(name); // our utility from helpers.cpp
	// look for ")d...d(" at the start of the reversed string, where d...d is one or more
	// digits; we want to get the digit(s), convert to int, increment by 1, convert back
	// to digits, and build the new string with (n) at the end where n is the new larger
	// value. However, mostly no such end string is present, in which case we can just
	// create a name with "(2)" at the end immediately.
	wxString shortname;
	wxChar aChar = reversed.GetChar(0);
	wxString ending = _T("");
	if (aChar == _T(')'))
	{
		// we've got a filename with the name part in the form name(n) where n is one or
		// more digits (or at least we'll assume so)
		ending = aChar;
		shortname = reversed.Mid(1);
		// get the digits -- look for matching '(', if not found, just add "(2)" as below,
		// but if found, the characters up to that point should be the digit string we want
		int offset = shortname.Find(_T('('));
		if (offset == wxNOT_FOUND)
		{
			newFilename = name + _T("(2)");
			newFilename += _T(".") + extn;
		}
		else
		{
			wxString digitStr = shortname.Left(offset);
			shortname = shortname.Mid(offset); // this is now "(reversednamepart"
			// reverse digitStr, to make it normal order
			digitStr = MakeReverse(digitStr);
			// convert digitStr to an unsigned long
			unsigned long value;
			bool bConvertedOK = digitStr.ToULong(&value);
			if (!bConvertedOK)
			{
				// it wasn't a valid digit string, so make a (2) at end of original name
				newFilename = name + _T("(2)");
				newFilename += _T(".") + extn;
			}
			else
			{
				// it converted correctly, so bump the value by 1 and rebuild the new
				// string's output form
				value++;
				digitStr.Printf(_T("%d"),value);
				// now reverse it again
				digitStr = MakeReverse(digitStr);
				// prepend to shortname
				shortname = digitStr + shortname;
				// add the ending
				shortname = ending + shortname; // remember this is still reversed!
				// now reverse it back to natural order
				shortname = MakeReverse(shortname);
				newFilename = shortname + _T(".") + extn;
			}
		}
	}
	else
	{
		// assume it is a normal filename with no (n) on the end
		newFilename = name + _T("(2)");
		newFilename += _T(".") + extn;
	}
	return newFilename;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CAdapt_ItApp construction

// initialize static class variable
bool CAdapt_ItApp::bLookAheadMerge = FALSE;

/// **** DO NOT PUT INITIALIZATIONS IN THE APP'S CONSTRUCTOR *****
/// **** ALL INITIALIZATIONS SHOULD BE DONE IN THE APP'S OnInit() METHOD *****
CAdapt_ItApp::CAdapt_ItApp()
{
	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // !!! NOTE: DO NOT PLACE ANY APPLICATION INITIALIZATIONS HERE IN THE APP's
    // CONSTRUCTOR!!! wxWidgets versions subsequent to 2.4.2 call this constructor much
    // earlier than version 2.4.2 and previous versions, and any initializations that
    // involve the wxWidgets library especially cannot be guaranteed to be available for
    // initialization here. Instead, DO ALL INITIALIZATION in the App's OnInit() method.
	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}// end of CAdapt_ItApp constructor

/// **** ALL CLEANUP SHOULD BE DONE IN THE APP'S OnExit() METHOD ****
CAdapt_ItApp::~CAdapt_ItApp()
{
	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // !!! NOTE: DO NOT PLACE ANY APPLICATION CLEANUP CODE HERE IN THE APP's DESTRUCTOR!!!
    // wxWidgets versions subsequent to 2.4.2 call this destructor much later than version
    // 2.4.2 and previous versions, and any cleanup that involve the wxWidgets library
    // especially cannot be guaranteed to work here. Instead, DO ALL CLEANUP in the App's
    // OnExit() method.
	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}

/////////////////////////////////////////////////////////////////////////////////////
/// \return     a pointer to the CMainFrame object
/// \remarks
/// Called from: any part of the source code where we need to obtain a pointer to the
/// application's main frame.
/////////////////////////////////////////////////////////////////////////////////////
CMainFrame* CAdapt_ItApp::GetMainFrame()
{
	wxASSERT(m_pMainFrame != NULL);
    return m_pMainFrame;
}

/*
// whm 14Nov11 Note: This FitWithScrolling() function is now integrated in Julian Smart's
// wxScrollingDialog class which (along with scScrollingWizard) is now used throughout
// Adapt It.
//
// The idea for this function was inspired by a blog by Julian Smart, wxWidgets developer
// at:  http://wxwidgets.blogspot.com/2007/12/programming-for-eee-pc-with-wxwidgets.html
// This is a function to fit the dialog it is called on around the dialog's contents, but
// then it checks that the dialog will fit in a certain maxSize. If not, the size of the
// dialog is adjusted smaller to fit within the maxSize and, if a scrolled window is passed
// in scrolledWindow, scrolling is enabled in the scrolledWindow in the required
// orientation(s). The maxSize would normally be the display size of the computer the
// program is running on, but, it could be a wizard, property sheet, or other dialog which
// contains sub-windows/pages which we want to fit within that wizard, property sheet, or
// other dialog, and make these sub-windows/pages be scrollable if they would otherwise
// exceed the maxSize. The main purpose of this function is to prevent dialogs, wizards,
// property sheets, etc, from ending up with controls off the screen on computers that have
// a small resolution (i.e., 800 x 600 or smaller which is typical of the new generation of
// mini-notebook computers such as the Asus Eee PC, or the Aspire One, Dell Mini 9, etc).
bool CAdapt_ItApp::FitWithScrolling(wxDialog* dialog, wxScrolledWindow* scrolledWindow,
									wxSize maxSize)
{
    wxSizer* sizer = dialog->GetSizer();
    if (!sizer)
        return false;

    sizer->SetSizeHints(dialog);

    wxSize windowSize = dialog->GetSize();

    // Allow for caption size on wxWidgets < 2.9
#if defined(__WXGTK__) && !wxCHECK_VERSION(2,9,0)
    int allowExtraHeight = 30;
#else
    int allowExtraHeight = 0;
#endif
    int scrollBarSize = 20;

    // whm Note: The wxDisplay class can be used to determine the sizes and locations of
    // displays connected to the system.
    // The GetFromWindow() method "Returns the index of the display on which the given
    // window lies. If the window is on more than one display it gets the display that
    // overlaps the window the most.
	// Returns wxNOT_FOUND if the window is not on any connected display."
    // The GetClientArea() method "Returns [as a wxRect] the client area of the display.
    // The client area is the part of the display available for the normal (non full
    // screen) windows, usually it is the same as GetGeometry but it could be less if there
    // is a taskbar (or equivalent) on this display."
    // The GetSize() is a method of wxRect that returns a size for the display (from the
    // rect returned by GetClientArea()).

    //wxSize displaySize =
    //wxDisplay(wxDisplay::GetFromWindow(dialog)).GetClientArea().GetSize();
    wxSize displaySize = maxSize;

    bool resizeVertically = (windowSize.y >= (displaySize.y - allowExtraHeight));
    bool resizeHorizontally = (windowSize.x >= displaySize.x);

    if (resizeVertically || resizeHorizontally)
    {
        int scrollBarExtraX = 0, scrollBarExtraY = 0;

        if (scrolledWindow)
        {
            // Allow extra for a scrollbar, assuming we resizing in one direction only.
            if ((resizeVertically && !resizeHorizontally) &&
					(windowSize.x < (displaySize.x - scrollBarSize)))
                scrollBarExtraX = scrollBarSize;
            if ((resizeHorizontally && !resizeVertically) &&
					(windowSize.y < (displaySize.y - scrollBarSize)))
                scrollBarExtraY = scrollBarSize;

            scrolledWindow->SetScrollRate(resizeHorizontally ?
											10 : 0, resizeVertically ? 10 : 0);
        }

        wxSize limitTo = windowSize + wxSize(scrollBarExtraX, scrollBarExtraY);
        if (resizeVertically)
            limitTo.y = displaySize.y - allowExtraHeight;
        if (resizeHorizontally)
            limitTo.x = displaySize.x;

        dialog->SetMinSize(limitTo);
        dialog->SetSize(limitTo);

        dialog->SetSizeHints( limitTo.x, limitTo.y, dialog->GetMaxWidth(),
								dialog->GetMaxHeight() );
    }

    return true;
}
*/

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the path to the directory which contains all of
///             the localization subdirectories (es, fr, in, ru, zh_TW, etc) which
///             contain .mo files
/// \remarks
/// Called from: the App's ChooseInterfaceLanguage().
/// Gets the path from which we expect to find the 2-letter ("xx") or 5-letter ("xx_XX")
/// subdirectories that contain localization .mo files for Adapt It and/or the wxWidgets
/// library strings. If the directory cannot be determined, or there are no subdirectories
/// of the expected form containing at least one localization .mo file, an empty string is
/// returned.
/////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetDefaultPathForLocalizationSubDirectories()
{
	// According to the wx docs:
	// Adapt It looks for its possible interface translations (localizations)
	// at the following locations, depending on the OS:
	//
	// - On Windows, there appears to be no well established location for localization files.
	// For example I looked at two wxWidgets based applications Poedit and Audacity.
	// The Poedit program places its localization files in:
	// "C:\Program Files\Poedit\share\locale\<lang>\LC_MESSAGES\"
	// The Audacity program uses a simpler method, putting its localization files in:
	// C:\Program Files\Audacity\Languages\<lang>.
	// For Windows at least, I like the simplified way that Audacity does it. So, we add a
	// "Languages" subdirectory so that the localization subdirectories and files will
	// be installed at:  "C:\Program Files\Adapt It WX\Languages\" or
	// "C:\Program Files\Adapt It WX Unicode\Languages\" and Adapt It on the Windows port
	// will look there.
	//
    // - On Unix, the localization files are installed in "<prefix>/share/locale" so Adapt
    // It looks for localization <lang> subfolders and files in the /usr/share/locale/
    // subdirectory. The <lang> subfolders have an additional LC_MESSAGES subfolder which
    // contains the adaptit.mo files.
	//
    // - On Mac OS X, localization files are installed in the
    // "<appname>.app/Contents/Resources/locale" bundle subdirectory, so Adapt It looks for
    // localization <lang> subfolders and files in the
    // AdaptIt.app/Contents/Resources/locale bundle subdirectory. The <lang> subfolders
    // also have an additional LC_MESSAGES subfolder which contains the AdaptIt.mo files.
    // In all cases, the <lang> subdirectory is named with the two (or five) letter short
    // canonical name of the language from the old ISO639 standard. Within these individual
    // <lang> subdirectories, the localization translations are contained in a compiled
    // <appname>.mo file. Additionally there should be a wxWidgets library file called
    // wxstd.mo in the directory if that language has also been localized for the wxWidgets
    // library itself.
	//
//	// !!! testing only below
//#if wxCHECK_VERSION(2, 7, 0)
//	wxString resourcesDir,localizedResourcesDir;
//	wxString dataDir, localDataDir, documentsDir;
//	wxString userConfigDir, userDataDir, userLocalDataDir;
//	wxString executablePath;
//#ifndef __WXMSW__
//	wxString installPrefix;
//#endif
//	wxStandardPaths stdPaths;
//	resourcesDir = stdPaths.GetResourcesDir(); // GetResourcesDir() is new with wxWidgets 2.7.0
//	wxLogDebug(_T("The wxStandardPaths::GetResourcesDir()  = %s"),resourcesDir.c_str());
//	localizedResourcesDir = stdPaths.GetLocalizedResourcesDir(_T("es")); // GetLocalizedResourcesDir() is new with wxWidgets 2.7.0
//	wxLogDebug(_T("The wxStandardPaths::GetLocalizedResourcesDir(_T(\"es\")) = %s"),localizedResourcesDir.c_str());
//	dataDir = stdPaths.GetDataDir();
//	wxLogDebug(_T("The wxStandardPaths::GetDataDir() = %s"),dataDir.c_str());
//	localDataDir = stdPaths.GetLocalDataDir();
//	wxLogDebug(_T("The wxStandardPaths::GetLocalDataDir() = %s"),localDataDir.c_str());
//	documentsDir = stdPaths.GetDocumentsDir();
//	wxLogDebug(_T("The wxStandardPaths::GetDocumentsDir() = %s"),documentsDir.c_str());
//	userConfigDir = stdPaths.GetUserConfigDir();
//	wxLogDebug(_T("The wxStandardPaths::GetUserConfigDir() = %s"),userConfigDir.c_str());
//	userDataDir = stdPaths.GetUserDataDir();
//	wxLogDebug(_T("The wxStandardPaths::GetUserDataDir() = %s"),userDataDir.c_str());
//	userLocalDataDir = stdPaths.GetUserLocalDataDir();
//	wxLogDebug(_T("The wxStandardPaths::GetUserLocalDataDir() = %s"),userLocalDataDir.c_str());
//	executablePath = stdPaths.GetExecutablePath();
//	wxLogDebug(_T("The wxStandardPaths::GetExecutablePath() = %s"),executablePath.c_str());
//#ifndef __WXMSW__
//	installPrefix = stdPaths.GetInstallPrefix();
//	wxLogDebug(_T("The wxStandardPaths::GetInstallPrefix() = %s"),installPrefix.c_str());
//#endif
//#endif // #if wxCHECK_VERSION(2, 7, 0)
    // Test results: The wxStandardPaths::GetLocalizedResourcesDir() function returns the
    // folder we want on each platform. Note: for Debug builds, the
    // GetLocalizedResourcesDir() actually returns the parent directory of the directory in
    // which the application actually exists (on Windows at least).

    // The global m_executingAppPathName contains the application name, but I only need the
    // executable name part so I'll use the built-in wxApp function GetAppName() instead.
	wxString appName;
	appName = GetAppName();

    // Determine the path to the localization subdirectory where any localization
    // subdirectories would be located.
    // Note: Our function FindAppPath() determined the most likely path where the Adapt It
    // executable program is located and stored that path in m_appInstallPathOnly.
	wxString localizationFilePath;
	wxString pathToLocalizationFolders;
#ifdef __WXMAC__
	// On the Mac appName is "Adapt It"
	// Set a suitable default localizationFilePath for the Mac.
	//
	// Make path to the Resources folder be a combination of the path to the executable modified by
	// the relative path from the executable to the Resources/locale folder. The path to the executable
	// during UnicodeDebug on my MacBook is this:
	// "/Users/wmartin/subversion/adaptit/bin/mac/build/UnicodeDebug/Adapt It.app/Contents/MacOS/Adapt It"
	// where the last "Adapt It" represents the actual executable file's name. From the MacOS folder (where
	// the executable resides) to the Resources folder requires the path augmented by:
	// "/../Resources/locale". The combined path to find the help file would then be:
	// "/Users/wmartin/subversion/adaptit/bin/mac/build/UnicodeDebug/Adapt It.app/Contents/MacOS/Adapt
	// It/../Resources/locale" which is programmatically represented by:
	localizationFilePath = m_appInstallPathOnly + _T("/../Resources/locale"); // the path separator is added by the caller
	//wxFileName fn(localizationFilePath);
	//localizationFilePath = fn.Normalize();
	pathToLocalizationFolders = localizationFilePath;
#endif

#ifdef __WXGTK__
	// On Linux appName is "adaptit"
	// Set a suitable default localizationFilePath for Linux.
	// There does not appear to be a wxStandardPaths method which gives us the path for locating the
	// <lang> localization subdirectories so we'll just hard code it for Ubuntu Linux.
	// Note: The actual full path and name for a given <lang> is "/usr/share/locale/<lang>/LC_MESSAGES/adaptit.mo"
	// or "/usr/local/share/locale/<lang>/LC_MESSAGES/adaptit.mo" depending on the value of m_PathPrefix
	localizationFilePath = m_PathPrefix + _T("/share/locale");
	pathToLocalizationFolders = localizationFilePath;
#endif //__WXGTK__

#ifdef __WXMSW__
	// Windows uses the m_appInstallPathOnly
	localizationFilePath = m_appInstallPathOnly; //m_setupFolder;
	if (wxDir::Exists(localizationFilePath + PathSeparator + _T("Languages")))
	{
		pathToLocalizationFolders = localizationFilePath + PathSeparator + _T("Languages");
	}
	else
	{
		pathToLocalizationFolders = localizationFilePath;
	}
#endif
	wxLogDebug(_T("pathToLocalizationFolders = %s"),pathToLocalizationFolders.c_str());
	wxFileName fn(pathToLocalizationFolders);
	fn.Normalize();
	return pathToLocalizationFolders;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the path to the directory which contains the XML
///             control files AI_USFM.xml and books.xml
/// \remarks
/// Called from: the App's OnInit();
/// Gets the path where we expect to find the AI_USFM.xml, AI_UserProfiles.xml, books.xml,
/// curl-ca-bundle.ctr, and iso639-1codes.txt files. Adapt It reads and parses the xml
/// files at startup and accessed the other files for certain features in the app.
/// If the directory cannot be determined an empty string is returned.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetDefaultPathForXMLControlFiles()
{
	// Adapt It looks for its possible interface translations (localizations)
	// at the following locations, depending on the OS:
	// - On Windows, there appears to be no well established location for XML control files.
	// For Windows these XML files will be installed together with the executable program at:
	// "C:\Program Files\Adapt It WX\ or C:\Program Files\Adapt It WX Unicode\"
	// and Adapt It on the Windows port will look there.
	// On Linux: "/usr/share/adaptit/" or "/usr/local/share/adaptit/" depending on the
	//           value of m_PathPrefix [adaptit here is the name of a directory]
	// - On Mac OS X, localization files are installed in the "<appname>.app/Contents/Resources"
	// bundle subdirectory, so Adapt It on the Mac looks for them there.
	//
	// Note: the wxStandardPaths::GetDataDir() could possibly be used for determining this path
	// but, since I'm not sure if it existed before version 2.7.0 of the wxWidgets library, I'll
	// hard code the paths we expect here.

	wxString appName;
	appName = GetAppName();

	wxString pathToXMLFolders;
#ifdef __WXMAC__
	// On the Mac appName is "Adapt It"
	// Set a suitable default path for the xml files on the Mac.
	pathToXMLFolders += m_appInstallPathOnly;
	pathToXMLFolders += _T("/../Resources"); // the path separator is added by the caller
#endif

#ifdef __WXGTK__
	// On Linux appName is "adaptit"
	// Set a suitable default path for the xml files on Ubuntu Linux.
	pathToXMLFolders = m_PathPrefix + _T("/share/adaptit");
#endif //__WXGTK__

#ifdef __WXMSW__
	// Windows uses the m_appInstallPathOnly, the same place the program file is installed
	pathToXMLFolders = m_appInstallPathOnly;
#endif
	wxLogDebug(_T("pathToXMLFolders = %s"),pathToXMLFolders.c_str());
	wxFileName fn(pathToXMLFolders);
	fn.Normalize();
	return pathToXMLFolders;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the path to the directory which contains the HTML Help
///             files for the appropriate platform
/// \remarks
/// Called from: the App's OnInit();
/// Gets the path where we expect to find the HTML Help files.
/// If the directory cannot be determined an empty string is returned.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetDefaultPathForHelpFiles()
{
	// Adapt It looks for its HTML Help files at the following locations, depending on the OS:
	//
	// - On Windows, there appears to be no well established location for HTML Help files.
	// For Windows the Html Help files will be installed together with the executable program at:
	// "C:\Program Files\Adapt It WX\ or C:\Program Files\Adapt It WX Unicode\"
	// and Adapt It on the Windows port will look there.
	//
	// - On Unix, the Html Help files are installed in "/usr/share/adaptit/help/"
	// or "/usr/local/share/adaptit/help/" which in turn may contain a "common/"
	// subdirectory with .gif and .css files (pointed to by the help files).
	// The .../help/ subdirectory may also contain one or more <lang>/ folders which contain the
	// .html .hhp .hhc help files for Adapt It.
	//
	// - On Mac OS X, Html Help files are installed in the "AdaptIt.app/Contents/SharedSupport/"
	// folder of the bundle subdirectory.
	//
	// Note: the wxStandardPaths class apparently doesn't have a method for locating the help files
	// on the various ports.

	wxString appName;
	appName = GetAppName();
	m_htbHelpFileName = appName + _T(".htb");

	wxString pathToHtmlHelpFiles;
#ifdef __WXMAC__
	// On the Mac appName is "Adapt It"
	// Set a suitable default path for the Html Help files on the Mac.
	//pathToHtmlHelpFiles += appName + _T(".app/Contents/SharedSupport"); // the path separator is added by the caller
	//
	// whm modified 17Feb09 to determine the help file path as a relative adjustment to the absolute
	// path to the actual executable that is running.
	//
	// On the Mac, the .htb help file is in the dmg bundle in a different part of the directory tree from
	// the Adapt It executable. The executable is in <bundle>/Contents/MacOS/ folder but the .htb help file
	// is in the <bundle>/Contents/SharedSupport/ folder. The relative help path from executable to
	// help file then is: "../SharedSupport". The double dot backs up the tree from the MacOS folder to
	// the Contents folder, and then goes into the SharedSupport folder.
	//
	// Make path to the SharedSupport folder be a combination of the path to the executable modified by
	// the relative path from the executable to the SharedSupport folder. The path to the executable
	// during UnicodeDebug on my MacBook is this:
	// "/Users/wmartin/subversion/adaptit/bin/mac/build/UnicodeDebug/Adapt It.app/Contents/MacOS/Adapt It"
	// where the last "Adapt It" represents the actual executable file's name. From the MacOS folder (where
	// the executable resides) to the SharedSupport folder requires the path augmented by:
	// "/../SharedSupport". The combined path to find the help file would then be:
	// "/Users/wmartin/subversion/adaptit/bin/mac/build/UnicodeDebug/Adapt It.app/Contents/MacOS/Adapt
	// It/../SharedSupport" which is programmatically represented by:
	pathToHtmlHelpFiles = m_appInstallPathOnly + _T("/../SharedSupport"); // the path separator is added by the caller
	//wxFileName fn(pathToHtmlHelpFiles);
	//pathToHtmlHelpFiles = fn.Normalize();
#endif

#ifdef __WXGTK__
	// On Linux appName is "adaptit"
	// Set a suitable default path for the Html Help files on Ubuntu Linux.
	pathToHtmlHelpFiles = m_PathPrefix + _T("/share/adaptit/help"); // the path separator is added by the caller
#endif //__WXGTK__

#ifdef __WXMSW__
	// Windows uses the m_appInstallPathOnly, the same place the program file is installed
	pathToHtmlHelpFiles = m_appInstallPathOnly;
#endif
	wxLogDebug(_T("pathToHtmlHelpFiles = %s m_htbHelpFileName = %s"),pathToHtmlHelpFiles.c_str(),m_htbHelpFileName.c_str());
	wxFileName fn(pathToHtmlHelpFiles);
	fn.Normalize();
	return pathToHtmlHelpFiles;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      initialPath  -> the path where subdirectories are expected/gathered
///                             into arrayStr
/// \param      arrayStr     <- wxArrayString to receive the list of subdirectories
/// \remarks
/// Called from: the App's PathHas_mo_LocalizationFile() and
/// CChooseLanguageDlg::InitDialog(). Gets a list in the form of a wxStringArray of the
/// subdirectories that exist in the initialPath directory. GetListOfSubDirectories does
/// not empty arrayStr before adding directories to the array, so it is up to the caller to
/// empty the array if needed. If no subdirectories are found arrayStr will not be changed.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetListOfSubDirectories(const wxString initialPath, wxArrayString &arrayStr)
{
	if (initialPath.IsEmpty())
		return;
	wxString filename,saveDir;
	saveDir = ::wxGetCwd();
	::wxSetWorkingDirectory(initialPath);
	wxDir dir(initialPath);

	//wxLogNull logNo;	// eliminates any spurious messages from the system while reading read-only folders/files
	wxASSERT(dir.IsOpened());
	bool bGotOne = dir.Open(initialPath) && dir.GetFirst(&filename, _T(""), wxDIR_DIRS); // wxDIR_DIRS gets only directories
	//wxLogDebug(_T("List of subDirs:"));
	while (bGotOne)
	{
		//wxLogDebug(_T("%s"), filename.c_str());
		arrayStr.Add(filename);
		bGotOne = dir.GetNext(&filename);
	}
	// restore the previous cwd
	::wxSetWorkingDirectory(saveDir);
	// end of scope for wxLogNull
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxLanguage value if a language value for fullLangName could be found
///             otherwise wxLANGUAGE_UNKNOWN
/// \param      fullLangName  ->    a wxString representing the common language name
///                                 (Description)
/// \remarks
/// Called from: the App's ChooseInterfaceLanguage().
/// Attempts to get the wxLanguage value represented by the incoming fullLangName value. It
/// first searches the langsKnownToWX[] array comparing the langsKnownToWX[].name
/// (Description) with fullLangName. If it finds a name (Description) matching fullLangName
/// it returns its wxLanguage value. Since the string values coming in fullLangName were
/// derived originally from
////////////////////////////////////////////////////////////////////////////////////////
wxLanguage CAdapt_ItApp::GetLanguageFromFullLangName(const wxString fullLangName)
{
    // Scan through the langsKnownToWX[] array of LangInfo structs for the full language
    // name as found in langsKnownToWX[].fullName. If found return the corresponding
    // langsKnownToWX[].code.
	int ct = 0;
	while (langsKnownToWX[ct].fullName != NULL)
	{
		if (langsKnownToWX[ct].fullName == fullLangName)
		{
			// we've found the shortName in our langsKnownToWX[] array, so return its
			// langsKnownToWX[].code
			return langsKnownToWX[ct].code;
		}
		ct++;
	}
    // If we get here we've searched the whole array and not found dirStr or its prefix in
    // langsKnownToWX[].
	return wxLANGUAGE_UNKNOWN;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxLanguage value if the language value for dirStr could be found
///             otherwise wxLANGUAGE_UNKNOWN
/// \param      dirStr        ->    the wxString representing the short name of the
///                                 localization subdirectory
/// \param      fullLangName  <-    a wxString to receive the full language name
///                                 langsKnownToWX[].fullName
/// \remarks
/// Called from: the App's ChooseInterfaceLanguage().
/// Attempts to get the wxLanguage value represented by the incoming dirStr value. It first
/// searches the langsKnownToWX[] array comparing the langsKnownToWX[].shortName with
/// dirStr. If it finds a matching shortName matching dirStr it returns its wxLanguage
/// value and sets the fullLangName to the full language name in langsKnownToWX[].fullName.
/// If it does not find a match on the first run, it checks to see if shortName is of the
/// xx_XX form. If so, it strips off the _XX part of the string and uses just the initial
/// xx part of the canonical short name for comparison with dirStr. If it finds a match for
/// the basic language xx part, we consider that to be an acceptable substitute
/// localization.
/////////////////////////////////////////////////////////////////////////////////////////
wxLanguage CAdapt_ItApp::GetLanguageFromDirStr(const wxString dirStr, wxString &fullLangName)
{
	// Scan through the langsKnownToWX[] array of LangInfo structs for the dirStr
	int ct = 0;
	while (langsKnownToWX[ct].fullName != NULL)
	{
		if (langsKnownToWX[ct].shortName == dirStr)
		{
            // we've found the shortName in our langsKnownToWX[] array, so assign
            // fullLangName the string value in langsKnownToWX[ct].fullName
			fullLangName = langsKnownToWX[ct].fullName;
			return langsKnownToWX[ct].code;
		}
		ct++;
	}

    // It may be that dirStr is of the form xx_XX and we might recognize the language, but
    // not the country/region XX. Such a localization would likely be acceptable or at
    // least better than none. So, in case dirStr is of the form xx_XX we search the
    // langsKnownToWX[] array again looking for just the xx part.
	ct = 0;
	while (langsKnownToWX[ct].fullName != NULL)
	{
		wxString str;
		str = langsKnownToWX[ct].shortName;
		if (str.Length() > 2 && str.GetChar(2) == _T('_'))
		{
			str = str.Mid(0,2);
		}
		if (str == dirStr)
		{
            // we've found the xx part of our shortName in our langsKnownToWX[] array, so
            // assign fullLangName the string value in langsKnownToWX[ct].fullName
			fullLangName = langsKnownToWX[ct].fullName;
			return langsKnownToWX[ct].code;
		}
		ct++;
	}
	// If we get here we've searched the whole array and not found dirStr or its prefix
	// in langsKnownToWX[].
	return wxLANGUAGE_UNKNOWN;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the dirPath represents a subdirectory containing a child or grandchild
///             localization directory(s) which contain an <appName>.mo file
/// \param      dirPath         -> the path to look for the <lang> localization subfolder
/// \param      subFolderName = -> the name of a specific subfolder to contain <appName>.mo
/// \remarks
/// Called from: the App's LocalizationFilesExist()
/// Determines if dirPath has one or more child or grandchild subfolders which contain an
/// <appName>.mo file.
/// The incoming dirPath would normally be the a path pointing to the "Languages" directory
/// (on Windows); or the /usr/share/locale/ directory on Linux; or
/// /<appName>.app/Contents/Resources directory on the Mac. These directory locations should
/// contain at least one localization <lang> subfolder containing an <appName>.mo file. If
/// subFolderName is not a null string, this function will only return TRUE if a subfolder
/// exists at dirPath with the subFolderName. If subFolderName is a null string the
/// function does not check the names of the localization subfolders, but only checks to
/// see if an <appName>.mo file can be found in at least one such subfolder.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::PathHas_mo_LocalizationFile(wxString dirPath, wxString subFolderName)
{
	if (dirPath.IsEmpty())
		return FALSE;

	wxString appName;
	appName = GetAppName();

	wxArrayString subDirList;
	subDirList.Clear();
	GetListOfSubDirectories(dirPath,subDirList);

	wxLogNull logNo;	// eliminates any spurious messages from the system while
						// reading read-only folders/files

	int ct;
	for (ct = 0; ct < (int)subDirList.GetCount(); ct++)
	{
		bool bNamesMatch = TRUE; // assume match unless subFolderName parameter
								 // has a non-null string
		bool bHasRegionCode = FALSE;
		if (!subFolderName.IsEmpty())
		{
			wxString subDir = subDirList.Item(ct);
			if (subDir.Length() > 2 && subDir[2] == _T('_') && subDir.Length() >= 5)
				bHasRegionCode = TRUE;
			wxString subFldr = subFolderName;
#ifdef __WXMSW__
			subDir.MakeLower();
			subFldr.MakeLower();
#endif
			if (bHasRegionCode && subFldr.Mid(0,2) != subDir.Mid(0,2))
			{
				bNamesMatch = FALSE;
			}
			else if (subFldr != subDir)
			{
				bNamesMatch = FALSE;
			}
		}

		dirPath = dirPath + PathSeparator + subDirList.Item(ct);
        // check for existence of "LC_MESSAGES" subfolder within dirPath, and if it exists,
        // search within it
		if (wxDir::Exists(dirPath + PathSeparator + _T("LC_MESSAGES")))
			dirPath = dirPath + PathSeparator + _T("LC_MESSAGES");
		wxDir dPath(dirPath);
		// whm Note: with wxDir we must call .Open() before enumerating files or calling
		// IsOpen()! Otherwise it asserts on wxGTK!
		if (dPath.Open(dirPath) && bNamesMatch && dPath.HasFiles(_T("*.mo")) &&
			dPath.HasFiles(appName + _T(".mo")))
		{
			return TRUE;
		}
	}
	// if we make it here none were found
	// end of scope for wxLogNull
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if locale and localizations were successfully created,
///             otherwise FALSE
/// \param      shortLangName -> the short (Canonical) name of the language/locale
/// \param      longLangName  -> the long (Description) name of the language/locale
/// \param      pathPrefix    -> the path prefix where localization subfolders
///                              and files are found
/// \remarks
/// Called from: the App's OnInit() and CChooseLanguageDlg::OnOK(). Deletes any existing
/// wxLocale object and creates a new one on the heap assigned to m_pLocale. Adds the
/// pathPrefix to the new locale and calls AddCatalog to load any new localization.
////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::InitializeLanguageLocale(wxString shortLangName, wxString longLangName,
											wxString pathPrefix)
{
	// delete any existing locale object
	if (m_pLocale)
		delete m_pLocale;

	bool bLoadOK = TRUE;
	wxLogNull nolog; // avoid spurious messages from the system
	m_pLocale = new wxLocale(longLangName, shortLangName, _T(""), TRUE, TRUE);
	if (!pathPrefix.IsEmpty())
		m_pLocale->AddCatalogLookupPathPrefix(pathPrefix);
	if (!m_pLocale->AddCatalog(GetAppName()))
	{
		bLoadOK = FALSE;
	}
	if (shortLangName.Find(_T("en_")) == 0 // we have shortLangName with
										   // en_ at the start of the name
		|| (shortLangName.Length() == 2 && shortLangName == _T("en"))) // or,
										   // we have the two-letter name en
	{
        // For our default English locale we don't need a loaded string catalog table, we
        // just use the program strings, so don't check m_pLocale->IsLoaded() for English.
		; // do nothing
	}
	else
	{
		// For a non-default non-English localization we can check if the catalog is
		// loaded OK
		if(!m_pLocale->IsLoaded(GetAppName()))
		{
			bLoadOK = FALSE;
		}
	}
	return bLoadOK;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's ProcessUILanguageInfoFromConfig() and ChangeUILanguage(). Stores
/// the user's choice of interface language (using the members of the CurrLocalizationInfo
/// struct) in the global configuration (the Registry on Windows, or a hidden file in the
/// user's folder on Linux/Mac.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SaveCurrentUILanguageInfoToConfig()
{
	// whm 8Dec11 revised to no longer store the ui_language_path_unicode or ui_language_path
	// This function uses the data currently in the global struct currLocalizationInfo

	wxLogNull logNo; // avoid spurious messages from the system

	// save current CurrLocalizationInfo struct's member information in registry/hidden
	// settings file
	wxString oldPath = m_pConfig->GetPath(); // is always absolute path "/Recent_File_List"
	m_pConfig->SetPath(_T("/Settings"));
	m_pConfig->Write(_T("ui_language"), (long)currLocalizationInfo.curr_UI_Language);
    m_pConfig->Write(_T("ui_language_code"), currLocalizationInfo.curr_shortName);
    m_pConfig->Write(_T("ui_language_name"), currLocalizationInfo.curr_fullName);
//#ifdef _UNICODE
//    m_pConfig->Write(_T("ui_language_path_unicode"), currLocalizationInfo.curr_localizationPath);
//#else
//    m_pConfig->Write(_T("ui_language_path"), currLocalizationInfo.curr_localizationPath);
//#endif

#ifdef __WXDEBUG__
	wxLogDebug(_T(
"Writing to m_pConfig:\n   curr_UI_Language = %d\n   curr_shortName = %s\n   curr_fullName = %s"), //\n   curr_localizationPath = %s"),
		currLocalizationInfo.curr_UI_Language,
		currLocalizationInfo.curr_shortName.c_str(),
		currLocalizationInfo.curr_fullName.c_str()); //,
		//currLocalizationInfo.curr_localizationPath.c_str());
#endif
	m_pConfig->Flush(); // write now, otherwise write takes place when m_p is destroyed in OnExit().
	// restore the oldPath back to "/Recent_File_List"
	m_pConfig->SetPath(oldPath);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: CChooseLanguageDlg::OnOK(). Stores a user defined interface language in
/// the global configuration (the Registry on Windows, or a hidden file in the user's
/// folder on Linux/Mac. User defined languages may be stored in registry/hidden settings
/// keys of the form user_defined_language_n, where n may be an integer from 0 through 8.
/// This function uses the incoming parameter data to create a composite unix-like string
/// delimited by colons (:), and saves this composit string to one of 9 keys in the
/// Registry or hidden settings file. Up to 9 user defined languages can be remembered in
/// this way, using keys with names such as user_defined_language_0,
/// user_defined_language_1, and so on up through user_defined_language_8. This function
/// first checks to see if the incoming user defined language was previously saved in one
/// of the user_defined_language_n keys. If the incoming language is not
/// already stored, the first available key that has not yet been assigned a string is
/// used. If all keys are currently filled with user defined language info, the oldest
/// string is replaced by the new language composite string.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SaveUserDefinedLanguageInfoStringToConfig(int &wxLangCode,
		const wxString shortName, const wxString fullName, const wxString localizationPath)
{
	// A composite unix string for a user defined language such as Tok Pisin might look like
	// this: 231:tpi:Tok Pisin
	// The 3 fields of the unix string are parsed using the : delimiter.

	wxString oldPath = m_pConfig->GetPath(); // is always absolute path "/Recent_File_List"
	m_pConfig->SetPath(_T("/Settings"));

    // Take stock of the user_defined_language_n entry keys the the registry/hidden
    // settings file. The keyArray[] array will contain what is stored there.
	int ct;
	const int nKeys = 9;
	wxArrayString keyArray;
	keyArray.Alloc(9);
	wxArrayString foundCodesArray;
	bool bKeysPresent = FALSE;
	bool bAllKeysAssigned = FALSE;
	for (ct = 0; ct < nKeys; ct++)
	{
		wxLogNull logNo; // eliminates spurious message from the system: "Can't read value of
			// key 'HKCU\Software\Adapt_It_WX\Settings' Error" [valid until end of this block]
		wxString str;
#ifdef _UNICODE
		str << _T("user_defined_language_u_") << ct;
#else
		str << _T("user_defined_language_") << ct;
#endif
		bool valReadOK = TRUE;
		wxString tempStr;
		valReadOK = m_pConfig->Read(str, &tempStr);
		keyArray.Add(tempStr);
		if (valReadOK && keyArray[ct] == _T("[UNASSIGNED]"))
		{
			bAllKeysAssigned = FALSE;
		}
		if (valReadOK && keyArray[ct] != _T("[UNASSIGNED]"))
		{
			bKeysPresent = TRUE;
			int pos;
			pos = keyArray[ct].Find(_T(':'));
			wxASSERT(pos > 0 && pos <= 3);	// the language code number should represented
											// as a three letter string between 231 and 255
			wxString codeStr = keyArray[ct].Left(pos);
			foundCodesArray.Add(codeStr);
		}
		if (!valReadOK)
		{
			keyArray[ct] = _T("[UNASSIGNED]");	// assign "[UNASSIGNED]" string to any
										// keyArray element for which there is no key
		}
		// end of wxLogNull logNo scope
	}

    // Note: our keyArray[] at this point should always contain exactly 9 items regardless
    // of whether some or all of the keys were present when
    // SaveUserDefinedLanguageInfoStringToConfig() was called.

    // Sort the array. Since the wxLanguage number (as string) is first in compositeStr, we
    // sort the array so that unassigned keys are moved to the end where we want them.
	//keyArray.Sort();  // sorts the array in ascending order (the unassigned keys get
						// sorted to the end of the list)

    // Check whether the language represented by our compositeStr has been assigned
    // previously; we don't want to store duplicate user languages, but we do want to
    // update the path part of the string if the user language already exists with a
    // different path.
	// Make a search string of just the shortName and fullName including the
	// surrounding colons.
	int nCodeAssigned = -1;
	wxString subStr;
	subStr << _T(':') << shortName << _T(':') << fullName << _T(':'); // for Tok Pisin
													// this would be ":tpi:Tok Pisin:"
	bool bAlreadyAssigned = FALSE;
	for (ct = 0; ct < nKeys; ct++)
	{
		if (keyArray[ct].Find(subStr) != -1)
		{
			bAlreadyAssigned = TRUE;
			int pos;
			pos = keyArray[ct].Find(_T(':'));
			wxASSERT(pos > 0 && pos <= 3); // the language code number should
					// represented as a three letter string between 231 and 255
			wxString codeStr = keyArray[ct].Left(pos);
			nCodeAssigned = wxAtoi(codeStr);
			// Update the path part (it may have been changed by the user).
			wxString tempStr = keyArray[ct];
			int posPath = pos + subStr.Length();
			tempStr = tempStr.Left(posPath);
			tempStr = tempStr + localizationPath; // use the incoming (possibly
												  // updated) path
			keyArray[ct] = tempStr; // update the keyArray item
			break;
		}
	}

	if (nCodeAssigned == -1)
	{
        // This language code was not assigned previously. If other user defined languages
        // were previously assigned, we assign this one the next available number in the
        // sequence. If no other user defined languages were previously assigned, we start
        // with wxLANGUAGE_USER_DEFINED + 1.
		if (bAllKeysAssigned)
		{
            // All 9 available user_defined_language_n keys have been previously assigned,
            // so we remove the oldest by copying keyArray[1] to keyArray[0], keyArray[2]
            // to keyArray[1], etc., all the way through keyArray[9] copied to keyArray[8].
            // Then we assign make this newest key "[UNASSIGNED]" so that it will get
            // assigned the current language in the routine below (where it will get
            // assigned the next numerical value of 240). This would ordinarily leave the
            // numerical ordering 232 through 240. At the next running of the application
            // the App's OnInit() calls ProcessUILanguageInfoFromConfig() which will detect
            // this situation and will renumber the user defined languages before calling
            // AddLangauge() to add them to the wxLanguage database.
			for (ct = 0; ct < nKeys - 1; ct++)
			{
				keyArray[ct] = keyArray[ct + 1];
			}
			keyArray[nKeys] = _T("[UNASSIGNED]");
			int nCount = (int)foundCodesArray.GetCount();
			wxASSERT(nCount > 0);
			foundCodesArray.Sort();
			wxString highestCodeStr = foundCodesArray[nCount - 1];
			nCodeAssigned = wxAtoi(highestCodeStr) + 1; // get the next number beyond the
														// value for highestCodeStr
			//nCodeAssigned = wxLANGUAGE_USER_DEFINED + 1 + nKeys; // should be 240
		}
		else if (bKeysPresent)
		{
			// should be at least one slot available
			int nCount = (int)foundCodesArray.GetCount();
			wxASSERT(nCount > 0);
			foundCodesArray.Sort();
			wxString highestCodeStr = foundCodesArray[nCount - 1];
			nCodeAssigned = wxAtoi(highestCodeStr) + 1; // get the next number beyond
														// the value for highestCodeStr
		}
		else
		{
			nCodeAssigned = wxLANGUAGE_USER_DEFINED + 1;
		}
	}
	wxASSERT(nCodeAssigned >= wxLANGUAGE_USER_DEFINED+1 && nCodeAssigned <= 255);
	wxLangCode = nCodeAssigned;

	// Assign this language, but only if it has not already been assigned.
	if (!bAlreadyAssigned)
	{
		// Make a composite unix-like string from the parameters
		wxString compositeStr;
		compositeStr << wxLangCode << _T(':') << shortName << _T(':') << fullName
					<< _T(':'); // << localizationPath; whm 8Dec11 removed the path part

		// Assign compositeStr to the first empty array element in keyArray[].
		for (ct = 0; ct < nKeys; ct++)
		{
			// if key is unassigned put the compositeStr there
			if (keyArray[ct] == _T("[UNASSIGNED]"))
			{
				keyArray[ct] = compositeStr;
				break;
			}
		}
	}

	// Sort the array again since we may have added or inserted something.
	//keyArray.Sort(); // sorts the array in ascending order (the unassigned keys get
					   //sorted to the end of the list)

 	wxLogNull logNo; // avoid spurious messages from the system

	// Rewrite all 9 keys from keyArray[] back to the registry/hidden settings file. This
    // is done even if we did not add a compositeStr language, but, since we did sort the
    // keyArray[], it may have changed the order.
	int ctkey;
	for (ctkey = 0; ctkey < nKeys; ctkey++)
	{
		wxString str;
#ifdef _UNICODE
		str << _T("user_defined_language_u_") << ctkey;
#else
		str << _T("user_defined_language_") << ctkey;
#endif
		m_pConfig->Write(str, keyArray[ctkey]);
	}

	m_pConfig->Flush(); // write now, otherwise write takes place when m_p is destroyed in OnExit().
	// restore the oldPath back to "/Recent_File_List"
	m_pConfig->SetPath(oldPath);
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: CChooseLanguageDlg::OnOK(). This function searches for a
/// user_defined_language_n key using the incoming parameter data. If the key is found, it
/// effectively removes the key value by making it a null string. We also sort the
/// user_defined_language_n keys and write them back to the registry/hidden settings file
/// so that they are always kept in numerical order.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::RemoveUserDefinedLanguageInfoStringFromConfig(const wxString shortName,
																 const wxString fullName)
{
    // The string key values associated with the user_defined_language_n keys are a
    // composite unix-like string delimited by colons (:). There are 9 keys in the registry
    // or hidden settings file, so up to 9 user defined languages can be remembered there.
    // A composite unix string for a user defined language such as Tok Pisin might look
    // like this: 231:tpi:Tok Pisin:C:\Program Files\Adapt It\Languages
    // The first 3 fields of the unix string are parsed using the : delimiter. The 4th
    // field is assumed to compose all the remaining characters of the localization path,
    // including any colon chars that may exist in the path after the volume label, i.e.,
    // C:\....

    // Read any existing strings associated with user_defined_language_n keys into an array
    // called keyArray[].
	wxString oldPath = m_pConfig->GetPath(); // is always absolute path "/Recent_File_List"
	m_pConfig->SetPath(_T("/Settings"));

	int ct;
	const int nKeys = 9;
	wxArrayString keyArray;
	bool bKeysPresent = FALSE;
	for (ct = 0; ct < nKeys; ct++)
	{
		wxLogNull logNo; // eliminates spurious message from the system:
            // "Can't read value of key 'HKCU\Software\Adapt_It_WX\Settings' Error" [valid
            // until end of this block]
		wxString str;
#ifdef _UNICODE
		str << _T("user_defined_language_u_") << ct;
#else
		str << _T("user_defined_language_") << ct;
#endif
		bool valReadOK = TRUE;
		wxString tempStr;
		valReadOK = m_pConfig->Read(str, &tempStr);
		keyArray.Add(tempStr);
		if (valReadOK && keyArray[ct] != _T("[UNASSIGNED]"))
		{
			bKeysPresent = TRUE;
		}
		if (!valReadOK)
		{
			keyArray[ct] = _T("[UNASSIGNED]");	// assign "[UNASSIGNED]" string to any
										// keyArray element for which there is no key
		}
		// end of wxLogNull logNo scope
	}
    // Note: our keyArray[] at this point should always contain exactly
    // 9 items regardless of whether some or all of the keys were present when
    // SaveUserDefinedLanguageInfoStringToConfig() was called.

	if (!bKeysPresent)
	{
        // there are no user_defined_language_n keys in the registry/hidden settings file,
        // so we have nothing to remove, so we quietly return to the caller.
		return;
	}
	else
	{
		// Scan through our keyArray[] parsing the composite unix-like string elements
		// to find the string key containing the language info that we want to remove.
		// Remove it by assigning the "[UNASSIGNED]" string to the key.
		// Make a search string of just the shortName and fullName including the
		// surrounding colons.
		wxString subStr;
		subStr << _T(':') << shortName << _T(':') << fullName << _T(':'); // for Tok
											// Pisin this would be ":tpi:Tok Pisin:"
		for (ct = 0; ct < nKeys; ct++)
		{
			if (keyArray[ct].Find(subStr) != -1)
			{
				keyArray[ct] = _T("[UNASSIGNED]");
				break;
			}
		}

        // Note: At the next running of the app, OnInit() calls
        // ProcessUILanguageInfoFromConfig() function which reads all the registry/hidden
        // settings file information and cleans it up if necessary, this cleanup includes
        // reordering of wxLanguage values before calling AddLanguage(), and insuring that
        // any [UNASSIGNED] keys are placed last in the list.

		// Sort the keyArray.
        // Sort the array. Since the wxLanguage number (as string) is first in
        // compositeStr, we sort the array so that unassigned keys are moved to the end
        // where we want them.
		//keyArray.Sort(); // sorts the array in ascending order (the unassigned keys
						   // get sorted to the end of the list)

		wxLogNull logNo; // avoid spurious messages from the system

		// Finally, write the 9 keys back to the registry
		for (ct = 0; ct < nKeys; ct++)
		{
			wxString str;
#ifdef _UNICODE
			str << _T("user_defined_language_u_") << ct;
#else
			str << _T("user_defined_language_") << ct;
#endif
			m_pConfig->Write(str, keyArray[ct]);
		}
	}

	m_pConfig->Flush(); // write now, otherwise write takes place when m_p is destroyed in OnExit().
	// restore the oldPath back to "/Recent_File_List"
	m_pConfig->SetPath(oldPath);
}


/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks This function builds the complete content for a new default AI_UserProfiles.xml
/// file including the comment at the beginning of the file. It assumes that the caller has
/// created and opened an empty wxTextFile (the textFile parameter) before calling this
/// function. The caller only calls this function in the unlikely case that no
/// AI_UserProfiles.xml file exists at the fullFilePath location used in calling
/// SaveUserProfilesMergingDataToXMLFile().
/// Called from: SaveUserProfilesMergingDataToXMLFile().
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::BuildUserProfileXMLFile(wxTextFile* textFile)
{
	wxString fileCommentBlock[] =
	{
		_T("<!--"),
		_T("Filename:	AI_UserProfiles.xml"),
		_T("Author: 	Bill Martin"),
		_T("Date Created:	27 August 2010"),
		_T("Last Updated:	24 May 2011, by Bill Martin"),
		_T("Description:	This file contains the user profile definitions and"),
		_T("		attributes for Adapt It's interface menus and settings."),
		_T("		Adapt It reads and parses this AI_UserProfiles.xml file"),
		_T("		when it starts up and when an administrator accesses the"),
		_T("		user workflow profiles dialog. Changes made to"),
		_T("		individual items in that dialog are automatically saved"),
		_T("		back to this file."),
		_T("***********************************************************************"),
		_T("**** DO NOT EDIT THIS FILE - UNLESS YOU KNOW WHAT YOU ARE DOING! ******"),
		_T("**** MAKE CHANGES TO THE USER WORKFLOW PROFILES BY SELECTING THE ******"),
		_T("**** User Workflow Profiles... ITEM ON THE ADMINISTRATOR MENU. ********"),
		_T("**** Manually changing the settings in this file may make Adapt It ****"),
		_T("**** fail or operate incorrectly. If you have edited this file and ****"),
		_T("**** and subsequently Adapt It fails or operates incorrectly, you *****"),
		_T("**** should delete AI_UserProfiles.xml from your Adapt It Work ********"),
		_T("**** folder and reinstall Adapt It. ***********************************"),
		_T("***********************************************************************"),
		_T("  -->"),
	};

	wxString composeXmlStr;
	if (textFile->IsOpened())
	{
		CBString xmlPrologue;
		wxString tab1,tab2,tab3;
		tab1 = _T("\t");
		tab2 = _T("\t\t");
		tab3 = _T("\t\t\t");
		GetEncodingStringForXmlFiles(xmlPrologue); // builds xmlPrologue and adds "\r\n" to it
		composeXmlStr = wxString::FromAscii(xmlPrologue); // first string in xml file
		composeXmlStr.Replace(_T("\r\n"),_T("")); // remove the ending \r\n added by GetEncodingStringForXmlFiles wxTextFile::AddLine adds its own eol
		textFile->AddLine(composeXmlStr);
		int nCommentItems;
		nCommentItems = sizeof(fileCommentBlock)/sizeof(wxString);
		int i;
		for (i = 0; i < nCommentItems; i++)
		{
			textFile->AddLine(fileCommentBlock[i]);
		}
		// now we start building the actual xml part of the file (remainder of file)
		// We use the data stored in m_pUserProfiles
		composeXmlStr.Empty();
		composeXmlStr += _T('<');
		composeXmlStr += wxString::FromAscii(userprofilessupport);
		textFile->AddLine(composeXmlStr);
		composeXmlStr.Empty();
		composeXmlStr = tab1 + wxString::FromAscii(profileVersion);
		wxString verStr = m_pUserProfiles->profileVersion;
		composeXmlStr += _T("=\"") + verStr + _T("\"");
		textFile->AddLine(composeXmlStr);
		composeXmlStr.Empty();

		composeXmlStr = tab1 + wxString::FromAscii(applicationCompatibility);
		wxString appCStr = m_pUserProfiles->applicationCompatibility;
		composeXmlStr += _T("=\"") + appCStr + _T("\"");
		textFile->AddLine(composeXmlStr);
		composeXmlStr.Empty();

		composeXmlStr = tab1 + wxString::FromAscii(adminModified);
		wxString adminModStr = m_pUserProfiles->adminModified;
		// Indicate "Yes" for adminModified if not already set to "Yes"
		if (adminModStr.Find(_T("Yes")) == wxNOT_FOUND)
		{
			int pos = adminModStr.Find(_T("No"));
			wxASSERT(pos != wxNOT_FOUND);
			if (pos != wxNOT_FOUND)
			{
				adminModStr.Remove(pos,2);
				adminModStr.insert(pos,_T("Yes"));
			}
		}
		composeXmlStr += _T("=\"") + adminModStr + _T("\"");
		textFile->AddLine(composeXmlStr);
		composeXmlStr.Empty();

		int ct;
		int tot = m_pUserProfiles->definedProfileNames.GetCount();
		wxString strVal;
		for (ct = 0; ct < tot; ct++)
		{
			strVal.Empty();
			strVal << ct+1;
			composeXmlStr = tab1 + wxString::FromAscii(definedProfile) + strVal + _T("=\"") + m_pUserProfiles->definedProfileNames.Item(ct) + _T("\"");
			textFile->AddLine(composeXmlStr);
			composeXmlStr.Empty();

			// replace any entity chars with their xml entity representations
			wxString str = m_pUserProfiles->descriptionProfileTexts.Item(ct);
			str.Replace(_T("&"),wxString::FromAscii(xml_amp)); // replacing '&' must be done first!
			str.Replace(_T("<"),wxString::FromAscii(xml_lt));
			str.Replace(_T(">"),wxString::FromAscii(xml_gt));
			str.Replace(_T("'"),wxString::FromAscii(xml_apos));
			str.Replace(_T("\""),wxString::FromAscii(xml_quote));
			str.Replace(_T("\t"),wxString::FromAscii(xml_tab)); // whm added 24May11

			composeXmlStr = tab1 + wxString::FromAscii(descriptionProfile) + strVal + _T("=\"") + str + _T("\"");
			textFile->AddLine(composeXmlStr);
		}
		composeXmlStr.Empty();
		composeXmlStr = tab1 + _T('>');
		textFile->AddLine(composeXmlStr);
		// the top level <UserProfilesSupport tag and attributes are done, now loop through the
		// profileItemList and output the data for each item in the list
		ProfileItemList::Node* node;
		UserProfileItem* pItem;
		tot = m_pUserProfiles->profileItemList.GetCount();
		for (ct = 0; ct < tot; ct++)
		{
			node = m_pUserProfiles->profileItemList.Item(ct);
			pItem = node->GetData();
			wxASSERT(pItem != NULL);
			composeXmlStr.Empty();
			composeXmlStr = _T('<') + wxString::FromAscii(menu) + _T(' ') + wxString::FromAscii(itemID) + _T("=\"") + pItem->itemID + _T("\"");
			textFile->AddLine(composeXmlStr);
			composeXmlStr.Empty();
			composeXmlStr = tab1 + wxString::FromAscii(itemType) + _T("=\"") + pItem->itemType + _T("\"");
			textFile->AddLine(composeXmlStr);
			composeXmlStr.Empty();

			// replace any entity chars with their xml entity representations
			wxString str = pItem->itemText;
			str.Replace(_T("&"),wxString::FromAscii(xml_amp)); // replacing '&' must be done first!
			str.Replace(_T("<"),wxString::FromAscii(xml_lt));
			str.Replace(_T(">"),wxString::FromAscii(xml_gt));
			str.Replace(_T("'"),wxString::FromAscii(xml_apos));
			str.Replace(_T("\""),wxString::FromAscii(xml_quote));
			str.Replace(_T("\t"),wxString::FromAscii(xml_tab)); // whm added 24May11

			composeXmlStr = tab1 + wxString::FromAscii(itemText) + _T("=\"") + str + _T("\"");
			textFile->AddLine(composeXmlStr);
			composeXmlStr.Empty();

			// replace any entity chars with their xml entity representations
			str = pItem->itemDescr;
			str.Replace(_T("&"),wxString::FromAscii(xml_amp)); // replacing '&' must be done first!
			str.Replace(_T("<"),wxString::FromAscii(xml_lt));
			str.Replace(_T(">"),wxString::FromAscii(xml_gt));
			str.Replace(_T("'"),wxString::FromAscii(xml_apos));
			str.Replace(_T("\""),wxString::FromAscii(xml_quote));
			str.Replace(_T("\t"),wxString::FromAscii(xml_tab)); // whm added 24May11

			composeXmlStr = tab1 + wxString::FromAscii(itemDescr) + _T("=\"") + str + _T("\"");
			textFile->AddLine(composeXmlStr);
			composeXmlStr.Empty();
			composeXmlStr = tab1 + wxString::FromAscii(itemAdminCanChange) + _T("=\"") + pItem->adminCanChange + _T("\"");
			textFile->AddLine(composeXmlStr);
			composeXmlStr.Empty();
			composeXmlStr = tab1 + _T('>');
			textFile->AddLine(composeXmlStr);
			composeXmlStr.Empty();
			int ct2;
			int tot2 = pItem->usedProfileNames.GetCount();
			for (ct2 = 0; ct2 < tot2; ct2++)
			{
				composeXmlStr = tab2 + _T('<') + wxString::FromAscii(profile) + _T(' ') + wxString::FromAscii(itemUserProfile) + _T("=\"") + pItem->usedProfileNames.Item(ct2) + _T("\"");
				textFile->AddLine(composeXmlStr);
				composeXmlStr.Empty();
				composeXmlStr = tab3 + wxString::FromAscii(itemVisibility) + _T("=\"") + pItem->usedVisibilityValues.Item(ct2) +  _T("\"");
				textFile->AddLine(composeXmlStr);
				composeXmlStr.Empty();
				composeXmlStr = tab3 + wxString::FromAscii(factory) + _T("=\"") + pItem->usedFactoryValues.Item(ct2) +  _T("\"");
				textFile->AddLine(composeXmlStr);
				composeXmlStr.Empty();
				composeXmlStr = tab2 +  _T('>');
				textFile->AddLine(composeXmlStr);
				composeXmlStr.Empty();
				composeXmlStr = tab2 + _T('<') + wxString::FromAscii(end_profile) + _T('>');
				textFile->AddLine(composeXmlStr);
				composeXmlStr.Empty();
			}
			composeXmlStr = _T('<') + wxString::FromAscii(end_menu) + _T('>');
			textFile->AddLine(composeXmlStr);
			composeXmlStr.Empty();
		}
		composeXmlStr.Empty();
		composeXmlStr += _T('<');
		composeXmlStr += wxString::FromAscii(end_userprofilessupport) + _T('>');
		textFile->AddLine(composeXmlStr);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnInit() and OnEditUserMenuSettingsProfiles().
/// This function calls a series of functions that set the visibility of the interface's menus,
/// modeBar, toolBar, wizardListItem and other potential interface settings, all based on the
/// information stored in AI_UserProfiles.xml and the App's m_pAI_MenuStructure member.
/// Note: The MakeMenuInitializationsAndPlatformAdjustments() function should always be called
/// immediately after the ConfigureInterfaceForUserProfile() function.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ConfigureInterfaceForUserProfile()
{
	// We use the menu and settings data in m_pUserProfiles to set visibility of interface
	// elements.
	//
	// First, configure visibility of itemType == subMenu elements
	ConfigureMenuBarForUserProfile();
	// Note: The MakeMenuInitializationsAndPlatformAdjustments() function is called in OnInit()
	// after this ConfigureInterfaceForUserProfile() completes.

	// Next, configure visibility of itemType == modeBar elements
	ConfigureModeBarForUserProfile();

	// Note: Changes in the visibility of itemType == preferencesTab elements
	// are not done here but within the CEditPreferencesDlg dialog class. The
	// tabs are hidden or shown based on the visibility flags in m_pUserProfiles
	// at the time when the Preferences dialog is instantiated.

	// Next, configure visibility of itemType == toolBar element
	ConfigureToolBarForUserProfile();

	// Next, configure visibility of itemType == wizardListItem element
	ConfigureWizardForUserProfile();

	// whm added 7Jan12 There is no "ConfigureStatusBarForUserProfile" but its
	// visibility according to the App's m_bStatusBarVisible needs to be ensured
	// with all the other Configure...ForUserProfile() calls above.
	if (m_bStatusBarVisible)
		m_pMainFrame->m_pStatusBar->Show();
	else
		m_pMainFrame->m_pStatusBar->Hide();

	// Finally, configure visibility of itemType == dialogControl elements
	// AI_UserProfiles.xml currently does not include any dialogControl
	// elements.
	// Other configuration capabilities could go here
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's ConfigureInterfaceForUserProfile().
/// This function reads the UserProfile data stored in the App's m_pUserProfiles member,
/// and sets the visibility of the interface's menus based on the information
/// stored in AI_UserProfiles.xml. It also reads the App's m_pAI_MenuStructure member and
/// uses it to ensure Adapt It's menu structure is restored to a uniform state when
/// changing the user profile or reverting to the "None" default profile.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ConfigureMenuBarForUserProfile()
{
	// whm 27Sep10 notes:
	// I tried calling delete on pMenuBar and reconstructing it from scratch as a way to
	// implement interface menu configuration. But deleting the menu bar (when it has
	// already been "set" into the main frame via the SetMenuBar() function, leads to some
	// memory leaks due to the wxDocManager::FileHistoryLoad() call that is done to load
	// the file history from our m_pConfig.
	// Later, I attempted to try adding menu items one-by-one to individual top level
	// menus and tidying up any menu separators that need to be added or removed for
	// the resulting menu bar. That approach also proved problematic as I could not
	// guarantee robustness of the result. Finally I decided on removing all menu items
	// from a given top level menu, and constructing the menu anew using the
	// m_pAI_Menustructure's itemVisibility info as the guide. That approach gives a
	// robust result that also allows for the insertion of menu separators at the right
	// places to fit the profile. Note: the m_pAI_MenuStructure struct is populated from
	// a temporary default menu bar in the SetupDefaultMenuStructure() function, not
	// from any internal string data, nor from any data in AI_UserProfiles.xml.

	// I don't know how to get the defined int value for an idenfifier from a string
	// representation such as "ID_SAVE_AS", so I'll just create a temporary default
	// menu bar from wxDesigners AIMenuBarFunc() so we can query it for menu id int
	// values we may need. We don't call SetMenuBar() on any frame so it won't be
	// visible. We delete it at the end of the menu bar handling part of this function.
	wxMenuBar* pTempMenuBar;
	pTempMenuBar = AIMenuBarFunc();

	// Go through the existing top level menus processing each one by removing existing
	// items and adding those that need to be visible for the current profile.
	wxString mainMenuLabel_DefaultStructure;
	wxString mainMenuLabel_CurrentMenuBar;
	MainMenuItemList::Node* mmNode;
	AI_MainMenuItem* pMainMenuItem_DefaultStructure;
	wxMenu* pMainMenuItem_CurrentMenuBar;
	wxMenuBar* pMenuBar_Current = GetMainFrame()->GetMenuBar();
	wxASSERT(pMenuBar_Current != NULL);
	pMenuBar_Current->Freeze(); // to avoid flicker while changing the menu
	int ct;
	int nMainMenuItems = (int)m_pAI_MenuStructure->aiMainMenuItems.GetCount();
	for (ct = 0; ct < nMainMenuItems; ct++)
	{
		//bool bProcessingFileMenu = FALSE;
		mmNode = m_pAI_MenuStructure->aiMainMenuItems.Item(ct);
		pMainMenuItem_DefaultStructure = mmNode->GetData();
		mainMenuLabel_DefaultStructure = pMainMenuItem_DefaultStructure->mainMenuLabel;
		//if (mainMenuLabel_DefaultStructure == GetTopLevelMenuName(fileMenu)) // fileMenu resolves to _("&File")
		//{
		//	bProcessingFileMenu = TRUE;
		//}
		// skip processing of the Help and Administrator menus
		if (mainMenuLabel_DefaultStructure == GetTopLevelMenuName(helpMenu) // helpMenu resolves to _("&Help")
			|| mainMenuLabel_DefaultStructure == GetTopLevelMenuName(administratorMenu)) // administratorMenu resolves to _("Ad&ministrator")
		{
			continue;
		}
		mainMenuLabel_DefaultStructure = mainMenuLabel_DefaultStructure; //RemoveMenuLabelDecorations(mainMenuLabel_DefaultStructure); // remove any & chars for comparison
		// get the current top level wxMenu* from the menu bar
		int topLevelMenuBarIndex;
		topLevelMenuBarIndex = pMenuBar_Current->FindMenu(mainMenuLabel_DefaultStructure);
		if (topLevelMenuBarIndex != wxNOT_FOUND)
		{
			// We must establish a new index for the pMenuBar, which won't necessarily be the
			// same as the ct index we use into the top level menus in the default m_pAIMenuStructure.
			int mbCt;
			int numFileHistoryItems = 0;
			mbCt = pMenuBar_Current->FindMenu(mainMenuLabel_DefaultStructure);
			pMainMenuItem_CurrentMenuBar = pMenuBar_Current->GetMenu(mbCt);
			if (pMainMenuItem_CurrentMenuBar != NULL)
			{
				// Remove all current menu items from the pMainMenuItem_CurrentMenuBar.
				// Note: we do not remove any File History Items from the File menu - these
				// can stay.
				wxMenuItemList menuItemListForThisMainMenu;
				menuItemListForThisMainMenu = pMainMenuItem_CurrentMenuBar->GetMenuItems();
				int numItemsToRemove;
				numItemsToRemove = (int)menuItemListForThisMainMenu.GetCount(); // could be empty already
				// Note: testing shows that a wxMenuItemList also enumerates menu separators as
				// countable items in the list.
				if (numItemsToRemove != 0)
				{
					// remove existing items from this top level menu (pMainMenuItem_CurrentMenuBar)
					int miCt;
					wxMenuItem* mItem;
					wxMenuItem* removedItem;
					wxMenuItemList::Node* pNode;
					for (miCt = 0; miCt < numItemsToRemove; miCt++)
					{
						pNode = menuItemListForThisMainMenu.Item(miCt);
						mItem = pNode->GetData();
						wxASSERT(mItem != NULL);
						// Don't remove File History items which are menu items that start with a digit (1
						// through 9) followed by a space, followed by the full path name. We assume we can
						// skip all menu items that start with a digit and a space.
						wxString tempStr = mItem->GetLabel();
						tempStr = tempStr.Mid(0,2);
						if ((tempStr.GetChar(0) == _T('1') || tempStr.GetChar(0) == _T('2') ||
							tempStr.GetChar(0) == _T('3') || tempStr.GetChar(0) == _T('4') || tempStr.GetChar(0) == _T('5') ||
							tempStr.GetChar(0) == _T('6') || tempStr.GetChar(0) == _T('7') || tempStr.GetChar(0) == _T('8') ||
							tempStr.GetChar(0) == _T('9')) && tempStr.GetChar(1) == _T(' ') )
						{
							numFileHistoryItems++;
							//wxLogDebug(_T("Menu item skipped for deletion = %s"),mItem->GetLabel().c_str());
							continue;
						}
						//wxLogDebug(_T("Menu Item deleted = %s"),mItem->GetLabel().c_str());
						if (mItem->GetLabel() == _("See Glosses"))
						{
							// TODO: Check the following assumption: We should unilaterally disable Glossing here.
							// Reasoning: An administrator cannot really force the "See Glossing" Advanced
							// menu item to remain ticked in a persistent manner by turning it ticking it "ON",
							// then hiding the See Glossing menu item in the current profile, because the
							// "See Glossing" setting is not persistent - it reverts back to being "OFF" each
							// time the app starts up. Hence, we can ensure Glossing is disabled here along with
							// the removal of the "See Glosses" Advanced menu item in this profile.
							gbGlossingVisible = FALSE;
							gbIsGlossing = FALSE; // this must be FALSE if gbGlossingVisible is FALSE
						}
						removedItem = pMainMenuItem_CurrentMenuBar->Remove(mItem);
						delete removedItem;
						removedItem = (wxMenuItem*)NULL;
					}
				}
			}

			// Note: The File at this point is empty of normal menu items, but may have
			// from 1 to 9 file history items. We don't want to append menu items below
			// the group of file history items, but rather we must insert the menu items at
			// GetMenuItemCount() - numFileHistoryItems.
			int insertAtIndex = 0;
			// add menu items to this top level menu (pMainMenuItem_CurrentMenuBar)
			wxArrayPtrVoid pArrayOfSubMenuItemsToAdd;
			pArrayOfSubMenuItemsToAdd = GetMenuStructureItemsArrayForThisTopLevelMenu(pMainMenuItem_DefaultStructure);
			int numPointers;
			int ct_ptr;
			AI_SubMenuItem* pSubMenuItem;
			numPointers = (int)pArrayOfSubMenuItemsToAdd.GetCount();
			for (ct_ptr = 0; ct_ptr < numPointers; ct_ptr++)
			{
				pSubMenuItem = (AI_SubMenuItem*)pArrayOfSubMenuItemsToAdd.Item(ct_ptr);
				wxASSERT(pSubMenuItem != NULL);

				if (MenuItemIsVisibleInThisProfile(m_nWorkflowProfile,pSubMenuItem->subMenuIDint))
				{
					// In the line below the numFileHistoryItems will be zero for top level menus except for
					// the File menu. We normally insert at the GetMenuItemCount() index, i.e., after the last
					// item in the menu, but insert before any file history items.
					insertAtIndex = pMainMenuItem_CurrentMenuBar->GetMenuItemCount() - numFileHistoryItems;
					wxASSERT(insertAtIndex >= 0);
					int menuItemId;
					menuItemId = GetSubMenuItemIdFromAIMenuBar(mainMenuLabel_DefaultStructure,pSubMenuItem->subMenuLabel,pTempMenuBar);

					wxItemKind itemKind;
					itemKind = GetMenuItemKindFromString(pSubMenuItem->subMenuKind);
					// do the menu item insertion
					// Note: menuItemId will be wxID_SEPARATOR (-2) and itemKind will be
					// wxITEM_SEPARATOR (-1) for menuSeparators.
					// Note: apparently the \t chars in the xml and internal strings become \\t literals
					// and need to be changed to \t to work in the menus.
					wxString labelStr = pSubMenuItem->subMenuLabel;
					labelStr.Replace(_T("\\t"),_T("\t"));
					wxMenuItem* item = new wxMenuItem(pMainMenuItem_CurrentMenuBar,menuItemId,labelStr,pSubMenuItem->subMenuHelp,itemKind);
					pMainMenuItem_CurrentMenuBar->Insert(insertAtIndex,item);
				}
			} // end of for (ct_ptr = 0; ct_ptr < numPointers; ct_ptr++)

			// Check for extraneous left-over menu separators in this top level menu
			// and delete if found.
			// Start at the bottom of the menu and remove all menu separators there.
			bool bLastItemWasSeparator = FALSE;
			wxMenuItemList::Node* pNode;
			wxMenuItem* pMenuItem;
			wxMenuItemList pMenuItemList = pMainMenuItem_CurrentMenuBar->GetMenuItems(); // refresh the list of menu items
			pNode = pMenuItemList.GetLast();
			while (pNode != NULL)
			{
				pMenuItem = pNode->GetData();
				if (pMenuItem->GetKind() != wxITEM_SEPARATOR)
				{
					break;
				}
				else
				{
					// This menu separator is either the last item on the menu
					// or it is the first of two adjacent separators in the menu.
					// In either case we delete the current menu separator.
					wxMenuItem* pRemMenuItem;
					pRemMenuItem = pMainMenuItem_CurrentMenuBar->Remove(pMenuItem);
					wxASSERT(pRemMenuItem != NULL);
					delete pRemMenuItem; // to avoid memory leaks
					pRemMenuItem = (wxMenuItem*)NULL;
				}
				pMenuItemList = pMainMenuItem_CurrentMenuBar->GetMenuItems(); // refresh list
				pNode = pMenuItemList.GetLast();
			}
			// remove any separators at the top of the top level menu
			pMenuItemList = pMainMenuItem_CurrentMenuBar->GetMenuItems(); // refresh the list of menu items
			int nSubMenuItems = (int)pMenuItemList.GetCount();
			pNode = pMenuItemList.GetFirst();
			while (pNode != NULL)
			{
				pMenuItem = pNode->GetData();
				if (pMenuItem->GetKind() == wxITEM_SEPARATOR)
				{
					// This menu separator is at the top of the menu
					// so remove it.
					wxMenuItem* pRemMenuItem;
					pRemMenuItem = pMainMenuItem_CurrentMenuBar->Remove(pMenuItem);
					wxASSERT(pRemMenuItem != NULL);
					delete pRemMenuItem; // to avoid memory leaks
					pRemMenuItem = (wxMenuItem*)NULL;
				}
				else
				{
					break;
				}
				pMenuItemList = pMainMenuItem_CurrentMenuBar->GetMenuItems(); // refresh list
				pNode = pMenuItemList.GetFirst();
			}

			// change any remaining multiple sequences of menu separators to a single separator
			pMenuItemList = pMainMenuItem_CurrentMenuBar->GetMenuItems(); // refresh the list of menu items
			nSubMenuItems = (int)pMenuItemList.GetCount();
			int smCt;
			for (smCt = nSubMenuItems - 1; smCt >= 0; smCt--) // process bottom to top of menu
			{
				pNode = pMenuItemList.Item(smCt);
				pMenuItem = pNode->GetData();
				wxString smKindStr;
				wxItemKind smKind = pMenuItem->GetKind();
				if (smKind == wxITEM_SEPARATOR)
				{
					if (smCt == nSubMenuItems - 1 || bLastItemWasSeparator)
					{
						// This menu separator is either the last item on the menu
						// or it is the first of two adjacent separators in the menu.
						// In either case we delete the current menu separator.
						wxMenuItem* pRemMenuItem;
						pRemMenuItem = pMainMenuItem_CurrentMenuBar->Remove(pMenuItem);
						wxASSERT(pRemMenuItem != NULL);
						delete pRemMenuItem; // to avoid memory leaks
						pRemMenuItem = (wxMenuItem*)NULL;
					}
					bLastItemWasSeparator = TRUE;
				}
				else
				{
					bLastItemWasSeparator = FALSE;
				}
			}
		}
		else
		{
			// The top level menu was not found in the menu bar. This can happen for
			// the Administrator menu when it is not present, and in an ANSI build
			// where the Layout menu is not present.
			;
		}
	} // end of for (ct = 0; ct < nMainMenuItems; ct++)

	pMenuBar_Current->Thaw(); // to avoid flicker while changing the menu
	// remove the temporary invisible menu bar to avoid memory leaks
	delete pTempMenuBar;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's ConfigureInterfaceForUserProfile().
/// This function destroys the existing mode bar then constructs a new mode bar and uses
/// it as the starting baseline, removing elements according to the currently selected
/// user profile. The mode bar may be either the standard 1-line mode bar or the
/// special 2-line mode bar used when the -xo command line parameter is used with
/// an OLPC XO computer.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ConfigureModeBarForUserProfile()
{
	// Note: The ModeBar (also called "controlBar") is created on a wxPanel in the
	// CMainFrame constructor in MainFrm.cpp. Its pointer on the App is m_pControlBar.
	// Unlike the menu bar, the m_pControlBar is not managed directly by its enclosing
	// frame (CMainFrame). The m_pControlBar, once created is never optionally hidden
	// (using the View menu) as can be done for the Tool bar, Status bar and Compose
	// bar. Nevertheless, the height of m_pControlBar must be current in the
	// main frame's m_controlBarHeight member in order to correctly size the main frame.
	// The m_controlBarHeight is kept current whether the application is using the normal
	// control bar (ControlBarFunc) or the two-line control bar (ControlBar2LineFunc)
	// designed for better visibility on the OLPC XO machines.
	// We will get the control bar and recreate it for the current user profile's
	// "modeBar" item visibility specifications. As with the AI menu bar, it is easiest
	// to simply remove the items from the existing mode bar, and add back those which
	// should appear in the current profile.
	//
	// We need to get the mode bar's sizer(s) in order to remove and add controls to
	// the correct part of the mode bar. We have assigned "Access variable names" for
	// the needed sizers in both mode bars. For the normal single-line mode bar the
	// access variable name is ID_CONTROLBAR_1_LINE_SIZER; for the two-line mode bar
	// the access variable names are ID_CONTROLBAR_2_LINE_SIZER_TOP and
	// ID_CONTROLBAR_2_LINE_SIZER_BOTTOM. These sizers are created as
	// wxBoxSizer( wxHORIZONTAL ) in wxDesigner.
	// The ID_CONTROLBAR_1_LINE_SIZER sizer has its items in the following order:
	// 1. Drafting [wxRadioButton]
	// 2. Reviewing [wxRadioButton]
	// 3. Automatic [wxCheckBox]
	// 4. Save to Knowledge Base [wxCheckBox]
	// 5. Force Choice For This Item [wxCheckBox]
	// 6. <no adaptation> [wxButton]
	// 7. Delay [wxStaticText] + wxTextCtrl
	// 8. Spacer
	// 9. Glossing [wxCheckBox]
	// Note: There are also two wxStaticLine controls created one above the ID_CONTROLBAR_1_LINE_SIZER and
	// one below it. We won't need to change those, just the contents of ID_CONTROLBAR_1_LINE_SIZER.

	CMainFrame* pMainFrame;
	pMainFrame = GetMainFrame();
	pMainFrame->Freeze(); // to avoid flicker
	pMainFrame->m_pControlBar->Destroy(); // removes the existing mode bar which may not be showing all items in the current profile

	// Create the new control bar using a wxPanel (see similar code in CMainFrame's constructor)
	// whm note: putting the control bar on a panel could have been done in wxDesigner
	// TODO: Make sure this works whether or not the toolbar and/or composebar are currently visible
	wxPanel *controlBar = new wxPanel(pMainFrame, -1, wxDefaultPosition, wxDefaultSize, 0);
	wxASSERT(controlBar != NULL);

	// The ControlBarFunc() and ControlBar2LineFunc() functions are located
	// in Adapt_It_wdr.cpp.
	// To populate the controlBar panel we've used wxBoxSizers. The outer
	// most sizer is a vertical box sizer which has a horizontal line in
	// the upper part of the box (for the line between the toolbar and
	// controlbar), and the row of controls laid out in wxHORIZONTAL
	// alignment within an embedded horizontal box sizer, below the line
	// within the vertical box sizer

	if (m_bExecutingOnXO) // prefix m_bExecutingOnXO with ! to test the two-line control bar configuration
	{
		// We're running on a high res screen - probably a OLPC XO, so use the 2 line control bar for
		// better fit in main frame
		ControlBar2LineFunc( controlBar, TRUE, TRUE );
		// make m_pControlBar point to the new control bar
		pMainFrame->m_pControlBar = controlBar;
		// In the case of the two line control bar, we have two
		// named wxBoxSizers.
		// The upper sizer called ID_CONTROLBAR_2_LINE_SIZER_TOP
		// has the following controls:
		//    1. Spacer
		//    2. Drafting [wxRadioButton]
		//    3. Reviewing [wxRadioButton]
		//    4. *Automatic [wxCheckBox]
		//    5. Save to Knowledge Base [wxCheckBox]
		//    6. *Delay [wxStaticText}
		//    7. wxTextCtrl named IDC_EDIT_DELAY
		// The lower sizer called ID_CONTROLBAR_2_LINE_SIZER_BOTTOM
		// has the following controls:
		//    1. Spacer
		//    2. *Force Choice For This Item [wxCheckBox]
		//    3. Spacer
		//    4. <no adaptation> [wxButton]
		//    5. Spacer
		//    6. *Glossing [wxCheckBox]
		// * These are the potentially "hidden" items depending on the selected
		// user profile.
		// Note: On the XO screen, it is the horizontal space that gets overly crowded due to
		// the system's increase in font size, rather than the vertical space, so I don't
		// think it would be worth the effort to try to consolidate the two bars into a one
		// line control bar in the case that an administrator sets up a profile in which many
		// items are not to be made visible.
		//
		// Go through the children of the two line control bar and
		// remove any that are not supposed to be visible in the current
		// profile.
		// First, the upper sizer ID_CONTROLBAR_2_LINE_SIZER_TOP
		wxSizer* pModeBarSizer = ID_CONTROLBAR_2_LINE_SIZER_TOP;
		RemoveModeBarItemsFromModeBarSizer(pModeBarSizer);

		// Second, the lower sizer ID_CONTROLBAR_2_LINE_SIZER_BOTTOM
		pModeBarSizer = ID_CONTROLBAR_2_LINE_SIZER_BOTTOM;
		RemoveModeBarItemsFromModeBarSizer(pModeBarSizer);
	}
	else
	{
		ControlBarFunc( controlBar, TRUE, TRUE );
		// make m_pControlBar point to the new control bar
		pMainFrame->m_pControlBar = controlBar;

		// Now we go through the children of the default mode bar and remove any that are
		// not supposed to be visible in the current profile
		wxSizer* pModeBarSizer = ID_CONTROLBAR_1_LINE_SIZER;
		RemoveModeBarItemsFromModeBarSizer(pModeBarSizer);
	}
	// If the "[] Glossing" check box is not removed in this profile after the above code
	// executes (i.e., NULL), check here to see if it should be visible or hidden according to the
	// current value of gbIsGlossing.
	wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)pMainFrame->m_pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
	// pCheckboxIsGlossing coulc be null if it is not visible in the current profile
	if (pCheckboxIsGlossing != NULL)
	{
		if (gbIsGlossing)
		{
			pCheckboxIsGlossing->Show(TRUE);
		}
		else
		{
			pCheckboxIsGlossing->Show(FALSE);
		}
	}

	wxButton* pNoAdaptationOrNoGloss = (wxButton*)pMainFrame->m_pControlBar->FindWindowById(IDC_BUTTON_NO_ADAPT);
	// pNoAdaptationOrNoGloss could be null if it is not visible in the current profile
	if (pNoAdaptationOrNoGloss != NULL)
	{
		if (gbIsGlossing)
		{
			pNoAdaptationOrNoGloss->SetLabel(_("<no gloss>"));
		}
		else
		{
			pNoAdaptationOrNoGloss->SetLabel(_("<no adaptation>"));
		}
	}

	// whm added 7Jan12 set controlBar visibility according to basic config
	// file setting - as stored in the App's m_bModeBarVisible member
	if (gpApp->m_bModeBarVisible)
	{
		gpApp->GetMainFrame()->m_pControlBar->Show();
	}
	else
	{
		gpApp->GetMainFrame()->m_pControlBar->Hide();
	}

	// lastly update the CMainFrame's m_controlBarHeight member with the newly populated
	// mode bar
	wxSize controlBarSize;
	controlBarSize = pMainFrame->m_pControlBar->GetSize();
	pMainFrame->m_controlBarHeight = controlBarSize.GetHeight();
	pMainFrame->Thaw(); // to avoid flicker
	pMainFrame->SendSizeEvent(); // we need to send a size event to the main frame
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's ConfigureModeBarForUserProfile().
/// This function is a helper function for ConfigureModeBarForUserProfile().
/// It removes any mode bar items that are not visible in the currently selected user
/// profile. It also deals with the special cases of the Glossing checkbox and the Delay's
/// wxTextCtrl. If Glossing is ON it turns it OFF if the Glossing checkbox is removed from
/// the modebar. If the Delay static text is removed, it removes the associated wxTextCtrl.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::RemoveModeBarItemsFromModeBarSizer(wxSizer* pModeBarSizer)
{
	wxASSERT(pModeBarSizer != NULL);
	wxSizerItemList modeBarItems = pModeBarSizer->GetChildren();
	wxSizerItemList::Node* node;
	int nSizerItems = (int)modeBarItems.GetCount();
	int ct;
	bool bDelayRemoved = FALSE;
	for (ct = 0; ct < nSizerItems; ct++)
	{
		node = modeBarItems.Item(ct);
		wxSizerItem* pSizerItem = node->GetData();
		wxString itemLabel;
		if (!pSizerItem->IsSpacer())
		{
			// don't call GetWindow()->GetLabel() on a spacer; it will crash
			itemLabel = pSizerItem->GetWindow()->GetLabel();
			itemLabel.Trim(FALSE);
			itemLabel.Trim(TRUE);
		}
		else
		{
			itemLabel = _T("");
		}
		if (!ModeBarItemIsVisibleInThisProfile(m_nWorkflowProfile,itemLabel))
		{
			if (itemLabel == _("Glossing") && gbIsGlossing == TRUE)
			{
				// TODO: Check the following assumption: We should unilaterally turn off Glossing here.
				// Reasoning: An administrator cannot really force Glossing to be "ON" in a persistent
				// manner by turning it on, then hiding the Glossing checkbox in the current profile,
				// because the Glossing setting is not persistent - it reverts back to being "OFF" each
				// time the app starts up. Hence, we can ensure Glossing is turned off here.
				gbIsGlossing = FALSE; // we are removing the [] Glossing checkbox so gbIsGlossing should be FALSE
			}
			if (itemLabel == _("Delay"))
			{
				// the "Delay" is actually associated with the itemLabel of the wxStaticText control and
				// not the following wxTextCtrl, so when the "Delay" wxStaticText control is removed we
				// also flag for removal (see below) the following wxTextCtrl which has the identifier of
				// IDC_EDIT_DELAY.
				bDelayRemoved = TRUE;
			}
			pSizerItem->DeleteWindows();
		}
	}
	if (bDelayRemoved)
	{
		// the Delay wxStaticText was removed, so remove the following wxTextCtrl as well
		wxTextCtrl* pDelayTextCtrl;
		pDelayTextCtrl = (wxTextCtrl*)GetMainFrame()->m_pControlBar->FindWindowById(IDC_EDIT_DELAY);
		wxASSERT(pDelayTextCtrl != NULL);
		if (pDelayTextCtrl != NULL)
		{
			pDelayTextCtrl->Destroy();
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's ConfigureInterfaceForUserProfile().
/// This function destroys the existing tool bar then constructs a new tool bar and uses
/// it as the starting baseline, removing elements according to the currently selected
/// user profile. The tool bar may be either the standard tool bar (AIToolBarFunc) or the
/// alternate tool bar (AIToolBar32x32Func) which has fewer buttons but larger bitmaps for
/// use when the -xo command line parameter is used with an OLPC XO computer.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ConfigureToolBarForUserProfile()
{
	CMainFrame* pMainFrame;
	pMainFrame = GetMainFrame();
	pMainFrame->Freeze(); // to avoid flicker
	pMainFrame->m_pToolBar->Destroy(); // removes the existing tool bar which may not be showing all items in the current profile

	// Create the new tool bar with our AIToolBar class override of wxToolBar (see similar
	// code in CMainFrame's constructor)
    long style = /*wxNO_BORDER |*/ wxTB_FLAT | wxTB_HORIZONTAL;
	AIToolBar* toolBar = new AIToolBar(pMainFrame, -1, wxDefaultPosition, wxDefaultSize, style);
	wxASSERT(toolBar != NULL);
	pMainFrame->m_pToolBar = toolBar;

	// The AIToolBarFunc() and AIToolBar32x30Func() functions are located
	// in Adapt_It_wdr.cpp.
	if (gpApp->m_bExecutingOnXO) // add a ! to test the 32x32 toolbar when -xo is not set
	{
		toolBar->SetToolBitmapSize(wxSize(32,30));
		AIToolBar32x30Func( toolBar ); // this calls toolBar->Realize(), but we want the frame to be parent
		// Note: AIToolBar32x32Func() creates 33 defauls elements including toolbar separators
		// The default elements that are not included (compared to AIToolBarFunc()) are:
		// 1. Cut [not likely used much - also has Ctrl-X hotkey]
		// 2. Copy [not likely used much - also has Ctrl-C hotkey]
		// 3. Paste [not likely used much - also has Ctrl-V hotkey]
		// 4. Spacer
		// 5. Print [available on File menu]
		// 6. Spacer
		// 7. Display Help Topics [available on Help menu]

		// scan through this default toolbar and remove items that are not supposed to
		// be visible in the current profile.
		// The wxToolBarBase class has a protected member called
		// wxToolBarToolsList m_tools which is "the list of all our tools" which
		// we can now retrieve with our AIToolBar::GetToolBarToolsList() override
		RemoveToolBarItemsFromToolBar(toolBar);
	}
	else
	{
		AIToolBarFunc( toolBar ); // this calls toolBar->Realize(), but we want the frame to be parent
		// Note: AIToolBar32x32Func() creates 40 default elements including toolbar separators

		// scan through this default toolbar and remove items that are not supposed to
		// be visible in the current profile.
		// The wxToolBarBase class has a protected member called
		// wxToolBarToolsList m_tools which is "the list of all our tools" which
		// we can now retrieve with our AIToolBar::GetToolBarToolsList() override
		RemoveToolBarItemsFromToolBar(toolBar);
	}
	// Note: The RemoveToolBarItemsFromToolBar() call above also removed any "leftover"
	// or duplicate tool bar separators.

	pMainFrame->SetToolBar(toolBar);
	// Notes on SetToolBar(): WX Docs say,
	// "SetToolBar() associates a toolbar with the frame. When a toolbar has been created with
	// this function, or made known to the frame with wxFrame::SetToolBar, the frame will manage
	// the toolbar position and adjust the return value from wxWindow::GetClientSize to reflect
	// the available space for application windows. Under Pocket PC, you should always use this
	// function for creating the toolbar to be managed by the frame, so that wxWidgets can use
	// a combined menubar and toolbar. Where you manage your own toolbars, create a wxToolBar
	// as usual."
	pMainFrame->m_pToolBar = pMainFrame->GetToolBar();
	wxASSERT(pMainFrame->m_pToolBar == toolBar);

	// whm added 7Jan12 set toolBar visibility according to basic config
	// file setting - as stored in the App's m_bToolBarVisible member
	if (gpApp->m_bToolBarVisible)
	{
		gpApp->GetMainFrame()->m_pToolBar->Show();
	}
	else
	{
		gpApp->GetMainFrame()->m_pToolBar->Hide();
	}

	wxSize toolBarSize;
	toolBarSize = pMainFrame->m_pToolBar->GetSize();
	pMainFrame->m_toolBarHeight = toolBarSize.GetHeight();	// we shouldn't need this since doc/view
												// is supposed to manage the toolbar and
												// our Main Frame should account for its
												// presence when calculating the client size
												// with pMainFrame->GetClientSize()
	pMainFrame->Thaw();
}


//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's ConfigureInterfaceForUserProfile().
/// This function sets the value of m_bShowNewProjectItem to FALSE if the <New Project> user
/// profile item's itemVisibility attribute for the current profile is set to "0"; otherwise
/// sets the value of m_bShowNewProjectItem to TRUE. The CProjectPage class uses the App's
/// m_bShowNewProjectItem flag to include <New Project> as the first item in the page's
/// list of projects, or omit it from the list.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ConfigureWizardForUserProfile()
{
	// we assume that a mode bar item is visible unless the m_pUserProfiles data
	// indicates otherwise.
	if (NewProjectItemIsVisibleInThisProfile(m_nWorkflowProfile))
	{
		m_bShowNewProjectItem = TRUE;
	}
	else
	{
		m_bShowNewProjectItem = FALSE;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return    TRUE if the "<New Project>" item is supposed to be visible in this nProfile,
///                 FALSE otherwise
/// \param      -> nProfile   the user workflow profile (zero based), i.e., m_nWorkflowProfile
///                     i.e., the tooltip
/// \remarks
/// Called from: the App's ConfigureWizardForUserProfile().
/// Determines whether the "<New Project>" item is supposed to be visible in
/// the interface for the user profile passed in as nProfile. Looks up the itemLabel in
/// the m_pUserProfiles data struct stored on the heap and reads the usedVisibilityValues
/// for that item as indexed for the nProfile.
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::NewProjectItemIsVisibleInThisProfile(const int nProfile)
{
	bool bItemIsVisible = TRUE;
	if (nProfile == 0)
	{
		// The work flow profile 0 (zero) is the "None" selection and all interface
		// items are visible by default
		return bItemIsVisible;
	}
	int ct;
	int totct;
	totct = (int)m_pUserProfiles->profileItemList.GetCount();
	for (ct = 0; ct < totct; ct++)
	{
		UserProfileItem* pUserProfileItem;
		ProfileItemList::Node* node;
		node = m_pUserProfiles->profileItemList.Item(ct);
		pUserProfileItem = node->GetData();
		wxASSERT(pUserProfileItem != NULL);
		if (pUserProfileItem->itemType != _T("wizardListItem"))
		{
			continue;
		}
		wxString itemLabelStr;
		itemLabelStr = pUserProfileItem->itemText;
		itemLabelStr.Trim(FALSE);
		itemLabelStr.Trim(TRUE);
		int indexFromProfile = 0;
		if (nProfile <= 0)
			indexFromProfile = 0;
		else if (nProfile > 0)
			indexFromProfile = nProfile - 1;
		if (itemLabelStr == _("<New Project>") && pUserProfileItem->usedVisibilityValues.Item(indexFromProfile) == _T("0"))
		{
			return FALSE;
		}
	}
	return bItemIsVisible;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      the AIToolBar (derived from wxToolBar) from which items are to be removed
/// \remarks
/// Called from: the App's ConfigureToolBarForUserProfile() and CMainFrame::RecreateToolBar().
/// This function is a helper function for ConfigureToolBarForUserProfile().
/// It removes any tool bar items that are not visible in the currently selected user
/// profile. It also removes any left-over or duplicate tool bar separators.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::RemoveToolBarItemsFromToolBar(AIToolBar* pToolBar)
{
	int ct,toolCount;
	toolCount = (int)pToolBar->GetToolsCount();
	wxToolBarToolsList toolBarToolsList = pToolBar->GetToolBarToolsList();
	wxToolBarToolsList::Node* node;
	wxToolBarToolBase* pTBItem;
	// Since we are removing the tool bar items by position in the bar, we
	// need to remove the items from the right end (higher position) to the
	// left end (lower) position, otherwise our position index ct will not
	// be accurate after the first removal.
	for (ct = toolCount-1; ct >= 0; ct--) // counting downwards from right end
	{
		node = toolBarToolsList.Item(ct);
		pTBItem = (wxToolBarToolBase*)node->GetData();
		wxString itemLabel;
		if (!pTBItem->IsSeparator())
		{
			//wxString isSepStr = _T("");
			//wxLogDebug(_T("Toolbar window item: Short Help: %s, Long Help: %s"),
			//	pTBItem->GetShortHelp().c_str(),pTBItem->GetLongHelp().c_str());
			itemLabel = pTBItem->GetShortHelp();
			itemLabel.Trim(FALSE);
			itemLabel.Trim(TRUE);
		}
		else
		{
			//wxString isSepStr = _T("");
			//isSepStr = _T("Separator");
			//wxLogDebug(_T("Toolbar window item: wxItemKind: %s"),isSepStr.c_str());
			itemLabel = _T("");
		}
		// Note: the above wxLogDebug() shows that GetLabel() always is null str, GetShortHelp() is
		// the name of the toolbar button (the tooltip), and GetLongHelp() is the status help for the
		// button. We can use the string returned from GetShortHelp() to identify the toolbar button.
		// separators are a null string in GetShortHelp and GetLongHelp - and they also have a
		// getter called IsSeparator() which returns TRUE for separators, FALSE otherwise.
		if (!ToolBarItemIsVisibleInThisProfile(m_nWorkflowProfile,itemLabel))
		{
			pToolBar->DeleteToolByPos(ct);
		}
	}
	// Now take care of left-over or duplicate tool bar separators
	toolCount = (int)pToolBar->GetToolsCount();
	toolBarToolsList = pToolBar->GetToolBarToolsList();
	// Since we are removing the tool bar items by position in the bar, we
	// need to remove the items from the right end (higher position) to the
	// left end (lower) position, otherwise our position index ct will not
	// be accurate after the first removal.
	bool bLastItemWasSeparator = FALSE;
	for (ct = toolCount-1; ct >= 0; ct--) // counting downwards from right end
	{
		node = toolBarToolsList.Item(ct);
		pTBItem = (wxToolBarToolBase*)node->GetData();
		if (!pTBItem->IsSeparator())
		{
			// item is a normal tool bar item (not a separator)
			bLastItemWasSeparator = FALSE;
		}
		else
		{
			// item is a tool bar separator
			// delete if the last item was a separator
			if (bLastItemWasSeparator)
			{
				pToolBar->DeleteToolByPos(ct);
			}
			bLastItemWasSeparator = TRUE;
		}
	}

}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      progMenuMode -> an enum which can be: collabNotAvailableNormal, collabAvailableTurnedOn, 
///                             collabAvailableTurnedOff, or collabAvailableReadOnlyOn
/// \remarks
/// Called from: the App's OnInit(), OnEditUserMenuSettingsProfiles(), and from the
/// CSetupEditorCollaboration::OnOK() handler.
/// Makes the following adjustments to AI menus:
/// 1. Adds parenthetical info in the Open... and Save menu labels of the File menu
///    when collaboration with Paratext or Bibledit is ON, removes the parenthetical
///    material when PT/BE collaboration is OFF.
/// 2. Displays or removes the top-level Administrator menu depending on the current
///    value of the App's m_bShowAdministratorMenu flag.
/// 3. Adjusts the Administrator menu's "Setup %s Collaboration" menu item to include
///    "Paratext" or "Bibledit" within its label substituted for %s.
/// 4. Make menu accelerator key adjustments required for the different platform's
///    needs - some platforms reserve certain accelerator keys for their own system
///    use.
/// 5. Remove the Layout menu if building for ANSI version (leave it for Unicode
///    version).
/// 6. Adjust the accelerator key for the Mac platform for the Layout menu's item.
/// 7. Set toggle menu items to reflect the current values of their GUI flags.
/// some menu labels and hot key assignments for the different platforms -
/// different platforms reserve certain hot key combinations for their own system use.
/// Adjustments are also made here for certain modes such as Paratext/Bibledit collaboration.
/// This function also sets the initial checked/unchecked state of menu items which are
/// checkable.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::MakeMenuInitializationsAndPlatformAdjustments(enum ProgramMenuMode progMenuMode)
{
	CMainFrame* pMainFrame = GetMainFrame();
	wxMenuBar* pMenuBar = pMainFrame->GetMenuBar();
	// Get the File Menu
	wxMenu* pFileMenu;
	pFileMenu = GetTopLevelMenuFromAIMenuBar(fileMenu);
	// Note: The FileHistoryLoad() call is done in OnInit() before the first
	// call of MakeMenuInitializationsAndPlatformAdjustments.

	// Make adjustments on the Windows platform for when Paratext or Bibledit
	// collaboration is in effect. We modify the labels for Open... and Save...
	// on the File menu to include parenthetical explanations as follows:
	// Open... (Get Source Text From Paratext) or Open... (Get Source Text From Bibledit)
	// Save (Transfer Translation Draft To Paratext) or Save... (Transfer Translation Draft To Bibledit)
	// Note: We do not need conditional define here for Windows because
	// m_bCollaboratingWithParatext or m_bCollaboratingWithBibledit will
	// only be TRUE on the platforms that host Paratext, i.e., Windows, or Bibledit,
	// i.e., Linux or the Mac.
	if (pFileMenu != NULL)
	{
		// whm added 29Mar12. Remove file history when collaborating with PT/BE. Also remove
		// any _Collab... files from history when collaborating was explicitly turned OFF
		// from the ChooseCollabOptionsDlg. Use the ProgMenuMode enum for possible modes.
		if (progMenuMode == collabAvailableTurnedOn)
		{
			wxASSERT(m_bCollaboratingWithParatext || m_bCollaboratingWithBibledit);
			// In this case the user opted to turn collab on, and as such we
			// remove all MRU items from the file history. In collaboration mode
			// the user should not be able to bypass the collaboration mechanism
			// by choosing an item from the file history even if it were a _Collab
			// item (loading of collaboration documents is not done via OnOpenDocument()).
			wxFileHistory* fileHistory = m_pDocManager->GetFileHistory();
			while (fileHistory->GetCount() > 0)
			{
				fileHistory->RemoveFileFromHistory(0);
			}
		}
		else if (progMenuMode == collabAvailableTurnedOff)
		{
			// In this case the user opted to turn collab off, and as such we
			// remove any _Collab documents from the file history but leave others
			wxFileHistory* fileHistory = m_pDocManager->GetFileHistory();
			int numFilesInHistory = fileHistory->GetCount();
			int ct;
			// remove any _Collab... file history items in reverse order (top down)
			for (ct = numFilesInHistory - 1; ct >= 0; ct--)
			{
				wxString fileHistoryName = fileHistory->GetHistoryFile(ct);
				if (fileHistoryName.Find(_T("_Collab")) == 0) // see DocPage.cpp test
				{
					fileHistory->RemoveFileFromHistory(ct);
				}
			}
		}
		else if (progMenuMode == collabIndeterminate)
		{
			// In this case MakeMenuInitializationsAndPlatformAdjustments() is being called
			// at a point where collaboration might be either ON or OFF. Remove file history
			// if collaboration is on. Don't worry about the _Collab... name cases here.
			if (m_bCollaboratingWithParatext || m_bCollaboratingWithBibledit)
			{
				wxFileHistory* fileHistory = m_pDocManager->GetFileHistory();
				while (fileHistory->GetCount() > 0)
				{
					fileHistory->RemoveFileFromHistory(0);
				}
			}
		}
		else if (progMenuMode == collabAvailableReadOnlyOn)
		{
			; // do nothing any MRU file history is eligible for selection
		}

		// The Open... and Save... commands have a tabbed hot key which we have to move to the right end of
		// the new label, otherwise everything that comes after the tab will be displaced to the right side
		// of the File menu (right aligned).
		wxString label;
		wxString defaultMenuLabel;
		wxString labelFromPT;
		wxString labelFromBE;
		// For wxID_OPEN add parenthetical infor during collaboration
		label = pFileMenu->GetLabel(wxID_OPEN);
		// whm added 28Jul11. Remove any initial underscore characters that seem
		// to creep in in the Linux implementation of GetLabel()
		//while (label.Find(_T('_')) == 0)
		//{
		//	label.Remove(0,1);
		//}
		// whm revised 30Dec11. On Linux the label for wxID_OPEN doesn't have the tab and shortcut
		// key indicated. Therefore, I'm going to handle the entire label string when doing
		// adjustments for indicating the Paratext/Bibledit parenthetical material for Open and
		// Save.
		defaultMenuLabel = _("&Open...\tCtrl-O"); // must be same as in wxDesigner resource
		labelFromPT = _("&Open... (Get Source Text From Paratext)\tCtrl-O");
		labelFromBE = _("&Open... (Get Source Text From Bibledit)\tCtrl-O");
		if (m_bCollaboratingWithParatext)
		{
			label = labelFromPT;
		}
		else if (m_bCollaboratingWithBibledit)
		{
			label = labelFromBE;
		}
		else
		{
			label = defaultMenuLabel;
		}
		label.Trim(TRUE);
		label.Trim(FALSE);
		pFileMenu->SetLabel(wxID_OPEN,label);

		// For wxID_SAVE add parenthetical infor during collaboration
		label = pFileMenu->GetLabel(wxID_SAVE);
		// whm added 28Jul11. Remove any initial underscore characters that seem
		// to creep in in the Linux implementation of GetLabel()
		//while (label.Find(_T('_')) == 0)
		//{
		//	label.Remove(0,1);
		//}
		defaultMenuLabel = _("&Save\tCtrl-S"); // must be same as in wxDesigner resource
		labelFromPT = _("&Save (Transfer Translation Draft To Paratext)\tCtrl-S");
		labelFromBE = _("&Save (Transfer Translation Draft To Bibledit)\tCtrl-S");
		if (m_bCollaboratingWithParatext)
		{
			label = labelFromPT;
		}
		else if (m_bCollaboratingWithBibledit)
		{
			label = labelFromBE;
		}
		else
		{
			label = defaultMenuLabel;
		}
		label.Trim(TRUE);
		label.Trim(FALSE);
		pFileMenu->SetLabel(wxID_SAVE, label);
	}

	// remove the Administrator menu until asked for
	if (!m_bShowAdministratorMenu)
	{
		// is the Admin menu showing? If so, remove it
		if (!m_bAdminMenuRemoved)
		{
			// whm Note: Bruce designed the Administrator menu item to be
			// deleted in the CMainFrame's destructor rather than when it
			// is "Removed" here.
			int menuCount = pMenuBar->GetMenuCount();
			m_adminMenuTitle = pMenuBar->GetMenuLabelText(menuCount - 1);
			m_pRemovedAdminMenu = pMenuBar->Remove(menuCount - 1);
			m_bAdminMenuRemoved = TRUE;
		}
		pMenuBar->Refresh();
	}
	else
	{
		// is the Admin menu hidden? If so, Append it back to the pMenuBar
		if (m_bAdminMenuRemoved)
		{
			bool bAppendedOK;
			bAppendedOK = pMenuBar->Append(m_pRemovedAdminMenu,m_adminMenuTitle);
			wxASSERT(bAppendedOK);
			wxCHECK_RET(bAppendedOK, _T("MakeMenuInitializationsAndPlatformAdjustments() failed in m_bAdminMenuRemoved == TRUE block"));
			m_pRemovedAdminMenu = NULL;
			m_bAdminMenuRemoved = FALSE;
		}
		pMenuBar->Refresh();
	}

	// Format the "Setup %s Collaboration..." menu item for Paratext or Bibledit
	wxMenu* pAdministratorMenu;
	pAdministratorMenu = GetTopLevelMenuFromAIMenuBar(administratorMenu);
	if (pAdministratorMenu != NULL)
	{
		wxString label;
		// wxMenu::GetLabel() gets menu item label including any mnemonics and
		// accelerators.
		label = pAdministratorMenu->GetLabel(ID_SETUP_EDITOR_COLLABORATION);
		// whm added 28Jul11. Remove any initial underscore characters that seem
		// to creep in in the Linux implementation of GetLabel()
		while (label.Find(_T('_')) == 0)
		{
			label.Remove(0,1);
		}
		// whm 4Apr12 removed %s from this label in wxDesigner
		//if (label.Find(_T("%s")) != wxNOT_FOUND)
		//{
		//	wxASSERT(!m_collaborationEditor.IsEmpty());
		//	label = label.Format(label,m_collaborationEditor.c_str());
		//}
		pAdministratorMenu->SetLabel(ID_SETUP_EDITOR_COLLABORATION,label);
		// whm added 1Sep11
		// now substitute "Paratext" or "Bibledit" for the %s in the menu help text
		// whm 4Apr12 removed %s instances (2) from this menu's help text in wxDesigner
		//wxMenuItem* pCollabMenuItem = pAdministratorMenu->FindItem(ID_SETUP_EDITOR_COLLABORATION);
		//if (pCollabMenuItem != NULL)
		//{
		//	label = pCollabMenuItem->GetHelp(); //_("Configure Adapt It to use a %s project for its input (source) texts, and a different %s project exporting its (target) texts")
		//	wxASSERT(!m_collaborationEditor.IsEmpty());
		//	label = label.Format(label,m_collaborationEditor.c_str(),m_collaborationEditor.c_str());
		//	pCollabMenuItem->SetHelp(label);
		//}
	}

	// MAKE MENU ACCELERATOR KEY ADJUSTMENTS REQUIRED FOR THE DIFFERENT PLATFORMS
    // See also the CMainFrame::CMainFrame constructor where accelerator key assignments
    // are made to coordinate with these menu hot key adjustments.
#if defined (__WXMAC__) || defined (__WXGTK__)
    // whm Added 11Feb09: We have to adjust the menu access keys for the wxMac port to keep
    // them from conflicting with the customary Mac access keys and accelerator keys. The
    // accelerator keys are created during the creation of the CMainFrame above, so we can
    // make adjustments here.

	// File | Start Working...
    // On Mac and Ubuntu Linux (Gnome/Gtk), Command-W is reserved for Closing the Active
    // Window, so we've defined the accelerator key on Mac for "Start Working..." as
    // Command-Shift-O, and on Linux as Ctrl-Shift-O, to avoid the conflict.
	if (pFileMenu != NULL)
	{
		pFileMenu->SetLabel(ID_FILE_STARTUP_WIZARD,_("Start Working...\tCtrl-Shift-O")); // Windows
													// & Linux have the default Ctrl-W
	}
#endif

#ifdef __WXMAC__
	// File | Close Project
    // On Mac, Command-J is reserved for Scroll/Jump to a Selection on the Mac. We've used
    // it on Windows/Linux for Close Project, but the comperable hot key to close the
    // active window for Mac is Command-W.
	// Note: On Linux/wxGTK, Ctrl-W is automatically assigned to the File | Close
	// (wxID_CLOSE) menu item.
	if (pFileMenu != NULL)
	{
		if (pFileMenu->FindItem(ID_FILE_CLOSEKB) != NULL)
		{
			pFileMenu->SetLabel(ID_FILE_CLOSEKB,_("Close Project\tCtrl-W")); // Windows
				// and Linux have the default Ctrl-J
		}
	}

	// File | Exit
	// On Mac, Command-Q is reserved for Quitting the Application on the Mac. We've used it on
	// Windows/Linux for Edit menu's Edit Source Text..., so for Quitting the application we'll
	// assign a Ctrl-Q as hot key to associate with the Exit menu command here.
    if (pFileMenu != NULL)
	{
		wxMenuItem* pFileExitItem;
		pFileExitItem = pFileMenu->FindItem(wxID_EXIT);
		if(pFileExitItem != NULL)
		{
			pFileExitItem->SetItemLabel(_("Quit\tCtrl-Q")); //pFileMenu->SetLabel(wxID_EXIT,_("Exit\tCtrl-Q"));
		}
	}

	wxMenu* pEditMenu = GetTopLevelMenuFromAIMenuBar(editMenu);
	if(pEditMenu != NULL)
	{
		// Edit | Edit Source Text
		// On Mac, the hot key command to quit the application is Command-Q and we have set a
		// Ctrl-Q accelerator key to be associated with wxID_Exit, so we've set the menu to use
		// Ctrl-Shift-E for Edit Source Text here.
		if (pEditMenu->FindItem(ID_EDIT_SOURCE_TEXT) != NULL)
		{
			pEditMenu->SetLabel(ID_EDIT_SOURCE_TEXT,_("Edit Source Text...\tCtrl-Shift-E"));
		}

		// Edit | Move Note Backward
		// On Mac, the hot key command to View as List is Command-2 and we have set a Ctrl-Shift-2
		// accelerator key to be associated with Edit | Move Note Backward, so we've set the menu to
		// use Ctrl-Shift-2 for it here.
		if (pEditMenu->FindItem(ID_EDIT_MOVE_NOTE_BACKWARD) != NULL)
		{
			pEditMenu->SetLabel(ID_EDIT_MOVE_NOTE_BACKWARD,_("Move Note Backward\tCtrl-Shift-2"));
		}

		// Edit | Move Note Forward
		// On Mac, the hot key command to View as Columns is Command-3 and we have set a Ctrl-Shift-3
		// accelerator key to be associated with Edit | Move Note Forward, so we've set the menu to
		// use Ctrl-Shift-3 for it here.
		if (pEditMenu->FindItem(ID_EDIT_MOVE_NOTE_FORWARD) != NULL)
		{
			pEditMenu->SetLabel(ID_EDIT_MOVE_NOTE_FORWARD,_("Move Note Forward\tCtrl-Shift-3"));
		}
	}

	wxMenu* pToolsMenu = GetTopLevelMenuFromAIMenuBar(toolsMenu);
	if(pToolsMenu != NULL)
	{
		// Tools | Find and Replace
		// On Mac, the hot key command to Hide the Active Window (close) is Command-H, and we have set a
		// Ctrl-Shift-F accelerator key to be associated with Edit | Find and Replace, so we've set the
		// menu to use Ctrl-Shift-F for it here.
		if (pToolsMenu->FindItem(wxID_REPLACE) != NULL)
		{
			pToolsMenu->SetLabel(wxID_REPLACE,_("Find and Replace...\tCtrl-Shift-F"));
		}
	}

	wxMenu* pLayoutMenu = GetTopLevelMenuFromAIMenuBar(layoutMenu);
	if(pLayoutMenu != NULL)
	{
		// Layout | Layout Window Right To Left
		// On Mac, the hot key command to View as Icons is Command-1, and we have set a Ctrl-Shift-1
		// accelerator key to be associated with Layout | Layout Window Right To Left, so we've set the
		// menu to use Ctrl-Shift-1 for it here.
		if (pLayoutMenu->FindItem(ID_ALIGNMENT) != NULL)
		{
			pLayoutMenu->SetLabel(ID_ALIGNMENT,_("Layout Window Right To Left\tCtrl-Shift-1"));
		}
	}

	// wxWidgets moves the wxID_HELP menu item from the Help menu to the Application menu, so we
	// don't assume wxID_HELP is in the Help menu.
	wxMenuItem* pHelpTopicsMenu = (wxMenuItem*)pMenuBar->FindItem(wxID_HELP); // use FindItem() for wxMenuItem
	if (pHelpTopicsMenu != NULL)
	{
		pHelpTopicsMenu->SetItemLabel(_("Help Topics\tCtrl-Shift-/"));
	}

#else
	// wxDesigner's Menubars properties doesn't allow us to set function keys as shortcuts
	// so we'll do it manually here for Windows and Linux.
	wxMenuItem* pHelpTopicsMenu = (wxMenuItem*)pMenuBar->FindItem(wxID_HELP);
	if (pHelpTopicsMenu != NULL)
	{
		pHelpTopicsMenu->SetItemLabel(_("Help Topics\tF1"));
	}

#endif

	// The wxWidgets version has the "Export Target Text As UTF-8..." Menu Item on
	// the File Menu and the Layout Menu as a top level menu in the AIMenuBarFunc() menu
	// resource. With wxDesigner handling resources, it's easier to start with the item
	// in the menu and programmatically delete it, rather than create it from scratch.
	// So, for ANSI version, we'll just remove them from the MenuBar.
#ifndef _UNICODE
	// ANSI only
	// In the wx version we started with the Layout menu loaded with
	// other menu resources. Here we'll remove it for the ANSI version.
	wxMenu* pLayoutMenu = GetTopLevelMenuFromAIMenuBar(layoutMenu);
	if(pLayoutMenu != NULL)
	{
		// first delete the "Layout Window Right To Left\tCTRL+1" menu item
		// Note: In the current profile, this item may not exist, so only
		// call Remove if it exists!
		if (pLayoutMenu->FindItem(ID_ALIGNMENT) != NULL)
		{
			wxMenuItem* pRemMenuItem;
			pRemMenuItem = pLayoutMenu->Remove(ID_ALIGNMENT);
			wxASSERT(pRemMenuItem != NULL);
			delete pRemMenuItem; // to avoid memory leaks
			pRemMenuItem = (wxMenuItem*)NULL;
		}
		// then delete the top level "Layout" menu
		wxMenu* pRemMenu;
		pRemMenu = pMenuBar->Remove(layoutMenu);
		wxASSERT(pRemMenu != NULL);
		delete pRemMenu; // to avoid memory leaks
		pRemMenu = (wxMenu*)NULL;
	}
#else
	// Unicode version

	// Initialize the Layout menu to LTR
	CAdapt_ItView* pView = GetView();
	gbLTRLayout = TRUE;
	gbRTLLayout = FALSE; // default is LTR layout
	if (gpApp->m_bSrcRTL == TRUE && gpApp->m_bTgtRTL == TRUE)
	{
		gbLTRLayout = FALSE; // use these to set layout direction on user's behalf, when possible
		gbRTLLayout = TRUE;
	}
	else if (gpApp->m_bSrcRTL == FALSE && gpApp->m_bTgtRTL == FALSE)
	{
		gbLTRLayout = TRUE; // use these to set layout direction on user's behalf, when possible
		gbRTLLayout = FALSE;
	}
	if (pView != NULL)
	{
		pView->AdjustAlignmentMenu(gbRTLLayout, gbLTRLayout); // fix the menu, if necessary
		// Note: AdjustAlignmentMenu above also sets the m_bRTL_Layout to match gbRTL_Layout
	}

#endif

    // These toggle menu items should be initially set as follows (TRUE=checked;
    // FALSE=unchecked):
    // whm modified 28Jul11. This MakeMenuInitializationsAndPlatformAdjustments()
    // function can now be called from places other than from OnInit(). Therefore,
    // the menu toggle items below should be set not to absolute initial values
    // but to values that reflect the current state of the GUI elements they
    // describe.
    if (pMenuBar->FindItem(ID_VIEW_TOOLBAR) != NULL)
		pMenuBar->Check(ID_VIEW_TOOLBAR, m_bToolBarVisible); // whm modified 6Jan12
    if (pMenuBar->FindItem(ID_VIEW_STATUS_BAR) != NULL)
		pMenuBar->Check(ID_VIEW_STATUS_BAR, m_bStatusBarVisible); // whm modified 6Jan12
    if (pMenuBar->FindItem(ID_VIEW_COMPOSE_BAR) != NULL)
		pMenuBar->Check(ID_VIEW_COMPOSE_BAR, pMainFrame->m_pComposeBar != NULL);
    if (pMenuBar->FindItem(ID_VIEW_MODE_BAR) != NULL)
		pMenuBar->Check(ID_VIEW_MODE_BAR, this->m_bModeBarVisible); // whm added 6Jan12
    if (pMenuBar->FindItem(ID_COPY_SOURCE) != NULL)
		pMenuBar->Check(ID_COPY_SOURCE, m_bCopySource);
    if (pMenuBar->FindItem(ID_MARKER_WRAPS_STRIP) != NULL)
		pMenuBar->Check(ID_MARKER_WRAPS_STRIP, m_bMarkerWrapsStrip);
    if (pMenuBar->FindItem(ID_USE_CC) != NULL)
		pMenuBar->Check(ID_USE_CC, m_bUseConsistentChanges);
	if (pMenuBar->FindItem(ID_ACCEPT_CHANGES) != NULL)
		pMenuBar->Check(ID_ACCEPT_CHANGES, m_bAcceptDefaults);
	if (pMenuBar->FindItem(ID_USE_SILCONVERTER) != NULL) // whm added 28Jul11
		pMenuBar->Check(ID_USE_SILCONVERTER, m_bUseSilConverter);
	if (pMenuBar->FindItem(ID_TOOLS_AUTO_CAPITALIZATION) != NULL) // whm added 28Jul11
		pMenuBar->Check(ID_TOOLS_AUTO_CAPITALIZATION, gbAutoCaps);
	if (pMenuBar->FindItem(ID_ADVANCED_SEE_GLOSSES) != NULL)
		pMenuBar->Check(ID_ADVANCED_SEE_GLOSSES, gbGlossingVisible);
	if (pMenuBar->FindItem(ID_ADVANCED_GLOSSING_USES_NAV_FONT) != NULL)
		pMenuBar->Check(ID_ADVANCED_GLOSSING_USES_NAV_FONT, gbGlossingUsesNavFont);
	if (pMenuBar->FindItem(ID_ADVANCED_BOOKMODE) != NULL) // whm added 28Jul11
		pMenuBar->Check(ID_ADVANCED_BOOKMODE, m_bBookMode);
	if (pMenuBar->FindItem(ID_ADVANCED_FREE_TRANSLATION_MODE) != NULL) // whm added 28Jul11
		pMenuBar->Check(ID_ADVANCED_FREE_TRANSLATION_MODE, m_bFreeTranslationMode);
	if (pMenuBar->FindItem(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT) != NULL) // whm added 28Jul11
		pMenuBar->Check(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT, m_bTargetIsDefaultFreeTrans);
	if (pMenuBar->FindItem(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT) != NULL) // whm added 28Jul11
		pMenuBar->Check(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT, m_bGlossIsDefaultFreeTrans);
	if (pMenuBar->FindItem(ID_ADVANCED_USETRANSLITERATIONMODE) != NULL) // whm added 28Jul11
		pMenuBar->Check(ID_ADVANCED_USETRANSLITERATIONMODE, m_bTransliterationMode);
	if (pMenuBar->FindItem(ID_ADVANCED_SENDSYNCHRONIZEDSCROLLINGMESSAGES) != NULL) // whm added 28Jul11
		pMenuBar->Check(ID_ADVANCED_SENDSYNCHRONIZEDSCROLLINGMESSAGES, !gbIgnoreScriptureReference_Send);
	if (pMenuBar->FindItem(ID_ADVANCED_RECEIVESYNCHRONIZEDSCROLLINGMESSAGES) != NULL) // whm added 28Jul11
		pMenuBar->Check(ID_ADVANCED_RECEIVESYNCHRONIZEDSCROLLINGMESSAGES, !gbIgnoreScriptureReference_Receive);
	// whm added 20Jul11 to initialize the View menu's "Show Administrator Menu... (Password protected)" item
	if (pMenuBar->FindItem(ID_VIEW_SHOW_ADMIN_MENU) != NULL)
		pMenuBar->Check(ID_VIEW_SHOW_ADMIN_MENU,m_bShowAdministratorMenu);
	if (pMenuBar->FindItem(ID_MENU_TEMP_TURN_OFF_CURRENT_PROFILE) != NULL)
		pMenuBar->Check(ID_MENU_TEMP_TURN_OFF_CURRENT_PROFILE,m_bTemporarilyRestoreProfilesToDefaults); // whm added 14Feb12
	//if (pMenuBar->FindItem(ID_PASSWORD_PROTECT_COLLAB_SWITCHING) != NULL) // whm added 2Feb12
	//	pMenuBar->Check(ID_PASSWORD_PROTECT_COLLAB_SWITCHING,m_bPwdProtectCollabSwitching);
    // ensure that the Use Tooltips menu item in the Help menu is checked or unchecked
    // according to the current value of m_bUseToolTips
	if (pMenuBar->FindItem(ID_HELP_USE_TOOLTIPS) != NULL)
		pMenuBar->Check(ID_HELP_USE_TOOLTIPS,m_bUseToolTips);
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnInit() after the external XML file AI_UserProfiles.xml has
/// been successfully read. This function does not re-read the raw data from the
/// arrays nor the external file, but "reads" the data from the pTempUserProfiles and
/// m_pUserProfiles created on the heap. The pTempUserProfiles is created by the
/// SetupDefaultUserProfiles() function from the internal unix-like default strings.
/// It then reports any inconsistencies to the developer in the form of wxLogDebug()
/// outputs for each inconsistency found. It only displays the wxLogDebug messages
/// and a few wxASSERT_MSG() messages in debug mode, so this function doesn't issue
/// any messages to the user in the release version; it merely exists to help the
/// developer know of any inconsistencies and what they are.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ReportMenuAndUserProfilesInconsistencies()
{
	// get temporary data structures from the internal unix-like strings
	UserProfiles* pTempUserProfiles; // destroyed at end of this function
	pTempUserProfiles = (UserProfiles*)NULL;

	SetupDefaultUserProfiles(pTempUserProfiles); // creates a new UserProfiles on heap pointed to by pTempUserProfiles; calls GetAndAssignIdValuesToUserProfilesStruct()

	// First make sure we have good pointers
	if (pTempUserProfiles == NULL)
	{
		wxLogDebug(_T("The pointer to the internal UserProfiles is NULL\n -   aborting the ReportMenuAndUserProfilesInconsistencies() function"));
		return;
	}
	if (m_pUserProfiles == NULL)
	{
		wxLogDebug(_T("The pointer to the App's m_pUserProfiles is NULL\n -   aborting the ReportMenuAndUserProfilesInconsistencies() function"));
		return;
	}

	// compare the profile version
	// Note: When an administrator customizes a given profile we expect that the following things
	// will be different between our internal values and the external xml file:
	//    1. The adminModified attribute will have the value of "Yes".
	//    2. The usedVisibilityValues changed when an admin edits the profiles and clicks OK, regardless of
	//       whether the edits were done to the currently selected profile.
	//    3. The descriptionProfileTexts. These are editable by the admin.
	// Note: The definedProfileNames would not normally be edited unless the admin manually
	// attempts to change or localize the names of the profiles/tabs.

	bool bVersionsDiffer = FALSE;
	// we need to ensure that the app's version (6.x.x) and the app's profile version (1.x)
	// agree with the data in the unix-like default strings (here it is in pTempUserProfiles).
	wxString appVerOfRunningApp = GetAppVersionOfRunningAppAsString();
	wxString profVerOfRunningApp = GetProfileVersionOfRunningAppAsString();
	if (pTempUserProfiles->profileVersion != profVerOfRunningApp)
	{
		bVersionsDiffer = TRUE;
		wxString msg;
		msg = _T("The app's defaultProfileItems[] and the app's PROFILE_VERSION_MAJOR_PART.PROFILE_VERSION_MINOR_PART have different profile versions %s and %s PLEASE FIX ME!");
		msg = msg.Format(msg,pTempUserProfiles->profileVersion.c_str(),profVerOfRunningApp.c_str());
		wxLogDebug(msg);
		wxASSERT_MSG(FALSE,msg);
	}

	if (pTempUserProfiles->applicationCompatibility != appVerOfRunningApp)
	{
		bVersionsDiffer = TRUE;
		wxString msg;
		msg = _T("The app's defaultProfileItems[] and the app's VERSION_MAJOR_PART.VERSION_MINOR_PART.VERSION_BUILD_PART have different compatibility versions %s and %s PLEASE FIX ME!");
		msg = msg.Format(msg,pTempUserProfiles->applicationCompatibility.c_str(),appVerOfRunningApp.c_str());
		wxLogDebug(msg);
		wxASSERT_MSG(FALSE,msg);
	}

	if (pTempUserProfiles->profileVersion != m_pUserProfiles->profileVersion)
	{
		bVersionsDiffer = TRUE;
		wxLogDebug(_T("The internal and external profileVersions have different versions %s and %s"),
			pTempUserProfiles->profileVersion.c_str(),m_pUserProfiles->profileVersion.c_str());
	}
	if (pTempUserProfiles->applicationCompatibility != m_pUserProfiles->applicationCompatibility)
	{
		bVersionsDiffer = TRUE;
		wxLogDebug(_T("The internal and external applicationCompatibility have different versions %s and %s"),
			pTempUserProfiles->applicationCompatibility.c_str(),m_pUserProfiles->applicationCompatibility.c_str());
	}
	if (pTempUserProfiles->adminModified != m_pUserProfiles->adminModified)
	{
		bVersionsDiffer = TRUE;
		wxLogDebug(_T("The internal and external adminModified have different values %s and %s"),
			pTempUserProfiles->adminModified.c_str(),m_pUserProfiles->adminModified.c_str());
	}
	// compare the number of elements - they should always be the same
	if (pTempUserProfiles->definedProfileNames.GetCount() != m_pUserProfiles->definedProfileNames.GetCount())
	{
		wxLogDebug(_T("The internal and external definedProfileNames arrays have different count %d and %d PLEASE FIX ME!"),
			pTempUserProfiles->definedProfileNames.GetCount(),m_pUserProfiles->definedProfileNames.GetCount());
	}
	if (pTempUserProfiles->descriptionProfileTexts.GetCount() != m_pUserProfiles->descriptionProfileTexts.GetCount())
	{
		wxLogDebug(_T("The internal and external descriptionProfileTexts arrays have different count %d and %d PLEASE FIX ME!"),
			pTempUserProfiles->descriptionProfileTexts.GetCount(),m_pUserProfiles->descriptionProfileTexts.GetCount());
	}
	if (pTempUserProfiles->profileItemList.GetCount() != m_pUserProfiles->profileItemList.GetCount())
	{
		wxLogDebug(_T("The internal and external profileItemLists have different count %d and %d PLEASE FIX ME!"),
			pTempUserProfiles->profileItemList.GetCount(),m_pUserProfiles->profileItemList.GetCount());
	}

	// Check for changes in their text and usedVisibilityValues arrays, but only assuming they have the same
	// counts.
	if (pTempUserProfiles->definedProfileNames.GetCount() == m_pUserProfiles->definedProfileNames.GetCount())
	{
		int ct;
		int tot;
		tot = (int)pTempUserProfiles->definedProfileNames.GetCount();
		for (ct = 0; ct < tot; ct++)
		{
			wxString tempStr, appStr;
			tempStr = pTempUserProfiles->definedProfileNames.Item(ct);
			appStr = m_pUserProfiles->definedProfileNames.Item(ct);
			if (pTempUserProfiles->definedProfileNames.Item(ct) != m_pUserProfiles->definedProfileNames.Item(ct))
			{
				wxLogDebug(_T("The internal and external definedProfileNames arrays have different names\n   %s and %s PLEASE FIX ME!"),
					tempStr.c_str(),appStr.c_str());
			}
		}
	}
	if (pTempUserProfiles->descriptionProfileTexts.GetCount() == m_pUserProfiles->descriptionProfileTexts.GetCount())
	{
		int ct;
		int tot;
		tot = (int)pTempUserProfiles->descriptionProfileTexts.GetCount();
		for (ct = 0; ct < tot; ct++)
		{
			wxString tempStr, appStr, verStr, msg;
			tempStr = pTempUserProfiles->descriptionProfileTexts.Item(ct);
			appStr = m_pUserProfiles->descriptionProfileTexts.Item(ct);
			if (tempStr != appStr)
			{
				if (bVersionsDiffer)
				{
					verStr = _T("Note: Versions Differ.");
					msg = msg.Format(_T("The internal and external descriptionProfileTexts arrays have different descriptions\n   %s and %s %s"),tempStr.c_str(),appStr.c_str(),verStr.c_str());
				}
				else
				{
					verStr = _T("Note: Same Versions! PLEASE FIX ME!");
					msg = msg.Format(_T("The internal and external descriptionProfileTexts arrays have different descriptions\n   %s and %s %s"),tempStr.c_str(),appStr.c_str(),verStr.c_str());
				}

				wxLogDebug(msg);
			}
		}
	}
	if (pTempUserProfiles->profileItemList.GetCount() == m_pUserProfiles->profileItemList.GetCount())
	{
		ProfileItemList::Node* posTemp;
		ProfileItemList::Node* posApp;
		int count;
		int item_count = (int)pTempUserProfiles->profileItemList.GetCount();
		for(count = 0; count < item_count; count++)
		{
			posTemp = pTempUserProfiles->profileItemList.Item(count);
			posApp = m_pUserProfiles->profileItemList.Item(count);
			UserProfileItem* pTempItem;
			UserProfileItem* pAppItem;
			pTempItem = posTemp->GetData();
			pAppItem = posApp->GetData();
			if (pTempItem->itemID != pAppItem->itemID)
			{
				// The itemID is the most crucial/unique identifier so ensure they match and are in
				// the same order.
				wxString tempStr = pTempItem->itemID;
				wxString appStr = pAppItem->itemID;
				wxLogDebug(_T("The itemID strings differ for %s: internal (%s) and external (%s)\n   - Are they spelled the same and in the same order?\n -   aborting the ReportMenuAndUserProfilesInconsistencies() function"),
					pAppItem->itemText.c_str(),tempStr.c_str(),appStr.c_str());
				wxASSERT_MSG(FALSE,_T("AI_UserProfile.xml and internal itemID strings in defaultProfileItems[] don't match. Are they spelled the same and in the same order? PLEASE FIX ME!"));
				return; // no point in continuing the check
			}

			if (pTempItem->itemIDint != pAppItem->itemIDint)
			{
				// The itemIDint is also a crucial/unique identifier so ensure they match and are in
				// the same order.
				wxLogDebug(_T("The itemID strings differ for %s: internal (%d) and external (%d)\n   -   aborting the ReportMenuAndUserProfilesInconsistencies() function"),
					pAppItem->itemText.c_str(),pTempItem->itemIDint,pAppItem->itemIDint);
				wxASSERT_MSG(FALSE,_T("AI_UserProfile.xml and internal itemIDint values don't match. PLEASE FIX ME!"));
				return; // no point in continuing the check
			}

			if (pTempItem->itemText  != pAppItem->itemText)
			{
				wxString tempStr = pTempItem->itemText;
				wxString appStr = pAppItem->itemText;
				wxString verStr;
				if (bVersionsDiffer)
				{
					verStr = _T("Note: Versions Differ.");
				}
				else
				{
					verStr = _T("Note: Same Versions! PLEASE FIX ME!");
				}
				wxString msg;
				msg = msg.Format(_T("The internal and external itemText strings differ for itemID: %s\n   (%s) and (%s) %s"),
							pTempItem->itemID.c_str(),tempStr.c_str(),appStr.c_str(),verStr.c_str());
				wxLogDebug(msg);
			}
			if (pTempItem->itemDescr != pAppItem->itemDescr)
			{
				wxString tempStr = pTempItem->itemDescr;
				wxString appStr = pAppItem->itemDescr;
				wxLogDebug(_T("The internal and external itemDescr strings differ for itemID: %s (%s) and (%s) PLEASE FIX ME!"),
					pTempItem->itemID.c_str(),tempStr.c_str(),appStr.c_str());
			}
			if (pTempItem->itemType  != pAppItem->itemType)
			{
				// differences here would result in an item not showing in the list (for an itemType typo)
				// or not being listed in the appropriate category (for a recognized but incorrect itemType).
				wxString tempStr = pTempItem->itemType;
				wxString appStr = pAppItem->itemType;
				wxLogDebug(_T("The internal and external itemType value differs for itemID: %s (%s) and (%s) PLEASE FIX ME!"),
					pTempItem->itemID.c_str(),tempStr.c_str(),appStr.c_str());
			}
			if (pTempItem->adminCanChange != pAppItem->adminCanChange)
			{
				// differences here may result in an item unexpectedly showing/not showing in the list
				wxString tempStr = pTempItem->adminCanChange;
				wxString appStr = pAppItem->adminCanChange;
				wxLogDebug(_T("The internal and external adminCanChange value differs for itemID: %s (%s) and (%s) PLEASE FIX ME!"),
					pTempItem->itemID.c_str(),tempStr.c_str(),appStr.c_str());
			}
			int ct;
			int totCt;
			totCt = (int)pTempItem->usedVisibilityValues.GetCount();
			for (ct = 0; ct < totCt; ct++)
			{
				if (pTempItem->usedProfileNames.Item(ct) != pAppItem->usedProfileNames.Item(ct))
				{
					wxString tempStr = pTempItem->usedProfileNames.Item(ct);
					wxString appStr = pAppItem->usedProfileNames.Item(ct);
					wxLogDebug(_T("The internal and external usedProfileNames differ for itemID: %s (%s) and (%s) PLEASE FIX ME!"),
						pTempItem->itemID.c_str(),tempStr.c_str(),appStr.c_str());
				}
				// Note: The usedProfileNames should always correspond to the definedProfileNames in the
				// top level UserProfilesSupport tag's definedProfileN attributes. Therefore we not only
				// check for consistency between the internal and external ones (above), but also that they
				// match the defined names (see next 2 tests).
				if (pTempItem->usedProfileNames.Item(ct) != pTempUserProfiles->definedProfileNames.Item(ct))
				{
					wxString tempStrUsed = pTempItem->usedProfileNames.Item(ct);
					wxString tempStrDefined = pTempUserProfiles->definedProfileNames.Item(ct);
					wxLogDebug(_T("The internal usedProfileNames differs from the defined Names for itemID: %s (%s) and (%s) PLEASE FIX ME!"),
						pTempItem->itemID.c_str(),tempStrUsed.c_str(),tempStrDefined.c_str());
				}
				if (pAppItem->usedProfileNames.Item(ct) != m_pUserProfiles->definedProfileNames.Item(ct))
				{
					wxString appStrUsed = pAppItem->usedProfileNames.Item(ct);
					wxString appStrDefined = m_pUserProfiles->definedProfileNames.Item(ct);
					wxLogDebug(_T("The internal usedProfileNames differs from the defined Names for itemID: %s (%s) and (%s) PLEASE FIX ME!"),
						pTempItem->itemID.c_str(),appStrUsed.c_str(),appStrDefined.c_str());
				}
				if (pTempItem->usedVisibilityValues.Item(ct) != pAppItem->usedVisibilityValues.Item(ct))
				{
					// These usedVisibility values are the main items we expect to be different so only
					// report inconsistencies when the versions are the same
					if (!bVersionsDiffer)
					{
						wxString tempStr = pTempItem->usedVisibilityValues.Item(ct);
						wxString appStr = pAppItem->usedVisibilityValues.Item(ct);
						wxLogDebug(_T("The internal and external usedVisibilityValues differ for itemID: %s (%s) and (%s)"),
							pTempItem->itemID.c_str(),tempStr.c_str(),appStr.c_str());
					}
				}
				if (pTempItem->usedFactoryValues.Item(ct) != pAppItem->usedFactoryValues.Item(ct))
				{
					wxString tempStr = pTempItem->usedFactoryValues.Item(ct);
					wxString appStr = pAppItem->usedFactoryValues.Item(ct);
					wxLogDebug(_T("The internal and external usedFactoryValues differ for itemID: %s (%s) and (%s) PLEASE FIX ME!"),
						pTempItem->itemID.c_str(),tempStr.c_str(),appStr.c_str());
				}
			}
		}
	}

	DestroyUserProfiles(pTempUserProfiles);
}


/* This function is currently unused (and possibly untested/incomplete) but might be useful in the future
bool CAdapt_ItApp::MenuItemExistsInAIMenuBar(wxString mainMenuLabel, wxString subMenuLabel, wxString itemKind)
{
	if (itemKind == _T("wxITEM_SEPARATOR"))
	{
		// do not confirm existence of menuSeparator items
		return FALSE;
	}
	bool bItemExists = FALSE;
	CMainFrame* pMainFrame = GetMainFrame();
	wxMenuBar* pMenuBar = pMainFrame->GetMenuBar();
	int mCt;
	int nMenuItems = pMenuBar->GetMenuCount();
	for (mCt = 0; mCt < nMenuItems; mCt++)
	{
		wxMenu* pMainMenu = pMenuBar->GetMenu(mCt);
		wxString mmLabel = pMenuBar->GetMenuLabel(mCt);
		if (mmLabel != mainMenuLabel)
		{
			// we're not in the right top level menu
			continue;
		}
		wxASSERT(pMainMenu != NULL);
		wxMenuItemList pMenuItemList = pMainMenu->GetMenuItems();
		int smCt;
		int nSubMenuItems = (int)pMenuItemList.GetCount();
		for (smCt = 0; smCt < nSubMenuItems; smCt++)
		{
			wxMenuItemList::Node* pNode;
			wxMenuItem* pMenuItem;
			pNode = pMenuItemList.Item(smCt);
			pMenuItem = pNode->GetData();
			wxString smKindStr;
			wxItemKind smKind = pMenuItem->GetKind();
			smKindStr = GetMenuItemKindAsString(smKind);

			// Note: Using GetItemLabel() is supposed to preserve any & and Ctrl-key accelerator characters.
			// Testing shows that it only partially does so - the \t character that separates the label from
			// the Ctrl-key part is a literal whitespace tab. To achieve more reliable comparisons, it is best
			// that we compare menu labels after removing both the & and any \tCtrl-key or Ctrl-key characters
			// from menu labels.
			wxString smLabel = pMenuItem->GetItemLabelText(); // GetItemLabelText removes any & and \tCtrl-key accelerator chars
			wxString subMenuLabelPlain = subMenuLabel;
			subMenuLabelPlain = RemoveMenuLabelDecorations(subMenuLabelPlain); // removes any & chars for comparison
			int nTest;
			nTest = subMenuLabelPlain.Find(_T("\\t"));
			if (subMenuLabelPlain.Find(_T("\\t")) != wxNOT_FOUND) // must use "\\t" since it is a string representation only
			{
				// there is a tab char in the menu label, so remove from that point to remainder of string
				subMenuLabelPlain = subMenuLabelPlain.Left(subMenuLabelPlain.Find(_T("\\t")));
			}
			else
			{
				// there is no tab char in the label. Check for "Ctrl-" or "Shift-"
				if (subMenuLabelPlain.Find(_T("Ctrl-")) != wxNOT_FOUND)
				{
					subMenuLabelPlain = subMenuLabelPlain.Left(subMenuLabelPlain.Find(_T("Ctrl-")));
				}
				else if (subMenuLabelPlain.Find(_T("Shift-")) != wxNOT_FOUND)
				{
					subMenuLabelPlain = subMenuLabelPlain.Left(subMenuLabelPlain.Find(_T("Shift-")));
				}
			}
			if (smLabel == subMenuLabelPlain && smKindStr == itemKind)
			{
				bItemExists = TRUE;
				return bItemExists;
			}
		}
	}


	return bItemExists;
}
*/

//////////////////////////////////////////////////////////////////////////////////////////
/// \return    TRUE if menuItemIDint is supposed to be visible in this nProfile, FALSE otherwise
/// \param      -> nProfile   the user workflow profile (zero based), i.e., m_nWorkflowProfile
/// \param      -> menuItemIDint the int representation of the menu item's ID
/// \remarks
/// Called from: the App's ConfigureMenuBarForUserProfile().
/// Determines whether the menu item represented in menuItemIDint is supposed to be visible in
/// the interface for the user profile passed in as nProfile. Looks up the menuItemIDint in
/// the m_pUserProfiles data struct stored on the heap. Note: this function depends on valid
/// values being assigned to the UserProfiles struct's itemIDInt attribute by a call to
/// GetAndAssignIdValuesToUserProfilesStruct().
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::MenuItemIsVisibleInThisProfile(const int nProfile, const int menuItemIDint)
{
	// we assume that a menu item is visible unless the m_pUserProfiles data
	// indicates otherwise.
	bool bItemIsVisible = TRUE;
	if (nProfile == 0)
	{
		// The work flow profile 0 (zero) is the "None" selection all all interface
		// items are visible by default
		return bItemIsVisible;
	}
	int ct;
	int totct;
	totct = (int)m_pUserProfiles->profileItemList.GetCount();
	for (ct = 0; ct < totct; ct++)
	{
		UserProfileItem* pUserProfileItem;
		ProfileItemList::Node* node;
		node = m_pUserProfiles->profileItemList.Item(ct);
		pUserProfileItem = node->GetData();
		wxASSERT(pUserProfileItem != NULL);
		if (menuItemIDint == wxID_SEPARATOR) // the value of wxID_SEPARATOR is -2
		{
			// We return TRUE for menuSeparators since they are visible when present.
			return TRUE;
		}
		if (pUserProfileItem->itemType != _T("subMenu")) // we are only checking for subMenu items
		{
			continue;
		}
		int itemIDint;
		itemIDint = pUserProfileItem->itemIDint; //itemID;
		int indexFromProfile = 0;
		if (nProfile <= 0)
			indexFromProfile = 0;
		else if (nProfile > 0)
			indexFromProfile = nProfile - 1;
		if (itemIDint == menuItemIDint && pUserProfileItem->usedVisibilityValues.Item(indexFromProfile) == _T("0"))
		{
			return FALSE;
		}
	}
	return bItemIsVisible;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return    TRUE if itemLabel is supposed to be visible in this nProfile, FALSE otherwise
/// \param      -> nProfile   the user workflow profile (zero based), i.e., m_nWorkflowProfile
/// \param      -> itemLabel the string representation of the mode bar item's text
/// \remarks
/// Called from: the App's RemoveModeBarItemsFromModeBarSizer().
/// Determines whether the mode bar item represented in itemLabel is supposed to be visible in
/// the interface for the user profile passed in as nProfile. Looks up the itemLabel in
/// the m_pUserProfiles data struct stored on the heap and reads the usedVisibilityValues
/// for that item as indexed for the nProfile.
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::ModeBarItemIsVisibleInThisProfile(const int nProfile, const wxString itemLabel)
{
	// we assume that a mode bar item is visible unless the m_pUserProfiles data
	// indicates otherwise.
	bool bItemIsVisible = TRUE;
	if (nProfile == 0)
	{
		// The work flow profile 0 (zero) is the "None" selection and all interface
		// items are visible by default
		return bItemIsVisible;
	}
	int ct;
	int totct;
	totct = (int)m_pUserProfiles->profileItemList.GetCount();
	for (ct = 0; ct < totct; ct++)
	{
		UserProfileItem* pUserProfileItem;
		ProfileItemList::Node* node;
		node = m_pUserProfiles->profileItemList.Item(ct);
		pUserProfileItem = node->GetData();
		wxASSERT(pUserProfileItem != NULL);
		if (pUserProfileItem->itemType != _T("modeBar"))
		{
			continue;
		}
		if (itemLabel == _T("")) // the item is a spacer in the sizer (just before the Glossing wxCheckBox)
		{
			// We skip the processing of the spacer
			continue;
		}
		wxString itemLabelStr;
		itemLabelStr = pUserProfileItem->itemText;
		itemLabelStr.Trim(FALSE);
		itemLabelStr.Trim(TRUE);
		int indexFromProfile = 0;
		if (nProfile <= 0)
			indexFromProfile = 0;
		else if (nProfile > 0)
			indexFromProfile = nProfile - 1;
		if (itemLabelStr == itemLabel && pUserProfileItem->usedVisibilityValues.Item(indexFromProfile) == _T("0"))
		{
			return FALSE;
		}
	}
	return bItemIsVisible;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return    TRUE if itemLabel is supposed to be visible in this nProfile, FALSE otherwise
/// \param      -> nProfile   the user workflow profile (zero based), i.e., m_nWorkflowProfile
/// \param      -> itemLabel the string representation of the tool bar item's (short) help text
///                     i.e., the tooltip
/// \remarks
/// Called from: the App's RemoveToolBarItemsFromToolBar().
/// Determines whether the tool bar item represented in itemLabel is supposed to be visible in
/// the interface for the user profile passed in as nProfile. Looks up the itemLabel in
/// the m_pUserProfiles data struct stored on the heap and reads the usedVisibilityValues
/// for that item as indexed for the nProfile.
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::ToolBarItemIsVisibleInThisProfile(const int nProfile, const wxString itemLabel)
{
	// we assume that a tool bar item is visible unless the m_pUserProfiles data
	// indicates otherwise.
	bool bItemIsVisible = TRUE;
	if (nProfile == 0)
	{
		// The work flow profile 0 (zero) is the "None" selection and all interface
		// items are visible by default
		return bItemIsVisible;
	}
	int ct;
	int totct;
	totct = (int)m_pUserProfiles->profileItemList.GetCount();
	for (ct = 0; ct < totct; ct++)
	{
		UserProfileItem* pUserProfileItem;
		ProfileItemList::Node* node;
		node = m_pUserProfiles->profileItemList.Item(ct);
		pUserProfileItem = node->GetData();
		wxASSERT(pUserProfileItem != NULL);
		if (pUserProfileItem->itemType != _T("toolBar"))
		{
			continue;
		}
		if (itemLabel == _T("")) // the item is a separator in the toolbar group
		{
			// We skip the processing of the separator
			continue;
		}
		wxString itemLabelStr;
		itemLabelStr = pUserProfileItem->itemText;
		itemLabelStr.Trim(FALSE);
		itemLabelStr.Trim(TRUE);
		int indexFromProfile = 0;
		if (nProfile <= 0)
			indexFromProfile = 0;
		else if (nProfile > 0)
			indexFromProfile = nProfile - 1;
		if (itemLabelStr == itemLabel && pUserProfileItem->usedVisibilityValues.Item(indexFromProfile) == _T("0"))
		{
			return FALSE;
		}
	}
	return bItemIsVisible;
}


/* This function is currently unused (and incomplete/untested) but might be helpful in the future
//////////////////////////////////////////////////////////////////////////////////////////
/// \return    nothing
/// \param      -> pMainMenuItem   pointer to the main menu item's struct on the heap
/// \param      -> pSubMenuItem    pointer to the sub menu item's struct on the heap
/// \remarks
/// Called from: the App's ConfigureInterfaceForUserProfile().
/// Adds the sub menu item (whose data representation is in pSubMenuItem) to AI's current
/// menu bar. Before calling this function a call to MenuItemIsVisibleInThisProfile() should
/// return TRUE and a call to MenuItemExistsInAIMenuBar() should return FALSE. This function
/// uses the AI_MenuStructure data on the heap to determine the position within the AI menu bar
/// where the sub menu item should be inserted, along with any preceding menu separator.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::AddSubMenuItemToAIMenuBar(AI_MainMenuItem* pMainMenuItem,AI_SubMenuItem* pSubMenuItem)
{
	// Note: All menu items that can be added to the AI menu bar, would have
	// previously been removed and stored within the m_pRemovedMenuItemArray
	// array of pointers to wxMenuItems. We should be able to find the wxMenuItem*
	// in that array that corresponds to pSubMenuItem, and Insert it into the
	// appropriate top level menu corresponding to pMainMenuItem. The relative
	// position where it gets inserted is determined by consulting the
	// AI_MenuStructure data on the heap. Afterwards we also tidy up the menu
	// separators.

	// Verify that pSubMenuItem exists within the m_pRemovedMenuItemArray
	int nIDofSubMenutoAddBack = -1;
	int miCt;
	int miTot;
	wxString subMenuLabelPlain = RemoveMenuLabelDecorations(pSubMenuItem->subMenuLabel);
	wxMenuItem* pMenuItemToAddBack = NULL;
	miTot = m_pRemovedMenuItemArray->GetCount();
	wxASSERT(miTot > 0); // this must be so if we are now adding back wxMenuItems!
	for (miCt = 0; miCt < miTot; miCt++)
	{
		pMenuItemToAddBack = (wxMenuItem*)m_pRemovedMenuItemArray->Item(miCt);
		if (pMenuItemToAddBack->GetLabel() == subMenuLabelPlain)
		{
			nIDofSubMenutoAddBack = pMenuItemToAddBack->GetId();
			break;
		}
	}
	wxASSERT(nIDofSubMenutoAddBack != -1);
	wxASSERT(pMenuItemToAddBack != NULL);

	// Get the menu item out of the removals list
	m_pRemovedMenuItemArray->Remove(pMenuItemToAddBack); // does not delete the object, but removes it from the array
	// We now have the pointer to the wxMenuItem* to be added back to the AI menu
	// in pMenuItemToAddBack, along with its int ID value in nIDofSubMenutoAddBack.

	// Determine in which top level menu pMenuItemToAddBack belongs
	wxMenu* pTopLevelAIMenuToGetItem = NULL; //
	CMainFrame* pMainFrame = GetMainFrame();
	wxMenuBar* pMenuBar = pMainFrame->GetMenuBar();
	int mCt;
	int nMenuItems = pMenuBar->GetMenuCount();
	wxString mmLabel;
	wxASSERT(nMenuItems > 0);
	for (mCt = 0; mCt < nMenuItems; mCt++)
	{
		pTopLevelAIMenuToGetItem = pMenuBar->GetMenu(mCt);
		mmLabel = pMenuBar->GetMenuLabel(mCt);
		if (mmLabel == pMainMenuItem->mainMenuLabel)
		{
			break;
		}
		else
		{
			// we're not in the right top level menu
			continue;
		}
	}
	wxASSERT(pTopLevelAIMenuToGetItem != NULL);

	// Get the list of menu items currently in AI's top level menu
	wxMenuItemList pAIMenuItemList = pTopLevelAIMenuToGetItem->GetMenuItems();

	// Get the list of all menu items in AI_MenuStructure for this top level menu
	wxArrayPtrVoid ItemsOfThisMainMenuStructure;
	ItemsOfThisMainMenuStructure = GetMenuStructureItemsArrayForThisTopLevelMenu(pMainMenuItem);

	// testing below!!!
	// Testing shows that pMenuItemList contains menuSeparators which have empty
	// strings for labels and -1 for wxItemKind; and, for the File menu, also
	// contains separate menu entries for all the file history entries prefixed
	// by a number and a space (1 up to a max of 9).
	{
		int i,tot;
		tot = (int)pAIMenuItemList.GetCount();
		wxMenuItem* pmItem;
		wxMenuItemList::Node* pNode;
		wxLogDebug(_T("AI Current %s Menu items:"),mmLabel.c_str());
		for (i = 0; i < tot; i++)
		{
			pNode = pAIMenuItemList.Item(i);
			pmItem = pNode->GetData();
			wxLogDebug(_T("   %s | %s | %d"),pmItem->GetLabel().c_str(),pmItem->GetHelp().c_str(),pmItem->GetKind());
			;
		}
	}
	// Testing shows that the removed items list does NOT contain
	// menuSeparators, but only the wxMenuItem information.
	// m_pRemovedMenuItemArray, of course, contains removed items
	// from all top level menus, whereas the pMenuItemList above
	// contains the wxMenuItems that belong only to the
	// pMainMenuItem parameter.
	{
		int i,tot;
		tot = (int)m_pRemovedMenuItemArray->GetCount();
		wxLogDebug(_T("Removed Menu items (all menus):"));
		for (i = 0; i < tot; i++)
		{
			wxMenuItem* pmItem;
			pmItem = (wxMenuItem*)m_pRemovedMenuItemArray->Item(i);
			wxLogDebug(_T("   %s | %s | %d"),pmItem->GetLabel().c_str(),pmItem->GetHelp().c_str(),pmItem->GetKind());
			;
		}

	}
	// Testing shows that ItemsOfThisMainMenuStructure contains menuSeparators
	// which have empty strings for labels and wxITEM_SEPARATOR for their item
	// kind. And, for the File menu there, is NO separate menu entries for the
	// file history entries.
	{
		int i,tot;
		tot = (int)ItemsOfThisMainMenuStructure.GetCount();
		wxLogDebug(_T("Top Level %s menu items:"),pMainMenuItem->mainMenuLabel.c_str());
		for (i = 0; i < tot; i++)
		{
			AI_SubMenuItem*  smItem;
			smItem = (AI_SubMenuItem*)ItemsOfThisMainMenuStructure.Item(i);
			wxLogDebug(_T("   %s | %s | %s"),smItem->subMenuLabel.c_str(),smItem->subMenuHelp.c_str(),smItem->subMenuKind.c_str());
			;
		}

	}
	// testing above !!!

	// Our task now is to compare the list called pAIMenuItemList with the void ptr array called
	// ItemsOfThisMainMenuStructure, and figure out where the (parameter) pSubMenuItem should go
	// into the pTopLevelAIMenuToGetItem.
	// TODO: Up to here !!!
	// Plan: Try to fit the following code into the solution.
	bool bInsertionMade = FALSE;
	int nSubMenuItems = (int)pAIMenuItemList.GetCount();
	if (nSubMenuItems == 0)
	{
		// the menu exists but has no items so just append the item where it will
		// be the only item in the list
		pTopLevelAIMenuToGetItem->Insert(0,
							pMenuItemToAddBack->GetId(),
							pMenuItemToAddBack->GetItemLabel(),
							pMenuItemToAddBack->GetHelp(),
							pMenuItemToAddBack->GetKind() );
		bInsertionMade = TRUE;
	}
	else
	{
		// The menu has existing items, so we have to decide where to
		// insert them.
		int smCt;
		for (smCt = 0; smCt < nSubMenuItems; smCt++)
		{
			wxMenuItemList::Node* pNode;
			wxMenuItem* pMenuItemBeingScanned;
			pNode = pAIMenuItemList.Item(smCt);
			pMenuItemBeingScanned = pNode->GetData();
			wxString smKindStr;
			wxItemKind smKind = pMenuItemBeingScanned->GetKind();
			smKindStr = GetMenuItemKindAsString(smKind);
			wxString smLabel = pMenuItemBeingScanned->GetItemLabelText(); // GetItemLabelText removes any & and \tCtrl-key accelerator chars
			wxString subMenuLabelPlain = pSubMenuItem->subMenuLabel;
			subMenuLabelPlain = RemoveMenuLabelDecorations(subMenuLabelPlain);

			// Q. Since the current menubar may already be missing certain menu items in
			// its current profile representation, how do we know where to insert pSubMenuItem?
			// A. We insert the menu item into the current menubar in its relative order
			// as determined by examining the m_pAI_MenuStructure struct on the heap.
			// It is sufficient to insert this item just before the first item known
			// to follow this item in the default menu. To do that we need to query the
			// m_pAI_MenuStructure and get a list of menu items that normally follow
			// pSubMenuItem within that top level menu. The list could have one or more
			// items depending on where pSubMenuItem normally appears in the menu.
			// In our current scan of AI's current menubar, we are comparing the current
			// menubar item with what we found in our queried list of items. When we
			// arrive at any one of those items in the list we insert the pSubMenuItem
			// into the menu at that point. If we get to the end of our current scan
			// through the menu and haven't found any item in the list, or if our list
			// was empty, we simply insert the pSubMenuItem at the end of the menu.
			// Note: We'll take care of inserting any menuSeparators later after having
			// inserted the item in the menu.

			if (smKind != wxITEM_SEPARATOR)
			{
				bool bAppendInsteadOfInsert = FALSE;
				if (AddMenuItemBeforeThisOne(pSubMenuItem, pMenuItemBeingScanned, bAppendInsteadOfInsert))
				{
					// we have found the correct sub menu item to be added before
					if (bAppendInsteadOfInsert)
					{
						pTopLevelAIMenuToGetItem->Append(
											pMenuItemToAddBack->GetId(),
											pMenuItemToAddBack->GetItemLabel(),
											pMenuItemToAddBack->GetHelp(),
											pMenuItemToAddBack->GetKind() );
					}
					else
					{
						pTopLevelAIMenuToGetItem->Insert(smCt,
											pMenuItemToAddBack->GetId(),
											pMenuItemToAddBack->GetItemLabel(),
											pMenuItemToAddBack->GetHelp(),
											pMenuItemToAddBack->GetKind() );
					}
					bInsertionMade = TRUE;
					break;
				}
				else
				{
					// should not get here
					int junk1;
					junk1 = 0;
				}
			}
		} // end of for (smCt = 0; smCt < nSubMenuItems; smCt++)
	}
	int junk;
	junk = 1;

		// TODO: code to insert any needed menu separator
		//if (bInsertionMade)
		//{
		//	// Check for extraneous left-over menu separators in this top level menu
		//	// and delete if found.
		//	// Start at the bottom of the menu and remove all menu separators there.
		//	bool bLastItemWasSeparator = FALSE;
		//	wxMenuItemList::Node* pNode;
		//	wxMenuItem* pMenuItem;
		//	pMenuItemList = pMainMenu->GetMenuItems(); // refresh the list of menu items
		//	pNode = pMenuItemList.GetLast();
		//	while (pNode != NULL)
		//	{
		//		pMenuItem = pNode->GetData();
		//		if (pMenuItem->GetKind() != wxITEM_SEPARATOR)
		//		{
		//			break;
		//		}
		//		else
		//		{
		//			// This menu separator is either the last item on the menu
		//			// or it is the first of two adjacent separators in the menu.
		//			// In either case we delete the current menu separator.
		//			wxMenuItem* pRemMenuItem;
		//			pRemMenuItem = pMainMenu->Remove(pMenuItem);
		//			wxASSERT(pRemMenuItem != NULL);
		//			delete pRemMenuItem; // to avoid memory leaks
		//			pRemMenuItem = (wxMenuItem*)NULL;
		//		}
		//		pNode = pMenuItemList.GetLast();
		//	}
		//	// remove any separators at the top of the top level menu
		//	pMenuItemList = pMainMenu->GetMenuItems(); // refresh the list of menu items
		//	nSubMenuItems = (int)pMenuItemList.GetCount();
		//	pNode = pMenuItemList.GetFirst();
		//	while (pNode != NULL)
		//	{
		//		pMenuItem = pNode->GetData();
		//		if (pMenuItem->GetKind() != wxITEM_SEPARATOR)
		//		{
		//			break;
		//		}
		//		else
		//		{
		//			// This menu separator is at the top of the menu
		//			// so remove it.
		//			wxMenuItem* pRemMenuItem;
		//			pRemMenuItem = pMainMenu->Remove(pMenuItem);
		//			wxASSERT(pRemMenuItem != NULL);
		//			delete pRemMenuItem; // to avoid memory leaks
		//			pRemMenuItem = (wxMenuItem*)NULL;
		//		}
		//		pNode = pMenuItemList.GetFirst();
		//	}
		//
		//	// change any remaining multiple sequences of menu separators to a single separator
		//	pMenuItemList = pMainMenu->GetMenuItems(); // refresh the list of menu items
		//	nSubMenuItems = (int)pMenuItemList.GetCount();
		//	for (smCt = nSubMenuItems - 1; smCt >= 0; smCt--) // process bottom to top of menu
		//	{
		//		pNode = pMenuItemList.Item(smCt);
		//		pMenuItem = pNode->GetData();
		//		wxString smKindStr;
		//		wxItemKind smKind = pMenuItem->GetKind();
		//		if (smKind == wxITEM_SEPARATOR)
		//		{
		//			if (smCt == nSubMenuItems - 1 || bLastItemWasSeparator)
		//			{
		//				// This menu separator is either the last item on the menu
		//				// or it is the first of two adjacent separators in the menu.
		//				// In either case we delete the current menu separator.
		//				wxMenuItem* pRemMenuItem;
		//				pRemMenuItem = pMainMenu->Remove(pMenuItem);
		//				wxASSERT(pRemMenuItem != NULL);
		//				delete pRemMenuItem; // to avoid memory leaks
		//				pRemMenuItem = (wxMenuItem*)NULL;
		//			}
		//			bLastItemWasSeparator = TRUE;
		//		}
		//		else
		//		{
		//			bLastItemWasSeparator = FALSE;
		//		}
		//	}
		//
		//}

	//}
}
*/

/* The following function is currently unused (and incomplete/untested) but might be helpful in the future
//////////////////////////////////////////////////////////////////////////////////////////
/// \return    nothing
/// \param      -> pMainMenuItem   pointer to the main menu item's struct on the heap
/// \param      -> pSubMenuItem    pointer to the sub menu item's struct on the heap
/// \remarks
/// Called from: the App's ConfigureInterfaceForUserProfile().
/// Removes the sub menu item (whose data representation is in pSubMenuItem) from AI's current
/// menu bar. Before calling this function a call to MenuItemIsVisibleInThisProfile() should
/// return FALSE and a call to MenuItemExistsInAIMenuBar() should return TRUE. This function
/// checks the resulting AI menu bar after the deletion of the sub menu item, and removes any
/// left over menu separators that would appear as a double separator or a separator left at
/// the bottom of the top level menu.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::RemoveSubMenuItemFromAIMenuBar(AI_MainMenuItem* pMainMenuItem,AI_SubMenuItem* pSubMenuItem)
{
	CMainFrame* pMainFrame = GetMainFrame();
	wxMenuBar* pMenuBar = pMainFrame->GetMenuBar();
	int mCt;
	int nMenuItems = pMenuBar->GetMenuCount();
	for (mCt = 0; mCt < nMenuItems; mCt++)
	{
		wxMenu* pMainMenu = pMenuBar->GetMenu(mCt);
		wxString mmLabel = pMenuBar->GetMenuLabel(mCt);
		if (mmLabel != pMainMenuItem->mainMenuLabel)
		{
			// we're not in the right top level menu
			continue;
		}
		wxASSERT(pMainMenu != NULL);
		wxMenuItemList pMenuItemList = pMainMenu->GetMenuItems();
		int smCt;
		int nSubMenuItems = (int)pMenuItemList.GetCount();
		bool bDeletionMade = FALSE;
		for (smCt = 0; smCt < nSubMenuItems; smCt++)
		{
			wxMenuItemList::Node* pNode;
			wxMenuItem* pMenuItem;
			pNode = pMenuItemList.Item(smCt);
			pMenuItem = pNode->GetData();
			wxString smKindStr;
			wxItemKind smKind = pMenuItem->GetKind();
			smKindStr = GetMenuItemKindAsString(smKind);
			wxString smLabel = pMenuItem->GetItemLabelText(); // GetItemLabelText removes any & and \tCtrl-key accelerator chars
			wxString subMenuLabelPlain = pSubMenuItem->subMenuLabel;
			subMenuLabelPlain = RemoveMenuLabelDecorations(subMenuLabelPlain);

			if (smLabel == subMenuLabelPlain && smKindStr == pSubMenuItem->subMenuKind)
			{
				// we have found the correct sub menu item to be removed
				wxMenuItem* pRemMenuItem;
				pRemMenuItem = pMainMenu->Remove(pMenuItem);
				wxASSERT(pRemMenuItem != NULL);
				m_pRemovedMenuItemArray->Add((void*)pRemMenuItem); // deleted in OnExit()
				//delete pRemMenuItem; // to avoid memory leaks
				//pRemMenuItem = (wxMenuItem*)NULL;
				bDeletionMade = TRUE;
			}
		} // end of for (smCt = 0; smCt < nSubMenuItems; smCt++)
		if (bDeletionMade)
		{
			// Check for extraneous left-over menu separators in this top level menu
			// and delete if found.
			// Start at the bottom of the menu and remove all menu separators there.
			bool bLastItemWasSeparator = FALSE;
			wxMenuItemList::Node* pNode;
			wxMenuItem* pMenuItem;
			pMenuItemList = pMainMenu->GetMenuItems(); // refresh the list of menu items
			pNode = pMenuItemList.GetLast();
			while (pNode != NULL)
			{
				pMenuItem = pNode->GetData();
				if (pMenuItem->GetKind() != wxITEM_SEPARATOR)
				{
					break;
				}
				else
				{
					// This menu separator is either the last item on the menu
					// or it is the first of two adjacent separators in the menu.
					// In either case we delete the current menu separator.
					wxMenuItem* pRemMenuItem;
					pRemMenuItem = pMainMenu->Remove(pMenuItem);
					wxASSERT(pRemMenuItem != NULL);
					delete pRemMenuItem; // to avoid memory leaks
					pRemMenuItem = (wxMenuItem*)NULL;
				}
				pNode = pMenuItemList.GetLast();
			}
			// remove any separators at the top of the top level menu
			pMenuItemList = pMainMenu->GetMenuItems(); // refresh the list of menu items
			nSubMenuItems = (int)pMenuItemList.GetCount();
			pNode = pMenuItemList.GetFirst();
			while (pNode != NULL)
			{
				pMenuItem = pNode->GetData();
				if (pMenuItem->GetKind() != wxITEM_SEPARATOR)
				{
					break;
				}
				else
				{
					// This menu separator is at the top of the menu
					// so remove it.
					wxMenuItem* pRemMenuItem;
					pRemMenuItem = pMainMenu->Remove(pMenuItem);
					wxASSERT(pRemMenuItem != NULL);
					delete pRemMenuItem; // to avoid memory leaks
					pRemMenuItem = (wxMenuItem*)NULL;
				}
				pNode = pMenuItemList.GetFirst();
			}

			// change any remaining multiple sequences of menu separators to a single separator
			pMenuItemList = pMainMenu->GetMenuItems(); // refresh the list of menu items
			nSubMenuItems = (int)pMenuItemList.GetCount();
			for (smCt = nSubMenuItems - 1; smCt >= 0; smCt--) // process bottom to top of menu
			{
				pNode = pMenuItemList.Item(smCt);
				pMenuItem = pNode->GetData();
				wxString smKindStr;
				wxItemKind smKind = pMenuItem->GetKind();
				if (smKind == wxITEM_SEPARATOR)
				{
					if (smCt == nSubMenuItems - 1 || bLastItemWasSeparator)
					{
						// This menu separator is either the last item on the menu
						// or it is the first of two adjacent separators in the menu.
						// In either case we delete the current menu separator.
						wxMenuItem* pRemMenuItem;
						pRemMenuItem = pMainMenu->Remove(pMenuItem);
						wxASSERT(pRemMenuItem != NULL);
						delete pRemMenuItem; // to avoid memory leaks
						pRemMenuItem = (wxMenuItem*)NULL;
					}
					bLastItemWasSeparator = TRUE;
				}
				else
				{
					bLastItemWasSeparator = FALSE;
				}
			}

		}
	}
}
*/

/* The following function is currently unused (and untested/incomplete) but might be useful in the future
//////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if pMenuItemComingNext normally follows immediately after pMenuItemToAdd
/// \param      -> pMenuItemToAdd      the menu item to be inserted in the menu
/// \param      -> pMenuItemComingNext the menu item before which pMenuItemToAdd should go
/// \remarks
/// Called from: the App's AddSubMenuItemToAIMenuBar().
/// This function is used as a test in the AddSubMenuItemToAIMenuBar() function. It is
/// called from code that is scanning down a given menu of menu items from top to bottom.
/// It determines if the menu item represented by pMenuItemToAdd should be inserted in the
/// menu just before the menu item represented by pMenuItemComingNext, or appended to the
/// end of the menu. When this function is called, the AI Menubar and its menus may have
/// had many of its normal menu items previously removed (depending on the currently
/// active user profile). Hence, this function consults the default menu structure
/// represented in m_pAI_MenuStructure to see where the pMenuItemToAdd would normally
/// appear within the full default menus. The caller will actually add the
/// pMenuItemToAdd to the menu. This function merely determines if it should be
/// inserted before pMenuItemComingNext or appended to the end of the menu.
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::AddMenuItemBeforeThisOne(AI_SubMenuItem* pMenuItemToAdd,
											wxMenuItem* pMenuItemComingNext,
											bool& bAppendInsteadOfInsert)
{
	bool bComesPrior = FALSE;

	// First, get the top level menu in the menu structure where pMenuItemToAdd is located.
	wxString topLevelMenuOfItemToAdd = GetTopLevelMenuLabelForThisSubMenuID(pMenuItemToAdd->subMenuID);
	wxASSERT (!topLevelMenuOfItemToAdd.IsEmpty());

	// Next, look in m_pAI_MenuStructure to get a wxArrayString of the menu item labels
	// that follow pMenuItemToAdd in AI's full default menu structure
	wxArrayString followingMenuItemsArray;
	followingMenuItemsArray = GetMenuItemsThatFollowThisSubMenuID(pMenuItemToAdd->subMenuID,pMenuItemToAdd->subMenuLabel);
	// Note: the followingMenuItemsArray now contains all sub menu item labels and menu
	// separators that normally follow the pMenuItemToAdd menu item. Since it comes from
	// an examination of the m_pAI_MenuStructure, it does not include any file history
	// items (that may show up as items on the File menu).

	// Now, determine if pMenuItemComingNext is contained within the followingMenuItemsArray.
	// If it is, or if the followingMenuItemsArray is empty, we return TRUE for bComesPrior,
	// otherwise FALSE for bComesPrior.
	if (followingMenuItemsArray.IsEmpty())
	{
		bComesPrior = TRUE; // default above was FALSE
		// when the array of menu items is empty it means that there were no other items
		// found following the item being checked, so set the bAppendInsteadOfInsert flag
		// to TRUE so it can be handled appropriately back in the caller
		bAppendInsteadOfInsert = TRUE;
		return bComesPrior;
	}
	else
	{
		// compare items in the array
		int ct;
		int tot;
		tot = (int)followingMenuItemsArray.GetCount();
		wxString itemLabelInArray;
		wxString itemLabelOfwxMenuItem;
		for (ct = 0; ct < tot; ct++)
		{
			itemLabelInArray = followingMenuItemsArray.Item(ct);
			// We have to compare menu labels since pMenuItemComingNext is a wxMenuItem
			// and, while we can query it with GetId() to get its int value, I don't know
			// of any way to get the string equivalent of that int's identifier!
			// We also need to compare the strings without menu decorations.
			// wxMenuItem::GetItemLabelText() gets without any accelerator chars or
			// other decorations. Use this because GetItemLabel() doesn't handle \t correctly.
			itemLabelInArray = this->RemoveMenuLabelDecorations(itemLabelInArray);
			itemLabelOfwxMenuItem = pMenuItemComingNext->GetItemLabelText(); //
			if (itemLabelInArray == itemLabelOfwxMenuItem)
			{
				bComesPrior = TRUE;
				break;
			}
		}
	}
	return bComesPrior;
}
*/

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the menu label in plain text with any & chars
///             and any accelerator/hot key notation such as \tCtrl-S or \tShift-Ctrl-x
///             removed from the incoming menuLabel string
/// \param      -> menuLabel  the string value of the menu label containing any "decorations"
/// \remarks
/// Called from: the App's GetAndAssignIdValuesToUserProfilesStruct(), SetupDefaultMenuStructure(),
/// ConfigureMenuBarForUserProfile() and GetSubMenuItemIdFromAIMenuBar()
/// and from PopulateListBox() and ProfileItemIsSubMenuOfThisMainMenu() in the
/// CAdminEditMenuProfile class.
/// This function is used for comparing menu label strings. It removes any '&' chars as
/// well as any accelerator/hot key strings embedded within the menu label such as
/// \tCtrl-x or \tShift-Ctrl-x. Note: This function detects the presence of both _T("\\t")
/// and _T("\t") in the menuLabel string, and removes all text following those occurrences.
/// The need for detecting both comes from the fact that strings imported from the
/// external AI_UserProfiles.xml file have embedded tabs of the form _T("\\t"). The _T("\\t")
/// form of the string is difficult to detect because they appear as "\t" within the IDE
/// debugger! Menu labels embedded with \\t do not right-align when the menu it shown, but
/// display the \t and its following Ctrl-x string suffixed on the text of the menu label
/// making for a rather ugly menu.
//////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::RemoveMenuLabelDecorations(wxString menuLabel)
{
	wxString tempStr = menuLabel;
	tempStr.Replace(_T("&"),_T(""));
	//int nTest;
	//nTest = tempStr.Find(_T("\\t"));
	if (tempStr.Find(_T("\\t")) != wxNOT_FOUND) // must use "\\t" since it is a string representation only
	{
		// there is a tab char in the menu label, so remove from that point to remainder of string
		tempStr = tempStr.Left(tempStr.Find(_T("\\t")));
	}
	else if (tempStr.Find(_T("\t")) != wxNOT_FOUND) // in case it has "\t" in stead of "\\t")
	{
		// there is a tab char in the menu label, so remove from that point to remainder of string
		tempStr = tempStr.Left(tempStr.Find(_T("\t")));
	}
	else
	{
		// there is no tab char in the label. Check for "Ctrl-" or "Shift-"
		if (tempStr.Find(_T("Ctrl-")) != wxNOT_FOUND)
		{
			tempStr = tempStr.Left(tempStr.Find(_T("Ctrl-")));
		}
		else if (tempStr.Find(_T("Shift-")) != wxNOT_FOUND)
		{
			tempStr = tempStr.Left(tempStr.Find(_T("Shift-")));
		}
	}
	return tempStr;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the string equivalent of the itemKind enum value
/// \param      -> itemKind  the wxItemKind enum value of the menu item
/// \remarks
/// Called from: the App's SetupDefaultMenuStructure().
/// Returns the wxString equivalent of a menu's wxItemKind value.
//////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetMenuItemKindAsString(wxItemKind itemKind)
{
	switch (itemKind)
	{
	case wxITEM_NORMAL:
		return _T("wxITEM_NORMAL");
	case wxITEM_CHECK:
		return _T("wxITEM_CHECK");
	case wxITEM_SEPARATOR:
		return _T("wxITEM_SEPARATOR");
	case wxITEM_RADIO:
		return _T("wxITEM_RADIO");
	default: return _T("wxITEM_NORMAL");
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     the wxItemKind enum value equivalent to the input itemKindStr
/// \param      -> itemKindStr  a wxString in the form of "wxITEM_NORMAL", "wxITEM_SEPARATOR",
///                             "wxITEM_CHECK" or "wxITEM_RADIO".
/// \remarks
/// Called from: the App's ConfigureMenuBarForUserProfile().
/// A convenience function that returns the wxItemKind enum equivalent of the input
/// wxString representation.
//////////////////////////////////////////////////////////////////////////////////////////
wxItemKind CAdapt_ItApp::GetMenuItemKindFromString(wxString itemKindStr)
{
	if (itemKindStr == _T("wxITEM_NORMAL"))
	{
		return wxITEM_NORMAL;
	}
	else if (itemKindStr == _T("wxITEM_SEPARATOR"))
	{
		return wxITEM_SEPARATOR;
	}
	else if (itemKindStr == _T("wxITEM_CHECK"))
	{
		return wxITEM_CHECK;
	}
	else if (itemKindStr == _T("wxITEM_RADIO"))
	{
		return wxITEM_RADIO;
	}
	else
	{
		wxASSERT(FALSE);
		return wxITEM_NORMAL;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the top level menu label corresponding to the
///             top level menu ID (i.e., ID_FILE_MENU). The label returned will
///             still contain any & character for ALT-key access to the menu.
/// \param      -> IDint    the int value representing the top level menu ID
/// \remarks
/// Called from: the App's GetTopLevelMenuName().
/// This function determines the string value that represents the top level menu ID according
/// to the m_pAI_MenuStructure that was populated from the SetupDefaultMenuStructure() function.
/// Note: The default string representations of the top level menus are all localizable as
/// they exist in the AIMenuBarFunc() produced by wxDesigner.
//////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetTopLevelMenuLabelForThisTopLevelMenuID(int IDint)
{
	wxString nullStr = _T("");
	// do a reality check
	wxASSERT(m_pAI_MenuStructure != NULL);
	if (m_pAI_MenuStructure == NULL)
	{
		return nullStr;
	}
	wxString menuLabel;
	MainMenuItemList::Node* mmNode;
	AI_MainMenuItem* pMainMenuItem;
	int ct;
	int nMainMenuItems = (int)m_pAI_MenuStructure->aiMainMenuItems.GetCount();
	for (ct = 0; ct < nMainMenuItems; ct++)
	{
		mmNode = m_pAI_MenuStructure->aiMainMenuItems.Item(ct);
		pMainMenuItem = mmNode->GetData();
		menuLabel = pMainMenuItem->mainMenuLabel;
		if (pMainMenuItem->mainMenuIDint == IDint)
		{
			return menuLabel;
		}
	}
	return nullStr;
}

/* This function is currently unused (and possibly incomplete/untested) but might be useful in the future
// Gets the label of the top level AI menu where the submenu having IDStr is located
// according to the current information stored in the m_pAI_MenuStructure object.
wxString CAdapt_ItApp::GetTopLevelMenuLabelForThisSubMenuID(wxString IDStr)
{
	wxString nullStr = _T("");
	// do a reality check
	wxASSERT(m_pAI_MenuStructure != NULL);
	if (m_pAI_MenuStructure == NULL)
	{
		return nullStr;
	}
	wxString menuLabel;
	MainMenuItemList::Node* mmNode;
	AI_MainMenuItem* pMainMenuItem;
	int ct;
	int nMainMenuItems = (int)m_pAI_MenuStructure->aiMainMenuItems.GetCount();
	for (ct = 0; ct < nMainMenuItems; ct++)
	{
		mmNode = m_pAI_MenuStructure->aiMainMenuItems.Item(ct);
		pMainMenuItem = mmNode->GetData();
		menuLabel = pMainMenuItem->mainMenuLabel;
		SubMenuItemList::Node* smNode;
		AI_SubMenuItem* pSubMenuItem;
		int ct_sm;
		int nSubMenuItems = (int)pMainMenuItem->aiSubMenuItems.GetCount();
		for (ct_sm = 0; ct_sm < nSubMenuItems; ct_sm++)
		{
			smNode = pMainMenuItem->aiSubMenuItems.Item(ct_sm);
			pSubMenuItem = smNode->GetData();
			if (pSubMenuItem->subMenuID == IDStr)
			{
				return menuLabel;
			}
		}
	}
	return nullStr;
}
*/

/* This function is currently unused (and possibly incomplete/untested) but might be useful in the future
// Gets a wxArrayString of the menu item IDs that occur after the menu item
// represented by IDStr within the same top level menu, according to the current
// information stored in the m_pAI_MenuStructure object.
wxArrayString CAdapt_ItApp::GetMenuItemsThatFollowThisSubMenuID(wxString IDStr)
{
	wxArrayString itemArray;
	itemArray.Clear();
	wxString nullStr = _T("");
	// do a reality check
	wxASSERT(m_pAI_MenuStructure != NULL);
	if (m_pAI_MenuStructure == NULL)
	{
		return itemArray; // array will have zero items
	}
	wxString mainMenuLabel;
	wxString sameMenuLabel = _T("");
	MainMenuItemList::Node* mmNode;
	AI_MainMenuItem* pMainMenuItem;
	bool bStartCopying = FALSE;
	int ct;
	int nMainMenuItems = (int)m_pAI_MenuStructure->aiMainMenuItems.GetCount();
	for (ct = 0; ct < nMainMenuItems; ct++)
	{
		mmNode = m_pAI_MenuStructure->aiMainMenuItems.Item(ct);
		pMainMenuItem = mmNode->GetData();
		mainMenuLabel = pMainMenuItem->mainMenuLabel;
		SubMenuItemList::Node* smNode;
		AI_SubMenuItem* pSubMenuItem;
		int ct_sm;
		int nSubMenuItems = (int)pMainMenuItem->aiSubMenuItems.GetCount();
		for (ct_sm = 0; ct_sm < nSubMenuItems; ct_sm++)
		{
			smNode = pMainMenuItem->aiSubMenuItems.Item(ct_sm);
			pSubMenuItem = smNode->GetData();
			if (bStartCopying && mainMenuLabel == sameMenuLabel)
			{
				itemArray.Add(pSubMenuItem->subMenuID);
			}
			if (pSubMenuItem->subMenuID == IDStr)
			{
				bStartCopying = TRUE; //
				sameMenuLabel = mainMenuLabel;
			}
		}
	}
	return itemArray;
}
*/

/* This function is currently unused (and possibly uncomplete/untested) but might be useful in the future
// This is an override of the previous function that gets an array of menu
// labels instead of menu ID strings.
// Gets a wxArrayString of the menu item IDs that occur after the menu item
// represented by IDStr within the same top level menu, according to the current
// information stored in the m_pAI_MenuStructure object.
wxArrayString CAdapt_ItApp::GetMenuItemsThatFollowThisSubMenuID(wxString IDStr, wxString Label)
{
	// the wxString Label paramter is not needed other than to make the signature of this
	// override function be different from the other function that returns an array of ID
	// strings.
	wxArrayString itemArray;
	itemArray.Clear();
	wxString nullStr = _T("");
	// do a reality check
	wxASSERT(m_pAI_MenuStructure != NULL);
	if (m_pAI_MenuStructure == NULL)
	{
		return itemArray; // array will have zero items
	}
	wxString mainMenuLabel;
	wxString sameMenuLabel = _T("");
	MainMenuItemList::Node* mmNode;
	AI_MainMenuItem* pMainMenuItem;
	bool bStartCopying = FALSE;
	int ct;
	int nMainMenuItems = (int)m_pAI_MenuStructure->aiMainMenuItems.GetCount();
	for (ct = 0; ct < nMainMenuItems; ct++)
	{
		mmNode = m_pAI_MenuStructure->aiMainMenuItems.Item(ct);
		pMainMenuItem = mmNode->GetData();
		mainMenuLabel = pMainMenuItem->mainMenuLabel;
		SubMenuItemList::Node* smNode;
		AI_SubMenuItem* pSubMenuItem;
		int ct_sm;
		int nSubMenuItems = (int)pMainMenuItem->aiSubMenuItems.GetCount();
		for (ct_sm = 0; ct_sm < nSubMenuItems; ct_sm++)
		{
			smNode = pMainMenuItem->aiSubMenuItems.Item(ct_sm);
			pSubMenuItem = smNode->GetData();
			if (bStartCopying && mainMenuLabel == sameMenuLabel)
			{
				if (pSubMenuItem->subMenuKind == _T("wxITEM_SEPARATOR"))
					itemArray.Add(_T("menuSeparator"));
				else
					itemArray.Add(pSubMenuItem->subMenuLabel); // Add label rather than ID string
			}
			if (pSubMenuItem->subMenuID == IDStr)
			{
				bStartCopying = TRUE; //
				sameMenuLabel = mainMenuLabel;
			}
		}
	}
	return itemArray;
}
*/

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     an array of pointers of wxMenuItem objects on the heap
/// \param      -> pMainMenuItem    the AI_MainMenuItem struct on the heap whose sub items are
///                                 being collected
/// \remarks
/// Called from: the App's ConfigureMenuBarForUserProfile().
/// This function scans the main menu struct of the default AI menu structure represented
/// in the pMainMenuItem incoming parameter, and collects the pointers of the structs of type
/// AI_SubMenuItem* representing the sub menu items contained in that main menu.
//////////////////////////////////////////////////////////////////////////////////////////
wxArrayPtrVoid CAdapt_ItApp::GetMenuStructureItemsArrayForThisTopLevelMenu(AI_MainMenuItem* pMainMenuItem)
{
	wxArrayPtrVoid itemArray;
	itemArray.Clear();
	wxString nullStr = _T("");
	// do a reality check
	wxASSERT(m_pAI_MenuStructure != NULL);
	if (m_pAI_MenuStructure == NULL)
	{
		return itemArray; // array will have zero items
	}
	wxString mainMenuLabel = pMainMenuItem->mainMenuLabel;
	wxString sameMenuLabel = _T("");
	int ct = 0;
	int nMainMenuItems = (int)m_pAI_MenuStructure->aiMainMenuItems.GetCount();
	AI_MainMenuItem* pmmItem = NULL;
	MainMenuItemList::Node* mmNode = m_pAI_MenuStructure->aiMainMenuItems.GetFirst();
	while (mmNode != NULL && ct < nMainMenuItems)
	{
		pmmItem = mmNode->GetData();
		mmNode = mmNode->GetNext();
		if (pmmItem->mainMenuLabel == mainMenuLabel)
			break;
		ct++;
	}
	wxASSERT(pmmItem != NULL);
	SubMenuItemList::Node* smNode;
	AI_SubMenuItem* pSubMenuItem;
	int ct_sm;
	int nSubMenuItems = (int)pmmItem->aiSubMenuItems.GetCount();
	for (ct_sm = 0; ct_sm < nSubMenuItems; ct_sm++)
	{
		smNode = pmmItem->aiSubMenuItems.Item(ct_sm);
		pSubMenuItem = smNode->GetData();
		itemArray.Add(pSubMenuItem);
	}
	return itemArray;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the menu label of the incoming topLevelMenu enum
/// \param      -> topLevelMenu    the enum of the top level menu whose label we are
///                                 determining
/// \remarks
/// Called from: the App's ConfigureMenuBarForUserProfile() and GetTopLevelMenuFromAIMenuBar().
/// This function determines which string value label is associated (by default) with the
/// enums describing the top level menus in Adapt It.
/// Note: The default string representations of the top level menus are all localizable, but
/// a user could change the labels of AI's top level menus via the AI_UserProfiles.xml file's
/// mainMenuLabel attribute of its MENU_STRUCTURE > MAIN_MENU entires without having to do
/// an entire localization.
//////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetTopLevelMenuName(TopLevelMenu topLevelMenu)
{
	wxASSERT(m_pAI_MenuStructure != NULL);
	wxASSERT(m_pAI_MenuStructure->aiMainMenuItems.GetCount() > 0);
	switch(topLevelMenu)
	{
	case fileMenu:
		return GetTopLevelMenuLabelForThisTopLevelMenuID(ID_FILE_MENU);
	case editMenu:
		return GetTopLevelMenuLabelForThisTopLevelMenuID(ID_EDIT_MENU);
	case viewMenu:
		return GetTopLevelMenuLabelForThisTopLevelMenuID(ID_VIEW_MENU);
	case toolsMenu:
		return GetTopLevelMenuLabelForThisTopLevelMenuID(ID_TOOLS_MENU);
	case exportImportMenu:
		return GetTopLevelMenuLabelForThisTopLevelMenuID(ID_EXPORT_IMPORT_MENU);
	case advancedMenu:
		return GetTopLevelMenuLabelForThisTopLevelMenuID(ID_ADVANCED_MENU);
	case layoutMenu:
		return GetTopLevelMenuLabelForThisTopLevelMenuID(ID_LAYOUT_MENU);
	case helpMenu:
		return GetTopLevelMenuLabelForThisTopLevelMenuID(ID_HELP_MENU);
	case administratorMenu:
		return GetTopLevelMenuLabelForThisTopLevelMenuID(ID_ADMINISTRATOR_MENU);
	default:
		wxString msg = msg.Format(_T("Programming Error: The GetTopLevelMenuName() function received an illegal TopLevelFunction enum value of %d"),topLevelMenu);
		wxASSERT_MSG(FALSE,msg); // programming error
		return _T("");
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing the current value of the top level menu's identifier,
///                     i.e., an int for ID_FILE_MENU, etc.
/// \param      -> topLevelMenuLabel the wxString value of the top level menu whose int
///                                  we are determining
/// \remarks
/// Called from: the App's SetupDefaultMenuStructure().
/// This function determines int value of the top level menu's identifier which is associated
/// with the input string in topLevelMenuLabel.
//////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::GetTopLevelMenuID(const wxString topLevelMenuLabel)
{
	wxString topLevelMenuLabelPlain;
	topLevelMenuLabelPlain = topLevelMenuLabel;
	if (topLevelMenuLabelPlain == _("&File"))
		return ID_FILE_MENU;
	else if (topLevelMenuLabelPlain == _("&Edit"))
		return ID_EDIT_MENU;
	else if (topLevelMenuLabelPlain == _("&View"))
		return ID_VIEW_MENU;
	else if (topLevelMenuLabelPlain == _("&Tools"))
		return ID_TOOLS_MENU;
	else if (topLevelMenuLabelPlain == _("E&xport-Import"))
		return ID_EXPORT_IMPORT_MENU;
	else if (topLevelMenuLabelPlain == _("&Advanced"))
		return ID_ADVANCED_MENU;
	else if (topLevelMenuLabelPlain == _("&Layout"))
		return ID_LAYOUT_MENU;
	else if (topLevelMenuLabelPlain == _("&Help"))
		return ID_HELP_MENU;
	else if (topLevelMenuLabelPlain == _("Ad&ministrator"))
		return ID_ADMINISTRATOR_MENU;
	else
	{
		wxASSERT_MSG(FALSE,_T("Programmer Error in GetTopLevelMenuID() function - Unknown top level menu ID symbol."));
		return -1;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing the current value of the top level menu's identifier,
///                     i.e., an int for ID_FILE_MENU, etc.
/// \param      -> topLevelMenu the enum value of the top level menu whose int
///                                  we are determining
/// \remarks
/// Called from: the App's ConfigureMenuBarForUserProfile().
/// This function is an override of the function that uses the menu label string as an
/// imput parameter. This one determines int value of the top level menu's identifier w
/// hich is associated with the input enum in topLevelMenu.
//////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::GetTopLevelMenuID(TopLevelMenu topLevelMenu)
{
	switch (topLevelMenu)
	{
	case fileMenu:
		{
			return ID_FILE_MENU;
			break;
		}
	case editMenu:
		{
			return ID_EDIT_MENU;
			break;
		}
	case viewMenu:
		{
			return ID_VIEW_MENU;
			break;
		}
	case toolsMenu:
		{
			return ID_TOOLS_MENU;
			break;
		}
	case exportImportMenu:
		{
			return ID_EXPORT_IMPORT_MENU;
			break;
		}
	case advancedMenu:
		{
			return ID_ADVANCED_MENU;
			break;
		}
	case layoutMenu:
		{
			return ID_LAYOUT_MENU;
			break;
		}
	case helpMenu:
		{
			return ID_HELP_MENU;
			break;
		}
	case administratorMenu:
		{
			return ID_ADMINISTRATOR_MENU;
			break;
		}
	default:
	{
		wxASSERT_MSG(FALSE,_T("Programmer Error in GetTopLevelMenuID() function - Unknown top level menu ID symbol."));
		return -1;
	}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a pointer to a wxMenu* object representing the top level menu of the AI
///             menu bar which is associated with the incoming topLevelMenu enum parameter
/// \param      -> topLevelMenu    the enum of the top level menu whose wxMenu object we are
///                                 locating
/// \remarks
/// Called from: the App's MakeMenuInitializationsAndPlatformAdjustments().
/// This function locates and returns the pointer to the wxMenu object that represents the
/// wxMenu* of the AI menu bar associated with the incoming topLevelMenu enum parameter.
//////////////////////////////////////////////////////////////////////////////////////////
wxMenu* CAdapt_ItApp::GetTopLevelMenuFromAIMenuBar(TopLevelMenu topLevelMenu)
{
	CMainFrame* pMainFrame = GetMainFrame();
	wxMenuBar* pMenuBar = pMainFrame->GetMenuBar();
	wxString tempName;
	int index;
	tempName = GetTopLevelMenuName(topLevelMenu);
	index = pMenuBar->FindMenu(tempName); // ignores & chars in name
	if (index == wxNOT_FOUND)
	{
		return (wxMenu*)NULL;
	}
	return pMenuBar->GetMenu(index);
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing the menu item id of the AI menu bar being examined
/// \param      -> mainMenuItemLabel  the string label of the top level menu of the menu bar
/// \param      -> menuItemLabel  the string label of the sub menu item of the menu bar
/// \param      -> tempMenuBar  the AI Menu Bar we are examining (generally a temp one)
/// \remarks
/// Called from: the App's ConfigureMenuBarForUserProfile().
/// This function determines and returns the int value of the identifier which was used
/// in creating the menu item in the tempMenuBar; the menu item being specified by its
/// location as being in the mainMenuItemLabel top level menu, and menuItemLabel sub
/// menu label. This function is a work around as it seems there is no way to determine
/// what the internal int value is of a program identifier such as ID_FILE_MENU when
/// one only knows the string value "ID_FILE_MENU". Moreover, the available functions
/// wxMenuBar::FindMenuItem() and wxMenu::FindItem() only take menu item labels.
/// Note: a menu separator has the value of wxID_SEPARATOR which is -2.
/// We cannot store the int values of identifiers in AI_UserProfiles.xml since those
/// int values will change for each build in which wxDesigner's inventory of identifiers
/// changes (it assigns them afresh for each build).
//////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::GetSubMenuItemIdFromAIMenuBar(wxString mainMenuItemLabel,wxString menuItemLabel, wxMenuBar* tempMenuBar)
{
	// The only available options to get an int id are via calling wxMenu::FindItem(const wxString& itemString) const
	// or wxMenuBar::FindMenuItem(const wxString& menuString, const wxString& itemString) const
	// on the appropriate top level menu of the tempMenuBar
	wxString menuItemLabelPlain = menuItemLabel;
	menuItemLabelPlain = menuItemLabelPlain; // RemoveMenuLabelDecorations(menuItemLabelPlain); // FindMenuItem() below strips out decorations
	int menuItemId;
	if (menuItemLabelPlain.IsEmpty())
		return wxID_SEPARATOR; // wxID_SEPARATOR has value of -2.
	else
	{
		menuItemId = tempMenuBar->FindMenuItem(mainMenuItemLabel,menuItemLabelPlain);
		return menuItemId;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing line position where replacement was done in the f wxTextFile
/// \param      -> f  the wxText file whose line we are modifying
/// \param      -> itemTextStr the highest level profile item we are looking for
/// \param      -> profileStr  the profile section under itemTextStr
/// \param      -> valueStr  the string value of the itemVisibility for the given profileStr
/// \remarks
/// Called from: the App's SaveUserProfilesMergingDataToXMLFile().
/// This function scans through the file f until it locates the line containing itemTextStr,
/// continues until the profileStr associated with itemTextStr is found, then replaces the
/// itemVisibility value associated with the above with the valueStr parameter.
//////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::ReplaceVisibilityStrInwxTextFile(wxTextFile* f, wxString itemTextStr, wxString profileStr, wxString valueStr)
{
	wxString lineStr;
	int linePos = -1;
	if (f->IsOpened())
	{
		// Note: we are scanning an in-memory representation of the xml file, so
		// our comparison string itemTextStr needs to have xml entity representations
		// to effect the comparison
		wxString str = itemTextStr;
		str.Replace(_T("&"),wxString::FromAscii(xml_amp)); // replacing '&' must be done first!
		str.Replace(_T("<"),wxString::FromAscii(xml_lt));
		str.Replace(_T(">"),wxString::FromAscii(xml_gt));
		str.Replace(_T("'"),wxString::FromAscii(xml_apos));
		str.Replace(_T("\""),wxString::FromAscii(xml_quote));
		str.Replace(_T("\t"),wxString::FromAscii(xml_tab)); // whm added 24May11

		bool bFoundItemTextLine = FALSE;
		for (lineStr = f->GetFirstLine(); !f->Eof() && !bFoundItemTextLine; lineStr = f->GetNextLine())
		{
			int chPos;
			// does this line have our itemTextStr?
			chPos = lineStr.Find(_T("itemText=\"")+str+_T("\""));
			if (chPos != wxNOT_FOUND)
			{
				bFoundItemTextLine = TRUE;
			}
		}
		if (bFoundItemTextLine)
		{
			// note: lineStr is now the next line beyond the "itemText..." line
			// so use a do ... while () loop
			bool bFoundProfileLine = FALSE;
			bool bMadeReplacement = FALSE;
			int chPos;
			do
			{
				chPos = lineStr.Find(profileStr);
				if (chPos != wxNOT_FOUND)
				{
					bFoundProfileLine = TRUE;
				}
				lineStr = f->GetNextLine();
			} while (!bFoundProfileLine && !f->Eof());
			if (bFoundProfileLine)
			{
				// the lineStr = f->GetNextLine() call above means we should now be pointing at the
				// itemVisibility line that we want to modify
				if (lineStr.Find(_T("itemVisibility")) != wxNOT_FOUND)
				{
					int rPos = -1;
					if (lineStr.Find(_T("\"0\"")) != wxNOT_FOUND)
					{
						rPos = (int)lineStr.Replace(_T("\"0\""),_T("\"1\""));
					}
					else if (lineStr.Find(_T("\"1\"")) != wxNOT_FOUND)
					{
						rPos = (int)lineStr.Replace(_T("\"1\""),_T("\"0\""));
					}
					else
					{
						wxASSERT(FALSE); // programmer error!
						return linePos;
					}
					if (rPos != wxNOT_FOUND)
						bMadeReplacement = TRUE;
				}
				else
				{
					wxASSERT(FALSE); // programmer error!
					return linePos;
				}
			}
			else
			{
				wxASSERT(FALSE); // programmer error!
				return linePos;
			}
			if (bMadeReplacement)
			{
				linePos = f->GetCurrentLine();
			}
		}
		else
		{
			wxASSERT(FALSE);
			return linePos;
		}
		wxString testStr1,testStr2; // for debugging below
		if (linePos != wxNOT_FOUND)
		{
			// now remove the "current" textFile line and replace it with lineStr
			testStr1 = f->GetLine(linePos); // for debugging
			f->RemoveLine(linePos);
			f->InsertLine(lineStr,linePos);
			testStr2 = f->GetLine(linePos); // for debugging
		}
	}
	return linePos;
}


//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      -> f  the wxText file whose line we are modifying
/// \remarks
/// Called from: the App's SaveUserProfilesMergingDataToXMLFile().
/// This function is called last after updating the wxTextFile with all other changes made
/// to the user workflow profiles. Here we update the adminModified="" line in the wxTextFile
/// to adminModified="Yes" if the data in the file differs from the factory data (determined
/// by calling CommonItemsInProfilesDiffer), otherwise we we ensure that the line reads
/// adminModified="No". Note: Working from the factory data as a baseline allows for the
/// possibility that a AI_UserProfiles.xml file that was previously modified resulting in the
/// line becoming adminModified="Yes", could now be modified again resulting in the line becoming
/// adminModified="No" in the event that the later modifications returned the data in the file
/// back to be identidal to the factory data.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::UpdateAdminModifiedLineToYesOrNo(wxTextFile* f)
{
	bool bProfilesDiffer = FALSE;
	bProfilesDiffer = CommonItemsInProfilesDiffer(m_pUserProfiles,m_pFactoryUserProfiles);

	wxString lineStr;
	int linePos = -1;
	if (f->IsOpened())
	{
		bool bFoundAdminModifiedLine = FALSE;
		for (lineStr = f->GetFirstLine(); !f->Eof() && !bFoundAdminModifiedLine; lineStr = f->GetNextLine())
		{
			int chPos;
			// does this line have our adminModified= line? If so, change it to adminModified="Yes"
			// or adminModified="No" depending on the value of bProfilesDiffer.
			chPos = lineStr.Find(_T("adminModified="));
			if (chPos != wxNOT_FOUND)
			{
				bFoundAdminModifiedLine = TRUE;
				linePos = f->GetCurrentLine();
				wxString str = lineStr;
				if (bProfilesDiffer)
				{
					// The profiles are different so modifications were made.
					// If adminModified="No" is in the line replace it with adminModified="Yes"
					if (str.Find(_T("adminModified=\"No\"")) != wxNOT_FOUND)
					{
						str.Replace(_T("adminModified=\"No\""),_T("adminModified=\"Yes\""));
					}
				}
				else
				{
					// The profiles are essentially the same as factory there are now no modifications.
					// If adminModified="Yes" is in the line replace it with adminModified="No"
					if (str.Find(_T("adminModified=\"Yes\"")) != wxNOT_FOUND)
					{
						str.Replace(_T("adminModified=\"Yes\""),_T("adminModified=\"No\""));
					}
				}
				wxString testStr1,testStr2; // for debugging below
				if (linePos != wxNOT_FOUND)
				{
					// now remove the "current" textFile line and replace it with lineStr
					testStr1 = f->GetLine(linePos); // for debugging
					f->RemoveLine(linePos);
					f->InsertLine(str,linePos);
					testStr2 = f->GetLine(linePos); // for debugging
				}
				break;
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing line position where replacement was done in the f wxTextFile
/// \param      -> f   the wxTextFile whose descriptionProfileN data we are replacing
/// \param      -> descrProfileN  the descriptionProfileN we are looking for in the file
/// \param      -> valueStr  the value of the new replacement descriptionProfileN text
/// \remarks
/// Called from: the App's SaveUserProfilesMergingDataToXMLFile().
/// This function scans through the file f until it locates the line containing descrProfileN,
/// then it replaces the existing text with the text in valueSrt.
//////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::ReplaceDescriptionStrInwxTextFile(wxTextFile* f, wxString descrProfileN, wxString valueStr)
{
	wxString lineStr;
	int linePos = -1;
	if (f->IsOpened())
	{
		bool bFoundDescrLine = FALSE;
		for (lineStr = f->GetFirstLine(); !f->Eof() && !bFoundDescrLine; lineStr = f->GetNextLine())
		{
			int chPos;
			// does this line have our itemTextStr?
			chPos = lineStr.Find(descrProfileN);
			if (chPos != wxNOT_FOUND)
			{
				bFoundDescrLine = TRUE;
			}
		}
		if (bFoundDescrLine)
		{
			// note: lineStr is now the next line beyond the "itemText..." line
			// so back up one line
			lineStr = f->GetPrevLine();
			wxString testStr1,testStr2; // for debugging below
			if (lineStr.Find(descrProfileN) != wxNOT_FOUND)
			{
				// Note: the default descriptive text describing each profile does not
				// use any "entities". However, since the description field is editable
				// by the user, a user may have introduced some characters or "entities"
				// i.e., '<', '>' '&', ''', and '"'. These need to be replaced by the
				// xml form: &lt;, &gt; &amp; &apos; and &quot; respectively, otherwise
				// it will produce malformed xml. The XML.cpp file has a ReplaceEntities()
				// function but it takes a CBString. Rather than converting to and from
				// CBString to use that function, we'll simply do the conversion directly
				// here.
				wxString str = valueStr;
				// replace entities
				str.Replace(_T("&"),wxString::FromAscii(xml_amp)); // replacing '&' must be done first!
				str.Replace(_T("<"),wxString::FromAscii(xml_lt));
				str.Replace(_T(">"),wxString::FromAscii(xml_gt));
				str.Replace(_T("'"),wxString::FromAscii(xml_apos));
				str.Replace(_T("\""),wxString::FromAscii(xml_quote));
				str.Replace(_T("\t"),wxString::FromAscii(xml_tab)); // whm added 24May11

				lineStr = lineStr.Mid(0,descrProfileN.Length()+1); // removes "="..." to right end of descr line
				lineStr += _T("=\"");
				lineStr += str;
				lineStr +=  _T("\"");
				linePos = f->GetCurrentLine();
				testStr1 = f->GetLine(linePos); // for debugging
				f->RemoveLine(linePos);
				f->InsertLine(lineStr,linePos);
				testStr2 = f->GetLine(linePos); // for debugging
			}
			else
			{
				wxASSERT(FALSE); // programmer error!
				return linePos;
			}
		}
	}
	return linePos;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnInit().
/// On Windows machines, transitions any registry information previously stored in the
/// Adapt_It_WX registry key to a Adapt_It_WX.ini file-on-disk format configuration file
/// and, once done, removes the old Adapt_It_WX registry key from the Windows registry,
/// so that this transition to using the file-on-disk format needs to happen only once.
/// As of version 6.0.0, the information saved previously in the Windows registry under
/// the HKEY_CURRENT_USER\Software\Adapt_It_WX key is now stored instead in a disk file
/// called Adapt_It_WX.ini - so that the Windows port now saves this information in the
/// same way that the Linux and Mac ports save it. It also makes Adapt It 6.0.0 more
/// compatible as a PortableApps application.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::TransitionWindowsRegistryEntriesTowxFileConfig()
{
#ifdef __WXMSW__ // only need to do this on a Windows host system
	// only transition data if the Adapt_It_WX key exists in the host Windows' registry
	wxRegKey keyAIWX(_T("HKEY_CURRENT_USER\\Software\\Adapt_It_WX"));
	if (keyAIWX.Exists())
	{
		// From version 6.0.0 Adapt It uses a wxFileConfig object instead of a wxConfig object
		// on the App called m_pConfig.
		// When TransitionWindowsRegistryEntriesTowxFileConfig() is called we don't know
		// whether AI's config info was transitioned previously from the host Windows'
		// registry or not, so we'll do this with a local object that we delete at the
		// end of this function.
		// The registry groups prior to 6.0.0 will have this heirarchical structure:
		// Adapt_It_WX
		//    Recent_File_List           [contains 11 REG_SZ entries and 8 REG_DWORD entries]
		//       wxHtmlWindow            [contains 3 REG_SZ entries and 8 REG_DWORD entries]
		//    Recent_File_List_Unicode   [contains 11 REG_SZ entries and 8 REG_DWORD entries]
		//       wxHtmlWindow            [contains 3 REG_SZ entries and 8 REG_DWORD entries]
		//    Settings                   [containes 13 REG_SZ entries and 3 REG_DWORD entries]
		//
		wxConfig* mpConfig;
		mpConfig = new wxConfig(_T("Adapt_It_WX")); // a local instance of wxConfig
		wxASSERT(mpConfig != NULL);

		wxFileConfig* mpFileConfig;
		// Note: in the wxFileConfig call below:
		// m_wxFileConfigPathAndName = m_appUserConfigDir + PathSeparator + _T("Adapt_It_WX.ini") on Windows
		// m_wxFileConfigPathAndName = m_appUserConfigDir + PathSeparator + _T(".Adapt_It_WX") on Linux and Mac
		mpFileConfig = new wxFileConfig(wxEmptyString,wxEmptyString,m_wxFileConfigPathAndName,wxEmptyString);
		wxASSERT(mpFileConfig != NULL);

		int nG;
		// Note: GetNumberOfEntries does not include the (Default) entry shown as first line in Regedit
		nG = mpConfig->GetNumberOfGroups(FALSE); // FALSE don't count groups recursively (i.e., don't include the wxHtmlWindow groups)
		bool bGroupOK;
		wxString groupName;
		long groupIndex; // we don't use this returned groupIndex
		bGroupOK = mpConfig->GetFirstGroup(groupName,groupIndex);
		int ctG = 0;
		while (bGroupOK && ctG < nG && !groupName.IsEmpty())
		{
			wxString path = _T('/') + groupName;
			// set the path to the current Group
			mpConfig->SetPath(path); // we know it exists so it won't be created
			// write the Group name to the mpFileConfig object
			mpFileConfig->SetPath(path); // if groupName doesn't exist it is created
			// read all entries for this group and write them to the wxFileConfig object
			wxString valueStr = _T("");
			int valueInt = 0;
			bool valueBool = FALSE;
			wxString entryName;
			bool bEntryOK;
			long entryIndex;
			int nE = mpConfig->GetNumberOfEntries(FALSE); // FALSE don't count entries recursively
			bEntryOK = mpConfig->GetFirstEntry(entryName,entryIndex);
			int ctE = 0;
			while (bEntryOK && ctE < nE && !entryName.IsEmpty())
			{
				bool bReadOK = FALSE;
				if (mpConfig->GetEntryType(entryName) == mpConfig->Type_String)
					bReadOK = mpConfig->Read(entryName,&valueStr);
				else if (mpConfig->GetEntryType(entryName) == mpConfig->Type_Integer)
					bReadOK = mpConfig->Read(entryName,&valueInt);
				else if (mpConfig->GetEntryType(entryName) == mpConfig->Type_Boolean)
					bReadOK = mpConfig->Read(entryName,&valueBool);
				if (bReadOK)
				{
					bool bWriteOK = FALSE;
					if (mpConfig->GetEntryType(entryName) == mpConfig->Type_String)
						bWriteOK = mpFileConfig->Write(entryName,valueStr);
					else if (mpConfig->GetEntryType(entryName) == mpConfig->Type_Integer)
						bWriteOK = mpFileConfig->Write(entryName,valueInt);
					else if (mpConfig->GetEntryType(entryName) == mpConfig->Type_Boolean)
						bWriteOK = mpFileConfig->Write(entryName,valueBool);
					if (!bWriteOK)
					{
						wxASSERT(FALSE);
					}
				}
				else
				{
					wxASSERT(FALSE);
				}
				ctE++;
				bEntryOK = mpConfig->GetNextEntry(entryName,entryIndex);
			}
			// all the entries of the current Group have been copied, but
			// there are also some sub-Groups called "wxHtmlWindow" containing
			// more entries, so we now handle those before getting the next top
			// level group
			int nSubG;
			nSubG = mpConfig->GetNumberOfGroups(FALSE); // don't count recursively
			bool bSubGroupOK;
			wxString subGroupName;
			long subGroupIndex; // we don't use this returned groupIndex
			bSubGroupOK = mpConfig->GetFirstGroup(subGroupName,subGroupIndex);
			int ctSubG = 0;
			while (bSubGroupOK && ctSubG < nSubG && !subGroupName.IsEmpty())
			{
				wxString subPath = _T('/') + groupName + _T('/') + subGroupName;
				// set the path to the current Group
				mpConfig->SetPath(subPath); // we know it exists so it won't be created
				// write the Group name to the mpFileConfig object
				mpFileConfig->SetPath(subPath); // if groupName doesn't exist it is created
				// read all entries for this group and write them to the wxFileConfig object
				wxString subValueStr = _T("");
				int subValueInt = 0;
				bool subValueBool = FALSE;
				wxString subEntryName;
				bool bSubEntryOK;
				long subEntryIndex;
				int nSubE = mpConfig->GetNumberOfEntries(FALSE); // FALSE don't count entries recursively
				bSubEntryOK = mpConfig->GetFirstEntry(subEntryName,subEntryIndex);
				int ctSubE = 0;
				while (bSubEntryOK && ctSubE < nSubE && !subEntryName.IsEmpty())
				{
					bool bSubReadOK = FALSE;
					if (mpConfig->GetEntryType(subEntryName) == mpConfig->Type_String)
						bSubReadOK = mpConfig->Read(subEntryName,&subValueStr);
					else if (mpConfig->GetEntryType(subEntryName) == mpConfig->Type_Integer)
						bSubReadOK = mpConfig->Read(subEntryName,&subValueInt);
					else if (mpConfig->GetEntryType(subEntryName) == mpConfig->Type_Boolean)
						bSubReadOK = mpConfig->Read(subEntryName,&subValueBool);
					if (bSubReadOK)
					{
						bool bSubWriteOK = FALSE;
						if (mpConfig->GetEntryType(subEntryName) == mpConfig->Type_String)
							bSubWriteOK = mpFileConfig->Write(subEntryName,subValueStr);
						else if (mpConfig->GetEntryType(subEntryName) == mpConfig->Type_Integer)
							bSubWriteOK = mpFileConfig->Write(subEntryName,subValueInt);
						else if (mpConfig->GetEntryType(subEntryName) == mpConfig->Type_Boolean)
							bSubWriteOK = mpFileConfig->Write(subEntryName,subValueBool);
						if (!bSubWriteOK)
						{
							wxASSERT(FALSE);
						}
					}
					ctSubE++;
					bSubEntryOK = mpConfig->GetNextEntry(subEntryName,subEntryIndex);
				}
				ctSubG++;
				bSubGroupOK = mpConfig->GetNextGroup(subGroupName,subGroupIndex);
			}
			ctG++;
			// set the paths back up to the top level
			mpConfig->SetPath(_T('/'));
			mpFileConfig->SetPath(_T('/'));
			bGroupOK = mpConfig->GetFirstGroup(groupName,groupIndex); // have to initialize group list again with GetFirstGroup
			// get the next first level group after the previous one (which is ctG steps down from top level)
			for (int i=0; i < ctG; i++)
			{
				bGroupOK = mpConfig->GetNextGroup(groupName,groupIndex);
			}
		}
		// Delete the Adapt_It_WX key along with all of its subgroups and subentries
		bool bDeletedOK = TRUE;
		bDeletedOK = keyAIWX.DeleteSelf(); // deletes the key with all its sub entries recursively
		wxASSERT(bDeletedOK == TRUE);
		mpConfig->Flush();
		mpFileConfig->Flush();
		// Finally, delete the temporary objects we've used above.
		// Note: mpFileConfig will be created again for the duration of the running app
		// in OnInit() just after this function ends.
		delete mpConfig;
		delete mpFileConfig;
	}
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnInit().
/// Removes all collaboration settings previously stored in the Adapt_It_WX.ini
/// file-on-disk format configuration file. With project-specific collaboration it
/// is no longer necessary to save collaboration settings in the Adapt_It_WX.ini
/// file. If we did the Adapt_It_WX.ini file would have to have separate settings
/// for each Adapt It project that the administrator has configured for collaboration
/// with Paratext/Bibledit.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::RemoveCollabSettingsFromFailSafeStorageFile()
{
	if (m_pConfig == NULL)
	{
		wxASSERT_MSG(FALSE,_T("Programming Error: the m_pConfig pointer in RemoveCollabSettingsFromFailSafeStorageFile() was NULL"));
		return;
	}
	wxString oldPath = m_pConfig->GetPath(); // is always absolute path "/Recent_File_List"
	bool bDelOK;
	m_pConfig->SetPath(_T("/Settings"));
	wxLogNull logNo; // eliminates spurious message from the system: "Can't read value
		// of key 'HKCU\Software\Adapt_It_WX\Settings' Error" [valid until end of this block]
	// whm Note 27Mar12. We want to purge the Adapt_It_WX.ini (.Adapt_It_WX) file of all
	// collaboration settings whether for pt or be, so we look for any/all such settings
	// and delete any that are found.
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collaboration"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collab_src_proj"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collab_tgt_proj"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collab_free_trans_proj"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collab_ai_proj_name"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collab_book_selected"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collab_by_chapter_only"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collab_chapter_selected"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collab_src_lang_name"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("pt_collab_tgt_lang_name"), TRUE);
	
	bDelOK = m_pConfig->DeleteEntry(_T("be_collaboration"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("be_collab_src_proj"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("be_collab_tgt_proj"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("be_collab_free_trans_proj"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("be_collab_ai_proj_name"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("be_collab_book_selected"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("be_collab_by_chapter_only"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("be_collab_chapter_selected"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("be_collab_src_lang_name"), TRUE);
	bDelOK = m_pConfig->DeleteEntry(_T("be_collab_tgt_lang_name"), TRUE);

	bDelOK = bDelOK; // to avoid warning. It is not important whether the entries get removed or not
	m_pConfig->Flush(); // write now, otherwise write takes place when m_pConfig is destroyed in OnExit().
	// restore the oldPath back to "/Recent_File_List"
	m_pConfig->SetPath(oldPath);
}


// The XML.cpp's InsertEntities() function takes a CBString which is inconvenient
// here so we'll just insert entities manually.
// replace any entity chars with their xml entity representations
wxString CAdapt_ItApp::InsertEntities(wxString str)
{
	str.Replace(_T("&"),wxString::FromAscii(xml_amp)); // replacing '&' must be done first!
	str.Replace(_T("<"),wxString::FromAscii(xml_lt));
	str.Replace(_T(">"),wxString::FromAscii(xml_gt));
	str.Replace(_T("'"),wxString::FromAscii(xml_apos));
	str.Replace(_T("\""),wxString::FromAscii(xml_quote));
	str.Replace(_T("\t"),wxString::FromAscii(xml_tab)); // whm added 24May11
	return str;
}

void CAdapt_ItApp::LogUserAction(wxString msg)
{
	if(m_userLogFile != NULL)
	{
		// Convert any \n chars in msg to <BR> to keep each msg to one line,
		// but embedded <BR> would allow us to process line breaks for display
		// as HTML.
		msg.Replace(_T("\n"),_T("<BR>"));
		wxDateTime theTime = wxDateTime::Now(); //initialize to the current time
		wxString timeStr;
		timeStr = theTime.Format();
		m_userLogFile->Write(timeStr+_T(':')+msg+m_eolStr);
		m_userLogFile->Flush();
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if Paratext.exe is installed on the host computer, FALSE otherwise
/// \remarks
/// Called from: the App's OnInit().
/// Looks in the Windows registry to see if Paratext is installed. Returns TRUE if host
/// machine has a Windows registry and this function finds the following conditions to
/// be met:
/// 1. The following key exists in the registry:
///    HKEY_LOCAL_MACHINE\SOFTWARE\ScrChecks\1.0\Program_Files_Directory_Ptw7
/// 2. The string value associated with the above key represents a valid path where
///    Paratext is installed, usually something like "C:\Program Files\Paratext7\".
/// 3. The folder designated in 2 above contains the Paratext.exe executable file.
/// If the above conditions are not all met, the function returns FALSE. This function
/// only reads/queries the Windows registry; it does not make changes to it.
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::ParatextIsInstalled()
{
	bool bPTInstalled = FALSE;
#ifdef __WXMSW__ // Windows host -- use registry

	wxLogNull logNo; // eliminate any spurious messages from the system
	// only transition data if the Adapt_It_WX key exists in the host Windows' registry
	wxRegKey keyPTInstallDir(_T("HKEY_LOCAL_MACHINE\\SOFTWARE\\ScrChecks\\1.0\\Program_Files_Directory_Ptw7"));
	if (keyPTInstallDir.Exists() && keyPTInstallDir.HasValues())
	{
		wxString dirStrValue;
		dirStrValue.Empty();
		if (keyPTInstallDir.Open(wxRegKey::Read)) // open the key for reading only!
		{
			// get the folder path stored in the key, (i.e., C:\Program Files\Paratext7\)
			// Note: the dirStrValue path ends with a backslash so we don't add one here.
			dirStrValue = keyPTInstallDir.QueryDefaultValue();
			if (::wxDirExists(dirStrValue))
			{
				// Note: There are two main Paratext components that we check for to determine
				// if Paratext is installed, Paratext.exe and ParatextShared.dll. The former is
				// the main program. The other is the shared dynamic library with which our
				// collaboration with Paratext is achieved. We later interact with the
				// ParatextShared.dll library.
				if (::wxFileExists(dirStrValue + _T("Paratext.exe"))
					&& ::wxFileExists(dirStrValue + _T("ParatextShared.dll")))
				{
					bPTInstalled = TRUE;
				}
			}
		}
	}
#endif
#ifdef __WXGTK__ // linux -- just look for the files in /usr/lib/Paratext/
    wxString strPTInstallDir = _T("/usr/lib/Paratext");

    if (::wxDirExists(strPTInstallDir))
    {
        // path exists -- see if the software is in there AND MONO_REGISTRY_PATH is defined
        if (::wxFileExists(strPTInstallDir + _T("/Paratext.exe"))
            && ::wxFileExists(strPTInstallDir + _T("/ParatextShared.dll"))
            && (!GetParatextEnvVar(_T("MONO_REGISTRY_PATH")).IsEmpty()))
        {
            bPTInstalled = TRUE;
        }
    }
#endif
	return bPTInstalled;
}

bool CAdapt_ItApp::BibleditIsInstalled()
{
	bool bBEInstalled;
	bBEInstalled = FALSE;
	wxString pathToExecutable;
	pathToExecutable.Empty();
#ifdef __WXGTK__
	pathToExecutable = GetBibleditInstallDirPath() + PathSeparator + _T("bibledit-rdwrt");
	if (::wxFileExists(pathToExecutable))
		bBEInstalled = TRUE;

	// TODO: write code to determine the version of bibledit-gtk that is
	// installed on Linux. It must be at least version 4.2.93 to respond
	// to the command-line usage implemented by Teus as of version 4.2.93.
#endif
#ifdef __WXMAC__
	pathToExecutable = GetBibleditInstallDirPath() + gpApp->PathSeparator + _T("bibledit-rdwrt");

	// If the above call doesn't find it then try /opt/local/bin/
	// According to the Bibledit wesite's instructions for installing Bibledit
	// on the Mac it should install to _T("/opt/local/bin/bibledit-gtk")
	// so if the above doesn't find it on the PATH, then try the hard coded Path
	if (::wxFileExists(pathToExecutable))
		bBEInstalled = TRUE;
	else if (::wxFileExists(_T("/opt/local/bin/bibledit")))
		bBEInstalled = TRUE;

	// TODO: write code to determine the version of bibledit-gtk that is
	// installed on the Mac. It must be at least version 4.2.93 to respond
	// to the command-line usage implemented by Teus as of version 4.2.93.
#endif

	m_bBibleditIsInstalled = bBEInstalled; // set the App's flag
	return bBEInstalled;
}

#ifdef __WXGTK__ // only used for mono / linux
//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the Paratext environment variable
/// \remarks
/// Called from GetParatextProjectsDirPath and ParatextIsInstalled
/// This method opens up the /usr/bin/paratext shell script that launches Paratext in
/// the mono environment, and looks for the specified environment variable.  If found,
/// this method returns the string value of that variable; if not found (or if there is
/// some other issue opening / parsing the file), an empty string is returned.
/// Note that this method is not called under the Windows environment.
//////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetParatextEnvVar(wxString strVariableName)
{
    wxString strScriptFilename = _T("/usr/bin/paratext");
    wxString value;
    value.Empty();
    // sanity check -- make sure the paratext script exists
    if (!::wxFileExists(strScriptFilename)) return value;
    // open the file and look for our variable name
    wxTextFile tfile;
    wxString strBuf;
    if (tfile.Open(strScriptFilename))
    {
        strBuf = tfile.GetFirstLine();
        while (!tfile.Eof())
        {
            if (strBuf.Contains(strVariableName))
            {
                // found it -- extract the variable value from this line
                int nStart = (strBuf.Find(_T("="))) + 1;
                value = strBuf.Mid(nStart, (strBuf.Length() - nStart));
                wxLogDebug(value);
                break; // exit the while loop -- we've found our match
            }
            strBuf = tfile.GetNextLine();
        }
        tfile.Close();
    }
    // return what we found
    return value;
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the path to the Paratext projects directory
/// \remarks
/// Called from: the App's OnInit().
/// Looks in the Windows registry to get the path to the Paratext Projects directory.
/// The following registry key is queried for the return value:
///    HKEY_LOCAL_MACHINE\SOFTWARE\ScrChecks\1.0\Settings_Directory
/// If the key is not found, or is found but the value string does not exist on
/// the system, the function returns an empty string. This function only reads/queries
/// the Windows registry; it does not make changes to it.
//////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetParatextProjectsDirPath()
{
	wxString path;
	path.Empty();
#ifdef __WXMSW__ // Windows host system - look in registry

	wxLogNull logNo; // eliminate any spurious messages from the system
	// only transition data if the Adapt_It_WX key exists in the host Windows' registry
	wxRegKey keyPTInstallDir(_T("HKEY_LOCAL_MACHINE\\SOFTWARE\\ScrChecks\\1.0\\Settings_Directory"));
	if (keyPTInstallDir.Exists() && keyPTInstallDir.HasValues())
	{
		wxString dirStrValue;
		dirStrValue.Empty();
		if (keyPTInstallDir.Open(wxRegKey::Read)) // open the key for reading only!
		{
			// get the folder path stored in the key, (i.e., C:\Program Files\Paratext7\)
			dirStrValue = keyPTInstallDir.QueryDefaultValue();
			// remove the final backslash, since our path values generally don't have a
			// trailing path separator.
			if (!dirStrValue.IsEmpty() && dirStrValue.GetChar(dirStrValue.Length()-1) == _T('\\'))
				dirStrValue.RemoveLast(1);
			if (::wxDirExists(dirStrValue))
			{
				path = dirStrValue;
			}
		}
	}
#endif
#ifdef __WXGTK__ // linux -- check mono directory for values.xml file
    wxString strRegPath = GetParatextEnvVar(_T("MONO_REGISTRY_PATH"));
    if (strRegPath.IsEmpty())
    {
        // problem getting shell script value -- try the default location
        strRegPath = wxGetenv(_T("HOME"));
        strRegPath += _T("/.config/paratext/registry");
    }
    else
    {
        // the shell script uses ${HOME} for the home directory, which the ::wxDirExists()
        // call chokes on -- replace that value with the system environment variable value
        // for the HOME directory before continuing
        strRegPath.Replace(_T("${HOME}"), wxGetenv(_T("HOME")));
    }
    if (::wxDirExists(strRegPath))
    {
        // MONO_REGISTRY_PATH exists -- see if we can get the projects dir our of the values.xml
        // file located in strRegPath
        wxString strValuesFile = strRegPath + _T("/LocalMachine/software/scrchecks/1.0/settings_directory/values.xml");
        wxString strBuf;
        wxString strPath;
        if (wxFileExists(strValuesFile))
        {
            wxTextFile tfile;
            if (tfile.Open(strValuesFile))
            {
                strBuf = tfile.GetFirstLine();
                while (!tfile.Eof())
                {
                    if (strBuf.Contains(_T("type=\"string\">")))
                    {
                        // extract the path from this string value
                        int nStart = (strBuf.Find(_T("\">"))) + 2;
                        int nEnd = strBuf.Find(_T("</value>"));
                        strPath = strBuf.Mid(nStart, (nEnd - nStart));
                        wxLogDebug(strPath);
                        break; // exit the while loop -- we've found our match
                    }
                    strBuf = tfile.GetNextLine();
                }
                tfile.Close();
            }
        }

        if (!strPath.IsEmpty() && strPath.GetChar(strPath.Length()-1) == _T('\\'))
            strPath.RemoveLast(1);
        if (::wxDirExists(strPath))
        {
            path = strPath;
        }
    }
#endif

	return path;
}

wxString CAdapt_ItApp::GetBibleditProjectsDirPath()
{
	// by inspection of Bibledit-gtk version 4.2.93 (cloned from git nightly build
	// and built 13Jun11), the bibledit project folder is located at:
	// ~/.bibledit/projects and the projects folder contains an xml file called
	// configuration.1.xml and folders for each project by name of project. We can
	// get a list of bibledit projects by collecting all the folder names. Each of
	// the named project folders should have a "data" folder and a configuration.1.xml
	// file which contains the vital information for AI project setup including
	// <language>, <versification>, <editable>, <editor-font-default>, <editor-font-name>
	// which is of the form Sans 14, <right-to-left>, etc.
	wxString path;
	path.Empty();
	// On Linux systems the wxStandardPaths::GetDocumentsDir() method gets
	// the user's ~/ folder where the .bibledit folder is located. We augment
	// that path by pointing to its projects subdirectory, i.e., ~/.bibledit/projects.
	// Get the "documents" directory for the current system/platform.
	wxStandardPaths stdPaths;
	path = stdPaths.GetDocumentsDir() + PathSeparator + _T(".bibledit") + PathSeparator + _T("projects");
	return path;
}


//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the path to the Paratext installation directory
/// \remarks
/// Called from: the App's OnInit().
/// Looks in the Windows registry to get the path to the Paratext Install directory.
/// The following registry key is queried for the return value:
///    HKEY_LOCAL_MACHINE\SOFTWARE\ScrChecks\1.0\Program_Files_Directory_Ptw7
/// If the key is not found, or is found but the value string does not exist on
/// the system, the function returns an empty string. This function only reads/queries
/// the Windows registry; it does not make changes to it.
//////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetParatextInstallDirPath()
{
	wxString path;
	path.Empty();
#ifdef __WXMSW__ // Windows host system - check the registry

	wxLogNull logNo; // eliminate any spurious messages from the system
	// only transition data if the Adapt_It_WX key exists in the host Windows' registry
	wxRegKey keyPTInstallDir(_T("HKEY_LOCAL_MACHINE\\SOFTWARE\\ScrChecks\\1.0\\Program_Files_Directory_Ptw7"));
	if (keyPTInstallDir.Exists() && keyPTInstallDir.HasValues())
	{
		wxString dirStrValue;
		dirStrValue.Empty();
		if (keyPTInstallDir.Open(wxRegKey::Read)) // open the key for reading only!
		{
			// get the folder path stored in the key, (i.e., C:\Program Files\Paratext7\)
			dirStrValue = keyPTInstallDir.QueryDefaultValue();
			// remove the final backslash, since our path values generally don't have a
			// trailing path separator.
			if (!dirStrValue.IsEmpty() && dirStrValue.GetChar(dirStrValue.Length()-1) == _T('\\'))
				dirStrValue.RemoveLast(1);
			if (::wxDirExists(dirStrValue))
			{
				path = dirStrValue;
			}
		}
	}
#endif
#ifdef __WXGTK__ // linux -- check /usr/lib/Paratext
    wxString strDir = _T("/usr/bin/Paratext");
    if (::wxDirExists(strDir))
    {
        path = strDir;
    }
#endif

	return path;
}

wxString CAdapt_ItApp::GetBibleditInstallDirPath()
{
	wxString dirPath;
	// By inspection of my Ubuntu 10.04 system with Bibledit on it, it appears that
	// it gets installed at /usr/bin/bibledit-gtk where the InstallDirPath() is /usr/bin
	// and the app name is bibledit-gtk.
    dirPath = GetProgramLocationFromSystemPATH(_T("bibledit-gtk"));

	// dirPath should normally be _T("/usr/bin") for a package installed version of
	// Bibledit, or possibly _T("/usr/local/bin") for a locally installed version.

	return dirPath;
}

wxString CAdapt_ItApp::GetAdaptit_Bibledit_rdwrtInstallDirPath()
{
	wxString dirPath;
	// The interim Bibledit utility is called adaptit-bibledit-rdwrt and
	// is installed by Adapt It, not by Bibledit. It will only be used if
	// Bibledit-gtk is installed, but is earlier than version 4.2.67 (the SIL
	// package at packages.sil.org/ubuntu that Neil packaged there earlier
	// in 2011. Once Balsa and the commonly-used Bibledit that is packaged
	// with Ubuntu distributions has a Bibledit version > 4.2.93 this
	// function and adaptit-bibledit-rdwrt will no longer be necessary.
    dirPath = GetProgramLocationFromSystemPATH(_T("adaptit-bibledit-rdwrt"));

	// dirPath should normally be _T("/usr/bin") for a package installed version of
	// Adapt It, or possibly _T("/usr/local/bin") for a locally installed version.

	return dirPath;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing a suitable document file name for AI's collaboration
///                    with Paratext or Bibledit
/// \param      collabPrefix       -> the USFM 3-letter book code string for a Scripture book
/// \param      bookCode           -> the USFM 3-letter book code string for a Scripture book
/// \param      ptProjectShortName -> the Paratext Project's short name the Scripture book is in
/// \param      chapterNumStr -> the chapter number as a string, optionally can be wxEmptyString
/// \param      extStr        -> the extension to use, generally will be "xml"
/// \remarks
///
/// Builds a suitable file name for Adapt It's local use based partly on the Paratext naming
/// scheme, and partly for Adapt It's own filename identification purposes. The usual resulting
/// string is of the form represented by the following example: Collab_nn_BBB_XYZ_CHcc.ext where
/// nn is the numerical book equivalent in the Paratext scheme (01 is Genesis, 39 is Malachi,
/// 41 is Matthew, 67 is Revelation); BBB is the USFM 3-letter book code; XYZ is the Paratext
/// project's short name; cc is the chapter number, and ext is the extension for the filename.
/// The format for nn and cc when < 10 has a leading '0'. If the chapterNumStr is empty
/// (wxEmptyString or _T("")), the resulting file name string is of the form: Collab_nn_BBB_XYZ.ext.
/// The incoming extStr can contain an initial dot or be just the extension itself; the
/// function puts the initial dot if it is not present in the incoming extStr. The bookCode and
/// extStr are the two manditory parameters that cannot be empty strings.
/// BEW 26Jun11, removed assert for non-empty extension, so that the function can also be
/// used for easily generating a window Title string
//////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetFileNameForCollaboration(wxString collabPrefix, wxString bookCode,
							wxString ptProjectShortName, wxString chapterNumStr, wxString extStr)
{
	wxASSERT(!bookCode.IsEmpty());
	//wxASSERT(!extStr.IsEmpty()); BEW removed 26Jun11
	wxString nameStr;
	nameStr.Empty();
	if (!collabPrefix.IsEmpty())
	{
		nameStr = collabPrefix; // don't localize
		nameStr += _T('_');
	}
	int num = GetNumberFromBookCodeForFileNaming(bookCode);
	// the number returned from GetNumberFromBookCodeForFileNaming() will never have leading zeros.
	if (num < 10)
	{
		nameStr += _T('0');
	}
	nameStr << num;
	nameStr += _T('_');
	nameStr += bookCode;
	if (!ptProjectShortName.IsEmpty())
	{
		nameStr += _T('_');
		nameStr += ptProjectShortName;
	}
	chapterNumStr.Trim(FALSE);
	chapterNumStr.Trim(TRUE);
	if (!chapterNumStr.IsEmpty())
	{
		int chNum;
		chNum = wxAtoi(chapterNumStr);
		// wxAtoi() removes any leading 0 chars, so get the normalized string form of the number for adding below
		wxString cNum;
		cNum.Empty();
		cNum << chNum;
		nameStr += _T("_CH"); // don't localize
		if (chNum < 10)
		{
			nameStr += _T('0');
		}
		nameStr += cNum;
	}
	if (extStr.Find(_T('.')) == 0)
	{
		// extStr begins with a '.' so just add it
		nameStr += extStr;
	}
	else
	{
		if (!extStr.IsEmpty()) // BEW added 27Jun11
		{
			nameStr += _T('.');
			nameStr += extStr;
		}
	}
	return nameStr;
}

// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
/*
// This function tests for the existence of "forced" collaboration values that are set
// when the application is started up with command-line switches/options set that can
// include -collab_on, -collab_off, -collab_proj, and -ai_proj. The "forced" tests utilize
// these flags and strings: m_bForceCollabModeON, m_bForceCollabModeOFF,
// m_bForceCollabExpectsFreeTrans, m_ForceCollabAIProjectName, and
// m_ForceCollabProjectNames. Under the forced conditions this function
// changes the App's applicable collaboration related values.
void CAdapt_ItApp::ForceCollabSettingsFromCommandLineSwitches()
{
	// At this point the basic settings have been read into their App member
	// values. We now check if command-line switches have been used to force
	// the collaboration mode ON or OFF, and/or the PT/BE projects to be used,
	// and or the AI project to be used during this session of AI.
	//
	// Note that we've saved the basic config file's values for
	// CollaborationWithParatext in m_nSavedCollabPTSetting and the
	// CollaborationWithBibledit value in m_nSavedCollabBESetting.
	// When the WriteBasicSettingsConfiguration() function is called later
	// during this session and/or at session end, it will always use the saved
	// values from m_nSavedCollabPTSetting and m_nSavedCollabBESetting rather
	// than the App's m_bCollaboratingWithParatext and m_bCollaboratingWithBibledit
	// values, because the command-line switches may force the App's values for
	// collaboration during this session of the App.
	// Note: m_bForceCollabModeON defaults to FALSE, but may be set to TRUE via
	// command-line switch in OnInit()
	if (m_bForceCollabModeON)
	{
		// When forcing collab mode ON for this session we should do some
		// sanity checks to verify that projects have been set up properly
		// before forcing the collab mode to ON.
		// TODO: sanity checks
		if (m_collaborationEditor == _T("Paratext"))
		{
			m_bCollaboratingWithParatext = TRUE;
		}
		else if (m_collaborationEditor == _T("Bibledit"))
		{
			m_bCollaboratingWithBibledit = TRUE;
		}
	}
	if (m_bForceCollabModeOFF)
	{
		// No sanity check needed to turn collab mode OFF for the session.
		if (m_collaborationEditor == _T("Paratext"))
		{
			m_bCollaboratingWithParatext = FALSE;
		}
		else if (m_collaborationEditor == _T("Bibledit"))
		{
			m_bCollaboratingWithBibledit = FALSE;
		}
	}
	// Note: m_ForceCollabProjectNames defaults to an empty string, but may be set to
	// a wxString of the form "PT/BE Src Proj:PT/BE Tgt Proj[:PT/BE FreeTrans Proj]"
	// via command-line switch/option in OnInit()
	if (m_ForceCollabProjectNames != _T(""))
	{
		if (m_bCollaboratingWithParatext || m_bCollaboratingWithBibledit)
		{
			// Note: the m_ForceCollabProjectNames string follows the -collab_proj
			// command-line option. It may have two fields of the form:
			//
			// "<source language project>:<target language project>"
			//
			// For example, when the string "Nyindrou:Tok Pisin" follows the -collab_proj
			// command-line option, it indicates that Nyindrou is the PT/BE project to be
			// used by AI for obtaining source texts for collaboration, and Tok Pisin is
			// the PT/BE project to be used by AI for receiving target texts from AI during
			// collaboration.
			// Alternately, the m_ForceCollabProjectNames may have three fields of the form:
			//
			// "<source language project>:<target language project>:<freetrans language project>"
			//
			// in which the first two fields delimited by the : characters are the PT/BE projects
			// for storing source texts and target texts (as described above), and the third field
			// is the PT/BE project for storing the free translation texts. For example, the
			// string "Tok Pisin:Nyindrou:English" following the -collab_proj command-line option
			// indicates that the PT/BE "English" project should be used for the third PT/BE project
			// involved in collaboration.
			if (m_ForceCollabProjectNames.Find(_T(':')) != wxNOT_FOUND)
			{
				// m_ForceCollabProjectNames has content delimited by ':' characters, so parse it
				wxStringTokenizer tkz(m_ForceCollabProjectNames,_T(":"));
				wxString srcProjStr, tgtProjStr, freeTransProjStr;
				int tokCt = 1;
				while (tkz.HasMoreTokens())
				{
					// Get the third token in tempProjStr and compare it with
					// the tmpSourceLangName and tmpTargetLangName for matches
					wxString tokenStr = tkz.GetNextToken();
					tokenStr.Trim(FALSE);
					tokenStr.Trim(TRUE);
					switch (tokCt)
					{
					case 1: srcProjStr = tokenStr;
						break;
					case 2: tgtProjStr = tokenStr;
						break;
					case 3: freeTransProjStr = tokenStr;
						break;
					}
					tokCt++;
				}
				// Check to ensure that the parsed substrings represent valid collaboration editor
				// projects
				wxArrayString projList;
				projList.Clear();
				if (m_bCollaboratingWithParatext)
				{
					projList = GetListOfPTProjects();
				}
				else if (m_bCollaboratingWithBibledit)
				{
					projList = GetListOfBEProjects();
				}
				bool bProjectsAreValid = TRUE;
				wxString tempCollabProjForSrcInputs = _T("");
				wxString tempCollabProjForTgtExports = _T("");
				wxString tempCollabProjForFreeTransExports = _T("");
				wxString invalidProjStr = _T("");
				if (!srcProjStr.IsEmpty())
				{
					ValidateCollabProject(srcProjStr,projList,tempCollabProjForSrcInputs);
					if (tempCollabProjForSrcInputs.IsEmpty())
					{
						bProjectsAreValid = FALSE;
						invalidProjStr = srcProjStr;
					}
				}
				if (!tgtProjStr.IsEmpty())
				{
					ValidateCollabProject(tgtProjStr,projList,tempCollabProjForTgtExports);
					if (tempCollabProjForTgtExports.IsEmpty())
					{
						bProjectsAreValid = FALSE;
						if (!invalidProjStr.IsEmpty())
							invalidProjStr += _T(", ");
						invalidProjStr += tgtProjStr;
					}
				}
				if (!freeTransProjStr.IsEmpty())
				{
					ValidateCollabProject(freeTransProjStr,projList,tempCollabProjForFreeTransExports);
					if (tempCollabProjForFreeTransExports.IsEmpty())
					{
						bProjectsAreValid = FALSE;
						if (!invalidProjStr.IsEmpty())
							invalidProjStr += _T(", ");
						invalidProjStr += freeTransProjStr;
					}
					else
					{
						m_bCollaborationExpectsFreeTrans = TRUE;
						m_bForceCollabExpectsFreeTrans = TRUE; // whm added 9Feb12
					}
				}

				if (bProjectsAreValid)
				{
					// all -collab_proj designated projects are valid PT/BE projects, so assign
					// the App's values
					m_CollabProjectForSourceInputs = tempCollabProjForSrcInputs;
					m_CollabProjectForTargetExports = tempCollabProjForTgtExports;
					m_CollabProjectForFreeTransExports = tempCollabProjForFreeTransExports;
					m_bCollaborationExpectsFreeTrans = !tempCollabProjForFreeTransExports.IsEmpty();
					wxString tmpAIProjName = _T("");
					wxString ai_srcLangName = _T("");
					wxString ai_tgtLangName = _T("");
					GetAIProjectFolderForCollab(tmpAIProjName, srcProjStr, tgtProjStr, m_CollabProjectForSourceInputs, m_CollabProjectForTargetExports);
					// Note: The next three may be overridden if the -ai_proj "Lang A to Lang B adaptations"
					// switch/option is also used (see the if (m_ForceCollabAIProjectName != _T("")) block below).
					m_CollabAIProjectName = tmpAIProjName;
					m_CollabSourceLangName = srcProjStr;
					m_CollabTargetLangName = tgtProjStr;
				}
				else
				{
					// One or more of the collab projects following the -collab_proj option are
					// invalid (not found as PT/BE projects).
					// Notify the user of the error.
					wxString collabEditor = m_collaborationEditor;
					wxString msg = _("The command-line string \"%s\" designates at least one %s project that cannot be found (%s). The -collab_proj command-line option will be ignored.");
					msg = msg.Format(msg,m_ForceCollabProjectNames.c_str(),collabEditor.c_str(),invalidProjStr.c_str());
					wxMessageBox(msg,_T(""),wxICON_WARNING);
					m_ForceCollabProjectNames.Empty(); // empty the string
					m_bForceCollabExpectsFreeTrans = FALSE;
				}
			}
			else
			{
				// m_ForceCollabProjectNames has no ':' delimiters so its content is not a properly
				// formed string option for a -collab_proj command-line parameter. Therefore we will
				// notify the user of the error.
				wxString collabEditor = m_collaborationEditor;
				wxString msg = _("The command-line string %s does not designate at least two %s projects in the form \"<source proj>:<target proj>\". The -collab_proj command-line option will be ignored.");
				msg = msg.Format(msg,m_ForceCollabProjectNames.c_str(),collabEditor.c_str());
				wxMessageBox(msg,_T(""),wxICON_WARNING);
				m_ForceCollabProjectNames.Empty(); // empty the string
				m_bForceCollabExpectsFreeTrans = FALSE;
			}
		}
		else
		{
			// The -collab_proj "..." option was used but the -collab_on was not used.
			// TODO: Test this!
			;
		}
	}
	// Note: m_ForceCollabAIProjectName defaults to an empty string, but may be set to
	// a wxString of the form "Lang A to Lang B adaptations" via command-line
	// switch/option in OnInit(). If set this switch will override the -collab_proj
	// switch's calculated AI project name (m_CollabAIProjectName) as well as the
	// language names that get used during the session (m_CollabSourceLangName
	// and m_CollabTargetLangName).
	if (m_ForceCollabAIProjectName != _T(""))
	{
		// Check to see if there is a suitable collaboration project that matches
		// the -ai_proj command-line option string. If so, we will try to have it
		// pre-selected when the GetSourceTextFromEditor dialog appears during
		// collaboration or when the projectPage appears in the wizard when collaboration
		// is OFF.
		wxArrayString aiProjList;
		aiProjList.Clear();
		GetPossibleAdaptionProjects(&aiProjList);
		// Check whether the forced ai project name is an actual project on the
		// host machine.
		wxString forced_aiProjName = m_ForceCollabAIProjectName;
#ifdef __WXMSW__
		forced_aiProjName.LowerCase();
#endif
		int ct;
		bool bAiProjectFound = FALSE;
		for (ct = 0; ct < (int)aiProjList.GetCount(); ct++)
		{
			wxString aiProjItem = aiProjList.Item(ct);
#ifdef __WXMSW__
			aiProjItem.LowerCase();
#endif
			if (aiProjItem == forced_aiProjName)
			{
				// m_ForceCollabAIProjectName exists as an AI project folder name
				bAiProjectFound = TRUE;
			}
		}
		if (!bAiProjectFound)
		{
			// No AI Project corresponds to the m_ForceCollabAIProjectName so notify user
			// that the -ai_proj parameter will be ignored.
			wxString msg = _("An Adapt It Project named %s was not found. The -ai_proj command-line option will be ignored.");
			msg = msg.Format(msg,m_ForceCollabAIProjectName.c_str());
			wxMessageBox(msg,_T(""),wxICON_WARNING);
			m_ForceCollabAIProjectName.Empty();	// empty the string so other functions in the App will
											// know that it is not in effect.
		}

		if (bAiProjectFound)
		{
			wxString tmpSourceLangName,tmpTargetLangName;
			if (m_bCollaboratingWithParatext || m_bCollaboratingWithBibledit)
			{
				// Collaboration is turned ON
				// Parse the language names from the AI project name.
				GetSrcAndTgtLanguageNamesFromProjectName(m_ForceCollabAIProjectName,
					m_CollabSourceLangName,m_CollabTargetLangName);
				// assign the forced name to m_CollabAIProject Name
				m_CollabAIProjectName = m_ForceCollabAIProjectName;
				// TODO: Check that the GetSourceTextFromEditor dialog now selects the
				// ai_proj command-line specified project

			} // end of if (m_bCollaboratingWithParatext || m_bCollaboratingWithBibledit)
			else
			{
				// Collaboration is turned OFF, so that the designated AI project will
				// be preselected when the wizard appears.
				// The selection of a project in the projectPage is based on the value
				// contained in the App's m_curProjectName member
				m_curProjectName = m_ForceCollabAIProjectName;
				m_curProjectPath = m_workFolderPath + PathSeparator + m_curProjectName; // see above
			}
		}
		// At this point the wizard will appear (if collaboration is OFF or
		// m_bForceCollabModeOFF is TRUE); or the GetSourceTextFromEditor
		// dialog will appear. In either case those functions will try to
		// pre-select the project declared in the -ai_proj command-line option
	}
}
*/

void CAdapt_ItApp::GetCollaborationSettingsOfAIProject(wxString projectName, wxArrayString& collabLabelsArray,
													   wxArrayString& collabSettingsArray)
{
	wxString curProjPathAndName;
	wxString projConfigPathAndName;
	if (!m_customWorkFolderPath.IsEmpty() && m_bUseCustomWorkFolderPath)
	{
		curProjPathAndName = m_customWorkFolderPath + PathSeparator
								 + projectName; // use the incoming project name
	}
	else
	{
		curProjPathAndName = m_workFolderPath + PathSeparator
								 + projectName; // use the incoming project name
	}
	projConfigPathAndName = curProjPathAndName + PathSeparator + szProjectConfiguration + _T(".aic");

	// Get the project configuration file open in memory in a wxTextFile
	wxTextFile f;
	bool bOpenedOK = f.Open(projConfigPathAndName);
	// should open ok, if not, tell the developer & abort
	if (bOpenedOK)
	{
		// Scan file for the Collab... settings and use them to populate the
		// collabLabelsArray and collabSettingsArray which are returned to the
		// caller as reference parameters.
		wxString tab = _T("\t");
		wxString lineStr;
		for (lineStr = f.GetFirstLine(); !f.Eof(); lineStr = f.GetNextLine())
		{
			int chPos;
			int tabPos;
			lineStr.Trim(FALSE); // trim any white space from left end (possibly due to manual editing of config file)
			chPos = lineStr.Find(_T("Collab"));
			tabPos = lineStr.Find(tab);
			wxString strFollowingTab = _T("");
			wxString strLabel = _T("");
			if (chPos == 0)
			{
				// parse the szLabel part and the "Collab..." part storing them in the
				// appropriate wxArrayStrings for return to the caller via the reference
				// parameters
				strLabel = lineStr.Mid(0,tabPos);
				strLabel.Trim(FALSE);
				strLabel.Trim(TRUE);
				collabLabelsArray.Add(strLabel);
				strFollowingTab = lineStr.Mid(tabPos);
				strFollowingTab.Trim(FALSE);
				strFollowingTab.Trim(TRUE);
				collabSettingsArray.Add(strFollowingTab);
			}
		}
	}
	else
	{
		; // TODO: Report Error?
	}
	f.Close();
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if an Adapt It project is open, FALSE if no Adapt It project is open
/// \remarks
/// Called from CSetupEditorCollaboration::OnInit().
/// Determines if an Adapt It project is currently open, as determined by whether the
/// KB is NULL or not. If the KB is NULL, no project is open.
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::IsAIProjectOpen()
{
	return m_pKB != NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the Adaptations folder of the m_projectName has one or more AI 
///                         documents within it that have a "_Collab" prefixed on the name(s). 
///                         FALSE if no documents within the Adaptations folder have the
///                         "_Collab" prefix.
/// \param      m_projectName  -> a wxString containing the project name to check
/// \remarks
/// Called from CProjectPage::OnWizardPageChanging().
/// Scans the Adaptations sub-folder of the m_projectName folder looking for AI document
/// files whose names begin with "_Collab...". If any are found the function immediately 
/// returns TRUE. If none are found the function returns FALSE.
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::AIProjectHasCollabDocs(wxString m_projectName)
{
	bool projHasCollabDocs = FALSE;
	wxASSERT(!m_projectName.IsEmpty());
	wxString workOrCustomFolderPath;
	if (!m_bUseCustomWorkFolderPath)
	{
		workOrCustomFolderPath = m_workFolderPath;
	}
	else
	{
		workOrCustomFolderPath = m_customWorkFolderPath;
	}
	wxString path2Adaptations = workOrCustomFolderPath + PathSeparator + m_projectName + PathSeparator + m_adaptionsFolder;
    
	wxString saveCurWorkingDir = ::wxGetCwd();
	// Scan the files in the Adaptations folder for any that start with a "_Collab" substring.
	wxDir finder;
	bool bOK = (::wxSetWorkingDirectory(path2Adaptations) && finder.Open(path2Adaptations)); // wxDir
	bOK = bOK; // avoid warning
	wxString str = _T("");
	bool bWorking = finder.GetFirst(&str,wxEmptyString,wxDIR_FILES);
	// whm note: wxDIR_FILES finds only files; it ignores directories, and . and ..
	while (bWorking)
	{
		if (str.Find(_T("_Collab")) == 0)
		{
			projHasCollabDocs = TRUE;
			break;
		}
		bWorking = finder.GetNext(&str);
	}
	::wxSetWorkingDirectory(saveCurWorkingDir); // ignore failures
	return projHasCollabDocs;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the m_projectName AI project has been setup for collaboration by an
///                         administrator for collaboration with Paratext/Bibledit, FALSE
///                         otherwise
/// \param      m_projectName  -> a wxString containing the project name to check
/// \remarks
/// Called from CDocPage::OnSetActive().
/// Opens the AI-ProjectConfiguration.aic file associated with the m_projectName in a
/// wxTextFile and scans through the project config file (in memory) and determines from
/// the "Collab..." settings in the file if the project was set up for collaboration with
/// Paratext or Bibledit. We don't use the normal GetProjectConfiguration() mechanism here
/// so as to not set the App's project settings prematurely by reading the project
/// configuration file into the App's variables which might have undesirable side effects.
/// Note: This function does not validate the collaboration settings. All such validation
/// and consistency checking is done in the CProjectPage's call of GetAIProjectCollabStatus().
/// Here we only check for the existence of three of the collaboration settings: 
/// "CollabProjectForSourceInputs", "CollabProjectForTargetExports" and "CollabAIProjectName".
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::AIProjectIsACollabProject(wxString m_projectName)
{
	bool isCollabProject = FALSE;
	wxString curProjPathAndName;
	wxString projConfigPathAndName;
	if (!m_customWorkFolderPath.IsEmpty() && m_bUseCustomWorkFolderPath)
	{
		curProjPathAndName = m_customWorkFolderPath + PathSeparator
								 + m_curProjectName;
	}
	else
	{
		curProjPathAndName = m_workFolderPath + PathSeparator
								 + m_curProjectName;
	}
	projConfigPathAndName = curProjPathAndName + PathSeparator + szProjectConfiguration + _T(".aic");

	// whm added 11Mar12 if there is no project config file, it obviously is not a collab project
	// so return FALSE.
	if (!::wxFileExists(projConfigPathAndName))
		return FALSE;

	// Get the project configuration file open in memory in a wxTextFile
	wxTextFile f;
	bool bOpenedOK = f.Open(projConfigPathAndName);
	// should open ok, if not, tell the developer & abort
	if (bOpenedOK)
	{
		// Scan file for the Collab... settings and use them to determine if a collaboration
		// setup has been established by an administrator
		//
		// Note: In the config file, there are three main collaboration settings that govern
		// whether collaboration setup has been successfully established for the project:
		//   "CollabProjectForSourceInputs"
		//   "CollabProjectForTargetExports"
		//   "CollabAIProjectName"
		// If all three of these config labels are followed by string values and the string
		// stored in the "CollabAIProjectName" is identical to the m_projectName incoming
		// parameter, we can safely assume that collaboration has been established for this
		// project. We could do some sanity checks if needed but that would mainly detect if
		// someone has been manually editing the config file, in which case anything could
		// happen.
		wxString tab = _T("\t");
		wxString lineStr;
		bool bFoundCollabLineStrOK1 = FALSE;
		bool bFoundCollabLineStrOK2 = FALSE;
		bool bFoundCollabLineStrOK3 = FALSE;
		for (lineStr = f.GetFirstLine(); !f.Eof(); lineStr = f.GetNextLine())
		{
			int chPos;
			int tabPos;
			lineStr.Trim(FALSE); // trim any white space from left end (possibly due to manual editing of config file)
			chPos = lineStr.Find(szCollabProjectForSourceInputs); // CollabProjectForSourceInputs
			tabPos = lineStr.Find(tab); tabPos = tabPos; // unused, so prevent compiler warning
			wxString strFollowingTab = _T("");
			if (chPos == 0)
			{
				// check for a following non-empty string
				strFollowingTab = lineStr.Mid(szCollabProjectForSourceInputs.Length());
				strFollowingTab.Trim(FALSE);
				strFollowingTab.Trim(TRUE);
				if (!strFollowingTab.IsEmpty())
					bFoundCollabLineStrOK1 = TRUE;
				continue;
			}
			chPos = lineStr.Find(szCollabProjectForTargetExports); // CollabProjectForTargetExports
			if (chPos == 0)
			{
				// check for a following non-empty string
				strFollowingTab = lineStr.Mid(szCollabProjectForTargetExports.Length());
				strFollowingTab.Trim(FALSE);
				strFollowingTab.Trim(TRUE);
				if (!strFollowingTab.IsEmpty())
					bFoundCollabLineStrOK2 = TRUE;
				continue;
			}
			chPos = lineStr.Find(szCollabAIProjectName); // CollabAIProjectName
			if (chPos == 0)
			{
				// check for a following non-empty string that matches m_projectName
				strFollowingTab = lineStr.Mid(szCollabAIProjectName.Length());
				strFollowingTab.Trim(FALSE);
				strFollowingTab.Trim(TRUE);
				if (!strFollowingTab.IsEmpty())
					bFoundCollabLineStrOK3 = TRUE;
				break; // break for the last string
			}
		}
		if (!bFoundCollabLineStrOK1 || !bFoundCollabLineStrOK2 || !bFoundCollabLineStrOK3)
		{
			// One or more of the necessary Collab... lines were missing from the config file
			// so we judge that this project is not a well-setup collab project. This is not
			// an error since non-collaboration projects will return FALSE.
			isCollabProject = FALSE;
		}
		else
		{
			// All three Collab... labels were found and all are followed by a
			// string and the last one's string == m_projectName, so return TRUE.
			isCollabProject = TRUE;
		}
	}
	else
	{
		// Note: In the CProjectPage::OnWizardPageChanging(), a more thorough check
		// and reporting of any condition preventing the opening of the project config
		// file is done in which the user is prevented from advancing away from the
		// ProjectPage if the project config file cannot be opened. We only get to the
		// DocPage - where this function is called - if the project config file was
		// successfully read back in the ProjectPage. Therefore, it is highly unlikely 
		// that something could go wrong in the split second between the ProjectPage 
		// and the DocPage. But, to cover the bases we will check whether this project's
		// Adaptations folder contains any _Collab... documents within it. If so we will
		// set isCollabProject to TRUE. If the Adaptations folder has no _Collab... docs
		// we will set isCollabProject to FALSE.
		wxString msg = _("Adapt It could not open the project configuration file (AI-ProjectConfiguration.aic) for the \"%s\" project. Please ask your administrator for help.");
		msg = msg.Format(msg,m_projectName.c_str());
		wxMessageBox(msg,_("This project's configuration settings could not be read"),wxICON_WARNING);
		// Add the following to the msg for the user log:
		msg += _T(" ");
		if (AIProjectHasCollabDocs(m_projectName))
		{
			isCollabProject = TRUE;
			msg += _T("The project's Adaptations folder contains collaboration documents, therefore the DocPage list will not display _Collab... docs.");
		}
		else
		{
			isCollabProject = FALSE;
			msg += _T("The project's Adaptations folder contains no collaboration documents, therefore the DocPage list will display all docs.");
		}
		this->LogUserAction(_T("In AIProjectIsACollabProject(): ") + msg);
	}
	f.Close();
	return isCollabProject;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     returns an enum of type AiProjectCollabStatus which can be one of 
///             collabProjExistsAndIsValid, collabProjExistsButIsInvalid,  
///             collabProjNotConfigured, projConfigFileMissing, or
///             projConfigFileUnableToOpen
/// \param      m_projectName  -> a wxString containing the project name to check (which
///                                 the user selected in the caller)
/// \param      errorStr <- a wxString that contains an information when an error occurs
/// \param      bChangeMadeToCollabSettings <- a bool the indicates if a change was made
///                                             to the collab settings during validation
/// \remarks
/// Called from CProjectPage::OnWizardPageChanging().
/// Opens the AI-ProjectConfiguration.aic file associated with the m_projectName in a
/// wxTextFile and scans through the project config file (in memory) and collects data about
/// the "Collab..." settings. This function also performs a number of sanity checks and 
/// corrects irregularities in the collaboration settings where possible - to correct 
/// manually edited typos or missing collab setting fields which can be deduced from other 
/// collab settings. The names of Paratext or Bibledit projects are checked against the 
/// currently installed Paratext or Bibledit projects. If the collaboration settings are 
/// undefined in the project config file the function returns collabProjNotConfigured. 
/// We don't use the normal GetProjectConfiguration() mechanism here for "reading" the 
/// project config file, so as to not set the App's project settings prematurely by reading 
/// the project configuration file into the App's variables which might have undesirable side 
/// effects.
//////////////////////////////////////////////////////////////////////////////////////////
enum AiProjectCollabStatus CAdapt_ItApp::GetAIProjectCollabStatus(wxString m_projectName, wxString& errorStr, 
											bool& bChangeMadeToCollabSettings, wxString& errorProjects)
{
	// whm 20Apr12 created to return an enum of states and expanded sanity
	// checking of the collab values stored in the project config file.
	// Also returns an wxString errorStr and a bool bChangeMadeToCollabSettings 
	// which are returned to the caller by reference, to inform the caller of
	// errors and any changes made to the collab settings (which can then be saved
	// by the caller to the project config file).
	bChangeMadeToCollabSettings = FALSE;
	wxString curProjPathAndName;
	wxString projConfigPathAndName;
	if (!m_customWorkFolderPath.IsEmpty() && m_bUseCustomWorkFolderPath)
	{
		curProjPathAndName = m_customWorkFolderPath + PathSeparator
								 + m_curProjectName;
	}
	else
	{
		curProjPathAndName = m_workFolderPath + PathSeparator
								 + m_curProjectName;
	}
	projConfigPathAndName = curProjPathAndName + PathSeparator + szProjectConfiguration + _T(".aic");

	// whm added 11Mar12 if there is no project config file, it obviously is not a collab project
	// so return collabProjNotConfigured to caller to issue message to user there.
	if (!::wxFileExists(projConfigPathAndName))
	{
		// This is the exit point for an AI project whose config file is not present in
		// the project's folder.
		wxString msg = _("The Adapt It project \"%s\" is missing its project configuration file (AI-ProjectConfiguration.aic).");
		msg = msg.Format(msg,m_projectName.c_str());
		errorStr = msg; // return the errorStr to the caller by reference
		return projConfigFileMissing;
	}

	// Get the project configuration file open in memory in a wxTextFile
	wxTextFile f;
	bool bOpenedOK = f.Open(projConfigPathAndName);
	// Should open ok, if not, return projConfigFileUnableToOpen to caller to issue message
	// to user there.
	if (bOpenedOK)
	{
		// Scan file for the Collab... settings and use them to determine if a collaboration
		// setup has been established by an administrator, and for sanity checks.
		//
		// Note: In the config file, there are six main collaboration settings that govern
		// whether collaboration setup has been successfully established for the project:
		//   "CollabProjectForSourceInputs"
		//   "CollabProjectForTargetExports"
		//   "CollabAIProjectName"
		//   "CollaborationEditor"
		//   "CollabSourceLangName"
		//   "CollabTargetLangName"
		// If all six of these config labels are followed by string values and the strings
		// are consistent/valid, we can safely assume that collaboration has been established 
		// for this project. 
		// Note: We also collect any collab setting for 
		//   "CollabProjectForFreeTransExports"
		//   "CollabExpectsFreeTrans"
		// The CollabProjectForFreeTransExports is an optional setting for collaboration, but
		// the CollabExpectsFreeTrans must be TRUE or FALSE depending on whether CollabProjectForFreeTransExports
		// has content or not. If CollabProjectForFreeTransExports has a string value we need to check for 
		// validity in the CollabProjectsAreValid() call farther below and that CollabProjectForFreeTransExports
		// and CollabExpectsFreeTrans are in sync.
		wxString tab = _T("\t");
		wxString lineStr;
		bool bFoundCollabSrcProj = FALSE;
		bool bFoundCollabTgtProj = FALSE;
		bool bFoundCollabFreeTransProj = FALSE; // (optional)
		bool bFoundCollabExpectsFreeTrans = FALSE; 
		bool bFoundCollabAiProj = FALSE;
		bool bFoundCollabEditor = FALSE;
		bool bFoundCollabSrcLangName = FALSE;
		bool bFoundCollabTgtLangName = FALSE;
		wxString CollabSrcProjStrFound = _T("");
		wxString CollabTgtProjStrFound = _T("");
		wxString CollabFreeTransProjStrFound = _T(""); // (optional)
		wxString CollabExpectsFreeTransFound = _T("");
		wxString CollabAiProjStrFound = _T("");
		wxString CollabEditorStrFound = _T("");
		wxString CollabSrcLangNameStrFound = _T("");
		wxString CollabTgtLangNameStrFound = _T("");
		// Scan through the in-memory lines of the project config file setting the boolean flags
		// indicating the presence or absence of each collab setting.
		for (lineStr = f.GetFirstLine(); !f.Eof(); lineStr = f.GetNextLine())
		{
			int chPos;
			int tabPos;
			lineStr.Trim(FALSE); // trim any white space from left end (possibly due to manual editing of config file)
			chPos = lineStr.Find(szCollabProjectForSourceInputs);
			tabPos = lineStr.Find(tab); tabPos = tabPos; // unused, so prevent compiler warning
			if (chPos == 0)
			{
				// Check for a following non-empty string, storing any string found for sanity checks (below)
				CollabSrcProjStrFound = lineStr.Mid(szCollabProjectForSourceInputs.Length());
				CollabSrcProjStrFound.Trim(FALSE);
				CollabSrcProjStrFound.Trim(TRUE);
				if (!CollabSrcProjStrFound.IsEmpty())
					bFoundCollabSrcProj = TRUE;
				continue; // use continue in case collab values ever get set in a different order in config file
			}
			chPos = lineStr.Find(szCollabProjectForTargetExports);
			if (chPos == 0)
			{
				// Check for a following non-empty string, storing any string found for sanity checks (below)
				CollabTgtProjStrFound = lineStr.Mid(szCollabProjectForTargetExports.Length());
				CollabTgtProjStrFound.Trim(FALSE);
				CollabTgtProjStrFound.Trim(TRUE);
				if (!CollabTgtProjStrFound.IsEmpty())
					bFoundCollabTgtProj = TRUE;
				continue;
			}
			chPos = lineStr.Find(szCollabProjectForFreeTransExports);
			if (chPos == 0)
			{
				// Check for a following non-empty string, storing any string found for sanity checks (below)
				CollabFreeTransProjStrFound = lineStr.Mid(szCollabProjectForFreeTransExports.Length());
				CollabFreeTransProjStrFound.Trim(FALSE);
				CollabFreeTransProjStrFound.Trim(TRUE);
				if (!CollabFreeTransProjStrFound.IsEmpty())
					bFoundCollabFreeTransProj = TRUE;
				continue;
			}
			chPos = lineStr.Find(szCollabExpectsFreeTrans);
			if (chPos == 0)
			{
				// Check for a following non-empty string, storing any string found for sanity checks (below)
				CollabExpectsFreeTransFound = lineStr.Mid(szCollabExpectsFreeTrans.Length());
				CollabExpectsFreeTransFound.Trim(FALSE);
				CollabExpectsFreeTransFound.Trim(TRUE);
				if (!CollabExpectsFreeTransFound.IsEmpty())
					bFoundCollabExpectsFreeTrans = TRUE;
				continue;
			}
			chPos = lineStr.Find(szCollabAIProjectName);
			if (chPos == 0)
			{
				// Check for a following non-empty string, storing any string found for sanity checks (below)
				CollabAiProjStrFound = lineStr.Mid(szCollabAIProjectName.Length());
				CollabAiProjStrFound.Trim(FALSE);
				CollabAiProjStrFound.Trim(TRUE);
				if (!CollabAiProjStrFound.IsEmpty())
					bFoundCollabAiProj = TRUE;
				continue;
			}
			chPos = lineStr.Find(szCollaborationEditor);
			if (chPos == 0)
			{
				// Check for a following non-empty string, storing any string found for sanity checks (below)
				CollabEditorStrFound = lineStr.Mid(szCollaborationEditor.Length());
				CollabEditorStrFound.Trim(FALSE);
				CollabEditorStrFound.Trim(TRUE);
				if (!CollabEditorStrFound.IsEmpty())
					bFoundCollabEditor = TRUE;
				continue;
			}
			chPos = lineStr.Find(szCollabSourceLangName);
			if (chPos == 0)
			{
				// Check for a following non-empty string, storing any string found for sanity checks (below)
				CollabSrcLangNameStrFound = lineStr.Mid(szCollabSourceLangName.Length());
				CollabSrcLangNameStrFound.Trim(FALSE);
				CollabSrcLangNameStrFound.Trim(TRUE);
				if (!CollabSrcLangNameStrFound.IsEmpty())
					bFoundCollabSrcLangName = TRUE;
				continue;
			}
			chPos = lineStr.Find(szCollabTargetLangName);
			if (chPos == 0)
			{
				// Check for a following non-empty string, storing any string found for sanity checks (below)
				CollabTgtLangNameStrFound = lineStr.Mid(szCollabTargetLangName.Length());
				CollabTgtLangNameStrFound.Trim(FALSE);
				CollabTgtLangNameStrFound.Trim(TRUE);
				if (!CollabTgtLangNameStrFound.IsEmpty())
					bFoundCollabTgtLangName = TRUE;
				continue;
			}
		}

		// At this point the collab settings have been examined, found flags set and strings stored.
		f.Close();

		// Do some sanity checks to ensure that the crucial strings are consistent and
		// represent valid projects (guarding against corruption or erroneous editing of the
		// project config file):
		// 
		// The first 6 are checks for when the CollabAIProjectName field has a string entry:
		// 1. Ensure that the CollaborationEditor field is set to either "Paratext" or "Bibledit".
		// 2. Check that the string stored in the "CollabAIProjectName" is identical to the 
		// m_projectName incoming parameter.
		// 3. Check for existence of the CollabSourceLangName field. If it is missing parse the source
		// lang name from the CollabAIProjectName and assign that name to CollabSourceLangName.
		// 4. If the CollabSourceLangName exists, check whether it agrees with the parsed source lang
		// name from the CollabAIProjectName string. If not just log the fact that it differs.
		// 5. Check for existence of the CollabTargetLangName field. If it is missing parse the target
		// lang name from the CollabAIProjectName and assign that name to CollabTargetLangName.
		// 6. If the CollabTargetLangName exists, check whether it agrees with the parsed target lang
		// name from the CollabAIProjectName string. If not just log the fact that it differs.
		// 
		// The next 5 checks are for when the CollabAIProjectName field is missing/empty:
		// 7. If the other 5 collab settings are present, construct a potential CollabAIProjectName
		// field entry from the CollabSourceLangName and CollabTargetLangName fields. If the
		// constructed name agrees with the currently selected AI project, go ahead and assign
		// the name of the currently selected project to the CollabAIProjectName field.
		// 8. If the constructed project name in 7 is not the same as the currently selected
		// project name, force the CollabAIProjectName, the CollabSourceLangName and the
		// CollabTargetLangName fields to agree with the currently selected AI project name.
		// 9. If all of the other 4 collab settings (not counting CollaborationEditor) are also 
		// missing/empty, that is the normal situation for projects that have not been 
		// configured for collaboration by the administrator.
		// 10. If the bFoundCollabSrcProj and bFoundCollabTgtProj were TRUE, but bFoundCollabAiProj was 
		// FALSE, and either bFoundCollabSrcLangName or bFoundCollabTgtLangName or both were FALSE we 
		// can construct the AI project names from the currently selected project (m_projectName).
		// 11. If any of the collab settings (mentioned in 9 above) are present, it is a mixed
		// bag. We just log information about the irregular settings, and consider the project
		// status is collabProjNotConfigured.
		// 
		// The next checks are for validating the PT/BE collaboraion projects:
		// 12. If the CollabProjectForSourceInputs or CollabProjectForTargetExports is 
		// missing/empty from the config file, pass an error message back to the caller 
		// saying that the setting for the PT/BE project(s) is missing from the config
		// file, and return the collab status as collabProjMissingFromEditorList. The
		// caller (ProjectPage) will allow the user to select from available PT/BE projects
		// which, if the PT/BE projects prove valid will allow the user to continue collab
		// work.
		// 13. If the CollabProjectForSourceInputs or CollabProjectForTargetExports is 
		// missing/empty from the config file, BUT a free trans project was designated in
		// the CollabProjectForFreeTransExports string setting, AND that PT/BE project 
		// tests out to be INVALID, process that invalid project problem here with the
		// missing CollabProjectForSourceInputs/CollabProjectForTargetExports problem,
		// and pass it also as part of the error message back to the caller saying that 
		// the setting for the PT/BE project(s) is missing from the config
		// file (or invalid in the case of the free trans proj). We still return the collab 
		// status as collabProjMissingFromEditorList. The caller (ProjectPage) will allow 
		// the user to select from available PT/BE projects which, if the PT/BE projects 
		// prove valid will allow the user to continue collab work.
		// 14. If the CollabProjectForSourceInputs or CollabProjectForTargetExports fields
		// are present in the config file, check to ensure that they are also listed in the
		// PT/BE projList of current editor projects. If not pass an error message back to
		// the caller saying that the setting for the PT/BE project(s) could not be found
		// as a %s [external editor] project, and return the collab status as 
		// collabProjMissingFromEditorList. The caller (ProjectPage) will allow the user to 
		// select from available PT/BE projects which, if the PT/BE projects prove valid,
		// will allow the user to continue collab work.
		// 15. If both the CollabProjectForSourceInputs and CollabProjectForTargetExports fields
		// are present, and they exist in projList as Editor projects (see above checks), call the 
		// CollabProjectsAreValid() function on them (and the CollabProjectForFreeTransExports value). 
		// If the CollabProjectsAreValid() returns FALSE - along with an errStr message, return the 
		// errorStr message to the caller and return the collab status as collabProjExistsButIsInvalid.
		// The caller (ProjectPage) will allow the user to select from available PT/BE projects which, 
		// if the PT/BE projects prove valid, will allow the user to continue collab work.
		// 16. If the GetAIProjectCollabStatus() function has not returned a state value by 
		// time control reaches this point, just return the collab status as 
		// collabProjNotConfigured.
		// 17. If the project config file could not be opened successfully, return an error
		// message to that fact and return the collab status as projConfigFileUnableToOpen.

		// 1. Ensure that the CollaborationEditor field is set to either "Paratext" or "Bibledit".
		// 
		// First do sanity test for the bFoundCollabEditor and ensure it is specified properly
		// whm 2May12 added this sanity test for a valid external editor for collaboration. It is
		// possible that a project could be copied (including the project config file) between a
		// Linux machine and a Windows machine. In such cases the CollaborationEditor field may
		// no longer refer to an existing external edditor. If the machine receiving the data does 
		// have a different external Scripture editor installed, we can adjust the value of 
		// CollaborationEditor to point to that existing external editor. If no external editor is 
		// installed/available we need to prevent ...
		// 
		// If the values for CollabAiProjStrFound, CollabSrcLangNameStrFound, and 
		// CollabTgtLangNameStrFound are not empty, we can assume that the project was at some 
		// point configured by an administrator as a collaboration project.
		// Check whether there is an actual installation of Paratext or Bibledit on the user's
		// machine. If not we must return collabProjExistsButEditorNotInstalled.
		if (!CollabAiProjStrFound.IsEmpty() && !CollabSrcLangNameStrFound.IsEmpty() && !CollabTgtLangNameStrFound.IsEmpty()
			&& !ParatextIsInstalled() && !BibleditIsInstalled())
		{
			// Although there are collaboration values in the project config file, there is currently
			// no installation of Paratext or Bibledit on the machine, so regardless of whether
			// the bFoundCollabEditor is TRUE or FALSE, the user's computer is not set up to
			// do collaboration. Return that status with collabProjExistsButEditorNotInstalled.
			wxString msg = _("The Adapt It project \"%s\" has been setup for collaboration, but neither Paratext nor Bibledit are installed on this computer. In order to continue to work on this project, Paratext or Bibledit need to be installed with the necessary projects for collaboration with Adapt It.");
			msg = msg.Format(msg,m_projectName.c_str());
			errorStr = msg;
			return collabProjExistsButEditorNotInstalled;
		}
		
		// If we get here either Paratext or Bibledit is installed on the user's machine.
		// If there is an external editor designated in the project config file, ensure that
		// the designated editor is actually the one that is installed. If not assign 
		// m_collaborationEditor to point to the one that is installed.
		if (bFoundCollabEditor)
		{
			// There is a string in the CollabEditorStrFound field of the project config file.
			// Verify that the collaboration editor that has been specified in the config file is
			// actually installed on the computer. If not, check to see if the other external
			// editor is installed and if it is, use it instead.
			bool bDesignatedEditorIsInstalled = FALSE;
			if (m_collaborationEditor == _T("Paratext") && ParatextIsInstalled())
			{
				 bDesignatedEditorIsInstalled = TRUE;
			}
			else if (m_collaborationEditor == _T("Bibledit") && BibleditIsInstalled())
			{
				 bDesignatedEditorIsInstalled = TRUE;
			}
			if (!bDesignatedEditorIsInstalled)
			{
				// The collaboration editor designated in the project config file is not installed
				// on this machine. Check to see if the other editor choice is installed on this
				// machine (might happen if config files are copied between Windows and Linux 
				// machines).
				if (m_collaborationEditor == _T("Paratext") && m_bBibleditIsInstalled)
				{
					m_collaborationEditor = _T("Bibledit");
					m_bCollaboratingWithBibledit = TRUE;
					m_bCollaboratingWithParatext = FALSE;
					bChangeMadeToCollabSettings = TRUE; // to force a save of project config file with new setting
					wxString msg = _T("In GetAIProjectCollabStatus() the CollaborationEditor field designated non-installed editor (%s). Adapt It assigned it to be '%s' which is installed.");
					msg = msg.Format(msg,CollabEditorStrFound.c_str(),m_collaborationEditor.c_str());
					this->LogUserAction(msg);
				}
				else if (m_collaborationEditor == _T("Bibledit") && m_bParatextIsInstalled)
				{
					m_collaborationEditor = _T("Paratext");
					m_bCollaboratingWithBibledit = FALSE;
					m_bCollaboratingWithParatext = TRUE;
					bChangeMadeToCollabSettings = TRUE; // to force a save of project config file with new setting
					wxString msg = _T("In GetAIProjectCollabStatus() the CollaborationEditor field designated non-installed editor (%s). Adapt It assigned it to be '%s' which is installed.");
					msg = msg.Format(msg,CollabEditorStrFound.c_str(),m_collaborationEditor.c_str());
					this->LogUserAction(msg);
				}
			}
		}
		if (!bFoundCollabEditor || !(CollabEditorStrFound == _T("Paratext") || CollabEditorStrFound == _T("Bibledit")))
		{
			wxString editorStr;
#ifdef __WXMSW__
			editorStr = _T("Paratext");
#else
			if (ParatextIsInstalled())
				editorStr = _T("Paratext");
			else
				editorStr = _T("Bibledit");
#endif
			m_collaborationEditor = editorStr;
			bChangeMadeToCollabSettings = TRUE; // to force a save of project config file with new setting
			wxString msg = _T("In GetAIProjectCollabStatus() the CollaborationEditor field was empty or mis-named (%s). Adapt It assigned it to be '%s'.");
			msg = msg.Format(msg,CollabEditorStrFound.c_str(),editorStr.c_str());
			this->LogUserAction(msg);
		}
		
		// Next do sanity test for the AI Project settings (CollabAIProjectName field)
		wxString srcNameStr;
		wxString tgtNameStr;
		GetSrcAndTgtLanguageNamesFromProjectName(m_projectName, srcNameStr, tgtNameStr);
		if (bFoundCollabAiProj)
		{
			// 2. Check that the string stored in the "CollabAIProjectName" is identcial to the 
			// m_projectName incoming parameter.
			//
			// A CollabAIProjectName string is stored in the config file. Do some sanity tests.
			// Test if the found string differs from the currently selected project in 
			// m_projectName. If so fix it.
			if (CollabAiProjStrFound != m_projectName)
			{
				// There was an AI project name in the field, but the name doesn't match
				// the name of the incoming m_projectName. The incoming m_projectName must be
				// the name of the project being opened, so we can unilaterally set the name of
				// the AI project for collaboration to the correct project name for storing in
				// the project config file (below).
				wxString msg = _T("In GetAIProjectCollabStatus() the user selected project name (%s) differed from the config file's CollabAIProjectName (%s), so AI assigned the selected project name to the config file entry.");
				msg = msg.Format(msg,m_projectName.c_str(),CollabAiProjStrFound.c_str());
				this->LogUserAction(msg);
				m_CollabAIProjectName = m_projectName;
				// We rectified the problem programmatically, so update the CollabAiProjStrFound
				// for other validation checks below.
				CollabAiProjStrFound = m_projectName; // update the found one too
				bChangeMadeToCollabSettings = TRUE;
				// Continue on with other validation checks for this project.
			}
			// Note: The ai project name now must necessarily exists as an AI project on the
			// user's machine (after all, the user just selected it from the project page's list).
			// 
			// 3. Check for existence of the CollabSourceLangName field. If it is missing parse the source
			// lang name from the CollabAIProjectName and assign that name to CollabSourceLangName.
			if (!bFoundCollabSrcLangName)
			{
				// The CollabSourceLangName was empty in the config file. We can supply the 
				// lang name(s) by assigning it from the parsed ai project name taking the first part.
				if (CollabSrcLangNameStrFound.IsEmpty())
				{
					wxString msg = _T("In GetAIProjectCollabStatus() the CollabSourceLangName was missing, so AI assigned %s to it by parsing the AI project name (%s)");
					msg = msg.Format(msg,srcNameStr.c_str(),m_projectName.c_str());
					this->LogUserAction(msg);
					m_CollabSourceLangName = srcNameStr;
					bChangeMadeToCollabSettings = TRUE;
					// We rectified the problem programmatically, so update the flags for other
					// validation checks below.
					bFoundCollabSrcLangName = TRUE;
					CollabSrcLangNameStrFound = srcNameStr;
					// Continue on with other validation checks for this project.
				}
			}
			else
			{
				// 4. If the CollabSourceLangName exists, check whether it agrees with the parsed source lang
				// name from the CollabAIProjectName string. If not just log the fact that it differs.
				//
				// At this point we know that a source lang name exists, now compare it with the 
				// source lang part of the ai project name, and put an entry in the user log if the
				// source lang name in the config file differs from the source language name parsed
				// from the AI project name.
				if (srcNameStr != CollabSrcLangNameStrFound)
				{
					wxString msg = _T("In GetAIProjectCollabStatus() the Source language name from the AI project name is %s, but the name from the config file is %s");
					msg = msg.Format(msg,srcNameStr.c_str(),CollabSrcLangNameStrFound.c_str());
					this->LogUserAction(msg);
					// Continue on with other validation checks for this project.
				}
				
			}
			// 5. Check for existence of the CollabTargetLangName field. If it is missing parse the target
			// lang name from the CollabAIProjectName and assign that name to CollabTargetLangName.
			if (!bFoundCollabTgtLangName)
			{
				// The CollabTargetLangName was empty in the config file. We can supply the 
				// lang name(s) by assigning it from the parsed ai project name taking the second part.
				if (CollabTgtLangNameStrFound.IsEmpty())
				{
					wxString msg = _T("In GetAIProjectCollabStatus() the CollabTargetLangName was missing, so AI assigned %s to it by parsing the AI project name (%s)");
					msg = msg.Format(msg,tgtNameStr.c_str(),m_projectName.c_str());
					this->LogUserAction(msg);
					m_CollabTargetLangName = tgtNameStr;
					bChangeMadeToCollabSettings = TRUE;
					// We rectified the problem programmatically, so update the flags for other
					// validation checks below
					bFoundCollabTgtLangName = TRUE;
					CollabTgtLangNameStrFound = tgtNameStr;
					// Continue on with other validation checks for this project.
				}
			}
			else
			{
				// 6. If the CollabTargetLangName exists, check whether it agrees with the parsed target lang
				// name from the CollabAIProjectName string. If not just log the fact that it differs.
				// 
				// At this point we know that a target lang name exists, now compare it with the 
				// target lang part of the ai project name, and put an entry in the user log if the
				// source lang name in the config file differs from the source language name parsed
				// from the AI project name.
				if (tgtNameStr != CollabTgtLangNameStrFound)
				{
					wxString msg = _T("In GetAIProjectCollabStatus() the Target language name from the AI project name is %s, but the name from the config file is %s");
					msg = msg.Format(msg,tgtNameStr.c_str(),CollabTgtLangNameStrFound.c_str());
					this->LogUserAction(msg);
					// Continue on with other validation checks for this project.
				}
			}
		}
		else
		{
			// The "CollabAIProjectName" in the config file was empty. If the bFoundCollabSrcProj, 
			// the bFoundCollabTgtProj, the bFoundCollabEditor, the bFoundCollabSrcLangName, 
			// and the bFoundCollabTgtLangName flags are TRUE we can confidently reconstruct the 
			// CollabAIProjectName from the two Lang Name fields and ensure that the reconstructed string
			// is consistent with the currently selected AI project. If so we can supply the string for the 
			// CollabAIProjectName field. Otherwise, if either one or both of the PT/BE project fields, or 
			// either one or both of the two Lang Name fields are empty, we presume that the project is not 
			// a configured/valid collaboration project.
			if (bFoundCollabSrcProj && bFoundCollabTgtProj && bFoundCollabSrcLangName && bFoundCollabTgtLangName && bFoundCollabEditor)
			{
				// 7. If the other 5 collab settings are present, construct a potential CollabAIProjectName
				// field entry from the CollabSourceLangName and CollabTargetLangName fields. If the
				// constructed name agrees with the currently selected AI project, go ahead and assign
				// the name of the currently selected project to the CollabAIProjectName field.
				// 
				// All the critical collab fields except for the CollabAIProjectName field were present in 
				// the config file, so the CollabAIProjectName field must have been lost or corrupted from
				// manual editing. We can reconstruct the potential ai project name from the Lang Names present.
				wxString constructedAIProjName = CollabSrcLangNameStrFound + _T(" to ") + CollabTgtLangNameStrFound + _T(" adaptations");
				// Check if it is consistent with the currently selected project name. If so, we can assign
				// the constructedAIProjName to the CollabAIProjectName. If not, we have no other recourse 
				// in reconstructing the complete collab settings and we must force it to be the same, and log
				// that fact.
				if (constructedAIProjName == m_projectName)
				{
					wxString msg = _T("In GetAIProjectCollabStatus() the CollabAIProjectName was missing, but the other collab settings found allowed it to be reassigned to %s, the currently selected ai project");
					msg = msg.Format(msg,m_projectName.c_str());
					this->LogUserAction(msg);
					this->m_CollabAIProjectName = m_projectName;
					// We rectified the problem programmatically, so update the flags for other
					// validation checks below
					CollabAiProjStrFound = m_projectName;
					bChangeMadeToCollabSettings = TRUE;
					// Continue on with other validation checks for this project.
				}
				else
				{
					// 8. If the constructed project name in 7 is not the same as the currently selected
					// project name, force the CollabAIProjectName, the CollabSourceLangName and the
					// CollabTargetLangName fields to agree with the currently selected AI project name.
					// 
					// The constructed project name is not the same as the currenly selected project's 
					// name, so we cannot really proceed with a collaboration session unless we force the
					// collab AI Project Name and the Lang Names to agree with the currently selected 
					// project. We will do that and log the actions that we have to take to make the
					// collaboration settings consistent with the currently selected project.
					// Note: Tests show that the check in 2 above and 10 below and other internal checks 
					// should remedy the issue here in 8. without the need for this test, but 8 is an 
					// additional fail-safe mechanism.
					wxString msg = _T("In GetAIProjectCollabStatus() the CollabAIProjectName was empty and the CollabSourceLangName and CollabTargetLangName fields are inconsistent with the currently selected project (%s). All three were changed to agree with a %s project.");
					msg = msg.Format(msg, m_projectName.c_str(),m_projectName.c_str());
					this->LogUserAction(msg);
					this->m_CollabAIProjectName = m_projectName;
					this->m_CollabSourceLangName = srcNameStr;
					this->m_CollabTargetLangName = tgtNameStr;
					// We rectified the problem programmatically, so update the flags for other
					// validation checks below
					CollabAiProjStrFound = m_projectName;
					CollabSrcLangNameStrFound = srcNameStr;
					CollabTgtLangNameStrFound = tgtNameStr;
					bChangeMadeToCollabSettings = TRUE;
					// Continue on with other validation checks for this project.
				}
			}
			else
			{
				// The "CollabAIProjectName" in the config file was empty, and one or more (perhaps all)
				// of the other four important collab values were not defined as strings in the config 
				// file. The obvious case is when all five values are empty - indicating the normal state 
				// for an AI project that has not been configured for collaboration by an administrator. 
				// We do not include the bFoundCollabEditor in the test because it should always be 
				// defined at this point (see above).
				// 
				// 9. If all of the other 4 collab settings (not counting CollaborationEditor) are also 
				// missing/empty, which is the normal situation for projects that have not been 
				// configured for collaboration by the administrator.
				// 
				if (!bFoundCollabSrcProj && !bFoundCollabTgtProj && !bFoundCollabSrcLangName && !bFoundCollabTgtLangName)
				{
					// This is the normal exit point for a project which has not been configured for 
					// collaboration with PT/BE.
					return collabProjNotConfigured;
				}
				else if (!bFoundCollabSrcLangName || !bFoundCollabTgtLangName)
				{
					// 10. If the bFoundCollabSrcProj and bFoundCollabTgtProj were TRUE, but bFoundCollabAiProj was 
					// FALSE, and either bFoundCollabSrcLangName or bFoundCollabTgtLangName or both were FALSE we 
					// can construct the AI project names from the currently selected project (m_projectName).
					wxString msg = _T("In GetAIProjectCollabStatus() the CollabAIProjectName is missing and one or both of the CollabSourceLangName or CollabTargetLangName are missing, so AI parsed %s and assigned the names to those 3 config file entries.");
					msg = msg.Format(msg,m_projectName.c_str());
					this->LogUserAction(msg);
					m_CollabAIProjectName = m_projectName;
					GetSrcAndTgtLanguageNamesFromProjectName(m_CollabAIProjectName,m_CollabSourceLangName,m_CollabTargetLangName);
					// We rectified the problem programmatically, so update the CollabAiProjStrFound
					// for other validation checks below.
					CollabAiProjStrFound = m_projectName; // update the found one too
					CollabSrcLangNameStrFound = m_CollabSourceLangName;
					CollabTgtLangNameStrFound = m_CollabTargetLangName;
					bChangeMadeToCollabSettings = TRUE;
					// Continue on with other validation checks for this project.
				}
				else
				{
					// 11. If any of the collab settings (mentioned in 9 above) are present, it is a mixed
					// bag. We just log information about the irregular settings, and consider the project
					// status is collabProjNotConfigured.
					//
					// If any of the above four flags are TRUE (indicating the presence of a collab setting), just 
					// log that fact as an irregularity, but with the CollabAIProjectName empty and at least one of
					// the other collab settings also empty, we judge that the project was not configured, or 
					// partially corrupted in any case. We could empty any partial settings, but probably it is
					// better to leave them present so an advisor or administrator can inspect the project config
					// file if desired.
					wxString tempStr = _T("");
					if (bFoundCollabSrcProj)
					{
						tempStr = _T("CollabProjectForSourceInputs: ");
					}
					if (bFoundCollabTgtProj)
					{
						if (!tempStr.IsEmpty())
							tempStr += _T(", ");
						tempStr += _T("CollabProjectForTargetExports: ");
					}
					if (bFoundCollabSrcLangName)
					{
						if (!tempStr.IsEmpty())
							tempStr += _T(", ");
						tempStr += _T("CollabSourceLangName: ");
					}
					if (bFoundCollabTgtLangName)
					{
						if (!tempStr.IsEmpty())
							tempStr += _T(", ");
						tempStr += _T("CollabTargetLangName: ");
					}
					if (!tempStr.IsEmpty())
					{
						wxString msg = _T("In GetAIProjectCollabStatus: The CollabAIProjectName was empty, but the following collab setting(s) had data: %s. Returning collabProjNotConfigured.");
						msg = msg.Format(msg,tempStr.c_str());
						this->LogUserAction(msg);
					}
					// This is the exit point for a project that is not configured for collaboration, but 
					// has some partial collaboration setting(s) which are now in the user log.
					return collabProjNotConfigured;
				}
			} // end of else block where one or more of five other values (apart from CollabAIProjectName) had collab data
		} // end of else "CollabAIProjectName" in the config file was empty

		// At this point, we've completed the above sanity tests, and the AI Collab Project should exist.
		wxASSERT(!m_CollabAIProjectName.IsEmpty());
		
		// Finally, do sanity tests for the indicated PT/BE collab projects. Do they exist and do they
		// have the necessary empty chapter and verse markers? The tests for the presence of empty 
		// chapter and verse markers that has been previously just done in the GetSourceTextFromEditor
		// dialog is also being done here (called from the wizard), earlier in the collaboration process 
		// at a point where incorrect settings are easier to handle and an advisor or administrator is 
		// more likely to see the problem and handle the situation.
		
		// Get a list of the current PT/BE projects in projList.
		wxArrayString projList;
		projList.Clear();
		if (m_collaborationEditor == _T("Paratext"))
		{
			projList = GetListOfPTProjects(); // as a side effect, it populates the App's m_pArrayOfCollabProjects
		}
		else if (m_collaborationEditor == _T("Bibledit"))
		{
			projList = GetListOfBEProjects(); // as a side effect, it populates the App's m_pArrayOfCollabProjects
		}

		// If either the source or target PT/BE project name(s) are missing, we cannot proceed with
		// collaboration
		// 
		// 12. If the CollabProjectForSourceInputs or CollabProjectForTargetExports is 
		// missing/empty from the config file, pass an error message back to the caller 
		// saying that the setting for the PT/BE project(s) is missing from the config
		// file, and return the collab status as collabProjMissingFromEditorList. The
		// caller (ProjectPage) will allow the user to select from available PT/BE projects
		// which, if the PT/BE projects prove valid will allow the user to continue collab
		// work.
		if (!bFoundCollabSrcProj || !bFoundCollabTgtProj)
		{
			wxString msg;
			wxString projects = _T("");
			if (!bFoundCollabSrcProj)
			{
				msg = _T("1. ");
				msg += _("The Adapt It project \"%s\" is missing its setting that designates its %s project for obtaining source texts.");
				msg = msg.Format(msg,m_projectName.c_str(), m_collaborationEditor.c_str());
				projects = _T("source");
			}
			if (!bFoundCollabTgtProj)
			{
				if (!msg.IsEmpty())
					msg += _T("\n2. ");
				else
					msg += _T("1. ");
				msg += _("The Adapt It project \"%s\" is missing its setting that designates its %s project for storing translation texts.");
				msg = msg.Format(msg,m_projectName.c_str(), m_collaborationEditor.c_str());
				if (!projects.IsEmpty())
					projects += _T(':');
				projects += _T("target");
			}
			// 13. If the CollabProjectForSourceInputs or CollabProjectForTargetExports is 
			// missing/empty from the config file, BUT a free trans project was designated in
			// the CollabProjectForFreeTransExports string setting, AND that PT/BE project 
			// tests out to be INVALID, process that invalid project problem here with the
			// missing CollabProjectForSourceInputs/CollabProjectForTargetExports problem,
			// and pass it also as part of the error message back to the caller saying that 
			// the setting for the PT/BE project(s) is missing from the config
			// file (or invalid in the case of the free trans proj). We still return the collab 
			// status as collabProjMissingFromEditorList. The caller (ProjectPage) will allow 
			// the user to select from available PT/BE projects which, if the PT/BE projects 
			// prove valid will allow the user to continue collab work.
			// 
			// Note: It could be that the source or target project (or both) are missing from the 
			// config file, and yet a free trans project string is present, but it might not be
			// a valid PT/BE project. If that is the case we should have the problem re the free 
			// trans project included with the above message - so that in the ProjectPage the user
			// can select a correct PT/BE project for the free trans.
			if (bFoundCollabFreeTransProj)
			{
				if (!CollabProjectHasAtLeastOneBook(CollabFreeTransProjStrFound))
				{
					// There is not at least one book in the Source project
					wxString msgAdd;
					msgAdd = _("The Adapt It project \"%s\" has a setting that designates its %s project for storing free translations, but the \"%s\" project does not have any books created in it.");
					msgAdd = msgAdd.Format(msgAdd,m_projectName.c_str(), m_collaborationEditor.c_str(),CollabFreeTransProjStrFound.c_str());
					if (!bFoundCollabSrcProj && !bFoundCollabTgtProj)
					{
						// neither src nor tgt were found and were items 1 and 2; free trans is item 3.
						msgAdd = _T("\n3. ") + msgAdd;
					}
					else if ((bFoundCollabSrcProj && !bFoundCollabTgtProj) || (bFoundCollabTgtProj && !bFoundCollabSrcProj))
					{
						// the src or tgt was found but not both getting item 1; free trans is item 2. 
						msgAdd = _T("\n2. ") + msgAdd;
					}
					else
					{
						// both src and tgt were found, so free trans is first item, item 1
						msgAdd = _T("\n1. ") + msgAdd;
					}
					msg += msgAdd;
					if (!projects.IsEmpty())
						projects += _T(':');
					projects += _T("freetrans");
				}
			}

			errorStr = msg; // return the errorStr to the caller by reference
			errorProjects += projects; // return the project type ("source", "target" or "freetrans"). 
			// This is the exit point for a project whose config file is missing its 
			// CollabProjectForSourceInputs or CollabProjectForTargetExports string value.
			return collabProjMissingFromConfigFile;
		}
		else
		{
			// 14. If the CollabProjectForSourceInputs or CollabProjectForTargetExports fields
			// are present in the config file, check to ensure that they are also listed in the
			// PT/BE projList of current editor projects. If not pass an error message back to
			// the caller saying that the setting for the PT/BE project(s) could not be found
			// as a %s [external editor] project, and return the collab status as 
			// collabProjMissingFromEditorList. The caller (ProjectPage) will allow the user to 
			// select from available PT/BE projects which, if the PT/BE projects prove valid,
			// will allow the user to continue collab work.
			// 			
			// both bFoundCollabSrcProj and bFoundBollabTgtProj are TRUE, so the project config file
			// contains strings for both. Now test that they exist in the inventory of current PT/BE 
			// projects (in projList) by calling CollabProjectFoundInListOfEditorProjects() on each
			// PT/BE project name that appears in the project config file.
			wxString foundSrcProjString = _T("");
			wxString foundTgtProjString = _T("");
			wxString foundFreeTransProjString = _T("");
			// In the CollabProjectFoundInListOfEditorProjects() function calls below the short name 
			// of the project is used (in PT) to match an existing PT/BE project (in projList). If 
			// the returned value is FALSE, no project was found, if the returned value is TRUE the 
			// project was found and the returned by reference foundProjString parameter will contain 
			// the actual composed string of the project - this is used to correct any typos in the 
			// full name part of a PT composite project id string.
			wxString msg = _T("");
			wxString projects = _T("");
			bool srcProjFoundInEditor = TRUE;
			bool tgtProjFoundInEditor = TRUE;
			bool freeTransProjFoundInEditor = TRUE;
			srcProjFoundInEditor = CollabProjectFoundInListOfEditorProjects(CollabSrcProjStrFound,projList,foundSrcProjString);
			tgtProjFoundInEditor = CollabProjectFoundInListOfEditorProjects(CollabTgtProjStrFound,projList,foundTgtProjString);
			if (!CollabFreeTransProjStrFound.IsEmpty())
				freeTransProjFoundInEditor = CollabProjectFoundInListOfEditorProjects(CollabFreeTransProjStrFound,projList,foundFreeTransProjString);
			if (!srcProjFoundInEditor)
			{
				// The project config file has an entry for the CollabSrcProjStrFound, but that project
				// could not be found in the PT/BE editor's list of current projects.
				wxString msgAdd = _("The \"%s\" project cannot be found as a %s project for obtaining source texts.");
				msgAdd = msgAdd.Format(msgAdd,CollabSrcProjStrFound.c_str(), m_collaborationEditor.c_str());
				msgAdd = _T("1. ") + msgAdd; // src was not found and is item 1
				msg += msgAdd;
				projects = _T("source");
			}
			else
			{
				// The project was found in the PT/BE editor's list of current projects.
				wxASSERT(!foundSrcProjString.IsEmpty());
				// Ensure the spelling of of full project name part in the config file is 
				// correct as used within the actual editor's full project name (user could
				// have changed it in PT).
				if (CollabSrcProjStrFound != foundSrcProjString)
				{
					// There was an irregularity in spelling of a token in the 2nd through 4th fields of the
					// composite project string. Fix the App's value and set flag to save the project config 
					// file changes.
					this->m_CollabProjectForSourceInputs = foundSrcProjString;
					bChangeMadeToCollabSettings = TRUE;
				}
			}
			if (!tgtProjFoundInEditor)
			{
				// The project config file has an entry for the CollabTgtProjStrFound, but that project
				// could not be found in the PT/BE editor's list of current projects.
				wxString msgAdd = _("The \"%s\" project cannot be found as a %s project for storing translation texts.");
				msgAdd = msgAdd.Format(msgAdd,CollabTgtProjStrFound.c_str(), m_collaborationEditor.c_str());
				if (!srcProjFoundInEditor)
				{
					// src was not found and was item 1; tgt is item 2.
					msgAdd = _T("\n2. ") + msgAdd;
				}
				else
				{
					// src was found; tgt is now item 1.
					msgAdd = _T("1. ") + msgAdd;
				}
				msg += msgAdd;
				if (!projects.IsEmpty())
					projects += _T(':');
				projects += _T("target");
			}
			else
			{
				// The project was found in the PT/BE editor's list of current projects.
				wxASSERT(!foundTgtProjString.IsEmpty());
				// Ensure the spelling of of full project name part in the config file is 
				// correct as used within the actual editor's full project name (user could
				// have changed it in PT).
				if (CollabTgtProjStrFound != foundTgtProjString)
				{
					// There was an irregularity in spelling of a token in the 2nd through 4th fields of the
					// composite project string. Fix the App's value and set flag to save the project config 
					// file changes.
					this->m_CollabProjectForTargetExports = foundTgtProjString;
					bChangeMadeToCollabSettings = TRUE;
				}
			}
			if (!CollabFreeTransProjStrFound.IsEmpty() && !freeTransProjFoundInEditor)
			{
				// The project config file has an entry for the CollabFreeTransProjStrFound, but that project
				// could not be found in the PT/BE editor's list of current projects.
				wxString msgAdd = _("The \"%s\" project cannot be found as a %s project for storing free translation texts.");
				msgAdd = msgAdd.Format(msgAdd,CollabFreeTransProjStrFound.c_str(), m_collaborationEditor.c_str());
				if (!srcProjFoundInEditor)
				{
					// src was not found as so was item 1
					if (!tgtProjFoundInEditor)
					{
						// both src and tgt were not found (items 1 and 2); free trans is now item 3.
						msgAdd = _T("\n3. ") + msgAdd;
					}
					else
					{
						// src was not found and was item 1, but tgt was found; free trans is now item 2.
						msgAdd = _T("\n2. ") + msgAdd;
					}
				}
				else
				{
					// src was found
					if (!tgtProjFoundInEditor)
					{
						// src was found but target not found and was item 1; free trans is item 2.
						msgAdd = _T("\n2. ") + msgAdd;
					}
					else
					{
						// both src and tgt were found; free trans is first item, item 1.
						msgAdd = _T("1. ") + msgAdd;
					}
				}
				msg += msgAdd;
				if (!projects.IsEmpty())
					projects += _T(':');
				projects += _T("freetrans");
			}
			else if (!CollabFreeTransProjStrFound.IsEmpty())
			{
				// The project was found in the PT/BE editor's list of current projects.
				wxASSERT(!foundFreeTransProjString.IsEmpty());
				// Ensure the spelling of of full project name part in the config file is 
				// correct as used within the actual editor's full project name (user could
				// have changed it in PT).
				if (CollabFreeTransProjStrFound != foundFreeTransProjString)
				{
					// There was an irregularity in spelling of a token in the 2nd through 4th fields of the
					// composite project string. Fix the App's value and set flag to save the project config 
					// file changes.
					this->m_CollabProjectForFreeTransExports = foundFreeTransProjString;
					bChangeMadeToCollabSettings = TRUE;
				}
			}

			// Also ensure that the m_bCollaborationExpectsFreeTrans flag is FALSE if the free trans
			// string is empty, TRUE if it has valid (as checked above) content.
			bool bCollabExpectsFreeTransAsFound = CollabExpectsFreeTransFound == _T("1");
			if (!bFoundCollabExpectsFreeTrans || bCollabExpectsFreeTransAsFound != !CollabFreeTransProjStrFound.IsEmpty())
			{
				this->m_bCollaborationExpectsFreeTrans = !CollabFreeTransProjStrFound.IsEmpty();
				bChangeMadeToCollabSettings = TRUE;
			}
			
			if (!srcProjFoundInEditor || !tgtProjFoundInEditor || (!CollabFreeTransProjStrFound.IsEmpty() && !freeTransProjFoundInEditor))
			{
				errorStr = msg; // return the errorStr to the caller by reference
				errorProjects = projects; // return the project type ("source", "target", or "freetrans") by reference
				return collabProjMissingFromEditorList;
			}

		}
		// Also ensure that the m_bCollaborationExpectsFreeTrans flag is FALSE if the free trans
		// string is empty, TRUE if it has valid (as checked above) content.
		bool bCollabExpectsFreeTransAsFound = CollabExpectsFreeTransFound == _T("1");
		if (!bFoundCollabExpectsFreeTrans || bCollabExpectsFreeTransAsFound != !CollabFreeTransProjStrFound.IsEmpty())
		{
			this->m_bCollaborationExpectsFreeTrans = !CollabFreeTransProjStrFound.IsEmpty();
			bChangeMadeToCollabSettings = TRUE;
		}

		// 15. If both the CollabProjectForSourceInputs and CollabProjectForTargetExports fields
		// are present, and they exist in projList as Editor projects (see above checks), call the 
		// CollabProjectsAreValid() function on them (and the CollabProjectForFreeTransExports value). 
		// If the CollabProjectsAreValid() returns FALSE - along with an errStr message, return the 
		// errorStr message to the caller and return the collab status as collabProjExistsButIsInvalid.
		// The caller (ProjectPage) will allow the user to select from available PT/BE projects which, 
		// if the PT/BE projects prove valid, will allow the user to continue collab work.
		if (bFoundCollabSrcProj && bFoundCollabTgtProj)
		{
			// Check the validity of the PT/BE projects. They are valid if they are not
			// empty and calls to CollabProjectHasAtLeastOneBook() indicate that the
			// projects have at least one book defined.
			// 
			// Note: This CollabProjectsAreValid() call is also done within the 3-button
			// ChooseCollabOptionsDlg's InitDialog() method using the App's stored values 
			// for the PT/BE projects' (composite) strings.
			wxString errStr = _T("");
			wxString errProj = _T("");
			if (!CollabProjectsAreValid(CollabSrcProjStrFound, CollabTgtProjStrFound, 
									CollabFreeTransProjStrFound, errStr, errProj))
			{
				errorStr = errStr;
				errorProjects = errProj;
				return collabProjExistsButIsInvalid;
			}
			// If we get here the projects are valid according to CollabProjectsAreValid() above.
			return collabProjExistsAndIsValid;
		}
		// 16. If the GetAIProjectCollabStatus() function has not returned a state value by 
		// time control reaches this point, just return the collab status as 
		// collabProjNotConfigured.
		// 
		// If we get here most if not all of the valid collab states have been bled off, so we can 
		// return collabProjNotConfigured for safety sake.
		return collabProjNotConfigured;
	} // end of if (bOpenedOK)
	else
	{
		// 17. If the project config file could not be opened successfully, return an error
		// message to that fact and return the collab status as projConfigFileUnableToOpen.
		// 
		// The f.Open() call failed for some reason.
		// This is the exit point for an AI project whose config file is present in
		// the project's folder but could not be opened/read.
		wxString msg = _("Adapt It could not open the project configuration file (AI-ProjectConfiguration.aic) for the \"%s\" project. Make sure the configuration file is not being used by another program (or reboot your computer) and try again.");
		msg = msg.Format(msg,m_projectName.c_str());
		errorStr = msg; // return the errorStr to the caller by reference
		return projConfigFileUnableToOpen;
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      combinedStr       -> a wxString containing a list of protected folder names
///                                 delimited by ':' characters
/// \remarks
/// Called from GetBasicSettingsConfiguration(), GetProjectSettingsConfiguration(), and
/// SetDefaults().
/// Uses wxStringTokenizer to parse the incoming string which contains the folders that
/// are to be protected from navigation, each folder name delimited by ':' characters.
/// The App's m_bProtect...Folder flags are set to TRUE if their associated folder name
/// is contained within combinedStr.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetFolderProtectionFlagsFromCombinedString(wxString combinedStr)
{
	// whm 30Sep11 added. Assume that folder protection for individual folders is OFF
	// unless it is turned on by the presence of the folder name in the combinedStr
	m_bProtectSourceInputsFolder = FALSE;
	m_bProtectFreeTransOutputsFolder = FALSE;
	m_bProtectFreeTransRTFOutputsFolder = FALSE;
	m_bProtectGlossOutputsFolder = FALSE;
	m_bProtectGlossRTFOutputsFolder = FALSE;
	m_bProtectInterlinearRTFOutputsFolder = FALSE;
	m_bProtectSourceOutputsFolder = FALSE;
	m_bProtectSourceRTFOutputsFolder = FALSE;
	m_bProtectTargetOutputsFolder = FALSE;
	m_bProtectTargetRTFOutputsFolder = FALSE;
	m_bProtectKbInputsAndOutputsFolder = FALSE;
	m_bProtectLiftInputsAndOutputsFolder = FALSE;
	m_bProtectPackedInputsAndOutputsFolder = FALSE;
	m_bProtectCCTableInputsAndOutputsFolder = FALSE;
	m_bProtectReportsOutputsFolder = FALSE;

	// tokenize the folder name elements in m_foldersProtectedFromNavigation
	// that are delimited by ':' chars
	wxString tokenStr;
	wxStringTokenizer tkz(combinedStr,_T(":"));
	while (tkz.HasMoreTokens())
	{
		// add the tokenStr to fitPartStr if it doesn't make fitPartStr get longer than extentRemaining
		tokenStr = tkz.GetNextToken();
		if (tokenStr == m_sourceInputsFolderName)
			m_bProtectSourceInputsFolder = TRUE;
		else if (tokenStr == m_freeTransOutputsFolderName)
			m_bProtectFreeTransOutputsFolder = TRUE;
		else if (tokenStr == m_freeTransRTFOutputsFolderName)
			m_bProtectFreeTransRTFOutputsFolder = TRUE;
		else if (tokenStr == m_glossOutputsFolderName)
			m_bProtectGlossOutputsFolder = TRUE;
		else if (tokenStr == m_glossRTFOutputsFolderName)
			m_bProtectGlossRTFOutputsFolder = TRUE;
		else if (tokenStr == m_interlinearRTFOutputsFolderName)
			m_bProtectInterlinearRTFOutputsFolder = TRUE;
		else if (tokenStr == m_sourceOutputsFolderName)
			m_bProtectSourceOutputsFolder = TRUE;
		else if (tokenStr == m_sourceRTFOutputsFolderName)
			m_bProtectSourceRTFOutputsFolder = TRUE;
		else if (tokenStr == m_targetOutputsFolderName)
			m_bProtectTargetOutputsFolder = TRUE;
		else if (tokenStr == m_targetRTFOutputsFolderName)
			m_bProtectTargetRTFOutputsFolder = TRUE;
		else if (tokenStr == m_kbInputsAndOutputsFolderName)
			m_bProtectKbInputsAndOutputsFolder = TRUE;
		else if (tokenStr == m_liftInputsAndOutputsFolderName)
			m_bProtectLiftInputsAndOutputsFolder = TRUE;
		else if (tokenStr == m_packedInputsAndOutputsFolderName)
			m_bProtectPackedInputsAndOutputsFolder = TRUE;
		else if (tokenStr == m_ccTableInputsAndOutputsFolderName)
			m_bProtectCCTableInputsAndOutputsFolder = TRUE;
		else if (tokenStr == m_reportsOutputsFolderName)
			m_bProtectReportsOutputsFolder = TRUE;
		else
		{
			wxString msg;
			wxString removeStr = tokenStr + _T(':');
			msg = msg.Format(_T("Unrecognized value (%s) in FoldersProtectedFromNavigation setting in basic config file."),tokenStr.c_str());
			wxLogDebug(msg);
			// Remove the bad value from m_foldersProtectedFromNavigation. This should
			// not normally happen for users, but might happen in development if folder
			// names are changed.
			wxASSERT(m_foldersProtectedFromNavigation.Find(removeStr) != wxNOT_FOUND);
			m_foldersProtectedFromNavigation.Replace(removeStr,_T(""));
			wxASSERT(m_foldersProtectedFromNavigation.Find(removeStr) == wxNOT_FOUND);
		}
	}
}


//////////////////////////////////////////////////////////////////////////////////////////
/// \return     a boolean indicating whether the Paratext 7 process is running (TRUE)
///                    or not running (FALSE)
/// \remarks
///
/// Only implemented currently for Windows host environments. Others (MAC/Linux) always return FALSE.
/// Win32 calls are made to obtain the list of running processes, which are then searched by name
///    for 'Paratext". This finds the Paratext 7 process, but not previous Paratext versions.
/// If the process is not found, or an error occurs, the function returns FALSE
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::ParatextIsRunning()
{
		bool bIsRunning = FALSE;

#ifdef __WXMSW__ // Windows host system

		try {

			HANDLE hProcessSnap;
			//HANDLE hProcess;
			PROCESSENTRY32 pe32;
			//DWORD dwPriorityClass;

			// Take a snapshot of all processes in the system.
			hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
			if( hProcessSnap == INVALID_HANDLE_VALUE )
			{
				// Error encountered
				return bIsRunning;
			}
			// Set the size of the structure before using it.
			pe32.dwSize = sizeof( PROCESSENTRY32 );

			// Retrieve information about the first process,
			// and exit if unsuccessful
			if( !Process32First( hProcessSnap, &pe32 ) )  // Unknown Error retreiving process-abort
			{
				return bIsRunning;
			}

			// Now walk the snapshot of processes, and
			// display information about each process in turn
			do
			{
				wxString sProcess = pe32.szExeFile;
				//wxLogDebug(_T("PROCESS NAME = %s"),sProcess); //

				if (sProcess.Contains(_T("Paratext")))
				{
					// Process found
					wxLogDebug(_T("PARATEXT PROCESS FOUND = %s"),sProcess);
					bIsRunning = TRUE;
					break;
				}

			} while( Process32Next( hProcessSnap, &pe32 ) );

			CloseHandle( hProcessSnap );           // clean the snapshot object

		}
		catch (...) {} // Just ignore - app continues, function should return FALSE as default
#endif
#ifdef __WXGTK__ // linux -- similar to Bibledit functionality
	// The name of the Bibledit application in the Linux system is bibledit-gtk
	long result = -1;
	wxString commandLine;
	// try the process name 'mono'
	commandLine = _T("ps -C mono -o cmd="); // outputs the full command in outputMsg
											// if a mono application is running, nothing otherwise
	wxArrayString outputMsg, errorsMsg;
	wxString outputStr;
	// Use the wxExecute() override that takes the two wxStringArray parameters. This
	// also redirects the output and suppresses the dos console window during execution.
	result = ::wxExecute(commandLine,outputMsg,errorsMsg);
	wxCHECK_MSG(result != -1, FALSE, _T("ParatextIsRunning() returned -1 (failure) for ::wxExecute() call, line 12252"));
#ifdef __WXDEBUG__
	int testCt;
	for (testCt = 0; testCt < (int)outputMsg.GetCount(); testCt++)
	{
		outputStr += _T("\nOutput: ");
		outputStr += outputMsg.Item(testCt);
	}
	for (testCt = 0; testCt < (int)errorsMsg.GetCount(); testCt++)
	{
		outputStr += _T("\nErrors: ");
		outputStr += errorsMsg.Item(testCt);
	}
	wxLogDebug(outputStr);
#endif
	if (outputMsg.GetCount() > 0)
	{
		wxString str = outputMsg.Item(0);
		if (str.Contains(_T("Paratext.exe")))
            bIsRunning = TRUE;
	}

#endif

	return bIsRunning;

}

bool CAdapt_ItApp::BibleditIsRunning()
{
	bool bIsRunning = FALSE;
	bIsRunning = bIsRunning; // avoid warning (BEW - no choice but to do the identity assignment trick here)

#ifndef __WXMSW__ // for the non-Windows systems, i.e., Linux and Mac

	// The name of the Bibledit application in the Linux system is bibledit-gtk
	long result = -1;
	wxString commandLine;
	// try the process name 'bibledit-gtk'
	commandLine = _T("ps -C bibledit-gtk -o pid="); // outputs the pid in outputMsg if bibledit-gtk is running, nothing otherwise
	wxArrayString outputMsg, errorsMsg;
	wxString outputStr;
	// Use the wxExecute() override that takes the two wxStringArray parameters. This
	// also redirects the output and suppresses the dos console window during execution.
	result = ::wxExecute(commandLine,outputMsg,errorsMsg);
	wxCHECK_MSG(result != -1, FALSE, _T("BibleditIsRunning() returned -1 (failure) for ::wxExecute() call, line 11598"));
#ifdef __WXDEBUG__
	int testCt;
	for (testCt = 0; testCt < (int)outputMsg.GetCount(); testCt++)
	{
		outputStr += _T("\nOutput: ");
		outputStr += outputMsg.Item(testCt);
	}
	for (testCt = 0; testCt < (int)errorsMsg.GetCount(); testCt++)
	{
		outputStr += _T("\nErrors: ");
		outputStr += errorsMsg.Item(testCt);
	}
	wxLogDebug(outputStr);
#endif
	if (outputMsg.GetCount() > 0)
	{
		wxString str = outputMsg.Item(0);
		bool bIsNumber = TRUE;
		int ct;
		for (ct = 0; ct < (int)str.Length(); ct++)
		{
			if (!wxIsdigit(str.GetChar(ct)))
				bIsNumber = FALSE;
		}
		if (bIsNumber)
			bIsRunning = TRUE;
	}

	// try the process name 'bibledit-bin'
	commandLine = _T("ps -C bibledit-bin -o pid="); // outputs the pid in outputMsg if bibledit-bin is running, nothing otherwise
	outputMsg.Clear(); errorsMsg.Clear();
	outputStr.Empty();
	// Use the wxExecute() override that takes the two wxStringArray parameters. This
	// also redirects the output and suppresses the dos console window during execution.
	result = ::wxExecute(commandLine,outputMsg,errorsMsg);
	wxCHECK_MSG(result != -1, FALSE, _T("BibleditIsRunning() returned -1 (failure) for ::wxExecute() call, line 11634"));
	if (outputMsg.GetCount() > 0)
	{
		wxString str = outputMsg.Item(0);
		bool bIsNumber = TRUE;
		int ct;
		for (ct = 0; ct < (int)str.Length(); ct++)
		{
			if (!wxIsdigit(str.GetChar(ct)))
				bIsNumber = FALSE;
		}
		if (bIsNumber)
			bIsRunning = TRUE;
	}

	// try the process name 'bibleditgui'
	commandLine = _T("ps -C bibleditgui -o pid="); // outputs the pid in outputMsg if bibledit-bin is running, nothing otherwise
	outputMsg.Clear(); errorsMsg.Clear();
	outputStr.Empty();
	// Use the wxExecute() override that takes the two wxStringArray parameters. This
	// also redirects the output and suppresses the dos console window during execution.
	result = ::wxExecute(commandLine,outputMsg,errorsMsg);
	wxCHECK_MSG(result != -1, FALSE, _T("BibleditIsRunning() returned -1 (failure) for ::wxExecute() call, line 11655"));
	if (outputMsg.GetCount() > 0)
	{
		wxString str = outputMsg.Item(0);
		bool bIsNumber = TRUE;
		int ct;
		for (ct = 0; ct < (int)str.Length(); ct++)
		{
			if (!wxIsdigit(str.GetChar(ct)))
				bIsNumber = FALSE;
		}
		if (bIsNumber)
			bIsRunning = TRUE;
	}

	// try the process name 'bibledit'
	commandLine = _T("ps -C bibledit -o pid="); // outputs the pid in outputMsg if bibledit-bin is running, nothing otherwise
	outputMsg.Clear(); errorsMsg.Clear();
	outputStr.Empty();
	// Use the wxExecute() override that takes the two wxStringArray parameters. This
	// also redirects the output and suppresses the dos console window during execution.
	result = ::wxExecute(commandLine,outputMsg,errorsMsg);
	wxCHECK_MSG(result != -1, FALSE, _T("BibleditIsRunning() returned -1 (failure) for ::wxExecute() call, line 11677"));
	if (outputMsg.GetCount() > 0)
	{
		wxString str = outputMsg.Item(0);
		bool bIsNumber = TRUE;
		int ct;
		for (ct = 0; ct < (int)str.Length(); ct++)
		{
			if (!wxIsdigit(str.GetChar(ct)))
				bIsNumber = FALSE;
		}
		if (bIsNumber)
			bIsRunning = TRUE;
	}

#endif

	return bIsRunning;
}

int CAdapt_ItApp::GetMaxRangeForProgressDialog(enum ProgressDialogType progDlgType, wxString pathAndXMLFileName)
{
	int nTotal = 0;
	switch (progDlgType)
	{
		case XML_Input_Chunks:
		{
			#define TwentyKB 20480
			wxULongLong  fileSizeLL;
			fileSizeLL = wxFileName::GetSize(pathAndXMLFileName);
			if (fileSizeLL == wxInvalidSize)
			{
				nTotal = 0;
			}
			else
			{
				wxString temp;
				temp = fileSizeLL.ToString();
				int tempInt = wxAtoi(temp);
				int nChunks = tempInt / TwentyKB;
				// add 1 chunk to insure that we have enough after int division above
				nTotal = nChunks + 1;
			}
			break;
		}
		case Adapting_KB_Item_Count:
		{
			int numWords_sim;
			MapKeyStringToTgtUnit::iterator iter_sim;
			CTargetUnit* pTU_sim = 0;
			for (numWords_sim = 1; numWords_sim <= MAX_WORDS; numWords_sim++)
			{
				if (m_pKB->m_pMap[numWords_sim-1]->size() == 0)
					continue;
				else
				{
					iter_sim = m_pKB->m_pMap[numWords_sim-1]->begin();
					do
					{
						nTotal++; // add number of <entry>s, i.e., <lexical-unit>s
						pTU_sim = (CTargetUnit*)iter_sim->second;
						wxASSERT(pTU_sim != NULL);
						nTotal += pTU_sim->m_pTranslations->GetCount(); // add number of <sense>s
						iter_sim++;
					} while (iter_sim != m_pKB->m_pMap[numWords_sim-1]->end());
				}
			}
			break;
		}
		case Glossing_KB_Item_Count:
		{
			int numWords_sim;
			MapKeyStringToTgtUnit::iterator iter_sim;
			CTargetUnit* pTU_sim = 0;
			for (numWords_sim = 1; numWords_sim <= MAX_WORDS; numWords_sim++)
			{
				if (m_pGlossingKB->m_pMap[numWords_sim-1]->size() == 0)
					continue;
				else
				{
					iter_sim = m_pGlossingKB->m_pMap[numWords_sim-1]->begin();
					do
					{
						nTotal++; // add number of <entry>s, i.e., <lexical-unit>s
						pTU_sim = (CTargetUnit*)iter_sim->second;
						wxASSERT(pTU_sim != NULL);
						nTotal += pTU_sim->m_pTranslations->GetCount(); // add number of <sense>s
						iter_sim++;
					} while (iter_sim != m_pGlossingKB->m_pMap[numWords_sim-1]->end());
				}
			}
			break;
		}
		default:
		case App_SourcePhrases_Count:
		{
			nTotal = (int)m_pSourcePhrases->GetCount();
			break;
		}
	}
	return nTotal;
}

wxProgressDialog* CAdapt_ItApp::OpenNewProgressDialog(wxString progTitle,wxString msgDisplayed,
		const int nTotal,
		const int width)
{
	wxProgressDialog* pProgDlg = (wxProgressDialog*)NULL;
	pProgDlg = new wxProgressDialog(progTitle,
					msgDisplayed,
					nTotal,    // range
					gpApp->GetMainFrame(),   // parent
					//wxPD_CAN_ABORT |
					//wxPD_CAN_SKIP |
					wxPD_APP_MODAL |
					wxPD_AUTO_HIDE //| -- try this as well
					//wxPD_ELAPSED_TIME |
					//wxPD_ESTIMATED_TIME |
					//wxPD_REMAINING_TIME
					//| wxPD_SMOOTH // - makes indeterminate mode bar on WinXP very small
	);
	wxASSERT(pProgDlg != NULL);
	pProgDlg->SetSize(width,pProgDlg->GetSize().GetHeight());
	pProgDlg->CenterOnParent();
	return pProgDlg;
}


//////////////////////////////////////////////////////////////////////////////////////////
/// \return     the CurrLocalizationInfo struct with its members populated from
///             m_pConfig info
/// \remarks
/// Called from: the App's OnInit(). Retrieves any previously stored user defined languages
/// from m_pConfig using the registry (Windows)/hidden settings file (Linux/Mac), and adds
/// the language info to the current locale with wxLocale::AddLanguage(). Then it retrieves
/// the user's current localization information stored in the m_pConfig and returns it to
/// the caller. If no previous interface has been chosen (i.e., on first run of Adapt It),
/// the string members of the CurrLocalizationInfo struct being returned are set to null
/// strings and the curr_UI_Language is set to wxLANGUAGU_UNKNOWN.
//////////////////////////////////////////////////////////////////////////////////////////
CurrLocalizationInfo CAdapt_ItApp::ProcessUILanguageInfoFromConfig()
{
	// Some wx example code uses the following:
	// wxString lng = wxConfig::Get()->Read(_T("ui_language"));
	// whm note: The above wxConfig->Get()... call creates a memory leak in our case since
	// it does not make it possible to delete the object created in the wxConfig->Get() call.
	// We want to get the ui_language data in our own m_pConfig object anyway.
	// So we use our m_pConfig object which was created in OnInit() and deleted in OnExit()

	// Retrieve the interface language information from m_pConfig if it exists.
	wxString oldPath = m_pConfig->GetPath(); // is always absolute path "/Recent_File_List"
	m_pConfig->SetPath(_T("/Settings"));

	wxLogNull logNo; // eliminates spurious message from the system: "Can't read value of
		// key 'HKCU\Software\Adapt_It_WX\Settings' Error" [valid until end of this block]

	// First, retrieve the current localization info
	CurrLocalizationInfo currLocInfo; // populate a local struct which we return to caller
	// initialize currLocInfo to some recognizable defaults since m_pConfig::Read() below
	// will not change the value unless it is found in the registry
	currLocInfo.curr_UI_Language = wxLANGUAGE_UNKNOWN; // value is 1
    currLocInfo.curr_shortName.Empty();
    currLocInfo.curr_fullName.Empty();
    currLocInfo.curr_localizationPath.Empty();

	m_pConfig->Read(_T("ui_language"), &currLocInfo.curr_UI_Language);
	m_pConfig->Read(_T("ui_language_code"),&currLocInfo.curr_shortName);
	m_pConfig->Read(_T("ui_language_name"),&currLocInfo.curr_fullName);
//#ifdef _UNICODE
//	m_pConfig->Read(_T("ui_language_path_unicode"),&currLocInfo.curr_localizationPath);
//#else
//	m_pConfig->Read(_T("ui_language_path"),&currLocInfo.curr_localizationPath);
//#endif

	// Next, retrieve any user defined language data from the user_defined_language_n keys.
	int ct;
	const int nKeys = 9;
	wxArrayString keyArray;
	keyArray.Alloc(9);
	bool bKeysPresent = FALSE;
	//bool bKeyMissing = FALSE;
	//bool bAllKeysAssigned = FALSE;

	for (ct = 0; ct < nKeys; ct++)
	{
		wxString str;
#ifdef _UNICODE
		str << _T("user_defined_language_u_") << ct;
#else
		str << _T("user_defined_language_") << ct;
#endif
		bool valReadOK = TRUE;
		wxString tempStr;
		valReadOK = m_pConfig->Read(str, &tempStr);
		keyArray.Add(tempStr);
		//if (valReadOK && keyArray[ct] == _T("[UNASSIGNED]"))
		//{
		//	bAllKeysAssigned = FALSE;
		//}
		if (valReadOK && keyArray[ct] != _T("[UNASSIGNED]"))
		{
			bKeysPresent = TRUE;
		}
		if (!valReadOK)
		{
			//bKeyMissing = TRUE;
			keyArray[ct] = _T("[UNASSIGNED]");	// assign null string to any keyArray element
												// for which there is no key
		}
	}

	if (bKeysPresent)
	{
        // User defined language keys are present. Do some sanity checks and then add them
        // to the current locale.
        // Note: The wxLanguage Database gets any user defined languages added here at each
        // running of the app, taking the user defined languages from the registry/hidden
        // settings file. It may be that during the previous running of the application the
        // user added a user defined language when all user_defined_language_n keys were
        // already assigned. In that case Adapt It removed the oldest assigned language
        // from the keys (which would have been assigned the wxLangauge numerical value of
        // 231); moved the other 8 keys up in the list (keeping their values ranging from
        // 232 through 239), and added the most recent language to the last key with a
        // value of 240. Therefore, with this scenario, it could be that the wxLanguage
        // value of the user_defined_language_0 key is 232 and the last key has a value of
        // 240. If this is the case, we can here (and here only) renumber the wxLanguage
        // values before we call AddLanguage(). In such a case we would renumber the user
        // defined languages 231 through 239, to keep from the possibility of running out
        // of wxLanguage values (which are enum values with a max value of 255).
		//
        // First we sort the keyArray in case
        // RemoveUserDefinedLanguageInfoStringFromConfig() was called previously and left
        // an "[UNASSIGNED]" string assigned to a key in the middle of the keys somewhere.
        // Note: This is the only place in the handling of the registry/hidden settings
        // that we will sort the keys.
		keyArray.Sort(); // Sorts in ascending order and places any unassigned keys
						 // toward the end.

		int nCodeToAssign;
		nCodeToAssign = wxLANGUAGE_USER_DEFINED + 1;
		for (ct = 0; ct < nKeys; ct++)
		{
			wxString str;
#ifdef _UNICODE
			str << _T("user_defined_language_u_") << ct;
#else
			str << _T("user_defined_language_") << ct;
#endif
			if (keyArray[ct] != _T("[UNASSIGNED]"))
			{
				// parse out the shortName and fullName parts of the unix-like string
				wxString tempStr,tempCode,tempShortName,tempFullName,tempPath;
				tempStr = keyArray[ct];
				tempCode = tempStr.Mid(0,tempStr.Find(_T(':')));
				tempStr = tempStr.Remove(0,tempStr.Find(_T(':'))+1);
				tempShortName = tempStr.Mid(0,tempStr.Find(_T(':')));
				tempStr = tempStr.Remove(0,tempStr.Find(_T(':'))+1);
				tempFullName = tempStr.Mid(0,tempStr.Find(_T(':')));
				tempStr = tempStr.Remove(0,tempStr.Find(_T(':'))+1);
				tempPath = tempStr;
                // If the existing wxLanguage value for this user_defined_language_n is the
                // same as the ui_language key, but this user_defined_language represents a
                // different language than the language represented by ui_language_code and
                // ui_language_name, we have a wxLanguage value conflict (our current
                // ui_language and a user defined language would be assigned the same
                // wxLanguage value in the code below). We resolve the conflict by
                // assigning to this user_defined_language a wxLanguage value that doesn't
                // conflict with the ui_language or any other existing
                // user_defined_language's curr_UI_Language.
				int nTempCode;
				nTempCode = wxAtoi(tempCode);
				if (nTempCode == currLocInfo.curr_UI_Language
					&& (tempShortName != currLocInfo.curr_shortName ||
					tempFullName != currLocInfo.curr_fullName))
				{
					int code;
					code = GetFirstAvailableLanguageCodeOtherThan(currLocInfo.curr_UI_Language,
																	keyArray);
					if (code != -1)
					{
                        // We found a suitable different language code for this
                        // user_defined_language key to avoid clash of wxLanguage values
                        // being stored in the registry/hidden settings file.
						wxString compositeStr;
						compositeStr << code << _T(':') << tempShortName << _T(':')
										<< tempFullName << _T(':'); // << tempPath; // whm 8Dec11 removed storage of the path part
						m_pConfig->Write(str, compositeStr);
					}
				}

				const wxLanguageInfo *info = wxLocale::FindLanguageInfo(tempFullName);
				if (!info)
				{
					// this language is not yet in the wxLanguage database
					wxLanguageInfo langInfo;
					langInfo.Language = nCodeToAssign;
					langInfo.CanonicalName = tempShortName;
		#ifdef __WIN32__
					// Win32 language identifiers
					langInfo.WinLang = 0;		// We don't know the Windows LANG_xxxx
												// value so enter zero
					langInfo.WinSublang = 0;	// We don't know the Windows SUBLANG_xxxx
												// value so enter zero
		#endif
					langInfo.Description = tempFullName;
					gpApp->m_pLocale->AddLanguage(langInfo);

					// Now write the key
                    // Make a composite unix-like string from the data stored in the
                    // registry/hidden settings file
					wxString compositeStr;
					compositeStr << nCodeToAssign << _T(':') << tempShortName << _T(':')
						<< tempFullName << _T(':'); // << currLocInfo.curr_localizationPath; // whm 8Dec11 removed the path part
					m_pConfig->Write(str, compositeStr);
                    // If our compositeStr represents the current interface language to be
                    // used, we should check to see if the wxLanguage value stored in the
                    // ui_language key needs updating.
					if (tempFullName == currLocInfo.curr_fullName &&
						tempShortName == currLocInfo.curr_shortName)
					{
                        // Our compositeStr represents the current interface language to be
                        // used, so update the wxLanguage value of ui_language if necessary
						if (nCodeToAssign != currLocInfo.curr_UI_Language)
						{
							m_pConfig->Write(_T("ui_language"), nCodeToAssign);
						}
					}
					nCodeToAssign++;
				}
				else
				{
                    // The language was already in the wxLanguage database, which means
                    // that either (1) it no longer needs to be considered a user defined
                    // language, or (2) it was somehow a duplicate user defined language in
                    // the list. In either case we don't need to write this user defined
                    // language back to a user_defined_language_n key, and we make the key
                    // "[UNASSIGNED]" instead.
					m_pConfig->Write(str, _T("[UNASSIGNED]"));
				}
			}
			else
			{
				// This keyArray element was already "[UNASSIGNED]" so we write it back
				// that way
				m_pConfig->Write(str, _T("[UNASSIGNED]"));
			}
		}
	}

	m_pConfig->Flush(); // write now, otherwise write takes place when m_p is destroyed in OnExit().
	// restore the oldPath back to "/Recent_File_List"
	m_pConfig->SetPath(oldPath);
    return currLocInfo;
	// end of wxLogNull logNo here
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if localization files exist at a known path; FALSE otherwise
/// \remarks
/// Called from: the App's OnInit(). Determines if localization files are present at a
/// known path on the local computer. This function first checks the registry/hidden
/// settings file to see if a previous localization path was set (in ui_language_path). If
/// so, it checks to see if localization files are actually currently located there. If so
/// it sets the ui_localizationFilesExist key to TRUE and returns TRUE. If no files are
/// located at a previously set path as indicated by the ui_language_path key, it checks to
/// see if localization files are located at the default location for the current platform.
/// If localization files actually exist there it sets the path stored in the
/// ui_language_path key to reflect where they are actually located, and sets the
/// ui_localizationFilesExist key to TRUE and returns TRUE. If localization files could not
/// be found by inspecting the ui_language_path key nor at the default location, the
/// ui_localizationFilesExist key is set to FALSE and this function returns FALSE.
/// Therefore, when this function returns, the ui_localizationFilesExist key is guaranteed
/// to be set to either TRUE or FALSE and the return value of this function will agree with
/// that key settings.
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::LocalizationFilesExist()
{
	bool bLocalizationFilesFound = FALSE; // assume FALSE unless we actually find them
	// First check to see if the ui_language_path key exists.
	//
	// Retrieve the interface language information from m_pConfig if it exists.
	wxString oldPath = m_pConfig->GetPath(); // is always absolute path "/Recent_File_List"
	m_pConfig->SetPath(_T("/Settings"));

	wxLogNull logNo; // eliminates spurious message from the system: "Can't read value
		// of key 'HKCU\Software\Adapt_It_WX\Settings' Error" [valid until end of this block]
	wxString uiLangPath;
	uiLangPath.Empty();
#ifdef _UNICODE
	m_pConfig->Read(_T("ui_language_path_unicode"),&uiLangPath);
#else
	m_pConfig->Read(_T("ui_language_path"),&uiLangPath);
#endif

	if (!uiLangPath.IsEmpty())
	{
        // The key was is the registry/hidden settings file, so check if localization files
        // actually exist at the specified location, and for the ui_language_code (used as
        // subdir name). Since ui_language_path exists, there should also be a
        // ui_language_code value that we can use to ensure that the specific localization
        // subfolder named actually exists.
		wxString shortNameStr;
		shortNameStr.Empty();
		m_pConfig->Read(_T("ui_language_code"), &shortNameStr);
        // If shortNameStr is empty at this point, it means that no actual ui_language_code
        // key was present and so the PathHas_mo_LocalizationFile() test below will not
        // require a specific subdir to be present as a localization folder.
		if (PathHas_mo_LocalizationFile(uiLangPath, shortNameStr))
		{
            // The uiLangPath contains at least one subfolder which in turn contains an
            // <appName>.mo file, so we set the ui_localizationFilesExist key to TRUE, and
            // return TRUE (at end).
			bLocalizationFilesFound = TRUE;
#ifdef _UNICODE
			m_pConfig->Write(_T("ui_localizationFilesExist_unicode"), bLocalizationFilesFound);
#else
			m_pConfig->Write(_T("ui_localizationFilesExist"), bLocalizationFilesFound);
#endif
		}
		else
		{
            // The current ui_language_path contains a bad localization files path. So,
            // we'll check to see if localization files are located at the platform default
            // location.
			wxString defaultPath;
			defaultPath = GetDefaultPathForLocalizationSubDirectories();
			if (PathHas_mo_LocalizationFile(defaultPath, shortNameStr))
			{
                // The defaultPath contains at least one subfolder which in turn contains
                // an <appName>.mo file, so we correct the bad ui_localization_path key,
                // set the ui_localizationFilesExist key to TRUE, and return TRUE (at end).
				bLocalizationFilesFound = TRUE;
#ifdef _UNICODE
				m_pConfig->Write(_T("ui_language_path_unicode"), defaultPath);
				m_pConfig->Write(_T("ui_localizationFilesExist_unicode"), bLocalizationFilesFound);
#else
				m_pConfig->Write(_T("ui_language_path"), defaultPath);
				m_pConfig->Write(_T("ui_localizationFilesExist"), bLocalizationFilesFound);
#endif
			}
			else
			{
				bLocalizationFilesFound = FALSE;
#ifdef _UNICODE
				m_pConfig->Write(_T("ui_localizationFilesExist_unicode"), bLocalizationFilesFound);
#else
				m_pConfig->Write(_T("ui_localizationFilesExist"), bLocalizationFilesFound);
#endif
			}
		}
	}
	else
	{
        // The ui_language_path key was not in the registry/hidden settings file. This
        // probably means that no ui_language has yet been stored in the registry/hidden
        // settings file. We could check to see if ui_language, ui_language_code and
        // ui_language_name exist unexpectedly, but if they do without a ui_language_path
        // key, it would only mean that someone has been monkeying with the registry/hidden
        // settings file, deleting some keys but not others. We can't prevent all possible
        // silly things from being done, so we will just assume that no localization files
        // exist which will bring up the ChooseLanguageDlg dialog at program startup (and
        // fix any problems that exist in the stored keys).
		bLocalizationFilesFound = FALSE;
#ifdef _UNICODE
		m_pConfig->Write(_T("ui_localizationFilesExist_unicode"), bLocalizationFilesFound);
#else
		m_pConfig->Write(_T("ui_localizationFilesExist"), bLocalizationFilesFound);
#endif
	}
	m_pConfig->Flush(); // write now, otherwise write takes place when m_p is destroyed in OnExit().
	// restore the oldPath back to "/Recent_File_List"
	m_pConfig->SetPath(oldPath);
	return bLocalizationFilesFound;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if user made a choice different from the current language; FALSE if
///             the user canceled or made no change
/// \remarks
/// Called from: the App's OnInit() and ChangeUILanguage(). If localization files are
/// present, it presents the user with the CChooseLanguageDlg dialog from which he can
/// choose an interface language localization for Adapt It from a list of possible language
/// localizations. If there are no localization files installed/available at the
/// localization files path, and no previous ui_language was ever saved in the
/// registry/hidden settings file, the dialog is not shown and ChooseInterfaceLanguage()
/// simply sets the global CurrLocalizationInfo struct's curr_UI_Language to
/// wxLANGUAGE_DEFAULT (and its other members appropriately). Also, if localization files
/// are present, but the user aborts the choice, or a suitable interface language could not
/// be determined, ChooseInterfaceLanguage() sets the global CurrLocalizationInfo struct's
/// curr_UI_Language to wxLANGUAGE_DEFAULT (and its other members appropriately).
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::ChooseInterfaceLanguage(enum SetInterfaceLanguage setInterface)
{
	// See LangInfo struct and langsKnownToWX[] for valid wxLanguage languages
	// identifiers known to wxWidgets.

	CurrLocalizationInfo currLocInfo;
	currLocInfo = currLocalizationInfo;
	bool bChangeMade = FALSE;

	if (setInterface == userInitiated || LocalizationFilesExist() || wxGetKeyState(WXK_ALT))
	{

		CChooseLanguageDlg dlg(NULL); // use NULL as "parent" window since our main frame
									  // may not be created yet
		dlg.Centre();
		if (dlg.ShowModal() == wxID_OK)
		{
            // CChooseLanguageDlg insures that the CurrLocalizationInfo struct's members
            // are filled in appropriately for the chosen language, so nothing more to do
            // here.
			;
			if (dlg.m_bChangeMade)
			{
				bChangeMade = TRUE;
				wxString msg = _T("User chose %s interface language in ChooseInterfaceLanguage()");
				msg = msg.Format(msg,currLocalizationInfo.curr_fullName.c_str());
				LogUserAction(msg);
			}
		}
		else
		{
			LogUserAction(_T("Cancelled ChooseInterfaceLanguage()"));
			// TODO: Check how Canceling the dialog handles the situation where the
			// systemLanguage of the host machine is something like "English India"
			// which is not a recognized language in wxWidgets language database.
			// In particular, we don't want curr_UI_Language to be assigned a language
			// which has no localization.
			//
			// The user aborted from the CChooseLanguageDlg dialog, so we set the
            // CurrLocalizationInfo struct's members back to their values before calling
            // CChooseLanguageDlg.
			currLocalizationInfo.curr_UI_Language = currLocInfo.curr_UI_Language;
			currLocalizationInfo.curr_shortName = currLocInfo.curr_shortName;
			currLocalizationInfo.curr_fullName = currLocInfo.curr_fullName;
			currLocalizationInfo.curr_localizationPath = currLocInfo.curr_localizationPath;
			//m_localizationInstallPath = currLocalizationInfo.curr_localizationPath; // save it here too
		}
	}
	else
	{
		LogUserAction(_T("Assign default English in ChooseInterfaceLanguage()"));
		// TODO: Check how Canceling the dialog handles the situation where the
		// systemLanguage of the host machine is something like "English India"
		// which is not a recognized language in wxWidgets language database.
		// In particular, we don't want curr_UI_Language to be assigned a language
		// which has no localization.
		//
        // Localization files could not be found, and user did not hold down the ALT key to
        // force the CChooseLanguageDlg dialog to appear. Therefore we quietly assign
        // default English language values to the currLocalizationInfo struct (which will
        // be saved to the registry/hidden settings file when
        // SaveCurrentUILanguageInforToConfig is called below).
		int sysLanguage = wxLocale::GetSystemLanguage();
		const wxLanguageInfo *info = wxLocale::GetLanguageInfo(sysLanguage);
		currLocalizationInfo.curr_UI_Language = sysLanguage;
		if (info != NULL)
		{
			currLocalizationInfo.curr_shortName = info->CanonicalName;
			currLocalizationInfo.curr_fullName = info->Description;
		}
		else
		{
			currLocalizationInfo.curr_shortName.Empty();
			currLocalizationInfo.curr_fullName.Empty();
		}
		currLocalizationInfo.curr_localizationPath = GetDefaultPathForLocalizationSubDirectories();
		//m_localizationInstallPath = currLocalizationInfo.curr_localizationPath; // save it here too
	}
    // the CurrLocalizationInfo struct's members are now filled appropriately, so save the
    // data in the m_pConfig configuration.
    SaveCurrentUILanguageInfoToConfig();

	return bChangeMade;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if reversal succeeded, FALSE otherwise
/// \param      pDialog -> pointer to the dialog whose OK and Cancel buttons are to be swapped
/// \remarks
/// Called from: Nearly all dialogs having OK and Cancel buttons.
/// Reverses the positions of the OK and Cancel buttons within their created dialogs. This is
/// accomplished by switching the button's ids and labels. The change is only made for the
/// wxMac port. wxDesigner positioned the dialog's OK and Cancel buttons assuming the style
/// of dialogs for Windows which have OK button on the left and Cancel button on the right.
/// For the proper "look and feel" on a Mac, this order should be reversed to Cancel on
/// the left and OK on the right. The dialog assumes that the dialog has already been created
/// from a function designed by wxDesigner, and that it contains a wxButton with the wxID_OK
/// identifier and another button with the wxID_CANCEL identifier which were both created as
/// child windows within a wxBoxSizer created as wxHORIZONTAL. Sets the new OK button as the
/// default button that is selected when user hits Enter.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::ReverseOkCancelButtonsForMac(wxDialog* pDialog)
{
	wxASSERT(pDialog != NULL);
	wxButton* pOKButton = (wxButton*)pDialog->FindWindow(wxID_OK); // FindWindow finds a
																   // child of pDialog
	if (pOKButton == NULL)
		return FALSE;
	wxButton* pCancelButton = (wxButton*)pDialog->FindWindow(wxID_CANCEL); // FindWindow
															// finds a child of pDialog
	if (pCancelButton == NULL)
		return FALSE;

#ifdef __WXMAC__ // Chande to #ifndef to test the swapping on Windows or Linux
	// Get pointers to the containing sizer of the two buttons
	wxBoxSizer* pContSizerOfOK = (wxBoxSizer*)pOKButton->GetContainingSizer();
	wxASSERT(pContSizerOfOK != NULL);
	wxBoxSizer* pContSizerOfCancel = (wxBoxSizer*)pCancelButton->GetContainingSizer();
	wxASSERT(pContSizerOfCancel != NULL);
	wxASSERT(pContSizerOfOK == pContSizerOfCancel);
	// Don't proceed if the buttons don't have the same containing sizer
	if (pContSizerOfOK == NULL || pContSizerOfCancel == NULL || pContSizerOfOK != pContSizerOfCancel)
		return FALSE;

	wxASSERT(pDialog->GetAffirmativeId() == wxID_OK);
	wxASSERT(pDialog->GetEscapeId() == wxID_ANY);
	// Don't proceed if the buttons don't operate in their expected default way
	if (pDialog->GetAffirmativeId() != wxID_OK || pDialog->GetEscapeId() != wxID_ANY)
		return FALSE;

	// we only swap buttons if their containing sizer is of wxHORIZONTAL orientation.
	if (pContSizerOfOK->GetOrientation() == wxHORIZONTAL)
	{
		wxString btnOKStr,btnCancelStr;
		btnOKStr = pOKButton->GetLabel();
		btnCancelStr = pCancelButton->GetLabel();

		// reverse the button IDs
		pOKButton->SetId(wxID_CANCEL);
		pCancelButton->SetId(wxID_OK);

		// reverse the button labels
		pOKButton->SetLabel(btnCancelStr);
		pCancelButton->SetLabel(btnOKStr);

		// reverse the button tooltips
		// BEW 27July10, changed the code to get the tooltip strings before doing the
		// switch of the tooltips
		wxString ttOKStr;
		wxString ttCancelStr;
		wxToolTip* pOkToolTip = pOKButton->GetToolTip();
		wxToolTip* pCancelToolTip = pCancelButton->GetToolTip();
		if (pOkToolTip != NULL)
		{
			ttOKStr = pOkToolTip->GetTip();
		}
		if (pCancelToolTip != NULL)
		{
			ttCancelStr = pCancelToolTip->GetTip();
		}
		if (!ttOKStr.IsEmpty())
		{
			pCancelButton->SetToolTip(ttOKStr);
		}
		if (!ttCancelStr.IsEmpty())
		{
			pOKButton->SetToolTip(ttCancelStr);
		}
		pCancelButton->SetDefault();
		return TRUE;
	}
#endif
	return FALSE;
}


////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the View's OnChangeInterfaceLanguage() and CLanguagesPage::OnUILanguage().
/// Calls the ChooseInterfaceLanguage() function which presents the user with the
/// CChooseLanguageDlg dialog from which he can choose an interface language for the
/// application from a list of languages that have localization <appName>.mo files on in
/// localization subfolders on the localization path.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ChangeUILanguage()
{
	bool bChangeMade;
	bChangeMade = ChooseInterfaceLanguage(userInitiated);	// calls CChooseLanguageDlg and
            // insures that currLocalizationInfo's curr_UI_Language is something other than
            // wxLANGUAGE_UNKNOWN
    if (bChangeMade)
	{
        // Try to get as many of the interface elements to layout with new localization
        // strings as possible.
        //
		// Note: wx docs say of wxWindow::UpdateWindowUI():
        // This function sends wxUpdateUIEvents to the window. The particular
        // implementation depends on the window; for example a wxToolBar will send an
        // update UI event for each toolbar button, and a wxFrame will send an update UI
        // event for each menubar menu item. You can call this function from your
        // application to ensure that your UI is up-to-date at this point (as far as your
        // wxUpdateUIEvent handlers are concerned). This may be necessary if you have
        // called wxUpdateUIEvent::SetMode or wxUpdateUIEvent::SetUpdateInterval to limit
        // the overhead that wxWidgets incurs by sending update UI events in idle time.
		//flags should be a bitlist of one or more of the following values.
		//enum wxUpdateUI
		//{
		//    wxUPDATE_UI_NONE          = 0x0000, // No particular value
		//    wxUPDATE_UI_RECURSE       = 0x0001, // Call the function for descendants
		//    wxUPDATE_UI_FROMIDLE      = 0x0002  // Invoked from On(Internal)Idle
		//};
        //If you are calling this function from an OnInternalIdle or OnIdle function, make
        //sure you pass the wxUPDATE_UI_FROMIDLE flag, since this tells the window to only
        //update the UI elements that need to be updated in idle time. Some windows update
        //their elements only when necessary, for example when a menu is about to be shown.
        //The following is an example of how to call UpdateWindowUI from an idle function.
		//void MyWindow::OnInternalIdle()
		//{
		//    if (wxUpdateUIEvent::CanUpdate(this))
		//        UpdateWindowUI(wxUPDATE_UI_FROMIDLE);
		//}
        // Note: The code below unfortunately does not update the translated strings
        // immeditately, so it is still best to advise the user to start up Adapt It again.
        // Looking at Audacity and PoEdit (which are applications created with wxWidgets) -
        // they also require a restart after changing the interface. It might be possible
        // to programattically offer to restart Adapt It, but that might have some
        // unintended side effects, so I won't go down that road at this point.
		//if (m_pMainFrame != NULL)
		//{
		//	m_pMainFrame->UpdateWindowUI(wxUPDATE_UI_RECURSE);
		//	if (m_pMainFrame->m_pMenuBar != NULL)
		//		m_pMainFrame->m_pMenuBar->UpdateWindowUI(wxUPDATE_UI_RECURSE);
		//	if (m_pMainFrame->m_pStatusBar != NULL)
		//		m_pMainFrame->m_pStatusBar->UpdateWindowUI(wxUPDATE_UI_RECURSE);
		//	if (m_pMainFrame->m_pToolBar != NULL)
		//		m_pMainFrame->m_pToolBar->UpdateWindowUI(wxUPDATE_UI_RECURSE);
		//	if (m_pMainFrame->m_pControlBar != NULL)
		//		m_pMainFrame->m_pControlBar->UpdateWindowUI(wxUPDATE_UI_RECURSE);
		//	if (m_pMainFrame->m_pComposeBar != NULL)
		//		m_pMainFrame->m_pComposeBar->UpdateWindowUI(wxUPDATE_UI_RECURSE);
		//}
		wxMessageBox(_(
"The user interface language change may not fully take effect until you restart Adapt It."),
        m_FrameAndDocProgramTitle, wxOK | wxCENTRE | wxICON_INFORMATION);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     the int value of the first available wxLanguage code for a user
///             defined language
/// \param      codeToAvoid  -> an int value to avoid when finding a wxLanguage code
/// \param      keyArray     -> a wxArrayString of registry/hidden setting file keys
///                             (pre-populated)
/// \remarks
/// Called from: The App's ProcessUILanguageInfoFromConfig().
/// Determines the next available wxLanguage value that can be assigned to a
/// user_defined_langauge-n registry/hidden settings file key. Since the number of user
/// defined language keys is restricted to no more than 9, the possible return values can
/// range from wxLANGUAGE_USER_DEFINED + 1 through wxLANGUAGE_USER_DEFINED + 1 + nKeys.
/// Since the current wxWidgets version's (2.8.8) wxLANGUAGE_USER_DEFINED symbol is defined
/// to be 230, the values that can be returned by this function range from 231 through 239.
/// If no value can be determined, the function returns -1.
/////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::GetFirstAvailableLanguageCodeOtherThan(const int codeToAvoid,
														 wxArrayString keyArray)
{
	int ct;
	wxArrayString codeStrArray;
	//int tempCode;
	int codeToReturn = -1;
	const int nKeys = 9; // the max number of keys we allow in the registry/hidden
						 // settings file
	wxString tempStr;
	bool bHasUnassigned = FALSE;
    // Gather the language code strings (first part of the key string before the first
    // colon). The incoming keyArray will have key strings associated with any
    // user_defined_language_n keys defined in the registry/hidden settings file.
	// An example of a key string might be "232:tpi:Tok Pisin:c:\Program Files\Adapt It\Languages"
	// where the "232" is the string equivalent of the wxLanguage value assigned for that
	// user_defined_language_n key.
	for (ct = 0; ct < nKeys; ct++)
	{
		if (keyArray[ct] != _T("[UNASSIGNED]"))
		{
			tempStr = keyArray[ct];
			tempStr = tempStr.Mid(0,tempStr.Find(_T(':')));
			//tempCode = wxAtoi(tempStr);
			//wxASSERT(tempCode > 230 && tempCode < (wxLANGUAGE_USER_DEFINED + 1 + nKeys));
			codeStrArray.Add(tempStr);
		}
		else
		{
			bHasUnassigned = TRUE;
		}
	}

	// At this point codeStrArray contains all of the code strings used in the keyArray.
	// Sort the codeStrArray to make it easier to determine the first available code.
	codeStrArray.Sort(); // sorts in ascending order by default

    // Now scan the codeStrArray to find the lowest wxLanguage code that has not already
    // been assigned and avoids codeToAvoid.
	bool bFound = FALSE;
	int maxCode = 0;
	int minCode = 999;
	if (codeStrArray.GetCount() > 0)
	{
		int cct, checkCode;
		for (cct = 0; cct < (int)codeStrArray.GetCount(); cct++)
		{
			int code;
			code = wxAtoi(codeStrArray[cct]);
			if (code > maxCode)
				maxCode = code;
			if (code < minCode)
				minCode = code;
			checkCode = wxLANGUAGE_USER_DEFINED + 1 + cct; // increments by the value
								// of loop counter cct, i.e., 231, 232, 233 ... 239
			if (checkCode != code && code != codeToAvoid)
			{
				// We found a checkCode that is not already used and not the codeToAvoid
				if (!bFound)
				{
					// get only the first one available
					codeToReturn  = checkCode;
					bFound = TRUE;
				}
			}
		}
	}
	else
	{
        // there are no user_defined_language_n keys assigned so assign codeToReturn the
        // value wxLANGUAGE_USER_DEFINED + 1, unless that is the codeToAvoid, in which case
        // assigne codeToReturn the value wxLANGUAGE_USER_DEFINED + 2.
		if (wxLANGUAGE_USER_DEFINED + 1 != codeToAvoid)
			codeToReturn = wxLANGUAGE_USER_DEFINED + 1;
		else
			codeToReturn = wxLANGUAGE_USER_DEFINED + 2;
	}
    // if codeToReturn is still -1 and there are unassigned keys try to find a value using
    // the minCode and maxCode values
	if (codeToReturn == -1 && bHasUnassigned)
	{
		if (minCode < 999 && minCode > (wxLANGUAGE_USER_DEFINED + 1) &&
			minCode != codeToAvoid)
		{
			codeToReturn = wxLANGUAGE_USER_DEFINED + 1;
		}
		else if (maxCode >= wxLANGUAGE_USER_DEFINED + 1 &&
				(maxCode + 1) < (wxLANGUAGE_USER_DEFINED + 1 + nKeys))
		{
			if (maxCode + 1 != codeToAvoid)
				codeToReturn = maxCode + 1;
			else
				codeToReturn = maxCode + 2;
		}
	}
    // At this point, if codeToReturn is still -1 it means that there were no values
    // available within the range wxLANGUAGE_USER_DEFINED + 1 through
    // wxLANGUAGE_USER_DEFINED + 1 + nKeys. In such cases we just return -1 to tell the
    // caller that we could not get a code.
	return codeToReturn;
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if all goes well, FALSE if there was something that causes premature exit
/// \remarks
/// Called once when the application is first executed. OnInit() is the main place where
/// all application level variables are to be initialized in a wxWidgets based application.
/// It is basically the equivalent of MFC's InitInstance(), but seems to be called earlier
/// in the execution of a program at startup than is InitInstance() on MFC. Note: The order
/// in which things are initialized can be important in OnInit(). For example, we cannot do
/// anything with the main frame or variables it initializes until the CMainFrame is
/// created in OnInit().
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::OnInit() // MFC calls this InitInstance()
{
	// mrh - the user is initially Joe Bloggs@JoesMachine.  DVCS uses this.
	gAI_user = wxGetUserName() + _T("@") + wxGetHostName();

	// initialize Printing support members
	m_bFrozenForPrinting = FALSE;
	m_bIsPrinting = FALSE;
	m_bPrintingRange = FALSE;
	m_savedSelectionLine = -1; // which cell of the piles has the selection (-1 if none)
	m_savedSelectionAnchorIndex = -1; // the sequence number for the pile where saved selection starts
	m_savedSelectionCount = -1; // how many consecutive CCell (or CPile) instances are in the selection

	m_bStatusBarVisible = TRUE; // Status Bar is visible unless changed by value in basic config file
	m_bToolBarVisible = TRUE; // Tool Bar is visible unless changed by value in basic config file
	m_bModeBarVisible = TRUE; // Control/Mode Bar is visible unless changed by value in basic config file

	// default substring delimiters possibly used within LIFT file <text> elements - we
	// assume only two, comma and semicolon
	m_LIFT_subfield_delimiters = _T(",;");

#if defined(__WXGTK__)
    // BEW added 15Nov11
    m_bPrintingPageRange = FALSE;
    m_userPageRangePrintStart = 1;
    m_userPageRangePrintEnd = 1;
#endif
	m_bPrintingSelection = FALSE;
	m_nCurPage = 1; // a benign default, since we use this only by subtracting 1 in an
					// list.Item() call, and if it was 0 we'd be looking for a -1 index
	m_bPagePrintInProgress = FALSE; // default value, it's true only while OnPrintPage()
					// is being executed

	// BEW added 31Aug11 -- strings needed in the consistency check dialogs
	m_modeWordAdapt = _("adaptation");
	m_modeWordGloss = _("gloss");
	m_modeWordAdaptPlusArticle = _("an adaptation");
	m_modeWordGlossPlusArticle = _("a gloss");
	m_strNotInKB = _T("<Not In KB>"); // this one is never localizable,
				// and this KB entry type is not available in glossing mode either
	m_strNoAdapt = _("<no adaptation>");
	m_strNoGloss = _("<no gloss>");
	m_strTitle = _("Inconsistency Found");
	m_strAdaptationText = _("Adaptation text");
	m_strGlossText = _("Gloss text");
	m_modeWordAdaptPlural = _("adaptations");
	m_modeWordGlossPlural = _("glosses");
	m_consCheck_msg1 = _("An adaptation exists. A knowledge base entry is expected, but is absent");
	m_consCheck_msg2 = _("The knowledge base entry is %s, the document does not agree");

	// BEW added 25Aug11
	m_bRetransReportInProgress = FALSE;
    // whm added 8Jan11. Based on feedback from LSdev Linux group in Calgary, AI should
    // check to see that the computer hardware has a certain minimum resolution, especially
    // the screen's vertical pixels should be at least 480 pixels in height. Width should
    // be at lease 640 pixels. Anything smaller especially in height makes the sizers for
    // the Start Working wizard shrink the wizard to an unusable size in which nothing
    // can be seen and the only response possible is to hit the Esc key to close the wizard.
    // Hence, if the screen size is below 480h x 640w we notify the user and shut down the
    // application.
    bDelay_PlacePhraseBox_Call_Until_Next_OnIdle = FALSE; // in support of Collaboration with
			// PT or BE; set when setting up a doc in collab mode, used to suppress the
			// PlacePhraseBox() call until the next OnIdle() call is made - and cleared there

	m_adminHelpFileName = _T("Help_for_Administrators.htm");
	m_quickStartHelpFileName = _T("Adapt_It_Quick_Start.htm");

	int nDisplayHeightInPixels;
	int nDisplayWidthInPixels;
	::wxDisplaySize(&nDisplayWidthInPixels,&nDisplayHeightInPixels);
	if (nDisplayWidthInPixels < 640 || nDisplayHeightInPixels < 480)
	{
		wxString msg;
		// a message in English will do, since this message is likely only to appear
		// before a user can change the interface language
		wxString appVer = GetAppVersionOfRunningAppAsString();
		msg = msg.Format(_T("The Display size of this computer is too small (%dw x %dh) to run this version of Adapt It (%s).\nAdapt It cannot display its windows and dialogs properly.\nProgram aborting..."),nDisplayWidthInPixels,nDisplayHeightInPixels,appVer.c_str());
		wxMessageBox(msg,_T("Screen size too small"),wxICON_ERROR);
		LogUserAction(_T("Screen size too small"));
		// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
		wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
		return FALSE;
	}
	// markers like \ft* \fk* \fq* etc are no longer supported, similarly for cross ref markers
	m_FootnoteMarkers = _T("\\f \\f* \\fe \\fe* \\fr \\fk \\fq \\fqa \\fl \\fp \\fv \\ft \\fdc \\fdc* \\fm \\fm* ");
	m_CrossReferenceMarkers = _T("\\x \\x* \\xo \\xk \\xq \\xt \\xot \\xot* \\xnt \\xnt* \\xdc \\xdc* ");
	// BEW 11Oct10, we need this fast-access string for improving punctuation support when
	// inline markers are in the immediate context (since endmarkers for inline markers
	// should be handled within ParseWord(), we'll have two strings
	m_inlineNonbindingEndMarkers = _T("\\wj* \\qt* \\sls* \\tl* \\fig* ");
	m_inlineNonbindingMarkers = _T("\\wj \\qt \\sls \\tl \\fig ");
	// the next set each have an endmarkers, we'll not bother to have a separate string
	// for the endmarkers, but just use this one string for both (BEW added \\qs on 9Feb11)
	m_inlineBindingMarkers = _T("\\add \\bk  \\dc \\k \\lit \\nd \\ord \\pn \\sig \\em \\bd \\it \\bdit \\no \\sc \\pb \\ndx \\pro \\w \\wg \\wh \\qs ");
	m_usfmIndicatorMarkers = _T("\\s2 \\s3 \\mt2 \\mt3 \\fr \\fq \\ft \\xo \\xt \\imt \\iot ");
	// whm 20Dec10 added \\rr \\qh \\dvrf markers to the m_pngIndicatorMarkers below based on their usage in the
	// Nyindrou New Testament (which had 300 \rr markers, 139 \qh markers and 76 of the \dvrf markers).
	m_pngIndicatorMarkers = _T("\\st \\sx \\xr \\rr \\qh \\pp \\@ \\div \\dvrf \\tis \\cap \\di \\F \\fe \\pt \\ps \\sz \\bn \\tir ");

	// the following characters must never be in a SFM or USFM marker (we'll have the XML
	// metacharacters, and curly quotes for now - we can add more later if we need to)
	m_forbiddenInMarkers = _T("<>'\"&"); // possibles for later:  _T("[],.{}()%$#@!^+=|/?:;")
	// and append the single and double curly quotes
	wxChar aChar;
#ifdef _UNICODE
	aChar = L'\x201C'; // unicode Left Double Quotation Mark
	m_forbiddenInMarkers += aChar;
	aChar = L'\x2018'; // unicode Left Single Quotation Mark
	m_forbiddenInMarkers += aChar;
	aChar = L'\x201D'; // unicode Right Double Quotation Mark
	m_forbiddenInMarkers += aChar;
	aChar = L'\x2019'; // unicode Right Single Quotation Mark
	m_forbiddenInMarkers += aChar;
#else // ANSI version
	aChar = (unsigned char)147; // Left Double Quotation Mark
	m_forbiddenInMarkers += aChar;
	aChar = (unsigned char)145; // Left Single Quotation Mark
	m_forbiddenInMarkers += aChar;
	aChar = (unsigned char)148; // Right Double Quotation Mark
	m_forbiddenInMarkers += aChar;
	aChar = (unsigned char)146; // Right Single Quotation Mark
	m_forbiddenInMarkers += aChar;
#endif

	//wxString s = _T("*f\\ *x\\");
	//const wxChar* pBuf = s.GetData();
	//int itemLen = ParseMarker(pBuf); // <- testing the one in helpers.cpp, it returns 2, not 3,
									 // for *f\ (the reversed \f* marker), so it needs fixing

	//m_pUsfm2Oxes = NULL; // BEW added 2Sep10 // BEW removed 15Jun11 until we need to support OXES
	//m_bOxesExportInProgress = FALSE; // BEW removed 15Jun11, same reason

	m_pAI_MenuStructure = (AI_MenuStructure*)NULL; // whm added 8Sep10
	m_pUserProfiles = (UserProfiles*)NULL; // whm added 8Sep10
	m_pFactoryUserProfiles = (UserProfiles*)NULL; // whm added 15Oct10

	m_pEmailReportData = (EmailReportData*)NULL; // whm added 10Nov10

	m_bForceFullConsistencyCheck = FALSE; // set true if user has respellings in the KB and
			// after the KB save to disk and the message comes up asking if he wants a full
			// consistency check done, and he responds by clicking Yes button
	m_bAdminMoveOrCopyIsInitializing = FALSE; // default
	maxProgDialogValue = 2147483647; //MAXINT;
	m_bControlIsWithinOnInit = TRUE;
	m_bAutoExport = FALSE; // this flag can only be set TRUE by use of the commandline command
						   // export, which takes three obligatory string parameters following
						   // BEW added 12Nov09 for John Hatton & Steve McEvoy; if set in OnInit()
						   // the app is launched does an automated default USFM adapation
						   // export from a given doc in given project and saves to a given
						   // folder and then shuts down, no GUI is displayed (John H will
						   // build a SendIt app to grab the resulting file and send it over
						   // HF radio email link to Steve McEvoy
	PathSeparator = wxFileName::GetPathSeparator(); // need this defined early, because the
													// ReadOnlyProtection class uses it
	// set m_pROPwxFile, on heap; delete it in OnExit()
	m_pROPwxFile = new wxFile;	// use default constructor; call Open() later when project
								// path is known

	// initialize for Read-Only support when accessing a remote project folder
	m_bReadOnlyAccess = FALSE; // default, allows current user write access to projects
	m_bFictitiousReadOnlyAccess = FALSE; // default unless explicitly turned on by advisor or consultant
	m_pROP = new ReadOnlyProtection(this);
	m_pROP->Initialize();

	//
	m_pRemovedMenuItemArray = new wxArrayPtrVoid;

	// whm added 26Apr11 for AI-PT Collaboration support
	m_pArrayOfCollabProjects = new wxArrayPtrVoid;

	// testing of BreakStringBufIntoChapters()
	//wxString testBookStr1,testBookStr2,testBookStr3;
	//testBookStr1 = _T("\\id MAT \n\\mt Matthew\n\\c 1\n\\s Subheading 1\n\\v 1\n\\c 2\n\\c 3\n\\v 1 \\v2 \\v3\n\\c 4\n\\v 1 Some verse text.\n\\c 5\n\\v 1");
	//testBookStr2 = _T("This string has no chapters or verses");
	//testBookStr3 = _T("\\c 1\n\\s Subheading 1\n\\v 1 This is the text of verse 1 of chapter 1\n\\c 2\n\\c 3\n\\v 1 \\v2 \\v3\n\\c 4\n\\v 1 Some verse text.\n\\c 5\n\\v 1");
	//wxArrayString testBookArr1,testBookArr2,testBookArr3;
	//testBookArr1 = BreakStringBufIntoChapters(testBookStr1);
	//testBookArr2 = BreakStringBufIntoChapters(testBookStr2);
	//testBookArr3 = BreakStringBufIntoChapters(testBookStr3);
	//int testBSct;
	//for (testBSct = 0; testBSct < (int)testBookArr1.GetCount(); testBSct++)
	//	wxLogDebug(_T("testBookArr1[%d] = [%s]"),testBSct,testBookArr1.Item(testBSct).c_str());
	//for (testBSct = 0; testBSct < (int)testBookArr2.GetCount(); testBSct++)
	//	wxLogDebug(_T("testBookArr2[%d] = [%s]"),testBSct,testBookArr2.Item(testBSct).c_str());
	//for (testBSct = 0; testBSct < (int)testBookArr3.GetCount(); testBSct++)
	//	wxLogDebug(_T("testBookArr3[%d] = [%s]"),testBSct,testBookArr3.Item(testBSct).c_str());
	//int endTest = 1;

	// testing of RemoveMultipleSpaces()
	//wxString testMultiSpInitial = _T("  This is a test string with multiple spaces initially");
	//wxString testMultiSpFinal = _T("This is a test string with multiple spaces initially  ");
	//wxString testMultiSpMedial = _T("This is a test string with multiple spaces        medially");
	//wxString testMultiSpAll = _T("        ");
	//wxString testMultiSpNull = _T("");
	//wxString testMultiSpNone = _T("Thisisateststringwithnospacesinthestringatall");
	//wxString result1,result2,result3,result4,result5,result6;
	//result1 = RemoveMultipleSpaces(testMultiSpInitial);
	//result2 = RemoveMultipleSpaces(testMultiSpFinal);
	//result3 = RemoveMultipleSpaces(testMultiSpMedial);
	//result4 = RemoveMultipleSpaces(testMultiSpAll);
	//result5 = RemoveMultipleSpaces(testMultiSpNull);
	//result6 = RemoveMultipleSpaces(testMultiSpNone);

	// end of testing of RemoveMultipleSpaces()

	/*
	// test of ChangeFilenameExtensionTo() and ChangeFilenameExtension2() function
	const int NUMTEST = 16;
	wxString test[NUMTEST] =
	{
	 _T(".hiddenFile"), // hidden filename (Unix) without extension
	 _T("periodAtEnd."), // filename ending with dot - empty extension
	 _T("file.has.multiple.ext"), // filename with multiple dots and extension
	 _T(".hiddenfile.has.multiple.ext"), // hidden filename (Unix) with multiple dots and extension
	 _T("file..doubleDotExt"), // filename with double dots (one is extension)
	 _T("..hiddenFileDoubleDotExt"), // hidden filename (Unix) with file beginning with dot (extension?)
	 _T("FileDoubleDotExtAtEnd.."), // filename ending with double dots (empty extension)
	 _T("C:\\.hiddenFile"),
	 _T("C:\\C++ Programming\\Adapt It\\adaptit\\source\\..\\xml\\AI_UserProfiles.xml"), // path+filename path redirection to valid file
	 _T("C:\\C++ Programming\\Adapt It\\adaptit\\source\\AI_UserProfiles.xml"), // path+filename file doesn't exist on path
	 _T("C:\\C++ Programming\\Adapt It\\adaptit\\xxx\\AI_UserProfiles.xml"), // path+filename invalid path
	 _T("C:\\C++ Programming\\Adapt It\\adaptit\\source\\..\\..\\ai_codefixes\\source\\xml\\AI_UserProfiles.xml"), // path+filename path redirection to valid path
	 _T("C:\\C++ Programming\\Adapt It\\adaptit\\source\\..\\"), // path only redirected to parent
	 _T("C:\\C++ Programming\\Adapt It\\adaptit\\source\\..\\docs\\Doxyfile"), // path redirected to docs folder with valid filename (no extension)
	 _T("C:\\C++ Programming\\Adapt It\\adaptit\\source\\.svn"), // path to .svn folder no final \ on folder and no filename
	 _T("C:\\C++ Programming\\Adapt It\\adaptit\\source\\.svn\\prop-base\\Adapt_It.wdr.svn-base") // path+filename to valid file multiple dots (pseudo extension)
	};

	wxString testArray1[NUMTEST];
	wxString testArray2[NUMTEST];
	wxLogDebug(_T("\nChangeFilenameExtensionTo() results:"));
	for (int indx = 0; indx < NUMTEST; indx++)
	{
		wxString temp1,temp2;
		temp1 = test[indx];
		testArray1[indx] = ChangeFilenameExtensionTo(temp1,_T("NewExt"));
		wxLogDebug(_T("   %d. File path/name was %s, now it is %s"),indx,temp1.c_str(),testArray1[indx].c_str());
	}
	wxLogDebug(_T("\nChangeFilenameExtension2() results:"));
	for (int indx = 0; indx < NUMTEST; indx++)
	{
		wxString temp1,temp2;
		temp1 = test[indx];
		testArray2[indx] = ChangeFilenameExtension2(temp1,_T(".NewExt"));
		wxLogDebug(_T("   %d. File path/name was %s, now it is %s"),indx,temp1.c_str(),testArray2[indx].c_str());
	}
	for (int indx = 0; indx < NUMTEST; indx++)
	{
		if (testArray1[indx] != testArray2[indx])
		{
			wxLogDebug(_T("\nDifferences found:"));
			wxLogDebug(_T("   %d. ChangeFilenameExtensionTo(): %s"),indx,testArray1[indx].c_str());
			wxLogDebug(_T("   %d. ChangeFilenameExtension2() : %s"),indx,testArray2[indx].c_str());
		}
	}
	*/

	// test wxProcess functions
	//unsigned long tempPID = ::wxGetProcessId();
	//bool bPIDExists;
	//bPIDExists = wxProcess::Exists(tempPID);
	//bPIDExists = wxProcess::Exists(9000);
	// result: wxProcess::Exists() returns true for an existing process, false if the pid isn't assigned
	// end of wxProcess function testing

	// test read-only access functionality
	/* successful, m_pROPwxFile on heap, if open, stays open until explicitly Close()-ed
	wxString projectFolderPath = _T("C:\\Card1");
	m_bReadOnlyAccess = m_pROP->SetReadOnlyProtection(projectFolderPath);
	m_bReadOnlyAccess = m_pROP->RemoveReadOnlyProtection(projectFolderPath);
	*/
	//wxString myFile = _T("C:\\Card1\\~AIROP-BEW-watersb.lock");
	//wxFile file(myFile,wxFile::write);
	//if (file.IsOpened())
	//{
	//	m_pROP->m_strTheOtherReadOnlyProtectionFilename =
	//		m_pROP->GetReadOnlyProtectionFileInProjectFolder(projectFolderPath);
	//}
	// end test of GetReadOnlyProtectionFileInProjectFolder() function
	//
	// testing of GetUniqueIncrementedFileName
	//int junkCt;
	//for (junkCt = 0; junkCt < 300; junkCt++)
	//{
	//	wxString testPath = _T("C:\\Users\\Bill Martin\\Documents\\Junk\\TestFile.txt");
	//	wxString newFile = GetUniqueIncrementedFileName(testPath,incrementViaNextAvailableNumber,2,_T("_Old_"));
	//	::wxCopyFile(testPath,newFile);
	//}
	// end test of GetUniqueIncrementedFileName

	m_collaborationEditor = _T("");

	m_nWorkflowProfile = 0; // default value is for "None" unless changed by the
							// value stored in the basic and/or config files.

	m_nTempWorkflowProfile = -1; // -1 is the default and means no profile value is
								 // being saved for restoration. The only time this
								 // int value will not be -1 is when the value of
								 // m_bTemporarilyRestoreProfilesToDefaults is TRUE.
	m_bTemporarilyRestoreProfilesToDefaults = FALSE; // whm added 14Feb12
	m_bAiSessionExpectsUserDefinedProfile = FALSE; // whm added 15Feb12

 	m_bForce_Review_Mode = FALSE; // BEW added 23Oct09, for Bob Eaton's "dumb mode" back
								  // translating, via a frm switch for a launch from the
								  // shell
	m_bSkipBasicConfigFileCall = FALSE;
	m_bFailedToRemoveCustomWorkFolderLocationFile = FALSE; // default
	m_pRemovedAdminMenu = NULL;
	m_bAdminMenuRemoved = FALSE; // it will be removed later in this function and this
								 // flag set at that point
	m_bDoNotWriteConfigFiles = FALSE; // default is allow them to be written
	m_adminPassword = _T(""); // nothing initially, basic config file can store one
							  // and "admin" will always work, but not be stored in basic
							  // config file ever
	//m_bPwdProtectCollabSwitching = TRUE; // whm added 2Feb12
	//m_collabSwitchingPassword = _T(""); // nothing initially, basic config file stores on
										// and "switch" will always work, but isn't stored in
										// the basic config file

	// wxWidgets NOTES:
    // 1. Do NOT attempt to call or manipulate anything from within the CMainFrame
    // constructor (see MainFrm.cpp) before a CMainFrame object is constructed here (see
    // the new CMainFrame() statement below. For example, removing a menu from the main
    // frame cannot be done in the CMainFrame constructor because the main frame menu
    // itself is not loaded and constructed until the SetMenuBar call here in
    // CAdapt_ItApp::OnInit() is executed with:
    // m_pMainFrame->SetMenuBar(AIMenuBarFunc(m_pDocManager));
    // 2. All Application initialization should be done here in OnInit() rather than in the
    // App's constructor CAdapt_ItApp::CAdapt_ItApp(). This is especially true for versions
    // of wxWidgets after 2.4.2 (2.5.x, 2.6.x, 2.7.x, 2.8.x etc), because in the more
    // recent wxWidgets' versions the application's constructor is "called much earlier
    // than previously." Also Note that any application level cleanup should be done in
    // CAdapt_ItApp::OnExit(), and NOT in the application's destructor
    // CAdapt_ItApp:~CAdapt_ItApp(), for similar reasons (i.e., the app's destructor gets
    // called much later than in previous versions).

	// whm moved initialization of global pointer to the appliction gpApp here at the
	// beginning of OnInit() to make it available sooner.
    gpApp = this;

	// whm added for wx version:
	// Adapt It has many windows and buttons, so in order to reduce the overhead of UI
	// update events we set the update interval to happen only every nUpdateInterval
	// milliseconds. Note: SetUpdateInterval() is a static function.
	// whm update note: testing seems to show that CPU usage is not affected by setting
	// the nUpdateInterval differently than its default value of 0. The CPU usage stays
	// around 50% for most states of the application (except when showing a wxMessageBox
	// when it drops to near 0%).
	//static long nUpdateInterval = -1;
	//wxUpdateUIEvent::SetUpdateInterval(nUpdateInterval);

	m_pLocale = (wxLocale*)NULL;

	// Initializations below are from MFC's CAdapt_ItApp's constructor
	//
	//m_pCurView = NULL; // BEW added 22Sep05
	//
    // whm Note: I'm not implementing this m_pCurView pointer in the wxWidgets version.
    // Bruce added it because MFC's split window facility was found to be creating a second
    // view (and hence a different view pointer value) depending on which view was in
    // focus. The MFC app was crashing when the view was split due various places in the
    // code where the MFC design assumed the view didn't change. This problem of crashing
    // because of not having a stable view pointer surfaced early on and more frequently in
    // the wxWidgets version, and that's why I decided not to implement a splitter window,
    // and also (because of wxWidgets doc/view creating multiple view pointers at other
    // times) I eventually decided it was safer just to move all variables being kept on
    // the Doc and View here to the App.

	m_bJustLaunched = FALSE; // set true at end of OnInit(); then set false in OnIdle call
							 // within the main frame once it is created (below)

	m_dialogFontSize = 12; // default, but user can override // unused in WX version
	m_pKB = (CKB*)NULL;
	m_pGlossingKB = (CKB*)NULL; // added - not done in MFC version
	m_bExistingAdaption = FALSE;
	m_bKBReady = FALSE;
	m_bGlossingKBReady = FALSE;
	m_bAutoInsert = FALSE;
	m_bTablesLoaded = FALSE; // whm added 23May04 not initialized in MFC

	// BEW 8Jun10, removed support for checkbox "Recognise standard format
	// markers only following newlines"
	//gbSfmOnlyAfterNewlines = FALSE; // default, so sfm escape char anywhere defines a sfm
#ifdef _RTL_FLAGS
	// default reading order should be LTR unless user changes it, or config file changes it
	m_bSrcRTL = FALSE;
	m_bTgtRTL = FALSE;
	m_bNavTextRTL = FALSE;
#endif

    // define the Unicode label for use in the final step, to get separate Unicode folder
    // structures NOTE: for version 2.0.6 and onwards, we use "Unicode<SP>" rather than
    // "NR<SP>", and the RenameNRtoUnicode( ) function does the required rename silently.
#ifdef _UNICODE
	m_FrameAndDocProgramTitle = _("Adapt It Unicode"); // whm added 25Apr07
	m_strNR = _("Unicode ");
#else // ANSI version
	m_FrameAndDocProgramTitle = _("Adapt It"); // whm added 25Apr07
	m_strNR = "";
#endif

	// initialize the directory paths
	m_workFolderPath = _T("");
	m_wf_forced_workFolderPath = _T(""); // whm added 5Jun09
	m_newdoc_forced_newDocPath = _T(""); // whm added 5Jun09
	m_exports_forced_exportsPath = _T(""); // whm added 5Jun09
	m_localPathPrefix = _T("");
	// BEW added 17Aug09
	m_customWorkFolderPath = _T("");
	m_bUseCustomWorkFolderPath = FALSE;
	m_bLockedCustomWorkFolderPath = FALSE;

	m_userProfileFileWorkFolderPath = _T(""); // whm added 7Sep10
	m_logsEmailReportsFolderPath = _T("");
	m_usageLogFilePathAndName = _T(""); // whm added 8Nov10
	m_userLogFile = (wxFile*)NULL; // whm added 12Nov10
	//m_packedDocumentFilePathOnly = _T(""); // whm added 8Nov10
	//m_ccTableFilePathOnly = _T(""); // whm added 14Jul11

	// The following use the _T() macro as they shouldn't be translated/localized
	m_theWorkFolder = m_theWorkFolder.Format(_T("Adapt It %sWork"),m_strNR.c_str());
	// whm Note: In the MFC version the "Adaptations" folder is localizable, so we
	// will do the same here
	// TODO: check the Unpack process when unpacking a packed file coming from
	// a different localization.
	m_adaptionsFolder = _("Adaptations");
	m_lastSourceInputPath = m_workFolderPath; // don't do alternative custom loc'n here
	m_curProjectPath = _T("");
	m_sourceInputsFolderPath = _T("");
	m_freeTransOutputsFolderPath = _T("");
	m_freeTransRTFOutputsFolderPath = _T("");
	m_glossOutputsFolderPath = _T("");
	m_glossRTFOutputsFolderPath = _T("");
	m_interlinearRTFOutputsFolderPath = _T("");
	m_sourceOutputsFolderPath = _T("");
	m_sourceRTFOutputsFolderPath = _T("");
	m_targetOutputsFolderPath = _T("");
	m_targetRTFOutputsFolderPath = _T("");
	m_kbInputsAndOutputsFolderPath = _T("");
	m_liftInputsAndOutputsFolderPath = _T("");
	m_packedInputsAndOutputsFolderPath = _T("");

	m_curAdaptionsPath = _T("");
	m_curKBName = _T("");
	m_curKBPath = _T("");
	m_curProjectName = _T("");
	m_curGlossingKBName  = _T("Glossing");
	m_curGlossingKBPath = _T("");

	// consistent changes pointers and paths
	m_pConsistentChanger[0] = (CConsistentChanger*)NULL; // whm added 19Jun07
	m_pConsistentChanger[1] = (CConsistentChanger*)NULL; // " " "
	m_pConsistentChanger[2] = (CConsistentChanger*)NULL; // " " "
	m_pConsistentChanger[3] = (CConsistentChanger*)NULL; // " " "

	m_lastCcTablePath = _T("");
	m_tableName[0] = _T("");
	m_tableName[1] = _T("");
	m_tableName[2] = _T("");
	m_tableName[3] = _T("");
	m_tableFolderPath[0] = _T("");
	m_tableFolderPath[1] = _T("");
	m_tableFolderPath[2] = _T("");
	m_tableFolderPath[3] = _T("");

	m_lastTargetOutputPath = _T("");
	m_lastTargetRTFOutputPath = _T("");
	m_lastDocPath = _T(""); // config file will set this
	m_lastSourceOutputPath = _T("");
	m_lastSourceRTFOutputPath = _T("");
	m_lastKbOutputPath = _T("");
	m_lastKbLiftOutputPath = _T("");
	m_lastPackedOutputPath = _T("");
	//m_lastRtfOutputPath = _T("");
	m_lastInterlinearRTFOutputPath = _T("");
	m_lastRetransReportPath = _T("");
	m_lastGlossesOutputPath = _T("");
	m_lastGlossesRTFOutputPath = _T("");
	m_lastFreeTransOutputPath = _T("");
	m_lastFreeTransRTFOutputPath = _T("");
	m_foldersProtectedFromNavigation = _T("");

	m_bExecutingOnXO = FALSE; // whm added 13Apr09 - can be set to TRUE by
							  // use of command-line parameter -xo

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	// The following m_...Force... values are used to track whether command-line switches have
	// been used for the current session that "force" certain collab values to be used for the
	// session due to the use of command-line switches that can control collaboration.
	// The following two are used in conjunction with command-line switches -collab_on and -collab_off
	m_bForceCollabModeON = FALSE; // whm added 17Jan12
	m_bForceCollabModeOFF = FALSE; // whm added 17Jan12
	// The following is used in conjunction with the command-line switch/option:
	//    -collab_proj "PT/BE Src Proj:PT/BE Tgt Proj[:PT/BE FreeTrans Proj]"
	m_ForceCollabProjectNames = _T(""); // whm added 22Jan12
	// The following is used in conjunction with the command-line switch/option:
	//    -ai_proj "<Lang A to Lang B adaptations>"
	m_ForceCollabAIProjectName = _T(""); // whm added 17Jan12
	m_bForceCollabExpectsFreeTrans = FALSE; // whm added 9Feb12

	// The following m_...Saved... values are used to store the temporary collaboration-related
	// values that are read in from the basic config file. When the basic config file is later
	// saved it will use these values when writing the collab values back to the basic config
	// file.
	m_nSavedCollabPTSetting = -1; // whm added 17Jan12 // -1 means no setting was saved, 0 means FALSE, 1 means TRUE
	m_nSavedCollabBESetting = -1; // whm added 17Jan12 // -1 means no setting was saved, 0 means FALSE, 1 means TRUE
	m_SavedCollabAIProjName = _T("");
	m_SavedCollabProjectForSourceInputs = _T(""); // whm added 23Jan12
	m_SavedCollabProjectForTargetExports = _T(""); // whm added 23Jan12
	m_SavedCollabProjectForFreeTransExports = _T(""); // whm added 23Jan12
	m_SavedCollabSourceLangName = _T(""); // whm added 23Jan12
	m_SavedCollabTargetLangName = _T(""); // whm added 23Jan12
	m_nSavedCollabExpectsFreeTrans = -1; // whm added 23Jan12 // -1 means no setting was saved, 0 means FALSE, 1 means TRUE
	m_SavedCurProjectName = _T(""); // whm added 26Jan12
	m_SavedCurProjectPath = _T(""); // whm added 26Jan12
	*/

	m_bSuppressWelcome = FALSE;
	m_bSuppressTargetHighlighting = FALSE;
	nSequNumForLastAutoSave = -1; // global (-1 = _("turned off")
	m_bBackupDocument = FALSE;

	m_bCCTableLoaded[0] = m_bCCTableLoaded[1] = m_bCCTableLoaded[2] =
							m_bCCTableLoaded[3] = FALSE;

	m_bUseStartupWizardOnLaunch = TRUE;
	m_bAutoBackupKB = TRUE;
	m_bNoAutoSave = TRUE;

#ifdef Test_m_bNoAutoSave
	// Test_m_bNoAutoSave symbol #defined at start of Adapt_It.h
	#ifdef __WXDEBUG__
		wxLogDebug(_T("m_bNoAutoSave  in OnInit()  is set TRUE"));
	#endif
#endif

	m_ptViewTopLeft.x = 20;
	m_ptViewTopLeft.y = 20;
	m_szView.x = 640;
	m_szView.y = 580;
	m_bMarkerWrapsStrip = TRUE;
	m_bZoomed = FALSE;

	m_bIsInches = FALSE; // Default to Metric for wx version, especially since in the
						 // Windows page setup we can only use mm for margins
	m_bIsPortraitOrientation = TRUE;
	m_paperSizeCode = 9; // always mapped to MFC's enum for paper size code = 9; // A4

	//englishToMetric = 2.5;	// Bruce uses this as an approximation...
    // The following are OK for maintaining compatibility with MFC's config files, but they
    // should not be used for conversions relating to screen and printer display contexts.
	config_only_thousandthsInchToMillimetres = (float)0.025; // conversion factor rounded from 0.0254
	config_only_millimetresToThousandthsInch = (float)40.00; // conversion factor rounded from 39.37

	thousandthsInchToMillimetres = (float)0.0254; // more precise conversion factor for display
												  // context calculations
	millimetresToThousandthsInch = (float)39.37;  // more precise conversion factor for display
												  // context calculations

    // Default values are set here and stored in config file in MFC's MM_LOENGLISH mapping
    // mode units (thousandths of an inch). The conversion between English and Metric in
    // MFC used two different degrees of precision for the conversion; MFC uses a
    // conversion factor of 0.025 when converting margins but a more precise 0.0254 when
    // converting page size dimensions. This creates a bit of a mismatch for the wxWidgets
    // version which handles page setup and printing values throughout in millimeters and
    // does those conversions regularly with the more precise 0.0254 conversion factor. To
    // keep compatibility with the MFC version and its config files, we need to use 0.025
    // for calculating margin values, but 0.0254 for calculating page dimensions.
	m_pageWidth = 8267;		// 210mm / 0.0254mm/in (result truncated to whole int) in thousandths of an inch = 8267 A4
	m_pageWidthMM = wxRound(m_pageWidth * thousandthsInchToMillimetres); // 210mm	A4 page width in mm
	m_pageLength = 11692;	// 297mm / 0.0254mm/in (result truncated to whole int) in thousandths of an inch = 11692 A4
	m_pageLengthMM = wxRound(m_pageLength * thousandthsInchToMillimetres); // 297mm A4 page height in mm
	// the default margin values below use less precise conversion factor of 0.0250mm/in
	m_marginTop = 1000;		// 25mm / 0.0250mm/in (result truncated to whole int) in thousandths of an inch = 1000; // one inch
	m_marginTopMM = (int)(m_marginTop * config_only_thousandthsInchToMillimetres); // 25mm top margin in mm
	m_marginBottom = 1000;	// 25mm / 0.0250mm/in (result truncated to whole int) in thousandths of an inch = 1000; // one inch
	m_marginBottomMM = (int)(m_marginBottom * config_only_thousandthsInchToMillimetres); // 25mm bottom margin in mm
	m_marginLeft = 1000;	// 25mm / 0.0250mm/in (result truncated to whole int) in thousandths of an inch = 1000; // one inch
	m_marginLeftMM = (int)(m_marginLeft * config_only_thousandthsInchToMillimetres); // 25mm left margin in mm
	m_marginRight = 1000;	// 25mm / 0.0250mm/in (result truncated to whole int) in thousandths of an inch = 1000; // one inch
	m_marginRightMM = (int)(m_marginRight * config_only_thousandthsInchToMillimetres); // 25mm right margin in mm

	m_bEarlierProjectChosen = FALSE;
	m_bEarlierDocChosen = FALSE;
	nLastActiveSequNum = 0; // config file will set this

    // initialize font pointers to NULL outside InitializeFonts() because InitializeFonts()
    // may also be called from SetDefaults().
	m_pSourceFont = (wxFont*)NULL;
	m_pTargetFont = (wxFont*)NULL;
	m_pNavTextFont = (wxFont*)NULL;
	m_pDlgSrcFont = (wxFont*)NULL;
	m_pDlgTgtFont = (wxFont*)NULL;
	m_pDlgGlossFont = (wxFont*)NULL;
	m_pComposeFont = (wxFont*)NULL;
	m_pRemovalsFont = (wxFont*)NULL;
	m_pVertEditFont = (wxFont*)NULL;

	m_pSrcFontData = (wxFontData*)NULL;
	m_pTgtFontData = (wxFontData*)NULL;
	m_pNavFontData = (wxFontData*)NULL;

	InitializeFonts();	// incorporates the font initialization parts of MFC's Initialize()
						// that came later in OnInit()

	InitializePunctuation();

	// if it is the NR version, permit the dialogs with extra RTL-related controls to show
	// the latter
#ifdef _RTL_FLAGS
	m_bShowRTL_GUI = TRUE;
#else
	m_bShowRTL_GUI = FALSE;
#endif
	m_bRTL_Layout = FALSE;

	gbRTL_Layout = FALSE; // a global helps faster access for speed critical stuff,
						  // don't need to get a pointer to the app first
	m_nCurDelay = 0; // default is no delay (zero ticks)
	m_bBookMode = FALSE; // default is OFF for "book mode" (ie. Bible books folders)
	m_nBookIndex = -1; // -1 means "no index is defined", index values are 0 based
	m_nDivSize[0] = 17; // history books
	m_nDivSize[1] = 5; // wisdom books
	m_nDivSize[2] = 17; // prophecy books
	m_nDivSize[3] = 27; // new testament books
	m_nDivSize[4] = 1; // Other Texts (catchall)
	m_pBibleBooks = new wxArrayPtrVoid();
	m_strDivLabel[0] = _("History books");
	m_strDivLabel[1] = _("Wisdom books");
	m_strDivLabel[2] = _("Prophecy books");
	m_strDivLabel[3] = _("New Testament books");
	m_strDivLabel[4] = _("Other Texts");
	m_nBookIndex = 0; // safe default, but we should do better in InitInstance()
	m_pCurrBookNamePair = NULL;
	m_bibleBooksFolderPath.Empty(); // determinable always from m_nBookIndex
	m_nLastBookIndex = -1;
	m_nDefaultBookIndex = 39;
	m_nTotalBooks = 67;
	m_bDisableBookMode = FALSE; // start off enabled
	gbAbortMRUOpen = FALSE;

	// !!! whm added 19Jan05 AI_USFM.xml file processing and USFM Filtering
	m_bUsingDefaultUsfmStyles = FALSE;

	// whm added 19Oct10 for user workflow profiles support
	m_bShowNewProjectItem = TRUE; // show <New Project> in projectPage by default
	m_bUseAdaptationsGuesser = TRUE; // the default is TRUE; use the Guesser for adaptations unless
									// changed by config file settings
	m_bIsGuess = FALSE;				// the default is FALSE, changed by the guesser when returning a guess
	m_nGuessingLevel = 50;			// The guesser level (can range from 0 to 100, default is 50);
									// default is 50 unless changed by config file settings
	m_nCorrespondencesLoadedInAdaptationsGuesser = 0;
	m_nCorrespondencesLoadedInGlossingGuesser = 0;
	m_bAllowGuesseronUnchangedCCOutput = FALSE; // If TRUE Consistent Changes can operate on unchanged
									// guesser output; default is FALSE unless changed by config file
									// settings
	m_pAdaptationsGuesser = (Guesser*)NULL;
	m_pGlossesGuesser = (Guesser*)NULL;

	// whm added 9Feb11 in support of Paratext collaboration
	m_bParatextIsInstalled = FALSE;
	m_bParatextIsInstalled = ParatextIsInstalled();
	m_bBibleditIsInstalled = FALSE;
	m_bBibleditIsInstalled = BibleditIsInstalled();
	m_bParatextIsRunning = FALSE;
	m_bCollaboratingWithParatext = FALSE; // collaboration is OFF unless user administrator has turned it on (stored in basic config file)
	m_bCollaboratingWithBibledit = FALSE; // collaboration is OFF unless user administrator has turned it on (stored in basic config file)
	m_bStartWorkUsingCollaboration = FALSE; // whm added 19Feb12
	
	// whm 4Apr12 modification:
	// As of version 6.2.1 the App's m_collaborationEditor variable is stored in
	// the project config file with the other collaboration settings. Therefore
	// we allow the reading of a project config file to set the string value of 
	// m_collaborationEditor, overriding whatever is set here based solely on what 
	// editor is installed. If more than one editor is installed, the administrator
	// can select the external Scripture editor of choice in the 
	// SetupEditorCollaboration dialog by choosing the appropriate radio box button.
	// If Paratext or Bibledit is currently installed we set a default editor name
	// here, giving Paratext preference if it is installed. We set it here because 
	// when the SetupEditorCollaboration dialog is invoked, no project will be open
	// and we won't know initially what editor may be preferred for a given AI project
	// until the administrator selects an AI project at Step 1 in the dialog. This
	// default assigned here will at least provide something other than %s for the
	// string substitutions in the dialog's controls when it first appears and before
	// the administrator selects an existing AI project.
	// 
	// If neither Paratext nor Bibledit are installed, the m_collaborationEditor is 
	// an empty string. Since m_collaborationEditor can be an empty string, code should 
	// call wxASSERT(!m_collaborationEditor.IsEmpty()) before using it for %s string 
	// substitutions.
	if (m_bParatextIsInstalled)
	{
	     m_collaborationEditor = _T("Paratext"); // default editor
	}
	else if (m_bBibleditIsInstalled)
	{
	     m_collaborationEditor = _T("Bibledit"); // don't localize
	}
	m_CollabProjectForSourceInputs = _T("");
	m_CollabProjectForTargetExports = _T("");
	m_CollabProjectForFreeTransExports = _T("");
	m_CollabAIProjectName = _T("");
	m_CollabBookSelected = _T("");
	m_bCollabByChapterOnly = TRUE; // collaboration defaults to "Get Chapter Only" selected
	m_CollabChapterSelected = _T("");
	m_CollabSourceLangName = _T("");
	m_CollabTargetLangName = _T("");
	m_ParatextInstallDirPath.Empty();
	m_ParatextProjectsDirPath.Empty();
	m_BibleditProjectsDirPath.Empty();
	m_BibleditInstallDirPath.Empty();
	bParatextSharedDLLLoaded = FALSE;

	// whm Note: Make sure these folder names match those used in the wxDesigner's
	// AssignLocationsForInputsOutputsFunc() resource function.
	m_sourceInputsFolderName = _T("__SOURCE_INPUTS");
	// whm 12Jun11 added in support of inputs and outputs navigation protection
	m_freeTransOutputsFolderName = _T("_FREETRANS_OUTPUTS");
	m_freeTransRTFOutputsFolderName = _T("_FREETRANS_RTF_OUTPUTS");
	m_glossOutputsFolderName = _T("_GLOSS_OUTPUTS");
	m_glossRTFOutputsFolderName = _T("_GLOSS_RTF_OUTPUTS");
	m_interlinearRTFOutputsFolderName = _T("_INTERLINEAR_RTF_OUTPUTS");
	m_sourceOutputsFolderName = _T("_SOURCE_OUTPUTS");
	m_sourceRTFOutputsFolderName = _T("_SOURCE_RTF_OUTPUTS");
	m_targetOutputsFolderName = _T("_TARGET_OUTPUTS");
	m_targetRTFOutputsFolderName = _T("_TARGET_RTF_OUTPUTS");
	m_reportsOutputsFolderName = _T("_REPORTS_OUTPUTS");
	m_kbInputsAndOutputsFolderName = _T("_KB_INPUTS_OUTPUTS");
	m_liftInputsAndOutputsFolderName = _T("_LIFT_INPUTS_OUTPUTS");

	// whm added 12Jul11 The following special folder names. Their paths need to be defined after
	// EnsureWorkFolderIsPresent() and DealWithThePossibilityOfACustomWorkFolderLocation() calls
	// are made above.
	m_logsEmailReportsFolderName = _T("_LOGS_EMAIL_REPORTS"); // located in m_workFolderPath or m_customWorkFolderPath
	m_packedInputsAndOutputsFolderName = _T("_PACKED_INPUTS_OUTPUTS"); // located in m_workFolderPath or m_customWorkFolderPath
	m_ccTableInputsAndOutputsFolderName = _T("_CCTABLE_INPUTS_OUTPUTS"); // located in m_workFolderPath or m_customWorkFolderPath

	// whm 12Jun11 added in support of inputs and outputs navigation protection
	// folder navigation protection defaults to FALSE but project config file
	// value stored in m_foldersProtectedFromNavigation
	m_bProtectSourceInputsFolder = FALSE;
	m_bProtectFreeTransOutputsFolder = FALSE;
	m_bProtectFreeTransRTFOutputsFolder = FALSE;
	m_bProtectGlossOutputsFolder = FALSE;
	m_bProtectGlossRTFOutputsFolder = FALSE;
	m_bProtectInterlinearRTFOutputsFolder = FALSE;
	m_bProtectSourceOutputsFolder = FALSE;
	m_bProtectSourceRTFOutputsFolder = FALSE;
	m_bProtectTargetOutputsFolder = FALSE;
	m_bProtectTargetRTFOutputsFolder = FALSE;
	m_bProtectKbInputsAndOutputsFolder = FALSE;
	m_bProtectLiftInputsAndOutputsFolder = FALSE;
	m_bProtectPackedInputsAndOutputsFolder = FALSE;
	m_bProtectCCTableInputsAndOutputsFolder = FALSE;
	m_bProtectReportsOutputsFolder = FALSE;

	m_bUsePrefixExportTypeOnFilename = FALSE; // whm added 9Dec11 Bruce wants this to default to FALSE
	m_bUseSuffixExportDateTimeOnFilename = FALSE; // whm added 9Dec11
	m_bUsePrefixExportProjectNameOnFilename = FALSE; // whm added 21Feb12

	m_aiDeveloperEmailAddresses = _T("developers@adapt-it.org (bruce_waters@sil.org,bill_martin@sil.org,...)"); // email addresses of developers (separated by commas) used in EmailReportDlg.cpp

	m_bChangeFixedSpaceToRegularSpace = FALSE; // fixed spaces default to join words
											   // into phrases for adapting
	m_pUsfmStylesMap = new MapSfmToUSFMAnalysisStruct;
	m_pPngStylesMap = new MapSfmToUSFMAnalysisStruct;
	m_pUsfmAndPngStylesMap = new MapSfmToUSFMAnalysisStruct;
	m_pMappedObjectPointers = new wxArrayPtrVoid;// array of all pointers to USFMAnalysis
											// structs on the heap - for ease of
											// deletion in the app destructor
	gCurrentSfmSet = UsfmOnly;	// A code block at the end of GetProjectSettingsConfiguration()
			// will check if there was a project config file line for storing the project's
			// last in-operation SFM set (either UsfmOnly, PngOnly, or UsfmAndPng), if the
			// line is not present then at code block forces the set to be PngOnly -- because
			// that means that the project was created prior to Version 3.x. If that line is
			// present however, the code block is not entered, and the project setting is just
			// taken from whatever the config file stores there - the value is then put in the
			// app member variable, gProjectSfmSetForConfig.

	gProjectSfmSetForConfig = UsfmOnly;	// Retains any value set in the project config file
                                // unless user explicitly changes it in Edit Preferences
                                // USFM and Filtering tab or the Start Working... wizard
                                // USFM and Filtering page when creating a new project.

	m_bSingleQuoteAsPunct = FALSE; // BEW added March 17, 2005
	m_bDoubleQuoteAsPunct = TRUE; // BEW added April 28, 2005
	m_bCopySourcePunctuation = TRUE;// BEW added April 20, 2005

	m_bFreeTranslationMode = FALSE; // BEW added 21Jun05, free translation mode is
									// off by default
	m_bTargetIsDefaultFreeTrans = FALSE; // default is to have no precomposed
										 // free translation formed
	m_bGlossIsDefaultFreeTrans = FALSE; // ditto
	m_bComposeBarWasAskedForFromViewMenu = FALSE; // the bar is initially unopened by the
												  // Compose Bar command on View menu
	m_bDefineFreeTransByPunctuation = TRUE; // default
	m_freeTransDefaultBackgroundColor = wxColour(189,255,189); // light pastel green
	m_freeTransCurrentSectionBackgroundColor = wxColour(255,200,200); // light pastel pink

	m_bNotesExist = FALSE; // 12Sep05 BEW
	m_bUnpacking = FALSE; // BEW added 10Jan06

	// RDE: added 3 Apr 06 in support of calling SilEncConverters for preprocessing
	// the target word form (c.f. Consistent Changes)
    m_strSilEncConverterName.Empty();
    m_bSilConverterDirForward = TRUE;
    m_bECConnected = FALSE;
	m_eSilConverterNormalizeOutput = 0;
	m_bTransliterationMode = FALSE;

	bECDriverDLLLoaded = FALSE;
#ifdef USE_SIL_CONVERTERS
	// Do not try to load SIL Converters ECDriver.dll on Win95 and Win98
    if (wxGetWinVersion() >= wxWinVersion_5)
	{
		// Turn off system message "Failed to load shared library...(error 126: the specified
		// module could not be found", which pops up in idle time if following .Load() call
		// fails. We have our own message.
		wxLogNull logNo;	// eliminates any spurious messages from the system while
							// reading read-only folders/files
		wxString secPath,secPath32,secPath64;
		secPath32 = _T("C:\\Program Files\\Common Files\\SIL") + PathSeparator + LIB_NAME;
		secPath64 = _T("C:\\Program Files (x86)\\Common Files\\SIL") + PathSeparator + LIB_NAME;
		if (::wxFileExists(secPath64))
		{
			secPath = secPath64;
		}
		else if (::wxFileExists(secPath32))
		{
			secPath = secPath32;
		}
		else
		{
			 // SIL Encoding Converters could have been installed in a non-default location, in
			 // which case Bob E says the wxDynamicLibrary::Load() call below should be able to
			 // find it because the Encoding Conv installation sets the path to be able to locate
			 // the dll. If the Load() call still fails, we won't bother the user in that case
			 // with the error message.
			secPath = LIB_NAME;
		}

		bECDriverDLLLoaded = ecDriverDynamicLibrary.Load(secPath);
		if (!ecDriverDynamicLibrary.IsLoaded())
		{
			// the ECDriver.dll file was not found
			bECDriverDLLLoaded = FALSE;
			if (!(secPath == LIB_NAME)) // see the comment in the last else block above
			{
				// Only show the error message when the ECDriver.dll was found, but the Load()
				// call above failed
				wxString msg;
				// This error shouldn't happen with normal install, so it can remain in English
				msg = msg.Format(_T(
		"Could not load the %s dynamic library file. SIL Encoding Converters will not be available, however the rest of Adapt It will work fine.\n(The SIL Encoding Converters that is currently installed is apparently not compatible with Adapt It.)"),
				LIB_NAME);
				wxMessageBox(msg,_T("Incompatible version of SIL Encoding Converters"),wxICON_INFORMATION);
			}
		}
	}
#else
	bECDriverDLLLoaded = bECDriverDLLLoaded; // avoids "local variable is initialized but
										// not referenced" warning when define is not set
#endif	// end of if USE_SIL_CONVERTERS

	// BEW added 2Sep08
	gbAdaptBeforeGloss = TRUE; // in vertical edit, do adaptations updating
							   // before doing glosses updating

	// Above initializations are from MFC's CAdapt_ItApp's constructor

	m_eolStr = wxTextFile::GetEOL(); // this retrieves the platform specific end-of-line
				// character string for external text files:
				// On Windows it is "\r\n"; on Linux it is "\n"; on Macintosh it is "\r"

    // BEW added 01Oct06, we set it TRUE when program counter reaches the end of
    // InitInstance() because there is a framework call of OnNewDocument() made in
    // InitInstances()'s ProcessShellCommand() call and our addition of code to immediately
    // write out the project settings config file at the end of OnNewDocument() would
    // result in book mode being unilaterally reset to OFF before we even got to the
    // wizard. So we use th gbPassedAppInitialization flag to suppress the config file
    // write until we are actually in the wizard
	gbPassedAppInitialization = FALSE;

	// *** Initializations below were originally in the Doc in the MFC version ***
	// Variable initializations below moved here from the Doc because the
	// wxWidgets' doc/view framework deletes the Doc and recreates it
	// afresh (calling the Doc's constructor when a new Doc is opened) whereas MFC's
	// deletes its contents but reuses the old Doc pointer.
	gPreviousTextType = verse;
	m_pBuffer = (wxString*)NULL; // MFC had =0
	m_nInputFileLength = 0;
	m_curOutputFilename = _T("");
	m_curOutputPath = _T("");
	m_curOutputBackupFilename = _T("");
	m_currentUnknownMarkersStr = _T(""); // whm added 31May05
	m_pSourcePhrases = (SPList*)NULL; // MFC had = 0

	// Set text colors (see below)

	int width = wxSystemSettings::GetMetric(wxSYS_SCREEN_X);
#ifdef _RTL_FLAGS
	// NR version, we will use most of screen width
	if (width < 800)
		m_docSize = wxSize(width - 20,600); // the cy parameter is changed
											// by the view later
	else
		m_docSize = wxSize(width - 40,600);
#else // ANSI version, LTR only
	if (width < 800)
		m_docSize = wxSize(width - 40,600);
	else
		m_docSize = wxSize(width - 80,600);
#endif
	// The following are initialized to their current values on entry to
	// the View's OnEditPreferences()
	m_sfmSetBeforeEdit = UsfmOnly; // some reasonable default whm added
								   // 10Jun05 for Bruce
	m_filterMarkersBeforeEdit.Empty(); // some reasonable default whm added
									   // 10Jun05 for Bruce
	// The following are set to their new values on exit after OK in the
	// View's OnEditPreferences()
	m_sfmSetAfterEdit = UsfmOnly; // some reasonable default whm added
								  // 10Jun05 for Bruce
	m_filterMarkersAfterEdit.Empty(); // some reasonable default whm added
									  // 10Jun05 for Bruce
	m_bWantSourcePhrasesOnly = FALSE; // Added by JF.

	// *** Initializations above were originally in the Doc in the MFC version ***

	// TokenizeText() makes use of these
	m_poetryMkrs = _T("\\q \\q1 \\q2 \\q3 \\q4 \\qc \\qm \\qm1 \\qm2 \\qm3 \\qr \\qa \\b ");

	// *** Initializations below were originally in the View in the MFC version ***

    // Variable initializations below moved here from the View because the wxWidgets'
    // doc/view framework deletes the View and recreates it afresh (calling the View's
    // constructor when a new view is opened)
	m_pTargetBox = (CPhraseBox*)NULL; // added for persistent target box

	m_pEarlierTransDlg = (CEarlierTranslationDlg*)NULL;

	m_pNoteDlg = (CNoteDlg*)NULL; // needed in wx version
	m_pViewFilteredMaterialDlg = (CViewFilteredMaterialDlg*)NULL; // needed in wx version

	//m_pBundle = (CSourceBundle*)NULL;
	m_pActivePile = (CPile*)NULL; // start with null, in case user invokes Allow Glossing
		// in the Advanced menu after launching and only a project is open but not a document
	m_pAnchor = (CCell*)NULL;
	m_selectionLine = -1;
	m_nActiveSequNum = -1; // negative until set after a file is read in and laid out

	m_bSelectByArrowKey = FALSE;
    // BEW comment 17Apr09: the next two are deprecated but retained and set TRUE, but the
    // values are never used, they cannot be eliminated (well, not easily) because they are
    // needed for backwards compatibility of the config files
	m_bSuppressLast = TRUE; // default, very first time launched; thereafter uses config file
							// stored value (which now will never be anything but TRUE)
	m_bSuppressFirst = TRUE; // default, very first time launched; thereafter uses config file
							 // stored value (which now will never be anything but TRUE)
	// default modes
	m_bDrafting = TRUE;
	m_bSingleStep = FALSE; // default was TRUE before version 1.1.0
	m_bAcceptDefaults = FALSE;
	m_bRestorePunct = FALSE;
	m_bComposeWndVisible = FALSE; // initially, don't show it (keep interface looking simple)
	m_bModeBarVisible = TRUE; // initially, show it TODO: make persistent via basic config file setting
	m_bUseConsistentChanges = FALSE;
	m_bUseSilConverter = FALSE;
	m_bSaveToKB = TRUE;
	m_bForceAsk = FALSE;
	m_bCopySource = TRUE;
	m_bMarkerWrapsStrip = TRUE;
	m_bRespectBoundaries = TRUE;
	m_bHidePunctuation = FALSE; // default, on very first launch
	m_bStartViaWizard = FALSE; // set it in the start of the wizard code, clear it in OnIdle()
	m_bUserTypedSomething = FALSE;
	m_bUseToolTips = TRUE;
	m_nTooltipDelay = 20000; // tooltip delay time is 20 seconds (20000 ms)

	m_pFindDlg = (CFindDlg*)NULL;
	m_pReplaceDlg = (CReplaceDlg*)NULL;

	m_pHtmlFileViewer = (CHtmlFileViewer*)NULL; // whm 14Sep11 added

	gbGlossingVisible = FALSE;
	gbIsGlossing = FALSE;
	gbGlossingUsesNavFont = FALSE;
	//gbRemovePunctuationFromGlosses = FALSE; << BEW removed 13Nov10, it's nowhere set TRUE
	gnSelectionLine = -1;
	gnSelectionStartSequNum = -1;
	gnSelectionEndSequNum = -1;
	gbPrintFooter = TRUE;

	gbIgnoreScriptureReference_Receive = TRUE;
	gbIgnoreScriptureReference_Send = TRUE;
	gbLegacySourceTextCopy = TRUE; // default is legacy behaviour,
                // to copy the source text (unless the project config file establishes the
                // FALSE value instead)

	// The following initializations are for refactored view layout support
	m_pLayout = new CLayout(); // persists on the heap for as long as the session is alive

	// *** The variable initializations above were moved here from the View ***

	/*
	// Testing the GetBookCodeFastFromDiskFile() function
	wxString testPathXML, testPathUSFM, testPathUSFMLongNoId, testPathUSFMShortHasId, testPathUSFMShortNoId;
	wxString testResultXML, testResultUSFM,testResultLongNoId, testResultUSFMShortHasId, testResultUSFMShortNoId;
	// test a typical AI xml document file
	testPathXML = _T("C:\\Users\\Bill Martin\\Documents\\Adapt It Unicode Work\\X to Y adaptations\\Adaptations\\_Hezekiah 7 USFM.xml");
	testResultXML = GetBookCodeFastFromDiskFile(testPathXML);
	// test a typical USFM formatted file
	testPathUSFM = _T("C:\\Users\\Bill Martin\\Documents\\Adapt It Source Texts\\All Tok Pisin Book Files\\01-MAT-DTP.txt");
	testResultUSFM = GetBookCodeFastFromDiskFile(testPathUSFM);
	// test a malformed file longer than 4K that has no \id NNN line in the first 4K of the file
	testPathUSFMLongNoId = _T("C:\\Users\\Bill Martin\\Desktop\\Junk\\01-MAT-Long-without id.txt");
	testResultLongNoId = GetBookCodeFastFromDiskFile(testPathUSFMLongNoId);
	// test a file shorter than 4K which has the \id NNN in the file
	testPathUSFMShortHasId = _T("C:\\Users\\Bill Martin\\Desktop\\Junk\\01-MAT-Short-with id.txt");
	testResultUSFMShortHasId = GetBookCodeFastFromDiskFile(testPathUSFMShortHasId);
	// test a file shorter than 4K which has no \id NNN in the file
	testPathUSFMShortNoId = _T("C:\\Users\\Bill Martin\\Desktop\\Junk\\01-MAT-Short-without id.txt");
	testResultUSFMShortNoId = GetBookCodeFastFromDiskFile(testPathUSFMShortNoId);
	*/

	// Testing the FindBookFileContainingThisReference() function
	//wxString testRes;
	//wxString testPath = _T("C:\\Users\\Bill Martin\\Documents\\Adapt It Unicode Work\\X to Y adaptations\\Adaptations");
	//wxString testRef = _T("2JN 1:5");
	//wxString testExt = _T(".XML");
	//testRes = FindBookFileContainingThisReference(testPath, testRef, testExt);
	//int junk;
	//junk = 1;

	// Testing the FindBookFileContainingThisReference() function
	//wxString testStr1 = GetFileNameForCollaboration(_T("Collab"), _T("MAT"), _T("NYNT"), _T("3"), _T("xml"));
	//wxString testStr2 = GetFileNameForCollaboration(wxEmptyString, _T("GEN"), _T("NYNT"), _T("11"), _T(".xml"));
	//wxString testStr3 = GetFileNameForCollaboration(wxEmptyString, _T("MAL"), wxEmptyString, wxEmptyString, _T(".xml"));
	//wxString testStr4 = GetFileNameForCollaboration(_T("Collab"), _T("MAL"), _T("NYNT"), _T("01"), _T("tmp"));
	//int junk;
	//junk = 1;
		/*

	// testing function used in FilenameConflictDlg & AdminMoveOrCopy (see lines 3120 to
	// 3198 above)

	wxString filename = _T("Filename.xml");
	wxString anOutput = BuildChangedFilenameForCopy(&filename);
	const wxChar* pOutput = anOutput.c_str();
	wxString anOutput2 = BuildChangedFilenameForCopy(&anOutput);
	const wxChar* pOutput2 = anOutput2.c_str();
	filename = _T("file(3)name.txt");
	wxString anOutput3 = BuildChangedFilenameForCopy(&filename);
	const wxChar* pOutput3 = anOutput3.c_str();
	filename = _T("filename(abc).txt");
	wxString anOutput4 = BuildChangedFilenameForCopy(&filename);
	const wxChar* pOutput4 = anOutput4.c_str();
	filename = _T("filename().txt");
	wxString anOutput5 = BuildChangedFilenameForCopy(&filename);
	const wxChar* pOutput5 = anOutput5.c_str();
	filename = _T("filename).txt");
	wxString anOutput6 = BuildChangedFilenameForCopy(&filename);
	const wxChar* pOutput6 = anOutput6.c_str();
	filename = _T("filename.");
	wxString anOutput7 = BuildChangedFilenameForCopy(&filename);
	const wxChar* pOutput7 = anOutput7.c_str();
	filename = _T("filename");
	wxString anOutput8 = BuildChangedFilenameForCopy(&filename);
	const wxChar* pOutput8 = anOutput8.c_str();
	// end test of function used in FilenameConflictDlg & AdminMoveOrCopy

	//////////////// BEGIN WXWIDGETS LIBRARY CODE FRAGMENT TESTING //////////////////

    // Testing of general C++ code fragments (not depending on Adapt It code) can be done
    // here to save time in loading the Adapt It main frame, etc.

	// Testing the weird world of rectangles in MFC and wxWidgets!!!
	const int MAXITERATIONS = 18;
	bool bNormalize = TRUE;
	struct coord
	{
		int x;
		int y;
		int xx;
		int yy;
		int w;
		int h;
		double quadrant;
	};
	//
	coord c[MAXITERATIONS] = {
	//    point 1   point 2 width,height                           (relative posn of
	//		x,y,    xx,yy,      w,h  Q    Test #  Cartesian Quadrant points in constructor)
	//		----------------------------------------------------------------------
			2,3,	10,7,		8,4, 4,   // Test 1  4th - lower right topL and botR
			10,7,	2,3,		8,4, 4,   // Test 2  4th - lower right topL and botR swapped
			2,-3,	10,-7,		8,4, 1,   // Test 3  1st - upper right botL and topR
			10,-7,	2,-3,		8,4, 1,   // Test 4  1st - upper right botL and topR swapped
			-2,3,	-10,7,		8,4, 3,   // Test 5  3rd - lower left  topR and botL
			-10,7,	-2,3,		8,4, 3,   // Test 6  3rd - lower left  topR and botL swapped
			-2,-3,	-10,-7,		8,4, 2,   // Test 7  2nd - upper left  botR and topL
			-10,-7,	-2,-3,		8,4, 2,   // Test 8  2nd - upper left  botR and topL swapped
			2,1,	10,-3,		8,4, 4.1, // Test 9  spans 4th & 1st   botL and topR
			10,-3,	2,1,		8,4, 4.1, // Test 10 spans 4th & 1st   botL and topR swapped
			-10,1,	-2,-3,		8,4, 2.3, // Test 11 spans 2nd & 3rd   botL and topR
			-2,-3,	-10,1,		8,4, 3.3, // Test 12 spans 2nd & 3rd   botL and topR swapped
			-3,3,	5,7,		8,4, 3.4, // Test 13 spans 3rd & 4th   topL and botR
			5,7,	-3,3,		8,4, 3.4, // Test 14 spans 3rd & 4th   topL and botR swapped
			-3,-3,	5,-7,		8,4, 1.2, // Test 15 spans 1st & 2nd   botL and topR
			5,-7,	-3,-3,		8,4, 1.2, // Test 16 spans 1st & 2nd   botL and topR swapped
			-3,3,	5,-1,		8,4, 0,   // Test 17 spand all quads   botL and topR
			5,-1,	-3,3,		8,4, 0,   // Test 18 spand all quads   botL and topR swapped
			};
	int recttop, rectbottom;
	int recttopx, rectbottomx;
	int recttopn, rectbottomn;
	int rectleft, rectright;
	int rectleftx, rectrightx;
	int rectleftn, rectrightn;
	int rectwidth, rectheight;
	int rectwidthx, rectheightx;
	int rectwidthn, rectheightn;
	int ct;
	for (ct = 0; ct < MAXITERATIONS; ct++)
	{
		//if (c[ct].x > c[ct].xx)
		//{
		//	int tmp = c[ct].x;
		//	c[ct].x = c[ct].xx;
		//	c[ct].xx = tmp;
		//}
		//if (c[ct].y > c[ct].yy)
		//{
		//	int tmp = c[ct].y;
		//	c[ct].y = c[ct].yy;
		//	c[ct].yy = tmp;
		//}
		wxPoint topLeft(c[ct].x,c[ct].y);
		wxPoint botRight(c[ct].xx,c[ct].yy);
		wxRect rect(topLeft,botRight); // create rect with two points
		wxSize sz(abs(c[ct].xx - c[ct].x),abs(c[ct].yy - c[ct].y)); // calculated size (ignore c[ct].w and c[ct].h)
		wxRect rectx(topLeft,sz); // create rects with point and size
		wxRect rectn(topLeft.x,topLeft.y,c[ct].w,c[ct].h); // x,y, width and height come directly from the constants
		if (bNormalize)
		{
			rect = NormalizeRect(rect);
			rectx = NormalizeRect(rectx);
			rectn = NormalizeRect(rectn);
		}
		recttop = rect.GetTop();
		recttopx = rectx.GetTop();
		recttopn = rectn.GetTop();
		rectbottom = rect.GetBottom();
		rectbottomx = rectx.GetBottom();
		rectbottomn = rectn.GetBottom();
		rectleft = rect.GetLeft();
		rectleftx = rectx.GetLeft();
		rectleftn = rectn.GetLeft();
		rectright = rect.GetRight();
		rectrightx = rectx.GetRight();
		rectrightn = rectn.GetRight();
		rectwidth = rect.GetWidth();
		rectwidthx = rectx.GetWidth();
		rectwidthn = rectn.GetWidth();
		rectheight = rect.GetHeight();
		rectheightx = rectx.GetHeight();
		rectheightn = rectn.GetHeight();
		if (bNormalize)
			wxLogDebug(_T("-------------Test %d Quadrant %1.1f !!NORMALIZED!!-------------:"),ct+1,c[ct].quadrant);
		else
			wxLogDebug(_T("-------------Test %d Quadrant %1.1f-------------:"),ct+1,c[ct].quadrant);
		wxLogDebug(_T("rect created with topLeft(%d,%d) botRight(%d,%d):"),topLeft.x,topLeft.y,botRight.x,botRight.y);
		wxLogDebug(_T("x coord diff = %d  y coord diff = %d"),c[ct].xx - c[ct].x,c[ct].yy - c[ct].y);
		wxLogDebug(_T("CSize sz.x = %d CSize sz.y = %d"),sz.x,sz.y);
		wxLogDebug(_T("rectx created with topLeft(%d,%d),wxSize(%d,%d) from calc coords:"),c[ct].x,c[ct].y,sz.x,sz.y);
		wxLogDebug(_T("rectn created with topLeft(%d,%d) width %d, height %d direct from constants w & h:"),c[ct].x,c[ct].y,c[ct].w,c[ct].h);
		wxLogDebug(_T("   recttop    = %3d  recttopx    = %3d  recttopn    = %3d"),recttop,recttopx,recttopn);
		wxLogDebug(_T("   rectbottom = %3d  rectbottomx = %3d  rectbottomn = %3d"),rectbottom,rectbottomx,rectbottomn);
		wxLogDebug(_T("   rectleft   = %3d  rectleftx   = %3d  rectleftn   = %3d"),rectleft,rectleftx,rectleftn);
		wxLogDebug(_T("   rectright  = %3d  rectrightx  = %3d  rectrightn  = %3d"),rectright,rectrightx,rectrightn);
		wxLogDebug(_T("   rectwidth  = %3d  rectwidthx  = %3d  rectwidthn  = %3d"),rectwidth,rectwidthx,rectwidthn);
		wxLogDebug(_T("   rectheight = %3d  rectheightx = %3d  rectheightn = %3d"),rectheight,rectheightx,rectheightn);
		int i;
		i = 1;
	}
	// The Set methods are sensitive to the order they are called on a wxRect

	// set left and top first
	// a 5 by 5 rect with top left at 120,120
	// and bottom right at 125,115
	wxRect r1;
	r1.SetLeft(120);
	r1.SetTop(120);
	r1.SetRight(125);
	r1.SetBottom(125);
	// set right & bottom first, then left & top
	// to "same" points as above
	wxRect r2;
	r2.SetRight(125);
	r2.SetBottom(125);
	r2.SetLeft(120);
	r2.SetTop(120);

	// Only setting the bottom and right points
	wxRect r3;
	r3.SetRight(125);
	r3.SetBottom(115);

	wxLogDebug (_T("r1.x           = %d"),r1.x);
	wxLogDebug (_T("r1.y           = %d"),r1.y);
	wxLogDebug (_T("r1.GetRight()  = %d"),r1.GetRight());
	wxLogDebug (_T("r1.GetBottom() = %d"),r1.GetBottom());
	wxLogDebug (_T("r1.GetWidth()  = %d"),r1.GetWidth());
	wxLogDebug (_T("r1.GetHeight() = %d"),r1.GetHeight());

	wxLogDebug (_T("r2.x           = %d"),r2.x);
	wxLogDebug (_T("r2.y           = %d"),r2.y);
	wxLogDebug (_T("r2.GetRight()  = %d"),r2.GetRight());
	wxLogDebug (_T("r2.GetBottom() = %d"),r2.GetBottom());
	wxLogDebug (_T("r2.GetWidth()  = %d"),r2.GetWidth());
	wxLogDebug (_T("r2.GetHeight() = %d"),r2.GetHeight());

	wxLogDebug (_T("r3.x           = %d"),r3.x);
	wxLogDebug (_T("r3.y           = %d"),r3.y);
	wxLogDebug (_T("r3.GetRight()  = %d"),r3.GetRight());
	wxLogDebug (_T("r3.GetBottom() = %d"),r3.GetBottom());
	wxLogDebug (_T("r3.GetWidth()  = %d"),r3.GetWidth());
	wxLogDebug (_T("r3.GetHeight() = %d"),r3.GetHeight());

	int stop;
	stop = 1;

	////////////// END OF WXWIDGETS LIBRARY CODE FRAGMENT TESTING ////////////////
	*/

	// BEW 6April2011 **** DO NOT REMOVE COMMENTED OUT CODE BELOW **** THIS IS VALUABLE FOR BEW ****
	//
	// Some code to get the sequence of utf-8 bytes for a given utf-16 character
	// in the output window -- run this in the Unicode build, it's useless in the ANSI build
	// Designed for Doulos SIL font (using utf8 CC I couldn't get to work right, but this
	// bit of quick & dirty code below is what I can use for perhaps a little applet with
	// a minimal GUI - just a standard file in dialog to get a file, and a standard file out
	// dialog to write to a given folder).
	// Input a file of Takia ANSI data and convert it to utf-8 and write to disk;
	// I only need to convert upper and lower case velar n, for Takia data. And I only
	// need do this on each Takia NT book - therefore 27 times. So having it here is enough.
	/*
	//CBString inStr = "ai ieg abag ari gup tamol aal san maau ipiteana a."; // test string, hacked ANSI legacy Takia text
	// get a file dialog to file in the wanted Takia sfm text file to inStr
	wxString fullPath = _T("");
	wxString takia_message = _T("Select Takia SFM file for conversion");
	wxString default_path = _T("C:\\Users\\watersb\\Documents");
	fullPath = ::wxFileSelector(takia_message,default_path);
	if (!fullPath.IsEmpty())
	{
		wxFileName fn(fullPath);
		wxString itsFilename = fn.GetFullName();
		wxString itsPath = fn.GetPath();
		wxFile fileIn;
		bool bOpen = fileIn.Open(fullPath);
		if (bOpen)
		{
			size_t aSafeLength = 320000; // about .3Mb, Takia Luke is 177MB so
										 // this will get all of any Takia NT file
			// need a big enough byte buffer
			char* pBuff = new char[aSafeLength];
			memset(pBuff,0,aSafeLength);
			size_t actualNumBytes = fileIn.Read((void*)pBuff, aSafeLength);
			// make a CBString with a copy of the buffer contents
			CBString inStr(pBuff);
			delete pBuff; // no longer needed
			wxString outStr;
			int length = inStr.GetLength();
			for (int i = 0; i < length; i++)
			{
				unsigned char ch = inStr[i];
				unsigned char lcEng = 0xFD; // in PNG SIL Doulos
				unsigned char ucEng = 0xDE; // ditto
				wxChar lcEngW = 0x014B;
				wxChar ucEngW = 0x14A;
				wxString s;
				if (ch == lcEng)
				{
					outStr += lcEngW;
				}
				else if (ch == ucEng)
				{
					outStr += ucEngW;
				}
				else
				{
					CBString byteStr;
					byteStr = ch;
					s = Convert8to16(byteStr);
					outStr += s;
				}
			}
			CBString utf8Str = Convert16to8(outStr); // convert to utf-8
			int itsLength = utf8Str.GetLength();
			//wxString outfilename = _T("C:\\CC\\MyTest_AsUtf8.txt");
			wxString outfilename = itsPath; // initialize with the path to the folder
			wxString newName = itsFilename;
			int offset = newName.Find(_T('.'));
			if (offset != wxNOT_FOUND)
			{
				newName = newName.Left(offset);
			}
			newName += _T("_utf8.txt"); // keep the old file unchanged
			outfilename += _T('\\');
			outfilename += newName; // store in the same folder as the original
			wxFile f;
			f.Create(outfilename,TRUE);
			size_t writtenCount = f.Write((void*)(char*)utf8Str,itsLength);
			f.Close(); // load into AI Unicode and select Doulos SIL and see how it looks
					   // (it works nice - is correctly converted; or Notepad)
		}
	}
	int stop_here = 1;	// put a break point here; cancel the run & reenter debugger to do next book
	*/

	// *** Variable initializations below moved here from the App's constructor ***

    // BEW 24Aug10, changed comment. Reinit of KB structures is done in view->OnCreate().
    // This is because with only 1 doc allowed in WX, it first deletes the current doc and
    // view and recreates new ones before calling OnNewDocument(). The MFC version did not
    // do this, but reused its old doc and view pointers under the CSingleDocTemplate()
    // that MFC Adapt It uses. OnInit() calls OnNewDocument() to get the doc/view
    // structures set up; and hence because of the destruction of the view that is
    // entailed, view->OnCreate() will be called when control is here within OnInit(). This
    // would result in a crash, when OnCreate() tried to load KBs prematurely. We prevent
    // this by using the app member boolean, m_bControlIsWithinOnInit which is TRUE only
    // while control is here within OnInit(), testing for a TRUE value in OnCreate() and if
    // we find that it is so, we exit from OnCreate() prematurely. (Formerly we used a
    // different boolean, but I have eliminated it from the app today.)

	m_pDocManager = (wxDocManager*)NULL;// was originally in App constructor's preamble
	m_pMainFrame = (CMainFrame*)NULL;// was originally in App constructor's preamble

	// *** Initializations above were originally in the App's constructor in the MFC version ***

	const wxString name = wxString::Format(_T("Adapt_ItApp-%s"), wxGetUserId().c_str());
	// on my Windows machine name = "Adapt_ItApp-Bill Martin"
	// on my Linux machine name = "Adapt_ItApp-wmartin"

	m_pChecker = (wxSingleInstanceChecker*)NULL;
	m_pServer = (AI_Server*)NULL;

    // Note: The wxSingleInstanceChecker class determines if another instance of Adapt It
    // is running by the same user on the same local machine.
	{ // begin block for wxLogNull()
		wxString cmdLine;
		cmdLine = _T("[Raise]"); // Passing "[Raise]" as cmdLine to connection->Execute(cmdLine)
								 // will just cause the other running instance to raise its window.

		wxLogNull logNo; // eliminates spurious "Deleted stale lock file
		                 // '/home/user/Adapt_ItApp-wmartin' on Linux
		m_pChecker = new wxSingleInstanceChecker(name); // must delete m_checker in OnExit()
		wxASSERT(m_pChecker != NULL);

		wxString serverName;
		serverName = name.Lower();
		wxString topic = _T("bring_to_front"); // an arbitrary topic name - can be anything as long as it is not an empty string
		// Some of the code below is taken from the wxWidgets book pages 506-510.
		if (!m_pChecker->IsAnotherRunning())
		{
			// There is no other instance running currently so create a new server
			m_pServer = new AI_Server;
			if (!m_pServer->Create(serverName))
			{
				wxLogDebug(_T("Failed to create an IPC service in OnInit()."));
			}
		}
		else
		{
			// Another instance is currently running so make a connection to it
			// and cause its window to raise
			wxLogNull logNull;
			AI_Client* pClient = new AI_Client;

			// Ignored under DDE, host name in TCP/IP based classes
			wxString hostName = _T("localhost");

			// Create the connection
			// Note: the MakeConnection() call below invokes AI_Server::OnAcceptConnection() method which returns
			// a new AI_Connection. The topic can be anything as long as it is not an empty string.
			wxConnectionBase* pConnection = pClient->MakeConnection(hostName,serverName,topic);
			if (pConnection)
			{
				// Ask the other instance to raise itself
				pConnection->Execute(cmdLine); // cmdLine is "[Raise]" in our case
				pConnection->Disconnect();
				delete pConnection;
				pConnection = (wxConnectionBase*)NULL;
			}
			else
			{
				wxLogDebug(_T("The existing instance may be too busy to respond. Close any open dialogs and retry."));
			}
			wxString msg = _("Adapt It is already running. Aborting attempt to run a second instance of Adapt It...");
			LogUserAction(msg);
			// If only a single instance is to be allowed, we will return FALSE here
			// from OnInit() after deallocating some memory items below.
			// First deallocate the client
			delete pClient;

			if (pConnection != NULL)
				delete pConnection;

			// To avoid memory leaks at shutdown we should deallocate the things
			// created in OnInit() up to this point - before returning FALSE from
			// OnInit() below.
			m_nTotalBooks = m_pBibleBooks->GetCount(); //m_nTotalBooks = m_pBibleBooks->GetSize();
			if (m_nTotalBooks == 0L)
			{
				delete m_pBibleBooks;
			}
			else
			{
				for (int i = 0; i < m_nTotalBooks; i++)
				{
					BookNamePair* pPair =  (BookNamePair*)(*m_pBibleBooks)[i];
					if (pPair)
						delete pPair;
				}
				delete m_pBibleBooks;
			}
			int aTot;
			aTot = m_pRemovedMenuItemArray->GetCount();
			if (aTot == 0L)
			{
				delete m_pRemovedMenuItemArray;
			}
			else
			{
				int aIndex;
				for (aIndex = 0; aIndex < aTot; aIndex++)
				{
					wxMenuItem* mItem = (wxMenuItem*)(*m_pRemovedMenuItemArray)[aIndex];
					delete mItem;
				}
				delete m_pRemovedMenuItemArray;
			}

			aTot = m_pArrayOfCollabProjects->GetCount();
			if (aTot == 0L)
			{
				delete m_pArrayOfCollabProjects;
			}
			else
			{
				int aIndex;
				for (aIndex = 0; aIndex < aTot; aIndex++)
				{
					Collab_Project_Info_Struct* pArrayItem = (Collab_Project_Info_Struct*)(*m_pArrayOfCollabProjects)[aIndex];
					delete pArrayItem;
				}
				m_pArrayOfCollabProjects->Clear();
				delete m_pArrayOfCollabProjects;
			}
			if (m_pChecker)
			{
				delete m_pChecker;
			}
			if (m_pServer)
			{
				delete m_pServer;
			}
			delete m_pROP; // delete the ReadOnlyProtection class's only instance
			delete m_pROPwxFile; // delete the wxFile object on the heap for support of an
								 // open read-only protection file of form
								 // ~AIRIOP-machinename-username.lock while the owning user
								 // has a project folder open (on this or a remote machine)
			if (m_pLayout)
			{
				// add code here to ensure the CLayout's lists are cleared before deleting it, we
				// don't want to leak memory
				m_pLayout->DestroyStrips(); // destroys each strip and the memory involved with
											// their m_arrPiles & m_arrPileOffsets arrays (these
											// are both wxArrayInt arrays)
				m_pLayout->DestroyPiles();	// destroys each pile in m_pLayout's m_pPiles lists,
											// and the CCell instances that each pile owns
				delete m_pLayout;
			}
			if (m_pUsfmStylesMap->size() > 0) //if (m_pUsfmStylesMap->GetCount() > 0)
			{
				// destroy all Usfm key/object associations
				m_pUsfmStylesMap->clear(); //m_pUsfmStylesMap->Clear();
			}
			// destroy the Usfm map itself
			delete m_pUsfmStylesMap;
			if (m_pPngStylesMap->size() > 0)
			{
				// destroy all Png key/object associations
				m_pPngStylesMap->clear();
			}
			// destroy the Png map itself
			delete m_pPngStylesMap;
			if (m_pUsfmAndPngStylesMap->size() > 0)
			{
				// destroy all UsfmAndPng key/object associations
				m_pUsfmAndPngStylesMap->clear();
			}
			// destroy the UsfmAndPng map itself
			delete m_pUsfmAndPngStylesMap;

			delete m_pSourceFont;
			delete m_pTargetFont;
			delete m_pNavTextFont;
			delete m_pDlgSrcFont;
			delete m_pDlgTgtFont;
			delete m_pComposeFont;
			delete m_pDlgGlossFont;
			delete m_pRemovalsFont;
			delete m_pVertEditFont;
			delete m_pSrcFontData;
			delete m_pTgtFontData;
			delete m_pNavFontData;
			wxString key;
			USFMAnalysis* pSfm;
			// destroy all USFMAnalysis objects and the CPtrArray pointing to them
			if (m_pMappedObjectPointers->GetCount() > 0)
			{
				// destroy the USFMAnalysis objects on the heap
				for (int upos = 0; upos < (int)m_pMappedObjectPointers->GetCount(); upos++)
				{
					pSfm = (USFMAnalysis*)m_pMappedObjectPointers->Item(upos);
					if (pSfm)
						delete pSfm;
				}
				// destroy all keys from CPtrArray
				m_pMappedObjectPointers->Clear();
				// destroy the CPtrArray itself
			}
			delete m_pMappedObjectPointers;

			return FALSE; // this terminates the current instance of the application
		}
	} // end of block for wxLogNull(), the ~wxLogNull destructor is called here

	// Is CoInitialize (initializes COM) available on Linux and Mac???
//#ifdef _UNICODE
	// RichEdit stuff not needed in wxWidgets version
	//  this should be done early on. The AfxInitRichEdit() call will load version 1
	//	so we must do its work manually ourselves to get version 3 used
	//   m_hmodRichEd1 = LoadLibrary(_T("riched20.dll")); // we've decided not to use Rich Edit
	//													  // controls, but this can stay
//#endif

	// CoInitialize() won't compile on Linux

	// whm added 7Dec05
    // Retrieve the path to the setup folder (i.e., the path the executable was launched
    // from) We store the path in m_setupFolder
    // WX NOTE: The MFC code will only work on some standard Window's configurations. It
    // certainly will not work on Linux or other platforms, since only Windows uses
    // C:\Program Files\somedir as a location for installation of user programs. Also,
    // other platforms like Linux do not have drive letter designations such as C:, so
    // hardcoding any path prefixed with C:\ will not work across platforms.
    // For the wxWidgets version, we may be potentially running on any platform, hence, so
    // certain installed files such as books.xml file will be placed in platform-specific
    // directories. For non-Windows platforms is is not sufficient to simply know where the
    // application that is currently running resides at run time.
    // Different platforms expect certain kinds of files to be installed in certain
    // expected locations.
    //
	// The function FindAppPath(const wxString& argv0, const wxString& cwd,
	//                          const wxString& appVariableName)
	// was suggested by Julian Smart as one means to do this.
	// FindAppPath() makes the following checks in order:
	// 1. Checks for existance of a path associated with an environment variable
	//    name (passed in as the third parameter) [for situations in which the
	//    installation program set up an environment variable]
	// 2. Classic Mac just needs the current working directory when the
	//    application starts, so the second parameter cwd is simply returned.
	// 3. If above checks fail (or are inappropriate because of a null string
	//    passed as third parameter), the function checks the commandline
	//    argv[0] string passed as third parameter argv0. By default
	//    this argv0 should contain the path and name of the executable on
	//    most computer systems. FindAppPath() checks whether arfv0 represents
	//    an absolute or relative path and insures that the executable actually
	//    exists there.
	// 4. If all above fails, FindAppPath() searches the computer's possible
	//    PATH environment variable paths for the executable. If the executable
	//    is found, its path string is returned, otherwise the FindAppPath()
	//    just returns an empty string.
	//
	// NOTE: regardless of whether Unicode or ANSI version is being run, the
	// string returned from FindAppPath() should be the location where we
	// should be able to find the books.xml file.

	// !!!!!!!!!!!!! SET UP SOME STANDARD PATHS BELOW !!!!!!!!!!!!!!!!!!!!!!!!!

	// !!! testing only below

#if wxCHECK_VERSION(2, 7, 0)
	wxString resourcesDir; //,localizedResourcesDir;
	wxString dataDir, localDataDir, documentsDir;
	wxString userConfigDir, userDataDir, userLocalDataDir;
	wxString executablePath;
#ifndef __WXMSW__
	wxString installPrefix;
#endif
	wxStandardPaths stdPaths;
	resourcesDir = stdPaths.GetResourcesDir(); // GetResourcesDir() is new with wxWidgets 2.7.0
	wxLogDebug(_T("The wxStandardPaths::GetResourcesDir()  = %s"),resourcesDir.c_str());
	dataDir = stdPaths.GetDataDir();
	wxLogDebug(_T("The wxStandardPaths::GetDataDir() = %s"),dataDir.c_str());
	localDataDir = stdPaths.GetLocalDataDir();
	wxLogDebug(_T("The wxStandardPaths::GetLocalDataDir() = %s"),localDataDir.c_str());
//#ifdef __WXMAC__
    // whm note 18Jun09: the wxStandardPaths::GetDocumentsDir() is probably causing program
    // crash when compiled for Mac OS X 10.3 Panther, so I'm using the older
    // ::wxGetHomeDir() function for the Mac which should return the same directory string
    // on the Mac that wxStandardPaths::GetDocumentsDir() does.
	// GDLC 29Sep11 Not needed now that we are not targeting MacOS Panther or PPC.
//	documentsDir = ::wxGetHomeDir();
//#else
	documentsDir = stdPaths.GetDocumentsDir();
//#endif
	wxLogDebug(_T("The wxStandardPaths::GetDocumentsDir() = %s"),documentsDir.c_str());
	userConfigDir = stdPaths.GetUserConfigDir();
	wxLogDebug(_T("The wxStandardPaths::GetUserConfigDir() = %s"),userConfigDir.c_str());
	userDataDir = stdPaths.GetUserDataDir();
	wxLogDebug(_T("The wxStandardPaths::GetUserDataDir() = %s"),userDataDir.c_str());
	userLocalDataDir = stdPaths.GetUserLocalDataDir();
	wxLogDebug(_T("The wxStandardPaths::GetUserLocalDataDir() = %s"),userLocalDataDir.c_str());
	executablePath = stdPaths.GetExecutablePath();
	wxLogDebug(_T("The wxStandardPaths::GetExecutablePath() = %s"),executablePath.c_str());
#ifndef __WXMSW__
	installPrefix = stdPaths.GetInstallPrefix();
	wxLogDebug(_T("The wxStandardPaths::GetInstallPrefix() = %s"),installPrefix.c_str());
#endif
#endif // #if wxCHECK_VERSION(2, 7, 0)

	// whm added 6Dec11
	// Get the prefix for Linux installed files needed by the App. The m_PathPrefix will
	// be an empty string for platforms other than Linux/GTK. On Linux the m_PathPrefix
	// will be "/usr" for debian package installs, "/usr/local" for "sudo make install"
	// instances, and an empty string when running adaptit from non installed locations.
	// The m_PathPrefix is used as a prefix on the path of the following files used by
	// adaptit:
	// 1. adaptit   the main executable program at /usr/bin/adaptit or /usr/local/bin/adaptit
	//    depending on the value of m_PathPrefix.
	//    path variable: m_appInstallPathOnly
	//    relevant function: FindAppPath() or GetProgramLocationFromSystemPATH(GetAppName()
	// 2. bibledit-rdwrt   the Bibledit supplied utility program at /usr/bin/bibledit-rdwrt (or
	//    where found on the systme PATH).  m_BibleditInstallDirPath already has a prefix on it
	//    because it calls the GetProgramLocationFromSystemPATH() function directly.
	//    path variable: m_BibleditInstallDirPath
	//    relevant functions: GetBibleditInstallDirPath() calls GetProgramLocationFromSystemPATH(_T("bibledit-rdwrt")).
	// 3. adaptit-bibledit-rdwrt   the Adapt It supplied Bibledit utility program at
	//    /usr/bin/adaptit-bibledit-rdwrt or /usr/local/bin/adaptit-bibledit-rdwrt depending
	//    on the value of m_PathPrefix.
	//    path variable: beRdwrtPathAndFileName (in CollabUtilities.cpp's GetPathToBeRdwrt())
	//    relevant function: GetAdaptit_Bibledit_rdwrtInstallDirPath() calls GetProgramLocationFromSystemPATH(_T("adaptit-bibledit-rdwrt"))
	// 4. AI_USFM.xml, AI_UserProfiles.xml and books.xml, curl-ca-bundle.ctr, iso639-3codes.txt
	//    the Adapt It xml control files, CA authority file, ethnologue codes
	//    at "/usr/share/adaptit/" or "/usr/local/share/adaptit/" depending on the value
	//    of m_PathPrefix.
	//    path variable: m_xmlInstallPath
	//    relevant function: GetDefaultPathForXMLControlFiles()
	// 5. The localization files named adaptit.mo for each language <lang> that get installed at
	//    "/usr/share/locale/<lang>/LC_MESSAGES/" or "/usr/local/share/locale/<lang>/LC_MESSAGES/"
	//    for each <lang> localization depending on the value of m_PathPrefix.
	//    path variable: m_localizationInstallPath
	//    relevant function: GetDefaultPathForLocalizationSubDirectories()
	// 6. The help documents adaptit.htb, Adapt_It_Quick_Start.htm, Help_for_Administrators.htm,
	//    and the supporting images files .../Images/Admin_help/* and .../Images/Adapt_It_Quick_Start/*
	//    at "/usr/share/adaptit/help/..." or "/usr/local/share/adaptit/help/..." depending on the
	//    value of m_PathPrefix.
	//    path variable: m_helpInstallPath
	//    relevant function: GetDefaultPathForHelpFiles()
	m_PathPrefix = GetAdaptItInstallPrefixForLinux();
	// Note: The m_PathPrefix will be an empty string unless the app is actually installed
	// and currently running on Linux.

	m_setupFolder = FindAppPath(argv[0], wxGetCwd(), _T(""));
#ifdef __WXGTK__
	// on Linux, first try getting the m_appInstallPathOnly from the actual system PATH
	m_appInstallPathOnly = GetProgramLocationFromSystemPATH(GetAppName());
	// if it is not on the system PATH, then get the path of the running executable
	if (m_appInstallPathOnly.IsEmpty())
	{
		m_appInstallPathOnly = FindAppPath(argv[0], wxGetCwd(), _T(""));
	}
#else
	m_appInstallPathOnly = FindAppPath(argv[0], wxGetCwd(), _T(""));
#endif
	wxLogDebug(_T("The m_appInstallPathOnly = %s"),m_appInstallPathOnly.c_str());
	// On Windows the m_appInstallPathOnly will be something like (if installed to
	// default location):
	// "C:\Program Files\Adapt It WX" or "C:\Program Files\Adapt It WX Unicode\"
	// On Linux/GTK the m_setupFolder will be something like:
	// "/usr/bin/" or "/usr/local/bin/"
	// On the Mac the m_setupFolder will be something like:
	// "/Applications"

    // The m_xmlInstallPath stores the path where the AI_USFM.xml, AI_UserProfiles.xml,
    // books.xml, curl-ca-bundle.crt, and iso639-3codes.txt files are installed on the
    // given platform.
	// On wxMSW: "C:\Program Files\Adapt It WX\ or C:\Program Files\Adapt It WX Unicode\"
	// On wxGTK: "/usr/share/adaptit/" or "/usr/local/share/adaptit/" depending on the
	//           value of m_PathPrefix [adaptit here is the name of a directory]
	// On wxMac: "AdaptIt.app/Contents/Resources"
	m_xmlInstallPath = GetDefaultPathForXMLControlFiles();
	wxLogDebug(_T("The m_xmlInstallPath = %s"),m_xmlInstallPath.c_str());

    // The m_localizationInstallPath stores the path where the <lang> localization files
    // are installed on the given platform.
	// On wxMSW:   "C:\Program Files\Adapt It WX\Languages\ or
	//             C:\Program Files\Adapt It WX Unicode\Languages\"
	// On wxGTK:   "/usr/share/locale/" or "/usr/local/share/locale/"   which then contains multiple
	//                                   "<lang>/LC_MESSAGES/adaptit.mo"
	// On wxMac:   "AdaptIt.app/Contents/Resources/locale"   [bundle subdirectory] // this
				// is where Poedit puts its localization files.
	m_localizationInstallPath = GetDefaultPathForLocalizationSubDirectories();
	wxLogDebug(_T("The m_localizationInstallPath = %s"),m_localizationInstallPath.c_str());

	// The m_helpInstallPath stores the path where the help files are installed on
	// the given platform.
	// On wxMSW:   "C:\Program Files\Adapt It WX\ or
	//             C:\Program Files\Adapt It WX Unicode\"
	// On wxGTK:   "/usr/share/adaptit/help/" or "/usr/local/share/adaptit/help/"
	//             depending on the value of m_PathPrefix.
	// On wxMac:   AdaptIt.app/Contents/SharedSupport   [bundle subdirectory]
	m_helpInstallPath = GetDefaultPathForHelpFiles();
	wxLogDebug(_T("The m_helpInstallPath = %s"),m_helpInstallPath.c_str());
	// Note: The m_htbHelpFileName is also determined in
	// GetDefaultPathForHelpFiles() call above

	// m_appUserConfigDir stores the path (only the path, not path and name) where the
	// wxFileConfig's (.)Adapt_It_WX(.ini) file is located beginning with version 6.0.0.
	// m_appUserConfigDir is set by calling wxStandardPaths::GetUserConfigDir().
	// On wxMSW: "C:\Users\Bill Martin\AppData\Roaming"
	// On wxGTK: "/home/wmartin"
	// On wxMac: "/Users/wmartin"
	m_appUserConfigDir =stdPaths.GetUserConfigDir();
	wxLogDebug(_T("The m_appUserConfigDir = %s"),m_appUserConfigDir.c_str());

	// m_appUserConfigDir stores the path and name of the wxFileConfig file's
	// on-disk configuration file. It is of the form: Adapt_It_WX.ini on Windows
	// and a .Adapt_It_WX hidden file on Linux and the Mac.
	// On Windows the Adapt_It_WX.ini file is first used with version 6.0.0 which
	// automatically transitions some settings previously stored in the Windows
	// registry into the external Adapt_It_WX.ini file.
	// m_appUserConfigDir is set by calling wxStandardPaths::GetUserConfigDir().
	// On wxMSW: "C:\Users\Bill Martin\AppData\Roaming\Adapt_It_WX.ini"
	// On wxGTK: "/home/wmartin/.Adapt_It_WX"
	// On wxMac: "/Users/wmartin/.Adapt_It_WX"
#ifdef __WXMSW__
	m_wxFileConfigPathAndName = m_appUserConfigDir + PathSeparator + _T("Adapt_It_WX.ini");
#else
	m_wxFileConfigPathAndName = m_appUserConfigDir + PathSeparator + _T(".Adapt_It_WX");
#endif
	wxLogDebug(_T("The m_wxFileConfigPathAndName = %s"),m_wxFileConfigPathAndName.c_str());


	// !!!!!!!!!!! SET UP SOME STANDARD PATHS ABOVE !!!!!!!!!!!!!!!!!!!!!!!!!!!


    // make a timesettings struct for autosaving feature & put some default values in it
    // (after first launch, values will come from the m_pConfig file settings instead)
	wxDateTime time;
	time = wxDateTime::Now();
	m_timeSettings.m_tLastDocSave = time;
	m_timeSettings.m_tLastKBSave = time;
	//wxTimeSpan tsDoc(0,0,10,0); // 0 days, 0 hours, 10 minutes, 0 seconds - MFC version
	//wxTimeSpan tsKB(0,0,15,0); // 0 days, 0 hours, 15 minutes, 0 seconds - MFC version
	// Note: wxWidgets' time span has different categories!! (we probably don't need to save
	// data files every 10 or 15 seconds!!). Note also: GetSeconds() and GetMinutes() also
	// work differently in the wxWidgets version!!
	wxTimeSpan tsDoc(0,10,0,0); // 0 hours, 10 minutes, 0 seconds, 0 milliseconds - wxWidgets
	wxTimeSpan tsKB(0,15,0,0); // 0 hours, 15 minutes, 0 seconds, 0 milliseconds - wxWidgets
	m_timeSettings.m_tsDoc = tsDoc;
	m_timeSettings.m_tsKB = tsKB;
	m_nMoves = 100; // initial default, save every 100 phrase box moves
	m_bIsDocTimeButton = TRUE; // initial default, save according to time interval, not moves

    // whm moved/changed 13Apr09 Command-line processing implemented in wx version and
    // moved earlier in OnInit() to this location after most variable initializations and
    // just before the application wxFileConfig processing. The command line processing must be
    // done before CMainFrame is created since the parameter -xo determines which toolbar
    // and commandbar is used in the main frame.
	// BEW 23Oct09 added frm 'force review mode' switch for no lookup when back translating
	// (intended for Bob Eaton, for shell opening of the application only, for a given doc)

	static const wxCmdLineEntryDesc cmdLineDesc[] =
	{
		{ wxCMD_LINE_SWITCH, _T("h"), _T("help"), _T("show this help message"),
			wxCMD_LINE_VAL_NONE, wxCMD_LINE_OPTION_HELP },
		//{ wxCMD_LINE_SWITCH, _T("v"), _T("version"), _T("Report application version number"),
		//	wxCMD_LINE_VAL_NONE, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_SWITCH, _T("frm"), _T("forcereviewmode"), _T("Force review mode ON"),
			wxCMD_LINE_VAL_NONE, wxCMD_LINE_PARAM_OPTIONAL  },
		// BEW 28Feb11, moved frm switch to above, it was before the  BEW 12Nov09 line previously
		{ wxCMD_LINE_SWITCH, _T("xo"), _T("olpc"), _T("Adjust GUI elements for OLPC XO Screen Resolution"),
			wxCMD_LINE_VAL_NONE, wxCMD_LINE_PARAM_OPTIONAL  },
		//{ wxCMD_LINE_SWITCH, _T("collab_on"), _T("collab_mode_on"), _T("Force collaboration mode ON"),
		//	wxCMD_LINE_VAL_NONE, wxCMD_LINE_PARAM_OPTIONAL  },
		//{ wxCMD_LINE_SWITCH, _T("collab_off"), _T("collab_mode_off"), _T("Force collaboration mode OFF"),
		//	wxCMD_LINE_VAL_NONE, wxCMD_LINE_PARAM_OPTIONAL  },
		//{ wxCMD_LINE_OPTION, _T("collab_proj"), _T("collab_project_names"), _T("Use these PT/BE projects \"Src Proj:Tgt Proj[:FreeTrans Proj]\""),
		//	wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		//{ wxCMD_LINE_OPTION, _T("ai_proj"), _T("ai_project_name"), _T("Use this AI project \"Lang A to Lang B adaptations\""),
		//	wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_OPTION, _T("wf"), _T("workfolder"), _T("Use alternate path for work folder"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_OPTION, _T("newdocs"), _T("newdocumentspath"), _T("Lock new documents path to this path"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_OPTION, _T("exports"), _T("exporteddocumentspath"), _T("Lock exported documents path to this path"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		// BEW 12Nov09, command line support requested by Steve McEvoy & John Hatton
		// for default adaptation export of adaptation text from a given doc file from
		// a given project folder is what the next 4 params are
		{ wxCMD_LINE_PARAM, _T("export"), _T("export_auto"), _T("export"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_PARAM, _T(""), _T(""), _T("\nproject name (must be in doublequotes)"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_PARAM, _T(""), _T(""), _T("\ndocument name (in doublequotes if spaces present)"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_PARAM, _T(""), _T(""), _T("\noutput folder path (in doublequotes if spaces present)"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },

		{ wxCMD_LINE_NONE }
	};

	// Note: In the MFC version, InitInstance() sets up CCommandLineInfo cmdInfo.
	// InitInstance() then calls ProcessShellCommand(cmdInfo) which has a switch
	// statement which switches on CCommandLineInfo::FileNew, and calls the app's
	// OnFileNew() to initiate the doc/view creation process at program startup.
	// Note: wxWidgets defines argc and argv as uninitialized public variables in App.h
	// header, so we don't need to define them here
	m_pParser = new wxCmdLineParser(cmdLineDesc, argc, argv);

	int itsokay = m_pParser->Parse(); // continue if it fails
	//if (m_pParser->Parse())
	// return false; // returns false if commandline help (-h or -help) is used or
				   // if there is an error parsing the commandline

	/*
	if (m_pParser->Found(_T("v")))
	{
        // command-line -v or -version option was specified, so report the version number
        // as standard output.
		wxString strVersionNumber;
		strVersionNumber.Empty();
		strVersionNumber << VERSION_MAJOR_PART;
		strVersionNumber += _T(".");
		strVersionNumber << VERSION_MINOR_PART;
		strVersionNumber += _T(".");
		strVersionNumber << VERSION_BUILD_PART;
        // whm Note: This version reporting switch need not be implemented unless there is
        // a specific need for it such as a script that needs to check the version of Adapt
        // It for use in some routine that is designed to verify that a certain version is
        // installed, such as Alistair Imrie's bootstrap routine (he however is checking
        // the version number by inspecting the first line in the Adapt It changes.txt
        // file).
        // TODO: In order to use wxLogStream the wxWidgets library must be compiled with
        // wxUSE_STD_IOSTREAM set to 1 (default is 0) in setup.h. This will be necessary to
        // actually output to the std::cout standard output.

		//wxLog *logger = new wxLogStream(&std::cout);
		//wxLog::SetActiveTarget(logger);
		//cout << strVersionNumber;
		return false;
	}
	*/

	int paramCount = m_pParser->GetParamCount();// this is relevant only to commands with params, like export

	if (itsokay == 0)
	{
		if (m_pParser->Found(_T("xo")))
		{
			m_bExecutingOnXO = TRUE;
		}

		// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
		/*
		if (m_pParser->Found(_T("collab_on")))
		{
			// The -collab_on command-line parameter forces collab mode ON (if a collab
			// project has been previously setup and would otherwise be OFF).
			// It does this by overriding the App's values for m_bCollaboratingWithParatext,
			// or m_bCollaboratingWithBibledit after first saving the value that gets stored
			// in those variables from the basic config file.
			// It is the stored/saved value is then written back to the basic config file
			// anytime the config file is saved during the current session, regardless of
			// the values for collaboration being used in the current session as a result
			// of the command-line switches.
			m_bForceCollabModeON = TRUE;
			// whm 15Apr11 Note: See the GetConfigurationFile() function where the value of
			// m_bForceCollabModeON when TRUE is used to force the value of
			// m_bCollaboratingWithParatext or m_bCollaboratingWithBibledit to TRUE.
		}

		if (m_pParser->Found(_T("collab_off")))
		{
			// The -collab_off command-line parameter forces collab mode OFF (if a collab
			// project has been previously setup and would otherwise be ON).
			// It does this by overriding the App's values for m_bCollaboratingWithParatext,
			// or m_bCollaboratingWithBibledit after first saving the value that gets stored
			// in those variables from the basic config file.
			// It is the stored/saved value is then written back to the basic config file
			// anytime the config file is saved during the current session, regardless of
			// the values for collaboration being used in the current session as a result
			// of the command-line switches.
			m_bForceCollabModeOFF = TRUE;
			// whm 15Apr11 Note: See the GetConfigurationFile() function where the value of
			// m_bForceCollabModeOFF when TRUE is used to force the value of
			// m_bCollaboratingWithParatext or m_bCollaboratingWithBibledit to FALSE.
		}

		wxString collabProjNames;
		if (m_pParser->Found(_T("collab_proj"), &collabProjNames))
		{
			// The -collab_proj command-line parameter represents the Paratext or Bibledit project
			// names to be used in collaboration work with Adapt It. The string following the
			// -collab_proj is to be enclosed in double quotes and its two or three parts
			// delimited by ':' characters in the form:
			// -collab_proj "Source Proj:Target Proj[:FreeTrans Proj]"
			// in which the designation of a FreeTrans Proj is optional.
			// The Paratext/Bibledit projects that are to be used during collaboration
			// are delimited within the quoted string following the -collab_proj switch. These
			// projects will only be used if they already exist as Paratext/Bibledit projects
			// on the local machine, and if collaboration is turned ON (either by administrator
			// setting or by use of the additional -collab_on command-line swtich).
			m_ForceCollabProjectNames = collabProjNames;
			// whm 15Apr11 Note: See the GetConfigurationFile() function where a non-empty
			// value of m_ForceCollabProjectNames is used to force the value of
			// m_CollabProjectForSourceInputs, m_CollabProjectForTargetExports,
			// m_CollabProjectForFreeTransExports and m_bCollaborationExpectsFreeTrans.
		}

		wxString aiProjName;
		if (m_pParser->Found(_T("ai_proj"), &aiProjName))
		{
			// The -ai_proj command-line parameter represents an AI project name in the form:
			// -ai_proj "Lang A to Lang B adaptations"
			// in which the Adapt It project name is specified within the quoted string following
			// the -ai_proj command-line switch. This AI project will be used as the local Adapt It
			// project folder and knowledge base file name when collaboration is turned ON, or if
			// collaboration is turned OFF, it will be the pre-selected project listed in the
			// Start Working wizard's "Select a project" page when Adapt It is started up.
			// This switch has an effect whether or not the collab_off or collab_on switches are
			// also used at the command-line.
			m_ForceCollabAIProjectName = aiProjName;
			// whm 15Apr11 Note: See the GetConfigurationFile() function where a non-empty
			// value of m_ForceCollabAIProjectName is used to force the value of
			// m_CollabAIProjectName (after verifiying that it is a valid AI project name).
		}
		*/

		wxString wfPathStr;
		if (m_pParser->Found(_T("wf"), &wfPathStr))
		{
			// The -wf command-line parameter represents a path that the user wants to become
			// the work folder path, so use it as the forced work folder path.
			m_wf_forced_workFolderPath = wfPathStr;
		}

		wxString newdocPathStr;
		if (m_pParser->Found(_T("newdocs"), &newdocPathStr))
		{
			// The -newdoc command-line parameter represents a path that the user wants to be
			// locked in as the only path for finding new documents to adapt, so use it as the
			// forced new documents path.
			m_newdoc_forced_newDocPath = newdocPathStr;
		}

		wxString exportPathStr;
		if (m_pParser->Found(_T("exports"), &exportPathStr))
		{
			// The -exports command-line parameter represents a path that the user wants to be
			// locked in as the folder path for saving all exports to, so use it as the
			// forced exports path.
			m_exports_forced_exportsPath = exportPathStr;
		}

		if (m_pParser->Found(_T("frm")))
		{
			// The -frm command-line parameter represents a choice to emasculate adaptation
			// mode by forcing ON the "reviewing" radio button (ie. m_bDrafting = FALSE) at
			// launch. It's intended for per-document launch via a shell script. Normal launches
			// using the Programs menu or desktop shortcuts, etc, should not use this switch
			// because it would turn off important functionality irrevokably on every launch
			m_bForce_Review_Mode = TRUE;
		}

		//m_bForce_Review_Mode = TRUE; // for debugging the frm switch, comment out for
									 // normal behaviours

		// if there were 4 params, it should be an auto-export attempt
		if (paramCount == 4)
		{
			// got a valid parse for the export command + params
			m_autoexport_command = m_pParser->GetParam(0);
			if (m_autoexport_command == _T("export"))
			{
				m_autoexport_projectname = m_pParser->GetParam(1);
				m_autoexport_projectname.Trim(FALSE); // remove whitespace from left
				m_autoexport_projectname.Trim(); // remove whitespace from right
				m_autoexport_docname = m_pParser->GetParam(2);
				m_autoexport_docname.Trim(FALSE); // remove whitespace from left
				m_autoexport_docname.Trim(); // remove whitespace from right
				m_autoexport_outputpath = m_pParser->GetParam(3);
				m_autoexport_outputpath.Trim(FALSE); // remove whitespace from left
				m_autoexport_outputpath.Trim(); // remove whitespace from right
				m_bAutoExport = TRUE;
			}
		}
	}

	// BEW 12Nov09, command line support requested by Steve McEvoy & John Hatton
	// for default adaptation export of adaptation text from a given doc file from
	// a given project folder
	/*
	static const wxCmdLineEntryDesc cmdLineDesc2[] =
	{
		{ wxCMD_LINE_SWITCH, _T("h"), _T("help"), _T("show this help message"),
			wxCMD_LINE_VAL_NONE, wxCMD_LINE_OPTION_HELP },
		{ wxCMD_LINE_PARAM, _T("export"), _T("export_auto"), _T("export"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_PARAM, _T(""), _T(""), _T("\nproject name (must be in doublequotes)"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_PARAM, _T(""), _T(""), _T("\ndocument name (in doublequotes if spaces present)"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_PARAM, _T(""), _T(""), _T("\noutput folder path (in doublequotes if spaces present)"),
			wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL  },
		{ wxCMD_LINE_NONE }
	};
	m_pParser2 = new wxCmdLineParser(cmdLineDesc2, argc, argv);

	// for testing, set up the following command line - comment out later for Release version
	//m_pParser2->SetCmdLine(_T("export \42 XX to YY adaptations\42 \42 Ruth.xml\42 \42C:\\Card1\42"));

	int allswell = m_pParser2->Parse(); // allow continued processing if parse failed

	// Note: returning here creates memory leaks, but it is not too serious since the
	// program is terminating anyway.

	int paramCount2 = m_pParser2->GetParamCount();
	if (allswell == 0 && paramCount2 == 4)
	{
		// got a valid parse for the export command + params
		m_autoexport_command = m_pParser2->GetParam(0);
		if (m_autoexport_command == _T("export"))
		{
			m_autoexport_projectname = m_pParser2->GetParam(1);
			m_autoexport_projectname.Trim(FALSE); // remove whitespace from left
			m_autoexport_projectname.Trim(); // remove whitespace from right
			m_autoexport_docname = m_pParser2->GetParam(2);
			m_autoexport_docname.Trim(FALSE); // remove whitespace from left
			m_autoexport_docname.Trim(); // remove whitespace from right
			m_autoexport_outputpath = m_pParser2->GetParam(3);
			m_autoexport_outputpath.Trim(FALSE); // remove whitespace from left
			m_autoexport_outputpath.Trim(); // remove whitespace from right
			m_bAutoExport = TRUE;
		}
		else
		{
			wxMessageBox(_("Command line, export command misspelled; parse failed"));
			m_bAutoExport = FALSE;
		}
	}
	else if (allswell > 0)
	{
		wxMessageBox(_("Command line, export command, parse error"));
		m_bAutoExport = FALSE;
	}
	*/

	// whm 2Nov10 design notes for use of wxConfig and wxFileConfig in version 6.0.0:
	// The application should make as little use as possible of the Windows registry.
	// As of version 6.0.0, the information saved previously in the Windows registry
	// will be stored instead in an Adapt_It_WX.ini file, similar to what has been
	// the case for the Linux and Mac ports previous to version 6.0.0. For users who
	// previously used a version prior to 6.0.0, we automatically and quitely
	// transition any registry information previously stored in the Adapt_It_WX
	// registry key to the Adapt_It_WX.ini on-disk file format and, once done, remove
	// the old registry key, so that the transition to using the file-on-disk format
	// needs to happen only once.
	TransitionWindowsRegistryEntriesTowxFileConfig();

	// Change the registry key to something appropriate
	// MFC used: SetRegistryKey(_T("SIL-PNG Applications"));
	// Previous to version 6.0.0 we used a wxConfig class object below to stored
	// some settings in the Registry under a Adapt_It_WX key on Windows, and in an
	// external hidden file called .Adapt_It_WX on Linux and the Mac. Starting with
	// version 6.0.0, however, all platforms now use wxFileConfig and store certain
	// settings in an external file. The TransitionWindowsRegistryEntriesTowxFileConfig()
	// call above transitions the host OS to use the external file rather than the
	// Windows registry (if settings were stored under the Adapt_It_WX key), on
	// first run of the version 6.0.0 of the program.
	m_pConfig = new wxFileConfig(wxEmptyString,wxEmptyString,m_wxFileConfigPathAndName,wxEmptyString); // must delete m_pConfig in OnExit()
	wxASSERT(m_pConfig != NULL);
	// Note: We'll use "Adapt_It_WX" to distinguish the wxWidgets version from MFC version

	// Retrieve the m_bUseToolTips setting from m_pConfig if it exists.
	{
	// begin a local block to restrict scope of wxLogNull logNo
	wxString oldPath = m_pConfig->GetPath(); // is always absolute path "/Recent_File_List"
	m_pConfig->SetPath(_T("/Settings"));
	wxLogNull logNo; // eliminates spurious message from the system: "Can't read value
		// of key 'HKCU\Software\Adapt_It_WX\Settings' Error" [valid until end of this block]
	m_pConfig->Read(_T("use_tooltips"), &m_bUseToolTips);
	// restore the oldPath back to "/Recent_File_List"
	m_pConfig->SetPath(oldPath);
	// end of local block for wxLogNull logNo
	}

	// Retrieve the m_nTooltipDelay time from m_pConfig if is exists
	{
	// begin a local block to restrict scope of wxLogNull logNo
	// Here the oldPath will be set to "\" or something like that, but normally will be set
	// to path "/Recent_File_List" (see farther below).
	wxString oldPath = m_pConfig->GetPath();
	m_pConfig->SetPath(_T("/Settings"));
	wxLogNull logNo; // eliminates spurious message from the system: "Can't read value
		// of key 'HKCU\Software\Adapt_It_WX\Settings' Error" [valid until end of this block]
	m_pConfig->Read(_T("time_tooltips_displayed_ms"), &m_nTooltipDelay);
    // TODO: Uncomment line below when figure out why it seems to disable tooltip function
    // in most of the interface
	//wxToolTip::SetDelay(m_nTooltipDelay);
	// restore the oldPath back to "/Recent_File_List"
	m_pConfig->SetPath(oldPath);
	// end of local block for wxLogNull logNo
	}

	// whm added 29Feb12. Remove any collaboration-related settings from the wxFileConfig
	// Adapt_It_WX.ini file. The collaboration settings are now project-specific and since
	// the user has free control over whether collaboration is turned ON or OFF for a
	// given AI project, I don't see any need to save them in the Adapt_It_WX.ini file.
	// This function call must follow the creation of the m_pConfig object above.
	// Normally this function would only make changes in Adapt_It_WX.ini when version
	// 6.2.0 if first run on a system after having had AI version 6.0.x or 6.1.x installed
	// and used.
	RemoveCollabSettingsFromFailSafeStorageFile();

	m_bConfigFileHasFontEncodingInfo = FALSE;	// normally false for config files written by
												// the MFC version; set to true for those
												// written by the wx version

	// Get system locale and encoding info:
	m_systemEncoding = wxLocale::GetSystemEncoding();		// Windows: m_systemEncoding = wxFONTENCODING_CP1252
															//  Ubuntu: m_systemEncoding = wxFONTENCODING_UTF8
															//     Mac: m_systemEncoding = wxFONTENCODING_MACROMAN
	m_systemEncodingName = wxLocale::GetSystemEncodingName();	// Windows: m_systemEncodingName = "windows-1252"
																//  Ubuntu: m_systemEncodingName = "UTF-8"
																//     Mac: m_systemEncodingName = ???
#ifdef __WXMAC__
	switch (m_systemEncoding)
	{
	    case wxFONTENCODING_MACROMAN: m_systemEncodingName = _T("MacRoman"); break; //47-77  the standard mac encodings [47-86]
		case wxFONTENCODING_MACJAPANESE: m_systemEncodingName = _T("MacJapanese"); break; //48
	    case wxFONTENCODING_MACCHINESETRAD: m_systemEncodingName = _T("MacChineseTrad"); break; //49
		case wxFONTENCODING_MACKOREAN: m_systemEncodingName = _T("MacKorean"); break; //50
		case wxFONTENCODING_MACARABIC: m_systemEncodingName = _T("MacArabic"); break; //51
		case wxFONTENCODING_MACHEBREW: m_systemEncodingName = _T("MacHebrew"); break; //52
		case wxFONTENCODING_MACGREEK: m_systemEncodingName = _T("MacGreek"); break; //53
		case wxFONTENCODING_MACCYRILLIC: m_systemEncodingName = _T("MacCyrillic"); break; //54
		case wxFONTENCODING_MACDEVANAGARI: m_systemEncodingName = _T("MacDevanagari"); break; //55
		case wxFONTENCODING_MACGURMUKHI: m_systemEncodingName = _T("MacGurmukhi"); break; //56
		case wxFONTENCODING_MACGUJARATI: m_systemEncodingName = _T("MacGujarati"); break; //57
		case wxFONTENCODING_MACORIYA: m_systemEncodingName = _T("MacOriya"); break; //58
		case wxFONTENCODING_MACBENGALI: m_systemEncodingName = _T("MacBengali"); break; //59
		case wxFONTENCODING_MACTAMIL: m_systemEncodingName = _T("MacTamil"); break; //60
		case wxFONTENCODING_MACTELUGU: m_systemEncodingName = _T("MacTelugu"); break; //61
		case wxFONTENCODING_MACKANNADA: m_systemEncodingName = _T("MacKannada"); break; //62
		case wxFONTENCODING_MACMALAJALAM: m_systemEncodingName = _T("MacMalajalam"); break; //63
		case wxFONTENCODING_MACSINHALESE: m_systemEncodingName = _T("MacSinhalese"); break; //64
		case wxFONTENCODING_MACBURMESE: m_systemEncodingName = _T("MacBurmese"); break; //65
		case wxFONTENCODING_MACKHMER: m_systemEncodingName = _T("MacKhmer"); break; //66
		case wxFONTENCODING_MACTHAI: m_systemEncodingName = _T("MacThai"); break; //67
		case wxFONTENCODING_MACLAOTIAN: m_systemEncodingName = _T("MacLaotian"); break; //68
		case wxFONTENCODING_MACGEORGIAN: m_systemEncodingName = _T("MacGeorgian"); break; //69
		case wxFONTENCODING_MACARMENIAN: m_systemEncodingName = _T("MacArmenian"); break; //70
		case wxFONTENCODING_MACCHINESESIMP: m_systemEncodingName = _T("MacChineseSimp"); break; //71
		case wxFONTENCODING_MACTIBETAN: m_systemEncodingName = _T("MacTibetan"); break; //72
		case wxFONTENCODING_MACMONGOLIAN: m_systemEncodingName = _T("MacMongolian"); break; //73
		case wxFONTENCODING_MACETHIOPIC: m_systemEncodingName = _T("MacEthiopic"); break; //74
		case wxFONTENCODING_MACCENTRALEUR: m_systemEncodingName = _T("MacCentralEur"); break; //75
		case wxFONTENCODING_MACVIATNAMESE: m_systemEncodingName = _T("MacViatnamese"); break; //76
		case wxFONTENCODING_MACARABICEXT: m_systemEncodingName = _T("MacArabicExt"); break; //77
		case wxFONTENCODING_MACSYMBOL: m_systemEncodingName = _T("MacSymbol"); break; //78
		case wxFONTENCODING_MACDINGBATS: m_systemEncodingName = _T("MacDingbats"); break; //79
		case wxFONTENCODING_MACTURKISH: m_systemEncodingName = _T("MacTurkish"); break; //80
		case wxFONTENCODING_MACCROATIAN: m_systemEncodingName = _T("MacCroatian"); break; //81
		case wxFONTENCODING_MACICELANDIC: m_systemEncodingName = _T("MacIcelandic"); break; //82
		case wxFONTENCODING_MACROMANIAN: m_systemEncodingName = _T("MacRomanian"); break; //83
		case wxFONTENCODING_MACCELTIC: m_systemEncodingName = _T("MacCeltic"); break; //84
		case wxFONTENCODING_MACGAELIC: m_systemEncodingName = _T("MacGaelic"); break; //85
		case wxFONTENCODING_MACKEYBOARD: m_systemEncodingName = _T("MacKeyboard"); break; //86
	default: m_systemEncodingName = _T("MACROMAN");
	}
#endif
	wxLogDebug(_T("m_systemEncodingName = %s wxFONTENCODING enum value = %d"),m_systemEncodingName.c_str(),(int)m_systemEncoding);

	m_systemLanguage = wxLocale::GetSystemLanguage();	// Windows: m_systemLanguage = 58
														//  Ubuntu: m_systemLanguage = 58
														//     Mac: m_systemLanguage = 58
	m_languageInfo = wxLocale::GetLanguageInfo(m_systemLanguage);
	// if GetStytemLanguage() can't determine the system language it returns wxLANGUAGE_UNKNOWN
	// for m_systemLanguage, and GetLanguageInfo(m_systemLanguage) will return NULL for
	// m_languageInfo.
	if (m_languageInfo != NULL)
	{
		wxLogDebug(_T("m_systemLanguage = %d"),m_systemLanguage); // 58
		wxLogDebug(_T("m_languageInfo->Description = %s"),m_languageInfo->Description.c_str()); // "English (U.S.)"
		wxLogDebug(_T("m_languageInfo->CanonicalName = %s"),m_languageInfo->CanonicalName.c_str()); // "en_US"
		wxLogDebug(_T("m_languageInfo->Language = %d"),m_languageInfo->Language); // 58 (both Windows and Ubuntu)
#ifdef __WIN32__
		wxLogDebug(_T("m_languageInfo->WinLang = %d"),m_languageInfo->WinLang); // Windows: 9
		wxLogDebug(_T("m_languageInfo->WinSublang = %d"),m_languageInfo->WinSublang); // Windows: 1
#endif
		wxLogDebug(_T("m_languageInfo->LayoutDirection = %d"),m_languageInfo->LayoutDirection); //wxLayout_LeftToRight (both)
	}
	else
	{
		wxLogDebug(_T("m_systemLanguage = %d (wxLANGUAGE_UNKNOWN)"),m_systemLanguage); // 58
		wxLogDebug(_T("m_languageInfo = NULL"));
	}

	wxASSERT(!m_appInstallPathOnly.IsEmpty()); //wxASSERT(!m_setupFolder.IsEmpty());

	// At this point - just before loading any non-English localization catalog, we
	// populate the m_mapMenuLabelStrToIdint with the English menu label items and
	// their menu id int associations. This shouldn't strictly be needed, but is a
	// precaution in case something goes awry with the localization - there will be
	// English defaults for menu item labels in the mapping.
	SetupUnTranslatedMapMenuLabelStrToIdInt(m_mapMenuLabelStrToIdInt);

    // NOTE: We determine Adapt It's user interface language here early in OnInit() before
    // the main frame and other visible parts of the interface are shown to the user. If
    // the user changes the interface language choice at this early point in the running
    // application, the app won't have to be restarted to fully exhibit the localized
    // interface.
	//
    // Get any interface language data stored in the m_pConfig (registry/hidden settings
    // file); ProcessUILanguageInfoFromConfig adds any previously stored user defined
    // languages to the current locale, and returns the current localization info in
    // currLocalizationInfo.
	// BEW added 4Dec09, so that a locale-related message doesn't come up when the
	// m_bAutoExport flag is TRUE (for use of the app with SendIt.exe, by John Hatton)
	if (!m_bAutoExport)
	{
		currLocalizationInfo = ProcessUILanguageInfoFromConfig(); // this needs to come after
												// the m_languageInfo is defined above

		// On first run of Adapt It (when no previous interface language choice has been made),
		// or if the user holds down the ALT key while running the application, the following
		// ChooseInterfaceLanguage() call will check to see if localizations other than the
		// default system language are present on the user's computer. If so,
		// ChooseInterfaceLanguage() will present the user with a "Select your preferred
		// language for Adapt It's menus and other messages" dialog in which an alternative
		// interface language choice can be made. For first run of Adapt It, the default choice
		// is "Use default language" (wxLANGUAGE_DEFAULT).
		// The only choices available in the dialog are languages for which actual localization
		// subfolders exist in the localization path and contain an <appName>.mo localization
		// file.
		// Once the user makes the choice the interface is set to use that language.
		// After the first run of Adapt It, the user's choice of UI language is saved in the
		// wxConfig's Adapt_It_WX.ini (Windows) or .Adapt_It_WX (Linux and Mac), and the user
		// won't be asked again at program startup - but the user can later change the interface
		// language choice from within the app via View | "Choose Interface Language...".
		// Note: currLocalizationInfo.curr_UI_Language is initialized to wxLANGUAGE_UNKNOWN by
		// OnInit(), but may be changed by ProcessUILanguageInfoFromConfig() call made above
		// if it has been previously determined.

		if (currLocalizationInfo.curr_UI_Language == wxLANGUAGE_UNKNOWN || wxGetKeyState(WXK_ALT))
		{
			// can disregard return bool value of ChooseInterfaceLanguage() here
			ChooseInterfaceLanguage(firstRun);	// calls CChooseLanguageDlg and insures that
				// currLocalizationInfo's curr_UI_Language is something other than wxLANGUAGE_UNKNOWN
		}

		// for testing below:
		//wxString pathToLocaleSubDir;
		//pathToLocaleSubDir = GetDefaultPathForLocalizationSubDirectories();

		// InitializeLanguageLocale() below deletes any exising wxLocale object and creates a
		// new wxLocale for the currently selected language (using the non-default wxLocale
		// constructor).
		// The currLocalizationInfo struct was initialized with the interface language of
		// choice above, so now we can create the wxLocale object

		// whm 8Dec11 modified below to use the App's m_localizationInstallPath
		//if (!InitializeLanguageLocale(currLocalizationInfo.curr_shortName,
		//	currLocalizationInfo.curr_fullName, currLocalizationInfo.curr_localizationPath))
		if (!InitializeLanguageLocale(currLocalizationInfo.curr_shortName,
			currLocalizationInfo.curr_fullName, m_localizationInstallPath))
		{
			// Loading of localization catalog failed. This means that either
			// m_pLocale->AddCatalog(GetAppName()) or m_pLocale->IsLoaded(GetAppName()) failed
			// in InitializeLanguageLocale(). Notify user of the problem.
			wxString msg;
			// We use the _T() macro below since localized translations of these messages would
			// never be shown anyway (the localization failed to load).
			msg = msg.Format(_T(
"Adapt It failed to initialize and load the localization for the %s language at the following path:\n%s\nYou may need to re-install the localization files or tell Adapt It where they are located by selecting the \"Change Interface Language..\" item on the View menu."),
			currLocalizationInfo.curr_fullName.c_str(),
			currLocalizationInfo.curr_localizationPath.c_str());
			wxMessageBox(msg,_T("Previous localization file not found"),wxICON_WARNING);
		}
	}
	wxString EncodingName = wxFontMapper::Get()->GetEncodingName(m_systemEncoding);
												// Windows: EncodingName = "windows-1252"
												//  Ubuntu: EncodingName = "UTF-8"
	wxFontEncoding fontenc = wxFontMapper::Get()->GetEncodingFromName(EncodingName);
												// Windows: fontenc = wxFONTENCODING_CP1252
												//  Ubuntu: fontenc = wxFONTENCODING_UTF8
	//static const wxChar** encNames = wxFontMapper::Get()->GetAllEncodingNames(fontenc);
	bool fontAvail;
	fontAvail = wxFontMapper::Get()->IsEncodingAvailable(fontenc);
												// Windows: fontAvail = true
												//  Ubuntu: fontAvail = true
	wxCHECK_MSG(fontAvail, FALSE, _T("OnInit() wxFontMapper returned FALSE (no font available) line 14500"));
	//wxFontEncoding altFontEnc;
	//wxString facename = _T("");
	//bool gotAltFont;
	//gotAltFont = wxFontMapper::Get()->GetAltForEncoding(fontenc, &altFontEnc, facename, false);
												// Windows: gotAltFont = true
												// Windows: altFontEnc = wxFONTENCODING_ISO8859_1
												//  Ubuntu: gotAltFont = false
												//  Ubuntu: (none)

    m_pDocManager = new wxDocManager; // must delete m_pDocManager in OnExit()
	wxASSERT(m_pDocManager != NULL);

	//LoadStdProfileSettings(9);  // Load standard INI file options (including MRU) - MFC version
	// Set things up for file history (MRU) list
	// File History is loaded below after Main Menu is created
	wxString strOldPath = m_pConfig->GetPath();// store old wxFileConfig path in case we need it
    // whm Note: Recently used files (MRU) that get recorded in the settings file are not
    // really compatible between Unicode and Ansi versions. It may well be the case that
    // the user switches between the Unicode and Ansi versions. In that case we don't want
    // there to be a mix of files in the MRU, some using Unicode and some Ansi. Therefore
    // I'm setting a different settings file group for Unicode. In either case the path
    // that is set for m_pConfig will be one or the other as default so that wxFileHistory
    // will use it appropriately.
#ifdef _UNICODE
	m_pConfig->SetPath(_T("/Recent_File_List_Unicode"));// set wxFileConfig path in external settings file
#else
	m_pConfig->SetPath(_T("/Recent_File_List"));// set wxFileConfig path in external settings file
#endif
    // wx note: In SetPath above we should use the _T() macro rather than _() so the config
    // string stays the same regardless of interface language chosen. Also, since the
    // "Recent_File_List" key is probably the most commonly used, we'll always leave the
    // "Path" for wxFileConfig::SetPath(Path) set as _T("/Recent_File_List"). Whenever we
    // change a setting other than an item under Recent_File_List, we'll save the oldPath
    // and restore it after doing the other setting.

	// Create doc template to manage doc/view framework.
	// Since wxWidgets data files probably won't be compatible with those produced
	// by MFC, we'll initially use .adx instead of .adt for wxWidgets AI documents
    wxDocTemplate* pDocTemplate;

	pDocTemplate = new wxDocTemplate(m_pDocManager, m_FrameAndDocProgramTitle,
					_T(".xml"), _T(""), _T("xml"), // previously ".adx" and "adx"
                    _T("Adapt It Document"), _T("Adapt It View"),
                    CLASSINFO(CAdapt_ItDoc),
                    CLASSINFO(CAdapt_ItView));
	// pDocTemplate above will be destroyed when m_pDocManager is deleted in OnExit()
	wxCHECK_MSG(pDocTemplate != NULL, FALSE, _T("OnInit() new wxDocTemplate returned NULL ptr, line 14544"));
    // Note: We could have another wxDocTemplate instance for plain text documents if we
    // wanted them to be managed by the doc/view framework.

	// The following are for HTML Help
    m_pHelpController = new wxHtmlHelpController(wxHF_DEFAULT_STYLE | wxHF_OPEN_FILES);
	wxHelpControllerHelpProvider* provider = new wxHelpControllerHelpProvider;
	wxHelpProvider::Set(provider);

	// Get/Set Help info (window size etc) in the config object.
    // Help window settings are saved in the registry/.Settings folder that stays the
    // default and is called "Recent_File_List". There are 10 settings in that folder plus
    // UseConfig() creates a subfolder within "Recent_File_List" called "wxHtmlWindow"
    // which contains another 10 help font settings.
	m_pHelpController->UseConfig(m_pConfig);

	// Required for images in the online documentation
    wxInitAllImageHandlers(); // the help sample program does this, although it is not
							  // documented anywhere in wxWidgets!
    // Note: There are also individual handlers, i.e., wxImage::AddHandler(new
    // wxGIFHandler), wxFileSystem::AddHandler(new wxZipFSHandler), etc., but ones used
    // here are what the help sample uses.

    // Note: The docs for wxHelpController say, "Note that if you use .zip or .htb formats
    // for your books, you must add this line to your application initialization:
    // wxFileSystem::AddHandler(new wxArchiveFSHandler); or nothing will be shown in your
    // help window."
	wxFileSystem::AddHandler(new wxArchiveFSHandler); // docs say to use this one


	// whm note: The new CMainFrame call below creates AI's top level Main Frame window.
	// It also calls m_pMenuBar = AIMenuBarFunc() to create the menuBar and calls
	// SetMenuBar(m_pMenuBar) to associate the menuBar with the Main Frame. All the
	// other panels and bars (tool bar, mode bar, compose bar, status bar, etc.) are
	// also created within the CMainFrame's constructor.

    m_pMainFrame = new CMainFrame(m_pDocManager, (wxFrame*) NULL, -1, m_FrameAndDocProgramTitle,
                                wxPoint(0, 0), wxSize(735, 500),
                                wxDEFAULT_FRAME_STYLE
								| wxFRAME_NO_WINDOW_MENU);	// wxFRAME_NO_WINDOW_MENU removes
															// the 'Window' menu from the
															// main frame that doc/view normally
															// places there. It is also removed
															// from any child view windows.
	// m_pMainFrame above will be destroyed when m_pDocManager is deleted in OnExit()
	wxASSERT(m_pMainFrame != NULL);

	// Notes: about Menu differences on the Mac:
    // 1. On the Mac, the "About" menu item should go in a particular place (in the Apple
    // menu on Mac OS 8/9, or in the program menu on Mac OS X). wxMac will automatically
    // move it to the proper menu the help menu's "About" identifier is wxID_ABOUT (I
    // changed it from MFC's ID_APP_ABOUT to wxID_ABOUT), to automatically make the menu
    // adjustments for the Mac.
    // 2. On the Mac, the "Preferences" menu also goes in a particular place (in the
    // AdaptIt menu to the left of the File menu). Preferences is moved there automatically
    // if the standard wxID_PREFERENCES is used, so I changed the MFC identifier
    // ID_EDIT_PREFERENCES to wxID_PREFERENCES.
    // 3. On the Mac, the "Help" menu is handled specially too according to Mac custom when
    // the Help menu identifier the menu uses is wxID_HELP; this one was already set
    // correctly.
    // 4. Keyboard shortcuts for menu items on the Mac are also automatically changed from
    // "CTRL" on the menu to use the clover leaf shaped Command key symbol plus the
    // appropriate key.


    // Give the main frame a 16x16 pixel icon (frame icons and task bar icons use 16x16
    // icons) This xpm format should work for all platforms. It embeds the icon resource
    // inside the executable file, so no need to have to hunt for it from an external
    // resource file.
	//	/* XPM */
	//	static const char * xpm_data16x16[] = {
	//	"16 16 10 1",
	//	" 	c None",
	//	"!	c #FFFF00",
	//	"#	c black",
	//	"$	c #FF0000",
	//	"%	c #808000",
	//	"&	c #808080",
	//	"'	c #00FFFF",
	//	"(	c #00FF00",
	//	")	c #000080",
	//	"*	c #C0C0C0",
	//	"!!!!!!!!!!!!!!!!",
	//	"!##!!!!!!!!!!!!!",
	//	"#$!#!!!!!!!!!!!!",
	//	"#$!#!!!!!!!!!!!!",
	//	"####!!%%%%%!!!!!",
	//	"#$!#!%#####&!!!!",
	//	"#$!#!%#'('#%!!!!",
	//	"#$!#!%#'''#%!!!!",
	//	"!!!!!%#(((#%!!!!",
	//	"!!&!!%#####%!!!!",
	//	"!!&)!%*****%!###",
	//	")))))%**))%%!!#!",
	//	"!!&)!%*****%!!#!",
	//	"!!&!!%%%%%%%!!#!",
	//	"!!!!!%%!!!%%!!#!",
	//	"!!!!!!!!!!!!!###"};

	// whm 10Aug10 replaced old 16x16 AI frame icon with new icons (blue theme) below:
	// To evaluate four different frame icon choices:
	//    Define only one of the four choices below to select it for use as 16x16 frame icon.
	//    Comment out the other three choices.
	//#define IconBlueShadesOn16x16WhiteRectangularBackground
	#define IconBlueShadesOn16x16WhiteDiskBackground
	//#define IconBlueShadesOn16x16AllTransparentBackground
	//#define IconWhiteBlueOn16x16BlueDiskBackground

	// To evaluate four different taskbar icon choices:
	//    Define only one of the four choices to select it for use as 32x32 taskbar icon.
	//    Comment out the other three choices.
	//#define IconBlueShadesOn32x32WhiteRectangularBackground
	#define IconBlueShadesOn32x32WhiteDiskBackground
	//#define IconBlueShadesOn32x32AllTransparentBackground
	//#define IconWhiteBlueOn32x32BlueDiskBackground

#if defined(IconBlueShadesOn16x16WhiteRectangularBackground)
	/* XPM */
	// The following xpm icon contains the 16x16 blue shades ai logo on a white rectangular background.
	static const char * AI_16_xpm[] = {
	"16 16 176 2",
	"  	c #0E76BC",
	". 	c #FEFEFF",
	"+ 	c #18A5DF",
	"@ 	c #1BA6E0",
	"# 	c #52BBE7",
	"$ 	c #76CAEC",
	"% 	c #006DB8",
	"& 	c #006EB8",
	"* 	c #FEFFFF",
	"= 	c #0D76BC",
	"- 	c #50BAE7",
	"; 	c #4B98CD",
	"> 	c #006CB8",
	", 	c #0A74BB",
	"' 	c #0C75BC",
	") 	c #55BDE8",
	"! 	c #006BB7",
	"~ 	c #5AA1D1",
	"{ 	c #74C9EC",
	"] 	c #B1D2E9",
	"^ 	c #15A4DF",
	"/ 	c #23A9E1",
	"( 	c #22A9E1",
	"_ 	c #F5F9FC",
	": 	c #016EB8",
	"< 	c #19A5E0",
	"[ 	c #79CBED",
	"} 	c #006CB7",
	"| 	c #0470B9",
	"1 	c #1CA6E0",
	"2 	c #006DB7",
	"3 	c #197CBF",
	"4 	c #19A5DF",
	"5 	c #69C5EB",
	"6 	c #14A3DF",
	"7 	c #0973BB",
	"8 	c #29ACE2",
	"9 	c #F7FBFD",
	"0 	c #F6FAFD",
	"a 	c #23AAE1",
	"b 	c #CBEBF8",
	"c 	c #FAFDFE",
	"d 	c #8DBDDF",
	"e 	c #ACCFE8",
	"f 	c #197DBF",
	"g 	c #58A0D1",
	"h 	c #0671BA",
	"i 	c #C4DEEF",
	"j 	c #57A0D1",
	"k 	c #0EA1DE",
	"l 	c #0065B4",
	"m 	c #62C2EA",
	"n 	c #DAF0FA",
	"o 	c #6FC7EB",
	"p 	c #0C74BB",
	"q 	c #71AFD8",
	"r 	c #A1DAF2",
	"s 	c #0069B6",
	"t 	c #75B0D8",
	"u 	c #77B1D9",
	"v 	c #0571B9",
	"w 	c #016FB8",
	"x 	c #D3E6F3",
	"y 	c #0069B5",
	"z 	c #FDFEFF",
	"A 	c #F5FAFD",
	"B 	c #0F76BC",
	"C 	c #1FA8E1",
	"D 	c #2C87C5",
	"E 	c #1E7FC0",
	"F 	c #267FC0",
	"G 	c #0F77BC",
	"H 	c #519BCE",
	"I 	c #539ECF",
	"J 	c #F9FCFD",
	"K 	c #ECF8FC",
	"L 	c #D7F0FA",
	"M 	c #E7F1F8",
	"N 	c #60C1E9",
	"O 	c #77CBED",
	"P 	c #C1DBED",
	"Q 	c #4C99CD",
	"R 	c #9CC6E3",
	"S 	c #90C0E0",
	"T 	c #BED9EC",
	"U 	c #78B2DA",
	"V 	c #006EB7",
	"W 	c #51BBE7",
	"X 	c #026FB8",
	"Y 	c #16A5DF",
	"Z 	c #2181C1",
	"` 	c #83B9DD",
	" .	c #1CA7E0",
	"..	c #83B8DD",
	"+.	c #18A5E0",
	"@.	c #006BB6",
	"#.	c #1479BE",
	"$.	c #DFEDF6",
	"%.	c #A9CEE7",
	"&.	c #0571BA",
	"*.	c #559ED0",
	"=.	c #A7CDE6",
	"-.	c #D5EFFA",
	";.	c #0B74BB",
	">.	c #C8EAF8",
	",.	c #DCF1FB",
	"'.	c #8DBEDF",
	").	c #48B7E6",
	"!.	c #E8F2F8",
	"~.	c #4595CB",
	"{.	c #1379BD",
	"].	c #FBFCFE",
	"^.	c #0BA0DD",
	"/.	c #DEF2FB",
	"(.	c #348BC6",
	"_.	c #88D1EF",
	":.	c #77B2D9",
	"<.	c #0370B9",
	"[.	c #8BD2EF",
	"}.	c #D4E6F2",
	"|.	c #0B75BC",
	"1.	c #D9EAF5",
	"2.	c #D8E8F4",
	"3.	c #ECF5FA",
	"4.	c #77CAED",
	"5.	c #DAEAF4",
	"6.	c #9EC8E4",
	"7.	c #F9FCFE",
	"8.	c #7FB6DC",
	"9.	c #DCF2FA",
	"0.	c #75CAEC",
	"a.	c #B5D5EB",
	"b.	c #E9F2F9",
	"c.	c #4796CC",
	"d.	c #5DA3D2",
	"e.	c #DDEBF5",
	"f.	c #006AB6",
	"g.	c #2280C1",
	"h.	c #AACFE7",
	"i.	c #B0D2E9",
	"j.	c #1479BD",
	"k.	c #157ABE",
	"l.	c #539DCF",
	"m.	c #0872BA",
	"n.	c #B2D3EA",
	"o.	c #49B8E6",
	"p.	c #3089C6",
	"q.	c #D5E7F3",
	"r.	c #ABCFE8",
	"s.	c #549ECF",
	"t.	c #5EA1D1",
	"u.	c #85B8DD",
	"v.	c #79CBEC",
	"w.	c #7BB4DA",
	"x.	c #C5DEEF",
	"y.	c #036FB9",
	"z.	c #C9EAF8",
	"A.	c #A6CCE6",
	"B.	c #C4E8F7",
	"C.	c #3C90C9",
	"D.	c #DFF3FA",
	"E.	c #16A4DF",
	"F.	c #4B97CC",
	"G.	c #DFF2FB",
	"H.	c #B7D6EB",
	"I.	c #EAF3F9",
	"J.	c #78CBED",
	"K.	c #3E91C9",
	"L.	c #64A5D3",
	"M.	c #E4F4FB",
	"N.	c #33B0E3",
	"O.	c #A1C9E5",
	"P.	c #D6EFF9",
	"Q.	c #207CBF",
	"R.	c #25AAE1",
	"S.	c #FFFFFF",
	"S.S.S.S.S.S.S.S.S.S.S.S.S.S.S.S.",
	"S.S.S.S.S.S.S.S.S.$ a < z S.S.S.",
	"S.S.S.S.S.S.S.S.S.{ ( +.. S.S.S.",
	"S.S.S.S.S.S.S.S.S.K n -.S.S.S.S.",
	"S.S.S.S.S.; % (.F.{ o.M.S.S.S.S.",
	"S.S.S.].f., 1.S.S.$ R.6 * S.S.S.",
	"S.S.S.6.=   p.S.S.$ R.@ . S.S.S.",
	"S.S.S.9 ! @.i S.S.$ R.@ . S.S.S.",
	"S.S.S.S.S.S.r.~.t.[ R.@ . S.S.S.",
	"S.S.S.S.Q & K.S.S.$ R.@ . S.S.S.",
	"S.S.S.C.B X S.S.S.$ R.@ . S.S.S.",
	"S.S.S.>   h 0 S.S.$ R.@ . S.S.S.",
	"S.S.S.%     f q.d [ R.@ . S.S.S.",
	"S.S.S.M m.& % g.J o 4 k . S.S.S.",
	"S.S.S.S.S.S.S.S.S.S.S.S.S.S.S.S.",
	"S.S.S.S.S.S.S.S.S.S.S.S.S.S.S.S."};

#elif defined(IconBlueShadesOn16x16WhiteDiskBackground)
	/* XPM */
	// The following xpm contains the 16x16 ai blue shades icon on a white disk.
	static const char * AI_16_xpm[] = {
	"16 16 58 1",
	" 	c None",
	".	c #FFFFFF",
	"+	c #76CAEC",
	"@	c #23AAE1",
	"#	c #19A5E0",
	"$	c #FDFEFF",
	"%	c #74C9EC",
	"&	c #22A9E1",
	"*	c #18A5E0",
	"=	c #FEFEFF",
	"-	c #ECF8FC",
	";	c #DAF0FA",
	">	c #D5EFFA",
	",	c #4B98CD",
	"'	c #006DB8",
	")	c #348BC6",
	"!	c #4B97CC",
	"~	c #49B8E6",
	"{	c #E4F4FB",
	"]	c #FBFCFE",
	"^	c #006AB6",
	"/	c #0A74BB",
	"(	c #D9EAF5",
	"_	c #25AAE1",
	":	c #14A3DF",
	"<	c #FEFFFF",
	"[	c #9EC8E4",
	"}	c #0D76BC",
	"|	c #0E76BC",
	"1	c #3089C6",
	"2	c #1BA6E0",
	"3	c #F7FBFD",
	"4	c #006BB7",
	"5	c #006BB6",
	"6	c #C4DEEF",
	"7	c #ABCFE8",
	"8	c #4595CB",
	"9	c #5EA1D1",
	"0	c #79CBED",
	"a	c #4C99CD",
	"b	c #006EB8",
	"c	c #3E91C9",
	"d	c #3C90C9",
	"e	c #0F76BC",
	"f	c #026FB8",
	"g	c #006CB8",
	"h	c #0671BA",
	"i	c #F6FAFD",
	"j	c #197DBF",
	"k	c #D5E7F3",
	"l	c #8DBDDF",
	"m	c #E7F1F8",
	"n	c #0872BA",
	"o	c #2280C1",
	"p	c #F9FCFD",
	"q	c #6FC7EB",
	"r	c #19A5DF",
	"s	c #0EA1DE",
	"   ..........   ",
	" ........+@#$.. ",
	" ........%&*=.. ",
	".........-;>....",
	".....,')!%~{....",
	"...]^/(..+_:<...",
	"...[}|1..+_2=...",
	"...3456..+_2=...",
	"......7890_2=...",
	"....abc..+_2=...",
	"...def...+_2=...",
	"...g|hi..+_2=...",
	"...'||jkl0_2=...",
	" ..mnb'opqrs=.. ",
	" .............. ",
	"   ..........   "};

#elif defined (IconBlueShadesOn16x16AllTransparentBackground)
	/* XPM */
	// The following xpm contains the 16x16 ai blue-shades icon on a transparent background.
	static const char * AI_16_xpm[] = {
	"16 16 39 1",
	" 	c None",
	".	c #75C9EB",
	"+	c #22A9E0",
	"@	c #18A4DF",
	"#	c #73C8EB",
	"$	c #21A8E0",
	"%	c #17A4DF",
	"&	c #4A97CC",
	"*	c #006CB7",
	"=	c #338AC5",
	"-	c #4A96CB",
	";	c #48B7E5",
	">	c #3B8FC8",
	",	c #0069B5",
	"'	c #0973BA",
	")	c #24A9E0",
	"!	c #13A2DE",
	"~	c #0C75BB",
	"{	c #0D75BB",
	"]	c #2F88C5",
	"^	c #1AA5DF",
	"/	c #006AB6",
	"(	c #006AB5",
	"_	c #4494CA",
	":	c #5DA0D0",
	"<	c #78CAEC",
	"[	c #4B98CC",
	"}	c #006DB7",
	"|	c #3D90C8",
	"1	c #0E75BB",
	"2	c #016EB7",
	"3	c #006BB7",
	"4	c #0570B9",
	"5	c #187CBE",
	"6	c #0771B9",
	"7	c #217FC0",
	"8	c #6EC6EA",
	"9	c #18A4DE",
	"0	c #0DA0DD",
	"                ",
	"         .+@    ",
	"         #$%    ",
	"                ",
	"     &*=-#;>    ",
	"    ,'>  .)!    ",
	"   >~{]  .)^    ",
	"    /(>  .)^    ",
	"      >_:<)^    ",
	"    [}|  .)^    ",
	"   >12   .)^    ",
	"   3{4   .)^    ",
	"   *{{5> <)^    ",
	"   >6}*7 890    ",
	"                ",
	"                "};

#else // IconWhiteBlueOn16x16BlueDiskBackground
	/* XPM */
	// The following xpm contains the 16x16 white-blue ai on a blue disk.
	static const char * AI_16_xpm[] = {
	"16 16 59 1",
	" 	c None",
	".	c #0E76BC",
	"+	c #0D75BB",
	"@	c #1D98D4",
	"#	c #1C96D3",
	"$	c #1990CE",
	"%	c #0D74BA",
	"&	c #26ADE3",
	"*	c #25AAE1",
	"=	c #209FD9",
	"-	c #0C75BC",
	";	c #0B74BB",
	">	c #1F9DD7",
	",	c #1B94D2",
	"'	c #0973BB",
	")	c #7DB5DB",
	"!	c #DBEAF5",
	"~	c #E7F1F9",
	"{	c #0570B9",
	"]	c #198FCE",
	"^	c #6BABD6",
	"/	c #FFFFFF",
	"(	c #D6E7F4",
	"_	c #006DB7",
	":	c #006EB8",
	"<	c #0E74BA",
	"[	c #26ACE3",
	"}	c #188CCC",
	"|	c #026FB9",
	"1	c #016FB8",
	"2	c #016EB8",
	"3	c #0772BA",
	"4	c #5AA2D1",
	"5	c #0A74BB",
	"6	c #338BC6",
	"7	c #0B73BA",
	"8	c #97C4E2",
	"9	c #D6E8F4",
	"0	c #4A98CD",
	"a	c #0B73B9",
	"b	c #D1E5F2",
	"c	c #0873BB",
	"d	c #96C3E2",
	"e	c #9BC6E3",
	"f	c #0D76BC",
	"g	c #C1DCEE",
	"h	c #FDFEFF",
	"i	c #0069B5",
	"j	c #0E75BA",
	"k	c #209ED8",
	"l	c #1F7FC1",
	"m	c #026EB8",
	"n	c #0F76BC",
	"o	c #0973BA",
	"p	c #84B9DD",
	"q	c #A3CBE5",
	"r	c #1E9BD7",
	"s	c #1E99D5",
	"t	c #1A92D0",
	"   ..........   ",
	" ........+@#$.. ",
	" ........%&*=.. ",
	".......-;+=>,...",
	".....')!~{].....",
	"....^/(_:<&[}...",
	"...:///|.%&*>...",
	"...1///2.%&*>...",
	"....342567&*>...",
	"....:8/90a&*>...",
	"...1//bc.%&*>...",
	"...d//e..%&*>...",
	"..fg//hi2j&*k...",
	" ..l/////m&*=.. ",
	" ..nopq01+rst.. ",
	"   ..........   "};
#endif

	//wxImage image( 16, 16, (unsigned char*)data, TRUE );
	wxIcon icon16x16( AI_16_xpm ); // wxIcon icon16x16( xpm_data16x16 );

    // Also give the main frame a 32x32 pixel icon (Alt+Tab uses a 32x32 pixel icon) This
    // xpm format should work for all platforms. It embeds the icon resource inside the
    // executable file, so no need to have to hunt for it from an external resource file.
#if defined (IconBlueShadesOn32x32WhiteRectangularBackground)
	/* XPM */
	static const char * xpm_data32x32[] = {
	// The following xpm icon contains the 32x32 blue shades ai logo on a white rectangular background.
	"32 32 176 2",
	"  	c #FFFFFF",
	". 	c #DFF2FB",
	"+ 	c #C8EAF8",
	"@ 	c #CBEBF8",
	"# 	c #C9EAF8",
	"$ 	c #D6EFF9",
	"% 	c #76CAEC",
	"& 	c #16A5DF",
	"* 	c #23AAE1",
	"= 	c #19A5E0",
	"- 	c #51BBE7",
	"; 	c #FDFEFF",
	"> 	c #75CAEC",
	", 	c #16A4DF",
	"' 	c #23A9E1",
	") 	c #50BAE7",
	"! 	c #FEFEFF",
	"~ 	c #74C9EC",
	"{ 	c #15A4DF",
	"] 	c #22A9E1",
	"^ 	c #18A5E0",
	"/ 	c #79CBEC",
	"( 	c #1CA7E0",
	"_ 	c #29ACE2",
	": 	c #1FA8E1",
	"< 	c #55BDE8",
	"[ 	c #FEFFFF",
	"} 	c #ECF8FC",
	"| 	c #DCF1FB",
	"1 	c #DAF0FA",
	"2 	c #D7F0FA",
	"3 	c #D5EFFA",
	"4 	c #DFF3FA",
	"5 	c #DFEDF6",
	"6 	c #B1D2E9",
	"7 	c #8DBEDF",
	"8 	c #7BB4DA",
	"9 	c #77B1D9",
	"0 	c #A6CCE6",
	"a 	c #DCF2FA",
	"b 	c #DEF2FB",
	"c 	c #ACCFE8",
	"d 	c #4B98CD",
	"e 	c #1479BE",
	"f 	c #006DB8",
	"g 	c #1E7FC0",
	"h 	c #348BC6",
	"i 	c #207CBF",
	"j 	c #4B97CC",
	"k 	c #1CA6E0",
	"l 	c #49B8E6",
	"m 	c #8BD2EF",
	"n 	c #E4F4FB",
	"o 	c #EAF3F9",
	"p 	c #539DCF",
	"q 	c #006CB7",
	"r 	c #1379BD",
	"s 	c #B0D2E9",
	"t 	c #F5FAFD",
	"u 	c #F7FBFD",
	"v 	c #E8F2F8",
	"w 	c #14A3DF",
	"x 	c #33B0E3",
	"y 	c #C4E8F7",
	"z 	c #FBFCFE",
	"A 	c #539ECF",
	"B 	c #006AB6",
	"C 	c #0C75BC",
	"D 	c #0A74BB",
	"E 	c #157ABE",
	"F 	c #D9EAF5",
	"G 	c #18A5DF",
	"H 	c #25AAE1",
	"I 	c #C1DBED",
	"J 	c #0470B9",
	"K 	c #0C74BB",
	"L 	c #0E76BC",
	"M 	c #006EB8",
	"N 	c #58A0D1",
	"O 	c #1BA6E0",
	"P 	c #9EC8E4",
	"Q 	c #006EB7",
	"R 	c #0D76BC",
	"S 	c #0571B9",
	"T 	c #3089C6",
	"U 	c #FAFDFE",
	"V 	c #52BBE7",
	"W 	c #B7D6EB",
	"X 	c #0B75BC",
	"Y 	c #006BB7",
	"Z 	c #559ED0",
	"` 	c #5AA1D1",
	" .	c #006DB7",
	"..	c #006BB6",
	"+.	c #1479BD",
	"@.	c #C4DEEF",
	"#.	c #A7CDE6",
	"$.	c #75B0D8",
	"%.	c #83B8DD",
	"&.	c #D8E8F4",
	"*.	c #F9FCFE",
	"=.	c #F6FAFD",
	"-.	c #77CAED",
	";.	c #E9F2F9",
	">.	c #ABCFE8",
	",.	c #77B2D9",
	"'.	c #4595CB",
	").	c #267FC0",
	"!.	c #5EA1D1",
	"~.	c #79CBED",
	"{.	c #B5D5EB",
	"].	c #549ECF",
	"^.	c #197CBF",
	"/.	c #0069B5",
	"(.	c #0571BA",
	"_.	c #85B8DD",
	":.	c #BED9EC",
	"<.	c #77CBED",
	"[.	c #DAEAF4",
	"}.	c #4C99CD",
	"|.	c #036FB9",
	"1.	c #3E91C9",
	"2.	c #D3E6F3",
	"3.	c #D4E6F2",
	"4.	c #2181C1",
	"5.	c #006CB8",
	"6.	c #DDEBF5",
	"7.	c #F5F9FC",
	"8.	c #3C90C9",
	"9.	c #0F76BC",
	"0.	c #026FB8",
	"a.	c #B2D3EA",
	"b.	c #016EB8",
	"c.	c #016FB8",
	"d.	c #519BCE",
	"e.	c #7FB6DC",
	"f.	c #0671BA",
	"g.	c #2C87C5",
	"h.	c #78B2DA",
	"i.	c #A1C9E5",
	"j.	c #AACFE7",
	"k.	c #0973BB",
	"l.	c #197DBF",
	"m.	c #9CC6E3",
	"n.	c #D5E7F3",
	"o.	c #8DBDDF",
	"p.	c #4796CC",
	"q.	c #0069B6",
	"r.	c #0B74BB",
	"s.	c #0F77BC",
	"t.	c #0370B9",
	"u.	c #0065B4",
	"v.	c #64A5D3",
	"w.	c #78CBED",
	"x.	c #E7F1F8",
	"y.	c #0872BA",
	"z.	c #2280C1",
	"A.	c #90C0E0",
	"B.	c #F9FCFD",
	"C.	c #6FC7EB",
	"D.	c #0BA0DD",
	"E.	c #19A5DF",
	"F.	c #0EA1DE",
	"G.	c #48B7E6",
	"H.	c #C5DEEF",
	"I.	c #83B9DD",
	"J.	c #5DA3D2",
	"K.	c #57A0D1",
	"L.	c #71AFD8",
	"M.	c #A9CEE7",
	"N.	c #ECF5FA",
	"O.	c #A1DAF2",
	"P.	c #60C1E9",
	"Q.	c #69C5EB",
	"R.	c #62C2EA",
	"S.	c #88D1EF",
	"                                                                ",
	"                                                                ",
	"                                      . + @ @ # $               ",
	"                                      % & * * = - ;             ",
	"                                      > , ' ' = ) !             ",
	"                                      ~ { ] ] ^ ) !             ",
	"                                      / ( _ _ : < [             ",
	"                                      } | 1 2 3 4               ",
	"                        5 6 7 8 9 0   a b                       ",
	"                    c d e f g h i j   ~ k l m n                 ",
	"                o p f q r s t [ u v   % { k w x y               ",
	"              z A B C D E F           % G H H w < [             ",
	"              I J K L L M N !         % G H H O ) !             ",
	"              P Q R L L S T U         % G H H O V !             ",
	"              W M X L L Y Z           % G H H O V !             ",
	"              u ` Y  ...+.@.          % G H H O V !             ",
	"                U #.$.%.&.      *.=.  -.G H H O V !             ",
	"                        ;.>.,.'.).!.  ~.G H H O V !             ",
	"                    {.].^./.(.d _.:.  <.G H H O V !             ",
	"                [.}.|.M f 1.2.        % G H H O V !             ",
	"              3.4.5.C D ^.6.          % G H H O V !             ",
	"            7.8. .9.L 0.d             % G H H O V !             ",
	"            a.b.R L L c.d.            % G H H O V !             ",
	"            e.5.L L L f.g.=.          % G H H O V !             ",
	"            h.5.L L L R J i.          % G H H O V !             ",
	"            j.f R L L L k.l.m.n.6 o.  ~.G H H O V !             ",
	"            7.p.q.r.L L s.k.t.D u.v.  w.G H H O V !             ",
	"              x.` y.q M M f b.z.A.B.  C.D.E.E.F.G.!             ",
	"                  H.I.J.K.L.M.N.      O.P.Q.Q.R.S.[             ",
	"                                                                ",
	"                                                                ",
	"                                                                "};

#elif defined (IconBlueShadesOn32x32WhiteDiskBackground)
	/* XPM */
	// The following xpm icon contains the 32x32 blue shades ai logo on a white disk.
	static const char * xpm_data32x32[] = {
	"32 32 177 2",
	"  	c None",
	". 	c #FFFFFF",
	"+ 	c #DFF2FB",
	"@ 	c #C8EAF8",
	"# 	c #CBEBF8",
	"$ 	c #C9EAF8",
	"% 	c #D6EFF9",
	"& 	c #76CAEC",
	"* 	c #16A5DF",
	"= 	c #23AAE1",
	"- 	c #19A5E0",
	"; 	c #51BBE7",
	"> 	c #FDFEFF",
	", 	c #75CAEC",
	"' 	c #16A4DF",
	") 	c #23A9E1",
	"! 	c #50BAE7",
	"~ 	c #FEFEFF",
	"{ 	c #74C9EC",
	"] 	c #15A4DF",
	"^ 	c #22A9E1",
	"/ 	c #18A5E0",
	"( 	c #79CBEC",
	"_ 	c #1CA7E0",
	": 	c #29ACE2",
	"< 	c #1FA8E1",
	"[ 	c #55BDE8",
	"} 	c #FEFFFF",
	"| 	c #ECF8FC",
	"1 	c #DCF1FB",
	"2 	c #DAF0FA",
	"3 	c #D7F0FA",
	"4 	c #D5EFFA",
	"5 	c #DFF3FA",
	"6 	c #DFEDF6",
	"7 	c #B1D2E9",
	"8 	c #8DBEDF",
	"9 	c #7BB4DA",
	"0 	c #77B1D9",
	"a 	c #A6CCE6",
	"b 	c #DCF2FA",
	"c 	c #DEF2FB",
	"d 	c #ACCFE8",
	"e 	c #4B98CD",
	"f 	c #1479BE",
	"g 	c #006DB8",
	"h 	c #1E7FC0",
	"i 	c #348BC6",
	"j 	c #207CBF",
	"k 	c #4B97CC",
	"l 	c #1CA6E0",
	"m 	c #49B8E6",
	"n 	c #8BD2EF",
	"o 	c #E4F4FB",
	"p 	c #EAF3F9",
	"q 	c #539DCF",
	"r 	c #006CB7",
	"s 	c #1379BD",
	"t 	c #B0D2E9",
	"u 	c #F5FAFD",
	"v 	c #F7FBFD",
	"w 	c #E8F2F8",
	"x 	c #14A3DF",
	"y 	c #33B0E3",
	"z 	c #C4E8F7",
	"A 	c #FBFCFE",
	"B 	c #539ECF",
	"C 	c #006AB6",
	"D 	c #0C75BC",
	"E 	c #0A74BB",
	"F 	c #157ABE",
	"G 	c #D9EAF5",
	"H 	c #18A5DF",
	"I 	c #25AAE1",
	"J 	c #C1DBED",
	"K 	c #0470B9",
	"L 	c #0C74BB",
	"M 	c #0E76BC",
	"N 	c #006EB8",
	"O 	c #58A0D1",
	"P 	c #1BA6E0",
	"Q 	c #9EC8E4",
	"R 	c #006EB7",
	"S 	c #0D76BC",
	"T 	c #0571B9",
	"U 	c #3089C6",
	"V 	c #FAFDFE",
	"W 	c #52BBE7",
	"X 	c #B7D6EB",
	"Y 	c #0B75BC",
	"Z 	c #006BB7",
	"` 	c #559ED0",
	" .	c #5AA1D1",
	"..	c #006DB7",
	"+.	c #006BB6",
	"@.	c #1479BD",
	"#.	c #C4DEEF",
	"$.	c #A7CDE6",
	"%.	c #75B0D8",
	"&.	c #83B8DD",
	"*.	c #D8E8F4",
	"=.	c #F9FCFE",
	"-.	c #F6FAFD",
	";.	c #77CAED",
	">.	c #E9F2F9",
	",.	c #ABCFE8",
	"'.	c #77B2D9",
	").	c #4595CB",
	"!.	c #267FC0",
	"~.	c #5EA1D1",
	"{.	c #79CBED",
	"].	c #B5D5EB",
	"^.	c #549ECF",
	"/.	c #197CBF",
	"(.	c #0069B5",
	"_.	c #0571BA",
	":.	c #85B8DD",
	"<.	c #BED9EC",
	"[.	c #77CBED",
	"}.	c #DAEAF4",
	"|.	c #4C99CD",
	"1.	c #036FB9",
	"2.	c #3E91C9",
	"3.	c #D3E6F3",
	"4.	c #D4E6F2",
	"5.	c #2181C1",
	"6.	c #006CB8",
	"7.	c #DDEBF5",
	"8.	c #F5F9FC",
	"9.	c #3C90C9",
	"0.	c #0F76BC",
	"a.	c #026FB8",
	"b.	c #B2D3EA",
	"c.	c #016EB8",
	"d.	c #016FB8",
	"e.	c #519BCE",
	"f.	c #7FB6DC",
	"g.	c #0671BA",
	"h.	c #2C87C5",
	"i.	c #78B2DA",
	"j.	c #A1C9E5",
	"k.	c #AACFE7",
	"l.	c #0973BB",
	"m.	c #197DBF",
	"n.	c #9CC6E3",
	"o.	c #D5E7F3",
	"p.	c #8DBDDF",
	"q.	c #4796CC",
	"r.	c #0069B6",
	"s.	c #0B74BB",
	"t.	c #0F77BC",
	"u.	c #0370B9",
	"v.	c #0065B4",
	"w.	c #64A5D3",
	"x.	c #78CBED",
	"y.	c #E7F1F8",
	"z.	c #0872BA",
	"A.	c #2280C1",
	"B.	c #90C0E0",
	"C.	c #F9FCFD",
	"D.	c #6FC7EB",
	"E.	c #0BA0DD",
	"F.	c #19A5DF",
	"G.	c #0EA1DE",
	"H.	c #48B7E6",
	"I.	c #C5DEEF",
	"J.	c #83B9DD",
	"K.	c #5DA3D2",
	"L.	c #57A0D1",
	"M.	c #71AFD8",
	"N.	c #A9CEE7",
	"O.	c #ECF5FA",
	"P.	c #A1DAF2",
	"Q.	c #60C1E9",
	"R.	c #69C5EB",
	"S.	c #62C2EA",
	"T.	c #88D1EF",
	"              . . . . . . . . . . . . . . . . . .               ",
	"          . . . . . . . . . . . . . . . . . . . . . .           ",
	"      . . . . . . . . . . . . . . . . + @ # # $ % . . . .       ",
	"    . . . . . . . . . . . . . . . . . & * = = - ; > . . . .     ",
	"    . . . . . . . . . . . . . . . . . , ' ) ) - ! ~ . . . .     ",
	"  . . . . . . . . . . . . . . . . . . { ] ^ ^ / ! ~ . . . . .   ",
	"  . . . . . . . . . . . . . . . . . . ( _ : : < [ } . . . . .   ",
	". . . . . . . . . . . . . . . . . . . | 1 2 3 4 5 . . . . . . . ",
	". . . . . . . . . . . . 6 7 8 9 0 a . b c . . . . . . . . . . . ",
	". . . . . . . . . . d e f g h i j k . { l m n o . . . . . . . . ",
	". . . . . . . . p q g r s t u } v w . & ] l x y z . . . . . . . ",
	". . . . . . . A B C D E F G . . . . . & H I I x [ } . . . . . . ",
	". . . . . . . J K L M M N O ~ . . . . & H I I P ! ~ . . . . . . ",
	". . . . . . . Q R S M M T U V . . . . & H I I P W ~ . . . . . . ",
	". . . . . . . X N Y M M Z ` . . . . . & H I I P W ~ . . . . . . ",
	". . . . . . . v  .Z ..+.@.#.. . . . . & H I I P W ~ . . . . . . ",
	". . . . . . . . V $.%.&.*.. . . =.-.. ;.H I I P W ~ . . . . . . ",
	". . . . . . . . . . . . >.,.'.).!.~.. {.H I I P W ~ . . . . . . ",
	". . . . . . . . . . ].^./.(._.e :.<.. [.H I I P W ~ . . . . . . ",
	". . . . . . . . }.|.1.N g 2.3.. . . . & H I I P W ~ . . . . . . ",
	". . . . . . . 4.5.6.D E /.7.. . . . . & H I I P W ~ . . . . . . ",
	". . . . . . 8.9...0.M a.e . . . . . . & H I I P W ~ . . . . . . ",
	". . . . . . b.c.S M M d.e.. . . . . . & H I I P W ~ . . . . . . ",
	". . . . . . f.6.M M M g.h.-.. . . . . & H I I P W ~ . . . . . . ",
	". . . . . . i.6.M M M S K j.. . . . . & H I I P W ~ . . . . . . ",
	"  . . . . . k.g S M M M l.m.n.o.7 p.. {.H I I P W ~ . . . . .   ",
	"  . . . . . 8.q.r.s.M M t.l.u.E v.w.. x.H I I P W ~ . . . . .   ",
	"    . . . . . y. .z.r N N g c.A.B.C.. D.E.F.F.G.H.~ . . . .     ",
	"    . . . . . . . I.J.K.L.M.N.O.. . . P.Q.R.R.S.T.} . . . .     ",
	"      . . . . . . . . . . . . . . . . . . . . . . . . . .       ",
	"          . . . . . . . . . . . . . . . . . . . . . .           ",
	"              . . . . . . . . . . . . . . . . . .               "};

#elif defined (IconBlueShadesOn32x32AllTransparentBackground)
	// The following xpm icon contains the 32x32 blue shades ai logo on a transparent background
	/* XPM */
	static const char * xpm_data32x32[] = {
	"32 32 82 1",
	" 	c None",
	".	c #1CA6E0",
	"+	c #52BBE7",
	"@	c #76CAEC",
	"#	c #16A5DF",
	"$	c #23AAE1",
	"%	c #19A5E0",
	"&	c #51BBE7",
	"*	c #75CAEC",
	"=	c #16A4DF",
	"-	c #23A9E1",
	";	c #50BAE7",
	">	c #74C9EC",
	",	c #15A4DF",
	"'	c #22A9E1",
	")	c #18A5E0",
	"!	c #79CBEC",
	"~	c #1CA7E0",
	"{	c #29ACE2",
	"]	c #1FA8E1",
	"^	c #55BDE8",
	"/	c #519BCE",
	"(	c #2181C1",
	"_	c #1479BE",
	":	c #006DB8",
	"<	c #1E7FC0",
	"[	c #348BC6",
	"}	c #49B8E6",
	"|	c #006CB7",
	"1	c #1379BD",
	"2	c #14A3DF",
	"3	c #33B0E3",
	"4	c #006AB6",
	"5	c #0C75BC",
	"6	c #0A74BB",
	"7	c #157ABE",
	"8	c #18A5DF",
	"9	c #25AAE1",
	"0	c #0470B9",
	"a	c #0C74BB",
	"b	c #0E76BC",
	"c	c #006EB8",
	"d	c #1BA6E0",
	"e	c #006EB7",
	"f	c #0D76BC",
	"g	c #0571B9",
	"h	c #3089C6",
	"i	c #0B75BC",
	"j	c #006BB7",
	"k	c #006DB7",
	"l	c #006BB6",
	"m	c #1479BD",
	"n	c #77CAED",
	"o	c #267FC0",
	"p	c #79CBED",
	"q	c #197CBF",
	"r	c #0069B5",
	"s	c #0571BA",
	"t	c #77CBED",
	"u	c #036FB9",
	"v	c #006CB8",
	"w	c #0F76BC",
	"x	c #026FB8",
	"y	c #016EB8",
	"z	c #016FB8",
	"A	c #0671BA",
	"B	c #2C87C5",
	"C	c #0973BB",
	"D	c #197DBF",
	"E	c #0069B6",
	"F	c #0B74BB",
	"G	c #0F77BC",
	"H	c #0370B9",
	"I	c #0065B4",
	"J	c #78CBED",
	"K	c #0872BA",
	"L	c #2280C1",
	"M	c #6FC7EB",
	"N	c #0BA0DD",
	"O	c #19A5DF",
	"P	c #0EA1DE",
	"Q	c #48B7E6",
	"                                ",
	"                                ",
	"                   .++++.       ",
	"                   @#$$%&       ",
	"                   *=--%;       ",
	"                   >,'');       ",
	"                   !~{{]^       ",
	"                   .++++.       ",
	"            /((((/              ",
	"          /(_:<[(( ..}}+        ",
	"        /(:|1(   ( @,.23+       ",
	"        (4567(     @8992^       ",
	"       /0abbc(     @899d;       ",
	"       (efbbgh     @899d+       ",
	"       /cibbj(     @899d+       ",
	"        /jklm(     @899d+       ",
	"         /(((      n899d+       ",
	"            ((((o( p899d+       ",
	"          /(qrs(// t899d+       ",
	"        /(uc:((    @899d+       ",
	"       /(v56q(     @899d+       ",
	"       (kwbx(      @899d+       ",
	"      /yfbbz(      @899d+       ",
	"      (vbbbAB      @899d+       ",
	"      (vbbbf0(     @899d+       ",
	"      /:fbbbCD(((( p899d+       ",
	"       (EFbbGCH6I( J899d+       ",
	"       /(K|cc:yL(  MNOOPQ       ",
	"         /(((((/   ......       ",
	"                                ",
	"                                ",
"                                "};

#else // IconWhiteBlueOn32x32BlueDiskBackground
	// The following xpm icon contains the 32x32 white-blue ai logo on a blue disk
	/* XPM */
	static const char * xpm_data32x32[] = {
	"32 32 155 2",
	"  	c None",
	". 	c #0E76BC",
	"+ 	c #0D74BB",
	"@ 	c #0D73BA",
	"# 	c #0D75BB",
	"$ 	c #188CCC",
	"% 	c #1D98D4",
	"& 	c #1C96D3",
	"* 	c #1990CE",
	"= 	c #0D74BA",
	"- 	c #1F9BD6",
	"; 	c #27B0E5",
	"> 	c #26ADE3",
	", 	c #27AFE4",
	"' 	c #21A1DB",
	") 	c #1E99D5",
	"! 	c #25AAE1",
	"~ 	c #26ACE2",
	"{ 	c #209FD9",
	"] 	c #26ACE3",
	"^ 	c #21A1DA",
	"/ 	c #0C75BC",
	"( 	c #0B74BB",
	"_ 	c #0D75BC",
	": 	c #1A90CF",
	"< 	c #1F9DD7",
	"[ 	c #209ED8",
	"} 	c #1B94D2",
	"| 	c #0571BA",
	"1 	c #006EB8",
	"2 	c #0370B9",
	"3 	c #0C75BB",
	"4 	c #1379BD",
	"5 	c #0C71B8",
	"6 	c #0C72B9",
	"7 	c #0973BB",
	"8 	c #3C90C9",
	"9 	c #7DB5DB",
	"0 	c #B7D6EB",
	"a 	c #DBEAF5",
	"b 	c #E7F1F8",
	"c 	c #E7F1F9",
	"d 	c #9AC5E3",
	"e 	c #0570B9",
	"f 	c #178BCB",
	"g 	c #198FCE",
	"h 	c #1381C4",
	"i 	c #016FB8",
	"j 	c #4595CB",
	"k 	c #C0DBED",
	"l 	c #FEFEFF",
	"m 	c #FFFFFF",
	"n 	c #E2EFF7",
	"o 	c #9CC7E3",
	"p 	c #82B8DC",
	"q 	c #9AC6E3",
	"r 	c #8BBDDF",
	"s 	c #0770B9",
	"t 	c #1E9BD6",
	"u 	c #26ABE2",
	"v 	c #1688C9",
	"w 	c #026FB9",
	"x 	c #6BABD6",
	"y 	c #FBFDFE",
	"z 	c #D6E7F4",
	"A 	c #0F77BC",
	"B 	c #006DB7",
	"C 	c #006DB8",
	"D 	c #0E74BA",
	"E 	c #0671BA",
	"F 	c #378DC7",
	"G 	c #FAFCFD",
	"H 	c #F4F8FC",
	"I 	c #3F92C9",
	"J 	c #0571B9",
	"K 	c #0D76BC",
	"L 	c #1F9ED8",
	"M 	c #89BCDE",
	"N 	c #AED1E9",
	"O 	c #9FC9E5",
	"P 	c #B9D7EC",
	"Q 	c #0470B9",
	"R 	c #6AAAD5",
	"S 	c #7CB5DA",
	"T 	c #016EB8",
	"U 	c #0E77BC",
	"V 	c #A3CBE6",
	"W 	c #FEFFFF",
	"X 	c #BBD8EC",
	"Y 	c #177BBE",
	"Z 	c #0A74BB",
	"` 	c #0772BA",
	" .	c #0872BA",
	"..	c #3D91C9",
	"+.	c #5AA2D1",
	"@.	c #4294CA",
	"#.	c #006BB7",
	"$.	c #1C7EC0",
	"%.	c #338BC6",
	"&.	c #328AC6",
	"*.	c #0B73BA",
	"=.	c #0067B5",
	"-.	c #1479BE",
	";.	c #59A0D1",
	">.	c #D2E5F2",
	",.	c #F5FAFD",
	"'.	c #036EB8",
	").	c #1D99D5",
	"!.	c #2B87C4",
	"~.	c #97C4E2",
	"{.	c #E8F2F9",
	"].	c #D6E8F4",
	"^.	c #7CB5DB",
	"/.	c #4A98CD",
	"(.	c #2684C3",
	"_.	c #0B73B9",
	":.	c #EFF6FB",
	"<.	c #91C0E0",
	"[.	c #0973BA",
	"}.	c #78B2D9",
	"|.	c #D1E5F2",
	"1.	c #0873BB",
	"2.	c #398FC8",
	"3.	c #98C5E3",
	"4.	c #96C3E2",
	"5.	c #9BC6E3",
	"6.	c #C1DCEE",
	"7.	c #CDE2F1",
	"8.	c #FDFEFF",
	"9.	c #58A0D1",
	"0.	c #0069B5",
	"a.	c #0E75BA",
	"b.	c #0E75BC",
	"c.	c #8ABCDF",
	"d.	c #71AED7",
	"e.	c #4394CA",
	"f.	c #73AFD8",
	"g.	c #8EBEE0",
	"h.	c #0871B9",
	"i.	c #1F7FC1",
	"j.	c #DDECF5",
	"k.	c #88BBDE",
	"l.	c #026EB8",
	"m.	c #0F76BC",
	"n.	c #2B86C4",
	"o.	c #CEE3F1",
	"p.	c #0672BA",
	"q.	c #0C73BA",
	"r.	c #84B9DD",
	"s.	c #A2CAE5",
	"t.	c #A3CBE5",
	"u.	c #86BADE",
	"v.	c #198ECD",
	"w.	c #1E9BD7",
	"x.	c #1A92D0",
	"              . . . . . . . . . . . . . . . . . .               ",
	"          . . . . . . . . . . . . . . + @ @ @ @ + . .           ",
	"      . . . . . . . . . . . . . . . # $ % & & % * . . . .       ",
	"    . . . . . . . . . . . . . . . . = - ; > > , ' . . . . .     ",
	"    . . . . . . . . . . . . . . . . = ) > ! ! ~ { . . . . .     ",
	"  . . . . . . . . . . . . . . . . . = - ; ] ] , ^ . . . . . .   ",
	"  . . . . . . . . . . . . . / ( ( _ # : { < < [ } . . . . . .   ",
	". . . . . . . . . . _ | 1 2 3 4 4 . . @ 5 6 = + # . . . . . . . ",
	". . . . . . . . . 2 7 8 9 0 a b c d e f g h . @ . . . . . . . . ",
	". . . . . . . . i j k l m n o p q r s t ; u ^ v + . . . . . . . ",
	". . . . . . . w x y m m z A B C 1 7 D ) > ! ] > $ = . . . . . . ",
	". . . . . . E F G m m m H I J . . K = ) > ! ! ] L + . . . . . . ",
	". . . . . . 1 M m m m m m N w K . . = ) > ! ! ] < + . . . . . . ",
	". . . . . . 1 O m m m m m P Q . . . = ) > ! ! ] < + . . . . . . ",
	". . . . . . i R m m m m m S T . . . = ) > ! ! ] < + . . . . . . ",
	". . . . . . 3 U V W m m X Y 7 Z `  .= ) > ! ! ] < + . . . . . . ",
	". . . . . . . ( ` ..+.@.T #.Z $.%.&.*.) > ! ! ] < + . . . . . . ",
	". . . . . . . . K C =.-.;.d >.,.W N '.).> ! ! ] < + . . . . . . ",
	". . . . . . . _ 1 !.~.{.m m ].^./.(._.) > ! ! ] < + . . . . . . ",
	". . . . . . _ 2 x :.m m m <.[.C 2 7 = ) > ! ! ] < + . . . . . . ",
	". . . . . . i }.m m m m |.[.1.. . . = ) > ! ! ] < + . . . . . . ",
	". . . . . | 2.y m m m m 3.C . . . . = ) > ! ! ] < + . . . . . . ",
	". . . . . T 4.m m m m m 5.1 . . . . = ) > ! ! ] < + . . . . . . ",
	". . . . K | 6.m m m m m 7. .3 . . K = ) > ! ! ] < + . . . . . . ",
	". . . . K | 6.m m m m m 8.9.0.2 T Z a.) > ! ! ] [ b.. . . . . . ",
	"  . . . . T c.m m m m m m :.d.e.f.g.h.).> ! ! ~ { . . . . . .   ",
	"  . . . . [.i.j.m m m m m m m m m k.l.).> ! ! ~ { . . . . . .   ",
	"    . . . m.J n.P m m m m m m o.;.p.q.- ; > > , ^ . . . . .     ",
	"    . . . . m.E [.j r.s.t.u./.m.i K # v.w.) ) t x.. . . . .     ",
	"      . . . . . _ Q 1 w w 1 2 3 . . . # = = = = + . . . .       ",
	"          . . . . . . . . . . . . . . . . . . . . . .           ",
	"              . . . . . . . . . . . . . . . . . .               "};
	#endif

	wxIcon icon32x32( xpm_data32x32 );


	// whm modification 22May09 to add multiple icons to the top level frame window
	// using wxIconBundle
	wxIconBundle iconBundle;
	iconBundle.AddIcon( icon16x16 );
	iconBundle.AddIcon( icon32x32 );

	m_pMainFrame->SetIcons(iconBundle); //m_pMainFrame->SetIcon(icon);
	//m_pMainFrame->SetIcon(wxIcon(wxICON(adaptit)));	// "adaptit" is a resource name
													// of an ICON defined in Adapt_It.rc
	// Only allow one document at a time to be open
	m_pDocManager->SetMaxDocsOpen(1);


	// The following commands probably have equivalents in wxWidgets' wxMimeTypesManager.
    // However, the wx version does not use serialized .adt type data files. I don't think
    // it would necessarily be a good thing for users to be able to open AI documents by
    // double clicking on Adapt It's data files. They are now stored in .xml files which we
    // wouldn't want to associate with the Adapt It application anyway. Moreover, when I
    // try double clicking the MFC version's .adt files, I get an error from the system
    // that says, "Adapt_It MFC Application has encountered a problem and needs to close.
    // We are sorry for the inconvenience." Therefore, I'll not convert the following MFC
    // function calls.
	// Enable DDE Execute open
	//EnableShellOpen();
	//RegisterShellFileTypes(TRUE);

	// In the MFC version the following command-line parsing code was
	// located here:
	// Parse command line for standard shell commands, DDE, file open
	//CCommandLineInfo cmdInfo;
	//ParseCommandLine(cmdInfo);
    // In the wx version, however, command-line processing is actually implemented but the
    // code was moved earlier in this OnInit() function (see above).

    // The one thing that ParseCommandLine() does in the MFC version is to start the
    // application with a new View as though File|New were executed giving the app access
    // to valid pView and pDoc pointers. We provide the equivalent below where we call
    // OnFileNew() directly (which is done below in this OnInit).

	// for richer memory leak dumps
    // whm - wxWidgets has its own memory leak facilities built into its library
	//_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );


	// some extra initializations, required for Adapt It
	m_bKBReady = FALSE;
//#ifdef _UNICODE
//	RenameNRtoUnicode(); // not used in wx version
//#endif
	EnsureWorkFolderPresent();
    // m_workFolderPath is set in EnsureWorkFolderPresent(), and this becomes the current
    // working directory. m_localPathPrefix is also set in here and is used in
    // MakeForeignBasicConfigFileSafe() below.
    // Bruce added 15Mar04 a parameter to EnsureWorkFolderPresent(m_localizedMyDocsPath),
    // but it's not needed for the wxWidgets version.
	// The m_workFolderPath typically is set to:
	// On Windows:	"C:\Documents and Settings\<UserName>\(My) Documents\Adapt It (Unicode) Work"
	// On Linux:	"/home/<UserName>/Adapt It (Unicode) Work"
	// On MacOSX:	"/Users/<UserName>/Adapt It (Unicode) Work"

	// BEW added 24Sep09: once m_workFolderPath has been set (it's the default work folder
	// location and will be a folder "Adapt It Work" or, for Unicode version, "Adapt It
	// Unicode Work"), and before MakeForeignBasicConfigFileSafe() is called a little
	// further below in the DealWith...() function, we must now check for a custom work
	// folder location having been made persistent in a previous session.
	// Such a folder, which could have any name and be anywhere on the local machine or an
	// attached read-writable drive, will have had its absolute path stored in a file
	// called CustomWorkFolderLocation, which is stored within the folder pointed at by
	// the path in m_workFolderPath. The custom location, and flags which say it is to be
	// turned on, are NOT stored in any configuration file, because that would be
	// dangerous due to the possibility of someone copying a foreign config file with
	// different settings over the local one and thereby losing information about where
	// the custom folder is and whether or not a custom work folder location has been made
	// persistent. Therefore, we have bypassed the config file mechanism to some extent,
	// and instead we treat the presence of a CustomWorkFolderLocation file in the default
	// work folder location as a flag indicating that a custom work folder has indeed been
	// set up, and get it's path from within the folder, and then turn on both
	// m_bUseCustomWorkFolderPath and m_bLockedCustomWorkFolderPath. Then in code further
	// below we use the path and these flags to navigate to the custom work folder, where
	// we will find an AI-BasicConfiguration.aic file containing appropropriate crutial
	// paths to the work folder, project, Adaptations folder, KB file and backup KB file.
	// This might by some unforseen circumstances (e.g. someone overwrites the config file
	// there with a foreign one with different path settings which, if used, would crash
	// the application) have bad paths, and so we first  call
	// MakeForeignBasicConfigFileSafe() to guarantee the paths in the AI-BasicConfiguration.aic
	// file are correct, and only then do we let control go further into OnInit() in order
	// to actually read the basic configuration file data within that file and set up the
	// application for work based on those settings. (The intent of all these convolutions
	// is so that any unwise meddling with what is in the basic config file, in
	// particular, it's stored critical paths, won't crash the app, but will instead get
	// self-healed before the data has to be committed to.)
	bool bDealtWithItOK = DealWithThePossibilityOfACustomWorkFolderLocation();
	if (!bDealtWithItOK)
	{
		// if we are supposed to have a persistent custom location but failed to setup for
		// it, then abort - the function will have put up an error message already, but
		// if recovery actions fail, another message is needed here, we'll make it localizable
		wxString str;
		str = str.Format(_(
"Locating the custom work folder location failed. Either recovery requires you to take action outside of Adapt It, or the recovery attempt failed, or you Cancelled in order to force the application to abort now."),
		m_customWorkFolderPath.c_str());
		wxMessageBox(str, _("Error of file named CustomWorkFolderLocation"), wxICON_ERROR);
		LogUserAction(_T("Locating the custom work folder location failed"));
		// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
		wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
		return FALSE;
	}

	// Bibledit testing below
	/*
	wxString beProjPath = GetBibleditProjectsDirPath();
	wxString shortProjName = _T("Tok Pisin"); // In BE the short and long project names are the same
	beProjPath += PathSeparator + shortProjName;
	//wxString testBuffer;
	wxString tempFolder;
	wxString tempFilePathName;
	int chNum = -1;
	wxString chNumStr;
	if (chNum == -1)
		chNumStr = _T("");
	else
		chNumStr << chNum;
	wxString bookName = _T("Matthew");
	wxString bookCode = this->GetBookCodeFromBookName(bookName);
	tempFolder = m_workFolderPath + PathSeparator + _T(".temp");
	tempFilePathName = tempFolder + PathSeparator + GetFileNameForCollaboration(_T("_Collab"), bookCode,
							shortProjName, chNumStr, _T(".tmp"));
	bool bWriteOK;
	wxArrayString errors;
	bWriteOK = CopyTextFromBibleditDataToTempFolder(beProjPath, bookName, chNum, tempFilePathName, errors);
	*/
	// Bibledit testing above

	m_backgroundMode = wxSOLID;	// whm added 6July2006 Set to wxSOLID here in App's
                // OnInit because wxDC's SetTextBackground uses by default background mode
                // of wxTRANSPARENT which doesn't show up on screen regardless of what
                // color we set with SetTextBackground(). Each call to SetTextBackground
                // should have a prior call to SetBackgroundMode(m_backgroundMode), in
                // which the m_backgroundMode = wxSOLID.

    // whm Note: In MFC version Bruce first created an off-screen temporary static control
    // window to get a valid CWnd*, but there is a simpler way in wxWidgets by using
    // wxGetClientDisplayRect() which I'm using here. According to wx docs, the
    // wxGetClientDisplayRect() function "returns the dimensions of the work area on the
    // display. On Windows this means the area not covered by the taskbar, etc. Other
    // platforms are currently defaulting to the whole display until a way is found to
    // provide this infor for all windows managers, etc."
	wxRect desktopWndRect = wxGetClientDisplayRect();
    // whm Note: If the user changes the screen resolution during program execution then
    // desktopWndRect could change. Also the MFC checks do not work when more than one
    // monitor are connected to the user's computer, especially when the application
    // position might have been on a second monitor. Therefore we need to check for
    // multiple monitor setup, and determine the boundaries for valid main frame positions
    // in such configurations. Checking for multiple monitors can be done with the
    // wxDisplay class.
    //
	int numMonitors;
	numMonitors = wxDisplay::GetCount();
	if (numMonitors > 1)
	{
		// assume two monitors
		wxDisplay displayOne(0);
		wxDisplay displayTwo(1);
		wxRect dispOneRect = displayOne.GetClientArea(); // x=0, y=0, width=1920,
					// height=1140 // doesn't include taskbar on Windows
		wxRect dispTwoRect = displayTwo.GetClientArea(); // x=1920, y=0, width=1920,
					// height=1200
		if (dispTwoRect.x > 0 || dispOneRect.x > 0)
		{
            // The second or first monitor's x coordinate is positive (instead of 0),
            // therefore we can assume that the desktop is extended from one display
            // monitor onto the other
			int maxDispRectX, maxDispRectY;
			maxDispRectX = dispOneRect.GetWidth() + dispTwoRect.GetWidth();
			maxDispRectY = wxMin(dispOneRect.GetHeight(),dispTwoRect.GetHeight()); // account
						// for task bar's presence
			// set the adjusted width and height of combined desktop display rect
			desktopWndRect.SetWidth(maxDispRectX);
			desktopWndRect.SetHeight(maxDispRectY);
		}
	}
	wxLogDebug(_T(
"desktopWndRect.x = %d, desktopWndRect.y = %d, desktopWndRect.width = %d, desktopWndRect.height = %d"),
	desktopWndRect.x,desktopWndRect.y,desktopWndRect.GetWidth(),desktopWndRect.GetHeight());
    //
    // The wndTopLeft and wndBotRight point coordinates below are used within the App's
    // GetBasicSettingsConfiguration() function
	wndTopLeft = wxPoint(desktopWndRect.GetLeft(),desktopWndRect.GetTop());
	wndBotRight = wxPoint(desktopWndRect.GetRight(),desktopWndRect.GetBottom());

    // The original position of MFC's Initialize() was here. In wx version it is divided up
    // into InitializeFonts() and InitializePunctuation() which are both called earler in
    // OnInit() above.

	// create the global Page Setup Dialog Data
	pPgSetupDlgData = new wxPageSetupDialogData; // must delete in OnExit()
	wxASSERT(pPgSetupDlgData != NULL);
	// create the global Print Data
	pPrintData = new wxPrintData; // must delete in OnExit()
	wxASSERT(pPrintData != NULL);
    // Set some defaults for the page setup dialog so they will show as defaults if the
    // user accesses the page setup dialog.
	// Margin MM values determined using the less precise
	// config_only_thousandthsInchToMillimetres conversion factor
	pPgSetupDlgData->SetMarginTopLeft(wxPoint(m_marginLeftMM,m_marginTopMM));
	pPgSetupDlgData->SetMarginBottomRight(wxPoint(m_marginRightMM,m_marginBottomMM));
	// Paper size MM values determined using the more precise
	// thousandthsInchToMillimetres conversion factor
	pPgSetupDlgData->SetPaperSize(wxSize(m_pageWidthMM,m_pageLengthMM));
	// SetPaperId() overrides the explicit paper dimensions passed in
	// wxPageSetupDialogData::SetPaperSize()
	pPgSetupDlgData->SetPaperId(wxPAPER_A4); // default to A4

	wxSize testSize;
	testSize = pPgSetupDlgData->GetPaperSize();
	// Set default orientation (Portrait)
	pPrintData->SetOrientation(wxPORTRAIT);
	// copy the printData info from the pageSetupDialog
	(*pPrintData) = pPgSetupDlgData->GetPrintData();

	//////////////////////////////////////////////////////////////////////////////////
    // Since we are about to read the config files, any data structures containing data
    // that might be changed from the reading of config files need to be created by this
    // point in OnInit().
	//////////////////////////////////////////////////////////////////////////////////

    // If the user holds the SHIFT-DOWN key here at program startup she can bypass the
    // normal reading of Adapt It's config file settings, forcing the program to load a set
    // of default settings instead.
	// The following routines can be forced to defaults by the user holding down the SHIFT-KEY:
	// 1. Basic Program-wide Adapt It Settings. See GetBasicConfiguration() which is only
	//    called from this OnInit() method (see below), and from
	//    app class's CustomWorkFolderLocation() command (available to administrator only)
	// 2. Project Settings. See GetProjectConfiguration() which is called from OnOpenDocument(),
	//    from DoUnpackDocument(), from the Project Page's OnWizardPageChanging (when an existing
	//    document was selected), and the Open Existing Project Dialog that gets called from
	//    AccessOtherAdaptionProject() while doing a transform glosses into adaptations operation.
	bool bConfigFilesRead = FALSE;

	// set the following before calling basic config files, otherwise these defaults wipe
	// out config file settings... of these 3, only the first is in the config file

   // BEW added 2Jul11, initialize the next two booleans. The first is set dynamically if
    // a PT or BE collaboration project is set up with a project nominated for receiving
	// free translations; the second is set if the Adapt It document in a collaboration
	// session has one or more free translations within it
	m_bCollaborationExpectsFreeTrans = FALSE;
	m_bCollaborationDocHasFreeTrans = FALSE;
	m_bSaveCopySourceFlag_For_Collaboration = FALSE;

	if (!m_bSkipBasicConfigFileCall)
	{
		// this call is skipped if the previous call to
		// DealWithThePossibilityOfACustomWorkFolderLocation() did not succeed in opening
		// the AI-BasicConfiguration.aic file at the custom work folder location, and so
		// SetDefaults() was instead called to set up default basic parameter values, and
		// if that is the case we must not here call GetBasicConfiguration() because
		// it would fail. The app's next shut down will write a correct basic config file
		// at the custom location (provided the user or admin doesn't change the location
		// using the Administrator menu).
		// !!!!!!!!!!!!!!!! BASIC CONFIG FILE IS READ HERE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		bConfigFilesRead = GetBasicConfiguration(); // GetBasicConfiguration
														 // detects SHIFT-DOWN
	}
	m_bSkipBasicConfigFileCall = FALSE; // restore default value
	if (bConfigFilesRead)
	{
		// this block won't be entered if the call of GetBasicConfiguration() above
		// was skipped - see the comment above for the protocol at this point in OnInit()
		int found = m_punctuation[0].Find(_T('\'')); // look for vertical ordinary
													 // quote (ie. apostrophe)
		if (found >= 0)
			m_bSingleQuoteAsPunct = TRUE;
		else
			m_bSingleQuoteAsPunct = FALSE;
		found = m_punctuation[0].Find(_T('\"')); // look for vertical
												 // ordinary double-quote
		if (found >= 0)
			m_bDoubleQuoteAsPunct = TRUE;
		else
			m_bDoubleQuoteAsPunct = FALSE;
		// Convert and set the PaperSizeCode, and Print margins that were read
		// from the basic config file
		pPgSetupDlgData->SetPaperId(MapMFCtoWXPaperSizeCode(m_paperSizeCode));
		pPgSetupDlgData->SetMarginTopLeft(wxPoint(m_marginLeftMM,m_marginTopMM));
		pPgSetupDlgData->SetMarginBottomRight(wxPoint(m_marginRightMM,m_marginBottomMM));
		pPgSetupDlgData->SetPaperSize(wxSize(m_pageWidthMM,m_pageLengthMM));
		// Note: SetPageOrientation() sets the page orientation in our pPrintData global
		SetPageOrientation(m_bIsPortraitOrientation);

		// initialize default path for cc tables
		m_tableFolderPath[0] = m_lastCcTablePath;
		m_tableFolderPath[1] = m_lastCcTablePath;
		m_tableFolderPath[2] = m_lastCcTablePath;
		m_tableFolderPath[3] = m_lastCcTablePath;

        // whm added 14Apr09. The basic config file contains position and size information
        // for the main frame and that information has now been read from the config file,
        // so here is where we should update the position and size of the CMainFrame
        // instance before other routines such as RecalcLayout will use it, or change the
        // App's values which store the current main frame's metrics.
        //
        // The wndBotRight and wndTopLeft coordinate points determined by the above call to
        // the wxGetClientDisplayRect() function are used in
        // GetBasicSettingsConfiguration() to ensure that the m_ptViewTopLeft.x and
        // m_ptViewTopLeft.y and m_szView.x and m_szView.y values are within range of the
        // current desktop. If the read-in values were not within range they were adjusted
        // to fall within the coordinates of the current desktop. Therefore, these values
        // should be "safe" to use in our SetSize() call on the main frame below, which is
        // called first to establish any non-zoomed window size, before re-establishing any
        // zoomed state.

		m_pMainFrame->SetSize(m_ptViewTopLeft.x, m_ptViewTopLeft.y, m_szView.x, m_szView.y, wxSIZE_AUTO);
		if (m_bZoomed)
		{
			m_pMainFrame->Maximize(TRUE);
		}
	}

	// MFC: Dispatch commands specified on the command line
	//if (!ProcessShellCommand(cmdInfo))
	//	return FALSE;

    // whm Note: For all intents and purposes, MFC's ProcessShellCommand() functions within
    // Adapt It to simply initiate a call to the App's OnFileNew() method in order to
    // create a doc/view as a stand-in at program startup. We can do the same in the wx
    // version by also calling the App's OnFileNew() method. This will provide for a Doc
    // and View for the opening canvas on the Main Frame. This Doc and View ensure there
    // are valid pDoc and pView pointers obtainable by routines like OnFilePageSetup()
    // which need access to them when no user selectable Doc and View are loaded, such as
    // when the user cancels at the opening wizard or closes the document or project.
    // App->OnFileNew() simply calls m_pDocManager->OnFileNew() which in turn calls
    // CreateDocument(). Note that the CreateDocument() call by itself actually sufficient,
    // since it also creates an associated view. It is therefore not necessary to call
    // CreateView() in addition to CreateDocument. In fact, when I did include a
    // CreateView() call below, it was causing problems, because OnCreate() was then
    // associating a different pointer with the view, causing some view members (like
    // m_pBundle) to have invalid pointers at some locations in the code resulting in
    // crashes.
	//CAdapt_ItDoc* pDoc;
	//pDoc = (CAdapt_ItDoc*)m_pDocManager->CreateDocument(m_workFolderPath,wxDOC_NEW);
	//
	wxCommandEvent event = wxID_NEW;
	OnFileNew(event);

	/* don't need this, as use in OnNewDocument() of m_bControlIsWithinOnInit makes it unneeded
	// we'll want to remove the ~AIROP*.lock file that may get set up here, so
	// use the project folder path, if set up, and remove the lock file
	if (!m_curProjectPath.IsEmpty())
	{
		bool bWasRemoved = m_pROP->RemoveReadOnlyProtection(m_curProjectPath);
		if (bWasRemoved)
		{
			m_bReadOnlyAccess = FALSE; // this process can now have ownership for writing
		}
		else
		{
			m_bReadOnlyAccess = TRUE; // control should never enter this block, don't
									  // proceed further if it does, abort instead
			wxString mssg;
			wxMessageBox(_T("Read-only protection was not removed. Remove the ~AIROP*.lock protection file from the project folder and re-launch. Now aborting."),_T("OnInit() Initialization error"), wxICON_ERROR);
			// this is how to abort cleanly from within the OnInit() function
			// (wxKill() is required, otherwise the process hangs around and that
			// makes the system think the app is still running)
			unsigned long pid = ::wxGetProcessId();
			enum wxKillError killErr;
			int rv = ::wxKill(pid,wxSIGTERM,&killErr); // makes OnExit() be called
			rv  = rv; // prevent compiler warning
			return FALSE;
		}
	}
	*/

	//CAdapt_ItView* pView;
	//pView = (CAdapt_ItView*)m_pDocManager->CreateView(pDoc,wxDOC_NEW);

    // The differences between MFC and wxWidgets' implementation of doc/view coupled with
    // Adapt It's design in which initializations are scattered over many code locations
    // make for a real messy conversion process.
	//
    // In the MFC version, OnInitialUpdate() is "called by the framework after the view is
    // first attached to the document, but before the view is initially displayed." To get
    // that equivalency here in the wxWidgets version, I determined by tracing through the
    // MFC code exactly when OnInitialUpdate() is called or not called in the following
    // startup/opening scenarios:
	// (which is not really what the MFC docs say about OnInitialUpdate)
	//		Scenario:							OnInitialUpdate() called:
	// 1. File|New...									YES
	// 2. File|Open...									NO
	// 3. File|Start Here...(more work on existing doc)	NO
	// 4. File|Startup Wizard..							NO
	// 5. Load file from MRU list on File Menu			YES
	// 6. After transform into glosses, File|New		YES (same as File|New...)
	//	  After transform into glosses, File|Open		NO
	// 7. Consistency Check...							NO
	// Summary: Taking the actual MFC code to contain the necessary conditions then,
	// OnInitialUpdate() and the various initializations therein, should be called
	// for only two main scenarios:
	// (1) for File | New Menu selection (OnFileNew), and
	// (2) when loading a file from the MRU list.
	// OnFileNew() above calls CreateDocument() which eventually calls OnNewDocument()
	// which calls OnInitialUpdate(). Hence, we do not need to explicityl call
	// OnInitialUpdate() here from OnInit().
	//CAdapt_ItView* pView = (CAdapt_ItView*) GetView();
	//wxASSERT(pView != NULL);
	//
	//pView->OnInitialUpdate();
	//

	// Creation of targetbox moved to the View's OnCreate() method

	/*
	// whm moved the following to the MakeMenuInitializationsAndPlatformAdjustments()
	// function.
    // These toggle menu items should be initially set as follows (TRUE=checked;
    // FALSE=unchecked):
    // whm verified 2Sep06 that at least some are needed to be pre-set as follows in order
    // for the calls to menu handlers to operate successfully in the View's
    // OnInitialUpdate() function where the initial state of toggled toolbar buttons is
    // set.
    m_pMainFrame->GetMenuBar()->Check(ID_VIEW_TOOLBAR, TRUE);
    m_pMainFrame->GetMenuBar()->Check(ID_VIEW_STATUS_BAR, TRUE);
    m_pMainFrame->GetMenuBar()->Check(ID_VIEW_COMPOSE_BAR, FALSE);
    m_pMainFrame->GetMenuBar()->Check(ID_COPY_SOURCE, TRUE);
    m_pMainFrame->GetMenuBar()->Check(ID_MARKER_WRAPS_STRIP, TRUE);
    m_pMainFrame->GetMenuBar()->Check(ID_USE_CC, FALSE);
    m_pMainFrame->GetMenuBar()->Check(ID_ACCEPT_CHANGES, FALSE);
    m_pMainFrame->GetMenuBar()->Check(ID_ADVANCED_SEE_GLOSSES, FALSE);
    m_pMainFrame->GetMenuBar()->Check(ID_ADVANCED_GLOSSING_USES_NAV_FONT, FALSE);
	*/

	// whm added 6Jan12. Show or Hide the toolbar, modeBar and/or statusBar according
	// to the user preferences. The Basic Config file was read in above, so the user's
	// preferences are stored in the App's members m_bStatusBarVisible, m_bToolBarVisible,
	// and m_bModeBarVisible. These main window bars, are shown or hidden irrespective
	// of whether the View menu has the items shown or hidden in the current profile.
	// Hence, if the administrator sets the visibility of a View menu item that controls
	// the visibility of these to be hidden from the menu, after having made the bar
	// element hidden, that element will stay hidden and the user won't be able to change
	// that element's visibility. The
	if (m_bToolBarVisible)
		m_pMainFrame->m_pToolBar->Show();
	else
		m_pMainFrame->m_pToolBar->Hide();

	if (m_bModeBarVisible)
		m_pMainFrame->m_pControlBar->Show();
	else
		m_pMainFrame->m_pControlBar->Hide();

	if (m_bStatusBarVisible)
		m_pMainFrame->m_pStatusBar->Show();
	else
		m_pMainFrame->m_pStatusBar->Hide();

	// The following code for setting the composebar font and RTL was moved here
	// to the App from the CMainFraim constructor where it was in the MFC version
	wxPanel* pComposeBar;
	pComposeBar = m_pMainFrame->m_pComposeBar;
	wxASSERT(pComposeBar != NULL);
	wxTextCtrl* pComposeBarEdit = (wxTextCtrl*)pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
	wxASSERT(pComposeBarEdit != NULL);
	pComposeBarEdit->SetFont(*m_pTargetFont);

	// Add RTL support for Unicode version
#ifdef _RTL_FLAGS
	if (gpApp->m_bTgtRTL)
	{
		pComposeBarEdit->SetLayoutDirection(wxLayout_RightToLeft);
	}
	else
	{
		pComposeBarEdit->SetLayoutDirection(wxLayout_LeftToRight);
	}
#endif

	//wxMenuBar* pMenuBar = m_pMainFrame->GetMenuBar();
	//wxASSERT(pMenuBar != NULL);

	// ************************* TEMPORARY FOR 6.0.0 ONLY <<-- Maybe, BEW removed OXES
	// support 15Jun15 until such time as LSDev clarify what the future of OXES is, and
	// until we have another app which needs to support it - TE is dead in the water,
	// since no longer does the Mara project in Tanzania use it

	// For OXES -- in 6.0.0 it isn't supported, so remove the menu item temporarily, and
	// restore it for 6.1.0

	// whm 23Mar11 change: The following creates a memory leak and is risks complications for
	// the user profiles menu routines. I've commented this out, and placed a wxMessageBox()
	// notification to the user in CAdapt_ItView::OnExportOXES()
	/*
	wxMenu* pItsMenu = NULL;
	wxMenuItem* pHideThisOxesMenuItem = pMenuBar->FindItem(ID_EXPORT_OXES, &pItsMenu);
	if (pItsMenu != NULL) // whm 15Mar11 added test for NULL pointer (might happen if menu item is hidden/removed in user profiles)
	{
		pItsMenu->Remove(pHideThisOxesMenuItem);
	}
	*/
// ************************ REMOVE ABOVE 3 LINES AFTER 6.0.0 IS RELEASED *********************

	// Hide the Glossing check box
	// whm 30Aug11 Note: At startup glossing is OFF and the <no adaptation> button label
	// is the default, so just keep <no adaptatioin> on the button here
	wxPanel* pBar;
	pBar = m_pMainFrame->m_pControlBar;
	wxASSERT(pBar != NULL);
	wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)pBar->FindWindowById(IDC_CHECK_ISGLOSSING);
	if(pCheckboxIsGlossing != NULL)
	{
		pCheckboxIsGlossing->Show(FALSE);
	}

    m_pMainFrame->Show(TRUE);
    SetTopWindow(m_pMainFrame);

	// MFC has this code for drag and drop at this point
	// Enable drag/drop open
	// wxWidgets has various drag and drop classes, but I'm not going to try to
	// implement it here
	//m_pMainWnd->DragAcceptFiles();

    // MFC Note: the following flag is TRUE while there is no m_targetBox created, during
    // setup of the view - because if it turns out that the first sourcephrase does not
    // have a KB entry, but the first two source phrases are in fact a phrase (ie. have a
    // KB entry for that phrase) then the setup will do the required merge, and this will
    // not have come about by the user hitting ENTER to jump to the next location; so
    // certain things pertinent to that state will not obtain (in particular m_targetBox
    // will be NULL), and so we have to test for the null box while the gbDoingInitialSetup
    // flag is TRUE, and use a successful test to enable us to jump code which would
    // otherwise crash the app; the gbDoingInitialSetup flag is then turned off at the end
    // of the Finish button's code in the Wizard, and the end of the handler for the NEW...
    // document command. We also must set the flag to true whenever the user closes a
    // document, because if he then does a <New Document> command in the wizard, the phrase
    // box will also at that point not be in existence, and otherwise a crash would happen
    // when in OnButtonMerge()
	gbDoingInitialSetup = TRUE;

	// change the unnamedN title to "Untitled - Adapt It"
	wxString viewTitle = _("Untitled - Adapt It");
	GetDocument()->SetTitle(viewTitle);
	GetDocument()->SetFilename(viewTitle,TRUE); // here TRUE means "notify the views"

	// Display message in status bar that we are loading the books.xml and
	// AI_USFM.xml files (brief)
	wxString message = _("Loading books.xml and AI_USFM.xml ...");
	wxStatusBar* pStatusBar = m_pMainFrame->GetStatusBar();//CStatusBar* pStatusBar;
	wxASSERT(pStatusBar != NULL);
	pStatusBar->SetStatusText(message,0); // use first field 0

    // Bible book folder support (accessing books.xml file, which can have its Christian
    // content removed if users want to fiddle with it) - if the file is absent from the
    // work folder, then default English bible book names plus "Other Texts" are set up;
    // and the default radio button labels would be "History books", .... etc.
	wxString booksfilePath;
	if (!m_customWorkFolderPath.IsEmpty() && m_bUseCustomWorkFolderPath)
	{
		booksfilePath = m_customWorkFolderPath + PathSeparator + _("books.xml");
	}
	else
	{
		booksfilePath = m_workFolderPath + PathSeparator + _("books.xml");
	}

	bool bBooksFileExists = ::wxFileExists(booksfilePath) && !::wxDirExists(booksfilePath);

    // if the file does not exist in the work folder, look for it in the m_xmlInstallPath
    // folder and if there then copy it to the work folder before opening it from the
    // latter location
	if (!bBooksFileExists)
	{

		wxString booksInstallFolderFileCopyPath;
		booksInstallFolderFileCopyPath = m_xmlInstallPath + PathSeparator + _("books.xml");
		bBooksFileExists = ::wxFileExists(booksInstallFolderFileCopyPath) && !::wxDirExists(booksInstallFolderFileCopyPath);
		if (bBooksFileExists)
		{
			//wxLogDebug(_T("Copying existing books.xml from m_xmlInstallPath to user's work folder."));
			// copy the file to the work folder
			bool success;
			// Use the simple wxCopyFile() method
			success = wxCopyFile(booksInstallFolderFileCopyPath, booksfilePath, TRUE); // TRUE = overwrite
			if (!success)
			{
				bBooksFileExists = FALSE;
				wxLogDebug(_T("Could NOT copy existing books.xml from m_xmlInstallPath to user's work folder."));
			}
		}
	}

	if (bBooksFileExists)
	{
        // parse the file, and set up m_pBibleBooks CPtrArray containing ptrs to
        // BookNamePair structs; and the Which Book? dialog's 5 button labels for the book
        // sublists (make sure xml file has a defaultBook=" some number " attribute, for
        // setting m_nBookIndex to that number less one (the XML user-readable should use
        // 1-based numbers))

        // whm added 30Nov07 If a customized books.xml file is used with fewer than 5
        // divisions ReadBooks_XML will only populate as many divisions as are actually
        // listed within the books.xml file. We don't want the remaining default labels to
        // be used in this case. Therefore we should set all five division labels to null
        // strings before reading in the books.xml file (which we know exists since we're
        // now in this block). we also need to allow the books.xml to specify the division
        // sizes for the same reasons as for the division labels above.
		int ct;
		for (ct = 0; ct < 5; ct++)
		{
			m_strDivLabel[ct] = _T("");
			m_nDivSize[ct] = 0;
		}

		bool bReadOK = ReadBooks_XML(booksfilePath,NULL,0);
		if (!bReadOK)
		{
            // a bad parse, or failure to read the file in off the disk correctly, means we
            // must prevent book mode from being entered, and revert to normal mode
            // (accessing Adaptations folder only)
			// IDS_DISABLE_BOOK_MODE
			wxMessageBox(_(
"Warning: book folder mode will be disabled until a books.xml file is stored \nin the work folder and it is read in and parsed correctly.\nYou should exit the application and fix the books.xml file\nbefore trying to do more work."),
			_T(""), wxICON_WARNING);
			m_bDisableBookMode = TRUE; // it will stay disabled until we exit the app &
            // fix the books.xml file disabling the mode does not change the m_bBookMode
            // value, nor the m_nBookIndex value, and these continue to be saved in the
            // document; however, m_bDisableBookMode will force the paths to be set to the
            // Adaptations folder in the project, and so the document saved formerly under
            // book mode will not be accessible (unless the user moves it to the
            // Adaptations folder using Windows Explorer) until the disabling is removed,
            // and if the document were to be saved it would get saved in the Adaptations
            // folder. To remove disabling, fix the books.xml file so it parses correctly,
            // or if it did not get read in, so that it gets read in. However, it is
            // unlikely that it did not get read in; most likely there was a parse error -
            // and the user should have seen an error message to that effect originating
            // from the ReadBooks_XML call above. If there was not such, then it must have
            // been a bad file read.
		}
	}
	else
	{
        // no "books.xml" file in the work folder, so use default setup; m_pBibleBooks
        // pointer is already created but as yet has no content
		SetupDefaultBooksArray(m_pBibleBooks); // hard coded for 67 folders

		//wxLogDebug(_T("No books.xml file found in work folder, so setting defaults via SetupDefaultBooksArray()."));

		// assume not in book mode, project config file will override this, so no
		// point to set a default here
		m_nBookIndex = -1;
		m_pCurrBookNamePair = NULL;
		m_bBookMode = FALSE;
		m_nDefaultBookIndex = 39; // so we'd get "Matthew" if the Bible books
								  // are set up as here
	}

	// !!! whm added 19Jan05 AI_USFM.xml file processing and USFM Filtering below
	// If the AI_USFM.xml file is absent from the work folder, then
	// default styles for USFM are set up.
	//
    // whm ammended 14Jun05. If the Output_Default_Style_Strings symbol is defined (in
    // XML.h) the program will look for the AI_USFM_full.xml file in the App Path instead
    // of AI_USFM.xml and produce a file called the AI_USFM_full.txt that contains the
    // Unix-like default strings. With this modification, the AI_USFM_full.xml file does
    // not need to be renamed to AI_USFM.xml; AI_USFM_full.xml only needs to be located in
    // the work folder, i.e., the "Adapt It Work" folder for it to be used in producing the
    // Unix-like default strings (in Debug build only).
	wxString AIstyleFileWorkFolderPath;
	wxString AIuserProfilesWorkFolderPath;
	wxString AIemailReportFolderPathOnly;
	wxString AIusageLogFolderPath;
	wxString AIpackedDocumentFolderPathOnly;
	wxString AIccTableFolderPathOnly;
	wxString strUserID = ::wxGetUserId(); // returns empty string if unsuccessful
	if (strUserID.IsEmpty())
	{
		// we must supply a default if nothing was returned
		strUserID = _T("unknownUser");
	}

	if (!m_customWorkFolderPath.IsEmpty() && m_bUseCustomWorkFolderPath)
	{
		#ifdef Output_Default_Style_Strings
		AIstyleFileWorkFolderPath = m_customWorkFolderPath + PathSeparator + _T("AI_USFM_full.xml");
		#else
		AIstyleFileWorkFolderPath = m_customWorkFolderPath + PathSeparator + _T("AI_USFM.xml");
		#endif
		AIuserProfilesWorkFolderPath = m_customWorkFolderPath + PathSeparator + _T("AI_UserProfiles.xml");
		if (!::wxDirExists(m_customWorkFolderPath + PathSeparator + m_logsEmailReportsFolderName))
			::wxMkdir(m_customWorkFolderPath + PathSeparator + m_logsEmailReportsFolderName);
		if (!::wxDirExists(m_customWorkFolderPath + PathSeparator + m_packedInputsAndOutputsFolderName))
			::wxMkdir(m_customWorkFolderPath + PathSeparator + m_packedInputsAndOutputsFolderName);
		if (!::wxDirExists(m_customWorkFolderPath + PathSeparator + m_ccTableInputsAndOutputsFolderName))
			::wxMkdir(m_customWorkFolderPath + PathSeparator + m_ccTableInputsAndOutputsFolderName);
		AIusageLogFolderPath = m_customWorkFolderPath + PathSeparator + m_logsEmailReportsFolderName + PathSeparator + _T("UsageLog_") + strUserID + _T(".txt");
		AIemailReportFolderPathOnly = m_customWorkFolderPath + PathSeparator + m_logsEmailReportsFolderName; // AI email reports use the same path as the usage logs
		AIpackedDocumentFolderPathOnly = m_customWorkFolderPath + PathSeparator + m_packedInputsAndOutputsFolderName;
		AIccTableFolderPathOnly = m_customWorkFolderPath + PathSeparator + m_ccTableInputsAndOutputsFolderName;
	}
	else
	{
		#ifdef Output_Default_Style_Strings
		AIstyleFileWorkFolderPath = m_workFolderPath + PathSeparator + _T("AI_USFM_full.xml");
		#else
		AIstyleFileWorkFolderPath = m_workFolderPath + PathSeparator + _T("AI_USFM.xml");
		#endif
		AIuserProfilesWorkFolderPath = m_workFolderPath + PathSeparator + _T("AI_UserProfiles.xml");
		if (!::wxDirExists(m_workFolderPath + PathSeparator + m_logsEmailReportsFolderName))
			::wxMkdir(m_workFolderPath + PathSeparator + m_logsEmailReportsFolderName);
		if (!::wxDirExists(m_workFolderPath + PathSeparator + m_packedInputsAndOutputsFolderName))
			::wxMkdir(m_workFolderPath + PathSeparator + m_packedInputsAndOutputsFolderName);
		if (!::wxDirExists(m_workFolderPath + PathSeparator + m_ccTableInputsAndOutputsFolderName))
			::wxMkdir(m_workFolderPath + PathSeparator + m_ccTableInputsAndOutputsFolderName);
		AIusageLogFolderPath = m_workFolderPath + PathSeparator + m_logsEmailReportsFolderName + PathSeparator + _T("UsageLog_") + strUserID + _T(".txt");
		AIemailReportFolderPathOnly = m_workFolderPath + PathSeparator + m_logsEmailReportsFolderName; // AI email reports use the same path as the usage logs
		AIpackedDocumentFolderPathOnly = m_workFolderPath + PathSeparator + m_packedInputsAndOutputsFolderName;
		AIccTableFolderPathOnly = m_workFolderPath + PathSeparator + m_ccTableInputsAndOutputsFolderName;
	}

	m_userProfileFileWorkFolderPath = AIuserProfilesWorkFolderPath;

	m_logsEmailReportsFolderPath = AIemailReportFolderPathOnly;
	m_packedInputsAndOutputsFolderPath = AIpackedDocumentFolderPathOnly; //m_packedDocumentFilePathOnly = AIpackedDocumentFolderPathOnly; // whm added 8Nov10
	m_usageLogFilePathAndName = AIusageLogFolderPath; // whm added 8Nov10
	m_ccTableInputsAndOutputsFolderPath = AIccTableFolderPathOnly; //m_ccTableFilePathOnly = AIccTableFolderPathOnly;

	m_userLogFile = new wxFile(m_usageLogFilePathAndName,wxFile::write_append); // just append new data to end of log file; deleted in OnExit()

	// Does AI_USFM.xml exist in the work folder
	bool bWorkStyleFileExists = wxFileExists(AIstyleFileWorkFolderPath);

    // Note: The path to the m_setupFolder may differ from the default installation
    // location if user installed Adapt It to a non-default user defined folder, The call
    // to FindAppPath() above determines the path to the currently running executable,
    // which is safer than hard coding the path to a predetermined setup location.
	wxString usfmStyleInstallFolderFileCopyPath = m_xmlInstallPath + PathSeparator + _T("AI_USFM.xml");
	bool bSetupStyleFileExists = wxFileExists(usfmStyleInstallFolderFileCopyPath);
	LogUserAction(_T("AppStartUp"));

	wxString userProfileInstallFolderFilecopyPath = m_xmlInstallPath + PathSeparator + _T("AI_UserProfiles.xml");
	// Does AI_UserProfiles.xml exist in the work folder
	bool bWorkFolderUserProfilesFileExists = wxFileExists(m_userProfileFileWorkFolderPath);
	bool bInstallFolderUserProfileFileExists = wxFileExists(userProfileInstallFolderFilecopyPath);

	// Now, check that the AI_USFM.xml file exists in the work folder (make a copy there
	// if necessary from the installation resources.
	// Note: The check for the AI_UserProfiles.xml file is similar to the handling of the
	// AI_USFM.xml file immediately below, but is handled farther below after the handling
	// of the AI_USFM.xml file.

	// If the AI_USFM.xml file does not exist in the work folder, look for it in the
	// setup folder and, if there, then copy it to the work folder before opening it
	// from the latter location.
	if (!bWorkStyleFileExists)
	{
		// There is no AI_USFM.xml file in the work folder, so get one from
		// the setup folder if one is there, and copy it to the work folder preserving
		// the date it had in the setup folder.
		if (bSetupStyleFileExists)
		{
			// copy the file to the work folder
			bool copyOK;
			copyOK = wxCopyFile(usfmStyleInstallFolderFileCopyPath, AIstyleFileWorkFolderPath, TRUE); // TRUE = overwrite
			if (copyOK)
			{
                // Testing shows that the wxCopyFile call above actually preserves the mod
                // dates, so we don't need code below for the wxWidgets version since a
                // successful copy will automatically make the newly copied file in the
                // work folder have same date it has in the installation/setup folder.
				//wxFileName fnInWorkFolderPath(AIstyleFileWorkFolderPath);
				//wxFileName fnInSetupFolderPath(usfmStyleInstallFolderFileCopyPath);
				//wxDateTime dtWorkFolderFileAccessTime,dtWorkFolderFileModTime,dtWorkFolderFileCreateTime;
				//wxDateTime dtSetupFolderFileAccessTime,dtSetupFolderFileModTime,dtSetupFolderFileCreateTime;
				//fnInWorkFolderPath.GetTimes(&dtWorkFolderFileAccessTime,&dtWorkFolderFileModTime,&dtWorkFolderFileCreateTime);
				//fnInSetupFolderPath.GetTimes(&dtSetupFolderFileAccessTime,&dtSetupFolderFileModTime,&dtSetupFolderFileCreateTime);
				//// we only need to compare the Modtimes
				//if (dtWorkFolderFileModTime != dtSetupFolderFileModTime)
				//{
				//	// file in work folder is not same as the one in setup folder so make Modtime of file
				//	// in work folder match the Modtime of file in setup folder
				//	fnInWorkFolderPath.SetTimes(&dtSetupFolderFileAccessTime,&dtSetupFolderFileModTime,&dtSetupFolderFileCreateTime);
				//}
				bWorkStyleFileExists = TRUE;
				//wxLogDebug(_T("Copying existing AI_USFM.xml from m_xmlInstallPath to user's work folder."));
			}
			else
			{
				bWorkStyleFileExists = FALSE;
				wxLogDebug(_T("Could NOT copy existing AI_USFM.xml from m_xmlInstallPath to user's work folder."));
			}
		}
	}
	else
	{
		bool bSetupFolderHasNewerVersion = FALSE;
		if (bSetupStyleFileExists)
		{
            // The AI_USFM.xml file exists, but there may have been a more recent
            // installation just done in which the file in the setup folder exists as a
            // later version with changed content, so we have to check for a later version
            // and if so we copy it to replace the old version in the work folder - if we
            // don't do this, tweaks done to the file in incremental version updates won't
            // get implemented unless the user manually moves the file to the work folder
            // and we don't want to expect users to have to remember to do such a thing.
			// Check if we have a newer version in the setup folder
			bSetupFolderHasNewerVersion = FileHasNewerModTime(usfmStyleInstallFolderFileCopyPath,AIstyleFileWorkFolderPath);
		}
		// If setup folder has a newer version, we will first delete what is in the work
		// folder, then copy the file from the setup folder to replace it. If setup folder
		// version is not newer then do nothing.
		if (bSetupFolderHasNewerVersion)
		{
			if (!wxRemoveFile(AIstyleFileWorkFolderPath))
			{
				wxMessageBox(_("Could not remove the AI_USFM.xml file from the work folder."),
					_T(""), wxICON_INFORMATION);
			}
			if (bSetupStyleFileExists)
			{
				// copy the file to the work folder
				bool copyOK;
				copyOK = wxCopyFile(usfmStyleInstallFolderFileCopyPath, AIstyleFileWorkFolderPath, TRUE); // TRUE = overwrite
				if (copyOK)
				{
                    // Testing shows that the wxCopyFile call above actually preserves the
                    // mod dates, so we don't need code below for the wxWidgets version
                    // since a successful copy will automatically make the newly copied
                    // file in the work folder have same date it has in the
                    // installation/setup folder.
					//wxFileName fnInWorkFolderPath(AIstyleFileWorkFolderPath);
					//wxFileName fnInSetupFolderPath(usfmStyleInstallFolderFileCopyPath);
					//wxDateTime dtWorkFolderFileAccessTime,dtWorkFolderFileModTime,dtWorkFolderFileCreateTime;
					//wxDateTime dtSetupFolderFileAccessTime,dtSetupFolderFileModTime,dtSetupFolderFileCreateTime;
					//fnInWorkFolderPath.GetTimes(&dtWorkFolderFileAccessTime,&dtWorkFolderFileModTime,&dtWorkFolderFileCreateTime);
					//fnInSetupFolderPath.GetTimes(&dtSetupFolderFileAccessTime,&dtSetupFolderFileModTime,&dtSetupFolderFileCreateTime);
					//// we only need to compare the Modtimes
					//if (dtWorkFolderFileModTime != dtSetupFolderFileModTime)
					//{
					//	// file in work folder is not same as the one in setup folder so make
					//	// Modtime of file in work folder match the Modtime of file in setup folder
					//	fnInWorkFolderPath.SetTimes(&dtSetupFolderFileAccessTime,
					//	   &dtSetupFolderFileModTime,&dtSetupFolderFileCreateTime);
					//}
					bWorkStyleFileExists = TRUE;
					//wxLogDebug(_T("Copying newer version of AI_USFM.xml to user's work folder."));
				}
				else
				{
					bWorkStyleFileExists = FALSE;
					wxLogDebug(_T("Could not copy newer version of AI_USFM.xml to user's work folder."));
				}
			}
		}
	}

	//wxLogDebug(_T("gnDefaultSFMs has %d strings in array."),gnDefaultSFMs);
	if (bWorkStyleFileExists)
	{
		// parse the file, and set up the three CMapStringToOb maps containing
		// mappings between usfm tags and the usfm analysis structs on the heap;
		bool bReadOK = ReadSFM_XML(AIstyleFileWorkFolderPath,NULL,0);
		if (!bReadOK)
		{
            // a bad parse, or failure to read the file in off the disk correctly, means we
            // will inform the user of the situation and use a default set of styles based
            // on our original AI_USFM.xml file
			// IDS_USING_DEFAULT_USFM_STYLES
			wxMessageBox(_(
"Warning: using default USFM styles until a AI_USFM.xml file is stored in the work folder and it is read in and parsed correctly. You should exit the application and fix the AI_USFM.xml file if you have previously told Adapt It to hide certain standard format markers."),
			_T(""), wxICON_INFORMATION);
			m_bUsingDefaultUsfmStyles = TRUE;
            // To use any non-default styles, user needs to fix the AI_USFM.xml file so it
            // parses correctly, or if it did not get read in, so that it gets read in.
            // However, it is unlikely that it did not get read in; most likely there was a
            // parse error - and the user should have seen an error message to that effect
            // originating from the ReadStyles_XML call above. If there was not such, then
            // it must have been a bad file read.
		}
	}
	else
	{
        // no "AI_USFM.xml" file in the work folder, so use default setup;
        // m_pUsfmStylesMap, m_pPngStylesMap, and m_pUsfmAndPngStylesMap pointers are
        // already created but as yet have no content
		wxLogDebug(_T("AI_USFM.xml not found in work folder - using internal styles via SetupDefaultStylesMap."));
		SetupDefaultStylesMap(); // hard coded for 282 default usfm styles
	}


	// Create the m_pAI_MenuStructure based on the default AI menu bar as found
	// in the wxDesigner's AIMenuBarFunc() function. This also populates the
	// m_mapMenuLabelStrToIdInt with all of AI's menu label -> menu id
	// associations.
	SetupDefaultMenuStructure(m_pAI_MenuStructure, m_mapMenuLabelStrToIdInt);
	// The following SetupDefaultUserProfiles() must come after the SetupDefaultMenuStructure()
	// call above within OnInit().
	SetupDefaultUserProfiles(m_pFactoryUserProfiles); // calls GetAndAssignIdValuesToUserProfilesStruct()

	// Now, check that the AI_UserProfiles.xml file exists in the work folder (make a
	// copy there if necessary from the installation resources.
	message = _("Loading AI_UserProfiles.xml ...");
	wxASSERT(pStatusBar != NULL);
	pStatusBar->SetStatusText(message,0); // use first field 0

	// If the AI_UserProfiles.xml file does not exist in the work folder, look for it in the
	// setup install folder and, if there, decide how to handle version differences due to
	// possible upgrades/downgrades which may require merging of any changes made to
	// AI_UserProfiles.xml by an administrator who has customized one or more profiles
	// using the User Workflow Profiles dialog from the Administrator menu.
	if (!bWorkFolderUserProfilesFileExists)
	{
		// There is no AI_UserProfiles.xml file in the work folder, so get one from
		// the setup folder if one is there, and copy it to the work folder preserving
		// the date it had in the setup folder.
		if (bInstallFolderUserProfileFileExists)
		{
			// copy the file to the work folder
			bool copyOK;
			copyOK = wxCopyFile(userProfileInstallFolderFilecopyPath, m_userProfileFileWorkFolderPath, TRUE); // TRUE = overwrite
			if (copyOK)
			{
				bWorkFolderUserProfilesFileExists = TRUE;
				//wxLogDebug(_T("Copying existing AI_UserProfiles.xml from m_xmlInstallPath to user's work folder."));
			}
			else
			{
				bWorkFolderUserProfilesFileExists = FALSE;
				wxLogDebug(_T("Could NOT copy existing AI_UserProfiles.xml from m_xmlInstallPath to user's work folder."));
			}
		}
	}
	else
	{
		// There is an AI_UserProfiles.xml file already in the work folder.
		// Does it need to be upgraded to a more recent (higher number) version?
		// If the installation setup folder contains an AI_UserProfiles.xml file
		// (normally there should be one there), we need to compare their versions
		// and see if the one in the work folder needs to be upgraded. The one in
		// the installation folder might be a newer version if the user installed
		// an AI update since the last time the app was run. Note however, that
		// the user/administrator may have previously modified the work folder's
		// existing AI_UserProfiles.xml via edits done in the User Workflow
		// Profiles dialog. So, in the event the user has installed a newer AI
		// update, we don't want to obliterate his existing user profiles modifications
		// (stored in the AI_UserProfiles.xml in his work folder), but we want to
		// preserve his profile edits while upgrading the AI_UserProfiles.xml to
		// the newer version. This requires that we merge his existing modifications
		// into the newly installed AI_UserProfiles.xml data as we copy the merged
		// AI_UserProfiles.xml file to his work folder.
		// In actuality the basic steps are:
		// 1. The work folder's existing AI_UserProfiles.xml file's xml content is
		// read using ReadPROFILES_XML(); this populates the m_pUserProfiles struct
		// on the heap with the existing old (but modified) data.
		// 2. The work folder's existing AI_UserProfiles.xml file is removed/deleted.
		// 3. We call SaveUserProfilesMergingDataToXMLFile() which reads the install
		// setup folder's (newer) version of AI_UserProfiles.xml into memory as a
		// wxTextFile, and merges changes into the appropriate lines of its in-memory
		// copy of the newer AI_UserProfiles.xml. Then it creates a new instance of
		// a wxTextFile (pointing to the user's work folder), copies all of the
		// in-memory text lines from install setup folder's version to the newly
		// created version. Finally it writes the newly created version out to the
		// user's work folder as a newly created AI_UserProfiles.xml file.
		bool bSetupFoldersVersionCanReplace = FALSE; // FALSE unless the next block changes it to TRUE
		if (bInstallFolderUserProfileFileExists)
		{
			// The AI_UserProfiles.xml file exists, but it may have been edited/customized
			// by an administrator. If so we should attempt to merge any edited/customized
			// data into any more recent version of AI_UserProfiles.xml file that now
			// exists in the work folder. We need to do the following each time the app
			// runs:
			// 1. Read the existing AI_UserProfiles.xml in the work folder and determine:
			//    a. The profileVersion attribute's value, i.e., "1.0"
			//    b. The applicationCompatibility attribute's value, i.e., "6.0.0"
			//    c. The adminModified attribute's value, i.e., "No" or "Yes"
			// 2. If the adminModified attribute is "No" we can quietly replace the existing
			//    AI_UserProfiles.xml file with any newer version contained in the setup folder,
			//    since we know that no edits/customizations would be lost in the update and
			//    replacement of the existing AI_UserProfiles.xml file with the one in the
			//    setup folder.
			// 3. If the adminModified attribute is "Yes" it differs from its factory defaults
			//    and we must consider the applicationCompatibility and profileVersion
			//    attibutes' values and determine the following:
			//    a. If the versions are deemed compatible, we quietly merge the
			//       edits/customizations made by the administrator into the incoming
			//       AI_UserProfiles.xml file and copy that merged AI_UserProfiles.xml
			//       file into the work folder location.
			//    b. If they are not compatible, we rename the existing file to
			//       AI_UserProfiles_old.xml, and inform the user that a backup copy of
			//       their edited/customized AI_UserProfiles.xml file was made in the work
			//       folder by that name, and that they will likely need to edit/customize
			//       the user workflow profiles anew for the updated version of the
			//       application.

			wxString profileVersionStr;
			wxString applicationCompatibilityStr;
			wxString adminModifiedStr;
			GetVersionAndModInfoFromProfilesXMLFile(m_userProfileFileWorkFolderPath,
				profileVersionStr,applicationCompatibilityStr,adminModifiedStr);
			wxASSERT(!profileVersionStr.IsEmpty());
			// NOTE COMMENT BELOW
			wxASSERT(!applicationCompatibilityStr.IsEmpty());
			// **** IF THE applicationCompatibilityStr ASSERT TRIPS on launch from the IDE ****
			// - probable reason is because the AI_UserProfiles.xml file being accessed is
			// an older version, or, it cannot be found when OnInit() looks for it.
            // Go to the adaptit working copy folder, look for the xml folder, and inside
            // that is the repository's latest AI_Profiles.xml file. Copy it to the
            // ...\bin\win32 four object file folders for the 4 configurations we support,
			// and all should be well on next launch. If not so, the probably reason is
			// that there is an older version of the file in the Adapt It Unicode Work
			// folder, or in the Adapt It Work folder for the ANSI app.
			wxASSERT(!adminModifiedStr.IsEmpty());

			if (adminModifiedStr == _T("No"))
			{
				// The work folder's version of AI_UserProfiles.xml has not been modified so
				// it is safe to quietly copy the install folder's version over it resulting
				// in an automatic upgrade of any newer version of AI_UserProfiles.xml.
				bSetupFoldersVersionCanReplace = TRUE;
			}
			else if (adminModifiedStr == _T("Yes"))
			{
				// The work folder's version of AI_UserProfiles.xml has been modified by an
				// administrator. How we proceed depends on what we find when we compare the
				// versions encoded in the profileVersion attribute and the applicationCompatibility
				// attribute of the work folder's AI_UserProfiles.xml against the application's
				// running versions (encoded in #defines at the beginning of Adapt_It.h).
				// Note: The running App's versions encoded in #defines should be identical to
				// those encoded in the AI_UserProfiles.xml file in the setup install folder - if
				// we have prepared our installers correctly!
				wxString runningAppVerStr;
				runningAppVerStr = GetAppVersionOfRunningAppAsString();
				wxString profileAppVerStr;
				profileAppVerStr = GetProfileVersionOfRunningAppAsString();
				enum VersionComparison versionComparison;
				// CompareRunningVersionWithWorkFolderVersion() compares the App's running version numbers
				// against those of the current work folder's AI_UserProfile.xml file. The profileVersionStr
				// and applicationCompatibilityStr strings were determined above in the
				// GetVersionAndModInfoFromProfilesXMLFile() function call.
				versionComparison = CompareRunningVersionWithWorkFolderVersion(profileVersionStr, applicationCompatibilityStr);

				// whm Note Regarding the handling of version "conflicts" between AI and
				// AI_UserProfiles.xml:
				// We attempt to handle both the case situations below together by merging the
				// AI_UserProfiles.xml file in the work folder with the one that now exists in the
				// install setup folder (which compared with the running application has a newer or
				// older version. For example, the running application may be version 6.0.3 but the
				// version of the AI_UserProfiles.xml file in the work folder might be 6.0.0 (which
				// could happen in a normal upgrade scenario). Another possible example might happen
				// when the running application may be version 6.0.1 but the version of the
				// AI_UserProfiles.xml file in the work folder might be 6.0.3 (which might happen if
				// a user decided to downgrade from AI version 6.0.3 to 6.0.1 because of some bug or
				// other problem, or could happen in a circumstance when someone copies a work
				// folder from a computer running version 6.0.3 to a computer that is still using
				// version 6.0.1). In either case, I've tried to make the upgrade and downgrade process
				// capable of handling such scenarios without problems. The worst that might happen is
				// that there could be some instances in which a profile item might return to its
				// default factory value or might not be available after an upgrade or downgrade.
				// It is not likely this would happen to much extent since I don't forsee us making
				// huge changes to the profiles design of the user profiles features in the future.
				//
				switch (versionComparison)
				{
				case runningAppVersionIsNewer:
				case runningAppVersionIsOlder:
					{
						// The work folder's AI_UserProfiles.xml was modified and there is a newer or
						// older version in the install setup folder.
						// In either case we do a backup of the user's modified AI_UserProfiles.xml file
						// before merging it with the newer or older version associated with the currently
						// running AI application.

						// Backup the existing AI_UserProfiles.xml file to AI_UserProfiles_Old_01.xml
						wxString backupPathNameUsed = _T("");
						bool bOK;
						bOK = BackupExistingUserProfilesFileInWorkFolder(m_userProfileFileWorkFolderPath,backupPathNameUsed);
						if (!bOK)
						{
							// This message should be localized
							wxString msg = _("Could not create backup of the modified AI_UserProfiles.xml file: \n   %s\nPlease ask your administrator to check your user workflow profiles.");
							msg = msg.Format(msg,AIuserProfilesWorkFolderPath.c_str());
							wxMessageBox(msg,_T(""),wxICON_INFORMATION);
						}
						// Note: we do the above back up quietly - unless
						// BackupExistingUserProfilesFileInWorkFolder() does not succeed for some reason.
						// The commented out code below might be used if we want to notify the user of the
						// upgrade or downgrade process with the recommendation that the administrator check
						// the user profiles.
						//else
						//{
						//	// This message should be localized
						//	wxString msg = _("There was a newer version (%s) of AI_UserProfiles.xml in the work folder than Adapt It version %s expected. It was backed up as:\n   %s\n and a new AI_UserProfiles.xml was created/merged.\nPlease ask your administrator to check your user workflow profiles.");
						//	// here we fill the first %s with the applicationCompatibilityStr which is in the
						//	// form of the application's version number, i.e., 6.x.x
						//	msg = msg.Format(msg,applicationCompatibilityStr.c_str(),runningAppVerStr.c_str(),backupPathNameUsed.c_str());
						//	wxMessageBox(msg,_T(""),wxICON_WARNING);
						//}

						// The "normal" calling of ReadPROFILES_XML() has not happened yet, so we need to
						// do it temporarily here in order to populate the existing m_pUserProfiles struct
						// in order to use it in the merging process.
						wxASSERT(m_pUserProfiles == NULL);
						// whm 25Aug11 Note: The AI_UserProfiles.xml file is not large enough to require
						// a wxProgressDialog, so we send NULL through ReadPROFILES_XML().
						bool bReadOK = ReadPROFILES_XML(m_userProfileFileWorkFolderPath,NULL,0);
						if (!bReadOK)
						{
							// a bad parse, or failure to read the file in off the disk correctly, means we
							// will inform the user of the situation and use the default user profile which
							// makes all menu items/settings visible.
							wxMessageBox(_(
				"Unable to read the AI_UserProfiles.xml file in the work folder. Ask your administrator to recreate Adapt It's user workflow profiles."),
							_T(""), wxICON_INFORMATION);

							// XML.cpp issues a Warning that AI_UserProfiles.xml could not be read.
							// We'll populate the list boxes with default settings parsed from our
							// default unix-like strings, so modifications the administrator did will
							// be lost (see information message above).
							SetupDefaultUserProfiles(m_pUserProfiles); // calls GetAndAssignIdValuesToUserProfilesStruct()
						}
						else
						{
							// We don't call GetAndAssignIdValuesToUserProfilesStruct(m_pUserProfiles)
							// nor ReportMenuAndUserProfilesInconsistencies() here - they are called
							// later after merging issues are handled.

							// The SaveUserProfilesMergingDataToXMLFile() below requires that we first
							// have the m_mapProfileChangesToStringValues map populated with the user's
							// modifications by a call to MapChangesInUserProfiles().
							// MapChangesInUserProfiles() allows for different number of
							// descriptionProfileTexts entries and a different number of UserProfileItems in
							// the ->profileItemList(s). This may happen when the applicationCompatibility
							// versions are different due to upgrades, downgrades, or copying of
							// work folder contents to a different machine running a different version
							// of Adapt It.
							// MapChangesInUserProfiles() internally keeps track of the number of
							// differences it encounteres in listed profile items.
							MapChangesInUserProfiles(m_pUserProfiles, m_pFactoryUserProfiles);

							// Remove the existing work folder's AI_UserProfiles.xml file. It was backed
							// up above and we have its data already in m_pUserProfiles because of the
							// ReadPROFILES_XML() call above.
							bool bRemovedOK;
							bRemovedOK = wxRemoveFile(m_userProfileFileWorkFolderPath);
							if (bRemovedOK)
							{
								bool bMergedSavedOK;
								// Note: below we use the userProfileInstallFolderFilecopyPath path which makes
								// SaveUserProfilesMergingDataToXMLFile() merge the install version's
								// AI_UserProfiles.xml into the work folder's version
								bMergedSavedOK = SaveUserProfilesMergingDataToXMLFile(userProfileInstallFolderFilecopyPath);
								if (!bMergedSavedOK)
								{
									// Note: Specific error messages are handled within
									// SaveUserProfilesMergingDataToXMLFile() above.
									SetupDefaultUserProfiles(m_pUserProfiles); // calls GetAndAssignIdValuesToUserProfilesStruct()
								}
							}
							else
							{
								wxMessageBox(_(
					"Unable to update the AI_UserProfiles.xml file in the work folder. Ask your administrator to recreate Adapt It's user workflow profiles."),
								_T(""), wxICON_INFORMATION);
								SetupDefaultUserProfiles(m_pUserProfiles); // calls GetAndAssignIdValuesToUserProfilesStruct()
							}
						}
						// We're finished with our temporary copy of m_pUserProfiles.
						DestroyUserProfiles(m_pUserProfiles); // it will get created again below in the normal call of ReadPROFILES_XML()
						// Note: bSetupFoldersVersionCanReplace stays FALSE here, because we handle getting
						// updated AI_UserProfiles.xml into the user's work folder above
						break;
					}
				case profileVersionDiffers:
					{
						// The profileVersion differs. The profileVersion only changes when
						// there has been a major change to the AI_UserProfiles.xml file that
						// would make it incompatible with the earlier "1.0" version. The
						// CompareRunningVersionWithWorkFolderVersion() function above indicates
						// that this is the case. Whether a merge would be possible in this
						// situation will need to be determined when the new profileVersion is
						// created (if ever). So, for now we notify the programmer via a debug assert,
						// make a backup copy of the edited/customized AI_UserProfiles.xml, and notify
						// the user that they will likely need to "check and recreate your user work
						// profiles if necessary" for the updated version of the application. The
						// bSetupFoldersVersionCanReplace flag is set TRUE, which will cause the
						// AI_UserProfiles.xml to be overwritten by the "incompatible version" that
						// is in the setup install folder (i.e., since profileVersion differences
						// mean some kind of incompatibility it is safest to use the AI_UserProfiles.xml
						// that is designed for the application that is currently running.
						wxASSERT_MSG(FALSE,_T("The PROFILE_VERSION_MAJOR_PART or PROFILE_VERSION_MINOR_PART version numbers of the running application differ\nfrom the profileVersion attribute of the modified AI_UserProfiles.xml file in the user's work folder."));
						// Backup the existing AI_UserProfiles.xml file to AI_UserProfiles_Old_01.xml
						wxString backupPathNameUsed = _T("");
						bool bOK;
						bOK = BackupExistingUserProfilesFileInWorkFolder(m_userProfileFileWorkFolderPath,backupPathNameUsed);
						if (!bOK)
						{
							// This message should be localized
							wxString msg = _("Could not create backup of the modified AI_UserProfiles.xml file: \n   %s\nPlease ask your administrator to recreate your user workflow profiles.");
							msg = msg.Format(msg,m_userProfileFileWorkFolderPath.c_str());
							wxMessageBox(msg,_T(""),wxICON_WARNING);
						}
						else
						{
							// This message should be localized
							wxString msg = _("There was an incompatible version (%s) of AI_UserProfiles.xml in the work folder.\nAdapt It version %s expected it to be %s. The existing AI_UserProfiles.xml file was backed up as:\n   %s\n and a new AI_UserProfiles.xml was created in the work folder.\nPlease ask your administrator to check and recreate your user workflow profiles if necessary.");
							// here we fill the first %s with the profileAppVerStr which is in the
							// form of the AI_UserProfiles.xml's profileVersion number, i.e., 1.x
							msg = msg.Format(msg,profileVersionStr.c_str(),runningAppVerStr.c_str(),profileAppVerStr.c_str(),backupPathNameUsed.c_str());
							wxMessageBox(msg,_T(""),wxICON_WARNING);
						}
						// Set bSetupFoldersVersionCanReplace = TRUE here because we want the version in the
						// setup install folder to be used since it is known to be compatible with the running
						// application.
						bSetupFoldersVersionCanReplace = TRUE;
						break;
					}
				case sameAppVersion: // fall through to sameAppVersion - the most common scenario
				default:
					{
						// Versions are the same so we don't need to copy the setup folder's version
						// to the work folder, i.e., the modified one in the work folder remains unchanged.
						// This is the most common case when edits have been made to AI_UserProfiles.xml
						// by an administrator. We set bSetupFoldersVersionCanReplace = FALSE so the
						// existing AI_UserProfiles.xml file in the user's work folder does NOT get
						// overwritten (in code below) by the unmodified one residing in the setup install
						// folder.
						bSetupFoldersVersionCanReplace = FALSE;
					}
				}
			}

			// Note: The checking for modification times of files is not appropriate for our
			// AI_UserProfiles.xml file handling in regards to upgrades or downgrades.
			// The AI_UserProfiles.xml file is likely to be edited by an administrator so
			// its modification date cannot be compared to the modification date of the
			// AI_UserProfiles.xml file installed in a given AI version update. The
			// modification time of the AI_UserProfiles.xml file in the user's work folder
			// could well be newer than one recently installed in the setup folder that
			// has a newer internal version.
		}
		// If bSetupFoldersVersionCanReplace is TRUE, we will first delete what is in the
		// work folder, then copy the file from the setup folder to replace it. If
		// bSetupFoldersVersionCanReplace is FALSE then do nothing.
		if (bSetupFoldersVersionCanReplace)
		{
			if (!wxRemoveFile(m_userProfileFileWorkFolderPath))
			{
				wxMessageBox(_("Could not remove the AI_UserProfiles.xml file from the work folder."),
					_T(""), wxICON_INFORMATION);
			}
			if (bInstallFolderUserProfileFileExists)
			{
				// copy the file to the work folder
				bool copyOK;
				copyOK = wxCopyFile(userProfileInstallFolderFilecopyPath, m_userProfileFileWorkFolderPath, TRUE); // TRUE = overwrite
				if (copyOK)
				{
					bWorkFolderUserProfilesFileExists = TRUE;
					//wxLogDebug(_T("Copying newer version of AI_UserProfiles.xml to user's work folder."));
				}
				else
				{
					bWorkFolderUserProfilesFileExists = FALSE;
					wxLogDebug(_T("Could not copy installed version of AI_UserProfiles.xml to user's work folder."));
				}
			}
		}
	}

	// Now, do the normal reading of AI_UserProfiles.xml which creates the m_pUserProfiles struct on
	// the heap.
	if (bWorkFolderUserProfilesFileExists)
	{
		wxLogDebug(_T("The m_userProfileFileWorkFolderPath = %s"),m_userProfileFileWorkFolderPath.c_str());
		// parse the xml file, and set up the data structures
		// whm 25Aug11 Note: The AI_UserProfiles.xml file is not large enough to require
		// a wxProgressDialog, so we send NULL through ReadPROFILES_XML().
		bool bReadOK = ReadPROFILES_XML(m_userProfileFileWorkFolderPath,NULL,0);
		if (!bReadOK)
		{
            // a bad parse, or failure to read the file in off the disk correctly, means we
            // will inform the user of the situation and use the default user profile which
            // makes all menu items/settings visible.
			wxMessageBox(_(
				"Unable to read the AI_UserProfiles.xml file in the work folder. Ask your administrator to recreate Adapt It's user workflow profiles."),
				_T(""), wxICON_INFORMATION);

			// XML.cpp issues a Warning that AI_UserProfiles.xml could not be read.
			// We'll populate the list boxes with default settings parsed from our
			// default unix-like strings.
			SetupDefaultUserProfiles(m_pUserProfiles); // calls GetAndAssignIdValuesToUserProfilesStruct()
		}
		else
		{
			// The AI_UserProfiles.xml file was read, check for inconsistencies between
			// our internal unix-like default strings and what was in AI_UserProfiles.xml.
			// Note: GetAndAssignIdValuesToUserProfilesStruct() needs to be called here
			// because ReadPROFILES_XML() does not call it, and it needs to be called at
			// some point before ReportMenuAndUserProfilesInconsistencies().
			GetAndAssignIdValuesToUserProfilesStruct(m_pUserProfiles);
			ReportMenuAndUserProfilesInconsistencies();
		}
	}
	else
	{
        // no "AI_UserProfiles.xml" file in the work folder, so use default user profile (none);
		wxLogDebug(_T("AI_UserProfiles.xml not found in work folder - using Adapt It's default internal user profile."));
		// XML.cpp issues a Warning that AI_UserProfiles.xml could not be read.
		// We'll populate the list boxes with default settings parsed from our
		// default unix-like strings.
		SetupDefaultUserProfiles(m_pUserProfiles); // calls GetAndAssignIdValuesToUserProfilesStruct()
	}

	// At this point the config files have been read and the AI_UserProfiles.xml file has been
	// read and the m_pUserProfiles and m_pFactoryUserProfiles data structures have been
	// created.
	//
	// Adjust menus and settings for the selected user workflow profile by calling
	// ConfigureInterfaceForUserProfile(). However, if the m_nWorkflowProfile is 0 "None"
	// we simply bypass calling ConfigureInterfaceForUserProfile() and the application
	// uses its default interface of menus, etc.
	if (m_nWorkflowProfile != 0)
	{
		ConfigureInterfaceForUserProfile();
	}

	// Config file's value for user work profile has been read in, so set the
	// m_bAiSessionExpectsUserDefinedProfile flag to its initial session state here
	// in OnInit(). The value of the flag should be TRUE when m_nWorkflowProfile is
	// not 0 ("None"), FALSE otherwise (when m_nWorkflowProfile is 0).
	m_bAiSessionExpectsUserDefinedProfile = (m_nWorkflowProfile != 0);

	// whm 28Jul11 moved the initialization of m_bShowAdministratorMenu here before the
	// call to MakeMenuInitializationsAndPlatformAdjustments().
	m_bShowAdministratorMenu = FALSE; // on launch, Administrator menu should be hidden
#ifdef __WXDEBUG__
	m_bShowAdministratorMenu = TRUE; // on launch, Administrator menu shown (debugging only)
#endif

	// whm Note: We should associate the file history with the File menu, and load
	// the File History AFTER calling ConfigureInterfaceForUserProfile() above.
	//
	// Get the File Menu, tell the doc manager that we want the File History on the
	// File Menu, and Load the File History (MRU) to it
	wxMenu* pFileMenu = m_pMainFrame->GetMenuBar()->GetMenu(fileMenu);
	wxASSERT(pFileMenu != NULL);
	m_pDocManager->FileHistoryUseMenu(pFileMenu);
	// This must come after Main Menu is created and FileHistoryUseMenu call
	m_pDocManager->FileHistoryLoad(*m_pConfig); // Load the File History (MRU)
												// list from *m_pConfig

	// whm 29Feb12 removed the sanity checks that check for an installed
	// collaboration editor (Paratext or Bibledit) along with the routines that
	// would save the m_pConfig saving routines for collaboration values.
	// Adapt It now does project-specific collaboration and the user always has
	// control over  whether collaboration with a particular AI project gets
	// turned ON or OFF. The ChooseCollabOptionsDlg now does the sanity check.
	// If neither Paratext or Bibledit is installed the ChooseCollabOptionsDlg
	// actually disables the Turn Collaboration ON radio button and changes its
	// label to "%s is NOT INSTALLED on this computer. No collaboration is
	// possible".

	// whm added 9Feb11 for Paratext and Bibledit Collaboration support
	// GetParatextProjectsDirPath gets the absolute path to the Paratext Projects directory
	// as stored in the Windows registry, i.e., "C:\My Paratext Projects\".
	// m_ParatextProjectsDirPath will be null if Paratext is not installed or we are not on
	// a Windows host system.
	// Note: the GetParatextInstallDirPath() and GetParatextProjectsDirPath() function remove
	// the Windows \ path separator from the end of the string
	m_ParatextInstallDirPath = GetParatextInstallDirPath();
	m_ParatextProjectsDirPath = GetParatextProjectsDirPath();

	// GetBibleditInstallDirPath gets the absolute path to the Bibledit projects directory
	// which on Linux systems is ~/.bibledit/projects.
	// m_BibleditInstallDirPath will be null if Bibledit is not installed or we are not on
	// a Linux host system.
	m_BibleditInstallDirPath = GetBibleditInstallDirPath();
	m_BibleditProjectsDirPath = GetBibleditProjectsDirPath();

	// Note: The code in MakeMenuInitializationsAndPlatformAdjustments() below was originally
	// called much earlier in OnInit(), but now that we have ConfigureInterfaceForUserProfile()
	// it makes better sense to do the menu modifications (mostly for the Mac) here at this
	// point in OnInit(). It also configures the initial state of the Administrator menu
	// according to the m_bShowAdministratorMenu flag set above.
	// whm Note: The following MakeMenuInitializationsAndPlatformAdjustments() need to occur
	// within OnInit() after the above m_collaborationEditor string has been assigned.
 	MakeMenuInitializationsAndPlatformAdjustments(collabIndeterminate);

	// whm 28Mar11 TESTING BELOW !!!
	// Test results. The ParatextShared.dll is a managed .NET dll and as such cannot be
	// loaded by the wxDynamicLibrary::Load() method.
	/*
	if (m_bParatextIsInstalled)
	{
		// try loading the managed code ParatextShared.dll
		if (wxGetWinVersion() >= wxWinVersion_5)
		{
			// Turn off system message "Failed to load shared library...(error 126: the specified
			// module could not be found", which pops up in idle time if following .Load() call
			// fails. We have our own message.
			wxLogNull logNo;	// eliminates any spurious messages from the system while
								// reading read-only folders/files
			bParatextSharedDLLLoaded = ptSharedDynamicLibrary.Load(PT_LIB_NAME);
			if (!ptSharedDynamicLibrary.IsLoaded())
			{
				// the ParatextShared.dll file was not found or could not be loaded
				bParatextSharedDLLLoaded = FALSE;
				wxString msg;
				// This error shouldn't happen with normal install, so it can remain in English
				msg = msg.Format(_T(
		"Could not find the %s dynamic library file. Paratext collaboration will not be available, however the rest of the application will work fine."),
				PT_LIB_NAME);
				wxMessageBox(msg,_T("File not found"),wxICON_INFORMATION);
			}
			else
			{
				bParatextSharedDLLLoaded = TRUE;
			}
		}

	}
	// whm 28Mar11 TESTING ABOVE !!!
	*/

	// Next, initialise the help system. We do it here because our m_setupFolder was
	// determined above and we now know the path to the setup folder where any help
	// file is installed.
    //
    // Determine the path to the installation folder where Adapt_It.xxx is located
    // Note: Our function FindAppPath() determined the most likely path where the
    // Adapt It executable program is located and stored it in m_setupFolder.

	wxString appName;
	appName = GetAppName();

	wxString helpFilePath,helpFileName;
    // Note: earlier in OnInit() m_helpInstallPath was determined in
    // GetDefaultPathForHelpFiles() which also determined the name stored in
    // m_htbHelpFileName.
	helpFilePath = m_helpInstallPath;
    // The file name stored in helpFileName below will be Adapt_It.htb for Windows;
    // adaptit.htb for Linux and AdaptIt.htb for Mac. The extension may be .zip, .htb or
    // .hhp when using wxHtmlHelpController
	helpFileName = m_htbHelpFileName;

#ifdef __WXGTK__
	// The call to m_pHelpController->Initialize() below will fail on wxGTK unless wxUSE-LIBMSPACK is 1
#ifndef wxUSE_LIBMSPACK
	wxLogDebug(_T("wxUSE_LIBMSPACK is NOT DEFINED! The MS Windows Adapt_It_Help.chm help file will not display properly."));
#endif
#endif

	helpFilePath = helpFilePath + PathSeparator + helpFileName;
	// Display message in status bar that we are initializing the help system
	message = message.Format(_("Initializing help system file %s..."),helpFilePath.c_str());
	pStatusBar->SetStatusText(message,0); // use first field 0

	wxLogDebug(_T("helpFilePath = %s"),helpFilePath.c_str());
	bool helpFileFound;
	helpFileFound = TRUE;
	if (!::wxFileExists(helpFilePath))
	{
		helpFileFound = FALSE;
		wxLogDebug(wxT("Cannot find .htb file at path: %s."),helpFilePath.c_str());
	}
    // whm note 27Dec08: apparently calling Addbook is sufficient to get the help system
    // initialized so we don't need to call Initialize() here
    if (!helpFileFound) // || !m_pHelpController->Initialize(helpFilePath) )
    {
        wxLogDebug(wxT("Cannot initialize the help system. Online help will not be available."));
    }

    // Get the text extent of the longest sfm represented in the input data. We only need
    // to scan the UsfmAndPng map since it has all the markers in it. For a pDC we've
    // already created our canvas within the Main Frame above, so we can use it, setting
    // the font to the App's m_pNavTextFont
	wxClientDC aDC(m_pMainFrame->canvas);
	wxFont tempFont = *m_pNavTextFont;
	tempFont.SetPointSize(12);
	aDC.SetFont(tempFont);
	sizeLongestSfm = GetExtentOfLongestSfm(&aDC); // sizeLongestSFM does not include
												  // any unknown markers
	aDC.GetTextExtent(_T(' '),&sizeSpace.x,&sizeSpace.y);

	// Set up the rapid access data strings for wrap markers, sectionHead markers,
	// inLine markers, and filter markers.
	SetupMarkerStrings();

    // gCurrentFilterMarkers is determined in SetupMarkerStrings above. We'll start with
    // gProjectFilterMarkersForConfig assigned gCurrentFilterMarkers's list of filter
    // markers; gProjectFilterMarkersForConfig may be changed once the config file is read
    // in
	gProjectFilterMarkersForConfig = gCurrentFilterMarkers;

	// Retain the initial USFM filter marker string as "Factory default"
	gFactoryFilterMarkersStr = UsfmFilterMarkersStr;
#ifdef __WXDEBUG__
	ShowFilterMarkers(1); // location 1
#endif
	gFactorySfmSet = UsfmOnly;

	// using PushEventHandler() here appears to be too early (there is no 'previous' event
	// handler yet), so try at end of OnInit()


	// Display message in status bar that startup initialization is complete
	message = _("Initialization complete. Call Start Working...");
	pStatusBar->SetStatusText(message,0); // use first field 0
    // we are passed all the MFC initialization stuff, and about to enter the Start
    // Working... wizard, so indicate it is safe for OnNewDocument() to be able to write
    // out the project config file once the user's setting for book mode is in place
	gbPassedAppInitialization = TRUE;

	// **** test code fragments here ****

	/* last test: March 9, 2011
	//int sizeofCStrip = sizeof(CStrip); // 48 bytes
	int sizeofCPile = sizeof(CPile); // 48 bytes
	int sizeofCCell = sizeof(CCell); // 28 bytes
	int sizeofCSourcePhrase = sizeof(CSourcePhrase); // 136 bytes
	int sizeofwxNode = sizeof(wxNode); // 24 bytes
	int sizeofwxString = sizeof(wxString); // 4 bytes
	int sizeofwxArrayInt = sizeof(wxArrayInt); // 12 bytes & its 16 int initial buffer is 4*16 = 64
	int sizeofwxArrayPtrVoid = sizeof(wxArrayPtrVoid); // 12 bytes
	int sizeofCLayout = sizeof(CLayout); // 272 bytes
	int sizeofCKB = sizeof(CKB); // 72 bytes (tested 9Mar11)
	int sizeofCRefString = sizeof(CRefString); // 28 bytes
	int sizeofCTargetUnit = sizeof(CTargetUnit); // 16 bytes
	int sizeofSPList = sizeof(SPList); // 28 bytes
	int sizeofwxArrayString = sizeof(wxArrayString); // 16 bytes
	int stophere = 1;
	*/
	/*
	// check what the character counts in GetUsfmStructureAndExtent(fileBuffer)
	// actually count, from some known data
	//wxString fileAndPath = _T("C:\\testdata.txt");
	//wxString fileAndPath = _T("C:\\Hez7_target_Filtered.txt");
	wxString fileAndPath = _T("C:\\Hez7_FreeTrans.txt");
	wxString fileBuffer;
	// now read the file into a buffer in preparation for analyzing their chapter and
	// verse status info (1:1:nnnn) using GetUsfmStructureAndExtent().
	// Note: The files produced by rdwrtp7.exe for projects with 65001 encoding (UTF-8) have a
	// UNICODE BOM of ef bb bf
	wxFile f(fileAndPath,wxFile::read);
	wxFileOffset fileLen;
	fileLen = f.Length();
	// read the raw byte data into pByteBuf (char buffer on the heap)
	char* pByteBuf = (char*)malloc(fileLen + 1);
	memset(pByteBuf,0,fileLen + 1); // fill with nulls
	f.Read(pByteBuf,fileLen);
	wxASSERT(pByteBuf[fileLen] == '\0'); // should end in NULL
	f.Close();
	fileBuffer = wxString(pByteBuf,wxConvUTF8,fileLen);
	free((void*)pByteBuf);
	wxArrayString arr;
	arr = GetUsfmStructureAndExtent(fileBuffer);
	int count = arr.GetCount();
	int index;
	for (index = 0; index < count; index++)
	{
		wxString s = arr.Item(index);
		//wxLogDebug(_T("Line  %d    String:   %s"), index, s.c_str());
		wxLogDebug(_T("   %s"), s.c_str());
	}
	arr.Clear();
	fileBuffer.Empty();
	*/
	//int ii = 1; ii = ii;
/*
	// This test compared with the same code under MFC shows that
	// simply moving the x (or MFC left coordinate) has different
	// effects: In MFC the widthrecafter increases by 3, whereas in
	// wxWidgets the widthrecafter stays the same, indicating that
	// when the MFC version moves the upper left point of a rect,
	// we must also adjust the rect width/height in wxWidgets.
	wxRect testrec = wxRect(5,5,10,10);
	int widthrecbefore = testrec.GetWidth();
	testrec.x -= 3;
	int widthrecafter = testrec.GetWidth();
	int endoftest = 1;

	wxString test,test2,test3,test4;
	//test = _T("This is\r\n a test string.\r\n");
	//test2 = _T("This is another\n test string.\n");
	test = _T("This is a test string.");
	test2 = _T("This is another test string.");
	//test += test2;
	test3 = _T("Finished. ");
	//test3 = test3 + test + test2;
	//test4 = test3 + test + test2;
	//test4.Shrink();
	//test4.append(test3);
	//test4.append(test);
	//test4.append(test2);
	test4 += test3;
	test4 += test;
	test4 += test2;
	int len = test4.Len();
	wxChar* pBuf = test4.GetWriteBuf(len + 1);
	wxChar* pEnd = pBuf + len;
	*pEnd = (wxChar)0;
	//wxASSERT(*pEnd == '\0');
	test3.UngetWriteBuf();
	//test = test + test2;
	//test += test2;
	//wxASSERT(test == *pBuf);
	int junk = 1;
*/
	/*
	// test InsertInString()
	wxString str0 = _T(""); // empty string
	wxString str1 = _T("1");
	wxString str2 = _T("12");
	wxString str3 = _T("1234567890");
	int psn0 = 0; // at beginning of string
	int psn1 = 10; // outside string bounds
	int psn2 = 9; // at end of string
	int psn3 = 5; // in middle of string
	wxString resultStr;
	resultStr = InsertInString(str0,psn0,str0);
	resultStr = InsertInString(str1,psn0,str0);
	resultStr = InsertInString(str2,psn0,str0);
	resultStr = InsertInString(str3,psn0,str0);
	resultStr = InsertInString(str0,psn1,str0);
	resultStr = InsertInString(str1,psn1,str0);
	resultStr = InsertInString(str2,psn1,str0);
	resultStr = InsertInString(str3,psn1,str0);
	resultStr = InsertInString(str0,psn2,str0);
	resultStr = InsertInString(str1,psn2,str0);
	resultStr = InsertInString(str2,psn2,str0);
	resultStr = InsertInString(str3,psn2,str0);
	resultStr = InsertInString(str0,psn3,str0);
	resultStr = InsertInString(str1,psn3,str0);
	resultStr = InsertInString(str2,psn3,str0);
	resultStr = InsertInString(str3,psn3,str0);

	resultStr = InsertInString(str0,psn0,str1);
	resultStr = InsertInString(str1,psn0,str1);
	resultStr = InsertInString(str2,psn0,str1);
	resultStr = InsertInString(str3,psn0,str1);
	resultStr = InsertInString(str0,psn1,str1);
	resultStr = InsertInString(str1,psn1,str1);
	resultStr = InsertInString(str2,psn1,str1);
	resultStr = InsertInString(str3,psn1,str1);
	resultStr = InsertInString(str0,psn2,str1);
	resultStr = InsertInString(str1,psn2,str1);
	resultStr = InsertInString(str2,psn2,str1);
	resultStr = InsertInString(str3,psn2,str1);
	resultStr = InsertInString(str0,psn3,str1);
	resultStr = InsertInString(str1,psn3,str1);
	resultStr = InsertInString(str2,psn3,str1);
	resultStr = InsertInString(str3,psn3,str1);

	resultStr = InsertInString(str0,psn0,str2);
	resultStr = InsertInString(str1,psn0,str2);
	resultStr = InsertInString(str2,psn0,str2);
	resultStr = InsertInString(str3,psn0,str2);
	resultStr = InsertInString(str0,psn1,str2);
	resultStr = InsertInString(str1,psn1,str2);
	resultStr = InsertInString(str2,psn1,str2);
	resultStr = InsertInString(str3,psn1,str2);
	resultStr = InsertInString(str0,psn2,str2);
	resultStr = InsertInString(str1,psn2,str2);
	resultStr = InsertInString(str2,psn2,str2);
	resultStr = InsertInString(str3,psn2,str2);
	resultStr = InsertInString(str0,psn3,str2);
	resultStr = InsertInString(str1,psn3,str2);
	resultStr = InsertInString(str2,psn3,str2);
	resultStr = InsertInString(str3,psn3,str2);

	resultStr = InsertInString(str0,psn0,str3);
	resultStr = InsertInString(str1,psn0,str3);
	resultStr = InsertInString(str2,psn0,str3);
	resultStr = InsertInString(str3,psn0,str3);
	resultStr = InsertInString(str0,psn1,str3);
	resultStr = InsertInString(str1,psn1,str3);
	resultStr = InsertInString(str2,psn1,str3);
	resultStr = InsertInString(str3,psn1,str3);
	resultStr = InsertInString(str0,psn2,str3);
	resultStr = InsertInString(str1,psn2,str3);
	resultStr = InsertInString(str2,psn2,str3);
	resultStr = InsertInString(str3,psn2,str3);
	resultStr = InsertInString(str0,psn3,str3);
	resultStr = InsertInString(str1,psn3,str3);
	resultStr = InsertInString(str2,psn3,str3);
	resultStr = InsertInString(str3,psn3,str3);
*/
	/*
	// Testing wxCheckListBox class
	wxPanel *m_panel;
    m_panel = new wxPanel(m_pMainFrame, wxID_ANY, wxPoint(0, 0),
                          wxSize(400, 200), wxTAB_TRAVERSAL);
	wxCheckListBox *m_pListBox;
	long flags = 0;
	// check list box
    static const wxChar *aszChoices[] =
    {
        _T("Zeroth"),
        _T("First"), _T("Second"), _T("Third"),
        _T("Fourth"), _T("Fifth"), _T("Sixth"),
        _T("Seventh"), _T("Eighth"), _T("Nineth")
    };

    wxString *astrChoices = new wxString[WXSIZEOF(aszChoices)];
    unsigned int ui;
    for ( ui = 0; ui < WXSIZEOF(aszChoices); ui++ )
        astrChoices[ui] = aszChoices[ui];

    m_pListBox = new wxCheckListBox
        (
         m_panel,               // parent
         -1,       // control id
         wxPoint(10, 10),       // listbox poistion
         wxSize(400, 100),      // listbox size
         WXSIZEOF(aszChoices),  // number of strings
         astrChoices,           // array of strings
         flags
        );

    //m_pListBox->SetBackgroundColour(*wxGREEN);

    delete [] astrChoices;

    // set grey background for every second entry
    for ( ui = 0; ui < WXSIZEOF(aszChoices); ui += 2 )
	{
        //AdjustColour(ui);
     // even items have grey backround, odd ones - white
      unsigned char c = ui % 2 ? 255 : 200;
      m_pListBox->GetItem(ui)->SetBackgroundColour(wxColor(c, c, c));
   }

    m_pListBox->Check(2);
    m_pListBox->Select(3);
	*/

/*
	CString bookIDStr;
	CString docPath =
	_T("C:\\Documents and Settings\\watersb\\My Documents\\Adapt It Unicode Work\\Takia to English adaptations\\Adaptations\\1Timothy.xml");
	bool isOK = FileContainsBookIndicator(docPath,bookIDStr);
	int yes = 1;
*/
	/*
	CString str = "something \\fr ";
	int len = str.GetLength();
	TCHAR* pBuff = str.GetBuffer(len+1);
	TCHAR* ptr = pBuff + len;
	int mkrlen;
	BOOL bWorked = GetView()->GetPrevMarker(pBuff,ptr,mkrlen);
	str.ReleaseBuffer();
	*/
/*
	CString sss = _T("\r\n ab\r\n ");
	CString xStr;
	xStr = Trim(sss,_T(" \r\n"));
*/
/*
#include "XML.h"
#include "BString.h"
CBString mybstr = "<<Tamol";
InsertEntities(mybstr);
ReplaceEntities(mybstr);
*/
/*
CSourcePhrase src;
src.m_bFootnote = TRUE;
src.m_bHasKBEntry = TRUE;
src.m_bHasFreeTrans = TRUE;
src.m_bStartFreeTrans = TRUE;
src.m_bEndFreeTrans = TRUE;
CBString bstr = MakeFlags(&src);
CString ss = (char*)bstr;
TRACE1("\n 22 digits = %s\n",ss);
bstr.Empty();
char numStr[24];
itoa(1524471,numStr,10);
bstr += numStr;
ss = (char*)bstr;
TRACE1("\n fewer digits (base 10) = %s\n",ss);
*/

/*
CString str( "%First Second#Third" );
CString resToken;
int curPos= 0;

resToken= str.Tokenize("% #",curPos);
while (resToken != "")
{
   //printf("Resulting token: %s\n", resToken);
   resToken= str.Tokenize("% #",curPos);
};
*/

/*	CString start;
	start.Format(IDS_MANUAL_FIXES_REFS);
	CString fixesStr = "23:1   ";
	fixesStr = start + fixesStr;
	for (int i = 2; i < 600; i++)
	{
		CString next = "23:";
		char pStr[10];
		_itoa(i,pStr,10);
		next += pStr;
		next += "   ";
		fixesStr += next;
	}
	int len = fixesStr.GetLength();
	CString path = gpApp->m_curProjectPath;
	path += _T('\\');
	path += _T("Rebuild Log.txt");
	CFile fout;
	CFileException error;
	BOOL bOK = fout.Open( path, CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive,&error);
	fout.Write((LPCTSTR)fixesStr,len);
	fout.Close();
	if (len > 1200)
	{
		// trim the excess and add the string telling user to check visually
		fixesStr = fixesStr.Left(1200);
		fixesStr.MakeReverse();
		int nFound = fixesStr.Find(_T(' '));
		if (nFound != -1)
		{
			fixesStr = fixesStr.Mid(nFound);
		}
		fixesStr.MakeReverse();
		CString appendStr;
		appendStr.Format(IDS_APPEND_MSG);
		fixesStr += appendStr;
	}
	AfxMessageBox(fixesStr,MB_ICONINFORMATION);
	ASSERT(FALSE);
*/
/* for docVersion 5
wxString mkr;
wxString endMkr;
wxString content;
wxString filtered = _T("\\f + This is a footnote. \\f*");
ParseMarkersAndContent(filtered, mkr, content, endMkr);
int ii = 1;
*/

/*
// test UUID generation
	wxString anUuid;
	int i;
	for (i = 1; i<20; i++)
	{
		anUuid.Empty();
		Uuid_AI* pUuidGen = new Uuid_AI(); // generates the UUID
		aUuid = pUuidGen->GetUUID(); // gets it as "hhhhhhhh-hhhh-hhhh-hhhh-hhhhhhhhhhhh" (32 hex digits plus 4 hyphens = total 36 chars)
		delete pUuidGen;
		wxLogDebug(_T("UUID =    %s"), anUuid);

	}
*/

// test getting current date-time in format "year:month:day hours:minutes:seconds"
//wxString dt = GetDateTimeNow();

// test GetWho() in helpers.cpp
//wxString str = GetWho();

// test IsLoadableFile() in helpers.cpp
//wxString aPath = _T("C:\\Card1\\biggie.xml");
//wxString aPath = _T("C:\\Card1\\binaryfile");
//wxString aPath = _T("C:\\Card1\\Heztext");
//wxString aPath = _T("C:\\Card1\\Hezdocxml");
//bool bIsLoadable = IsLoadableFile(aPath);
//bIsLoadable = bIsLoadable;

//wxString testStr =  _T(" First?! second, third:  fourth?");
//wxString testStr = _T(" First?;~second: "); // test fixedSpace symbol
//GetView()->RemovePunctuation(GetDocument(),&testStr,1);


#if wxMAC_USE_CORE_GRAPHICS
	wxLogDebug(_T("In OnInit() wxMAC_USE_CORE_GRAPHICS is defined!"));
	if (m_pMainFrame->canvas->IsDoubleBuffered())
		wxLogDebug(_T("This wxScrolledWindow is double-buffered by the system."));
#endif

	// set these back to 0 and -1 when the phrase box location changes, after storage to
	// the KB has been done
	m_nPlacePunctDlgCallNumber = 0; // incrememted each time MakeTargetStringIncludingPunctuation() is
									// called from within StoreText()
	m_nCurSequNum_ForPlacementDialog = -1; // -1 is default, it means "undefined"

	m_bMatchedRetranslation = FALSE;
	m_bJustLaunched = TRUE;// set false in OnIdle call
	m_bExportingGlossesAsText = FALSE;   // set TRUE during export of glosses
	m_bExportingFreeTranslation = FALSE; // set TRUE during export of free translations

	m_bSkipBasicConfigFileCall = FALSE; // ensure it is returned to default FALSE

	// override the default for m_bDrafting if the frm switch was found
	if (m_bForce_Review_Mode)
	{
		m_bDrafting = FALSE; // turn review mode on

		// hide the radio buttons
		CMainFrame *pFrame = GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxPanel* pControlBar;
		pControlBar = pFrame->m_pControlBar;
		wxASSERT(pControlBar);
		wxRadioButton* pDraftingBtn =
			(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_DRAFTING);
		// whm 12Oct10 modified below to make safe for user workflow profiles
		if (pDraftingBtn != NULL)
		{
			pDraftingBtn->Hide();
		}
		wxRadioButton* pReviewingBtn =
			(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_REVIEWING);
		if (pReviewingBtn != NULL)
		{
			pReviewingBtn->Hide();
		}
	}
	else if (m_bAutoExport)
	{
		// BEW added 12Nov09, do the auto-export here, if asked for, and shut
		// down the app before returning; otherwise, continue for normal user
		// GUI interaction...
		// What we do here is bypass the Startup Wizard, calling OnOpenDocument()
		// and passing in the absolute path to the document - after setting up
		// a few string member variables (for filenames and paths) that would
		// otherwise have been set up from using the wizard - such as the project
		// folder name, the project folder path, and so forth. (Then in OnOpenDocument()
		// at the end of it we have another test of m_bAutoExport, and in its block
		// we do the export and shut the app down.)
		wxString fullPath;
		m_curProjectName = m_autoexport_projectname;
		m_curProjectPath = m_workFolderPath + PathSeparator + m_curProjectName;
		//m_sourceInputsFolderPath = m_curProjectPath + PathSeparator + m_sourceInputsFolderName;
		//m_freeTransOutputsFolderPath = m_curProjectPath + PathSeparator + m_freeTransOutputsFolderName;
		//m_freeTransRTFOutputsFolderPath = m_curProjectPath + PathSeparator + m_freeTransRTFOutputsFolderName;
		//m_glossOutputsFolderPath = m_curProjectPath + PathSeparator + m_glossOutputsFolderName;
		//m_glossRTFOutputsFolderPath = m_curProjectPath + PathSeparator + m_glossRTFOutputsFolderName;
		//m_interlinearRTFOutputsFolderPath = m_curProjectPath + PathSeparator + m_interlinearRTFOutputsFolderName;
		//m_sourceOutputsFolderPath = m_curProjectPath + PathSeparator + m_sourceOutputsFolderName;
		//m_sourceRTFOutputsFolderPath = m_curProjectPath + PathSeparator + m_sourceRTFOutputsFolderName;
		//m_targetOutputsFolderPath = m_curProjectPath + PathSeparator + m_targetOutputsFolderName;
		//m_targetRTFOutputsFolderPath = m_curProjectPath + PathSeparator + m_targetRTFOutputsFolderName;
		//m_kbInputsAndOutputsFolderPath = m_curProjectPath + PathSeparator + m_kbInputsAndOutputsFolderName;
		//m_liftInputsAndOutputsFolderPath = m_curProjectPath + PathSeparator + m_liftInputsAndOutputsFolderName;

		m_curAdaptionsPath = m_curProjectPath + PathSeparator + m_adaptionsFolder;
		fullPath = m_curAdaptionsPath + PathSeparator + m_autoexport_docname;
		GetDocument()->OnOpenDocument(fullPath);
	}
	m_bControlIsWithinOnInit = FALSE;


	//GDLC 2010-02-12
	// Create the free translation display handler
	m_pFreeTrans = new CFreeTrans(this);
	// push it on to the stack of window event handlers (otherwise, it won't receive events)
	GetView()->canvas->pFrame->PushEventHandler(m_pFreeTrans);

	m_pNotes = new CNotes(this);
	// push it on to the stack of window event handlers (otherwise, it won't receive events)
	GetView()->canvas->pFrame->PushEventHandler(m_pNotes);

	m_pRetranslation = new CRetranslation(this);
	// push it on to the stack of window event handlers (otherwise, it won't receive events)
	GetView()->canvas->pFrame->PushEventHandler(m_pRetranslation);

	m_pPlaceholder = new CPlaceholder(this);
	// push it on to the stack of window event handlers (otherwise, it won't receive events)
	GetView()->canvas->pFrame->PushEventHandler(m_pPlaceholder);

	wxASSERT(m_pRetranslation);
	m_pRetranslation->SetSuppressRemovalOfRefString(FALSE); // must start off FALSE, otherwise
			// it will suppress the mechanism for decrementing the m_refCount value, etc, if
			// the box is made to land on a non-hole

    // BEW added 19Apr for Save As... support. The document version will henceforth be
    // parameterized. The doc class now has a private int member, m_docVersionCurrent which
    // is used for constructing the XML for doc and KB which has the docVersion parameter
    // value; and the Save As... dialog now lets the user choose to save in doc versions 5
    // (the default, the combo box has index 0 for this value), or 4 (the combobox has
    // index 1 for this value). 5 is the current value of VERSION_NUMBER which is #defined
    // in AdaptitConstants.h, and DOCVERSION4 is there #defined as 4. To set or restore the
    // current version number, call the public doc function:
    // RestoreCurrentDocVersion(), which restores m_docVersionCurrent to VERSION_NUMBER. To
    // set some other version number (currently, only version number 4 is supported), call
    // the doc public function SetDocVersion(int index), which returns void. The index
    // parameter is the value returned from the Save As... dialog's combobox for document
    // type (0 is always mapped to the current value of VERSION_NUMBER, and 1 is always
    // mapped to DOCVERSION4. (If later we have a docVersion 6, 5 would be assigned to a
    // DOCVERSION5 new #define, and VERSION_NUMBER would become 6, and the Save As...
    // dialog would then have 3 options for saving.) Use GetCurrentDocVersion() to return
    // whatever is the current value of m_docVersionCurrent. So set the current value:
    //
	GetDocument()->RestoreCurrentDocVersion(); // currently, sets a value of 5

	m_pNavProtectDlg = NULL; // it's created on heap just before being shown, in OnNewDocument()
	m_sortedLoadableFiles.Clear(); // used to get the list of filenames into the above dialog

	// add oxes support here, the creator will call an initializing function to have oxes
	// export support ready for whenever it is needed; m_pUsfm2Oxes is destroyed in OnExit()
	//
	// BEW temporarily (or permanently?) deprecated 15Jun11, until need for OXES support
	// is clarified and there is some other app 'out there' that could benefit from AI
	// supporting an OXES export
	//m_pUsfm2Oxes = new Usfm2Oxes(this);

	// Add Guesser support here. m_pAdaptationsGuesser and m_pGlossesGuesser are destroyed in OnExit()
	m_pAdaptationsGuesser = new Guesser;
	m_pGlossesGuesser = new Guesser;

	CAdapt_ItView* pView = (CAdapt_ItView*) GetView();
	pView->m_pDoc = GetDocument(); // BEW added m_pDoc to CAdapt_ItView on 14Nov11

/* Nah, the "Debugger (debug)" log window collects all the wxLogDebug() returns in CodeBlocks IDE
#if defined(__WXDEBUG__) && defined(__WXGTK__)
    // we need a Debug Log window created (put a forward declaration for class wxLogDebug in Adapt_It.h too)
	wxFrame* pLogFrame;
	wxLogWindow* m_pLogWindow = new wxLogWindow(GetMainFrame()->canvas,wxT("Debug Log"),true,true);
    pLogFrame = m_pLogWindow->GetFrame();
	pLogFrame->SetWindowStyle(wxDEFAULT_FRAME_STYLE | wxSTAY_ON_TOP);
	//pLogFrame->SetSize( wxRect(0,900,1600,200));
	pLogFrame->SetSize( wxRect(0,900,160,200));
	wxLog::SetActiveTarget(m_pLogWindow);
#endif
*/

	// support Mike's testing of DVCS work (inspired by Chorus) (TEST_DVCS is #defined at line 25 of Adapt_It.h)
#if defined(TEST_DVCS) && defined(__WXDEBUG__)

	wxMenuBar* pAIMenuBar = NULL;
	pAIMenuBar = GetMainFrame()->m_pMenuBar; // pointer to the frame's current menu bar
	int nIndexOfEditMenu = pAIMenuBar->FindMenu(_T("Edit"));
	wxASSERT(nIndexOfEditMenu != wxNOT_FOUND);
	wxMenu* pEditMenu = pAIMenuBar->GetMenu(nIndexOfEditMenu);

	pEditMenu->AppendSeparator();

	pEditMenu->Append (ID_MENU_DVCS_VERSION, _T("DVCS version"));								// defaults for final 2 params
	pEditMenu->Append (ID_MENU_INIT_REPOSITORY, _T("Set up version control"));					// ditto
	pEditMenu->Append (ID_MENU_DVCS_ADD_FILE, _T("Put this file under version control"));		// ditto
	pEditMenu->Append (ID_MENU_DVCS_ADD_ALL_FILES, _T("Put all project files under version control"));
	pEditMenu->Append (ID_MENU_DVCS_REMOVE_FILE, _T("Remove this file from version control (file won't be deleted)"));
	pEditMenu->Append (ID_MENU_DVCS_REMOVE_PROJECT, _T("Remove project from version control (files won't be deleted)"));
	pEditMenu->Append (ID_MENU_DVCS_COMMIT_FILE, _T("Commit changes to this file"));			// ditto
	pEditMenu->Append (ID_MENU_DVCS_COMMIT_PROJECT, _T("Commit all changes to the current project"));
	pEditMenu->Append (ID_MENU_DVCS_LOG_FILE, _T("Show version log for this file"));			// ditto
	pEditMenu->Append (ID_MENU_DVCS_LOG_PROJECT, _T("Show version log for whole project"));		// ditto
	pEditMenu->Append (ID_MENU_DVCS_REVERT_FILE, _T("Revert this file to previous revision"));	// ditto

#endif
	// end of code for supporting Mike's DVCS work

	//klb test
	//bool a = ParatextIsRunning();

	//wxLogDebug(_T("At end of app's member function OnInit(), m_bCancelAndSelectButtonPressed = %d"),
	//	m_pTargetBox->GetCancelAndSelectFlag());
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return   nothing
/// \remarks
/// Called from: the App's OnExit(). The function is a misnomer, because all the function
/// does is call WriteConfigurationFile() to save the basic configuration file.
/// BEW modified 19Aug09 for support of administrator access to custom work folder
/// locations
///////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::Terminate()
{
	bool bOK;
	if (m_bUseCustomWorkFolderPath && !m_customWorkFolderPath.IsEmpty())
	{
		// BEW 17Sep09, must save using what paths are current, but when the custom
		// location has been locked in, the filename lacks "Admin" in it, so that it
		// becomes a "normal" basic configuration file at the custom location
		if (m_bLockedCustomWorkFolderPath)
			bOK = WriteConfigurationFile(szBasicConfiguration, m_customWorkFolderPath,basicConfigFile);
		else
			bOK = WriteConfigurationFile(szAdminBasicConfiguration, m_workFolderPath,basicConfigFile);
		wxCHECK_RET(bOK, _T("Terminate(): WriteConfigurationFile() returned FALSE, line 18,009 or 18011"));
	}
	else
	{
		bOK = WriteConfigurationFile(szBasicConfiguration, m_workFolderPath,basicConfigFile);
		wxCHECK_RET(bOK, _T("Terminate(): WriteConfigurationFile() returned FALSE, line 18,016"));
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return   the maximum index for the CSourcePhrases in the m_pSourcePhrases list
/// \remarks
/// created 21Mar09 to replace the now deprecated m_maxIndex app member
////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::GetMaxIndex()
{
	// whm modified 19Feb12 to prevent crash if m_pSourcePhrases is NULL
	if (m_pSourcePhrases != NULL)
		return m_pSourcePhrases->GetCount() - 1;
	else
		return 0;
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return     always zero (0)
/// \remarks
/// Called from: the wxApp object just before it exits and returns control back to the
/// system. All cleanup of allocated memory needs to be done here if not already done
/// elsewhere in the application. OnExit() is called after destroying all application
/// windows and controls, but before wxWidgets cleanup. Note that it is not called at all
/// if OnInit() failed.
///////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::OnExit(void)
{
    // OnExit() "is called when the application exits, but before wxWidgets cleans up its
    // internal structures. All wxWidgets' objects that the program creates should be
    // deleted by the time OnExit() finishes. In particular, do NOT destroy them from the
    // application class destructor!"

	// BEW 1Mar10: it turns out that one or all of view, canvas or frame are undefined at
	// this point, and so the call to PopEventHandler() can't be made here. But I also
	// found out that not making the call does not leak memory, and presumably wxWidgets
	// itself cleans up what is on its event stack, so we don't need to do it here
	// ourselves. (Next 6 lines of comments now don't apply)
	// Our "new" classes need to have their event tables popped off the stack of windows
	// event handlers - so do them in reverse order in which they were pushed.
	// (Alternatively, we could pass the param TRUE to the pop call, and then the pop will
	// do the class instance deletion from the heap for us. Do that if we ever suspect the
	// order below is not correct, and remove our explicit delete statements, and add the
	// appropriate casts on the RHS and the appropriate class pointer on the left.)
	//
	// The push order is so far:
	// 1. CFreeTrans
	// 2. CNotes
	// 3.
	//wxEvtHandler* pHdlr = NULL;

	// delete the Guesser objects
	if (m_pAdaptationsGuesser != NULL)
		delete m_pAdaptationsGuesser;
	if (m_pGlossesGuesser != NULL)
		delete m_pGlossesGuesser;

	// delete the object for support of oxes  BEW removed 15Jun11 until OXES support is needed
	//delete m_pUsfm2Oxes;

	// delete the CNotes object
	delete m_pNotes;

	// delete the CRetranslation object
	delete m_pRetranslation;

	// delete the CPlaceholder object
	delete m_pPlaceholder;

	//GDLC Added 2010-02-12
	// Delete the CFreeTrans manager after popping its event table off the stack of
	// windows event handlers
	//pHdlr = GetView()->canvas->pFrame->PopEventHandler(); // default param is FALSE
								// (meaning that we'll do the deleting ourselves)
	delete m_pFreeTrans;

	delete m_pROP; // delete the ReadOnlyProtection class's only instance
	m_pROPwxFile->Close(); // may already be closed, but no harm in the call even so
	delete m_pROPwxFile; // delete the wxFile object on the heap for support of an
						 // open read-only protection file of form
						 // ~AIRIOP-machinename-username.lock while the owning user
						 // has a project folder open (on this or a remote machine)

	m_pDocManager->FileHistorySave(* m_pConfig);

	// whm 31Jan12 initialized bOK to TRUE and added else if test for content in
	// m_curProjectPath. If on first run of the app, user cancels out of wizard and
	// immediately exits the app, there will not be any m_curProjectPath established.
	// Without these modifications the wxCHECK_MSG would trip and give a cryptic
	// message to the user.
	bool bOK = TRUE; // we won't care whether it succeeds or not, since the later
			  // Get... can use defaults
	// WriteConfigurationFile projectConfigFile forces write of project config info
	if (!m_bAutoExport)
	{
		// only write the project config file if we are not doing a command line export
		if (m_bUseCustomWorkFolderPath && !m_customWorkFolderPath.IsEmpty())
		{
			// whm 10Mar10, must save using what paths are current, but when the custom
			// location has been locked in, the filename lacks "Admin" in it, so that it
			// becomes a "normal" project configuration file in m_curProjectPath at the
			// custom location.
			if (m_bLockedCustomWorkFolderPath)
				bOK = WriteConfigurationFile(szProjectConfiguration, m_curProjectPath,projectConfigFile);
			else
				bOK = WriteConfigurationFile(szAdminProjectConfiguration, m_curProjectPath,projectConfigFile);
		}
		else if (!m_curProjectPath.IsEmpty()) // whm added 31Jan12 test for empty m_curProjectPath
		{
			bOK = WriteConfigurationFile(szProjectConfiguration, m_curProjectPath,projectConfigFile);
		}
		wxCHECK_MSG(bOK, 0, _T("OnExit(): WriteConfigurationFile() returned FALSE, either project one or admin project one"));
		// below is original
		//if (::wxDirExists(m_curProjectPath))
		//{
		//	bOK = WriteConfigurationFile(szProjectConfiguration,m_curProjectPath,projectConfigFile);
		//}
	}
    // clean up the help system
	delete m_pHelpController;
	m_pHelpController = (wxHtmlHelpController*)NULL;
	delete wxHelpProvider::Set(NULL);

	// call Terminate to get the app level 1 basic configuration file updated
	if (!m_bAutoExport)
	{
		// only write the basic config file if we are not doing a command line export
		Terminate();
	}

    // WX Note: Our TargetBox is now a child of the view's canvas (which itself is derived
    // from wxScrolledWindow. As a child of the canvas window, m_pTargetBox will be
    // automatically destroyed when pView->canvas is destroyed during doc/view's normal
    // cleanup. That is, when our View is destroyed, all child windows (including our
    // target box) are automatically destroyed too. Therefore, the target box must not be
    // deleted again in the App's OnExit() method, when the App terminates.
	//delete m_pTargetBox;
	//m_pTargetBox = (CPhraseBox*)NULL;

	delete m_pConfig;
	m_pConfig = (wxFileConfig*)NULL;

	if (m_pChecker)
	{
		delete m_pChecker;
		m_pChecker = (wxSingleInstanceChecker*)NULL;
	}
	if (m_pServer)
	{
		delete m_pServer;
		m_pServer = (AI_Server*)NULL;
	}

	delete m_pParser;
	m_pParser = (wxCmdLineParser*)NULL;
	//delete m_pParser2; // BEW added 11Nov09
	//m_pParser2 = (wxCmdLineParser*)NULL;

	delete m_pSourceFont;
	m_pSourceFont = (wxFont*)NULL;
	delete m_pTargetFont;
	m_pTargetFont = (wxFont*)NULL;
	delete m_pNavTextFont;
	m_pNavTextFont = (wxFont*)NULL;
	delete m_pDlgSrcFont;
	m_pDlgSrcFont = (wxFont*)NULL;
	delete m_pDlgTgtFont;
	m_pDlgTgtFont = (wxFont*)NULL;
	delete m_pComposeFont;
	m_pComposeFont = (wxFont*)NULL;
	delete m_pDlgGlossFont;
	m_pDlgGlossFont = (wxFont*)NULL;
	delete m_pRemovalsFont;
	m_pRemovalsFont = (wxFont*)NULL;
	delete m_pVertEditFont;
	m_pVertEditFont = (wxFont*)NULL;

	delete m_pSrcFontData;
	m_pSrcFontData = (wxFontData*)NULL;
	delete m_pTgtFontData;
	m_pTgtFontData = (wxFontData*)NULL;
	delete m_pNavFontData;
	m_pNavFontData = (wxFontData*)NULL;

	delete pPgSetupDlgData;
	pPgSetupDlgData = (wxPageSetupDialogData*)NULL;
	delete pPrintData;
	pPrintData = (wxPrintData*)NULL;

	if (gpDocList != NULL)
	{
		// delete the object, it's contents should already have been removed
		delete gpDocList;
		gpDocList = (SPList*)NULL;
	}

	// In wxWidgets we've moved all the doc's data members to the App
	// The following is from the MFC's CAdapt_ItDoc::~CAdapt_ItDoc() destructor:
	if (m_pSourcePhrases != 0)
	{
		delete m_pSourcePhrases;
		m_pSourcePhrases = (SPList*)NULL;
	}

	if (m_pBuffer != 0)
	{
		delete m_pBuffer;
		m_pBuffer = (wxString*)NULL;
	}

	// wxWidgets docs say not to do cleanup in the App class destructor
	// The following from the MFC's CAdapt_ItApp::~CAdapt_ItApp() destructor:
	m_nTotalBooks = m_pBibleBooks->GetCount(); //m_nTotalBooks = m_pBibleBooks->GetSize();
	if (m_nTotalBooks == 0L)
	{
		delete m_pBibleBooks;
	}
	else
	{
		for (int i = 0; i < m_nTotalBooks; i++)
		{
			BookNamePair* pPair =  (BookNamePair*)(*m_pBibleBooks)[i];
			if (pPair)
				delete pPair;
		}
		delete m_pBibleBooks;
	}

	// whm added 19Jan05 AI_USFM.xml file processing and USFM Filtering
	wxString key;
	USFMAnalysis* pSfm;
	// destroy all USFMAnalysis objects and the CPtrArray pointing to them
	if (m_pMappedObjectPointers->GetCount() > 0)
	{
		// destroy the USFMAnalysis objects on the heap
		for (int upos = 0; upos < (int)m_pMappedObjectPointers->GetCount(); upos++)
		{
			pSfm = (USFMAnalysis*)m_pMappedObjectPointers->Item(upos);
			if (pSfm)
				delete pSfm;
		}
		// destroy all keys from CPtrArray
		m_pMappedObjectPointers->Clear();
		// destroy the CPtrArray itself
	}
	delete m_pMappedObjectPointers;

	// USFMAnalysis objects are destroyed, now destroy the map keys and
	// maps themselves
	if (m_pUsfmStylesMap->size() > 0) //if (m_pUsfmStylesMap->GetCount() > 0)
	{
		// destroy all Usfm key/object associations
		m_pUsfmStylesMap->clear(); //m_pUsfmStylesMap->Clear();
	}
	// destroy the Usfm map itself
	delete m_pUsfmStylesMap;

	if (m_pPngStylesMap->size() > 0)
	{
		// destroy all Png key/object associations
		m_pPngStylesMap->clear();
	}
	// destroy the Png map itself
	delete m_pPngStylesMap;

	if (m_pUsfmAndPngStylesMap->size() > 0)
	{
		// destroy all UsfmAndPng key/object associations
		m_pUsfmAndPngStylesMap->clear();
	}
	// destroy the UsfmAndPng map itself
	delete m_pUsfmAndPngStylesMap;

	// destroy the allocated memory in m_pUserProfiles. This is a single
	// instance of the UserProfiles struct that was allocated on the heap. Note
	// that m_pUserProfiles also contains a list of pointers in its
	// profileItemList member that point to UserProfileItem instances on the
	// heap.
	DestroyUserProfiles(m_pUserProfiles);
	// also destroy the allocated memory in m_pFactoryUserProfiles. This is a single
	// instance of the UserProfiles struct that was allocated on the heap. Note
	// that m_pFactoryUserProfiles also contains a list of pointers in its
	// profileItemList member that point to UserProfileItem instances on the
	// heap.
	DestroyUserProfiles(m_pFactoryUserProfiles);

	if (m_pEmailReportData != NULL)
		delete m_pEmailReportData;

	DestroyMenuStructure(m_pAI_MenuStructure);

	if (m_userLogFile != NULL)
	{
		LogUserAction(_T("AppShutDown"));
		m_userLogFile->Close();
		delete m_userLogFile;
	}

	int aTot;
	aTot = m_pRemovedMenuItemArray->GetCount();
	if (aTot == 0L)
	{
		delete m_pRemovedMenuItemArray;
	}
	else
	{
		int aIndex;
		for (aIndex = 0; aIndex < aTot; aIndex++)
		{
			wxMenuItem* mItem = (wxMenuItem*)(*m_pRemovedMenuItemArray)[aIndex];
			delete mItem;
		}
		delete m_pRemovedMenuItemArray;
	}

	aTot = m_pArrayOfCollabProjects->GetCount();
	if (aTot == 0L)
	{
		delete m_pArrayOfCollabProjects;
	}
	else
	{
		int aIndex;
		for (aIndex = 0; aIndex < aTot; aIndex++)
		{
			Collab_Project_Info_Struct* pArrayItem = (Collab_Project_Info_Struct*)(*m_pArrayOfCollabProjects)[aIndex];
			delete pArrayItem;
		}
		m_pArrayOfCollabProjects->Clear();
		delete m_pArrayOfCollabProjects;
	}

	// whm: before deleting our CConsistentChanger objects, we need to
	// free up the memory used by the structures within CCCModule.
	int ct;
	for (ct = 0; ct < 4; ct++)
	{
		if (m_pConsistentChanger[ct] != NULL && m_bCCTableLoaded[ct])
		{
			delete m_pConsistentChanger[ct];
			m_pConsistentChanger[ct] = (CConsistentChanger*)NULL;
		}
	}

	if (m_pLocale)
	{
		delete m_pLocale;
		m_pLocale = (wxLocale*)NULL;
	}

	if (m_pLayout)
	{
        // add code here to ensure the CLayout's lists are cleared before deleting it, we
        // don't want to leak memory
		m_pLayout->DestroyStrips(); // destroys each strip and the memory involved with
									// their m_arrPiles & m_arrPileOffsets arrays (these
									// are both wxArrayInt arrays)
		m_pLayout->DestroyPiles();	// destroys each pile in m_pLayout's m_pPiles lists,
									// and the CCell instances that each pile owns
		delete m_pLayout;
	}

	// BEW added 12Nov09, for support of auto export from the command line
	if (m_bAutoExport)
	{
		// try shut down by deleting the top window, which also halts the event loop
		m_bAutoExport = FALSE;
		//ExitMainLoop();
		delete GetTopWindow();
	}
	else
	{
		// can't do this from a call of OnExit() from OnOpenDocument() without it
		// asking if I want to save the document because it is changed, so I moved
		// this to the end, and we do it only if not auto exporting
		delete m_pDocManager; // deleting this
		m_pDocManager = (wxDocManager*)NULL;
	}

	return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnInit() and from the App's SetDefaults() if the user holds the
/// shift key down during startup, or if there is no existing configuration files.
/// InitializeFonts() handles the initial creation of all the fonts used in the
/// application, including m_pSourceFont, m_pTargetFont, m_pNavTextFont, m_pDlgSrcFont,
/// m_pDlgTgtFont, m_pDlgGlossFont, m_pComposeFont, m_pRemovalsFont, and m_pVertEditFont.
/// It then sets a suitable default encoding if the ANSI build is running. It then creates
/// corresponding wxFontData objects on the heap for the created fonts, and sets default
/// point sizes, weights, and colors for the created fonts.
/// It then updates the fontInfo structs which function as an MFC compatibility structure
/// for saving the font data in the configuration files.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::InitializeFonts()
{
    // In the wx version, the original Initialize() function is reworked into individual
    // files more specific to the kind of initializations being done (all called from
    // OnInit()). Individual functions that do initialization tasks are now called
    // InitializeFonts(); InitializePunctuation(); and GetConfigurationFileData().
	/*
	whm notes concerning 8-bit font encodings (non-Unicode):
	The MFC LOGFONT.lfCharset is defined as a byte value which has the following predefined values for
	the character set (encoding?) under Windows:

	MFC Symbol:		Byte Value
	==========================
	ANSI_CHARSET		0
	DEFAULT_CHARSET		1
	MFC docs say about DEFAULT_CHARSET on Windows 95/98/Me: You can use the DEFAULT_CHARSET value to allow
	the name and size of a font to fully describe the logical font. If the specified font name does not
	exist, a font from any character set can be substituted for the specified font, so you should use
	DEFAULT_CHARSET sparingly to avoid unexpected results.
	MFC docs say about DEFAULT_CHARSET on Windows NT/2000/XP: DEFAULT_CHARSET is set to a value based on the
	current system locale. For example, when the system locale is English (United States), it is set as
	ANSI_CHARSET 0.

	SYMBOL_CHARSET		2  [N/A IN WX]
	MAC_CHARSET			77
	SHIFTJIS_CHARSET	128
	HANGUL_CHARSET		129
	JOHAB_CHARSET		130 Korean language edition of Windows [N/A IN WX]
	GB2312_CHARSET		134
	CHINESEBIG5_CHARSET	136
	GREEK_CHARSET		161
	TURKISH_CHARSET		162
	VIETNAMESE_CHARSET	163 [N/A IN WX]
	HEBREW_CHARSET		177 Middle East language edition of Windows
	ARABIC_CHARSET		178 Middle East language edition of Windows
	BALTIC_CHARSET		186
	RUSSIAN_CHARSET		204
	THAI_CHARSET		222 Thai language edition of Windows
	EASTEUROPE_CHARSET	238
	OEM_CHARSET			255 The OEM_CHARSET value specifies a character set that is operating-system
							dependent
	Fonts with other character sets may exist in the operating system. If an application uses a font
	with an unknown character set, it should not attempt to translate or interpret strings that are
	rendered with that font.
	The lfCharset parameter of LOGFONT is important in the font mapping process. To ensure consistent
	results, specify a specific character set. If you specify a typeface name in the lfFaceName member,
	make sure that the lfCharSet value matches the character set of the typeface specified in lfFaceName.

	Here is how the above charsets compare/map to the wxWidgets font encoding values for 8-bit fonts:
	(Note: "Value" is the value of the enum wxFontEncoding struct; there are also values in that
	struct which apply to Unicode encodings including: wxFONTENCODING_UTF7 40 for UTF-7 Unicode encoding;
    wxFONTENCODING_UTF8 41 for UTF-8 Unicode encoding; wxFONTENCODING_UNICODE 43 for Unicode - currently
	used only by the wxEncodingConverter class.
	The following is from the wxWidgets header file fontenc.h

								 WX   MFC
	wxWidgets Symbol:			 Val  Val
	======================================
	wxFONTENCODING_SYSTEM		-1    255 The default encoding of the underlying operating system (notice that
									      this might be a "foreign" encoding for foreign versions of Windows 9x/NT).
	wxFONTENCODING_DEFAULT		0	  1	  The applications default encoding as returned by wxFont::GetDefaultEncoding.
									      On program startup, the applications default encoding is the same as
									      wxFONTENCODING_SYSTEM, but may be changed to make all the fonts created
									      later to use it (by default).
									      The 1..15 ISO8859 family encodings are usually used by all non-Microsoft
									      operating systems
	wxFONTENCODING_ISO8859_1	1         West European (Latin1)
	wxFONTENCODING_ISO8859_2	2	      Central and East European (Latin2)
	wxFONTENCODING_ISO8859_3	3	      Esperanto (Latin3)
	wxFONTENCODING_ISO8859_4	4	      Baltic (old) (Latin4)
	wxFONTENCODING_ISO8859_5	5	      Cyrillic
	wxFONTENCODING_ISO8859_6	6	      Arabic
	wxFONTENCODING_ISO8859_7	7	      Greek
	wxFONTENCODING_ISO8859_8	8	      Hebrew
	wxFONTENCODING_ISO8859_9	9	      Turkish (Latin5)
	wxFONTENCODING_ISO8859_10	10	      Variation of Latin4 (Latin6)
	wxFONTENCODING_ISO8859_11	11	      Thai
	wxFONTENCODING_ISO8859_12	12	      doesn't exist currently, but put here to make all ISO8859 consecutive numbers
	wxFONTENCODING_ISO8859_13	13	      Baltic (Latin7)
	wxFONTENCODING_ISO8859_14	14	      Latin8
	wxFONTENCODING_ISO8859_15	15	      Latin9 (a.k.a. Latin0, includes euro)
    wxFONTENCODING_ISO8859_MAX	16       (max value for the ISO8859 encodings)
	wxFONTENCODING_KOI8			17        Standard Cyrillic encoding for the Internet (but see also
									      wxFONTENCODING_ISO8859_5 and wxFONTENCODING_CP1251)
									      Cyrillic charset soup (see http://czyborra.com/charsets/cyrillic.html)
									      we don't support any of KOI8 variants
    wxFONTENCODING_KOI8_U		18	      KOI8 Ukrainian
    wxFONTENCODING_ALTERNATIVE	19	      same as MS-DOS CP866
    wxFONTENCODING_BULGARIAN	20	      used under Linux in Bulgaria
    wxFONTENCODING_CP437		21	 254  original MS-DOS codepage (what would we do without Microsoft? They have
									      their own encodings for DOS)
    wxFONTENCODING_CP850		22	      CP437 merged with Latin1
    wxFONTENCODING_CP852		23	      CP437 merged with Latin2
    wxFONTENCODING_CP855		24	      another cyrillic encoding
    wxFONTENCODING_CP866		25	      and another one

	wxFONTENCODING_CP874		26	 222  WinThai
    wxFONTENCODING_CP932		27	 128  Japanese (shift-JIS)
    wxFONTENCODING_CP936		28	 134  Chinese simplified (GB)
    wxFONTENCODING_CP949		29	 129  Korean (Hangul charset)
    wxFONTENCODING_CP950		30	 136  Chinese (traditional - Big5)
	wxFONTENCODING_CP1250		31   238  Microsoft analogue of ISO8859-2 "WinLatin2"
	wxFONTENCODING_CP1251		32   204  Microsoft analogue of ISO8859-5 "WinCyrillic"
	wxFONTENCODING_CP1252		33   0    Microsoft analogue of ISO8859-1 "WinLatin1"
    wxFONTENCODING_CP1253		34	 161  WinGreek (8859-7)
    wxFONTENCODING_CP1254		35	 162  WinTurkish
    wxFONTENCODING_CP1255		36	 177  WinHebrew
    wxFONTENCODING_CP1256		37	 178  WinArabic
    wxFONTENCODING_CP1257		38	 186  WinBaltic (same as Latin 7)
    wxFONTENCODING_CP12_MAX		39	      (max cp12... encoding defined)

	wxFONTENCODING_UTF7			40		  UTF-7 Unicode encoding
    wxFONTENCODING_UTF8			41		  UTF-8 Unicode encoding
    wxFONTENCODING_EUC_JP		42		  Extended Unix Codepage for Japanese
    wxFONTENCODING_UTF16BE		43		  UTF-16 Big Endian Unicode encoding
    wxFONTENCODING_UTF16LE		44		  UTF-16 Little Endian Unicode encoding
    wxFONTENCODING_UTF32BE		45		  UTF-32 Big Endian Unicode encoding
    wxFONTENCODING_UTF32LE		46		  UTF-32 Little Endian Unicode encoding

    wxFONTENCODING_MACROMAN		47	  77  the standard mac encodings [47-86]
    wxFONTENCODING_MACJAPANESE	48
    wxFONTENCODING_MACCHINESETRAD 49
    wxFONTENCODING_MACKOREAN	50
    wxFONTENCODING_MACARABIC	51
    wxFONTENCODING_MACHEBREW	52
    wxFONTENCODING_MACGREEK		53
    wxFONTENCODING_MACCYRILLIC	54
    wxFONTENCODING_MACDEVANAGARI 55
    wxFONTENCODING_MACGURMUKHI	56
    wxFONTENCODING_MACGUJARATI	57
    wxFONTENCODING_MACORIYA		58
    wxFONTENCODING_MACBENGALI	59
    wxFONTENCODING_MACTAMIL		60
    wxFONTENCODING_MACTELUGU	61
    wxFONTENCODING_MACKANNADA	62
    wxFONTENCODING_MACMALAJALAM	63
    wxFONTENCODING_MACSINHALESE	64
    wxFONTENCODING_MACBURMESE	65
    wxFONTENCODING_MACKHMER		66
    wxFONTENCODING_MACTHAI		67
    wxFONTENCODING_MACLAOTIAN	68
    wxFONTENCODING_MACGEORGIAN	69
    wxFONTENCODING_MACARMENIAN	70
    wxFONTENCODING_MACCHINESESIMP 71
    wxFONTENCODING_MACTIBETAN	72
    wxFONTENCODING_MACMONGOLIAN	73
    wxFONTENCODING_MACETHIOPIC	74
    wxFONTENCODING_MACCENTRALEUR 75
    wxFONTENCODING_MACVIATNAMESE 76
    wxFONTENCODING_MACARABICEXT	77
    wxFONTENCODING_MACSYMBOL	78
    wxFONTENCODING_MACDINGBATS	79
    wxFONTENCODING_MACTURKISH	80
    wxFONTENCODING_MACCROATIAN	81
    wxFONTENCODING_MACICELANDIC	82
    wxFONTENCODING_MACROMANIAN	83
    wxFONTENCODING_MACCELTIC	84
    wxFONTENCODING_MACGAELIC	85
    wxFONTENCODING_MACKEYBOARD	86

    wxFONTENCODING_MAX			87	  highest enumerated encoding value

    wxFONTENCODING_MACMIN = wxFONTENCODING_MACROMAN	47
    wxFONTENCODING_MACMAX = wxFONTENCODING_MACKEYBOARD	86

    // aliases for endian-dependent UTF encodings
#ifdef WORDS_BIGENDIAN
    wxFONTENCODING_UTF16 = wxFONTENCODING_UTF16BE	43	// native UTF-16
    wxFONTENCODING_UTF32 = wxFONTENCODING_UTF32BE	45	// native UTF-32
#else // WORDS_BIGENDIAN
    wxFONTENCODING_UTF16 = wxFONTENCODING_UTF16LE	44	// native UTF-16
    wxFONTENCODING_UTF32 = wxFONTENCODING_UTF32LE	46	// native UTF-32
#endif // WORDS_BIGENDIAN

    // alias for the native Unicode encoding on this platform
    // (this is used by wxEncodingConverter and wxUTFFile only for now)
#if SIZEOF_WCHAR_T == 2
    wxFONTENCODING_UNICODE = wxFONTENCODING_UTF16	43
#else // SIZEOF_WCHAR_T == 4
    wxFONTENCODING_UNICODE = wxFONTENCODING_UTF32	45
#endif

    // alternative names for Far Eastern encodings
        // Chinese
    wxFONTENCODING_GB2312 = wxFONTENCODING_CP936	28	134	// Simplified Chinese
    wxFONTENCODING_BIG5 = wxFONTENCODING_CP950		30  136	// Traditional Chinese

        // Japanese (see http://zsigri.tripod.com/fontboard/cjk/jis.html)
    wxFONTENCODING_SHIFT_JIS = wxFONTENCODING_CP932	27	128	// Shift JIS

	The wxWidgets docs add the following comments (from: "Font encoding overview"):
    As you may see, Microsoft's encodings partly mirror the standard ISO8859 ones, but
    there are (minor) differences even between ISO8859-1 (Latin1, ISO encoding for Western
    Europe) and CP1251 (WinLatin1, standard code page for English versions of Windows) and
    there are more of them for other encodings. The situation is particularly complicated
    with Cyrillic encodings for which (more than) three incompatible encodings exist: KOI8
    (the old standard, widely used on the Internet), ISO8859-5 (ISO standard for Cyrillic)
    and CP1251 (WinCyrillic).
    This abundance of (incompatible) encodings should make it clear that using encodings is
    less easy than it might seem. The problems arise both from the fact that the standard
    encodings for the given language (say Russian, which is written in Cyrillic) are
    different on different platforms and because the fonts in the given encoding might just
    not be installed (this is especially a problem with Unix, or, in general, non-Win32
    systems).
    To clarify, the wxFontEnumerator class may be used to enumerate all available
    encodings, and to find the facename(s) in which the given encoding exists. If you can
    find the font in the correct encoding with wxFontEnumerator then your troubles are
    over, but, unfortunately, sometimes this is not enough. For example, there is no
    standard way (that I know of, please tell me if you do!) to find a font on a Windows
    system for KOI8 encoding (only for WinCyrillic one which is quite different), so
    wxFontEnumerator will never return one, even if the user has installed a KOI8 font on
    his system. To solve this problem, a wxFontMapper class is provided. This class stores
    the mapping between the encodings and the font face names which support them in
    wxConfig object. Of course, it would be fairly useless if it tried to determine these
    mappings by itself, so, instead, it (optionally) asks the user and remembers his
    answers so that the next time the program will automatically choose the correct font.
    All these topics are illustrated by the font sample; please refer to it and the
    documentation of the classes mentioned here for further explanations.

	Design Considerations for Adapt It development:
	1.	On modern Windows machines wxLocale::GetSystemEncoding() returns wxFONTENCODING_CP1252,
		and wxFontMapper::Get()->GetAltForEncoding() returns wxFONTENCODING_ISO8859_1.
		To accommodate the possible/likely migration of data from Windows environment to an
		Ubuntu Linux environment, we can set the initial encoding for source, target, nav,
		and the dialog fonts to wxFONTENCODING_ISO8859_1, so that the text controls and
		display contexts can convert any upper ASCII character data to UTF-8 without generating
		the "Failed to set text in text control" error (displaying it as "boxed" hex values
		inline in the displayed string)
	2.	We can give the user the option in the fontPage to change the encoding for a given
		language font which would then override the default setting when setting up an
		Adapt It project.
	3.	Presumably, the Charset value stored for each Unicode font in the config files (of
		the Unicode version) would be 0 (zero), as the charset value is not significant for
		Unicode operations.
	4.	We can determine from the project config file whether the config file was generated
		by the legacy MFC version or the newer wxWidgets version, by whether the config file
		has the "SourceHasUpperCaseAndLowerCase n" field in it (which is unique to the
		wxWidgets version). Then, the Charset fields for each of the fonts read at the
		beginning of the config files can be interpreted accordingly. If we know that the
		config file was generated by the wxWidgets version, we can accurately know the
		font encoding for the particular font in the data. If that font encoding is available
		on the current system all is OK; if the font encoding is not available, we can ask
		the user to select a font encoding via a "Choose Font Encoding" dialog for each font
		necessary when opening the project.
		If the config file was generated by the MFC version, we can assume that we should be
		able to map the Charset from the MFC byte Charset values to any corresponding wxWidgets
		encodings. If a reliable mapping is not available, we can ask the user to select a font
		encoding via a "Choose Font Encoding" dialog for each font necessary when opening the
		project.
	*/

	// First, in case this is very first time app is run, default to a platform appropriate
	// font for source, target, and navtext languages and also appropriate fonts for the
	// dialog fonts.
	// Notes:
	//    1. wxFont objects are created on the heap, and must be deleted in OnExit();
	//    2. Vadim Zeitlin's suggestion for ANSI builds was to create a wxNORMAL_FONT and then
	//       set its encoding appropriately (and use SetFont) for converting the smart quotes to
	//       UTF-8 used internally by the wxGTK library
	if (m_pSourceFont == NULL)
		m_pSourceFont = new wxFont(*wxNORMAL_FONT);
	wxASSERT(m_pSourceFont != NULL);
	if (m_pTargetFont == NULL)
		m_pTargetFont = new wxFont(*wxNORMAL_FONT);
	wxASSERT(m_pTargetFont != NULL);
	if (m_pNavTextFont == NULL)
		m_pNavTextFont = new wxFont(*wxNORMAL_FONT);
	wxASSERT(m_pNavTextFont != NULL);

	// Create suitable dialog fonts
	if (m_pDlgSrcFont == NULL)
		m_pDlgSrcFont = new wxFont(*wxNORMAL_FONT);
	wxASSERT(m_pDlgSrcFont != NULL);
	if (m_pDlgTgtFont == NULL)
		m_pDlgTgtFont = new wxFont(*wxNORMAL_FONT);
	wxASSERT(m_pDlgTgtFont != NULL);
	if (m_pDlgGlossFont == NULL)
		m_pDlgGlossFont = new wxFont(*wxNORMAL_FONT);
	wxASSERT(m_pDlgGlossFont != NULL);
	if (m_pComposeFont == NULL)
		m_pComposeFont = new wxFont(*wxNORMAL_FONT);
	wxASSERT(m_pComposeFont != NULL);
	if (m_pRemovalsFont == NULL)
		m_pRemovalsFont = new wxFont(*wxNORMAL_FONT);
	wxASSERT(m_pRemovalsFont != NULL);
	if (m_pVertEditFont == NULL)
		m_pVertEditFont = new wxFont(*wxNORMAL_FONT);
	wxASSERT(m_pVertEditFont != NULL);

	// Set a suitable default font encoding.
    // Note: To accommodate Word's "smart quotes," we'll set the default font encoding as
    // follows:
    // For ANSI builds, we'll use what Windows calls the ANSI_CHARSET (value 0), which in
    // the wxWidgets' wxFontEncoding equivalent is wxFONTENCODING_CP1252.
    // For Unicode builds, we'll use the system default wxFONTENCODING_DEFAULT (enum value
    // of 0) which on program startup should be the same as wxFONTENCODING_SYSTEM (enum
    // value of -1).
#ifndef _UNICODE
	// For ANSI use a default Windows encoding CP1252 which can represent the smart quotes

	// whm added 19Feb07
	// The following static function call sets the default font encoding application wide to
	// wxFONTENCODING_CP1252 so that any new font created with no parameter or with wxNORMAL_FONT
	// as parameter will use this encoding
	wxFont::SetDefaultEncoding(wxFONTENCODING_CP1252);

	// whm TODO: Some of the wxFontEncoding identifiers below duplicate the functions of others
	// that are initialized in OnInit(), namely m_srcEncoding and m_tgtEncoding. Eliminate the
	// duplication if possible.
	m_srcEncoding = wxFONTENCODING_CP1252;
	m_tgtEncoding = wxFONTENCODING_CP1252;
	m_navtextFontEncoding = wxFONTENCODING_CP1252;

	m_dlgSrcFontEncoding = wxFONTENCODING_CP1252;
	m_dlgTgtFontEncoding = wxFONTENCODING_CP1252;
	m_dlgGlossFontEncoding = wxFONTENCODING_CP1252;
	m_composeFontEncoding = wxFONTENCODING_CP1252;
	m_removalsFontEncoding = wxFONTENCODING_CP1252;
	m_vertEditFontEncoding = wxFONTENCODING_CP1252;
#else
	// For Unicode use a default system encoding
	m_srcEncoding = wxFONTENCODING_DEFAULT;
	m_tgtEncoding = wxFONTENCODING_DEFAULT;
	m_navtextFontEncoding = wxFONTENCODING_DEFAULT;

	m_dlgSrcFontEncoding = wxFONTENCODING_DEFAULT;
	m_dlgTgtFontEncoding = wxFONTENCODING_DEFAULT;
	m_dlgGlossFontEncoding = wxFONTENCODING_DEFAULT;
	m_composeFontEncoding = wxFONTENCODING_DEFAULT;
	m_removalsFontEncoding = wxFONTENCODING_DEFAULT;
	m_vertEditFontEncoding = wxFONTENCODING_DEFAULT;
#endif

	// set the initial encoding of the major language fonts
	m_pSourceFont->SetEncoding(m_srcEncoding);
	m_pTargetFont->SetEncoding(m_tgtEncoding);
	m_pNavTextFont->SetEncoding(m_navtextFontEncoding);

	m_pDlgSrcFont->SetEncoding(m_dlgSrcFontEncoding);
	m_pDlgTgtFont->SetEncoding(m_dlgTgtFontEncoding);
	m_pDlgGlossFont->SetEncoding(m_dlgGlossFontEncoding);
	m_pComposeFont->SetEncoding(m_composeFontEncoding);
	m_pRemovalsFont->SetEncoding(m_removalsFontEncoding);
	m_pVertEditFont->SetEncoding(m_vertEditFontEncoding);


    // create the corresponding wxFontData ojbects on the heap; delete them in OnExit() In
    // wxWidgets these wxFontData objects are used mainly to get the user's chosen font
    // from a font dialog, and to call Get/SetColour() methods to get/set the font color.
	if (m_pSrcFontData == NULL)
		m_pSrcFontData = new wxFontData;	// must delete in OnExit()
	wxASSERT(m_pSrcFontData != NULL);
	if (m_pTgtFontData == NULL)
		m_pTgtFontData = new wxFontData;	// must delete in OnExit()
	wxASSERT(m_pTgtFontData != NULL);
	if (m_pNavFontData == NULL)
		m_pNavFontData = new wxFontData;	// must delete in OnExit()
	wxASSERT(m_pNavFontData != NULL);

    // For wxWidgets we have our own fontInfo structure to hold the legacy MFC LOGFONT
    // struct-type data, mainly for use in maintaining backward compatibility in reading
    // and writing config files.
	// We'll initialize the fontInfo values and set the necessary font characteristics
	// in those fontInfo structs to use the default system fonts as created above.

	// For our default system Source Font, we only set its size to 12 points and its
	// weight to bold and its color (via its wxFontData class) to bright blue.
	// We don't specify the face name nor the family here as we want to use whatever
	// the GetFont() call above gave us as a system font for the current platform.
	m_pSourceFont->SetPointSize(12); // 12 point
	m_pSourceFont->SetWeight(wxBOLD);
	m_sourceColor = wxColour(0,0,255); // bright blue "16711680"
	// It is necessary to call the font data's SetColour() function to effect color change
	m_pSrcFontData->SetColour(m_sourceColor);

	// For our default system Target Font, we only set its size to 12 points and its
	// weight to bold and its color (via its wxFontData class) to black.
	// We don't specify the face name nor the family here as we want to use whatever
	// the GetFont() call above gave us as a system font for the current platform.
	m_pTargetFont->SetPointSize(12); // 12 point
	m_pTargetFont->SetWeight(wxBOLD);
	m_targetColor = wxColour(0,0,0); // black
	// It is necessary to call the font data's SetColour() function to effect color change
	m_pTgtFontData->SetColour(m_targetColor); //

	// For our default system Nav Text Font, we only set its size to 12 points and its
	// weight to bold and its color (via its wxFontData class) to bright green.
	// We don't specify the face name nor the family here as we want to use whatever
	// the GetFont() call above gave us as a system font for the current platform.
	m_pNavTextFont->SetPointSize(11); // make it 11 pt - a little smaller
	m_pNavTextFont->SetWeight(wxBOLD);
	m_navTextColor = wxColour(0,255,0); //bright green "65280"
	// It is necessary to call the font data's SetColour() function to effect color change
	m_pNavFontData->SetColour(m_navTextColor); //

	m_specialTextColor = wxColour(255,0,0); // red "255" - whm added
	m_reTranslnTextColor = wxColour(160,80,0); // mid brown "32896" - whm added
	m_tgtDiffsTextColor = wxColour(67,100,40); // slightly greenish khaki "2647107" - bew added
	m_AutoInsertionsHighlightColor = wxColour(203,151,255); // solid light purple "16750539"
	m_GuessHighlightColor = wxColour(255,180,128); //wxColour(255,128,0); // pastel orange background for Guess - whm added 1Nov10
	m_freeTransTextColor = wxColour(100,0,100); // dark purple - fixed not user selectable

	// color used for read-only text controls displaying static text info button face color
	sysColorBtnFace = wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE);
	// color used for read-only text controls displaying static text info window background color
	sysColorWindow = wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOW);

	// The following values for fonInfo echo the defaults above using wxFont methods.
	// All the defaults set here in Initialize will be used on first run of program, or
	// any time the user holds the shift key down during program startup. These values
	// will normally change to the user's preferences when the config file is read.

	SrcFInfo.fLangType = _T("SourceFont");
	TgtFInfo.fLangType = _T("TargetFont");
	NavFInfo.fLangType = _T("NavTextFont");

	// The UpdateFontInfoStruct functions below assign the font characteristics of the
	// font in the first argument to the corresponding fontInfo struct passed in the
	// second argument.
	UpdateFontInfoStruct(m_pSourceFont,SrcFInfo);
	UpdateFontInfoStruct(m_pTargetFont,TgtFInfo);
	UpdateFontInfoStruct(m_pNavTextFont,NavFInfo);

	// the following are additional font characteristics not used by wxWidgets
	// but are stored in the legacy config files. We set the default values to
	// arbitrary defaults initially. If a legacy config file is read, the existing
	// values are stored in the appropriate fontInfo fields and used only for
	// writing the values back out to the config files.
	SrcFInfo.fWidth = 0;
	TgtFInfo.fWidth = 0;
	NavFInfo.fWidth = 0;

	SrcFInfo.fEscapement = 0;
	TgtFInfo.fEscapement = 0;
	NavFInfo.fEscapement = 0;

	SrcFInfo.fOrientation = 0;
	TgtFInfo.fOrientation = 0;
	NavFInfo.fOrientation = 0;

	SrcFInfo.fStrikeOut = FALSE;
	TgtFInfo.fStrikeOut = FALSE;
	NavFInfo.fStrikeOut = FALSE;

	SrcFInfo.fCharset = 0; // 0 is the value for ANSI_CHARSET, presumably same for Unicode encodings
	TgtFInfo.fCharset = 0; // 0 is the value for ANSI_CHARSET, presumably same for Unicode encodings
	NavFInfo.fCharset = 0; // 0 is the value for ANSI_CHARSET, presumably same for Unicode encodings

	SrcFInfo.fOutPrecision = 1;
	TgtFInfo.fOutPrecision = 1;
	NavFInfo.fOutPrecision = 1;

	SrcFInfo.fClipPrecision = 2;
	TgtFInfo.fClipPrecision = 2;
	NavFInfo.fClipPrecision = 2;

	SrcFInfo.fQuality = 2;
	TgtFInfo.fQuality = 2;
	NavFInfo.fQuality = 2;

}// end of InitializeFonts()

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnInit() and from the App's SetDefaults() if the user holds the
/// shift key down during startup, or if there is no existing configuration files.
/// InitializePunctuation() handles the initial creation of the default punctuation
/// characters used in the application. Normally, the initial punctuation characters are
/// replaced by those stored in the basic and project configuration files when they are
/// read.
//////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::InitializePunctuation()
{
    // initialize the punctuation pairs array to all zeros (can be unicode) '\0' is okay
    // for unicode or not
	for (int i=0; i<MAXPUNCTPAIRS; i++)
	{
		m_punctPairs[i].charSrc = '\0';
		m_punctPairs[i].charTgt = '\0';
	}

	// initialize the two-punctuation pairs array to all zeros
	for (int i=0; i<MAXTWOPUNCTPAIRS; i++)
	{
		m_twopunctPairs[i].twocharSrc[0] = '\0';
		m_twopunctPairs[i].twocharTgt[0] = '\0';
		m_twopunctPairs[i].twocharSrc[1] = '\0';
		m_twopunctPairs[i].twocharTgt[1] = '\0';
	}

    // whm moved following here from block after GetBasicConfiguration() call in
    // OnInit() where bConfigFilesRead was false. This was done to simplify the handling of
    // default punctuation which should be consolidated in InitializePunctuation.
    // if (m_punctuation[0].IsEmpty())
	//{
		// leave this block here, but we no longer set up the defaults here, but rather in
		// the code following this block
		m_punctuation[0] = _T(" . , < > ; ? ! : ( ) \" { } [ ] "); // defaults for narrow or
																// wide characters
		m_punctWordBuilding[0] = _T(""); // leave this in the code, just don't use them --
										// since reading an old config file would require them
		if (m_punctuation[1].IsEmpty())
		{
			m_punctuation[1] = m_punctuation[0];
			m_punctWordBuilding[1] = m_punctWordBuilding[0]; // leave here, for above reason
		}

		// next, set up the correspondence strings...
		// BEW inserted in following section on March 17, 2005
		// for support of curly quotes as punctuation for stripping out
		wxString additions;
		additions.Empty();
		wxString ch = _T("."); // we overwrite the full stop below (can't leave it empty)

		// next, set up the correspondence strings
#ifdef _UNICODE // Unicode version
		wxString strPunctPairsSrcSet;
		wxString strPunctPairsTgtSet;
		wxString strTwoPunctPairsSrcSet;
		wxString strTwoPunctPairsTgtSet;

		strPunctPairsSrcSet = _T("?.,;:\"!()<>{}[]");

		ch.SetChar(0,L'\x201C'); // hex for left double quotation mark
		additions += ch;
		ch.SetChar(0,L'\x201D'); // hex for right double quotation mark
		additions += ch;
		ch.SetChar(0,L'\x2018'); // hex for left single quotation mark
		additions += ch;
		ch.SetChar(0,L'\x2019'); // hex for right single quotation mark
		additions += ch;
		strPunctPairsSrcSet += additions;
		m_bSingleQuoteAsPunct = FALSE;

		strPunctPairsTgtSet = strPunctPairsSrcSet;
		strTwoPunctPairsSrcSet.Empty();
		strTwoPunctPairsTgtSet = strTwoPunctPairsSrcSet;
		TwoStringsToPunctPairs(m_punctPairs,strPunctPairsSrcSet,strPunctPairsTgtSet);
		TwoStringsToTwoPunctPairs(m_twopunctPairs,strTwoPunctPairsSrcSet,strTwoPunctPairsTgtSet);
#else // ANSI version
		wxString strValue = _T("??..,,;;::\"\"!!(())<<>>[[]]{{}}");

        // For Windows, we can support curly quotes like MFC does in the ANSI version. When
        // first converted to wxWidgets, GTK's text control was failing when use SetValue()
        // with any of these upper ascii values in the punctuation string. A partial
        // solution was to ensure that SetEncoding(wxFONTENCODING_CP1252) was called on the
        // fonts involved. Note: SetEncoding() is an "undocumented" method of wxFont. The
        // documented SetDefaultEncoding() did not seem to work. Also setting the encoding
        // to wxFONTENCODING_ISO8859_1 did not work (it eliminated the "Failed to set text
        // in text control" message, but showed the smart quotes as boxes with the hex
        // values in them, instead of the actual quote characters). Because it was only a
        // partial solution and problems seemed to continually crop up, in the end I
        // decided to include smart quotes only in the wxMSW ANSI version and not in wxGTK
        // builds.
#ifdef __WXMSW__
		unsigned char thechar = 147; // left double quotation mark
		ch.SetChar(0,thechar);
		additions += ch;
		additions += ch;
		thechar = 148;// right double quotation mark
		ch.SetChar(0,thechar);
		additions += ch;
		additions += ch;
		thechar = 145; // left single quotation mark
		ch.SetChar(0,thechar);
		additions += ch;
		additions += ch;
		thechar = 146; // right single quotation mark
		ch.SetChar(0,thechar);
		additions += ch;
		additions += ch;
		strValue += additions;
#endif
        // wxGTK uses UTF-8 internally in its wxTextCtrl widgets, so let's try converting
        // the punctuation string to UTF-8 for wxGTK ANSI builds.
//#ifdef __GNUG__
//			// The following converts strValue to
//			wxConvUTF8.cWC2MB(wxConvCurrent->cMB2WC(strValue));
//#endif
		//int found = strValue.Find(_T('\''),0); // look for vertical ordinary quote (ie. apostrophe)
		//if (found >= 0)
		//	m_bSingleQuoteAsPunct = TRUE;
		//else
			m_bSingleQuoteAsPunct = FALSE; // default setup can only can be this

		StringToPunctPairs(m_punctPairs,strValue);
		strValue.Empty();
		StringToTwoPunctPairs(m_twopunctPairs,strValue);
#endif
		// end of BEW insertions for March 17, 2005

	//}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return    TRUE if the basic configuration file exists and was successfully read, FALSE
///             if the basic config file could not be read or if the user held the SHIFT key
///             down on application startup
/// \remarks
/// Called from: the App's OnInit(), SetupCustomWorkFolderLocation(), and
/// OnRestoreDefaultWorkFolderLocation().
/// Reads the basic configuration file (AI-BasicConfiguration.aic) by calling the
/// GetConfigurationFile() function with szBasicConfiguration passed as input parameter.
/// If the user holds down the SHIFT key during application startup, or if the configuration
/// file cannot be read, this function calls SetDefaults() instead.
/// BEW modified 19Aug09 in support of adminstrator pointing app at custom work folder locations
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::GetBasicConfiguration()	// whm 20Jan08 changed signature to return bool
											// whm 9Mar10 changed name from GetBasicConfigFileSettings
											// to GetBasicConfiguration
{
	// Called from OnInit() at program startup. Or from CustomWorkFolderLocation() command
	// handler when administrator has Administrator menu showing
	// If user starts up with the SHIFT key down, or if an existing basic config file cannot
	// be read successfully, SetupDefaults() is called and all initializations and settings
	// are drawn from there. Otherwise, intializations and settings contained in the basic
	// config file are used
	// Now attempt to set source, target language fonts, and nav text font set up from the
	// data in the configuration file
	// ::wxGetKeyState() was not available as a global function in wxWidgets
	// version 2.4.2, but ::wxGetKeyState() is available in wxWidgets version 2.5.3
	// and later, so we use it here.
	bool bReturn = FALSE;
	bReturn = bReturn; // avoid compiler warning (appropriate here, else block doesn't use
					   // this boolean, and we don't want to use wxCHECK_MSG() in this
					   // function either)
	if (!wxGetKeyState(WXK_SHIFT)) // if (keyState != WXK_SHIFT)
	{
		// Shift key is not down, so load the config file data for fonts & other settings.
		// This version of the function uses configuration file, not the registry.
		if ((m_customWorkFolderPath != m_workFolderPath) && m_bUseCustomWorkFolderPath)
		{
			// Before GetBasicConfiguration() is called,
			// MakeForeignBasicConfigFileSafe() will have been called and the "foreign" basic
			// config file at the custom location will have been cloned, renamed, and
			// modified to have the appropriate paths for the custom location, so the
			// following call will not fail; it's stored in the default work folder
			// BEW 17Sep09, it's now at m_workFolderPath, not m_customWorkFolderPath, when
			// the administrator is accessing a custom or remote (non-persistent) work
			// folder location; but it is at m_customWorkFolderPath when the basic config
			// file is being read in from the custom location which has been made
			// persistent with a click of the Lock Custom Path command
			if (m_bLockedCustomWorkFolderPath)
				bReturn = GetConfigurationFile(szBasicConfiguration,m_customWorkFolderPath,basicConfigFile);
			else
				bReturn = GetConfigurationFile(szAdminBasicConfiguration,m_workFolderPath,basicConfigFile);
		}
		else
		{
			bReturn = GetConfigurationFile(szBasicConfiguration,m_workFolderPath,basicConfigFile);
		}
		if (!bReturn)
		{
			// we want defaults, if it fails - as it will on very first launch of the app
			SetDefaults();
		}
	}
	else
	{
		// SHIFT key is down at launch time, so user wants to bypass configuration file settings
		// (which may be corrupt), so set up default values for the settings needed for a
		// successful launch -- BEW 19Aug09, this functionality needs to also be supported when
		// pointing the application at a custom work folder location
		SetDefaults();
	}
	return bReturn;
}

///////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param		projectFolderPath -> the path/name of the project config file
///                                  which is generally m_curProjectPath
/// \remarks
/// Called from: the Doc's OnOpenDocument() [via MRU call], DoUnpackDocument(),
/// the COpenExistingProjectDlg's OnOK() and OnDblclkListboxAdaptions(), the ProjectPage's
/// OnWizardPageChanging().
/// Calls the App's GetConfigurationFile() function to retrieve the settings from the project
/// config file. If the user is holding the SHIFT key down, the function does not load
/// settings from the project config file, but instead calls the App's
/// SetDefaultCaseEquivalences() function (the other defaults will have been done from the
/// application-level configuration file already).
///////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetProjectConfiguration(wxString projectFolderPath)
{
	// attempt to set project source, target language fonts, and nav text font from the
	// data in the project configuration file; but if SHIFT key is still down, then bypass it
	// (the values set as defaults when the basic config file was bypassed will remain in
	// effect)
	bool bReturn = FALSE;
	bReturn = bReturn; // avoid compiler warning
	if (!wxGetKeyState(WXK_SHIFT))
	{
		// whm added 9Mar10 to ensure that a "foreign" project config file has been cloned,
		// renamed, and modified to have the appropriate (or compatible) fonts for the project.
		// MakeForeignProjectConfigFileSafe() also deals with any font mismatches before
		// the appropriate GetConfigurationFile() is called below.
		wxString configFName = szProjectConfiguration + _T(".aic");
		wxString adminConfigFName = szAdminProjectConfiguration + _T(".aic");
		MakeForeignProjectConfigFileSafe(configFName,projectFolderPath,&adminConfigFName);
		// shift key is not down, so load the config file keys for fonts & settings
		if ((m_customWorkFolderPath != m_workFolderPath) && m_bUseCustomWorkFolderPath)
		{
			// We are using a custom work folder path.
			// MakeForeignProjectConfigFileSafe() (called above) insured that a "foreign"
			// project config file has been cloned, renamed, and modified to have the
			// appropriate (or compatible) fonts for the project. The project admin config
			// file is at m_curProjectPath if administrator is accessing a custom or remote
			// (non-persistent) work folder location and it is a custom work folder path that
			// is not locked. If no custom work folder path is being used, or it a custom
			// path is being used that is a locked (persistent) custom work folder path, then
			// the project admin config file is at the m_customWorkFolderPath.
			if (m_bLockedCustomWorkFolderPath)
				bReturn = GetConfigurationFile(szProjectConfiguration,projectFolderPath,projectConfigFile);
			else
				bReturn = GetConfigurationFile(szAdminProjectConfiguration,projectFolderPath,projectConfigFile);
		}
		else
		{
			// We are NOT using a custom work folder path.
			bReturn = GetConfigurationFile(szProjectConfiguration,projectFolderPath,projectConfigFile);
		}
		if (!bReturn)
		{
			// failure to get it, so use the built-in defaults instead
			SetDefaultCaseEquivalences();
		}
	}
	else
	{
		// shift key is still down, so get the default character case equivalents only
		// for the project; the other defaults will have been done from the application-level
		// configuration file already
		SetDefaultCaseEquivalences();
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return    TRUE if the directory structure and KBs were created successfully
///             and/or exist, FALSE if an error occurred.
/// \remarks
/// Called from: the App's OnRestoreDefaultWorkFolderLocation(), Doc's OnOpenDocument(),
/// DoUnpackDocument(), CreateNewAIProject() in CollabUtilities, and from
/// CLangaugesPage::OnWizardPageChanging().
/// when processing MRU file and m_pKB == NULL, DoUnpackDocument(), and from
/// CLanguagesPage::OnWizardPageChanging() when the wizard page is moving forward.
/// SetupDirectories() ensures that the appropriate directory/folder structure is created
/// when a new project is started, and that the appropriate directory/folder structure
/// exists or can be created prior to opening or unpacking a document. It sets up various
/// derivative paths, based on m_workFolderPath.
/// BEW modified 18Aug09 to support custom work folder locations:
/// When the m_bUseCustomWorkFolderPath flag is TRUE, a custom location (never the same as
/// the default location, because if that were the case then OnCustomWorkFolderLocation()
/// will already have turned the flag back off to FALSE) is to be used and that directory
/// is already set as the working directory. Derivative paths are then based on the
/// contents of the m_customWorkFolderPath application class member; these are paths such
/// as m_curProjectPath, m_curAdaptationsPath, m_curOutputPath, etc.
/// whm revised 12Jun11 to simplify by using a workOrCustomFolderPath which here at the
/// beginning is defined as m_workFolderPath when not using a custom work folder, or as
/// m_customWorkFolderPath when using a custom work folder. Also added the creation of
/// the various inputs and outputs folders being used in AI version 6. Previously a
/// "Source Data" folder might be created as needed, however, with version 6 it has been
/// renamed to __SOURCE_INPUTS and, along with other folders are created if needed whenever
/// SetupDirectories() is called.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::SetupDirectories()
{
	// whm revised 12Jun11 to simplify by using a workOrCustomFolderPath which
	// here at the beginning is defined as m_workFolderPath when not using a
	// custom work folder, or as m_customWorkFolderPath when using a custom
	// work folder. The two versions tended to get out of sync with time due to
	// changes made to one and not the other.
	wxString workOrCustomFolderPath;
	if (!m_bUseCustomWorkFolderPath)
	{
		workOrCustomFolderPath = m_workFolderPath;
	}
	else
	{
		workOrCustomFolderPath = m_customWorkFolderPath;
	}

	// this is where we have to start setting up the directory structures
	bool bWorkExists = FALSE;
	bWorkExists = bWorkExists; // avoid compiler warning (easiest way to do it for
							   // this complex function)

	if (::wxFileExists(workOrCustomFolderPath) || ::wxDirExists(workOrCustomFolderPath))
    // The Docs say ::wxFileExists() "returns TRUE if the file exists. It also returns
    // TRUE if the file is a directory", however, I've found that the second statement
    // is false, so, I'm ORing it with ::wxDirExists().
	{
		if (::wxDirExists(workOrCustomFolderPath))
		{
			// work folder already exists, so don't create it
			bWorkExists = TRUE;
		}
		else
		{
            // Work folder does not yet exist, but a file of that name does exist, so
            // it must be renamed before user can proceed. Abort after a message is
            // easiest way.
			wxString str;
			// IDS_FILENAME_CLASH
			str = str.Format(_(
"Sorry, there is a file named 'Adapt It %sWork'. Please delete or rename this file because Adapt It needs to use this name instead for a folder."),
			m_strNR.c_str());
			wxMessageBox(str, _T(""), wxICON_ERROR);
			LogUserAction(_T("A file named 'Adapt It Work' exists interfering with creating the folder of same name. Aborting..."));
			// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
			wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
			return FALSE;
		}
	}
	else
	{
		// Work folder does not yet exist, so create it.
		bool bOK = ::wxMkdir(workOrCustomFolderPath); //bool bOK = ::CreateDirectory(workOrCustomFolderPath,NULL);
        // WX NOTE: On Unix/Linux wxMkdir has a second default param: int perm = 0777
        // which makes a directory with full read, write, and execute permissions.
		if (!bOK)
		{
			wxString str;
			// IDS_CREATE_DIR_FAILED
			str = str.Format(_(
"Sorry, there was an error creating the \"Adapt It %sWork\" folder in your <home user>/My Documents folder.\nAdapt It %s is not set up correctly and so must close down."),
			m_strNR.c_str(),m_strNR.c_str());
			wxMessageBox(str, _T(""), wxICON_ERROR);
			LogUserAction(_T("Error creating the \"Adapt It %sWork\" folder in <home user>"));
			wxASSERT(FALSE);
			return FALSE;
		}
		bWorkExists = TRUE; // it now exists
	}

    // at this point we have an "Adapt It Work" folder existing in My Documents (If we
    // loaded a document from the MRU list, m_sourceName and m_targetName are
    // serialized on the doc, and so we can determine the doc's project folder name
    // from those now too; and the wxString buffer has been pressed into service in the
    // serialization code to store and load book mode information on the document, so
    // that is available now to - all except m_bibleBooksFolderPath which we must
    // recreate here below a bit)
    // whm: For localization purposes the " to " and " adaptations" strings should not
    // be translated, otherwise other localizations would not be able to handle the
    // unpacking of files created on different localizations.
	wxString workFolder = m_sourceName + _T(" to ") + m_targetName + _T(" adaptations");
	m_curProjectName = workFolder;
	wxASSERT(!m_curProjectName.IsEmpty());
	m_curProjectPath = workOrCustomFolderPath + PathSeparator + m_curProjectName;

	// check to see if this folder already exists
	bool bLangWorkFolderExists = FALSE;
	bLangWorkFolderExists = bLangWorkFolderExists; // avoid warning
	if (::wxFileExists(m_curProjectPath) || ::wxDirExists(m_curProjectPath))
	{
		if (::wxDirExists(m_curProjectPath))
		{
			// language-specific work folder already exists, so don't create it
			bLangWorkFolderExists = TRUE;
			if (!gbViaMostRecentFileList && pStartWorkingWizard == NULL)
			{
                // if we are not in the startup wizard, then to set up same project
                // again would likely be an error made by a novice user, thinking he
                // was creating a new document, so he should be given this message. But
                // the message should be suppressed in the wizard, since the wizard
                // allows the user to navigate back to the start of the wizard, so
                // having set up a new project, he could navigate back, and then use
                // Next> buttons again, and so we would want the use of the existing
                // folder to be done silently BEW added 10Jan06; the Unpack Document...
                // command calls SetupDirectories() from its handler on the destination
                // machine, and if there is a project of the same name already on the
                // same machine (eg. as would be the case if an unpack was done of a
                // second document file from the same source project) we would not want
                // this message to come up each time; nor even once, since the
                // destination machine's user expects the project to be automatically
                // set up and it would be a nuisance to mention it already exists. The
                // m_bUnpacking flag is cleared in the doc class's OnFileUnpackDoc()
                // function.
				// BEW 12Nov09 added m_bAutoExport test to suppress the message when
				// doing an autoexport from the command line
				// BEW 25Aug11, added a further flag - it keeps coming up in collab mode
				// if a multi-doc retranslation report is in progress - at each doc
				// access, so suppress these too
				if (!m_bUnpacking && !m_bAutoExport && !m_bRetransReportInProgress)
				{
					wxString str;
					// IDS_DUP_PROJECT_NAME
					str = str.Format(_(
"Warning: a project with the name \"%s\" already exists. Adapt It will therefore use the existing project."),
					workFolder.c_str());
                    // use wxMessageDialog rather than wxMessageBox below. For some
                    // reason the dialog would have a null parent when loading a file
                    // from MRU, and wxMessageDialog allows us to specify the main
                    // frame as parent.
					wxMessageBox(str, _T(""), wxICON_INFORMATION);
				}
			}
		}
		else
		{
			// language-specific Work folder does not yet exist, but a file of
			// that name does exist, so it must be renamed before
			// user can proceed. Abort after a message is easiest way.
			wxString text;
			// IDS_FILENAME2_CLASH
			text = text.Format(_(
"Sorry, there is a file named \"%s to %s adaptations\" in your Adapt It %sWork folder. You must rename or delete this file because Adapt It needs to use this name for a folder."),
			m_sourceName.c_str(),m_targetName.c_str(),m_strNR.c_str());
			wxMessageBox(text, _T(""), wxICON_ERROR);
			LogUserAction(_T("A file named 'Adapt It Work' exists interfering with creating the folder of same name. Aborting..."));
			// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
			wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
			return FALSE;
		}
	}
	else
	{
		// language-specific Work folder does not yet exist, so create it, but only if
		// the source and target language names are currently defined; if they aren't,
		// we don't go any further & return TRUE
		if (!m_sourceName.IsEmpty() && !m_targetName.IsEmpty())
		{
			bool bOK = ::wxMkdir(m_curProjectPath);
			// WX NOTE: On Unix/Linux wxMkdir has a second default param: int perm = 0777 which
			// makes a directory with full read, write, and execute permissions.
			if (!bOK)
			{
				wxString str;
				// IDS_CREATE_DIR2_FAILED
				str = str.Format(_(
"Sorry, there was an error creating the \"%s to %s adaptations\" folder in your Adapt It %sWork folder. Adapt It is not set up correctly and so must close down."),
				m_sourceName.c_str(),m_targetName.c_str(),m_strNR.c_str(),m_strNR.c_str());
				wxMessageBox(str, _T(""), wxICON_ERROR);
				wxASSERT(FALSE);
				return FALSE;
			}
			bLangWorkFolderExists = TRUE; // it now exists
		}
		else
		{
			// both or one of the names is not defined and so we can't set up a valid
			// project folder, so don't go any further
			return TRUE;
		}
	}

    // we now have a location in which we can store the adaption project's knowledge
    // base, and we have to finally create an Adaptations folder here too for the
    // adapted output. do the Adaptations folder first
	m_curAdaptionsPath = m_curProjectPath + PathSeparator + m_adaptionsFolder;

	// check to see if this folder already exists
	bool bAdaptionsFolderExists = FALSE;
	bAdaptionsFolderExists = bAdaptionsFolderExists; // avoid warning
	if (::wxFileExists(m_curAdaptionsPath) || ::wxDirExists(m_curAdaptionsPath))
	{
		if (::wxDirExists(m_curAdaptionsPath))
		{
			// Adaptions folder already exists, so don't create it
			bAdaptionsFolderExists = TRUE;
		}
		else
		{
            // adaptations folder does not yet exist, but a file of that name does
            // exist, so it must be renamed before user can proceed. Abort after a
            // message is easiest way.
			wxString text;
			// IDS_ADAPTATIONS_CLASH // MFC error message has "Adaptions" rather than "Adaptations"
			text = text.Format(_(
"Sorry, there is a file named \"Adaptations\" in your \"%s\" folder. Please delete or rename it because Adapt It needs to use that name for a directory instead."),
			m_curProjectName.c_str());
			wxMessageBox(text, _T(""), wxICON_ERROR);
			LogUserAction(_T("A file named \"Adaptations\" exists interfering with creating the folder of same name. Aborting..."));
			// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
			wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
			return FALSE;
		}
	}
	else
	{
		// language-specific Work folder does not yet exist, so create it.
		bool bOK = ::wxMkdir(m_curAdaptionsPath); //bool bOK = ::CreateDirectory(m_curAdaptionsPath,NULL);
		// WX NOTE: On Unix/Linux wxMkdir has a second default param: int perm = 0777 which
		// makes a directory with full read, write, and execute permissions.
		if (!bOK)
		{
			// IDS_CREATE_DIR3_FAILED // MFC error message has "Adaptions" rather than "Adaptations"
			wxMessageBox(_(
"Sorry, there was an error creating the \"Adaptations\" folder in your project folder. Adapt It is not set up properly and so must close down."),
			_T(""), wxICON_ERROR);
			LogUserAction(_T("Error creating the \"Adaptations\" folder in the project folder"));
			wxASSERT(FALSE);
			return FALSE;
		}
		bAdaptionsFolderExists = TRUE; // it now exists
	}

	// whm 12Jun11 added the following for creating inputs and outputs directories
	wxString pathCreationErrors = _T("");
	CreateInputsAndOutputsDirectories(m_curProjectPath, pathCreationErrors);

	if (!pathCreationErrors.IsEmpty())
	{
			wxString str;
			str = str.Format(_(
"Sorry, there was an error creating the following folder(s) in your Adapt It %sWork folder.\n%s\nAdapt It is not set up correctly and so must close down."),
			m_strNR.c_str(),pathCreationErrors.c_str());
			wxMessageBox(str, _T(""), wxICON_ERROR);
			wxASSERT(FALSE);
			return FALSE;
	}

    // we have the desired directory structures. But in case the document was a MRU
    // list one saved when book mode was on, we must set up the appropriate book folder
    // path or not, depending on the serialized in information in the document
    // (SetupDirectories() is called immediately after a MRU document is serialized in,
    // so the user can have done nothing to muck up the restored book mode settings
    // which we will use now

    // BEW added 09Jan06; we also need to do this in case SetupDirectories() was called
    // on someone else's computer as part of the Unpack Document... command, because it
    // cannot be certain that that person will already have turned on book mode, but
    // the person who packed the document may have had it on. In fact, Pack and Unpack
    // forces us to add code here to check the relevant folders have been created in
    // the Adaptations folder, and if not, we must first create them and set the
    // m_pCurrBookNamePair app member.
	if (m_bBookMode && !m_bDisableBookMode)
	{
        // check the book folders are already present, and if not then create them whm
        // note: AreBookFoldersCreated() has the side effect of changing the current
        // work directory to the passed in m_curAdaptionsPath.
		bool bFoldersPresent = AreBookFoldersCreated(m_curAdaptionsPath);
		if (!bFoldersPresent)
		{
			CreateBookFolders(m_curAdaptionsPath,m_pBibleBooks);
		}

		// set the current folder and its path
		m_pCurrBookNamePair = ((BookNamePair*)(*m_pBibleBooks)[m_nBookIndex]);
		m_bibleBooksFolderPath = m_curAdaptionsPath + PathSeparator + m_pCurrBookNamePair->dirName;
	}
	else
	{
		m_bibleBooksFolderPath.Empty();
		m_pCurrBookNamePair = NULL;
		if (m_bDisableBookMode)
			gbAbortMRUOpen = TRUE;
	}

	//Now we need to get a KB initialized and stored in the languages-specific folder.
	// Ditto for the glossing KB (version 2)
	// BEW changed 15Aug05
	// whm 26Aug11 modified wxProgressDialog to be able to pass pProgDlg pointers
	// to LoadKB() and LoadGlossingKB(). Modified also to treat setting up of KB
	// and Glossing KB separately with separate wxProgressDialog calls. We can't
	// use the same wxProgressDialog instance for both the KB and the Glossing KB,
	// because they will have different maximum range values.
	SetupKBPathsEtc();

	// whm revised 28Aug11: The CreateAndLoadKBs() function below now encapsulates
	// the creation of in-memory KB objects and the loading of external xml file
	// data into those objects. It also allows program control to continue on
	// failures after notifying the user of the failures.
	// The CreateAndLoadKBs() is called from here as well as from
	// the View's OnCreate(), the CollabUtilities' HookUpToExistingAIProject()
	// and the ProjectPage::OnWizardPageChanging().
	//
	// open the two knowledge bases and load their contents;
	if (!CreateAndLoadKBs())
	{
		// deal with failures here
		// There is not much we can do other than what was suggested in the
		// error messages within CreatAndLoadKBs() itself.
		//
		// whm TODO: Go through each use of SetupDirectories() and adjust
		// the code subsequent to its use to best deal with such failures.
		//
		// whm Note: The SetupDirectories() is called from: the App's
		// OnRestoreDefaultWorkFolderLocation(), the Doc's OnOpenDocument(),
		// DoUnpackDocument(), CreateNewAIProject() in CollabUtilities, and from
		// CLangaugesPage::OnWizardPageChanging() when the wizard page is moving
		// forward.
	}

	return m_bKBReady;
}


bool CAdapt_ItApp::CreateInputsAndOutputsDirectories(wxString curProjectPath, wxString& pathCreationErrors)
{
	wxASSERT(!curProjectPath.IsEmpty());
	bool bCreatedOK = TRUE;
	if (!curProjectPath.IsEmpty())
	{
		m_sourceInputsFolderPath = curProjectPath + PathSeparator + m_sourceInputsFolderName;
		m_freeTransOutputsFolderPath = curProjectPath + PathSeparator + m_freeTransOutputsFolderName;
		m_freeTransRTFOutputsFolderPath = curProjectPath + PathSeparator + m_freeTransRTFOutputsFolderName;
		m_glossOutputsFolderPath = curProjectPath + PathSeparator + m_glossOutputsFolderName;
		m_glossRTFOutputsFolderPath = curProjectPath + PathSeparator + m_glossRTFOutputsFolderName;
		m_interlinearRTFOutputsFolderPath = curProjectPath + PathSeparator + m_interlinearRTFOutputsFolderName;
		m_sourceOutputsFolderPath = curProjectPath + PathSeparator + m_sourceOutputsFolderName;
		m_sourceRTFOutputsFolderPath = curProjectPath + PathSeparator + m_sourceRTFOutputsFolderName;
		m_targetOutputsFolderPath = curProjectPath + PathSeparator + m_targetOutputsFolderName;
		m_targetRTFOutputsFolderPath = curProjectPath + PathSeparator + m_targetRTFOutputsFolderName;
		m_kbInputsAndOutputsFolderPath = curProjectPath + PathSeparator + m_kbInputsAndOutputsFolderName;
		m_liftInputsAndOutputsFolderPath = curProjectPath + PathSeparator + m_liftInputsAndOutputsFolderName;
		// Note: the m_packedInputsAndOutputsFolderPath uses m_workFolderPath or m_customWorkFolderPath, not
		// curProjectPath (see OnInit()).
		// Note: the m_ccTableInputsAndOutputsFolderPath uses m_workFolderPath or m_customWorkFolderPath, not
		// curProjectPath (see OnInit()).
		m_reportsOutputsFolderPath = curProjectPath + PathSeparator + m_reportsOutputsFolderName;

		if (!::wxDirExists(m_sourceInputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_sourceInputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_sourceInputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_sourceInputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_freeTransOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_freeTransOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_freeTransOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_freeTransOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_freeTransRTFOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_freeTransRTFOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_freeTransRTFOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_freeTransRTFOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_glossOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_glossOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_glossOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_glossOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_glossRTFOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_glossRTFOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_glossRTFOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_glossRTFOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_interlinearRTFOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_interlinearRTFOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_interlinearRTFOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_interlinearRTFOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_sourceOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_sourceOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_sourceOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_sourceOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_sourceRTFOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_sourceRTFOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_sourceRTFOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_sourceRTFOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_targetOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_targetOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_targetOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_targetOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_targetRTFOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_targetRTFOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_targetRTFOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_targetRTFOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_kbInputsAndOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_kbInputsAndOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_kbInputsAndOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_kbInputsAndOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_liftInputsAndOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_liftInputsAndOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_liftInputsAndOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_liftInputsAndOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		// OnInit() creates the _PACKED_INPUTS_OUTPUTS, but we can check that
		// it is created here
		if (!::wxDirExists(m_packedInputsAndOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_packedInputsAndOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_packedInputsAndOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_packedInputsAndOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		// OnInit() creates the _CCTABLE_INPUTS_OUTPUTS, but we can check that
		// it is created here
		if (!::wxDirExists(m_ccTableInputsAndOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_ccTableInputsAndOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_ccTableInputsAndOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_ccTableInputsAndOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
		if (!::wxDirExists(m_reportsOutputsFolderPath))
		{
			bool bOK = ::wxMkdir(m_reportsOutputsFolderPath);
			if (!bOK)
			{
				if (!pathCreationErrors.IsEmpty())
				{
					pathCreationErrors += _T("\n   ");
					pathCreationErrors += m_reportsOutputsFolderName;
				}
				else
				{
					pathCreationErrors += _T("   ");
					pathCreationErrors += m_reportsOutputsFolderName;
				}
				bCreatedOK = FALSE;
			}
		}
	}
	return bCreatedOK;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return    nothing
/// \remarks
/// Called from: the App's SetupDirectories(), the Doc's DoUnpackDocument(), the
/// CProjectPage::OnWizardPageChanging() when the wizard page is moving forward, and
/// CAdapt_ItView::OnCreate().
/// SetupKBPathsEtc() composes the path and file names for the regular KB and its backup
/// and the path and file names for the glossing KB and its backup.
/// BEW 1Aug09, added a call of this function to view's OnCreate() function to remove a
/// bug in which the File / New command was erasing the project's KB file.
/// BEW changed 3Mar11 at Bob Eaton's request, .BAK.xml should be just .BAK
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetupKBPathsEtc()
{
	wxString saveName;
	// only XML input &  output
	m_curKBName = m_curProjectName + _T(".xml");
	m_curKBPath = m_curProjectPath + PathSeparator + m_curKBName;
	m_curKBBackupPath = m_curProjectPath + PathSeparator + m_curProjectName + _T(".BAK");

	// now the same stuff for the glossing KB
	saveName = m_curGlossingKBName;
	m_curGlossingKBPath = m_curProjectPath + PathSeparator + saveName + _T(".xml");
	m_curGlossingKBBackupPath = m_curProjectPath + PathSeparator + saveName + _T(".BAK");
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE
/// \param      punctPgCommon   ->  pointer to the actual punctuation page in use
/// \param      reparseDoc      ->  enum value of DoReparse
///                                 (NoReparse if available but not used)
/// \remarks
/// Called from: CPunctCorrespPagePrefs::OnOK().
/// DoPunctuationChanges() detects if the user has changed any punctuation correspondences.
/// If so, it calls the Doc's RetokenizeText() function to rebuild the document with the
/// new punctuation scheme. It also insures that safe indices are set up and that the
/// phrasebox is appropriately located after the doc rebuild is complete.
/// Note: since called from the wizard, by the time it is called, a project should have
/// been chosen and therefore the KB and Glossing KB should each have been instantiated,
/// and so the app's members m_pKB and m_pGlossingKB should be valid pointers.
/// BEW 11Oct10 (actually 11Jan11) added test for m_punctuation[1] (target punctuation
/// characters) being changed -- if they were, then that too needs to trigger a reparse
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::DoPunctuationChanges(CPunctCorrespPageCommon* punctPgCommon,
										enum Reparse reparseDoc)
{
	// whm added 26Apr05
    // BEW ammended 06May05 to handle the possibility of variation in the final box
    // location and its contents, and to get the indices set up safely before
    // RedrawEverything() is called in the caller. This function currently only has code to
    // detect punctuation changes and if reparse is called for executes the main block and
    // calls RetokenizeText().
	if (reparseDoc == DoReparse)
	{
		CAdapt_ItDoc* pDoc = GetDocument();
		CAdapt_ItView* pView = gpApp->GetView();

        // if the source punctuation was empty and remains so, then don't retokenize (we check
        // just the source puncts because it is these that get stripped out in parsing)
		if (!(punctPgCommon->m_punctuationBeforeEdit[0].IsEmpty() && m_punctuation[0].IsEmpty()))
		{
			// the source or target punctuation list has changed, so do the retokenization
			int nOldCount = m_pSourcePhrases->GetCount();
			int difference = 0;

            // BEW 4Feb11, legacy comment; it is now deprecated - see below
            // make sure we don't lose the active sourcephrase's contents from the KB
            // (if the sourcephrase's m_bHasKBEntry is TRUE, then no store will be done
            // - which is what we'd want because that means it has already been done;
            // but if FALSE, then the store gets done (which again is what we want,
            // because the FALSE value means that the active location's KB entry has
            // already been removed (or its count decremented) and so a re-store is
            // appropriate now -- because the box location may end up elsewhere
            // depending on the results of the rebuild process.)
			// BEW 4Feb11 DO NOT CALL StoreBeforeProceeding() when the punctuation set
			// or sets is/ are in the process of being changed. If it is called, it
			// cannot be guaranteed that the target text of the entry being put in the
			// KB will be correct. See the descriptive header before the definition of
			// the StoreBeforeProceeding() function for more details why this is
			// dangerous
			//pView->StoreBeforeProceeding(m_pActivePile->GetSrcPhrase()); <<-- it's better
			//to do no store than to do a possibly bogus one, the user won't see a
			//bogus KB entry storage, but he will notice a target text in the layout
			//which may need it's punctuation or word spelling altered - so we'll go
			//for the safer option. Since the punctuation settings are already
			//altered, the store if done now, may not have right spelling for tgt text

			wxString strSavePhraseBox = m_targetPhrase;
            // now do the reparse - the functions which effect the reconstitution of
            // the doc when punctuation was changed, or when filtering settings were
            // changed, or both, will progressively update the view's m_nActiveSequNum
            // value as necessary so that the stored phrase box contents and the final
            // active location remain in sync.
			int nNewSrcPhraseCount = pDoc->RetokenizeText(TRUE,	// TRUE = punctuation only changing here
														FALSE,	// bFilterChange FALSE = no filter changes here
														FALSE);	// bSfmSetChange FALSE = no sfm set change here

			// set up some safe indices, since the counts could be quite different
			// than before
			difference = nNewSrcPhraseCount - nOldCount; // could even be negative, but unlikely
			// difference should not be negative; it is expected to be 0 or, in very rare
			// circumstances where an extra CSourcePhrase might get generated (which we
			// try hard in TokenizeText() and so in RetokenizeText() which calls it, to avoid
			// doing) so we need to test for difference being negative
			wxCHECK_MSG(!(difference < 0), TRUE, _T("DoPunctuationChanges(): fewer CSourcePhrases produced, line 19,880 Adapt_It.cpp"));

            // for refactored layout code, the following suffices because
			// m_nActiveSequNum remains unchanged within the document; we defer the
			// RecalcLayout() call to later though
			CSourcePhrase* pSrcPhrase = NULL;
			m_targetPhrase = strSavePhraseBox; // restore the phrase box contents
			pSrcPhrase = pView->GetSrcPhrase(m_nActiveSequNum);
			wxASSERT(pSrcPhrase);

			// remove the KB or GlossingKB entry for this location, depending on the mode
			// and make the box contents resaveable
			if (gbIsGlossing)
			{
				if (m_pGlossingKB != NULL)
				{
					m_pGlossingKB->GetAndRemoveRefString(pSrcPhrase, m_targetPhrase,
														useTargetPhraseForLookup);
				}
			}
			else
			{
				if (m_pKB != NULL)
				{
					m_pKB->GetAndRemoveRefString(pSrcPhrase, m_targetPhrase,
														useTargetPhraseForLookup);
				}
			}
			// BEW changed 4Mar11, it needs to be set TRUE, if at all, in the OnOK()
			// call of CPunctCorrespPage class, as that function is always called on
			// exit of Preferences, and if the punctuation hasn't been changed,
			// DoPunctuationChanges() should not then be called (doing it here was too late)
			//m_pLayout->m_bPunctuationChanged = TRUE; // do full rebuild of the layout
		}
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int value representing the active sequence number of a safe phrase
///             box location
/// \param      pView   -> pointer to the View
/// \remarks
/// Called from: the App's DoPunctuationChanges() and the Doc's
/// ReconstituteAfterFilteringChange(). Gets a safe location for placing the phrase box. It
/// avoids placing the phrase box in a retranslation (unless that is the only possible
/// place), and prepares for a bundle change if the safe location is outside the current
/// bundle.
////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::GetSafePhraseBoxLocationUsingList(CAdapt_ItView* pView)
{
    // for GetSafePhraseBoxLocationUsingList() to work correctly, the view's
    // m_nActiveSequNum value must be set to a valid list location before the function is
    // called; and likewise for the view's maximum index value
	//
	// get the sourcephrase which is at the potential active location
	CSourcePhrase*  pSrcPhrase = pView->GetSrcPhrase(m_nActiveSequNum);

	// this location could be in a retranslation, so adjust the sequence number
	// and its sourcephrase if that is the case
	CSourcePhrase* pSaveSrcPhrase = pSrcPhrase;
	if (pSrcPhrase->m_bRetranslation)
	{
		// its a retranslation location, so move active location to an earlier sequence
		// number until we find a sourcePhrase which is not in the retranslation
		int nPrevSequNum = m_nActiveSequNum - 1;
		CSourcePhrase* pNextSrcPhrase = NULL;
		if (nPrevSequNum < 0)
		{
			// we are at the start of the document and still within a
			// retranslation, so search forward instead
a:			pNextSrcPhrase = pSaveSrcPhrase;
			int nNextSequNum = m_nActiveSequNum;
			while (pNextSrcPhrase->m_bRetranslation)
			{
				++nNextSequNum;
				if (nNextSequNum > GetMaxIndex())
				{
                    // there is nowhere where there is no retranslation so go to the start
                    // & just too bad - put the box in a retranslation!!!! It's naughty,
                    // but the app will not die.
					{
						nNextSequNum = 0;
						pNextSrcPhrase = pView->GetSrcPhrase(nNextSequNum);
						break;
					}
				}
				pNextSrcPhrase = pView->GetSrcPhrase(nNextSequNum);
			} // loop end
			pSrcPhrase = pNextSrcPhrase;
			m_nActiveSequNum = pNextSrcPhrase->m_nSequNumber;
		}
		else
		{
			// not yet at the doc start, so we can search back further
			CSourcePhrase* pPrevSrcPhrase = pView->GetSrcPhrase(nPrevSequNum);
			while (pPrevSrcPhrase->m_bRetranslation)
			{
				--nPrevSequNum;
				if (nPrevSequNum < 0)
				{
					goto a;
				}
				pPrevSrcPhrase = pView->GetSrcPhrase(nPrevSequNum);
			} // loop end
			pSrcPhrase = pPrevSrcPhrase;
			m_nActiveSequNum = pPrevSrcPhrase->m_nSequNumber;
		}
	}

	// inform, via a member in the app class, the DoUsfmFilterChanges() function of the
	// m_srcPhrase string value at the pSrcPhrase location
	m_strFiltering_SrcText_AtNewLocation = pSrcPhrase->m_srcPhrase;

	// set m_targetPhrase
	if (gbIsGlossing)
		m_targetPhrase = pSrcPhrase->m_gloss;
	else
		m_targetPhrase = pSrcPhrase->m_adaption;

	// BEW added 29Jul09, get the phrase box text into the box and all selected
	m_pTargetBox->ChangeValue(m_targetPhrase);
	m_nStartChar = -1;
	m_nEndChar = -1;
	if (m_pTargetBox != NULL)
	{
		m_pTargetBox->SetSelection(m_nStartChar, m_nEndChar); // select it all
	}

	return m_nActiveSequNum;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE
/// \param      pUsfmFilterPageCommon ->  pointer to the usfmFilterPage being
///                                     displayed
/// \param      reparseDoc           ->  enum value that can be either NoReparse or
///                                     DoReparse
/// \remarks
/// Called from: the CUsfmFilterPageWiz::OnWizardPageChanging() when moving forward, and the
/// CUsfmFilterPagePrefs::OnOK().
/// Updates the internal data structures for any changes made in the usfm filter page.
/// It first checks for filtering changes made to the markers currently being
/// used in the Doc. If filtering changes are made in the doc and/or the parameter
/// reparseDoc == DoReparse, DoUSFMFilterChanges calls RetokenizeText() with the
/// appropriate flags. Next, DoUSFMFilterChanges checks for filtering changes made to the
/// list of markers stored in the Project (config file), and if changes were made, stores
/// the updated filtering markers list in the App's gProjectFilterMarkersForConfig for
/// later writing to the project config file.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::DoUsfmFilterChanges(CUsfmFilterPageCommon* pUsfmFilterPageCommon,
				enum Reparse reparseDoc)
{
	// whm added 26Apr05
	CAdapt_ItDoc* pDoc = GetDocument();
	CAdapt_ItView* pView = gpApp->GetView();

	bool bFilterChangeInDoc = FALSE;
	bool bFilterChangeInProj = FALSE;
	wxString tempStr;
	wxString filterMkr;
	wxString strMarkersToBeUnfiltered;
	wxString strMarkersToBeFiltered;
	strMarkersToBeUnfiltered.Empty();
	strMarkersToBeFiltered.Empty();

	// added for Bruce 1Apr05
	gpApp->m_FilterStatusMap.empty(); // start with empty map

    // since the CUIntArrays contain all the document's markers, and since the user cannot
    // add markers in the GUI which calls this function, the sizes must be identical
	int countBeforeEdit = (int)pUsfmFilterPageCommon->m_filterFlagsDocBeforeEdit.GetCount();
	int countAfterEdit = (int)pUsfmFilterPageCommon->m_filterFlagsDoc.GetCount();
	wxASSERT(countBeforeEdit == countAfterEdit);

	// While we don't make use of their variable, there is no reason why countBeforeEdit
	// should not differ from countAfterEdit, so just do identity assignments here in
	// order to avoid a compiler warning (BEW 2Jan12)
	countBeforeEdit = countBeforeEdit; // avoid warning
	countAfterEdit = countAfterEdit; // avoid warning

	int numFlags = (int)pUsfmFilterPageCommon->m_filterFlagsDoc.GetCount();
    // The usfm filter page's m_SfmMarkerAndDescriptionsDoc wxStringArray and the parallel
    // m_filterFlagsDoc CUIntArray contain data for both known and unknown markers. The
    // former contains the list box formatted whole marker and its description. The later
    // contains flags indicating the filter state of the associated/parallel markers.
	// Below we do the following filter marker housekeeping and data processes:
	// 1. Check for changes in the filter state of markers (both known and unknown markers)
	// 2. For markers whose filtering state has changed, we do the following:
	//    a. build the pDoc->m_FilterStatusMap which Bruce uses in the doc rebuild code.
	//    b. build the strMarkersToBeUnfiltered and strMarkersToBeFiltered strings for
	//       ResetUSFMFilterStructs() - DoUsfmFilterChanges now uses Bruce's version of
	//       ResetUSFMFilterStructs which handles the reset of USFM filter structs correctly
	//       whereas the original version did not handle unfiltering correctly here in
	//       DoUsfmFilterChanges.
	for (int index = 0; index < numFlags;  index++)
	{
		if (pUsfmFilterPageCommon->m_filterFlagsDoc[index] !=
			pUsfmFilterPageCommon->m_filterFlagsDocBeforeEdit[index])
		{
			bFilterChangeInDoc = TRUE;
			// while we are at it, collect the markers that need changing into a string
			// that can be input into the Doc's ResetUSFMFilterStructs().

			tempStr = pUsfmFilterPageCommon->m_SfmMarkerAndDescriptionsDoc[index];
			int strLen = tempStr.Length();
			int spCt = 0;
			int nwspCt = 0;
			// parse white space at begtinning of string
			while(spCt < strLen && tempStr.GetChar(spCt) == _T(' '))
			{
				spCt++;
			}
			// remove prefixed white space
			tempStr = tempStr.Mid(spCt);
			filterMkr.Empty();
			// parse the whole marker
			while(nwspCt < strLen && tempStr.GetChar(nwspCt) != _T(' '))
			{
				filterMkr += tempStr.GetChar(nwspCt);
				nwspCt++;
			}

			filterMkr.Trim(TRUE); // trim right end
			filterMkr.Trim(FALSE); // trim left end

			wxString valStr;
			if (gpApp->m_FilterStatusMap.find(filterMkr) == gpApp->m_FilterStatusMap.end())
			{
				// marker does not already exist in m_FilterStatusMap so add it
				if (pUsfmFilterPageCommon->m_filterFlagsDocBeforeEdit[index] == 0	// previously unfiltered
					&& pUsfmFilterPageCommon->m_filterFlagsDoc[index] == 1)			// now filtered
				{
					gpApp->m_FilterStatusMap[filterMkr] = _T("1");
					strMarkersToBeFiltered += filterMkr + _T(' ');
				}
				else if (pUsfmFilterPageCommon->m_filterFlagsDocBeforeEdit[index] == 1	// previously filtered
					&& pUsfmFilterPageCommon->m_filterFlagsDoc[index] == 0)				// now unfiltered
				{
					gpApp->m_FilterStatusMap[filterMkr] = _T("0");
					strMarkersToBeUnfiltered += filterMkr + _T(' ');
				}
			}
		}
	}

	// whm added 12May06
    // Mark the doc as "dirty" so the save toolbar button will be active to allow the user
    // to save changes to the doc, and if he immediately exits the program it will prompt
    // to save those changes. This should go here rather than within the if
    // (bFilterChangeInDoc) block below, because under certain circumstances the doc can
    // change without bFilterChangeInDoc changing to TRUE.
	pDoc->Modify(TRUE);

	if (bFilterChangeInDoc)
	{
		// Any filter change in the Doc requires updating the current USFM and Filtering data
		// structures.

		// Update the active set of USFMAnalysis structs.
        // ResetUSFMFilterStructs calls the App's SetupMarkerStrings which updates
        // gCurrentFilterMarkers Use Bruce's version of ResetUSFMFilterStructs
		pDoc->ResetUSFMFilterStructs(gpApp->gCurrentSfmSet, strMarkersToBeFiltered,
										strMarkersToBeUnfiltered);

        // When there is a set change, the Doc's m_filterMarkersAfterEdit and the App's
        // gCurrentFilterMarkers should have been set to the same string value in
        // DoUsfmSetChanges, however, when there was no set change, but was a filtering
        // change the Doc's m_filterMarkersAfterEdit needs to be updated
		gpApp->m_filterMarkersAfterEdit = gCurrentFilterMarkers;

		if (reparseDoc == DoReparse)
		{
			// Reparse the Document
			if (gpApp->m_nActiveSequNum < 0)
			{
                // must not have data yet, or we are at EOF and so no pile is currently
                // active
				gpApp->m_nActiveSequNum = -1; // was activeSequNum = -1;
			}
			else
			{
				// we are somewhere in the midst of the data, so a pile will be active
				if (gpApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber >= 0)
				{
					// remove any current selection, as we can't be sure of any pointers
					// depending on what user may choose to alter
					pView->RemoveSelection();
				}
			}

            // as in DoPunctuationChanges, we need to be sure we can recreate the phrase
            // box safely so changes will be needed here; however, this is done at a lower
            // level within RetokenizeText(), and typically the box location is preserved,
            // so it makes sense to retain its contents for redisplay when unfiltering &
            // filtering has completed -- however, if the phrase box was located within a
            // stretch which got filtered out, then it's location will be changed to
            // somewhere close by (the app tries to put it at the first safe location
            // following where its earlier location was destroyed by the filtering) - and
			// restoring the old contents will in that case be wrong without the tweaks we
			// do here and after the RetokenizeText() call -- see comments below for more
			// details
			wxString strSavePhraseBox = gpApp->m_targetPhrase;
            // BEW added 29Jul09, save the m_srcPhrase contents for use in the test after
            // RetokenizeText() returns
			wxString savedSrcPhrase = gpApp->m_pActivePile->GetSrcPhrase()->m_srcPhrase;

			// now do the reparse
			int nNewSrcPhraseCount = pDoc->RetokenizeText(FALSE, // FALSE = punctuation not changed here
															bFilterChangeInDoc,
															FALSE); // FALSE = sfm set change not flagged here
			// a dummy line to avoid a compiler warning
			nNewSrcPhraseCount = nNewSrcPhraseCount;

			// BEW added 29Jul09, use the saved value when the CSourcePhrase which is the
			// active location hasn't changed (the m_strFiltering_SrcText_AtNewLocation
			// string is set at the end of the GetSafePhraseBoxLocationUsingList()
			// function) Note: the reason we can't use the CSourcePhrase:m_nSequNumber
			// value here instead is because filtering consumes pile instances and
			// sequence number reordering may result in a different CSourcePhrase instance
			// becoming the new active location but it may end up with the same sequence
			// number value as for the old active location - testing for identity of
			// sequence numbers would then give wrong results
			if (savedSrcPhrase == m_strFiltering_SrcText_AtNewLocation)
			{
				// restore what the phrase box's old contents were (this will override
				// whatever value GetSafePhraseBoxLocationUsingList() set at its end; but
				// that function's value will be used instead whenever the the active
				// location has moved to a different CSourcePhrase instance.
				// Note: if when unfiltering something the active location is place in the
				// unfiltered content, we cannot restore the former adaptation (or gloss)
				// text there because such text is irretrievably lost when the filtering
				// was done earlier
				gpApp->m_targetPhrase = strSavePhraseBox;
			}
		}
		else
		{
			// No Reparse of the Document is called for
			;
		}
		m_pLayout->m_bFilteringChanged = TRUE;
	}

	// Now check for changes in the Project's list of filter markers
	wxString filterMkrStr;
	filterMkrStr.Empty(); // start with an empty string
	countBeforeEdit = (int)pUsfmFilterPageCommon->m_filterFlagsProjBeforeEdit.GetCount();
	countAfterEdit = (int)pUsfmFilterPageCommon->m_filterFlagsProj.GetCount();
	wxASSERT(countBeforeEdit == countAfterEdit);
	numFlags = (int)pUsfmFilterPageCommon->m_filterFlagsProj.GetCount();
	for (int index = 0; index < numFlags;  index++)
	{
		// Collect the markers to store as new filter marker defaults for the Project
		// in case user made a change.
		// whm modified 23Sep10 to do more robust parsing of marker
		//int posn = pUsfmFilterPageCommon->m_SfmMarkerAndDescriptionsProj[index].Find(_T("  "));
		//filterMkr = pUsfmFilterPageCommon->m_SfmMarkerAndDescriptionsProj[index].Mid(0,posn);
		filterMkr = pUsfmFilterPageCommon->m_SfmMarkerAndDescriptionsProj[index];
		filterMkr.Trim(FALSE); // trim left end
		int spPos = filterMkr.Find(_T(' '));
		wxASSERT(spPos != -1);
		filterMkr = filterMkr.Mid(0,spPos);
		filterMkr.Trim(TRUE); // trim right end
		if (pUsfmFilterPageCommon->m_filterFlagsProj[index] == TRUE)
		{
			filterMkrStr += filterMkr + _T(' ');
		}
		// check for changes
		if (pUsfmFilterPageCommon->m_filterFlagsProj[index] !=
			pUsfmFilterPageCommon->m_filterFlagsProjBeforeEdit[index])
		{
			bFilterChangeInProj = TRUE;
		}
	}

	if (bFilterChangeInProj)
	{
		// Filtering changes in the Project do not require adjustments to any of the
		// document's current data structures. Project changes only require storing the
		// new list of filter marker strings in the App's gProjectFilterMarkersForConfig
		// for later saving in the project config file.
		// Note: Here is the only place where gProjectFilterMarkersForConfig is set.
		// The filter markers saved in the project config file are only set from the
		// Filtering tab/wizard page.
		gpApp->gProjectFilterMarkersForConfig  = filterMkrStr;
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE
/// \param      pUsfmFilterPageCommon   -> pointer to the usfmFilterPage
/// \param      bSetChanged       <- TRUE by reference if the sfm set changed,
///                                  FALSE otherwise
/// \param      reparseDoc        -> enum value that can be either NoReparse
///                                  or DoReparse
/// \remarks
/// Called from: the CUsfmFilterPageWiz::OnWizardPageChanging() when moving forward, and the
/// CUsfmFilterPagePrefs::OnOK().
/// It updates the internal data structures for any changes made to the sfm set in the
/// usfmFilterPage. It calls RetokenizeText with reparseDoc == DoReparse if the user changed
/// the SfmSet in the document.
/// whm 5Oct10 modified user workflow profiles compatibility.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::DoUsfmSetChanges(CUsfmFilterPageCommon* pUsfmFilterPageCommon,
									bool& bSetChanged, enum Reparse reparseDoc)
{
	// whm added 23May05
	CAdapt_ItDoc* pDoc = GetDocument();
	CAdapt_ItView* pView = gpApp->GetView();

	wxString filterMkr;
	wxString filterMkrStr = _T("");

	// added for Bruce 1Apr05
	gpApp->m_FilterStatusMap.clear(); // start with empty map

    // whm Note 29Jun05: DoUsfmSetChanges() is always called when the user clicks on OK in
    // Preferences, and/or clicks FINISH in the wizard. As long as the local copies of the
    // following variables are properly initialized in the Usfm Filter page's
    // constructors, we can unconditionally copy those local copies back to their
    // corresponding variables on the App and Doc when the user clicks on OK in the
    // Preferences, and/or clicks FINISH in the wizard. These variables are:
	// 1. gpApp->gCurrentSfmSet (enum SfmSet) [always represents the current sfm set of
	//     the active document]
	// 2. gpApp->gCurrentFilterMarkers (wxString) [always represents the filter markers
	//     of the active document]
	// 3. gpApp->gProjectSfmSetForConfig (enum SfmSet) [always has the current value for
	//     storing in proj config]
	// 4. gpApp->gProjectFilterMarkersForConfig (wxString) [always has the current value
	//     for storing in proj config]
	// 5. gpApp->m_sfmSetAfterEdit (enum SfmSet)
	// 6. gpApp->m_filterMarkersAfterEdit (wxString)
	// 7. gpApp->m_unknownMarkers (CStringArray)
	// 8. gpApp->m_filterFlagsUnkMkrs (CUIntArray)
	// 9. gpApp->m_currentUnknownMarkersStr (wxString)
    // When checking code integrity, the above should be used to initialize the
    // corresponding temporary local variables used in the Usfm Filter page.
    // Only the temporary local variables should be modified while the Preferences and/or
    // Wizard are active. Only when the user clicks OK in Preferences or FINISH in the
    // wizard, should the temporary local variables be used to update the above global
    // variables on the App.

    // Update the sfm set stored in gCurrentSfmSet on the App (gCurrentSfmSet always
    // reflects the state of the current Doc) with the USFM and Filtering page's
    // tempSfmSetAfterEditDoc
	if (pUsfmFilterPageCommon != NULL)
		gpApp->gCurrentSfmSet = pUsfmFilterPageCommon->tempSfmSetAfterEditDoc;
	// Update the App's gCurrentFilterMarkers with the USFM and Filtering page's
	// tempFilterMarkersAfterEditDoc
	if (pUsfmFilterPageCommon != NULL)
		gpApp->gCurrentFilterMarkers = pUsfmFilterPageCommon->tempFilterMarkersAfterEditDoc;
	// Update the global for the project sfm set with the USFM and Filtering page's
	// tempSfmSetAfterEditProj
	if (pUsfmFilterPageCommon != NULL)
		gpApp->gProjectSfmSetForConfig = pUsfmFilterPageCommon->tempSfmSetAfterEditProj;
	// Update the global for the project's filter markers with the USFM and Filtering page's
	// tempFilterMarkersAfterEditProj
	if (pUsfmFilterPageCommon != NULL)
		gpApp->gProjectFilterMarkersForConfig = pUsfmFilterPageCommon->tempFilterMarkersAfterEditProj;
	// Update the sfm set stored on the App with the USFM and Filtering page's
	// tempSfmSetAfterEditDoc
	if (pUsfmFilterPageCommon != NULL)
		gpApp->m_sfmSetAfterEdit = pUsfmFilterPageCommon->tempSfmSetAfterEditDoc; // whm added
		// 10Jun05 for Bruce
	// Update the list of filter markers on the App with the USFM and Filtering page's
	// tempFilterMarkersAfterEditDoc
	if (pUsfmFilterPageCommon != NULL)
		gpApp->m_filterMarkersAfterEdit = pUsfmFilterPageCommon->tempFilterMarkersAfterEditDoc;

#ifdef _Trace_UnknownMarkers
	TRACE0("In DoUsfmSetChanges BEFORE Doc's unknown markers copied from pUsfmFilterPageCommon\n");
	TRACE1("   Doc's unknown markers = %s\n", pDoc->GetUnknownMarkerStrFromArrays(&pDoc->m_unknownMarkers, &pDoc->m_filterFlagsUnkMkrs));
	TRACE1("    Filter pg's unk mkrs = %s\n", pDoc->GetUnknownMarkerStrFromArrays(&pUsfmFilterPageCommon->m_unknownMarkers, &pUsfmFilterPageCommon->m_filterFlagsUnkMkrs));
#endif

	if (pUsfmFilterPageCommon != NULL)
	{
		// Update the unknown markers vars on the App with those in the Usfm Filter page
		gpApp->m_unknownMarkers.Clear();
		int ct;
		for (ct = 0; ct < (int)pUsfmFilterPageCommon->m_unknownMarkers.GetCount(); ct++)
			gpApp->m_unknownMarkers.Add(pUsfmFilterPageCommon->m_unknownMarkers.Item(ct));

		gpApp->m_filterFlagsUnkMkrs.Clear();
		for (ct = 0; ct < (int)pUsfmFilterPageCommon->m_filterFlagsUnkMkrs.GetCount(); ct++)
			gpApp->m_filterFlagsUnkMkrs.Add(pUsfmFilterPageCommon->m_filterFlagsUnkMkrs.Item(ct));
		gpApp->m_currentUnknownMarkersStr = pUsfmFilterPageCommon->m_currentUnknownMarkersStr;
	}

	if (pUsfmFilterPageCommon != NULL)
	{
		if (pUsfmFilterPageCommon->tempSfmSetBeforeEditDoc != pUsfmFilterPageCommon->tempSfmSetAfterEditDoc)
		{
			bSetChanged = TRUE; // return TRUE so that filtering call can be suppressed in caller
								// (caller must default this flag to FALSE before DoUsfmSetChanges
								// is called)
		}

		if (pUsfmFilterPageCommon->bChangeFixedSpaceToRegularSpace !=
			pUsfmFilterPageCommon->bChangeFixedSpaceToRegularBeforeEdit)
		{
			gpApp->m_bChangeFixedSpaceToRegularSpace = pUsfmFilterPageCommon->bChangeFixedSpaceToRegularSpace;
		}
	}

	// whm added 12May06
    // Mark the doc as "dirty" so the save toolbar button will be active to allow the user
    // to save changes to the doc, and if he immediately exits the program it will prompt
    // to save those changes. This should go here rather than within the if (bSetChanged)
    // block below, because under certain circumstances the doc can change without
    // bSetChanged changing to TRUE.
	pDoc->Modify(TRUE);

	if (bSetChanged)
	{

#ifdef _Trace_FilterMarkers
		TRACE0("In DoUsfmSetChanges BEFORE SetupMarkerStrings call:\n");
		TRACE1("   App's gCurrentSfmSet = %d\n",gpApp->gCurrentSfmSet);
		TRACE1("   App's gCurrentFilterMarkers = %s\n",gpApp->gCurrentFilterMarkers);
		TRACE1("   Doc's m_sfmSetBeforeEdit = %d\n",pDoc->m_sfmSetBeforeEdit);
		TRACE1("   Doc's m_filterMarkersBeforeEdit = %s\n",pDoc->m_filterMarkersBeforeEdit);
#endif

		// Sfm set change requires updating the rapid access data strings
		gpApp->SetupMarkerStrings();

#ifdef _Trace_FilterMarkers
		TRACE0("In DoUsfmSetChanges AFTER SetupMarkerStrings call:\n");
		TRACE1("   App's gCurrentSfmSet = %d\n",gpApp->gCurrentSfmSet);
		TRACE1("   App's gCurrentFilterMarkers = %s\n",gpApp->gCurrentFilterMarkers);
		TRACE1("   Doc's m_sfmSetBeforeEdit = %d\n",pDoc->m_sfmSetBeforeEdit);
		TRACE1("   Doc's m_filterMarkersBeforeEdit = %s\n",pDoc->m_filterMarkersBeforeEdit);

#endif
		if (reparseDoc == DoReparse)
		{

#ifdef _Trace_FilterMarkers
			TRACE0("In DoUsfmSetChanges reparse == DoReparse so calling RetokenizeText next\n");
#endif

			// Reparse the Document
			if (m_nActiveSequNum < 0)
			{
                // must not have data yet, or we are at EOF and so no pile is currently
                // active so do nothing here
				;
			}
			else
			{
				// phrase box is visible somewhere in the data, so a pile will be active
				m_nActiveSequNum = m_pActivePile->GetSrcPhrase()->m_nSequNumber;
				//gpApp->m_curIndex = activeSequNum;

				// remove any current selection, as we can't be sure of any pointers
				// depending on what user may choose to alter
				pView->RemoveSelection();
			}
			wxString strSavePhraseBox = gpApp->m_targetPhrase;
			// now do the reparse
			int nNewSrcPhraseCount = pDoc->RetokenizeText(
										FALSE,	// FALSE = punctuation not changed here
										FALSE,  // because any filtering changes are
										bSetChanged); // done as a side-effect
#ifdef _Trace_FilterMarkers
			TRACE0("In DoUsfmSetChanges AFTER RetokenizeText call:\n");
			TRACE1("   App's gCurrentSfmSet = %d\n",gpApp->gCurrentSfmSet);
			TRACE1("   App's gCurrentFilterMarkers = %s\n",gpApp->gCurrentFilterMarkers);
			TRACE1("   Doc's m_sfmSetBeforeEdit = %d\n",pDoc->m_sfmSetBeforeEdit);
			TRACE1("   Doc's m_filterMarkersBeforeEdit = %s\n",pDoc->m_filterMarkersBeforeEdit);
#endif

			nNewSrcPhraseCount = nNewSrcPhraseCount; // avoids a compile warning
													 // (we don't use this value)

            // version 3 always rebuilds the doc, so we need to unconditionally restore the
            // phrasebox contents... (The box contents will generally be correct and the
            // location unchanged, except if the SFM set change involved a filtering of
            // content in which the phrase box happened to be located - in which case the
            // phrase box will be relocated automatically at some nearby later safe
            // location, but the contents will no longer be appropriate when restored - but
            // the user will see that and can edit it immediately, so we won't do anything
            // smarter here.
			gpApp->m_targetPhrase = strSavePhraseBox;
		}
		else
		{
			// No Reparse of the Document called for
			;
		}
		m_pLayout->m_bUSFMChanged = TRUE;
	}
	return TRUE;
}

// whm Note: This macro is from Bob E
//	#define MAKE_DWORD(hw,lw) ((wxUint32) (((unsigned long)(hw)<<16) | ((unsigned long)(lw))) )

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pView   -> pointer to the View (unused)
/// \remarks
/// Called from: the Doc's OnNewDocument(), OnOpenDocument(), the View's OnInitialUpdate(),
/// CFontPageWiz::OnWizardPageChanging() when moving forward, and from
/// CFontPagePrefs::OnOK(). Gets the text heights for the source font (m_nSrcHeight), the
/// target font (m_nTgtHeight) and the navigation text font (m_nNavTextHeight). Each font
/// is selected into the display context and the GetCharHeight() method of the display
/// context is called to determine the height of each of the three fonts.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::UpdateTextHeights(CAdapt_ItView* WXUNUSED(pView))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// need a CDC
	wxClientDC dC(pApp->GetMainFrame()->canvas);
	wxASSERT(m_pSourceFont != NULL);
	wxFont SaveFont = dC.GetFont();
	dC.SetFont(*m_pSourceFont);
	m_nSrcHeight = dC.GetCharHeight();

    // whm note: The following is Bob Eaton's modification to detect if the font is a
    // symbol font, and if so, use a different "encoding" string in Adapt It's xml files.
    // Problem: m_nCodePage in the MFC version is a 32 bit int, whereas within the
    // wxWidgets font encoding representation they are represented as an enum, which has a
    // maximum of 255 different values. Bob's GetEncodingStringForXmlFiles() function has a
    // switch(m_nCodePage) statement which has 141 cases in it, but the values in the
    // switch/case range from 42 to 65006. The values above 255 are not legal for an enum,
    // so we can't map directly from MFC's code page values to wxWidget's wxFontEncoding
    // enum values. See the InitializeFonts() function for more info on wxWidgets and MFC
    // font encoding matters. See also the following functions:
	//    GetEncodingStringForXmlFiles() [Bob Eaton's function for Windows]
	//    MapMFCCharsetToWXFontEncoding()
	//    MapWXFontEncodingToMFCCharset()

	dC.SetFont(*m_pTargetFont);
	m_nTgtHeight = dC.GetCharHeight();

	// whm Note: The wxDC class does not use a separate TEXTMETRIC struct. Within
	// the wxDC class there appears to be no way to access an internal leading
	// value. And, the external leading value seems to be only available when
	// measuring an actual string of text using GetTextExtent().
#ifdef _RTL_FLAGS
    // still the Unicode version, but using CEdit for the base class for the phrase box box
    // height needs to include external and internal leading for CRichEditCtrl, else text
    // is cut off at the bottom by the bottom of the box; see globals for explanation of
    // gnVerticalBoxBloat
	gnVerticalBoxBloat = 0; //metrics.tmInternalLeading + metrics.tmExternalLeading;
#else
	gnVerticalBoxBloat = 0;
#endif // for _RTL_FLAGS

	// temporary - for use in fine tuning display code
	dC.SetFont(*m_pNavTextFont); // now handle the navigation text's font
	m_nNavTextHeight = dC.GetCharHeight();
	dC.SetFont(SaveFont); // restore original font
}

//////////////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if the store operation failed, TRUE if it succeeded
/// \param      bShowProgress -> flag to show or hide the wxProgressDialog
/// \remarks
/// Called from: the App's SetupDirectories(), SubstituteKBBackup(), the View's OnCreate(),
/// and CProjectPage::OnWizardPageChanging() when moving forward. Reads the data from an
/// existing xml glossing KB file if present. If the xml glossing KB file was not found
/// (or could not be read), it creates a new (empty) KB for glossing.
/// whm 26Aug11 revised to show or hide a wxProgressDialog
//////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::LoadGlossingKB(bool bShowProgress)
{
#ifdef SHOW_KB_I_O_BENCHMARKS
	wxDateTime dt1 = wxDateTime::Now(),
			   dt2 = wxDateTime::UNow();
#endif

	// whm 26Aug11 Open a wxProgressDialog instance here for "Loading the Knowledge
	// Base".
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process, starting with LoadGlossingKB() below.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	wxString msgDisplayed;
	wxString progMsg;
	wxProgressDialog* pProgDlg = (wxProgressDialog*)NULL;
	// add 1 chunk to insure that we have enough after int division above
	const int nTotal = GetMaxRangeForProgressDialog(XML_Input_Chunks,m_curGlossingKBPath) + 1;
	// Only show the progress dialog on request
	if (bShowProgress)
	{
		// Only create the progress dialog if we have data to progress
		if (nTotal > 0)
		{
			progMsg = _("Reading File %s - part %d of %d");
			wxFileName fn(m_curGlossingKBPath);
			msgDisplayed = progMsg.Format(progMsg,fn.GetFullName().c_str(),1,nTotal);
			pProgDlg = gpApp->OpenNewProgressDialog(_("Loading the Glossing Knowledge Base"),msgDisplayed,nTotal,500);
		}
	}

	bool bSaveIsGlossingFlag = gbIsGlossing;

    // set the gbIsGlossing flag to TRUE, as the XML needs to use it (it may have a
    // different value in the caller, so we restore it before returning)
	gbIsGlossing = TRUE;

    // first make sure the paths and filenames match are consistent with the m_gSaveAsXML
    // flag's value of TRUE (ie. set them to .xml extension, and the alternate filename and
    // path will have the .KB extension); or with FALSE (and the current and alternate are
    // the opposite)
	CAdapt_ItDoc* pDoc = GetDocument();
	pDoc->UpdateFilenamesAndPaths(FALSE,FALSE,FALSE,TRUE,TRUE);

	// some temporaries for the code below
	bool bReadOK = FALSE; // whm added initialization
	wxString path = m_curGlossingKBPath;

	// version 3.0 and upwards, the default is to do i/o in XML
	if (wxFileExists(path))
	{
		// the expected *.xml glossing knowledge base file is in the project folder
		// attempt the load
		if (bShowProgress)
		{
			bReadOK = ReadKB_XML(path, m_pGlossingKB, pProgDlg, nTotal);
		}
		else
		{
			bReadOK = ReadKB_XML(path, m_pGlossingKB, NULL, 0); // pProgDlg can be NULL and nTotal 0
		}
	}

	// if there was a bad load...
	if (!bReadOK)
	{
		wxMessageBox(_(
"Warning: a knowledge base for storing glosses was not found. An empty one has been created for your use instead."),
		_T(""), wxICON_INFORMATION);

		// make the substitute KB in memory
		if (m_pGlossingKB == NULL)
			m_pGlossingKB = new CKB(TRUE);

		// store it on disk & close it
		bool bOK = StoreGlossingKB(FALSE); // first time, so we can't make a backup

		// restore the saved flag values to what they were in the caller
		gbIsGlossing = bSaveIsGlossingFlag;

		if (!bOK)
		{
			if (pProgDlg != NULL)
				pProgDlg->Destroy();
			return FALSE; // let the caller put up message and abort
		}

		// restore the gbIsGlossing flag value to what it was in the caller
		gbIsGlossing = bSaveIsGlossingFlag;
		if (pProgDlg != NULL)
			pProgDlg->Destroy();
		return TRUE; // nothing much in it, so just return saying all is well
	}

	// restore the gbIsGlossing flag value to what it was in the caller
	gbIsGlossing = bSaveIsGlossingFlag;

#ifdef SHOW_KB_I_O_BENCHMARKS
		dt1 = dt2;
		dt2 = wxDateTime::UNow();
		wxLogDebug(_T("LoadGlossingKB executed in %s ms"),
			(dt2 - dt1).Format(_T("%l")).c_str());
#endif

	// remove the progress dialog
	if (pProgDlg != NULL)
		pProgDlg->Destroy();
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if the store operation failed, TRUE if it succeeded
/// \param      bShowProgress -> flag to show or hide the wxProgressDialog
/// \remarks
/// Called from: the App's SetupDirectories(), SubstituteKBBackup(), the View's OnCreate(),
/// and CProjectPage::OnWizardPageChanging() when moving forward. Reads the data from an
/// existing xml adapting KB file if present. If the xml KB file was not found (or could
/// not be read), it creates a new (empty) adapting KB.
/// BEW added 13Nov09: call of m_bReadOnlyAccess = SetReadOnlyProtection(), in order to give
/// the person entering the project ownership for writing permission (if FALSE is returned)
/// or READ-ONLY access (if TRUE is returned). (Also added to OnNewDocument &
/// OnOpenDocument() and OnCreate() for the view class.)
/// whm 26Aug11 revised to show or hide a wxProgressDialog
/////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::LoadKB(bool bShowProgress)
{
#ifdef SHOW_KB_I_O_BENCHMARKS
	wxDateTime dt1 = wxDateTime::Now(),
			   dt2 = wxDateTime::UNow();
#endif

	// whm 26Aug11 Open a wxProgressDialog instance here for "Loading the Knowledge
	// Base".
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process, starting with LoadKB() below.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	wxString msgDisplayed;
	wxString progMsg;
	wxProgressDialog* pProgDlg = (wxProgressDialog*)NULL;
	// add 1 chunk to insure that we have enough after int division above
	const int nTotal = GetMaxRangeForProgressDialog(XML_Input_Chunks,m_curKBPath) + 1;
	// Only show the progress dialog on request
	if (bShowProgress)
	{
		// Only create the progress dialog if we have data to progress
		if (nTotal > 0)
		{
			progMsg = _("Reading File %s - part %d of %d");
			wxFileName fn(m_curKBPath);
			msgDisplayed = progMsg.Format(progMsg,fn.GetFullName().c_str(),1,nTotal);
			pProgDlg = gpApp->OpenNewProgressDialog(_("Loading the Knowledge Base"),msgDisplayed,nTotal,500);
		}
	}

	bool bSaveIsGlossingFlag = gbIsGlossing;

    // set the gbIsGlossing flag to FALSE, as the XML needs to use it (it may have a
    // different value in the caller, so we restore it before returning)
	gbIsGlossing = FALSE;

    // first make sure the paths and filenames match are consistent with the m_gSaveAsXML
    // flag's value of TRUE (ie. set them to .xml extension, and the alternate filename and
    // path will have the .KB extension); or with FALSE (and the current and alternate are
    // the opposite)
	CAdapt_ItDoc* pDoc = GetDocument();
	pDoc->UpdateFilenamesAndPaths(TRUE,TRUE,TRUE,FALSE,FALSE);

	// some temporaries for the code below
	bool bReadOK = FALSE; // whm added initialization
	wxString path = m_curKBPath;

	// version 3.0 and upwards, the default is to do i/o in XML
	if (wxFileExists(path))
	{
        // the expected *.xml knowledge base file is in the project folder
        // attempt the load
		if (bShowProgress)
		{
			bReadOK = ReadKB_XML(path, m_pKB, pProgDlg, nTotal);
		}
		else
		{
			bReadOK = ReadKB_XML(path, m_pKB, NULL, 0); // pProgDlg can be NULL and nTotal 0
		}
	}

	// if there was a bad load...
	if (!bReadOK)
	{
		wxMessageBox(_(
"Warning: a knowledge base for storing adaptations was not found. An empty one has been created for your use instead. "),
		_T(""), wxICON_INFORMATION);

		// make the substitute KB in memory
		if (m_pKB == NULL)
			m_pKB = new CKB(FALSE);

        // we'll have to make sure we get the right source and target language names,
        // so we must analyse the path name to extract them from there; the app's
        // m_sourceName etc can't be relied on here, because the user might have
        // backtracked in the startup wizard after having supplied different names.
		wxFileName pathName;
		wxString path, fname, ext;
		pathName.SplitPath(m_curProjectPath, &path, &fname, &ext);

		wxString name = fname; // this is the project folder name
		int index;
        // whm: For localization purposes the " to " and " adaptations" strings should
        // not be translated, otherwise other localizations would not be able to handle
        // the unpacking of files created on different localizations.
		index = name.Find(_T(" to ")); // find "to" between spaces
		m_sourceName = name.Left(index); // get the source name, can contain
										 // multiple words
		index += 4;
		name = name.Mid(index); // name has target name plus "adaptations"
		index = name.Find(_T(" adaptations"));
		m_targetName = name.Left(index);

		// store in the memory instance of the knowledge base
		m_pKB->m_sourceLanguageName = m_sourceName;
		m_pKB->m_targetLanguageName = m_targetName;

		// store it on disk & close it
		bool bOK = StoreKB(FALSE); // first time, so we can't make a backup

		// restore the saved flag values to what they were in the caller
		gbIsGlossing = bSaveIsGlossingFlag;

		if (!bOK)
		{
			if (pProgDlg != NULL)
				pProgDlg->Destroy();
			return FALSE; // let the caller put up message and abort
		}
		if (pProgDlg != NULL)
			pProgDlg->Destroy();
		return TRUE; // nothing much in it, so just return saying all is well
	}

    // set the language names from the KB's stored names, in case the user has been
    // monkeying with language names in the startup wizard and has backed up to open an
    // existing project without resetting the language names to what they should be
	m_sourceName = m_pKB->m_sourceLanguageName;
	m_targetName = m_pKB->m_targetLanguageName;

	// restore the gbIsGlossing flag value to what it was in the caller
	gbIsGlossing = bSaveIsGlossingFlag;

	// BEW added 13Nov09, for setting or denying ownership for writing permission
	// attempt to set it only if not already set
	// whm added 7Mar12 code for fictitious read only access. If the m_bFictitiousReadOnlyAccess
	// flag is set, ForceFictitiousReadOnlyProtection() should be called before the call to
	// SetReadOnlyProtection().
	if (m_bFictitiousReadOnlyAccess)
	{
		m_pROP->ForceFictitiousReadOnlyProtection(m_curProjectPath);
	}

	m_bReadOnlyAccess = m_pROP->SetReadOnlyProtection(m_curProjectPath);

#ifdef SHOW_KB_I_O_BENCHMARKS
		dt1 = dt2;
		dt2 = wxDateTime::UNow();
		wxLogDebug(_T("LoadKB executed in %s ms"),
			(dt2 - dt1).Format(_T("%l")).c_str());
#endif

	// remove the progress dialog
	if (pProgDlg != NULL)
		pProgDlg->Destroy();
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if something went wrong with the loading of KB data from disk, TRUE
///                     otherwise
/// \remarks
/// Called from: the App's SetupDirectories(), the View's OnCreate(), the CollabUtilities'
/// HookUpToExistingAIProject(), and the CProjectPage::OnWizardPageChanging() when moving
/// forward. First, this function removes/erases any existing in-memory CKB object to
/// avoid leaking memory. Then it creates new in-memory KB objects, and then reads the
/// appropriate KBs to load the xml data from disk into the newly created KB objects.
/// Has the side-effect of setting the App's m_bKBReady and m_bGlossingKBReady values to
/// TRUE on success, and FALSE if unable to create/load the KB data. A return value of
/// FALSE (rather than aborting the program as previous code did) allows the caller to
/// more adequately deal with any failures.
/////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::CreateAndLoadKBs() // whm 28Aug11 added
{
	// whm 25Aug11 Note: I initially modelled this function from reworking the code in
	// SetupDirectories() and HookUpToExistingAIProject() that functioned to create the
	// KBs and load them with xml data from disk, and making unique adjustments for
	// any failures there in the caller's code by handling them in a FALSE block test
	// when calling this function.
	//
	// First, delete/erase any existing in-memory KB object to avoid leaking memory.
	// This probably would also prevent the problems with an assert he described
	// on 23Aug10 in the View's OnCreate() function.
	// whm: TODO: move the EraseKB() function from the Doc to the App class (or even
	// better to its own CKB class). Doing so would avoid having to get a pointer to
	// the document when one is unsure if such a pointer exists.
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);
	if (pDoc != NULL && m_pKB != NULL)
	{
		// delete the adapting one we successfully loaded
		GetDocument()->EraseKB(m_pKB); // calls delete
		m_pKB = (CKB*)NULL;
	}
	if (pDoc != NULL && m_pGlossingKB != NULL)
	{
		GetDocument()->EraseKB(m_pGlossingKB); // calls delete
		m_pGlossingKB = (CKB*)NULL;
	}
	//
	// setup for the adaptations KB
	if (::wxFileExists(m_curKBPath))
	{
		// there is an existing .KB file, so we need to create a CKB instance in
		// memory, open the .KB file on disk, and fill the memory instance's members
		wxASSERT(m_pKB == NULL);
		m_pKB = new CKB(FALSE);
		wxASSERT(m_pKB != NULL);
		bool bOK = LoadKB(TRUE); // TRUE - show progress dialog
		if (bOK)
		{
			m_bKBReady = TRUE;
			LoadGuesser(m_pKB); // whm added 29Oct10
		}
		else
		{
			// whm modified 28Aug11: Don't abort but notify the user, set
			// m_bKBReady to FALSE and return FALSE.
			// In the user message we should inform the user
			// of possible actions he can take - such as using the Restore
			// Knowledge Base... command, or restoring the kb files from
			// backups.
			wxMessageBox(_(
"Loading the knowledge base failed. You should now try the Restore Knowledge Base command in the File menu. If that fails, you should restore your knowledge base from backups. You need a valid knowledge base before doing any more work."),
			_T(""), wxICON_ERROR);
			wxASSERT(FALSE);
			LogUserAction(_T("Loading the knowledge base failed. You should now try the Restore Knowledge Base command in the File menu. If that fails, you should restore your knowledge base from backups. You need a valid knowledge base before doing any more work."));
			m_bKBReady = FALSE;
			return FALSE;
		}
	}
	else
	{
        // The KB file does not exist, so make sure there is an initialized CKB
        // instance on the application ready to receive data, and save it to disk.
        // Note: This operation goes fast because it is storing an empty KB.
		wxASSERT(m_pKB == NULL);
		m_pKB = new CKB(FALSE);
		wxASSERT(m_pKB != NULL);

		// store the language names in it
		m_pKB->m_sourceLanguageName = m_sourceName;
		m_pKB->m_targetLanguageName = m_targetName;

		bool bOK = StoreKB(FALSE); // first time, so we can't make a backup
		if (bOK)
		{
			m_bKBReady = TRUE;
			// whm Note: a new KB has no entries so no need to call LoadGuesser(m_pKB)
		}
		else
		{
			// whm modified 28Aug11: Don't abort but notify the user, set
			// m_bKBReady to FALSE and return FALSE.
			// In the user message we should inform the user
			// of possible actions he can take - such as ensuring
			// that some other app does not have the files in use,
			// using the Restore Knowledge Base... command, or restoring
			// the kb files from backups.
			wxMessageBox(_(
"Creating the knowledge base failed. Ensure that no other program is using the KB files, then try again. If continue to get failures you can try the Restore Knowledge Base... command from the File menu, or restore your knowledge base files from backups. You need a valid knowledge base before doing any more work."),
			_T(""), wxICON_ERROR); // something went wrong
			wxASSERT(FALSE);
			LogUserAction(_T("Creating the knowledge base failed. Ensure that no other program is using the KB files, then try again. If continue to get failures you can try the Restore Knowledge Base... command from the File menu, or restore your knowledge base files from backups. You need a valid knowledge base before doing any more work."));
			//abort(); // whm removed 28Aug11
			m_bKBReady = FALSE;
			return FALSE;
		}
	}

	// if we get here m_bKBReady will be TRUE since if setting up
	// the main KB fails, the function issues an error message and returns
	// FALSE.
	// setup for the glossing KB
	if (::wxFileExists(m_curGlossingKBPath))
	{
		// now do it for the glossing KB
		wxASSERT(m_pGlossingKB == NULL);
		m_pGlossingKB = new CKB(TRUE);
		wxASSERT(m_pGlossingKB != NULL);
		bool bOK = LoadGlossingKB(TRUE); // TRUE - show progress dialog
		if (bOK)
		{
			m_bGlossingKBReady = TRUE;
			LoadGuesser(m_pGlossingKB); // whm added 29Oct10
		}
		else
		{
			// whm modified 28Aug11: Don't abort but notify the user, set
			// m_bGlossingKBReady to FALSE and return FALSE.
			// In the user message we should inform the user
			// of possible actions he can take - such as using the Restore
			// Knowledge Base... command, or restoring the kb files from
			// backups.
			wxMessageBox(_(
"Error: loading the glossing knowledge base failed. The application will now close."),
			_T(""), wxICON_ERROR);
			wxASSERT(FALSE);
			LogUserAction(_T("Error: loading the glossing knowledge base failed"));
			m_bGlossingKBReady = FALSE;
			return FALSE;
		}
	}
	else
	{
        // The glossing KB file does not exist, so make sure there is an
        // initialized CKB  instance on the application ready to receive data,
        // and save it to disk.
        // Note: This operation goes fast because it is storing an empty
        // glossing KB.
		wxASSERT(m_pGlossingKB == NULL);
		m_pGlossingKB = new CKB(TRUE);
		wxASSERT(m_pGlossingKB != NULL);

		bool bOK = StoreGlossingKB(FALSE); // first time, so we can't make a backup
		if (bOK)
		{
			m_bGlossingKBReady = TRUE;
			// whm Note: a new KB has no entries so no need to call LoadGuesser(m_pGlossingKB)
		}
		else
		{
			// whm modified 28Aug11: Don't abort but notify the user, set
			// m_bKBReady to FALSE and return FALSE.
			// In the user message we should inform the user
			// of possible actions he can take - such as ensuring
			// that some other app does not have the files in use,
			// using the Restore Knowledge Base... command, or restoring
			// the kb files from backups.
			wxMessageBox(_(
"Creating the glossing knowledge base failed. Ensure that no other program is using the KB files, then try again. If continue to get failures you can try the Restore Knowledge Base... command from the File menu, or restore your knowledge base files from backups. You need a valid knowledge base before doing any more work."),
			_T(""), wxICON_ERROR); // something went wrong
			wxASSERT(FALSE);
			LogUserAction(_T("Creating the glossing knowledge base failed. Ensure that no other program is using the KB files, then try again. If continue to get failures you can try the Restore Knowledge Base... command from the File menu, or restore your knowledge base files from backups. You need a valid knowledge base before doing any more work."));
			m_bGlossingKBReady = FALSE;
			return FALSE;
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      -> m_pKB the knowledge base from which correspondences are taken for this Guesser
///                 which can be either the m_pAdaptationsGuesser or the m_pGlossesGuesser
/// \remarks
/// Called from: the App's SetupDirectories(), SubstituteKBBackup(), OnFileRestoreKb(),
/// the View's OnCreate(), and CProjectPage::OnWizardPageChanging() when moving forward.
/// Initializes the appropriate Guesser, then reads the appropriate KB to populate the
/// correspondence list of the guesser object.
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::LoadGuesser(CKB* m_pKB)
{
	// whm added 29Oct10 for Guesser support
	if (m_pKB->IsThisAGlossingKB())
		m_pGlossesGuesser->Init(m_nGuessingLevel);
	else
		m_pAdaptationsGuesser->Init(m_nGuessingLevel); // clears the Guesser correspondence list
	int numCorrespondencesLoaded = 0;
	int numWords;
	int counter = 0;
	wxString key,baseKey,gloss,baseGloss;
	wxString strNotInKB = _T("<Not In KB>");
	MapKeyStringToTgtUnit::iterator iter;
	CTargetUnit* pTU = 0;
	CRefString* pRefStr;
	for (numWords = 1; numWords <= MAX_WORDS; numWords++)
	{
		if (m_pKB->IsThisAGlossingKB() && numWords > 1)
			continue; // when glossing we want to consider only the first map, the others
					  // are all empty
		if (m_pKB->m_pMap[numWords-1]->size() == 0)
			continue;
		else
		{
			iter = m_pKB->m_pMap[numWords-1]->begin();
			do
			{
				counter++;
				key = iter->first;
				pTU = (CTargetUnit*)iter->second;
				wxASSERT(pTU != NULL);
				baseKey = key;

				// get the reference strings
				TranslationsList::Node* posRef = 0;

				// if the data somehow got corrupted by a CTargetUnit being retained in the
				// list but which has an empty list of reference strings, this illegal
				// instance would cause a crash - so test for it and if such occurs, then
				// remove it from the list and then just continue looping
				if (pTU->m_pTranslations->IsEmpty())
				{
					m_pKB->m_pMap[numWords-1]->erase(baseKey); // the map now lacks this
														// invalid association
					delete pTU; // its memory chunk is freed (don't leak memory)
					continue;
				}
				else
				{
					posRef = pTU->m_pTranslations->GetFirst();
				}
				wxASSERT(posRef != 0);

				// if control gets here, there will be at least one non-null posRef
				pRefStr = (CRefString*)posRef->GetData();
				posRef = posRef->GetNext(); // prepare for possibility of another CRefString
				wxASSERT(pRefStr != NULL);
				gloss = pRefStr->m_translation;
				baseGloss = gloss;
				// Don't add correspondences for deleted or "<Not In KB>"
				if (!pRefStr->GetDeletedFlag() && baseGloss.Find(strNotInKB) == wxNOT_FOUND)
				{
					// Add correspondence to the Guesser
					if (m_pKB->IsThisAGlossingKB())
						m_pGlossesGuesser->AddCorrespondence(key,gloss);
					else
						m_pAdaptationsGuesser->AddCorrespondence(key,gloss);
					numCorrespondencesLoaded++;
				}
				// According to Alan Buseman, he says, "I recommend for the guesser that you only
				// give it one equivalent for each word, preferably the most frequent. Giving the
				// guesser multiple equivalents for a word will tend to reduce the number of guesses
				// it can make." If this is the case we should limit the correspondences given to
				// the Guesser to the first item in the m_pTranslations list - which presumably also
				// is the one at the top of the list in the ChooseTranslation dialog and as such
				// probably also the one the user feels is the most frequent or important translation
				// for a given target unit. Therefore I will comment out the code below which
				// functions to add the additional CRefString instances within the same CTargetUnit
				// instance.
				/*

				// now deal with any additional CRefString instances within the same
				// CTargetUnit instance
				while (posRef != 0)
				{
					pRefStr = (CRefString*)posRef->GetData();
					wxASSERT(pRefStr != NULL);
					posRef = posRef->GetNext(); // prepare for possibility of yet another
					gloss = pRefStr->m_translation;
					baseGloss = gloss;

					if (!pRefStr->GetDeletedFlag() && baseGloss.Find(strNotInKB) == wxNOT_FOUND)
					{
						// Add correspondence to the Guesser
						if (m_pKB->IsThisAGlossingKB())
							m_pGlossesGuesser->AddCorrespondence(key,gloss);
						else
							m_pAdaptationsGuesser->AddCorrespondence(key,gloss);
						numCorrespondencesLoaded++;
					}
				} // end of inner loop for looping over CRefString instances

				*/
				// point at the next CTargetUnit instance, or at end() (which is NULL) if
				// completeness has been obtained in traversing the map
				iter++;
			} while (iter != m_pKB->m_pMap[numWords-1]->end());
		} // end of normal situation block ...
	} // end of numWords outer loop
	if (m_pKB->IsThisAGlossingKB())
	{
		m_nCorrespondencesLoadedInGlossingGuesser = numCorrespondencesLoaded;
		wxLogDebug(_T("The Glossing guesser has %d correspondences loaded"),m_nCorrespondencesLoadedInGlossingGuesser);
	}
	else
	{
		m_nCorrespondencesLoadedInAdaptationsGuesser = numCorrespondencesLoaded;
		wxLogDebug(_T("The Adaptations guesser has %d correspondences loaded"),m_nCorrespondencesLoadedInAdaptationsGuesser);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the title is a project folder name (i.e., has " adaptations"
///             and " to " in it) and is is not less than 18 characters, otherwise FALSE
/// \param      title   ->  the incoming title string
/// \remarks
/// Called from: the App's GetPossibleAdaptionProjects().
/// Checks to see if the title string has the signs of being a project folder name.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::IsAdaptitProjectDirectory(wxString title)
{
	// return FALSE if the title is not one of ours, ie, not a project folder name
    // whm: For localization purposes the " to " and " adaptations" strings should not be
    // translated, otherwise other localizations would not be able to handle the unpacking
    // of files created on different localizations.
	if (title.Find(_T(" adaptations")) == -1)
		return FALSE;
	if (title.Find(_T(" to ")) == -1)
		return FALSE;
	if (title.Length() < 18)
		return FALSE;
	else
		return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pList   <- list of possible adaptation documents found on dirPath
/// \param      dirPath -> the path to search for adaptation documents
/// \remarks
/// Called from: the App's EnumerateDocFiles(), CDocPage::OnSetActive(),
/// CJoinDialog::InitialiseLists(), CListDocumentsInOtherFolderDialog::InitDialog(),
/// CMoveDialog::UpdateFileList(), and CSplitDialog::ListFiles().
/// Fills the array string pList with the file names having .xml extension in dirPath.
/// Note: The caller should ensure that dirPath exists before calling this function
/// since it does not have a graceful way to return if dirPath is bad.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetPossibleAdaptionDocuments(wxArrayString *pList, wxString dirPath)
{
	// whm - The caller should ensure that dirPath exists before calling this function
	// since it does not have a graceful way to return if dirPath is bad. See CDocPage.
	wxDir finder;//CFileFind finder;

	bool bOK = (::wxSetWorkingDirectory(dirPath) && finder.Open(dirPath)); // wxDir
										// must call .Open() before enumerating files!
	if (!bOK)
	{
		// think again!
		wxMessageBox(_(
	"Failed to set the current directory when getting existing adaptation documents"),
		_T(""), wxICON_ERROR);
		wxASSERT(FALSE);
		wxExit();
	}
	else
	{
		CAdapt_ItDoc* pDoc = GetDocument();
		// BEW changed 16Aug10, because the previous line can return NULL for pDoc in the
		// following circumstance. Have bible book folder mode turned on, and a doc
		// visible in the main window. Then close the document (this clobbers the document
		// pointer). Then use the Advanced menu to turn off book folder mode. This causes
		// the wizard to be entered at docPage, and the latter's OnSetActive() is called,
		// which in turn calls GetPossibleAdaptionDocuments() for the path
		// m_curAdaptionsPath, and then the above GetDocument() call returns NULL. So
		// having a wxASSERT here for a non-Null pDoc pointer is no help. We cannot in
		// this circumstance use pDoc to access the document template, so for the present
		// I'll do a kludge - test for pDoc NULL and if so, set strExt to ".xml" manually.
		// Hmmm... try as I might, I've not been able to recreate pDoc being NULL, even
		// though I've done what I previously did and other variations on it too - so I
		// can't check the kludge works, though I suspect it will.
		wxString strExt;
		if (pDoc == NULL)
		{
			strExt = _T(".xml");
		}
		else
		{
			//wxASSERT(pDoc != NULL);
			wxDocTemplate* pTemplate = pDoc->GetDocumentTemplate();
			wxASSERT(pTemplate != NULL);
			strExt = pTemplate->GetFileFilter(); // GetFileFilter returns "*.xml"
												 // in wx version
		}
		// Must call wxDir::Open() before calling GetFirst() - see above
		wxString str = _T("");
		bool bWorking = finder.GetFirst(&str,wxEmptyString,wxDIR_FILES);
		// whm note: wxDIR_FILES finds only files; it ignores directories, and . and ..
		while (bWorking)
		{
			if (str.IsEmpty())
				continue;
			wxString strEnd = str.Right(4); // extract its extension
			wxString strEndLower = strEnd;
			strEndLower = strEndLower.MakeLower();
			int nFound = str.Find(_T(".BAK"));
			if ((strEnd == strExt || strEndLower == strExt) && nFound == -1)
				pList->Add(str); // add filename to the list, if it's extension is ours,
								 // but exclude backup document files with ".BAK"
			bWorking = finder.GetNext(&str);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      dirPath   -> must be the absolute path to the current project's Adaptations
///                         folder (this is stored in the app's m_curAdaptionsPath member)
/// \param      pFolders  -> the app's m_pBibleBooks member
/// \remarks
/// Called from: the App's SetupDirectories(), AccessOtherAdaptionProject(), and
/// OnAdvancedBookMode().
/// Creates the set of book folders specified in pFolders in the directory specified by
/// dirPath (which should be the app's m_curAdaptionsPath).
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::CreateBookFolders(wxString dirPath, wxArrayPtrVoid* pFolders)
// the passed in dirPath string must be the absolute path to the current project's
// Adaptations folder (this is stored in the app's m_curAdaptionsPath member);
// and pFolders should be the app's m_pBibleBooks member.
{
	wxString path;
	wxString folder;
	bool bExists;
	int count = pFolders->GetCount();
	for (int i = 0; i < count; i++)
	{
		folder = ((BookNamePair*)(*pFolders)[i])->dirName;
		path = dirPath + PathSeparator + folder;
		bExists = ::wxDirExists(path);
		if (bExists)
		{
			// this folder exists already, so continue
			continue;
		}
		else
		{
			// this folder does not exist yet, so create it
			bool bOK = ::wxMkdir(path); // NULL for default security settings
			// WX NOTE: On Unix/Linux wxMkdir has a second default param: int perm = 0777 which
			// makes a directory with full read, write, and execute permissions.
			if (!bOK)
			{
				// error, we'll just warn user, skip this folder, and carry on;
				// user could manually try create it later
				wxString str;
				str = str.Format(_(
"Creating folder: \"%s\" failed. This folder will be skipped, processing will continue."),
				path.c_str());
				wxMessageBox(str, _T(""), wxICON_WARNING);
			}
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the Adaptations folder contains a subdirectory name which
///             is contained within, and of equal length to, the seeName name in one of
///             structs in the book folders array
/// \param      dirPath   ->    must be the absolute path to the current project's
///                             Adaptations folder (this is stored in the app's
///                             m_curAdaptionsPath member)
/// \remarks
/// Called from: the App's SetupDirectories(), OnFileRestoreKb(),
/// AccessOtherAdaptionProject(), OnAdvancedBookMode(), and
/// CRetranslation::OnRetranslationReport().
/// Determines if the book folders have already been created or not in the dirPath. Note:
/// AreBookFoldersCreated() has the side effect of changing the current work directory to
/// the passed in dirPath.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::AreBookFoldersCreated(wxString dirPath)
// the passed in dirPath string must be the absolute path to the current project's
// Adaptations folder (this is stored in the app's m_curAdaptionsPath member) Returns TRUE
// if the Adaptations folder contains a subdirectory name which is contained within, and of
// equal length to, the seeName name in one of structs in the book folders array
// whm note: AreBookFoldersCreated() has the side effect of changing the current work
// directory to the passed in dirPath.
{
	wxDir finder;
	bool bOK = (::wxSetWorkingDirectory(dirPath) && finder.Open(dirPath)); // wxDir must
												// call .Open() before enumerating files!
	if (!bOK)
	{
		wxMessageBox(_T(
			"Failed to set the current directory in AreBookFoldersCreated function"),
			_T(""), wxICON_ERROR);
		wxASSERT(FALSE);
		wxExit();	// TODO: See if there is a more graceful way to recover from
					// not being able to set the working directory to dirPath
		return FALSE; // to get rid of compiler warning - this line never executes
	}
	else
	{
		wxString str;
		// whm note: in GetFirst below, wxDIR_FILES | wxDIR_DIRS flag finds files
		// or directories, but not . or .. or hidden files
		bool bWorking = finder.GetFirst(&str,wxEmptyString,wxDIR_FILES | wxDIR_DIRS);
		while (bWorking)
		{
			bWorking = finder.GetNext(&str);
			if (str.IsEmpty())
				continue;
			if (finder.Exists(str)) // wxDir::Exists(str) returns true if str is
									// a directory that exists
			{
				// BEW changed 25Aug05, so that other user-defined folders can be
				// in the Adaptations folder without making the app confused
				// as to whether or not Bible Book folders are present or not

				// we have found a folder, check if it matches one of those in
				// the array of BookNamePair structs (using the seeName member)
				if (IsDirectoryWithin(str,m_pBibleBooks))
					return TRUE;
				else
					continue;
			}
			else
			{
				// its a file, so ignore it
				continue;
			}
		}
	}
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the folder represented by dir is one of the recognized
///             book folders listed in pBooks
/// \param      dir    -> the folder name being checked
/// \param      pBooks -> the array/list of recognized book names
/// \remarks
/// Called from: the App's AreBookFoldersCreated(), OnFileRestoreKb(),
/// AccessOtherAdaptionProject(), the View's OnRetransReport().
/// Determines is dir is one of the recognized book folder names.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::IsDirectoryWithin(wxString& dir, wxArrayPtrVoid*& pBooks)
{
	int nCount = pBooks->GetCount();
	int index;
	BookNamePair* pNP;
	for (index = 0; index < nCount; index++)
	{
		pNP = (BookNamePair*)pBooks->Item(index);
		int curPos = pNP->seeName.Find(dir);
		if (curPos >= 0)
		{
			// the passed in directory name is equal to, or a substring of
			// one of the bible book names
			int lenDir = dir.Length();
			int lenBookFolderName = pNP->seeName.Length();
			if (lenDir == lenBookFolderName)
			{
				// equal lengths, so assume that all the folders are present already
				return TRUE;
			}
			else
				continue;
		}
		else
			continue;
	}
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pList   <- an array string list that gets filled with project names.
/// \remarks
/// Called from: COpenExistingProjectDlg::InitDialog(), and CProjectPage::InitDialog(),
/// and CAdapt_ItApp::GetEthnologueLangCodePairsForAIProjects().
/// Gets a list of possible Adapt It projects located on the m_workFolderPath.
/// BEW modified 9Sep09, so it can access projects (?? or create a new project at a custom
/// folder location ?? surely it can't do that -- BEW 22Jun11)
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetPossibleAdaptionProjects(wxArrayString *pList)
{
	wxString dirPath;
	if (!m_customWorkFolderPath.IsEmpty() && m_bUseCustomWorkFolderPath)
	{
		dirPath = m_customWorkFolderPath;
	}
	else
	{
		dirPath = m_workFolderPath;
	}
	wxDir finder;

	bool bOK = ::wxSetWorkingDirectory(dirPath) && finder.Open(dirPath); // wxDir must
											// call .Open() before enumerating files!
	if (!bOK)
	{
		// oops, this is a fatal error, we can't go on
		wxMessageBox(_T("Failed setting current directory in GetPossibleAdaptationProjects()")
		,_T(""), wxICON_ERROR);
		wxASSERT(FALSE);
		wxExit(); // this calls OnExit() before exiting
	}
	else
	{
		wxString str;
		// by default, finder enumerates everything except '.' and '..'
		// using wxDIR_FILES | wxDIR_DIRS as flag finds files or directories,
		// but not . or .. or hidden files
		bool bWorking = finder.GetFirst(&str,wxEmptyString,wxDIR_FILES | wxDIR_DIRS);
		while (bWorking)
		{
			// whm Note: The Exists() method of wxDIR used below returns TRUE if
			// the passed name IS a directory.
			if (finder.Exists(str))
			{
				// exclude any directory which does not have a name of the form
				// "X to Y adaptations"
				bool bOurs = IsAdaptitProjectDirectory(str);
				if (bOurs)
				{
					pList->Add(str);
				}
			}
			bWorking = finder.GetNext(&str);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE unless a serious enough error occurs that the app cannot continue
///             in which case it returns FALSE
/// \param      bAutoBackup   -> if TRUE it also saves a backup copy of the glossing KB
/// \remarks
/// Called from: the App's SetupDirectories(), LoadGlossingKB(), SaveGlossingKB(),
/// SubstituteKBBackup(), AccessOtherAdaptionProject(), the Doc's DoFileSave(), the View's
/// OnCreate().
/// Stores the glossing KB data in the external xml file located in the path represented
/// by m_curGlossingKBPath.
///////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::StoreGlossingKB(bool bAutoBackup)
{
	// whm Note: This StoreGlossingKB() could easily be combined with the StoreKB()
	// routine below into a single function

	if (m_bReadOnlyAccess)
		return TRUE; // BEW 13Nov09, not an error, just suppression of a remote save

#ifdef SHOW_KB_I_O_BENCHMARKS
	wxDateTime dt1 = wxDateTime::Now(),
			   dt2 = wxDateTime::UNow();
#endif
	wxFile f; // create a CFile instance, using default constructor
	wxString path;

	// ensure the extension is what it should be
	gpApp->GetDocument()->UpdateFilenamesAndPaths(FALSE,FALSE,FALSE,TRUE,TRUE);

	// open a CFile stream
	path = m_curGlossingKBPath;

	if (!f.Open(m_curGlossingKBPath, wxFile::write))
	{
		wxString message;
		message = _("Error opening glossing KB file for writing with path:\n")
			+ m_curGlossingKBPath + _(
"\nThe glossing knowledge base was not saved.\nIs your drive's free space low, or is the file open in another application?");
		wxMessageBox(message, _T(""), wxICON_INFORMATION);
		LogUserAction(message);
		return FALSE;
	}

	// whm 26Aug11 Open a wxProgressDialog instance here for save operations.
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	wxString msgDisplayed;
	const int nTotal = GetMaxRangeForProgressDialog(Glossing_KB_Item_Count) + 1;
	wxString progMsg = _("Saving KB %s - %d of %d Total entries and senses");
	wxFileName fn(m_curGlossingKBPath);
	msgDisplayed = progMsg.Format(progMsg,fn.GetFullName().c_str(),1,nTotal);
	wxProgressDialog* pProgDlg;
	pProgDlg = OpenNewProgressDialog(_("Saving the Glossing KB"),msgDisplayed,nTotal,500);

	m_pGlossingKB->DoKBSaveAsXML(f, pProgDlg, nTotal); // pProgDlg can be NULL and nTotal 0

	// close the file
	f.Close();
	f.Flush();

    // if backing up is desired, we rename the newly saved copy as a *.BAK, then resave
    // the glossing knowledge base to the old name again
	if (bAutoBackup)
	{
		if (::wxFileExists(m_curGlossingKBBackupPath) && !::wxDirExists(m_curGlossingKBBackupPath))
		{
			// found a backup, so remove it to make way for new backup
			if (!::wxRemoveFile(m_curGlossingKBBackupPath))
			{
				// notify user of error (maybe backup file is protected or in use???)
				wxMessageBox(_("Removing backup glossing kb file failed."), _T(""),wxICON_WARNING);
				LogUserAction(_T("Removing backup glossing kb file failed."));
				if (pProgDlg != NULL)
					pProgDlg->Destroy();
				return TRUE; // allow the app to continue
			}
		}

		// BEW changed 30Apr10, make the backup by copying the saved file to the backup filename
		bool bCopiedOK = ::wxCopyFile(m_curGlossingKBPath, m_curGlossingKBBackupPath);
		bCopiedOK = bCopiedOK; // prevent compiler warning
	}
#ifdef SHOW_KB_I_O_BENCHMARKS
		dt1 = dt2;
		dt2 = wxDateTime::UNow();
		wxLogDebug(_T("StoreGlossingKB executed in %s ms"),
			(dt2 - dt1).Format(_T("%l")).c_str());
#endif
	if (pProgDlg != NULL)
		pProgDlg->Destroy();
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE unless a serious enough error occurs that the app cannot continue
///             in which case it returns FALSE
/// \param      bAutoBackup   -> if TRUE it also saves a backup copy of the KB
/// \remarks
/// Called from: the App's SetupDirectories(), LoadKB(), SaveKB(), SubstituteKBBackup(),
/// AccessOtherAdaptionProject(), the Doc's DoFileSave(), the View's OnCreate().
/// Stores the KB data in the external xml file located in the path represented
/// by m_curKBPath.
///////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::StoreKB(bool bAutoBackup)
{
	if (m_bReadOnlyAccess)
		return TRUE; // BEW 13Nov09, not an error, just suppression of a remote save
#ifdef SHOW_KB_I_O_BENCHMARKS
	wxDateTime dt1 = wxDateTime::Now(),
			   dt2 = wxDateTime::UNow();
#endif

	wxFile f; // create a CFile instance, using default constructor
	wxString path;

	// ensure the extension is what it should be
	gpApp->GetDocument()->UpdateFilenamesAndPaths(TRUE,TRUE,TRUE,FALSE,FALSE);

	if (!f.Open(m_curKBPath, wxFile::write))
	{
			wxString message;
			message = _("Error opening KB file for writing with path:\n")
				+ m_curKBPath + _(
"\nThe knowledge base was not saved.\nIs your drive's free space low, or is the file open in another application?");
			wxMessageBox(message, _T(""), wxICON_INFORMATION);
			LogUserAction(message);
			return FALSE;
	}

	// whm 26Aug11 Open a wxProgressDialog instance here for save operations.
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	wxString msgDisplayed;
	const int nTotal = gpApp->GetMaxRangeForProgressDialog(Adapting_KB_Item_Count) + 1;
	wxString progMsg = _("Saving KB %s - %d of %d Total entries and senses");
	wxFileName fn(m_curKBPath);
	msgDisplayed = progMsg.Format(progMsg,fn.GetFullName().c_str(),1,nTotal);
	wxProgressDialog* pProgDlg;
	pProgDlg = gpApp->OpenNewProgressDialog(_("Saving the KB"),msgDisplayed,nTotal,500);

	m_pKB->DoKBSaveAsXML(f, pProgDlg, nTotal); // pProgDlg can be NULL and nTotal 0

	// close the file
	f.Close();
	f.Flush();

    // if backing up is desired, we rename the newly saved copy as a *.BAK, then resave
    // the knowledge base to the old name again
	if (bAutoBackup)
	{
		// first, remove the old backup file, if it still is on disk
		if (::wxFileExists(m_curKBBackupPath) && !::wxDirExists(m_curKBBackupPath))
		{
			// found a backup, so remove it to make way for new backup
			if (!::wxRemoveFile(m_curKBBackupPath))
			{
				// notify user of error (maybe backup file is protected or in use???)
				wxMessageBox(_("Removing backup kb file failed."), _T(""), wxICON_WARNING);
				LogUserAction(_T("Removing backup kb file failed."));
				if (pProgDlg != NULL)
					pProgDlg->Destroy();
				return TRUE; // allow app to continue
			}
		}

		// BEW changed 30Apr10, make the backup by copying the saved file to the backup filename
		bool bCopiedOK = ::wxCopyFile(m_curKBPath, m_curKBBackupPath);
		bCopiedOK = bCopiedOK; // prevent compiler warning
	}
#ifdef SHOW_KB_I_O_BENCHMARKS
		dt1 = dt2;
		dt2 = wxDateTime::UNow();
		wxLogDebug(_T("StoreKB executed in %s ms"),
			(dt2 - dt1).Format(_T("%l")).c_str());
#endif
	if (pProgDlg != NULL)
		pProgDlg->Destroy();
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE unless an error occurred and the KB could not be stored in which
///             case it returns FALSE
/// \param      bAutoBackup   -> if TRUE it also saves a backup copy of the KB
/// \remarks
/// Called from: the App's SetupDirectories(), LoadKB(), SaveKB(), SubstituteKBBackup(),
/// AccessOtherAdaptionProject(), the Doc's DoFileSave(), the View's OnCreate().
/// Calls StoreKB() to store the KB data in the external xml file.
/// BEW modified 13Nov09, don't permit saving of a remote KB if the local instance only
/// has read-only access to the remote project
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::SaveKB(bool bAutoBackup)
{
	if (m_bReadOnlyAccess)
		return TRUE; // not an error, just suppression of a remote save
	if (bAutoBackup)
	{
        // Guarantee correct form for m_curKBBackupPath, we handle m_curKBFilename,
        // m_curKBPath too, because we keep all three in sync
		gpApp->GetDocument()->UpdateFilenamesAndPaths(TRUE,TRUE,TRUE,FALSE,FALSE);

		// is there a backup file? remove it if so
		if(::wxFileExists(m_curKBBackupPath) && !::wxDirExists(m_curKBBackupPath))
		{
			// found a backup, so remove it to make way for new backup
			if (!::wxRemoveFile(m_curKBBackupPath))
			{
				// notify user of error (maybe backup file is protected or in use???)
				// The following message did not exist in the MFC version
				wxMessageBox(_("Removing backup kb file failed."), _T(""), wxICON_ERROR);
				LogUserAction(_T("Removing backup kb file failed."));
				return FALSE;
			}
		}
		// no removal needed if there is not a backup present
	}
	bool bOK = StoreKB(bAutoBackup);

	return bOK;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE unless an error occurred and the glossing KB could not be stored
///             in which case it returns FALSE
/// \param      bAutoBackup   -> if TRUE it also saves a backup copy of the glossing KB
/// \remarks
/// Called from: the App's DoGlossingKBBackup(), DoKBRestore(),
/// SetupDirectories(), LoadKB(), SaveKB(), the View's OnFileSaveKB(), and
/// OnToolsKbEditor().
/// Calls StoreGlossingKB() to store the glossing KB data in the external xml file.
/// BEW modified 13Nov09, don't permit saving of a remote KB if the local instance only
/// has read-only access to the remote project
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::SaveGlossingKB(bool bAutoBackup)
{
	if (m_bReadOnlyAccess)
		return TRUE; // not an error, just suppression of a remote save
	if (bAutoBackup)
	{
        // Guarantee correct form for m_curGlossingKBBackupPath, we handle
        // m_curGlossingKBFilename, m_curGlossingKBPath too, because we keep all three in
        // sync
		gpApp->GetDocument()->UpdateFilenamesAndPaths(FALSE,FALSE,FALSE,TRUE,TRUE);

		// is there a backup file? remove it if so
		if(::wxFileExists(m_curGlossingKBBackupPath) && !::wxDirExists(m_curGlossingKBBackupPath))
		{
			// found a backup, so remove it to make way for new backup
			if (!::wxRemoveFile(m_curGlossingKBBackupPath))
			{
				// notify user of error (maybe backup file is protected or in use???)
				// The following message did not exist in the MFC version
				wxMessageBox(_("Removing backup glossing kb file failed."),
				_T(""), wxICON_ERROR);
				LogUserAction(_T("Removing backup glossing kb file failed."));
				return FALSE;
			}
		}
		// no removal needed if there is not a backup present
	}
	bool bOK = StoreGlossingKB(bAutoBackup);
	return bOK;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the app is in Vertical Edit Mode the Start Working
/// Wizard is disabled and this handler returns immediately.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateFileStartupWizard(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE); // we want it always available, with several entry points
}


////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if successful in getting all pointers, otherwise FALSE
/// \param      pDoc   <- pointer to the document
/// \param      pView  <- pointer to the view
/// \param      pBox   <- pointer to the phrasebox
/// \remarks
/// Called from: the Doc's OnCloseDocument(), the View's OnRetransReport(),
/// OnFileExportKb(), CMainFrame's SyncScrollReceive(), ComposeBarGuts(), OnIdle(), and
/// CPhraseBox::ChooseTranslation().
/// Gets pointers for the Doc, View, and PhraseBox.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::GetBasePointers(CAdapt_ItDoc*& pDoc, CAdapt_ItView*& pView,
									CPhraseBox*& pBox)
// return FALSE if not successful in getting all pointers, TRUE if all are okay
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	pDoc = (CAdapt_ItDoc*)NULL;
	pView = (CAdapt_ItView*)NULL;
	pBox = (CPhraseBox*)NULL;

	pDoc = GetDocument();
	if (pDoc == NULL) return FALSE;
	pView = (CAdapt_ItView*)pDoc->GetFirstView();
	if (pView == NULL) return FALSE;
	wxASSERT(pView->IsKindOf(CLASSINFO(CAdapt_ItView)));
	pBox = pApp->m_pTargetBox;
	if (pBox == NULL) return FALSE;
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     pointer to the MapSfmToUSFMAnalysisStruct map specified by sfmSet
/// \param      sfmSet   -> the specified sfm set (UsfmOnly, PngOnly or UsfmAndPng)
/// \remarks
/// Called from: the Doc's ReconstituteAfterFilteringChange(), ResetUSFMFilterStructs(),
/// GetUnknownMarkersFromDoc(), the View's GetMarkerInventoryFromCurrentDoc(),
/// MarkerTakesAnEndMarker(), and (from ExportFunctions.cpp) DoExportInterlinearRTF(),
/// BuildRTFTagsMap(), BuildColorTableFromUSFMColorAttributes(), GetMaxMarkerLength(), the
/// CUsfmFilterPageCommon::LoadDocSFMListBox(), CUsfmFilterPageCommon::LoadProjSFMListBox(),
/// CUsfmFilterPageCommon::DoInit(), CUsfmFilterPageCommon::DoBnClickedRadioUseUbsSetOnlyDoc(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseSilpngSetOnlyDoc(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseBothSetsDoc(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseUbsSetOnlyProj(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseSilpngSetOnlyProj(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseBothSetsProj().
/// Gets a pointer to the current MapSfmToUSFMAnalysisStruct map specified by sfmSet.
////////////////////////////////////////////////////////////////////////////////////////
MapSfmToUSFMAnalysisStruct* CAdapt_ItApp::GetCurSfmMap(enum SfmSet sfmSet)
{
	// returns the current USFMAnalysis map for the sfmSet
	switch(sfmSet)
	{
		case UsfmOnly: return gpApp->m_pUsfmStylesMap;
		case PngOnly: return gpApp->m_pPngStylesMap;
		case UsfmAndPng: return gpApp->m_pUsfmAndPngStylesMap;
		default: return gpApp->m_pUsfmStylesMap;// this should never happen
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE (but it aborts the program with a call to wxExit() if
///             the path represented by m_curAdaptionsPath could not be found)
/// \param      event   -> (unused)
/// \remarks
/// Called from: DoStartWorkingWizard is called by App's DoFileOpen(),
/// OnFileChangeFolder(), and OnAdvancedBookMode(), and also by the View's
/// OnFileStartupWizard(), which in turn is called by DoStartupWizardOnLaunch() which gets
/// called by the CMainFrame's OnIdle method, when the program starts (or by File | Start
/// Working...).
/// Initiates the Start Working Wizard which has smarts to detect which page of the wizard
/// should be presented to the user for the current working situation.
/// whm modified 20Apr11 to use the "Get Source Text from Paratext Project" dialog instead
/// of running the Start Working Wizard when m_bStartWorkUsingCollaboration is TRUE
/////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::DoStartWorkingWizard(wxCommandEvent& WXUNUSED(event))
{
	// Note: This version of DoStartWorkingWizard() is
	// structured quite differently from the MFC version.
	// WX Notes:
	// 1. The CPropertySheet and CPropertyPage classes in MFC are designed
	//    to double as tabbed property sheet pages in a single preferences dialog,
	//    or, when CPropertySheet::SetWizardMode() is called, the property sheet
	//    turns into a wizard with more or less linear traversal of the pages.
	//    In WX we don't have a single CPropertySheet class for both functions,
	//    instead, we can define individual pages as in MFC, but we then use them
	//    in two separate built-in WX classes: wxNotebook (for tabbed preferences
	//    dialog), and wxWizard for the Start Working wizard.
	// 2. I originally tried to structure the operation of the wizard using all
	//    wxWizardSimple page classes. That design, however, resulted in problems
	//    because I destroyed the wizard and called RunWizard again each time
	//    I wanted the wizard to change the page ordering/sequencing. Eventually
	//    I decided to use the more advanced wxWizardPage class for all the wizard
	//    pages.

	// whm added 9Mar12. DoStartWorkingWizard() can be summoned while a document
	// is open. We should ensure that any open document is closed and unsaved
	// changes are saved before proceeding to either the wizard or the
	// GetSourceTextFromEditorDlg dialog get a pointer to the currently being used KB
	CKB* pKB;
	if (gbIsGlossing)
		pKB = m_pGlossingKB;
	else
		pKB = m_pKB;

	if (pKB != NULL && m_pLayout->GetStripCount() > 0)
	{
		// a document is open, close it and save any unsaved changes
		// doc is open, so close it first
		// Note: OnFileClose() calls the Doc's OnSaveModified() before closing
		// the document. OnSaveModified() prompts for saving if the doc is
		// dirty (usually is for a collab doc). If user indicates "Yes" to the
		// prompt, it calls DoCollabFileSave() if collaboration is on, otherwise
		// it calls DoFileSave_Protected().
		wxCommandEvent dummyevent;
		GetDocument()->OnFileClose(dummyevent);
		GetMainFrame()->canvas->Update(); // force immediate repaint
		GetDocument()->Modify(FALSE);
	}

	// whm 19Feb12 modified. Collaboration with PT/BE is now turned ON or OFF
	// by the user, after selecting a project at the Start Working Wizard's
	// ProjectPage.
	// whm added 20Apr11 support for Paratext/Bibledit collaboration.
	// When m_bStartWorkUsingCollaboration is TRUE, we don't show the typical
	// Start Working Wizard, but instead we show the "Get Source Text from
	// Paratext/Bibledit Project" dialog.
	if (m_bStartWorkUsingCollaboration)
	{
		gbDoingInitialSetup = FALSE; // ensure it's off, otherwise RecalcLayout() may
									 // fail after phrase box gets past end of doc
		CGetSourceTextFromEditorDlg dlg(GetMainFrame());
		dlg.CenterOnParent();
		wxASSERT(!m_collaborationEditor.IsEmpty());
		dlg.m_collabEditorName = m_collaborationEditor; // _T("Paratext") or _T("Bibledit");
		int dlgResult = dlg.ShowModal();
		if (dlgResult == wxID_CANCEL)
		{
			// The user explicitly clicked on Cancel from the "Get Source Text
			// from Paratext/Bibledit Project" dialog. After such a Cancel,
			// the user could get the dialog up again by clicking on the
			// Open tool bar button, or selecting File | Open or File | Start
			// Working...). Normally doing a File > Open or File > Start Working...
			// would both bring up the GetSourceTextFromEditor dialog here (because
			// the App's m_bCollaboratingWithParatext or m_bCollaboratingWithBibledit
			// flags would be true at this point. The user would have to exit the
			// program and start up again to get the normal wizard, unless we ask
			// if the user wants to turn collaboration off after this Cancel. We'll
			// ask the user. We have to set the App's flags and also save the project
			// config file (since the flags get read out of the config file before the
			// ChooseCollabOptionsDlg is shown again).
			int response;
			wxString msg = _("You cancelled the dialog - You may turn collaboration off if you want to access a different project from the Start Working Wizard.\nDo you want to turn collaboration off?");
			response = wxMessageBox(msg,_T(""),wxICON_QUESTION | wxYES_NO);
			if (response == wxYES)
			{
				// The user selected to "Turn Collaboration OFF"
				if (m_collaborationEditor == _T("Paratext"))
				{
					m_bCollaboratingWithParatext = FALSE;
				}
				else if (m_collaborationEditor == _T("Bibledit"))
				{
					m_bCollaboratingWithBibledit = FALSE;
				}
				// The user wants to get the wizard to select a different project.
				LogUserAction(_T("Collaboration turned OFF by user after Cancel of GetSourceTextFromEditorDlg"));
				m_bStartWorkUsingCollaboration = FALSE;
				// Set the File > Open and File > Save menu items back to their normal
				// state - without the parenthetical information in the labels.
				MakeMenuInitializationsAndPlatformAdjustments(collabAvailableTurnedOff);
				// Save the changes to the above collab values to the project config file.
				bool bOK;
				bOK = WriteConfigurationFile(szProjectConfiguration, m_curProjectPath,projectConfigFile);
				bOK = bOK; // was unused, so prevent compiler warning
				m_bJustLaunched = TRUE; // cause the wizard to open in MainFrame's OnIdle() handler
			}
			else if (response == wxNO)
			{
				m_bJustLaunched = FALSE;
			}
			return TRUE;
		}
		else if (dlgResult == wxID_ABORT) // whm added 19Apr12
		{
			// the GetSourceTextFromEditor dialog had to abort due to a the external editor either having
			// less than two projects, or from the project config file's collaboration settings having 
			// specified PT/BE projects that cannot be found in the list of the external editor's projects.
			wxString msg = _("Adapt It cannot collaborate with this project (%s). There is a problem with the project's settings.\nPlease ask your administrator for help.");
			msg = msg.Format(msg,dlg.m_TempCollabAIProjectName.c_str());
			wxMessageBox(msg,_T(""),wxICON_WARNING);
			m_bStartWorkUsingCollaboration = FALSE;
			m_bJustLaunched = TRUE; // cause the wizard to open in MainFrame's OnIdle() handler
			return TRUE;
		}

		// In PT or BE Collaboration mode, the CGetSourceTextFromEditorDlg class
		// above will ensure that a path is set for m_curAdaptionsPath and that
		// it exists even upon a SHIFT-down startup and calling of SetDefaults().
		// Hence, we return below without executing the remining code below.

		// Note: we should return TRUE for PT or BE collaboration.
		return TRUE;
	}

	// Do we have a valid directory? Probably not if user copied
	// a project from another user or a different platform.
	bool bDirPathOk = ::wxDirExists(m_curAdaptionsPath);
	if (m_curAdaptionsPath.IsEmpty())
	{
		// for debugging...
		//bool bUse = m_bUseCustomWorkFolderPath;
		//bool bLocked = m_bLockedCustomWorkFolderPath;
		//wxString s = m_customWorkFolderPath;

		// path is empty, possibly because user held SHIFT key down, or a basic
		// config file could not be opened at the custom work folder location, and so
		// SetDefaults() was called to get default parameters -- but doing that leaves
		// the m_curAdaptionsPath empty, so just show the user whatever is in the
		// custom work folder and let him choose unless he prefers to exit
		if (m_curAdaptionsPath.IsEmpty() && !m_customWorkFolderPath.IsEmpty()
			&& m_bUseCustomWorkFolderPath)
		{
			// no config file read in
			wxString message1, message2;
			message1 = message1.Format(_("No project folder defined yet. "),
				m_curAdaptionsPath.c_str());
			message2 = message1 +
_("\nIf you want to continue, you must choose a project or create a new project.\nDo you want to continue? ");
			int result = wxMessageBox(message2,_("Basic Configuration File Not Read"), wxYES_NO | wxICON_WARNING);
			if (result == wxNO)
			{
				wxASSERT(FALSE);
				// whm modified to use wxKill() instead of wxExit() which is the same as a crash
				wxKill(::wxGetProcessId(),wxSIGKILL); // wxExit();
				return FALSE;
			}
		}
	}
	else if (!bDirPathOk)
	{
		// if we get here because we closed a basic configuration file in order to make an
		// administrator basic configuration file for the targetted custom folder location
		// and the project name part that gets put in m_curAdaptionsPath doesn't exist at
		// the custom location, we'd of course not want to have the warning message come
		// up to disturb the administrator - instead, just let the wizard show what is
		// present, if anything, for projects at the custom work folder
		if (!(!m_customWorkFolderPath.IsEmpty() && m_bUseCustomWorkFolderPath))
		{
			// malformed config file, warn user and allow choice to continue (and we are
			// not in a custom work folder path being used state, its a normal state)
			wxString message1, message2;
			message1 = message1.Format(_("Failed to find the %s folder."),
				m_curAdaptionsPath.c_str());
			message2 = message1 + _(
"\nIf you want to continue, you must choose a different project or create a new project.\nDo you want to continue? ");
			int result = wxMessageBox(message2,_("Bad path in config file"), wxYES_NO | wxICON_WARNING);
			if (result == wxNO)
			{
				wxASSERT(FALSE);
				// whm modified to use wxKill() instead of wxExit() which is the same as a crash
				wxKill(::wxGetProcessId(),wxSIGKILL); // wxExit();
				return FALSE;
			}
		}
	}

	CStartWorkingWizard startWorkingWizard(GetMainFrame());
	startWorkingWizard.CenterOnParent(); // whm Note: calling Center() on the wizard has no effect
	// Note:
	// wizard pages are created within the CStartWorkingWizard's constructor
	//
    // Since all the wizard pages have the startWorkingWizard as parent window they will be
    // destroyed automatically when startWorkingWizard goes out of scope below.
	//
    // Each of the wizard page's InitDialog() handlers is NOT automatically called when the
    // pages are created or shown in the Start Working Wizard. They must be called
    // explicitly in program code to execute. We've made them public functions in their
    // class declarations so we can call them explicitly. The InitDialog function for each
    // page is called by the preceding page's OnWizardPageChanging() function (at the end
    // of the bMovingForward block).
	//
    // The general ordering of the individual wizard pages is determined by the GetNext()
    // and GetPrev() calls within the page's methods. The changed order is determined and
    // set from within the pProjectPage and the pDocPage's GetNext() and GetPrev()
    // handlers. Hence, the displaying of a 1-page, 2-page or 8-page wizard is established
    // as the wizard runs depending on the following conditional states of the program:
	//
	//    a. If a project is currently open (user gets a 1-page wizard)
	//    b. If a project is not currently open (user gets a 2-page wizard)
	//    c. If the <New Project> item has been selected from the project page (user gets
	//       an 8-page wizard)
	// Details:
    // The 1-page wizard displays the docPage initially if a project is currently open and
    // the user selects File | Start Working... This allows the user to select a different
    // document from the same project, or select <New Document> to create a new document in
    // the same project.
	//
    // The 2-page wizard displays the projectPage initially (followed by the docPage) if
    // the user or program has selected an existing project on the projectPage, then
    // continues (via click on Next, or if the existing project selection was made with a
    // double click). In this case the docPage appears as the second wizard page, allowing
    // the user to select any existing document from the docPage's list, or <New Document>
    // to create a new document within the selected project. The reverse also happens if at
    // the docPage, the user clicks on the Prev button - the previous page is the
    // projectPage.
	//
    // The full 8-page wizard will appear if the user selects <New Project> on the
    // projectPage and proceeds (via Next or double click). The 8 pages define the most
    // important items of information and parameters for any new project.
	// The 8 pages of the full wizard are presented in order, which are:
	//   (1) the projectPage,
	//   (2) the langaugesPage,
	//   (3) the fontPage,
	//   (4) the punctMapPage,
	//   (5) the caseEquivPage,
	//   (6) the USFMpage,      [added in version 3]
	//   (7) the FilteringPage, [added in version 3]
	//   (8) the docPage.
    // At any time within the 1-page or 2-page wizard the user can use the Back button to
    // go back to the project page and start creating a new project by selecting <New
    // Project> from the project page and continuing through the now active full 8-page
    // wizard.

	// Call RunWizard to start the wizard
	pStartWorkingWizard->CenterOnParent();
	pStartWorkingWizard->RunWizard(pStartWorkingWizard->GetFirstPage());
	gbWizardNewProject = FALSE; // reset wizard global back to FALSE
	pStartWorkingWizard = (CStartWorkingWizard*)NULL;

	// The code below was within the else (not ID_WIZFINISH) above
    // BEW added 31Oct05 to prevent the Project config file for the last-opened project
    // being clobbered by a Cancel of the wizard at the project page, or any other page
    // other than the doc_page (since the latter will have resulted in the project config
    // file being loaded, if the project pre-existed).
	if (!gbReachedDocPage)
	{
        // user cancelled before getting to the document page, and so we cannot know what
        // project path is valid, so set m_curProjectPath to NULL so that SaveModified()
        // (which gets called, for example, from OnClose()'s call of CanCloseFrame() when
        // user clicks window's close box) does not write out a default project config file
        // to the last opened project - thereby clobbering any case equivalences set up in
        // it and its auto caps flag setting if the latter was turned on in that project)
		m_curProjectPath.Empty();
	}

    // BEW added 28Nov05. If the user reached the Document page, in book mode, and then
    // cancelled out he likely did so because there were no files in the book folder yet
    // and he cancelled out in order to use the Move command to move one or more from the
    // Adaptations folder into the book folder. Without the following change, the status
    // bar continues to say that the current folder is the Adaptations one, when in fact it
    // is not. So we have the status bar updated here too.
	if (gbReachedDocPage)
		RefreshStatusBarInfo();

	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     pointer to the document
/// \remarks
/// Called from: many places throughout the application where a pointer to the document is
/// requited to call a function/method of the Doc.
/// Gets a pointer to the current document.
////////////////////////////////////////////////////////////////////////////////////////
CAdapt_ItDoc* CAdapt_ItApp::GetDocument()
{
	// We need to get the first doc in doc manager's list
	CAdapt_ItDoc* pDoc = (CAdapt_ItDoc*)NULL;
	pDoc = (CAdapt_ItDoc*)m_pDocManager->GetCurrentDocument();
	if (pDoc == NULL)
	{
		return pDoc;
	}
	pDoc = (CAdapt_ItDoc*)m_pDocManager->GetDocuments().GetFirst()->GetData();
	if (pDoc == NULL) return NULL;
	wxASSERT(pDoc->IsKindOf(CLASSINFO(CAdapt_ItDoc)));
	return pDoc;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     pointer to the free translations manager
/// \remarks
/// Called from: many places throughout the application where a pointer to the CFreeTrans
/// is required to call a function/method of the CFreeTrans.
/// Gets a pointer to the current CFreeTrans.
/// NOTE: Needs to be called with reference to the app object e.g. pApp->GetFreeTrans()
////////////////////////////////////////////////////////////////////////////////////////
CFreeTrans*	CAdapt_ItApp::GetFreeTrans()
{
	// The member function m_pFreeTrans was set when the app's OnInit() created the
	// CFreeTrans object.
	wxASSERT(m_pFreeTrans);
	return m_pFreeTrans;
}
////////////////////////////////////////////////////////////////////////////////////////
/// \return     pointer to the Layout
/// \remarks
/// Called from: many places throughout the application where a pointer to the Layout
/// is required to call a function/method of the Layout.
/// Gets a pointer to the current Layout.
/// NOTE: Needs to be called with reference to the app object e.g. pApp->GetLayout()
////////////////////////////////////////////////////////////////////////////////////////
CLayout*	CAdapt_ItApp::GetLayout()
{
	// The member function m_pLayout was set during app startup
	wxASSERT(m_pLayout);
	return m_pLayout;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     pointer to the CNotes object instance
/// \remarks
/// Called from: many places throughout the application where a pointer to the CNotes
/// object is required to call a function/method of CNotes.
/// Gets a pointer to the current CNotes object.
////////////////////////////////////////////////////////////////////////////////////////
CNotes*	CAdapt_ItApp::GetNotes()
{
	wxASSERT(m_pNotes);
	return m_pNotes;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     pointer to the CRetranslation object instance
/// \remarks
/// Called from: many places throughout the application where a pointer to the CRetranslation
/// object is required to call a function/method of CRetranslation.
/// Gets a pointer to the current CRetranslation object.
////////////////////////////////////////////////////////////////////////////////////////
CRetranslation*	CAdapt_ItApp::GetRetranslation()
{
	wxASSERT(m_pRetranslation);
	return m_pRetranslation;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     pointer to the CPlaceholder object instance
/// \remarks
/// Called from: many places throughout the application where a pointer to the CPlaceholder
/// object is required to call a function/method of CPlaceholder.
/// Gets a pointer to the current CPlaceholder object.
////////////////////////////////////////////////////////////////////////////////////////
CPlaceholder*	CAdapt_ItApp::GetPlaceholder()
{
	wxASSERT(m_pPlaceholder);
	return m_pPlaceholder;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     pointer to the view
/// \remarks
/// Called from: many places throughout the application where a pointer to the view is
/// required to call a function/method of the View.
/// Gets a pointer to the current view.
////////////////////////////////////////////////////////////////////////////////////////
CAdapt_ItView* CAdapt_ItApp::GetView()
{
	// We need to get the first view associated with the first doc
	CAdapt_ItDoc* pDoc;
	pDoc = GetDocument();
	if (pDoc == NULL)
		return NULL;
	CAdapt_ItView* pView = (CAdapt_ItView*)GetDocument()->GetFirstView();
	if (pView == NULL) return NULL;
	wxASSERT(pView->IsKindOf(CLASSINFO(CAdapt_ItView)));
	return pView;
}

/////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the Doc's OnFileOpen().
/// In recent version of Adapt It, this always calls up the Start Working Wizard by a call
/// to DoStartWorkingWizard().
/////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DoFileOpen()
{
	// DoFileOpen() makes it possible to contextualize the Title of the file dialog.
	// MFC version note:
    // BEW changed 4May 05 so that a click on the Open command in the File menu (which can
    // only be done after the document has been closed - and so the window will be clear
    // and the old list of sourcephrase instances for the document will have been cleaned
    // out already) will open the Start Working... wizard at the document page. (It opens
    // at the document page because DoStartWorkingWizard() has a test near the start for
    // m_pKB non-NULL and the flag m_bKBReady being TRUE, and if so then it knows a project
    // is open and so it should open at the document pane.)
    // The reason for changing DoFileOpen() to avoid using the MFC standard file i/o
    // dialog was because of the possibility that Book Folder mode might have been used at
    // some earlier time and if so the Adaptations folder will have 67 folders at the top
    // of the list of files and folders. Not only would this be confusing to the user (he'd
    // have to scroll down a long way to see the available documents), but he could use the
    // dialog to open any book folder or Adaptations folder without Adapt It knowing, and
    // so defeat the built in modality of legacy mode versus book folder mode. This must be
    // prevented at any cost, and so causing a click on the Open command to instead open
    // the wizard is both aesthetically pleasing and safe. This means it is impossible for
    // the user to navigate up or down the folder hierarchy within Adapt It except by the
    // one way which Adapt It totally controls - to turn on or off book folders mode.
	wxCommandEvent dummyevent;
	DoStartWorkingWizard(dummyevent);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnInit() and GetBasicSettingsConfiguration().
/// Makes use of the wxWidgets ::wxGetHomeDir() method to determine the best
/// platform-specific location for the user's work folder, creating it if necessary. The
/// user's work folder is stored in the m_workFolderPath global.
///
/// BEW modified 18Aug09 to support custom work folder locations:
/// The approach I have taken for this in EnsureWorkFolderPresent() always calculates the
/// legacy default location for every call of this function; but when the
/// m_bUseCustomWorkFolderPath flag is TRUE, we just reset the working directory to the
/// custom work one. So, if the user reverts to the legacy location, calling this function
/// with m_bUseCustomWorkFolderPath set to FALSE will ensure the default location are set
/// up correctly
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::EnsureWorkFolderPresent()
{
    // whm 5Jun09 modified this routine to implement the ability of the user to specify a
    // non-default location for a work folder as supplied from a -wf <path> command-line
    // option.
	wxString stdDocsDir = _T("");
	wxString dirPath = _T("");
	wxString workFolderPath = _T("");
	wxString workFolder;

	workFolder = m_theWorkFolder; // always "Adapt It Work" or "Adapt It Unicode Work"

	// whm Design Notes:
	// We want to provide a default work folder path for most users who will use the
	// default location without second thought. The wxStandardPaths::GetDocumentsDir()
	// method tells us the standard place to put documents on all platforms. It also works
	// if, in Windows, the user changes/moves the location of his "Documents" folder (on
	// Vista) or "My Documents" folder (on 2000/XP) to a non-default drive or folder
	// location.
	//
	// We also want to accommodate the power-user who may want to set up a work folder
	// path in a non-default location.
	// Some possibilities for accommodating a power user's desire to use a non-default
	// location for his work folder:
	// 1. Provide a Browse button on the Project page that would allow the user to select a
	// different path for the project folder. There could also be a "Restore Default Path"
	// button next to it on the Project page. This makes it easy to change (or too easy -
	// could get naive users in trouble?).
    // BEW note 17Sep09: Interpretting "Project page" literally as meaning where a project
    // folder is to be placed, I don't think we should allow a project folder to be
    // relocated independently (and therefore potentially outside of) its work folder -
    // relocating a work folder is all that is needed, and that can take some or all of the
    // earlier location's project folders with it. I've built an Administrator menu which
    // allows for relocating the work folder etc, and I don't think we should let the
    // typical user have access to this feature and therefore I don't think we should
    // provide buttons in the Project page as suggested above.
	// 2. Allow for command-line arguments to be passed at application startup that would
	// allow the setting of a non-default work folder location. The commane-line arguments
	// can be set by right clicking on a menu or desktop shortcut to Adapt It and selecting
	// "Properties". Then on the "Shortcut" tab, a power user could add arguments to the
	// existing Target: edit box to indicate a non-default work folder location. For
	// example, the default Target string that calls the executable on Windows is something
	// like this:
	//    "C:\Program Files\Adapt It WX\Adapt_It.exe"
	// A power user could add the -wf command-line followed by the work folder path so that
	// the whole Target edit box would look like this:
	//    "C:\Program Files\Adapt It WX\Adapt_It.exe" -wf "E:\Adapt It\Data"
	// The -wf switch means that the following string is a path to the work folder (in the
	// above example the work folder is at E:\Adapt It\Data). Option 2 would be difficult
	// for all but power users to do, but that may help prevent naive users from
	// accidentally misplacing their data. At any rate, providing a way to set up a work
	// folder path in a non-default location is a feature that should be capable of being
	// turned off by an advisor if/when we provide such an adjustable interface.
	// In case 1 (and possible also case 2) we could save the indicated non-default path as
	// a key-value pair in the m_pConfig settings. The key value could be something like
	// "user_defined_work_folder_path" with the data being the string representing the path
	// to the non-default location.
	// whm Note 5Jun09: I am initially providing the -wf <path> command-line option (2
	// above). This option could eventually be supplemented with other options including
	// option 1 above.

	// whm Note: I first used the wxWidgets ::wxGetHomeDir() function to determine the
	// users home directory and then augment it to include "Documents" or "My Documents"
	// folder (if Windows). The wxGetHomeDir() function however, does not detect the
	// situation where a user "Moves" his "Documents" (or My Documents) folder to a
	// non-default location. Testing shows that using the
	// wxStandardPaths::GetDocumentsDir() function does get the right folder, regardless of
	// whether the user has "moved" it or not.

	// Get the "documents" directory for the current system/platform.
	wxStandardPaths stdPaths;
//#ifdef __WXMAC__
	// whm note 18Jun09: the wxStandardPaths::GetDocumentsDir() is probably causing program
	// crash when compiled for Mac OS X 10.3 Panther, so I'm using the older
	// ::wxGetHomeDir() function for the Mac which should return the same directory string
	// on the Mac that wxStandardPaths::GetDocumentsDir() does.
	// GDLC 29Sep11 Not needed now that we are not targeting MacOS Panther or PPC.
//	stdDocsDir = ::wxGetHomeDir();
//#else
	stdDocsDir = stdPaths.GetDocumentsDir(); // The GetDocumentsDir() function is new since
											 // wxWidgets version 2.7.0
//#endif
	// Typically the "documents" directory depends on the system:
	// Unix: ~/(the home directory, i.e., /home/<username>/)
	// Windows (earlier and Vista): C:\Documents and Settings\username\Documents
	// Windows (2000 and XP): C:\Documents and Settings\username\My Documents
	// Mac: ~/(the home directory, i.e., /Users/<username>/

	// whm note: In the cross-platform version we never refer to a specific "Documents" or
	// "My Documents" folder and so we do not need to localize the name of the folder that
	// is returned by the "GetDocumentsDir() function call.
	//
	// Set the current working directory to point to the standard docs directory which
	// would normally be the "Documents" or "My Documents" folder on Windows, the ~ (home
	// directory) on Linux, or the ~/Documents directory on the Mac.
	::wxSetWorkingDirectory(stdDocsDir);
	dirPath = ::wxGetCwd();
	m_localPathPrefix = dirPath; // m_localPathPrefix used in MakeForeignBasicConfigFileSafe
								 // which gets called subsequently in OnInit().

	// whm modified 5Jun09 to use m_wf_forced_workFolderPath if it was defined on the
	// command-line
	if (!m_wf_forced_workFolderPath.IsEmpty())
	{
		// Ensure that the user supplied work folder path does not end with a path separator
		// character
		if (m_wf_forced_workFolderPath.GetChar(m_wf_forced_workFolderPath.Length() - 1)
			== PathSeparator)
		{
			m_wf_forced_workFolderPath.RemoveLast(); // remove the PathSeparator char
													 // at the end of the path string
		}
		workFolderPath = m_wf_forced_workFolderPath;
		// When we force the local path we need to also change m_localPathPrefix, and set
		// the working directory to it (setting the working dir is done near the end of
		// EnsureWorkFolderPresent below)
		m_localPathPrefix = m_wf_forced_workFolderPath;
	}
	else
	{
		// check that dirPath doesn't end with a PathSeparator character, eg. on Windows
		// the user may have pointed Documents at D:\, and so adding an additional separator
		// would generate a wrong path... this check will have to be done in
		// MakeForeignBasicConfigFileSafe() too. Easiest thing to do is just remove the
		// final separator if it is there...  BEW added 31Jan10
		if (dirPath.GetChar(dirPath.Length() - 1) == PathSeparator)
		{
			dirPath.RemoveLast(); // remove the PathSeparator char
								  // at the end of the path string
		}
		workFolderPath = dirPath + PathSeparator + workFolder;
	}

	if (!::wxDirExists(workFolderPath))
	{
        // we did not find the required directory, so create it now - it has to be present
        // before the app calls GetPossibleAdaptionProjects function
		// WX NOTE: On Unix/Linux wxMkdir has a second default param: int perm = 0777 which
		// makes a directory with full read, write, and execute permissions.
		if (!::wxMkdir(workFolderPath))
		{
			// work folder creation failed for some reason, so abort
			wxString message;
			message = _("Adapt It cannot create its work folder: ") + workFolderPath;
			message += _("\nAdapt It cannot continue and will now abort.");
			wxMessageBox(message, _("Critical Error"), wxICON_ERROR | wxOK);
			LogUserAction(_T("Adapt It cannot create its work folder in EnsureWorkFolderPresent(. Aborting...)"));
			// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
			wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
		}
	}

	// be sure to set the m_workFolderPath variable (path to the Adapt It Work folder, or
    // the Adapt It Unicode Work folder) before exiting
	m_workFolderPath = workFolderPath;

	if ((m_workFolderPath != m_customWorkFolderPath) && m_bUseCustomWorkFolderPath)
	{
		// customWorkFolderPath exists so set the current work directory to it
		::wxSetWorkingDirectory(m_customWorkFolderPath);
	}
	else
	{
		// workFolderPath exists so set the current work directory to it
		::wxSetWorkingDirectory(workFolderPath);
	}

	// for the custom location, m_customWorkFolderPath is already determined to be a valid
	// work directory and so we don't need to do anything more here
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnFileBackupKb() and OnFileRestoreKb().
/// Calls SaveGlossingKB().
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DoGlossingKBBackup()
{
	SaveGlossingKB(TRUE); // resaves the KB and makes a backup which is a copy,
						  // after deleting old one
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return
/// \remarks
/// Called from: the App's OnFileBackupKb() and OnFileRestoreKb().
/// Calls SaveKB().
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DoKBBackup()
{
    // NOTE: wxWidgets version: SaveKB returns bool value which is ignored here. I've added
    // an error message in SaveKB() in case it fails.
	SaveKB(TRUE); // resaves the KB and makes a backup which is a copy,
				  // after deleting old one
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated
///                         menu item is selected
/// \remarks
/// Called from: The Event Table when "Backup Knowledge Base" item is selected on the File
/// Menu. Backs up the regular or glossing KB. If gbIsGlossing is TRUE it calls
/// DoGlossingKBBackup(), otherwise it calls DoKBBackup().
/// whm 15Jan11 changed so that both DoGlossingKBBackup() and DoKBBackup() are called
/// when the File > Backup Knowledge Base menu item is selected.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnFileBackupKb(wxCommandEvent& WXUNUSED(event))
{
	LogUserAction(_T("Initiated OnFileBackKb()"));
	//if (gbIsGlossing)
		DoGlossingKBBackup();
	//else
		DoKBBackup();
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// When gbIsGlossing is TRUE and m_bGlossingKBReady flag is TRUE the "Backup Knowledge
/// Base" item on the File menu is enabled, otherwise it is disabled. When gbIsGlossing is
/// FALSE (using the normal KB), and the m_bKBReady flag is TRUE the the "Backup Knowledge
/// Base" item on the File menu is enabled, otherwise it is disabled.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateFileBackupKb(wxUpdateUIEvent& event)
{
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbIsGlossing)
	{
		if (m_bGlossingKBReady)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
	else
	{
		if (m_bKBReady)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxUpdateUIEvent that is generated when the File Menu
///                         is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is in Vertical Edit Mode, Free Translation Mode, or there is no
/// valid document pointer (it is NULL), the "Restore Knowledge Base..." item on the File
/// menu is always disabled and this event handler returns immediately.
/// As long as the active KB (glossing or regular) is in a ready state and there is at
/// least one source phrase listed in m_pSourcePhrases, the "Restore Knowledge Base..."
/// item on the File menu is enabled, otherwise it is disabled.
/// BEW modified 19Nov09, suppress the menu item when local user has read-only access to
/// a remote project (it must not be possible to initiate a KB restoration on the remote
/// user's machine; that could lose some of his data. He must do it locally.)
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateFileRestoreKb(wxUpdateUIEvent& event)
{
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItDoc* pDoc = GetDocument();
	if (pDoc == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	// BEW 24Aug11 changed to allow Restore Knowledge Base to be chosen whether or not a
	// document is currently open (if open, it will be forced close automatically before
	// the restore is attempted) - all we check for is that the relevant KB is ready
	if ((!gbIsGlossing && m_bKBReady) || (gbIsGlossing && m_bGlossingKBReady))
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
	// legacy criteria
	//if ((!gbIsGlossing && m_bKBReady && (m_pSourcePhrases->GetCount() == 0)) ||
	//	(gbIsGlossing && m_bGlossingKBReady && (m_pSourcePhrases->GetCount() == 0)))
	//{
	//	event.Enable(TRUE);
	//}
	//else
	//{
	//	event.Enable(FALSE);
	//}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      bDoOnGlossingKB      ->     check the glossing KB if TRUE, otherwise
///                                         check the regular KB
/// \remarks
/// Called from: the App's DoGlossingKBBackup(), DoKBBackup()
/// Called only if a serious problem was detected in the active KB. After cleaning things
/// up, it substitutes the backup copy of the active KB after deteleting the currently
/// (corrupted) KB.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SubstituteKBBackup(bool bDoOnGlossingKB)
{
	CAdapt_ItDoc* pDoc = GetDocument();

	// clobber the bad knowledge base's structures in memory
	if (bDoOnGlossingKB)
	{
		pDoc->EraseKB(m_pGlossingKB);
		m_pGlossingKB = (CKB*)NULL;
	}
	else
	{
		pDoc->EraseKB(m_pKB);
		m_pKB = (CKB*)NULL;
	}

	// set up the m_curKBPath and backup ones
	if (bDoOnGlossingKB)
	{
		pDoc->UpdateFilenamesAndPaths(FALSE,FALSE,FALSE,TRUE,TRUE);
	}
	else
	{
		pDoc->UpdateFilenamesAndPaths(TRUE,TRUE,TRUE,FALSE,FALSE);
	}

	/*
    // determine which path to use; since the KB or GlossingKB could be on disk in binary
    // or XML format from version 3 onwards
	wxString strUseThisPath;
	if (bDoOnGlossingKB)
	{
		if (::wxFileExists(m_curGlossingKBPath))
		{
			strUseThisPath = m_curGlossingKBPath;
		}
		else
		{
			strUseThisPath = m_altGlossingKBPath;
		}
	}
	else
	{
		if (::wxFileExists(m_curKBPath))
		{
			strUseThisPath = m_curKBPath;
		}
		else
		{
			strUseThisPath = m_altKBPath;
		}
	}
	*/
	// get rid of the knowledge base file
	wxString message;
	if (bDoOnGlossingKB)
	{
		if (!::wxRemoveFile(m_curGlossingKBPath))
		{
			message = message.Format(_(
			"Warning: Did not remove bad knowledge base file %s."),
			m_curGlossingKBPath.c_str());
			wxMessageBox(message, _T(""), wxICON_ERROR);
			wxASSERT(FALSE);
			wxExit();
		}
	}
	else
	{
		if (!::wxRemoveFile(m_curKBPath))
		{
			message = message.Format(_(
			"Warning: Did not remove bad knowledge base file %s."),
			m_curKBPath.c_str());
			wxMessageBox(message, _T(""), wxICON_ERROR);
			wxASSERT(FALSE);
			wxExit();
		}
	}

	// check to see if there is a backup KB available, & if so, rename if
	if (bDoOnGlossingKB)
	{
		if(::wxFileExists(m_curGlossingKBBackupPath) && !::wxDirExists(m_curGlossingKBBackupPath))
		{
            // attempt to rename the glossing backup file to the same name, .BAK becomes .xml
            // extension
			if (!::wxRenameFile(m_curGlossingKBBackupPath,m_curGlossingKBPath))
			{
				wxString message;
				message = message.Format(_(
"Error renaming glossing KB Backup file, path %s, to be the new glossing KB file."),
				m_curGlossingKBBackupPath.c_str());
				wxMessageBox(message, _T(""), wxICON_ERROR);
				wxASSERT(FALSE);
				wxExit();
			}
		}
		else
		{
			// the backup glossing KB does not exist, so all we can do is substitute an empty
            // one and save it to disk.
			m_pGlossingKB = new CKB(TRUE);
			wxASSERT(m_pGlossingKB != NULL);

			bool bOK = StoreGlossingKB(FALSE); // first time, so we can't make a backup
			if (bOK)
			{
				m_bGlossingKBReady = TRUE;
			}
			else
			{
				// IDS_STORE_KB_FAILURE
				wxMessageBox(_(
				"Error: saving the knowledge base failed. The application will now close."),
				_T(""), wxICON_ERROR); // something went wrong
				wxASSERT(FALSE);
				wxExit();
			}
			return;
		}
	}
	else // adaptations KB
	{
		if(::wxFileExists(m_curKBBackupPath) && !::wxDirExists(m_curKBBackupPath))
		{
			// attempt to rename the backup file to the same name, .BAK becomes .xml extension
			if (!::wxRenameFile(m_curKBBackupPath, m_curKBPath))
			{
				wxString message;
				message = message.Format(_(
			"Error renaming KB Backup file with path %s to become the new KB file."),
				m_curKBBackupPath.c_str());
				wxMessageBox(message, _T(""), wxICON_ERROR);
				wxASSERT(FALSE);
				wxExit();
			}
		}
		else
		{
            // the backup KB does not exist, so all we can do is substitute an empty one
            // and save it to disk.
			m_pKB = new CKB(FALSE);
			wxASSERT(m_pKB != NULL);

			// store the language names in it
			m_pKB->m_sourceLanguageName = m_sourceName;
			m_pKB->m_targetLanguageName = m_targetName;

			bool bOK = StoreKB(FALSE); // first time, so we can't make a backup
			if (bOK)
			{
				m_bKBReady = TRUE;
			}
			else
			{
				// IDS_STORE_KB_FAILURE
				wxMessageBox(_(
			"Error: saving the knowledge base failed. The application will now close."),
				_T(""), wxICON_ERROR); // something went wrong
				wxASSERT(FALSE);
				wxExit();
			}
			return;
		}
	}

	// now that we have a substitute KB made from the old backup, load it; but first
	// ensure it really can be found
	if (bDoOnGlossingKB)
	{
		if(::wxFileExists(m_curGlossingKBPath) && !::wxDirExists(m_curGlossingKBPath))
		{
            // the .xml file exists, so we need to create a CKB instance in memory, open the
            // .xml file on disk, and fill the memory instance's members
			wxASSERT(m_pGlossingKB == NULL);
			m_pGlossingKB = new CKB(TRUE);
			wxASSERT(m_pGlossingKB != NULL);
			// whm 25Aug11 Note: Since SubstituteKBBackup() is only called if a serious problem
			// is detected in the KB, I'm not going to have it display a progress dialog.
			bool bOK = LoadGlossingKB(FALSE);
			if (bOK)
			{
				m_bGlossingKBReady = TRUE;
				LoadGuesser(m_pGlossingKB); // whm added 29Oct10
			}
			else
			{
				wxMessageBox(_(
	"Error: loading the glossing knowledge base failed. The application will now close."),
				_T(""), wxICON_ERROR);
				wxASSERT(FALSE);
				wxExit();
			}
		}
		else
		{
			// it has to be there, so again something quick & diry since this should never
			// happen
			wxMessageBox(_(
			"Glossing KB file not found immediately after it was renamed!\n"),
			_T(""), wxICON_ERROR);
			wxASSERT(FALSE);
			wxExit();
		}
	}
	else
	{
		if(::wxFileExists(m_curKBPath) && !::wxDirExists(m_curKBPath))
		{
            // the .xml file exists, so we need to create a CKB instance in memory, open the
            // .xml file on disk, and fill the memory instance's members
			wxASSERT(m_pKB == NULL);
			m_pKB = new CKB(FALSE);
			wxASSERT(m_pKB != NULL);
			// whm 25Aug11 Note: Since SubstituteKBBackup() is only called if a serious problem
			// is detected in the KB, I'm not going to have it display a progress dialog.
			bool bOK = LoadKB(FALSE);
			if (bOK)
			{
				m_bKBReady = TRUE;
				LoadGuesser(m_pKB); // whm added 29Oct10
			}
			else
			{
				// IDS_LOAD_KB_FAILURE
				wxMessageBox(_(
				"Error: loading a knowledge base failed. The application will now close."),
				_T(""), wxICON_ERROR);
				wxASSERT(FALSE);
				wxExit();
			}
		}
		else
		{
			// it has to be there, so again something quick & diry since this should never
			// happen
			wxMessageBox(_(
			"KB file not found immediately after it was renamed!\n"),
			_T(""), wxICON_ERROR);
			wxASSERT(FALSE);
			wxExit();
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxUpdateUIEvent that is generated when the Tools Menu
///                         is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is in Free Translation Mode, the "Load Consistent Changes..." item
/// on the Tools menu is always disabled and this event handler returns immediately,
/// otherwise the "Load Consistent Changes..." item on the Tools menu is enabled.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateLoadCcTables(wxUpdateUIEvent& event)
{
	// whm added 15Mar12 for read-only mode
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxUpdateUIEvent that is generated when the Tools Menu
///                         is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is in Free Translation Mode, the "Unload Consistent Changes..." item
/// on the Tools menu is always disabled and this event handler returns immediately. If the
/// m_bTablesLoaded flag is TRUE the "Unload Consistent Changes..." item on the Tools menu
/// is enabled, otherwise it is disabled.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateUnloadCcTables(wxUpdateUIEvent& event)
{
	// whm added 26Mar12.
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
    // Note: In the if (m_bCCTableLoaded) condition below m_bCCTableLoaded is an array, of
    // booleans, and since the array name m_bCCTableLoaded is just a pointer the condition
    // will be false if the array is NULL otherwise true, probably not what Bruce wanted.
    // I'm changing this UpdateUI to use the m_bTablesLoaded boolean instead
	if (m_bTablesLoaded)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated
///                         menu item is selected
/// \remarks
/// Called from: the Tools menu when the "Load Consistent Changes..." menu item is
/// selected. This menu handler creates the four m_pConsistentChanger instances of the
/// CConsistentChanger class. It then creates a wxPropertySheet with 4 tabs, one for each
/// potential changes table, and shows it as a modal dialog to the user. If the user
/// defines one or more .cct tables for use by Adapt It, the table(s) is/are loaded by
/// calling the appropriate m_pConsistentChanger's loadTableFromFile(path) method(s). Once
/// one or more tables are loaded the paths to the tables are stored/remembered and
/// m_bTablesLoaded is set to TRUE. If an error is encountered in loading any one of the
/// tables, the user is informed, and any subsequent tables are not loaded. Note: Simply
/// loading consistent changes tables (.cct files) does not turn on the consistent changes
/// functionality. To turn on the consistent changes functionality the user must also
/// select the "Use Consistent Changes" toggle item in the Tools menu. Change tables remain
/// loaded until the user either selects "Unload Consistent Changes" from the Tools menu,
/// or exits the application.
///////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnToolsDefineCC(wxCommandEvent& WXUNUSED(event))
{
	// define and load one or more consistent change tables
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	LogUserAction(_T("Initiated OnToolsDefineCC()"));

	// The wxWidgets version handles consistent changes directly via our CCModule which
    // incapsulates the CC functionality of the old cc32.dll dynamic library within the
    // Adapt It executable, without having to resort to calling any external dynamic
    // library file. This approach has a number of advantages including not having to
    // install, locate and load a dynamic library file at run time. Moreover, since the
    // CCModule is a C++ class modified for wxWidgets, the CC functionality is
    // automatically available without need for further modifications for Windows, Linux
    // and/or Macintosh builds.
    //
    // In the MFC version the Adapt It program itself cannot run at all unless the cc32.dll
    // file is present on the user's system. Although the wxWidgets framework has a
    // wxDynamicLibrary class which could be used to load external dynamic library files
    // via its methods: Load(), IsLoaded(), and Unload(), it makes more sense to do the
    // extra effort of converting the CC functionality into the CCModule class and thus
    // avoid all the potential problems of dealing with external libraries. We can load,
    // use, and unload .cct table files at will whenever the user selects the "Load
    // Consistent Changes...", "Unload Consistent Changes", or the "Use Consistent Changes"
    // menu items from the Tools menu.

	// Create the CConsistentChanger objects (a 4-element array of void* pointers was declared in the
    // App class. We create the objects here and store their pointers in the m_pConsistentChanger[]
    // array.
    // whm Note: Rather than creating all four consistent changer instances at this point,
    // for the sake of better memory management and dealing with CCCModule's allocation of
    // buffers and tables on the heap, we should only create an instance when the user
    // actually loads one. See the "ShowModal() == wxID_OK" block below.
    // We can tell which instance has been created by examining the flags in the
    // m_bCCTableLoaded[] array.

	CCCTabbedDialog ccPropertySheet(pApp->GetMainFrame());

	// make the font show only 12 point size in the dialog
	CopyFontBaseProperties(m_pSourceFont,m_pDlgSrcFont);
	m_pDlgSrcFont->SetPointSize(12);

	// show the property sheet
	if(ccPropertySheet.ShowModal() == wxID_OK)
	{
		for (int i=0; i<4; i++)
		{
			m_tableFolderPath[i] = ccPropertySheet.m_folderPath[i];
			m_tableName[i] = ccPropertySheet.m_tblName[i];
			// create consistent changer instances and consider loaded only those the user asked
			// for
			if (m_tableName[i].IsEmpty())
				m_bCCTableLoaded[i] = FALSE;
			else
			{
				wxString msg = _T("Loaded CCTable %d");
				msg = msg.Format(msg,i);
				LogUserAction(msg);
				m_bCCTableLoaded[i] = TRUE;
				m_pConsistentChanger[i] = new CConsistentChanger;
			}
		}

		// load the tables
		wxString path = _T("");
		int whichOne = -1;

		wxString sError;
		sError.Empty();
		for (int j=0; j<4; j++)
		{
			if (m_bCCTableLoaded[j])
			{
				whichOne = j;
				path = m_tableFolderPath[j] + PathSeparator + m_tableName[j];
				sError = m_pConsistentChanger[j]->loadTableFromFile(path);
				if (!sError.IsEmpty())
					break; // don't load any more; whm added 19Jun07 - sError is checked below
			}
		}

		if (!sError.IsEmpty())
		{
			wxString addMore;
			// IDS_TABLES_LOADED_ERR
			addMore = addMore.Format(_(
"Warning: the consistent changes table number %d, and any further tables, were not loaded."),
			whichOne + 1);
			sError += addMore;
			wxMessageBox(sError, _T(""), wxICON_INFORMATION);
			LogUserAction(sError);
			// later ones won't be loaded once the error has occurred, so ensure that
			// the non-loaded ones are not tried
			switch (whichOne)
			{
			case 0:
				m_bCCTableLoaded[0] = m_bCCTableLoaded[1] = m_bCCTableLoaded[2] =
													m_bCCTableLoaded[3] = FALSE;
				break;
			case 1:
				m_bCCTableLoaded[1] = m_bCCTableLoaded[2] =
													m_bCCTableLoaded[3] = FALSE;
				break;
			case 2:
				m_bCCTableLoaded[2] = m_bCCTableLoaded[3] = FALSE;
				break;
			case 3:
				m_bCCTableLoaded[3] = FALSE;
				break;
			default:
				wxASSERT(FALSE); // this would only be a programming error
				wxExit();
			}
		}

        // our algorithm above allows processing to proceed even if an exception was
        // thrown, the relevant table, and any subsequent ones, just won't be used; but the
        // user will have been alerted
		if (m_bCCTableLoaded[0] || m_bCCTableLoaded[1] || m_bCCTableLoaded[2]
			|| m_bCCTableLoaded[3])
			m_bTablesLoaded = TRUE;
		else
			m_bTablesLoaded = FALSE;

		// force the Use ConsistentChanges checkbox to ON, if it is not ON already
		if (m_bTablesLoaded && !pApp->m_bUseConsistentChanges)
		{
			wxCommandEvent event;
			GetView()->OnUseConsistentChanges(event);
		}
	}

	int len = pApp->m_targetPhrase.Length();
	m_nStartChar = len;
	m_nEndChar = len;
	pApp->m_pTargetBox->SetSelection(len,len);
	pApp->m_pTargetBox->SetFocus();
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated
///                         menu item is selected
/// \remarks
/// Called from: the Tools menu when the "Unload Consistent Changes" menu item is selected.
/// This menu handler empties the m_tableName array, sets the m_bCCTableLoaded array flags
/// to FALSE, and changes the interface globals and menu items to their "off" state,
/// effectively "unloading" the consistent changes functionality.
/// To turn on the consistent changes functionality again, the user must again select the
/// "Load Consistent Changes..." menu item, load the .cct changes files, and then select
/// the "Use Consistent Changes" toggle item in the Tools menu.
/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnToolsUnloadCcTables(wxCommandEvent& WXUNUSED(event))
{

	m_tableName[0] = m_tableName[1] = m_tableName[2] = m_tableName[3] = _T("");
	m_bCCTableLoaded[0] = m_bCCTableLoaded[1] = m_bCCTableLoaded[2] = m_bCCTableLoaded[3]
																		= FALSE;
	m_bTablesLoaded = FALSE;
    // leave m_folderPath[] unchanged, so these can function as default folders for
    // accessing tables if the user invokes Define Consistent Changes... menu item again

	// turn off the use of cc tables
	if (m_bUseConsistentChanges)
	{
		wxCommandEvent cevent;
		GetView()->OnUseConsistentChanges(cevent);
	}

    // in case we are in auto insert mode, we should stop at this point so that user can
    // take stock of the situation and decide if he wants to change any other mode flags
	m_bAutoInsert = FALSE;
    // the above FALSE value is incompatible with m_bAcceptDefaults being TRUE, so ensure
    // that is turned off too
	m_bAcceptDefaults = FALSE;

	// turn the checkmarks off
	CMainFrame *pFrame = GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsUseCC = pMenuBar->FindItem(ID_USE_CC);
	if(pToolsUseCC != NULL)
	{
		LogUserAction(_T("Unload CC Tables"));
		pToolsUseCC->Check(FALSE);
	}
	wxMenuItem * pToolsAcceptChanges = pMenuBar->FindItem(ID_ACCEPT_CHANGES);
	if(pToolsAcceptChanges != NULL)
	{
		pToolsAcceptChanges->Check(FALSE);
	}

	// ensure the "Accept changes without stopping" flag is FALSE
	m_bAcceptDefaults = FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's SaveDocChanges() and from CMainFrame's OnIdle. Calls the Doc's
/// DoFileSave() method, and updates the times for auto saving operations.
///////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DoAutoSaveDoc()
// with additions for handling glossing versus adapting (ie. to get the stuff in the
// phrase box into the appropriate KB before the save is done)
{
	bool bOkay;
	//bOkay = GetDocument()->DoFileSave(FALSE);
	wxProgressDialog* pProgDlg = (wxProgressDialog*)NULL;
	bOkay = GetDocument()->DoFileSave_Protected(FALSE,pProgDlg); // FALSE - don't show wait/progress dialog
	wxCHECK_RET(bOkay, _T("DoAutoSaveDoc(): DoFileSave_Protected() failed, line 23,053 in Adapt_It.cpp"));

	// update the time it was last saved
	wxDateTime time = wxDateTime::Now();
	m_timeSettings.m_tLastDocSave = time;
	m_timeSettings.m_tLastKBSave = time;
	nSequNumForLastAutoSave = nCurrentSequNum;
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: CMainFrame's OnIdle.
/// Calls the View's DoFileSaveKB() method, and updates the time last saved.
///////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DoAutoSaveKB()
{
	GetView()->DoFileSaveKB();

	// update the time last saved
	wxDateTime time = wxDateTime::Now();
	m_timeSettings.m_tLastKBSave = time;
}

/////////////////////////////////////////////////////////////////////////////
// MRU file list default implementation -- copied from MFC folder's appui.cpp
// in case I want to develop a smarter override based on it sometime
/*
BOOL CWinApp::OnOpenRecentFile(UINT nID)
{
	ASSERT(m_pRecentFileList != NULL);

	ASSERT(nID >= ID_FILE_MRU_FILE1);
	ASSERT(nID < ID_FILE_MRU_FILE1 + (UINT)m_pRecentFileList->GetSize());
	int nIndex = nID - ID_FILE_MRU_FILE1;
	ASSERT((*m_pRecentFileList)[nIndex].GetLength() != 0);

	TRACE(traceAppMsg, 0, _T("MRU: open file (%d) '%s'.\n"), (nIndex) + 1,
			(LPCTSTR)(*m_pRecentFileList)[nIndex]);

	if (OpenDocumentFile((*m_pRecentFileList)[nIndex]) == NULL)
		m_pRecentFileList->Remove(nIndex);

	return TRUE;
}
*/
/////////////////////////////////////////////////////////////////////////////

//BOOL CAdapt_ItApp::OnOpenRecentFile(UINT nID)
// wx version Note: The wx doc/view framework uses OnMRUFile() as a virtual method of
// wxDocParentFrame. It is now a handler in CMainFrame, renamed to OnMRUFile(), and is a
// void function.
//bool CAdapt_ItApp::OnOpenRecentFile(wxCommandEvent& event)

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated
///                         menu item is selected
/// \remarks
/// Called from: The Event Table when "Restore Knowledge Base..." item is selected on the
/// File Menu. Restores the Knowledge Base by discarding the current knowledge base, and
/// then using the user's saved document files, it rebuilds a new KB (or glossing KB if
/// that mode is current). The restore first processes files in the current project's
/// Adaptations folder, after giving the user the option of choosing which files to process
/// via the "Which Files" dialog. Then, if book folder mode was ever used, it processes all
/// of files found in book folders automatically (without asking the user). At the end of
/// the process, it reports how many words and phrases, and how many documents it
/// processed.
/// Modified to work for either the glossing KB, or the adaptations KB BEW changed 05Sept05
/// to work on contents not just of the Adaptations folder but also the contents of the set
/// of all Bible book folders in the Adaptations folder (if book mode has at some previous
/// time been turned on)
/// BEW 19Mar10, fixed faulty logic in the book folders loop
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnFileRestoreKb(wxCommandEvent& WXUNUSED(event))
{
	// BEW added 05Jan07 to enable work folder on input to be restored when done
	wxString strSaveCurrentDirectoryFullPath = GetDocument()->GetCurrentDirectory();

	// IDS_RESTORE_KB_MSG
	int value = wxMessageBox(_(
"Use this command if the knowledge base has become corrupted.\n(To restore a glossing knowledge base, turn glossing ON and then choose this command again.)\nIt will throw away your current knowledge base, and then using your saved document files it will build a new one.\n\nDo you wish to go ahead?"),
	_T("Restore Knowledge Base..."), wxYES_NO);
	if (!(value == wxYES))
		return;

	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc);
	LogUserAction(_T("Initiated OnFileRestoreKb()"));

	// BEW 24Aug11, change protocol so as to allow the user to initiate a restore even
	// when a document is open. We check here, and if open, we force it to close and then
	// proceed as before. The .Enable() for the menu commands will enable the command so
	// long as the relevant CKB is ready
	wxString savedCurOutputPath = m_curOutputPath;	// includes filename
	wxString savedCurOutputFilename = m_curOutputFilename;
	int		 savedCurSequNum = m_nActiveSequNum;	// for resetting the box location
	bool	 savedBookmodeFlag = m_bBookMode;	// for ensuring correct mode
	bool	 savedDisableBookmodeFlag = m_bDisableBookMode;		// ditto
	int		 savedBookIndex = m_nBookIndex;
	BookNamePair*	pSavedCurBookNamePair = m_pCurrBookNamePair;

	bool bDocForcedToClose = FALSE;
	if (!m_pSourcePhrases->GetCount() == 0)
	{
		// whm 26Aug11 Open a wxProgressDialog instance here for KB Restore operations.
		// The dialog's pProgDlg pointer is passed along through various functions that
		// get called in the process.
		// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
		// be changed after the dialog is created. So any routine that gets passed the
		// pProgDlg pointer, must make sure that value in its Update() function does not
		// exceed the same maximum value (nTotal).
		wxString msgDisplayed;
		const int nTotal = gpApp->GetMaxRangeForProgressDialog(App_SourcePhrases_Count) + 1;
		wxString progMsg = _("Saving File %s  - %d of %d Total words and phrases");
		wxFileName fn(gpApp->m_curOutputFilename);
		msgDisplayed = progMsg.Format(progMsg,fn.GetFullName().c_str(),1,nTotal);
		wxProgressDialog* pProgDlg;
		pProgDlg = gpApp->OpenNewProgressDialog(_("Saving File"),msgDisplayed,nTotal,500);

		// doc is open, so close it -- we want all docs accessible to the scanning loop
		bDocForcedToClose = TRUE;
		bool fsOK = pDoc->DoFileSave_Protected(TRUE,pProgDlg); // TRUE - show the wait/progress dialog
		if (!fsOK)
		{
			// something's real wrong!
			wxMessageBox(_(
"Could not save the current document. Restore Knowledge Base command aborted.\nYou can try to continue working, but it would be safer to shut down and relaunch, even if you loose your unsaved edits."),
			_T(""), wxICON_EXCLAMATION);
			LogUserAction(_T("Could not close and save the current document. Restore Knowledge Base command aborted."));
			pProgDlg->Destroy();
			return;
		}

        // Ensure the current document's contents are removed, otherwise we will get a
        // doubling of the doc data when OnOpenDocument() is called because the latter will
		// append to whatever is in m_pSourcePhrases.
		// whm Note: ClobberDocument() is a potentially time consuming operation for long
		// documents.
		GetView()->ClobberDocument();
		// remove this instance of the wxProgressDialog
		pProgDlg->Destroy();
		pProgDlg = (wxProgressDialog*)NULL;
	}
	bool bOK;
	wxArrayString* pList = &m_acceptedFilesList;
	int nCount;

	// the 'accepted' list holds the document filenames to be used
	pList->Clear(); // ensure it starts empty

	// get whichever KB is to be worked on
	CKB* pKB;
	if (gbIsGlossing)
		pKB = m_pGlossingKB;
	else
		pKB = m_pKB;

	// Only offer option when profile settings = 0 (None) KLB 3/11/2011
	bool bRescueFlags = FALSE;
	if (m_nWorkflowProfile == 0)
	{
		// recover as many m_bAlwaysAsk flag = TRUE instances as possible
		// from the corrupted KB
		value = wxMessageBox(_(
		"Adapt It can also try to rescue your settings for the \"Force Choice For This Item\" checkbox,\nbut it might result in a harmless crash. (If so, just run Adapt It again and take the \"No\" option.)\n\nDo you wish to try this extra rescue?"),
		_T("Restore Knowledge Base..."), wxYES_NO);
		if (value == wxYES)
		{
			LogUserAction(_T("Using bRescueFlags"));
			bRescueFlags = TRUE;
		}
	}
	KPlusCList keys;
	if (bRescueFlags)
	{
		pKB->GetForceAskList(&keys);
	}

	// whm 27Aug11 added. Create a new wxProgress dialog to track the remaining steps
	// to complete this OnFileRestoreKb(): Those steps inlude potentially the following 7:
	// 1. Creating a temporary KB backup for restoring the KB later if something goes wrong.
	// 2. ClearKB().
	// 3. EnumerateDocFiles() in Adaptations location
	// 4. DoKBRestore() for docs in Adaptations location
	//  [if gbHasBookFolders]
	// 5. EnumerateDocFiles() and DoKBRestore() for each book folder
	//  [if not gbHasBookFolders]
	// 6. DoGlossingKBBackup() or DoKBBackup() depending on gbIsGlossing
	//    Note: ReOpenDocument() if doc was open at step 1 has its own prog dlg
	// 7. End of processes.

	// whm 26Aug11 Open a wxProgressDialog instance here for Restoring KB operations.
	// The dialog's pProgDlg pointer is passed along through various functions that
	// get called in the process.
	// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
	// be changed after the dialog is created. So any routine that gets passed the
	// pProgDlg pointer, must make sure that value in its Update() function does not
	// exceed the same maximum value (nTotal).
	wxString msgDisplayed;
	const int nTotal = 7; // we will do up to 7 Steps
	wxString progMsg = _("Restoring the KB - Step %d of %d");
	msgDisplayed = progMsg.Format(progMsg,1,nTotal);
	wxProgressDialog* pProgDlg;
	pProgDlg = gpApp->OpenNewProgressDialog(_("Restoring Knowledge Base..."),msgDisplayed,nTotal,500);

	// Update for step 1 Creating a temporary KB backup for restoring the KB later
	msgDisplayed = progMsg.Format(progMsg,1,nTotal);
	pProgDlg->Update(1,msgDisplayed);
	//::wxSafeYield();

	// BEW 22July10, CWhichFilesDlg is called from EnumerateDocFiles(), and if the user
	// cancels from that dialog, we don't want the KB or GlossingKB lost (it might still
	// be good), so save the relevant KB file first, and restore it below if the user has
	// cancelled from the enum call for the Adaptations dialog's contents
	wxString tempKBfilePath;
	if (gbIsGlossing)
	{
		tempKBfilePath = m_curProjectPath + PathSeparator + _T("Save_GlossingKB");
		bOK = ::wxCopyFile(m_curGlossingKBPath, tempKBfilePath);
	}
	else
	{
		tempKBfilePath = m_curProjectPath + PathSeparator + _T("Save_AdaptingKB");
		bOK = ::wxCopyFile(m_curKBPath, tempKBfilePath);
	}

	// Update for step 2 ClearKB()
	msgDisplayed = progMsg.Format(progMsg,2,nTotal);
	pProgDlg->Update(2,msgDisplayed);
	//::wxSafeYield();
	// clear out the KB, actually erase it & create a new empty one & store it ready
	// for filling
	// whm Note: ClearKB() is a potentially time consuming operation for long
	// documents.
	ClearKB(pKB,pDoc); // checks clears whichever KB is passed in as first param, &
					   // recreates an empty one

    // the pointer will be a new one because of ClearKB( ) call,
    // so update pKB to point to it
	if (gbIsGlossing)
		pKB = m_pGlossingKB;
	else
		pKB = m_pKB;

	// get a pointer to the view (since it's SDI interface, our implementation
	// has the view always present, as the doc and its template get reused)
	CAdapt_ItView* pView = GetView();
	wxASSERT(pView);

	// save entry state (only necessary if entry state had book mode on)
	BookNamePair* pSave_BookNamePair = m_pCurrBookNamePair;
	int nSave_BookIndex = m_nBookIndex;
	wxString save_bibleBooksFolderPath = m_bibleBooksFolderPath;

    // determine whether or not there are Bible book folders in the Adaptations folder; if
    // there are book folders then we have to process all the documents in each such folder
    // after processing the ones in Adaptations
    // whm note: AreBookFoldersCreated() has the side effect of changing the current work
    // directory to the passed in m_curAdaptionsPath.
	gbHasBookFolders = AreBookFoldersCreated(m_curAdaptionsPath);

	// lock view window updates till done
	pView->canvas->Freeze();

	int nCumulativeTotal = 0;
	int nDocCount = 0;

	// Update for step 3 EnumerateDocFiles() in Adaptations location
	msgDisplayed = progMsg.Format(progMsg,3,nTotal);
	pProgDlg->Update(3,msgDisplayed);
	//::wxSafeYield();

	// handle the Adaptations folder's files first - for these, we allow the
    // IDD_WHICH_FILES dialog to show and the user can remove some files from the
    // processing using it if he wishes, but for looping across all the book folders, we'll
    // suppress the dialog so that all doc files in the book folders get processed
    // whm note: EnumerateDocFiles() has the side effect of changing the current work
    // directory to the passed in m_curAdaptionsPath.
	//
	// Dialog should be suppressed for profile == 1 : klb 3/2011
	if (m_nWorkflowProfile == 1)
	{
		bOK = EnumerateDocFiles(pDoc, m_curAdaptionsPath, TRUE);
	}
	else
	{
		bOK = EnumerateDocFiles(pDoc, m_curAdaptionsPath);
	}
	nCount = pList->GetCount(); // the count of doc files (could be zero if all docs are in
								// Bible book folders only)
	nDocCount += nCount;
	wxASSERT(nCount >= 0);
	if (bOK)
	{
		// if there are no documents yet, a restore or other operation requiring one of more
		// document files is impossible, so then return to caller with a FALSE value
		if (m_acceptedFilesList.GetCount() == 0 && !gbHasBookFolders)
		{
			wxMessageBox(_(
"Sorry, there are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."),
			_T("Restore Knowledge Base..."), wxICON_EXCLAMATION);

			// let the view respond again to updates
			bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
			if (::wxFileExists(tempKBfilePath))
			{
				bOK = ::wxRemoveFile(tempKBfilePath);
				tempKBfilePath.Empty();
			}
			LogUserAction(_T("...no saved document files yet for this project..."));
			if (bDocForcedToClose)
			{
				bOK = pDoc->ReOpenDocument(	this, strSaveCurrentDirectoryFullPath,
					savedCurOutputPath, savedCurOutputFilename, savedCurSequNum, savedBookmodeFlag,
					savedDisableBookmodeFlag, pSavedCurBookNamePair, savedBookIndex, FALSE); // bMarkAsDirty = FALSE
			}
			pView->canvas->Thaw();
			pProgDlg->Destroy();
			return;
		}

		// Update for step 4 DoKBRestore()
		msgDisplayed = progMsg.Format(progMsg,4,nTotal);
		pProgDlg->Update(4,msgDisplayed);
		//::wxSafeYield();

		// there is at least one document, so do the restore
		pKB->DoKBRestore(nCount, nCumulativeTotal);
	}
	else
	{
		// probably the user cancelled from the CWhichFilesDlg dialog, in which case we
		// want to set up the old KB, as it might still be good; assume the restore will
		// not have any errors
		if (gbIsGlossing)
		{
			bOK = ::wxCopyFile(tempKBfilePath, m_curGlossingKBPath);
			bOK = LoadGlossingKB(FALSE); // user cancelled OnFileRestore() - do the restoration of the old KB quietly
			if (bOK)
			{
				m_bGlossingKBReady = TRUE;
				LoadGuesser(m_pGlossingKB); // whm added 29Oct10
			}
		}
		else
		{
			bOK = ::wxCopyFile(tempKBfilePath, m_curKBPath);
			bOK = LoadKB(FALSE); // user cancelled OnFileRestore() - do the restoration of the old KB quietly
			if (bOK)
			{
				m_bKBReady = TRUE;
				LoadGuesser(m_pKB); // whm added 29Oct10
			}
		}
		// remove the temporary copy of the KB file or Glossing KB file
		bOK = ::wxRemoveFile(tempKBfilePath);
		tempKBfilePath.Empty();

		// clean up the list
		m_acceptedFilesList.Clear();

		// restore the former book mode parameters (even if book mode was not on on entry)
		m_pCurrBookNamePair = pSave_BookNamePair;
		m_nBookIndex = nSave_BookIndex;
		m_bibleBooksFolderPath = save_bibleBooksFolderPath;

		// restore the former current working directory to what it was on entry
		bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
		LogUserAction(_T("Cancelled from CWhichFilesDlg()"));
		if (bDocForcedToClose)
		{
			bOK = pDoc->ReOpenDocument(	this, strSaveCurrentDirectoryFullPath,
				savedCurOutputPath, savedCurOutputFilename, savedCurSequNum, savedBookmodeFlag,
				savedDisableBookmodeFlag, pSavedCurBookNamePair, savedBookIndex, FALSE); // bMarkAsDirty = FALSE
		}
		// let the view respond again to updates
		pView->canvas->Thaw();
		pProgDlg->Destroy();
		return;
	}

	if (gbHasBookFolders)
	{
        // process this block only if the project's Adaptations folder contains the set of
        // Bible book folders - these could contain documents, and some or all could be
        // empty;
        // NOTE: the code below is smart enough to ignore any user-created folders which
        // are sisters of the Bible book folders for which the Adaptations folder is the
        // common parent folder
		wxDir finder; //CFileFind finder;
		bool bOK = (::wxSetWorkingDirectory(m_curAdaptionsPath) && finder.Open(m_curAdaptionsPath)); // wxDir
											// must call .Open() before enumerating files!
		if (!bOK)
		{
			wxString s1, s2, s3;
			s1 = _T(
"Failed to set the current directory to the Adaptations folder in OnFileRestoreKb function, ");
			s2 = _T(
"processing book folders, so the book folder document files do not contribute to the rebuild.");
			s3 = s3.Format(_T("%s%s"),s1.c_str(),s2.c_str());
			wxMessageBox(s3,_T(""), wxICON_EXCLAMATION);
			bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
			m_acceptedFilesList.Clear();
			if (::wxFileExists(tempKBfilePath))
			{
				bOK = ::wxRemoveFile(tempKBfilePath);
				tempKBfilePath.Empty();
			}
			LogUserAction(s3);
			if (bDocForcedToClose)
			{
				bOK = pDoc->ReOpenDocument(	this, strSaveCurrentDirectoryFullPath,
					savedCurOutputPath, savedCurOutputFilename, savedCurSequNum, savedBookmodeFlag,
					savedDisableBookmodeFlag, pSavedCurBookNamePair, savedBookIndex, FALSE); // bMarkAsDirty = FALSE
			}
			// let the view respond again to updates
			pView->canvas->Thaw();
			pProgDlg->Destroy();
			return;
		}
		else
		{
			// Update for step 5 EnumerateDocFiles() for each book folder
			msgDisplayed = progMsg.Format(progMsg,5,nTotal);
			pProgDlg->Update(5,msgDisplayed);
			//::wxSafeYield();

			wxString str;
			bool bWorking = finder.GetFirst(&str,_T("*.*"),wxDIR_FILES | wxDIR_DIRS);
			while (bWorking)
			{
				// BEW 19Mar10, added a call of finder.GetNext() so that iterating continues
				if (str.IsEmpty())
				{
					bWorking = finder.GetNext(&str);
					continue;
				}

                // whm note: in the MFC version's "if (finder.IsDirectory())" test below,
                // the finder continues to use the directory path that was current when the
                // inital finder.FindFile call was made above, even though the
                // EnumerateDocFiles() call below changes the current working dir for each
                // of the book folder directories it processes. In the wx version the
                // finder.Exists(str) call uses whatever the current working directory is
                // and checks for a sub-directory "str" below that - a difference we must
                // account for here in the wx version.
				if (finder.Exists(m_curAdaptionsPath + PathSeparator + str))
				{
                    // User-defined folders can be in the Adaptations folder without making
                    // the app confused as to whether or not Bible Book folders are present
                    // or not

					// we have found a folder, check if it matches one of those in
					// the array of BookNamePair structs (using the seeName member)
					if (IsDirectoryWithin(str,m_pBibleBooks))
					{
						// we have found a folder name which belongs to the set of
						// Bible book folders, so construct the required path to the
						// folder and enumerate is documents then call
						// DoTransformationsToGlosses() to process any documents within
						wxString folderPath = m_curAdaptionsPath;
						folderPath += PathSeparator + str;

                        // clear the string list of directory names & then enumerate the
                        // directory's file contents; the EnumerateDocFiles() call sets the
                        // current directory to the one given by folderPath (ie. to a book
                        // folder) so after the DoKBRestore() call, which relies on that
                        // directory being current, we must call
                        // ::SetCurrentDirectory(m_curAdaptionsPath) again so that this
                        // outer look which iterates over directories continues correctly
						pList->Clear();
                        // whm note: EnumerateDocFiles() has the side effect of changing
                        // the current work directory to the passed in folderPath.
						bOK = EnumerateDocFiles(pDoc, folderPath, TRUE); // TRUE == suppress dialog
						if (!bOK)
						{
                            // don't process any directory which gives an error, but
                            // continue looping -- this is a highly unlikely error, so an
                            // English message will do
							wxString errStr;
							errStr = errStr.Format(_T(
			"Error returned by EnumerateDocFiles in Book Folder loop, directory %s skipped."),
							folderPath.c_str());
							wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
							LogUserAction(errStr);

							// BEW added 19Mar10, a call of wxSetWorkingDirectory() is
							// needed here because EnumerateDocFiles() has been called
							// and it has clobbered the setting of the working directory
							// to the Adaptations folder & call finder.GetNext()
							bOK = ::wxSetWorkingDirectory(m_curAdaptionsPath);
									// restore parent folder as current
							wxASSERT(bOK);
							bWorking = finder.GetNext(&str); // needed for the iteration
							continue;
						}
						nCount = pList->GetCount();
						nDocCount += nCount;
						if (pList->GetCount() == 0)
						{
							// no documents to work on in this folder, so iterate...

							// BEW added 19Mar10, a call of wxSetWorkingDirectory() is
							// needed here because EnumerateDocFiles() has been called
							// and it has clobbered the setting of the working directory
							// to the Adaptations folder; and call finder.GetNext()
							bOK = ::wxSetWorkingDirectory(m_curAdaptionsPath);
									// restore parent folder as current
							wxASSERT(bOK);
							bWorking = finder.GetNext(&str); // needed for the iteration
							continue;
						}

						// There are files to be processed. TRUE parameter suppresses the statistics
						// dialog
						pKB->DoKBRestore(nCount, nCumulativeTotal);

						//bOK = (::wxSetWorkingDirectory(m_curAdaptionsPath) && finder.Open(m_curAdaptionsPath));
						// BEW altered 19Mar2010, because the reopening of finder by the
						// above line of code destroyed the iterator, contributing to infinite
						// looping
						bOK = ::wxSetWorkingDirectory(m_curAdaptionsPath);
								// restore parent folder as current
						wxASSERT(bOK);
					} // end of TRUE block for test IsDirectoryWithin(str,m_pBibleBooks)
					else
					{
						// it's not a known directory for bible book folders, nor the
						// "Other Texts" folder either, so ignore it
						//continue; // BEW removed 19Mar10 - continue causes the finder.GetNext()
						// call to be missed
						; // working directory is unchanged, so don't reset it here
					}
				} // end of TRUE block for test: if (finder.Exists(m_curAdaptionsPath + PathSeparator + str))
				  // which, if str is a child directory's name (rather than a filename),
				  // then the contructed parameter will be the absolute path to that folder
				else
				{
					// its a file, so ignore it
					//continue; // BEW removed 19Mar10 - continue causes the finder.GetNext()
					// call to be missed
					; // working directory is unchanged, so don't reset it here
				}

                // BEW changed 19Mar10: moved the finder.GetNext() call from the top of the
                // loop to here, because having it at the top of the loop meant that the
                // directory contents already in str from the call finder.Open() preceding
                // the loop is never processed; and on return to top of the loop, the
                // GetNext() call then fails but str stays unchanged, contributing to
                // infinite looping
				bWorking = finder.GetNext(&str);
			} // end loop for FindFile() scanning all possible files in folder
		}  // end block for bOK == TRUE
	} // end block for test for gbHasBookFolders yielding TRUE

	if (bRescueFlags)
	{
		// do the rescue, for either glossing KB or the adaptation KB
		pKB->RestoreForceAskSettings(&keys); // also cleans up after itself,
											  // deleting the list contents
	}

	// Update for step 6 DoGlossingKBBackup() or DoKBBackup() depending on gbIsGlossing
	msgDisplayed = progMsg.Format(progMsg,6,nTotal);
	pProgDlg->Update(6,msgDisplayed);
	//::wxSafeYield();

	// do the KB backup, if the relevant flag is set
	if(m_bAutoBackupKB)
	{
		if (gbIsGlossing)
			DoGlossingKBBackup();
		else
			DoKBBackup();
	}
	if (::wxFileExists(tempKBfilePath))
	{
		bOK = ::wxRemoveFile(tempKBfilePath);
		tempKBfilePath.Empty();
	}

	// Update for step 7 End of processes
	msgDisplayed = progMsg.Format(progMsg,7,nTotal);
	pProgDlg->Update(7,msgDisplayed);
	//::wxSafeYield();

	// inform user of success and some statistics
	wxString stats;
	// IDS_RESTORE_KB_STATS
	stats = stats.Format(_(
"Your rebuilt knowledge base is now in operation. It was built from %d source words and phrases taken from %d documents."),
	nCumulativeTotal,nDocCount);
	wxMessageBox(stats,_T("Restore Knowledge Base..."),wxICON_INFORMATION);
	LogUserAction(stats);

	// clean up the list
	m_acceptedFilesList.Clear();

	// restore the former book mode parameters (even if book mode was not on on entry)
	m_pCurrBookNamePair = pSave_BookNamePair;
	m_nBookIndex = nSave_BookIndex;
	m_bibleBooksFolderPath = save_bibleBooksFolderPath;
	// now, if the user opens the Document tab of the Start Working wizard, and book
	// mode is on, then at least the path and index and book name are all consistent

	// make sure that book mode is off if there is no valid folder path
	if (m_bBookMode)
	{
		if (m_bibleBooksFolderPath.IsEmpty())
		{
			// no path defined, so having the mode on would lead to a crash,
			// so turn it off (a manual turn on subsequently will get all
			// set up correctly)
			m_bBookMode = FALSE;
			m_nBookIndex = -1;
			m_nDefaultBookIndex = 39;
			m_nLastBookIndex = 39;
		}
	}

	// BEW added 05Jan07 to restore the former current working directory
	// to what it was on entry
	bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);

	if (bDocForcedToClose)
	{
		bOK = pDoc->ReOpenDocument(	this,
			    strSaveCurrentDirectoryFullPath,   // for setting current working directory
				savedCurOutputPath,				   // includes filename
				savedCurOutputFilename,			   // to help get window Title remade
				savedCurSequNum,			       // for resetting the box location
				savedBookmodeFlag,				   // for ensuring correct mode
				savedDisableBookmodeFlag,		   // ditto
				pSavedCurBookNamePair,             // for restoring the pointed at struct
				savedBookIndex,				       // for restoring the book folder's index in array
				FALSE); // bMarkAsDirty = FALSE
	}
	// let the view respond again to updates
	pView->canvas->Thaw();

	// remove the progress dialog
	pProgDlg->Destroy();

}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if all was okay, FALSE if the path to the folder could not be
///             made the current directory, or if the user cancelled the Which Files dialog
/// \param      pDoc        ->  pointer to the document class (unused)
/// \param      folderPath  ->  a wxString representing the full path to the folder which
///                             is to have its document files enumerated
/// \param      bSuppressDialog -> default is FALSE (ie. the IDD_WHICH_FILES dialog is
///                             visible), but if set TRUE then the dialog is suppressed
///                             (and all document files in the passed in folderPath are
///                             left in m_acceptedFilesList for the caller to use)
/// \remarks
/// Called from: the App's OnFileRestoreKb(), AccessOtherAdaptionProject(), the View's
/// OnEditConsistencyCheck(), OnRetransReport(), and SyncScrollReceive() in MainFrm.cpp. We
/// only want to suppress the IDD_WHICH_FILES dialog when iterating through the 67 folders
/// of the Bible books - when these are present in the Adaptations folder, since having to
/// manually interact with the dialog 67 times would be grossly tedious for the user, and
/// the need to exclude a document in one of the folders would be pretty well zero.
/// However, we will also suppress showing the dialog if there are no files in the string
/// list, because this could well be the situation when there are book folders in the
/// Adaptations folder and all the documents are in them and none are in Adaptations
/// itself.
/// Another context for suppressing the dialog is when showing lists of files in the split
/// or join or move dialog; also when scanning xml documents after having received a
/// scripture reference message.
/// Note: EnumerateDocFiles() has the side effect of changing the current work directory to
/// the passed in folderPath.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::EnumerateDocFiles(CAdapt_ItDoc* WXUNUSED(pDoc), wxString folderPath,
									 bool bSuppressDialog)
{
	// set a local var for the Adaptations folder's path, or book folder path - whichever
	// was passed in
	wxASSERT(!folderPath.IsEmpty());
	bool bOK = ::wxSetWorkingDirectory(folderPath);
	if (!bOK)
	{
		// something's real wrong!
		wxMessageBox(_T(
		"Failed to set the current directory to the passed in folder. Command aborted."),
		_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

    // enumerate the document files in the Adaptations folder or the current book folder;
    // and note that internally GetPossibleAdaptionDocuments excludes any files with names
    // of the form *.BAK (these are backup XML document files, and for each there will
    // be present an *.xml file which has identical content -- it is the latter we
    // enumerate) and also note the result could be an empty m_acceptedFilesList, but have
    // the caller of EnumerateDocFiles check it for no entries in the list
	GetPossibleAdaptionDocuments(&m_acceptedFilesList, folderPath);

	if (m_acceptedFilesList.GetCount() > 0)
	{
		if (!bSuppressDialog)
		{
			CWhichFilesDlg dlg(GetMainFrame());
			dlg.Centre();
			if (dlg.ShowModal() == wxID_OK)
			{
				return TRUE;
			}
			else
			{
				return FALSE; // user cancelled the dialog, typically this
                //constitutes a wish to abort the operation - so return FALSE so that the
                //caller can use the FALSE value if it wants to effect the operation abort
			}
		}
	}
	return TRUE; // return TRUE even if the list is empty, because the caller may wish
            // not to abort the operation, but instead attempt it on another folder of
            // files, so we need to allow different functionalities to interpret an empty
            // list in different ways
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if all was okay, FALSE if the path to the folder could not be
///             made the current directory
/// \param      docNamesList -> a wxArrayString to store the documents' filenames
/// \param      folderPath   -> a wxString representing the full path to the folder which
///                             is to have its document files enumerated
/// \remarks
/// Called from: the App's AccessOtherAdaptionProjects().
/// This is a similar function to EnumerateDocFiles, but with a few differences as follows:
/// 1.  EnumerateDocFiles() stores in CAdapt_ItApp::m_acceptedFilesList, and so is not a
///     useful function if we wish to enumerate the documents in more than one folder (which
///     is the case when transforming adaptations to glosses); so we pass in the storage
///     array as the first parameter
/// 2.  EnumerateDocFiles_ParametizedStore() enumerates all doc files in the folder, there
///     is no provision for a dialog for the user to select which ones are to be kept for use
/// 3.  EnumerateDocFiles_ParametizedStore((), on exit, restores the caller's work directory
///     to what it was prior to being called
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::EnumerateDocFiles_ParametizedStore(wxArrayString& docNamesList,
													  wxString folderPath)
{
	// first, save the caller's current working directory
	wxString saveWorkDir = ::wxGetCwd();

	// reset the current working directory to the path passed in
	wxASSERT(!folderPath.IsEmpty());
	bool bOK = ::wxSetWorkingDirectory(folderPath);
	if (!bOK)
	{
		// something's real wrong!
		wxMessageBox(_T(
		"Failed to set the current directory to the passed in folder, in EnumerateDocFiles_ParametizedStore(). Command aborted."),
		_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

    // enumerate the document files in the folder ( excludes any files with names
    // of the form *.BAK )
	GetPossibleAdaptionDocuments(&docNamesList, folderPath);

	// restore the working directory
	bOK = ::wxSetWorkingDirectory(saveWorkDir);
	if (!bOK)
	{
		// something's real wrong!
		wxMessageBox(_T(
		"Failed to re-set the work directory in EnumerateDocFiles_ParametizedStore(). Command aborted."),
		_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	return TRUE; // return TRUE even if the list is empty
}

//////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if one or more loadable files was added to the passed in array, FALSE
///             if there was an error or if there were no loadable files in the folder
/// \param      array         ->    ref to a sorted string array to store the names of the files
///                                 judged to be loadable for creating valid adaptation docs
/// \param      folderPath    ->    the absolute path to the folder whose files are to be
///                                 enumerated and tested for loadability
/// \remarks
/// Uses the function, bool IsLoadableFile() (see helpers.cpp), to test each file for
/// loadability. Those that are are added to the array (it's a sorted array) - and only
/// these should be shown to the user for document creation purposes. We have to do this
/// enumeration immediately prior to creation of a new document, because it may happen
/// that someone (e.g. an administrator) might have changed the contents of the __SOURCE_INPUTS
/// folder's monocline list of loadable files since the last call of this function -
/// either to add more loadable files, or even some not loadable.
/// BEW 15Aug10, removed call of EnumerateDocFiles_ParametizedStore() because the latter
/// internally calls EnumerateDocFiles() and that only enumerates *.xml files which are not
/// *.BAK files, which is of no help when we want to enumerate what typically are plain
/// text files. The enumeration is unsorted in the returned array; we do any required
/// sorting at the point in the application where we call a different function,
/// RemoveNameDuplicatesFromArray(), defined in helpers.cpp, which has a bool bSorted
/// parameter for which we can supply a TRUE value to get the final array of strings
/// sorted (and currently the latter function is called only in OnNewDocument()).
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::EnumerateLoadableSourceTextFiles(wxArrayString& array, wxString& folderPath,
													enum LoadabilityFilter filtered)
{
	wxArrayString arrFilenames; // the unfiltered enumeration stores filenames here,
								// but the passed in array parameter will only store those
								// that get through the filter (i.e. IsLoadableFile())
	array.Clear();

	// first, save the caller's current working directory
	wxString saveWorkDir = ::wxGetCwd();

	// reset the current working directory to the path passed in
	wxASSERT(!folderPath.IsEmpty());
	bool bOK = ::wxSetWorkingDirectory(folderPath);
	if (!bOK)
	{
		// something's real wrong!
		wxMessageBox(_T(
"Failed to set the current directory to the passed in folder, in EnumerateLoadableSourceTextFiles().\nThe user is not protected from folder navigation."),
		_T(""), wxICON_WARNING);
		return FALSE;
	}

	// get them all, then loop to exclude the non-loadable ones
	wxString filename = _T("");
	wxDir finder;
	// wxDirmust call .Open() before enumerating files!
	bool bItsOK = (finder.Open(folderPath));
	if (!bItsOK)
	{
		// a significant error, so we'll make the icon be the error one, but let the app
		// continue - but with no user protection from folder navigation
		wxMessageBox(_T(
			"Error: The wxDir::Open() call failed in EnumerateLoadableSourceTextFiles().\nThe user is not protected from folder navigation."),
		_T(""), wxICON_ERROR);
		return FALSE;
	}
	else
	{
		// Must call wxDir::Open() before calling GetFirst() - see above
		wxString str = _T("");
		bool bWorking = finder.GetFirst(&str,wxEmptyString,wxDIR_FILES);
		// whm note: wxDIR_FILES finds only files; it ignores directories, and . and ..
		while (bWorking)
		{
			if (str.IsEmpty())
				continue;
			wxFileName fn(str);
			wxString aFilename = fn.GetFullName();
			arrFilenames.Add(str); // add filename to the list
			bWorking = finder.GetNext(&str);
		}
	}
	size_t index;
	size_t limit = arrFilenames.GetCount();
	if (limit == 0)
	{
		// restore the working directory (we don't expect failure, so a
		// non-localizable message will do)
		bOK = ::wxSetWorkingDirectory(saveWorkDir);
		if (!bOK)
		{
			// something's real wrong!
			wxMessageBox(_T(
			"Failed to re-set the work directory in EnumerateLoadableSourceTextFiles().\nThe user is not protected from folder navigation."),
			_T(""), wxICON_WARNING);
			return FALSE;
		}
        // we can't enumerate files that don't exist, so just return TRUE for an empty
        // folder situation and let the caller test and tell the user about the problem if
        // the telling is warranted;
		return TRUE;
	}

	// now apply the IsLoadableFile() filter to the set of filenames we've collected, and
	// accept only those that pass the test
	filename = _T("");
	if (filtered == filterOutUnloadableFiles)
	{
		for (index = 0; index < limit; index++)
		{
			filename = arrFilenames.Item(index);
			wxString aPath = folderPath + PathSeparator + filename;
			wxASSERT(::wxFileExists(aPath));
			if (IsLoadableFile(aPath))
			{
				// store this loadable file's name in the passed in array, in its proper
				// sorted location (ignore returned index as it's irrelevant since insertion
				// is done, not appending)
				array.Add(filename);
			}
		}
	}
	else
	{
		// filtering is not wanted, so just copy the lot across to the array list
		for (index = 0; index < limit; index++)
		{
			filename = arrFilenames.Item(index);
			array.Add(filename); // adding preserves their sorted order too
		}
	}

	// restore the working directory (we don't expect failure, so a non-localizable
	// message will do)
	bOK = ::wxSetWorkingDirectory(saveWorkDir);
	if (!bOK)
	{
		// something's real wrong! This is too big an error for the app to continue
		wxMessageBox(_T(
		"Failed to re-set the work directory in EnumerateLoadableSourceTextFiles().\nThe user is not protected from folder navigation."),
		_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

    // there may be no loadable files (i.e. not no files, but rather, no 'loadable' files
    // -- meaning that IsLoadableFile() has excluded all contenders if filtering was
    // wanted) but we'll not test here because the caller can do any such test if it is
    // required, we just return TRUE
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the "__SOURCE_INPUTS" folder exists and it has at least one loadable
///             source text file within it; FALSE if there are no loadable files in it, or
///             no files at all, or if one of several possible error conditions happens
/// \remarks
/// Called from OnNewDocument().
/// This function tests for existence of a folder named "__SOURCE_INPUTS" as a child folder of
/// the current project folder, and if it exists, and provided it also has at least one
/// file within it which is loadable for adaptation document creation purposes, the
/// function will return TRUE; if the __SOURCE_INPUTS folder does not exist, it returns FALSE,
/// it also returns FALSE if it has no files in that folder, or if all the files in that
/// folder, when tested with the IsLoadableFile() function, return FALSE. The function can
/// rely on the fact that a valid path to a __SOURCE_INPUTS folder will have been set up when
/// the project was entered, the path will be in the app member string,
/// m_sourceInputsFolderPath. Error conditions do not halt the app, but instead allow
/// processing to continue in the legacy way, with no user navigation protection (that is,
/// the wxFileDialog is used in the OPEN state, rather than the SAVE state).
///
/// The UseSourceDataFolderOnlyForInputFiles() function is used at any point in the
/// application where the user has the possibility of creating a new adaptation document.
/// (Currently, there is only one such place - the OnNewDocument() call, and the latter
/// function is called in either or the two following cases: (1) a File / New... choice, or
/// (2) in the DocPage pane of the wizard, for a user choice of <New Document>.) If the
/// return value is TRUE, the standard folder and file navigation dialog is suppressed, and
/// instead only a monocline list of loadable files is shown to the user in a dialog with a
/// ListBox -- only a selected file from that list can be used to create a document - but
/// not all files in that folder might be listed because any with a file title the same as
/// an existing document's filename title will not be shown to the user (since presumably
/// the source text file of the same name was used to create that document).
/// BEW created 22July10
//////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::UseSourceDataFolderOnlyForInputFiles()
{
	wxASSERT(!m_sourceInputsFolderPath.IsEmpty());
	bool bDirExists = ::wxDirExists(m_sourceInputsFolderPath);
	if (!bDirExists)
	{
		return FALSE;
	}
	else
	{
		// whm added 13Jun11. With version 6.0.0, AI will always create a __SOURCE_INPUTS
		// folder in a new project. The crucial test for switching ON nav protection now
		// is not whether the __SOURCE_INPUTS folder exists, nor whether it has at least
		// one loadable file, but whether the "Protect from Navigation" checkbox has been
		// selected by the administrator (or has been unilaterally checked because Paratext
		// or Bibledit collaboration is ON). The flag for this test now resides in
		// the the App's m_bProtectSourceInputsFolder variable which is controlled by the
		// CAssignLocationsForInputsAndOutputs class. If this flag is TRUE at this point
		// we need to return TRUE from this function.
		if (m_bProtectSourceInputsFolder)
			return TRUE;

        // enumerate the files in the __SOURCE_INPUTS directory, don't do any filtering there,
        // as we want to do it further below since we've special messages below for the
		// user if we find unloadable files in the __SOURCE_INPUTS folder; for the current
		// function it is not necessary to have the enumeration sorted
		wxArrayString arrFilenames;
		bool bOkay = EnumerateLoadableSourceTextFiles(arrFilenames,m_sourceInputsFolderPath,
														doNotFilterOutUnloadableFiles);
		if (!bOkay)
		{
			// a warning will already have been given about the specific error, so pass
			// the FALSE value back to the caller; an empty folder is not regarded as an
			// error and so we check for that below
			return FALSE;
		}
		else
		{
			// if there are no files in the folder, return FALSE
			if (arrFilenames.IsEmpty())
			{
				wxMessageBox(_(
"There are no files in the '__SOURCE_INPUTS' folder.\nTherefore the user is not protected from folder navigation."),
				_("No source text files for document creation"),
				wxICON_WARNING);
				return FALSE;
			}

			// check that at least one of the enumerated files is loadable; if some are
			// not loadable, warn the user which ones -- here's where we do the filtering
			wxString unloadables; unloadables.Empty();
			bool bSomeAreBad = FALSE;
			wxString filename;
			wxString aPath;
			bool  bOneIsGood = FALSE;
			size_t index;
			size_t count = arrFilenames.GetCount();
			for (index = 0; index < count; index++)
			{
				filename = arrFilenames.Item(index);
				aPath = m_sourceInputsFolderPath + PathSeparator + filename;
				wxASSERT(::FileExists(aPath));
				bool bIsGood = IsLoadableFile(aPath);
				if (!bIsGood)
				{
					bSomeAreBad = TRUE;
					if (unloadables.IsEmpty())
						unloadables = filename;
					else
						// make it a comma-delimited list, because some filenames contain
						// spaces and won't necessarily have an extension to indicate
						// where one filename ends and the next begins
						unloadables += _T(",  ") + filename;
				}
				else
				{
					bOneIsGood = TRUE;
				}
			} // end for loop, testing all files in the folder
			if (bSomeAreBad && bOneIsGood)
			{
				// warn the user which ones are not loadable for doc creation purposes
				wxString msg;
				msg = msg.Format(_("Some of the '__SOURCE_INPUTS' folder's files are not suitable for creating an adaptation document.\nThey are: %s"),
				unloadables.c_str());
				wxMessageBox(msg,_("Warning: do not input these files"),wxICON_WARNING);
			}
			else if (bSomeAreBad && !bOneIsGood)
			{
				// warn the user that none are loadable for doc creation purposes,
				// and that navigation protect therefore can't be turned on
				wxString msg;
				msg = msg.Format(_("Folder navigation protection is not turned on, because none of the '__SOURCE_INPUTS' folder's files are suitable for creating an adaptation document.\nThe unsuitable ones are: %s"),
				unloadables.c_str());
				wxMessageBox(msg,_("Warning: do not input these files"),wxICON_WARNING);
				return FALSE;
			}
		}
	}
	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pKB    -> pointer to the CKB instance being cleared from memory
/// \param      pDoc    -> pointer to the document
/// \remarks
/// Called from: the App's OnFileRestoreKb().
/// Calls the Doc's EraseKB() on the appropriate KB -- deleting from memory the CKB
/// instance and clearing its pointer to NULL, then creates a new, empty KB in its place.
/// It also stores, for the adapting KB only though, the language names in the memory
/// instance of the knowledge base. Finally it checks the Glossing KB or the adapting KB is
/// ready for use, as the case may be.
/// Note: This function is not moved to the CKB class, because it deletes from memory the
/// instance it would be called from, prior to returning.
/// BEW 13May10, added pKB parameter in order to remove internal use of gbIsGlossing
///////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ClearKB(CKB* pKB, CAdapt_ItDoc *pDoc)
{
	wxASSERT(pDoc != NULL);

	// by adding new first param, pKB, we get access to the m_bGlossingKB flag on the
	// instance being deleted, which removes one more reference of the global bool gbIsGlossing
	if (pKB->IsThisAGlossingKB()) // doing glossing
	{
		// erase the current GlossingKB in memory & delete the memory if occupies
		pDoc->EraseKB(m_pGlossingKB); // leaves m_bGlossingKBReady unchanged

		//create a new KB
		m_pGlossingKB = new CKB(TRUE); // create a new GlossingKB
		wxASSERT(m_pGlossingKB != NULL);

		// check it is ready for use
		wxASSERT(m_bGlossingKBReady);
	}
	else // doing adaptation
	{
		// erase the current KB in memory & delete the memory if occupies
		pDoc->EraseKB(m_pKB); // leaves m_bKBReady unchanged

		//create a new KB
		m_pKB = new CKB(FALSE); // create a new (adapting) KB
		wxASSERT(m_pKB != NULL);

		// store the language names in the memory instance of the knowledge base
		wxASSERT(!m_sourceName.IsEmpty());
		wxASSERT(!m_targetName.IsEmpty());
		m_pKB->m_sourceLanguageName = m_sourceName;
		m_pKB->m_targetLanguageName = m_targetName;

		// check it is ready for use
		wxASSERT(m_bKBReady);
	}
}

///////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      fi   ->     the fontInfo struct containing the font information for
///                         writing in the configuration files
/// \param      pf   <-     pointer to the wxTextFile that is being written as the
///                         config file
/// \remarks
/// Called from: the App's WriteConfigurationFile().
/// Writes the font configuration part of a configuration file. WriteFontConfiguration()
/// gets called once for each of the three main fonts used: source language, target
/// language, and navigation text language. The text file is opened by the caller and
/// remains open after each call to WriteFontConfiguration(). Note: wxTextFile is processed
/// entirely in memory, so it is up to the caller to actually write the information to the
/// file by calling pf->Write() once the in-memory file has been fully composed/processed.
///////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::WriteFontConfiguration(const fontInfo fi, wxTextFile* pf)
{
	// Note: wxTextFile is Unicode enabled when _UNICODE is defined
	wxString data = _T("");
	wxString tab = _T("\t");
	wxString number;

#ifndef _UNICODE // ANSI or _MBCS version

	data.Empty();
	data << szHeight << tab << fi.fHeight; //data = szHeight + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szWidth << tab << fi.fWidth; //data = szWidth + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szEscapement << tab << fi.fEscapement;//data = szEscapement + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szOrientation << tab << fi.fOrientation; //data = szOrientation + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szWeight << tab << fi.fWeightConfSave; //data = szWeight + tab + number + end;
	pf->AddLine(data);

	if (fi.fItalic)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szItalic << tab << number; //data = szItalic + tab + number + end;
	pf->AddLine(data);

	if (fi.fUnderline)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szUnderline << tab << number; //data = szUnderline + tab + number + end;
	pf->AddLine(data);

	if (fi.fStrikeOut)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szStrikeOut << tab << number; //data = szStrikeOut + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szFontEncoding << tab << fi.fEncoding; //data = szCharSet + tab + number + end;
	pf->AddLine(data); // whm added 14Feb07

	data.Empty();
	data << szCharSet << tab << fi.fCharset; //data = szCharSet + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szOutPrecision << tab << fi.fOutPrecision; //data = szOutPrecision + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szClipPrecision << tab << fi.fClipPrecision; //data = szClipPrecision + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szQuality << tab << fi.fQuality; //data = szQuality + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szPitchAndFamily << tab << fi.fPitchAndFamily; //data = szPitchAndFamily + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szFaceName << tab << fi.fFaceName; //data = szFaceName + tab + number + end;
	pf->AddLine(data);

	int fntColor = 0; // default black until changed below
	if (fi.fLangType.GetChar(0) == _T('S'))
		fntColor = WxColour2Int(m_sourceColor); // WxColour2Int() in helpers.h
	else if (fi.fLangType.GetChar(0) == _T('T'))
		fntColor = WxColour2Int(m_targetColor); // WxColour2Int() in helpers.h
	else if (fi.fLangType.GetChar(0) == _T('N'))
		fntColor = WxColour2Int(m_navTextColor); // WxColour2Int() in helpers.h
	data.Empty();
	data << szColor << tab << fntColor; //data = szColor + tab + number + end;
	pf->AddLine(data);

#else // _UNICODE version (ie. _UNICODE defined)

    // MFC: for the unicode version, from version 2.0.4 and onwards we may as well force
    // output of the configuration files to be in UTF-8, nothing is lost and the potential
    // for spurious conversions to a legacy encoding is avoided; hence the next six lines,
    // and 3 lines at end of the function to restore the old system encoding value
	data.Empty();
	data << szHeight << tab << fi.fHeight; //data = szHeight + tab + number + end;
    // Note: On 15Mar04 Bruce changed all of the m_systemEncoding params in ConvertAndWrite
    // to eUTF8 but I don't expect I'll need to use ConvertAndWrite, so I'll keep his
    // changes as commented out lines below the earlier commented out lines.
	pf->AddLine(data);

	data.Empty();
	data << szWidth << tab << fi.fWidth; //data = szWidth + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szEscapement << tab << fi.fEscapement; //data = szEscapement + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szOrientation << tab << fi.fOrientation; //data = szOrientation + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szWeight << tab << fi.fWeightConfSave; //data = szWeight + tab + number + end;
	pf->AddLine(data);

	if (fi.fItalic)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szItalic << tab << number; //data = szItalic + tab + number + end;
	pf->AddLine(data);

	if (fi.fUnderline)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szUnderline << tab << number; //data = szUnderline + tab + number + end;
	pf->AddLine(data);

	if (fi.fStrikeOut)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szStrikeOut << tab << number; //data = szStrikeOut + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szFontEncoding << tab << fi.fEncoding; //data = szCharSet + tab + number + end;
	pf->AddLine(data); // whm added 14Feb07

	data.Empty();
	data << szCharSet << tab << fi.fCharset; //data = szCharSet + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szOutPrecision << tab << fi.fOutPrecision; //data = szOutPrecision + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szClipPrecision << tab << fi.fClipPrecision; //data = szClipPrecision + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szQuality << tab << fi.fQuality; //data = szQuality + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szPitchAndFamily << tab << fi.fPitchAndFamily; //data = szPitchAndFamily + tab + number + end;
	pf->AddLine(data);

	data.Empty();
	data << szFaceName << tab << fi.fFaceName; //data = szFaceName + tab + number + end;
	pf->AddLine(data);

	int fntColor = 0; // default black until changed below
	if (fi.fLangType.GetChar(0) == _T('S'))
		fntColor = WxColour2Int(m_sourceColor); // WxColour2Int() in helpers.h
	else if (fi.fLangType.GetChar(0) == _T('T'))
		fntColor = WxColour2Int(m_targetColor); // WxColour2Int() in helpers.h
	else if (fi.fLangType.GetChar(0) == _T('N'))
		fntColor = WxColour2Int(m_navTextColor); // WxColour2Int() in helpers.h
	data.Empty();
	data << szColor << tab << fntColor; //data = szColor + tab + number + end;
	pf->AddLine(data);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pf   <-     pointer to the wxTextFile that is being written as the
///                         config file
/// \remarks
/// Called from: the App's WriteConfigurationFile().
/// Writes the basic settings part of a configuration file. The text file is opened by the
/// caller and remains open after the call to WriteFontConfiguration().
/// Note: wxTextFile is processed entirely in memory, so it is up to the caller to actually
/// write the information to the file by calling pf->Write() once the in-memory file has
/// been fully composed/processed.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::WriteBasicSettingsConfiguration(wxTextFile* pf)
{
    // BEW refactored 22Mar09, for compatibility with earlier settings file - write this
    // out for the m_nMaxToDisplay value, which is not needed any more
	m_nMaxToDisplay = GetMaxIndex() + 1;
	int dummyValue1 = 10; // for removed m_nPrecedingContext;
	int dummyValue2 = 10; // for removed m_nFollowingContext;

	// wx version combines ANSI and UNICODE parts in common to simplify this function
	wxString data = _T("");
	wxString tab = _T("\t");
	wxString number;

	data.Empty();
	data << szSourceLanguageName << tab << m_sourceName;
	pf->AddLine(data);

	data.Empty();
	data << szTargetLanguageName << tab << m_targetName;
	pf->AddLine(data);

	data.Empty();
	data << szGlossesLanguageName << tab << m_glossesName;
	pf->AddLine(data);

	data.Empty();
	data << szSourceLanguageCode << tab << m_sourceLanguageCode;
	pf->AddLine(data);

	data.Empty();
	data << szTargetLanguageCode << tab << m_targetLanguageCode;
	pf->AddLine(data);

	data.Empty();
	data << szGlossesLanguageCode << tab << m_glossesLanguageCode;
	pf->AddLine(data);

	data.Empty();
	data << szAdaptitPath << tab << m_workFolderPath;
	pf->AddLine(data);

    // next two added by BEW 9Oct09, for support of persistent custom work folder locations
    // Note: if the flag is true, the path was locked in and therefore persistent and only
    // then do we want to record (ie. write) the custom work folder path; because if the
    // flag is false, the custom path was a temporary one used by the administrator and we
    // don't want to keep track of what he does - in that case, we set the path string to
    // an empty string. Note, the GetBasicConfiguration() function does NOT try, ever,
    // to read the flag value nor the custom work folder path from the basic configuration
    // file, because there is no way to determine where that folder is from configuration
	// files alone - at least as long as we retain the model in which the basic config
	// file is stored in the work folder itself.
    // Therefore, the location of the persisent custom folder is found by looking at the
    // default work folder to see if a file CustomWorkFolderLocation is present - if it is,
    // that fact sets the m_bLockedCustomWorkFolderPath boolean, and the contents of the
    // file (we look only at the first line - so the user is free to add personal comments
    // to non-first lines in a text editor) is the custom work folder path and it is
    // assigned to m_customWorkFolderPath in the app's OnInit() function before the basic
    // config file is read in.
	if (m_bLockedCustomWorkFolderPath)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szLockedCustomWorkFolderPath << tab << number;
	pf->AddLine(data);

	data.Empty();
	if (m_bLockedCustomWorkFolderPath)
	{
		// write out a path only if the flag is set
		data << szCustomWorkFolderPath << tab << m_customWorkFolderPath;
	}
	else
		data << szCustomWorkFolderPath << tab << _T(""); // no path written out
	pf->AddLine(data);

	/*
	// whm 19Feb12 removed
	wxString strCollabValueToUse; // this is reused below for each of the wxString value settings
	// whm 26Jan12 added
	if (!m_SavedCurProjectName.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_curProjectName that was forced by the -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCurProjectName will be a string value that was actually read
		// from the basic config file.
		strCollabValueToUse = m_SavedCurProjectName;
	}
	else
	{
		// The value of m_SavedCollabProjectForSourceInputs is empty meaning that it was not
		// overridden by a -ai_proj command-line switch. In this case
		// save the current session value of the App's m_curProjectName.
		strCollabValueToUse = m_curProjectName;
	}
	*/
	data.Empty();
	data << szCurProjectName << tab << m_curProjectName; //strCollabValueToUse;
	pf->AddLine(data);

	/*
	// whm 19Feb12 removed
	// whm 26Jan12 added
	if (!m_SavedCurProjectPath.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_curProjectPath that was forced by the -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCurProjectPath will be a string value that was actually read
		// from the basic config file.
		strCollabValueToUse = m_SavedCurProjectPath;
	}
	else
	{
		// The value of m_SavedCurProjectPath is empty meaning that it was not
		// overridden by a -ai_proj command-line switch. In this case
		// save the current session value of the App's m_curProjectPath.
		strCollabValueToUse = m_curProjectPath;
	}
	*/
	data.Empty();
	data << szCurLanguagesPath << tab << m_curProjectPath; //strCollabValueToUse;
	pf->AddLine(data);

	data.Empty();
	data << szCurAdaptionsPath << tab << m_curAdaptionsPath;
	pf->AddLine(data);

	data.Empty();
	data << szCurKBName << tab << m_curKBName;
	pf->AddLine(data);

	data.Empty();
	data << szCurKBPath << tab << m_curKBPath;
	pf->AddLine(data);

	data.Empty();
	data << szCurKBBackupPath << tab << m_curKBBackupPath;
	pf->AddLine(data);

	// whm 6Aug11: From version 6.x.x on store the m_lastDocPath
	// only in the appropriate project config file under szLastDocPath
	//data.Empty();
	//data << szLastDocPath << tab << m_lastDocPath;
	//pf->AddLine(data);

	// whm 6Aug11: From version 6.x.x on store the m_lastSourceInputPath
	// only in the appropriate project config file under szLastSourceInputPath
	//data.Empty();
	//data << szLastSourceInputPath << tab << m_lastSourceInputPath;
	//pf->AddLine(data);


	// whm 6Aug11: From version 6.x.x on store the m_lastTargetOutputPath
	// only in the appropriate project config file under szLastTargetOutputPath
	//data.Empty();
	//data << szLastExportPath << tab << m_lastTargetOutputPath;
	//pf->AddLine(data);

	// m_last...Path values below
	data.Empty();
	data << szLastCCTablePath << tab << m_lastCcTablePath; // old pre-6.x.x label was szDefaultTablePath
	pf->AddLine(data);

	data.Empty();
	data << szLastRetranslationReportPath << tab << m_lastRetransReportPath; // prior to 6.x.x used szRetranslationReportPath
	pf->AddLine(data);

	data.Empty();
	data << szLastPackedDocumentPath << tab << m_lastPackedOutputPath;
	pf->AddLine(data);

	data.Empty();
	data << szLastKBExportPath << tab << m_lastKbOutputPath; // prior to 6.x.x used szKBExportPath "KB_ExportPath"
	pf->AddLine(data);

	data.Empty();
	data << szLastKBLIFTExportPath << tab << m_lastKbLiftOutputPath;
	pf->AddLine(data);
	// end of m_last...Path values

	data.Empty();
	data << szFoldersProtectedFromNavigation << tab << m_foldersProtectedFromNavigation;
	pf->AddLine(data);

	data.Empty();
	data << szAdministratorPassword << tab << m_adminPassword;
	pf->AddLine(data);

	data.Empty();
	data << szLastActiveSequNum << tab << nLastActiveSequNum;
	pf->AddLine(data);

#ifndef _UNICODE
	// ANSI
	wxString s;
	PunctPairsToString(m_punctPairs,s);
	data.Empty();
	data << szPunctPairs << tab << s; //data = szPunctPairs + tab + s + end;
	pf->AddLine(data);

	TwoPunctPairsToString(m_twopunctPairs,s);
	data.Empty();
	data << szTwoPunctPairs << tab << s; //data = szTwoPunctPairs + tab + s + end;
	pf->AddLine(data);

#else
	// UNICODE
	// From version 2.3.0 the hard-coding of the encoding ID in punctuation fields
	// has been removed, we use UTF-8 for them all now
	wxString src;
	wxString tgt;
	PunctPairsToTwoStrings(m_punctPairs,src,tgt);

	data.Empty();
	data << szPunctPairsSrc << tab << src;
	pf->AddLine(data);

	data.Empty();
	data << szPunctPairsTgt << tab << tgt;
	pf->AddLine(data);

	TwoPunctPairsToTwoStrings(m_twopunctPairs,src,tgt);

	data.Empty();
	data << szTwoPunctPairsSrc << tab << src;
	pf->AddLine(data);

	data.Empty();
	data << szTwoPunctPairsTgt << tab << tgt;
	pf->AddLine(data);

#endif // _UNICODE

	if (m_bZoomed)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szZoomed << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szMaxToDisplay << tab << m_nMaxToDisplay;
	pf->AddLine(data);

	data.Empty();
	//data << szMinPrecContext << tab << m_nPrecedingContext;
	data << szMinPrecContext << tab << dummyValue1;
	pf->AddLine(data);

	data.Empty();
	//data << szMinFollContext << tab << m_nFollowingContext;
	data << szMinFollContext << tab << dummyValue2;
	pf->AddLine(data);

	data.Empty();
	data << szLeading << tab << m_curLeading;
	pf->AddLine(data);

	data.Empty();
	data << szLeftMargin << tab << m_curLMargin;
	pf->AddLine(data);

	data.Empty();
	data << szGapWidth << tab << m_curGapWidth;
	pf->AddLine(data);

	if (m_bSuppressFirst)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szSuppressFirst << tab << number;
	pf->AddLine(data);

	if (m_bSuppressLast)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szSuppressLast << tab << number;
	pf->AddLine(data);

	if (m_bBackupDocument)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szBackupDocument << tab << number;
	pf->AddLine(data);

	// whm added 3Sep10 for user workflow profile support
	// whm modified 15Feb12 to restore the value of m_nWorkflowProfile
	// to its value that it was before any temporary state was set
	// according to the m_bAiSessionExpectsUserDefinedProfile flag and
	// the value stored in m_nTempWorkflowProfile as long as m_nTempWorkflowProfile
	// isn't undefined (-1).
	if (m_nTempWorkflowProfile != -1 && m_bAiSessionExpectsUserDefinedProfile)
	{
		m_nWorkflowProfile = m_nTempWorkflowProfile;
	}
	data.Empty();
	data << szWorkflowProfile << tab << m_nWorkflowProfile;
	pf->AddLine(data);

/*
	// whm added 15Apr11 for Paratext/Bibledit collaboration
	//
	// whm Note 8Sep11. ALL of the collaboration-related settings need to be in
	// the basic configuration file because the GetSourceTextFromEditor dialog
	// needs them at the time that only the basic config file has been read in.
	//
	// whm modified 17Jan12 most of the collaboration-related values below to restore
	// the App's collaboration settings to their previous settings as were contained
	// in the basic config file when session started. This restores the App for the next
	// run to what it was before the command-line switches were used, and hence the use
	// of the command-line switches for some launcher icons won't disturb any sessions
	// that are run on the same computer without employing any command-line switches.
	int nCollabValueToUse; // this is reused below for each of the int value settings
	if (m_nSavedCollabPTSetting != -1)
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_bCollaboratingWithParatext that was forced by the -collab_on or -collab_off switch at
		// the command-line. In the forced collab mode situation the value of
		// m_nSavedCollabPTSetting will be 0 or 1 reflecting what was
		// actually read from the basic config file.
		nCollabValueToUse = m_nSavedCollabPTSetting;
	}
	else
	{
		// The value of m_nSavedCollabPTSetting is -1 meaning that it was not
		// overridden by a -collab_on or -collab_off command-line switch. In this case save the current
		// session value of the App's m_bCollaboratingWithParatext (cast to an int of
		// 1 or 0).
		nCollabValueToUse = (int)m_bCollaboratingWithParatext;
	}

	if (nCollabValueToUse == 1) //if (m_bCollaboratingWithParatext)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollaboratingWithParatext << tab << number;
	pf->AddLine(data);

	// whm added 15Apr11 for Bibledit collaboration
	if (m_nSavedCollabBESetting != -1)
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_bCollaboratingWithBibledit that was forced by the -collab_on or -collab_off switch at
		// the command-line. In the forced collab mode situation the value of
		// m_nSavedCollabBESetting will be 0 or 1 reflecting what was
		// actually read from the basic config file.
		nCollabValueToUse = m_nSavedCollabBESetting;
	}
	else
	{
		// The value of m_nSavedCollabBESetting is -1 meaning that it was not
		// overridden by a -collab_on or -collab_off command-line switch. In this case save the current
		// session value of the App's m_bCollaboratingWithBibledit (cast to an int of
		// 1 or 0).
		nCollabValueToUse = (int)m_bCollaboratingWithBibledit;
	}
	// whm added 15Apr11 for Bibledit collaboration
	if (nCollabValueToUse == 1)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollaboratingWithBibledit << tab << number;
	pf->AddLine(data);

	// whm 23Jan11 added
	if (!m_SavedCollabProjectForSourceInputs.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabProjectForSourceInputs that was forced by the -collab_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabProjectForSourceInputs will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabProjectForSourceInputs;
	}
	else
	{
		// The value of m_SavedCollabProjectForSourceInputs is empty meaning that it was not
		// overridden by a -collab_proj command-line switch. In this case
		// save the current session value of the App's m_CollabProjectForSourceInputs.
		strCollabValueToUse = m_CollabProjectForSourceInputs;
	}
	data.Empty();
	data << szCollabProjectForSourceInputs << tab << strCollabValueToUse;
	pf->AddLine(data);

	// whm 23Jan11 added
	if (!m_SavedCollabProjectForTargetExports.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabProjectForTargetExports that was forced by the -collab_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabProjectForTargetExports will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabProjectForTargetExports;
	}
	else
	{
		// The value of m_SavedCollabProjectForTargetExports is empty meaning that it was not
		// overridden by a -collab_proj command-line switch. In this case
		// save the current session value of the App's m_CollabProjectForTargetExports.
		strCollabValueToUse = m_CollabProjectForTargetExports;
	}
	data.Empty();
	data << szCollabProjectForTargetExports << tab << strCollabValueToUse;
	pf->AddLine(data);

	// whm 23Jan11 added
	if (!m_SavedCollabProjectForFreeTransExports.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabProjectForFreeTransExports that was forced by the -collab_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabProjectForFreeTransExports will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabProjectForFreeTransExports;
	}
	else
	{
		// The value of m_SavedCollabProjectForFreeTransExports is empty meaning that it was not
		// overridden by a -collab_proj command-line switch. In this case
		// save the current session value of the App's m_CollabProjectForFreeTransExports.
		strCollabValueToUse = m_CollabProjectForFreeTransExports;
	}
	data.Empty();
	data << szCollabProjectForFreeTransExports << tab << strCollabValueToUse;
	pf->AddLine(data);

	if (!m_SavedCollabAIProjName.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabAIProjectName that was forced by the -collab_proj and/or -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabAIProjName will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabAIProjName;
	}
	else
	{
		// The value of m_SavedCollabAIProjName is empty meaning that it was not
		// overridden by a -collab_proj and/or -ai_proj command-line switch. In this case
		// save the current session value of the App's m_CollabAIProjectName.
		strCollabValueToUse = m_CollabAIProjectName;
	}
	data.Empty();
	data << szCollabAIProjectName << tab << strCollabValueToUse; //m_CollabAIProjectName;
	pf->AddLine(data);

	// whm 23Jan11 added
	if (!m_SavedCollabSourceLangName.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabSourceLangName that was forced by the -collab_proj and/or -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabSourceLangName will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabSourceLangName;
	}
	else
	{
		// The value of m_SavedCollabSourceLangName is empty meaning that it was not
		// overridden by a -collab_proj and/or -ai_proj command-line switch. In this case
		// save the current session value of the App's m_CollabSourceLangName.
		strCollabValueToUse = m_CollabSourceLangName;
	}
	data.Empty();
	data << szCollabSourceLangName << tab << strCollabValueToUse;
	pf->AddLine(data);

	// whm 23Jan11 added
	if (!m_SavedCollabTargetLangName.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabTargetLangName that was forced by the -collab_proj and/or -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabTargetLangName will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabTargetLangName;
	}
	else
	{
		// The value of m_SavedCollabTargetLangName is empty meaning that it was not
		// overridden by a -collab_proj and/or -ai_proj command-line switch. In this case
		// save the current session value of the App's m_CollabTargetLangName.
		strCollabValueToUse = m_CollabTargetLangName;
	}
	data.Empty();
	data << szCollabTargetLangName << tab << strCollabValueToUse;
	pf->AddLine(data);

	if (m_nSavedCollabExpectsFreeTrans != -1)
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_bCollaborationExpectsFreeTrans that was forced by the -collab_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_nSavedCollabExpectsFreeTrans will be 0 or 1 reflecting what was
		// actually read from the basic config file.
		nCollabValueToUse = m_nSavedCollabExpectsFreeTrans;
	}
	else
	{
		// The value of m_nSavedCollabExpectsFreeTrans is -1 meaning that it was not
		// overridden by a -collab_proj command-line switch. In this case save the current
		// session value of the App's m_bCollaborationExpectsFreeTrans (cast to an int of
		// 1 or 0).
		nCollabValueToUse = (int)m_bCollaborationExpectsFreeTrans;
	}
	if (nCollabValueToUse) // whm added 9Aug11
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollabExpectsFreeTrans << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szCollabBookSelected << tab << m_CollabBookSelected;
	pf->AddLine(data);

	if (m_bCollabByChapterOnly)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollabByChapterOnly << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szCollabChapterSelected << tab << m_CollabChapterSelected;
	pf->AddLine(data);

	if (m_bPwdProtectCollabSwitching)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollabSwitchingPasswordProtected << tab << number; // whm added 2Feb12
	pf->AddLine(data);

	data.Empty();
	data << szCollabSwitchingPassword << tab << m_collabSwitchingPassword; // whm added 2Feb12
	pf->AddLine(data);
*/
	// BEW removed 8Aug09, there is no good reason to store a "punctuation hidden" value
	// because it we do that, the user could get confused if next time his document
	// doesn't show and punctuation and he didn't realize he shut down with this setting
	// toggled from the default, so now we'll ignore the config file value, and always
	// launch the app with this m_bHidePunctuation flag set FALSE
	//if (m_bHidePunctuation)
	//	number = _T("1");
	//else
	//	number = _T("0");
	//data.Empty();
	//data << szHidePunctuation << tab << number;
	//pf->AddLine(data);

	if (m_bStatusBarVisible)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szStatusBarIsVisible << tab << number;
	pf->AddLine(data);

	if (m_bToolBarVisible)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szToolBarIsVisible << tab << number;
	pf->AddLine(data);

	if (m_bModeBarVisible)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szModeBarIsVisible << tab << number;
	pf->AddLine(data);

	if (m_bSuppressWelcome)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szSuppressWelcome << tab << number;
	pf->AddLine(data);

	// Version 3 always uses startup wizard
	number = _T("1");
	data.Empty();
	data << szUseStartupWizardOnLaunch << tab << number;
	pf->AddLine(data);

	if (m_bAutoBackupKB)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szBackupKBFlag << tab << number;
	pf->AddLine(data);

	if (m_bNoAutoSave)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szNoAutoSaveFlag << tab << number;
	pf->AddLine(data);
#ifdef Test_m_bNoAutoSave
	// Test_m_bNoAutoSave symbol #defined at start of Adapt_It.h
	#ifdef __WXDEBUG__
	if (m_bNoAutoSave)
		wxLogDebug(_T("m_bNoAutoSave  in WriteBasicSettingsConfiguration()  was just set to TRUE"));
	else
		wxLogDebug(_T("m_bNoAutoSave  in WriteBasicSettingsConfiguration()  was just set to FALSE"));
	#endif
#endif

	data.Empty();
	data << szTS_DOC_MINS << tab << m_timeSettings.m_tsDoc.GetMinutes();
	pf->AddLine(data);

    // The wxTimeSpan::GetSeconds() works differently than CTimeSpan's method of the same
    // name. The wxWidgets GetSeconds() gets the total time span difference in seconds,
    // whereas the MFC method only returns the number of seconds in the current minute (-59
    // through 59). Because of these differences and since Bruce decided to ignore seconds
    // any way, we will just set the string value to zero _T("0");
	data.Empty();
	data << szTS_DOC_SECS << tab << _T("0");
	pf->AddLine(data);

	data.Empty();
	data << szTS_KB_MINS << tab << m_timeSettings.m_tsKB.GetMinutes();
	pf->AddLine(data);

	// force the seconds value to be string zero _T("0")
	data.Empty();
	data << szTS_KB_SECS << tab << _T("0");
	pf->AddLine(data);

	data.Empty();
	data << szPhraseBoxMoves << tab << m_nMoves;
	pf->AddLine(data);

	if (m_bIsDocTimeButton)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szIsDocTimeButtonFlag << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szTopLeftX << tab << m_ptViewTopLeft.x;
	pf->AddLine(data);

	data.Empty();
	data << szTopLeftY << tab << m_ptViewTopLeft.y;
	pf->AddLine(data);

	data.Empty();
	data << szWSizeCX << tab << m_szView.x;
	pf->AddLine(data);

	data.Empty();
	data << szWSizeCY << tab << m_szView.y;
	pf->AddLine(data);

	if (m_bMarkerWrapsStrip)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szMarkerWrapsFlag << tab << number;
	pf->AddLine(data);

	if (m_bIsInches)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szLoEnglishFlag << tab << number;
	pf->AddLine(data);

	if (m_bIsPortraitOrientation)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szUsePortraitOrientation << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szLastPageWidth << tab << m_pageWidth;
	pf->AddLine(data);

	data.Empty();
	data << szLastPageLength << tab << m_pageLength;
	pf->AddLine(data);

	data.Empty();
	data << szPaperSizeCode << tab << m_paperSizeCode;
	pf->AddLine(data);

	data.Empty();
	data << szMarginTop << tab << m_marginTop;
	pf->AddLine(data);

	data.Empty();
	data << szMarginBottom << tab << m_marginBottom;
	pf->AddLine(data);

	data.Empty();
	data << szMarginLeft << tab << m_marginLeft;
	pf->AddLine(data);

	data.Empty();
	data << szMarginRight << tab << m_marginRight;
	pf->AddLine(data);

	data.Empty();
	data << szPhraseBoxExpansionMultiplier << tab << gnExpandBox;
	pf->AddLine(data);

	data.Empty();
	data << szTooNearEndMultiplier << tab << gnNearEndFactor;
	pf->AddLine(data);

	if (m_bRTL_Layout)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szRTL_Layout << tab << number;
	pf->AddLine(data);

// the following is only in the _UNICODE version
#ifdef _RTL_FLAGS

	if (m_bSrcRTL)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szRTLSource << tab << number;
	pf->AddLine(data);

	if (m_bTgtRTL)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szRTLTarget << tab << number;
	pf->AddLine(data);

	if (m_bNavTextRTL)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szRTLNavText << tab << number;
	pf->AddLine(data);
#endif // _RTL_FLAGS

	// whm 6Aug11 Note: the m_lastRtfOutputPath is no longer used because it is
	// replaced by other specific m_last...RTFOutputPath variables (in project
	// config files). See GetBasicSettingsConfiguration() where we read the value
	// from old basic config files (pre-version 6), but ignore them.
	//data.Empty();
	//data << szRTFExportPath << tab << m_lastRtfOutputPath;
	//pf->AddLine(data);

	if (m_bSuppressTargetHighlighting)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szSuppressTargetHighlighting << tab << number;
	pf->AddLine(data);

	if (m_bUsePrefixExportTypeOnFilename)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szUsePrefixExportTypeOnFilename << tab << number;
	pf->AddLine(data);

	if (m_bUseSuffixExportDateTimeOnFilename)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szUseSuffixExportDateTimeOnFilename << tab << number;
	pf->AddLine(data);

	if (m_bUsePrefixExportProjectNameOnFilename)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szUsePrefixExportProjectNameOnFilename << tab << number;
	pf->AddLine(data);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      strReadIn   ->  a text line read from the config file
/// \param      strValue    <-  the "value" of the setting as a string
/// \param      name        <-  the "label" or setting being defined on the left part of
///                             the config file line
/// \remarks
/// Called from: the App's GetFontConfiguration(), GetBasicSettingsConfiguration(),
/// GetProjectSettingsConfiguration(), and GetConfigurationFile().
/// Parses the text line from the config file into a string label and a string value
/// associated with that label (the value can be an empty string). Assumes that the label
/// and its associated value are separated by a tab ('\t') on the same text line (or two
/// tabs for version 2.3.0 and earlier).
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetValue(const wxString strReadIn, wxString& strValue, wxString& name)
{
	wxChar delimiter = _T('\t');
	name.Empty();
	strValue.Empty();
	if (strReadIn.IsEmpty())
		return;
	name = strReadIn.BeforeFirst(delimiter);
	int offset = strReadIn.Find(delimiter);
	if (offset == -1)
	{
		// its a section heading only
		return;
	}
    // determine how many tabs. If there are two, we have an old config file with the
    // encoding (UTF-8) value stored between the two tabs, and we want to just jump it and
    // extract the data which follows the second tab; but if there is only one tab, then
    // the data we want follows immediately after it. Version 2.3.0 will no longer write
    // out the encoding value.
	offset++; // offset now references the start of
			  // either the data or the encoding subfield
	int freq = strReadIn.Freq(delimiter); // returns the number of
										  // occurrences of delimiter
	int nFound;
	if (freq >= 2)
		nFound = strReadIn.Find(delimiter,TRUE); // TRUE search from end forward
	else
		nFound = strReadIn.Find(delimiter,FALSE); // search from front of strReadIn
	wxString strExtract;
	if (freq == 1)
	{
		// the line has only a singe tab, so offset references the data we want to extract
		strExtract = strReadIn.Mid(offset);
	}
	else
	{
		// the line has two tabs, so it is an older config file, and ++nFound will be
		// the reference to the data we want
		strExtract = strReadIn.Mid(++nFound);
	}
	// note: strValue can be empty (eg. the default path to the cc tables)
	strValue = strExtract;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxSize representing the extent of the longest sfm string in the
///             styles map
/// \param      pDC   -> pointer to the display context
/// \remarks
/// Called from: the App's OnInit().
/// Scans through all entries in the m_pUsfmAndPngStylesMap styles map and determines the
/// maximum (horizontal) text extent of the longest sfm read from the AI_USFM.xml file.
////////////////////////////////////////////////////////////////////////////////////////
wxSize CAdapt_ItApp::GetExtentOfLongestSfm(wxDC* pDC)
{
	wxSize tempSize;
	wxSize maxSize(0,0);
	USFMAnalysis* pSfm;
	wxString key;
	MapSfmToUSFMAnalysisStruct::iterator iter;
	for( iter = m_pUsfmAndPngStylesMap->begin();
		iter != m_pUsfmAndPngStylesMap->end(); ++iter )
	{
		pSfm = iter->second;
		pDC->GetTextExtent(pSfm->marker, &tempSize.x,&tempSize.y);
		if (tempSize.x > maxSize.x)
		{
			maxSize.x = tempSize.x;
			maxSize.y = tempSize.y;
		}
	}
	return maxSize;
}


#ifdef _UNICODE

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      s   <-  a wxString on which any "NR Work" substring exists is converted
///                     to "Unicode Work"
/// \remarks
/// Called from: the App's GetBasicSettingsConfiguration(),
/// GetProjectSettingsConfiguration().
/// Changes an instance of "NR Work" found within a config file (path) string s to "Unicode
/// Work". This is done to automatically update any path names that were created with very
/// old versions of Adapt It to agree with the current work folder name scheme for the
/// Unicode application.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ChangeNRtoUnicode(wxString& s)
{
	int nFound = s.Find(_T("NR Work")); // only will occur once per string
	if (nFound < 0)
		return;
	s.Remove(nFound,7);
	s = InsertInString(s,nFound,_T("Unicode Work"));
}
#endif

/////////////////////////////////////////////////////////////////////////////////***********
// !!! possible useful functions below !!!
// whm added 29Dec06 (modified from functions in catalog.cpp of PoEdit sources by Vaclav Slavik)

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the input string converted to the local charset/encoding
/// \param      str   -> the string to be converted to the local charset/encoding
/// \remarks
/// Called from: (currently unused)
/// An inline function that onverts an input string to the local charset or encoding using the
/// wxConvUTF8 and wxConvLocal predefined converters. Attempts conversion only in ANSI builds.
/// In Unicode builds it simply returns the (Unicode) str unchanged.
////////////////////////////////////////////////////////////////////////////////////////
inline wxString convertToLocalCharset(const wxString& str)
{
#if !wxUSE_UNICODE
	wxString s2(str.wc_str(wxConvUTF8), wxConvLocal);
	if (s2.empty() /*conversion failed*/)
		return str;
	else
		return s2;
#else
	return str;
#endif
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the input string converted from the local
///             charset/encoding to UTF-8 encoding
/// \param      str   ->    the string to be converted from the local charset/encoding
///                         to UTF-8
/// \remarks
/// Called from: (currently unused)
/// An inline function that onverts an input string from the local charset or encoding to
/// UTF-8 using the wxConvLocal wxConvUTF8 predefined converters. Attempts conversion only
/// in ANSI builds. In Unicode builds it simply returns the (Unicode) str unchanged.
////////////////////////////////////////////////////////////////////////////////////////
inline wxString convertFromLocalCharset(const wxString& str)
{
#if !wxUSE_UNICODE
	return wxString(str.wc_str(wxConvLocal), wxConvUTF8);
#else
	return str;
#endif
}

// ReadTextLine is not used in the wx version which uses the wxTextFile class.

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE when font info section of config file was read up to a blank
///             line. If there was a problem reading a font setting it returns FALSE to
///             tell the caller to issue a warning message (but config file reading
///             continues)
/// \param      fi   <-     the fontInfo struct containing the font information as read
///                         in from the configuration files
/// \param      pf   ->     pointer to the wxTextFile that is being read as the
///                         config file
/// \param      bFaceNameFound   ->     TRUE if the font's face name was found on the
///                                     local machine, otherwise FALSE if the face name
///                                     was not found
/// \remarks
/// Called from: the App's GetConfigurationFile().
/// Reads the font configuration part of a configuration file. GetFontConfiguration() gets
/// called once for each of the three main fonts used: source language, target language,
/// and navigation text language. The text file is opened by the caller and remains open
/// after each call to GetFontConfiguration(). Note: wxTextFile is processed entirely in
/// memory.
/// whm 25Feb10 modified - moved font mismatch (facename not found) messages to another
/// function FixConfigFileFonts().
/////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::GetFontConfiguration(fontInfo& fi, wxTextFile* pf)
// Note: wxTextFile is Unicode enabled when _UNICODE is defined
// This function accepts the config file entries in any order, as long as the format of
// each line's entry is correct: that is, a name, tab, string value, and \n at the end. For
// the unicode compilation, the config files are saved as UTF-8 with no initial BOM; but if
// the user opens the config file in WORD (as an encoded file), edits something perhaps,
// and then resaves it - WORD will write a UFT-8 BOM at the start of the saved file. This
// will clobber the S, T, or N selector syntax, so we must check for a BOM and remove it if
// present.

// NOTE: This wxWidgets version uses wxTextFile and we can assume that the whole config
// file was successfully read into memory. So, we will be "reading" successive lines from
// memory rather than from disk which eliminates the need for some of MFC's disk-related
// error trapping.
{
	wxChar chSelector;
	wxString data;
	data.Empty();
	wxString name;
	bool	bIsOK = TRUE;
	wxString strValue;
	int		num; // for the string converted to a number

    // The first call of GetFontConfiguration reads the Source Font data, and exits at the
    // first blank line at end of Source Font data; then the second call of the routine
    // continues reading the Target Font data, exiting at the next blank line (at end of
    // Target Font data), and the third call of the routine continues reading the Nav Font
    // data, exiting at the blank line just before the "Settings" (or "ProjectSettings")
    // heading. Here we'll not use GetFirstLine() since this current function is designed
    // to be entered three times (once each for source, target and nav fonts) while the
    // config file is open with the pointer continuing through the file, rather than being
    // reset to the beginning like GetFirstLine would do. Hence, we'll check to see if we
    // are at line zero or not and only use GetNextLine when we're not at line zero.
	size_t curLine = pf->GetCurrentLine();
	data = pf->GetLine(curLine);
	// don't use GetNextLine if we've just opened the file, otherwise we would skip
	// the first line of the file before getting a chance to process it below
	if (curLine != 0)
	{
		data = pf->GetNextLine();
	}
	GetValue(data, strValue, name);

	// get rid of the BOM if present - we can assume it is there if the first character
	// of name is not S, T, or N
	chSelector = name.GetChar(0);
	if ((chSelector != _T('S')) && (chSelector != _T('T')) && (chSelector != _T('N')))
	{
        // BEW changed, 2July07, because the UTF8 name becomes UTF16, and is one UTF16 char
        // by the time the program counter gets here, so Mid(3) needs to become Mid(1)
        // (from Bob Eaton)
#ifdef _UNICODE
		name = name.Mid(1); // in the Unicode version, the UTF-8 BOM (which was 3 bytes
							// long) is turned into a single UTF16 character
#else
		name = name.Mid(3);	// in the ansi version, the UTF-8 BOM is 3 characters
#endif
		chSelector = name.GetChar(0); // S for source, T for target, N for navText;
									  // use for setting color
		if ((chSelector != _T('S')) && (chSelector != _T('T')) && (chSelector != _T('N')))
		{
			wxMessageBox(_T(
"Selector not set to one of S, T, or N, when getting the logfont info. Will try to continue."));
		}
	}

    // Because of a peculiarity of wxTextFile, its method Eof returns TRUE if the current
    // line is the last one, so we need to use a do...while loop here rather than a while
    // loop, otherwise we'll not process the last line. This behavior of wxTextFile may
    // have changed with wxWidgets library version 2.7.0 and later, but the method here
    // still works.
	do
	{
		data = pf->GetNextLine();
		GetValue(data, strValue, name);
		if ( name == szHeight)
		{
			num = wxAtoi(strValue); // MFC has _ttoi((LPCTSTR)strValue);
									// Note: both _ttoi and wxAtoi return 0 if strValue is
									// empty string ""
			if (num < -120 || num > 120)
				num = -16; // 12 point
			fi.fHeight = num; // this fi value is saved in config
			fi.fPointSize = NegHeightToPointSize(num);// this one for program use
			// set the fontsize for the actual font on the App
			if (fi.fLangType.GetChar(0)  == _T('S'))
				m_pSourceFont->SetPointSize(fi.fPointSize);
			else if (fi.fLangType.GetChar(0)  == _T('T'))
				m_pTargetFont->SetPointSize(fi.fPointSize);
			else if (fi.fLangType.GetChar(0)  == _T('N'))
				this->m_pNavTextFont->SetPointSize(fi.fPointSize);

			// testing of PointSize NegHeight conversion functions below !!!!
			//int lfh;
			//int ps;
			//lfh = PointSizeToNegHeight(9); // lfh = -12
			//ps = NegHeightToPointSize(lfh);// ps = 9
			//lfh = PointSizeToNegHeight(10);// lfh = -13
			//ps = NegHeightToPointSize(lfh);// ps = 10
			//lfh = PointSizeToNegHeight(11);// lfh = -14
			//ps = NegHeightToPointSize(lfh);// ps = 11
			//lfh = PointSizeToNegHeight(12);// lfh = -16
			//ps = NegHeightToPointSize(lfh);// ps = 12
			//lfh = PointSizeToNegHeight(13);// lfh = -17
			//ps = NegHeightToPointSize(lfh);// ps = 13
			//lfh = PointSizeToNegHeight(14);// lfh = -18
			//ps = NegHeightToPointSize(lfh);// ps = 14
			//lfh = PointSizeToNegHeight(15);// lfh = -20
			//ps = NegHeightToPointSize(lfh);// ps = 15
			//lfh = PointSizeToNegHeight(16);// lfh = -21
			//ps = NegHeightToPointSize(lfh);// ps = 16
			//lfh = PointSizeToNegHeight(17);// lfh = -22
			//ps = NegHeightToPointSize(lfh);// ps = 17
			//lfh = PointSizeToNegHeight(18);// lfh = -24
			//ps = NegHeightToPointSize(lfh);// ps = 18
			//lfh = PointSizeToNegHeight(19);// lfh = -25
			//ps = NegHeightToPointSize(lfh);// ps = 19
			//lfh = PointSizeToNegHeight(20);// lfh = -26
			//ps = NegHeightToPointSize(lfh);// ps = 20
			//int dummy = -1;
			// test results appear to be what they should be
			// end of testing!!!!
		}
		else if (name == szWeight)
		{
			num = wxAtoi(strValue);
			if (num < 400 || num > 1000) // just a guess for a valid range,
										 // its normally 400, or 700 for bold
				num = 700; // default bold

			// we'll retain the raw fWeight value read in, in order to be able to
			// save it out to config file again
			fi.fWeightConfSave = num;
			// wxWidgets needs the predefined const value for Weight
			if (num >= 400 && num < 500)
				fi.fWeight = wxLIGHT;
			else if (num >= 500 && num < 700)
				fi.fWeight = wxNORMAL;
			else if (num >= 700)
				fi.fWeight = wxBOLD;
			// set the weight of the actual font on the App
			if (fi.fLangType.GetChar(0)  == _T('S'))
				m_pSourceFont->SetWeight(fi.fWeight);
			else if (fi.fLangType.GetChar(0)  == _T('T'))
				m_pTargetFont->SetWeight(fi.fWeight);
			else if (fi.fLangType.GetChar(0)  == _T('N'))
				this->m_pNavTextFont->SetWeight(fi.fWeight);
		}
		else if (name == szWidth)
		{
			num = wxAtoi(strValue); // allow nearly anything positive,
									// but 0 for automatic calculation -
			if (num < 0 || num > 1000)
				num = 0;
			fi.fWidth = num; // font width is ignored in wxWidgets
		}
		else if (name == szEscapement)
		{
			num = wxAtoi(strValue);
			if (num < -10 || num > 10) // only allow one degree, its normally 0
				num = 0;
			fi.fEscapement = num; // font escapement is ignored in wxWidgets
		}
		else if (name == szOrientation)
		{
			num = wxAtoi(strValue);
			if (num < -10 || num > 10) // only allow one degree, its normally 0
				num = 0;
			fi.fOrientation = num; // font orientation is ignored in wxWidgets
		}
		else if (name == szItalic)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 255)) // TRUE if italic, regular is FALSE
				num = 0; // regular
			if (num == 0)
				fi.fStyle = wxNORMAL;
			else
				fi.fStyle = wxITALIC;
			// set the style (normal or italic) of the actual font on the App
			if (fi.fLangType.GetChar(0)  == _T('S'))
				m_pSourceFont->SetStyle(fi.fStyle);
			else if (fi.fLangType.GetChar(0)  == _T('T'))
				m_pTargetFont->SetStyle(fi.fStyle);
			else if (fi.fLangType.GetChar(0)  == _T('N'))
				this->m_pNavTextFont->SetStyle(fi.fStyle);
		}
		else if (name == szStrikeOut)
		{
			num = wxAtoi(strValue);
			if (num != 0)
				num = 0; // don't want strikeout
			if (num == 0)
				fi.fStrikeOut = FALSE; // font strikeout is ignored in wxWidgets
			else
				fi.fStrikeOut = TRUE;
		}
		else if (name == szUnderline)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1)) // TRUE if underline, regular is FALSE
				num = 0; // regular
			if (num == 0)
				fi.fUnderline = FALSE;
			else
				fi.fUnderline = TRUE;
			// set the underline of the actual font on the App
			if (fi.fLangType.GetChar(0)  == _T('S'))
				m_pSourceFont->SetUnderlined(fi.fUnderline);
			else if (fi.fLangType.GetChar(0)  == _T('T'))
				m_pTargetFont->SetUnderlined(fi.fUnderline);
			else if (fi.fLangType.GetChar(0)  == _T('N'))
				this->m_pNavTextFont->SetUnderlined(fi.fUnderline);
		}
		else if (name == szOutPrecision)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 9)
				num = 3; // OUT_DEFAULT_PRECIS is 0, others are +ve, 3 is usual one
			fi.fOutPrecision = num; // font outprecision is ignored in wxWidgets
		}
		else if (name == szQuality)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 2)
				num = 0;// DRAFT_QUALITY; // DRAFT_QUALITY is 1, default 0,
									 // proof is 2; 1 is usual one
			fi.fQuality = num; // font quality is ignored in wxWidgets
		}
		else if (name == szClipPrecision)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 7)
				num = 2; //CLIP_STROKE_PRECIS; // CLIP_STROKE_PRECIS is for TrueType fonts
			fi.fClipPrecision = num; // font clipprecision is ignored in wxWidgets
		}
		else if (name == szPitchAndFamily)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 255)
				num = 2; // all bytes can be used, usual value is 2
			fi.fPitchAndFamily = num; // this one saved in conf file; fFamily used within program
			// wxWidgets is only interested in the family which is encoded in bits 4-7
			wxUint32 FF;
			FF = num & 0xF0; // mask out the 4 low order bits
			switch (FF)
			{
			case 1: fi.fFamily = wxROMAN;break;			//1 = FF_ROMAN
			case 2: fi.fFamily = wxSWISS;break;			//2 = FF_SWISS
			case 3: fi.fFamily = wxMODERN;break;		//3 = FF_MODERN
			case 4: fi.fFamily = wxSCRIPT;break;		//4 = FF_SCRIPT
			case 5: fi.fFamily = wxDECORATIVE;break;	//5 = FF_DECORATIVE
			case 0: fi.fFamily = wxDEFAULT;break;		//0 = FF_DONTCARE
			default: fi.fFamily = wxDEFAULT;
			}
			// set the family of the actual font on the App
			if (fi.fLangType.GetChar(0)  == _T('S'))
				m_pSourceFont->SetFamily(fi.fFamily);
			else if (fi.fLangType.GetChar(0)  == _T('T'))
				m_pTargetFont->SetFamily(fi.fFamily);
			else if (fi.fLangType.GetChar(0)  == _T('N'))
				this->m_pNavTextFont->SetFamily(fi.fFamily);
		}
		else if (name == szFontEncoding) // if present in config file,
										 // this should preceed szCharset
		{
			m_bConfigFileHasFontEncodingInfo = TRUE;
			num = wxAtoi(strValue);
			if (num < -1 || num > 255)
				num = 0; // allow only possible values, default to 0
						 // (wxFONTENCODING_DEFAULT) if value corrupted out of range
			fi.fEncoding = (wxFontEncoding)num;
            // whm 25Feb10 Note: See FixConfigFileFonts() where font mismatches are dealt with.
		}
		else if (name == szCharSet)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 255)
				num = 0; // allow many values, usual value is 0
						 // (probably DEFAULT_CHARSET)
			fi.fCharset = num;
			if (!m_bConfigFileHasFontEncodingInfo)
			{
                // config file was produced by the MFC version, so we need to map the
                // fCharset value to fEncoding value which is used internally in the wx
                // version (see fontInfo struct). The fCharset value is maintained
                // primarily for backwards compatibility with the MFC version's LOGFONT
                // apparatus.
				fi.fEncoding = MapMFCCharsetToWXFontEncoding(fi.fCharset);
			}
            // If this config file was produced by the MFC app, the "if
            // (!m_bConfigFileHasFontEncodingInfo)" block above will have mapped the MFC
            // fi.fCharset to an equivalent wx font encoding (stored in fi.fEncoding).
            // whm 25Feb10 Note: See FixConfigFileFonts() where font mismatches are dealt with.
		}
		else if (name == szFaceName)
		{
			fi.fFaceName = strValue;
			// set the face name of the actual font on the App
            // wx version: We could use wxFontMapper to locate a font on the user's machine
            // corresponding to the font specified in the config file. If found we could
            // assign its face name to the appropriate font using SetFaceName(). If the
            // face name doesn't exist we won't try to set the face name, but allow the
            // font family setting to stand; and will notify the user that a substitute
            // font is being used. This method, however, is far too slow (see below).
			//wxFontEnumerator fe;
			//wxArrayString faceNames;
			//faceNames = fe.GetFacenames();
			//int ct,nFaceNames;
			//wxString fname;
			//bool bFoundFaceName = FALSE;
			//nFaceNames = fe.GetFacenames().GetCount();
            // the following for loop is way too time consuming, sometimes taking 5-10
            // seconds so we'll just try to assigne the facename. SetFaceName() returns a
            // bool that is TRUE if the face name exists; false otherwise. If it returns
            // false we'll just get a font from the general font family.
			//for (ct = 0; ct < nFaceNames; ct++)
			//{
			//	fname = fe.GetFacenames().Item(ct);
			//	if (fi.fFaceName == fname)
			//	{
			//		bFoundFaceName = TRUE;
			//		break;
			//	}
			//}
            // whm 25Feb10 Note: See FixConfigFileFonts() where font mismatches are dealt with.
		}
		else if (name == szColor)
		{
			num = wxAtoi(strValue); // allow anything
			if (fi.fLangType.GetChar(0)  == _T('S'))
			{
				m_sourceColor = Int2wxColour(num);
				// It is necessary to call the font data's SetColour() function to effect color
				// change
				m_pSrcFontData->SetColour(m_sourceColor);
			}
			else if (fi.fLangType.GetChar(0)  == _T('T'))
			{
				m_targetColor = Int2wxColour(num);
				// It is necessary to call the font data's SetColour() function to effect color
				// change
				m_pTgtFontData->SetColour(m_targetColor); //
			}
			else if (fi.fLangType.GetChar(0)  == _T('N'))
			{
				m_navTextColor = Int2wxColour(num);
				// In wx version text color is changed by modifying the font data object
				m_pNavFontData->SetColour(m_navTextColor);
			}
		}
		else if (name.IsEmpty()) // return when we come to the blank line
		{
			// The file pointer will be ready to read the next font's data
			return bIsOK;
		}
		else
		{
			bIsOK = FALSE;
			wxString error = _("Unrecognized font attribute field; unmatched name is: ") + name;
			wxMessageBox(error, _("Error parsing font information"), wxICON_ERROR);
		}
	} while(!pf->Eof());// should never get here just reading the font config data

	return bIsOK;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pf   -> pointer to the wxTextFile that is being read as the config file
/// \param      bBasicConfigHasCollabSettingsData <-> flag the returns to caller whether the
///                 basic config file has collaboration settings that have not been
///                 transitioned to the appropriate project config file
/// \param      collabProjectName <-> the path pointed to for any collab project
/// \remarks
/// Called from: the App's GetConfigurationFile().
/// Reads the basic settings part of a basic configuration file. The text file is opened by
/// the caller. Note: wxTextFile is processed entirely in memory. For most settings, this
/// function accepts the config file entries in any order as long as the format of each
/// line's entry is correct: that is, a name, tab, and string value. Order of entries is
/// important in the config file only for unicode punctuation support i.e., the order of
/// src & tgt punct lines.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetBasicSettingsConfiguration(wxTextFile* pf, bool& bBasicConfigHasCollabSettingsData,
					wxString& collabProjectName)
{
	//int nLineCount = 0;
	int		mins;
	int		secs;
	int		num; // for the string converted to a number
	//bool	bAdjusted = FALSE;

	wxString data = _T("");
	wxString name;
	wxString strValue;

#ifdef _UNICODE
	bool bAddedLeftDoubleQuote = FALSE;
	bool bAddedRightDoubleQuote = FALSE;
	bool bAddedLeftSingleQuote = FALSE;
	bool bAddedRightSingleQuote = FALSE;

	wxString strPunctPairsSrcSet;
	wxString strPunctPairsTgtSet;
	wxString strTwoPunctPairsSrcSet;
	wxString strTwoPunctPairsTgtSet;
#endif

	do
	{
		data = pf->GetNextLine();

#ifdef _UNICODE
		ChangeNRtoUnicode(data);
#endif
		GetValue(data, strValue, name);

		if (name == szSourceLanguageName)
		{
			m_sourceName = strValue;
		}
		else if (name == szTargetLanguageName)
		{
			m_targetName = strValue;
		}
		else if (name == szGlossesLanguageName)
		{
			m_glossesName = strValue;
		}
		else if (name == szSourceLanguageCode)
		{
			m_sourceLanguageCode = strValue;
		}
		else if (name == szTargetLanguageCode)
		{
			m_targetLanguageCode = strValue;
		}
		else if (name == szGlossesLanguageCode)
		{
			m_glossesLanguageCode = strValue;
		}
		else if (name == szAdaptitPath)
		{
            // BEW changed 12Oct09, we come here when reading either the
            // AI-BasicConfiguration.aic file or the AI-AdminBasicConfiguration.aic file.
            // Regardless of whichever is the case, the m_workFolderPath **ALWAYS** points
            // to the folder which is the default work folder location as defined for
            // legacy versions of Adapt It; that is, it will have the name "Adapt It
            // Unicode Work" or "Adapt It Work" (the latter for the ANSI version only), and
            // be located at the default data folder for the underlying OS -- eg. Documents
            // folder for Windows Vista, /username/home for Linux, etc. The basic config
            // file stores both the m_workFolderPath and m_customWorkFolderPath (the latter
            // will be empty string if a persistent custom folder was not earlier set up),
            // but when reading values from the basic config file, we **NEVER** read in and
            // use the stored line which stores the m_customWorkFolderPath value, because
            // at the time we need to do so, we can't be sure the location of the custom
            // work folder which stores the relevant path is known. Instead, we get that
            // path from the path stored within a file called CustomWorkFolderLocation
            // which is always stored in the legacy default work folder location (even
            // though typically when we do so, nothing else is stored in that default work
            // folder but that particular file containing the path to the custom work
            // folder)
			m_workFolderPath = strValue;
			if (m_workFolderPath.IsEmpty())
			{
				EnsureWorkFolderPresent(); // sets up a default work folder etc
			}
		}
		else if (name == szLockedCustomWorkFolderPath)
		{
			; // do nothing, we never read in this value -- see 12Oct09 above for explanation
		}
		else if (name == szCustomWorkFolderPath)
		{
			; // do nothing, we never read in this value -- see 12Oct09 above for explanation
		}
		else if (name == szCurProjectName)
		{
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_curProjectName
			// can be overridden by the use of command-line switches.
			m_curProjectName = strValue;
			// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
			//if (!m_ForceCollabAIProjectName.IsEmpty())
			//	m_SavedCurProjectName = strValue;
		}
		else if (name == szCurLanguagesPath)
		{
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_curProjectPath
			// can be overridden by the use of command-line switches.
			m_curProjectPath = strValue;
			// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
			//if (!m_ForceCollabAIProjectName.IsEmpty())
			//	m_SavedCurProjectPath = strValue;
		}
		else if (name == szCurAdaptionsPath)
		{
			m_curAdaptionsPath = strValue;
		}
		else if (name == szCurKBName)
		{
			m_curKBName = strValue;
		}
		else if (name == szCurKBPath)
		{
			m_curKBPath = strValue;
		}
		else if (name == szCurKBBackupPath)
		{
			m_curKBBackupPath = strValue;
		}

		// m_last...Path values below
		else if (name == szLastCCTablePath || name == szDefaultTablePath) // szLastCCTablePath new in 6.x.x
		{
			m_lastCcTablePath = strValue; // can be empty
		}
		else if (name == szLastRetranslationReportPath || name == szRetranslationReportPath) // new 6.x.x label for newer basic config files
		{
			m_lastRetransReportPath = strValue;
		}
		else if (name == szLastPackedDocumentPath)
		{
			m_lastPackedOutputPath = strValue; // can be empty
		}
		else if (name == szLastKBExportPath || name == szKBExportPath) // new 6.x.x label for newer basic config files
		{
			m_lastKbOutputPath = strValue;
		}
		else if (name == szLastKBLIFTExportPath || name == szKBLIFTExportPath)
		{
			m_lastKbLiftOutputPath = strValue;
		}
		// whm 6Aug11 From version 6.x.x on store the m_lastDocPath
		// only in the appropriate project config file
		else if (name == szLastDocPath) // for reading pre-6.x.x basic config files without a warning
		{
			m_lastDocPath = strValue;
		}
		// whm 6Aug11 From version 6.x.x on store the m_lastSourceInputPath
		// only in the appropriate project config file
		else if (name == szLastSourceInputPath) // for reading pre-6.x.x basic config files without a warning
		{
			m_lastSourceInputPath = strValue;
		}
		// whm 6Aug11 From version 6.x.x on store the m_lastTargetOutputPath
		// only in the appropriate project config file.
		else if (name == szLastExportPath) // for reading pre-6.x.x basic config files without a warning
		{
			m_lastTargetOutputPath = strValue;
		}
		// whm 6Aug11 From version 6.x.x on store the m_lastSourceOutputPath
		// only in the appropriate project config file.
		else if (name == szLastSourceOutputPath) // for reading pre-6.x.x basic config files without a warning
		{
			m_lastSourceOutputPath = strValue;
		}
		// whm 6Aug11 From version 6.x.x on store the m_lastSourceRTFOutputPath
		// only in the appropriate project config file.
		else if (name == szLastSourceRTFOutputPath) // for reading pre-6.x.x basic config files without a warning
		{
			m_lastSourceRTFOutputPath = strValue;
		}
		else if (name == szRTFExportPath) // for reading pre-6.x.x basic config files without a warning
		{
			// whm 6Aug11 Note: We no longer use m_lastRtfOutputPath, but it has been
			// replaced by more specific m_last...RTFOutputPath variables in the project
			// config files, so we here just ignore any value from old config files.
			; //m_lastRtfOutputPath = strValue;
		}
		else if (name == szFoldersProtectedFromNavigation)
		{
			m_foldersProtectedFromNavigation = strValue;
			// parse the m_foldersProtectedFromNavigation string and set the App's
			// folder protection flags
			SetFolderProtectionFlagsFromCombinedString(m_foldersProtectedFromNavigation);
		}
		else if (name == szAdministratorPassword)
		{
			m_adminPassword = strValue;
		}
		else if (name == szLastActiveSequNum)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 3000000)
				num = 0; // safe default is start of doc
			nLastActiveSequNum = num;
		}
        // From version 2.3.0, we don't write out m_punctuation[0] and m_punctuation[1] and
        // m_punctWordBuilding[0] and [1] are no longer used, so we retain the reads here
        // in case the user reads a legacy configuration file, but do nothing with what is
        // read for these fields; and in new config files, these fields are absent.
		else if (name == szSrcPunctuation) // new punctuation system (split)
		{
			; // m_punctuation[0] = strValue;
		}
		else if (name == szSrcPunctAsWordBuilding)
		{
			; // m_punctWordBuilding[0] = strValue;
		}
		else if (name == szTgtPunctuation)
		{
			; // m_punctuation[1] = strValue;
		}
		else if (name == szTgtPunctAsWordBuilding)
		{
			; // m_punctWordBuilding[1] = strValue;
		}
#ifndef _UNICODE
		else if (name == szPunctPairs)
		{
			// For Windows, ensure curly quotes are supported in ANSI version.
            // When first converted to wxWidgets, GTK's text control was failing when use
            // SetValue() with any of these upper ascii values in the punctuation string. A
            // partial solution was to ensure that SetEncoding(wxFONTENCODING_CP1252) was
            // called on the fonts involved. Note: SetEncoding() is an "undocumented"
            // method of wxFont. The documented SetDefaultEncoding() did not seem to work.
            // Also setting the encoding to wxFONTENCODING_ISO8859_1 did not work (it
            // eliminated the "Failed to set text in text control" message, but showed the
            // smart quotes as boxes with the hex values in them, instead of the actual
            // quote characters). Because it was only a partial solution and problems
            // seemed to continually crop up, in the end I decided to include smart quotes
            // only in the wxMSW ANSI version and not in wxGTK builds.
#ifdef __WXMSW__
			wxString additions;
			additions.Empty();
			wxString ch = _T("."); // must not be empty, so put any char in it
			unsigned char thechar = 147; // left double quotation mark
			ch.SetChar(0,thechar);
			if (strValue.Find(ch) == -1) // not found
			{
				additions += ch;
				additions += ch;
			}
			thechar = 148; // right double quotation mark
			ch.SetChar(0,thechar);
			if (strValue.Find(ch) == -1) // not found
			{
				additions += ch;
				additions += ch;
			}
			thechar = 145; // left single quotation mark
			ch.SetChar(0,thechar);
			if (strValue.Find(ch) == -1) // not found
			{
				additions += ch;
				additions += ch;
			}
			thechar = 146; // right single quotation mark
			ch.SetChar(0,thechar);
			if (strValue.Find(ch) == -1) // not found
			{
				additions += ch;
				additions += ch;
			}
			strValue += additions;
#else
            // In non-windows ANSI versions, remove any smart quotes that exist in the
            // punctuation string.
            // Possible Problem: We cannot assume that the user would always want smart
            // quotes converted to regular quotes in the punctuation lists. Maybe they used
            // smart quotes for all their quotes requirements, and used a regular single
            // quote (apostrophe) as a word building glottal character, for example.

            // whm note: For wx ANSI version, when compiled for wxGTK, we should check the
            // punct strings for illegal 8-bit chars, specifically for MS' smart quotes
            // which cause problems because the wxGTK library internally keeps strings in
            // UTF-8. We'll quietly convert any smart quotes we find to normal quotes.
			int ct;
			bool hackedFontCharPresent = FALSE;
			int hackedCt = 0;
			wxString hackedStr;
			hackedStr.Empty();
			const wxChar lsqm(-111);
			const wxChar rsqm(-110);
			const wxChar ldqm(-109);
			const wxChar rdqm(-108);
            // replace any smart quote chars with a space - if both src and tgt punct have
            // smart quotes we end up with both being spaces, but I think
            // StringToPunctPairs and its complement PunctPairsToString can handle it.
			strValue.Replace(&lsqm,_T(" "));
			strValue.Replace(&rsqm,_T(" "));
			strValue.Replace(&ldqm,_T(" "));
			strValue.Replace(&rdqm,_T(" "));
			// check for any remaining hacked font chars
			for (ct = 0; ct < (int)strValue.Length(); ct++)
			{
				int charValue;
				charValue = (int)strValue.GetChar(ct);
                // whm note: The decimal int value of extended ASCII chars is represented
                // as its decimal extended value minus 256, making any extended characters
                // be represented as negative numbers
				if (charValue < 0)
				{
					// we have an extended ASCII character in the string, remove it
					//switch(charValue)
					//{
					//case -111:	strValue.Remove(ct,1); // left single quotation mark
					//			break;
					//case -110:	strValue.Remove(ct,1); // right single quotation mark
					//			break;
					//case -109:	strValue.Remove(ct,1); // left double quotation mark
					//			break;
					//case -108:	strValue.Remove(ct,1); // right double quotation mark
					//			break;
					//default:
					//	{
                            // the default case indicates there is a non-smart quote
                            // extended ASCII character present. In this case we should
                            // warn the user that the data cannot be handled until it is
                            // converted to Unicode, then delete the extended punct char
                            // from the list.
							//::wxBell();
							hackedFontCharPresent = TRUE;
							hackedCt++;
							if (hackedCt < 10)
							{
								hackedStr += _T("\n   character with ASCII value: ");
								hackedStr << (charValue+256);
							}
							else if (hackedCt == 10)
								hackedStr += _T("...\n");
					//	}
					//}
				}
			}

            // we assume that regular quote marks are already in the punctuation string if
            // the user desired them to be there

			if (hackedFontCharPresent && !gbHackedDataCharWarningGiven)
			{
				gbHackedDataCharWarningGiven = TRUE;
				wxString msg2 = _(
"\nYou should not use this non-Unicode version of Adapt It.\nYour data should first be converted to Unicode using TecKit\nand then you should use the Unicode version of Adapt It.");
				wxString msg1 = _(
"Extended 8-bit ASCII characters were detected in the\nBasic Configuration File\'s punctuation string (see below):");
				msg1 += hackedStr + msg2;
				wxMessageBox(msg1,_("Warning: Invalid Characters Detected"),wxICON_WARNING);
			}

#endif
            // wxGTK uses UTF-8 internally in its wxTextCtrl widgets, so let's try
            // converting the punctuation string to UTF-8 for wxGTK ANSI builds.
//#ifdef __GNUG__
//			// The following converts strValue to
//			wxConvUTF8.cWC2MB(wxConvCurrent->cMB2WC(strValue));
//#endif
			// set flag if apostrophe is designated as a punctuation character (this makes
			// ParseWord() do its job smarter within TokenizeText())
			int found = strValue.Find(_T('\'')); // look for vertical ordinary quote (ie. apostrophe)
			if (found >= 0)
				m_bSingleQuoteAsPunct = TRUE;
			else
				m_bSingleQuoteAsPunct = FALSE;

			StringToPunctPairs(m_punctPairs,strValue);
		}
		else if (name == szTwoPunctPairs)
		{
			StringToTwoPunctPairs(m_twopunctPairs,strValue);
		}
#else // _UNICODE version
		else if (name == szPunctPairsSrc)
		{
			// make sure curly quotes are supported as punctuation
			wxString additions;
			additions.Empty();
			wxString ch = _T("."); // must not be empty, or SetChar() fails
			ch.SetChar(0,L'\x201C'); // hex for left double quotation mark
			if (strValue.Find(ch) == -1) // not found
			{
				bAddedLeftDoubleQuote = TRUE;
				additions += ch;
			}
			ch.SetChar(0,L'\x201D'); // hex for right double quotation mark
			if (strValue.Find(ch) == -1) // not found
			{
				bAddedRightDoubleQuote = TRUE;
				additions += ch;
			}
			ch.SetChar(0,L'\x2018'); // hex for left single quotation mark
			if (strValue.Find(ch) == -1) // not found
			{
				bAddedLeftSingleQuote = TRUE;
				additions += ch;
			}
			ch.SetChar(0,L'\x2019'); // hex for right single quotation mark
			if (strValue.Find(ch) == -1) // not found
			{
				bAddedRightSingleQuote = TRUE;
				additions += ch;
			}
			int found = strValue.Find(_T('\'')); // look for vertical ordinary
												 // quote (ie. apostrophe)
			if (found >= 0)
				m_bSingleQuoteAsPunct = TRUE;
			else
				m_bSingleQuoteAsPunct = FALSE;
			strValue = additions + strValue;

			strPunctPairsSrcSet = strValue;
		}
		else if (name == szPunctPairsTgt)
		{
			// THIS BLOCK WORKS RIGHT ONLY WHEN THE
			// SOURCE SET WAS PROCESSED EARLIER - so
			// ORDER is important in the config file for unicode punctuation
			// support - so don't alter order of src & tgt punct lines

			// make sure curly quotes are supported as punctuation
			wxString additions;
			additions.Empty();
			wxString ch = _T("."); // set to anything, which will be overwritten below
			ch.SetChar(0,L'\x201C'); // hex for left double quotation mark
			if (bAddedLeftDoubleQuote) // source had this added
			{
				 // so target has to have it too
				additions += ch;
			}
			ch.SetChar(0,L'\x201D'); // hex for right double quotation mark
			if (bAddedRightDoubleQuote)
			{
				// add it if the source had it added
				additions += ch;
			}
			ch.SetChar(0,L'\x2018'); // hex for left single quotation mark
			if (bAddedLeftSingleQuote)
			{
				// add it if the source had it added
				additions += ch;
			}
			ch.SetChar(0,L'\x2019'); // hex for right single quotation mark
			if (bAddedRightSingleQuote)
			{
				// add it if the source had it added
				additions += ch;
			}
			int found = strValue.Find(_T('\'')); // look for vertical ordinary
												 // quote (ie. apostrophe)
			if (found >= 0)
				m_bSingleQuoteAsPunct = TRUE;
			else
				m_bSingleQuoteAsPunct = FALSE;
			strValue = additions + strValue;

			strPunctPairsTgtSet = strValue;
		}
		else if (name == szTwoPunctPairsSrc)
		{
			strTwoPunctPairsSrcSet = strValue;
		}
		else if (name == szTwoPunctPairsTgt)
		{
			strTwoPunctPairsTgtSet = strValue;
		}
#endif

		// now stuff for the view
		else if (name == szZoomed)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // window not zoomed
			if (num == 0)
				m_bZoomed = FALSE;
			else
				m_bZoomed = TRUE;
		}
		else if (name == szMaxToDisplay)
		{
			num = wxAtoi(strValue);
            // refactored 22Mar09, we don't use this anymore (and is now used just to save
            // count of doc pSrcPhrase instances - though we generate that value now on the
            // fly when we need it, so m_nMaxToDisplay is only for backwards compatibility
            // of the config files)
			//if (num <= 80 || num > 4000)
			//	num = 300;
			m_nMaxToDisplay = num;
		}
		else if (name == szMinPrecContext)
		{
			num = wxAtoi(strValue);
			/* refactored 22Mar09 - no longer needed, but retain in config file
			if (num <= 10 || num > 80)
				num = 50;
			m_nPrecedingContext = num;
			*/
			int dummyvalue = num; // don't use it any more
			dummyvalue = dummyvalue; // avoid compiler warning
		}
		else if (name == szMinFollContext)
		{
			num = wxAtoi(strValue);
			/*
			if (num <= 10 || num > 60)
				num = 30;
			m_nFollowingContext = num;
			*/
			int dummyvalue = num; // don't use it any more
			dummyvalue = dummyvalue; // avoid compiler warning
		}
		else if (name == szLeading)
		{
			num = wxAtoi(strValue);
			if (num <= 16 || num > 80)
				num = 32;
			m_curLeading = num;
		}
		else if (name == szLeftMargin)
		{
			// whm 2Aug06 changed default to 16 for better visibility
			// of the notes icon at left margin
			num = wxAtoi(strValue);
			if (num < 16 || num > 80)
				num = 16;
			m_curLMargin = num;
		}
		else if (name == szGapWidth)
		{
			num = wxAtoi(strValue);
			if (num < 6 || num > 80)
				num = 16;
			m_curGapWidth = num;
		}
		else if (name == szSuppressFirst)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 0)
				m_bSuppressFirst = FALSE;
			else
				m_bSuppressFirst = TRUE;
		}
		else if (name == szSuppressLast)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 0)
				m_bSuppressLast = FALSE;
			else
				m_bSuppressLast = TRUE;
		}
		else if (name == szBackupDocument)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 1)
				m_bBackupDocument = TRUE;
			else
				m_bBackupDocument = FALSE;
		}
		else if (name == szWorkflowProfile)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 10)
				num = 0; // if out of reasonable range default to a profile of "None".
			m_nWorkflowProfile = num;
		}
		// whm Note 8Sep11. ALL of the collaboration-related settings need to be in
		// the basic configuration file because the GetSourceTextFromEditor dialog
		// needs them at the time that only the basic config file has been read in.
		else if (name == szCollaboratingWithParatext) // whm added 15Apr11
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_bCollaboratingWithParatext member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			if (num == 1)
			{
				m_bCollaboratingWithParatext = TRUE;
			}
			else
			{
				m_bCollaboratingWithParatext = FALSE;
			}
		}
		else if (name == szCollaboratingWithBibledit) // whm added 15Apr11
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_bCollaboratingWithBibledit member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			if (num == 1)
			{
				m_bCollaboratingWithBibledit = TRUE;
			}
			else
			{
				m_bCollaboratingWithBibledit = FALSE;
			}
		}
		else if (name == szCollabProjectForSourceInputs) // whm added 15Apr11
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_CollabProjectForSourceInputs member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			m_CollabProjectForSourceInputs = strValue;
		}
		else if (name == szCollabProjectForTargetExports) // whm added 15Apr11
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_CollabProjectForTargetExports member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			m_CollabProjectForTargetExports = strValue;
		}
		else if (name == szCollabProjectForFreeTransExports) // whm added 30Jun11
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_CollabProjectForFreeTransExports member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			m_CollabProjectForFreeTransExports = strValue;
		}
		else if (name == szCollabAIProjectName) // whm added 7Sep11
		{
			collabProjectName = strValue;

			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_CollabAIProjectName member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			m_CollabAIProjectName = strValue;
		}
		else if (name == szCollabExpectsFreeTrans) // whm added 9Aug11
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_bCollaborationExpectsFreeTrans member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			if (num == 1)
			{
				m_bCollaborationExpectsFreeTrans = TRUE;
			}
			else
			{
				m_bCollaborationExpectsFreeTrans = FALSE;
			}
		}
		// whm Note: The next three having to do with book and chapter
		// selection are not affected by command-line switches.
		else if (name == szCollabBookSelected)
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_CollabBookSelected member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			m_CollabBookSelected = strValue;
		}
		else if (name == szCollabByChapterOnly)
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_bCollabByChapterOnly member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			if (num == 1)
				m_bCollabByChapterOnly = TRUE;
			else
				m_bCollabByChapterOnly = FALSE;
		}
		else if (name == szCollabChapterSelected)
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_CollabChapterSelected member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			m_CollabChapterSelected = strValue;
		}
		// whm 4Sep11 added the next two
		else if (name == szCollabSourceLangName)
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_CollabSourceLangName member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			m_CollabSourceLangName = strValue;
		}
		else if (name == szCollabTargetLangName)
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_CollabTargetLangName member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			m_CollabTargetLangName = strValue;
		}
		/*
		else if (name == szCollabSwitchingPasswordProtected) // whm added 2Feb12
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_bPwdProtectCollabSwitching member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			if (num == 0)
				m_bPwdProtectCollabSwitching = FALSE;
			else
				m_bPwdProtectCollabSwitching = TRUE;
		}
		else if (name == szCollabSwitchingPassword) // whm added 2Feb12
		{
			// whm modified 19Feb12 set the flag that will trigger transitioning
			// any collab settings in the basic config file to the appropriate
			// project config file. The caller uses the bBasicConfigHasCollabSettingsData
			// flag's value below to call MoveCollabSettingsToProjectConfigFile()
			// when appropriate.
			// The collab settings, if they exist are read in and allowed to change
			// the App's m_collabSwitchingPassword member. They will not be written out
			// to the basic config file which will happen in the call to
			// MoveCollabSettingsToProjectConfigFile() that will happen after this
			// basic config file is read.
			bBasicConfigHasCollabSettingsData = TRUE;

			m_collabSwitchingPassword = strValue;
		}
		*/
		else if (name == szHidePunctuation)
		{
            // BEW removed 8Aug09, there is no good reason to store a "punctuation hidden"
            // value because if we do that, the user could get confused if next time his
            // document doesn't show and punctuation and he didn't realize he shut down
            // with this setting toggled from the default, so now we'll ignore the config
            // file value, and always launch the app with this m_bHidePunctuation flag set
            // FALSE
			m_bHidePunctuation = FALSE;
			//	num = wxAtoi(strValue);
			//	if (!(num == 0 || num == 1))
			//		num = 0; // don't hide it
			//	if (num == 0)
			//		m_bHidePunctuation = FALSE;
			//	else
			//		m_bHidePunctuation = TRUE;
		}
		else if (name == szStatusBarIsVisible) // whm added 6Jan12
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1; // make it visible
			if (num == 1)
				m_bStatusBarVisible = TRUE;
			else
				m_bStatusBarVisible = FALSE;
		}
		else if (name == szToolBarIsVisible) // whm added 6Jan12
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1; // make it visible
			if (num == 1)
				m_bToolBarVisible = TRUE;
			else
				m_bToolBarVisible = FALSE;
		}
		else if (name == szModeBarIsVisible) // whm added 6Jan12
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1; // make it visible
			if (num == 1)
				m_bModeBarVisible = TRUE;
			else
				m_bModeBarVisible = FALSE;
		}
		else if (name == szSuppressWelcome)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // don't suppress it
			if (num == 1)
				m_bSuppressWelcome = TRUE;
			else
				m_bSuppressWelcome = FALSE;
		}
		else if (name == szUseStartupWizardOnLaunch)
		{
			num = wxAtoi(strValue);
			// Ignore config value, Version 3 always uses startup wizard
			m_bUseStartupWizardOnLaunch = TRUE;
		}
		else if (name == szBackupKBFlag)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1; // back it up
			if (num == 1)
				m_bAutoBackupKB = TRUE;
			else
				m_bAutoBackupKB = FALSE;
		}
		else if (name == szNoAutoSaveFlag)
		{
			num = wxAtoi(strValue);
#ifdef Test_m_bNoAutoSave
	// Test_m_bNoAutoSave symbol #defined at start of Adapt_It.h
	#ifdef __WXDEBUG__
		wxLogDebug(_T("m_bNoAutoSave  in GetBasicSettingsConfiguration()  was just read in as %d"), num);
	#endif
#endif
			if (!(num == 0 || num == 1))
			{
				num = 0; // auto save
#ifdef Test_m_bNoAutoSave
	// Test_m_bNoAutoSave symbol #defined at start of Adapt_It.h
	#ifdef __WXDEBUG__
		wxLogDebug(_T("m_bNoAutoSave  in GetBasicSettingsConfiguration()  BAD VALUE, so set to FALSE"));
	#endif
#endif
			}
			if (num == 1)
				m_bNoAutoSave = TRUE;
			else
				m_bNoAutoSave = FALSE;
#ifdef Test_m_bNoAutoSave
	// Test_m_bNoAutoSave symbol #defined at start of Adapt_It.h
	#ifdef __WXDEBUG__
	if (num == 1)
		wxLogDebug(_T("m_bNoAutoSave  in GetBasicSettingsConfiguration() (after test) was set to TRUE"));
	else
		wxLogDebug(_T("m_bNoAutoSave  in GetBasicSettingsConfiguration() (after test) was set to FALSE"));
	#endif
#endif
		}
		else if (name == szSpecialTextColor) // read but no longer written in the basic config file
		{
			//num = wxAtoi(strValue); // allow anything
			; //m_specialTextColor = Int2wxColour(num); // Int2wxColour() in helpers.h
		}
		else if (name == szReTranslnTextColor) // read but no longer written in the basic config file
		{
			//num = wxAtoi(strValue); // allow anything
			; //m_reTranslnTextColor = Int2wxColour(num);// Int2wxColour() in helpers.h
		}
		else if (name == szTgtDiffsTextColor) // read but no longer written in the basic config file
		{
			// num = wxAtoi(strValue); // allow anything
			; //m_tgtDiffsTextColor = Int2wxColour(num);// Int2wxColour() in helpers.h
		}
		else if (name == szTS_DOC_MINS)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 60)
				num = 10;
			mins = num;
			secs = 0; // we don't use seconds any more
			//CTimeSpan ts(0,0,mins,secs); // MFC version has (days,hours,minutes,seconds)
			wxTimeSpan ts(0,mins,secs,0); // wxTimeSpan has (hours,minutes,seconds,milliseconds)
			m_timeSettings.m_tsDoc = ts;
		}
		else if (name == szTS_DOC_SECS)
		{
			// ignore seconds now
			;
		}
		else if (name == szTS_KB_MINS)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 60)
				num = 15;
			mins = num;
			secs = 0; // we don't use seconds any more
			//CTimeSpan tsKB(0,0,mins,secs);// MFC version has (days,hours,minutes,seconds)
			wxTimeSpan tsKB(0,mins,secs,0); // wxTimeSpan has (hours,minutes,seconds,milliseconds)

			m_timeSettings.m_tsKB = tsKB;
		}
		else if (name == szTS_KB_SECS)
		{
			// ignore seconds now
			;
		}
		else if (name == szPhraseBoxMoves)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 1000)
				num = 100; // default bold
			m_nMoves = num;
		}
		else if (name == szIsDocTimeButtonFlag)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1; // save by time span elapsed
			if (num == 1)
				m_bIsDocTimeButton = TRUE;
			else
				m_bIsDocTimeButton = FALSE;
		}
		else if (name == szNavTextColor) // read but no longer written in the basic config file
		{
			//num = wxAtoi(strValue); // allow anything
			;
		}

        // Ursula Wiesemann (Brazil), in early version 3, was having bizarre values of 3000
        // for xTopLeft and yTopLeft, and bad values (e.g 160 by 24) for cxWZize and
        // cyWSize, respectively. I cannot find any reason for these - unless rogue code is
        // overwriting memory. So I'll check for rogue values on read of the basic config
        // file, and on writing the basic config file, and substitute safe ones when values
        // for the top left would place the main window to the right or below the point
        // near the bottom right of the screen, or too narrow or high a window size etc.
        // (Bill Martin got, one time, -32000 values for top left in Unicode app!)

		else if (name == szTopLeftX)
		{
			num = wxAtoi(strValue);
            // whm Note: The wndBotRight and wndTopLeft coordinate points are determined in
            // the App's OnInit() by a call to the wxGetClientDisplayRect() function
            // adjusted for any extended desktop support over dual monitors.
			if (num < -6 || num > wndBotRight.x - 5) // -4 is maximized window's x value
			{
				//bAdjusted = TRUE; // it's too far left or right
				num = 5;
			}
			m_ptViewTopLeft.x = num;
		}
		else if (name == szTopLeftY)
		{
			num = wxAtoi(strValue);
            // whm Note: The wndBotRight and wndTopLeft coordinate points are determined in
            // the App's OnInit() by a call to the wxGetClientDisplayRect() function
            // adjusted for any extended desktop support over dual monitors.
			if (num < -6 || num > wndBotRight.y - 5) // -4 is maximized window's y value
			{
				//bAdjusted = TRUE; // it's too far up or down
				num = 5;
			}
			m_ptViewTopLeft.y = num;
		}
		else if (name == szWSizeCX)
		{
			num = wxAtoi(strValue);
            // whm Note: The wndBotRight and wndTopLeft coordinate points are determined in
            // the App's OnInit() by a call to the wxGetClientDisplayRect() function
            // adjusted for any extended desktop support over dual monitors.
			if (num < 200 || num > wndBotRight.x - wndTopLeft.x)
			{
				//bAdjusted = TRUE; // it's too narrow or too wide
				num = wndBotRight.x - wndTopLeft.x -100;
			}
			m_szView.x = num;
		}
		else if (name == szWSizeCY)
		{
			num = wxAtoi(strValue);
            // whm Note: The wndBotRight and wndTopLeft coordinate points are determined in
            // the App's OnInit() by a call to the wxGetClientDisplayRect() function
            // adjusted for any extended desktop support over dual monitors.
			if (num < 200 || num > wndBotRight.y - wndTopLeft.y)
			{
				//bAdjusted = TRUE; // it's too short or too long
				num = wndBotRight.y - wndTopLeft.y - 100;
			}
			m_szView.y = num;
		}
		else if (name == szFitFlag)
		{
			; // unused as of version 2.4.2
		}
		else if (name == szMarkerWrapsFlag)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 0)
				m_bMarkerWrapsStrip = FALSE;
			else
				m_bMarkerWrapsStrip = TRUE;
		}
		else if (name == szLoEnglishFlag)
		{
			// in wx version page setup only has mm for margins,
			// so we only use Metric for now
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 0)
				m_bIsInches = FALSE;
			else
				m_bIsInches = TRUE;
		}
		else if (name == szUsePortraitOrientation)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 0)
				m_bIsPortraitOrientation = FALSE;
			else
				m_bIsPortraitOrientation = TRUE;
		}
		else if (name == szLastPageWidth)
		{
			// whm MFC used if (num < 0), wx versions uses if (num <= 0)
			// to set default to A4 if config has 0
			num = wxAtoi(strValue);
			if (num <= 0)
				num = 8267;
			m_pageWidth = num;
			// use the more prcise conversion factor for page size
			m_pageWidthMM = wxRound(num * thousandthsInchToMillimetres);
		}
		else if (name == szLastPageLength)
		{
			// whm MFC used if (num < 0), wx versions uses if (num <= 0)
			// to set default to A4 if config has 0
			num = wxAtoi(strValue);
			if (num <= 0)
				num = 11692;
			m_pageLength = num;
			// use the more prcise conversion factor for page size
			m_pageLengthMM = wxRound(num * thousandthsInchToMillimetres);
		}
		else if (name == szPaperSizeCode)
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 300)
				num = 9; // A4
			m_paperSizeCode = num;
		}
		else if (name == szMarginTop)
		{
			num = wxAtoi(strValue);
			if (num < 0)
				num = 1000;
			m_marginTop = num;
			// use the less precise conversion factor for margins
			m_marginTopMM = (int)(num * config_only_thousandthsInchToMillimetres);
		}
		else if (name == szMarginBottom)
		{
			num = wxAtoi(strValue);
			if (num < 0)
				num = 1000;
			m_marginBottom = num;
			m_marginBottomMM = (int)(num * config_only_thousandthsInchToMillimetres); // use the less precise conversion factor for margins
		}
		else if (name == szMarginLeft)
		{
			num = wxAtoi(strValue);
			if (num < 0)
				num = 1000;
			m_marginLeft = num;
			m_marginLeftMM = (int)(num * config_only_thousandthsInchToMillimetres); // use the less precise conversion factor for margins
		}
		else if (name == szMarginRight)
		{
			num = wxAtoi(strValue);
			if (num < 0)
				num = 1000;
			m_marginRight = num;
			// use the less precise conversion factor for margins
			m_marginRightMM = (int)(num * config_only_thousandthsInchToMillimetres);
		}
		else if (name == szPunctuation) // (now very) old punctuation system
		{
			; // m_punctuation[0] = strValue; // retain in case a pre-2001
			  // config file needs to be read
		}
		else if (name == szPunctAsWordBuilding)
		{
			; //m_punctWordBuilding[0] = strValue; // ditto
		}
		else if (name == szPhraseBoxExpansionMultiplier)
		{
			num = wxAtoi(strValue);
			if (num < 5 || num > 30)
				num = 10;
			gnExpandBox = num;
		}
		else if (name == szTooNearEndMultiplier)
		{
			num = wxAtoi(strValue);
			if (num < 3 || num > 6)
				num = 3;
			gnNearEndFactor = num;
		}
		else if (name == szRTL_Layout)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // LTR layout is safe default
			if (num == 1)
				m_bRTL_Layout = TRUE;
			else
				m_bRTL_Layout = FALSE;
			gbRTL_Layout = m_bRTL_Layout; // set the global at same time
		}

#ifdef _RTL_FLAGS
		else if (name == szRTLSource)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // LTR reading text is safe default
			if (num == 1)
				m_bSrcRTL = TRUE;
			else
				m_bSrcRTL = FALSE;
		}
		else if (name == szRTLTarget)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // LTR reading text is safe default
			if (num == 1)
				m_bTgtRTL = TRUE;
			else
				m_bTgtRTL = FALSE;
		}
		else if (name == szRTLNavText)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // LTR reading text is safe default
			if (num == 1)
				m_bNavTextRTL = TRUE;
			else
				m_bNavTextRTL = FALSE;
		}
#endif
		else if (name == szSuppressTargetHighlighting)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // don't suppress it
			if (num == 1)
				m_bSuppressTargetHighlighting = TRUE;
			else
				m_bSuppressTargetHighlighting = FALSE;
		}
		else if (name == szUsePrefixExportTypeOnFilename) // whm added 9Dec11
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // don't suppress it
			if (num == 1)
				m_bUsePrefixExportTypeOnFilename = TRUE;
			else
				m_bUsePrefixExportTypeOnFilename = FALSE;
		}
		else if (name == szUseSuffixExportDateTimeOnFilename) // whm added 9Dec11
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // don't suppress it
			if (num == 1)
				m_bUseSuffixExportDateTimeOnFilename = TRUE;
			else
				m_bUseSuffixExportDateTimeOnFilename = FALSE;
		}
		else if (name == szUsePrefixExportProjectNameOnFilename) // whm added 21Feb12
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // don't suppress it
			if (num == 1)
				m_bUsePrefixExportProjectNameOnFilename = TRUE;
			else
				m_bUsePrefixExportProjectNameOnFilename = FALSE;
		}
		else if (name == szAutoInsertionsHighlightColor) // whm 6Aug11 moved to project config file
		{
			// whm 6Aug11 we read the value from old config files but ignore it
			//num = wxAtoi(strValue); // allow anything
			//m_AutoInsertionsHighlightColor = Int2wxColour(num); // Int2wxColour() in helpers.h
			;
		}
		else if (name == szGuessHighlightColor) // whm 6Aug11 moved to project config file
		{
			// whm 6Aug11 we read the value from old config files but ignore it
			//num = wxAtoi(strValue); // allow anything
			//m_GuessHighlightColor = Int2wxColour(num); // Int2wxColour() in helpers.h
			;
		}

		// added for v1.4.1 and onwards
		else if (name == szSFMescapechar)
		{
			;	// disregard the sfm esc char read in from config as of version 3
				// gSFescapechar is always backslash
		}

		else
		{
			if (!data.IsEmpty())
			{
				wxString error;
				error = error.Format(_(
				"Warning: Unrecognized Basic settings field; unmatched name is: %s\n"),name.c_str());
				wxMessageBox(error, _T(""), wxICON_INFORMATION);
			}
		}
	} while (!pf->Eof());
	// BEW changed 06Mar06, on Bill's recommendation - ie. don't tell the user when an adjustment
	// was required, just do it
	//if (bAdjusted)
	//{
	//	AfxMessageBox(IDS_WINDOW_LOC_ERR,MB_ICONINFORMATION);
	//}

#ifdef _UNICODE
	// do the to set the punct pairs arrays, the equivalent calls for the ANSI
	// version are done in the "else if" blocks above
	TwoStringsToPunctPairs(m_punctPairs,strPunctPairsSrcSet,strPunctPairsTgtSet);
	TwoStringsToTwoPunctPairs(m_twopunctPairs,strTwoPunctPairsSrcSet,strTwoPunctPairsTgtSet);
#endif
	//set the src and tgt punctuation sets to be used for parsing
	GetPunctuationSets(m_punctuation[0], m_punctuation[1]);
}


////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if successful, FALSE otherwise
/// \remarks
/// Called from: GetConfigurationFile() when getting the basicConfigFile and when
/// bBasicConfigHasCollabSettingsData is true.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::MoveCollabSettingsToProjectConfigFile(wxString collabProjName)
{
	// This function does the following:
	// 1. Determine the name and path of the collaboration project
	// 2. Call WriteConfigurationFile([basic]) to write out a new basic config file without
	// the collaboration settings.
	// 3. Call WriteConfigurationFile([project]) to write out a new project config file that
	// now has those collaboration settings
	// Note: This routine does not guarantee that the collab settings were correct, it just
	// moves them from the basic config file to an appropriate AI project config file - as
	// long as the destination project config file can be determined from the collaboration
	// settings that were found in the basic config file. The collaboration dialog(s) test
	// for correct collaboration settings.

	// 1. Determine the path and name from the incoming wxString collabProjName.
	// Note: Don't assign values to the App's m_curProjectName or m_curProjectPath
	// here, but use local variables instead so we don't create any side effects
	// by changing the m_curProjectName and m_curProjectPath.
	wxString temp_curProjectName;
	wxString temp_curProjectPath;
	temp_curProjectName = collabProjName; // from the incoming parameter (read from
							// the CollabAIProjectName field in the basic config file)
	if (!m_customWorkFolderPath.IsEmpty() && m_bUseCustomWorkFolderPath)
	{
		temp_curProjectPath = m_customWorkFolderPath + PathSeparator
								 + temp_curProjectName;
	}
	else
	{
		temp_curProjectPath = m_workFolderPath + PathSeparator
								 + temp_curProjectName;
	}
	if (!collabProjName.IsEmpty() && ::wxDirExists(temp_curProjectPath))
	{
		// 2. Write out the basic config file - it will get written out *without* the
		// collaboration settings saved in it.
		bool bOK1;
		if (m_bUseCustomWorkFolderPath && !m_customWorkFolderPath.IsEmpty())
		{
			// BEW 17Sep09, must save using what paths are current, but when the custom
			// location has been locked in, the filename lacks "Admin" in it, so that it
			// becomes a "normal" basic configuration file at the custom location
			if (m_bLockedCustomWorkFolderPath)
				bOK1 = WriteConfigurationFile(szBasicConfiguration, m_customWorkFolderPath,basicConfigFile);
			else
				bOK1 = WriteConfigurationFile(szAdminBasicConfiguration, m_workFolderPath,basicConfigFile);
			wxCHECK_MSG(bOK1, FALSE,_T("MoveCollabSettingsToProjectConfigFile(): WriteConfigurationFile() returned FALSE, line 18,009 or 18011"));
		}
		else
		{
			bOK1 = WriteConfigurationFile(szBasicConfiguration, m_workFolderPath,basicConfigFile);
			wxCHECK_MSG(bOK1, FALSE,_T("MoveCollabSettingsToProjectConfigFile(): WriteConfigurationFile() returned FALSE, line 18,016"));
		}
		// 3. Write out the project config file - it will get written out *with* the
		// collaboration settings saved in it.
		wxASSERT(::wxDirExists(temp_curProjectPath));
		bool bOK2;
		bOK2 = WriteConfigurationFile(szProjectConfiguration,temp_curProjectPath,projectConfigFile);
		wxCHECK_MSG(bOK2, FALSE,_T("MoveCollabSettingsToProjectConfigFile(): WriteConfigurationFile() failed, line 27,957 in Adapt_It.cpp"));
	}
	else
	{
		// Either the incoming collabProjName is empty, or when used as the AI
		// project folder in the temp_curProjectPath, it is not a valid project
		// path and name in AI's work folder.
		// Here again, we could warn the user/administrator that the AI
		// collaboration settings (from the basic config file) didn't specify a
		// valid AI project for collaboration work. But, again I think we should
		// just quietly proceed without attempting to save any of the other collab
		// settings that may have been in the basic config file. They might have
		// been wrong or corrupted, so it is best that we just assume that the
		// administrator will set collaboration up properly in this new version
		// for the desired AI project(s).
		wxString msg = _("Adapt It was not able to upgrade the collaboration settings for use in this version (%s) of Adapt It.\nPlease ask your administrator to setup Adapt It for collaboration with %s.");
		wxASSERT(!m_collaborationEditor.IsEmpty());
		msg = msg.Format(msg,appVerStr.c_str(),m_collaborationEditor.c_str());
		wxMessageBox(msg,_T(""),wxICON_WARNING);
	}
	return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's GetProjectConfiguration() if SHIFT key is being held down,
/// CCaseEquivPageCommon::DoBnClickedSrcSetEnglish(),
/// CCaseEquivPageCommon::DoBnClickedTgtSetEnglish(),
/// CCaseEquivPageCommon::DoBnClickedGlossSetEnglish(), and
/// CProjectPage::OnWizardPageChanging() moving forward and creating a <New Project>.
/// Sets the default source, target and gloss language case equivalences to the
/// English/Latin alphabetical set.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetDefaultCaseEquivalences()
// ASCII defaults, for when a project first is created
{
	m_srcLowerCaseChars = _T("abcdefghijklmnopqrstuvwxyz");
	m_srcUpperCaseChars = _T("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
	m_tgtLowerCaseChars = m_srcLowerCaseChars;
	m_tgtUpperCaseChars = m_srcUpperCaseChars;
	m_glossLowerCaseChars = m_srcLowerCaseChars;
	m_glossUpperCaseChars = m_srcUpperCaseChars;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's GetBasicConfiguration() if the SHIFT key is being held
/// down, or if the basic configuration file could not be read. Also called from
/// DealWithThePossibilityOfACustomWorkFolderLocation() if the basic config file at the
/// custom work folder location could not be read.
/// SetDefaults() establishes reasonable defaults that can be used for fonts, punctuation
/// and other settings until the user sets more suitable defaults using the Edit |
/// Preferences dialog.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetDefaults(bool bAllowCustomLocationCode)
{
    // SetDefaults() is only called if the user holds down SHIFT key as app starts up, or
    // if the basic config file cannot be read successfully, i.e., the call to
    // GetConfigurationFile(szBasicConfiguration,m_workFolderPath,1) in the App's
    // Initialize() function returns FALSE.
	//
    // Although InitializeFonts() always gets called from OnInit(), SetDefaults() can also
    // be invoked if there was a bad read of the basic config file, so we call
    // InitializeFonts() again here to correct any garbage settings that may have been set
    // during a bad read of the config file.
	InitializeFonts();
	InitializePunctuation();

	// TODO: Should some/all of the following be put in Adapt_ItConstants.h ???
	//m_nMaxToDisplay = 300; // 22Mar09, no longer used, but retained for backwards
							 // compatibility of config file
	//m_nPrecedingContext = 50;
	//m_nFollowingContext = 30;
	m_curLeading = 32;
	m_curLMargin = 16;	// whm changed default to 16 for better visibility of any notes
						// icon at left margin
	m_curGapWidth = 16;
	m_bSuppressFirst = TRUE;
	m_bSuppressLast = TRUE;
	gnExpandBox = 8;
	gnNearEndFactor = 3;
	m_bHidePunctuation = FALSE;

	m_bUseStartupWizardOnLaunch = TRUE;
	m_bAutoBackupKB = TRUE;
	/*
	//BEW changed default to FALSE, because new users won't realize they start out
	//unprotected from total work loss if the power goes out during their first session,
	//as happened in Bob Buss's Brazil training workshop
	m_bNoAutoSave = TRUE; // whm changed to TRUE in wx (MFC has FALSE here but TRUE in
						  // App's constructor as default)
	*/
	m_bNoAutoSave = FALSE; // AutoSavingPage.cpp, InitDialog() takes this value and
						   // sets up the wiz page's control value from it
#ifdef Test_m_bNoAutoSave
	// Test_m_bNoAutoSave symbol #defined at start of Adapt_It.h
	#ifdef __WXDEBUG__
	if (m_bNoAutoSave)
		wxLogDebug(_T("m_bNoAutoSave  in SetDefaults() was set to TRUE"));
	else
		wxLogDebug(_T("m_bNoAutoSave  in SetDefaults() was set to FALSE"));
	#endif
#endif

	m_ptViewTopLeft.x = 20;
	m_ptViewTopLeft.y = 20;
	m_szView.x = 640;
	m_szView.y = 580;
	m_bMarkerWrapsStrip = TRUE;
	m_bZoomed = FALSE;

	m_bIsInches = FALSE; // in wx version's Windows page setup only has mm
						 // for margins, so we set default to Metric for now
	m_bIsPortraitOrientation = TRUE;
	m_paperSizeCode = 9; // always mapped to MFC's enum for paper size code = 9; // A4

    // MFC used default values in MM_LOENGLISH mapping mode (thousandths of an inch) The wx
    // version uses mainly metric millimeter values internally for printing and print
    // preview
	m_pageWidth = 8267;		// 210mm / 0.0254mm/in (result truncated to whole int) in thousandths of an inch = 8267 A4
	m_pageWidthMM = wxRound(m_pageWidth * thousandthsInchToMillimetres); // 210mm	A4 page width in mm
	m_pageLength = 11692;	// 297mm / 0.0254mm/in (result truncated to whole int) in thousandths of an inch = 11692 A4
	m_pageLengthMM = wxRound(m_pageLength * thousandthsInchToMillimetres); // 297mm A4 page height in mm
	// the default margin values below use less precise conversion factor of 0.0250mm/in
	m_marginTop = 1000;		// 25mm / 0.0250mm/in (result truncated to whole int) in thousandths of an inch = 1000; // one inch
	m_marginTopMM = (int)(m_marginTop * config_only_thousandthsInchToMillimetres); // 25mm top margin in mm
	m_marginBottom = 1000;	// 25mm / 0.0250mm/in (result truncated to whole int) in thousandths of an inch = 1000; // one inch
	m_marginBottomMM = (int)(m_marginBottom * config_only_thousandthsInchToMillimetres); // 25mm bottom margin in mm
	m_marginLeft = 1000;	// 25mm / 0.0250mm/in (result truncated to whole int) in thousandths of an inch = 1000; // one inch
	m_marginLeftMM = (int)(m_marginLeft * config_only_thousandthsInchToMillimetres); // 25mm left margin in mm
	m_marginRight = 1000;	// 25mm / 0.0250mm/in (result truncated to whole int) in thousandths of an inch = 1000; // one inch
	m_marginRightMM = (int)(m_marginRight * config_only_thousandthsInchToMillimetres); // 25mm right margin in mm

	// standard format marker's escape char
	gSFescapechar = _T('\\');

	m_nCurDelay = 0; // default is no delay (zero ticks)

	// whm note 9Jun11:
	// TODO: The code block below for re-establishing a custom work folder setup when
	// a user does a SHIFT-down startup, works OK when PT collaboration is in effect,
	// but I think it can be improved to make a SHIFT-down startup work better.
	// I think that adding the storage of critical custom workfolder values in the
	// Adapt_It_WX.ini - in particular the m_bLockedCustomWorkFolderPath,
	// the m_bUseCustomWorkFolderPath, and the m_customWorkFolderPath - would improve
	// reliability and usability. The values stored in Adapt_It_WX.ini are likely to
	// be only stored on a user's machine and won't be transferred to other machines
	// if/when an Adapt It project is copied to another machine via a thumbdrive or
	// via Pack/Unpack Document operation. Hence, the values stored within
	// Adapt_It_WX.ini are more stable for a give user's computing environment.
	// If the user needs to do a SHIFT-down startup because of a corruption problem
	// in one of the .aic config files or from getting a foreign .aic config file, the
	// Adapt_It_WX.ini values would very likely be those that an administrator would
	// have wanted to be preserved for that given user's computer.

	if (bAllowCustomLocationCode)
	{
		// BEW added 12Oct09 in support of custom work folder locations
		m_bLockedCustomWorkFolderPath = FALSE;
		m_customWorkFolderPath = _T(""); // default to no custom work folder set
		// the above two lines are inappropriate if the user had a custom work folder location
		// set and ran into difficulties and used the SHIFT key to get the app going again;
		// because the default work folder may have the correct path defined in the file
		// CustomWorkFolderLocation stored in the default work folder location, and we'd want
		// the SHIFT-start mechanism to still test for this possibility and use that path if
		// it exists, setting m_customWorkFolderLocation to it, and turning on the
		// m_bLockedCustomWorkFolderPath boolean. So do that now. The code for this test is
		// taken from OnInit() where the same check has to be made.
		bool bDealtWithItOK = DealWithThePossibilityOfACustomWorkFolderLocation();
		if (!bDealtWithItOK)
		{
			// if we are supposed to have a persistent custom location but failed to setup for
			// it, then abort - the function will have put up an appropriate error message
			// already
			// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
			wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
			return;
		}
	}

	// whm added 20Jun11. If the administrator has selected to use fixed locations for certain inputs
	// and outputs folders at the time the user held down the SHIFT key to get the app going again, we
	// would want those fixed location folders to continue to be used which are stored in Adapt_It_WX.ini.
	// Read the value related to m_foldersProtectedFromNavigation from the Adapt_It_WX.ini file, and if
	// it differs from what is stored in the App's m_foldersProtectedFromNavigation member (due to SHIFT
	// down restart), restore the value stored in Adapt_It_WX.ini.
	bool bReadOK = FALSE;
	wxString tempFoldersProtectedFromNavigation;
	wxString oldPath = m_pConfig->GetPath(); // is always absolute path "/Recent_File_List"
	m_pConfig->SetPath(_T("/Settings"));
	{ // begin wxLogNull block
	wxLogNull logNo; // eliminates spurious message from the system
	bReadOK = m_pConfig->Read(_T("folders_protected_from_navigation"), &tempFoldersProtectedFromNavigation);
	} // end wxLogNull block
	if (bReadOK && tempFoldersProtectedFromNavigation != m_foldersProtectedFromNavigation)
	{
		m_foldersProtectedFromNavigation = tempFoldersProtectedFromNavigation;
		SetFolderProtectionFlagsFromCombinedString(m_foldersProtectedFromNavigation);
	}

	// whm 29Feb12 removed the m_pConfig reading routines below for collaboration values
	// Adapt It now does project-specific collaboration and user always has control over
	// whether collaboration with a particular AI project gets turned ON or OFF.
	/*
	// whm added 7Jun11. If Paratext collaboration was ON at the time the user used the SHIFT
	// key to get the app going again, we would want the values related to Paratext collaboration
	// that are stored in Adapt_It_WX.ini to be restored since it is likely to be accurate even if
	// the basic config file needs to be re-created from scratch (most likely due to errant edits
	// done by a user).

	// Read the PT related flags that were last stored in the Adapt_It_WX.ini file and restore
	// them if they differ from what was stored in the corresponding App's values (due to SHIFT-down
	// restart).
	bReadOK = FALSE;
	bool bReadOK2 = FALSE;
	bool bReadOK3 = FALSE;
	bool bReadOK4 = FALSE;
	bool bReadOK5 = FALSE;
	bool bReadOK6 = FALSE;
	bool bReadOK7 = FALSE;
	bool bReadOK8 = FALSE;
	bool bReadOK9 = FALSE;
	bool bReadOK10 = FALSE;
	bool bTempCollabFlag = FALSE;
	wxString tempCollabProjForSrcInputs = _T("");
	wxString tempCollabProjForTgtExports = _T("");
	wxString tempCollabProjForFreeTransExports = _T("");
	wxString tempCollabBookSelected = _T("");
	bool bTempCollabByChapterOnly = TRUE;
	wxString tempCollabChapterSelected = _T("");
	wxString tempCollabSourceLangName = _T("");
	wxString tempCollabTargetLangName = _T("");
	wxString tempCollabAIProjectName = _T("");
	if (m_collaborationEditor == _T("Paratext"))
	{
		{ // begin wxLogNull block
		wxLogNull logNo; // eliminates spurious message from the system
		bReadOK = m_pConfig->Read(_T("pt_collaboration"), &bTempCollabFlag);
		bReadOK2 = m_pConfig->Read(_T("pt_collab_src_proj"), &tempCollabProjForSrcInputs);
		bReadOK3 = m_pConfig->Read(_T("pt_collab_tgt_proj"), &tempCollabProjForTgtExports);
		bReadOK4 = m_pConfig->Read(_T("pt_collab_free_trans_proj"), &tempCollabProjForFreeTransExports);
		bReadOK5 = m_pConfig->Read(_T("pt_collab_book_selected"), &tempCollabBookSelected);
		bReadOK6 = m_pConfig->Read(_T("pt_collab_by_chapter_only"), &bTempCollabByChapterOnly);
		bReadOK7 = m_pConfig->Read(_T("pt_collab_chapter_selected"), &tempCollabChapterSelected);
		bReadOK8 = m_pConfig->Read(_T("pt_collab_src_lang_name"), &tempCollabSourceLangName);
		bReadOK9 = m_pConfig->Read(_T("pt_collab_tgt_lang_name"), &tempCollabTargetLangName);
		bReadOK10 = m_pConfig->Read(_T("pt_collab_ai_proj_name"), &tempCollabAIProjectName);
		} // end wxLogNull block
		if (bReadOK && bTempCollabFlag != m_bCollaboratingWithParatext)
		{
			m_bCollaboratingWithParatext = bTempCollabFlag;

			if (bReadOK2 && tempCollabProjForSrcInputs != m_CollabProjectForSourceInputs)
			{
				m_CollabProjectForSourceInputs = tempCollabProjForSrcInputs;
			}
			if (bReadOK3 && tempCollabProjForTgtExports != m_CollabProjectForTargetExports)
			{
				m_CollabProjectForTargetExports = tempCollabProjForTgtExports;
			}
			if (bReadOK4 && tempCollabProjForFreeTransExports != m_CollabProjectForFreeTransExports)
			{
				m_CollabProjectForFreeTransExports = tempCollabProjForFreeTransExports;
			}
			if (bReadOK5 && tempCollabBookSelected != m_CollabBookSelected)
			{
				m_CollabBookSelected = tempCollabBookSelected;
			}
			if (bReadOK6 && bTempCollabByChapterOnly != m_bCollabByChapterOnly)
			{
				m_bCollabByChapterOnly = bTempCollabByChapterOnly;
			}
			if (bReadOK7 && tempCollabChapterSelected != m_CollabChapterSelected)
			{
				m_CollabChapterSelected = tempCollabChapterSelected;
			}
			if (bReadOK8 && tempCollabSourceLangName != m_CollabSourceLangName)
			{
				m_CollabSourceLangName = tempCollabSourceLangName;
			}
			if (bReadOK9 && tempCollabTargetLangName != m_CollabTargetLangName)
			{
				m_CollabTargetLangName = tempCollabTargetLangName;
			}
			if (bReadOK10 && tempCollabAIProjectName != m_CollabAIProjectName)
			{
				m_CollabAIProjectName = tempCollabAIProjectName;
			}
		}
	}

	// Read the BE related flags that were last stored in the Adapt_It_WX.ini file and restore
	// them if they differ from what was stored in the corresponding App's values (due to SHIFT-down
	// restart).
	tempCollabProjForSrcInputs = _T("");
	tempCollabProjForTgtExports = _T("");
	tempCollabProjForFreeTransExports = _T("");
	tempCollabBookSelected = _T("");
	bTempCollabByChapterOnly = TRUE;
	tempCollabChapterSelected = _T("");
	tempCollabSourceLangName = _T("");
	tempCollabTargetLangName = _T("");
	tempCollabAIProjectName = _T("");
	if (m_collaborationEditor == _T("Bibledit"))
	{
		{ // begin wxLogNull block
		wxLogNull logNo; // eliminates spurious message from the system
		bReadOK = m_pConfig->Read(_T("be_collaboration"), &bTempCollabFlag);
		bReadOK2 = m_pConfig->Read(_T("be_collab_src_proj"), &tempCollabProjForSrcInputs);
		bReadOK3 = m_pConfig->Read(_T("be_collab_tgt_proj"), &tempCollabProjForTgtExports);
		bReadOK4 = m_pConfig->Read(_T("be_collab_free_trans_proj"), &tempCollabProjForFreeTransExports);
		bReadOK5 = m_pConfig->Read(_T("be_collab_book_selected"), &tempCollabBookSelected);
		bReadOK6 = m_pConfig->Read(_T("be_collab_by_chapter_only"), &bTempCollabByChapterOnly);
		bReadOK7 = m_pConfig->Read(_T("be_collab_chapter_selected"), &tempCollabChapterSelected);
		bReadOK8 = m_pConfig->Read(_T("be_collab_src_lang_name"), &tempCollabSourceLangName);
		bReadOK9 = m_pConfig->Read(_T("be_collab_tgt_lang_name"), &tempCollabTargetLangName);
		bReadOK10 = m_pConfig->Read(_T("be_collab_ai_proj_name"), &tempCollabAIProjectName);
		} // end wxLogNull block
		if (bReadOK && bTempCollabFlag != m_bCollaboratingWithBibledit)
		{
			m_bCollaboratingWithBibledit = bTempCollabFlag;

			if (bReadOK2 && tempCollabProjForSrcInputs != m_CollabProjectForSourceInputs)
			{
				m_CollabProjectForSourceInputs = tempCollabProjForSrcInputs;
			}
			if (bReadOK3 && tempCollabProjForTgtExports != m_CollabProjectForTargetExports)
			{
				m_CollabProjectForTargetExports = tempCollabProjForTgtExports;
			}
			if (bReadOK4 && tempCollabProjForFreeTransExports != m_CollabProjectForFreeTransExports)
			{
				m_CollabProjectForFreeTransExports = tempCollabProjForFreeTransExports;
			}
			if (bReadOK5 && tempCollabBookSelected != m_CollabBookSelected)
			{
				m_CollabBookSelected = tempCollabBookSelected;
			}
			if (bReadOK6 && bTempCollabByChapterOnly != m_bCollabByChapterOnly)
			{
				m_bCollabByChapterOnly = bTempCollabByChapterOnly;
			}
			if (bReadOK7 && tempCollabChapterSelected != m_CollabChapterSelected)
			{
				m_CollabChapterSelected = tempCollabChapterSelected;
			}
			if (bReadOK8 && tempCollabSourceLangName != m_CollabSourceLangName)
			{
				m_CollabSourceLangName = tempCollabSourceLangName;
			}
			if (bReadOK9 && tempCollabTargetLangName != m_CollabTargetLangName)
			{
				m_CollabTargetLangName = tempCollabTargetLangName;
			}
			if (bReadOK10 && tempCollabAIProjectName != m_CollabAIProjectName)
			{
				m_CollabAIProjectName = tempCollabAIProjectName;
			}
		}
	}
	*/

	// whm added 7Jun11. If a User Workflow Profile was in effect at the time the user used
	// the SHIFT key to get the app going again, we would want the workflow related values
	// stored in Adapt_It_WX.ini to be restored, since it is likely to be accurate even if
	// the basic config file needs to be re-created from scratch (most likely due to errant
	// edits done by a user).
	// The basic config file value of concern is m_nWorkflowProfile.
	// Read the Work Profile related value that was last stored in the Adapt_It_WX.ini file
	// and restore it if it differs from what was stored in the corresponding App's
	// m_nWorkflowProfile value (due to SHIFT-down restart).
	bReadOK = FALSE;
	int nTempUserProfile = 0;
	{ // begin wxLogNull block
	wxLogNull logNo; // eliminates spurious message from the system
	bReadOK = m_pConfig->Read(_T("work_flow_profile"), &nTempUserProfile);
	} // end wxLogNull block
	if (bReadOK && nTempUserProfile != m_nWorkflowProfile)
	{
		m_nWorkflowProfile = nTempUserProfile;
	}

	// Restore the m_bAiSessionExpectsUserDefinedProfile flag to its administrator
	// set value. The value of the flag should be TRUE when m_nWorkflowProfile is
	// not 0 ("None"), FALSE otherwise (when m_nWorkflowProfile is 0).
	m_bAiSessionExpectsUserDefinedProfile = (m_nWorkflowProfile != 0);

	// restore the oldPath back to "/Recent_File_List"
	m_pConfig->SetPath(oldPath);


}

// the code here is called in two places (OnInit() and SetDefaults()) and so I've pulled
// it into a single function which can be called where needed
bool CAdapt_ItApp::DealWithThePossibilityOfACustomWorkFolderLocation() // BEW added 12Oct09
{
	wxString customPathFilename = _T("CustomWorkFolderLocation"); // must NOT be localizable
	wxString aPath = m_workFolderPath + PathSeparator + customPathFilename;

	wxLogNull logNo; // avoid spurious messages from the system

	bool bIsCustomLocationPersistent = ::FileExists(aPath);
	if (bIsCustomLocationPersistent)
	{
		bool bUseAndLockedFlagsShouldBeSet = TRUE;

		// check for a file with no content, or locked by another process
		wxFileName fnAttributes(aPath);
		wxULongLong itsSize = fnAttributes.GetSize();
		wxULongLong invalidSize = wxInvalidSize;
		if (itsSize == 0 || itsSize == invalidSize)
		{
			if (itsSize == 0)
			{
				// can't proceed with an empty path, so warn user tell him to locate the work
				// folder using a file browser, then to type the correct path into the file
				// CustomWorkFolderLocation, and then re-launch (Returning FALSE will force
				// a call to abort())
				wxMessageBox(_T(
					"The CustomWorkFolderLocation file is empty, but it should contain the path to the custom work folder. Aborting now. To recover: (1) Outside of Adapt It use a file browser to find where your custom work folder is located, then (2) in a text editor, type the path to that custom work folder into the CustomWorkFolderLocation, (3) save the file where it currently is (in the default work folder), and then (4) re-launch Adapt It."),
				_("Error of file named CustomWorkFolderLocation"), wxICON_ERROR);
				LogUserAction(_T("Error of file named CustomWorkFolderLocation - file is empty"));
				return FALSE;
			}
			else
			{
				// Open in another process, tell user to halt the other process & relaunch
				// (Return FALSE to force caller to call abort(). SetDefaults() will also
				// check for a returned FALSE and likewise abort)
				wxMessageBox(_T(
"Another running process has the file named CustomWorkFolderLocation open, and so that file is locked and Adapt It is unable to use it until you halt that other process. Aborting now. Halt the other process, then re-launch Adapt It."),
				_("Error of file named CustomWorkFolderLocation"), wxICON_ERROR);
				LogUserAction(_T("Error of file named CustomWorkFolderLocation - another process has the file open"));
				return FALSE;
			}
		}

		// a failure to open the CustomWorkFolderLocation file will leave a file specification
		// of that name on disk, with no size, and so we don't want valuable evidence wiped out,
		// so we here create a renamed clone first, and destroy it if we get the original file
		// open without error, but if not, then we remove the empty file and rename the clone
		// to be the original filename before aborting
		wxString strOriginalFile = aPath;
		wxString strRenamedFile = strOriginalFile + _T("_"); // append an underscore
		bool bOK = ::wxCopyFile(strOriginalFile,strRenamedFile,TRUE); // TRUE = overwrite
						// if it exists already; ignore returned bool, we assume it will work
		// if the copy fails, no big deal, we can leave the file spec there & the administrator
		// can take manual corrective steps to set it up again properly - unlikely to
		// happen though (note: the return of FALSE causes abort() to be called)
		wxCHECK_MSG(bOK, FALSE, _T("DealWithThePossibilityOfACustomWorkFolderLocation(): ::wxCopyFile() failed, line 27,003 in Adapt_It.cpp"));

		wxTextFile f;
		bool bOpenedOK = f.Open(aPath);
		// should open ok, if not, tell the developer & abort
		if (bOpenedOK)
		{
			bOK = ::wxRemoveFile(strRenamedFile);
		}
		else
		{
			// since we've already verified that there is something in the
			// CustomWorkFolderLocation file and that file is not locked, there ought to
			// be no problem getting it open; so this failure can be an English message
			// and then abort, because the fix required would be a developer issue
			f.Close(); // don't bother with the returned boolean
			bOK = ::wxRenameFile(strRenamedFile,strOriginalFile,TRUE); // overwrites
					// strOriginalFile with contents of strRenamedFile but gives the
					// resulting file the name strOriginalFile
			wxMessageBox(_T(
"DealWithThePossibilityOfACustomWorkFolderLocation(): Failed to open the CustomWorkFolderLocation file at default work folder location, and that file is neither locked nor empty. Aborting..."),
			_T("Error of file named CustomWorkFolderLocation"), wxICON_ERROR);
			LogUserAction(_T("Error of file named CustomWorkFolderLocation - failed to open at default work folder location"));
			wxCHECK_MSG(bOK, FALSE, _T("DealWithThePossibilityOfACustomWorkFolderLocation(): ::wxRenameFile() failed, line 27,026 in Adapt_It.cpp"));
			return FALSE; // forces caller to call abort()
		}
		// get the first line (path is to be in first line, if there is any text in
		// subsequent lines it is to be treated as a comment and ignored, so the
		// administrator or user can add something there which may be helpful as a memory
		// aid if so desired)
		m_customWorkFolderPath = f.GetFirstLine();
		f.Close(); // don't bother with the returned boolean

		bool bDirectoryExists = ::wxDirExists(m_customWorkFolderPath);
		if (!bDirectoryExists)
		{
			// this normally doesn't fail, but it will certainly fail if the user at
			// an earlier session set up a custom work folder on an external (removable)
			// drive and made it persistant there, but then unmounted the drive before
			// the current launch, or while working -- so because these possibilities are
			// real, we need to give the user a chance to recover
			wxString str;
			str = str.Format(_(
"Adapt It did not find your work folder at\n   %s\nThis error will occur either \n1. because your work folder is located on an external drive which is not currently plugged in, or \n2. because there is a typing error in the work folder path stored in the file named CustomWorkFolderLocation, or \n3. another application currently has the CustomWorkFolderLocation file open. \nYou will have a chance to recover now."),
			m_customWorkFolderPath.c_str());
			wxMessageBox(str, _("Failed to find the custom work folder"), wxICON_ERROR);
			enum ActionChoices {
				cancelled = -1,
				plugInDriveAndRetry = 0,
				editCustomWorkFolderLocationFile,
				ignoreCustomLocation,
				ignoreCustomLocationAndForceAdminMenuOpen
			};
			wxString choices[4];
			choices[0] = _("1. Plug in the missing external drive, then click OK here.");
			choices[1] = _("2. Close the other application, or use a text editor to fix the path in the file CustomWorkFolderLocation; then click OK here.");
			choices[2] = _("3. Ignore the custom work folder location, use the default location instead. (Then ask your administrator to help you.)");
			choices[3] = _("4. Forget the custom work folder location. The command Custom Work Folder Location will then run, use it to relocate the folder.");
			wxString myCaption = _("Choose Recovery Action or Cancel (to abort)");
			wxString message = _("Select from the list of recovery actions, then click OK. The Cancel button will abort the application. \n1. Plug in the required external drive now, then click OK. \n2. Leave the dialog open, launch a text editor, open the CustomWorkFolderLocation file in it, edit the path, save, then click OK here. \n3. Forget (but do not delete) the custom work folder location, use the default location instead. \n4. Same as option 3. but also show the Administrator menu (helpful if you know what to do with it).");
			int returnValue = wxGetSingleChoiceIndex(
				message,myCaption,4,choices,gpApp->m_pMainFrame);
			switch (returnValue)
			{
			case plugInDriveAndRetry:
				{
					// assume the missing drive has been mounted, so try the code from
					// the beginning of DealWithThePossibilityOfACustomWorkFolderLocation()
					// again, and if it succeeds then we've successfully recovered
					bDirectoryExists = ::wxDirExists(m_customWorkFolderPath);
					if (!bDirectoryExists)
					{
						wxMessageBox(_(
"The path to the custom work folder did not find a directory with the required name. Did you plug in the external drive containing the work folder before clicking OK in the dialog? Aborting now. Make the custom work folder's location accessible on your machine before you re-launch Adapt It."),
						_("Recovery By Plugging In The Missing External Drive Failed"), wxICON_ERROR);
						LogUserAction(_T("Recovery By Plugging In The Missing External Drive Failed"));
						return FALSE; // let caller do the abort() call
					}
					break;
				}
			case editCustomWorkFolderLocationFile:
				{
					// assume the bad directory path specification has been edited and the
					// CustomWorkFolderLocation file resaved where it is, or if the file was open
					// then the user has closed it; and so try the code from
					// the beginning of DealWithThePossibilityOfACustomWorkFolderLocation()
					// again, and if it succeeds then we've successfully recovered
					wxString strOriginalFile = aPath;
					wxString strRenamedFile = strOriginalFile + _T("_"); // append an underscore
					bool bOK = ::wxCopyFile(strOriginalFile,strRenamedFile,TRUE); // TRUE = overwrite
					wxCHECK_MSG(bOK, FALSE, _T("DealWithThePossibilityOfACustomWorkFolderLocation(): ::wxCopyFile() failed, line 27,099 in Adapt_It.cpp"));
					wxTextFile f;
					bool bOpenedOK = f.Open(aPath);
					// should open ok, if not, tell the user & abort
					if (bOpenedOK)
					{
						bOK = ::wxRemoveFile(strRenamedFile);
					wxCHECK_MSG(bOK, FALSE, _T("DealWithThePossibilityOfACustomWorkFolderLocation(): ::wxCopyFile() failed, line 27,099 in Adapt_It.cpp"));
						m_customWorkFolderPath = f.GetFirstLine();
						f.Close(); // don't bother with the returned boolean
					}
					else
					{
						f.Close(); // don't bother with the returned boolean
						bOK = ::wxRenameFile(strRenamedFile,strOriginalFile,TRUE);
						wxMessageBox(_(
"Failed to open the CustomWorkFolderLocation file at default work folder location. Is the CustomWorkFolderLocation file still open in another application? Is the path within it an incorrect path to the custom work folder on your machine? Check and fix such errors before you re-launch Adapt It. Aborting now."),
						_("Error of file named CustomWorkFolderLocation"), wxICON_ERROR);
						LogUserAction(_T("Error of file named CustomWorkFolderLocation - file still oper or incorrect path"));
						wxCHECK_MSG(bOK, FALSE, _T("DealWithThePossibilityOfACustomWorkFolderLocation(): ::wxRenameFile() failed, line 27,114 in Adapt_It.cpp"));
						return FALSE; // forces caller to call abort()
					}
					// now check if the stored folder path string yields a valid directory
					bDirectoryExists = ::wxDirExists(m_customWorkFolderPath);
					if (!bDirectoryExists)
					{
						wxMessageBox(_(
"The path to the custom work folder did not find a directory with the required name. Did you check the path specification using a file browser, to make sure your edit of the path in the CustomWorkFolderLocation file resulted in a correct path to the custom work folder? Aborting now. Use a text editor again to get the path typed correctly before you re-launch Adapt It."),
						_("Recovery By Editing The Path Specificiation Failed"), wxICON_ERROR);
						LogUserAction(_T("Recovery By Editing The Path Specificiation Failed"));
						return FALSE; // let caller do the abort() call
					}
					break;
				}
			case ignoreCustomLocation:
				{
					// remove the CustomWorkFolderLocation file, because if we don't
					// then the same failure could occur on next launch -- since we
					// cannot assume that a naive user will have taken any action
					// to sort out what the problem with the file's contents was
					bOK = wxRemoveFile(aPath); // assume it worked, ignore returned value
					m_bUseCustomWorkFolderPath = FALSE;
					m_bLockedCustomWorkFolderPath = FALSE;
					m_customWorkFolderPath.Empty();
					bIsCustomLocationPersistent = FALSE;
					// the above four lines ensure the app initialization proceeds
					// from this point as if the work folder is the default one -
					// this always exists, but it may have no project folders in it,
					// so this option could be unhelpful. Recovery would require an
					// administrator to re-locate the custom work folder by using the
					// Administrator menu command "Custom Work Folder Location" on
					// relaunch
					bUseAndLockedFlagsShouldBeSet = FALSE; // suppress flag setting below
					break;
				}
			case ignoreCustomLocationAndForceAdminMenuOpen:
				{
					// remove the CustomWorkFolderLocation file, because if we don't
					// then the same failure could occur on next launch -- since we
					// cannot assume that a naive user will have taken any action
					// to sort out what the problem with the file's contents was
					bOK = wxRemoveFile(aPath); // assume it worked, ignore returned value
					m_bUseCustomWorkFolderPath = FALSE;
					m_bLockedCustomWorkFolderPath = FALSE;
					m_customWorkFolderPath.Empty();
					bIsCustomLocationPersistent = FALSE;
					// the above four lines ensure the app initialization proceeds
					// from this point as if the work folder is the default one -
					// this always exists, but it may have no project folders in it,
					// however. The Administrator menu will not be made visible, but
					// nevertheless we now drop straight into the function which
					// OnCustomWorkFolderLocation() calls, which allows the user to
					// do a once-only navigation to where he believes the work folder
					// to be. Then on exit we unilaterally call the handler for the
					// Lock Custom Location command, to make the chosen folder path
					// be stored in a newly created CustomWorkFolderLocation file stored
					// in the default work folder
					// administrator to re-locate the custom work folder by using the
					// Administrator menu command "Custom Work Folder Location" on
					// relaunch; on exit from the switch, two flags are redundantly
					// reset TRUE, and then control passes on - having 'recovered'
					// (provided the user chose the correct folder!)
					bool bSucceeded = SetupCustomWorkFolderLocation(); // let user search
					if (bSucceeded)
					{
						wxCommandEvent dummy; // needed for signature, not used internally
						OnLockCustomLocation(dummy);
						// since the above code is being called from OnInit() or SetDefaults(),
						// in other case control will enter the Start Working Wizard and
						// so the projects in the custom work folder location should be
						// accessible now (a way to test this is to set up a custom work
						// folder on a thumb drive, then close AI, remove the thumb drive,
						// launch AI, and when the recovery messages are visible, plug in
						// the thumb drive but choose option 4 above, rather than option 1;
						// option 4 is more circuituous, but should get to the same result)
					}
					else
					{
						// user may have cancelled, or something unexpected went wrong; so
						// the appropriate thing to do is to abort. May need administrator
						// to intervene to set the user up again, after determining just why
						// his access to the custom work folder location got lost.
						wxMessageBox(_(
"You did not succeed in locating the work folder location. Aborting now. Next time you launch, you or your administrator will need to use the Administrator menu to locate the required work folder."),
						_("One chance to relocate the work folder failed"), wxICON_ERROR);
						LogUserAction(_T("One chance to relocate the work folder failed. Aborting..."));
						// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
						wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
						return FALSE;
					}
					break;
				}
			default:
			case cancelled:
				{
					// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
					wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
					return FALSE;
					break;
				}
			}
		} // end of TRUE block for test:  if (!bDirectoryExists)

		// the custom work folder exists, so commit to it, provided the setting of
		// the flags has not be turned off in the switch above
		if (bUseAndLockedFlagsShouldBeSet)
		{
			m_bUseCustomWorkFolderPath = TRUE;
			m_bLockedCustomWorkFolderPath = TRUE;
		}
	} // end of TRUE block for test: if (bIsCustomLocationPersistent)


	// in case the user is using a copied (ie. 'foreign') basic configuration file from
	// some else's adaptation work on another machine, check and fix any bad path names
	// (actually, only 5 of them need to be potentially fixed, the others won't crash
	// anything because of fail-safe code elsewhere in the app)
	wxString configFName = szBasicConfiguration + _T(".aic");
	wxString adminConfigFName = szAdminBasicConfiguration + _T(".aic");
	if (bIsCustomLocationPersistent && !m_customWorkFolderPath.IsEmpty())
	{
 		// we do expect a basic config file to be located ready for us at the custom work
		// folder location; but if for any reason one is not found there, we don't want to
		// abort the app, instead, we will just warn the user that one was not found, and
		// call SetDefaults() to set up default basic config values. The user will then
		// need to perhaps do a little fiddling later in Preferences to restore his desired
		// settings, but at least when he next exits the app, a valid basic config file will
		// be written to the custom location for use in subsequent launches
		wxString aPathToFile = m_customWorkFolderPath + PathSeparator + configFName;
		bool bConfigFileExists = ::wxFileExists(aPathToFile);
		if (!bConfigFileExists)
		{
			// probably a path error... so take an alternate route
			SetDefaults(FALSE); // FALSE = bAllowCustomLocationCode (we want suppression)

			// having set the default parameters with a SetDefaults() call, we must not let
			// OnInit() subsequently call GetBasicConfiguration(), because the latter
			// would fail due to a path error; we can suppress the call by the following
			// line
			m_bSkipBasicConfigFileCall = TRUE;
			return TRUE;
		}

	   // ultimately, the custom work folder location could have been locked down, and if so,
		// then the basic config file will have its location, and m_bUseCustomWorkFolderPath
		// will have been set TRUE and so too will m_bLockedCustomWorkFolderPath be set TRUE if
		// there is a file called "CustomWorkFolderPath" in the default work folder location,
		// but FALSE if not - so two conditions are needed in order to use the custom location
		// here for initialization
		if (m_bLockedCustomWorkFolderPath && m_bUseCustomWorkFolderPath)
		{
			// the custom location is persistent
			MakeForeignBasicConfigFileSafe(configFName,m_customWorkFolderPath,&adminConfigFName);
		}
		else
		{
			// must be a non-persistent custom location, for that we always look in
			// the default location for the basic config file
			MakeForeignBasicConfigFileSafe(configFName,m_workFolderPath,&adminConfigFName);
		}
	}
	else
	{
		// using default location, for that we always look in
		// the default location for the basic config file
		MakeForeignBasicConfigFileSafe(configFName,m_workFolderPath,&adminConfigFName);
	}
	m_bSkipBasicConfigFileCall = FALSE;
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pf   <- pointer to the wxTextFile that is being written as the
///                     config file
/// \remarks
/// Called from: the App's WriteConfigurationFile().
/// Writes the project settings part of a project configuration file. The text file is
/// opened by the caller.
/// BEW modified 17Aug09 & removed modification on 19Aug09 for following reason:
/// When administrator navigates to a custom work folder location and enters someone
/// else's project folder there, the administrator could make changes to the project -
/// such as turning on book folder mode and moving some or all documents to book folders.
/// If such changes were stored in a separate AI-AdminProjectConfiguration.aic file, so
/// that the other user's AI-ProjectConfiguration.aic file remains unchanged, then the
/// other user (who typically would not be an administrator), could when next time that
/// project or work folder is checked out to a machine which he uses, suddenly find that
/// some of all of his documents have mysteriously "disapeared" and he may not realize
/// he'd need to turn book folder mode on, in fact, the administrator's setup may preclude
/// him from having the option to change to book folder mode. Therefore, any changes
/// affecting the project's config file (such as path changes due to the administrator
/// doing things, such as exports or imports to kb, etc) will need to be reflected in the
/// project config file that the other person will be accessing - ie, in
/// AI-ProjectConfiguration.aic. Changed paths are not a problem in project config files
/// because the app, if any path is not present on the person's machine, will detect the
/// fact and not crash, but will instead substitute a safe default folder's path -
/// typically the project folder's path.
/// Also, because we don't allow immediate entry to administrator-enabled mode when the
/// app is launched by anybody, there is no need to store the flag or custom path that was
/// last used, in a config file - whether basic config file or project one. The only
/// administrator config file that gets set up is AI-AdminBasicConfiguration.aic, and it
/// is required in order that MakeForeignConfigFileSafe() can set correct key paths for
/// accessing the work folder contents at the custom location. This admin config file is
/// destroyed and recreated at each access to a give custom work folder location. There is
/// therefore no reason to version it in a DVCS system, because the "other person" will
/// never get access to it (since he's not an administrator), and even if he was an
/// administrator, it's presence would go unnoticed most likely (except if he used a file
/// manager to see what was in his work folder). So the DVCS system can just ignore the
/// AI-AdminBasicConfiguration.aic file.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::WriteProjectSettingsConfiguration(wxTextFile* pf)
{
	// wx version combines ANSI and UNICODE parts in common to simplify this function
	wxString data = _T("");
	wxString tab = _T("\t");
	wxString number;

	data.Empty();
	data << szSourceLanguageName << tab << m_sourceName;
	pf->AddLine(data);

	data.Empty();
	data << szTargetLanguageName << tab << m_targetName;
	pf->AddLine(data);

	data.Empty();
	data << szGlossesLanguageName << tab << m_glossesName;
	pf->AddLine(data);

	data.Empty();
	data << szSourceLanguageCode << tab << m_sourceLanguageCode;
	pf->AddLine(data);

	data.Empty();
	data << szTargetLanguageCode << tab << m_targetLanguageCode;
	pf->AddLine(data);

	data.Empty();
	data << szGlossesLanguageCode << tab << m_glossesLanguageCode;
	pf->AddLine(data);

	wxString strCollabValueToUse; // this is reused below for each of the wxString value settings

	/*
	// whm added 17Feb12
	if (!m_SavedCurProjectName.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_curProjectName that was forced by the -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCurProjectName will be a string value that was actually read
		// from the basic config file.
		strCollabValueToUse = m_SavedCurProjectName;
	}
	else
	{
		// The value of m_SavedCollabProjectForSourceInputs is empty meaning that it was not
		// overridden by a -ai_proj command-line switch. In this case
		// save the current session value of the App's m_curProjectName.
		strCollabValueToUse = m_curProjectName;
	}
	data.Empty();
	data << szCurProjectName << tab << strCollabValueToUse;
	pf->AddLine(data);

	// whm 26Jan12 added
	if (!m_SavedCurProjectPath.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_curProjectPath that was forced by the -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCurProjectPath will be a string value that was actually read
		// from the basic config file.
		strCollabValueToUse = m_SavedCurProjectPath;
	}
	else
	{
		// The value of m_SavedCurProjectPath is empty meaning that it was not
		// overridden by a -ai_proj command-line switch. In this case
		// save the current session value of the App's m_curProjectPath.
		strCollabValueToUse = m_curProjectPath;
	}
	data.Empty();
	data << szCurLanguagesPath << tab << strCollabValueToUse;
	pf->AddLine(data);
	*/

	// m_last...Path values below
	data.Empty();
	data << szLastDocPath << tab << m_lastDocPath; // whm 6Aug 11 moved here from basic config file
	pf->AddLine(data);

	data.Empty();
	data << szLastSourceInputPath << tab << m_lastSourceInputPath;
	pf->AddLine(data);

	data.Empty();
	data << szLastInterlinearRTFOutputPath << tab << m_lastInterlinearRTFOutputPath;
	pf->AddLine(data);

	data.Empty();
	data << szLastSourceOutputPath << tab << m_lastSourceOutputPath; // whm 6Aug 11 moved here from basic config file
	pf->AddLine(data);

	data.Empty();
	data << szLastSourceRTFOutputPath << tab << m_lastSourceRTFOutputPath; // whm 6Aug 11 moved here from basic config file
	pf->AddLine(data);

	data.Empty();
	data << szLastTargetOutputPath << tab << m_lastTargetOutputPath; // use the new LastTargetExportPath label from 6.x.x on
	pf->AddLine(data);

	data.Empty();
	data << szLastTargetRTFOutputPath << tab << m_lastTargetRTFOutputPath;
	pf->AddLine(data);

	data.Empty();
	data << szLastGlossesOutputPath << tab << m_lastGlossesOutputPath;
	pf->AddLine(data);

	data.Empty();
	data << szLastGlossesRTFOutputPath << tab << m_lastGlossesRTFOutputPath;
	pf->AddLine(data);

	data.Empty();
	data << szLastFreeTransOutputPath << tab << m_lastFreeTransOutputPath;
	pf->AddLine(data);

	data.Empty();
	data << szLastFreeTransRTFOutputPath << tab << m_lastFreeTransRTFOutputPath;
	pf->AddLine(data);

	data.Empty();
	data << szFoldersProtectedFromNavigation << tab << m_foldersProtectedFromNavigation;
	pf->AddLine(data);

#ifndef _UNICODE
	// ANSI
	wxString s;
	PunctPairsToString(m_punctPairs,s);
	data.Empty();
	data << szPunctPairs << tab << s;
	pf->AddLine(data);

	TwoPunctPairsToString(m_twopunctPairs,s);
	data.Empty();
	data << szTwoPunctPairs << tab << s;
	pf->AddLine(data);
#else
	// UNICODE
	// From version 2.3.0 we no longer write out the encoding ID
	// value for the punctuation fields
	wxString src;
	wxString tgt;
	PunctPairsToTwoStrings(m_punctPairs,src,tgt);

	data.Empty();
	data << szPunctPairsSrc << tab << src;
	pf->AddLine(data);

	data.Empty();
	data << szPunctPairsTgt << tab << tgt;
	pf->AddLine(data);

	TwoPunctPairsToTwoStrings(m_twopunctPairs,src,tgt);

	data.Empty();
	data << szTwoPunctPairsSrc << tab << src;
	pf->AddLine(data);

	data.Empty();
	data << szTwoPunctPairsTgt << tab << tgt;
	pf->AddLine(data);
#endif // _UNICODE

	data.Empty();
	data << szSpecialTextColor << tab <<  WxColour2Int(m_specialTextColor);
	pf->AddLine(data);

	data.Empty();
	data << szReTranslnTextColor << tab << WxColour2Int(m_reTranslnTextColor);
	pf->AddLine(data);

	data.Empty();
	data << szTgtDiffsTextColor << tab << WxColour2Int(m_tgtDiffsTextColor);
	pf->AddLine(data);

	data.Empty();
	data << szNavTextColor << tab <<  WxColour2Int(m_navTextColor);
	pf->AddLine(data);

	// whm 6Aug11 moved here from the basic config file
	data.Empty();
	data << szAutoInsertionsHighlightColor << tab
			<< WxColour2Int(m_AutoInsertionsHighlightColor);
	pf->AddLine(data);

	// whm 6Aug11 moved here from the basic config file
	data.Empty();
	data << szGuessHighlightColor << tab
			<< WxColour2Int(m_GuessHighlightColor); // whm added 1Nov10
	pf->AddLine(data);
	if (m_bBackupDocument)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szBackupDocument << tab << number;
	pf->AddLine(data);

	// whm added 3Sep10 for user workflow profile support
	// whm modified 15Feb12 to deal with the case in which an administrator
	// has toggled on the "Temporarily restore all default user profile items..."
	// menu item on the Administrator menu.
	// If the AI session was set by the config file to have a user profile other
	// than "None" we need to restore the value of m_nWorkflowProfile
	// to its value that it was before the temporary state was set to show all
	// menu items. When the value of the m_bAiSessionExpectsUserDefinedProfile flag
	// is TRUE at this point, we need to assign m_nWorkflowProfile with the temporary
	// value in we saved in m_nTempWorkflowProfile - as long as m_nTempWorkflowProfile
	// isn't undefined (-1).
	if (m_nTempWorkflowProfile != -1 && m_bAiSessionExpectsUserDefinedProfile)
	{
		m_nWorkflowProfile = m_nTempWorkflowProfile;
	}
	data.Empty();
	data << szWorkflowProfile << tab << m_nWorkflowProfile;
	pf->AddLine(data);

	// whm 17Feb12 added collaboration-related settings below to the project config file.

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	// whm added 15Apr11 for Paratext/Bibledit collaboration
	// whm modified 17Jan12 most of the collaboration-related values below to restore
	// the App's collaboration settings to their previous settings as were contained
	// in the basic config file when session started. This restores the App for the next
	// run to what it was before the command-line switches were used, and hence the use
	// of the command-line switches for some launcher icons won't disturb any sessions
	// that are run on the same computer without employing any command-line switches.
	int nCollabValueToUse; // this is reused below for each of the int value settings
	if (m_nSavedCollabPTSetting != -1)
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_bCollaboratingWithParatext that was forced by the -collab_on or -collab_off switch at
		// the command-line. In the forced collab mode situation the value of
		// m_nSavedCollabPTSetting will be 0 or 1 reflecting what was
		// actually read from the basic config file.
		nCollabValueToUse = m_nSavedCollabPTSetting;
	}
	else
	{
		// The value of m_nSavedCollabPTSetting is -1 meaning that it was not
		// overridden by a -collab_on or -collab_off command-line switch. In this case save the current
		// session value of the App's m_bCollaboratingWithParatext (cast to an int of
		// 1 or 0).
		nCollabValueToUse = (int)m_bCollaboratingWithParatext;
	}
	*/
	if (m_bCollaboratingWithParatext) //if (nCollabValueToUse == 1) //
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollaboratingWithParatext << tab << number;
	pf->AddLine(data);

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	// whm added 15Apr11 for Bibledit collaboration
	if (m_nSavedCollabBESetting != -1)
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_bCollaboratingWithBibledit that was forced by the -collab_on or -collab_off switch at
		// the command-line. In the forced collab mode situation the value of
		// m_nSavedCollabBESetting will be 0 or 1 reflecting what was
		// actually read from the basic config file.
		nCollabValueToUse = m_nSavedCollabBESetting;
	}
	else
	{
		// The value of m_nSavedCollabBESetting is -1 meaning that it was not
		// overridden by a -collab_on or -collab_off command-line switch. In this case save the current
		// session value of the App's m_bCollaboratingWithBibledit (cast to an int of
		// 1 or 0).
		nCollabValueToUse = (int)m_bCollaboratingWithBibledit;
	}
	*/
	// whm added 15Apr11 for Bibledit collaboration
	if (m_bCollaboratingWithBibledit) //if (nCollabValueToUse == 1) //
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollaboratingWithBibledit << tab << number;
	pf->AddLine(data);

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	// whm 23Jan11 added
	if (!m_SavedCollabProjectForSourceInputs.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabProjectForSourceInputs that was forced by the -collab_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabProjectForSourceInputs will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabProjectForSourceInputs;
	}
	else
	{
		// The value of m_SavedCollabProjectForSourceInputs is empty meaning that it was not
		// overridden by a -collab_proj command-line switch. In this case
		// save the current session value of the App's m_CollabProjectForSourceInputs.
		strCollabValueToUse = m_CollabProjectForSourceInputs;
	}
	*/
	data.Empty();
	data << szCollabProjectForSourceInputs << tab << m_CollabProjectForSourceInputs; //strCollabValueToUse;
	pf->AddLine(data);

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	// whm 23Jan11 added
	if (!m_SavedCollabProjectForTargetExports.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabProjectForTargetExports that was forced by the -collab_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabProjectForTargetExports will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabProjectForTargetExports;
	}
	else
	{
		// The value of m_SavedCollabProjectForTargetExports is empty meaning that it was not
		// overridden by a -collab_proj command-line switch. In this case
		// save the current session value of the App's m_CollabProjectForTargetExports.
		strCollabValueToUse = m_CollabProjectForTargetExports;
	}
	*/
	data.Empty();
	data << szCollabProjectForTargetExports << tab << m_CollabProjectForTargetExports; //strCollabValueToUse;
	pf->AddLine(data);

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	// whm 23Jan11 added
	if (!m_SavedCollabProjectForFreeTransExports.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabProjectForFreeTransExports that was forced by the -collab_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabProjectForFreeTransExports will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabProjectForFreeTransExports;
	}
	else
	{
		// The value of m_SavedCollabProjectForFreeTransExports is empty meaning that it was not
		// overridden by a -collab_proj command-line switch. In this case
		// save the current session value of the App's m_CollabProjectForFreeTransExports.
		strCollabValueToUse = m_CollabProjectForFreeTransExports;
	}
	*/
	data.Empty();
	data << szCollabProjectForFreeTransExports << tab << m_CollabProjectForFreeTransExports; //strCollabValueToUse;
	pf->AddLine(data);

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	if (!m_SavedCollabAIProjName.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabAIProjectName that was forced by the -collab_proj and/or -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabAIProjName will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabAIProjName;
	}
	else
	{
		// The value of m_SavedCollabAIProjName is empty meaning that it was not
		// overridden by a -collab_proj and/or -ai_proj command-line switch. In this case
		// save the current session value of the App's m_CollabAIProjectName.
		strCollabValueToUse = m_CollabAIProjectName;
	}
	*/
	data.Empty();
	data << szCollabAIProjectName << tab << m_CollabAIProjectName; //strCollabValueToUse;
	pf->AddLine(data);

	if (m_collaborationEditor.IsEmpty())
	{
		// We don't want to write out an empty value for the CollaborationEditor field.
		// If m_collaborationEditor is empty at this point, supply a reasonable default -
		// the same default as supplied in OnInit().
		if (m_bParatextIsInstalled)
		{
			 m_collaborationEditor = _T("Paratext"); // default editor
		}
		else if (m_bBibleditIsInstalled)
		{
			 m_collaborationEditor = _T("Bibledit"); // don't localize
		}
	}
	data.Empty();
	data << szCollaborationEditor << tab << m_collaborationEditor; // whm added 4Apr12
	pf->AddLine(data);

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	// whm 23Jan11 added
	if (!m_SavedCollabSourceLangName.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabSourceLangName that was forced by the -collab_proj and/or -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabSourceLangName will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabSourceLangName;
	}
	else
	{
		// The value of m_SavedCollabSourceLangName is empty meaning that it was not
		// overridden by a -collab_proj and/or -ai_proj command-line switch. In this case
		// save the current session value of the App's m_CollabSourceLangName.
		strCollabValueToUse = m_CollabSourceLangName;
	}
	*/
	data.Empty();
	data << szCollabSourceLangName << tab << m_CollabSourceLangName; //strCollabValueToUse;
	pf->AddLine(data);

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	// whm 23Jan11 added
	if (!m_SavedCollabTargetLangName.IsEmpty())
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_CollabTargetLangName that was forced by the -collab_proj and/or -ai_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_SavedCollabTargetLangName will be a string value that was actually read
		// from the basic config file..
		strCollabValueToUse = m_SavedCollabTargetLangName;
	}
	else
	{
		// The value of m_SavedCollabTargetLangName is empty meaning that it was not
		// overridden by a -collab_proj and/or -ai_proj command-line switch. In this case
		// save the current session value of the App's m_CollabTargetLangName.
		strCollabValueToUse = m_CollabTargetLangName;
	}
	*/
	data.Empty();
	data << szCollabTargetLangName << tab << m_CollabTargetLangName; //strCollabValueToUse;
	pf->AddLine(data);

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	/*
	if (m_nSavedCollabExpectsFreeTrans != -1)
	{
		// Save the value that was read from the basic config file, rather than whatever value
		// of m_bCollaborationExpectsFreeTrans that was forced by the -collab_proj switch at
		// the command-line. In the forced collab mode situation the value of
		// m_nSavedCollabExpectsFreeTrans will be 0 or 1 reflecting what was
		// actually read from the basic config file.
		nCollabValueToUse = m_nSavedCollabExpectsFreeTrans;
	}
	else
	{
		// The value of m_nSavedCollabExpectsFreeTrans is -1 meaning that it was not
		// overridden by a -collab_proj command-line switch. In this case save the current
		// session value of the App's m_bCollaborationExpectsFreeTrans (cast to an int of
		// 1 or 0).
		nCollabValueToUse = (int)m_bCollaborationExpectsFreeTrans;
	}
	*/
	if (m_bCollaborationExpectsFreeTrans) //if (nCollabValueToUse) // whm added 9Aug11
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollabExpectsFreeTrans << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szCollabBookSelected << tab << m_CollabBookSelected;
	pf->AddLine(data);

	if (m_bCollabByChapterOnly)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollabByChapterOnly << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szCollabChapterSelected << tab << m_CollabChapterSelected;
	pf->AddLine(data);

	/*
	if (m_bPwdProtectCollabSwitching)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szCollabSwitchingPasswordProtected << tab << number; // whm added 2Feb12
	pf->AddLine(data);

	data.Empty();
	data << szCollabSwitchingPassword << tab << m_collabSwitchingPassword; // whm added 2Feb12
	pf->AddLine(data);
	// whm 17Feb12 added above collaboration-related settings to the project config file
	*/

	// whm added next three for Guesser support
	data.Empty();
	if (m_bUseAdaptationsGuesser)
		number = _T("1");
	else
		number = _T("0");
	data << szUseAdaptationsGuesser << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szGuessingLevel << tab << m_nGuessingLevel;
	pf->AddLine(data);

	data.Empty();
	if (m_bAllowGuesseronUnchangedCCOutput)
		number = _T("1");
	else
		number = _T("0");
	data << szAllowCConUnchangedGuesserOutput << tab << number;
	pf->AddLine(data);

	if (m_bRTL_Layout)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szRTL_Layout << tab << number;
	pf->AddLine(data);

	// whm removed 8Aug11 from config file - not used since version 3
	//data.Empty();
	//data <<	szSFMescapechar << tab;
	//data << gSFescapechar;
	//pf->AddLine(data);

	// BEW 8Jun10, removed support for checkbox "Recognise standard format
	// markers only following newlines"
	//if (gbSfmOnlyAfterNewlines)
	//	number = _T("1");
	//else
		number = _T("0"); // now always is FALSE
	data.Empty();
	data << szSFMafterNewlines << tab << number;
	pf->AddLine(data);

#ifdef _RTL_FLAGS

	if (m_bSrcRTL)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szRTLSource << tab << number;
	pf->AddLine(data);

	if (m_bTgtRTL)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szRTLTarget << tab << number;
	pf->AddLine(data);

	if (m_bNavTextRTL)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szRTLNavText << tab << number;
	pf->AddLine(data);

#endif // _RTL_FLAGS

	// now for the auto-capitalization stuff
	data.Empty();
	data << szLowerCaseSourceChars << tab << m_srcLowerCaseChars;
	pf->AddLine(data);

	data.Empty();
	data << szUpperCaseSourceChars << tab << m_srcUpperCaseChars;
	pf->AddLine(data);

	data.Empty();
	data << szLowerCaseTargetChars << tab << m_tgtLowerCaseChars;
	pf->AddLine(data);

	data.Empty();
	data << szUpperCaseTargetChars << tab << m_tgtUpperCaseChars;
	pf->AddLine(data);

	data.Empty();
	data << szLowerCaseGlossChars << tab << m_glossLowerCaseChars;
	pf->AddLine(data);

	data.Empty();
	data << szUpperCaseGlossChars << tab << m_glossUpperCaseChars;
	pf->AddLine(data);

	if (gbAutoCaps)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szAutoCapitalization << tab << number;
	pf->AddLine(data);

	if (gbSrcHasUcAndLc)	// not in MFC version; whm added for wx version
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szSrcHasUcAndLc << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szFontSizeForDialogs << tab << m_dialogFontSize;
	pf->AddLine(data);

	switch (gProjectSfmSetForConfig) // whm ammended 6May05 to use gProjectSfmSetForConfig
	{
		case UsfmOnly: number = szUsfmOnly;break;
		case PngOnly: number = szPngOnly;break;
		case UsfmAndPng: number = szUsfmAndPng;break;
		default: number = szUsfmOnly;
	}
	data.Empty();
	data << szUseSFMarkerSet << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szUseFilterMarkers << tab << gProjectFilterMarkersForConfig; // whm added 13May05
	pf->AddLine(data);

	if (m_bChangeFixedSpaceToRegularSpace)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szChangeFixedSpaceToRegSpace << tab << number;
	pf->AddLine(data);

    // order is important for the next two - m_bBookMode must be in the config file earlier
    // than m_nBookIndex, since the latter must be used to restore the pair pointer when
    // book mode is on
	if (m_bBookMode)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szBookMode << tab << number;
	pf->AddLine(data);

	data.Empty();
	data << szBookIndex << tab <<  m_nBookIndex;
	pf->AddLine(data);

	/* this flag is deprecated (Reading a project config must read it for backwards compatibility but do nothing with it)
	// wx version: m_bSaveAsXML must always be true
	number = _T("1");
	data.Empty();
	data << szSaveAsXML << tab << number;
	pf->AddLine(data);
	*/

	data.Empty();
	data << szSilConverterName << tab << m_strSilEncConverterName;
	pf->AddLine(data);

	if (m_bSilConverterDirForward)
		number = _T("1");
	else
		number = _T("0");
    data.Empty();
	data << szSilConverterDirForward << tab << number;
    pf->AddLine(data);

	number.Empty();
	number << m_eSilConverterNormalizeOutput;
	data.Empty();
	data << szSilConverterNormalize << tab << number;
	pf->AddLine(data);

	if (gbLegacySourceTextCopy)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szLegacyCopyForPhraseBox << tab << number;
	pf->AddLine(data);

	if (gbAdaptBeforeGloss)
		number = _T("1");
	else
		number = _T("0");
	data.Empty();
	data << szDoAdaptingBeforeGlossing_InVerticalEdit << tab << number;
	pf->AddLine(data);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pf   -> pointer to the wxTextFile that is being read as the config file
/// \remarks
/// Called from: the App's GetConfigurationFile().
/// Reads the project settings part of a project configuration file.
/// For the most part, the project settings entries can be in any order, as long as the
/// format of each line's entry is correct: that is, a name, tab, and string value. The
/// exception is that the source language punctuation pairs data must be read before the
/// target punctuation pairs data.
/// NOTE: This function expects pf to already have been opened and the internal
/// pointer to be moved to the "ProjectSettings" line in the config file. The
/// wxWidgets version holds the entire config file in memory and reads individual
/// text lines from memory.
/// BEW 10Aug09 introducted additional order dependence, the paths for glosses and free
/// translation exports have to be after the line for getting the last export path,
/// because the latter's code block sets the boolean bForeignConfigFile which is needed
/// for handling the other paths safely
/// whm 7Aug11 removed the boolean bForeignConfigFile test - as now unnecessary, therefore
/// Bruce's comment above about additional order dependence for glosses and free
/// translation exports is no longer an issue. The only remaining order dependence in
/// the project config file is for the BookModeFlag to preceed the BookIndexValue item.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetProjectSettingsConfiguration(wxTextFile* pf)
{
	wxString data = _T("");
	wxString name;
	wxString strValue;
	int num; // for the string converted to a number
	bool bExistsUsfmSettingInConfig = FALSE; // whm added 2Feb05

	// BEW added 10Aug09, for detecting when the project config file is from a "foreign"
	// profile, and therefore would give an error if a path from that profile was used
	// herein as a path valid in the current user's profile; when the profile name part of
	// paths differ, set the following boolean TRUE, default is FALSE (meaning the config
	// file is not of foreign source and the path is the user's own)
	//bool bForeignConfigFile = FALSE; // whm 7Aug11 removed as unnecessary

#ifdef _UNICODE
	wxString strPunctPairsSrcSet;
	wxString strPunctPairsTgtSet;
	wxString strTwoPunctPairsSrcSet;
	wxString strTwoPunctPairsTgtSet;
	bool bAddedLeftDoubleQuote = FALSE;
	bool bAddedRightDoubleQuote = FALSE;
	bool bAddedLeftSingleQuote = FALSE;
	bool bAddedRightSingleQuote = FALSE;
#endif

	do
	{
		data = pf->GetNextLine();

#ifdef _UNICODE
		ChangeNRtoUnicode(data);
#endif
		GetValue(data, strValue, name);
		if (name == szSourceLanguageName)
		{
			m_sourceName = strValue;
		}
		else if (name == szTargetLanguageName)
		{
			m_targetName = strValue;
		}
		else if (name == szGlossesLanguageName)
		{
			m_glossesName = strValue;
		}
		else if (name == szSourceLanguageCode)
		{
			m_sourceLanguageCode = strValue;
		}
		else if (name == szTargetLanguageCode)
		{
			m_targetLanguageCode = strValue;
		}
		else if (name == szGlossesLanguageCode)
		{
			m_glossesLanguageCode = strValue;
		}

		// whm 17Feb12 added the following two from the basic config file. They are
		// used in collaboration operations too.
		else if (name == szCurProjectName)
		{
			// whm 20Feb12 removed from project config
			;
			//m_curProjectName = strValue;
			//if (!m_ForceCollabAIProjectName.IsEmpty())
			//	m_SavedCurProjectName = strValue;
		}
		else if (name == szCurLanguagesPath)
		{
			// whm 20Feb12 removed from project config
			;
			//m_curProjectPath = strValue;
			//if (!m_ForceCollabAIProjectName.IsEmpty())
			//	m_SavedCurProjectPath = strValue;
		}


		// m_last...Path values below
		else if (name == szDefaultTablePath)
		{
			m_lastCcTablePath = strValue; // read it to transition - now only stored in basic config file
		}
		else if (name == szLastDocPath) // pre-6.x.x this was located in the basic config file
		{
			m_lastDocPath = strValue;
		}
		else if (name == szLastSourceInputPath)
		{
			m_lastSourceInputPath = strValue;
		}
		else if (name == szLastInterlinearRTFOutputPath)
		{
			m_lastInterlinearRTFOutputPath = strValue;
		}
		else if (name == szLastSourceOutputPath) // pre-6.x.x this was located in the basic config file
		{
			m_lastSourceOutputPath = strValue;
		}
		else if (name == szLastSourceRTFOutputPath) // pre-6.x.x this was located in the basic config file
		{
			m_lastSourceRTFOutputPath = strValue;
		}
		else if (name == szLastTargetOutputPath || name == szLastExportPath) // whm 6Aug11 added szLastTargetOutputPath
		{
			m_lastTargetOutputPath = strValue;
		}
		else if (name == szLastTargetRTFOutputPath)
		{
			m_lastTargetRTFOutputPath = strValue;
		}
		else if (name == szLastGlossesOutputPath)
		{
			m_lastGlossesOutputPath = strValue;
		}
		else if (name == szLastGlossesRTFOutputPath)
		{
			m_lastGlossesRTFOutputPath = strValue;
		}
		else if (name == szLastFreeTransOutputPath)
		{
			m_lastFreeTransOutputPath = strValue;
		}
		else if (name == szLastFreeTransRTFOutputPath)
		{
			m_lastFreeTransRTFOutputPath = strValue;
		}
		else if (name == szFoldersProtectedFromNavigation)
		{
			m_foldersProtectedFromNavigation = strValue;
			// parse the m_foldersProtectedFromNavigation string and set the App's
			// folder protection flags
			SetFolderProtectionFlagsFromCombinedString(m_foldersProtectedFromNavigation);
		}

		// the next four are redundant from 2.3.0 and onwards, but must be retained
		// in case the user uses a later version to read a config file produced by
		// a pre-2.3.0 version of the application
		else if (name == szSrcPunctuation) // new punctuation system (split)
		{
			; // m_punctuation[0] = strValue; // do nothing with it
		}
		else if (name == szSrcPunctAsWordBuilding)
		{
			; // m_punctWordBuilding[0] = strValue;
		}
		else if (name == szTgtPunctuation)
		{
			; // m_punctuation[1] = strValue;
		}
		else if (name == szTgtPunctAsWordBuilding)
		{
			; // m_punctWordBuilding[1] = strValue;
		}
#ifndef _UNICODE
		else if (name == szPunctPairs)
		{
			// For Windows, ensure curly quotes are supported in ANSI version.
            // When first converted to wxWidgets, GTK's text control was failing when use
            // SetValue() with any of these upper ascii values in the punctuation string. A
            // partial solution was to ensure that SetEncoding(wxFONTENCODING_CP1252) was
            // called on the fonts involved. Note: SetEncoding() is an "undocumented"
            // method of wxFont. The documented SetDefaultEncoding() did not seem to work.
            // Also setting the encoding to wxFONTENCODING_ISO8859_1 did not work (it
            // eliminated the "Failed to set text in text control" message, but showed the
            // smart quotes as boxes with the hex values in them, instead of the actual
            // quote characters).
            // Because it was only a partial solution and problems seemed to continually
            // crop up, in the end I decided to include smart quotes only in the wxMSW ANSI
            // version and not in wxGTK builds.
#ifdef __WXMSW__
			wxString additions;
			additions.Empty();
			wxString ch = _T("."); // must not be empty, so put any char in it
			unsigned char thechar = 147; // left double quotation mark
			ch.SetChar(0,thechar);
			if (strValue.Find(ch) == -1) // not found
			{
				additions += ch;
				additions += ch;
			}
			thechar = 148; // right double quotation mark
			ch.SetChar(0,thechar);
			if (strValue.Find(ch) == -1) // not found
			{
				additions += ch;
				additions += ch;
			}
			thechar = 145; // left single quotation mark
			ch.SetChar(0,thechar);
			if (strValue.Find(ch) == -1) // not found
			{
				additions += ch;
				additions += ch;
			}
			thechar = 146; // right single quotation mark
			ch.SetChar(0,thechar);
			if (strValue.Find(ch) == -1) // not found
			{
				additions += ch;
				additions += ch;
			}
			strValue += additions;
#else
			// In non-windows ANSI versions, remove any smart quotes that exist in the
			// punctuation string.
            // Possible Problem: We cannot assume that the user would always want smart
            // quotes converted to regular quotes in the punctuation lists. Maybe they used
            // smart quotes for all their quotes requirements, and used a regular single
            // quote (apostrophe) as a word building glottal character, for example.

			// whm note: For wx ANSI version, when compiled for wxGTK, we should
			// check the punct strings for illegal 8-bit chars, specifically for MS' smart
			// quotes which cause problems because the wxGTK library internally
			// keeps strings in UTF-8. We'll quietly convert any smart quotes we find
			// to normal quotes.
			int ct;
			bool hackedFontCharPresent = FALSE;
			int hackedCt = 0;
			wxString hackedStr;
			hackedStr.Empty();
			const wxChar lsqm(-111);
			const wxChar rsqm(-110);
			const wxChar ldqm(-109);
			const wxChar rdqm(-108);
            // replace any smart quote chars with a space - if both src and tgt punct have
            // smart quotes we end up with both being spaces, but I think
            // StringToPunctPairs and its complement PunctPairsToString can handle it.
			strValue.Replace(&lsqm,_T(" "));
			strValue.Replace(&rsqm,_T(" "));
			strValue.Replace(&ldqm,_T(" "));
			strValue.Replace(&rdqm,_T(" "));
			for (ct = 0; ct < (int) strValue.Length(); ct++)
			{
				int charValue;
				charValue = (int)strValue.GetChar(ct);
				// whm note: The decimal int value of extended ASCII chars is represented
				// as its decimal extended value minus 256, making any extended characters
				// be represented as negative numbers
				if (charValue < 0)
				{
					//// we have an extended ASCII character in the string
					//switch(charValue)
					//{
					//case -111:	strValue.Remove(ct,1);
					//			break;
					//case -110:	strValue.Remove(ct,1);
					//			break;
					//case -109:	strValue.Remove(ct,1);
					//			break;
					//case -108:	strValue.Remove(ct,1);
					//			break;
					//default:
					//	{
                            // the default case indicates there is a non-smart quote
                            // extended ASCII character present. In this case we should
                            // warn the user that the data cannot be handled until it is
                            // converted to Unicode, then delete the extended punct char
                            // from the list.
							// TODO: implement warning message and delete routine instead of Beep
							//::wxBell();
							hackedFontCharPresent = TRUE;
							hackedCt++;
							if (hackedCt < 10)
							{
								hackedStr += _T("\n   character with ASCII value: ");
								hackedStr << (charValue+256);
							}
							else if (hackedCt == 10)
								hackedStr += _T("...\n");
					//	}
					//}
				}
			}

			// we assume that regular quote marks are already in the punctuation string if the user
			// desired them to be there

			if (hackedFontCharPresent && !gbHackedDataCharWarningGiven)
			{
				gbHackedDataCharWarningGiven = TRUE;
				wxString msg2 = _(
"\nYou should not use this non-Unicode version of Adapt It.\nYour data should first be converted to Unicode using TecKit\nand then you should use the Unicode version of Adapt It.");
				wxString msg1 = _(
"Extended 8-bit ASCII characters were detected in the\nProject Configuration File\'s punctuation string (see below):");
				msg1 += hackedStr + msg2;
				wxMessageBox(msg1,_("Warning: Invalid Characters Detected"),wxICON_WARNING);
			}
#endif
            // wxGTK uses UTF-8 internally in its wxTextCtrl widgets, so let's try
            // converting the punctuation string to UTF-8 for wxGTK ANSI builds.
//#ifdef __GNUG__
//			// The following converts strValue to
//			wxConvUTF8.cWC2MB(wxConvCurrent->cMB2WC(strValue));
//#endif
			// set flag if apostrophe is designated as a punctuation character (this makes
			// ParseWord() do its job smarter within TokenizeText())
			int found = strValue.Find(_T('\'')); // look for vertical ordinary quote (ie. apostrophe)
			if (found >= 0)
				m_bSingleQuoteAsPunct = TRUE;
			else
				m_bSingleQuoteAsPunct = FALSE;

			StringToPunctPairs(m_punctPairs,strValue);
		}
		else if (name == szTwoPunctPairs)
		{
			StringToTwoPunctPairs(m_twopunctPairs,strValue);
		}
#else // _UNICODE version
		else if (name == szPunctPairsSrc)
		{
			// make sure curly quotes are supported as punctuation
			wxString additions;
			additions.Empty();
			wxString ch = _T("."); // must be initialized to something, else SetChar() fails
			ch.SetChar(0,L'\x201C'); // hex for left double quotation mark
			if (strValue.Find(ch) == -1) // not found
			{
				bAddedLeftDoubleQuote = TRUE;
				additions += ch;
			}
			ch.SetChar(0,L'\x201D'); // hex for right double quotation mark
			if (strValue.Find(ch) == -1) // not found
			{
				bAddedRightDoubleQuote = TRUE;
				additions += ch;
			}
			ch.SetChar(0,L'\x2018'); // hex for left single quotation mark
			if (strValue.Find(ch) == -1) // not found
			{
				bAddedLeftSingleQuote = TRUE;
				additions += ch;
			}
			ch.SetChar(0,L'\x2019'); // hex for right single quotation mark
			if (strValue.Find(ch) == -1) // not found
			{
				bAddedRightSingleQuote = TRUE;
				additions += ch;
			}
			int found = strValue.Find(_T('\'')); // look for vertical ordinary quote (ie. apostrophe)
			if (found >= 0)
				m_bSingleQuoteAsPunct = TRUE;
			else
				m_bSingleQuoteAsPunct = FALSE;
			strValue = additions + strValue;

			strPunctPairsSrcSet = strValue;
		}
		else if (name == szPunctPairsTgt)
		{
			// THIS BLOCK WORKS RIGHT ONLY WHEN THE
			// SOURCE SET WAS PROCESSED EARLIER - so
			// ORDER is important in the config file for unicode punctuation
			// support - so don't alter order of src & tgt punct lines

			// make sure curly quotes are supported as punctuation
			wxString additions;
			additions.Empty();
			wxString ch = _T("."); // must be initialized to something, else SetAt() fails
			ch.SetChar(0,L'\x201C'); // hex for left double quotation mark
			if (bAddedLeftDoubleQuote) // source had this added
			{
				 // so target has to have it too
				additions += ch;
			}
			ch.SetChar(0,L'\x201D'); // hex for right double quotation mark
			if (bAddedRightDoubleQuote)
			{
				// add it if the source had it added
				additions += ch;
			}
			ch.SetChar(0,L'\x2018'); // hex for left single quotation mark
			if (bAddedLeftSingleQuote)
			{
				// add it if the source had it added
				additions += ch;
			}
			ch.SetChar(0,L'\x2019'); // hex for right single quotation mark
			if (bAddedRightSingleQuote)
			{
				// add it if the source had it added
				additions += ch;
			}
			int found = strValue.Find(_T('\'')); // look for vertical ordinary
												 // quote (ie. apostrophe)
			if (found >= 0)
				m_bSingleQuoteAsPunct = TRUE;
			else
				m_bSingleQuoteAsPunct = FALSE;
			strValue = additions + strValue;

			strPunctPairsTgtSet = strValue;
		}
		else if (name == szTwoPunctPairsSrc)
		{
			strTwoPunctPairsSrcSet = strValue;
		}
		else if (name == szTwoPunctPairsTgt)
		{
			strTwoPunctPairsTgtSet = strValue;
		}
#endif
		else if (name == szSpecialTextColor)
		{
			num = wxAtoi(strValue); // allow anything
			m_specialTextColor = Int2wxColour(num); // Int2wxColour() in helpers.h
		}
		else if (name == szReTranslnTextColor)
		{
			num = wxAtoi(strValue); // allow anything
			m_reTranslnTextColor = Int2wxColour(num); // Int2wxColour() in helpers.h
		}
		else if (name == szTgtDiffsTextColor)
		{
			num = wxAtoi(strValue); // allow anything
			m_tgtDiffsTextColor = Int2wxColour(num); // Int2wxColour() in helpers.h
		}
		else if (name == szNavTextColor)
		{
			num = wxAtoi(strValue); // allow anything
            // BEW changed 28Sep05; the font info at the start of config is enough, it only
            // adds confusion to reset what has already been set, and is a potential source
            // of error; so we will continue to Write this value in the settings (for
            // backwards compatibity), but we will ignore the value read in, and only rely
            // on the one that GetFontConfiguration returns
		}
		else if (name == szAutoInsertionsHighlightColor) // whm 6Aug11 moved here from basic config file
		{
			num = wxAtoi(strValue); // allow anything
			m_AutoInsertionsHighlightColor = Int2wxColour(num); // Int2wxColour() in helpers.h
		}
		else if (name == szGuessHighlightColor) // whm 6Aug11 moved here from basic config file
		{
			num = wxAtoi(strValue); // allow anything
			m_GuessHighlightColor = Int2wxColour(num); // Int2wxColour() in helpers.h
		}
		else if (name == szPunctuation) // old punctuation system
		{
			; // do nothing, (retained for reading legacy config files safely)
		}
		else if (name == szPunctAsWordBuilding)
		{
			; // ditto
		}
		else if (name == szBackupDocument)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 1)
				m_bBackupDocument = TRUE;
			else
				m_bBackupDocument = FALSE;
		}
		else if (name == szWorkflowProfile) // whm added 3Sep10 for user workflow profile support
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 10)
				num = 0; // if out of reasonable range default to a profile of "None".
			m_nWorkflowProfile = num;
		}

		// whm added 17Feb12 next 14 items for project-specific collaboration
		else if (name == szCollaboratingWithParatext) // whm added 15Apr11
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_bCollaboratingWithParatext
			// can be overridden by the use of the command-line switches -collab_on or -collab_off.
			if (num == 1)
			{
				m_bCollaboratingWithParatext = TRUE;
				// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
				//if (m_bForceCollabModeON)
				//{
				//	m_nSavedCollabPTSetting = 1;
				//}
			}
			else
			{
				m_bCollaboratingWithParatext = FALSE;
				// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
				//if (m_bForceCollabModeOFF)
				//{
				//	m_nSavedCollabPTSetting = 0;
				//}
			}
		}
		else if (name == szCollaboratingWithBibledit) // whm added 15Apr11
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_bCollaboratingWithBibledit
			// can be overridden by the use of the command-line switches -collab_on or -collab_off.
			if (num == 1)
			{
				m_bCollaboratingWithBibledit = TRUE;
				// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
				//if (m_bForceCollabModeON)
				//{
				//	m_nSavedCollabBESetting = 1;
				//}
			}
			else
			{
				m_bCollaboratingWithBibledit = FALSE;
				// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
				//if (m_bForceCollabModeOFF)
				//{
				//	m_nSavedCollabBESetting = 0;
				//}
			}
		}
		else if (name == szCollabProjectForSourceInputs) // whm added 15Apr11
		{
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_CollabProjectForSourceInputs
			// can be overridden by the use of the command-line switch -collab_proj followed by the
			// PT/BE project names in the form "Source Proj:Target Proj[:FreeTrans Proj]" where the
			// first part "Source Proj" is significant in this case.
			m_CollabProjectForSourceInputs = strValue;
			// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
			//if (!m_ForceCollabProjectNames.IsEmpty())
			//{
			//	m_SavedCollabProjectForSourceInputs = strValue;
			//}
		}
		else if (name == szCollabProjectForTargetExports) // whm added 15Apr11
		{
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_CollabProjectForTargetExports
			// can be overridden by the use of the command-line switch -collab_proj followed by the
			// PT/BE project names in the form "Source Proj:Target Proj[:FreeTrans Proj]" where the
			// second part "Target Proj" is significant in this case.
			m_CollabProjectForTargetExports = strValue;
			// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
			//if (!m_ForceCollabProjectNames.IsEmpty())
			//{
			//	m_SavedCollabProjectForTargetExports = strValue;
			//}
		}
		else if (name == szCollabProjectForFreeTransExports) // whm added 30Jun11
		{
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_CollabProjectForFreeTransExports
			// can be overridden by the use of the command-line switch -collab_proj followed by the
			// PT/BE project names in the form "Source Proj:Target Proj[:FreeTrans Proj]" where the
			// third part "FreeTrans Proj", if specifieded, is significant in this case.
			m_CollabProjectForFreeTransExports = strValue;
			// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
			//if (!m_ForceCollabProjectNames.IsEmpty())
			//{
			//	m_SavedCollabProjectForFreeTransExports = strValue;
			//}
		}
		else if (name == szCollabAIProjectName) // whm added 7Sep11
		{
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_CollabAIProjectName
			// can be overridden by the use of the command-line switch -ai_proj followed by
			// the AI project name in the form "Lang A to Lang B adaptations".
			m_CollabAIProjectName = strValue;
			// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
			//if (!m_ForceCollabAIProjectName.IsEmpty())
			//{
			//	m_SavedCollabAIProjName = strValue;	// whm added 20Jan12 used to restore m_CollabAIProjectName before
			//								// saving value to basic config file after -ai_proj was used to
			//								// force the project name from the command-line.
			//}
		}
		else if (name == szCollaborationEditor) // whm added 4Apr12
		{
			// whm 25Apr12 added. Don't allow a blank config file entry for the CollaborationEditor to
			// remove the default or current m_collaborationEditor.
			if (!strValue.IsEmpty())
			{
				m_collaborationEditor = strValue;
			}
		}
		else if (name == szCollabExpectsFreeTrans) // whm added 9Aug11
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_bCollaborationExpectsFreeTrans
			// can be overridden by the use of the command-line switch -collab_proj followed by the
			// PT/BE project names in the form "Source Proj:Target Proj[:FreeTrans Proj]" where the
			// third part "FreeTrans Proj", if specifieded, is significant in this case.
			if (num == 1)
			{
				m_bCollaborationExpectsFreeTrans = TRUE;
				// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
				//if (m_bForceCollabExpectsFreeTrans)
				//{
				//	m_nSavedCollabExpectsFreeTrans = 1;
				//}
			}
			else
			{
				m_bCollaborationExpectsFreeTrans = FALSE;
				// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
				//if (m_bForceCollabExpectsFreeTrans)
				//{
				//	m_nSavedCollabExpectsFreeTrans = 0;
				//}
			}
		}
		// whm Note: The next three having to do with book and chapter
		// selection are not affected by command-line switches.
		else if (name == szCollabBookSelected)
		{
			m_CollabBookSelected = strValue;
		}
		else if (name == szCollabByChapterOnly)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			if (num == 1)
				m_bCollabByChapterOnly = TRUE;
			else
				m_bCollabByChapterOnly = FALSE;
		}
		else if (name == szCollabChapterSelected)
		{
			m_CollabChapterSelected = strValue;
		}
		// whm 4Sep11 added the next two
		else if (name == szCollabSourceLangName)
		{
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_CollabSourceLangName
			// can be overridden by the use of command-line switches -collab_proj or -ai_proj
			// followed by their associated strings indicating specified projects.
			m_CollabSourceLangName = strValue;
			// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
			//if (!m_ForceCollabProjectNames.IsEmpty() || (!m_ForceCollabAIProjectName.IsEmpty()))
			//{
			//	m_SavedCollabSourceLangName = strValue;
			//}
		}
		else if (name == szCollabTargetLangName)
		{
			// whm 15Apr11 Note: See the GetBasicSettingsConfiguration() call within
			// the GetConfigurationFile() function where the value of m_CollabTargetLangName
			// can be overridden by the use of command-line switches -collab_proj or -ai_proj
			// followed by their associated strings indicating specified projects.
			m_CollabTargetLangName = strValue;
			// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
			//if (!m_ForceCollabProjectNames.IsEmpty() || (!m_ForceCollabAIProjectName.IsEmpty()))
			//{
			//	m_SavedCollabTargetLangName = strValue;
			//}
		}
		/*
		else if (name == szCollabSwitchingPasswordProtected) // whm added 2Feb12
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0;
			if (num == 0)
				m_bPwdProtectCollabSwitching = FALSE;
			else
				m_bPwdProtectCollabSwitching = TRUE;
		}
		else if (name == szCollabSwitchingPassword) // whm added 2Feb12
		{
			m_collabSwitchingPassword = strValue;
		}
		// whm added 17Feb12 above 14 items for project-specific collaboration
		*/

		else if (name == szUseAdaptationsGuesser) // whm added 28Oct10 for Guesser support
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 1)
				m_bUseAdaptationsGuesser = TRUE;
			else
				m_bUseAdaptationsGuesser = FALSE;
		}
		else if (name == szGuessingLevel) // whm added 28Oct10 for Guesser support
		{
			num = wxAtoi(strValue);
			if (num < 0 || num > 100) // m_nGuessingLevel must be between 0 and 100; 50 is default
				num = 50;
			m_nGuessingLevel = num;
		}
		else if (name == szAllowCConUnchangedGuesserOutput) // whm added 28Oct10 for Guesser support
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 1)
				m_bAllowGuesseronUnchangedCCOutput = TRUE;
			else
				m_bAllowGuesseronUnchangedCCOutput = FALSE;
		}
		else if (name == szRTL_Layout)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // LTR layout is safe default
			if (num == 1)
				m_bRTL_Layout = TRUE;
			else
				m_bRTL_Layout = FALSE;
			gbRTL_Layout = m_bRTL_Layout; // set the global at same time
		}
		else if (name == szSFMescapechar)
		{
			;	// disregard the sfm esc char read in from config as of version 3
				//gSFescapechar is always backslash
		}
		else if (name == szSFMafterNewlines)
		{
			// BEW 8Jun10, removed support for checkbox "Recognise standard format
			// markers only following newlines"
			//num = wxAtoi(strValue);
			//if (!(num == 0 || num == 1))
			//	num = 0;
			//if (num == 1)
			//	gbSfmOnlyAfterNewlines = TRUE;
			//else
			//	gbSfmOnlyAfterNewlines = FALSE;
			; // deprecated
		}

#ifdef _RTL_FLAGS
		else if (name == szRTLSource)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // LTR reading text is safe default
			if (num == 1)
				m_bSrcRTL = TRUE;
			else
				m_bSrcRTL = FALSE;
		}
		else if (name == szRTLTarget)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // LTR reading text is safe default
			if (num == 1)
				m_bTgtRTL = TRUE;
			else
				m_bTgtRTL = FALSE;
		}
		else if (name == szRTLNavText)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // LTR reading text is safe default
			if (num == 1)
				m_bNavTextRTL = TRUE;
			else
				m_bNavTextRTL = FALSE;
		}
#endif
		// autocapitalization stuff
		else if (name == szLowerCaseSourceChars)
		{
			m_srcLowerCaseChars = strValue;
		}
		else if (name == szUpperCaseSourceChars)
		{
			m_srcUpperCaseChars = strValue;
		}
		else if (name == szLowerCaseTargetChars)
		{
			m_tgtLowerCaseChars = strValue;
		}
		else if (name == szUpperCaseTargetChars)
		{
			m_tgtUpperCaseChars = strValue;
		}
		else if (name == szLowerCaseGlossChars)
		{
			m_glossLowerCaseChars = strValue;
		}
		else if (name == szUpperCaseGlossChars)
		{
			m_glossUpperCaseChars = strValue;
		}
		else if (name == szAutoCapitalization)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 1)
				gbAutoCaps = TRUE;
			else
				gbAutoCaps = FALSE;
		}
		else if (name == szSrcHasUcAndLc) // whm added 12Aug04 - not in MFC version
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 1)
				gbSrcHasUcAndLc = TRUE;
			else
				gbSrcHasUcAndLc = FALSE;
		}
		else if (name == szFontSizeForDialogs)
		{
			num = wxAtoi(strValue);
			if (num < 10 || num > 24)
				num = 12;
			m_dialogFontSize = num;
		}
		else if (name == szUseSFMarkerSet)
		{
			num = wxAtoi(strValue);
			if (strValue == szUsfmOnly)
				gProjectSfmSetForConfig = UsfmOnly;
			else if (strValue == szPngOnly)
				gProjectSfmSetForConfig = PngOnly;
			else if (strValue == szUsfmAndPng)
				gProjectSfmSetForConfig = UsfmAndPng;
			else
				gProjectSfmSetForConfig = UsfmOnly;
			bExistsUsfmSettingInConfig = TRUE;
		}
		else if (name == szUseFilterMarkers) // whm added 13May05
		{
			if (!strValue.IsEmpty())
			{
				gProjectFilterMarkersForConfig = strValue;
			}
			else
			{
                // config has szUseFilterMarkers label but no filter markers following it
                // so use the gCurrentFilterMarkers value for
                // gProjectFilterMarkersForConfig
				gProjectFilterMarkersForConfig = gCurrentFilterMarkers;
			}
		}
		else if (name == szChangeFixedSpaceToRegSpace) // whm added 3Apr05
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 1)
				m_bChangeFixedSpaceToRegularSpace = TRUE;
			else
				m_bChangeFixedSpaceToRegularSpace = FALSE;
		}
		// order is important for the next two - m_bBookMode must be in the config file earlier
		// than m_nBookIndex, since the latter must be used to restore the pair pointer when
		// book mode is on
		else if (name == szBookMode)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 0; // off, if there was an error
			if (num == 1)
				m_bBookMode = TRUE;
			else
				m_bBookMode = FALSE;
		}
		else if (name == szBookIndex)
		{
			num = wxAtoi(strValue);
			if ((num < -1 || num > 66))
				num = -1; // -1, if there was an error
			m_nBookIndex = num;

			// we must now restore the pair pointer, if book mode is on
			// and the folder path
			if (m_bBookMode && !m_bDisableBookMode)
			{
				if (m_nBookIndex == -1)
					goto t;

				// whm added 30Nov07 check to ensure the m_nBookIndex is not out of
				// range for the number of Bible books in m_pBibleBooks. If it is out
				// of range (i.e., user changed to a custom books.xml or edited the
				// project config file's BookIndexValue to an erroneous value), turn
				// off book mode and set flags to default values.
				if (m_nBookIndex < -1 ||
					(m_nBookIndex + 1) > (int)(*m_pBibleBooks).GetCount())
				{
					goto t;
				}

				m_pCurrBookNamePair = ((BookNamePair*)(*m_pBibleBooks)[m_nBookIndex]);
				m_bibleBooksFolderPath = m_curAdaptionsPath + PathSeparator +
													m_pCurrBookNamePair->dirName;
			}
			else
			{
t:				m_pCurrBookNamePair = NULL;
				m_bibleBooksFolderPath.Empty();
				m_bBookMode = FALSE;
				m_nBookIndex = -1;
				m_nLastBookIndex = m_nDefaultBookIndex;
			}
		}
		else if (name == szSaveAsXML) // BEW added 04Aug05
		{
			// 30Apr10, this flag is deprecated, read it but no longer set it, and
			// writing the project config file no longer writes it
			//num = wxAtoi(strValue);
			// wx version: we only allow a value of TRUE for wx version
			//m_bSaveAsXML = TRUE;
			;
		}
		else if (name == szSilConverterName)	// rde added 03 Apr 06
		{
			m_strSilEncConverterName = strValue;
		}
		else if (name == szSilConverterDirForward)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 0)
				m_bSilConverterDirForward = FALSE;
			else
				m_bSilConverterDirForward = TRUE;
		}
		else if (name == szSilConverterNormalize)
		{
			num = wxAtoi(strValue);
			m_eSilConverterNormalizeOutput = num;
		}
		else if (name == szLegacyCopyForPhraseBox)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 0)
				gbLegacySourceTextCopy = FALSE;
			else
				gbLegacySourceTextCopy = TRUE;
		}
		else if (name == szDoAdaptingBeforeGlossing_InVerticalEdit)
		{
			num = wxAtoi(strValue);
			if (!(num == 0 || num == 1))
				num = 1;
			if (num == 0)
				gbAdaptBeforeGloss = FALSE;
			else
				gbAdaptBeforeGloss = TRUE;
		}
		else
		{
			if (!data.IsEmpty())
			{
				wxString error = _(
				"Warning: Unrecognized project settings field; unmatched name is: ") + name;
				wxMessageBox(error, _T(""), wxICON_INFORMATION);
			}
		}
	} while (!pf->Eof());

	// whm ammended 6May05
	if (!bExistsUsfmSettingInConfig)
	{
        // If no UseSFMarkerSet is encoded in the project config file, we assume the user
        // is upgrading from a previous Adapt It version. In this case, all previous
        // documents created by previous version will have been created using a PngOnly
        // inventory of standard format markers, therefore we assign both gCurrentSfmSet
        // and gProjectSfmSetForConfig to be PngOnly. This setting remains PngOnly until
        // the user explicitly changes to a different SfmSet using Edit Preferences USFM
        // and Filtering tab, or the USFM and Filtering page in the Start Working... wizard
        // upon creation of a new project.
		gCurrentSfmSet = PngOnly;
		gProjectSfmSetForConfig = gCurrentSfmSet; // whm added 6May05
		gCurrentFilterMarkers = PngFilterMarkersStr; // whm added 13May05
		gProjectFilterMarkersForConfig = gCurrentFilterMarkers; // whm added 13May05
	}

#ifdef _UNICODE
	// the ANSI function calls are done above, we only need do the Unicode ones here
	TwoStringsToPunctPairs(m_punctPairs,strPunctPairsSrcSet,strPunctPairsTgtSet);
	TwoStringsToTwoPunctPairs(m_twopunctPairs,strTwoPunctPairsSrcSet,strTwoPunctPairsTgtSet);
#endif

	// compute the source and target punctuation sets to be used for parsing
	GetPunctuationSets(m_punctuation[0], m_punctuation[1]);

	// toggle the checkmark on if the flag value from the config file is TRUE
	// BEW added 31Oct05; else remove the checkmark if the value was FALSE
	// remove the checkmark
	gbSuppressAutoCapsAsk = TRUE;
	// toggle the flag value because the OnToolsAutoCapitalization call will
	// retoggle it back again
	if (gbAutoCaps)
	{
		gbAutoCaps = FALSE;
	}
	else
	{
		gbAutoCaps = TRUE;
	}
	wxCommandEvent dummyEvent;
	OnToolsAutoCapitalization(dummyEvent); // this toggles the flag & sets the tick accordingly
	gbSuppressAutoCapsAsk = FALSE; // enable the ask message to be shown to the user

	// determine the flag values for when there may be empty correspondences list(s)
	gbNoSourceCaseEquivalents = FALSE; // default
	if (m_srcLowerCaseChars.IsEmpty() && m_srcUpperCaseChars.IsEmpty())
		gbNoSourceCaseEquivalents = TRUE; // restore this flag if user cleared source lists

	gbNoTargetCaseEquivalents = FALSE; // default
	if (m_tgtLowerCaseChars.IsEmpty() && m_tgtUpperCaseChars.IsEmpty())
		gbNoTargetCaseEquivalents = TRUE; // restore this flag if user cleared target lists

	gbNoGlossCaseEquivalents = FALSE; // default
	if (m_glossLowerCaseChars.IsEmpty() && m_glossUpperCaseChars.IsEmpty())
		gbNoGlossCaseEquivalents = TRUE; // restore this flag if user cleared source lists
}

// whm 25Sep11 added for printing support of glosses
bool CAdapt_ItApp::DocHasGlosses(SPList* pSPList)
{
	bool bFound = FALSE;
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)NULL;
	SPList::Node* pos = pSPList->GetFirst();
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase);
		if (pSrcPhrase->m_bHasGlossingKBEntry)
		{
			return TRUE;
		}
	}
	// if we get here no glosses were found
	return bFound;
}

// whm 25Sep11 added for printing support of free translations
bool CAdapt_ItApp::DocHasFreeTranslations(SPList* pSPList)
{
	bool bFound = FALSE;
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)NULL;
	SPList::Node* pos = pSPList->GetFirst();
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase);
		if (pSrcPhrase->m_bHasFreeTrans)
		{
			return TRUE;
		}
	}
	// if we get here no free translations were found
	return bFound;
}


// Gets the source language and target language ethnologue codes from the project
// configuration file in the folder which is passed in as the absolute path to the project
// (code taken and tweaked from GetProjectConfiguration(), GetConfigurationFile() and
// GetProjectSettingsConfiguration() )
// return TRUE if all went well, FALSE if there was an error along the way
// Used in Paratext or Bibledit collaboration feature -- see GetSourceTextFromEditor.h & .cpp
// BEW created 22Jun11
bool CAdapt_ItApp::ExtractEthnologueLangCodesFromProjConfigFile(wxString& projectFolderPath,
																EthnologueCodePair* pCodePair)
{
	wxString configFName = szProjectConfiguration + _T(".aic");
	wxString fname;
	fname.Empty();
	fname << configFName;
	wxString path;
	path.Empty();
	path << projectFolderPath << PathSeparator << fname;
	wxString data = _T("");
	wxString name;
	bool	bIsOK = TRUE;
	bool	bSuccessful = FALSE;
	wxString  strValue;
	wxString dummy;
	// make the working directory the "Adapt It Work" or "Adapt It Unicode Work" one
	bIsOK = ::wxSetWorkingDirectory(projectFolderPath);
	wxTextFile f;
	// Under wxWidgets, wxTextFile actually reads the entire file into memory at the Open()
    // call. It is set up so we can treat it as a line oriented text file while in memory,
    // modifying it, then if not just reading it, we can write it back out to persistent
	// storage with a single call to Write().
	// open the config file for reading
    // wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
    // Note: Need to check if file exists, otherwise if Open fails wxWidgets' wxTextFile
    // conjures up its own error message to that fact which it issues in Idle time just
    // after it's no longer busy.
	if (!bIsOK || !::wxFileExists(path))
	{
		bSuccessful = FALSE;
	}
	else
	{
#ifndef _UNICODE
		// ANSI
		bSuccessful = f.Open(path); // read ANSI file into memory
#else
		// UNICODE
		bSuccessful = f.Open(path, wxConvUTF8); // read UNICODE file into memory
#endif
	}
	if (!bSuccessful)
	{
		// don't give any error message, just return FALSE so that the attempt to match a
		// project fails and AI will end up creating a new project for working with the
		// collaboration data from PT or BE
		return FALSE;
	}
	// We need to initialize the wxTextFile file pointer to the beginning of the file
	// otherwise the GetNextLine() will fail
	dummy = f.GetFirstLine();
	// The entire basic config file is now in memory and we can read the information
	// by scanning its virtual lines. Loop until we come to the first entry we want...
	do {
		data = f.GetNextLine();
		GetValue(data, strValue, name);
	} while (name != szSourceLanguageCode && !f.Eof()); // whm added !f.Eof() condition 30Jun11
	// we exit the loop at the line with label _T("SourceLanguageName"), the strValue has
	// the first code that we want
	// whm modified 30Jun11. Older config files won't have the szSourceLanguageCode or
	// soTargetLanguageCode values, therefore we must test for f.Eof() in the do loop
	// above, and prevent the calling of f.GetNextLine() below if we are at Eof().
	pCodePair->srcLangCode = strValue;
	// the next line has the target language code, get it
	if (!f.Eof())
	{
		data = f.GetNextLine();
		GetValue(data, strValue, name);
		wxASSERT(name == szTargetLanguageCode);
	}
	else
	{
		strValue.Empty();
	}
	pCodePair->tgtLangCode = strValue;
	// the other two members of pCodePair (folderName and path to the folder - that is,
	// folderName will be at the end of the folderPath string as well) are set in the caller
	f.Close(); // closes the wxTextFile and frees memory used for it
	return TRUE;
}

// Interrogate all the current work folder's project folders, to get the ethnologue
// language code pairs from each one's project config file, returned an array of
// EthnologueCodePair structs containing the gleaned information, the structs also return
// the project's folder name and the absolute path to the project folder.
// Calls: bool ExtractEthnologueLangCodesFromProjConfigFile(wxString& projectFolderPath,
// EthnologueCodePair* pCodePair); see above
// Return FALSE if there was an error preventing successful populating of the
// pCodePairsArray, otherwise return TRUE.
// We don't use the normal functions for dealing with configuration files, because they
// would mess with application parameters currently in force, clobbering the integrity of
// the running app.
bool CAdapt_ItApp::GetEthnologueLangCodePairsForAIProjects(wxArrayPtrVoid* pCodePairsArray)
{
	wxString workPath;
	// get the absolute path to "Adapt It Unicode Work" or "Adapt It Work" as the case may be
	// NOTE: m_bLockedCustomWorkFolderPath == TRUE is included in the test deliberately,
	// because without it, an (administrator) snooper might be tempted to access someone
	// else's remote shared Adapt It project and set up a PT or BE collaboration on his
	// behalf - we want to snip that possibility in the bud!! The snooper won't have this
	// boolean set TRUE, and so he'll be locked in to only being to collaborate from
	// what's on his own machine
	workPath = SetWorkFolderPath_For_Collaboration();

	// create an array to hold the set of project folder names
	wxArrayString aiProjectNamesArray;
	// populate the array
	GetPossibleAdaptionProjects(&aiProjectNamesArray);
	// In a loop, generate the path to each project folder, create an EthnologueCodePair
	// struct on the heap, fill its path and folder name members, and call the
	// ExtractEthnologueLangCodesFromProjConfigFile() function to get and store it's
	// srcLangCode and tgtLangCode members
	int count = aiProjectNamesArray.GetCount();
	wxString projectFolderPath;
	wxString folderName;
	EthnologueCodePair* pCodePair = NULL;
	bool bOK = TRUE;
	int index;
	for (index = 0; index < count; index++)
	{
		folderName = aiProjectNamesArray.Item(index);
		projectFolderPath = workPath + PathSeparator + folderName;
		pCodePair = new EthnologueCodePair;
		pCodePair->projectFolderName = folderName;
		pCodePair->projectFolderPath = projectFolderPath;
		bOK = ExtractEthnologueLangCodesFromProjConfigFile(projectFolderPath, pCodePair);
		if (!bOK)
		{
			// bad luck, never mind, at least we tried
			int count2 = pCodePairsArray->GetCount();
			int index2;
			for(index2 = 0; index2 < count2; index2++)
			{
				EthnologueCodePair* pCP = (EthnologueCodePair*)pCodePairsArray->Item(index2);
				delete pCP;
			}
			pCodePairsArray->Clear();
			return FALSE;
		}
		pCodePairsArray->Add(pCodePair);
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated
///                         menu item is selected
/// \remarks
/// Called from: The Event Table of the CAdapt_ItDoc class where the Doc's OnFileNew()
/// handler gets triggered by a File | New command, and the Doc's OnFileNew() explicitly
/// calls this function. This OnFileNew() handler is also called explicitly from the App's
/// OnInit() function with a wxID_NEW command event passed to it in order to create an
/// initial default document when the app is first run.
/// This handler simply calls the OnFileNew() method of the m_pDocManager object.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnFileNew(wxCommandEvent& event)
{
	//This is needed in the wx version
	if (m_pDocManager != NULL)
		m_pDocManager->OnFileNew(event);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      srcPunctuation   <- a wxString that receives the source language punctuation
/// \param      tgtPunctuation   <- a wxString that receives the target language punctuation
/// \remarks
/// Called from: the App's GetBasicSettingsConfiguration(), GetProjectSettingsConfiguration(),
/// and from CPunctCorrespPageCommon::GetPunctuationSets().
/// Parses the source and target language punctuations characters from the PUNCTPAIR or
/// TWOPUNCTPAIR structs and stores them in separate strings. Also checks to ensure that
/// '<' and '>' angle brackets are used as punctuation characters rather than word building
/// characters.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetPunctuationSets(wxString& srcPunctuation, wxString& tgtPunctuation)
{
	// next compute srcPunctuation and tgtPunctuation referenced variable contents (note,
	// CPunctCorrespPageWiz and CPunctCorrespPagePrefs classes also uses this function)
	srcPunctuation.Empty();
	tgtPunctuation.Empty();
	for (int index = 0; index < MAXPUNCTPAIRS; index++)
	{
		if (m_punctPairs[index].charSrc != _T('\0'))
		{
			srcPunctuation += _T(" ");
			srcPunctuation += m_punctPairs[index].charSrc;
		}
		if (m_punctPairs[index].charTgt != _T('\0'))
		{
			tgtPunctuation += _T(" ");
			tgtPunctuation += m_punctPairs[index].charTgt;
		}
	}

    // now scan the two punct pairs arrays for anything the user included there and forgot
    // to add to the single equivalences, or chose not to add to the single equivalences
	wxChar srcChar = _T('\0');
	wxChar tgtChar = _T('\0');
	for (int index = 0; index < MAXTWOPUNCTPAIRS; index++)
	{
		if (m_twopunctPairs[index].twocharSrc[0] != _T('\0'))
		{
			srcChar = m_twopunctPairs[index].twocharSrc[0];
			int nFound = srcPunctuation.Find(srcChar);
			if (nFound == -1)
			{
				// we've found one not included in the single set, so add it to the inventory
				srcPunctuation += _T(" ");
				srcPunctuation += srcChar;
			}
		}
		if (m_twopunctPairs[index].twocharSrc[1] != _T('\0'))
		{
			srcChar = m_twopunctPairs[index].twocharSrc[1];
			int nFound = srcPunctuation.Find(srcChar);
			if (nFound == -1)
			{
				// we've found one not included in the single set, so add it to the inventory
				srcPunctuation += _T(" ");
				srcPunctuation += srcChar;
			}
		}

		// now do the same for the target set
		if (m_twopunctPairs[index].twocharTgt[0] != _T('\0'))
		{
			tgtChar = m_twopunctPairs[index].twocharTgt[0];
			int nFound = tgtPunctuation.Find(tgtChar);
			if (nFound == -1)
			{
				// we've found one not included in the single set, so add it to the inventory
				tgtPunctuation += _T(" ");
				tgtPunctuation += tgtChar;
			}
		}
		if (m_twopunctPairs[index].twocharTgt[1] != _T('\0'))
		{
			tgtChar = m_twopunctPairs[index].twocharTgt[1];
			int nFound = tgtPunctuation.Find(tgtChar);
			if (nFound == -1)
			{
				// we've found one not included in the single set, so add it to the inventory
				tgtPunctuation += _T(" ");
				tgtPunctuation += tgtChar;
			}
		}
	}

	// check that < and > have not been omitted, if they have, warn user that they are being
	// automatically added (they are required so that the algorithm for parsing nested quotes
	// with space between them does not get defeated - the nested quotes belong on the same
	// CSourcePhrase instance, not on consecutive ones)
	int offset;
	if (srcPunctuation.IsEmpty())
		goto n; // don't bother with the checks if there is no content anyway
	offset = srcPunctuation.Find(_T("<"));
	if (offset == -1)
	{
        // no left wedge, so it would be treated as a word-building character, which is
        // illegal for standard format, so warn user and insert it; all we do now is make
        // sure it gets put in m_punctuation[0] and [1])
        // BEW changed this, 27Apr05, to also construct a PUNCTPAIR for the < wedge,
        // provided there is space for it
		// IDS_LEFT_WEDGE_ERR
		wxMessageBox(_(
"Sorry, Adapt It will not permit the < character to be used as a word-building character. It must be included with the punctuation characters, and it will be placed there now."),
		_T(""), wxICON_INFORMATION);
		srcPunctuation += _T(" <"); // add it after a delimiting space
		AddWedgePunctPair(_T('<'));
	}
	offset = srcPunctuation.Find(_T(">"));
	if (offset == -1)
	{
        // no right wedge, so it would be treated as a word-building character, which is
        // illegal for standard format, so warn user and insert it (if the user wants to
        // set up the source to target correspondence, he'll have to explicitly return to
        // the dialog manually; all we do now is make sure it gets put in m_punctuation[0]
        // and [1])
		// IDS_RIGHT_WEDGE_ERR
		wxMessageBox(_("Sorry, Adapt It will not permit the > character to be used as a word-building character. It must be included with the punctuation characters, and it will be placed there now."), _T(""), wxICON_INFORMATION);
		srcPunctuation += _T(" >"); // add it after a delimiting space
		AddWedgePunctPair(_T('>'));
	}

	// do the target ones now
	if (tgtPunctuation.IsEmpty())
		goto n; // don't bother with the checks if there is no content anyway
	offset = tgtPunctuation.Find(_T("<"));
	if (offset == -1)
	{
		// we'll do the fix silently for the target language
		tgtPunctuation += _T(" <"); // add it after a delimiting space
	}
	offset = tgtPunctuation.Find(_T(">"));
	if (offset == -1)
	{
		// we'll do the fix silently for the target language
		tgtPunctuation += _T(" >"); // add it after a delimiting space
	}

	// finally, add a delimiting space to the end, provided there is some content already
	if (!srcPunctuation.IsEmpty())
		srcPunctuation += _T(' ');
	if (!tgtPunctuation.IsEmpty())
		tgtPunctuation += _T(' ');
n:	;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      wedge   -> a wxChar representing either '<' or '>'
/// \remarks
/// Called from: the App's GetPunctuationSets().
/// This function is called only if the user tries to use the left wedge '<' and/or right
/// wedgt '>' as word building characters - which is illegal. After notifying the user of
/// the error, the function adds the wedges to the the PUNCTPAIR struct (or TWOPUNCTPAIR
/// struct if all PUNCTPAIR possibilities are already taken).
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::AddWedgePunctPair(wxChar wedge)
{
    // BEW added 27Apr05 to support adding of a left or right wedge PUNCTPAIR (or
    // TWOPUNCTPAIR if all PUNCTPAIR possibilities are already taken, or no effect if both
    // sets of possibilities are already taken) when the GetPunctuationSets() function
    // detects the omission of < or > in the source punctuation set - we assume that such
    // an omission from the source punctuation set (ie. the CString) indicates the lack of
    // < to < or > to >, as the case may be, equivalences and so AddWedgePunctPair builds
    // what we need.
	int index;

    // a PunctPair instance for this wedge might previously have been constructed (such as
    // when dealing with Project configuration where it is lacking after having dealt with
    // its lack in the Basic configuration), so we check for this and do nothing if the
    // appropriate one is already in the m_punctPairs array.
	for (index = 0; index < MAXPUNCTPAIRS; index++)
	{
		if (gpApp->m_punctPairs[index].charSrc == wedge)
			return;
	}
	for (index = 0; index < MAXTWOPUNCTPAIRS; index++)
	{
		if (gpApp->m_twopunctPairs[index].twocharSrc[0] == wedge)
			return;
	}

	// it's not there yet, so create the PunctPair and add it to one of the arrays
	// now (try for the single-to-single one, but if not, the doubles one will do
	bool bAddedIt = FALSE;
	for (index = 0; index < MAXPUNCTPAIRS; index++)
	{
		if (gpApp->m_punctPairs[index].charSrc != _T('\0'))
			continue;
		else
		{
			// found an empty one, so see if its matching target character is also null
			// and if it is, construct the wedge pair here
			if (gpApp->m_punctPairs[index].charTgt != _T('\0'))
			{
				continue; // this one is already filled, so iterate
			}
			else
			{
				// eureka! we can build it now
				gpApp->m_punctPairs[index].charSrc = wedge;
				gpApp->m_punctPairs[index].charTgt = wedge;
				return;
			}
		}
	}
	if (!bAddedIt)
	{
        // If we did not add it in the singles correspondences because all 24 pairs had
        // already got correspondences in them, then we can add it to an empty TWOPUNCTPAIR
        // in the first character of each double - since the algorithm for using
        // equivalences is general enough to cope with this. We exploit the fact that if a
        // double cell is empty, then the first character of the pair will be a null - this
        // is a sufficient condition for an empty cell in the dialog
		for (index = 0; index < MAXTWOPUNCTPAIRS; index++)
		{
			if (gpApp->m_twopunctPairs[index].twocharSrc[0] != _T('\0'))
				continue;
			else
			{
                // found an empty one, so see if its matching target characters are also
                // nulls and if so, construct the wedge pair here
				if (gpApp->m_twopunctPairs[index].twocharTgt[0] != _T('\0'))
				{
					continue; // this one is already filled, so iterate
				}
				else
				{
					// eureka! we can build it now
					gpApp->m_twopunctPairs[index].twocharSrc[0] = wedge;
					gpApp->m_twopunctPairs[index].twocharSrc[1] = _T('\0');
					gpApp->m_twopunctPairs[index].twocharTgt[0] = wedge;
					gpApp->m_twopunctPairs[index].twocharTgt[1] = _T('\0');
					return;
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if destinationFolder is empty, if no configuration file yet
///             exists, or could not set directory path, otherwise TRUE indicating write
///             was successful
/// \param      configFilename     ->   the name of the configuration file (without
///                                     .aic extension)
/// \param      destinationFolder  ->   the path location where the configuration file
///                                     is to be written
/// \param      configType         ->   an enum of basicConfigFile when writing the
///                                     Basic config file; projectConfigFile if writing
///                                     the Project config file
/// \remarks
/// Called from: the App's Terminate() and OnExit(), the Doc's OnNewDocument(),
/// OnSaveModified(), OnOpenDocument(), and OnFilePackDoc(). BEW 9Sep09, also can be
/// called from MakeForeignBasicConfigFileSafe() when needing to clone a basic
/// configuration file in order to produce a AI-AdminBasicConfiguration.aic file.
///
/// Composes the whole configuration file in memory (as a wxTextFile) by calling the
/// appropriate helper functions (WriteFontConfiguration and either
/// WriteBasicSettingsConfiguration or WriteProjectSettingsConfiguration), then writes the
/// in-memory text file to its path/name destination.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::WriteConfigurationFile(wxString configFilename,
										  wxString destinationFolder,ConfigFileType configType)
{
	if (m_bReadOnlyAccess || (IsURI(destinationFolder) && configFilename.Find(_T("AI-Admin")) != 0))
	{
		// BEW added 13Nov09, we don't allow the local user, if he has read-only access
		// to a remote project folder, to cause project or basic config files on the
		// remote machine to be written because of actions done on the local machine
		// whm modified 10Mar10, we also don't allow the local user, if he has access to a
		// remote project folder, to write project or basic config files on the remote
		// machine, unless they are of the "AI-Admin..." type.
		return TRUE; // TRUE to only simulate successful write in WriteConfigurationFile().
	}

	// BEW added 17Aug09, to allow OnExit() to be called without having config files
	// composed and written out when in an error state early in app setup
	if (m_bDoNotWriteConfigFiles)
		return FALSE;

    // WriteConfigurationFile(,,basicConfigFile) to Basic config file: called only in App's Terminate()
    // WriteConfigurationFile(,,projectConfigFile) to Project config file: called in App's OnExit(),
    // OnSaveModified() and OnFilePackDoc() BEW on 4Jan07 added change to
    // WriteConfiguration to save the external current work directory and reestablish it at
    // the end of the WriteConfiguration call, because the latter function resets the
    // current directory to the project folder before saving the project config file - and
    // this clobbered the restoration of a KB from the 2nd doc file accessed
	wxString strSaveCurrentDirectoryFullPath = GetDocument()->GetCurrentDirectory();

	wxString fName = configFilename + _T(".aic"); // extension for config files

	// exit if there is no path yet
	if (destinationFolder.IsEmpty())
	{
		// BEW removed message 31Oct05; it serves no useful purpose
		// because the user does not need to know this
		//IDS_NO_PROJECT_PATH
		return FALSE;
	}
	wxString path;
	path.Empty();
	path << destinationFolder << PathSeparator << fName;
	wxString data = _T("");
	wxString end = _T(""); // we're using wxStrings which already have EOL
	wxString tab = _T("\t");
	wxString number;
	//int color = 0; // default black - unused

	wxLogNull logNo; // avoid spurious messages from the system

	// open the config file for writing
	bool bIsOK = TRUE;
	wxTextFile f;
	// make the working directory the "Adapt It Work" one
	// bool bOK = ::SetCurrentDirectory(destinationFolder); // ignore failures
	bIsOK = ::wxSetWorkingDirectory(destinationFolder);
	wxCHECK_MSG(bIsOK, FALSE, _T("WriteConfigurationFile(): ::wxSetWorkingDirectory() failed, line 29,032 in Adapt_It.cpp"));

	// open the config file for writing
    // wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
    // Note: Need to check if file exists, otherwise if Open fails wxWidgets' wxTextFile
    // conjures up its own error message to that fact which it issues in Idle time, which
    // we don't want.
	bool bSuccessful = TRUE;
	if (!::wxFileExists(path))
	{
		// config file doesn't yet exist so create it
		bSuccessful = f.Create(path);
#ifndef _UNICODE
		// ANSI
		bSuccessful = f.Write(wxTextFileType_None); // read ANSI file into memory
#else
		// UNICODE
		bSuccessful = f.Write(wxTextFileType_None, wxConvUTF8); // write UNICODE file to disk as UTF8
#endif
		bSuccessful = f.Close();
	}

	// open the config file in memory
	// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
#ifndef _UNICODE
	// ANSI
	bSuccessful = f.Open(path); // read ANSI file into memory
#else
	// UNICODE
	bSuccessful = f.Open(path, wxConvUTF8); // read UNICODE file into memory
#endif

	if (!bSuccessful)
	{
		// assume there was no configuration file in existence yet,
		// so nothing needs to be fixed
		return FALSE;
	}

	// Since we are going to write a new config file we clear the
	// current contents from memory
	while (f.GetLineCount())
		f.RemoveLine(0);

	// The fontInfo structs SrcFInfo, TgtFInfo, and NavFInfo should have current
	// information in them, so write out the information to the config file
	// first, do the source font
	data.Empty();
	data << szSourceFont; //data = szSourceFont;
	f.AddLine(data);
	// wx version: WriteFontConfiguration includes the color setting
	WriteFontConfiguration(SrcFInfo,&f);
	f.AddLine(end); // blank line as separator

	// next do the target font
	f.AddLine(szTargetFont);
	// wx version: WriteFontConfiguration includes the color setting
	WriteFontConfiguration(TgtFInfo,&f);
	f.AddLine(end); // blank line as separator

	// next do the navigation text's font
	f.AddLine(szNavTextFont);
	// wx version: WriteFontConfiguration includes the color setting
	WriteFontConfiguration(NavFInfo,&f);
	f.AddLine(end); // blank line as separator

	if (configType == basicConfigFile)
	{
		f.AddLine(szBasicSettings);
		WriteBasicSettingsConfiguration(&f);
	}
	else
	{
		f.AddLine(szProjectSettings);
		WriteProjectSettingsConfiguration(&f);
	}

	if (!f.Write())
		bIsOK = FALSE;

	f.Close();

	// BEW added 04Jan07 to restore the former current working directory
	// to what it was for document accesses
	bIsOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
	wxCHECK_MSG(bIsOK, FALSE, _T("WriteConfigurationFile(): ::wxSetWorkingDirectory() failed, line 29,117 in Adapt_It.cpp"));

	return bIsOK;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if if no configuration file yet exists, or could not could
///             not read it, otherwise TRUE indicating read was successful
/// \param      configFilename     ->   the name of the configuration file (without
///                                     .aic extension)
/// \param      sourceFolder       ->   the path location where the configuration file
///                                     is to be read
/// \param      configType         ->   either the basicConfigFile or projectConfigFile
/// \remarks
/// Called from: the App's GetBasicConfiguration() and GetProjectConfiguration().
/// Reads the whole config file into memory and from there it decomposes it line-by-line
/// (as a wxTextFile) by calling the appropriate helper functions: GetFontConfiguration()
/// and either GetBasicSettingsConfiguration() or GetProjectSettingsConfiguration().
/// whm 24Feb10 modified to move the font mismatch checking to FixConfigFileFonts().
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::GetConfigurationFile(wxString configFilename, wxString sourceFolder,
										ConfigFileType configFType)
{
	wxString fname;
	fname.Empty();
	fname << configFilename << _T(".aic");
	wxString path;
	path.Empty();
	path << sourceFolder << PathSeparator << fname;
	wxString data = _T("");
	wxString name;
	bool	bIsOK = TRUE;
	bool	bSuccessful = FALSE;
	bool	bEmptyConfigFile = FALSE;
	wxString  strValue;
	wxString dummy;

	// make the working directory the "Adapt It Work" one
	bool bOK = ::wxSetWorkingDirectory(sourceFolder);

	wxTextFile f;
	// Under wxWidgets, wxTextFile actually reads the entire file into memory at the Open()
    // call. It is set up so we can treat it as a line oriented text file while in memory,
    // modifying it, then if not just reading it, we can write it back out to persistent
	// storage with a single call to Write().

	wxLogNull logNo; // avoid spurious messages from the system

	wxString configType;
	// whm Note 30Jan12. The wxString configType declaration in the line above was conflicting with the
	// enum 'ConfigFileType configType' parameter declaration in the GetConfigurationFile() function's
	// signature (see above). It has been this way for a long time. This had the effect that the local
	// configType string creation would make override and turn the parameter into an empty string and
	// thus skip the "if...else if" test below entirely. To fix it I changed the parameter name to
	// configFType and modified it accordingly in the comparisons used in this function.
	if (configFType == basicConfigFile)
		configType = _("basic");
	else if (configFType == projectConfigFile)
		configType = _("project");
		
	// open the config file for reading
    // wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
    // Note: Need to check if file exists, otherwise if Open fails wxWidgets' wxTextFile
    // conjures up its own error message to that fact which it issues in Idle time just
    // after it's no longer busy.
	if (!::wxFileExists(path))
	{
		bSuccessful = FALSE;
	}
	else
	{
		// file exists at path.
		// whm added 4Apr12. Check for a zero-length (empty) basic config file
		if (FileIsEmpty(path))
		{
			bEmptyConfigFile = TRUE;
		}
		else
		{

#ifndef _UNICODE
			// ANSI
			bSuccessful = f.Open(path); // read ANSI file into memory
#else
			// UNICODE
			bSuccessful = f.Open(path, wxConvUTF8); // read UNICODE file into memory
#endif
		}
	}
	if (bEmptyConfigFile)
	{
		// whm added 4Apr12. Tell user about the zero-length (empty) basic config file
		wxString msg = _("The %s configuration file exists but it is empty (has no content). Default values will be used instead. You may need to reset some preferences by selecting Preferences... from the Edit menu.");
		msg = msg.Format(msg, configType.c_str());
		wxMessageBox(msg,_T(""),wxICON_WARNING);
		bIsOK = FALSE;
	}
	else if (!bSuccessful)
	{
		// whm added 24Apr12. Don't show the message below anymore if the project config file
		// cannot be opened. The call of GetAIProjectCollabStatus() in the OnWizardPageChanging()
		// function of the ProjectPage now handles this situation in a better way that takes in
		// to account the possibility that the project config file may have had collaboration
		// settings in it.
		if (configFType != projectConfigFile)
		{
			wxString msg;
			msg = msg.Format(_(
	"Unable to open the %s configuration file for reading. Default values will be used instead. (Ignore this message if you have just launched Adapt It for the first time, or have just created a new project, because no configuration file exists yet.)"),
			configType.c_str());
			// assume there was no configuration file in existence yet, so nothing needs to be fixed
			wxMessageBox(msg,_T(""),wxICON_INFORMATION);
		}

		bIsOK = FALSE;

		// This block added by JF Tue 5-Apr-2005.
        // The problem is that, when making a new project in book mode, no default book is
        // specified, meaning that m_pCurrBookNamePair remains NULL, causing this software
        // to crash not far down the track, because elsewhere in this program it is assumed
        // that if book mode is on, m_pCurrBookNamePair is non-NULL. We solve the problem
        // by explicitly defaulting to the first book (book 0) when a new project is
        // created. Of course, all this is subject to us really defaulting to book mode
        // being ON, and since I don't know the conditions under which we default one way
        // or the other for the setting in question, I explicitly test that book mode is on
        // before doing my magic.
		if (m_bBookMode && !m_bDisableBookMode)
		{
            m_nBookIndex = 39;
			m_pCurrBookNamePair = ((BookNamePair*)(*m_pBibleBooks)[m_nBookIndex]);
			m_bibleBooksFolderPath.Empty();
			m_bibleBooksFolderPath << m_curAdaptionsPath << PathSeparator <<
													m_pCurrBookNamePair->dirName;
		}
	}

	if (!bIsOK)
	{
        // whm note: When GetConfiguration is called to get the basic configuration and it
        // fails, and bIsOK is FALSE, in which case the caller calls SetDefaults which sets
        // default color values for the fonts. When GetConfigurationFile is called to get
        // the project configuration and it fails, the previously set values for basic
        // configuration will apply, or if it also failed, those set in OnInit() and
        // Initialize() will prevail. Therefore we, don't need to set the font color
        // defaults here.
		return FALSE;
	}

	// We need to initialize the wxTextFile file pointer to the beginning of the file
	// otherwise the GetNextLine() will fail
	dummy = f.GetFirstLine();

	// The entire basic config file is now in memory and we can read the information
	// by scanning its virtual lines.

    // wx version: fonts are created only once in the App's OnInit(). The default font
    // color is also assigned there using wxFontData::SetColour(). If GetFontConfiguration
    // fails here the default values will be used
	wxString errMsg,msg;
	msg = _(
"Unable to read %s font data from the %s configuration file. Default values will be used instead.");

	// get the source font's SrcFInfo data from the configFileType config file
	bOK = GetFontConfiguration(SrcFInfo,&f);
	if (!bOK)
	{
		wxString fontType = _("source");
		errMsg = errMsg.Format(msg,
			fontType.c_str(), configType.c_str());
		wxMessageBox(errMsg,_T(""),wxICON_WARNING);
	}

	// get the target font's TgtFInfo data from the configFileType config file
	bOK = GetFontConfiguration(TgtFInfo,&f);
	if (!bOK)
	{
		wxString fontType = _("target");
		errMsg = errMsg.Format(msg,
			fontType.c_str(), configType.c_str());
		wxMessageBox(errMsg,_T(""),wxICON_WARNING);
	}

	// get the nav font's NavFInfo data from the configFileType config file
	bOK = GetFontConfiguration(NavFInfo, &f);
	if (!bOK)
	{
		wxString fontType = _("navigation");
		errMsg = errMsg.Format(msg,
			fontType.c_str(), configType.c_str());
		wxMessageBox(errMsg,_T(""),wxICON_WARNING);
	}

    // whm 25Feb10 Note: See FixConfigFileFonts() where font mismatches are dealt with.

	// get the section heading from our in-memory config file
	data = f.GetNextLine(); // data should be "Settings" for basic config file
							// or "ProjectSettings" for proj config file

	GetValue(data, strValue, name);

	// now get the rest of the settings parameters from the config file
	// wx note: The wxTextFile remains open during the following calls which
	// simply continue reading the configuration data from memory
	if (configFType == basicConfigFile) // app level
	{
		bool bBasicConfigHasCollabSettingsData = FALSE;
		wxString collabProjectName = _T("");
		GetBasicSettingsConfiguration(&f,bBasicConfigHasCollabSettingsData,collabProjectName);
		if (bBasicConfigHasCollabSettingsData)
		{
			// In version 6.2.x and following we store the collaboration settings
			// in the specific AI project config files.
			// The just-read basic config file still has collaboration settings, so
			// we will transition them to the appropriate project config file and
			// notify the user of what's happening.
			MoveCollabSettingsToProjectConfigFile(collabProjectName);
		}

		// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
		//ForceCollabSettingsFromCommandLineSwitches();
	}
	else // project level
	{
		GetProjectSettingsConfiguration(&f);

		FixConfigFileFonts(&f);

		// whm added 3Dec08
        // The wx version adds a "SourceHasUpperCaseAndLowerCase" value to the project
        // config file. This value was not in the MFC version. Both the wx version and MFC
        // has the "AutoCapitalizationFlag" setting in the project config file. In the wx
        // version the value for the new "SourceHasUpperCaseAndLowerCase" setting should
        // always be set to TRUE if the AutoCapitalizationFlag was set to TRUE when reading
        // a legacy project config file. So we will ensure that is the case here. If this
        // consistency check is not done, the two global flags can get out of sync, and
        // under some circumstances the wx application may give a spurious error message
        // when it saves values from the Case page (in OnOK) in Preferences after reading a
        // legacy project config file for the first time.
		if (gbAutoCaps == TRUE && gbSrcHasUcAndLc == FALSE)
			gbSrcHasUcAndLc = TRUE;
	}

	// whm added 17Feb12. The collaboration-related command-line switches/options "force"
	// certain of the collaboration values to adhere to the command-line switches/options
	// via tests of the following 5 flags: m_bForceCollabModeON, m_bForceCollabModeOFF,
	// m_bForceCollabExpectsFreeTrans, m_ForceCollabAIProjectName, and
	// m_ForceCollabProjectNames. Those tests previously were in the block for getting
	// the basic settings configuration. I've put those routines in a separate function
	// called ForceCollabSettingsFromCommandLineSwitches() which now should be called
	// also when getting the project settings configuration.

	// whm 20Feb12 removed collab command-line support to implement project-specific collaboration
	//ForceCollabSettingsFromCommandLineSwitches();


	f.Close(); // closes the wxTextFile and frees memory used for it
	return bIsOK;
}

#ifdef _UNICODE

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pp[MAXPUNCTPAIRS]   ->  the PUNCTPAIR array
/// \param      rSrcStr             <-  a wxString that receives the source language
///                                     punctuation characters
/// \param      rTgtStr             <-  a wxString that receives the target language
///                                     punctuation characters
/// \remarks
/// Called from: the App's WriteBasicSettingsConfiguration() and
/// WriteProjectSettingsConfiguration().
/// Populates the strings with the current contents of the array of pairs; source puncts in
/// the rSrcStr, and target ones in rTgtStr. Separating them in such a way allows us to
/// convert each with the encoding appropriate for each when we output the config files to
/// disk.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::PunctPairsToTwoStrings(PUNCTPAIR pp[MAXPUNCTPAIRS],
											wxString& rSrcStr, wxString& rTgtStr)
{
	// clear strings
	rSrcStr.Empty();
	rTgtStr.Empty();

    // populate the strings with the current contents of the array of pairs; source puncts
    // in the rSrcStr, and target ones in rTgtStr - separating them like this allows us to
    // convert each with the encoding appropriate for each when we output the config files
    // to disk
    // BEW changed 15May08 to remove the test for chSrc and chTgt both being null bytes,
    // because that happens when the user clears out a punctuation character from both src
    // and tgt lists in the GUI, and the result was that the wrong test here was causing
    // premature list termination. Our new algorithm should (1) use space as a placeholder
    // for any null, and process the whole set of cells, including empty pairs; (2) on loop
    // termination, remove any matched space pairs at the list ends, as there is no point
    // in keeping them; (3) support "closing of the gaps" when the user removes pairs of
    // punctuation charcters in the GUI, so that the gaps he thereby creates will, after an
    // app exit and relaunch, be closed up (if he wanted to put the removed punctuation
    // characters back in the list, he'd then just add them at the empty cells at the end;
    // (4) implement the same general protocols as 1 -3 for the two character pairs too, in
    // the TwoPunctPairsToTwoStrings() function. The best way to support gap closure is to
    // do it BEFORE the final strings are written out in the configuration file, as that
    // makes reading the punctuation from the config file on app launch and project entry
    // easy, as there would be no gaps to worry about. That means we must implement the
    // "close the gaps" code in this present function, and in the
    // TwoPunctPairsToTwoStrings() function.
	for (int i = 0; i < MAXPUNCTPAIRS; i++)
	{
		wxChar chSrc = pp[i].charSrc;
		wxChar chTgt = pp[i].charTgt;
		if (chSrc == _T('\0') && chTgt == _T('\0'))
		{
			continue; // eliminate this "gap", whether list-medial, or at list end.
		}
		if (chSrc == _T('\0'))
		{
			rSrcStr += _T(" ");
		}
		else
		{
			rSrcStr += chSrc;
		}
		if (chTgt == _T('\0'))
		{
			rTgtStr += _T(" ");
		}
		else
		{
			rTgtStr += chTgt;
		}
	}
}
#endif

#ifdef _UNICODE

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pp[MAXTWOPUNCTPAIRS]   ->   the TWOPUNCTPAIR array
/// \param      rSrcStr                <-   a wxString that receives the source language
///                                         punctuation characters
/// \param      rTgtStr                <-   a wxString that receives the target language
///                                         punctuation characters
/// \remarks
/// Called from: the App's WriteBasicSettingsConfiguration() and
/// WriteProjectSettingsConfiguration().
/// Populates the strings with the current contents of the array of twopunct pairs; source
/// puncts in the rSrcStr, and target ones in rTgtStr. Separating them in such a way allows
/// us to convert each with the encoding appropriate for each when we output the config
/// files to disk.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::TwoPunctPairsToTwoStrings(TWOPUNCTPAIR pp[MAXTWOPUNCTPAIRS],
											 wxString& rSrcStr, wxString& rTgtStr)
{
	// clear strings
	rSrcStr.Empty();
	rTgtStr.Empty();

    // populate the strings with the current contents of the array of twopunct pairs, one
    // string for source text punctuation, the other for target text punctuation; so we can
    // support separate encodings
    // BEW changed 15May08 to remove the test for twocharSrc[0] & [1] both being null
    // bytes, as the old code did not adequately support the user when he cleared out a
    // cell or cell pair medially within the GUI lists; the result was that the test here
    // would cause premature list termination. Our new algorithm should (1) use spaces as a
    // placeholders for null character, and process the whole set of cells, including empty
    // double-pairs; (2) on loop termination, remove any matched space double-pairs at the
    // list ends, as there is no point in keeping them; (3) support "closing of the gaps"
    // when the user removes pairs of punctuation charcters in the GUI, so that the gaps he
    // thereby creates will, after an app exit and relaunch, be closed up (if he wanted to
    // put the removed punctuation characters back in the list, he'd then just add them at
    // the empty cells at the end; (4) implement the same general protocols as 1 -3 for the
    // one character pairs too, in the PunctPairsToTwoStrings() function.
    // The best way to support gap closure is to do it BEFORE the final strings are written
    // out in the configuration file, as that makes reading the punctuation from the config
    // file on app launch and project entry easy, as there would be no gaps to worry about.
    // That means we must implement the "close the gaps" code in this present function, and
    // in the PunctPairsToTwoStrings() function. Only "gaps" where all four characters of
    // paired double characters are absent need be eliminated, these will be four null
    // characters which we need to test for; all other combinations must be retrained,
    // using space as placeholder for each null character.
	for (int i = 0; i < MAXTWOPUNCTPAIRS; i++)
	{
		if (pp[i].twocharSrc[0] == _T('\0') && pp[i].twocharSrc[1] == _T('\0' &&)
			pp[i].twocharTgt[0] == _T('\0') && pp[i].twocharTgt[1] == _T('\0'))
		{
			continue; // remove this gap, whether list-medial or at the end of the list
		}
		wxChar chSrc0 = pp[i].twocharSrc[0];
		wxChar chSrc1 = pp[i].twocharSrc[1];
		wxChar chTgt0 = pp[i].twocharTgt[0];
		wxChar chTgt1 = pp[i].twocharTgt[1];
		if (chSrc0 == _T('\0'))
		{
			// if first is null, put a placeholder space in the string, then check second
			rSrcStr += _T(" ");
			if (chSrc1 == _T('\0'))
				rSrcStr += _T(" ");
			else
				rSrcStr += chSrc1;
		}
		else
		{
			rSrcStr += chSrc0;
			if (chSrc1 == _T('\0'))
				rSrcStr += _T(" ");
			else
				rSrcStr += chSrc1;
		}
		if (chTgt0 == _T('\0'))
		{
			// if first is null, put a placeholder space there in the string , then check second
			rTgtStr += _T(" ");
			if (chTgt1 == _T('\0'))
				rTgtStr += _T(" ");
			else
				rTgtStr += chTgt1;
		}
		else
		{
			rTgtStr += chTgt0; // first is non empty, append it; then check second
			if (chTgt1 == _T('\0'))
				rTgtStr += _T(" ");
			else
				rTgtStr += chTgt1;
		}
	}
}
#endif

#ifdef _UNICODE

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pp[MAXPUNCTPAIRS]   <-  the PUNCTPAIR array that gets populated with
///                                     punct pairs
/// \param      rSrcStr             ->  a wxString that contains the source language
///                                     punctuation characters
/// \param      rTgtStr             ->  a wxString that contains the target language
///                                     punctuation characters
/// \remarks
/// Called from: the App's GetBasicSettingsConfiguration() and
/// GetProjectSettingsConfiguration().
/// Populates the PUNCTPAIR array with the current contents of the punctuation characters
/// stored in the rSrcStr and rTgtStr strings. See PunctPairsToTwoStrings() for the
/// function that does the opposite action.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::TwoStringsToPunctPairs(PUNCTPAIR pp[MAXPUNCTPAIRS],
										  wxString& rSrcStr, wxString& rTgtStr)
{
	// clear the array
	for (int j = 0; j < MAXPUNCTPAIRS; j++)
	{
		pp[j].charSrc = _T('\0');
		pp[j].charTgt = _T('\0');
	}
	// populate the contents of the array of pairs using the string contents
	int lenSrc = rSrcStr.Length();
	int lenTgt = rTgtStr.Length();
	if (rSrcStr.IsEmpty())
		return;
	if (rTgtStr.IsEmpty())
		return;
    // from version 2.2.1 I will make the config table less fragile - the two strings can
    // be different in length (we makes as many pairs as we can, and bale out when there
    // are no more to be made), don't have to be filled to 24 characters by trailing
    // spaces, and we no longer care if they are even or odd in length
	int nCount = -1; // count (index) of how many pairs have been formed
	for (int i = 0; i < MAXPUNCTPAIRS; i++)
	{
		nCount++;
		if (nCount >= lenSrc)
			return; // bale out when source string is traversed
		wxChar ch = rSrcStr.GetChar(i);
		if (ch == _T(' '))
		{
			pp[i].charSrc = _T('\0');
		}
		else
		{
			pp[i].charSrc = ch;
		}
		if (nCount >= lenTgt)
		{
			// end of the target string has been reached, so bale out
			return;
		}
		ch = rTgtStr.GetChar(i); // get its paired target punct char
		if (ch == _T(' '))
		{
			pp[i].charTgt = _T('\0'); // space is used for setting up a null correspondence
		}
		else
		{
			pp[i].charTgt = ch;
		}
	}
}
#endif

#ifdef _UNICODE

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pp[MAXTWOPUNCTPAIRS]   <-   the TWOPUNCTPAIR array that gets populated
///                                         with  two punct pairs
/// \param      rSrcStr                ->   a wxString that contains the source language
///                                         punctuation characters
/// \param      rTgtStr                ->   a wxString that contains the target language
///                                         punctuation characters
/// \remarks
/// Called from: the App's GetBasicSettingsConfiguration() and
/// GetProjectSettingsConfiguration().
/// Populates the TWOPUNCTPAIR array with the current contents of the punctuation
/// characters stored in the rSrcStr and rTgtStr strings. See TwoPunctPairsToTwoStrings()
/// for the function that does the opposite action.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::TwoStringsToTwoPunctPairs(TWOPUNCTPAIR pp[MAXTWOPUNCTPAIRS],
											 wxString& rSrcStr, wxString& rTgtStr)
{
    // if a single character, it can be only in the first position of a pair because in the
    // GUI there is no way to type a single character and make it occupy the second place
    // in the underlying 2-character array; and to get the pairs counting right, when
    // single character pairs are in these lists, the second null byte has to be preserved
    // as a following space. The only removals will have been all four characters null, for
    // a given pair of two-character punctuations; and those removals were done to "close
    // the gaps" left by the user removing the contents of a cell pair. clear the array
	for (int j = 0; j < MAXTWOPUNCTPAIRS; j++)
	{
		pp[j].twocharSrc[0] = _T('\0');
		pp[j].twocharSrc[1] = _T('\0');
		pp[j].twocharTgt[0] = _T('\0');
		pp[j].twocharTgt[1] = _T('\0');
	}

	// populate the contents of the array of two-character pairs using the
	// string contents
	int lenSrc = rSrcStr.Length();
	int lenTgt = rTgtStr.Length();
	int nCount = -1; // from version 2.2.1, we don't require spaces at the end,
					 // just build as many pairs as possible

    // BEW changed 4 May, since allowing singles to be placed in the doubles rows, we can
    // no longer assume pairs; but we can assert the strings must be equal length
	//wxASSERT(lenSrc % 2 == 0); // must be even
	//wxASSERT(lenTgt % 2 == 0); // must be even
	// BEW changed 15May08 to reinstate the earlier protocol, because we eliminated gaps
	// (which eliminated 4 characters at a time, two per string in matching locations,) and
	// so the modulo 2 test must be TRUE for each string
	wxASSERT(lenSrc % 2 == 0); // must be even
	wxASSERT(lenTgt % 2 == 0); // must be even
	wxASSERT(lenSrc == lenTgt); // must be same length

	for (int i = 0; i < MAXTWOPUNCTPAIRS; i++)
	{
		nCount++;
		int k[2] = {2*i,2*i+1};
		if (rSrcStr.IsEmpty())
		{
			return; // no correspondences at all
		}
		if (nCount >= lenSrc/2) // divide  by 2, since we deal with pairs of chars
		{
			return;
		}
		wxChar ch = rSrcStr.GetChar(k[0]);
		wxChar ch1 = rSrcStr.GetChar(k[1]);

		pp[i].twocharSrc[0] = ch; // left one of pair always has a character in it
		if (ch1 == _T(' '))
			{
				// if second was a space, user put a single character in the cell
				// so make this second character a null
				pp[i].twocharSrc[1] = _T('\0');
			}
			else
			{
				// second character of the pair exists, so put it in the array
				pp[i].twocharSrc[1] = ch1;
			}

		if (nCount >= lenTgt/2) // divide by 2, since dealing with pairs
		{
			return;
		}

		// now the target side...
		ch = rTgtStr.GetChar(k[0]);  // get its paired target punct chars
		ch1 = rTgtStr.GetChar(k[1]); // assume there are at least two
									 // chars left, perhaps spaces

		pp[i].twocharTgt[0] = ch; // first of pair is never empty
		if (ch1 == _T(' '))
		{
            // if second was a space, second user put a single character in the cell, so
            // make this second character a null in the character array
			pp[i].twocharTgt[1] = _T('\0');
		}
		else
		{
			// second character of the pair exists, so put it in the array
			pp[i].twocharTgt[1] = ch1;
		}
	}
}
#endif

//ANSI version routines below

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pp[MAXPUNCTPAIRS]   ->  the PUNCTPAIR array
/// \param      rStr                <-  a wxString that receives the punctuation
///                                     characters
/// \remarks
/// Called from: the App's WriteBasicSettingsConfiguration() and
/// WriteProjectSettingsConfiguration().
/// Populates the string with the current contents of the array of pairs.
/// See StringToPunctPairs() for a function that does the opposite action.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::PunctPairsToString(PUNCTPAIR pp[MAXPUNCTPAIRS], wxString& rStr)
{
    // BEW changed behaviour, 27Apr05, of PunctPairsToString so it would iterate, rather
    // than return, if both source and target cells in the punctuation map dialog had been
    // edited so that they contained nothing. If that was the case, we want other cell
    // entries to be utilized; the old algorithm would return and anything subsequent to
    // the empty pair of cells used to be ignored. clear rStr
	rStr.Empty();

	// populate rStr with the current contents of the array of pairs
	for (int i = 0; i < MAXPUNCTPAIRS; i++)
	{
		wxChar chSrc = pp[i].charSrc;
		wxChar chTgt = pp[i].charTgt;
		if (chSrc == _T('\0') && chTgt == _T('\0'))
			continue; // iterate when there is no character in
					  // source & target of the pair
		if (chSrc == _T('\0'))
		{
			rStr += _T(" ");
		}
		else
		{
			rStr += chSrc;
		}
		if (chTgt == '\0')
		{
			rStr += _T(" "); // use space as a placeholder when
							 // user has specified no equivalence
		}
		else
		{
			rStr += chTgt;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pp[MAXTWOPUNCTPAIRS]   ->   the TWOPUNCTPAIR array
/// \param      rStr                   <-   a wxString that receives the punctuation
///                                         characters
/// \remarks
/// Called from: the App's WriteBasicSettingsConfiguration() and
/// WriteProjectSettingsConfiguration().
/// Populates the string with the current contents of the array of two-punct pairs.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::TwoPunctPairsToString(TWOPUNCTPAIR pp[MAXTWOPUNCTPAIRS], wxString& rStr)
{
    // BEW changed behaviour, 27Apr05, of TwoPunctPairsToString so it would iterate, rather
    // than return, if both a source cell in the punctuation map dialog had been edited so
    // it contained nothing. If that was the case, we want other cell entries to be
    // utilized; the old algorithm would return and anything subsequent to the empty source
    // cell used to be ignored. BEW modified 16May08, to work like the Unicode-supporting
    // function does (ie. TwoPunctPairsToTwoStrings()) clear rStr
	rStr.Empty();

	// populate rStr with the current contents of the array of twopunct pairs
	for (int i = 0; i < MAXTWOPUNCTPAIRS; i++)
	{
		if (pp[i].twocharSrc[0] == _T('\0') && pp[i].twocharSrc[1] == _T('\0') &&
			pp[i].twocharTgt[0] == _T('\0') && pp[i].twocharTgt[1] == _T('\0'))
			continue; // skip when matched cell pairs are empty
		wxChar chSrc0 = pp[i].twocharSrc[0];
		wxChar chSrc1 = pp[i].twocharSrc[1];
		wxChar chTgt0 = pp[i].twocharTgt[0];
		wxChar chTgt1 = pp[i].twocharTgt[1];
        // in the following, the GUI character, if there is only one, will always be at the
        // [0] location; the code assumes this could be at [0] or [1], but that generality
        // doesn't have any effect as the actual things which can happen are all catered
        // for anyway
		if (chSrc0 == _T('\0'))
		{
			// if first is null, put a placeholder space in the string, then check second
			rStr += _T(" ");
			if (chSrc1 == _T('\0'))
				rStr += _T(" ");
			else
				rStr += chSrc1;
		}
		else
		{
			rStr += chSrc0;
			if (chSrc1 == _T('\0'))
				rStr += _T(" ");
			else
				rStr += chSrc1;
		}
		if (chTgt0 == '\0')
		{
			// if first is null, put a placeholder space there in the string,
			// then check second
			rStr += _T(" ");
			if (chTgt1 == _T('\0'))
				rStr += _T(" ");
			else
				rStr += chTgt1;
		}
		else
		{
			rStr += chTgt0;  // first is non empty, append it; then check second
			if (chTgt1 == _T('\0'))
				rStr += _T(" ");
			else
				rStr += chTgt1;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pp[MAXPUNCTPAIRS]   <-  the PUNCTPAIR array that is populated from the
///                                     characters in rStr
/// \param      rStr                ->  a wxString that stores the punctuation characters
/// \remarks
/// Called from: the App's InitializePunctuation(), GetBasicSettingsConfiguration() and
/// GetProjectSettingsConfiguration().
/// Populates the PUNCTPAIR array with the current contents of the rStr string.
/// See PunctPairsToString() for a function that does the opposite action.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::StringToPunctPairs(PUNCTPAIR pp[MAXPUNCTPAIRS], wxString& rStr)
{
	// clear the array
	for (int m = 0; m < MAXPUNCTPAIRS; m++)
	{
		pp[m].charSrc = _T('\0');
		pp[m].charTgt = _T('\0');
	}

	// populate the contents of the array of pairs using the string contents
	int len = rStr.Length();
	wxASSERT(len % 2 == 0); // len must be even
	if (rStr.IsEmpty())
		return;

    // from version 2.2.1 I won't pad the string with nulls, which will reduce the
    // fragility of the config file to user editing
	int nCount = -1; // count (index) of how man pairs have been formed
	for (int i = 0; i < MAXPUNCTPAIRS; i++)
	{
		nCount++;
		if (nCount >= len/2)
			return; // bale out when the last pair of characters has been traversed
		int k = 2*i;
		int j = 2*i + 1;
		wxChar ch = rStr.GetChar(k);
		if (ch == _T(' '))
		{
			pp[i].charSrc = _T('\0');
		}
		else
		{
			pp[i].charSrc = ch;
		}
		ch = rStr.GetChar(j); // get its paired target punct char
							  // (it could be a placeholding space)
		if (ch == _T(' '))
		{
			pp[i].charTgt = _T('\0');
		}
		else
		{
			pp[i].charTgt = ch;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pp[MAXTWOPUNCTPAIRS]   <-   the TWOPUNCTPAIR array that is populated
///                                         from the characters in rStr
/// \param      rStr                   ->   a wxString that stores the punctuation
///                                         characters
/// \remarks
/// Called from: the App's InitializePunctuation(), GetBasicSettingsConfiguration() and
/// GetProjectSettingsConfiguration().
/// Populates the TWOPUNCTPAIR array with the current contents of the rStr string.
/// See TwoPunctPairsToString() for a function that does the opposite action.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::StringToTwoPunctPairs(TWOPUNCTPAIR pp[MAXTWOPUNCTPAIRS], wxString& rStr)
{
	// clear the array
	for (int m = 0; m < MAXTWOPUNCTPAIRS; m++)
	{
		pp[m].twocharSrc[0] = _T('\0');
		pp[m].twocharSrc[1] = _T('\0');
		pp[m].twocharTgt[0] = _T('\0');
		pp[m].twocharTgt[1] = _T('\0');
	}

	// populate the contents of the array of two-character pairs using the
	// string contents
	int len = rStr.Length();
	int nCount = -1; // from version 2.2.1, we don't require spaces at the end, just build
					 // as many pairs as possible
	wxASSERT(len % 2 == 0); // len must be even - if not for allowing singles correspondence,
						    // we'd  be able to make it a modulo 4 test; but it will have to
						    // be just mod 2
	for (int i = 0; i < MAXTWOPUNCTPAIRS; i++)
	{
		nCount++;
		int k[2] = {4*i,4*i+1};
		int j[2] = {4*i + 2, 4*i+3};
		if (rStr.IsEmpty())
			return; // no correspondences at all
		if (nCount >= len/4) // divide  by 4, since we deal with pairs of pairs of chars
			return; // we are at the end of the string, so bale out early
					// (don't pad with spaces)
		wxChar ch = rStr.GetChar(k[0]);
		wxChar ch1 = rStr.GetChar(k[1]);
		if (ch == _T(' ') && ch1 == _T(' '))
		{
            // assume no more when both source characters are spaces (this makes old config
            // files get processed safely)
			return;
		}
		else
		{
			if (ch == _T(' '))
			{
				// if first was a space, second will be non-zero
				pp[i].twocharSrc[0] = _T('\0');
				pp[i].twocharSrc[1] = ch1;
			}
			else
			{
				pp[i].twocharSrc[0] = ch;
				if (ch1 == _T(' '))
					pp[i].twocharSrc[1] = _T('\0');
				else
					pp[i].twocharSrc[1] = ch1;
			}
		}
		ch = rStr.GetChar(j[0]); // get its paired target punct chars
		ch1 = rStr.GetChar(j[1]);
		if (ch == _T(' '))
		{
			// if first was a space, second may not be
			pp[i].twocharTgt[0] = _T('\0');
			if (ch1 == _T(' '))
				pp[i].twocharTgt[1] = _T('\0');
			else
				pp[i].twocharTgt[1] = ch1;
		}
		else
		{
			pp[i].twocharTgt[0] = ch;  // first of pair is not empty
			if (ch1 == _T(' '))
				pp[i].twocharTgt[1] = _T('\0');
			else
				pp[i].twocharTgt[1] = ch1;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated
///                         menu item is selected
/// \remarks
/// Called from: The Event Table of the CAdapt_ItApp class in response to a File | Page
/// Setup menu command. Currently, the Page Setup dialog provided with wxWidgets only takes
/// margin settings in millimetres. As a consequence of this the Units Of Measure dialog
/// and Preference page only allow the selection of "Centimeters" with the "Inches"
/// selection disabled.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnFilePageSetup(wxCommandEvent& WXUNUSED(event))
{
	// wxWidgets Note:
    // The page setup dialog as it is currently instituted in wxWidgets appears to only
    // take margin units in millimetres. There is no provision for changing the Windows
    // page setup dialog flags parameter. It might be possible to override the default
    // dialog in a Windows port, but not sure about Linux or Mac. Therefore, I'm going to
    // leave it in millimeters here for now. TODO: I'll have to look at it again when
    // instituting the "Units of Measure..." dialog.

    // MFC Note: this code works fine for starting with Portrait orientation and changing
    // to Landscape; but when opening the Page Setup dialog in Landscape orientation, the
    // dialog does not show the radio button for Landscape checked, instead Portrait is
    // checked. Clicking OK will then restore Portrait, or Cancel will leave user in
    // Landscape, so the behaviour is reasonable, the only problem is that landscape is not
    // reflected in the button setting. This can't be changed without my having to set up a
    // subclass and access the radio button from it - a lot of work for very little payoff,
    // so I will see if I can get away with not doing it.

	// create the page setup class instance using defaults
	CAdapt_ItView* pView = GetView();
	LogUserAction(_T("Initiated OnFilePageSetup()"));
	if (pView == NULL)
	{
		wxMessageBox(_T(
		"Unable to display page setup dialog because no View is currently valid."));
		LogUserAction(_T("Unable to display page setup dialog because no View is currently valid."));
		return;
	}

	// The pPgSetupDlgData and pPrintData objects were created in OnInit() and exist
	// while the App itself exists, so we need not create temporary ones here as the
	// MFC version does.


    // Margins and Paper Size are kept in the App, so update the pPgSetupDlgData with them
    // The MFC version internally keeps these measurements in 1,000ths of an inch. We'll
    // maintain the MFC internal storage units, but we'll need to convert them to
    // millimetres for the dialog's text boxes.
	// SetMarginTopLeft, SetMarginBottomRight, and SetPaperSize expect values
	// in millimetres (use thousandths of inches internally)

    // Set the page orientation according to the App's m_bIsPortraitOrientation. Note:
    // SetPageOrientation() sets the page orientation in our pPrintData global
	SetPageOrientation(m_bIsPortraitOrientation);
	// the initializations of pPgSetupDlgData are done in OnInit()

    // Patrick Rietveld reported 19Dec08 that in his Dutch version of Windows XP the paper
    // size selection and the orientation came up from the system grayed out. The following
    // lines attempt to enable those parts of the Page Setup dialog (assuming the system
    // will allow it). Update 23Dec08 - Patrick subsequently said he was mistaken and found
    // that he was actually running the v. 3.6.4 legacy version, but that the wx version
    // 4.0.4 was OK. So there is likely no need for the following Enable... calls, but they
    // don't hurt anything and might help ensure that those parts of the Page Setup dialog
    // actually work in some situations, so I'll leave them here in the code.
	pPgSetupDlgData->EnableMargins(TRUE);
	pPgSetupDlgData->EnableOrientation(TRUE);
	pPgSetupDlgData->EnablePaper(TRUE);
	pPgSetupDlgData->EnablePrinter(TRUE);

	// Margin MM values determined using the less precise
	// config_only_thousandthsInchToMillimetres conversion factor
	pPgSetupDlgData->SetMarginTopLeft(wxPoint(m_marginLeftMM,m_marginTopMM));
	pPgSetupDlgData->SetMarginBottomRight(wxPoint(m_marginRightMM,m_marginBottomMM));
	// Paper size MM values determined using the more precise
	// thousandthsInchToMillimetres conversion factor
	pPgSetupDlgData->SetPaperSize(wxSize(m_pageWidthMM,m_pageLengthMM));
	// set the paper id, converting it from MFC's enum to wx's enum.
	// Note: SetPaperId() overrides the explicit paper dimensions passed in
	// wxPageSetupDialogData::SetPaperSize()
	pPgSetupDlgData->SetPaperId(MapMFCtoWXPaperSizeCode(m_paperSizeCode));

	// put up page setup dialog for the canvas using default print data setup
    wxPageSetupDialog pageSetupDialog(GetMainFrame()->canvas, pPgSetupDlgData);
    if (pageSetupDialog.ShowModal() == wxID_CANCEL)
	{
		// user cancelled
		LogUserAction(_T("Cancelled from OnFilePageSetup()"));
		return;
	}
	else
	{
		// User pressed OK
		//
		// Get any new values and store them in the global print data object.
		(*pPrintData) = pageSetupDialog.GetPageSetupData().GetPrintData();
		// Get updated values and store them in the global page setup dialog data object.
		(*pPgSetupDlgData) = pageSetupDialog.GetPageSetupData();

		// save new values for configuration file when next written out
        // MFC says, "we use SAE units internally, so that we can just use MM_LOENGLISH for
        // both SAE and Metric
		wxPoint pt;
		pt = pPgSetupDlgData->GetMarginTopLeft();
		m_marginLeftMM = pt.x;
		m_marginLeft = (int)(pt.x*config_only_millimetresToThousandthsInch);
		m_marginTopMM = pt.y;
		m_marginTop = (int)(pt.y*config_only_millimetresToThousandthsInch);
		pt = pPgSetupDlgData->GetMarginBottomRight();
		m_marginRightMM = pt.x;
		m_marginRight = (int)(pt.x*config_only_millimetresToThousandthsInch);
		m_marginBottomMM = pt.y;
		m_marginBottom = (int)(pt.y*config_only_millimetresToThousandthsInch);

		wxPaperSize pSize,pSizepd;
		// pSize for debugging only
		pSize = pPgSetupDlgData->GetPaperId();
		pSize = pSize; // for debugging only. whm note: pSize is a wxPaperSize enum instance, not a pointer
		pSizepd = pPrintData->GetPaperId();
		m_paperSizeCode = MapWXtoMFCPaperSizeCode(pSizepd);

		wxSize size;
		size = pPgSetupDlgData->GetPaperSize();
		m_pageWidthMM = size.x;
		m_pageLengthMM = size.y;
		m_pageWidth = (int)(size.x*millimetresToThousandthsInch);
		m_pageLength = (int)(size.y*millimetresToThousandthsInch);

		m_bIsPortraitOrientation = (pPrintData->GetOrientation() == wxPORTRAIT);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxUpdateUIEvent that is generated when the File Menu
///                         is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress the Page Setup menu item is always disabled and this
/// handler returns immediately. Otherwise, if the application has a valid View pointer,
/// the "Page Setup..." item on the File menu is enabled, otherwise it is disabled.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateFilePageSetup(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// Shouldn't enable the File|Page Setup... interface unless there is a valid view
	CAdapt_ItView* pView = GetView();
	if (pView != NULL)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      bIsPortrait   -> TRUE for portrait, FALSE for landscape
/// \remarks
/// Called from: the App's OnInit(), OnFilePageSetup(), and the View's OnInitialUpdate()
/// Calls the SetOrientation() method of the global wxPrintData object passing it either
/// the wxPORTRAIT or wxLANDSCAPE symbol as parameter, depending on the value of
/// bIsPortrait passed into the current function.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetPageOrientation(bool bIsPortrait)
{
	// pPrintData is the App's wxPrintData member
	if (pPrintData->IsOk())
	{
		if (bIsPortrait)
			pPrintData->SetOrientation(wxPORTRAIT);
		else
			pPrintData->SetOrientation(wxLANDSCAPE);
		// ensure that the pPgSetupDlgData gets any pPrintData change
		//(*pPgSetupDlgData) = (*pPrintData); // NO!!, Doing this resets the default pPgSetupDlgData!
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     1 if portrait, 2 if landscape (for compatibility with MFC)
/// \remarks
/// Called from: AIPrintout::OnPreparePrinting(), DoExportSrcOrTgtRTF() of
/// ExportFunctions.cpp, and the CExportInterlinearDlg's constructor.
/// Calls the GetOrientation() method of the global wxPrintData object. If it returns
/// wxPORTRAIT this function returns 1; if it returns wxLANDSCAPE this function returns 2
/// (for compatibility with MFC).
////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::GetPageOrientation()
{
	// returns 1 if dmOrientation = 1 (portrait),
	// returns 2 if dmOrientation = 2 (landscape)
	int nOrientation = 1; // default is portrait

	// pPrintData is the App's wxPrintData member
	if (pPrintData->IsOk())
	{
		if (pPrintData->GetOrientation() != wxPORTRAIT)
		{
			wxASSERT(pPrintData->GetOrientation() == wxLANDSCAPE);
			nOrientation = 2;
		}
	}
	return nOrientation;
}

#ifdef _UNICODE

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      bstr       ->   a CBString containing the single-byte character
///                             string to be converted
/// \param      convStr    <-   a wxString representing the UTF-16 converted string
/// \remarks
/// Called from: the Doc's DoUnpackDocument(), the View's
/// DoConsistentChanges(), FileContainsBookIndicator() in helpers.cpp, ParseXML() in
/// XML.cpp as well as AtBooksAttr() and AtSFMAttr(), and CXMLErrorDlg::InitDialog().
/// Converts a single-byte character string, which is ASCII or UTF-8 (as returned from
/// parsing XML data) to a Unicode (UTF-16) string storing it in the wxString convStr. See
/// also the overloaded version in which the function returns the converted wxString.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::Convert8to16(CBString& bstr,wxString& convStr)
{
    // Convert8to16 is used for converting a single-byte character string stored in
    // CBString, which is ASCII or UTF-8, (as returned from parsing XML data), and
    // converting it to a UTF-16 string in a CString instance. BEW added an overloaded
    // version on 09Aug05, which returns a copy of the constructed CString - this
    // overloaded version is more useful because it can be then used within the parameter
    // list of function signatures

	// This function is only called when _UNICODE is defined, so we'll use the appropriate
	// portion of the function of the same name defined in the CBString class.
#if !wxUSE_UNICODE
#error "This program can't be built without wxWidgets library built with wxUSE_UNICODE set to 1"
#endif
	wxWCharBuffer buf(wxConvUTF8.cMB2WC(bstr.GetBuffer()));
	if(!buf.data())
	{
		convStr.Empty();
		return;
	}
	convStr = wxString(buf);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the UTF-16 converted string
/// \param      bstr       ->   a CBString containing the single-byte character string
///                             to be converted
/// \remarks
/// Called from: the Doc's DoUnpackDocument(), the View's DoConsistentChanges(),
/// FileContainsBookIndicator() in helpers.cpp, ParseXML() in XML.cpp as well as
/// AtBooksAttr() and AtSFMAttr(), and CXMLErrorDlg::InitDialog().
/// Converts a single-byte character string, which is ASCII or UTF-8 (as returned from
/// parsing XML data) to a Unicode (UTF-16) string which it returns.
/// See the overloaded void function which returns the converted string in a reference
/// parameter. See also the complementary Convert16to8() function which converts the other
/// direction.
/// GDLC 8Sep11 No longer called from DoInputConversion()
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::Convert8to16(CBString& bstr)
{
	// This function is only called when _UNICODE is defined, so we'll use the appropriate
	// portion of the function of the same name defined in the CBString class.
#if !wxUSE_UNICODE
#error "This program can't be built without wxWidgets library built with wxUSE_UNICODE set to 1"
#endif
	wxWCharBuffer buf(wxConvUTF8.cMB2WC(bstr.GetBuffer()));
	if(!buf.data())
		return buf;
	return wxString(buf);
}
#endif

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pBuf       <- the wxChar buffer which receives the converted text
///	\param		bufLen	   <- the length of the wxChar buffer
/// \param      pbyteBuff  -> the byte buffer containing the text to be converted
/// \param      eEncoding  -> the encoding to use if there is no BOM in the input
/// \param      byteBufLen -> the length of the byte buffer to be converted
/// \remarks
/// Called from: the Doc's GetNewFile() and CCCTabbedDialog::DoEditor().
/// Converts a UTF-8 or UTF-16 input text to the required UTF-16 for internal use in
/// Adapt It, removing any BOM that may be present before storing the text in pBuf.
/// Because TokeniseText() and other related functions in Adapt It rely on the presence of
/// a wchar_t NUL at the end of their input wxStrings, the byte buffer pbyteBuff should
/// have a terminating NUL (4 bytes in the UNICODE build) and its specified length
/// byteBufLen should include this NUL.
///
///	Note: This function now needs the wxConvAuto_AI from wxWidgets 2.9.1
//
//	GDLC 8Sep11 Modified to use wxConvAuto_AI
//	GDLC 9Sep11 Removed params eEncoding and bHasBOM
//	GDLC 16Sep11 Put eEncoding back in for wxConvAuto_AI default encoding
//	GDLC 25Nov11 Added length parameter to constructor for dstStr
//	GDLC 7Dec11 Changed to returning a wxChar buffer. NOTE: callers need to free the
//				wxChar buffer when they have finished with it.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DoInputConversion(wxChar*& pBuf,wxUint32& bufLen, const char* pbyteBuff,
									 wxFontEncoding eEncoding, size_t byteBufLen)
{
#define NUL	'\0'
#ifdef _UNICODE
	wxConvAuto_AI conv(eEncoding);
	// GDLC 26Nov11 Because the pbyteBuff could be UTF16 which has numerous NUL bytes,
	// we specify the length of the input buffer rather than allow ToWChar to stop
	// when it finds a NUL.
	size_t dstLen = conv.ToWChar(NULL, 0, pbyteBuff, byteBufLen);
	if ( dstLen == wxCONV_FAILED )
	{
		LogUserAction(_T("conv.ToWChar() could not understand the input byte buffer"));
		// GDLC 26Jan12 Return an empty wxChar buffer
		wxChar *dst = new wxChar[1];
		pBuf = dst;
		bufLen = 0;
		return;
	}
	// Create a wxChar buffer in which to build the converted string of wxChars
	// The caller will have to dispose of this when it is no longer needed
	wxChar *dst = new wxChar[dstLen];
	if ( conv.ToWChar(dst, dstLen, pbyteBuff, byteBufLen) == wxCONV_FAILED )
	{
		LogUserAction(_T("conv.ToWChar() could not complete the conversion of the input byte buffer"));
		// GDLC 26Jan12 Return an empty wxChar buffer
		wxChar *dst = new wxChar[1];
		pBuf = dst;
		bufLen = 0;
		return;
	}
	pBuf = dst;
	bufLen = dstLen;
#else
	// ANSI code goes in here. A wxChar is one byte only.
	// Create a wxChar buffer in which to build the converted string of wxChars
	// The caller will have to dispose of this when it is no longer needed
	eEncoding = eEncoding; // prevent a compiler warning
	wxChar* dst = new wxChar[byteBufLen];
	char* p = const_cast<char*>(pbyteBuff);
	wxChar* q = dst;
	size_t n = 0;
	// Copy characters until byteBufLen or a NUL
	for (size_t i=0; i<byteBufLen; i++, n++)
	{
		if ((*q++ = *p++) == NUL) break;
	}
	pBuf = dst;
	bufLen = n;
#endif
}

// whm Note: The ConvertAndWrite() function might not actually be needed within the WX version because
// the wxTextFile class in wxWidgets automatically takes care of UNICODE and non-Unicode conversions.
// The places in the MFC app where ConvertAndWrite() is used is for the writing of:
//    1. The WriteFontConfiguration parts of the config files. [WX version uses wxTextFile]
//    2. The WriteBasicSettingsConfiguration config file. [WX version uses wxTextFile]
//    3. The WriteProjectSettingsConfiguration config file. [WX version uses wxTextFile]
//    4. The MakeForeignBasicConfigFileSafe (config file). [WX version uses wxTextFile]
//    5. The OnRetransReport function. [WX version uses ConvertAndWrite now, but could use wxTextFile]
//    6. The DoOneDocReport function (called from DoRetranslationReport). [WX version uses ConvertAndWrite now, but could use wxTextFile]
//    7. The DoKBExport function. [WX version uses ConvertAndWrite now, but could use wxTextFile]
//    8. The DoExportSrcOrTgt function. [WX version uses ConvertAndWrite and wxTextFile doesn't lend
//                                         itself to simple buffer conversions]
// For the above functions that can utilize the wxTextFile class for writing the output, the
// ConvertAndWrite() function would not be needed; but in DoExportSrcOrTgt() the wxTextFile class is
// not really suitable for use there, therefore we retain ConvertAndWrite() in the WX version.

// file in the _UNICODE version.
#ifdef _UNICODE

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      eEncoding           ->  (unused in wx version)
/// \param      pFile               <-  a pointer to the wxFile being written
/// \param      str                 ->  the string being converted and written
/// \param      bNoTerminatingNull  ->  if TRUE we don't allow for a terminating
///                                     null (line-based output)
/// \remarks
/// Called from: the View's OnRetransReport(), DoOneDocReport(), DoKBExport(), and
/// DoExportSrcOrTgt() in ExportFunctions.cpp.
/// Converts the string str from its internal UTF-16 to UTF-8 and writes it to pFile.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ConvertAndWrite(wxFontEncoding WXUNUSED(eEncoding), wxFile* pFile,
								   wxString& str)
{
    // MFC original Note: convert from internal UTF-16 to either the user's legacy
    // encoding, or for all other input encodings, (including UTF-16 or variants thereof)
    // to UTF-8; and then write the bytes out

	wxCharBuffer tempBuf = str.mb_str(wxConvUTF8);
	size_t nLen = strlen(tempBuf); //strlen(lpMacroConvertedText);
	// don't allow for a terminating null when we are doing line-based output
	// (ie. the flag is TRUE)
    // whm Note: In the wx version we handle the output of platform appropriate eol
    // sequences as a separate output process, so the bNoTerminatingNull is always TRUE.
	//if (!bNoTerminatingNull) // whm: defaults to TRUE and never explicitly called with
							   // FALSE in wx version, so not needed
	//	nLen++;

	// Note: Early on in Unicode builds, tempBuf ended up with only the first character
	// of the string str (a backslash). This resulted in the pFile->Write(tempBuf,nLen)
	// and the alternate pFile->Write(str) function calls outputting only a backslash
	// character. The failure turned out to happened in the str.mb_str(wxConvUTF8) conversion
	// which is apparently also used implicitly in the pFile-Write(str) call.
	// It turns out that the reason for the failure was that in the caller (the View), the
	// source.UngetWriteBuf() call was not made to get the buffer back into shape before
	// passing the source string to ConvertAndWrite!!

	wxLogNull logNo; // avoid spurious messages from the system

	// write it out
	pFile->Write(tempBuf,nLen);

	// whm note: the following defaults to doing the same thing as the code above
	// using the str.mb_str(wxConvUTF8) call and the wxCharBuffer.
	//pFile->Write(str); // default for wxFile Write is wxConvUTF8
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a CBString representing the UTF-8 converted string
/// \param      str  -> a wxString representing a UTF-16 string to be converted to UTF-8
/// \remarks
/// Called from: the App's MakeKBElementXML(), DoKBSaveAsXML(), the Doc's
/// ConstructSettingsInfoAsXML(), from CSourcePhrase::MakeXML(), and MakeMSWORDWarning() in
/// XML.cpp.
/// Converts a UTF-16 string to UTF-8.
/// See the complementary Convert8to16() function which converts the other direction.
////////////////////////////////////////////////////////////////////////////////////////
CBString CAdapt_ItApp::Convert16to8(const wxString& str)
{
	// converts UTF-16 strings to UTF-8

    // The wxString::mb_str() method returns a wxCharBuffer. The wxConvUTF8 is a predefined
    // instance of the wxMBConvUTF8 class which converts between Unicode (UTF-16) and
    // UTF-8. The CBString constructor is happy to accept the wxCharBuffer
	wxCharBuffer tempBuf = str.mb_str(wxConvUTF8);
	return CBString(tempBuf);
}

#endif // for _UNICODE

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxUpdateUIEvent that is generated when the
///                         Advanced Menu is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is in Free Translation Mode or the m_pSourcePhrases pointer is NULL,
/// the "Transform Adaptations Into Glosses..." menu item on the Advanced menu is disabled
/// and this handler returns immediately.
/// If m_pSourcePhrases has at least one item in its list and the appropriate KB is in a
/// ready state, "Transform Adaptations Into Glosses..." menu item on the Advanced menu is
/// enabled, otherwise it is disabled.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateAdvancedTransformAdaptationsIntoGlosses(wxUpdateUIEvent& event)
{
    // BEW ammended 31Aug05; enabled if a project is open but no document is open, and we
    // no longer care whether book mode is on or not, or if it has been disabled - because
    // what will happen depends on whether book folders are in the Adaptations folder of
    // the chosen project for transformation -- if they are there, we must create them in
    // the current project too (if not already there)

	// wxWidgets uses OnIdle time to poll the wxUpdateUIEvents. Hence, onUpdate
	// handlers get called earlier in the wxWidgets version than in the MFC version.
	// Hence this, and other OnUpdate handlers get called when the m_pSourcePhrases
	// pointer is still NULL, causing the following if() line to crash.
	//if (GetDocument()->m_pSourcePhrases->GetCount() == 0 && m_bKBReady && m_bGlossingKBReady)
	// To prevent this I've added a conditional statement to prevent the test being made when
	// the Doc's m_pSourcePhrases member pointer is NULL.
	// TODO: I think a better approach would be to have actual global boolean flags called
	// bProjectOpen and bDocumentOpen that could be used for the many cases (especially
	// for the OnUpdate... handlers) when certain actions need to be taken based on
	// whether the project and/or document is open or not.

	// whm added 26Mar12.
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}

	// If the project and/or the doc are not yet set up don't enable the interface
	if (m_pSourcePhrases == NULL)
	{
		event.Enable(FALSE);
		return;
	}

	if (m_pSourcePhrases->GetCount() == 0 && m_bKBReady && m_bGlossingKBReady)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated
///                         menu item is selected
/// \remarks
/// Called from: The Event Table of the CAdapt_ItApp class in response to a "Transform
/// Adaptations Into Glosses..." command on the Advanced menu.
/// Shows the CTransformToGlossesDlg dialog which allows the advanced user to take
/// adaptations done in a different project and turn them into glosses for reference in the
/// current project. Usually the adaptations taken are those which were done as a back
/// translation of a different, but related language project - the back translations being
/// done into a major language. If the source language for the back translation project was
/// a language related to the current language and is being contemplated as the source
/// language for adaptation work into the current language, this command can be used to
/// pre-populate Adapt It ready documents for the current project that contain the major
/// language adaptations (from the other back translation project) and transform them into
/// glosses for reference while adapting in the current project. Such pre-populated gloss
/// lines can help explain the meaning of the source text for MTTs working on adapting from
/// that "other" language into the current language. See "Transform Adaptations Into
/// Glosses" in the Adapt It Basics.doc reference document in the Adapt It start menu
/// group.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnAdvancedTransformAdaptationsIntoGlosses(wxCommandEvent& WXUNUSED(event))
{
	CTransformToGlossesDlg dlg(GetMainFrame());
	dlg.Centre();
	if (dlg.ShowModal() == wxID_OK)
	{
		// user is ready to proceed (i.e., pressed "Yes").
		gpApp->LogUserAction(_T("Initiated OnAdvancedTransformAdaptationsIntoGlosses()"));
		gbExcludeCurrentProject = TRUE; // cause suppression of name of current project

		// save entry state (only necessary if entry state had book mode on)
		BookNamePair* pSave_BookNamePair = m_pCurrBookNamePair;
		int nSave_BookIndex = m_nBookIndex;
		wxString save_bibleBooksFolderPath = m_bibleBooksFolderPath;

        // The process will open documents in another project; and these have various
        // settings stored within them (such as whether or not book mode was turned on when
        // the document was created, and SF set and which markers are filtered, etc). These
        // settings should be preserved into the transformed document files, and we do so.
        // The document settings which are in effect when the last such document has been
        // processed will therefore be the settings which obtained for that document when
        // last saved in the 'other' project. In particular, book mode may have been on or
        // off, and so - depending on what the setting is in the last document processed -
        // it may get turned on as a byproduct of the process, or turned off. There is no
        // reliable way to do otherwise, such as to have the process support document
        // settings originally in the receptor project, since typically there will be no
        // documents in the receptor project when the process is initiated. The last
        // section of code in this block will therefore aim to get the application
        // consistent with whatever was the last document processed

		bool bOK;
		bOK = AccessOtherAdaptionProject(); // see the list and choose one
		wxCHECK_RET(bOK, _T("OnAdvancedTransformAdaptationsIntoGlosses(): AcessOtherAdaptionProject() returned FALSE, line 30,478 in Adapt_It.cpp"));

		// restore the flag to its default value
		gbExcludeCurrentProject = FALSE;
		// restore the former book mode parameters (even if book mode was not on on entry)
		m_pCurrBookNamePair = pSave_BookNamePair;
		m_nBookIndex = nSave_BookIndex;
		m_bibleBooksFolderPath = save_bibleBooksFolderPath;
		// now, if the user opens the Document tab of the Start Working wizard, and book
		// mode is on, then at least the path and index and book name are all consistent

        // determine what the last document's settings are, and make sure supporting
        // variables are consistent with them - what this boils down to is to determine if
        // book mode has been turned on, and if so, to make sure that the app member
        // m_bibleBooksFolderPath is not null; if it is null, then turn off book mode to
        // force the user to manually turn it back on if he wants it, which will set
        // everything up correctly. (Note: m_bibleBooksFolderPath is set to the folder path
        // in the function DoTransformationsToGlosses, just after the other project's
        // document has been loaded)
		if (m_bBookMode)
		{
			if (m_bibleBooksFolderPath.IsEmpty())
			{
				// no path defined, so having the mode on would lead to a crash,
				// so turn it off
				m_bBookMode = FALSE;
				m_nBookIndex = -1;
				m_nDefaultBookIndex = 39;
				m_nLastBookIndex = 39;
			}
		}
	}
	else
	{
		// user is not ready to proceed, so he clicked the No button
		gpApp->LogUserAction(_T("Cancelled OnAdvancedTransformAdaptationsIntoGlosses()"));
		return;
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if no error
/// \remarks
/// Called from: the App's OnAdvancedTransformAdaptationsIntoGlosses(). Presents the user
/// with the COpenExistingProjectDlg dialog which lists possible projects. Based on the
/// user's selection it computes the needed paths to the other project which is to supply
/// the adaptations to be transformed into glosses for both (glossing) KB and documents.
/// That is, the user should first create an "empty" target project by some means - such as
/// the Start Working... wizard, with suitable source and target names - this will be come
/// the project in which the documents have source text and glosses but no adaptations; and
/// then from within that open project, the command is given to transform a source project
/// - which then causes a dialog to open for the user to navigate to the source project to
/// be used for the transformations. Note: the source project's doc files and kbs are NOT
/// changed in any way in this transformation process. Then when the dialog is dismissed
/// the transformations are done.
/// The target target project's KB and glossingKB are exported to temporary files before
/// the transforms are done, and then after they are finished, they are imported
/// automatically back to the KBs - so if there are adaptations or glosses initially in the
/// being-transformed project, they won't be lost.
/// Note 2: The both source and target projects will be, and must be, within the one work
/// folder. It is not possible to perform this transformation across work folders on
/// different machines, nor between two work folders on the same machine. (BEW 11Sep09)
/// BEW 2July10, updated for support of kbVersion 2, and preserving KB contents too
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::AccessOtherAdaptionProject()
{
	// BEW added 05Jan07 to enable work folder on input to be restored when done
	wxString strSaveCurrentDirectoryFullPath = GetDocument()->GetCurrentDirectory();

	bool bSuccess = FALSE;
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc);
	COpenExistingProjectDlg dlg(GetMainFrame());
	dlg.Centre();

	// put up the dialog
	if(dlg.ShowModal() == wxID_OK)
	{
		// get the chosen "other" project's name
		wxString strOtherProjectName = dlg.m_projectName;

		// define paths to the other project's kb file and adaptations folder
		wxString strOtherProjectPath = _T("");
		if (!m_customWorkFolderPath.IsEmpty() && m_bUseCustomWorkFolderPath)
		{
			strOtherProjectPath = m_customWorkFolderPath +
											PathSeparator + strOtherProjectName;
		}
		else
		{
			strOtherProjectPath = m_workFolderPath +
											PathSeparator + strOtherProjectName;
		}
		wxString strOtherAdaptationsPath = strOtherProjectPath +
										PathSeparator + m_adaptionsFolder;
		// m_adaptionsFolder is defined in the app creator as _T("Adaptations")

        // determine whether or not there are Bible book folders in the Adaptations folder
        // of the "other" project (the one to be transformed)
        // whm note: AreBookFoldersCreated() has the side effect of changing the current
        // work directory to the passed in strOtherAdaptationsPath.
		gbHasBookFolders = AreBookFoldersCreated(strOtherAdaptationsPath);
		if (gbHasBookFolders)
		{
            // there may not be any book folders yet in the Adaptations folder of the
            // current project (the one which is going to accept the transformed KBs and
            // documents), if that is the case, then insert a set of folders there ready
            // for receiving the transformed documents
            // whm note: AreBookFoldersCreated() has the side effect of changing the
            // current work directory to the passed in m_curAdaptionsPath.
			bool bCurrentProjectHasBookFolders = AreBookFoldersCreated(m_curAdaptionsPath);
			if (!bCurrentProjectHasBookFolders)
			{
				// install them
				CreateBookFolders(m_curAdaptionsPath,m_pBibleBooks);
			}
		}

        // in version 3 we have the possibility of KB files being binary (*.KB) or XML
        // (*.xml) and either can be on disk when the m_gSaveAsXML flag has the 'opposite'
        // value to what would be expected from the kb file's extension, so we have to set
        // up alternate names and check for what file type is actually present, and use
        // that
		// BEW changed 28May10, because from version 4.0.0 onwards we no longer support
		// binary document and KB files ( so removed two wxString variables here, leaving
		// only the xml ones)
		wxString strOtherKBNameXML = strOtherProjectName + _T(".xml");
		wxString strOtherKBPathXML = strOtherProjectPath + PathSeparator + strOtherKBNameXML;

		// BEW 6July10, I've made this functionality able to preserve any adapting (and
		// even any glossing) work done in the target project as follows: before
		// transforming the KB, both the target projects glossing KB and adapting KB are
		// exported (in SFM form) to temporary files in the project folder, and after the
		// transformations are completed, these are imported back to the glossing and
		// adapting KBs. Also, if any document in the "other" project (i.e. the source of
		// the documents to be transformed) has the same filename as a document in the
		// target (i.e. transformed) project, then that other project's document is
		// skipped -- doing this ensures that the doc transformations do not overwrite any
		// transformed document in which the user has done some adapting work. Supporting
		// these changes requires a new function, EnumerateDocFiles_ParametizedStore()
		// which passes in by reference the wxArrayString to be used for temporarily
		// storing the enumerated document files from the target project's current folder
		// (either Adaptations, or a Bible book folder, as the case may require).
		// A beneficial effect of these changes is that it is no longer necessary to warn
		// the user about the KB contents being cleared, so that is comment out (below)
		/*
        // count the entries in the current project's KB, since we must warn the user that
        // it's contents are now about to be removed, so if the user is in a project in
        // which some work has been done, he better know that this operation (if he
        // continues) is going to clobber the KB (because we assume that the adaptations KB
        // should be empty following this operation which will fill up the glossing KB
        // only, so we will make the adaptations KB empty in preparation for others to use
        // the transformed documents.)
		wxASSERT(m_pKB != NULL);
		int nCount = 0;
		for (int i = 0; i < MAX_WORDS; i++)
		{
			nCount += m_pKB->m_pMap[i]->size();
		}
        // also count the glossing KB's entries, but we won't make any decisions based on
        // the result, though we will tell the user it will be cleared and how many entries
        // are in it
		int nGlossingCount = m_pGlossingKB->m_pMap[0]->size();

		// the user will have to decide if he is willing to let the current kb's contents
		// be cleared, likewise the current glossing KB
		wxString message;
		message = message.Format(_(
"Warning: the Transform Adaptations Into Glosses command will clear out the contents of the current project's knowledge base, which contains %d entries.\nLikewise for the glossing knowledge base, which contains %d entries.\nAre you willing for this to happen?"),
		nCount,nGlossingCount);
		int nGoAhead = wxYES; // default (proceed)

		nGoAhead = wxMessageBox(message,_T(""), wxYES_NO);
		if (nGoAhead == wxNO)
		{
            // whm added 05Jan07 for safety sake restore the former current working
            // directory to what it was on entry. The
            // AreBookFoldersCreated(m_curAdaptionsPath) call above changes the current
            // working directory to m_curAdaptionsPath. (This change not in MFC version)
			bool bOK;
			bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
			return FALSE; // user baled out by clicking NO button, so do nothing
		}
		*/
		// enumerate the target project's doc files (Note: we must also do this again
		// below if book folders are involved, once per book folder), and set up paths for
		// the needed KB exports and do the exports
		wxArrayString targetProjectDocsList;
		wxString glossesKBExportFilename = _T("TEMP_AI_GlossesKB_Exported");
		wxString adaptionsKBExportFilename = _T("TEMP_AI_AdaptionsKB_Exported");
		wxString glossesKBExportPath = m_curProjectPath + PathSeparator + glossesKBExportFilename;
		wxString adaptionsKBExportPath = m_curProjectPath + PathSeparator + adaptionsKBExportFilename;

		wxFile f;
		// first, the glossing KB export
		if( !f.Open( glossesKBExportPath, wxFile::write))
		{
			// we don't expect failure, English message will do
			wxMessageBox(_T("Unable to open glossing knowledge base export file in AccessOtherAdaptionProject(). Aborting the transform process before it begins."),
			_T(""), wxICON_WARNING);
			LogUserAction(_T("Unable to open glossing knowledge base export file in AccessOtherAdaptionProject(). Aborting the transform process before it begins."));
			return FALSE; // return, do nothing
		}
		m_pGlossingKB->DoKBExport(&f,KBExportSaveAsSFM_TXT);
		f.Close();
		// second, the adapting KB export
		if( !f.Open( adaptionsKBExportPath, wxFile::write))
		{
			// we don't expect failure, English message will do
			wxMessageBox(_T("Unable to open adaptations knowledge base export file in AccessOtherAdaptionProject(). Aborting the transform process before it begins."),
			_T(""), wxICON_WARNING);
			LogUserAction(_T("Unable to open adaptations knowledge base export file in AccessOtherAdaptionProject(). Aborting the transform process before it begins."));
			return FALSE; // return, do nothing
		}
		m_pGlossingKB->DoKBExport(&f,KBExportSaveAsSFM_TXT);
		f.Close();
		// now get the list of documents in the target project's Adaptations folder
        // (any from the "other" project which match these, we just won't have converted,
        // so that data overwrite accidents won't happen)
		if (!EnumerateDocFiles_ParametizedStore(targetProjectDocsList,m_curAdaptionsPath))
		{
			// we don't expect failure, English message will do
			wxMessageBox(_T("Unable to enumerate the target project's docs in AccessOtherAdaptionProject(). Aborting the transform process before it begins."),
			_T(""), wxICON_WARNING);
			LogUserAction(_T("Unable to enumerate the target project's docs in AccessOtherAdaptionProject(). Aborting the transform process before it begins."));
			return FALSE; // return, do nothing
		}

		// okay, clean out the glossing KB ready for the new content (we don't want to just
        // add the new content, since the user might invoke the Transform Adaptations Into
        // Glosses command more than once, so that an addition schema would result in
        // duplicates and hence a glossing KB with incorrect reference counts)
		int nGlossingCount = m_pGlossingKB->m_pMap[0]->size();
		if (nGlossingCount > 0)
		{
			pDoc->EraseKB(m_pGlossingKB);
			m_pGlossingKB = new CKB(TRUE); // don't store yet, in case failure occurs we'd want old
									 // contents left undisturbed
			wxASSERT(m_pGlossingKB != NULL);
			m_bGlossingKBReady = TRUE;
		}

        // if we get to here, the user is committed, the current project's kb will be
        // cleared further down, because we delay in case the load of the 'other' project's
        // KB failed, and we don't want to clobber our kb until we know we've not had a
        // failure; and so we go ahead with the transformations - provided we can find the
        // KB file
		if (!wxFileExists(strOtherKBPathXML))
		{
            // we could not detect any valid KB file, so abort the operation; don't expect
            // this to ever be the case, so it can be a hard coded English message for
            // debug purposes only
			wxMessageBox(_T(
			"Aborting the Transform operation, because no valid KB file was detected"),
			_T(""),wxICON_WARNING);
			LogUserAction(_T("Aborting the Transform operation, because no valid KB file was detected"));
            // whm added 05Jan07 for safety sake restore the former current working
            // directory to what it was on entry. The
            // AreBookFoldersCreated(m_curAdaptionsPath) call above changes the current
            // working directory to m_curAdaptionsPath.
			bool bOK;
			bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
			wxCHECK_MSG(bOK, FALSE, _T("AccessOtherAdaptionProject(): ::wxSetWorkingDirectory() failed, line 30,740 in Adapt_It.cpp"));
			return FALSE;
		}

		// whm 26Aug11 Open a wxProgressDialog instance here for loading KB operations.
		// The dialog's pProgDlg pointer is passed along through various functions that
		// get called in the process.
		// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
		// be changed after the dialog is created. So any routine that gets passed the
		// pProgDlg pointer, must make sure that value in its Update() function does not
		// exceed the same maximum value (nTotal).
		wxString msgDisplayed;
		wxString progMsg;
		wxProgressDialog* pProgDlg = (wxProgressDialog*)NULL;
		// add 1 chunk to insure that we have enough after int division above
		const int nTotal = gpApp->GetMaxRangeForProgressDialog(XML_Input_Chunks) + 1;
		// Only show the progress dialog when there is at lease one chunk of data
		// Only create the progress dialog if we have data to progress
		if (nTotal > 0)
		{
			progMsg = _("Reading file %s - part %d of %d");
			wxFileName fn(strOtherKBPathXML);
			msgDisplayed = progMsg.Format(progMsg,fn.GetFullName().c_str(),1,nTotal);
			pProgDlg = gpApp->OpenNewProgressDialog(_("Loading the Other Project's Knowledge Base"),msgDisplayed,nTotal,500);
		}

		// "Load" the other project's adaptations KB. Code for this will be plagiarized
        // from the app class's LoadKB() function, but using a local CKB pointer to access
        // the KB
		CKB* pOtherKB = new CKB(FALSE); // FALSE means "not a glossing KB"
		bool bReadOK = ReadKB_XML(strOtherKBPathXML, pOtherKB, pProgDlg, nTotal); // pProgDlg can be NULL
		if (!bReadOK)
		{
			// a bad read or parsing - if so, there will have been an XML error report
			// already, so just abort the command
			wxMessageBox(_(
"Error: the application could not find the other project's knowledge base, or failed to open and load it. The command has therefore been ignored."),
			_T(""), wxICON_INFORMATION);
			LogUserAction(_T("Error: the application could not find the other project's knowledge base, or failed to open and load it. The command has therefore been ignored."));
            // whm added 05Jan07 for safety sake restore the former current working
            // directory to what it was on entry. The
            // AreBookFoldersCreated(m_curAdaptionsPath) call above changes the current
            // working directory to m_curAdaptionsPath.
			bool bOK;
			bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
			wxCHECK_MSG(bOK, FALSE, _T("AccessOtherAdaptionProject(): ::wxSetWorkingDirectory() failed, line 30,785 in Adapt_It.cpp"));
			if (pProgDlg != NULL)
				pProgDlg->Destroy();
			return FALSE; // abandon the command, the adaptations KB couldn't be opened
		}

        // the other KB is now in memory, so we can scan its contents and transfer them to
        // the current project's glossing KB; remember, null src phrases must not be
        // transferred, nor <Not In KB> entries
		int nMaxIndex = pOtherKB->m_nMaxWords - 1; // index of highest map having content
		MapKeyStringToTgtUnit* pMap = (MapKeyStringToTgtUnit*)NULL;
		CTargetUnit* pTgtUnit = (CTargetUnit*)NULL;
		CRefString* pRefString = (CRefString*)NULL;
		wxString key;
		wxString storedStr;
		MapKeyStringToTgtUnit::iterator iter;
		for (int index = 0; index <= nMaxIndex; index++)
		{
			pMap = pOtherKB->m_pMap[index];
			wxASSERT(pMap != NULL && pMap->size() >= 0);
			if (pMap->size() == 0)
				continue; // could be some of the maps are empty
			else // the map is not empty, so process its contents
			{
				iter = pMap->begin();
				while (iter != pMap->end())
				{
					// get the next association (ie. a CTargetUnit instance associated
					// with a key string)
					key = iter->first;
					pTgtUnit = iter->second;
					iter++;

					// BEW 2July10, additions to the tests have to be made for kbVersion
					// 2, and the copy actions modified somewhat - see below.
					// We now have a key, and its associated CTargetUnit instance. These
                    // will need to go in the glossing KB except as follows: we throw away
                    // the CTargetUnit instance if it is for a null source phrase (key =
                    // "..."), or if it contains a non-deleted CRefString storing the
					// string "<Not In KB>", or if all the stored CRefString instances are
					// marked as deleted. Also, when copying the CRefString instances
					// across, we don't copy any for which the m_bDeleted flag is TRUE
					if (key == _T("..."))
						continue; // skip any placeholder entries - we handle these when
								  // we later convert the documents, because we do it there
								  // selectively - we call StoreText() on those inserted
								  // manually, but don't for those auto-inserted to pad
								  // out a retranslation; we don't have enuf info to do it
								  // here now
					if (pTgtUnit->CountNonDeletedRefStringInstances() == 0)
						continue; // skip any in which every CRefString is deleted

                    // if we get to here, then we may have a target unit which has to be
                    // associated with the key and go into the glossing KB's same numbered
                    // map - but one which just has a non-deleted "<Not In KB>" adaptation
                    // will need to be ignored - so check for that and if found then delete
                    // the new CTargetUnit and iterate; otherwise, accept all the contents
                    // that remain unremoved
					CTargetUnit* pGlossingTgtUnit = new CTargetUnit; // create an empty one
					wxASSERT(pGlossingTgtUnit != NULL);
					pGlossingTgtUnit->Copy(*pTgtUnit); // copy it (a copy constructor does not
													  // work, hence the two step workaround)
					// find and throw away any CRefString instances which are marked as
					// deleted, and SetNewValue means that any non-deleted CRefString
					// instances that remain will have their m_modifiedDateTime member set
					// to the current datetime
					pGlossingTgtUnit->EraseDeletions(SetNewValue);
					// if pGlossingTgtUnit contains a CRefString with "<Not In KB>" then
					// that will now be the only CRefString in gGlossingTgtUnit

					// check now for <Not In KB> entry  -- delete pGLossingTgtUnit if we
					// find this string in its CRefString instance; otherwise, we keep all
					// the CRefString instances that remain after the removals done by the
					// EraseDeletions() call above
					TranslationsList::Node* tuPos = pGlossingTgtUnit->m_pTranslations->GetFirst();
					pRefString = (CRefString*)tuPos->GetData();
					storedStr = pRefString->m_translation;
					if (storedStr == _T("<Not In KB>"))
					{
						pGlossingTgtUnit->DeleteTargetUnitContents();
						delete pGlossingTgtUnit; // don't leak memory
						continue;
					}

					wxASSERT(pGlossingTgtUnit->CountNonDeletedRefStringInstances() >= 1);
					(*m_pGlossingKB->m_pMap[index])[key] = pGlossingTgtUnit; // put it into the map

					//m_pGlossingKB->m_nMaxWords = 1; // always is 1 for the glossing KB
					m_pGlossingKB->m_nMaxWords = nMaxIndex; // BEW 13Nov10, glossing KB uses all maps now

				} // end block for scanning all associations stored in the current map
			} // end block for processing a map with contents
		} // end for loop for processing all maps

		// clean up the kbs
//		if (nCount > 0)
//		{
			// clean out the adaptations kb (actually delete it and make a new empty one)
			// (delayed to here, in case the transformation process failed, in which case
			// we'd prefer the current adaptations KB to be left untouched)
			pDoc->EraseKB(m_pKB);
			m_pKB = new CKB(FALSE);
			m_bKBReady = TRUE;
			wxASSERT(m_pKB);
			bool bStoredOK = StoreKB(m_bAutoBackupKB);
			// unlikely to fail, so an English message hardcoded will do
			if (!bStoredOK)
				wxMessageBox(_T("The new empty adaptations KB did not successfully store to disk"),
				_T(""), wxICON_INFORMATION);
			LogUserAction(_T("The new empty adaptations KB did not successfully store to disk"));
//		}

		// delete the other project's copied KB from the heap (the original is still safe
		// on disk)
		pDoc->EraseKB(pOtherKB);

		// store the filled glossing KB on disk; leave it open since the user may want to
		// do some work or examine the glossing KB in the KB editor etc.
		bool bOK = StoreGlossingKB(m_bAutoBackupKB);
		// unlikely to fail, so an English message hardcoded will do
		if (!bOK)
		{
			wxMessageBox(_T(
			"Warning: the newly filled glossing KB did not successfully store to disk"),
				_T(""), wxICON_INFORMATION);
			LogUserAction(_T("Warning: the newly filled glossing KB did not successfully store to disk"));
		}

        // now we must look at all the documents in the other project, making copies which
        // have the adaptations shifted to the m_gloss member, and saved to the current
        // project's Adaptations folder. Code for this kind of stuff is to be found in the
        // handler OnFileRestoreKB( ) and its auxiliary function, DoKBRestore( ), with a
        // few modifications needed for our present task
		// BEW 6July10, as above except that now we only process doc files with filename
		// not in the targetProjectDocsList array.

        // first, get a list of all the documents the user wants transformed (normally all
        // of them, but the dialog which comes up allows fewer than all to be worked on)
		m_acceptedFilesList.Clear(); // ensure we start with a clear list

        // BEW 31Aug05, for version 3 we must deal first with document files in the
        // Adaptations folder, as in the legacy app, but then if there are embedded book
        // folders in the Adaptations folder, we must loop through each such folder and
        // enumerate the doc files in each, and call DoTransformationsToGlosses() for each
        // document in each of the book folders

        // Enumerate the document files (fills m_acceptedFilesList with the document
        // filenames, which potentially could be a mix of *.xml and *.adt names, and some
        // book folders can be expected to contain no documents) -- this first enumeration
        // is for the Adaptations folder only
		bool bIsOK;
        // whm note: EnumerateDocFiles() has the side effect of changing the current work
        // directory to the passed in strOtherAdaptationsPath.
		bIsOK = EnumerateDocFiles(pDoc, strOtherAdaptationsPath);
		if (!bIsOK)
		{
            // if no English error message occurs, then the user cancelled & the process
            // should be halted -- either way, halt the process if FALSE is returned before
            // looping through the Adaptations folder's document file set
            // whm added 05Jan07 for safety sake restore the former current working
            // directory to what it was on entry. The
            // EnumerateDocFiles(strOtherAdaptationsPath) call above changes the current
            // working directory to strOtherAdaptationsPath.
			bool bOK;
			bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
			wxCHECK_MSG(bOK, FALSE, _T("AccessOtherAdaptionProject(): ::wxSetWorkingDirectory() failed, line 30,950 in Adapt_It.cpp"));
			wxMessageBox(_T("EnumerateDocFiles() in AccessOtherAdaptionProject() returned FALSE. Aborting the transform process before documents are transformed, but the glossing KB was built."),
			_T(""), wxICON_WARNING);
			LogUserAction(_T("EnumerateDocFiles() in AccessOtherAdaptionProject() returned FALSE. Aborting the transform process before documents are transformed, but the glossing KB was built."));
			if (pProgDlg != NULL)
				pProgDlg->Destroy();
			return FALSE; // do nothing
		}
		if (m_acceptedFilesList.GetCount() == 0 && !gbHasBookFolders)
		{
			// no documents to work on, and no book folders either, so abort the operation
			// IDS_NO_DOCUMENTS_YET
			wxMessageBox(_(
"Sorry, there are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."),
			_T(""), wxICON_EXCLAMATION);
            LogUserAction(_T("Sorry, there are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."));
			// whm added 05Jan07 for safety sake restore the former current working
            // directory to what it was on entry. The
            // EnumerateDocFiles(strOtherAdaptationsPath) call above changes the current
            // working directory to strOtherAdaptationsPath.
			bool bOK;
			bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
			wxCHECK_MSG(bOK, FALSE, _T("AccessOtherAdaptionProject(): ::wxSetWorkingDirectory() failed, line 30,972 in Adapt_It.cpp"));
			if (pProgDlg != NULL)
				pProgDlg->Destroy();
			return FALSE;
		}

        // do the transformation of the other project's documents - changing adaptations
        // into glosses, and storing the transformed documents in the current project
		// (Since there may be some documents in the Adaptations folder, as well as more
		// documents in Bible book folders within the former, we must do the
		// transformations on the Adaptations' folder's documents first, and then on any
		// book folders which contain one or more documents.)
		wxString bookFolderName;
		bookFolderName.Empty(); // this ensures the next call works on Adaptations folder only
		bool bTransformedOK;
		bTransformedOK = DoTransformationsToGlosses(targetProjectDocsList, pDoc,
										strOtherAdaptationsPath, bookFolderName);

		if (gbHasBookFolders)
		{
            // process this block only if the 'other' project's Adaptations folder contains
            // the set of Bible book folders - these could contain documents, and some or
            // all could be empty; NOTE: the code below is smart enough to ignore any
            // user-created folders which are sisters of the Bible book folders for which
            // the Adaptations folder is the common parent folder
			wxDir finder;
			bool bOK = (::wxSetWorkingDirectory(strOtherAdaptationsPath) &&
													finder.Open(strOtherAdaptationsPath));
										// wxDir must call .Open() before enumerating files!
			if (!bOK)
			{
				wxString s1, s2, s3;
				s1 = _T(
"Failed to set the current directory to the Adaptations folder in AccessOtherAdaptionProject function, ");
				s2 = _T(
"processing book folders, so the book folder document files are absent in the transformed project.");
				s3 = s1 + s2;
				wxMessageBox(s3,_T(""),wxICON_EXCLAMATION);
				LogUserAction(s3);
                // whm added 05Jan07 for safety sake restore the former current working
                // directory to what it was on entry. The
                // wxSetWorkingDirectory(strOtherAdaptationsPath) call above changes the
                // current working directory to strOtherAdaptationsPath.
				bool bOK2;
				bOK2 = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
				wxCHECK_MSG(bOK2, FALSE, _T("AccessOtherAdaptionProject(): ::wxSetWorkingDirectory() failed, line 31,017 in Adapt_It.cpp"));
				if (pProgDlg != NULL)
					pProgDlg->Destroy();
				return FALSE;
			}
			else
			{
				// Must call wxDir::Open() before calling GetFirst() - see above
				wxString str = _T("");
				// whm note: in GetFirst below, wxDIR_FILES | wxDIR_DIRS flag finds
				// files or directories, but not . or .. or hidden files
				bool bWorking = finder.GetFirst(&str,wxEmptyString,wxDIR_FILES | wxDIR_DIRS);
				while (bWorking)
				{
                    // whm note: in the MFC version's "if (finder.IsDirectory())" test
                    // below, the finder continues to use the directory path that was
                    // current when the inital finder.FindFile call was made above, even
                    // though the EnumerateDocFiles() call below changes the current
                    // working dir for each of the book folder directories it processes. In
                    // the wx version the finder.Exists(str) call uses whatever the current
                    // working directory is and checks for a sub-directory "str" below that
                    // - a difference we must account for here in the wx version.
                    // whm Note: The Exists() method of wxDIR used below returns TRUE if
                    // the passed name IS a directory.
					if (finder.Exists(strOtherAdaptationsPath + PathSeparator + str))
					{
						// BEW changed 25Aug05, so that other user-defined folders can be
						// in the Adaptations folder without making the app confused
						// as to whether or not Bible Book folders are present or not

						// we have found a folder, check if it matches one of those in
						// the array of BookNamePair structs (using the seeName member)
						if (IsDirectoryWithin(str,m_pBibleBooks))
						{
							// we have found a folder name which belongs to the set of
							// Bible book folders, so construct the required path to the
							// folder and enumerate is documents then call
							// DoTransformationsToGlosses() to process any documents within
							wxString otherFolderPath = strOtherAdaptationsPath;
							otherFolderPath += PathSeparator + str;

                            // clear the string list of directory names & then enumerate
                            // the directory's file contents
							m_acceptedFilesList.Clear();
                            // whm note: EnumerateDocFiles() has the side effect of
                            // changing the current work directory to the passed in
                            // otherFolderPath.
							bIsOK = EnumerateDocFiles(pDoc, otherFolderPath,
														TRUE); // TRUE == suppress dialog
							if (m_acceptedFilesList.GetCount() == 0)
							{
								// no documents to work on in this folder, so iterate
								bWorking = finder.GetNext(&str);
								continue;
							}

							// BEW 6July10, enumerate the target project's equivalent
							// bible book folder for doc files
							wxString bibleBookPath = m_curAdaptionsPath +
											PathSeparator + str;
							targetProjectDocsList.Clear(); // it's already cleared, but no harm
														   // in doing it again
							if (!EnumerateDocFiles_ParametizedStore(targetProjectDocsList,bibleBookPath))
							{
								// we don't expect failure, English message will do
								wxMessageBox(_T("Unable to enumerate the target project's docs in AccessOtherAdaptionProject() in a book folder. Aborting the transform process before it begins."),
								_T(""), wxICON_WARNING);
								LogUserAction(_T("Unable to enumerate the target project's docs in AccessOtherAdaptionProject() in a book folder. Aborting the transform process before it begins."));
								if (pProgDlg != NULL)
									pProgDlg->Destroy();
								return FALSE; // return, do nothing
							}

                            // there are files to be processed, so do the transformations
                            // (the function internally does the required saving of the
                            // transformed document as part of the current project) TRUE
                            // parameter suppresses the statistics dialog.
							bTransformedOK = DoTransformationsToGlosses(targetProjectDocsList,
														pDoc,otherFolderPath,str,TRUE);
							// note, the function clears targetProjectDocsList before returning
							wxCHECK_MSG(bTransformedOK, FALSE, _T("AccessOtherAdaptionProject(): DoTransformationsToGlosses() failed, line 31,095 in Adapt_It.cpp"));
						}
						else
						{
							bWorking = finder.GetNext(&str);
							continue;
						}
					}
					else
					{
						// its a file, so ignore it
						bWorking = finder.GetNext(&str);
						continue;
					}
					bWorking = finder.GetNext(&str);
				} // end of while (bWorking)
			}
		}

		// clean out the app's string list for the list of doc files
		m_acceptedFilesList.Clear();

		// import the temporary files with the exported glossing and adapting KBs back to
		// the  target project, so that KB data is not lost from either one
		bool bSuccessful = TRUE;
		m_pGlossingKB->DoKBImport(glossesKBExportPath, KBImportFileOfSFM_TXT);
		bSuccessful = ::wxRemoveFile(glossesKBExportPath);
		wxCHECK_MSG(bSuccessful, FALSE, _T("AccessOtherAdaptionProject(): ::wxRemoveFile() failed, line 31,124 in Adapt_It.cpp"));

		m_pKB->DoKBImport(adaptionsKBExportPath, KBImportFileOfSFM_TXT);
		bSuccessful = ::wxRemoveFile(adaptionsKBExportPath);
		wxCHECK_MSG(bSuccessful, FALSE, _T("AccessOtherAdaptionProject(): ::wxRemoveFile() failed, line 31,128 in Adapt_It.cpp"));
		if (pProgDlg != NULL)
			pProgDlg->Destroy();
	} // end of if(dlg.ShowModal() == wxID_OK)

	// BEW added 05Jan07 to restore the former current working directory
	// to what it was on entry
	bool bOK;
	bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
	wxCHECK_MSG(bOK, FALSE, _T("AccessOtherAdaptionProject(): ::wxSetWorkingDirectory() failed, line 31,138 in Adapt_It.cpp"));
	return bSuccess;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE
/// \param      tgtDocsList          -> ref to array of target project's document filenames
///                                     (used for preventing overwrites)
/// \param      pDoc                 -> a pointer to the document
/// \param      folderPath           <- the full path to whatever folder in the other
///                                     project is supplying the documents being currently
///                                     transformed (it could be the Adaptations folder, or
///                                     any one of the embedded Bible book folders if that
///                                     mode has previously been turned on)
/// \param      bookFolderName       <- an empty string when the function is being called
///                                     on the Adaptations folder; otherwise pass the name
///                                     of the currently being accessed Bible book folder
/// \param      bSuppressStatistics  -> If FALSE (default) presents statistics for the
///                                     operation, otherwise does the transformations
///                                     quietly
/// \remarks
/// Called from: the App's AccessOtherAdaptionProject().
/// Transforms another project's documents - changing adaptations into glosses, and stores
/// the transformed documents in the current project.
/// BEW 2July10, updated for support of kbVersion 2 (no changes here, but changes within
/// the TransformSourcePhraseAdaptationsToGlosses() function which it calls for each
/// CSourcePhrase instance's transformation)
/// BEW 6July10, updated to add tgtDocsList parameter, so that we can test for same
/// document filenames and skip the transform process for any such matches (which protects
/// against inadventent data loss because the user may have done some adapting work in the
/// target project since the last transformation process)
/// BEW 11Oct10, no changes for additions to doc version 5 (but the
/// TransformSourcePhraseAdaptationsToGlosses() function has some changes - to support
/// fixedspace symbol ~ particularly)
/// BEW 13Nov10 no changes for supporting Bob Eaton's request that glossing KB use all maps
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::DoTransformationsToGlosses(wxArrayString& tgtDocsList,
											  CAdapt_ItDoc* pDoc,
											  wxString& folderPath,
											  wxString& bookFolderName,
											  bool bSuppressStatistics)
{
    // BEW updated it on 31Aug05 to comply with version 3 - specifically, to handle book
    // folders, and the possibility of some or all documents being XML rather than binary).
    // The bSuppressStatistics defaults to FALSE (in the prototype)
	wxArrayString List = m_acceptedFilesList;
	int nCount = List.GetCount();
	wxASSERT(nCount > 0);
	int nCumulativeTotal = 0;

	// get a pointer to the view (since it's SDI interface, our implementation
	// has the view always present, as the doc and its template get reused)
	CAdapt_ItView* pView = GetView();
	wxASSERT(pView != NULL);

	// lock view window updates till done
	wxGetApp().GetMainFrame()->canvas->Freeze();

	// iterate over the document files
	for (int i=0; i < nCount; i++)
	{
		wxString newDocName = List[i];

		// BEW 6July10, test for same names, and skip any that comply
		int anIndex = wxNOT_FOUND;
		anIndex = tgtDocsList.Index(newDocName);
		if (anIndex != wxNOT_FOUND)
		{
			// don't transform this document
			continue;
		}
		wxASSERT(!newDocName.IsEmpty());
		wxString ourProjectsDocFileName = newDocName;
		wxString curOutputPath; // for full path to the transformed document to
								// be saved in current project
		wxString newPathName; // for the full path to whatever document is
							  // currently to be loaded and transformed

        // create the path to the other project's document file using the passed in
        // folderPath and the bookFolderName; then create the needed output path to to
        // either the Adaptations folder in current project, or to the same named Bible
        // book folder if processing doc files from a Bible book folder -- to determine if
        // the latter is the case, use the bookFolderName as a flag -- it will be empty
        // when we are processing documents in an Adaptations folder, and it will be
        // non-empty when processing documents from a Bible book folder
		newPathName = folderPath + PathSeparator + newDocName;
		wxString bookFolderPath;
		if (bookFolderName.IsEmpty())
		{
			// we are processing documents from an Adaptations folder, not an embedded
			// Bible book folder in the Adaptations folder
			curOutputPath = m_curAdaptionsPath + PathSeparator + ourProjectsDocFileName;
			bookFolderPath.Empty();
		}
		else
		{
			// we are processing documents from one of the Bible book folders
			curOutputPath = m_curAdaptionsPath + PathSeparator;
			curOutputPath += bookFolderName;
			bookFolderPath = curOutputPath; // extract the path to the book folder
			curOutputPath += PathSeparator + ourProjectsDocFileName; // the path to the file
		}

		bool bOK = pDoc->OpenDocumentInAnotherProject(newPathName);
		if (bOK)
		{
			// why do I do set the path name? Should not be necessary since the view is
			// frozen while the documents are processed, but there is no harm in it
			pDoc->SetFilename(newPathName,TRUE);

			// the document may be the last to be processed, so we must ensure that if it
			// turned book mode on then we have a valid path for the app member
			// m_bibleBooksFolderPath, and m_nLastBookIndex can be set to m_nBookIndex
			// as obtained from the document settings as loaded
			if (gpApp->m_bBookMode && !m_bDisableBookMode)
			{
				gpApp->m_bibleBooksFolderPath = bookFolderPath;
				gpApp->m_nLastBookIndex = gpApp->m_nBookIndex;
			}
			else if (m_bDisableBookMode)
			{
				// if the XML read did not succeed, then disable the mode and
				// set parameters accordingly
				gpApp->m_bibleBooksFolderPath.Empty();
				gpApp->m_nBookIndex = -1;
				gpApp->m_nLastBookIndex = 39; // Matthew
				gpApp->m_nDefaultBookIndex = 39;
				gpApp->m_bBookMode = FALSE;
			}

			// whm 26Aug11 Open a wxProgressDialog instance here for transform to glosses operations.
			// The dialog's pProgDlg pointer is passed along through various functions that
			// get called in the process.
			// whm WARNING: The maximum range of the wxProgressDialog (nTotal below) cannot
			// be changed after the dialog is created. So any routine that gets passed the
			// pProgDlg pointer, must make sure that value in its Update() function does not
			// exceed the same maximum value (nTotal).
			wxString msgDisplayed;
			const int nTotal = GetMaxRangeForProgressDialog(App_SourcePhrases_Count) + 1;
			wxString progMsg = _("Transforming File %s  - %d of %d Total words and phrases");
			wxFileName fn(ourProjectsDocFileName);
			msgDisplayed = progMsg.Format(progMsg,fn.GetFullName().c_str(),1,nTotal);
			wxProgressDialog* pProgDlg;
			pProgDlg = OpenNewProgressDialog(_("Transformations To Glosses"),msgDisplayed,nTotal,500);

			SPList* pPhrases = m_pSourcePhrases;
			SPList::Node* pos1;
			pos1 = pPhrases->GetFirst();
			wxASSERT(pos1 != NULL);
			int counter = 0;
			while (pos1 != NULL)
			{
				SPList::Node* savePos = pos1;
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos1->GetData();
				pos1 = pos1->GetNext();
				counter++;

				// update the glossing or adapting KB for this source phrase
				bool bRemoveIt = FALSE;
				bRemoveIt = pView->TransformSourcePhraseAdaptationsToGlosses(
									this,savePos,pos1,pSrcPhrase);

                // if it needs to be removed, do so; (any adjustments to flags which are
                // needed will already have been done in the
                // TransformSourcePhraseAdaptationsToGlosses( ) function)
				if (bRemoveIt)
				{
                    // removing the one at savePos, so pos1 will remain valid since it is
                    // next
					pDoc->DeleteSingleSrcPhrase(pSrcPhrase);
					pPhrases->DeleteNode(savePos);
					pDoc->UpdateSequNumbers(0); // update from the start to be safe
				}
				// update the progress bar every 1000th iteration
				if (counter % 1000 == 0)
				{
					msgDisplayed = progMsg.Format(progMsg,fn.GetFullName().c_str(),
									counter,nTotal);
					pProgDlg->Update(counter,msgDisplayed);
					//::wxSafeYield();
				}
			}

			bool bSavedOK;
			bSavedOK = pDoc->DoTransformedDocFileSave(curOutputPath);
			wxCHECK_MSG(bSavedOK, TRUE, _T("DoTransformationsToGlosses(): DoTransformedDocFileSave() failed, line 31,322 in Adapt_It.cpp"));

			pView->ClobberDocument();

			// remove the progress indicator window
			pProgDlg->Destroy();
		}
		else
		{
            // user needs to know a document could not be processed; the message can be in
            // English because it is unlikely to ever be seen
			wxString errStr;
			errStr = errStr.Format(_(
			"The document with pathname: %s, was not opened and therefore not processed."),
				newPathName.c_str());
			wxMessageBox(errStr, _T(""), wxICON_EXCLAMATION);
		}

		if (m_pBuffer != NULL)
		{
			delete m_pBuffer;
			m_pBuffer = (wxString*)NULL;
		}
	}

	// clear the tgt list of doc names
	tgtDocsList.Clear();

	// inform user of success and some statistics, but only if not processing book folders
	if (!bSuppressStatistics && bookFolderName.IsEmpty())
	{
        // we suppress this information when processing through the documents in the 67
        // Bible book folders - otherwise the user might have to manually dismiss an
        // information dialog some hundreds of times!!!
		wxString stats;
		// IDS_TRANSFORMATION_DONE
		stats = stats.Format(_(
"The documents you chose from the other project have been transformed and copied to the current project. A total of %d source words and phrases were transformed, and these occur in %d  documents."),
		nCumulativeTotal,nCount);
		wxMessageBox(stats,_T(""),wxICON_INFORMATION);
	}
	// let the view respond again to updates
	wxGetApp().GetMainFrame()->canvas->Thaw();
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxUpdateUIEvent that is generated when the Tools Menu
///                         is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the appropriate KB is in a ready state the "Use Automatic Capitalization" menu item
/// on the Tools menu is enabled, otherwise it is disabled.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateToolsAutoCapitalization(wxUpdateUIEvent& event)
{
	// whm added 26Mar12.
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (gbIsGlossing)
	{
		if (m_bGlossingKBReady)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
	else
	{
		if (m_bKBReady)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated
///                         menu item is selected
/// \remarks
/// Called from: The Event Table of the CAdapt_ItApp class in response to a "Use Automatic
/// Capitalization" command on the Tools menu.
/// Toggles the Automatic Capitalization feature of Adapt It on or off depending on the
/// initial value of the gbAutoCaps global flag. Warns the user if the project's settings
/// are not set up to utilize this feature.
/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnToolsAutoCapitalization(wxCommandEvent& event)
{
	// TODO: This handler won't be needed once we eliminate the Tools'
	// "Use Automatic Capitalization" menu item (possibly incorporated into an
	// upper/lower case definition pane in wizard and Edit Preferences). Some
	// of the code below should be transferred to the LowerToUpperCaseEquivalencesDlg
	// and/or LowerToUpperCaseEquivalencesPage routines.
	CMainFrame *pFrame = GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuAutoCap = pMenuBar->FindItem(ID_TOOLS_AUTO_CAPITALIZATION);
	//wxASSERT(pToolsMenuAutoCap != NULL);

	// toggle the setting & update the display accordingly
	if (gbAutoCaps)
	{
		// toggle the checkmark to OFF & recalc the layout with strip-wrap off
		if (pToolsMenuAutoCap != NULL)
		{
			// Only log when user explicitly calls this handler from the menu
			if (event.GetId() == ID_TOOLS_AUTO_CAPITALIZATION)
			{
				LogUserAction(_T("Use Autocaps is OFF"));
			}
			pToolsMenuAutoCap->Check(FALSE);
		}
		gbAutoCaps = FALSE;
	}
	else
	{
        // don't permit auto caps to be turned on if the source language does not have an
        // upper/lower case distinction (before 2.0.6, gbSuppressAutoCapsAsk was only ever
        // true when reading a config file and the app was about to set up a tick or no
        // tick in the Use Automatic Capitalization menu item; once that was done, it was
        // cleared to false and remained that way until next launch of the app; but in
        // 2..0.6 we test for non empty src and tgt upper and lower case strings being
        // nonEmpty and if so, we assume that user has things set up okay and is just
        // wanting to turn auto caps back on, so we should suppress the ask in that
        // circumstance too) (the test has to be sensitive to gbIsGlossing flag too)
		if (gbIsGlossing)
		{
			// in glossing mode
			if (!m_srcLowerCaseChars.IsEmpty() && !m_srcUpperCaseChars.IsEmpty()
				&& !m_glossLowerCaseChars.IsEmpty() && !m_glossUpperCaseChars.IsEmpty())
				gbSuppressAutoCapsAsk = TRUE;
		}
		else
		{
			// in adapting mode
			if (!m_srcLowerCaseChars.IsEmpty() && !m_srcUpperCaseChars.IsEmpty()
				&& !m_tgtLowerCaseChars.IsEmpty() && !m_tgtUpperCaseChars.IsEmpty())
				gbSuppressAutoCapsAsk = TRUE;
		}

		if (!gbSuppressAutoCapsAsk)
		{
			int intTrue = wxYES;
			if (!gbSrcHasUcAndLc)
			{
				intTrue = wxMessageBox(_(
"Automatic capitalization support will work only provided the source language distinguishes between upper case and lower case letters. A \"No\" response will prohibit auto-capitalization from being turned on. Does your source language have both upper and lower case letters?"),
				_T(""), wxYES_NO);
			}
			if (intTrue == wxNO)
			{
				gbNoSourceCaseEquivalents = TRUE;
				gbSuppressAutoCapsAsk = FALSE;
				LogUserAction(_T("User says has no upper and lower case letters"));
				return; // return without turning the flag on
			}
			else
			{
				gbNoSourceCaseEquivalents = FALSE;

				// if the user has not yet set up case equivalences, then open the dialog
				// for him now, so he can do it; what we do here will depend on the mode
				// - whether glossing or adapting
				if (gbIsGlossing)
				{
					if ((m_srcLowerCaseChars.IsEmpty() && m_srcUpperCaseChars.IsEmpty())
						|| (m_glossLowerCaseChars.IsEmpty() && m_glossUpperCaseChars.IsEmpty()))
					{
                        // the source correspondences do not yet exist, or the gloss ones
                        // do not yet exist (all must exist for auto caps to work), so
                        // until they do automatic capitalization cannot be turned on. So
                        // now we give the user the chance to set up what is needed

						// Remind user to set equivalences in the Case tab of Edit Preferences
						gbNoSourceCaseEquivalents = TRUE;
						gbSuppressAutoCapsAsk = FALSE;
						// IDS_NO_SRC_PUNCT_CORRESP_EXIST
						wxMessageBox(_(
"The source language upper and lower case correspondences do not yet exist. Until they do, automatic captialization cannot be turned on.\nYou can set them up in the Edit Preferences menu selection on the \"Case\" tab."),
						_T(""), wxICON_WARNING);
						LogUserAction(_T("Src or Gls language u/l case do not yet exist... in OnToolsAutoCapitalization()"));
						return;
					}
				}
				else
				{
					if ((m_srcLowerCaseChars.IsEmpty() && m_srcUpperCaseChars.IsEmpty())
						|| (m_tgtLowerCaseChars.IsEmpty() && m_tgtUpperCaseChars.IsEmpty()))
					{
                        // the source correspondences do not yet exist, or the target ones
                        // do not yet exist (all must exist for auto caps to work), so
                        // until they do automatic capitalization cannot be turned on. So
                        // now we give the user the chance to set up what is needed

						// Remind user to set equivalences in the Case tab of Edit Preferences
						gbNoSourceCaseEquivalents = TRUE;
						gbSuppressAutoCapsAsk = FALSE;
						// IDS_NO_SRC_PUNCT_CORRESP_EXIST
						wxMessageBox(_(
"The source language upper and lower case correspondences do not yet exist. Until they do, automatic captialization cannot be turned on.\nYou can set them up in the Edit Preferences menu selection on the \"Case\" tab."),
						_T(""), wxICON_WARNING);
						LogUserAction(_T("Src or Tgt language u/l case do not yet exist... in OnToolsAutoCapitalization()"));
						return;
					}
				}
			}
		}
		// toggle the checkmark to ON, and recalc the layout with strip-wrap on
		if (pToolsMenuAutoCap != NULL)
		{
			if (event.GetId() == ID_TOOLS_AUTO_CAPITALIZATION)
			{
				gpApp->LogUserAction(_T("Use Autocaps is ON"));
			}
			pToolsMenuAutoCap->Check(TRUE);
		}
		gbAutoCaps = TRUE;
		gbSuppressAutoCapsAsk = FALSE;
	}
}


////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated
///                         menu item is selected
/// \remarks
/// Called from: The Event Table of the CAdapt_ItApp class in response to a "Change
/// Folder..." command on the File menu.
/// Shows the CWhichBook dialog allowing the user to change the active book folder, but
/// only while the application is in book folder mode. Any currently opened document is
/// first closed and after changing the book folder, the Start Working Wizard is invoked
/// automatically.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnFileChangeFolder(wxCommandEvent& event)
{
	//force closure of the document, before seeing the dialog
	CAdapt_ItDoc* pDoc = GetDocument();
	CAdapt_ItView* pView = GetView();
	LogUserAction(_T("Initiated OnFileChangeFolder()"));
	CKB* pKB;
	if (gbIsGlossing)
		pKB = gpApp->m_pGlossingKB;
	else
		pKB = gpApp->m_pKB;
	if (pKB != NULL && m_pLayout->GetStripArray()->GetCount() > 0)
	{
		// doc is open, so close it first
		pDoc->OnFileClose(event); // my version, which does not call OnCloseDocument
		pView->canvas->Refresh(); // force immediate repaint
	}

	// show the dialog
	CWhichBook whichBkDlg(gpApp->GetMainFrame());
	whichBkDlg.Centre();
	whichBkDlg.ShowModal();

    // force the Startup Wizard open, otherwise user might be confused about the doc
    // remaining gone and nothing else happening
	bool bSuccess = DoStartWorkingWizard(event);
	if (!bSuccess)
	{
		wxMessageBox(_(
"The Startup Wizard failed to open. Use the File menu's Open command to open a document."),
		_T(""), wxICON_EXCLAMATION);
		LogUserAction(_T("The Startup Wizard failed to open. Use the File menu's Open command to open a document."));
	}

}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxUpdateUIEvent that is generated when the File Menu
///                         is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress the Change Folder menu item is always disabled and
/// this handler returns immediately. Otherwise, if the appropriate KB is in a ready state
/// and Book Mode is enabled, the "Change Folder..." menu item on the File menu is enabled,
/// otherwise it is disabled.
/// whm modified 6Jul11 to prevent changing to book folder mode when collaborating with
/// Paratext or Bibledit.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateFileChangeFolder(wxUpdateUIEvent& event)
{
	if (m_bCollaboratingWithParatext || m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// enable if a project is active and book mode is ON
	if ((m_bKBReady || m_bGlossingKBReady) && m_bBookMode && !m_bDisableBookMode)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxCommandEvent that is generated when the associated menu
///                         item is selected
/// \remarks
/// Called from: The Event Table of the CAdapt_ItApp class in response to a "Storing
/// Documents in Book Folders" command on the Advanced menu.
/// This handler first closes any document that is currently open. The first time this
/// command is chosen the application creates the book folders structure and notes their
/// divisions as specified in books.xml. This handler then invokes the Start Working Wizard
/// which allows the user to select the division and specific folder to use for opening
/// and/or creating new documents.
/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnAdvancedBookMode(wxCommandEvent& event)
{
	CAdapt_ItView* pView = GetView();
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedMenu = pMenuBar->FindItem(ID_ADVANCED_BOOKMODE);
	//wxASSERT(pAdvancedMenu != NULL);
	LogUserAction(_T("Initiated OnAdvancedBookMode()"));

	// force closure of an open document, before the mode is changed - since the
	// document has to go to its current folder, and after the mode change that will
	// not be possible
	CAdapt_ItDoc* pDoc = GetDocument();
	CKB* pKB;
	if (gbIsGlossing)
		pKB = gpApp->m_pGlossingKB;
	else
		pKB = gpApp->m_pKB;
	//if (pKB != NULL && gpApp->m_pBundle->m_nStripCount > 0)
	if (pKB != NULL && m_pLayout->GetStripArray()->GetCount() > 0)
	{
		// doc is open, so close it first
		pDoc->OnFileClose(event); // my version, which does not call OnCloseDocument
		pView->canvas->Refresh(); // force immediate repaint
	}

	// toggle the setting
	if (m_bBookMode)
	{
		// toggle the checkmark to OFF
		if (pAdvancedMenu != NULL)
		{
			LogUserAction(_T("Book Folder Mode OFF"));
			pAdvancedMenu->Check(FALSE);
		}
		m_bBookMode = FALSE;
		m_nLastBookIndex = m_nBookIndex; // store last used index, in case
										 // the user restarts book mode
		m_nBookIndex = -1;
		m_pCurrBookNamePair = NULL;
		m_bibleBooksFolderPath.Empty();
	}
	else
	{
		// toggle the checkmark to ON
		if (pAdvancedMenu != NULL)
		{
			LogUserAction(_T("Book Folder Mode ON"));
			pAdvancedMenu->Check(TRUE);
		}

		// restore the settings, set the name pair structure, and redefine
		// the book folder's path
		m_bBookMode = TRUE;
		if (m_nLastBookIndex < 0)
		{
			// mode not set yet in this run of the app, so use the default
			m_nBookIndex = m_nDefaultBookIndex;
		}
		else
		{
			// the mode was in effect earlier in this run, so reset same
			// book as was last used at that time
			m_nBookIndex = m_nLastBookIndex;
		}
		m_pCurrBookNamePair = ((BookNamePair*)(*m_pBibleBooks)[m_nBookIndex]);
		m_bibleBooksFolderPath = m_curAdaptionsPath + PathSeparator +
												m_pCurrBookNamePair->dirName;

		// check the book folders are already present, and if not then create them
        // whm note: AreBookFoldersCreated() has the side effect of changing the current
        // work directory to the passed in m_curAdaptionsPath.
		bool bFoldersPresent = AreBookFoldersCreated(m_curAdaptionsPath);
		if (!bFoldersPresent)
		{
			CreateBookFolders(m_curAdaptionsPath,m_pBibleBooks);
		}
	}

	// restore focus to the targetBox, if it is visible
	if (m_pTargetBox != NULL)
	{
		if (m_pTargetBox->IsShown())
			m_pTargetBox->SetFocus();
		// also get the status bar updated, if there is a document visible
		if (gpApp->m_nActiveSequNum != -1 && gpApp->m_pActivePile != NULL)
			gpApp->RefreshStatusBarInfo();
	}

    // force the Startup Wizard open, otherwise user might be confused about the doc
    // remaining gone and nothing else happening
	bool bSuccess = DoStartWorkingWizard(event);
	if (!bSuccess)
	{
		wxMessageBox(_(
"The Startup Wizard failed to open. Use the File menu's Open command to open a document."),
		_T(""), wxICON_EXCLAMATION);
		LogUserAction(_T("After Book Folder Mode changed - The Startup Wizard failed to open. Use the File menu's Open command to open a document."));
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxUpdateUIEvent that is generated when the Advanced Menu
///                         is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress the Book Mode menu item is disabled and this handler
/// returns immediately. Otherwise, if the appropriate KB is in a ready state and Book Mode
/// is enabled, the "Storing Documents in Book Folders" menu item on the Advanced menu is
/// enabled, otherwise it is disabled. This handler also insures that the toggle state is
/// ticked if On and unticked if Off.
/// BEW added 13Nov09, don't allow local user with read-only access to a remote project
/// folder to make document or folder changes of this kind on the remote machine
/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
/// whm modified 6Jul11 to prevent switching to book folder mode when collaborating with
/// Paratext or Bibledit.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateAdvancedBookMode(wxUpdateUIEvent& event)
{
	if (m_bCollaboratingWithParatext || m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// BEW changed 27Nov05 to get the tick shown or not when the menu is opened
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedMenu = pMenuBar->FindItem(ID_ADVANCED_BOOKMODE);
	if (pAdvancedMenu == NULL)//wxASSERT(pAdvancedMenu != NULL);
		return;

	if (m_bBookMode && !m_bDisableBookMode)
	{
		pAdvancedMenu->Check(TRUE);
	}
	else
	{
		pAdvancedMenu->Check(FALSE);
	}

	// enable if a project is active & the disable flag is not set
	if ((m_bKBReady || m_bGlossingKBReady) && !m_bDisableBookMode)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   ->  the wxUpdateUIEvent that is generated when the Advanced Menu
///                         is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// The "Change Location of Adapt It Work Folder..." menu item on the Advanced menu is
/// enabled only when there is no project currently open.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateAdvancedChangeWorkFolderLocation(wxUpdateUIEvent& event)
{
	// enable only if no project is active
	if (!(m_bKBReady || m_bGlossingKBReady))
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if s contains an ordinary double quote " or a single
///             quote ' mark, FALSE otherwise
/// \param      s   -> the wxString being examined
/// \param      ch  -> the quote character for comparison, either \" or \'
/// \remarks
/// Called from: CPunctCorrespPageCommon::UpdateAppValues().
/// Determines if the string s contains an ordinary double " or single ' quote.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::ContainsOrdinaryQuote(wxString s, wxChar ch)
{
    // BEW added 5May05 to handle determining whether or not and ordinary single quote (ie.
    // apostrophe ASCII 39) or double-quote (ASCII 34) is in the passed in string s. Can't
    // use CString's .Find() function because it returns a positive result if the string
    // has curly quotes - and for punctuation in Adapt It that will always be the case. So
    // I do it by explicitly checking for value 39 or 34 as the case may be; it will of
    // course work for other passed in ch values, but I intend to use it for only " or '
	int valueCh = (int)ch;
	int len = s.Length();
    // wx version note: Since we require a read-only buffer we use GetData which just
    // returns a const wxChar* to the data in the string.
	const wxChar* pBuff = s.GetData();
	wxChar* pEnd = (wxChar*)pBuff + len; //
	wxASSERT(*pEnd == _T('\0')); // ensure there is a null there; this must be done
								 // for all wxStringBuffer calls!!!
	wxChar* ptr = (wxChar*)pBuff;
	while (ptr < pEnd)
	{
		int itsValue = (int)*ptr;
		if (itsValue == valueCh)
		{
			return TRUE;
		}
		else
			ptr++;
	}
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's OnInit(), DoUsfmSetChanges(), the Doc's ResetUSFMFilterStructs()
/// and ResetUSFMFilterStructs().
/// Takes data from the sfm maps, and constructs some raipd access strings as a convenience
/// for string Find operations. Strings are set up for wrap markers, section head markers,
/// inline markers, filter markers and unknown markers.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetupMarkerStrings()
{
    // At this point all the SFM maps are ready, so we can now set up some rapid access
    // data strings, for such things as wrap markers (and perhaps others as the need
    // arises) Note: We can easily set up other rapid access strings here if needed for any
    // other attributes in USFMAnalysis.
    // Ammended to also setup the m_currentUnknownMarkersStr for saving in the Doc's Buffer
    // member. Assumes the m_filterFlagsUnkMkrs is current reflecting the current filter
    // status of the unknown markers in the m_unknownMarkers CStringArray. This would
    // normally be the case when SetupMarkerStrings is called from within
    // ResetUSFMFilterStructs. When SetupMarkerStrings is called from elsewhere, it is up
    // to the caller to ensure that m_filterFlagsUnkMkrs is up to date.

	CAdapt_ItDoc* pDoc = GetDocument();
	// set up marker strings for each type of map.
	UsfmWrapMarkersStr.Empty();
	PngWrapMarkersStr.Empty();
	UsfmAndPngWrapMarkersStr.Empty();

	UsfmSectionHeadMarkersStr.Empty();
	PngSectionHeadMarkersStr.Empty();
	UsfmAndPngSectionHeadMarkersStr.Empty();

	UsfmInLineMarkersStr.Empty();
	PngInLineMarkersStr.Empty();
	UsfmAndPngInLineMarkersStr.Empty();

#ifdef __WXDEBUG__
	ShowFilterMarkers(2); // location 2
#endif
	UsfmFilterMarkersStr.Empty();
	PngFilterMarkersStr.Empty();
	UsfmAndPngFilterMarkersStr.Empty();

	gCurrentFilterMarkers.Empty();
	m_currentUnknownMarkersStr.Empty();

	USFMAnalysis* pSfm;
	wxString key;
	MapSfmToUSFMAnalysisStruct::iterator iter;

#ifdef __WXDEBUG__
	ShowFilterMarkers(3); // location 3
#endif

	for (iter = m_pUsfmStylesMap->begin(); iter != m_pUsfmStylesMap->end(); ++iter)
	{
		// Retrieve each USFMAnalysis struct from the map
		key = iter->first;
		pSfm = iter->second;
		if (pSfm->wrap)
		{
			UsfmWrapMarkersStr += gSFescapechar;
			UsfmWrapMarkersStr += key;
			UsfmWrapMarkersStr += _T(' ');
		}
		if (pSfm->textType == sectionHead)
		{
			UsfmSectionHeadMarkersStr += gSFescapechar;
			UsfmSectionHeadMarkersStr += key;
			UsfmSectionHeadMarkersStr += _T(' ');
		}
		if (pSfm->inLine)
		{
			UsfmInLineMarkersStr += gSFescapechar;
			UsfmInLineMarkersStr += key;
			UsfmInLineMarkersStr += _T(' ');
		}
		if (pSfm->filter)
		{
			UsfmFilterMarkersStr += gSFescapechar;
			UsfmFilterMarkersStr += key;
			UsfmFilterMarkersStr += _T(' ');
		}
	}

#ifdef __WXDEBUG__
	ShowFilterMarkers(4); // location 4
#endif

	for (iter = m_pPngStylesMap->begin(); iter != m_pPngStylesMap->end(); ++iter)
	{
		// Retrieve each USFMAnalysis struct from the map
		key = iter->first;
		pSfm = iter->second;
		if (pSfm->wrap)
		{
			PngWrapMarkersStr += gSFescapechar;
			PngWrapMarkersStr += key;
			PngWrapMarkersStr += _T(' ');
		}
		if (pSfm->textType == sectionHead)
		{
			PngSectionHeadMarkersStr += gSFescapechar;
			PngSectionHeadMarkersStr += key;
			PngSectionHeadMarkersStr += _T(' ');
		}
		if (pSfm->inLine)
		{
			PngInLineMarkersStr += gSFescapechar;
			PngInLineMarkersStr += key;
			PngInLineMarkersStr += _T(' ');
		}
		if (pSfm->filter)
		{
			PngFilterMarkersStr += gSFescapechar;
			PngFilterMarkersStr += key;
			PngFilterMarkersStr += _T(' ');
		}
	}
	for (iter = m_pUsfmAndPngStylesMap->begin(); iter != m_pUsfmAndPngStylesMap->end(); ++iter)
	{
		// Retrieve each USFMAnalysis struct from the map
		key = iter->first;
		pSfm = iter->second;
		if (pSfm->wrap)
		{
			UsfmAndPngWrapMarkersStr += gSFescapechar;
			UsfmAndPngWrapMarkersStr += key;
			UsfmAndPngWrapMarkersStr += _T(' ');
		}
		if (pSfm->textType == sectionHead)
		{
			UsfmAndPngSectionHeadMarkersStr += gSFescapechar;
			UsfmAndPngSectionHeadMarkersStr += key;
			UsfmAndPngSectionHeadMarkersStr += _T(' ');
		}
		if (pSfm->inLine)
		{
			UsfmAndPngInLineMarkersStr += gSFescapechar;
			UsfmAndPngInLineMarkersStr += key;
			UsfmAndPngInLineMarkersStr += _T(' ');
		}
		if (pSfm->filter)
		{
			UsfmAndPngFilterMarkersStr += gSFescapechar;
			UsfmAndPngFilterMarkersStr += key;
			UsfmAndPngFilterMarkersStr += _T(' ');
		}
	}

	switch(gCurrentSfmSet) // gCurrentSfmSet is UsfmOnly when SetupMarkerStrings
						   // is called from InitInstance
	{
	case UsfmOnly: gCurrentFilterMarkers = UsfmFilterMarkersStr; break;
	case PngOnly: gCurrentFilterMarkers = PngFilterMarkersStr; break;
	case UsfmAndPng: gCurrentFilterMarkers = UsfmAndPngFilterMarkersStr; break;
	default: gCurrentFilterMarkers = UsfmFilterMarkersStr;
	}
#ifdef __WXDEBUG__
	ShowFilterMarkers(5); // location 5
#endif

#ifdef _Trace_UnknownMarkers
	wxString filteredUnkMkrsAddedTogCurrentFilterMarkers;
	filteredUnkMkrsAddedTogCurrentFilterMarkers.Empty();
	TRACE0("In SetupMarkerStrings BEFORE Doc's unknown markers copied from pUsfmFilterPageCommon\n");
	TRACE1("   Doc's unknown markers = %s\n", pDoc->GetUnknownMarkerStrFromArrays(&m_unknownMarkers, &m_filterFlagsUnkMkrs));
#endif

    // Populate the Doc's unknown markers string pDoc->m_currentUnknownMarkersStr from the
    // doc's unknown marker data arrays.
    // Add any filtered unknown markers to the App's filter markers string
    // gCurrentFilterMarkers if the unknown marker is not already present.
	wxASSERT(m_unknownMarkers.GetCount() == m_filterFlagsUnkMkrs.GetCount());
	int unkCount = m_unknownMarkers.GetCount();
	int index;
	int dummyPos; // unused here
	wxString bareMkr;
    for (index = 0; index < unkCount; index++)
    {
        bareMkr = m_unknownMarkers.Item(index);
        // if the unknown marker doesn't already exist in
        // m_currentUnknownMarkersStr add it
        if (!pDoc->MarkerExistsInString(m_currentUnknownMarkersStr,bareMkr,dummyPos))
        {
            m_currentUnknownMarkersStr += bareMkr;
            int filterFlag = m_filterFlagsUnkMkrs.Item(index);
            if (filterFlag == 0)
            {
                // the unknown marker is not filtered
				// if it doesn't already exist in m_current
                m_currentUnknownMarkersStr += _T("=0 ");
            }
            else
            {
                // the unknown marker is filtered
                m_currentUnknownMarkersStr += _T("=1 ");
                // also add this marker to gCurrentFilterMarkers if it doesn't
                // already exist
                if (!pDoc->MarkerExistsInString(gCurrentFilterMarkers,bareMkr,dummyPos))
                {
                    gCurrentFilterMarkers += bareMkr;
                    gCurrentFilterMarkers += _T(' '); // add the space for efficient
													  // parsing later
#ifdef _Trace_UnknownMarkers
					filteredUnkMkrsAddedTogCurrentFilterMarkers += bareMkr;
					filteredUnkMkrsAddedTogCurrentFilterMarkers += _T(' ');
#endif
                }
            }
        }
    }

#ifdef _Trace_UnknownMarkers
	TRACE0("In SetupMarkerStrings AFTER Doc's unknown markers copied from pUsfmFilterPageCommon\n");
	TRACE1("   Doc's unknown markers = %s\n", pDoc->GetUnknownMarkerStrFromArrays(&m_unknownMarkers, &m_filterFlagsUnkMkrs));
	TRACE1("   Unk mkrs added to glbl= %s\n", filteredUnkMkrsAddedTogCurrentFilterMarkers);
#endif
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      markerStr     <- the string from which any instance of wholeMarker
///                              is removed
/// \param      wholeMarker   -> the whole marker of interest
/// \remarks
/// Called from: (currently unused)
/// Removes any instance of wholeMarker found in markerStr.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::RemoveMarkerFromString(wxString& markerStr, wxString wholeMarker)
{
    // If the wholeMarker exists in markerStr, RemoveMarkerFromString remove it from
    // markerStr. Assumes markerStr consists of a string of markers, each beginning with a
    // backslash and terminating with a delimiting space
    // Also assumes wholeMarker begins with backslash, and insures it ends with a
    // delimiting space.
	wholeMarker.Trim(FALSE); // trim left end
	wholeMarker.Trim(TRUE); // trim right end
	wxASSERT(!wholeMarker.IsEmpty());
	// then add the necessary final space
	wholeMarker += _T(' ');
	int posn = markerStr.Find(wholeMarker);
	if (posn != -1)
	{
		// The wholeMarker does exist in the string, so remove it.
		markerStr.Remove(posn, wholeMarker.Length());
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pDC                -> pointer to the display context
/// \param      MkrAndDescrArray   <- a wxStringArray containing strings of markers
///                                   and their descriptions
/// \param      minNumSpaces       -> the minimum number of spaces required to be
///                                   maintained between the whole marker and the following
///                                   descriptive text
/// \remarks
/// Called from: the View's GetMarkerInventoryFromCurrentDoc(),
/// from CUsfmFilterPageCommon::LoadDocSFMListBox(), CUsfmFilterPageCommon::LoadProjSFMListBox(),
/// from CUsfmFilterPageCommon::DoInit(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseUbsSetOnlyDoc(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseSilpngSetOnlyDoc(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseBothSetsDoc(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseUbsSetOnlyProj(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseSilpngSetOnlyProj(),
/// CUsfmFilterPageCommon::DoBnClickedRadioUseBothSetsProj().
/// This function scans the array to find the whole marker that has the greatest text extent
/// in the pDC. It then scans the array again and uses that text extent determined in the
/// first scan to calculate and insert the amount of white space needed between the whole
/// marker and the following descriptive text in order to make them line up relatively
/// straight within the containing list box.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::FormatMarkerAndDescriptionsStringArray(wxClientDC* pDC,
						wxArrayString* MkrAndDescrArray, int minNumSpaces,
						wxArrayInt* pUserCanSetFilterFlags)
{
    // Takes an input CStringArray which is assumed to be composed of strings which are
    // roughly formatted as white space, followed by a whole marker (no embedded spaces)
    // followed by some white space, followed by some descriptive text. This function scans
    // the array to find the whole marker that has the greatest text extent in the pDC. It
    // then scans the array again and uses that text extent determined in the first scan to
    // calculate and insert the amount of white space needed between the whole marker and
    // the following descriptive text in order to make them line up relatively straight
    // within the containing list box. They will not be perfectly lined up because we
    // cannot add fractional spaces to the string in order to get a perfectly justified
    // text line up. The minNumSpaces parameter indicates the minimum number of spaces
    // required to be maintained between the whole marker and the following descriptive
    // text. The string array is repopulated with the same strings but with the amount of
    // white space between whole marker and following text adjusted so that they will line
    // up.
    // Note: Most strings added to a CCheckListBox style list box look better if they have
    // at least one space prefixed to the string. In addition to this space the caller may
    // have prefixed an extra space to force the list box to sort certain of its strings at
    // the beginning of the list box. Because of this we preserve any initial white space
    // found on the array strings and only adjust the medial space in our formatting
    // process. wx version note: The wx version does not have a "Show All" button in the
    // usfm filter page dialog, therefore I've modified the code within the usfm filter page
    // to eliminate from the wxArrayString items that won't be shown in the listbox before
    // the wxArrayString is input into this FormatMarkerAndDescriptionsStringArray function.
    // Hence, here in this function we only calculate the extents of markers that do not
    // display within list boxes.
    // whm added 19Jan09 additional parameter pUserCanSetFilterFlags so we can determine
    // the subset of markers and their descriptions that will actually be formatted and
    // added to the listbox (this eliminates the extra space formatted between the marker
    // and its description, because the amount of space was previously determined by the
    // longest sfm which usually wouldn't appear in the list box.
	int arrayCt = MkrAndDescrArray->GetCount();
	if (arrayCt == 0)
	{
		// nothing to do so
		return;
	}

	wxString tempStr, checkStr;
	wxString initialWhiteSp;
	initialWhiteSp.Empty();
	wxString descrStr;
	descrStr.Empty();
	wxString wholeMkr;
	wholeMkr.Empty();
	wxString formattedStr;
	formattedStr.Empty();
	wxSize longestSfmExtent(0,0);
	wxSize spaceExtent(0,0);
	wxSize testExtent(0,0);
	if (pDC != NULL)
	{
		pDC->GetTextExtent(_T(' '),&spaceExtent.x, &spaceExtent.y);
	}
	else
	{
		// use the sizeSpace determined in InitInstance
		spaceExtent = sizeSpace;
	}

    // First scan the input wxStringArray strings and determine the extent of the marker
    // having the greatest text extent.
	for (int ct = 0; ct < arrayCt; ct++)
	{
		if (pUserCanSetFilterFlags == NULL)
		{
			// No pUserCanSetFilterFlags array was passed in so we format all
			// MkrAndDescArray items
			tempStr = MkrAndDescrArray->Item(ct);
			int spCt = 0;
			int nwspCt = 0;
			int strLen = tempStr.Length();
			// count white space
			while(spCt < strLen && tempStr.GetChar(spCt) == _T(' '))
			{
				spCt++;
			}
			// count non-white space (the whole marker)
			while(spCt + nwspCt < strLen && tempStr.GetChar(spCt + nwspCt) != _T(' '))
			{
				nwspCt++;
			}
			// checkStr is the array string up to but not including the first "medial space"
			checkStr = tempStr.Mid(0, spCt + nwspCt);

			if (pDC != NULL)
			{
				// measure the text extent of this marker (including preceeding white space)
				 pDC->GetTextExtent(checkStr,&testExtent.x, &testExtent.y);
				if (testExtent.x > longestSfmExtent.x)
				{
					longestSfmExtent = testExtent;
				}
			}
			else
			{
				// use the sizeSpace determined in InitInstance for longestSfmExtent
				longestSfmExtent = sizeSpace;
			}
		}
		else // pUserCanSetFilterFlags was not NULL
		{
			if (pUserCanSetFilterFlags->Item(ct) == 1) // we only format those that
													   // will fill the box
			{
                // pUserCanSetFilterFlags array was passed in so we format only those
                // markers that have their pUserCanSetFilterFlags[ct] == 1.
				tempStr = MkrAndDescrArray->Item(ct);
				int spCt = 0;
				int nwspCt = 0;
				int strLen = tempStr.Length();
				// count white space
				while(spCt < strLen && tempStr.GetChar(spCt) == _T(' '))
				{
					spCt++;
				}
				// count non-white space (the whole marker)
				while(spCt + nwspCt < strLen && tempStr.GetChar(spCt + nwspCt) != _T(' '))
				{
					nwspCt++;
				}
				// checkStr is the array string up to but not including the first
				// "medial space"
				checkStr = tempStr.Mid(0, spCt + nwspCt);

				if (pDC != NULL)
				{
					// measure the text extent of this marker (including preceeding white space)
					 pDC->GetTextExtent(checkStr,&testExtent.x, &testExtent.y);
					if (testExtent.x > longestSfmExtent.x)
					{
						longestSfmExtent = testExtent;
					}
				}
				else
				{
					// use the sizeSpace determined in InitInstance for longestSfmExtent
					longestSfmExtent = sizeSpace;
				}
			}
		}
	}

    // now scan the string array again, this time reformatting the strings to add the
    // correct amount of white space between the whole marker and following descriptive
    // text so they will line up
	for (int ct = 0; ct < arrayCt; ct++)
	{
		if (pUserCanSetFilterFlags == NULL)
		{
			// No pUserCanSetFilterFlags array was passed in so we format all
			// MkrAndDescArray items
			initialWhiteSp.Empty();
			descrStr.Empty();
			wholeMkr.Empty();
			formattedStr.Empty();

			tempStr = MkrAndDescrArray->Item(ct);
			int spCt = 0;
			int nwspCt = 0;
			int strLen = tempStr.Length();
			// count white space
			while(spCt < strLen && tempStr.GetChar(spCt) == _T(' '))
			{
				spCt++;
				initialWhiteSp += _T(' ');
			}
			// remove prefixed white space
			tempStr = tempStr.Mid(spCt);
			// count non-white space (the whole marker)
			while(nwspCt < strLen && tempStr.GetChar(nwspCt) != _T(' '))
			{
				wholeMkr += tempStr.GetChar(nwspCt);
				nwspCt++;
			}
			// checkStr is the array string up to but not including the first
			// "medial space"
			checkStr = tempStr.Mid(0, nwspCt);


			if (pDC != NULL)
			{
				// measure the text extent of this marker (including preceeding
				// white space)
				 pDC->GetTextExtent(checkStr, &testExtent.x, &testExtent.y);
				if (testExtent.x > longestSfmExtent.x)
				{
					longestSfmExtent = testExtent;
				}
			}
			else
			{
				// use the sizeSpace determined in InitInstance for longestSfmExtent
				longestSfmExtent = sizeSpace;
			}

			descrStr += tempStr.Mid(nwspCt); // get remainder of string for descrStr
			descrStr.Trim(TRUE); // trim right end
			descrStr.Trim(FALSE); // trim left end
			// build the formatted array string
			formattedStr = initialWhiteSp;
			formattedStr += wholeMkr;
            // add enough spaces to make the text extent of formattedStr equal to or
            // greater than longestSfmExtent.cx

			if (pDC != NULL)
			{
				int extSpacex, extSpacey;
				int fStrExtx, fStrExty;
				pDC->GetTextExtent(_T(' '),&extSpacex,&extSpacey);
				pDC->GetTextExtent(formattedStr,&fStrExtx,&fStrExty);
				while (fStrExtx < longestSfmExtent.x)
				{
					formattedStr += _T(' ');
					fStrExtx += extSpacex;
				}
			}
            // now add the minimum number of spaces of separation - the array string gets
            // this much separation between whole marker and its description even when pDC
            // == NULL
			for (int minSp = 0; minSp < minNumSpaces; minSp++)
			{
				formattedStr += _T(' ');
			}
			// add back the description
			formattedStr += descrStr;
			// set the newly formatted string back into the array
			(*MkrAndDescrArray)[ct] = formattedStr;
		}
		else
		{
			if (pUserCanSetFilterFlags->Item(ct) == 1) // we only format those that
													   // will fill the box
			{
                // pUserCanSetFilterFlags array was passed in so we format only those
                // markers that have their pUserCanSetFilterFlags[ct] == 1.
				initialWhiteSp.Empty();
				descrStr.Empty();
				wholeMkr.Empty();
				formattedStr.Empty();

				tempStr = MkrAndDescrArray->Item(ct);
				int spCt = 0;
				int nwspCt = 0;
				int strLen = tempStr.Length();
				// count white space
				while(spCt < strLen && tempStr.GetChar(spCt) == _T(' '))
				{
					spCt++;
					initialWhiteSp += _T(' ');
				}
				// remove prefixed white space
				tempStr = tempStr.Mid(spCt);
				// count non-white space (the whole marker)
				while(nwspCt < strLen && tempStr.GetChar(nwspCt) != _T(' '))
				{
					wholeMkr += tempStr.GetChar(nwspCt);
					nwspCt++;
				}
				// checkStr is the array string up to but not including the first
				// "medial space"
				checkStr = tempStr.Mid(0, nwspCt);


				if (pDC != NULL)
				{
					// measure the text extent of this marker (including preceeding
					// white space)
					 pDC->GetTextExtent(checkStr, &testExtent.x, &testExtent.y);
					if (testExtent.x > longestSfmExtent.x)
					{
						longestSfmExtent = testExtent;
					}
				}
				else
				{
					// use the sizeSpace determined in InitInstance for longestSfmExtent
					longestSfmExtent = sizeSpace;
				}

				descrStr += tempStr.Mid(nwspCt); // get remainder of string for descrStr
				descrStr.Trim(TRUE); // trim right end
				descrStr.Trim(FALSE); // trim left end
				// build the formatted array string
				formattedStr = initialWhiteSp;
				formattedStr += wholeMkr;
                // add enough spaces to make the text extent of formattedStr equal to or
                // greater than longestSfmExtent.cx

				if (pDC != NULL)
				{
					int extSpacex, extSpacey;
					int fStrExtx, fStrExty;
					pDC->GetTextExtent(_T(' '),&extSpacex,&extSpacey);
					pDC->GetTextExtent(formattedStr,&fStrExtx,&fStrExty);
					while (fStrExtx < longestSfmExtent.x)
					{
						formattedStr += _T(' ');
						fStrExtx += extSpacex;
					}
				}
                // now add the minimum number of spaces of separation - the array string
                // gets this much separation between whole marker and its description even
                // when pDC == NULL
				for (int minSp = 0; minSp < minNumSpaces; minSp++)
				{
					formattedStr += _T(' ');
				}
				// add back the description
				formattedStr += descrStr;
				// set the newly formatted string back into the array
				(*MkrAndDescrArray)[ct] = formattedStr;
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxFontEncoding value that is the closest equivalent to the MFC Charset
/// \param      Charset   -> the MFC Charset value
/// \remarks
/// Called from: the App's GetFontConfiguration().
/// Maps an MFC Charset value to its closest equivalent wxFontEncoding value in wxWidgets.
/// See the complementing function MapWXFontEncodingToMFCCharset().
////////////////////////////////////////////////////////////////////////////////////////
wxFontEncoding CAdapt_ItApp::MapMFCCharsetToWXFontEncoding(const int Charset)
{
	switch(Charset)
	{
        // Note: MFC's SYMBOL_CHARSET, JOHAB_CHARSET, and VIETNAMESE_CHARSET do not seem to
        // have a wx equivalent to map to, so I'm mapping SYMBOL_CHARSET to
        // wxFONTENCODING_DEFAULT; and the other two to wxFONTENCODING_DEFAULT.
	case 0: return wxFONTENCODING_CP1252; // ANSI_CHARSET maps to wxFONTENCODING_CP1252 [Microsoft analogue of ISO8859-1 "WinLatin1"]
	//case 1: return wxFONTENCODING_DEFAULT; // DEFAULT_CHARSET maps to wxFONTENCODING_DEFAULT
	//case 2: return wxFONTENCODING_SYSTEM; // SYMBOL_CHARSET maps to [???] wxFONTENCODING_SYSTEM
	case 1: return wxFONTENCODING_ISO8859_1; // Western European (ISO) whm Note: Bob Eaton's GetEncodingStringForXmlFiles() function maps CP_SYMBOL to "iso-8859-1"
	case 2: return wxFONTENCODING_ISO8859_2; // Central European (ISO) TODO: verify
	case 3: return wxFONTENCODING_ISO8859_3; // Latin 3 (ISO) TODO: verify
	case 4: return wxFONTENCODING_ISO8859_4; // Baltic (ISO) TODO: verify
	case 5: return wxFONTENCODING_ISO8859_5; // Cyrillic (ISO) TODO: verify
	case 6: return wxFONTENCODING_ISO8859_6; // Arabic (ISO) TODO: verify
	case 7: return wxFONTENCODING_ISO8859_7; // Greek (ISO) TODO: verify
	case 8: return wxFONTENCODING_ISO8859_8; // Hebrew (ISO-Visual) TODO: verify
	case 9: return wxFONTENCODING_ISO8859_9; // Turkish (ISO) TODO: verify
	case 10: return wxFONTENCODING_ISO8859_10; // TODO: verify
	case 11: return wxFONTENCODING_ISO8859_11; // TODO: verify
	case 12: return wxFONTENCODING_ISO8859_12; // TODO: verify
	case 13: return wxFONTENCODING_ISO8859_13; // Estonian (ISO) TODO: verify
	case 14: return wxFONTENCODING_ISO8859_14; // TODO: verify
	case 15: return wxFONTENCODING_ISO8859_15; // Latin 9 (ISO) TODO: verify
	case 77: return wxFONTENCODING_MACROMAN; // MAC_CHARSET maps to wxFONTENCODING_MACROMAN [mac has encodings 47-86 under wx, default to Roman]
	case 128: return wxFONTENCODING_CP932; // SHIFTJIS_CHARSET maps to wxFONTENCODING_CP932 [shift-JIS]
	case 129: return wxFONTENCODING_CP949; // HANGUL_CHARSET maps to wxFONTENCODING_CP949 [Korean (Hangul charset)]
	case 130: return wxFONTENCODING_DEFAULT; // JOHAB_CHARSET maps to [???] wxFONTENCODING_DEFAULT
	case 134: return wxFONTENCODING_CP936; // GB2312_CHARSET maps to wxFONTENCODING_CP936 [Chinese simplified (GB)]
	case 136: return wxFONTENCODING_CP950; // CHINESEBIG5_CHARSET maps to wxFONTENCODING_CP950 [Chinese (traditional - Big5)]
	case 161: return wxFONTENCODING_CP1253; // GREEK_CHARSET maps to wxFONTENCODING_CP1253 [WinGreek (8859-7)]
	case 162: return wxFONTENCODING_CP1254; // TURKISH_CHARSET maps to wxFONTENCODING_CP1254 [WinTurkish]
	case 163: return wxFONTENCODING_DEFAULT; // VIETNAMESE_CHARSET maps to [???] wxFONTENCODING_DEFAULT
	case 177: return wxFONTENCODING_CP1255; // HEBREW_CHARSET maps to wxFONTENCODING_CP1255 [WinHebrew]
	case 178: return wxFONTENCODING_CP1256; // ARABIC_CHARSET maps to wxFONTENCODING_CP1256 [WinArabic]
	case 186: return wxFONTENCODING_CP1257; // BALTIC_CHARSET maps to wxFONTENCODING_CP1257 [WinBaltic (same as Latin 7)]
	case 204: return wxFONTENCODING_CP1251; // RUSSIAN_CHARSET maps to wxFONTENCODING_CP1251 [Microsoft analogue of ISO8859-5 "WinCyrillic"]
	case 222: return wxFONTENCODING_CP874; // THAI_CHARSET maps to wxFONTENCODING_CP874 [WinThai]
	case 238: return wxFONTENCODING_CP1250; // EASTEUROPE_CHARSET maps to wxFONTENCODING_CP1250 [Microsoft analogue of ISO8859-2 "WinLatin2"]
	case 255: return wxFONTENCODING_SYSTEM; // OEM_CHARSET maps to wxFONTENCODING_SYSTEM
	default: return wxFONTENCODING_SYSTEM; // Use the default encoding of the underlying operating system
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing the MFC Charset value that fontEnc maps
///             to from wxWidgets
/// \param      fontEnc   -> the wxFontEncoding value to map from
/// \remarks
/// Called from: the App's UpdateFontInfoStruct().
/// Maps a wxWidgets wxFontEncoding value to its closest MFC Charset value.
/// See the complementing function MapMFCCharsetToWXFontEncoding().
////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::MapWXFontEncodingToMFCCharset(const wxFontEncoding fontEnc)
{
	switch(fontEnc)
	{
        // Note: MFC's SYMBOL_CHARSET, JOHAB_CHARSET, and VIETNAMESE_CHARSET do not seem to
        // have a wx equivalent to map to, so I'm mapping SYMBOL_CHARSET to
        // wxFONTENCODING_DEFAULT; and the other two to wxFONTENCODING_DEFAULT.
	case wxFONTENCODING_CP1252: return 0; //  wxFONTENCODING_CP1252 [Microsoft analogue of ISO8859-1 "WinLatin1"] maps to (0) ANSI_CHARSET
	//case wxFONTENCODING_DEFAULT: return 1; // wxFONTENCODING_DEFAULT maps to (1) DEFAULT_CHARSET
	//case wxFONTENCODING_SYSTEM: return 2; //  wxFONTENCODING_SYSTEM maps to [???] SYMBOL_CHARSET
	case wxFONTENCODING_ISO8859_1: return 1; // Western European (ISO) whm Note: Bob Eaton's GetEncodingStringForXmlFiles() function maps CP_SYMBOL to "iso-8859-1"
	case wxFONTENCODING_ISO8859_2: return 2; // Central European (ISO) TODO: verify
	case wxFONTENCODING_ISO8859_3: return 3; // Latin 3 (ISO) TODO: verify
	case wxFONTENCODING_ISO8859_4: return 4; // Baltic (ISO) TODO: verify
	case wxFONTENCODING_ISO8859_5: return 5; // Cyrillic (ISO) TODO: verify
	case wxFONTENCODING_ISO8859_6: return 6; // Arabic (ISO) TODO: verify
	case wxFONTENCODING_ISO8859_7: return 7; // Greek (ISO) TODO: verify
	case wxFONTENCODING_ISO8859_8: return 8; // Hebrew (ISO-Visual) TODO: verify
	case wxFONTENCODING_ISO8859_9: return 9; // Turkish (ISO) TODO: verify
	case wxFONTENCODING_ISO8859_10: return 10; // TODO: verify
	case wxFONTENCODING_ISO8859_11: return 11; // TODO: verify
	case wxFONTENCODING_ISO8859_12: return 12; // TODO: verify
	case wxFONTENCODING_ISO8859_13: return 13; // Estonian (ISO) TODO: verify
	case wxFONTENCODING_ISO8859_14: return 14; // TODO: verify
	case wxFONTENCODING_ISO8859_15: return 15; // Latin 9 (ISO) TODO: verify
	case wxFONTENCODING_MACROMAN: return 77; // wxFONTENCODING_MACROMAN [mac has encodings 47-86 under wx, default to Roman] maps to MAC_CHARSET
	case wxFONTENCODING_CP932: return 128; // wxFONTENCODING_CP932 [shift-JIS] maps to SHIFTJIS_CHARSET
	case wxFONTENCODING_CP949: return 129; // wxFONTENCODING_CP949 [Korean (Hangul charset)] maps to HANGUL_CHARSET
	//case wxFONTENCODING_DEFAULT: return 130; // wxFONTENCODING_DEFAULT maps to [???] JOHAB_CHARSET
	case wxFONTENCODING_CP936: return 134; // wxFONTENCODING_CP936 [Chinese simplified (GB)] maps to GB2312_CHARSET
	case wxFONTENCODING_CP950: return 136; // wxFONTENCODING_CP950 [Chinese (traditional - Big5)] maps to CHINESEBIG5_CHARSET
	case wxFONTENCODING_CP1253: return 161; // wxFONTENCODING_CP1253 [WinGreek (8859-7)] maps to GREEK_CHARSET
	case wxFONTENCODING_CP1254: return 162; // wxFONTENCODING_CP1254 [WinTurkish] maps to TURKISH_CHARSET
	//case wxFONTENCODING_DEFAULT: return 163; // wxFONTENCODING_DEFAULT maps to [???] VIETNAMESE_CHARSET
	case wxFONTENCODING_CP1255: return 177; // wxFONTENCODING_CP1255 [WinHebrew] maps to HEBREW_CHARSET
	case wxFONTENCODING_CP1256: return 178; // wxFONTENCODING_CP1256 [WinArabic] maps to ARABIC_CHARSET
	case wxFONTENCODING_CP1257: return 186; // wxFONTENCODING_CP1257 [WinBaltic (same as Latin 7)] maps to BALTIC_CHARSET
	case wxFONTENCODING_CP1251: return 204; // wxFONTENCODING_CP1251 [Microsoft analogue of ISO8859-5 "WinCyrillic"] maps to RUSSIAN_CHARSET
	case wxFONTENCODING_CP874: return 222; // wxFONTENCODING_CP874 [WinThai] maps to THAI_CHARSET
	case wxFONTENCODING_CP1250: return 238; // wxFONTENCODING_CP1250 [Microsoft analogue of ISO8859-2 "WinLatin2"] maps to EASTEUROPE_CHARSET
	//case wxFONTENCODING_SYSTEM: return 255; // wxFONTENCODING_SYSTEM maps to OEM_CHARSET
	default: return 0; // Use the default encoding of the underlying operating system for all the others
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      aStr   <- a CBString (byte string) representing the prologue line
///                       for an XML file which contains the encoding
/// \remarks
/// Called from: the App's DoKBSaveAsXML(), the Doc's BackupDocument(), DoFileSave(), and
/// DoTransformedDocFileSave().
/// Generates a byte string formatted as an XML prologue that contains the encoding=
/// element with the standard encoding name. The wxWidgets version identifies only a subset
/// of the exhaustive list of (mostly unused) encoding names available in the MFC version.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetEncodingStringForXmlFiles(CBString& aStr)
{
#ifdef _UNICODE
    // rde's MFC note: if the user configures a legacy font in the AIUnicode product, this
    // will not work! That is, I'm assuming with this code that AIU always only deals with
    // Unicode, for which UTF-8 is the correct encoding name/code page. If the user tried
    // to configure, say, SIL Galatia in AIU, this will fail to work (since in that case,
    // the encoding name should be iso-8859-1)... however, there's no reason we need to
    // support legacy fonts in the Unicode product, so this is a fair assumption for now.
	//
    // whm notes: This GetEncodingStringForXmlFiles is Bob Eaton's large switch case
    // structure designed to return an encoding name string for use in the prologue of
    // Adapt It's xml files. The m_nCodePage is assigned its current value within the
    // UpdateTextHeights() function which is called often - whenever a font change requires
    // redrawing the screen. The current value of m_nCodePage is determined by Microsoft
    // specific calls which are unique to the Windows platform. Bob uses the FONTSIGNATURE
    // and CHARSETINFO structs along with the GetTextCharsetInfo() and
    // TranslateCharsetInfo() functions. When AI starts up it initially sets the
    // m_systemEncoding UINT using the Windows GetACP(void) function which "returns the
    // current ANSI code-page identifier for the system, or a default identifier if no code
    // page is current." The MSDN "Code Page Identifiers" table lists about 149 ANSI code
    // page numbers from 037 through 65001.
    // The FONTSIGNATURE struct contains two bitfields, the first is a 128-bit Unicode
    // subset bitfield, and the second is a 64-bit code-page bitfield that identifies a
    // specific character set of code page - code pages are in the lower 32 bits of this
    // bitfield; the high 32 bits are used for non-Windows code pages. The CHARSETINFO
    // struct contains info about a character set. This struct has a UINT ciCharset
    // containing the "Character set value"; a UINT ciACP containing the "ANSI code-page
    // identifier"; and a FONTSIGNATURE fs member that "identifies the Unicode and code
    // pagefont signature values." The GetTextCharsetInfo() function "retrieves information
    // about the character set of the font that is currently selected into a specified
    // device context." Its int return value can be one of the following defined
    // identifiers (their #define values on Windows are also indicated):
	// ANSI_CHARSET			0
	// BALTIC_CHARSET		186
	// CHINESEBIG5_CHARSET	136
	// DEFAULT_CHARSET		1
	// EASTEUROPE_CHARSET	238
	// GB2312_CHARSET		134
	// GREEK_CHARSET		161
	// HANGUL_CHARSET		129
	// MAC_CHARSET			77
	// OEM_CHARSET			255
	// RUSSIAN_CHARSET		204
	// SHIFTJIS_CHARSET		128
	// SYMBOL_CHARSET		2
	// TURKISH_CHARSET		162
	// VIETNAMESE_CHARSET	163
	//
	// Korean language edition of Windows:
	// JOHAB_CHARSET		130
	//
	// Middle East language edition of Windows:
	// ARABIC_CHARSET		178
	// HEBREW_CHARSET		177
	//
	// Thai language edition of Windows:
	// THAI_CHARSET			222
	//
	// If the function fails, the return value is DEFAULT_CHARSET.
	// The TranslateCharsetInfo() function "translates based on the specified character set,
	// code page, or font signature value, setting all members of the destination structure
	// to appropriate values."
	// The TranslateCharsetInfo() function

	// Bob's code in UpdateTextHeights() is designed to detect if the font is a symbol
	// font, and if so, use a different "encoding" string in Adapt It's xml files.
	// Problem: m_nCodePage in the MFC version is a 32 bit int, whereas within the wxWidgets
	// font encoding representation they are represented as an enum, which has a maximum of
	// 255 different values. Bob's GetEncodingStringForXmlFiles() function has a
	// switch(m_nCodePage) statement which has 141 cases in it, but the values in the
	// switch/case range from 42 to 65006. The values above 255 are not legal for an enum.
	// The appropriate thing to do within wxWidgets is to supply the encoding string
	// for the font encodings that wxWidgets knows about. Therefore, I've commented out
	// parts of Bob's large switch() statement and provided the encoding strings
	// that match those Bob uses where the closest font encoding equivalents match,
	// and a few that don't match - based on the current encoding of Adapt It's source
	// font.

	aStr = "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\r\n";
#else


	switch (m_srcEncoding) //switch(m_nCodePage)
	{
	//case 37:
	//	aStr = "IBM037";
	//	break;
	case wxFONTENCODING_CP437: //case 437:
		aStr = "IBM437";
		break;
	//case 500:
	//	aStr = "IBM500";
	//	break;
	//case 708:
	//	aStr = "ASMO-708";
	//	break;
	//case 720:
	//	aStr = "DOS-720";
	//	break;
	//case 737:
	//	aStr = "ibm737";
	//	break;
	//case 775:
	//	aStr = "ibm775";
	//	break;
	case wxFONTENCODING_CP850: //case 850:
		aStr = "ibm850";
		break;
	case wxFONTENCODING_CP852: //case 852:
		aStr = "ibm852";
		break;
	case wxFONTENCODING_CP855: //case 855:
		aStr = "IBM855";
		break;
	//case 857:
	//	aStr = "ibm857";
	//	break;
	//case 858:
	//	aStr = "IBM00858";
	//	break;
	//case 860:
	//	aStr = "IBM860";
	//	break;
	//case 861:
	//	aStr = "ibm861";
	//	break;
	//case 862:
	//	aStr = "DOS-862";
	//	break;
	//case 863:
	//	aStr = "IBM863";
	//	break;
	//case 864:
	//	aStr = "IBM864";
	//	break;
	//case 865:
	//	aStr = "IBM865";
	//	break;
	case wxFONTENCODING_CP866: //case 866:
		aStr = "cp866";
		break;
	//case 869:
	//	aStr = "ibm869";
	//	break;
	//case 870:
	//	aStr = "IBM870";
	//	break;
	case wxFONTENCODING_CP874: //case 874:
		aStr = "windows-874";
		break;
	//case 875:
	//	aStr = "cp875";
	//	break;
	case wxFONTENCODING_CP932: //case 932:
		aStr = "shift_jis";
		break;
	case wxFONTENCODING_CP936: //case 936:
		aStr = "gb2312";
		break;
	case wxFONTENCODING_CP949: //case 949:
		aStr = "ks_c_5601-1987";
		break;
	case wxFONTENCODING_CP950: //case 950:
		aStr = "big5";
		break;
	//case 1026:
	//	aStr = "IBM1026";
	//	break;
	//case 1047:
	//	aStr = "IBM01047";
	//	break;
	//case 1140:
	//	aStr = "IBM01140";
	//	break;
	//case 1141:
	//	aStr = "IBM01141";
	//	break;
	//case 1142:
	//	aStr = "IBM01142";
	//	break;
	//case 1143:
	//	aStr = "IBM01143";
	//	break;
	//case 1144:
	//	aStr = "IBM01144";
	//	break;
	//case 1145:
	//	aStr = "IBM01145";
	//	break;
	//case 1146:
	//	aStr = "IBM01146";
	//	break;
	//case 1147:
	//	aStr = "IBM01147";
	//	break;
	//case 1148:
	//	aStr = "IBM01148";
	//	break;
	//case 1149:
	//	aStr = "IBM01149";
	//	break;
	//case 1200:
	//	aStr = "utf-16";
	//	break;
	//case 1201:
	//	aStr = "unicodeFFFE";
	//	break;
	case wxFONTENCODING_CP1250: //case 1250:
		aStr = "windows-1250";
		break;
	case wxFONTENCODING_CP1251: //case 1251:
		aStr = "windows-1251";
		break;
	case wxFONTENCODING_CP1253: //case 1253:
		aStr = "windows-1253";
		break;
	case wxFONTENCODING_CP1254: //case 1254:
		aStr = "windows-1254";
		break;
	case wxFONTENCODING_CP1255: //case 1255:
		aStr = "windows-1255";
		break;
	case wxFONTENCODING_CP1256: //case 1256:
		aStr = "windows-1256";
		break;
	case wxFONTENCODING_CP1257: //case 1257:
		aStr = "windows-1257";
		break;
	//case 1258:
	//	aStr = "windows-1258";
	//	break;
	//case 1361:
	//	aStr = "Johab";
	//	break;
	case wxFONTENCODING_MACROMAN: //case 10000:
		aStr = "macintosh";
		break;
	case wxFONTENCODING_MACJAPANESE: //case 10001:
		aStr = "x-mac-japanese";
		break;
	case wxFONTENCODING_MACCHINESETRAD: //case 10002:
		aStr = "x-mac-chinesetrad";
		break;
	case wxFONTENCODING_MACKOREAN: //case 10003:
		aStr = "x-mac-korean";
		break;
	case wxFONTENCODING_MACARABIC: //case 10004:
		aStr = "x-mac-arabic";
		break;
	case wxFONTENCODING_MACHEBREW: //case 10005:
		aStr = "x-mac-hebrew";
		break;
	case wxFONTENCODING_MACGREEK: //case 10006:
		aStr = "x-mac-greek";
		break;
	case wxFONTENCODING_MACCYRILLIC: //case 10007:
		aStr = "x-mac-cyrillic";
		break;
	case wxFONTENCODING_MACCHINESESIMP: //case 10008:
		aStr = "x-mac-chinesesimp";
		break;
	case wxFONTENCODING_MACROMANIAN: //case 10010:
		aStr = "x-mac-romanian";
		break;
	//case 10017:
	//	aStr = "x-mac-ukrainian";
	//	break;
	case wxFONTENCODING_MACTHAI: //case 10021:
		aStr = "x-mac-thai";
		break;
	case wxFONTENCODING_MACCENTRALEUR: //case 10029:
		aStr = "x-mac-ce"; // "ce" stands for "central european"
		break;
	case wxFONTENCODING_MACICELANDIC: //case 10079:
		aStr = "x-mac-icelandic";
		break;
	case wxFONTENCODING_MACTURKISH: //case 10081:
		aStr = "x-mac-turkish";
		break;
	case wxFONTENCODING_MACCROATIAN: //case 10082:
		aStr = "x-mac-croatian";
		break;
	//case 20000:
	//	aStr = "x-Chinese-CNS"; // same as wxFONTENCODING_CP950 Chinese (traditional - Big5)?
	//	break;
	//case 20001:
	//	aStr = "x-cp20001";
	//	break;
	//case 20002:
	//	aStr = "x-Chinese-Eten";
	//	break;
	//case 20003:
	//	aStr = "x-cp20003";
	//	break;
	//case 20004:
	//	aStr = "x-cp20004";
	//	break;
	//case 20005:
	//	aStr = "x-cp20005";
	//	break;
	//case 20105:
	//	aStr = "x-IA5";
	//	break;
	//case 20106:
	//	aStr = "x-IA5-German";
	//	break;
	//case 20107:
	//	aStr = "x-IA5-Swedish";
	//	break;
	//case 20108:
	//	aStr = "x-IA5-Norwegian";
	//	break;
	//case 20127:
	//	aStr = "us-ascii";
	//	break;
	//case 20261:
	//	aStr = "x-cp20261";
	//	break;
	//case 20269:
	//	aStr = "x-cp20269";
	//	break;
	//case 20273:
	//	aStr = "IBM273";
	//	break;
	//case 20277:
	//	aStr = "IBM277";
	//	break;
	//case 20278:
	//	aStr = "IBM278";
	//	break;
	//case 20280:
	//	aStr = "IBM280";
	//	break;
	//case 20284:
	//	aStr = "IBM284";
	//	break;
	//case 20285:
	//	aStr = "IBM285";
	//	break;
	//case 20290:
	//	aStr = "IBM290";
	//	break;
	//case 20297:
	//	aStr = "IBM297";
	//	break;
	//case 20420:
	//	aStr = "IBM420";
	//	break;
	//case 20423:
	//	aStr = "IBM423";
	//	break;
	//case 20424:
	//	aStr = "IBM424";
	//	break;
	//case 20833:
	//	aStr = "x-EBCDIC-KoreanExtended";
	//	break;
	//case 20838:
	//	aStr = "IBM-Thai";
	//	break;
	//case 20866:
	//	aStr = "koi8-r";
	//	break;
	//case 20871:
	//	aStr = "IBM871";
	//	break;
	//case 20880:
	//	aStr = "IBM880";
	//	break;
	//case 20905:
	//	aStr = "IBM905";
	//	break;
	//case 20924:
	//	aStr = "IBM00924";
	//	break;
	case wxFONTENCODING_EUC_JP: //case 20932:
		aStr = "EUC-JP";
		break;
	//case 20936:
	//	aStr = "x-cp20936";
	//	break;
	//case 20949:
	//	aStr = "x-cp20949";
	//	break;
	//case 21025:
	//	aStr = "cp1025";
	//	break;
	case wxFONTENCODING_KOI8_U: //case 21866:
		aStr = "koi8-u";
		break;
	//case CP_SYMBOL: // ??? The enum value for this in Windows is 42 which is wxFONTENCODING_EUC_JP
	case wxFONTENCODING_ISO8859_1: //case 28591:
		aStr = "iso-8859-1";
		break;
	case wxFONTENCODING_ISO8859_2: //case 28592:
		aStr = "iso-8859-2";
		break;
	case wxFONTENCODING_ISO8859_3: //case 28593:
		aStr = "iso-8859-3";
		break;
	case wxFONTENCODING_ISO8859_4: //case 28594:
		aStr = "iso-8859-4";
		break;
	case wxFONTENCODING_ISO8859_5: //case 28595:
		aStr = "iso-8859-5";
		break;
	case wxFONTENCODING_ISO8859_6: //case 28596:
		aStr = "iso-8859-6";
		break;
	case wxFONTENCODING_ISO8859_7: //case 28597:
		aStr = "iso-8859-7";
		break;
	case wxFONTENCODING_ISO8859_8: //case 28598:
		aStr = "iso-8859-8";
		break;
	case wxFONTENCODING_ISO8859_9: //case 28599:
		aStr = "iso-8859-9";
		break;
	// Note: wxFONTENCODING_CP1252 is just above the default: case below
	case wxFONTENCODING_ISO8859_13: //case 28603:
		aStr = "iso-8859-13";
		break;
	case wxFONTENCODING_ISO8859_15: //case 28605:
		aStr = "iso-8859-15";
		break;
	//case 29001:
	//	aStr = "x-Europa";
	//	break;
	//case 38598:
	//	aStr = "iso-8859-8-i";
	//	break;
	//case 50220:
	//	aStr = "iso-2022-jp";
	//	break;
	//case 50221:
	//	aStr = "csISO2022JP";
	//	break;
	//case 50222:
	//	aStr = "iso-2022-jp";
	//	break;
	//case 50225:
	//	aStr = "iso-2022-kr";
	//	break;
	//case 50227:
	//	aStr = "x-cp50227";
	//	break;
	//case 51932:
	//	aStr = "euc-jp";
	//	break;
	//case 51936:
	//	aStr = "EUC-CN";
	//	break;
	//case 51949:
	//	aStr = "euc-kr";
	//	break;
	//case 52936:
	//	aStr = "hz-gb-2312";
	//	break;
	//case 54936:
	//	aStr = "GB18030";
	//	break;
	//case 57002:
	//	aStr = "x-iscii-de";
	//	break;
	//case 57003:
	//	aStr = "x-iscii-be";
	//	break;
	//case 57004:
	//	aStr = "x-iscii-ta";
	//	break;
	//case 57005:
	//	aStr = "x-iscii-te";
	//	break;
	//case 57006:
	//	aStr = "x-iscii-as";
	//	break;
	//case 57007:
	//	aStr = "x-iscii-or";
	//	break;
	//case 57008:
	//	aStr = "x-iscii-ka";
	//	break;
	//case 57009:
	//	aStr = "x-iscii-ma";
	//	break;
	//case 57010:
	//	aStr = "x-iscii-gu";
	//	break;
	//case 57011:
	//	aStr = "x-iscii-pa";
	//	break;
	case wxFONTENCODING_UTF7: //case 65000:
		aStr = "utf-7";
		break;
	case wxFONTENCODING_UTF8: //case 65001:
		aStr = "utf-8";
		break;
	case wxFONTENCODING_UTF32LE: // case 65005: // I assume utf-32 is Little Endian LE
		aStr = "utf-32";
		break;
	case wxFONTENCODING_UTF32BE: //case 65006:
		aStr = "utf-32BE";
		break;

	case wxFONTENCODING_CP1252: //case 1252: // falls through to "Windows-1252"
	default:
		aStr = "Windows-1252";
		break;
	}

	aStr = "<?xml version=\"1.0\" encoding=\"" + aStr + "\" standalone=\"yes\"?>\r\n";
#endif
}


////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the App's DoStartWorkingWizard(), OnAdvancedBookMode(), the canvas'
/// OnLButtonDown(), the Doc's OnOpenDocument(), the View's Jump(),
/// OnAdvancedUseTransliterationMode(), CDocPage's InitDialog(), OnWizardFinish(),
/// CJoinDialog's InitDialog(), OnBnClickedJoinNow(), CMoveDialog's InitDialog(),
/// OnBnClickedMoveNow(), OnBnClickedButtonRenameDoc(), OnBnClickedRadioToBookFolder(),
/// OnBnClickedRadioFromBookFolder(), CPhraseBox's OnPhraseBoxChanged(), MoveToNextPile(),
/// MoveToPrevPile(), OnKeyDown(), ChooseTranslation(), CSplitDialog's
/// OnBnClickedButtonSplitNow(), InitDialog(), CWhichBook's InitDialog(),
/// OnSelchangeChooseBook(), OnCancel(), OnOK(), OnCustomWorkFolderLocation(),
/// OnLockCustomLocation(), OnUnlockCustomLocation, OnRestoreDefaultWorkFolderLocation(),
/// OnRadioReviewing() and OnRadioDrafting()
/// Updates the status bar message to reflect the current activity.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::RefreshStatusBarInfo()
{
	CAdapt_ItView* pView = gpApp->GetView();
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxString rscStr; // MFC Note: to get past a bug

	// BEW 6Nov09, added "[Default Work Folder Location]" versus "[Custom Work Folder Location]"
	// to distinguish between whether a custom work folder location is in effect versus the
	// default "Adapt It Work" or "Adapt It Unicode Work" folder at the standard data folder
	// for the particular OS (the latter also includes non-standard locations specified by
	// use of the -wf switch) -- also added "[Temporary Work Folder Location]" for when
	// the custom location is not locked down (ie. will not persist beyond the session)
	if (m_bUseCustomWorkFolderPath)
	{
		if (m_bLockedCustomWorkFolderPath)
		{
			// a persistent custom work folder location is in effect
			rscStr = _("[Custom Work Folder Location]  Current Project: %s");
		}
		else
		{
			// a non-persistent custom work folder location is in effect
			rscStr = _("[Temporary Work Folder Location]  Current Project: %s");
		}
	}
	else
	{
		// the default, or -wf switch-specified, location is in effect
		// whm modified 7Jan12 replace "Default Work Folder Location" info with "Collaborating
		// with Paratext/Bibledit" info in status bar
		if (gpApp->m_bCollaboratingWithBibledit || gpApp->m_bCollaboratingWithParatext)
		{
			wxASSERT(!m_collaborationEditor.IsEmpty());
			wxString message = _("Collaborating with ");
			message += gpApp->m_collaborationEditor;
			rscStr = _T("[");
			rscStr += message;
			rscStr += _T("] ");
			rscStr += _T("Current Project: %s");
		}
		else
		{
			rscStr = _("[Default Work Folder Location]  Current Project: %s");
		}
	}
	wxString message;
	message = message.Format(rscStr,gpApp->m_curProjectName.c_str());

	// do nothing if there is no active pile or a bad sequence number of no target box
	bool bDocIsThere = TRUE;
	if (gpApp->m_pTargetBox != NULL)
	{
		// whm added test for m_pActivePile == NULL
		//if (gpApp->m_pActivePile == NULL || gpApp->m_pActivePile->m_pSrcPhrase == NULL
		if (gpApp->m_pActivePile == NULL || gpApp->m_pActivePile->GetSrcPhrase() == NULL
			|| gpApp->m_nActiveSequNum < 0
			|| gpApp->m_pTargetBox->IsShown())
			bDocIsThere = FALSE;
	}
	else
		bDocIsThere = FALSE;

	if (bDocIsThere)
	{
		gpApp->m_pActivePile = pView->GetPile(gpApp->m_nActiveSequNum); // ensure a
												// valid pointer (BEW added 28Jun05)
		wxString chVerse = pView->GetChapterAndVerse(gpApp->m_pActivePile->GetSrcPhrase());
		if (!chVerse.IsEmpty())
		{
			message += _T("  ") + chVerse;
		}
	}
	wxString prefix;
	if (gbIsGlossing)
	{
		// IDS_GLOSSING
		prefix = _("Glossing");
	}
	else
	{
		// BEW changed 6Nov09 to distinguish between drafting (ie. "adapting")
		// versus reviewing (as adapting mode can be used for smart back translating
		// and reviewing mode for dumb back translating, we use the primary labels
		// adapting versus reviewing, which hopefully are the maximally meaningful ones)
		if (m_bDrafting)
		{
			// IDS_ADAPTING
			prefix = _("Adapting");
		}
		else
		{
			// review mode - which, for the use of the -frm switch, is also
			// the "back translating 'dumb' mode made persistent for the
			// session
			prefix = _("Reviewing");
		}
	}
	message = prefix + _T("  ") + message;
	wxString mssg;
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
	{
		if (gpApp->m_pCurrBookNamePair != NULL && gpApp->m_nBookIndex != -1)
		{
			// IDS_CURFOLDER
			mssg = mssg.Format(_("  Current Folder: %s"),
							gpApp->m_pCurrBookNamePair->seeName.c_str());
			message += mssg;
		}
		else
		{
			wxString undef;
			// IDS_UNDEFINED
			undef = _(" Undefined");
			// IDS_CURFOLDER
			mssg = mssg.Format(_("  Current Folder: %s"),undef.c_str());
			message += mssg;
		}
	}
	else
	{
		// IDS_CURFOLDER
		mssg = mssg.Format(_("  Current Folder: %s"),_("Adaptations"));
		message += mssg;
	}
	if (gpApp->m_bTransliterationMode)
	{
		// add the extra !! Using Transliteration Mode !! to the end,
		// when it is turned on
		//IDS_USING_TRANSLIT_STATUS_MSG
		mssg = _("!! TRANSLITERATING !!");
		message += _T("    ") + mssg;
	}
	pView->StatusBarMessage(message);
	pFrame->m_pStatusBar->Update();
}

// Getters, setters, and shorthands.  Added by Jonathn Field 2005

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the current book display name
/// \remarks
/// Called from: The App's GetCurrentDocFolderDisplayName(), CMoveDialog's
/// OnBnClickedViewOther(), and MoveDirectionChanged().
/// Gets the seeName for the current book.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetCurrentBookDisplayName()
{
	return m_pCurrBookNamePair->seeName;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the current book folder path
/// \remarks
/// Called from: The App's GetCurrentBookFolderName(), GetCurrentDocFolderPath(),
/// CMoveDialog's OnBnClickedButtonRenameDoc(), OnBnClickedViewOther(), UpdateFileList(),
/// and Mover::BeginMove().
/// Gets the value stored in m_bibleBooksFolderPath.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetCurrentBookFolderPath() {
	return m_bibleBooksFolderPath;
	// OR perhaps
	// ConcatenatePathBits(GetAdaptationsFolderPath(), m_pCurrBookNamePair->dirName);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the current book folder name
/// \remarks
/// Called from: (currently unused).
/// Gets the current book folder name by stripping the path from the current
/// book folder path.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetCurrentBookFolderName()
{
	return StripPath(GetCurrentBookFolderPath());
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the adaptations folder display name
/// \remarks
/// Called from: the App's GetCurrentDocFolderDisplayName(), CMoveDialog's
/// OnBnClickedViewOther(), and MoveDirectionChanged().
/// Gets the adaptations folder display name which is "Adaptations"
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetAdaptationsFolderDisplayName()
{
	wxString rv; // Return Value
	rv = _("Adaptations");
	return rv;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the adaptations folder path
/// \remarks
/// Called from: the App's GetAdaptationsFolderName(), GetCurrentDocFolderPath(),
/// CMoveDialog's OnBnClickedButtonRenameDoc(), OnBnClickedViewOther(), UpdateFileList(),
/// and Mover::BeginMove().
/// Gets the adaptations folder path stored in m_curAdaptionsPath.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetAdaptationsFolderPath()
{
	return m_curAdaptionsPath;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the adaptations folder name
/// \remarks
/// Called from: (currently unused).
/// Gets the adaptations folder name by stripping the path from the
/// adaptations folder path.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetAdaptationsFolderName()
{
	return StripPath(GetAdaptationsFolderPath());
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the current document's name
/// \remarks
/// Called from: the App's GetCurrentDocPath(), CJoinDialog's OnBnClickedJoinNow(),
/// InitialiseLists(), CSplitDialog's OnBnClickedButtonSplitNow(),
/// SplitAtPhraseBoxLocation_Interactive(), and InitDialog().
/// Gets the current document's name as stored in m_curOutputFilename.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetCurrentDocFileName()
{
	return m_curOutputFilename;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the current document's path
/// \remarks
/// Called from: CSplitDialog::SplitAtPhraseBoxLocation_Interactive(),
/// DoSplitIntoChapters(), and SplitIntoChapters_Interactive().
/// Gets the current document's path by concatenating its path and name.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetCurrentDocPath()
{
	return ConcatenatePathBits(GetCurrentDocFolderPath(), GetCurrentDocFileName());
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the current document's display name
/// \remarks
/// Called from: CSplitDialog::ListFiles().
/// Gets the current document's display name depending on the book mode.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetCurrentDocFolderDisplayName()
{
	return GetBookMode() ? GetCurrentBookDisplayName() : GetAdaptationsFolderDisplayName();
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the current document folder's path
/// \remarks
/// Called from: the App's GetCurrentDocPath(), ChangeDocUnderlyingFileDetailsInPlace(),
/// CJoinDialog's OnBnClickedJoinNow(), InitialiseLists(),
/// CMoveDialog::OnBnClickedButtonRenameDoc(), CSplitDialog's
/// SplitAtPhraseBoxLocation_Interactive(), SplitIntoChapters_Interactive(), and
/// ListFiles().
/// Gets the current document folder's path depending on the book mode.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetCurrentDocFolderPath()
{
	return GetBookMode() ? GetCurrentBookFolderPath() : GetAdaptationsFolderPath();
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      NewFileName -> the new filename
/// \remarks
/// Called from: CSplitDialog's SplitIntoChapters_Interactive().
/// Calls ChangeDocUnderlyingFileDetailsInPlace().
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ChangeDocUnderlyingFileNameInPlace(wxString NewFileName)
{
	ChangeDocUnderlyingFileDetailsInPlace(NewFileName);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      NewFolderPath -> the new folder path
/// \param      NewFileName   -> the new filename
/// \remarks
/// Called from: the App's ChangeDocUnderlyingFileDetailsInPlace() [one paramater
/// override], CJoinDialog's OnBnClickedJoinNow(), CMoveDialog's
/// OnBnClickedButtonRenameDoc(), Changes the App's m_curOutputFilename to NewFileName, and
/// the App's m_curOutputPath to NewFolderPath + NewFileName. Calls the Doc's SetFilename()
/// with m_curOutputPath.
/// See override that takes only NewFileName parameter.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ChangeDocUnderlyingFileDetailsInPlace(wxString NewFolderPath, wxString NewFileName)
{
	CAdapt_ItDoc *d = GetDocument();
	m_curOutputFilename = NewFileName;
	m_curOutputPath = ConcatenatePathBits(NewFolderPath, NewFileName);
	d->SetFilename(m_curOutputPath, true);

	// get OnIdle() to update the document name
	gbUpdateDocTitleNeeded = TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      NewFileName   -> the new filename
/// \remarks
/// Called from: the App's ChangeDocUnderlyingFileNameInPlace(),
/// CSplitDialog's SplitAtPhraseBoxLocation_Interactive().
/// Calls ChangeDocUnderlyingFileDetailsInPlace() [two parameter override].
/// See override that takes both NewFolderPath and NewFileName.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::ChangeDocUnderlyingFileDetailsInPlace(wxString NewFileName)
{
	ChangeDocUnderlyingFileDetailsInPlace(this->GetCurrentDocFolderPath(), NewFileName);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if doc is open, FALSE otherwise
/// \param      FolderPath   -> the folder path
/// \param      FileName     -> the filename
/// \remarks
/// Called from: CMoveDialog::OnBnClickedButtonRenameDoc() and Mover::FinishMove().
/// Determines if the FolderPath+FileName doc is open (does not use file operations).
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::IsOpenDoc(wxString FolderPath, wxString FileName)
{
	return m_curOutputPath.CmpNoCase(ConcatenatePathBits(FolderPath, FileName)) == 0;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if doc has unsaved changes, FALSE otherwise
/// \remarks
/// Called from: CMoveDialog::OnBnClickedButtonRenameDoc(), Mover::FinishMove(),
/// CSplitDialog's SplitAtPhraseBoxLocation_Interactive() and DoSplitIntoChapters().
/// Determines if the doc is dirty (has unsaved changes) by calling IsModified().
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::GetDocHasUnsavedChanges()
{
	return (gpApp->GetDocument()->IsModified() != FALSE);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the book indicator string for the current
///             book folder if in book mode, otherwise a null string if book mode is not
///             activated
/// \remarks
/// Called from: the App's GetBookID(), and Mover::FinishMove().
/// Gets the book indicator string for the current book folder, or a null string if
/// not in book folder mode.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetBookIndicatorStringForCurrentBookFolder()
{
	wxString rv;
	rv.Empty();
	wxString s;

    // BEW modified 03Nov05: we rely on the fact that when book mode is on, the
    // m_nBookIndex tells us which BookNamePair pointer to index in m_pBibleBooks in order
    // to get the current directory name, and the book ID code (from the same BookNamePair
    // instance) and we return an empty string if book mode is not turned on
	if (GetBookMode() && m_nBookIndex >= 0 && m_nBookIndex <= 66)
	{
		BookNamePair* pPair = (BookNamePair*)m_pBibleBooks->Item(m_nBookIndex);
		return pPair->bookCode;
	}
	return rv;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if in book mode, otherwise FALSE
/// \remarks
/// Called from: the App's GetCurrentDocFolderDisplayName(), GetCurrentDocFolderPath(),
/// GetBookIndicatorStringForCurrentBookFolder(), and GetBookID().
/// Determines if the application is in book mode or not. Simply returns the
/// value in m_bBookMode.
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::GetBookMode()
{
	return m_bBookMode != 0;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: CJoinDialog::OnBnClickedJoinNow(),
/// CMoveDialog::OnBnClickedButtonRenameDoc(), Mover::FinishMove(), CSplitDialog's
/// SplitAtPhraseBoxLocation_Interactive(), and SplitIntoChapters_Interactive().
/// Calls the App's DoAutoSaveDoc().
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SaveDocChanges()
{
	DoAutoSaveDoc();
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: CMoveDialog::OnBnClickedButtonRenameDoc() and Mover::FinishMove().
/// Calls the View's ClobberDocument() to destroy the current in-memory document
/// structures, then calls the Doc's OnOpenDocument() to open the same document afresh.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DiscardDocChanges()
{
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	CAdapt_ItView* pView = gpApp->GetView();
	pView->ClobberDocument();
	wxString reversionPath = m_curOutputPath;
	wxASSERT(!reversionPath.IsEmpty());
	bool bOK = pDoc->OnOpenDocument(reversionPath);
	// we should get it open safely every time, but just in case...
	if (!bOK)
	{
		// a hard coded message will do, we never expect to see it
		wxMessageBox(_T(
"DiscardDocChanges() failed on the OnOpenDocument() call after passing in the reversion document's path."),
		_T(""), wxICON_WARNING);
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: Mover::FinishMove() and CSplitDialog::SplitIntoChapters_Interactive().
/// Calls the View's ClobberDocument().
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::CloseDocDiscardingAnyUnsavedChanges()
{
	GetView()->ClobberDocument();
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a pointer to a SPList of source phrases loaded from the document
///             at FilePath
/// \remarks
/// Called from: CJoinDialog::OnBnClickedJoinNow().
/// Calls the Doc's method of the same name: CAdapt_ItDoc::LoadSourcePhraseListFromFile().
////////////////////////////////////////////////////////////////////////////////////////
SPList *CAdapt_ItApp::LoadSourcePhraseListFromFile(wxString FilePath)
{
	return CAdapt_ItDoc::LoadSourcePhraseListFromFile(FilePath);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE unless there was a mismatch book ID or an invalid book ID in
///             which case returns FALSE
/// \param      ol                                   <- pointer to the list of source
///                                                     phrases to be appended
/// \param      curBookID                            -> the current book ID
/// \param      IsLastAppendUsingThisMethodRightNow  -> TRUE when being called on the
///                                                     last of the listed files to be
///                                                     appended
/// \remarks
/// Called from: CJoinDialog::OnBnClickedJoinNow().
/// Appends a list of source phrases (from ol) to the current Doc's list of source phrases,
/// effectively joining two documents. Tests to make sure book IDs are valid and that they
/// match, and does other housekeeping to make sure end markers and sequence numbers are
/// handled properly.
/// BEW 12Apr10, changed for support of doc version 5
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::AppendSourcePhrasesToCurrentDoc(SPList *ol, wxString& curBookID,
												 bool IsLastAppendUsingThisMethodRightNow)
{
    // In AppendSourcePhrasesToCurrentDoc the bool input parameter will be true when this
    // method is being called on the last of the listed files to be appended.
    // BEW modified 15Aug07 (version 3.5.0 is officially dated 7Aaug07, but I did not
    // release it until end of the month and so these 15Aug bug fix changes are in 3.5.0)
    // to move final endmarkers on a null CSourcePhrase to the first CSourcePhrase instance
    // (after removal of the book ID one) in the doc to be joined, to its m_markers
    // member's start
	CAdapt_ItDoc *d = GetDocument();
	CAdapt_ItView *v = GetView();
	CLayout* pLayout = m_pLayout;

    // get the current document's count of CSourcePhrase instances, so we can later locate
    // the active location to the first instance at the join location
	int nOldCount = m_pSourcePhrases->GetCount();

	// test for match of book ID codes here, return if they don't match
	wxString lowerPassedInID = curBookID;
	lowerPassedInID.MakeLower(); // it's now lower case
	wxString appendingDoc_BookID;
	wxString lowerAppendingBookID;
	SPList::Node* pos = ol->GetFirst();
	CSourcePhrase* pFirstSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pFirstSrcPhrase);
	if (pFirstSrcPhrase->m_markers.Find(_T("\\id ")) == 0)
	{
		// there is an \id defined, and so we can get it and check for a match
		appendingDoc_BookID = pFirstSrcPhrase->m_srcPhrase; // if it had
										// punctuation it would be invalid
		if (IsValidBookID(appendingDoc_BookID))
		{
			// check if we have matching book IDs
			lowerAppendingBookID = appendingDoc_BookID;
			lowerAppendingBookID.MakeLower(); // it's now lower case too
			if (lowerPassedInID != lowerAppendingBookID)
			{
				// mismatched
				return FALSE;
			}
			else
			{
				// matched book IDs, so delete the first source phrase in the
				// doc to be appended's list
				ol->DeleteNode(ol->GetFirst()); //ol->RemoveHead();
			}
		}
		else
		{
			// an invalid ID cannot possibly match the passed in bookID,
			// so we have a mismatch
			return FALSE;
		}
	}
	else
	{
		// here is no \id, (the document might not have USFM or SFM markup),
		// so don't make any book ID check
		;
	}
	// Jonathan's code continues here...
	//m_pSourcePhrases->Append(ol);
    // wx doesn't have a wxList method for appending one list onto another list, so we'll
    // do it manually
    // BEW 15Jun09; in the refactored view design, each CSourcePhrase instance in the list
	// should have a partner pile in the m_pileList in CLayout, and just appending
	// CSourcePhrase instances in the loop below will not be enough. Moreover the Jump()
	// call at the end of the block below has a PlacePhraseBox() call, with RecalcLayout()
	// using the option keep_strips_keep_piles, but there won't have been any strips yet
	// for the CSourcePhrases which we append just below. So, we have to get a set of
	// valid partner piles, and do a RecalcLayout() call here with the option
	// create_strips_and_piles in order for the rest of the code to work right in the
	// refactored design
	SPList::Node* node = ol->GetFirst();
	while (node)
	{
		m_pSourcePhrases->Append(node->GetData());
		node = node->GetNext();
	}
	// now do the adjustments for our refactored view design
	d->UpdateSequNumbers(0); // even though it's done in next block, next block is called
							 // only for the last set of appends, and we need it here
							 // each time
	pLayout->RecalcLayout(m_pSourcePhrases,create_strips_and_piles); // this call destroys
							// the smaller set of current piles and builds all from scratch
							// and then the strips based on them - this ensures that a later
							// ScrollIntoView() call, which will use CPile::m_pOwningStrip
							// will always succeed for whatever CPile instance is used
	if (IsLastAppendUsingThisMethodRightNow)
	{
		// get all the sequence numbers into correct sequence
		d->UpdateSequNumbers(0);
		int anActiveSequNum = nOldCount; // the first CSourcePhrase of the just
										 // joined doc part
		if (anActiveSequNum <= GetMaxIndex())
		{
			// it's within the document span
			m_nActiveSequNum = anActiveSequNum;
		}
		else
		{
			m_nActiveSequNum = GetMaxIndex();
		}
		CSourcePhrase* pSrcPhrase = v->GetSrcPhrase(m_nActiveSequNum);
		v->Jump(this, pSrcPhrase); // Jump to the last join point, if possible;
								   // else to a safe location
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a pointer to the SPList of the current document's source phrases
/// \remarks
/// Called from: CSplitDialog::GoToNextChapter_Interactive().
/// Simply returns the pointer to the App's m_pSourcePhrases member.
////////////////////////////////////////////////////////////////////////////////////////
SPList *CAdapt_ItApp::GetSourcePhraseList()
{
	return m_pSourcePhrases;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a pointer to the current source phrase (at m_cruIndex)
/// \remarks
/// Called from: the App's CascadeSourcePhraseListChange(), and
/// CSplitDialog::GoToNextChapter_Interactive().
/// Simply calls GetSourcePhraseByIndex() passing in the view's m_nActiveSequNum
/// remarks:
/// A similar function on the view class is GetSourcePhrase(int nSequNum)
////////////////////////////////////////////////////////////////////////////////////////
CSourcePhrase *CAdapt_ItApp::GetCurrentSourcePhrase()
{
    // refactored 22Mar09: to be based on view's m_nActiveSequNum rather than bundle's
    // m_curIndex because the latter has been removed
	return GetSourcePhraseByIndex(m_nActiveSequNum);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      sp   -> a pointer to a source phrase to jump to
/// \remarks
/// Called from: CSplitDialog::GoToNextChapter_Interactive().
/// Ensures that gbIsDocumentSplittingDialogActive is TRUE, then calls the View's Jump()
/// method to jump to the source phrase at sp. Then sets the global back to FALSE. The
/// purpose of the global is so that "the Jump() call will not copy the source text into
/// the phrasebox if the box lands at a hitherto unadapted (or unglossed) location -- so if
/// the document split is then made at that location, it won't save into the KB a spurious
/// copy of the source text as the 'adaptation' at whatever location the box happened to
/// land at."
/// whm comment: A cleaner design would add a bool parameter to the Jump() method to
/// specify whether the source text should be copied, something that would eliminate the
/// use of the global and which might simplify the code at the other locations where Jump()
/// is called.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetCurrentSourcePhrase(CSourcePhrase *sp)
{
	// refactored 22Mar09 - no change needed
    // BEW modified 02Nov05, to prevent a copy of the source text word at the new box
    // location being copied to m_targetPhrase when there is no adaptation (or gloss if
    // gloss mode is currently on) already available for that location
	gbIsDocumentSplittingDialogActive = TRUE;
	GetView()->Jump(this, sp);
	gbIsDocumentSplittingDialogActive = FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a pointer to a source phrase that starts the next chapter of text
///             or NULL if none found
/// \param      ol   -> the SPList of the document
/// \param      sp   <- the source phrase at the initial and subsequent active
///                     search locations
/// \remarks
/// Called from: CSplitDialog::GoToNextChapter_Interactive().
/// Determines which source phrase in the SPList of the current document marks the
/// beginning of the next chapter, i.e., the potential point where that next chapter could
/// be split off.
////////////////////////////////////////////////////////////////////////////////////////
CSourcePhrase *CAdapt_ItApp::FindNextChapter(SPList *ol, CSourcePhrase *sp)
{
    // Note 1: FindNextChapter includes any section head which precedes the chapter because
    // of the rather fortunate (or deliberate) fact that correct SF markup places the \c
    // marker preceding the \s or \s1 marker of the section head; and even if the section
    // head is specified as to be filtered, it will be stored on the pSrcPhrase instance
    // which has the m_bChapter boolean set TRUE, so correct behaviour is assured provided
    // the next chapter's start is determined by the SplitDialog's button for that purpose.
    // Note 2: In the case where the phrase box is located anywhere in an \id marker's
    // content, we don't want the next chapter to be wrongly set as the chapter immediately
    // following the identification information, but rather at the end of chapter one - so
    // we explicitly check for a TextType different than verse, and advance over it any
    // other text types until we come to a verse TextType and use that as the kick-off
    // point
	SPList::Node* p = ol->Find(sp);
	sp = (CSourcePhrase*)p->GetData();
	p = p->GetNext();	// TODO: check this - doesn't MFC version skip a source
						// phrase before the while loop below???

	// get over any \id content, or other TextType(s)
	while (sp->m_curTextType != verse)
	{
		sp = (CSourcePhrase*)p->GetData();
		p = p->GetNext();
	}

	// get past any sourcephrase which may start the current rather than next chapter
	//if (p) sp = (CSourcePhrase*)ol->GetNext(p);
	if (p)
	{
		sp = (CSourcePhrase*)p->GetData();
		p = p->GetNext();
	}

	// scan until the next start of chapter location is found
	while (p != NULL && sp->m_bChapter == false)
	{
		sp = (CSourcePhrase*)p->GetData();
		p = p->GetNext();
	}
	return p ? sp : NULL;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing a filename guaranteed to end with
///             the .xml extension
/// \param      s   -> a wxString representing a file name
/// \remarks
/// Called from: CJoinDialog::OnBnClickedJoinNow(), CSplitDialog's
/// SplitAtPhraseBoxLocation_Interactive() and DoSplitIntoChapters().
/// Makes sure the file name s has an .xml extension and returns it to the caller.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::ApplyDefaultDocFileExtension(wxString s)
{
	wxString defExtn = _T(".xml");
	if (s.Find(_T(".")) == wxNOT_FOUND)
	{
		// if there is no point, then we can unlaterally add the default extension
		return s + defExtn;
	}
	else
	{
        // there is a point character, but it might not be .xml and so we must check out if
        // the point is a chapter and/or verse delimiter in the filename - our criterion
        // will be that this is so whenever the filename does not end in .xml
		wxString xmlext = _T(".xml");
		s = MakeReverse(s);
		xmlext = MakeReverse(xmlext);
		if (s.Find(xmlext) == 0)
		{
			// we have a valid extension, so return without doing anything
			s = MakeReverse(s);
			return s;
		}
		else
		{
			// we need to add the current default extension
			s = MakeReverse(s);
			return s + defExtn;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      l   -> pointer to a list of source phrases
/// \remarks
/// Called from: CSplitDialog's SplitAtPhraseBoxLocation_Interactive() and
/// SplitIntoChapters_Interactive().
/// Deletes the source phrases from the list pointed to by l. Does nothing if there
/// are no source phrases in l.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DeleteSourcePhraseListContents(SPList *l)
{
	// BEW modified 02Nov05, because earlier version leaked memory (so I plagiarized
	// the DeleteSourcePhrases() function in the doc class for safe deletion code)
	CAdapt_ItDoc* pDoc = GetDocument();
	if (!l->IsEmpty())
	{
		// delete all the tokenizations of the source text
		SPList::Node* pos = l->GetFirst();
		while (pos != NULL)
		{
			CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			pDoc->DeleteSingleSrcPhrase(pSrcPhrase); // Note, it would be more efficient
			// to use (pSrcPhrase,FALSE) and then destroy the partner piles enmasse with
			// a call such as DestroyPiles(PileList* piles) -- but we don't have such a
			// function defined in AI yet, and the sublist corresponding to the sublist l
			// passed in above, would have to be calculated -- all of which could be done,
			// but the returns are diminished, so I'll not bother
		}
		l->Clear();
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      DoFullScreenUpdate   -> fully updates the screen if TRUE
/// \remarks
/// Called from: CJoinDialog::OnBnClickedJoinNow(),
/// CSplitDialog's SplitAtPhraseBoxLocation_Interactive() and
/// SplitIntoChapters_Interactive().
/// Updates sequence numbers and the various indices including: m_curIndex, m_beginIndex,
/// m_endIndex, m_lowerIndex, and m_upperIndex to ensure they are within proper ranges.
/// Calls the View's Jump() on the current source phrase to effect any desired screen
/// update.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::CascadeSourcePhraseListChange(bool DoFullScreenUpdate)
{
	// refactored 22Mar09  -- all the index stuff is now unneeded, so just do the Jump
	CAdapt_ItView *v = GetView();
	CAdapt_ItDoc *d = GetDocument();
	d->UpdateSequNumbers(0);

    // The GetCurrentSourcePhrase() call below gets the one at the m_nActiveSequNum value,
    // so the only value which can be safely set here is to set it to zero
	m_nActiveSequNum = 0;

    // BEW added 13Aug09, in our refactored layout code, we can't just call Jump() here
    // because it would use the recalc layout call with parameter keep_strips_keep_piles
    // and that would involve hanging pointers and we'd get a crash. We therefore have to
    // do a call here with parameter create_strips_and_piles, for active sequ num = 0
    // location, and then the Jump() call to the actual location and the ensuing
	// RecaclLayout(), and then the Draw() won't fail in the CleanUpTheLayoutFromStripAt()
	// call
	gpApp->m_pLayout->RecalcLayout(gpApp->m_pSourcePhrases,create_strips_and_piles);
	gpApp->m_pActivePile = v->GetPile(m_nActiveSequNum);

	if (DoFullScreenUpdate) {
		v->Jump(this, GetCurrentSourcePhrase());
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a pointer to the source phrase found by index value
/// \param      Index   -> an int representing the index of the source phrase
///                        in m_pSourcePhrases
/// \remarks
/// Called from: the App's GetCurrentSourcePhrase() and SetCurrentSourcePhraseByIndex().
/// Gets a pointer to the source phrase instance at Index in m_pSourcePhrases. whm: Does
/// not do any error checking so it assumes that Index is a valid index into the list,
/// i.e., within the list.
/// Jonathan build this function, it does exactly the same as the
/// CAdapt_ItView::GetSourcePhrase(int nSequNum) function - but the latter checks pointer
/// validity in the debug build as well, Jonathan's doesn't
////////////////////////////////////////////////////////////////////////////////////////
CSourcePhrase *CAdapt_ItApp::GetSourcePhraseByIndex(int Index)
{
	// refactored 22Mar09 - no change needed
	SPList *ol = m_pSourcePhrases;
	SPList::Node* node = ol->Item(Index);
	return (CSourcePhrase*)node->GetData();
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return nothing
/// \param
///     Index ->    an int representing the index of the source phrase to Jump to
/// \remarks
/// Called from: CSplitDialog::SplitAtPhraseBoxLocation_Interactive().
/// Calls the View's Jump() method to jump to the source phrase instance at Index in
/// m_pSourcePhrases.
/// whm: *** TODO someday *** Does not do any error checking so it assumes that Index is a
/// valid index into the list, i.e., within the list.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetCurrentSourcePhraseByIndex(int Index)
{
	gbIsDocumentSplittingDialogActive = TRUE; // suppress source text copy if the
											  // box location is empty
	GetView()->Jump(this, GetSourcePhraseByIndex(Index));
	gbIsDocumentSplittingDialogActive = FALSE;
}

// additional getters, setters or helpers added by BEW on 03Nov05 or later

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if id is a valid book ID, otherwise FALSE
/// \param      id   -> the book ID being tested for validity
/// \remarks
/// Called from: the App's AppendSourcePhrasesToCurrentDoc() and GetBookIDFromDoc().
/// Determines if the string represented by id is a valid book ID contained in the
/// m_pBibleBooks list of pointers to BookNamePair structs. It is valid if it is the
/// same as a bookCode member in the list.
/// BEW 29Mar10, changed to accept lower, upper or mixed case for the book code
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::IsValidBookID(wxString& id)
{
	wxArrayPtrVoid* pBooks = this->m_pBibleBooks;
	int nArraySize = pBooks->GetCount();
	int index;
	bool bFoundIt = FALSE;
	wxString lowerId = id;
	lowerId.MakeLower(); // change only the local copy
	wxString lowerBookCode;
	for (index = 0; index < nArraySize; index++)
	{
		lowerBookCode = (((BookNamePair*)pBooks->Item(index))->bookCode);
		lowerBookCode.MakeLower(); // change only the local copy
		if (lowerId == lowerBookCode)
		{
			bFoundIt = TRUE;
			break;
		}
	}
	return bFoundIt != FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the document's book ID if present and if
///             valid, otherwise a null string
/// \remarks
/// Called from: the App's GetBookID() if the GetBookMode() call returns FALSE.
/// Looks as the first source phrase instance in the document (which should be the one to
/// have any "\id" marker in its m_markers member). If the \id marker exists, it examines
/// the next word of the \id line checking there for a valid 3-letter book ID name. If a
/// valid book ID is found it returns it, otherwise it returns a null string.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetBookIDFromDoc()
{
    // get BookIDFromDoc looks at the first CSourcePhrase instance in the document, which
    // should be one with a "\id " m_markers content, and its m_key member should store the
    // book ID we want. It is possible the source text file from which the doc was created
    // lacked an initial \id field, or if it had one, the book ID might contain a typo, so
    // we check for validity of the ID code and that it has a length of 3 (characters)
    // returning an empty string if invalid, no matter what the string may have been; or
    // returning the code if it is a valid one
	wxString id;
	id.Empty();
	SPList::Node* pos = m_pSourcePhrases->GetFirst();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase);
	if (pSrcPhrase->m_markers.Find(_T("\\id ")) == -1)
	{
		// there is no \id field
		return id;
	}
	id = pSrcPhrase->m_key;
	if (id.Length() != 3)
	{
		// string does not qualify for a valid ID because its length is not 3
		id.Empty();
		return id;
	}
	bool bIsValid = this->IsValidBookID(id);
	if (!bIsValid)
	{
		// it's not one of the IDs defined in the books.xml file
		id.Empty();
		return id;
	}
	return id;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the document's book ID if present and if valid,
///             otherwise a null string
/// \remarks
/// Called from: CJoinDialog::InitDialog(), CSplitDialog's
/// SplitAtPhraseBoxLocation_Interactive() and DoSplitIntoChapters().
/// If GetBookMode() returns TRUE, this function calls
/// GetBookIndicatorStringForCurrentBookFolder(), otherwise it calls GetBookIdFromDoc().
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetBookID()
{
	wxString id;
	id = GetBookMode() ? this->GetBookIndicatorStringForCurrentBookFolder() : this->GetBookIDFromDoc();
	return id;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrasesList   <- pointer to the SPList of a document
/// \param      id                -> a wxString representing the book ID to be added
/// \remarks
/// Called from: CSplitDialog's SplitAtPhraseBoxLocation_Interactive() and
/// DoSplitIntoChapters().
/// Makes sure that the document has the correct \id entry at its beginning after a
/// document split operation. To effect this this function adds a pointer to a new source
/// phrase instance at the head of the pSrcPhrasesList, giving it an "\id " string in its
/// m_markers member. The id is in m_key and m_srcPhrase, and an appropriate navigation
/// text string is placed in m_inform by calling RedoNavigationText().
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::AddBookIDToDoc(SPList* pSrcPhrasesList, wxString id)
{
    // AddBookIDToDoc addes a pointer to a new pSrcPhrase instance at the head of the
    // pSrcPhrasesList which is passed in, giving it an "\id " string in m_markers, the id
    // in m_key and m_srcPhrase, and an appropriate navigation text string in m_inform --
    // this function is used within the Split functionality to ensure that what remains
    // when the doc is split still has the correct \id entry at its beginning
	CAdapt_ItDoc* pDoc = this->GetDocument();
	wxASSERT(!id.IsEmpty());
	CSourcePhrase* pSrcPhrase = new CSourcePhrase;
	pSrcPhrase->m_markers = _T("\\id ");
	pSrcPhrase->m_key = id;
	pSrcPhrase->m_srcPhrase = id;
	pSrcPhrase->m_curTextType = identification;

	// update the navigation text & relevant flags
	pSrcPhrase->m_inform = pDoc->RedoNavigationText(pSrcPhrase);
	pSrcPhrase->m_bSpecialText = TRUE;
	pSrcPhrase->m_bFirstOfType = TRUE;

	// insert this instance at the start of the document
	SPList::Node* pos = pSrcPhrasesList->GetFirst();
	pos = pSrcPhrasesList->Insert(pos,pSrcPhrase);
	//pDoc->CreatePartnerPile(pSrcPhrase); // makes no sense, remove it (BEW 13Aug09)
										   // bug discovered by Kent Schroeder
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      project   -> the project name in the form of "srcName to tgtName
///                          Adaptations"
/// \param      srcName   <- a wxString that receives the source name of the project name
/// \param      tgtName   <- a wxString that receives the target name of the project name
/// \remarks
/// Called from: the Doc's RestoreDocParamsOnInput(), AiProjectCollabStatus() and OnFilePackDoc().
/// GetSrcAndTgtLanguageNamesFromProjectName takes the current project name as stored in
/// the app's m_curProjectName member, and extracts from it the source and target language
/// names (these may not actaully be language names, they are potentially arbitrary text
/// strings). The project name is in the form "srcName to tgtName Adaptations" where
/// srcName and tgtName represent the strings that we want to get. We use this in the
/// document's RestoreDocParamsOnInput() function, so we can check whether we are restoring
/// a document from the currently open project or not; it will be so if these extracted
/// names match the m_sourceName and m_targetName values on the app class as determined by
/// RestoreDocParamsOnInput() from the information stored within the document file itself
/// (whether XML or binary). This is necessary in order for the latter function to restore
/// the correct settings for the book mode (whether on or off) and book index whether (a
/// positive value or -1), since we can have opened the document either via the Start
/// Working wizard, or the MRU list, and these two options give different results - the
/// former opens only within a known project, the latter opens any document of any project.
/// For additional extended comments, see the comments within RestoreDocParamsOnInput()
/// itself.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::GetSrcAndTgtLanguageNamesFromProjectName(wxString& project,
													wxString& srcName, wxString& tgtName)
{
	if (project.IsEmpty())
	{
		srcName.Empty();
		tgtName.Empty();
		return;
	}
	// whm: For localization purposes the " to " and " adaptations" strings should not be
	// translated, otherwise other localizations would not be able to handle the unpacking
	// of files created on different localizations.
	int curPos = project.Find(_T(" to "));
	srcName = project.Left(curPos);
	curPos += 4; // where we think the target name starts
	int curPos2 = FindFromPos(project,_T(" adaptations"),curPos); // find the end of
																  // the target name
	int count = curPos2 - curPos;
	wxASSERT(count > 0);
	tgtName = project.Mid(curPos,count);
}

// Helper function
////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      font   -> pointer to the font from which the attributes are taken
/// \param      fInfo  <- the fontInfo struct whose members get updated
/// \remarks
/// Called from: the App's InitializeFonts(), CFontPageWiz's OnWizardPageChanging() when
/// moving forward, and CFontPagePrefs::OnOK().
/// Queries the font for its characteristics and stores the appropriate values in the
/// fontInfo struct. The attributes that are stored are the font's point size (fHeight),
/// weight (fWeight), style (fItalic), underlined (fUnderline), encoding (fEncoding),
/// charset (mapped from wx values), family (bit mapped to fPitchAndFamily) and face name
/// (fFaceName).
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::UpdateFontInfoStruct(wxFont* font, fontInfo& fInfo)
{
    // This helper function is used to set the fontInfo struct members (fPointSize,
    // fWeight, etc). When the user changes the font or font characteristic from within the
    // program this function will get called to update the fontInfo structs which are used
    // to update the font info values in the config files. This function will become
    // deprecated if/when the wxWidgets version does away entirely with fontInfo structs.
	fInfo.fHeight = PointSizeToNegHeight(font->GetPointSize());
	//fInfo.fWidth = 0; // font width ignored in wxWidgets, so leave current value
	//fInfo.fEscapement = 0; // escapement ignored in wxWidgets, so leave current value
	//fInfo.fOrientation = 0; // orientation ignored in wxWidgets, so leave current value
	switch(font->GetWeight())
	{
		case wxLIGHT:
			fInfo.fWeight = 400;
			fInfo.fWeightConfSave = 400;
			break; // same as normal
		case wxNORMAL:
			fInfo.fWeight = 400;
			fInfo.fWeightConfSave = 400;
			break;
		case wxBOLD:
			fInfo.fWeight = 700;
			fInfo.fWeightConfSave = 700;
			break;
		default:
			fInfo.fWeight = 700;
			fInfo.fWeightConfSave = 700;
	}
	if (font->GetStyle() == wxNORMAL)
        fInfo.fItalic = 0;
	else if (font->GetStyle() == wxITALIC || font->GetStyle() == wxSLANT)
        fInfo.fItalic = 1;
	if (font->GetUnderlined())
        fInfo.fUnderline = 1;
	else
        fInfo.fUnderline = 0;
	//fInfo.fStrikeOut = 0; // strikeout ignored in wxWidgets, so leave current value
	// Note: wxWidgets does use wxFontEncoding which can be retrieved with GetEncoding()
	fInfo.fEncoding = font->GetEncoding();
	fInfo.fCharset = MapWXFontEncodingToMFCCharset(fInfo.fEncoding); // the wx encodings
											// that MFC doesn't know about map to 0 (zero)
	//fInfo.fOutPrecision = 1; // outprecision ignored in wxWidgets, so leave current value
	//fInfo.fClipPrecision = 2; // clipprecision ignored in wxWidgets, so leave current value
	//fInfo.fQuality = 2; // quality ignored in wxWidgets, so leave current value
	switch(font->GetFamily())
	{
		case wxROMAN: fInfo.fFamily = 1; break;     //1 = FF_ROMAN (MFC)
		case wxSWISS: fInfo.fFamily = 2; break;     //2 = FF_SWISS (MFC)
		case wxMODERN: fInfo.fFamily = 3; break;    //3 = FF_MODERN (MFC)
		case wxSCRIPT: fInfo.fFamily = 4; break;    //4 = FF_SCRIPT (MFC)
		case wxDECORATIVE: fInfo.fFamily = 5; break;//5 = FF_DECORATIVE (MFC)
		case wxDEFAULT: fInfo.fFamily = 0; break;   //0 = FF_DONTCAR (MFC)
		default: fInfo.fFamily = 0;
	}
	// wxWidgets is only interested in the family which is encoded in bits 4-7
	// of the fPitchAndFamily value. The Pitch is encoded in the two lower order
	// bits of fPitchAndFamily (bits 1 and 2), and can be (MFC) DEFAULT_PITCH,
	// FIXED_PITCH, or VARIABLE_PITCH. MFC defines determine these to be:
	// #define DEFAULT_PITCH 0
	// #define FIXED_PITCH 1
	// #define VARIABLE_PITCH 2
	// According to the MFC docs "The proper value can be obtained by using the
	// Boolean OR operator to join one pitch constant with one family constant."
	// wxFont does not track font pitch, so we'll assume a default pitch (0)
	// then we should be able to get the fPitchAndFamily by shifting the fFamily
	// value 3 bits to the left.
	fInfo.fPitchAndFamily = fInfo.fFamily << 4;
	fInfo.fFaceName = font->GetFaceName();
}

// helper function
////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing the calculated optimal height for a dialog's
///             text control
/// \param      pointSize  -> an int representing the font point size
/// \remarks
/// Called from: (currently unused)
/// Calculates an estimated optimal value for the height of a text crontrol by applying a
/// ratio to the dialog font's point size.
////////////////////////////////////////////////////////////////////////////////////////
int	 CAdapt_ItApp::GetOptimumDlgEditBoxHeight(int pointSize)
{
	// For 12pt font the default height of a text ctrl is about 20 pixels.
	// With the following ratio a 24pt font would need a text ctrl with
	// height of about 40 pixels.
	int intTemp = (int)(22.0 + ((float)pointSize - MIN_DLG_FONT_SIZE)*1.667);
	return intTemp;
}

// helper function
////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing the font size constrained to the defined limits
/// \param      pointSize  -> an int representing the font point size
/// \remarks
/// Called from: (currently unused)
/// Limits a text control's font size to the range specified by MIN_DLG_FONT_SIZE and
/// MAX_DLG_FONT_SIZE.
////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::GetOptimumDlgFontSize(int pointSize)
{
	// Limit Optimum dialog text edit box font size to
	// between MIN_DLG_FONT_SIZE (11 points) and
	// MAX_DLG_FONT_SIZE (24 points)
	int ps = pointSize;
	if (ps < MIN_DLG_FONT_SIZE)
		ps = MIN_DLG_FONT_SIZE;
	if (ps > MAX_DLG_FONT_SIZE)
		ps = MAX_DLG_FONT_SIZE;
	return ps;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the path of the currently executing program
///                 or an empty/null string if the path could not be determined
/// \param      argv0  -> a wxString representing the system's argv[0] parameter (to Main)
/// \param      cwd    -> a wxString representing the current working directory (value
///                       returned by wxGetCwd)
/// \param      appVariableName  -> an (optional) application environment variable name
/// \remarks
/// Called from: the App's OnInit().
/// Gets an absolute path for the currently executing program, or a null string if the path
/// could not be determined. This function also stores the argv0 parameter in the App's
/// m_executingAppPathName member.
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::FindAppPath(const wxString& argv0, const wxString& cwd,
										const wxString& appVariableName)
{
	// whm added 5Jan04 FindAppPath() from suggestion by Julian Smart in wxWidgets
	// docs re "Writing installers for wxWidgets applications"
    wxString str;

    // Try appVariableName
    if (!appVariableName.IsEmpty())
    {
        str = wxGetenv(appVariableName);
        if (!str.IsEmpty())
            return str;
    }

#if defined(__WXMAC__) && !defined(__DARWIN__)
    // On Mac, the current directory is the relevant one when
    // the application starts.
    return cwd;
#endif

	// whm added 31July06 to store the path and file name of the executing app
	m_executingAppPathName = argv0;

    if (wxIsAbsolutePath(argv0))
        return wxPathOnly(argv0);
    else
    {
        // Is it a relative path?
        wxString currentDir(cwd);
        if (currentDir.Last() != wxFILE_SEP_PATH)
            currentDir += wxFILE_SEP_PATH;

        str = currentDir + argv0;
        if (wxFileExists(str))
            return wxPathOnly(str);
    }

    // OK, it's neither an absolute path nor a relative path.
    // Search PATH.

    wxPathList pathList;
    pathList.AddEnvList(wxT("PATH"));
    str = pathList.FindAbsoluteValidPath(argv0);
    if (!str.IsEmpty())
        return wxPathOnly(str);

    // Failed
    return wxEmptyString;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxMemorySize giving the number of bytes of free memory
/// \remarks
/// Called from the App's OnInit() and CEmailReportDlg::FormatSysInfoIntoString().
/// On Windows and Linux uses the wxWidgets function wxGetFreeMemory but on Macintosh uses
/// Mac OS X APIs to determine the free memory (this code was put into helpers.cpp to
/// avoid header problems with __BEGIN_DECLS inside the class CAdapt_ItApp.
////////////////////////////////////////////////////////////////////////////////////////

wxMemorySize CAdapt_ItApp::GetFreeMemory(void)
{
#ifdef __WXMSW__
	return ::wxGetFreeMemory();
#elif defined(__WXGTK__)
	return ::wxGetFreeMemory();
#elif defined(__WXMAC__)
	return MacGetFreeMemory();
#endif
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the file name with any .xml extension removed
/// \param      anyName   -> a wxString representing a file name
/// \remarks
/// Called from: the Doc's SetDocumentWindowTitle(), and
/// CMoveDialog::OnBnClickedButtonRenameDoc().
/// Removes any .xml extension occurring at the end of anyName and returns the result.
/// BEw changed 23Aug10, because we'll want to use this to remove extensions like ".txt"
/// too, not just ".xml", and we'll want it to handle extensions which may be more than 3
/// characters or less than three, so following Bill's comment, I've recoded it to use
/// wxFileName
////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::MakeExtensionlessName(wxString anyName)
{
	// whm Note: this could be done more efficiently using wxFileName
	wxFileName fn(anyName);
	wxString name = fn.GetName();
	/* legacy code
	wxString name = anyName;
	wxString extn;
	name = MakeReverse(name);
	// beware, there could be . in the name which is not for an extension
	int nFound = name.Find(_T('.'));
	if (nFound >= 0)
	{
		// there may be an extension to be removed
		extn = name.Left(nFound); // a potential extension
		int len = extn.Length();
		if (len == 3)
		{
			// it could be an extension, so check further
			extn = MakeReverse(extn);
			extn.MakeLower();
			if (extn == _T("xml"))
			{
				// it's one of ours, so remove it and the .
				name = name.Mid(nFound + 1);
			}
		}
	}
	name = MakeReverse(name);
	*/
	return name;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pFont      -> a pointer to the font from which its base properties are
///                           copied in setting pDlgFont
/// \param      pointsize  -> the pointsize (+ve number) for the text to be displayed in
///                           the control
/// \param      pStatTxt   <- a pointer to the wxStaticText control whose font is to be set
/// \param      pDlgFont   <- the dialog font being adjusted for use in the control
/// \param      bIsRTL     -> TRUE if the control is Right-to-Left (RTL), FALSE if the
///                           control is Left-to-Right (LTR)
/// \remarks
/// Called from: The InitDialog() methods of most of the application's dialogs that use
/// a wxStatText that needs to be a different size, use src or tgt font characteristics,
/// and or a non-standard point size.
/// Used in dialogs for Consistency Check feature
/// BEW created 2Sep11, tweaked the code from SetFontAndDirectionalityForDialogControl()
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetFontAndDirectionalityForStatText(wxFont* pFont, int pointsize,
								wxStaticText* pStatTxt, wxFont*& pDlgFont, bool bIsRTL)
{
	wxASSERT(pFont != NULL);
	wxASSERT(pDlgFont != NULL);
	CopyFontBaseProperties(pFont,pDlgFont);
	// The CopyFontBaseProperties function above doesn't copy the point size, so
	// make the dialog font show the wanted font size.
	pDlgFont->SetPointSize(pointsize);
	if (pStatTxt != NULL)
		pStatTxt->SetFont(*pDlgFont);

	bIsRTL = bIsRTL; // suppresses "unreferenced formal parameter" warning in ANSI version
	// add RTL support for Unicode version
#ifdef _RTL_FLAGS
	if (pStatTxt != NULL)
	{
		if (bIsRTL)
		{
			pStatTxt->SetLayoutDirection(wxLayout_RightToLeft);
		}
		else
		{
			pStatTxt->SetLayoutDirection(wxLayout_LeftToRight);
		}
	}
#endif
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pFont      -> a pointer to the font from which its base properties are
///                           copied in setting the pDlgFont
/// \param      pEdit1     <- a pointer to the first text control whose font that can
///                           be set
/// \param      pEdit2     <- a pointer to the second text control whose font that can
///                           be set
/// \param      pListBox1  <- a pointer to the first list box control whose font that can
///                           be set
/// \param      pListBox2  <- a pointer to the second list box control whose font that can
///                           be set
/// \param      pDlgFont   <- the dialog font being adjusted for use in the above
///                           dialog controls
/// \param      bIsRTL     -> TRUE if the control is Right-to-Left (RTL), FALSE if the
///                           control is Left-to-Right (LTR)
/// \remarks
/// Called from: The InitDialog() methods of most of the application's dialogs that use
/// source or target language text within text controls or list boxes.
/// SetFontAndDirectionalityForDialogControl sets the dialog's font and script
/// directionality for up two two edit boxes and/or two list boxes at a time -- the pFont
/// pointer passed in is used for each. To set a mixture of such controls to different
/// fonts and directionalities, according to the app's settings for source, target and
/// navigation text fonts, repeat the calls with varying font pointers. The desired
/// directionality is specified by the bIsRTL, which should be TRUE when right to left
/// reading text is wanted (and right justification), default is FALSE for left to right.
/// Use NULL for any control which is to be ignored, but the font pointer must never be
/// NULL.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetFontAndDirectionalityForDialogControl(wxFont* pFont, wxTextCtrl* pEdit1,
					wxTextCtrl* pEdit2, wxListBox* pListBox1, wxListBox* pListBox2,
					wxFont*& pDlgFont, bool bIsRTL)
{
    // whm Note: The MFC function deletes any existing dialog font that is passed in; then
    // creates the dialog font anew by first getting the pFont's LOGFONT data (stored in
    // navLF), and using that log font data calls CreateFontIndirect(&navLF) to create a
    // new pDlgFont. If the attempt to get the log font data from pFont fails, it creates a
    // new pApp->m_pNavTextFont using a Windows SYSTEM_FONT, then uses that font at 12
    // point size as input to SetFont for the edit and/or listbox controls' font. The WX
    // version does not need to delete the existing dialog font and recreate it for the
    // dialog. Instead, the wx version simply assigns the pFont characteristics to the
    // dialog font pDlgFont, but sets its size to pApp->m_dialogFontSize.
	wxASSERT(pFont != NULL);
	wxASSERT(pDlgFont != NULL);
	CopyFontBaseProperties(pFont,pDlgFont);
	// The CopyFontBaseProperties function above doesn't copy the point size, so
	// make the dialog font show in the proper dialog font size.
	pDlgFont->SetPointSize(m_dialogFontSize);
	if (pEdit1 != NULL)
		pEdit1->SetFont(*pDlgFont);
	if (pEdit2 != NULL)
		pEdit2->SetFont(*pDlgFont);
	if (pListBox1 != NULL)
		pListBox1->SetFont(*pDlgFont);
	if (pListBox2 != NULL)
		pListBox2->SetFont(*pDlgFont);

	bIsRTL = bIsRTL; // suppresses "unreferenced formal parameter" warning in ANSI version
	// add RTL support for Unicode version
#ifdef _RTL_FLAGS
	if (pEdit1 != NULL)
	{
		if (bIsRTL)
		{
			pEdit1->SetLayoutDirection(wxLayout_RightToLeft);
		}
		else
		{
			pEdit1->SetLayoutDirection(wxLayout_LeftToRight);
		}
	}
	if (pEdit2 != NULL)
	{
		if (bIsRTL)
		{
			pEdit2->SetLayoutDirection(wxLayout_RightToLeft);
		}
		else
		{
			pEdit2->SetLayoutDirection(wxLayout_LeftToRight);
		}
	}
	if (pListBox1 != NULL)
	{
        // whm modified 8Jul09 to always use wxLayout_LeftToRight for list boxes, since we
        // probably don't want the list item right justified and the scroll bar mirrored on
        // the left side, since the main window is not similarly mirrored.
        //
        //if (bIsRTL)
        //{
        // pListBox1->SetLayoutDirection(wxLayout_RightToLeft);
        //}
        //else
        //{
			pListBox1->SetLayoutDirection(wxLayout_LeftToRight);
		//}
	}
	if (pListBox2 != NULL)
	{
        // whm modified 8Jul09 to always use wxLayout_LeftToRight for list boxes, since we
        // probably don't want the list item right justified and the scroll bar mirrored on
        // the left side, since the main window is not similarly mirrored.
        //
		//if (bIsRTL)
		//{
		// pListBox2->SetLayoutDirection(wxLayout_RightToLeft);
		//}
		//else
		//{
			pListBox2->SetLayoutDirection(wxLayout_LeftToRight);
		//}
	}
	#endif
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pFont      -> a pointer to the font from which its base properties are
///                           copied in setting the pDlgFont
/// \param      pCombo     <- a pointer to the wxComboBox for which we wish to set the font
/// \param      pDlgFont   <- the dialog font being adjusted for use in the above
///                           combobox
/// \param      bIsRTL     -> TRUE if the control is Right-to-Left (RTL), FALSE if the
///                           control is Left-to-Right (LTR)
/// \remarks
/// Called from: The InitDialog() methods of most of the application's dialogs that use a
/// combobox control. SetFontAndDirectionalityForDialogControl sets the dialog's font and
/// script directionality for a single wxComboBox -- the pFont pointer passed in is used.
/// To set a mixture of such controls to different fonts and directionalities, according to
/// the app's settings for source, target and navigation text fonts, repeat the calls with
/// varying font pointers. The desired directionality is specified by the bIsRTL, which
/// should be TRUE when right to left reading text is wanted (and right justification),
/// default is FALSE for left to right.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::SetFontAndDirectionalityForComboBox(wxFont* pFont, wxComboBox* pCombo,
				wxFont*& pDlgFont, bool bIsRTL)
{
    // whm Note: The MFC function deletes any existing dialog font that is passed in; then
    // creates the dialog font anew by first getting the pFont's LOGFONT data (stored in
    // navLF), and using that log font data calls CreateFontIndirect(&navLF) to create a
    // new pDlgFont. If the attempt to get the log font data from pFont fails, it creates a
    // new pApp->m_pNavTextFont using a Windows SYSTEM_FONT, then uses that font at 12
    // point size as input to SetFont for the edit and/or listbox controls' font. The WX
    // version does not need to delete the existing dialog font and recreate it for the
    // dialog. Instead, the wx version simply assigns the pFont characteristics to the
    // dialog font pDlgFont, but sets its size to pApp->m_dialogFontSize.
	wxASSERT(pFont != NULL);
	wxASSERT(pDlgFont != NULL);
	CopyFontBaseProperties(pFont,pDlgFont);
	// The CopyFontBaseProperties function above doesn't copy the point size, so
	// make the dialog font show in the proper dialog font size.
	pDlgFont->SetPointSize(m_dialogFontSize);
	if (pCombo != NULL)
		pCombo->SetFont(*pDlgFont);

	bIsRTL = bIsRTL; // suppresses "unreferenced formal parameter" warning in ANSI version
	// add RTL support for Unicode version
#ifdef _RTL_FLAGS
	if (pCombo != NULL)
	{
		if (bIsRTL)
		{
			pCombo->SetLayoutDirection(wxLayout_RightToLeft);
		}
		else
		{
			pCombo->SetLayoutDirection(wxLayout_LeftToRight);
		}
	}
	#endif
}


////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing the index into the array where findStr was found,
///             otherwise -1 if the string was not found.
/// \param      findStr   -> a wxString representing the (exact) string being searched for
/// \param      strArray  <- a pointer to the wxArrayString being searched
/// \remarks
/// Called from: CExportOptionsDlg's OnBnClickedRadioExportSelectedMarkers(),
/// OnLbnSelchangeListSfms(), OnCheckListBoxToggle(),
/// OnBnClickedButtonFilterOutFromExport(), OnBnClickedButtonIncludeInExport(),
/// OnBnClickedButtonUndo(), DoBoxClickedIncludeOrFilterOutDoc() and
/// DoBoxClickedIncludeOrFilterOutProj().
/// This function does a brute force linear search through strArray looking for findStr. If
/// found (array element == findStr exactly) it returns the found element's index in the
/// array, otherwise it returns -1.
////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::FindArrayString(const wxString& findStr, wxArrayString* strArray)
{
	int ct;
	for (ct = 0; ct < (int)strArray->GetCount(); ct++)
	{
		if (strArray->Item(ct) == findStr)
		{
			return ct;
		}
	}
	return -1;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing the index of the list box item if found, otherwise -1
/// \param      pListBox         -> a pointer to the list box being searched
/// \param      searchStr        <- a wxString representing the string being searched for
/// \param      searchCaseType   -> a SearchCaseType which can be caseSensitive or
///                                 caseInsensitive
/// \param      searchStrLenType <- a SearchStrLengthType which can be subString or
///                                 exactString
/// \remarks
/// Called from: CChooseTranslation's OnButtonMoveUp(), OnButtonMoveDown(),
/// OnSelchangeListboxTranslations(), OnDblclkListboxTranslations(), OnButtonRemove(),
/// InitDialog(), CConsistencyCheckDlg::InitDialog(),
/// CFilterPageCommon::LoadListBoxFromArrays(), CKBEditor's OnSelchangeListSrcKeys(),
/// OnSelchangeListExistingTranslations(), OnUpdateEditSrcKey(), OnButtonUpdate(),
/// OnAddNoAdaptation(), OnButtonAdd(), OnButtonRemove(),
/// OnButtonMoveUp(),OnButtonMoveDown(), and LoadDataForPage().
/// Finds the index of an item in pListBox that matches the searchStr and the case and
/// and/or substring type. Returns the index of the item if found, or -1 if not found. This
/// function adds more search options and search criteria than what is available in the
/// standard wxListBox which can do case sensitive or insensitive searches but cannot do
/// substring searches with its FindString() method. Care needs to be taken when using
/// functions like FindListBoxItem on list boxes that may contain hundreds or thousands of
/// items. Since the find operation is a simple brute force search through each item, the
/// time taken can be considerable for list boxes that may contain very large numbers of
/// items.
////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::FindListBoxItem(wxListBox* pListBox, wxString searchStr,
		enum SearchCaseType searchCaseType, enum SearchStrLengthType searchStrLenType)
{
    // FindListBoxItem searches for searchStr in pListBox and returns the zero-based index
    // of a found item, or -1 if not found. If searchType is caseSensitive, it will return
    // the index of the first exact (case sensitive) match found; if searchCaseType is
    // caseInsensitive, it will return the index of the first match found that may differ
    // in case; if searchStrLenType is subString, it will return the index of the first
    // item with a matching substring.
	int ct;
	//bool bFound = FALSE;
	wxString caseKeyStr = searchStr;
	if (searchCaseType == caseInsensitive)
		caseKeyStr.UpperCase();
	wxString srcStr;
	for (ct = 0; ct < (int)pListBox->GetCount(); ct++)
	{
		srcStr = pListBox->GetString(ct);
		if (searchCaseType == caseInsensitive)
			srcStr.UpperCase();
		if (searchStrLenType == subString)
		{
            // If needed we could here further modify FindListBoxItem to allow for a
            // substring at any location in the string, not just initially It would require
            // an additional enum parameter SubStrType {initialOnly, anywhere}
			if (srcStr.Find(caseKeyStr) == 0)
			{
				// we found an item whose beginning chars match
				//bFound = TRUE;
				return ct;
			}
		}
		else
		{
			// searchStrLenType == exactString
			if (srcStr == caseKeyStr)
			{
				// we found an item whose chars match exactly
				//bFound = TRUE;
				return ct;
			}
		}
	}
	return -1;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing the index of the list box item if found, otherwise -1
/// \param      pListBox         -> a pointer to the list box being searched
/// \param      searchStr        <- a wxString representing the string being searched for
/// \param      searchCaseType   -> a SearchCaseType which can be caseSensitive or
///                                 caseInsensitive
/// \param      searchStrLenType <- a SearchStrLengthType which can be subString or
///                                 exactString
/// \param      startFromType    -> a StartFromType which can be fromFirstListPos,
///                                 fromCurrentSelPosToListEnd,
///                                 or fromCurrentSelPosCyclingBack
/// \remarks
/// Called from: CMyListBox::OnSysKeyUp(wxKeyEvent& event).
/// This function is an override of the function of the same name but has a startFromType
/// parameter added to the function signature to further indicate the scope of a list box
/// search for an item. Hence, this function enables searches for successive list items
/// that match the list criteria. It is designed to emulate for wxGTK and wxMAC the list
/// box behavior that exists in wxMSW and wxMac native list boxes. As such it would
/// ordinarily be called from within a #if defined(__WXGTK__) && defined(_UNICODE)
/// conditional compilation block. Finds the index of an item in pListBox that matches the
/// searchStr and the case and and/or substring type. Returns the index of the item if
/// found, or -1 if not found. This function adds more search options and search criteria
/// than what is available in the standard wxListBox which can do case sensitive or
/// insensitive searches but cannot do substring searches with its FindString() method. In
/// this function, if the startFromType is fromCurrentSelPosToListEnd, it will start
/// searching using parameter search criteria from the current selection + 1 to the end of
/// the list, and will return an index number if an item is found, or -1 (not found) if the
/// searchStr could not be found according to the other parameter criteria. If the
/// startFromType is fromCurrentSelPosCyclingBack, it will start searching as per the
/// fromCurrentSelPosToListEnd, but if it reaches the end of the list and has not found an
/// item matching search criteria, it will cycle back and search also from the top of the
/// list to the current selection. Care needs to be taken when using functions like
/// FindListBoxItem on list boxes that may contain hundreds or thousands of items. Since
/// the find operation is a simple brute force search through each item, the time taken can
/// be considerable for list boxes that may contain very large numbers of items.
////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::FindListBoxItem(wxListBox* pListBox, wxString searchStr,
		enum SearchCaseType searchCaseType, enum SearchStrLengthType searchStrLenType,
		enum StartFromType startFromType)
{
    // FindListBoxItem searches for searchStr in pListBox and returns the zero-based index
    // of a found item, or -1 if not found. If searchType is caseSensitive, it will return
    // the index of the first exact (case sensitive) match found; if searchCaseType is
    // caseInsensitive, it will return the index of the first match found that may differ
    // in case; if searchStrLenType is subString, it will return the index of the first
    // item with a matching substring; if startFromType is currentSelPos, it will only
    // search for list items below the currently selected item in the list, or if none are
    // found below the item, but an item is found preceding the currently selected item, it
    // will cycle to that item.
	int ct, nStartIndex, nEndIndex, nCurrSel, nTotLBItems;
	bool bFound = FALSE;
	wxString caseKeyStr = searchStr;
	nCurrSel = pListBox->GetSelection();
	nTotLBItems = (int)pListBox->GetCount();
	if (searchCaseType == caseInsensitive)
		caseKeyStr.UpperCase();
	nStartIndex = 0; // the default starting point case which is fromFirstListPos
	nEndIndex = nTotLBItems - 1; // the default ending point is index of
								 // last item in list

	// handle the special cases where starting index is from current
	// selection index
	if (startFromType == fromCurrentSelPosToListEnd ||
		startFromType == fromCurrentSelPosCyclingBack)
	{
		// Set starting index at next index below the current selection position.
		nStartIndex = nCurrSel + 1; // start searching with next item below
									// current selection
		// But first do some sanity checks.
		if (nCurrSel == -1 || nStartIndex >= nTotLBItems)
		{
			// no valid selection is current so cannot search
			return -1;
		}
	}
	// Search from starting index through end of list
	wxString srcStr;
	for (ct = nStartIndex; ct <= nEndIndex; ct++) // use <= here
	{
		srcStr = pListBox->GetString(ct);
		if (searchCaseType == caseInsensitive)
			srcStr.UpperCase();
		if (searchStrLenType == subString)
		{
            // If needed we could here further modify FindListBoxItem to allow for a
            // substring at any location in the string, not just initially It would require
            // an additional enum parameter SubStrType {initialOnly, anywhere}
			if (srcStr.Find(caseKeyStr) == 0)
			{
				// we found an item whose beginning chars match
				bFound = TRUE;
				return ct;
			}
		}
		else
		{
			// searchStrLenType == exactString
			if (srcStr == caseKeyStr)
			{
				// we found an item whose chars match exactly
				bFound = TRUE;
				return ct;
			}
		}
	}
	// For the possible cycle back bFound == FALSE case, search again from index 0 to
	// current selection
	if (startFromType == fromCurrentSelPosCyclingBack && bFound == FALSE)
	{
		nStartIndex = 0; // the default starting point case which is fromFirstListPos
		nEndIndex = nCurrSel; // the default ending point is index of last item in list
		wxString srcStr;
		for (ct = nStartIndex; ct <= nEndIndex; ct++) // use <= here
		{
			srcStr = pListBox->GetString(ct);
			if (searchCaseType == caseInsensitive)
				srcStr.UpperCase();
			if (searchStrLenType == subString)
			{
                // If needed we could here further modify FindListBoxItem to allow for a
                // substring at any location in the string, not just initially It would
                // require an additional enum parameter SubStrType {initialOnly, anywhere}
				if (srcStr.Find(caseKeyStr) == 0)
				{
					// we found an item whose beginning chars match
					bFound = TRUE;
					return ct;
				}
			}
			else
			{
				// searchStrLenType == exactString
				if (srcStr == caseKeyStr)
				{
					// we found an item whose chars match exactly
					bFound = TRUE;
					return ct;
				}
			}
		}
	}
	return -1;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     an int representing an MFC paper size code value equivalent to the
///             wxPaperSize id
/// \param      id   -> the wxPaperSize id to be mapped to an MFC value
/// \remarks
/// Called from: the App's OnFilePageSetup().
/// Maps a wxPaperSize value to the equivalent MFC paper size value.
////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItApp::MapWXtoMFCPaperSizeCode(wxPaperSize id)
{
	switch(id)
	{
	case wxPAPER_NONE: return 9;	//	0       // Use specific dimensions
	case wxPAPER_LETTER: return 1;  // Letter, 8 1/2 by 11 inches
	case wxPAPER_LEGAL: return 5;  // Legal, 8 1/2 by 14 inches
    case wxPAPER_A4: return 9;  // A4 Sheet, 210 by 297 millimeters
    case wxPAPER_CSHEET: return 24; // C Sheet, 17 by 22 inches
    case wxPAPER_DSHEET: return 25; // D Sheet, 22 by 34 inches
    case wxPAPER_ESHEET: return 26; // E Sheet, 34 by 44 inches
    case wxPAPER_LETTERSMALL: return 2;  // Letter Small, 8 1/2 by 11 inches
    case wxPAPER_TABLOID: return 3;  // Tabloid, 11 by 17 inches
    case wxPAPER_LEDGER: return 4;  // Ledger, 17 by 11 inches
    case wxPAPER_STATEMENT: return 6;  // Statement, 5 1/2 by 8 1/2 inches
    case wxPAPER_EXECUTIVE: return 7;  // Executive, 7 1/4 by 10 1/2 inches
    case wxPAPER_A3: return 8;  // A3 sheet, 297 by 420 millimeters
    case wxPAPER_A4SMALL: return 9; // A4 small sheet, 210 by 297 millimeters // whm changed from return 10 to return 9
    case wxPAPER_A5: return 11; // A5 sheet, 148 by 210 millimeters
    case wxPAPER_B4: return 12; // B4 sheet, 250 by 354 millimeters
    case wxPAPER_B5: return 13; // B5 sheet, 182-by-257-millimeter paper
    case wxPAPER_FOLIO: return 14; // Folio, 8-1/2-by-13-inch paper
    case wxPAPER_QUARTO: return 15; // Quarto, 215-by-275-millimeter paper
    case wxPAPER_10X14: return 16; // 10-by-14-inch sheet
    case wxPAPER_11X17: return 17; // 11-by-17-inch sheet
    // For some unknown reason, selecting "LETTER" in a Windows Page Setup dialog, the
    // return code is 18 wxPAPER_NOTE, which is the same size as wxPAPER_LETTER. I've
    // changed the return value for wxPAPER_NOTE to 1 (wxPAPER_LETTER) which should make
    // things work better.
    case wxPAPER_NOTE: return 1; // Note, 8 1/2 by 11 inches
    case wxPAPER_ENV_9: return 19; // #9 Envelope, 3 7/8 by 8 7/8 inches
    case wxPAPER_ENV_10: return 20; // #10 Envelope, 4 1/8 by 9 1/2 inches
    case wxPAPER_ENV_11: return 21; // #11 Envelope, 4 1/2 by 10 3/8 inches
    case wxPAPER_ENV_12: return 22; // #12 Envelope, 4 3/4 by 11 inches
    case wxPAPER_ENV_14: return 23; // #14 Envelope, 5 by 11 1/2 inches
    case wxPAPER_ENV_DL: return 27; // DL Envelope, 110 by 220 millimeters
    case wxPAPER_ENV_C5: return 28; // C5 Envelope, 162 by 229 millimeters
    case wxPAPER_ENV_C3: return 29; // C3 Envelope, 324 by 458 millimeters
    case wxPAPER_ENV_C4: return 30; // C4 Envelope, 229 by 324 millimeters
    case wxPAPER_ENV_C6: return 31; // C6 Envelope, 114 by 162 millimeters
    case wxPAPER_ENV_C65: return 32; // C65 Envelope, 114 by 229 millimeters
    case wxPAPER_ENV_B4: return 33; // B4 Envelope, 250 by 353 millimeters
    case wxPAPER_ENV_B5: return 34; // B5 Envelope, 176 by 250 millimeters
    case wxPAPER_ENV_B6: return 35; // B6 Envelope, 176 by 125 millimeters
    case wxPAPER_ENV_ITALY: return 36; // Italy Envelope, 110 by 230 millimeters
    case wxPAPER_ENV_MONARCH: return 37; // Monarch Envelope, 3 7/8 by 7 1/2 inches
    case wxPAPER_ENV_PERSONAL: return 38; // 6 3/4 Envelope, 3 5/8 by 6 1/2 inches
    case wxPAPER_FANFOLD_US: return 39; // US Std Fanfold, 14 7/8 by 11 inches
    case wxPAPER_FANFOLD_STD_GERMAN: return 40; // German Std Fanfold, 8 1/2 by 12 inches
    case wxPAPER_FANFOLD_LGL_GERMAN: return 41; // German Legal Fanfold, 8 1/2 by 13 inches
// Windows 95 only:
// whm: For the values below I've only estimated what seems correct
    case wxPAPER_ISO_B4: return 12; // B4 (ISO) 250 x 353 mm // whm: same as wxPAPER_B4
    case wxPAPER_JAPANESE_POSTCARD: return 11; // Japanese Postcard 100 x 148 mm // no equiv just map to wxPAPER_A5
    case wxPAPER_9X11: return 16; // 9 x 11 in // no equiv just map to wxPAPER_10X14
    case wxPAPER_10X11: return 16; // 10 x 11 in // no equiv just map to wxPAPER_10X14
    case wxPAPER_15X11: return 4;  // 15 x 11 in // no equiv just map to wxPAPER_LEDGER
    case wxPAPER_ENV_INVITE: return 1;  // Envelope Invite 220 x 220 mm // no equiv just map to wxPAPER_LETTER
    case wxPAPER_LETTER_EXTRA: return 1;  // Letter Extra 9 \275 x 12 in // no equiv just map to wxPAPER_LETTER
    case wxPAPER_LEGAL_EXTRA: return 5;  // Legal Extra 9 \275 x 15 in // no equiv just map to wxPAPER_LEGAL
    case wxPAPER_TABLOID_EXTRA: return 3;  // Tabloid Extra 11.69 x 18 in // no equiv just map to wxPAPER_TABLOID
    case wxPAPER_A4_EXTRA: return 9;  // A4 Extra 9.27 x 12.69 in // no equiv just map to wxPAPER_A4
    case wxPAPER_LETTER_TRANSVERSE: return 1;  // Letter Transverse 8 \275 x 11 in // no equiv just map to wxPAPER_LETTER
    case wxPAPER_A4_TRANSVERSE: return 9;  // A4 Transverse 210 x 297 mm // no equiv just map to wxPAPER_A4
    case wxPAPER_LETTER_EXTRA_TRANSVERSE: return 1;  // Letter Extra Transverse 9\275 x 12 in // no equiv just map to wxPAPER_LETTER
    case wxPAPER_A_PLUS: return 9;  // SuperA/SuperA/A4 227 x 356 mm // no equiv just map to wxPAPER_A4
    case wxPAPER_B_PLUS: return 8;  // SuperB/SuperB/A3 305 x 487 mm // no equiv just map to wxPAPER_A3
    case wxPAPER_LETTER_PLUS: return 1;  // Letter Plus 8.5 x 12.69 in // no equiv just map to wxPAPER_LETTER
    case wxPAPER_A4_PLUS: return 9;  // A4 Plus 210 x 330 mm // no equiv just map to wxPAPER_A4
    case wxPAPER_A5_TRANSVERSE: return 11; // A5 Transverse 148 x 210 mm // same size as wxPAPER_A5
    case wxPAPER_B5_TRANSVERSE: return 13; // B5 (JIS) Transverse 182 x 257 mm // no equiv just map to wxPAPER_B5
    case wxPAPER_A3_EXTRA: return 8;  // A3 Extra 322 x 445 mm  // no equiv just map to wxPAPER_A3
    case wxPAPER_A5_EXTRA: return 11; // A5 Extra 174 x 235 mm  // same size as wxPAPER_A5
    case wxPAPER_B5_EXTRA: return 13; // B5 (ISO) Extra 201 x 276 mm // no equiv just map to wxPAPER_B5
    case wxPAPER_A2: return 24; // A2 420 x 594 mm  // no equiv just map to wxPAPER_CSHEET
    case wxPAPER_A3_TRANSVERSE: return 8;  // A3 Transverse 297 x 420 mm // same size as wxPAPER_A3
    case wxPAPER_A3_EXTRA_TRANSVERSE: return 8;  // A3 Extra Transverse 322 x 445 mm  // no equiv just map to wxPAPER_A3
	default: return 9;
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxPaperSize value equivalent to the MFC paper size code
/// \param      id   -> an int representing the MFC paper size code to be mapped
/// \remarks
/// Called from: the App's OnInit() and OnFilePageSetup().
/// Maps an MFC paper size value to the equivalent wxWidgets' wxPaperSize value.
////////////////////////////////////////////////////////////////////////////////////////
wxPaperSize CAdapt_ItApp::MapMFCtoWXPaperSizeCode(int id)
{
	switch(id)
	{
	case 1: return wxPAPER_LETTER; //				  1 Letter, 8 1/2 by 11 inches
    case 2: return wxPAPER_LETTERSMALL; //	          2 Letter Small, 8 1/2 by 11 inches
    case 3: return wxPAPER_TABLOID; //		          3 Tabloid, 11 by 17 inches
    case 4: return wxPAPER_LEDGER; //				  4  Ledger, 17 by 11 inches
    case 5: return wxPAPER_LEGAL; //				  5 Legal, 8 1/2 by 14 inches
    case 6: return wxPAPER_STATEMENT; //			  6  Statement, 5 1/2 by 8 1/2 inches
    case 7: return wxPAPER_EXECUTIVE; //			  7  Executive, 7 1/4 by 10 1/2 inches
    case 8: return wxPAPER_A3; //					  8  A3 sheet, 297 by 420 millimeters
    case 9: return wxPAPER_A4; //					  9 A4 Sheet, 210 by 297 millimeters
    case 10: return wxPAPER_A4SMALL; //			     10 A4 small sheet, 210 by 297 millimeters
    case 11: return wxPAPER_A5; //					 11 A5 sheet, 148 by 210 millimeters
    case 12: return wxPAPER_B4; //					 12 B4 sheet, 250 by 354 millimeters
    case 13: return wxPAPER_B5; //					 13 B5 sheet, 182-by-257-millimeter paper
    case 14: return wxPAPER_FOLIO; //				 14 Folio, 8-1/2-by-13-inch paper
    case 15: return wxPAPER_QUARTO; //				 15 Quarto, 215-by-275-millimeter paper
    case 16: return wxPAPER_10X14; //				 16 10-by-14-inch sheet
    case 17: return wxPAPER_11X17; //				 17 11-by-17-inch sheet
    case 18: return wxPAPER_NOTE; //				 18 Note, 8 1/2 by 11 inches
    case 19: return wxPAPER_ENV_9; //				 19 #9 Envelope, 3 7/8 by 8 7/8 inches
    case 20: return wxPAPER_ENV_10; //				 20 #10 Envelope, 4 1/8 by 9 1/2 inches
    case 21: return wxPAPER_ENV_11; //				 21 #11 Envelope, 4 1/2 by 10 3/8 inches
    case 22: return wxPAPER_ENV_12; //				 22 #12 Envelope, 4 3/4 by 11 inches
    case 23: return wxPAPER_ENV_14; //				 23 #14 Envelope, 5 by 11 1/2 inches
    case 24: return wxPAPER_CSHEET; //				 24 C Sheet, 17 by 22 inches
    case 25: return wxPAPER_DSHEET; //				 25 D Sheet, 22 by 34 inches
    case 26: return wxPAPER_ESHEET; //				 26 E Sheet, 34 by 44 inches
    case 27: return wxPAPER_ENV_DL; //				 27 DL Envelope, 110 by 220 millimeters
    case 28: return wxPAPER_ENV_C5; //				 28 C5 Envelope, 162 by 229 millimeters
    case 29: return wxPAPER_ENV_C3; //				 29 C3 Envelope, 324 by 458 millimeters
    case 30: return wxPAPER_ENV_C4; //				 30 C4 Envelope, 229 by 324 millimeters
    case 31: return wxPAPER_ENV_C6; //				 31 C6 Envelope, 114 by 162 millimeters
    case 32: return wxPAPER_ENV_C65; //			     32 C65 Envelope, 114 by 229 millimeters
    case 33: return wxPAPER_ENV_B4; //				 33 B4 Envelope, 250 by 353 millimeters
    case 34: return wxPAPER_ENV_B5; //				 34 B5 Envelope, 176 by 250 millimeters
    case 35: return wxPAPER_ENV_B6; //				 35 B6 Envelope, 176 by 125 millimeters
    case 36: return wxPAPER_ENV_ITALY; //			 36 Italy Envelope, 110 by 230 millimeters
    case 37: return wxPAPER_ENV_MONARCH; //		     37 Monarch Envelope, 3 7/8 by 7 1/2 inches
    case 38: return wxPAPER_ENV_PERSONAL; //		 38 6 3/4 Envelope, 3 5/8 by 6 1/2 inches
    case 39: return wxPAPER_FANFOLD_US; //			 39 US Std Fanfold, 14 7/8 by 11 inches
    case 40: return wxPAPER_FANFOLD_STD_GERMAN; // 	 40 German Std Fanfold, 8 1/2 by 12 inches
    case 41: return wxPAPER_FANFOLD_LGL_GERMAN; // 	 41 German Legal Fanfold, 8 1/2 by 13 inches
// The Windows 95 only values don't map to any unique wxPaperSize
	default: return wxPAPER_A4;
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Set bRestoreView, which defaults to TRUE, to FALSE if using DoPrintCleanup to remove a
/// layout and pagination as an intermediate step in doing a real print job, and then the
/// view window won't be updated at this call
/// BEW 14Nov11, changed to reflect the fact that chapter/verse range printing will have
/// used deep copies of the CSourcePhrase instances, and the partner piles will need to
/// be recreated for each RecalcLayout() call, passing in create_strips_and_piles. This
/// needs to be the case until the full document is restored, and thereafter normal value
/// create_strips_keep_piles can be used
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::DoPrintCleanup()
{
	// BEW 18Jul09, move the code here from ~AIPrintout() destructor, as it's needed in
	// more than one place

    // Note: The code below cleans up the indices and flags after a print and/or print
    // preview operation. It could not go in OnEndPrinting because that gets called earlier
    // and more often in the wx version (especially when doing print preview).
	CAdapt_ItView* pView = GetView();

	if (m_nAIPrintout_Destructor_ReentrancyCount == 1)
	{
		// so the the stuff in this block only when we enter this function the first time

		// restore original doc size
		m_docSize = m_saveDocSize;
		// and put that value back into CLayout::m_logicalDocSize
		m_pLayout->RestoreLogicalDocSizeFromSavedSize();
		m_pLayout->m_pOffsets = NULL; // restore default NULL value for PageOffsets instance

        // if we were printing a selection, restore the original state first (but don't
        // restore the selection), then do tidy up of everything else & get a new layout
        // calculated; likewise if we were printing a chapter & verse range
		bool bSaveListHasContent = !m_pSaveList->IsEmpty();
#if defined(__WXGTK__)
        if (m_bPrintingSelection  || m_bPrintingRange || m_bPrintingPageRange || (gbIsBeingPreviewed && bSaveListHasContent))
#else
		if (m_bPrintingSelection  || m_bPrintingRange || (gbIsBeingPreviewed && bSaveListHasContent))
#endif
		{
			// BEW 14Nov11, RestorOriginalList now does a deep copy restore
			pView->RestoreOriginalList(m_pSaveList, m_pSourcePhrases); // ignore return value,
														// either we aborted, or all was well
            // we want any selection retained if we have been doing a print preview, but we
            // want the selection removed if we have been printing
			if (!gbIsBeingPreviewed && m_bPrintingSelection)
			{
				pView->RemoveSelection();
			}

			m_bPrintingSelection = FALSE;
			m_bPrintingRange = FALSE;

#if defined(__WXGTK__)
            // BEW added 15Nov11 - restore defaults
            m_bPrintingPageRange = FALSE;
            m_userPageRangePrintStart = 1;
            m_userPageRangePrintEnd = 1;
#endif

			// restore defaults for the checkboxes
			gbSuppressPrecedingHeadingInRange = FALSE;
			gbIncludeFollowingHeadingInRange = FALSE;
		}

		// clean up
		//pView->RestoreIndices();
		pView->ClearPagesList();
		// wx version: I think the All Pages button gets enabled

        // layout again for the screen, get an updated pointer to the active location,
        // restore the phrase box, scroll, invalidate window to restore pre-printing
        // appearance (if we had been printing a selection, it will get restored now
        // because the globals will have been preserved)
		m_nActiveSequNum = m_nSaveActiveSequNum; // restore active location sequ num
		m_pActivePile = NULL; // the piles are destroyed and recreated
							  // so the old pointer is useless

#ifdef _NEW_LAYOUT
		m_pLayout->RecalcLayout(m_pSourcePhrases, create_strips_and_piles);
#else
		m_pLayout->RecalcLayout(m_pSourcePhrases, create_strips_and_piles);
#endif
        // BEW 29Nov11, moved this line to be after the RecalcLayout() call, the latter
        // uses a TRUE value in a block near the end of RecalcLayout() which must not
        // be entered when the layout has been clobbered, and it's the TRUE value of
        // this flag which causes that block to be skipped
        m_bIsPrinting = FALSE;

	} // kluge block ends here so that a call to ScrollIntoView() is done for each
      // time entered, otherwise, the scroll position gets lost for the second entrance,
      // and a manual scroll is then required to make the active strip visible; but having
      // the call done each time solves this problem

	// recalculate the active pile & update location for phraseBox creation
	m_pActivePile = pView->GetPile(m_nActiveSequNum);
	if (m_pActivePile != NULL) // whm added 27Feb05 to avoid crash when
            // m_nActiveSequNum == -1 as can be the case when user finishes adapting a doc,
            // dismisses the dialog that informs of such, then immediately does print
            // preview. When closing print preview this routine would otherwise crash below
            // because GetPile makes m_pActivePile NULL.
	{
		GetMainFrame()->canvas->ScrollIntoView(m_nActiveSequNum);
		m_nStartChar = 0;
		m_nEndChar = -1; // ensure initially all is selected
		m_pTargetBox->SetSelection(-1,-1); // select all
		m_pTargetBox->SetFocus();
	}

	pView->Invalidate();
	m_pLayout->PlaceBox();
	//wxWindow* pWnd; // unused
	//pWnd = wxWindow::FindFocus(); // the box is not visible when the focus is set
            // by the above code, so unfortunately the cursor will have to be manually put
            // back in the box

    // Code to thaw the canvas needs to go here in OnCloseWindow, because OnEndPrinting
    // gets called prematurely by the framework as each preview page is about to be shown.
	// (Also, now that BEW has added the m_nAIPrintout_Destructor_ReentrancyCount kluge,
	// we must permit a balanced number of calls to Thaw(), although we permit the stuff
	// in the block above to be done only once)
	if (GetMainFrame()->canvas->IsFrozen())
		GetMainFrame()->canvas->Thaw();

	m_nAIPrintout_Destructor_ReentrancyCount++; // count the number of times this
            // function is entered, we do nothing in this block if it is is entered more
            // than once
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if all was well, FALSE if the width and length were not successfully
///             calculated
/// \param
/// nPagePrintingWidthLU    <-  return the printable page width in logical units (
///                             screen pixels)
/// nPagePrintingLengthLU   <-  return the printable page length in logical units
///                             (screen pixels)
/// \remarks
/// Takes the docSize value as modified for the printable width of the paper, and converts
/// it to logical units (which means 'screen pixels')
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::CalcPrintableArea_LogicalUnits(int& nPagePrintingWidthLU,
							int& nPagePrintingLengthLU)
{
	if (gbIsBeingPreviewed)
	{
		//wxLogDebug(_T("OnPreparePrint() START"));
		// refactored 6Apr09, moved from OnPreparePrint() in AIPrintout.cpp and made a
		// function here in the app class by BEW on 18Jul09
		m_docSize = m_pLayout->GetLogicalDocSize(); // copy m_logicalDocSize value
													// back to app's member
 		m_saveDocSize = m_docSize; // also done in creator of AIPrintout class

	  // whm notes:
		//
        // 1. OnPreparePrinting() is called automatically by the framework when an
        // OnPrint() event is handled (via wxID_PRINT standard Identifier). According to
        // the docs, "It is called once by the framework before any other demands are made
        // of the wxPrintout object. This gives the object an opportunity to calculate the
        // number of pages in the document, and any other print preparations that are
        // necessary before actual printing or print preview is done." OnPreparePrinting()
        // is always called once just before a print preview dialog is displayed, and it is
        // not called again when a different page is selected in print preview mode. When
        // File | Print is selected OnPreparePrinting() is not called until after the the
        // OK button is pressed at the print dialog, so, if user cancels the print dialog
        // OnPreparePrinting() is never called in that case.
		//
        // 2. MFC uses a CPrintInfo* pInfo parameter, but the wx version creates a
        // wxPrintData object (pPrintData) in OnInit() of the App. pPrintData is also used
        // as a data member of wxPrintDialogData and wxPageSetupDialogData, as part of the
        // mechanism for transferring data between the print dialogs and the application.
		//
        // 3. For the wx version, as the wxWidgets' printing sample illustrates, it is not
        // necessary to explicitly change the display context's mapping mode for printing
        // and print previewing, but that printing can be done readily just using the
        // default wxMM_TEXT mapping mode. Also it is evident that most of the manipulation
        // that MFC does of the printing routines that are conditional on the gbIsPrinting
        // global (especially in the handling of negative y axis offsets) are not
        // necessary.
		//
        // 4. Note: The page setup routines in wx mostly return values in millimeters, so
        // I've revised the App to maintain page size and margin data in metric
        // (millimeters) as well as MFC's thousandths of an inch. The internal routines
        // here in OnPreparePrinting() handle the data in mm.
		//
        // 5. The MFC version actually calls up the print dialog from within its version of
        // OnPreparePrinting (by calling the MFC DoPreparePrinting(pInfo) function). The wx
        // version works differently. The print dialog is called up in its high level
        // OnPrint() handler at the point where the wxPrinter object's Print() method is
        // called. There is therefore no need for cleanup code to fix indices, call
        // RecalcLayout, etc. All that is done in the AIPrintout's destructor.
		//
		// See code:#print_flow for the order of calling of OnPreparePrinting().

		CAdapt_ItView* pView = GetView();

		// whm Note: Most of the approximately 50 blocks of code where gbIsPrinting is used in
		// the MFC version (in Adapt_ItCanvas.cpp, Adapt_ItView.cpp, AIPrintout.cpp, Cell.cpp,
		// Pile.cpp and Strip.cpp), are removed in the wx version. The wx version does not use
		// any negative offsets in printing. We can't remove gbIsPrinting altogether because of
		// the way that it is used in the Strip's Draw() function.
		//
		// whm update: It is not sufficient to set m_bIsPrinting to TRUE only here, because
		// OnEndPrinting() sets it to FALSE after each page is drawn in print preview. It is
		// also set to TRUE in OnBeginDocument().
		m_bIsPrinting = TRUE;

        // The MFC version deletes the CPrintDialog object created in the CPrintInfo
        // constructor, and substitutes a customized print dialog. The wx version is not
        // using a customized print dialog at present, but we may provide one eventually if
        // it becomes clear how to tie in to the standard print dialog for each individual
        // platform.

		// whm: get a pointer to the wxPrintDialogData object (from printing sample)
		wxPrintDialogData printDialogData(*pPrintData);

		// set the page range to defaults
		printDialogData.SetMinPage(1); // must start at 1
		printDialogData.SetMaxPage(0xffff); // don't know how many yet

		// clear any old view settings for an earlier print, in case they were not cleared
		pView->ClearPagesList();

/*  This doesn't belong here, Print Preview can't do range printing
		if (m_bPrintingRange)
		{
            // set up the range, layout, etc. (It is SetupRangePrintOp()'s responsibility
            // to set up the new index values, since the old settings have already been
            // saved)
			bool bSetupOK = pView->SetupRangePrintOp(gnFromChapter,gnFromVerse,gnToChapter,
									gnToVerse,pPrintData,gbSuppressPrecedingHeadingInRange,
									gbIncludeFollowingHeadingInRange);
			if(!bSetupOK)
			{
				// printing a chapter/verse range failed
				wxString str = _("Setup of the chapter and verse range failed. This printing operation has been aborted. Perhaps the document does not contain chapter or verse numbers within the range you specified.");
				LogUserAction(str);
				wxMessageBox(str, _T(""), wxICON_STOP);
				return FALSE; // abort the print operation
			}
		}
*/
/* -- can't do this here, m_pagesList is empty, and SetupPageRangePrintOp() relies on it
#if defined(__WXGTK__)
        else if (m_bPrintingPageRange)
        {
            // this is required in the Linux build because support for a user-set range of
            // pages to print, is broken - so we have to support it by this workaround
            int nFromPage = m_userPageRangePrintStart; // RHS was set in view's OnPrint()
            int nToPage = m_userPageRangePrintEnd;     // ditto
            bool bSetupOK = pView->SetupPageRangePrintOp(nFromPage, nToPage, pPrintData);
 			if(!bSetupOK)
			{
				// Page range printing failed
				wxString str = _("Setup of your choice for the range of pages to be printed, failed. This printing operation has been aborted. Please alert the developers.");
				LogUserAction(str);
				wxMessageBox(str, _T(""), wxICON_STOP);
				return FALSE; // abort the print operation
			}
       }
#endif
*/
		bool bDefaultPgSetupInfoAvailable;
		bDefaultPgSetupInfoAvailable = pPgSetupDlgData->GetDefaultInfo();
		if (!bDefaultPgSetupInfoAvailable)
		{
            // The default page setup information is not available, so set the default page
            // setup dimensions for A4 paper. The default page setup info generally won't
            // be available unless the user has explicitly called up the page setup dialog.
			pPgSetupDlgData->SetPaperSize(wxSize(210,297)); // sets A4 paper size in mm (210mm x 297mm)
			pPgSetupDlgData->SetMarginTopLeft(wxPoint(25,25)); // sets top left margin in mm (approx 1 inch)
			pPgSetupDlgData->SetMarginBottomRight(wxPoint(25,25)); // sets bottom right margin in mm (approx 1 inch)
		}

        // whm: Caution: The following commented out call to SetDefaultInfo(TRUE) would
        // cause the page setup handler to be inable to call up the page setup dialog after
        // a print preview.
		// pPgSetupDlgData->SetDefaultInfo(TRUE);
		// TRUE means we return default printer information without showing a dialog
		// (Windows only)

		// whm Notes:
		//
        // 1. If the user has not accessed the page setup dialog pPgSetupDlgData's
        // GetPaperSize() and actually selected a paper size explicitly, this
        // GetPaperSize() method will return a (0,0) size, Check for a (0,0) sized paper.
		//
        // 2. It should not be necessary to store the m_paperSizeCode value here from
        // within the print or print preview routines. If the user changes the paper size
        // selection (which can only be done from the Page Setup Dialog), the App's storage
        // variables should only be changed from there not here.
		//
        // 3. For compatibility with MFC version we could store the paper size in config
        // file as an int representative of MFC's DEVMODE enum values, however the paper
        // size codes in MFC and wx don't match because they use different enum structures.
        // To get better compatibility between the config values stored in MFC and wx, we
        // map the wx paper size code to MFC's code using our MapWXtoMFCPaperSizeCode
        // function in OnFilePageSetup() and store in m_paperSizeCode.
		//
        // 4. The App's m_pageWidth and m_pageLength are stored in thousandths of an inch,
        // i.e., 8269 x 11692 for A4, 8500 x 11000 for Letter. Neither the MFC nor the wx
        // version use m_pageWidth and m_pageLength to draw text on the screen apart from
        // print operations. Moreover, the wx version doesn't need to use these values in
        // its print and print preview routines. Therefore, I don't see any reason to
        // change these values held on the App during printing. They really only store the
        // page width and length for eventual writing to the config files

        // MFC Note: Because PrintSetup, if user changes from Portrait to Landscape, does
        // not result in the width and height being swapped, we have to test for the change
        // in orientation and fix it up - this mismatch will obtain if
        // m_bIsPortraitOrientation is still TRUE when GetPageOrientation() returns 2 (==
        // Landscape) - the next two if's are needed only if user changes orientation in
        // the Print Setup dialog; if he does it in the Page Setup dialog, my other code
        // gets everything fixed right, but Print Setup doesn't inform the view of the
        // interchange of x and y axes in MFC, so I must do it here.
		int nOrientation = GetPageOrientation();
		if (nOrientation == 1)
		{
			m_bIsPortraitOrientation = TRUE;
		}
		else
		{
			m_bIsPortraitOrientation = FALSE;
		}

		// the above width & length are portrait settings, so check if we have landscape
		// currently set, if so, switch values to agree
		if (!m_bIsPortraitOrientation)
		{
			// Swap the width and length values for landscape in the pPgSetupDlgData object.
			//
            // Note: the pPrintData->SetOrientation(wxLANDSCAPE) method will already have
            // been called (via SetPageOrientation() function) for landscape mode. That
            // call switches the printer into that mode when printing, so we only need to
            // manually reverse the dimensions of the paper size (here), and set the
            // logical unit page printing width nPagePrintingWidthLU. The
            // nPagePrintingWidthLU is assigned to m_docSize (used in RecalcLayout) and
            // passed to our PaginateDoc() function.
			int width = m_pageWidthMM;
			int length = m_pageLengthMM;
			pPgSetupDlgData->SetPaperSize(wxSize(length,width)); // reverse parameters for landscape
		}

        // At this point we should have a valid (non-zero) paper size stored in our
        // pPgSetupDlgData object. It should have x and y values which reflect the page
        // orientation m_bIsPortraitOrientation. The paper size is in mm (default is 210 mm
        // by 297 mm for A4). If we have landscape mode, the paperSize will be 297 mm by
        // 210 mm.
		wxSize paperSize_mm;
		paperSize_mm = pPgSetupDlgData->GetPaperSize();
		wxASSERT(paperSize_mm.x != 0);
		wxASSERT(paperSize_mm.y != 0);

		// We should also have valid (non-zero) margins stored in our pPgSetupDlgData object.
		wxPoint topLeft_mm, bottomRight_mm; // MFC uses CRect for margins, wx uses wxPoint
		topLeft_mm = pPgSetupDlgData->GetMarginTopLeft(); // returns top (y) and
										// left (x) margins as wxPoint in milimeters
		bottomRight_mm = pPgSetupDlgData->GetMarginBottomRight(); // returns bottom (y)
										// and right (x) margins as wxPoint in milimeters
		wxASSERT(topLeft_mm.x != 0);
		wxASSERT(topLeft_mm.y != 0);
		wxASSERT(bottomRight_mm.x != 0);
		wxASSERT(bottomRight_mm.y != 0);

		// whm Note: Up to this point the code in OnPreparePrinting() has focused on insuring
        // that we have good (or default) page and margin sizes established before
        // proceeding with printing and/or print previewing. Now we focus on getting the
        // actual dimensions of the printing area and determining the scaling factors we'll
        // use to properly draw into our differing display contexts (screen resolutions are
        // generally different from printer resolutions).

        // whm Note: The MFC application assumed the screen resolution would always be
        // 96dpi, or each dot being approximately 1/100th of an inch; hence, it divided the
        // calculated printing area (whose value was in 1000ths of an inch) by 10 to get
        // the assumed printing width (nPrintingWidth) to pass to RecalcLayout (via the
        // m_docSize global) and to PaginateDoc (directly as parameter). I've written the
        // code below for the wx version so that no screen resolution is assumed.

		// The code below was patterned after the wxWidgets printing sample.
		//
        // whm Note: For a good explanation of GDI Mapping Modes, SetWindowOrg and
        // SetViewportOrg see: http://wvware.sourceforge.net/caolan/mapmode.html See also:
        // http://functionx.com/visualc/gdi/gdicoord.htm for a decent graphical
        // illustration of SetViewportOrg() and SetMappingMode effects for the various
        // mapping modes.
		//
        // whm: Our target display context for pagination purposes is the printed page. We
        // want to draw strips within the printed page's margins - from the top margin to
        // the bottom margin - paginating the document into full pages plus any final
        // partially filled page.
		//
        // See CAdapt_ItView::SetupRangePrintOp() and CPrintOptionsDlg::InitDialog() for
        // coding similar to that below which calculates the page dimensions in logical
        // units. TODO: It might be good to write a separate function to do the job for all
        // three places. The main difference here is that we can use the
        // wxPrintout::GetPPIScreen() and wxPrintout::GetPPIPrinter() convenience methods,
        // but the method used in SetupRangePrintOp() and CPrintOptionsDlg's InitDialog()
        // would also work here.
		//
        // When printing, Adapt It's RecalcLayout generates strips whose width is based on
        // the margin dimensions of a printed page (printer device context), rather than
        // RecalcLayout's usual (when not printing) docSize.x based on the dimensions of
        // the main window's client area in device units or pixels. Since this
        // OnPreparePrinting function is also called for a print preview display context,
        // if we were to call the GetLogicalPageMarginsRect function during a print
        // preview, it won't give us the length data of printed page display context we
        // need for calling PaginateDoc. Instead we'll first calculate the length between
        // top and bottom margins of a printed page in mm, then convert the result to
        // appropriate device units for use by PaginateDoc.
		int pageWidthBetweenMarginsMM, pageHeightBetweenMarginsMM;
        // The size data returned by GetPageSizeMM is not the actual paper size edge to
        // edge, nor the size within the margins, but it is the usual printable area of a
        // paper, i.e., the limit of where most printers are physically able to print; it
        // is the area in between the actual paper size and the usual margins. We therefore
        // start with the raw paperSize and determine the intended print area between the
        // margins.
		pageWidthBetweenMarginsMM = paperSize_mm.x - topLeft_mm.x - bottomRight_mm.x;
		pageHeightBetweenMarginsMM = paperSize_mm.y - topLeft_mm.y - bottomRight_mm.y;
		// Now, convert the pageHeightBetweenMargins to logical units for use in calling
		// PaginateDoc. Get the logical pixels per inch of screen and printer.
		int ppiScreenX, ppiScreenY;
		pAIPrintout->GetPPIScreen(&ppiScreenX, &ppiScreenY); // usually 96 dpi but may
													// differ on newer/future computers
		int ppiPrinterX, ppiPrinterY;
		pAIPrintout->GetPPIPrinter(&ppiPrinterX, &ppiPrinterY); // dependent on the printer
        // Calculate the scale for the DC so that the printout represents the screen
        // scaling. The printing sample has the following comment: "The text point size
        // _should_ be the right size but in fact is too small for some reason. This is a
        // detail that will need to be addressed at some point but can be fudged for the
        // moment."

		// Do a reality check. On wxMAC sometimes the ppiPrinterX and ppiScreenX values
		// are zero! If either value is zero we set up a wxDC and try to calculate those
		// values using the wxDC::GetPPI() method.
		float scale;
		if (ppiPrinterX == 0 || ppiScreenX == 0)
		{
            // Now, convert the pageHeightBetweenMarginsMM to logical units for use in
            // calling PaginateDoc.
            //
			// Get the logical pixels per inch of screen and printer.
            // whm NOTE: We can't yet use the wxPrintout::GetPPIScreen() and
            // GetPPIPrinter() methods because the wxPrintout object is not created yet at
            // the time this print options dialog is displayed. But, we can do the same
            // calculations by using the wxDC::GetPPI() method call on both a wxPrinterDC
            // and a wxClientDC of our canvas.
			//
			// Set up printer and screen DCs and determine the scaling factors between
			// printer and screen.
			wxASSERT(pPrintData->IsOk());

		#ifdef __WXGTK__
			// Linux requires we use wxPostScriptDC rather than wxPrinterDC
            // Note: If the Print Preview display is drawn with text displaced up and off
            // the display on wxGTK, the wxWidgets libraries probably were not configured
            // properly. They should have included a --with-gnomeprint parameter in the
            // configure call.
			wxPostScriptDC printerDC(*pPrintData);
		#else
			wxPrinterDC printerDC(*pPrintData);
		#endif

			wxASSERT(printerDC.IsOk());
			wxSize printerSizePPI = printerDC.GetPPI(); // gets the resolution of the
												// printer in pixels per inch (dpi)
			wxClientDC canvasDC(GetMainFrame()->canvas);
			wxSize canvasSizePPI = canvasDC.GetPPI(); // gets the resolution of the
												// screen/canvas in pixels per inch (dpi)
			scale = (float)printerSizePPI.GetHeight() / (float)canvasSizePPI.GetHeight();
            // Calculate the conversion factor for converting millimetres into logical
            // units. There are approx. 25.4 mm to the inch. There are ppi device units to
            // the inch. Therefore 1 mm corresponds to ppi/25.4 device units. We also
            // divide by the screen-to-printer scaling factor, because we need to unscale
            // to pass logical units to PaginateDoc.
			float logicalUnitsFactor = (float)(printerSizePPI.GetHeight()/(scale*25.4));
			nPagePrintingWidthLU = (int)(pageWidthBetweenMarginsMM * logicalUnitsFactor);
			nPagePrintingLengthLU = (int)(pageHeightBetweenMarginsMM * logicalUnitsFactor);
		}
		else
		{
            // Use the values calculated by pAIPrintout->GetPPIScreen() and
            // pAIPrintout->GetPPIPrinter()
			scale = (float)((float)ppiPrinterX/(float)ppiScreenX);
			// Calculate the conversion factor for converting millimetres into logical units.
			// There are approx. 25.4 mm to the inch. There are ppi device units to the inch.
			// Therefore 1 mm corresponds to ppi/25.4 device units. We also divide by the
			// screen-to-printer scaling factor, because we need to unscale to pass logical
			// units to PaginateDoc.
			float logicalUnitsFactor = (float)(ppiPrinterX/(scale*25.4)); // use the more
																// precise conversion factor
			nPagePrintingWidthLU = (int)(pageWidthBetweenMarginsMM * logicalUnitsFactor);
			nPagePrintingLengthLU = (int)(pageHeightBetweenMarginsMM * logicalUnitsFactor);
		}
	}
	else
	{
		// normal printing to a real printer

		GetView()->ClearPagesList();

		int pageWidthBetweenMarginsMM, pageHeightBetweenMarginsMM;
		wxSize paperSize_mm;
		paperSize_mm = pPgSetupDlgData->GetPaperSize();
		wxASSERT(paperSize_mm.x != 0);
		wxASSERT(paperSize_mm.y != 0);
		 // We should also have valid (non-zero) margins stored in our pPgSetupDlgData object.
		wxPoint topLeft_mm, bottomRight_mm; // MFC uses CRect for margins, wx uses wxPoint
		topLeft_mm = pPgSetupDlgData->GetMarginTopLeft(); // returns top (y) and
									// left (x) margins as wxPoint in milimeters
		bottomRight_mm = pPgSetupDlgData->GetMarginBottomRight(); // returns bottom (y)
									// and right (x) margins as wxPoint in milimeters
		wxASSERT(topLeft_mm.x != 0);
		wxASSERT(topLeft_mm.y != 0);
		wxASSERT(bottomRight_mm.x != 0);
		wxASSERT(bottomRight_mm.y != 0);
        // The size data returned by GetPageSizeMM is not the actual paper size edge to
        // edge, nor the size within the margins, but it is the usual printable area of a
        // paper, i.e., the limit of where most printers are physically able to print; it
        // is the area in between the actual paper size and the usual margins. We therefore
        // start with the raw paperSize and determine the intended print area between the
        // margins.
		pageWidthBetweenMarginsMM = paperSize_mm.x - topLeft_mm.x - bottomRight_mm.x;
		pageHeightBetweenMarginsMM = paperSize_mm.y - topLeft_mm.y - bottomRight_mm.y;

        // Now, convert the pageHeightBetweenMarginsMM to logical units for use in calling
        // PaginateDoc.
        //
		// Get the logical pixels per inch of screen and printer.
        // whm NOTE: We can't yet use the wxPrintout::GetPPIScreen() and GetPPIPrinter()
        // methods because the wxPrintout object is not created yet at the time this print
        // options dialog is displayed. But, we can do the same calculations by using the
        // wxDC::GetPPI() method call on both a wxPrinterDC and a wxClientDC of our canvas.
		//
		// Set up printer and screen DCs and determine the scaling factors between
		// printer and screen.
		wxASSERT(pPrintData->IsOk());

	#ifdef __WXGTK__
		// Linux requires we use wxPostScriptDC rather than wxPrinterDC
        // Note: If the Print Preview display is drawn with text displaced up and off the
        // display on wxGTK, the wxWidgets libraries probably were not configured properly.
        // They should have included a --with-gnomeprint parameter in the configure call.
		wxPostScriptDC printerDC(*pPrintData);
	#else
		wxPrinterDC printerDC(*pPrintData);
	#endif

		wxASSERT(printerDC.IsOk());
		wxSize printerSizePPI = printerDC.GetPPI(); // gets the resolution of the
											// printer in pixels per inch (dpi)
		wxClientDC canvasDC(GetMainFrame()->canvas);
		wxSize canvasSizePPI = canvasDC.GetPPI(); // gets the resolution of the
										// screen/canvas in pixels per inch (dpi)
		float scale = (float)printerSizePPI.GetHeight() / (float)canvasSizePPI.GetHeight();

        // Calculate the conversion factor for converting millimetres into logical units.
        // There are approx. 25.4 mm to the inch. There are ppi device units to the inch.
        // Therefore 1 mm corresponds to ppi/25.4 device units. We also divide by the
        // screen-to-printer scaling factor, because we need to unscale to pass logical
        // units to PaginateDoc.
		float logicalUnitsFactor = (float)(printerSizePPI.GetHeight()/(scale*25.4));
		nPagePrintingWidthLU = (int)(pageWidthBetweenMarginsMM * logicalUnitsFactor);
		nPagePrintingLengthLU = (int)(pageHeightBetweenMarginsMM * logicalUnitsFactor);
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if all was well, FALSE if the layout and pagination was not
///             successful
/// parameters:
/// nPagePrintingWidthLU    ->  the printable page width in logical units
///                             (screen pixels)
/// nPagePrintingLengthLU   ->  the printable page length in logical units
///                             (screen pixels)
/// Remarks:
/// The function encapsulates the actions required for supporting a printout or print
/// preview or selecting just a range of CSourcePhrases selected in the view - such a
/// selection can be any length; when there is a selection, the original CSourcePhrase
/// instances in the m_pSourcePhrases list are temporarily stored in the app member
/// m_pSaveList, and (shallow) copies the CSourcePhrase instances of the selection are
/// stored in the m_pSourcePhrases list - and only after that is the pagination done. A
/// gloobal boolean, gbPrintingSelection is set TRUE as well, and this is used to govern
/// what happens subsequently, in particular, to ensure that after printing, the original
/// document state is set up again in DoPrintCleanup().
////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItApp::LayoutAndPaginate(int& nPagePrintingWidthLU,
									 int& nPagePrintingLengthLU)
{
	CAdapt_ItView* pView = GetView();
	wxPrintDialogData printDialogData(*pPrintData);

	// Set the document size (the width explicitly).
    // whm: m_docSize.x is normally the width of the main window client area in pixels. For
    // printing we want this to be the size of the printable area within the page's
    // margins.
	//pApp->m_docSize.x = nPagePrintingWidthLU;
	m_docSize.x = nPagePrintingWidthLU;
    // Note: the document's length m_docSize.y is determined after call to PaginateDoc()
    // farther below, so just set the .y value to zero here - then call
    // CopyLogicalDocSizeFromApp() to inform the CLayout::m_logicalDocSize member (used in
    // RecalcLayout() of the different strip width to be used for populating the strips
    // with piles for printing
	m_docSize.y = 0;
    m_pLayout->CopyLogicalDocSizeFromApp();

	// check for a selection, if it exists, assume user wants to print it & setup
	// accordingly; similarly, check for a range - if a range, assume any selection should
	// be ignored
	if (m_bPrintingRange && !gbIsBeingPreviewed )
	{
        // set up the range, layout, etc. (It is SetupRangePrintOp()'s responsibility
        // to set up the new index values, since the old settings have already been
        // saved)
		bool bSetupOK = pView->SetupRangePrintOp(gnFromChapter,gnFromVerse,gnToChapter,
								gnToVerse,pPrintData,gbSuppressPrecedingHeadingInRange,
								gbIncludeFollowingHeadingInRange);
		if(!bSetupOK)
		{
			// chapter/verse range print failed
			wxString str = _("Setup of the chapter and verse range failed. This printing operation has been aborted. Perhaps the document does not contain chapter or verse numbers within the range you specified.");
			LogUserAction(str);
			wxMessageBox(str, _T(""), wxICON_STOP);
			return FALSE; // abort the print operation
		}
		m_pActivePile = NULL;
		m_nActiveSequNum = -1;
	}
#if defined(__WXGTK__)
	else if (m_bPrintingPageRange)
	{
	    // printing a user-chosen page range (we have to handle it explicitly
        // because the wxGnomeprinter framework is broken for this feature

        // The call below for setting up the page range requires we have m_pagesList
        // populated, and it isn't yet. So we'll do a preliminary pagination so as to
        // get a full-document list of PageOffsets structs -- from these the user's
        // choices for the page to start and the page to end can be made, the
        // appropriate sequence number bounds calculated, and then the range of
        // CSourcePhrase instances defined by the starting and ending sequence numbers
        // allows a sublist to be extracted to form a shortened doc, which we then print
        // and restore the full list later in DoPrintCleanup() in the AIPrintout destructor
#ifdef _NEW_LAYOUT
			m_pLayout->RecalcLayout(m_pSourcePhrases, create_strips_keep_piles);
#else
			m_pLayout->RecalcLayout(m_pSourcePhrases, create_strips_keep_piles);
#endif
       int aStripCount = m_pLayout->GetStripArray()->GetCount();
        bool bIsOK;
        bIsOK = pView->PaginateDoc(aStripCount, nPagePrintingLengthLU);
        wxCHECK_MSG(bIsOK, FALSE, _T("LayoutAndPaginate(): PaginateDoc() failed, line 35,631 in Adapt_It.cpp"));
		// app's m_pagesList is now populated
	    bool bSetupOK = pView->SetupPageRangePrintOp(m_userPageRangePrintStart, m_userPageRangePrintEnd, pPrintData);
		if(!bSetupOK)
		{
			// chapter/verse range print failed
			wxString str = _("Setup of your chosen range of pages for printing, failed. This printing operation has been aborted. Please alert the developers.");
			LogUserAction(str);
			wxMessageBox(str, _T(""), wxICON_STOP);
			return FALSE; // abort the print operation
		}
		m_pActivePile = NULL;
		m_nActiveSequNum = -1;
	}
#endif
	else if (m_selectionLine == -1)
	{
        // BEW added wrapping test on 18Jul09, Print Preview enters OnPreparePrinting
        // twice, so suppress the redoing of the calculations on the second time round -
        // note, if Print Previewing a selection, then the first entrance will have
        // clobbered the selection and so m_selectionLine would be -1 the second time
        // round, so we can get into this block in a "print preview of selection" scenario,
        // and so such as situation we'd prefer to leave the gbPrintingSelection global's
        // value unchanged, so include it within the TRUE block of the following test; on
        // the second time round, the app list member m_pSaveList will have content if a
        // selection is being previewed and when that is the case we want to skip this
        // block
		if (!gbIsBeingPreviewed  || (gbIsBeingPreviewed && m_pSaveList->IsEmpty()))
		{
			if (m_bPrintingSelection && !m_pSaveList->IsEmpty())
			{
				// a selection has been setup for, so we retain the value of
				// m_bPrintingSelection unchanged
				;
			}
			else
			{
				// no selection, so assume whole document (but see comment above)
				m_bPrintingSelection = FALSE;

				// force the selection button to be disabled, set the page range
				// to defaults
				printDialogData.SetSelection(FALSE); // must start at 1
			}

			// Recalc the layout with the new width.
			//
            // whm note: RecalcLayout uses m_docSize.x as its width in calculating the
            // number of strips for the current document. When layout out for the screen is
            // intended RecalcLayout sets m_docSize.x equal to the client size of the main
            // window - RHSlop. But, in printing, the client window size is ignored and the
            // value for m_docSize.x is assigned (above) based on the resolution width of
            // the display context, i.e., the number of dots printed per paper width when
            // printing, or the number of pixels per width of simulated paper in the print
            // preview (the number of pixels per width will vary depending on the scale set
            // in preview).
			// BEW note 21Jul09: the RecalcLayout() call below is NOT redundant when
			// OnPreparePrinting() is called after the Print Options dialog is dismissed,
			// because while that dialog was visible, RecalcLayout() was done with for the
			// view because the view needs to be repainted underneath the dialog, and if
			// the user moves the dialog it needs to repaint it correctly, so the strips
			// will have been restored to their view-supporting width, hence when we get
			// here after the dialog is dismissed, we have to recalculate the strips with
			// the strip width as required by the page dimensions. It's regretable we have
			// to do this twice (the earlier one was for getting the parameters, such as
			// the number of pages to print, correct for the Print Options dialog, and was
			// done in that dialog class's InitDialog() function prior to it being shown)
			// but we have no option. Hence the PaginateDoc() call below, also has to be
			// done the second time - but it's very fast compared to RecalcLayout()
#ifdef _NEW_LAYOUT
            m_pLayout->RecalcLayout(m_pSourcePhrases, create_strips_keep_piles);
#else
            m_pLayout->RecalcLayout(m_pSourcePhrases, create_strips_keep_piles);
#endif
			m_pActivePile = pView->GetPile(m_nActiveSequNum);
		}
	}
	else
	{
		// a selection is current, so set up for it
		printDialogData.SetSelection(TRUE);

        // MFC version: we want the pages radio button to be enabled, so fix Flags for that
        // whm: The wx version appears to have no way to change the "Pages" radio button;
        // it is not generally disabled. I think that just doing SetSelection(TRUE) above
        // is sufficient.

		// Be able to recover the fact that we are printing a selection.
		m_bPrintingSelection = TRUE;

		CCellList::Node* pos = m_selection.GetFirst();
		CCell* pCell = pos->GetData();
		int nBeginSN = pCell->GetPile()->GetSrcPhrase()->m_nSequNumber;
		pos = m_selection.GetLast();
		pCell = pos->GetData();
		int nEndSN = pCell->GetPile()->GetSrcPhrase()->m_nSequNumber;

        // The selection is about to be temporarily made the whole document, so we
        // must clobber the selection, since we now have nBeginSN and nEndSN
        // values defined (do it here, because after the GetSublist() call would
        // result in a crash because the "doc" would no longer agree with the layout
		pView->RemoveSelection();

		bool bOK;
		// BEW on 14Nov changed GetSublist() to make deep copies, an implication of
		// that is that the PileList constents in CLayout will all be invalid. So
		// we must do any RecalcLayout() call with the param create_stripes_and_piles
		bOK = pView->GetSublist(m_pSaveList, m_pSourcePhrases, nBeginSN, nEndSN);
		wxCHECK_MSG(bOK, FALSE, _T("LayoutAndPaginate(): GetSublist() failed, line 35,738 in Adapt_It.cpp"));

        // Recalc the layout with the new width
#ifdef _NEW_LAYOUT
            m_pLayout->RecalcLayout(m_pSourcePhrases, create_strips_and_piles);
#else
            m_pLayout->RecalcLayout(m_pSourcePhrases, create_strips_and_piles);
#endif

		// Set safe values for a non-active location (but leave m_targetPhrase unchanged).
		m_pActivePile = NULL;
		m_nActiveSequNum = -1;
	}

	// do pagination
	//
    // whm: In the following call to PaginateDoc, we use the current document
    // m_nStripCount, because the PaginateDoc() call here is done within
    // OnPreparePrinting() which is called after the print dialog has been dismissed with
    // OK, and thus we are paginating the actual doc to print and not merely simulating it
	// for purposes of getting the pages edit box values for the print options dialog.
	// (Don't suppress this pagination on second entry when doing print preview, as
	// otherwise the list of structs will be empty)
	int nStripCount = m_pLayout->GetStripArray()->GetCount(); // put it here, for debugging
	bool bOK;
	bOK = pView->PaginateDoc(nStripCount, nPagePrintingLengthLU); // doesn't call
																  // RecalcLayout()
	if (!bOK)
	{
        // PaginateDoc will have notified the user of any problem, so just return here -
        // we can't print without paginating the doc. Cleanup of the doc's indices, etc,
        // is done in the AIPrintout destructor.
		return FALSE;
	}
	//int nPageCount; // for debugging purposes only
	//nPageCount = m_pagesList.GetCount();
	//nPageCount = nPageCount; // avoid compiler warning

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
///
///    END OF PRINTING_SUPPORT FUNCTIONS
///
//////////////////////////////////////////////////////////////////////////////////////////

// return TRUE if the path is to a folder, otherwise return FALSE
bool CAdapt_ItApp::IsValidWorkFolder(wxString path)
{
	// now that Bill has opened the door for arbitrary folders of arbitrary name to be a
	// valid work folder, the only tests we can make are for an empty string and for a
	// valid folder at the end of the path
	if (path.IsEmpty())
		return FALSE;
	return ::wxDirExists(path.c_str());
}

/* unused
// return TRUE if one of the two basic config file types is present, in second parameter
// pass back the one found (don't look for the AI-AdminBasicConfiguration.aic file if the
// standard basic one is present), and pass back in bIsAdminBasic a record of which was
// found - it is conceivable that an admin one may be present but not yet a normal one
bool CAdapt_ItApp::IsConfigFileWithin(wxString path, wxString& configFilePath, bool& bIsAdminBasic)
{
	// beware, a windows machine may be looking at a folder on a linux or mac machine, or
	// vise versa, so we can't assume that the native path separator will apply equally to
	// the targetted folder, so we have to try each of / and \ separators
	wxString basicConfigName = szBasicConfiguration + _T(".aic");
	wxString adminBasicConfigName = szAdminBasicConfiguration + _T(".aic");

	// check first for the normal basic config file, with \ separator
	wxString configPath = path + _T("\\") + basicConfigName;
	if (::wxFileExists(configPath))
	{
		// it exists, so go no further
		configFilePath = configPath; // return path to caller, it may want it
		bIsAdminBasic = FALSE;
		return TRUE;
	}
	// else check first for the normal basic config file, with / separator
	configPath = path + _T("/") + basicConfigName;
	if (::wxFileExists(configPath))
	{
		// it exists, so go no further
		configFilePath = configPath; // return path to caller, it may want it
		bIsAdminBasic = FALSE;
		return TRUE;
	}
	// couldn't find a normal basic config file, try for an administrator one - perhaps an
	// administrator was here earlier and this really is a valid work folder if so
	// check for one with \ separator first
	configPath = path + _T("\\") +adminBasicConfigName;
	if (::wxFileExists(configPath))
	{
		// it exists, so go no further
		configFilePath = configPath; // return path to caller, it may want it
		bIsAdminBasic = TRUE;
		return TRUE;
	}
	// else check for one with / separator
	configPath = path + _T("/") +adminBasicConfigName;
	if (::wxFileExists(configPath))
	{
		// it exists, so go no further
		configFilePath = configPath; // return path to caller, it may want it
		bIsAdminBasic = TRUE;
		return TRUE;
	}
	return FALSE; // couldnt find any basic config file of either type
}
*/

// return TRUE if a valid work folder was located, otherwise return FALSE, and return the
// path found (or an empty string if used cancelled browse dialog) in the returnedPath
// parameter; if the user cancelled, bUserCancelled will be returned set to TRUE
bool CAdapt_ItApp::LocateCustomWorkFolder(wxString defaultPath, wxString& returnedPath,
										  bool& bUserCancelled)
{
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxString msg = _("Locate the folder you wish to use for Adapt It work");
	//long style = wxDD_DEFAULT_STYLE | wxDD_DIR_MUST_EXIST | wxDD_CHANGE_DIR;
		// second param suppresses a Create button being shown, 3rd makes chose directory
		// the working directory, first param is for default dialog style with resizable
		// border (see wxDirDialog for details)
	long style = wxDD_DEFAULT_STYLE | wxDD_CHANGE_DIR; // allow Create button in dialog
	wxPoint pos = wxDefaultPosition;
	// in the following call, which is a wx widget which can be called as below or as
	// ::wxDirSelector(...params...), if the user cancels from the browser window the
	// returned string is empty, otherwise it is the absolute path to whatever directory
	// was shown selected in the folder hierarchy when the OK button was pressed
	wxString dir = wxDirSelector(msg,defaultPath,style,pos,(wxWindow*)pFrame);
	returnedPath = dir;
	if (dir == _T(""))
	{
		bUserCancelled = TRUE;
		return FALSE;
	}
	bool bIsValid = IsValidWorkFolder(dir);
	return bIsValid;
}

// whm 12Jun11 added for Assign Locations For Inputs and Outputs... item on Administrator menu
void CAdapt_ItApp::OnUpdateAssignLocationsForInputsAndOutputs(wxUpdateUIEvent& event)
{
	// The "Assign Locations For Inputs And Outputs" item should be enabled except for
	// when administrator has read-only access
	if (m_bShowAdministratorMenu && !m_bReadOnlyAccess)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

// whm 12Jun11 added for Assign Locations For Inputs and Outputs... item on Administrator menu
void CAdapt_ItApp::OnAssignLocationsForInputsAndOutputs(wxCommandEvent& WXUNUSED(event))
{
	LogUserAction(_T("Initiated OnAssignLocationsForInputsAndOutputs()"));
	CAssignLocationsForInputsAndOutputs dlg(GetMainFrame());
	dlg.Center();
	if (dlg.ShowModal() == wxID_OK)
	{
		; // all work is done within the class methods
	}
	else
	{
		LogUserAction(_T("Cancelled OnAssignLocationsForInputsAndOutputs()"));
	}

}

void CAdapt_ItApp::OnUpdateSetupEditorCollaboration(wxUpdateUIEvent& event)
{
	// whm added 26Mar12.
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (m_bParatextIsInstalled || m_bBibleditIsInstalled)
	{
		event.Enable(TRUE);
	}
	else
	{
		// Neither PT nor BE are installed so disable the menu
		event.Enable(FALSE);
	}
}


void CAdapt_ItApp::OnSetupEditorCollaboration(wxCommandEvent& WXUNUSED(event))
{
	LogUserAction(_T("Initiated OnSetupEditorCollaboration()"));

	// whm 6Apr12 moved here from the InitDialog() of the CSetupEditorCollaboration class. Avoids having the
	// SetupEditorCollaboration dialog appear in the background while the following prompt is displaying.
	if (IsAIProjectOpen())
	{
		// whm Note: for the following block we use the App's m_collaborationEditor value instead of
		// our local m_TempCollaborationEditor which below this block is initialized to a null string.
		wxASSERT(!m_collaborationEditor.IsEmpty());
		CAdapt_ItView* pView = GetView();
		if (pView != NULL)
		{
			wxString msg = _("Adapt It needs to close the currently open project (%s) in order to set up collaboration with %s.");
			msg = msg.Format(msg,m_curProjectName.c_str(),m_collaborationEditor.c_str());
			wxMessageBox(msg,_T(""),wxICON_INFORMATION);
			pView->CloseProject();
		}
	}
	
	CSetupEditorCollaboration dlg(GetMainFrame());
	if (dlg.ShowModal() == wxID_OK)
	{
		// All setup is done and saved to individual AI project config files within
		// the CSetupEditorCollaborationDlg class.
		;
	}
	// Note: The CSetupEditorCollaboration dialog now only has a "Close" (wxID_OK)
	// button
}

// whm added the next two handlers 14Feb12
void CAdapt_ItApp::OnUpdateTempRestoreUserProfiles(wxUpdateUIEvent& event)
{
	// Enable the menu item as long as m_bAiSessionExpectsUserDefinedProfile is TRUE.
	// Note: The m_bAiSessionExpectsUserDefinedProfile flag is FALSE at initial program
	// startup, but would be set to TRUE if, when reading the basic config file, the
	// WorkflowProfile value there is a non-zero value. The flag could be set back to
	// false during the current session if the administrator were to access the
	// Administrator menu's "User Workflow Profiles..." menu and change the user profile
	// setting s back to "None".
	if (m_bAiSessionExpectsUserDefinedProfile)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItApp::OnTempRestoreUserProfiles(wxCommandEvent& WXUNUSED(event))
{
	// This is the menu handler for the "Temporarily restore all default user profile items..."
	// menu item on the Administrator menu. It is a toggle menu that toggles checked ON or OFF
	// depending on the value of the m_bTemporarilyRestoreProfilesToDefaults boolean flag.
	//
	// Note: we do NOT change the value of m_bAiSessionExpectsUserDefinedProfile
	// here nor in the else block below, since it is to reflect what the normal session
	// expects, not the temporary state as is done in this handler.
	if (m_bTemporarilyRestoreProfilesToDefaults)
	{
		// The "Temporarily restore all default user profile items..." menu item is toggled
		// on, so turn it off and reset any user profile setting (other than None) that
		// was in effect previously to the value stored in the App's m_nTempWorkflowProfile
		// variable.
		wxASSERT(m_nTempWorkflowProfile != -1);
		m_nWorkflowProfile = m_nTempWorkflowProfile;
		m_nTempWorkflowProfile = -1;
		// reset the user profile using saved setting that was in effect previously and which
		// is held in the m_nTempWorkflowProfile variable.
		ConfigureInterfaceForUserProfile(); // sets the profile to the value in m_nWorkflowProfile
		// Toggle the check state of the menu item to unticked.
		m_bTemporarilyRestoreProfilesToDefaults = FALSE;
		MakeMenuInitializationsAndPlatformAdjustments(collabIndeterminate);
		// Note: we don't call SaveUserProfilesMergingDataToXMLFile() here because the profile
		// change was temporary.
		// Compare the code in this block with that in the if (m_bTemporarilyRestoreProfilesToDefaults)
		// block of the OnEditUserMenuSettingsProfiles() handler - the code for the profile change
		// should be the same.
	}
	else
	{
		// The "Temporarily restore all default user profile items..." menu item is toggled
		// off, so turn it on, and set all menu items, etc to their visible defaults
		wxASSERT(m_nWorkflowProfile != -1);
		m_nTempWorkflowProfile = m_nWorkflowProfile; // save the current setting in the temp value
		m_nWorkflowProfile = 0; // 0 is the "None" profile which shows all interface elements
		ConfigureInterfaceForUserProfile();  // sets the profile to the value in m_nWorkflowProfile
		// Toggle the check state of the menu item to ticked.
		m_bTemporarilyRestoreProfilesToDefaults = TRUE;
		MakeMenuInitializationsAndPlatformAdjustments(collabIndeterminate);
		// Note: we don't call SaveUserProfilesMergingDataToXMLFile() here because the profile
		// change is goin to be temporary.
	}
}

void CAdapt_ItApp::OnUpdateEditUserMenuSettingsProfiles(wxUpdateUIEvent& event)
{
	// whm 19Sep11 modified. The "User Workflow Profiles..." menu item should
	// be available even when no project has been selected and m_curProjectPath
	// is empty
	//if (m_curProjectPath.IsEmpty())
	//{
	//	event.Enable(FALSE);
	//}
	//else
	//{
		if (m_bShowAdministratorMenu && !m_bReadOnlyAccess)
		{
			event.Enable(TRUE);
		}
		else
		{
			event.Enable(FALSE);
		}
	//}
}

void CAdapt_ItApp::OnEditUserMenuSettingsProfiles(wxCommandEvent& WXUNUSED(event))
{
	LogUserAction(_T("Initiated OnEditUserMenuSettingsProfiles()"));
	// whm added 17Feb12. If the administrator has made the Administrator
	// menu's "Turn OFF the current user profile temporarily" active so that
	// we are temporarily in the "None" user profile, then we unilaterally
	// set the Admin's normal setting of the user profile to what it normally
	// is, and notify the administrator of what we have done.
	if (m_bTemporarilyRestoreProfilesToDefaults)
	{
		wxASSERT(m_nTempWorkflowProfile > 0); // m_bTemporarilyRestoreProfilesToDefaults should not be 0 ("None") or -1 (undefined)
		// Determine the name of the m_nTempWorkflowProfile from the m_pUserProfiles struct on the heap.
		wxString userProfiileStr = _T("");
		if (m_pUserProfiles != NULL)
		{
			int count;
			int item_count = (int)m_pUserProfiles->definedProfileNames.GetCount();
			for(count = 0; count < item_count; count++)
			{
				if ((m_nTempWorkflowProfile - 1) == count) // Note: must compare count with m_nTempWorkProfile - 1
				{
					userProfiileStr = m_pUserProfiles->definedProfileNames.Item(count);
					break;
				}
			}
		}
		wxASSERT(!userProfiileStr.IsEmpty());
		wxString msg = _T("At your choice Adapt It temporarily set the user profile to \"None\" to allow you to access all menu items. Before showing you the User Workflow Profiles dialog, Adapt It is now switching back to the \"%s\" user profile which was in effect when this session of Adapt It started up.");
		msg = msg.Format(msg,userProfiileStr.c_str());
		wxMessageBox(msg,_T(""),wxICON_INFORMATION);

		// switch the interface back to the "normal" one as defined previously by the administrator
		// Note: The code below must be the same as in the if (m_bTemporarilyRestoreProfilesToDefaults)
		// block in OnTempRestoreUserProfiles() menu handler.
		wxASSERT(m_nTempWorkflowProfile != -1);
		m_nWorkflowProfile = m_nTempWorkflowProfile;
		m_nTempWorkflowProfile = -1;
		// reset the user profile using saved setting that was in effect previously and which
		// is held in the m_nTempWorkflowProfile variable.
		ConfigureInterfaceForUserProfile(); // sets the profile to the value in m_nWorkflowProfile
		// Toggle the check state of the menu item to unticked.
		m_bTemporarilyRestoreProfilesToDefaults = FALSE;
		MakeMenuInitializationsAndPlatformAdjustments(collabIndeterminate);
		// Note: we don't call SaveUserProfilesMergingDataToXMLFile() here because the profile
		// change was temporary.
	}

	CAdminEditMenuProfile editMenuDlg(GetMainFrame());
	editMenuDlg.Center();
	if (editMenuDlg.ShowModal() == wxID_OK)
	{
		if (editMenuDlg.bChangesMadeToProfileItems
			|| editMenuDlg.bChangeMadeToProfileSelection
			|| editMenuDlg.bChangeMadeToDescriptionItems)
		{
			// Make changes to the interface here based on the user's workflow
			// profile selection/changes which are now stored in m_nWorkflowProfile
			// and m_pUserProfiles.
			ConfigureInterfaceForUserProfile();
			MakeMenuInitializationsAndPlatformAdjustments(collabIndeterminate);
			// Also, save the changes to the AI_UserProfiles.xml file
			SaveUserProfilesMergingDataToXMLFile(m_userProfileFileWorkFolderPath);
		}
	}
	else
	{
		LogUserAction(_T("Cancelled OnEditUserMenuSettingsProfiles()"));
	}
}

void CAdapt_ItApp::OnHelpForAdministrators(wxCommandEvent& WXUNUSED(event))
{
	// Note: The option to load the help file into the user's default browser
	// a better option for this reason: When we use AI's own CHtmlWindow class,
	// although it is shown as a modeless dialog, it cannot be accessed
	// (to scroll, click on links, etc.) while other Adapt It dialogs (such
	// as the Setup Paratext Collaboration dialog) are being shown modal.
	// Therefore, the CHtmlWindow dialog is limited in what can be shown if
	// the administrator wants to follow its setup instructions during
	// the setup of the user's Adapt It settings. Loading the html help file
	// into the user's default browser has the advantage in that it can be
	// accessed at the same time the administrator is doing his setup using
	// modal dialogs within Adapt It. He might need to switch back and forth
	// between AI and the browser, of course, depending on how much screen
	// disktop is available to work with.
	//
	// The "Help for Administrators.htm" file should go into the m_helpInstallPath
	// for each platform, which is determined by the GetDefaultPathForHelpFiles() call.
	wxString adminHelpFilePath = GetDefaultPathForHelpFiles() + PathSeparator + m_adminHelpFileName;
	// Create a wxHtmlWindow to display the Help for Administrators.htm help file
    //wxFrame* pHtmlWinFrame = new wxFrame(this->GetMainFrame(),-1,_T(""));

#ifdef _USE_HTML_FILE_VIEWER
	// for testing the CHtmlFileViewer class dialog
	bool bSuccess = FALSE;
#else
	// for normal execution of the app
	bool bSuccess = TRUE;
#endif

	if (bSuccess)
	{
		wxLogNull nogNo;
		bSuccess = wxLaunchDefaultBrowser(adminHelpFilePath,wxBROWSER_NEW_WINDOW); // result of using wxBROWSER_NEW_WINDOW depends on browser's settings for tabs, etc.
	}
	if (!bSuccess)
	{
		wxString msg = _("Could not launch the default browser to open the HTML file's URL at:\n\n%s\n\nYou may need to set your system's settings to open the .htm file type in your default browser.\n\nDo you want Adapt It to show the Help file in its own HTML viewer window instead?");
		msg = msg.Format(msg, adminHelpFilePath.c_str());
		int response = wxMessageBox(msg,_("Browser launch error"),wxYES_NO);
		LogUserAction(msg);
		if (response == wxYES)
		{
			wxString title = _("Help for Administrators");
			m_pHtmlFileViewer = new CHtmlFileViewer(this->GetMainFrame(),&title,&adminHelpFilePath);
			m_pHtmlFileViewer->Show(TRUE);
			LogUserAction(_T("Launched Help_for_Administrators.htm in browser"));
		}
	}
	else
	{
		LogUserAction(_T("Launched Help_for_Administrators.htm in browser"));
	}
}

void CAdapt_ItApp::OnUpdateHelpForAdministrators(wxUpdateUIEvent& event)
{
	event.Enable(TRUE); // we want it always available
}

void CAdapt_ItApp::OnUpdateCustomWorkFolderLocation(wxUpdateUIEvent& event)
{
	// whm added 26Mar12.
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE); // we want it always available, if visible
}

void CAdapt_ItApp::OnUpdateSetPassword(wxUpdateUIEvent& event)
{
	if (m_bAdminMenuRemoved)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE); // permit password setting if Administrator
						// menu is currently visible
}

void CAdapt_ItApp::OnSetPassword(wxCommandEvent& WXUNUSED(event))
{
	LogUserAction(_T("Initiated OnSetPassword()"));
	wxString caption = _("Type A Password");
	wxString message = _(
"The password can be a mix of letters, numbers and punctuation. Less than five characters will not be accepted.\nEmptying the text box erases the previously set password, leaving no password set.\nTyping a different password replaces the current one.");
	//wxString default_value = _T(""); <- email exchanges 4-5April2011 with Bob Buss,
	// we agreed that it would be more helpful to see the current password in the clear,
	// and that should be okay because the Administrator menu should not be open in the
	// novice user's presence, but if it is, its the administrator's problem to sort out
	wxString default_value = m_adminPassword;
	wxString password = ::wxGetTextFromUser(message,caption,default_value,m_pMainFrame);
	int length = password.Len();
	if (length == 0)
	{
		// administrator wants to lock out anyone who does not know the "admin" secret password
		m_adminPassword = _T("");
		LogUserAction(_T("Admin removed password"));
		return;
	}
	if (length <= 4)
	{
		::wxBell();
		wxMessageBox(_("Too short."),_T(""),wxICON_WARNING);
		LogUserAction(_T("Password too short"));
	}
	else
	{
		LogUserAction(_T("Password accepted"));
		// accept the password
		m_adminPassword = password;
	}
}

void CAdapt_ItApp::OnUpdateRestoreDefaultWorkFolderLocation(wxUpdateUIEvent& event)
{
	//wxLogDebug(_T("m_bAdminMenuRemoved %d , equal paths %d , m_bUseCustomWorkFolderPath %d , m_customWorkFolderPath %s , m_workFolderpath %s"),
	//			m_bAdminMenuRemoved, m_workFolderPath == m_customWorkFolderPath, m_bUseCustomWorkFolderPath ,
	//			m_customWorkFolderPath, m_workFolderPath);
	// whm added 26Mar12.
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (m_bAdminMenuRemoved)
	{
		// can't do it if the menu is not attached
		event.Enable(FALSE);
		return;
	}
	if (!m_bAdminMenuRemoved)
	{
		// the menu is showing

		// don't enable if the m_customWorkFolderPath is empty string
		if (m_customWorkFolderPath.IsEmpty())
		{
			event.Enable(FALSE);
			return;
		}
		// don't enable the menu item if the work folder and custom work folder are one
		// and the same
		if (m_workFolderPath == m_customWorkFolderPath)
		{
			event.Enable(FALSE);
			return;
		}
		// otherwise, returning to the default work folder location is possible because
		// the application is pointing at some other work folder - provided
		// m_UseCustomWorkFolderPath is TRUE, so allow user to choose it if so (we ignore
		// the m_bLockedCustomWorkFolderPath flag, allowing Restore Default Work Folder
		// Location and / or Unlock Custom Location commands to be active with the same
		// protocol
		if (m_bUseCustomWorkFolderPath)
		{
			event.Enable(TRUE);
		}
		else
		{
			// not using a custom path
			event.Enable(FALSE);
		}
	}
}

// handler for the Restore Default Work Folder Location command
void CAdapt_ItApp::OnRestoreDefaultWorkFolderLocation(wxCommandEvent& WXUNUSED(event))
{
	LogUserAction(_T("Initiated OnRestoreDefaultWorkFolderLocation()"));
	//wxLogDebug(_T("STARTING....  m_workFolderPath = %s  flag = %d"), m_workFolderPath.c_str(), (int)m_bUseCustomWorkFolderPath);
	//wxLogDebug(_T("1  m_curAdaptionsPath = %s "), m_curAdaptionsPath.c_str());

	m_bFailedToRemoveCustomWorkFolderLocationFile = FALSE; // ensure we start with the default value
	wxASSERT(m_bUseCustomWorkFolderPath);

	// the user may have a persistent custom work folder location set, and not bothered to
	// use the Unlock Custom Location command first, to make that location non-persistent,
	// so we must check for that now and do it for him here, or he may have tried it and
	// it failed. So if m_bLockedCustomWorkFolderPath is still TRUE, we will call
	// OnUnlockCustomLocation() here, and then if the flag
	// m_bFailedToRemoveCustomWorkFolderLocationFile is TRUE we'll know the attempt to
	// make the custom location non-peprsistent failed, (a message in English will be
	// shown too, so we don't need an extra one here) and so we'll use the flag to
	// suppress the attempt to restore the default work folder location. (The developer
	// should then fix the problem. But if necessary, manual deletion of the
	// CustomWorkFolderLocation file can be done with WinExplorer or equivalent, and that
	// would make the location non-persistent on next launch.)
	if (m_bLockedCustomWorkFolderPath)
	{
		// custom work folder location is still persistent, so help the user out by making
		// it non-persistent on his behalf (this will set or clear the flag
		// m_bFailedToRemoveCustomWorkFolderLocationFile if the call here fails or
		// succeeds, respectively
		wxCommandEvent dummyevent;
		OnUnlockCustomLocation(dummyevent); // also deletes CustomWorkFolderLocation file
	}

	if (!m_bFailedToRemoveCustomWorkFolderLocationFile)
	{
        // the m_bLockedCustomWorkFolderPath flag is FALSE, and the
        // CustomWorkFolderLocation file no longer exists on disk, so do the rest of the
        // actions required for restoring the default work folder location as the current
        // and persistent work folder location (the administrator should have moved current
        // project folders there beforehand, from the custom location; but if he didn't,
        // then it could be done manually in the OS's file manager app, such as Windows
        // Explorer - unless a default work folder location with no project folders in it
        // is what he wants to achieve)
		GetView()->CloseProject(); // calls protected view member OnFileCloseProject()

		//wxLogDebug(_T("2  m_workFolderPath = %s  flag = %d"), m_workFolderPath.c_str(), (int)m_bUseCustomWorkFolderPath);
		//wxLogDebug(_T("2  m_curAdaptionsPath = %s "), m_curAdaptionsPath.c_str());

		m_customWorkFolderPath.Empty();
		m_bUseCustomWorkFolderPath = FALSE;
		bool bIsValid = IsValidWorkFolder(m_workFolderPath);

		//wxLogDebug(_T("3  m_workFolderPath = %s  flag = %d"), m_workFolderPath.c_str(), (int)m_bUseCustomWorkFolderPath);
		//wxLogDebug(_T("3  m_curAdaptionsPath = %s "), m_curAdaptionsPath.c_str());
		if (bIsValid)
		{
			::wxSetWorkingDirectory(m_workFolderPath);
			// MUST call EnsureWorkFolderPresent() before calling
			// MakeForeignBasicConfigFileSafe(), if it isn't called then
			// m_localPathPrefix string is left with the remote work folder's path and we get
			// wrong paths set up, and a crash (I'll see if I can remove the use of
			// m_localPathPrefix at the custom location, that will be added protection -- yes,
			// I did that)
			EnsureWorkFolderPresent();	// <- this call should not now be needed, because
										// m_localPathPrefix is not now reset when setting
										// up for a custom work folder location, and so that
										// variable should still be valid; however, calling
										// it will ensure its validity so I've left it here
			wxString configFName = szBasicConfiguration + _T(".aic");
			wxString adminConfigFName = szAdminBasicConfiguration + _T(".aic");
			MakeForeignBasicConfigFileSafe(configFName,m_workFolderPath,&adminConfigFName);
			//wxLogDebug(_T("4  m_workFolderPath = %s  flag = %d"), m_workFolderPath.c_str(), (int)m_bUseCustomWorkFolderPath);
			//wxLogDebug(_T("4  m_curAdaptionsPath = %s "), m_curAdaptionsPath.c_str());
		}
		else
		{
			// don't expect this, so do the from-first-principles way
			EnsureWorkFolderPresent();

			//wxLogDebug(_T("5  m_workFolderPath = %s  flag = %d"), m_workFolderPath.c_str(), (int)m_bUseCustomWorkFolderPath);
			//wxLogDebug(_T("5  m_curAdaptionsPath = %s "), m_curAdaptionsPath.c_str());

			SetupDirectories(); // also sets KB paths and loads KBs & Guesser

			//wxLogDebug(_T("6  m_workFolderPath = %s  flag = %d"), m_workFolderPath.c_str(), (int)m_bUseCustomWorkFolderPath);
			//wxLogDebug(_T("6  m_curAdaptionsPath = %s "), m_curAdaptionsPath.c_str());
		}

		// restore administrator's former local basic configuration settings
		GetBasicConfiguration();

		//wxLogDebug(_T("7  m_workFolderPath = %s  flag = %d"), m_workFolderPath.c_str(), (int)m_bUseCustomWorkFolderPath);
		//wxLogDebug(_T("7  m_curAdaptionsPath = %s "), m_curAdaptionsPath.c_str());

		// run the wizard, so that the administrator can access projects & their documents at
		// the custom work folder's location
		wxCommandEvent dummyevent;
		pStartWorkingWizard = (CStartWorkingWizard*)NULL;
		DoStartWorkingWizard(dummyevent); // ignore returned TRUE, FALSE is never returned
	} // end of TRUE block for test: if (!m_bFailedToRemoveCustomWorkFolderLocationFile)
	RefreshStatusBarInfo();
}

bool CAdapt_ItApp::SetupCustomWorkFolderLocation()
{
	//wxLogDebug(_T("STARTING....  m_workFolderPath = %s  flag = %d"), m_workFolderPath.c_str(), (int)m_bUseCustomWorkFolderPath);

	// give the user a folder browser to locate a valid work folder. If he selects a
	// folder which is not a valid work folder, warn him and do nothing, just reinstate
	// the existing default location or current custom work folder location, and allow him
	// to call the function again to have another go; but if he chooses the same or
	// different work folder location and it is a valid work folder, accept it and set it
	// up as the currently pointed at active work folder
	wxString strSaveCurrentCustomWorkFolder = m_customWorkFolderPath;
	bool	 bSaveUsageFlag = m_bUseCustomWorkFolderPath;
	wxString saveCurWorkingDir;

	saveCurWorkingDir = ::wxGetCwd(); // whm added 10Jun11

	/*
	// whm changed 10Jun11. I've relocated the CloseProject() below down further in the
	// function to allow for the user being able to cancel out of the LocateCustomWorkFolder()
	// function and not have his project and document closed

	// the current project, if one is open, and or and open doc, can't stay open when the
	// work folder location is changed, so close doc and project
	GetView()->CloseProject(); // calls protected view member OnFileCloseProject()
	*/

	//wxLogDebug(_T("1  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);

	// get a default folder to start searching from - what we get will depend on whether
	// we already have a custom location in effect, or are at the default location
	bool bGotFolder = FALSE;
	wxString default_path;
	if (m_bUseCustomWorkFolderPath)
	{
		// if the flag was TRUE, the m_customWorkFolderPath member should contain a valid
		// path to a custom location for a valid work folder, but we must allow for the
		// possibility of internal error and the member may be an empty string - if so,
		// we'll set a default folder from which the user can commence looking for his
		// desired work folder
		if (m_customWorkFolderPath.IsEmpty())
		{
			//wxLogDebug(_T("2  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);

			// use standard documents directory - in portable way using the wxWidgets
			// class wxStandardPaths (code plagiarized from EnsureWorkFolderPresent())
a:			wxString stdDocsDir = _T("");
			wxStandardPaths stdPaths;
//			#ifdef __WXMAC__
			// whm note 18Jun09: the wxStandardPaths::GetDocumentsDir() is probably causing program
			// crash when compiled for Mac OS X 10.3 Panther, so I'm using the older
			// ::wxGetHomeDir() function for the Mac which should return the same directory string
			// on the Mac that wxStandardPaths::GetDocumentsDir() does.
			// GDLC 29Sep11 Not needed now that we are not targeting MacOS Panther or PPC.
//			stdDocsDir = ::wxGetHomeDir();
//			#else
			stdDocsDir = stdPaths.GetDocumentsDir(); // The GetDocumentsDir() function
												// is new since wxWidgets version 2.7.0
//			#endif
			// Typically the "documents" directory depends on the system:
			// Unix: ~/(the home directory, i.e., /home/<username>/)
			// Windows (earlier and Vista): C:\Documents and Settings\username\Documents
			// Windows (2000 and XP): C:\Documents and Settings\username\My Documents
			// Mac: ~/(the home directory, i.e., /Users/<username>/

            // whm note: In the cross-platform version we never refer to a specific
            // "Documents" or "My Documents" folder and so we do not need to localize
            // the name of the folder that is returned by the "GetDocumentsDir()
            // function call.
			//
            // Set the current working directory to point to the standard docs
            // directory which would normally be the "Documents" or "My Documents"
            // folder on Windows, the ~ (home directory) on Linux, or the ~/Documents
            // directory on the Mac.
			default_path = stdDocsDir; // one wasn't set, so use documents dir
			::wxSetWorkingDirectory(stdDocsDir);

			//wxLogDebug(_T("3  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);
		}
		else
		{
			// the m_customWorkFolderPath has content, so we'll assume it is a valid
			// path on the machine - that should be the case, unless the user has removed
			// or renamed one or more directories in the path while AI has been running,
			// which is pretty unlikely
			bool bExists = wxDir::Exists(m_customWorkFolderPath);
			// if the directory does not exist, use the code above for a valid path to a
			// directory from which to start searching
			if (!bExists)
				goto a;
			default_path = m_customWorkFolderPath; // the current one, if there is one
			::wxSetWorkingDirectory(default_path);

			//wxLogDebug(_T("4  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);
		}
	}
	else
	{
        // a custom path is not in use, so this should mean that the legacy location is
        // valid -- possibly redirected to a different partition or drive - but that should
        // not give a problem here because other functions will have set up the legacy
        // location's path already - but we'll check the path is actually a path to a
        // directory and if not we'll use the code above instead
		bool bExists = wxDir::Exists(m_customWorkFolderPath);
		if (!bExists)
			goto a;
		default_path = m_workFolderPath;
		::wxSetWorkingDirectory(default_path);

		//wxLogDebug(_T("5  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);
	}
	wxString workFolderPath;
	bool bWasCancelled = FALSE;
	bGotFolder = LocateCustomWorkFolder(default_path, workFolderPath, bWasCancelled);

	//wxLogDebug(_T("6  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);

	if (!bGotFolder)
	{
		if (bWasCancelled)
		{
            // assume a cancel means cancel from the whole attempt, so restore whatever was
            // the earlier work folder location - whether legacy location or a custom
            // location

			// whm added 10Jun11 to better handlel a Cancel from LocateCustomWorkFolder()
			// above.
			// restore custom work folder to saved state
			m_bUseCustomWorkFolderPath = bSaveUsageFlag;
			m_customWorkFolderPath = strSaveCurrentCustomWorkFolder;
			// restore the saved working dir
			::wxSetWorkingDirectory(saveCurWorkingDir);


			// ** TODO **   call OnLocalWorkFolder() ?? actually it could be one of
			// several possibilities, depending on whether administrator is local or
			// remote and whether a path is currently locked or not, or whether the
			// default location on local machine is current or not...
			wxString msg = _T("Cancelled block: default_path was = %s  cancelled flag = %d  MORE TO DO HERE!!");
			msg = msg.Format(msg, m_workFolderPath.c_str(), (int)bWasCancelled);
			wxLogDebug(msg);
			//OnLocalWorkFolder(); // force re-establish of default?? Nah, too simple, see above
			LogUserAction(msg);
			return FALSE;

		}
		else
		{
			// Bill suggests this block should ask the user what to do. Either cancel, or try
			// a different folder -- implement these options.


			// ** TODO **  first shot at it in code below - check it is enough

			// a valid work folder location was not obtained, so warn the user and let him try
			// again
			m_bUseCustomWorkFolderPath = bSaveUsageFlag;
			m_customWorkFolderPath = strSaveCurrentCustomWorkFolder;
			wxString msg1 = _("You failed to locate a valid work folder. Please try again.");
			wxMessageBox(msg1,_T(""),wxICON_WARNING);
			LogUserAction(msg1);
			// check the former location is valid as a work folder, if not set up the default
			// path
			if (m_bUseCustomWorkFolderPath)
			{
				bool bExists = wxDir::Exists(m_customWorkFolderPath);
				if (!bExists)
				{
					// not a folder on the system, so use default location
					// which m_workFolderPath already points at
					m_bUseCustomWorkFolderPath = FALSE;
					m_customWorkFolderPath = _T("");
				}
				else
				{
					// it's a folder on the system, but is it a valid work folder?
					bool bIsValid = IsValidWorkFolder(m_customWorkFolderPath);
					if (!bIsValid)
					{
						// not a work folder, so we have to use default location
						// which m_workFolderPath already points at
						m_bUseCustomWorkFolderPath = FALSE;
						m_customWorkFolderPath = _T("");
					}
					else
					{
						// this path is to a valid custom work folder location, so use it
						; // nothing more to do
					}
				}
			}
		} // end of else block for bWasCancelled test
	}
	else
	{
		// a valid work folder location was obtained, so use it. It can be the same as the
		// earlier one which was in effect at entry, or a different one.
		m_bUseCustomWorkFolderPath = TRUE;
		m_customWorkFolderPath = workFolderPath;

		// whm added 12Aug11.
		// The administrator has just successfully slected a folder to be used as a
		// custom work folder. I think we should ask the administrator at this point
		// if his intent is that this custom work folder be locked in or not. Otherwise
		// if he forgets to tick the Administrator item "Lock Custom Location"
		// afterwards, he (or the MTT) may be dismayed to find out that the custom
		// work folder is not being used after it was set up. This is the way the
		// Load Consistent Changes... and "Use Consistent Changes" menu items work.
		wxString msg;
		msg = _("You have selected the following folder to be used as a custom work folder:\n\n%s\n\nDo you want this custom work folder to be \"locked\" so that it becomes the user's permanent work folder?");
		msg = msg.Format(msg,m_customWorkFolderPath.c_str());
		int response = wxMessageBox(msg,_T("Is this custom work folder permanent or temporary?"),wxICON_QUESTION | wxYES_NO);
		if (response == wxYES)
		{
			LogUserAction(_T("Lock custom work folder"));
			wxCommandEvent dummyEvent;
			OnLockCustomLocation(dummyEvent);
		}
		else
		{
			LogUserAction(_T("Temporary custom work folder"));
		}
	}

	// whm 10Jun11 moved CloseProject() here from above.
	// the current project, if one is open, and or and open doc, can't stay open when the
	// work folder location is changed, so close doc and project
	GetView()->CloseProject(); // calls protected view member OnFileCloseProject()


	//wxLogDebug(_T("7  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);

	// if the user has made the legacy default location the "custom" one, then revert to
	// having the m_bUseCustomWorkFolderPath flag cleared to FALSE, and use the legacy
	// location as normal
	if (m_bUseCustomWorkFolderPath)
	{
		if (m_customWorkFolderPath == m_workFolderPath)
		{
			// the two locations are the same, so revert to the standard situation...

			// the user may have a persistent custom work folder location set, and not bothered to
			// use the Unlock Custom Location command first, to make that location non-persistent,
			// so we must check for that now and do it for him here, or he may have tried it and
			// it failed. So if m_bLockedCustomWorkFolderPath is still TRUE, we will call
			// OnUnlockCustomLocation() here, and then if the flag
			// m_bFailedToRemoveCustomWorkFolderLocationFile is TRUE we'll know the attempt to
			// make the custom location non-peprsistent failed, (a message in English will be
			// shown too, so we don't need an extra one here) and so we'll use the flag to
			// suppress the attempt to restore the default work folder location. (The developer
			// should then fix the problem. But if necessary, manual deletion of the
			// CustomWorkFolderLocation file can be done with WinExplorer or equivalent, and that
			// would make the location non-persistent on next launch.)
			if (m_bLockedCustomWorkFolderPath)
			{
				// custom work folder location is still persistent, so help the user out by making
				// it non-persistent on his behalf (this will set or clear the flag
				// m_bFailedToRemoveCustomWorkFolderLocationFile if the call here fails or
				// succeeds, respectively
				wxCommandEvent dummyevent;
				OnUnlockCustomLocation(dummyevent); // also deletes CustomWorkFolderLocation file
			}

			// if a persistent custom work folder location is defined and the above
			// OnUnlockCustomLocationa() call failed to do its job (in particular, to
			// remove the CustomWorkFolderLocation file from the default work folder
			// location) then we don't want to restore the work folder to the default
			// location, so the appropriate thing to do would be to continue processing
			// without clearing m_bUseCustomWorkFolderPath to FALSE, and setting
			// m_customWorkFolderPath to be the empty string -- (the developer should be
			// notified as we don't expect a failure in removal of a small text file)
			if (!m_bFailedToRemoveCustomWorkFolderLocationFile)
			{
				m_bUseCustomWorkFolderPath = FALSE;
				m_customWorkFolderPath.Empty();
			}
			//wxLogDebug(_T("8  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);
		}
	}

	//OnInit(); // <--- must not call this

	EnsureWorkFolderPresent();

	//wxLogDebug(_T("9  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);

    // the basic config file at the new location will be 'foreign', from someone else's
    // adaptation work on another machine, check and fix any bad path names (actually, only
    // 5 of them need to be potentially fixed, the others won't crash anything because of
    // fail-safe code elsewhere in the app) and save the modified config file to a file
    // with unique name (AI-AdminBasicConfiguration.aic) which is used only by the
    // administrator (or a user with administrator privileges)
	wxString configFName = szBasicConfiguration + _T(".aic");
	wxString adminConfigFName = szAdminBasicConfiguration + _T(".aic");
	// use m_workFolderPath here, whether or not a custom folder location is
	// being set up, since we store the Admin basic config file on the
	// administrator's machine's default work folder location, as we do
	// the normal basic config file
	MakeForeignBasicConfigFileSafe(configFName,m_workFolderPath,&adminConfigFName);

	/* BEW removed 6Nov09, as 3rd argument is now obligatory, even if unused within
	if (m_bUseCustomWorkFolderPath)
	{
		// use m_workFolderPath here, since we store the Admin basic config file on the
		// administrator's machine's default work folder location
		MakeForeignBasicConfigFileSafe(configFName,m_workFolderPath,&adminConfigFName);
		//wxLogDebug(_T("10  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);
	}
	else
	{
		MakeForeignBasicConfigFileSafe(configFName,m_workFolderPath,&adminConfigFName);
		//wxLogDebug(_T("11  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);
	}
	*/
	// we make no use of the returned bMadeSafe flag, because OnCustomWorkFolderLocation
	// should only return a value of TRUE; it's only when the custom location is on an
	// external drive and the user has forgotten to mount it, that in OnInit() just after
	// AI is launched, a FALSE value would be returned, and that's where we need to make
	// use of that fact

    // now that the basic config file, whether foreign or not, and whether at the default
    // location or the custom location, is made safe for use, read it in and set up the app
    // for work folder access
	GetBasicConfiguration(); // distinguishes between custom & default locations
				// internally, and for custom locations, it distinguishes between
				// a persistent versus a non-persistent custom location

	//wxLogDebug(_T("12  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);
	// setup succeeded, so return TRUE
	return TRUE;
}

void CAdapt_ItApp::OnCustomWorkFolderLocation(wxCommandEvent& WXUNUSED(event))
{
	LogUserAction(_T("Initiated OnCustomWorkFolderLocation()"));
	bool bSetupSucceeded = SetupCustomWorkFolderLocation();

	if (bSetupSucceeded)
	{
		// run the wizard, so that the administrator can access projects & their documents at
		// the custom work folder's location
		wxCommandEvent dummyevent;
		pStartWorkingWizard = (CStartWorkingWizard*)NULL;
		DoStartWorkingWizard(dummyevent); // ignore returned TRUE, FALSE is never returned
	}
	//wxLogDebug(_T("END  m_workFolderPath = %s  flag = %d"), m_workFolderPath, (int)m_bUseCustomWorkFolderPath);
	RefreshStatusBarInfo();
}

// \return     TRUE if the path passed in begins with either pair of backslashes,
//             or a pair of forward slashes
// \remarks    Use a TRUE returned value to disable the Administrator menu's command "Lock
// Custom Location", because if the path is a URI then Adapt It is being pointed at a
// remote machine, and our code cannot make a custom work folder location on a remote
// machine be persistent - that has to be done from the local machine only
bool CAdapt_ItApp::IsURI(wxString& uriPath)
{
	bool bURI = FALSE;
	if (uriPath.IsEmpty())
		return FALSE;
	wxString uriBack = _T('\\');
	uriBack += uriBack;
	wxString uriForward = _T("//");
	bURI = uriPath.Find(uriBack) == 0;
	if (bURI)
		return TRUE; // it's "\\"
	bURI = uriPath.Find(uriForward) == 0;
	if (bURI)
		return TRUE; // it's "//"
	return FALSE;
}

void CAdapt_ItApp::OnUpdateLockCustomLocation(wxUpdateUIEvent& event)
{
	// whm added 26Mar12.
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (m_bAdminMenuRemoved)
	{
		// can't do it if the menu is not attached
		event.Enable(FALSE);
		return;
	}
	if (!m_bAdminMenuRemoved)
	{
		// the menu is showing
		bool bURI = IsURI(m_customWorkFolderPath);

		// don't enable the menu item if the custom work folder path is a URI
		// specification, or if the path is empty, or if the default path and the
		// custom path are the same
		if (m_customWorkFolderPath.IsEmpty() || m_customWorkFolderPath == m_workFolderPath)
		{
			event.Enable(FALSE);
			return;
		}
		if (bURI)
		{
			event.Enable(FALSE);
			return;
		}
		else
		{
			// the application is pointing at some other work folder than the default, and
			// it is not a folder on a remote machine, and not an empty path, so allow the
			// user to choose it - provided a path is not already locked in
			if (m_bLockedCustomWorkFolderPath)
			{
				// a custom path is locked in already, so disable the menu item
				event.Enable(FALSE);
				return;
			}
			else
			{
				// not yet locked, so allow it to be locked
				event.Enable(TRUE);
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event         -> the event is not used, except to trigger this handler
/// \remarks
/// Puts the custom work folder path in the file "CustomWorkFolderLocation" and stores the
/// file in the default work folder on the host machine (ie. the one running the AI
/// instance) and turns on the m_bLockedCustomWorkFolderPath flag. Then normal and admin
/// configuration file names are constructed, and they plus the custom work folder path
/// are parameters to a call to MakeForeignBasicConfigFileSafe() in order to construct a
/// valid basic configuration file at the custom work folder location to be used
/// thereafter for as long as that location remains the work folder location currently
/// used.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnLockCustomLocation(wxCommandEvent& event)
{
	// whm Note: Only log user action when user explicitly selectd the
	// "Lock Custom Location" menu item, not when OnLockCustomLocation()
	// is called by other functions.
	if (event.GetId() == ID_LOCK_CUSTOM_LOCATION)
	{
		LogUserAction(_T("Initiated OnLockCustomLocation()"));
	}

	m_bFailedToRemoveCustomWorkFolderLocationFile = FALSE; // ensure default value is in
								// effect before OnUnlockCustomLocation() can be called
	// a) get the absolute path to the custom work folder
	// b) put it in a file called CustomWorkFolderLocation
	// c) store that file in the default work folder location (i.e. the
	// one that m_workFolderPath points at, even if nothing else is there)
	bool bOK;
	wxFile f; // create a wxFile instance with default constructor

	wxLogNull logNo; // avoid spurious messages from the system

	bOK = ::wxSetWorkingDirectory(m_workFolderPath); // the default work folder location
	if (!bOK)
	{
		// only need a message for the developer here, once debugged this
		// shouldn't fail
		wxMessageBox(_T(
		"Failed to set the current working directory to default work folder location. Aborting..."),
		_T(""), wxICON_ERROR);
		LogUserAction(_T("Failed to set the current working directory to default work folder location in OnLockCustomLocation(). Aborting..."));
		// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
		wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
		return;
	}
	wxString theFilename = _T("CustomWorkFolderLocation"); // a hard-coded name, we
														   //don't want this localized
	// open the file for writing, & if it already exists, clear it's contents too
	if (!f.Open(theFilename,wxFile::write))
	{
		// don't expect a failure, but if we get one, just tell the developer & abort
		wxMessageBox(_T(
		"Failed to open the CustomWorkFolderLocation file at default work folder location. Aborting..."),
		_T(""), wxICON_ERROR);
		LogUserAction(_T("Failed to open the CustomWorkFolderLocation file at default work folder location in OnLockCustomLocation(). Aborting..."));
		// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
		wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
		return;
	}
	// save the custom path string to the file, but if the custom path is empty,
	// tell the developer and abort
	if (m_customWorkFolderPath.IsEmpty())
	{
		wxMessageBox(_T(
			"Making paths safe: m_customWorkFolderPath is empty when trying to save it to CustomWorkFolderLocation file. Aborting..."),
		_T(""), wxICON_ERROR);
		LogUserAction(_T("Making paths safe: m_customWorkFolderPath is empty when trying to save it to CustomWorkFolderLocation file. Aborting..."));
		// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
		wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
		return;
	}
	else
	{
		f.Write(m_customWorkFolderPath); // in Unicode build, converts
										 // contents to UTF-8 before writing
	}
	f.Close(); // close the created file with the custom path within it

	// the menu command is disabled if the flag is true, so since this handler can only be
	// called fwhen the flag is false, we unilaterally set it now
	m_bLockedCustomWorkFolderPath = TRUE;

	// now construct the names for basic and administrator basic config files, and make
	// the needed basic config file at the custom location, with fixed critical paths
	wxString configFName = szBasicConfiguration + _T(".aic");
	wxString adminConfigFName = szAdminBasicConfiguration + _T(".aic");
	MakeForeignBasicConfigFileSafe(configFName,m_customWorkFolderPath,&adminConfigFName);
	RefreshStatusBarInfo();
}

void CAdapt_ItApp::OnUpdateUnlockCustomLocation(wxUpdateUIEvent& event)
{
	// whm added 26Mar12.
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (m_bAdminMenuRemoved)
	{
		// can't do it if the menu is not attached
		event.Enable(FALSE);
		return;
	}
	if (!m_bAdminMenuRemoved)
	{
		// the menu is showing
		if (m_bLockedCustomWorkFolderPath)
		{
			// the application has a locked path currently
			bool bURI = IsURI(m_customWorkFolderPath);
			if (bURI)
			{
				// the administrator does not have permission to unlock a permanent path
				// set up already on a remote machine; she can only do it from that
				// machine itself - which is a reasonable constraint, otherwise a remote
				// person could lock out a remote user from his or her data remotely
				// without their knowledge, which would be naughty in the extreme
				event.Enable(FALSE);
			}
			else
			{
				// administrator is on the machine which has the locked path, so is
				// authorized to unlock it
				event.Enable(TRUE);
			}
			return;
		}
		else
		{
			// the application doesn't have a locked path currently
			event.Enable(FALSE);
		}
	}
}

void CAdapt_ItApp::OnUnlockCustomLocation(wxCommandEvent& event)
{
	if (event.GetId() == ID_UNLOCK_CUSTOM_LOCATION)
	{
		LogUserAction(_T("Initiated OnUnlockCustomLocation()"));
	}
	wxLogDebug(_T("m_bLockedCustomWorkFolderPath = %d"),m_bLockedCustomWorkFolderPath);
	wxString customPathFilename = _T("CustomWorkFolderLocation"); // must NOT be localizable
	wxString aPath = m_workFolderPath + PathSeparator + customPathFilename;
	bool bIsCustomLocationPersistent = ::FileExists(aPath);
	if (bIsCustomLocationPersistent)
	{
		// make the custom location non-persistent (all that is needed is to remove from
		// the default work folder location the file called "CustomWorkFolderLocation" and
		// set the m_bLockedCustomWorkFolderPath to FALSE. No change is made to
		// m_bUseCustomWorkFolderPath boolean, which remains TRUE, nor is
		// m_customWorkFolderPath made empty, which means that the work folder at the
		// custom location remains in effect until one of the the following happens:
		// 1. the user, in the current session, reinstates the persistence of the current
		// custom work folder location by clicking the Administrator menu item Lock Custom
		// Location, or
		// 2. the session ends (ie. the user exits from Adapt It) - in this case, to
		// reinstate the persistence of this custom work folder location would require use
		// of the Administrator menu command Custom Work Folder Location and navigating in
		// that command's folder dialog to the relevant custom work folder, and then
		// making the location persistent again using the Lock Custom Location command. If
		// this is not done at the new session, then access to this custom location is
		// only available via the Administrator menu and lasts only for the length of the
		// new session.
		bool bRemovedOK = ::wxRemoveFile(aPath);
		if (bRemovedOK)
		{
			// only make the custom location non-persistent provided the
			// CustomWorkFolderLocation file was genuinely removed from disk. If not, the
			// location should remain persistent. Give the developer an error message
			// here, in English should suffice, because we don't expect the removal to fail,
			// and the developer would need to figure why the failure happened and fix it
			m_bLockedCustomWorkFolderPath = FALSE;
			m_bFailedToRemoveCustomWorkFolderLocationFile = FALSE;
		}
		else
		{
			m_bFailedToRemoveCustomWorkFolderLocationFile = TRUE; // the command
				// Restore Default Work Folder will need to know this failure happened
				// so as to block the restoration if the custom work folder location could
				// not be made non-persistent
			wxMessageBox(_T(
				"OnUnlockCustomLocation(): Failed to remove the CustomWorkFolderLocation file at default work folder location. The custom work folder location remains persistent. Developer must fix this problem. Adapt It now continues to run with full functionality."),
			_T(""), wxICON_ERROR);
			LogUserAction(_T("OnUnlockCustomLocation(): Failed to remove the CustomWorkFolderLocation file at default work folder location. The custom work folder location remains persistent. Developer must fix this problem. Adapt It now continues to run with full functionality."));
		}
	}
	RefreshStatusBarInfo();
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \remarks	Catches wxTimerEvent when m_timer is running. For each timer event it calls
/// CheckLockFileOwnership().
/// This OnTimer() handler is only called at 2 second intervals while the current instance
/// of Adapt It owns a project folder on a remote computer. It does not get called in other
/// circumstances. Its purpose is to enable automatic switching of the current instance to
/// read-only mode in the event that an Instance of Adapt It local to that remote computer
/// acquires write acces to its project folder.
///////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnTimer(wxTimerEvent& WXUNUSED(event))
{
	CheckLockFileOwnership();
}

void CAdapt_ItApp::CheckLockFileOwnership()
{
	// The App class holds the m_pROP pointer to the ReadOnlyProtection object, so we can
	// call m_pROP's public methods from here.
	// Get the
	//wxString ropFile = m_pROP->GetReadOnlyProtectionFileInProjectFolder(m_curProjectPath);
	if (m_pROP->IsItNotMe(m_curProjectPath))
	{
		if (!m_bReadOnlyAccess)
		{
			m_timer.Stop();
			m_bReadOnlyAccess = TRUE;
			// force a refresh of the main window so it changes to pink
			GetView()->canvas->Refresh(); // force color change to pink
			wxMessageBox(
	_("Someone just opened the project folder on the remote computer, so you have READ-ONLY access."),_("Another process owns write permission"),
			wxICON_INFORMATION);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pathType            -> an enum, either defaultPathsFix, or customPathsFix
/// \param      pf                  -> pointer to an opened wxTextFile for the config file
/// \param      basePath            -> reference to the part of the path up to the work
///                                    folder when processing for a default folder
///                                    location, but to whatever follows the tab in the
///                                    szAdaptitPath line of the config file when
///                                    processing a custom folder location
/// \param      localPath           -> whatever is the work folder path on the local
///                                    machine (usually same as basePath, but because of
///                                    the possibility of using someone else's config
///                                    file, and the possibility of pointing the app at a
///                                    custom location anywhere, it could be different)
/// \remarks
/// BEW created 23aSept09 in support of custom work folder locations, to separate the
/// actual path fixing from the code which determines just what the calling context's
/// state is and what therefore has to be done. Called only from within
/// MakeForeignBasicConfigFileSafe().
/// Note: m_workFolderPath always is the default work folder location on the host machine,
/// and so when calling FixBasicConfigPaths for a basic config file stored at a persistent
/// custom work folder location, we must retain the m_workFolderPath value unchanged, even
/// though the code does calculations based on the custom path passed in in both basePath
/// and localPath parameters - but the calculations are to get an offset only, which is
/// used subsequently for making safe the other 4 critical paths.
////////////////////////////////////////////////////////////////////////////////////////

void CAdapt_ItApp::FixBasicConfigPaths(enum ConfigFixType pathType, wxTextFile* pf,
						wxString& basePath, wxString& localPath)
{
	wxString tab = _T('\t');
	wxString fileLine;
	int basePathLength = 0; // set it at szAdaptitPath line, the use that value for
							// subsequent critical path lines
	switch (pathType)
	{
	case customPathsFix:
		// scan the in-memory file line-by-line and process those needing path updates
		for ( fileLine = pf->GetFirstLine(); !pf->Eof(); fileLine = pf->GetNextLine() )
		{
			wxString subFoldersPath = _T("");	// for the part of the path to the
												// right of m_theCustomWorkFolder
			int nStartOfSubFoldersPath;
			int strLength;
			if(fileLine.Find(szAdaptitPath) != wxNOT_FOUND)
			{
				// whm modified 10Jun11 to correct the logic in this block below.
				// The problem is this: The incoming parameter basePath is set by its calling
				// code to be based on the App's m_customWorkFolderPath because we are
				// currently dealing with a customPathsFix. We cannot safely reset the
				// incoming basePath to the string value associated with AdaptItPath in
				// the basic config file now being read because by design AdaptItPath is
				// never going to be anything but the default path. Therefore I've commented
				// out the three lines below which can result in a garbled path being
				// assigned to the four critical paths in the else if blocks below.
				//
				// [original comment below:]
				// we're at a line with "AdaptItPath" in it that we want to adjust; here
				// we must set basePath to whatever follows the tab character, as that
				// will be used in the other critical lines as the path to the work folder
				// and it is not necessarily the same path as in folderPath which was
				// passed in
				//int offsetToTab = fileLine.Find(tab);
				//wxASSERT(offsetToTab > 0);
				//basePath = fileLine.Mid(offsetToTab + 1); // "AdaptItPath MUST precede the
				//										  // other critical paths in the
				//										  // basic configuration file or
				//										  // our code for setting correct
				//										  // paths will break. ***NOTE***
				basePathLength = basePath.Len();
				wxASSERT(basePathLength > 0);

				// we now have basePathLength which we need in subsequent blocks below;
				// and while the szAdaptitPath line is probably correct as is, we'll
				// rebuild it using the known m_workFolderPath value to ensure it stays
				// correct and unchanged
				fileLine = szAdaptitPath + tab + m_workFolderPath; // make the fixed fileLine string
				size_t lineNum = pf->GetCurrentLine(); // get the line number
				pf->RemoveLine(lineNum); // remove the old line from the in-memory file
				pf->InsertLine(fileLine, lineNum); // replace it with the fixed line
			}
			else if (fileLine.Find(szCurLanguagesPath) != wxNOT_FOUND)
			{
				// we're at a line with "ProjectFolderPath" in it that we want to adjust
				// ... get the offset to the path separator following basePath
				nStartOfSubFoldersPath = fileLine.Find(basePath) + basePathLength;
				strLength = fileLine.Len();
				subFoldersPath = fileLine.Right(strLength - nStartOfSubFoldersPath);
				if (!subFoldersPath.IsEmpty())
				{
					// We don't know whether the subFoldersPath has \ or / separators so
					// we'll change both to the native one (PathSeparator) The default
					// behavior of the wxString::Replace method is to replace all.
					int NumReplacements = subFoldersPath.Replace(_T("/"),PathSeparator);
					NumReplacements = subFoldersPath.Replace(_T("\\"),PathSeparator);
					NumReplacements = NumReplacements; // avoid compiler warning (leave as is, BEW 2Jan12)
				}
				// build the required administrator's config file path for this line
				fileLine = szCurLanguagesPath + tab + localPath + subFoldersPath; // the fix
				size_t lineNum = pf->GetCurrentLine();
				pf->RemoveLine(lineNum);
				pf->InsertLine(fileLine, lineNum);
			}
			else if (fileLine.First(szCurAdaptionsPath) != -1)
			{
				// we're at a line with "DocumentsFolderPath" in it that we want to
				// adjust
				nStartOfSubFoldersPath = fileLine.Find(basePath) + basePathLength;
				strLength = fileLine.Length();
				subFoldersPath = fileLine.Right(strLength - nStartOfSubFoldersPath);
				if (!subFoldersPath.IsEmpty())
				{
					// We don't know whether the subFoldersPath has \ or / separators so
					// we'll change both to the native one (PathSeparator) The default
					// behavior of the wxString::Replace method is to replace all.
					int NumReplacements = subFoldersPath.Replace(_T("/"),PathSeparator);
					NumReplacements = subFoldersPath.Replace(_T("\\"),PathSeparator);
					NumReplacements = NumReplacements; // avoid compiler warning (leave as is, BEW 2Jan12)
				}
				// build the required administrator's config file path for this line
				fileLine = szCurAdaptionsPath + tab + localPath + subFoldersPath;
				size_t lineNum = pf->GetCurrentLine();
				pf->RemoveLine(lineNum);
				pf->InsertLine(fileLine, lineNum);
			}
			else if (fileLine.First(szCurKBPath) != -1)
			{
				// we're at a line with "KnowledgeBasePath" in it that we want to
				// adjust
				nStartOfSubFoldersPath = fileLine.Find(basePath) + basePathLength;
				strLength = fileLine.Length();
				subFoldersPath = fileLine.Right(strLength - nStartOfSubFoldersPath);
				if (!subFoldersPath.IsEmpty())
				{
					// We don't know whether the subFoldersPath has \ or / separators so
					// we'll change both to the native one (PathSeparator) The default
					// behavior of the wxString::Replace method is to replace all.
					int NumReplacements = subFoldersPath.Replace(_T("/"),PathSeparator);
					NumReplacements = subFoldersPath.Replace(_T("\\"),PathSeparator);
					NumReplacements = NumReplacements; // avoid compiler warning (leave as is, BEW 2Jan12)
				}
				// build the required administrator's config file path for this line
				fileLine = szCurKBPath + tab + localPath + subFoldersPath;
				size_t lineNum = pf->GetCurrentLine();
				pf->RemoveLine(lineNum);
				pf->InsertLine(fileLine, lineNum);
			}
			else if (fileLine.First(szCurKBBackupPath) != -1)
			{
				// we're at a line with "KBBackupPath" in it that we want to
				// adjust
				nStartOfSubFoldersPath = fileLine.Find(basePath) + basePathLength;
				strLength = fileLine.Length();
				subFoldersPath = fileLine.Right(strLength - nStartOfSubFoldersPath);
				if (!subFoldersPath.IsEmpty())
				{
					// We don't know whether the subFoldersPath has \ or / separators so
					// we'll change both to the native one (PathSeparator) The default
					// behavior of the wxString::Replace method is to replace all.
					int NumReplacements = subFoldersPath.Replace(_T("/"),PathSeparator);
					NumReplacements = subFoldersPath.Replace(_T("\\"),PathSeparator);
					NumReplacements = NumReplacements; // avoid compiler warning (leave as is, BEW 2Jan12)
				}
				// build the required administrator's config file path for this line
				fileLine = szCurKBBackupPath + tab + localPath + subFoldersPath;
				size_t lineNum = pf->GetCurrentLine();
				pf->RemoveLine(lineNum);
				pf->InsertLine(fileLine, lineNum);
			}
		}
		break;
	default:
	case defaultPathsFix:
		// scan the in-memory file line-by-line and process those needing path updates
		// whm 29Dec06 TODO: determine if we should call convertToLocalCharset() here on fileLine
		for ( fileLine = pf->GetFirstLine(); !pf->Eof(); fileLine = pf->GetNextLine() )
		{
			wxString foreignFilePath = _T("");	// the part of the path to the left of the m_theWorkFolder
												// excluding the sz... keyword part of fileLine
			wxString subFoldersPath = _T("");	// the part of the path to the right of m_theWorkFolder
			int nStartOfForeignFilePath;
			int nStartOfSubFoldersPath;
			int strLength;
			if(fileLine.First(szAdaptitPath) != -1)
			{
				// we're at a line with "AdaptItPath" in it that we want to check/adjust
				// Get the foreign path
				nStartOfForeignFilePath = fileLine.First(szAdaptitPath) + szAdaptitPath.Length();
				nStartOfSubFoldersPath = fileLine.Find(m_theWorkFolder) + m_theWorkFolder.Length();
				strLength = fileLine.Length();
				foreignFilePath = fileLine.Right(strLength - nStartOfForeignFilePath);
				foreignFilePath.Trim(TRUE); // Trim any white space from Right end
				foreignFilePath.Trim(FALSE); // Trim white space (expect tab) from Left end
				subFoldersPath = fileLine.Right(strLength - nStartOfSubFoldersPath);
				if (!subFoldersPath.IsEmpty() && subFoldersPath.First(PathSeparator) == -1)
				{
					// subFoldersPath doesn't have native PathSeparator, so convert it/them to
					// native We don't know whether the subFoldersPath has \ or / separators so
					// we'll take the brute force method and change both to the native one
					// (PathSeparator) The default behavior of the wxString::Replace method is
					// to replace all.
					int NumReplacements = subFoldersPath.Replace(_T("/"),PathSeparator);
					NumReplacements = subFoldersPath.Replace(_T("\\"),PathSeparator);
					NumReplacements = NumReplacements; // avoid compiler warning (leave as is, BEW 2Jan12)
				}
				// Compare the imported localPathPrefix with that of our local machine
				if (!foreignFilePath.StartsWith(basePath)) // ensure Linux etc are handled too
				{
					// foreignFilePath doesn't start with the basePath
					// so we need to modify it for the local machine's use
					fileLine = szAdaptitPath + tab + localPath + subFoldersPath; // subFoldersPath
																				 // is null here
					size_t lineNum = pf->GetCurrentLine();
					pf->RemoveLine(lineNum);
					pf->InsertLine(fileLine, lineNum);
				}
			}
			else if (fileLine.First(szCurLanguagesPath) != -1)
			{
				// we're at a line with "ProjectFolderPath" in it that we want to check/adjust
				// Compare the imported localPathPrefix with that of our local machine
				nStartOfForeignFilePath = fileLine.First(szCurLanguagesPath) +
															szCurLanguagesPath.Length();
				nStartOfSubFoldersPath = fileLine.Find(m_theWorkFolder) +
															m_theWorkFolder.Length();
				strLength = fileLine.Length();
				foreignFilePath = fileLine.Right(strLength - nStartOfForeignFilePath);
				foreignFilePath.Trim(TRUE); // Trim any white space from Right end
				foreignFilePath.Trim(FALSE); // Trim white space (expect tab) from Left end
				subFoldersPath = fileLine.Right(strLength - nStartOfSubFoldersPath);
				if (!subFoldersPath.IsEmpty() && subFoldersPath.First(PathSeparator) == -1)
				{
					// subFoldersPath doesn't have native PathSeparator, so convert it/them to
					// native We don't know whether the subFoldersPath has \ or / separators so
					// we'll take the brute force method and change both to the native one
					// (PathSeparator) The default behavior of the wxString::Replace method is
					// to replace all.
					int NumReplacements = subFoldersPath.Replace(_T("/"),PathSeparator);
					NumReplacements = subFoldersPath.Replace(_T("\\"),PathSeparator);
					NumReplacements = NumReplacements; // avoid compiler warning (leave as is, BEW 2Jan12)
				}
				// Compare the imported localPathPrefix with that of our local machine
				if (!foreignFilePath.StartsWith(basePath))
				{
					// foreignFilePath doesn't start with the localPathPrefix
					// so we need to modify it for the local machine's use
					fileLine = szCurLanguagesPath + tab + localPath + subFoldersPath;
					size_t lineNum = pf->GetCurrentLine();
					pf->RemoveLine(lineNum);
					pf->InsertLine(fileLine, lineNum);
				}
			}
			else if (fileLine.First(szCurAdaptionsPath) != -1)
			{
				// we're at a line with "DocumentsFolderPath" in it that we want to
				// check/adjust
				// Compare the imported localPathPrefix with that of our local machine
				nStartOfForeignFilePath = fileLine.First(szCurAdaptionsPath) +
														szCurAdaptionsPath.Length();
				nStartOfSubFoldersPath = fileLine.Find(m_theWorkFolder) +
														m_theWorkFolder.Length();
				strLength = fileLine.Length();
				foreignFilePath = fileLine.Right(strLength - nStartOfForeignFilePath);
				foreignFilePath.Trim(TRUE); // Trim any white space from Right end
				foreignFilePath.Trim(FALSE); // Trim white space (expect tab) from Left end
				subFoldersPath = fileLine.Right(strLength - nStartOfSubFoldersPath);
				if (!subFoldersPath.IsEmpty() && subFoldersPath.First(PathSeparator) == -1)
				{
					// subFoldersPath doesn't have native PathSeparator, so convert it/them to
					// native We don't know whether the subFoldersPath has \ or / separators so
					// we'll take the brute force method and change both to the native one
					// (PathSeparator) The default behavior of the wxString::Replace method is
					// to replace all.
					int NumReplacements = subFoldersPath.Replace(_T("/"),PathSeparator);
					NumReplacements = subFoldersPath.Replace(_T("\\"),PathSeparator);
					NumReplacements = NumReplacements; // avoid compiler warning (leave as is, BEW 2Jan12)
				}
				// Compare the imported localPathPrefix with that of our local machine
				if (!foreignFilePath.StartsWith(basePath))
				{
					// foreignFilePath doesn't start with the localPathPrefix
					// so we need to modify it for the local machine's use
					fileLine = szCurAdaptionsPath + tab + localPath + subFoldersPath;
					size_t lineNum = pf->GetCurrentLine();
					pf->RemoveLine(lineNum);
					pf->InsertLine(fileLine, lineNum);
				}
			}
			else if (fileLine.First(szCurKBPath) != -1)
			{
				// we're at a line with "KnowledgeBasePath" in it that we want to
				// check/adjust
				// Compare the imported localPathPrefix with that of our local machine
				nStartOfForeignFilePath = fileLine.First(szCurKBPath) +
																szCurKBPath.Length();
				nStartOfSubFoldersPath = fileLine.Find(m_theWorkFolder) +
															m_theWorkFolder.Length();
				strLength = fileLine.Length();
				foreignFilePath = fileLine.Right(strLength - nStartOfForeignFilePath);
				foreignFilePath.Trim(TRUE); // Trim any white space from Right end
				foreignFilePath.Trim(FALSE); // Trim white space (expect tab) from Left end
				subFoldersPath = fileLine.Right(strLength - nStartOfSubFoldersPath);
				if (!subFoldersPath.IsEmpty() && subFoldersPath.First(PathSeparator) == -1)
				{
					// subFoldersPath doesn't have native PathSeparator, so convert it/them to
					// native We don't know whether the subFoldersPath has \ or / separators so
					// we'll take the brute force method and change both to the native one
					// (PathSeparator) The default behavior of the wxString::Replace method is
					// to replace all.
					int NumReplacements = subFoldersPath.Replace(_T("/"),PathSeparator);
					NumReplacements = subFoldersPath.Replace(_T("\\"),PathSeparator);
					NumReplacements = NumReplacements; // avoid compiler warning (leave as is, BEW 2Jan12)
				}
				// Compare the imported localPathPrefix with that of our local machine
				if (!foreignFilePath.StartsWith(basePath))
				{
					// foreignFilePath doesn't start with the basePath
					// so we need to modify it for the local machine's use
					fileLine = szCurKBPath + tab + localPath + subFoldersPath; // add tab back
					size_t lineNum = pf->GetCurrentLine();
					pf->RemoveLine(lineNum);
					pf->InsertLine(fileLine, lineNum);
				}
			}
			else if (fileLine.First(szCurKBBackupPath) != -1)
			{
				// we're at a line with "KBBackupPath" in it that we want to
				// check/adjust
				// Compare the imported localPathPrefix with that of our local machine
				nStartOfForeignFilePath = fileLine.First(szCurKBBackupPath) +
															szCurKBBackupPath.Length();
				nStartOfSubFoldersPath = fileLine.Find(m_theWorkFolder) +
															m_theWorkFolder.Length();
				strLength = fileLine.Length();
				foreignFilePath = fileLine.Right(strLength - nStartOfForeignFilePath);
				foreignFilePath.Trim(TRUE); // Trim any white space from Right end
				foreignFilePath.Trim(FALSE); // Trim white space (expect tab) from Left end
				subFoldersPath = fileLine.Right(strLength - nStartOfSubFoldersPath);
				if (!subFoldersPath.IsEmpty() && subFoldersPath.First(PathSeparator) == -1)
				{
					// subFoldersPath doesn't have native PathSeparator, so convert it/them to
					// native We don't know whether the subFoldersPath has \ or / separators so
					// we'll take the brute force method and change both to the native one
					// (PathSeparator) The default behavior of the wxString::Replace method is
					// to replace all.
					int NumReplacements = subFoldersPath.Replace(_T("/"),PathSeparator);
					NumReplacements = subFoldersPath.Replace(_T("\\"),PathSeparator);
					NumReplacements = NumReplacements; // avoid compiler warning (leave as is, BEW 2Jan12)
				}
				// Compare the imported localPathPrefix with that of our local machine
				if (!foreignFilePath.StartsWith(basePath))
				{
					// foreignFilePath doesn't start with the localPathPrefix
					// so we need to modify it for the local machine's use
					fileLine = szCurKBBackupPath + tab + localPath + subFoldersPath; // add tab back
					size_t lineNum = pf->GetCurrentLine();
					pf->RemoveLine(lineNum);
					pf->InsertLine(fileLine, lineNum);
				}
			}
		}
		break;
	}
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pf                  -> pointer to an opened wxTextFile for the config file
/// \remarks
/// Called from MakeForeignBasicConfigFileSafe().
/// This function fixes, or attempts to fix the font information in a basic config file
/// when a foreign config file is read. The font characteristics at the beginning of the
/// config file that are checked for needed adjustment are the CharSet, FontEncoding,
/// and FaceName - for each of the three main fonts: SourceFont, TargetFont and NavTextFont.
/// All other font characteristics especially Height, Width, Weight, PitchAndFamily,
/// Italic, Underline and Color are not changed.
/// FixConfigFileFonts() parallels FixBasicConfigPaths() but deals with font mismatches
/// encountered when a foreign config file is processed. Like FixBasicConfigPaths(),
/// it only makes font adjustments to the in-memory wxTextFile pf, therefore it is the
/// responsibility of the caller MakeForeignBasicConfigFileSafe() to write any changes
/// made here to the persistent media.
void CAdapt_ItApp::FixConfigFileFonts(wxTextFile* pf)
{
	// whm added 24Feb10.
	// This function consolidates some font error handling previously done in
	// GetConfigurationFile().
	//wxString errStr = fontErrInfoStr; // a local copy
	wxString tab = _T('\t');
	wxString fileLine;
	wxString Encoding[3];
	wxString Charset[3];
	wxString Facename[3];

	// In the first for loop below we collect the three font characteristics for
	// the three fonts; in the second for loop we save back any changed values

	int nFontEncodingIndex = 0;
	int nCharSetIndex = 0;
	int nFaceNameIndex = 0;
	// scan the in-memory file line-by-line and collect the font characteristics
	for ( fileLine = pf->GetFirstLine(); !pf->Eof(); fileLine = pf->GetNextLine() )
	{
		if(fileLine.Find(szFontEncoding) != wxNOT_FOUND)
		{
			// we're at a line with "FontEncoding" in it
			Encoding[nFontEncodingIndex] = fileLine.Mid(fileLine.Find(tab)+1);
			nFontEncodingIndex++;
		}
		else if (fileLine.Find(szCharSet) != wxNOT_FOUND)
		{
			// we're at a line with "CharSet" in it
			Charset[nCharSetIndex] = fileLine.Mid(fileLine.Find(tab)+1);
			nCharSetIndex++;
		}
		else if (fileLine.First(szFaceName) != wxNOT_FOUND)
		{
			// we're at a line with "FaceName" in it
			Facename[nFaceNameIndex] = fileLine.Mid(fileLine.Find(tab)+1);
			nFaceNameIndex++;
		}
	}
	// nFontEncodingIndex may be 0 for an MFC ver. 3.6.4 or earlier produced config file
	// nCharSetIndex should be 3 for all version config files
	// nFaceNameIndex should be 3 for all version config files

	// #####################processing any needed font changes below ############################

	// following was originally from GetFontConfiguration() "else if (name == szFaceName)" block
	wxString errMsg,sysFontName;
	errMsg.Empty();
	sysFontName.Empty();
	bool bFoundFaceName = FALSE;

	int srcPointSize = m_pSourceFont->GetPointSize();
	int srcFamily = m_pSourceFont->GetFamily();
	int srcStyle = m_pSourceFont->GetStyle();
	int srcWeight = m_pSourceFont->GetWeight();
	bool srcUnderlined = m_pSourceFont->GetUnderlined();

	bFoundFaceName = m_pSourceFont->SetFaceName(Facename[0]);
	if (!bFoundFaceName)
	{
		// There isn't a font on the local system by the exact FaceName, so
		// try finding any font in the given Encoding
		if (wxFontMapper::Get()->IsEncodingAvailable((wxFontEncoding)wxAtoi(Encoding[0]),wxEmptyString))
		{
			// create the font using wxFont's full constructor which takes the encoding
			// name and doesn't have to have a facename in the constructor - after the
			// font is created store the face name it creates in fi.fFaceName and call
			// SetFaceName() on the appropriate AI font.
			wxFont* tempFont = new wxFont(srcPointSize,srcFamily,srcStyle,
				srcWeight,srcUnderlined,wxEmptyString,(wxFontEncoding)wxAtoi(Encoding[0]));
			SrcFInfo.fFaceName = tempFont->GetFaceName(); // keep the fontInfo struct up to date
			if (!m_pSourceFont->SetFaceName(SrcFInfo.fFaceName))
			{
				;
				wxASSERT(FALSE);
			}
			delete tempFont;
			tempFont = (wxFont*)NULL;
		}
		else
		{
			wxFontEncoding alt_encoding;
			if (wxFontMapper::Get()->GetAltForEncoding((wxFontEncoding)wxAtoi(Encoding[0]),&alt_encoding,wxEmptyString,FALSE)) // FALSE = non-interactive
			{
				// create the font using wxFont's full constructor which takes the encoding
				// name and doesn't have to have a facename in the constructor - after the
				// font is created store the face name it creates in fi.fFaceName and call
				// SetFaceName() on the appropriate AI font.
				wxFont* tempFont = new wxFont(srcPointSize,srcFamily,srcStyle,
					srcWeight,srcUnderlined,wxEmptyString,alt_encoding);
				SrcFInfo.fFaceName = tempFont->GetFaceName(); // keep the fontInfo struct up to date
				if (!m_pSourceFont->SetFaceName(SrcFInfo.fFaceName))
				{
					;
					wxASSERT(FALSE);
				}
				delete tempFont;
				tempFont = (wxFont*)NULL;
			}
			else
			{
				// revert to using a system font (for face name)
				wxFont* tempFont = new wxFont(*wxSWISS_FONT); //wxFont(*wxNORMAL_FONT);
				SrcFInfo.fFaceName = tempFont->GetFaceName();
				if (!m_pSourceFont->SetFaceName(SrcFInfo.fFaceName))
				{
					;
					wxASSERT(FALSE);
				}
				m_pSourceFont->SetPointSize(12); // use a reasonable size for
												 // the system font
				delete tempFont;
				tempFont = (wxFont*)NULL;

				errMsg += _T("\n   ");
				errMsg += _("Source Font Name");
				errMsg += _T(": ");
				errMsg += Facename[0];
				sysFontName = SrcFInfo.fFaceName;	// a system font should have the
													// same face name in all cases
			}
		}
		// update values for XxxFInfo structs and three local wxString arrays used in
		// updating config file below
		SrcFInfo.fEncoding = m_pSourceFont->GetEncoding();
		Encoding[0].Empty();
		Encoding[0] << SrcFInfo.fEncoding; // int to wxString
		SrcFInfo.fCharset = MapWXFontEncodingToMFCCharset(SrcFInfo.fEncoding); // the wx encodings
		Charset[0] << SrcFInfo.fCharset;
		SrcFInfo.fFaceName = m_pSourceFont->GetFaceName();
		Facename[0] = SrcFInfo.fFaceName;
	}

	int tgtPointSize = m_pTargetFont->GetPointSize();
	int tgtFamily = m_pTargetFont->GetFamily();
	int tgtStyle = m_pTargetFont->GetStyle();
	int tgtWeight = m_pTargetFont->GetWeight();
	bool tgtUnderlined = m_pTargetFont->GetUnderlined();

	bFoundFaceName = m_pTargetFont->SetFaceName(Facename[1]);
	if (!bFoundFaceName)
	{
		// There isn't a font on the local system by the exact FaceName, so
		// try finding any font in the given Encoding
		if (wxFontMapper::Get()->IsEncodingAvailable((wxFontEncoding)wxAtoi(Encoding[1]),wxEmptyString))
		{
			// create the font using wxFont's full constructor which takes the encoding
			// name and doesn't have to have a facename in the constructor - after the
			// font is created store the face name it creates in fi.fFaceName and call
			// SetFaceName() on the appropriate AI font.
			wxFont* tempFont = new wxFont(tgtPointSize,tgtFamily,tgtStyle,
				tgtWeight,tgtUnderlined,wxEmptyString,(wxFontEncoding)wxAtoi(Encoding[1]));
			TgtFInfo.fFaceName = tempFont->GetFaceName(); // keep the fontInfo struct up to date
			if (!m_pTargetFont->SetFaceName(TgtFInfo.fFaceName))
			{
				;
				wxASSERT(FALSE);
			}
			delete tempFont;
			tempFont = (wxFont*)NULL;
		}
		else
		{
			wxFontEncoding alt_encoding;
			if (wxFontMapper::Get()->GetAltForEncoding((wxFontEncoding)wxAtoi(Encoding[1]),&alt_encoding,wxEmptyString,FALSE)) // FALSE = non-interactive
			{
				// create the font using wxFont's full constructor which takes the encoding
				// name and doesn't have to have a facename in the constructor - after the
				// font is created store the face name it creates in fi.fFaceName and call
				// SetFaceName() on the appropriate AI font.
				wxFont* tempFont = new wxFont(tgtPointSize,tgtFamily,tgtStyle,
					tgtWeight,tgtUnderlined,wxEmptyString,alt_encoding);
				TgtFInfo.fFaceName = tempFont->GetFaceName(); // keep the fontInfo struct up to date
				if (!m_pTargetFont->SetFaceName(TgtFInfo.fFaceName))
				{
					;
					wxASSERT(FALSE);
				}
				delete tempFont;
				tempFont = (wxFont*)NULL;
			}
			else
			{
				// revert to using a system font (for face name)
				wxFont* tempFont = new wxFont(*wxSWISS_FONT); //wxFont(*wxNORMAL_FONT);
				TgtFInfo.fFaceName = tempFont->GetFaceName();
				if (!m_pTargetFont->SetFaceName(TgtFInfo.fFaceName))
				{
					;
					wxASSERT(FALSE);
				}
				m_pTargetFont->SetPointSize(12); // use a reasonable size
												 // for the system font
				delete tempFont;
				tempFont = (wxFont*)NULL;

				errMsg += _T("\n   ");
				errMsg += _("Target Font Name");
				errMsg += _T(": ");
				errMsg += Facename[1];
				sysFontName = TgtFInfo.fFaceName; // a system font should have the
												  // same face name in all cases
			}
		}
		// update values for XxxFInfo structs and three local wxString arrays used in
		// updating config file below
		TgtFInfo.fEncoding = m_pTargetFont->GetEncoding();
		Encoding[1].Empty();
		Encoding[1] << TgtFInfo.fEncoding; // int to wxString
		TgtFInfo.fCharset = MapWXFontEncodingToMFCCharset(TgtFInfo.fEncoding); // the wx encodings
		Charset[1] << TgtFInfo.fCharset;
		TgtFInfo.fFaceName = m_pTargetFont->GetFaceName();
		Facename[1] = TgtFInfo.fFaceName;
	}

	int navPointSize = m_pNavTextFont->GetPointSize();
	int navFamily = m_pNavTextFont->GetFamily();
	int navStyle = m_pNavTextFont->GetStyle();
	int navWeight = m_pNavTextFont->GetWeight();
	bool navUnderlined = m_pNavTextFont->GetUnderlined();

	bFoundFaceName = m_pNavTextFont->SetFaceName(Facename[2]);
	if (!bFoundFaceName)
	{
		// There isn't a font on the local system by the exact fFaceName, so
		// try finding any font in the given fEncoding
		if (wxFontMapper::Get()->IsEncodingAvailable((wxFontEncoding)wxAtoi(Encoding[2]),wxEmptyString))
		{
			// create the font using wxFont's full constructor which takes the encoding
			// name and doesn't have to have a facename in the constructor - after the
			// font is created store the face name it creates in fi.fFaceName and call
			// SetFaceName() on the appropriate AI font.
			wxFont* tempFont = new wxFont(navPointSize,navFamily,navStyle,
				navWeight,navUnderlined,wxEmptyString,(wxFontEncoding)wxAtoi(Encoding[2]));
			NavFInfo.fFaceName = tempFont->GetFaceName(); // keep the fontInfo struct up to date
			if (!m_pNavTextFont->SetFaceName(NavFInfo.fFaceName))
			{
				;
				wxASSERT(FALSE);
			}
			delete tempFont;
			tempFont = (wxFont*)NULL;
		}
		else
		{
			wxFontEncoding alt_encoding;
			if (wxFontMapper::Get()->GetAltForEncoding((wxFontEncoding)wxAtoi(Encoding[2]),&alt_encoding,wxEmptyString,FALSE)) // FALSE = non-interactive
			{
				// create the font using wxFont's full constructor which takes the encoding
				// name and doesn't have to have a facename in the constructor - after the
				// font is created store the face name it creates in fi.fFaceName and call
				// SetFaceName() on the appropriate AI font.
				wxFont* tempFont = new wxFont(navPointSize,navFamily,navStyle,
					navWeight,navUnderlined,wxEmptyString,alt_encoding);
				NavFInfo.fFaceName = tempFont->GetFaceName(); // keep the fontInfo struct up to date
				if (!m_pNavTextFont->SetFaceName(NavFInfo.fFaceName))
				{
					;
					wxASSERT(FALSE);
				}
				delete tempFont;
				tempFont = (wxFont*)NULL;
			}
			else
			{
				// revert to using a system font (for face name)
				wxFont* tempFont = new wxFont(*wxSWISS_FONT); //wxFont(*wxNORMAL_FONT);
				NavFInfo.fFaceName = tempFont->GetFaceName();
				if (!m_pNavTextFont->SetFaceName(NavFInfo.fFaceName))
				{
					;
					wxASSERT(FALSE);
				}
				m_pNavTextFont->SetPointSize(12); // use a reasonable size
												  // for the system font
				delete tempFont;
				tempFont = (wxFont*)NULL;

				errMsg += _T("\n   ");
				errMsg += _("Navigation Font Name");
				errMsg += _T(": ");
				errMsg += Facename[2];
				sysFontName = NavFInfo.fFaceName; // a system font should have the
												  // same face name in all cases
			}
		}
		// update values for XxxFInfo structs and three local wxString arrays used in
		// updating config file below
		NavFInfo.fEncoding = m_pNavTextFont->GetEncoding();
		Encoding[2].Empty();
		Encoding[2] << NavFInfo.fEncoding; // int to wxString
		NavFInfo.fCharset = MapWXFontEncodingToMFCCharset(NavFInfo.fEncoding); // the wx encodings
		Charset[2] << NavFInfo.fCharset;
		NavFInfo.fFaceName = m_pNavTextFont->GetFaceName();
		Facename[2] = NavFInfo.fFaceName;
	}

	// Display to user any font mismatches detected and the substituted font.
	if (!errMsg.IsEmpty())
	{
		wxString errMsg2;
		errMsg2 = _(
"The following fonts (in the project configuration file) cannot be found on your computer:");
		errMsg2 += errMsg;
		errMsg2 = errMsg2 + _(
"\nA system font (%s) will be used instead. You may need to install the appropriate font, then select it from the Fonts tab of the Preferences... dialog (on the Edit menu).");
		errMsg2 = errMsg2.Format(errMsg2,sysFontName.c_str());
		wxMessageBox(errMsg2,_("Font name in configuration file not found"),
		wxICON_WARNING);
	}

	// Note: In GetFontConfiguration() in the "else if (name == szFontEncoding)"
	// block FontEncoding values read in from the configuration file are
	// restricted to values between -1 and 255, and set to 0 if outside that range.

	// Note: In GetFontConfiguration() in the "else if (name == szCharSet)" block
	// the CharSet values read in from the configuration file are restricted
	// to values between 0 and 255, and set to 0 if outside that range.

	// Call SetEncoding() only if the encoding is available on this system
	wxFontEncoding nEnc;
	nEnc = (wxFontEncoding)wxAtoi(Encoding[0]);
	if (wxFontMapper::Get()->IsEncodingAvailable(nEnc,wxEmptyString))
		m_pSourceFont->SetEncoding(nEnc);
	nEnc = (wxFontEncoding)wxAtoi(Encoding[1]);
	if (wxFontMapper::Get()->IsEncodingAvailable(nEnc,wxEmptyString))
		m_pTargetFont->SetEncoding(nEnc);
	nEnc = (wxFontEncoding)wxAtoi(Encoding[2]);
	if (wxFontMapper::Get()->IsEncodingAvailable(nEnc,wxEmptyString))
		m_pNavTextFont->SetEncoding(nEnc);

	// #####################processing any needed font changes above ############################

	nFontEncodingIndex = 0;
	nCharSetIndex = 0;
	nFaceNameIndex = 0;
	bool bEncodingProcessed[3] = {FALSE,FALSE,FALSE};
	// scan the in-memory file line-by-line and process those needing font updates
	for ( fileLine = pf->GetFirstLine(); !pf->Eof(); fileLine = pf->GetNextLine() )
	{
		if(fileLine.Find(szFontEncoding) != wxNOT_FOUND)
		{
			// we're at a line with "FontEncoding" in it
			// build the required config file encoding for this line
			fileLine = szFontEncoding + tab + Encoding[nFontEncodingIndex]; // make the fixed fileLine string
			bEncodingProcessed[nFontEncodingIndex] = TRUE;
			nFontEncodingIndex++;
			size_t lineNum = pf->GetCurrentLine(); // get the line number
			pf->RemoveLine(lineNum); // remove the old line from the in-memory file
			pf->InsertLine(fileLine, lineNum); // replace it with the fixed line
		}
		else if (fileLine.Find(szCharSet) != wxNOT_FOUND)
		{
			if (bEncodingProcessed[nCharSetIndex] == FALSE)
			{
				// there was no FontEncoding item occurring preceding this CharSet item
				// (indicating we're processing a conf file produced by MFC version 3.6.4
				// or earlier). We'll insert at this point (before the CharSet line) the
				// default encoding that was determined above
				nFontEncodingIndex = nCharSetIndex;
				bEncodingProcessed[nFontEncodingIndex] = TRUE;
				wxString nEncStr = _T("");
				nEncStr << (int)nEnc;
				fileLine = szFontEncoding + tab + nEncStr; // make the fixed fileLine string
				size_t lineNum = pf->GetCurrentLine(); // get the line number
				pf->InsertLine(fileLine, lineNum);
				pf->GoToLine(lineNum + 1); // set the current line pointer past the FontEncoding line just inserted
				nFontEncodingIndex++; // will be ignored except on last of the three fonts processed to keep assert below from tripping
			}
			// we're at a line with "CharSet" in it
			// build the required config file charset for this line
			fileLine = szCharSet + tab + Charset[nCharSetIndex]; // the fix
			nCharSetIndex++;
			size_t lineNum = pf->GetCurrentLine();
			pf->RemoveLine(lineNum);
			pf->InsertLine(fileLine, lineNum);
		}
		else if (fileLine.First(szFaceName) != wxNOT_FOUND)
		{
			// we're at a line with "FaceName" in it
			// build the required config file facename for this line
			fileLine = szFaceName + tab + Facename[nFaceNameIndex];
			nFaceNameIndex++;
			size_t lineNum = pf->GetCurrentLine();
			pf->RemoveLine(lineNum);
			pf->InsertLine(fileLine, lineNum);
		}
	}
	wxASSERT(nFontEncodingIndex == 3); // if this trips the logic above is wrong
	wxASSERT(nCharSetIndex == 3);
	wxASSERT(nFaceNameIndex == 3);
}

////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      configFName         -> the default name of the basic config file (this
///									   is always AI-BasicConfiguration.aic)
/// \param      folderPath          -> the work folder path m_workFolderPath, or
///                                    m_customWorkFolderPath, at which the fixed
///									   configuration file will be saved
/// \param      adminConfigFName    -> pointer to the name of the administor configuration
///                                    file name, for use when m_bUseCustomWorkFolderPath
///                                    is TRUE, because administrator is looking into a
///                                    work folder stored at a custom location on the
///                                    machine or on a remote machine connected to the LAN
///                                    (default is NULL, when accessing legacy location,
///                                    and for that the m_bUseCustomWorkFolderPath flag is
///                                    FALSE) (This name, if supplied, is always
///									   AI-AdminBasicConfiguration.aic)
/// \remarks
/// BEW modified 18Aug09 in support of custom work folder locations.
/// whm modified 24Feb10 to incorporate font mismatch handling via helper function called
/// FixConfigFileFonts() which parallels Bruce's FixBasicConfigPaths().
///
/// Called from: the App's OnInit(), SetupCustomWorkFolderLocation(), OnLockCustomLocation(),
/// OnRestoreDefaultWorkFolderLocation(), DealWithThePossibilityOfACustomWorkFolderLocation().
///
/// Compares the "home" directory part of the current user's path to the "(My) Documents"
/// folder (or the "Adapt It Work" folder for non-Win systems), with the paths in the
/// AdaptItPath, ProjectFolderPath, DocumentsFolderPath, KnowledgeBasePath, and
/// KBBackupPath pathname strings in the current AI-BasicConfiguration.aic file. If its a
/// foreign config file, this first part of these paths will differ for any of the
/// following reasons:
/// 1. The foreign machine uses a different drive letter,
/// 2. Or, because the user's name is different,
/// 3. Or, the foreign machine uses the Unix/Linux home directory scheme
///     (typically /usr/home).
/// 4. An administrator is pointing the running Adapt It at a custom work folder location.
/// The function then fixes these paths so as to get safe defaults for the current machine,
/// and the subsequent read of the updated config file will not cause an app crash due to
/// bad paths.
///
/// The passed in path at folderPath can be m_workFolderPath when
/// m_bUseCustomWorkFolderPath is FALSE, or when TRUE a local wxString is used instead
/// which is nice as the code is not dependent on something being set in the caller; the
/// local string is basePath, and it's set from whatever AI-BasicConfiguration.aic file
/// that we grab or create for cloning purposes in order to form an administrator's basic
/// configuration file - using the szAdaptitPath line's stored path following the tab.
/// So we'll get a basic configuration file somehow, clone it, and change the relevant
/// paths as needed for the targetted machine (which could be the same machine or one on
/// the LAN with shared folders in which we are poking around), and save the modifed config
/// data to a configuration file with a new name, in the work folder of the user or
/// administrator on his local machine, and use that for loading and saving basic config
/// file settings when the administrator is poking his nose into someone else's work
/// folder. That new filename will be AI-AdminBasicConfiguration.aic. We also use this
/// function when setting up a custom work folder location on a machine, so as to put
/// correct paths in the basic configuration file stored in that custom folder; when doing
/// this the input paths are probably correct as is, but we recreate them "safely" as a
/// precaution, even though we probably for most situations are merely recreating what we
/// already have got from the contents of the CustomWorkFolderLocation file stored in the
/// default work folder location on the machine.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::MakeForeignBasicConfigFileSafe(wxString& configFName,wxString& folderPath,
											wxString* adminConfigFNamePtr)
{
	wxString basePath = _T("");
	if ((m_customWorkFolderPath == m_workFolderPath) || !m_bUseCustomWorkFolderPath)
	{
        // NOTE: EnsureWorkFolderExists() must be called beforehand to ensure
        // m_localPathPrefix path string has been correctly set before the program counter
        // traverses this code block - this is important now that the path which was
        // formerly being used may be to a non-standard work folder location somewhere deep
        // in the folder hierarchy!

		// Get the "home" directory for the current system/platform. This would typically be:
		// For Windows: C:\Documents and Settings\<UserName>
		// For Linux: /usr/home
		wxStandardPaths stdPaths;
		wxString homeDir;
//		#ifdef __WXMAC__
		// whm note 18Jun09: the wxStandardPaths::GetDocumentsDir() is probably causing program
		// crash when compiled for Mac OS X 10.3 Panther, so I'm using the older
		// ::wxGetHomeDir() function for the Mac which should return the same directory string
		// on the Mac that wxStandardPaths::GetDocumentsDir() does.
		// GDLC 29Sep11 Not needed now that we are not targeting MacOS Panther or PPC.
//		homeDir = ::wxGetHomeDir();
//		#else
		homeDir = stdPaths.GetDocumentsDir(); // The GetDocumentsDir() function is new since
											  // wxWidgets version 2.7.0
//		#endif
		// The PathSeparator becomes the appropriate symbol; \ on Windows, / on Linux
		if (folderPath.GetChar(folderPath.Length() - 1) == PathSeparator)
		{
			folderPath.RemoveLast(); // remove the PathSeparator char
				// at the end of the path string, so next line won't give two contiguous

		}
		wxString configPath = folderPath + PathSeparator + configFName;
		basePath = m_localPathPrefix; // m_localPathPrefix was set
					// in EnsureWorkFolderPresent, and it is relevant in
					// MakeForeignBasicConfigFileSafe() only when m_bUseCustomWorkFolderPath
					// is FALSE
		// m_localPathPrefix represents the part of the path preceeding the m_theWorkFolder
		// part so that m_localPathPrefix + m_theWorkFolder together represents the desired
		// folderPath On any imported data, we expect the m_theWorkFolder part of config paths
		// to be the same, but the m_localPathPrefix part may vary. Use local basePath for it
		// below

		// For small config type text files, wxTextFile is probably most convenient. A version
		// of the Open() function also understands Unicode, so we don't need to distinguish
		// for example CStdioFile from CStdioFileEx. We just conditional compile with the
		// appropriate methods for Unicode.

		wxTextFile f;
		// Under wxWidgets wxTextFile actually reads the entire file into memory at the Open()
		// call. It is set up so we can treat it as a line oriented text file while in memory,
		// modifying it, then writing it back out to persistent storage with a single
		// call to Write().

		wxLogNull logNo; // avoid spurious messages from the system

		// wx note: To avoid an annoying system message that pops up if Open is called on
		// a non-existing file, we'll check for its existence first, and return immediately
		// if it doesn't exist
		if (!::wxFileExists(configPath))
			return;
		// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
		#ifndef _UNICODE
		// ANSI
		bool bSuccessful = f.Open(configPath); // read ANSI file into memory
		#else
		// UNICODE
		bool bSuccessful = f.Open(configPath, wxConvUTF8); // read UNICODE file into memory
		#endif
		if (!bSuccessful)
			// there was a problem opening the file, so we'll just return
			return;

		// The entire basic config file is now in memory and we can modify the lines we want
		// to change. Basically we want the wxHomeDir part of the paths of concern to be the
		// same as what wxHomeDir returns on the local machine.

		// In the MFC version the first instance of the string "\My Documents" is located
		// and the left part of that path determined. In our wxWidgets context we want to
		// know the foreign localPathPrefix part that differs from the basePath of
		// the local machine, which won't necessarily have the string "My Documents" in it.

		// The five paths of concern are:
		// szAdaptitPath = _("AdaptItPath");
		// szCurLanguagesPath = _("ProjectFolderPath");
		// szCurAdaptionsPath = _("DocumentsFolderPath");
		// szCurKBPath = _("KnowledgeBasePath");
		// szCurKBBackupPath = _("KBBackupPath");

		// whm modified 5Jun09. If the user is forcing the work folder to be what s/he wants
		// then we won't suffix the forced path with m_theWorkFolder ("Adapt It <Unicode>
		// Work").
		// BEW added 31Jan10; code here assumes a PathSeparator will not be at end of basePath
		// so if so, whether Windows (e.g. D:\ or Linux or Mac / root folder), remove it as
		// code further below should add a PathSeparator automatically before appending a
		// child folder name...
		if (basePath.GetChar(basePath.Length() - 1) == PathSeparator)
		{
			basePath.RemoveLast(); // remove the PathSeparator char
				// at the end of the path string, so next line won't give two contiguous
		}
		wxString localPath;
		if (m_wf_forced_workFolderPath.IsEmpty())
		{
			localPath = basePath + PathSeparator + m_theWorkFolder;
		}
		else
		{
			localPath = basePath; // it's already set to m_wf_forced_workFolderPath
		}
		// do the actual path fixes
		FixBasicConfigPaths(defaultPathsFix, &f, basePath, localPath);

		// whm 23Feb10 Note: FixConfigFileFonts() is called in the parallel MakeForeighProjectConfigFileSafe().

		#ifndef _UNICODE
		// ANSI
		bSuccessful = f.Write(); // write ANSI file back to disk
		#else
		// UNICODE
		bSuccessful = f.Write(); // write UNICODE file back to disk
								 // whm note: default is to use wxConvUTF8 in Unicode build
		#endif
		if (!bSuccessful)
		{
			// could not update the config file so inform user
			wxMessageBox(_("Unable to write updated config file, so just did nothing"));
			return;
		}
	} // end of TRUE block for test
	  // if ((m_customWorkFolderPath == m_workFolderPath) || !m_bUseCustomWorkFolderPath)
	else
	{
		if (!m_bLockedCustomWorkFolderPath)
		{
			// this block for when the administrator is looking at someone's work folder in a
			// custom location, and an AI-AdminBasicConfiguration.aic file needs to be created
			// with appropriate paths for the administrator's running AI instance. We need an
			// administrator's basic configuration file to "fix", but there may not be one yet
			// in his work folder - if so we resort to the expedient of taking the
			// administrator's normal one, cloning and renaming it, and fixing that -- that one
			// should be found in the m_workFolderPath location, & if that does not yield one,
			// we'll force one to be temporarily written there and clone from that. Hence by
			// one means or another we obtain a configuration file for cloning, modify its
			// contents and save them to a different file called AI_AdminBasicConfiguration.aic,
			// in the administrator's default work folder location (the latter is always
			// pointed at by the path in m_workFolderLocation)
			bool bRemoveCloneSource = FALSE; // set TRUE if we need later to remove a temporary
											 // basic config file saved to disk only for cloning
											 // purposes
			wxString configPath = m_workFolderPath + PathSeparator + configFName; // use native separator
			// construct the path for where to save the admin basic config file from the
			// administrator's machine's default work folder path (if he uses a custom work
			// folder location, there won't be a basic config file in the default location,
			// but no matter, we can force one to be temporarily saved there for cloning
			// purposes and then remove it afterwards)
			//wxString adminConfigPath = folderPath + PathSeparator + *adminConfigFNamePtr;
			wxString adminConfigPath = m_workFolderPath + PathSeparator + *adminConfigFNamePtr;
			// now check if configPath contains a basic config file we can use for cloning, we
			// can use a normal one, or an already existing administrator's one if such is present
			bool bCloneableBasicConfigFilePresent = TRUE;
			bCloneableBasicConfigFilePresent = ::wxFileExists(adminConfigPath); // best choice
			bool bBestChoice = bCloneableBasicConfigFilePresent;
			if (!bCloneableBasicConfigFilePresent)
			{
				// no admin basic config file is present, so take our second best choice - the
				// 'normal' basic config file, if present
				bCloneableBasicConfigFilePresent = ::wxFileExists(configPath);
			}
			basePath = m_workFolderPath;
			if (!bCloneableBasicConfigFilePresent)
			{
				// none available, so force one to be written out to m_workFolderPath
				// and then use that, and remove the one we forced after the cloning is
				// done further below; parameter 1 in the following call forces writing
				// of a basic config file rather than a project one
				bool bWrittenOK = WriteConfigurationFile(configFName,basePath,basicConfigFile);
				if (!bWrittenOK)
				{
					// fatal error, shouldn't happen, but if it does alert developer and
					// exit app
					wxMessageBox(
	_T("MakeForeignBasicConfigFileSafe(): forcing write of a temporary basic config file for cloning failed. Shutting down."));
					wxExit();
					return;
				}
				bRemoveCloneSource = TRUE;
			}
			// once here, basePath has the path to whatever folder stores the basic config file
			// we are going to clone off; bBestChoice tells us which it will be. The path we
			// construct within the cloned config file, however, is constructed from the value
			// of the passed in folderPath - which points at the custom work folder location.
			// The administrator's config file line, szAdaptitPath, is setup from that.
			wxTextFile f;
			// Under wxWidgets wxTextFile actually reads the entire file into memory at the Open()
			// call. It is set up so we can treat it as a line oriented text file while in memory,
			// modifying it, then writing it back out to persistent storage with a single
			// call to Write().

			wxLogNull logNo; // avoid spurious messages from the system

			// At this point we must clone the configPath file, and give the clone the
			// adminConfigPath filename. But if an admin basic config file already exists, we
			// don't need to clone it, but just fix it's contents further below.
			bool bRemoved = TRUE;
			if (!bBestChoice)
			{
				wxFileInputStream fis(configPath);
				if (fis.IsOk())
				{
					wxFileOutputStream fos(adminConfigPath);
					if (fos.IsOk())
					{
						// copy the input stream's data to the output streams file
						fos.Write(fis);
					}
				}
			}

			// if we forced a cloneable basic config file to be written, now remove it
			if (bRemoveCloneSource)
			{
				if (::wxFileExists(configPath))
					bRemoved = ::wxRemoveFile(configPath);
				bRemoved = bRemoved; // avoid warning (BEW 2Jan12, keep this, since we
									 // treat it as a non-error)
				// we don't care if the removal didn't happen, so ignore a FALSE value
				// returned (we don't expect to ever get FALSE returned here)
			}

			// now work exclusively with the adminConfigPath clone of the basic config file,
			// or with the previous admin basic config file if one was already present
			if (!::wxFileExists(adminConfigPath))
			{
				// eh!? We just got it, and now it's not there?! Tell developer and exit app
				wxMessageBox(
	_T("MakeForeignBasicConfigFileSafe(): adminConfigPath's admin basic config file somehow doesn't exist!! Shutting down."));
				wxExit();
				return;
			}

			// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
			#ifndef _UNICODE
			// ANSI
			bool bSuccessful = f.Open(adminConfigPath); // read ANSI file into memory
			#else
			// UNICODE
			bool bSuccessful = f.Open(adminConfigPath, wxConvUTF8); // read UNICODE file into memory
			#endif
			if (!bSuccessful)
			{
				// there was a problem opening the file, so we'll just shut down after warning
				// developer
				wxMessageBox(
_T("MakeForeignBasicConfigFileSafe(): custom location block, could not open adminConfigPath file. Shutting down."));
				wxExit();
				return;
			}
			// The entire cloned basic config file is now in memory under the name
			// adminConfigPath, and we can modify the lines we want to change. Basically we
			// want the set the critical paths to point at the relevant folders in the
			// non-standard location

			// The five paths of concern are:
			// szAdaptitPath = _("AdaptItPath");
			// szCurLanguagesPath = _("ProjectFolderPath");
			// szCurAdaptionsPath = _("DocumentsFolderPath");
			// szCurKBPath = _("KnowledgeBasePath");
			// szCurKBBackupPath = _("KBBackupPath");

			wxString localPath = folderPath; // target work folder after the fix is done

			// do the actual path fixes
			FixBasicConfigPaths(customPathsFix, &f, basePath, localPath);

			// whm 23Feb10 Note: FixConfigFileFonts() is called in the parallel MakeForeighProjectConfigFileSafe().

			#ifndef _UNICODE
			// ANSI
			bSuccessful = f.Write(); // write ANSI file back to disk
			#else
			// UNICODE
			bSuccessful = f.Write(); // write UNICODE file back to disk
									 // whm note: default is to use wxConvUTF8 in Unicode build
			#endif
			if (!bSuccessful)
			{
				// could not update the config file so inform developer
				wxMessageBox(
_T("Unable to write adjusted Administrator basic config file for custom location, so abort"));
				wxExit();
				return;
			}
		}
		else
		{
			// this block for when m_bLockedCustomWorkFolderPath is TRUE
			// The actions here are:
			// a) clone the current AI-AdminBasicConfiguration.aic file - there has to
			// be one as a consequence of the prior Locate Custom Work Folder command
			// b) give the clone the name AI-BasicConfiguration.aic, and store it in
			// the custom work folder location
			// Note: the AI-BasicConfiguration.aic file will contain the work folder path
			// string in its szAdaptitPath line, but this is unused at startup, rather,
			// the path in the CustomWorkFolderLocation file is used, and that is accessed,
			// in OnInit(), before the basic configuration file is read.

			// If there is already an AI-BasicConfiguration.aic file at the custom work
			// folder location, then use that - and fix its five ciritical paths; but if
			// not, then clone the AI-AdminBasicConfiguration.aic file which is at the
			// default work folder location (it already has the custom path stored in its
			// szAdaptitPath line) and give it the new name of AI-BasicConfiguration.aic,
			// but store it at the custom work folder location - because code comes
			// through this block only when m_bLockedCustomWorkFolderPath is TRUE, as is
			// the case when Lock Custom Location is clicked for the first time, or when
			// returning in a later session to the permanently locked custom work folder
			// location.

			wxLogNull logNo; // avoid spurious messages from the system

			wxString configPath_Basic_CustomLoc = folderPath + PathSeparator + configFName;
			wxString configPath_Admin_DefaultLoc = m_workFolderPath + PathSeparator
													+ *adminConfigFNamePtr;
			bool bBasicConfigFileAtCustomLoc = ::wxFileExists(configPath_Basic_CustomLoc);
			if (bBasicConfigFileAtCustomLoc)
			{
				// we must be returning to the already permanent custom location to get the
				// AI-BasicConfiguration.aic file stored there at an earlier session, but
				// although we expect it's internal paths to be correct already, we'll go
				// through the fixing process in order to guarantee that fact
				basePath = folderPath;
			}
			else
			{
				// must be the case that Lock Custom Location has just been clicked and
				// there is no AI-BasicConfiguration.aic file at the custom location yet,
				// so we must clone the default work folder location's
				// AI-AdminBasicConfiguration.aic file, and store it at the custom
				// location with the name AI-BasicConfiguration.aic -- and although we
				// expect it's internal paths don't need fixing, we'll do so to guarantee
				// they point where they should
				bool bRemoveCloneSource = FALSE; // set TRUE if we need later to remove a
												 // temporary basic config file saved to
												 // disk only for cloning purposes
				bool bCloneableBasicConfigFilePresent = TRUE;
				bCloneableBasicConfigFilePresent = ::wxFileExists(configPath_Admin_DefaultLoc);
				if (bCloneableBasicConfigFilePresent)
				{
					// a cloneable AI-AdminBasicConfiguration.aic file is at the default
					// work folder location, so use that one for the clone operation
					wxFileInputStream fis(configPath_Admin_DefaultLoc);
					if (fis.IsOk())
					{
						wxFileOutputStream fos(configPath_Basic_CustomLoc);
						if (fos.IsOk())
						{
							// copy the input stream's data to the output streams file
							fos.Write(fis);
						}
					}
					basePath = folderPath;
				}
				else
				{
					// we don't expect that  a cloneable admin basic config file is not
					// present at the default location, but since it has happened, we can force
					// one to be temporarily created there and clone from that
					bRemoveCloneSource = TRUE;
					basePath = m_workFolderPath;
					bool bWrittenOK = WriteConfigurationFile(*adminConfigFNamePtr,basePath,basicConfigFile);
					if (!bWrittenOK)
					{
						// fatal error, shouldn't happen, but if it does alert developer and
						// exit app
						wxMessageBox(
_T("MakeForeignBasicConfigFileSafe(): forcing write of a temporary admin basic config file for cloning failed. Aborting..."));
						LogUserAction(_T("MakeForeignBasicConfigFileSafe(): forcing write of a temporary admin basic config file for cloning failed. Aborting..."));
						// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
						wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
						return;
					}
					wxFileInputStream fis(configPath_Admin_DefaultLoc);
					if (fis.IsOk())
					{
						wxFileOutputStream fos(configPath_Basic_CustomLoc);
						if (fos.IsOk())
						{
							// copy the input stream's data to the output streams file
							fos.Write(fis);
						}
					}
                    // now remove the source of the clone (we could instead leave it here
                    // as a corrective measure, but as it is a concocted one from the
                    // administrator's current app state it probably should be removed, as
                    // it represents a state which never occurred previously)
					if (bRemoveCloneSource)
					{
						if (::wxFileExists(configPath_Admin_DefaultLoc))
							::wxRemoveFile(configPath_Admin_DefaultLoc);
						// we don't care if the removal didn't happen, so ignore a FALSE value
						// returned (we don't expect to ever get FALSE returned here)
					}
					basePath = folderPath;
				}
			}

			// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
			wxTextFile f;
			#ifndef _UNICODE
			// ANSI
			bool bSuccessful = f.Open(configPath_Basic_CustomLoc); // read ANSI file into memory
			#else
			// UNICODE
			bool bSuccessful = f.Open(configPath_Basic_CustomLoc, wxConvUTF8); // read UNICODE file into memory
			#endif
			if (!bSuccessful)
			{
				// there was a problem opening the file
				wxString str = _T("MakeForeignBasicConfigFileSafe() failed, path to the folder was  %s. Aborting...");
				wxMessageBox(str, _T("Could not open basic config file"), wxICON_ERROR);
				LogUserAction(_T("MakeForeignBasicConfigFileSafe(): Could not open basic config file. Aborting..."));
				// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
				wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
				return;
			}
            // The entire basic config file is now on disk with the path name
            // configPath_Basic_CustomLoc, and we can modify the lines we want to change.
            // Basically we want the set the critical paths to point at the relevant
            // folders in the non-standard location

			// The five paths of concern are:
			// szAdaptitPath = _("AdaptItPath");
			// szCurLanguagesPath = _("ProjectFolderPath");
			// szCurAdaptionsPath = _("DocumentsFolderPath");
			// szCurKBPath = _("KnowledgeBasePath");
			// szCurKBBackupPath = _("KBBackupPath");

			wxString localPath = folderPath; // target work folder after the fix is done

			// do the actual path fixes
			FixBasicConfigPaths(customPathsFix, &f, basePath, localPath);

			// whm 23Feb10 Note: FixConfigFileFonts() is called in the parallel MakeForeighProjectConfigFileSafe().

			#ifndef _UNICODE
			// ANSI
			bSuccessful = f.Write(); // write ANSI file back to disk
			#else
			// UNICODE
			bSuccessful = f.Write(); // write UNICODE file back to disk
									 // whm note: default is to use wxConvUTF8 in Unicode build
			#endif
			if (!bSuccessful)
			{
				// could not update the config file so inform developer
				wxMessageBox(
_T("Unable to write adjusted basic config file for persistent custom location, so abort"));
				LogUserAction(_T("MakeForeignBasicConfigFileSafe(): Unable to write adjusted basic config file for persistent custom location. Aborting..."));
				// whm modified 25Jan12. Calling wxKill() on the current process is a quiet way to terminate.
				wxKill(::wxGetProcessId(),wxSIGKILL); // abort();
				return;
			}
		}
	}
}


////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      configFName         -> the default name of the project config file (this
///									   is always AI-ProjectConfiguration.aic)
/// \param      folderPath          -> the project folder path m_curProjectPath
/// \param      adminConfigFName    -> pointer to the name of the administor configuration
///                                    file name, for use when m_bUseCustomWorkFolderPath
///                                    is TRUE, because administrator is looking into a
///                                    work folder stored at a custom location on the
///                                    machine or on a remote machine connected to the LAN
///                                    (default is NULL, when accessing legacy location,
///                                    and for that the m_bUseCustomWorkFolderPath flag is
///                                    FALSE) (This name, if supplied, is always
///									   AI-AdminProjectConfiguration.aic)
/// \remarks
/// Called from: The App's GetProjectConfiguration().
/// whm created 24Feb10 to incorporate font mismatch handling via a helper function called
/// FixConfigFileFonts() which parallels Bruce's FixBasicConfigPaths().
/// This function parallels the MakeForeignBasicConfigFileSafe() function, but rather than
/// dealing with foreign paths that might be detected in the config file, this function
/// adjusts the font(s) if mismatches are detected in incoming project configuration files.
/// This function also creates an AI-AdminProjectConfiguration.aic file when necessary to
/// avoid modifying the regular project config files (both those of the remote user and of
/// the administrator) while the administrator is accessing the project remotely.
///
/// The AI-AdminProjectConfiguration.aic file, if created, will not exist in a project
/// folder, but in the current work folder, and its contents are significant only during
/// the time the administrator is accessing the remote project. The contents of the
/// AI-AdminProjectConfiguration.aic file are recreated for each project folder the
/// administrator accesses remotely.
////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::MakeForeignProjectConfigFileSafe(wxString& configFName,wxString& folderPath,
											wxString* adminConfigFNamePtr)
{
	wxString basePath = _T("");
	if ((m_customWorkFolderPath == m_workFolderPath) || !m_bUseCustomWorkFolderPath)
	{
		// We are NOT using a custom work folder path.
        // We can check for font mismatches in project config files even when we are not
        // using a custom work folder path, as there could be font mismatches because the
        // project folder was copied from another computer to the current work folder at
        // m_workFolderPath.

		// The PathSeparator becomes the appropriate symbol; \ on Windows, / on Linux
		if (folderPath.GetChar(folderPath.Length() - 1) == PathSeparator)
		{
			folderPath.RemoveLast(); // remove the PathSeparator char
				// at the end of the path string, so next line won't give two contiguous

		}
		wxString configPath = folderPath + PathSeparator + configFName;

		// For small config type text files, wxTextFile is probably most convenient. A version
		// of the Open() function also understands Unicode, so we don't need to distinguish
		// for example CStdioFile from CStdioFileEx. We just conditional compile with the
		// appropriate methods for Unicode.

		wxTextFile f;
		// Under wxWidgets wxTextFile actually reads the entire file into memory at the Open()
		// call. It is set up so we can treat it as a line oriented text file while in memory,
		// modifying it, then writing it back out to persistent storage with a single
		// call to Write().

		wxLogNull logNo; // avoid spurious messages from the system

		// wx note: To avoid an annoying system message that pops up if Open is called on
		// a non-existing file, we'll check for its existence first, and return immediately
		// if it doesn't exist
		if (!::wxFileExists(configPath))
			return;
		// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
		#ifndef _UNICODE
		// ANSI
		bool bSuccessful = f.Open(configPath); // read ANSI file into memory
		#else
		// UNICODE
		bool bSuccessful = f.Open(configPath, wxConvUTF8); // read UNICODE file into memory
		#endif
		if (!bSuccessful)
			// there was a problem opening the file, so we'll just return
			return;

		// The entire basic config file is now in memory and we can modify the lines we want
		// to change.
		//
		// FixConfigFileFonts() deals intelligently with mismatch between fonts contained in
		// the foreign config file and those available on the local machine. In this case we
		// are not dealing with a custom work folder location, but we may still have to deal
		// with a foreign basic config file that gets copied from a "foreign" machine that
		// has fonts not found on the local machine.
		// FixConfigFilefonts() displays a message to the user if no suitable font(s) could
		// be found.
		FixConfigFileFonts(&f);

		#ifndef _UNICODE
		// ANSI
		bSuccessful = f.Write(); // write ANSI file back to disk
		#else
		// UNICODE
		bSuccessful = f.Write(); // write UNICODE file back to disk
								 // whm note: default is to use wxConvUTF8 in Unicode build
		#endif
		if (!bSuccessful)
		{
			// could not update the config file so inform user
			wxMessageBox(_("Unable to write updated config file, so just did nothing"));
			return;
		}
	}
	else
	{
		// We are using a custom work folder path. If m_bLockedCustomWorkFolderPath if FALSE
		// we are just looking at someone's project folder in a custom location and need to
		// set up and use an admin project config file. If m_bLockedCustomWorkFolderPath is
		// TRUE we can go ahead and use the project config file for that project's folder
		// itself. Note: When we are looking at a project folder over a network (as opposed
		// to a project folder at a custom work folder on the same computer) the custom work
		// folder location cannot be locked and m_bLockedCustomWorkFolderPath will be FALSE.
		if (!m_bLockedCustomWorkFolderPath)
		{
			// this block for when the administrator is looking at a project in someone's work
			// folder in a custom location, and an AI-AdminProjectConfiguration.aic file needs
			// to be found there to "fix". If an AI-AdminProjectConfiguration.aic file already
			// exists in the project folder of the custom location we check it and fix it if
			// necessary. But if there is not an admin project config file yet in project folder
			// (in the custom location) being accessed, we resort to the expedient of generating
			// a normal project config file from the administrator's own project config settings,
			// renaming it, and fixing the fonts in that one. Hence by one means or another we
			// obtain a configuration file for cloning, modify its contents and save them to a
			// different file called AI_AdminProjectConfiguration.aic, in the administrator's
			// default work folder location (the latter is always pointed at by the path in
			// m_workFolderLocation)

			wxLogNull logNo; // avoid spurious messages from the system

			bool bRemoveCloneSource = FALSE; // set TRUE if we need later to remove a temporary
											 // project config file saved to disk only for cloning
											 // purposes
			wxString configPath = m_curProjectPath + PathSeparator + configFName; // use native separator
			// construct the path for where to save the admin project config file from the
			// administrator's machine's default work folder path (if he uses a custom work
			// folder location, there won't be a project config file in the default location,
			// but no matter, we can force one to be temporarily saved there for cloning
			// purposes and then remove it afterwards)
			wxString adminConfigPath = m_curProjectPath + PathSeparator + *adminConfigFNamePtr;
			// now check if configPath contains a basic config file we can use for cloning, we
			// can use a normal one, or an already existing administrator's one if such is present
			bool bCloneableProjectConfigFilePresent = TRUE;
			bCloneableProjectConfigFilePresent = ::wxFileExists(adminConfigPath); // best choice
			bool bBestChoice = bCloneableProjectConfigFilePresent;
			if (!bCloneableProjectConfigFilePresent)
			{
				// no admin project config file is present, and since project config files are
				// not stored in m_workFolderPath there is
				bCloneableProjectConfigFilePresent = ::wxFileExists(configPath);
			}
			basePath = m_curProjectPath;
			if (!bCloneableProjectConfigFilePresent)
			{
				// none available, so force one to be written out to m_workFolderPath
				// and then use that, and remove the one we forced after the cloning is
				// done further below; parameter 2 in the following call forces writing
				// of a project config file rather than a basic one
				bool bWrittenOK = WriteConfigurationFile(szProjectConfiguration,basePath,projectConfigFile);
				if (!bWrittenOK)
				{
					// shouldn't happen, but if it does we'll quietly return without
					// trying to mess with font mismatches
					return;
				}
				bRemoveCloneSource = TRUE;
			}
			// once here, basePath has the path to whatever folder stores the project config file
			// we are going to clone off; bBestChoice tells us which it will be.
			wxTextFile f;
			// Under wxWidgets wxTextFile actually reads the entire file into memory at the Open()
			// call. It is set up so we can treat it as a line oriented text file while in memory,
			// modifying it, then writing it back out to persistent storage with a single
			// call to Write().

			// At this point we must clone the configPath file, and give the clone the
			// adminConfigPath filename. But if an admin project config file already exists, we
			// don't need to clone it, but just fix it's contents further below.
			bool bRemoved = TRUE;
			if (!bBestChoice)
			{
				wxFileInputStream fis(configPath);
				if (fis.IsOk())
				{
					wxFileOutputStream fos(adminConfigPath);
					if (fos.IsOk())
					{
						// copy the input stream's data to the output streams file
						fos.Write(fis);
					}
				}
			}

			// if we forced a cloneable project config file to be written, now remove it
			if (bRemoveCloneSource)
			{
				if (::wxFileExists(configPath))
					bRemoved = ::wxRemoveFile(configPath);
				bRemoved = bRemoved; // avoid warning (BEW 2Jan12, keep <- this unchanged)
				// we don't care if the removal didn't happen, so ignore a FALSE value
				// returned (we don't expect to ever get FALSE returned here)
			}

			// now work exclusively with the adminConfigPath clone of the project config file,
			// or with the previous admin project config file if one was already present
			if (!::wxFileExists(adminConfigPath))
			{
				// eh!? We just got it, and now it's not there?! Tell developer and exit app
				wxMessageBox(
	_T("MakeForeignProjectConfigFileSafe(): adminConfigPath's admin project config file somehow doesn't exist!!"));
				//wxExit(); // not serious enough in this case to shut down
				return;
			}

			// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
			#ifndef _UNICODE
			// ANSI
			bool bSuccessful = f.Open(adminConfigPath); // read ANSI file into memory
			#else
			// UNICODE
			bool bSuccessful = f.Open(adminConfigPath, wxConvUTF8); // read UNICODE file into memory
			#endif
			if (!bSuccessful)
			{
				// there was a problem opening the file, so we'll just shut down after warning
				// developer
				wxMessageBox(
_T("MakeForeignProjectConfigFileSafe(): custom location block, could not open adminConfigPath file."));
				//wxExit(); // not serious enough in this case to shut down
				return;
			}
			// The entire cloned project config file is now in memory under the name
			// adminConfigPath, and we can modify the lines we want to change.

			// FixConfigFileFonts() deals intelligently with mismatch between fonts contained
			// in the foreign config file and those available on the local machine.
			// In this case the custom work folder location is used but it is NOT locked,
			// so we are likely to get references to fonts that are different from the fonts
			// installed on the local machine.
			FixConfigFileFonts(&f);

			#ifndef _UNICODE
			// ANSI
			bSuccessful = f.Write(); // write ANSI file back to disk
			#else
			// UNICODE
			bSuccessful = f.Write(); // write UNICODE file back to disk
									 // whm note: default is to use wxConvUTF8 in Unicode build
			#endif
			if (!bSuccessful)
			{
				// could not update the config file so inform developer
				wxMessageBox(
_T("Unable to write adjusted Administrator project config file for custom location"));
				//wxExit(); // not serious enough in this case to shut down
				return;
			}
		}
		else
		{
			// This block for when m_bLockedCustomWorkFolderPath is TRUE
			// If there is already an AI-ProjectConfiguration.aic file in a project folder
			// of the custom work folder location, then use that - and fix its fonts; but if
			// not, then clone any AI-AdminProjectConfiguration.aic file which is at the
			// default work folder location (or generate one if necessary) and give it the
			// new name of AI-ProjectConfiguration.aic, but store it in the approproate
			// project folder at the custom work folder location - because code comes
			// through this block only when m_bLockedCustomWorkFolderPath is TRUE, as is
			// the case when Lock Custom Location is clicked for the first time, or when
			// returning in a later session to the permanently locked custom work folder
			// location.

			wxTextFile f;
			// Under wxWidgets wxTextFile actually reads the entire file into memory at the Open()
			// call. It is set up so we can treat it as a line oriented text file while in memory,
			// modifying it, then writing it back out to persistent storage with a single
			// call to Write().
			wxString configPath = m_curProjectPath + PathSeparator + configFName; // use native separator
			wxString configPath_Admin_DefaultLoc = m_workFolderPath + PathSeparator
													+ *adminConfigFNamePtr;
			wxLogNull logNo; // avoid spurious messages from the system

			if (::wxFileExists(configPath))
			{
				// There is a project config file at m_curProjectPath, so use it and adjust for
				// font mismatches if necessary

				// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
				#ifndef _UNICODE
				// ANSI
				bool bSuccessful = f.Open(configPath); // read ANSI file into memory
				#else
				// UNICODE
				bool bSuccessful = f.Open(configPath, wxConvUTF8); // read UNICODE file into memory
				#endif
				if (!bSuccessful)
					// there was a problem opening the file, so we'll just return
					return;

				// The entire project config file is now in memory and we can modify the lines we want
				// to change.
				//
				// FixConfigFileFonts() deals intelligently with mismatch between fonts contained in
				// the foreign config file and those available on the local machine. In this case we
				// are not dealing with a custom work folder location, but we may still have to deal
				// with a foreign project config file that gets copied from a "foreign" machine that
				// has fonts not found on the local machine.
				// FixConfigFilefonts() displays a message to the user if no suitable font(s) could
				// be found.
				FixConfigFileFonts(&f);

				#ifndef _UNICODE
				// ANSI
				bSuccessful = f.Write(); // write ANSI file back to disk
				#else
				// UNICODE
				bSuccessful = f.Write(); // write UNICODE file back to disk
										 // whm note: default is to use wxConvUTF8 in Unicode build
				#endif
				if (!bSuccessful)
				{
					// could not update the config file so inform user
					wxMessageBox(_("Unable to write updated config file, so just did nothing"));
					return;
				}
			}
			// See if there is an admin project config file at m_workFolderPath that
			// can be used
			else if (::wxFileExists(configPath_Admin_DefaultLoc))
			{
				// A cloneable AI-AdminProjectConfiguration.aic file is at the default
				// work folder location, so use that one for the clone operation.
				wxFileInputStream fis(configPath_Admin_DefaultLoc);
				if (fis.IsOk())
				{
					wxFileOutputStream fos(configPath);
					if (fos.IsOk())
					{
						// copy the input stream's data to the output streams file
						fos.Write(fis);
					}
				}

				// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
				#ifndef _UNICODE
				// ANSI
				bool bSuccessful = f.Open(configPath); // read ANSI file into memory
				#else
				// UNICODE
				bool bSuccessful = f.Open(configPath, wxConvUTF8); // read UNICODE file into memory
				#endif
				if (!bSuccessful)
					// there was a problem opening the file, so we'll just return
					return;

				// The entire project config file is now in memory and we can modify the lines we want
				// to change.
				//
				// FixConfigFileFonts() deals intelligently with mismatch between fonts contained in
				// the foreign config file and those available on the local machine. In this case we
				// are not dealing with a custom work folder location, but we may still have to deal
				// with a foreign project config file that gets copied from a "foreign" machine that
				// has fonts not found on the local machine.
				// FixConfigFilefonts() displays a message to the user if no suitable font(s) could
				// be found.
				FixConfigFileFonts(&f);

				#ifndef _UNICODE
				// ANSI
				bSuccessful = f.Write(); // write ANSI file back to disk
				#else
				// UNICODE
				bSuccessful = f.Write(); // write UNICODE file back to disk
										 // whm note: default is to use wxConvUTF8 in Unicode build
				#endif
				if (!bSuccessful)
				{
					// could not update the config file so inform user
					wxMessageBox(_("Unable to write updated config file, so just did nothing"));
					return;
				}
			}
			else
			{
				// There is no project config file we can clone, so we just generate one in
				// m_curProjectPath (where the path to the file is configPath) using our current
				// instance's settings
				bool bOK;
				bOK = WriteConfigurationFile(szProjectConfiguration,m_curProjectPath,projectConfigFile);
				wxCHECK_RET(bOK, _T("MakeForeignProjectConfigFileSafe(): WriteConfigurationFile() failed, line 38,585 in Adapt_It.cpp"));
				// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
				#ifndef _UNICODE
				// ANSI
				bool bSuccessful = f.Open(configPath); // read ANSI file into memory
				#else
				// UNICODE
				bool bSuccessful = f.Open(configPath, wxConvUTF8); // read UNICODE file into memory
				#endif
				if (!bSuccessful)
					// there was a problem opening the file, so we'll just return
					return;

				// The entire project config file is now in memory and we can modify the lines we want
				// to change.
				//
				// FixConfigFileFonts() deals intelligently with mismatch between fonts contained in
				// the foreign config file and those available on the local machine. In this case we
				// are not dealing with a custom work folder location, but we may still have to deal
				// with a foreign project config file that gets copied from a "foreign" machine that
				// has fonts not found on the local machine.
				// FixConfigFilefonts() displays a message to the user if no suitable font(s) could
				// be found.
				FixConfigFileFonts(&f);

				#ifndef _UNICODE
				// ANSI
				bSuccessful = f.Write(); // write ANSI file back to disk
				#else
				// UNICODE
				bSuccessful = f.Write(); // write UNICODE file back to disk
										 // whm note: default is to use wxConvUTF8 in Unicode build
				#endif
				if (!bSuccessful)
				{
					// could not update the config file so inform user
					wxMessageBox(_("Unable to write updated config file, so just did nothing"));
					return;
				}
			}
		}
	} // end of else [using a custom work folder location]
}

void  CAdapt_ItApp::OnMoveOrCopyFoldersOrFiles(wxCommandEvent& event)
{
	if (event.GetId() == ID_MOVE_OR_COPY_FOLDERS_OR_FILES)
	{
		LogUserAction(_T("Initiated OnMoveOrCopyFoldersOrFiles()"));
	}

	if (m_bReadOnlyAccess)
	{
		return;
	}
	AdminMoveOrCopy dlg(GetMainFrame());
	dlg.Center();
	if (dlg.ShowModal() == wxID_OK)
	{
		LogUserAction(_T("Closed OnMoveOrCopyFoldersOrFiles()"));
	}
}

void CAdapt_ItApp::OnUpdateMoveOrCopyFoldersOrFiles(wxUpdateUIEvent& event)
{
	if (m_bAdminMenuRemoved)
	{
		event.Enable(FALSE);
		return;
	}
	if (m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the appropriate KB is not in a ready state this
/// handler disables the "Export Knowledge Base..." item in the File menu, otherwise it
/// enables the "Export Knowledge Base..." item on the File menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItApp::OnUpdateFileExportKb(wxUpdateUIEvent& event)
{
	if ((!gbIsGlossing && m_pKB != NULL) || (gbIsGlossing && m_pGlossingKB != NULL))
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItApp::OnFileExportKb(wxCommandEvent& WXUNUSED(event))
{
	// get a pointer to either the glossing KB or the adaptation one
	CKB* pKB;
	if (gbIsGlossing)
		pKB = m_pGlossingKB;
	else
		pKB = m_pKB;
	wxASSERT(pKB != NULL);

	// whm revised 5Aug11. We don't know what protected folder to use for KB exports
	// until the user specifies either SFM or LIFT. That specification previously
	// would occur at the time the user gets the wxFileDialog and accesses the
	// "File Type" drop-down list of options. However, with navigation protection we
	// don't provide a standard wxFileDialog where a user can make that selection.
	// Therefore, we get that decision earlier via KBExportImportOptionsDlg, and
	// not from the wxFileDialog - even when no protection is in effect. Doing so, I
	// think will simplify the file naming process too.

	// While nav protection is ON, the user doesn't see a wxFileDialog where the
	// Save As Type dropdown box is an option. So, we have to ask the user directly
	// whether s/he wants LIFT or SFM (\lx \ge) format of KB export. We'll set the
	// filterIndex according to the user's response.
	KBExportSaveAsType kbExportType = KBExportSaveAsSFM_TXT;
	CKBExportImportOptionsDlg dlg(GetMainFrame());
	dlg.Center();

	wxString actionTypeStr = _("Export Knowledge Base");
	// set dialog's title
	dlg.SetTitle(actionTypeStr);
	// set the %s substitution strings in the dialog's controls
	wxString tempStr;
	tempStr = dlg.pRadioBoxSfmOrLIFT->GetLabel();
	tempStr = tempStr.Format(tempStr,actionTypeStr.c_str());
	dlg.pRadioBoxSfmOrLIFT->SetLabel(tempStr);

	// Note: OnFileExportKb() here and OnFileExportKb() in the App use the same dialog.
	// Since the View's OnImportToKb() required that the call of
	// the second parameter of KBExportImportOptionsFunc(this, false, TRUE)
	// be false in KBExportImportOptionsDlg's constructor, we need to either:
	// (1) manually fit the dialog's size to its contents in this instance here
	// in the App, or (2) pass a parameter when constructing the dialog to make
	// the constructor use true or false as required. I've chosed to do (1) here.
	dlg.pKBExportImportOptionsDlgSizer->Layout();
	dlg.m_computedDlgSize = dlg.pKBExportImportOptionsDlgSizer->ComputeFittingWindowSize(&dlg);
	dlg.SetSize(dlg.m_computedDlgSize);
	dlg.CenterOnParent();
	if (dlg.ShowModal() == wxID_CANCEL)
	{
		// user canceled
		gpApp->LogUserAction(_T("Cancelled from OnFileExportKb()"));
		return;
	}

	// if we get here user has clicked OK to proceed
	int nRadioBoxSel;
	nRadioBoxSel = dlg.pRadioBoxSfmOrLIFT->GetSelection();
	wxASSERT(nRadioBoxSel == 0 || nRadioBoxSel == 1);
	kbExportType = (KBExportSaveAsType)nRadioBoxSel; // cast int to KBExportSaveAsType enum
	wxASSERT(kbExportType == KBExportSaveAsSFM_TXT || kbExportType == KBExportSaveAsLIFT_XML);

	// Calculate the appropriate KB export's dictFilename and defaultDir.
    // Note: In the App's SetupDirectories() function the m_curProjectName is
    // constructed as: m_sourceName + _T(" to ") + m_targetName + _T(" adaptations"),
    // so the "to" and "adaptations" parts are non-localized, i.e., we can depend on
    // them being constant in project names. All KB exports use a default name based
    // on m_curProjectName without " adaptations" part.
	wxString dictFilename;
	dictFilename = m_curProjectName; // m_curProjectName is of the form "x to y adaptations"
	int offset = dictFilename.Find(_T(' '),TRUE); // TRUE - find from right end
	dictFilename = dictFilename.Mid(0,offset); // remove "adaptations" or Tok Pisin equivalent
	// The base dictFilename is now in the form of "x to y"

	wxString defaultDir;
	wxString glossStr;
	bool bBypassFileDialog_ProtectedNavigation = FALSE;
	if (kbExportType == KBExportSaveAsSFM_TXT)
	{
		gpApp->LogUserAction(_T("SFM Export"));
		// The user wants KB export in standard format (\x and \ge).
		// Check whether navigation protection is in effect for _KB_INPUTS_OUTPUTS,
		// and whether the App's m_lastKbOutputPath is empty or has a valid path,
		// and set the defaultDir for the export accordingly.
		if (this->m_bProtectKbInputsAndOutputsFolder)
		{
			// Navigation protection is ON, so set the flag to bypass the wxFileDialog
			// and force the use of the special protected folder for the export.
			bBypassFileDialog_ProtectedNavigation = TRUE;
			defaultDir = m_kbInputsAndOutputsFolderPath;
		}
		else if (m_lastKbOutputPath.IsEmpty()
			|| (!m_lastKbOutputPath.IsEmpty() && !::wxDirExists(m_lastKbOutputPath)))
		{
			// Navigation protection is OFF so we set the flag to allow the wxFileDialog
			// to appear. But the m_lastKbOutputPath is either empty or, if not empty,
			// it points to an invalid path, so we initialize the defaultDir to point to
			// the special protected folder, even though Navigation protection is not ON.
			// In this case, the user could point the export path elsewhere using the
			// wxFileDialog that will appear.
			bBypassFileDialog_ProtectedNavigation = FALSE;
			defaultDir = m_kbInputsAndOutputsFolderPath;
		}
		else
		{
			// Navigation protection is OFF and we have a valid path in m_lastKbOutputPath,
			// so we initialize the defaultDir to point to the m_lastKbOutputPath for the
			// location of the export. The user could still point the export path elsewhere
			// in the wxFileDialog that will appear.
			bBypassFileDialog_ProtectedNavigation = FALSE;
			defaultDir = m_lastKbOutputPath;
		}
		// Add "dictionary records" and "glossing" (if gbIsGlossing) to the dictFilename
		dictFilename += _T(' ');
		dictFilename += _("dictionary records");
		if (gbIsGlossing)
		{
			glossStr = _T(" ");
			glossStr += _("glossing");
			dictFilename += glossStr; // ensure the glossing KB
									  // export has its own filename
		}
		// Add the default extension for SFM KB exports
		dictFilename += _T(".txt"); // the extension is not localizable
	}
	else if (kbExportType == KBExportSaveAsLIFT_XML)
	{
		gpApp->LogUserAction(_T("LIFT Export"));
		// Check whether navigation protection is in effect for _LIFT_INPUTS_OUTPUTS,
		// and whether the App's m_lastKbLiftOutputPath is empty or has a valid path,
		// and set the defaultDir for the export accordingly.
		if (this->m_bProtectLiftInputsAndOutputsFolder)
		{
			// Navigation protection is ON, so set the flag to bypass the wxFileDialog
			// and force the use of the special protected folder for the export.
			bBypassFileDialog_ProtectedNavigation = TRUE;
			defaultDir = m_liftInputsAndOutputsFolderPath;
		}
		else if (m_lastKbLiftOutputPath.IsEmpty()
			|| (!m_lastKbLiftOutputPath.IsEmpty() && !::wxDirExists(m_lastKbLiftOutputPath)))
		{
			// Navigation protection is OFF so we set the flag to allow the wxFileDialog
			// to appear. But the m_lastKbLiftOutputPath is either empty or, if not empty,
			// it points to an invalid path, so we initialize the defaultDir to point to
			// the special protected folder, even though Navigation protection is not ON.
			// In this case, the user could point the export path elsewhere using the
			// wxFileDialog that will appear.
			bBypassFileDialog_ProtectedNavigation = FALSE;
			defaultDir = m_liftInputsAndOutputsFolderPath;
		}
		else
		{
			// Navigation protection is OFF and we have a valid path in m_lastKbLiftOutputPath,
			// so we initialize the defaultDir to point to the m_lastKbLiftOutputPath for the
			// location of the export. The user could still point the export path elsewhere
			// in the wxFileDialog that will appear.
			bBypassFileDialog_ProtectedNavigation = FALSE;
			defaultDir = m_lastKbLiftOutputPath;
		}

		// Add " glossing" (if gbIsGlossing) to the dictFilename
		if (gbIsGlossing)
		{
			glossStr = _T(" ");
			glossStr += _("glossing");
			dictFilename += glossStr; // ensure the glossing KB
									  // export has its own filename
		}
		// Add the default extension for LIFT KB exports
		dictFilename += _T(".lift"); // the extension is not localizable
	}

	wxString exportPath;
	wxString uniqueFilenameAndPath;
	// Prepare a unique filename and path from the exportFilename. This unique filename
	// and path is used when the export is nav protected or when the user has ticked the
	// checkbox at the bottom of the ExportSaveAsDlg to indicate that a date-time stamp
	// is to be suffixed to the export filename, which ensures that any existing exports
	// are not overwritten.
	uniqueFilenameAndPath = GetUniqueIncrementedFileName(dictFilename,incrementViaDate_TimeStamp,TRUE,2,_T("_exported_")); // TRUE - always modify
	if (gpApp->m_bUseSuffixExportDateTimeOnFilename)
	{
		// Use the unique path for exportPath
		dictFilename = uniqueFilenameAndPath;
	}

	// Allow the wxFileDialog only when the export is not protected from navigation
	if (!bBypassFileDialog_ProtectedNavigation)
	{
		// get a file dialog
		wxString filter;
		if (kbExportType == KBExportSaveAsSFM_TXT)
		{
			filter = _("SFM plain text export (with \\lx & \\ge fields) (*.txt)|*.txt|All Files (*.*)|*.*||");
		}
		else if (kbExportType == KBExportSaveAsLIFT_XML)
		{
			filter = _("XML LIFT export (*.lift)|*.lift|All Files (*.*)|*.*||");
		}
		wxFileDialog fileDlg(
			(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
			_("Filename For KB Export"),
			defaultDir,	// empty string causes it to use the current working directory (set above)
			dictFilename,	// default filename
			filter,
			wxFD_SAVE | wxFD_OVERWRITE_PROMPT);
			// | wxHIDE_READONLY); wxHIDE_READONLY deprecated in 2.6 - the checkbox is never shown
			// GDLC wxSAVE & wxOVERWRITE_PROMPT deprecated in 2.8
		fileDlg.Centre();

		// make the dialog visible
		if (fileDlg.ShowModal() != wxID_OK)
		{
			gpApp->LogUserAction(_T("Cancelled from OnFileExportKb() from wxFileDialog()"));
			return; // user cancelled
		}

		// get the user's desired path and file name
		exportPath = fileDlg.GetPath();

		// whm 5Aug11 note: When nav protection is OFF, we allow the user to
		// determine the dictFilename's extension for SFM exports (default is .txt)
		// but we need to force the extension to be .lift for LIFT exports even if
		// the user has typed a different extension
		wxString path, fname, ext;
		wxFileName::SplitPath(exportPath, &path, &fname, &ext);
		if (kbExportType == KBExportSaveAsLIFT_XML)
		{
			if (ext != _T("lift"))
			{
				exportPath = path + PathSeparator + fname + _T('.') + _T("lift");
			}
		}
	}
	else
	{
		// While nav protection is ON, the user doesn't see a wxFileDialog but we set
		// the path and filename automatically depending on the kbExportType.
		if (kbExportType == KBExportSaveAsSFM_TXT)
		{
			// determine exportPath to the _KB_INPUTS_OUTPUTS folder using the dictFilename
			exportPath = gpApp->m_kbInputsAndOutputsFolderPath + gpApp->PathSeparator + dictFilename;
		}
		else if (kbExportType == KBExportSaveAsLIFT_XML)
		{
			// determine exportPath to the _LIFT_INPUTS_OUTPUTS folder using the dictFilename
			exportPath = gpApp->m_liftInputsAndOutputsFolderPath + gpApp->PathSeparator + dictFilename;
		}
	}

	wxFile f;
	if( !f.Open(exportPath, wxFile::write))
	{
		wxMessageBox(_("Unable to open knowledge base export file."),
		_T(""), wxICON_WARNING);
		gpApp->LogUserAction(_T("Unable to open knowledge base export file."));
		return; // return since it is not a fatal error
	}

	// whm Note: We set the App's m_lastKbOutputPath and/or m_lastKbLiftOutputPath
	// variables with the path part of the exportPath just used. We do this even when
	// navigation protection is on, so that the special folders would be the initial
	// path suggested if the administrator were to switch Navigation Protection OFF.
	wxString path, fname, ext;
	wxFileName::SplitPath(exportPath, &path, &fname, &ext);

	// Update the m_last...Path variables as appropriate.
	if (kbExportType == KBExportSaveAsSFM_TXT)
	{
        // the user chose Save As Type of "SFM plain text export (with \\lx & \\ge fields)
        // (*.txt)" or "All Files (*.*)" which we assume would be same as "SFM plain text
        // export..."
		pKB->DoKBExport(&f,KBExportSaveAsSFM_TXT);

		// update m_lastKbOutputPath
		m_lastKbOutputPath = path;
	}
	else if (kbExportType == KBExportSaveAsLIFT_XML)
	{
		pKB->DoKBExport(&f,KBExportSaveAsLIFT_XML);

		// update m_lastKbLiftOutputPath
		m_lastKbLiftOutputPath = path;
	}
	// close the file
	f.Close();

	// whm revised 5Aug11 to always inform the user of the completion of
	// the export operation.
	// Report the completion of the export to the user.
	// Note: For protected navigation situations AI determines the actual
	// filename that is used for the export, and the export itself is
	// automatically saved in the appropriate outputs folder. Especially
	// in these situations where the user has no opportunity to provide a
	// file name nor navigate to a random path, we should inform the user
	// of the successful completion of the export, and indicate the file
	// name that was used and its outputs folder name and location.
	wxFileName fn(exportPath);
	wxString fileNameAndExtOnly = fn.GetFullName();

	wxString msg;
	msg = msg.Format(_("The exported file was named:\n\n%s\n\nIt was saved at the following path:\n\n%s"),fileNameAndExtOnly.c_str(),exportPath.c_str());
	wxMessageBox(msg,_("Export operation successful"),wxICON_INFORMATION);
	gpApp->LogUserAction(_T("Export operation successful"));
}

#ifdef __WXDEBUG__
void CAdapt_ItApp::ShowFilterMarkers(int refNum)
{
	refNum = refNum; // avoid compiler warning
	/* for displaying rapid-access markers in UsfmFilterMarkersStr
	wxString s = UsfmFilterMarkersStr;
	wxArrayString arr;
	wxStringTokenizer tokens(s);
	while (tokens.HasMoreTokens())
	{
		wxString mkr = tokens.GetNextToken();
		mkr += _T(" ");
		arr.Add(mkr);
	}
	int total = arr.GetCount();
	int remainder = total;
	int curCount = 0;
	int lastLineHas = 0;
	s.Empty();
	// chop it into lines with 10 markers each
	while (remainder > 0)
	{
		wxString mkr = arr.Item(curCount);
		s += mkr;
		curCount++;
		lastLineHas++;
		remainder--;
		if (lastLineHas == 10)
		{
			s += _T("\n"); // start a new line
			lastLineHas = 0;
		}
	}

	wxString msg;
	msg = msg.Format(_T("***FILTERED MARKERS:    location: %d\n%s\nEND FILTERED MARKERS***"),
		refNum, s.c_str());
	wxLogDebug(msg);
	*/
}
#endif


///////////////////////////////////////////////////////////////////////////////
/// \return		a wxArrayString that contains usable Paratext projects on the
///             host computer, formatted in string format with fields separated
///             by ':' delimiters (see remarks)
/// \remarks
/// Called from: the CGetSourceTextFromEditorDlg::InitDialog and
/// CSetupEditorCollaboration::InitDialog.
/// Gathers a list of "usable" Paratext (PT) projects from the user's
/// PT installation (if PT 7.1 is installed). A "usable" PT project is
/// one which is not a PT "resource" project. It parses the PT project's
/// .ssf files extracting from the xml the various properties described
/// for the given PT project.
///
/// As a side effect, this function populates the App's m_pArrayOfCollabProjects
/// array of pointers to Collab_Project_Info_Struct structs stored on the heap.
/// In the returned wxArrayString, each string element contains identifying
/// fields structured as follows:
/// "shortName : fullName : languageName : ethnologueCode"
/// The ethnologueCode field is optional and won't appear unless the user has
/// explicitly entered it in for LIFT file properites within PT.
/// This string is used in various places such as the combo box controls the
/// "Setup Paratext Collaboration... and "Get Source Text from Paratext Project".
/// It is also used in the basic config file as string values for the
/// PTProjectForSourceInputs and PTProjectForTargetExports entries.
///////////////////////////////////////////////////////////////////////////////
wxArrayString CAdapt_ItApp::GetListOfPTProjects()
{
	wxArrayString tempListOfPTProjects;
	tempListOfPTProjects.Clear();
	// deallocate any memory for items currently in list on heap
	int aTot = (int)m_pArrayOfCollabProjects->GetCount();
	if (aTot > 0)
	{
		int aIndex;
		for (aIndex = 0; aIndex < aTot; aIndex++)
		{
			Collab_Project_Info_Struct* pArrayItem = (Collab_Project_Info_Struct*)(*m_pArrayOfCollabProjects)[aIndex];
			delete pArrayItem;
		}
		m_pArrayOfCollabProjects->Clear();
	}
	wxString PT_ProjectsDirPath;
	PT_ProjectsDirPath = GetParatextProjectsDirPath();
	// Note: PT_ProjectsDirPath will end with a backslash
	// Within the PT_ProjectsDirPath folder, the Paratext projects each have a file
	// composed of the abbreviated PT project name with a .ssf extension.
	// Resource projects under Paratext cannot be used as collaboration projects
	// (technically they could be read from, but we cannot assume that is possible
	// without specific permission of UBS).
	// So, we read each <file>.ssf within the folder and determine if the project
	// represented is a candidate for Adapt It collaboration (either for reading
	// as source texts, or for transferring AI-produced translation drafts).

	// PT's ssf files are small xml formatted files. We only need some values from
	// the file, so rather than using our XML reading routines, I think it will be
	// more efficient to just use the xxTextFile class to read each xml formatted
	// file into memory and read the information we need from it there.

	wxDir finder;
	bool bOK = (::wxSetWorkingDirectory(PT_ProjectsDirPath) &&
								finder.Open(PT_ProjectsDirPath));
								// wxDir must call .Open() before enumerating files!
	if (!bOK)
	{
		// TODO: error
	}

	// Must call wxDir::Open() before calling GetFirst() - see above
	wxString str = _T("");
	// whm note: in GetFirst below, the wxDIR_FILES flag finds
	// files only, not . nor .. nor hidden files
	bool bWorking = finder.GetFirst(&str,_T("*.ssf"),wxDIR_FILES);
	while (bWorking)
	{
		// the str variable contains the found .ssf file (case is ignored
		// so it will find .ssf as well as .SSF files).
		//wxLogDebug(_T("Found file: %s"),str.c_str());

		// open the .ssf file and glean the necessary information to
		// determine if the project is a potential collaboration project
		wxTextFile f;
		bool bFileExists = wxFileExists(str);
		if (bFileExists)
		{
			bool bOpenedOK;
			bOpenedOK = f.Open(str);
			if (bOpenedOK)
			{
				// The ssf file is now in memory and accessible line-by-line using wxTextFile
				// methods.

				Collab_Project_Info_Struct* pPTInfo = new Collab_Project_Info_Struct;
				pPTInfo->booksPresentFlags = _T("");
				pPTInfo->ethnologueCode = _T("");
				pPTInfo->fullName = _T("");
				pPTInfo->languageName = _T("");
				pPTInfo->projectDir = _T("");
				pPTInfo->shortName = _T("");
				pPTInfo->versification = _T("");
				pPTInfo->chapterMarker = _T("c"); // default is c
				pPTInfo->verseMarker = _T("v"); // default is v
				pPTInfo->defaultFont = _T("Arial"); // default is Arial
				pPTInfo->defaultFontSize = _T("10"); // default is 10
				pPTInfo->leftToRight = _T("T"); // default is T
				pPTInfo->encoding = _T("65001"); // default is 65001 (UTF8)
				pPTInfo->bProjectIsNotResource = TRUE;
				pPTInfo->bProjectIsEditable = TRUE;

				// Initialize some variables for fields we are interested in.
				wxString booksPresentFlags = _T("");
				wxString ethnologueCode = _T("");
				wxString fullName = _T("");
				wxString languageName = _T("");
				wxString projectDir = _T("");
				wxString shortName = _T("");
				wxString versification = _T("");
				wxString chapterMarker = _T("c");
				wxString verseMarker = _T("v");
				wxString defaultFont = _T("Arial");
				wxString defaultFontSize = _T("10");
				wxString leftToRight = _T("T");
				wxString encoding = _T("65001");
				bool bProjectIsNotResource = TRUE;
				//bool bProjectIsEditable = TRUE;

				wxString lineStr;
				// scan through all lines of file setting field values as we go
				for (lineStr = f.GetFirstLine(); !f.Eof(); lineStr = f.GetNextLine())
				{
					//wxLogDebug(_T("%s"),lineStr.c_str());
					// collect data fields for filling in PTProject structs.
					lineStr.Trim(FALSE);
					lineStr.Trim(TRUE);
					wxString tagName;
					wxString endTagName;

					tagName = _T("<BooksPresent>");
					endTagName = _T("</BooksPresent>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						booksPresentFlags = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->booksPresentFlags = booksPresentFlags;
					}

					tagName = _T("<EthnologueCode>");
					endTagName = _T("</EthnologueCode>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						ethnologueCode = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->ethnologueCode = ethnologueCode;
					}

					tagName = _T("<FullName>");
					endTagName = _T("</FullName>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						fullName = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->fullName = fullName;
					}

					tagName = _T("<Language>");
					endTagName = _T("</Language>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						languageName = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->languageName = languageName;
					}

					tagName = _T("<Directory>");
					endTagName = _T("</Directory>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						projectDir = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->projectDir = projectDir;
					}

					tagName = _T("<Name>");
					endTagName = _T("</Name>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						shortName = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->shortName = shortName;
					}

					tagName = _T("<Versification>");
					endTagName = _T("</Versification>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						versification = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->versification = versification;
					}

					tagName = _T("<ChapterMarker>");
					endTagName = _T("</ChapterMarker>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						chapterMarker = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->chapterMarker = chapterMarker;
					}

					tagName = _T("<VerseMarker>");
					endTagName = _T("</VerseMarker>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						verseMarker = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->verseMarker = verseMarker;
					}

					tagName = _T("<DefaultFont>");
					endTagName = _T("</DefaultFont>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						defaultFont = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->defaultFont  = defaultFont;
					}

					tagName = _T("<DefaultFontSize>");
					endTagName = _T("</DefaultFontSize>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						defaultFontSize = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->defaultFontSize = defaultFontSize;
					}

					tagName = _T("<LeftToRight>");
					endTagName = _T("</LeftToRight>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						leftToRight = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->leftToRight = leftToRight;
					}

					tagName = _T("<Encoding>");
					endTagName = _T("</Encoding>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						encoding = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						pPTInfo->encoding = encoding;
					}

					tagName = _T("<ResourceText>");
					endTagName = _T("</ResourceText>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						wxString temp;
						temp = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						// Note: non-Resource projects often don't have the "<ResourceText>"
						// tag at all, therefore we set bProjectIsNotResource to TRUE as its
						// default, unless <ResourceText>T</ResourceText> is present.
						if (temp == _T("T"))
						{
							bProjectIsNotResource = FALSE;
							pPTInfo->bProjectIsNotResource = FALSE;
						}
					}

					tagName = _T("<Editable>");
					endTagName = _T("</Editable>");
					if (lineStr.Find(tagName) != wxNOT_FOUND)
					{
						wxString temp;
						temp = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						if (temp == _T("T"))
						{
							//bProjectIsEditable = TRUE;
							pPTInfo->bProjectIsEditable = TRUE;
						}
						else if (temp == _T("F"))
						{
							//bProjectIsEditable = FALSE;
							pPTInfo->bProjectIsEditable = FALSE;
						}
					}

				}
				wxString storageStr;
				// We do not allow collaboration with resource projects or
				// projects that have no short name, since the short name is
				// the basic PT name for the project (and the folder it is
				// contained in).
				if (bProjectIsNotResource && !shortName.IsEmpty())
				{
					storageStr = shortName;
					if (!fullName.IsEmpty())
					{
						storageStr += _T(" : ") + fullName;
					}
					if (!languageName.IsEmpty())
					{
						storageStr += _T(" : ") + languageName;
					}
					if (!ethnologueCode.IsEmpty())
					{
						storageStr += _T(" : ") + ethnologueCode;
					}
					tempListOfPTProjects.Add(storageStr);
					m_pArrayOfCollabProjects->Add(pPTInfo);
				}
				else
				{
					delete pPTInfo; // it's not a valid PT project we can use
				}
				f.Close();
			}
		}

		bWorking = finder.GetNext(&str);
	}

	return tempListOfPTProjects;
}

// See comments on the GetListOfPTProjects() function above.
// For Bibledit, in the returned wxArrayString, each string element contains
// identifying a single field structured as follows:
// "shortName"  [note that in Bibledit's case shortName == fullName == languageName]
wxArrayString CAdapt_ItApp::GetListOfBEProjects()
{
	wxArrayString tempListOfBEProjects, tempListOfAllBEProjects;
	tempListOfBEProjects.Clear();
  	tempListOfAllBEProjects.Clear();
	// deallocate any memory for items currently in list on heap
	int aTot = (int)m_pArrayOfCollabProjects->GetCount();
	if (aTot > 0)
	{
		int aIndex;
		for (aIndex = 0; aIndex < aTot; aIndex++)
		{
			Collab_Project_Info_Struct* pArrayItem = (Collab_Project_Info_Struct*)(*m_pArrayOfCollabProjects)[aIndex];
			delete pArrayItem;
		}
		m_pArrayOfCollabProjects->Clear();
	}
	wxString BE_ProjectsDirPath;
	BE_ProjectsDirPath = GetBibleditProjectsDirPath();
	// Note: BE_ProjectsDirPath will NOT end with a backslash (in contrast to GetParatextProjectsDirPath).
	// Within the BE_ProjectsDirPath folder, the Bibledit projects are represented by
	// individual folders. Hence, we can get an inventory of Bibledit project names
	// by collecting the names of all subdirectories in this BE_ProjectsDirPath.

	wxDir finder;
	bool bOK = (::wxSetWorkingDirectory(BE_ProjectsDirPath) &&
								finder.Open(BE_ProjectsDirPath));
								// wxDir must call .Open() before enumerating files!
	if (!bOK)
	{
		// TODO: error
	}

	wxString str;
	bool bWorking = finder.GetFirst(&str,_T(""),wxDIR_DIRS);
	while (bWorking)
	{
		tempListOfAllBEProjects.Add(str);
		bWorking = finder.GetNext(&str);
	}

	// Now get information from the configuration.1.xml file(s) in each project folder
	// to use in filling out the Collab_Project_Info_Struct structs stored on the heap.
	int nTotNumProjects = (int)tempListOfAllBEProjects.GetCount();

	if (nTotNumProjects > 0)
	{
		// Open the configuration.1.xml file in each project folder and glean the
		// necessary information populating the Collab_Project_Info_Struct fields
		// for the given project.
		int projCt;
		for (projCt = 0; projCt < nTotNumProjects; projCt++)
		{
			wxString projConfigFilePath;
			wxString projName = tempListOfAllBEProjects.Item(projCt);
			wxString projPath = BE_ProjectsDirPath + PathSeparator + projName;
			projConfigFilePath = projPath + PathSeparator + _T("configuration.1.xml");
			wxTextFile f;
			bool bFileExists = wxFileExists(projConfigFilePath);
			if (bFileExists)
			{
				bool bOpenedOK;
				bOpenedOK = f.Open(projConfigFilePath);
				if (bOpenedOK)
				{
					// The ssf file is now in memory and accessible line-by-line using wxTextFile
					// methods.

					Collab_Project_Info_Struct* pBEInfo = new Collab_Project_Info_Struct;
					pBEInfo->booksPresentFlags = _T(""); // computed for BE
					pBEInfo->ethnologueCode = _T(""); // not used by BE
					pBEInfo->fullName = _T(""); // same as project folder name in BE
					pBEInfo->languageName = _T(""); // not well-defined in BE - we use project folder name
					pBEInfo->projectDir = _T(""); // ~/.bibledit/projects/<projName>
					pBEInfo->shortName = _T(""); // not used by BE
					pBEInfo->versification = _T(""); // differs from PT classification but we don't really use it
					pBEInfo->chapterMarker = _T("c"); // default is c; BE doesn't define it
					pBEInfo->verseMarker = _T("v"); // default is v; BE doesn't define it
					pBEInfo->defaultFont = _T("Sans"); // default is Sans; BE combines name and size together
					pBEInfo->defaultFontSize = _T("10"); // default is 10
					pBEInfo->leftToRight = _T("1"); // default is 1 (BE uses right-to-left logic)
					pBEInfo->encoding = _T("65001"); // default is 65001 (UTF8); not used by BE
					pBEInfo->bProjectIsNotResource = TRUE;
					pBEInfo->bProjectIsEditable = TRUE;

					// Initialize some variables for fields we are interested in.
					wxString booksPresentFlags = _T(""); // computed for BE
					wxString ethnologueCode = _T(""); // not used by BE
					wxString fullName = _T(""); // same as project folder name in BE
					wxString languageName = _T(""); // not well-defined in BE - we use project folder name
					wxString projectDir = _T(""); // ~/.bibledit/projects/<projName>
					wxString shortName = _T(""); // not used by BE
					wxString versification = _T(""); // differs from PT classification but we don't really use it
					wxString chapterMarker = _T("c"); // default is c; BE doesn't define it
					wxString verseMarker = _T("v"); // default is v; BE doesn't define it
					wxString defaultFont = _T("Sans"); // use Sans for Linux; BE combines name and size together
					wxString defaultFontSize = _T("10"); // default is 10
					wxString leftToRight = _T("1"); // Bibledit uses "0" or "1" rather than "F" or "T"
					wxString encoding = _T("65001"); // default is 65001 (UTF8); not used by BE
					bool bProjectIsNotResource = TRUE;
					bool bProjectIsEditable = TRUE;

					wxString lineStr;

					// The Bibledit configuration files do not have an xml field that
					// is parallel to the Paratext xml tag <BooksPresent>...</BooksPresent>.
					// Instead, we must scan the BE project's "data" directory and collect
					// the folder names within that directory. There will be a folder for
					// each Bible book name the project has data for.
					booksPresentFlags = GetBibleditBooksPresentFlagsStr(projPath);
					pBEInfo->booksPresentFlags = booksPresentFlags;
					// The full name in Paratext is equivalent of the projName in Bibledit
					// i.e., the name of the folder we are currentlyscanning.
					fullName = projName;
					pBEInfo->fullName = fullName;
					shortName = fullName;
					pBEInfo->shortName = shortName;
					// whm Note: Bibledit's configuration1.1.xml file has a <language>...</language> tag
					// but it doesn't currently represent the actual name of the language of a project,
					// because Bibledit's drop down list for Language in its project dialog only allows
					// for selecting a small number (about 16) languages. Hence, for Bibledit we
					// have to assume that the languageName is the same as the projName
					languageName = projName;
					pBEInfo->languageName = languageName;
					// I don't thing the projectDir is used anywhere, but we will set it to point to
					// the top-level folder of the Bibledit project (note project texts are located
					// deeper down within subfolders of this path).
					projectDir = projPath;
					pBEInfo->projectDir = projectDir;

					// scan through all lines of file setting field values as we go
					for (lineStr = f.GetFirstLine(); !f.Eof(); lineStr = f.GetNextLine())
					{
						//wxLogDebug(_T("%s"),lineStr.c_str());
						// collect data fields for filling in PTProject structs.
						lineStr.Trim(FALSE);
						lineStr.Trim(TRUE);
						wxString tagName;
						wxString endTagName;

						//tagName = _T("<BooksPresent>");
						//endTagName = _T("</BooksPresent>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	booksPresentFlags = GetStringBetweenXMLTags(lineStr, tagName, endTagName);
						//	pBEInfo->booksPresentFlags = booksPresentFlags;
						//}

						//tagName = _T("<EthnologueCode>");
						//endTagName = _T("</EthnologueCode>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	ethnologueCode = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						//	pBEInfo->ethnologueCode = ethnologueCode;
						//}

						//tagName = _T("<FullName>");
						//endTagName = _T("</FullName>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	fullName = GetStringBetweenXMLTags(lineStr, tagName, endTagName);
						//	pBEInfo->fullName = fullName;
						//}

						//tagName = _T("<Language>");
						//endTagName = _T("</Language>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	languageName = GetStringBetweenXMLTags(lineStr, tagName, endTagName);
						//	pBEInfo->languageName = languageName;
						//}

						//tagName = _T("<Directory>");
						//endTagName = _T("</Directory>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	projectDir = GetStringBetweenXMLTags(lineStr, tagName, endTagName);
						//	pBEInfo->projectDir = projectDir;
						//}

						//tagName = _T("<Name>");
						//endTagName = _T("</Name>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	shortName = GetStringBetweenXMLTags(lineStr, tagName, endTagName);
						//	pBEInfo->shortName = shortName;
						//}

						// whm Note: PT used a <Versification> tag, Bibledit uses a <versification> tag
						// [different capitalization in the tag], and nests the actual value within a
						// deeper <value>...</value> tag.
						tagName = _T("<versification>");
						endTagName = _T("</versification>");
						if (lineStr.Find(tagName) != wxNOT_FOUND)
						{
							versification = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
							pBEInfo->versification = versification;
						}

						//tagName = _T("<ChapterMarker>");
						//endTagName = _T("</ChapterMarker>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	chapterMarker = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						//	pBEInfo->chapterMarker = chapterMarker;
						//}

						//tagName = _T("<VerseMarker>");
						//endTagName = _T("</VerseMarker>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	verseMarker = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						//	pBEInfo->verseMarker = verseMarker;
						//}

						tagName = _T("<editor-font-name>");
						endTagName = _T("</editor-font-name>");
						if (lineStr.Find(tagName) != wxNOT_FOUND)
						{
							wxString tempStr = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
							// whm Note: Bibledit's font name and size are combined in the same text
							// string as for example "Sans 14", therefore we will get both defaultFont
							// and defaultFontSize here.
							wxString fontName;
							wxString fontSize;
							int posSp = tempStr.Find(_T(' '),TRUE); // TRUE - Find from right end
							if (posSp != wxNOT_FOUND)
							{
								fontSize = tempStr.Mid(posSp);
								fontSize.Trim(TRUE);
								fontSize.Trim(FALSE);
								fontName = tempStr.Mid(0,posSp);
								fontName.Trim(TRUE);
								fontName.Trim(FALSE);
							}

							defaultFont = fontName;
							pBEInfo->defaultFont  = fontName;
							defaultFontSize = fontSize;
							pBEInfo->defaultFontSize = fontSize;
						}

						//tagName = _T("<DefaultFontSize>");
						//endTagName = _T("</DefaultFontSize>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	defaultFontSize = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						//	pBEInfo->defaultFontSize = defaultFontSize;
						//}

						// PT uses <LeftToRight> with values of T or F, but BE uses <right-to-left> with
						// values of 0 or 1
						tagName = _T("<right-to-left>");
						endTagName = _T("</right-to-left>");
						if (lineStr.Find(tagName) != wxNOT_FOUND)
						{
							wxString tempStr;
							tempStr = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName); // will be 0 or 1
							// reverse the value for the structs' "leftToRight" value
							if (tempStr == _T("0"))
								leftToRight = _T("T");
							else if (tempStr == _T("1"))
								leftToRight = _T("F");
							pBEInfo->leftToRight = leftToRight;
						}

						//tagName = _T("<Encoding>");
						//endTagName = _T("</Encoding>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	encoding = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						//	pBEInfo->encoding = encoding;
						//}

						// whm Note: Bibledit'd resources are kept in a separate "resources" folder
						// which is a sibling of "projects" within the .bibledit top level folder
						//tagName = _T("<ResourceText>");
						//endTagName = _T("</ResourceText>");
						//if (lineStr.Find(tagName) != wxNOT_FOUND)
						//{
						//	wxString temp;
						//	temp = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
						//	// Note: non-Resource projects often don't have the "<ResourceText>"
						//	// tag at all, therefore we set bProjectIsNotResource to TRUE as its
						//	// default, unless <ResourceText>T</ResourceText> is present.
						//	if (temp == _T("T"))
						//	{
						//		bProjectIsNotResource = FALSE;
						//		pBEInfo->bProjectIsNotResource = FALSE;
						//	}
						//}

						// whm Note: PT uses <Editable> and </Editable> tags with 'T' and 'F' values
						// whereas BE uses <editable> and </editable> tags with a further nested
						// <value> and </value> tags containing '0' and '1' values
						tagName = _T("<editable>");
						endTagName = _T("</editable>");
						if (lineStr.Find(tagName) != wxNOT_FOUND)
						{
							wxString temp;
							temp = GetStringBetweenXMLTags(&f,lineStr, tagName, endTagName);
							if (temp == _T("1"))
							{
								bProjectIsEditable = TRUE;
							}
							else if (temp == _T("0"))
							{
								bProjectIsEditable = FALSE;
							}
							pBEInfo->bProjectIsEditable = bProjectIsEditable;
						}

					}
					wxString storageStr;
					// We do not allow collaboration with resource projects or
					// projects that have no short name, since the short name is
					// the basic PT name for the project (and the folder it is
					// contained in).
					if (bProjectIsNotResource && !shortName.IsEmpty())
					{
						storageStr = shortName; // this is the same as languageName and fullName
						//if (!fullName.IsEmpty())
						//{
						//	storageStr += _T(" : ") + fullName;
						//}
						//if (!languageName.IsEmpty())
						//{
						//	storageStr += _T(" : ") + languageName;
						//}
						//if (!ethnologueCode.IsEmpty())
						//{
						//	storageStr += _T(" : ") + ethnologueCode;
						//}
						tempListOfBEProjects.Add(storageStr);
						m_pArrayOfCollabProjects->Add(pBEInfo);
					}
					else
					{
						delete pBEInfo; // it's not a valid PT project we can use
					}
					f.Close();
				}
			}
		}
	}

	return tempListOfBEProjects;
}

wxString CAdapt_ItApp::GetBibleditBooksPresentFlagsStr(wxString projPath)
{
	// We collect directory names within Bibledit's data folder within the
	// incoming parameter's projPath. Hence, we want to look in the following
	// Linux path:
	// ~/.bibledit/projects/data/
	wxString pathToScan = projPath + PathSeparator + _T("data");
	wxString dirNameStr;
	// Note: the AllBookNames[] array has 123 elements
	wxString nameFlagsStr = _T("00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
	wxArrayString bookNames;
	wxDir finder;
	if (finder.Open(pathToScan))
	{
		bool bWorking = finder.GetFirst(&dirNameStr,_T(""),wxDIR_DIRS);
		while (bWorking)
		{
			bookNames.Add(dirNameStr);
			int nIndxOfBook;
			nIndxOfBook = GetBookFlagIndexFromFullBookName(dirNameStr);
			wxASSERT(nIndxOfBook != wxNOT_FOUND);
			nameFlagsStr.SetChar(nIndxOfBook,_T('1'));
			bWorking = finder.GetNext(&dirNameStr);
		}
	}
	return nameFlagsStr;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a pointer to a Collab_Project_Info_Struct struct on the heap
/// \param      projShortName -> the PT/BE project's short name which is unique
///                             and is used for the PT project's ssf file
///                             and/or the PT or BE project folder where PT/BE stores
///                             the project's documents
/// \remarks
/// Called from: various places in the CGetSourceTextFromEditorDlg's
/// class methods.
/// Examines the App's m_pArrayOfCollabProjects and finds the item that points
/// to the struct containing the given PT/BE project which is uniquely identified
/// by projShortName.
///////////////////////////////////////////////////////////////////////////////
Collab_Project_Info_Struct* CAdapt_ItApp::GetCollab_Project_Struct(wxString projShortName)
{
	Collab_Project_Info_Struct* pCollab_Proj;
	int ct, tot;
	tot = (int)m_pArrayOfCollabProjects->GetCount();
	for (ct = 0; ct < tot; ct++)
	{
		pCollab_Proj = (Collab_Project_Info_Struct*)m_pArrayOfCollabProjects->Item(ct);
		if (pCollab_Proj->shortName == projShortName)
		{
			// we found it so return the pointer to it
			return pCollab_Proj;
		}
	}
	// if we get here we did not find the project so return NULL
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString representing the string value between beginTag and
///             an endTag of within an xml-formatted line of text (lineStr). Or
///             an empty string is there was an error.
/// \param      lineStr -> the string containing the beginTag and possible endTag
/// \param      beginTag -> the xml tag after which we copy non-tag text
/// \param      endTag -> the xml tag before which we stop copying non-tag text
/// \remarks
/// Called from: GetListOfPTProjects() and GetListOfBEProjects().
/// A convenience function to extract the PCDATA text between an xml begin tag
/// and its end tag, i.e., <tag> text </tag>. The caller has determined that
/// beginTag is located within the lineStr. The endTag can also be on the same
/// line (as in PT) or on a subsequent line (as in BE where the text string to
/// be copied is within a deeper nested <value>... </value> set of tags.
/// This function is used in parsing the xml Paratext ssf project description
/// files and/or Bibledit configuration.1.xml files. The file being read resides
/// in memory as a wxTextFile.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetStringBetweenXMLTags(wxTextFile* f, wxString lineStr, wxString beginTag, wxString endTag)
{
	wxString tempStr;
	tempStr.Empty();
	int nTagPos;
	lineStr.Trim(TRUE);
	lineStr.Trim(FALSE);
	nTagPos = lineStr.Find(beginTag);
	if (nTagPos == 0)
	{
		// the tag begins the line
		int nEndTagPos;
		nEndTagPos = lineStr.Find(endTag);
		if (nEndTagPos == wxNOT_FOUND)
		{
			// we are dealing with a Bibledit configuration.1.xml file which is structured like this:
			// <tag> <=== we are currently pointing at this line
			//  <value>PCDATA</value>  <=== we want the PCDATA value between <value> and </value> on next line
			// <endtag>
			// Hence, we will use the wxTextFile::GetLine() function to
			int nCurLine = f->GetCurrentLine();
			wxString valueLine;
			valueLine = f->GetLine(nCurLine + 1); // doesn't change wxTextFile's internal pointer
			valueLine.Trim(TRUE);
			valueLine.Trim(FALSE);
			wxString valueBeginTag = _T("<value>");
			wxString valueEndTag = _T("</value>");
			int posValueBeginTag;
			posValueBeginTag = valueLine.Find(valueBeginTag);
			int posValueEndTag = valueLine.Find(valueEndTag);
			// BEW 2Jan12, turned the wxASSERT() here into an if test, which also prevents
			// a compile warning that posValueBeginTag wasn't used
			if(posValueBeginTag != wxNOT_FOUND && posValueEndTag != wxNOT_FOUND && posValueEndTag > posValueBeginTag)
			{
				tempStr = valueLine.Mid(valueBeginTag.Length(), posValueEndTag - valueBeginTag.Length());
			}
		}
		else
		{
			// This is the Paratext case which is structured like this:
			// <tag>PCDATA</endtag>
			// and doesn't have a nested <value>...</value> set of tags
			tempStr = lineStr.Mid(beginTag.Length(),nEndTagPos - beginTag.Length());
		}
	}
	return tempStr;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString representing the 3-letter USFM book code for bookName
/// \param      bookName -> the full Scripture book name (English)
/// \remarks
/// Called from: CGetSourceTextFromEditorDlg::OnLBBookSelected().
/// Finds the bookName in the App's bookNameArray and uses the found index as an
/// index into the parallel AllBookIds array, extracting the corresponding 3-letter
/// book code.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetBookCodeFromBookName(wxString bookName)
{
	// The Paratext list of book codes (3-letter Ids) is located in the App's array of
	// wxStrings called AllBookIds. The Paratext list of full book names (English)
	// is located in the App's array of wxStrings called AllBookNames.
	wxString bookCode;
	bookCode.Empty();
	wxArrayString bookIDArray(123,AllBookIds);
	wxArrayString bookNameArray(123,AllBookNames);
	wxASSERT(bookIDArray.GetCount() == bookNameArray.GetCount());
	int i,arrayCt;
	arrayCt = (int)bookIDArray.GetCount();
	for (i = 0; i < arrayCt; i++)
	{
		if (bookName == bookNameArray.Item(i))
		{
			bookCode = bookIDArray.Item(i);
			break;
		}
	}
	return bookCode;
}

int CAdapt_ItApp::GetBookFlagIndexFromFullBookName(wxString fullBookName)
{
	int ct;
	// Note: the AllBookNames[] array as used in Paratext has 123 elements
	for (ct = 0; ct < 123; ct++)
	{
		if (fullBookName == AllBookNames[ct])
			return ct;
	}
	return wxNOT_FOUND; // -1
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString representing the 3-letter USFM book code from the beginning
///             part of the input file at pathAndName; or an empty string if there
///             was an error
/// \param      pathAndName -> the full path and name of the file being examined
/// \remarks
/// Called from:
/// Finds the 3-letter book code encoded in the \id marker field that exists in
/// properly formed USFM and AI Document files. The input file pathAndName can be
/// either an AI xml document file, or a plain text USFM formatted file.
/// Opens the file at pathAndName and reads a small portion into a buffer of
/// 4K size (4096 bytes - more than enough to get past the header stuff in an AI
/// xml document file). In plain text files the \id line should be right at
/// the beginning of the file, but doesn't have to be for this function to
/// work as long as it is within the first 4K of the file.
/// If the file is an AI xml adaptation document it searches for the m="\id "
/// attribute, and if found then scans backwards in the buffer until it finds
/// the associated s= attribute which should be followed by the book code
/// within quote marks, i.e., m="MAT".
/// If the file is a USFM formatted file, it searches for the \id line (normally
/// the first line of the file), and if found then gets the code following that
/// \id line, i.e., \id MAT.
/// For large files this routine can be much faster that opening whole documents
/// with ReadDoc_XML() or with OnOpenDocument(), or even by using the wxTextFile
/// class (especially for large files).
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetBookCodeFastFromDiskFile(wxString pathAndName)
{
	wxString bookCode = _T("");
	CBString bookCd = "";
	bool bFoundCode = FALSE;
	if (wxFileExists(pathAndName))
	{
		const int nFourKB = 4096;
		wxUint32  nRead;
		char* pBuff = new char[nFourKB + 1];
		char* ptr = pBuff;
		char* pEnd;
		pEnd = pBuff + nFourKB;
		memset(pBuff,0,nFourKB + 1); // assume no error
		wxFile f;
		if (f.Open(pathAndName,wxFile::read))
		{
			nRead = f.Read(pBuff, nFourKB);
			if (nRead == (wxUint32)wxInvalidOffset)
			{
				return bookCode; // it's still an empty string
			}
			wxASSERT(*pEnd == '\0');
			if (*ptr != '\\' && *(ptr+1) != 'i' && *(ptr+2) != 'd' && *(ptr+3) != ' ')
			{
				ptr++; // advance past start of buffer
			}
			while (ptr < pEnd)
			{
				if (*ptr == '\\' && *(ptr+1) == 'i' && *(ptr+2) == 'd' && *(ptr+3) == ' ')
				{
					// we are at an \id marker. If the "\id " we've detected so far is followed
					// by a quote mark and closing tag '>' then we know we are in an AI xml document
					if (*(ptr+4) == '\"' && *(ptr+5) == '>')
					{
						// We are in an AI xml document, so scan backwards to find the book code within
						// the s= field.
						// Scan back until ptr is pointing at the ':' at the end of the xml header stuff
						while (ptr > pBuff && *ptr != ':')
						{
							ptr--;
						}
						// at this point ptr should be pointing at the ':' at the end of the xml header stuff
						// advance again till we get to the first s= sequenct
						while (*ptr != 's' && *(ptr+1) != '=')
						{
							ptr++;
						}
						if (*ptr == 's' && *(ptr+1) == '=' && *(ptr+2) == '\"')
						{
							ptr += 3; // point past the s=" sequence
							int ct;
							for (ct = 0; ct < 3; ct++)
							{
								bookCd += *(ptr+ct);
							}
							bFoundCode = TRUE;
						}
					}
					else
					{
						// we are in a plain text USFM file which is the easy case
						// *(ptr+4), *(ptr+5), and *(ptr+6) should contain the bood code
						if (ptr+6 < pEnd)
						{
							bookCd += *(ptr+4);
							bookCd += *(ptr+5);
							bookCd += *(ptr+6);
							bFoundCode = TRUE;
						}
					}
				}
				if (bFoundCode && bookCd.GetLength() == 3)
				{
					break;
				}
				ptr++;
			} // end of while()
			f.Close();
		} // end of if (f.Open...
		delete pBuff;
	} // end of if (wxFileExists(pathAndName))
	if (bFoundCode && bookCd.GetLength() == 3)
	{
		bookCode = wxString(bookCd,wxConvUTF8);
	}
	return bookCode;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString representing the book path and name which contains
///             the scripture reference
/// \param      folderPath -> the path of the folder to search in
/// \param      reference -> the three letter book code and Scripture reference
///                          in the form "REV 1:10"
/// \param      extensionFilter -> the file extension to limit the search if any
///                             i.e., ".XML"
/// \remarks
/// Called from:
/// Use this function to get the the path and name of the first disk file in a folder
/// which contains the Scripture reference specified in the reference parameter.
/// The reference is of the form "REV 1:10". The search algorithm attempts to take
/// the shortest/fastest method of determining which file in the folder matches the
/// specified reference. First we attempt to narrow the choices by examining the
/// file names themselves and eliminating those which don't have the specified
/// extension (specified in the extensionFilter parameter), and which don't have
/// hint numbers within their names, i.e., 41MATNYNT_CH01.xml, in which the 41 is
/// a hint for the book and _CH01 is a hint for the chapter contained in the file.
/// Most of the time this function is called on files we have named so this should
/// work quite efficiently. But, there are times when this function may be called
/// on files which may not have hints in their names. In such cases we have to
/// examine each file within the folder (matching the extensionFilter) and scan its
/// contents for a \id NNN marker identifying the book, then scanning the rest of
/// the contents to find matching chapter and verse markers that are specified by
/// the reference parameter. This function uses the GetBookCodeFastFromDiskFile()
/// function for speed, and also block reads the file where necessary into a
/// buffer for fast in-memory searches.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::FindBookFileContainingThisReference(wxString folderPath, wxString reference, wxString extensionFilter)
{
	wxString tempBookPathName;
	// parse the reference
	wxString tempRefStr = reference;
	tempRefStr.Trim(FALSE);
	tempRefStr.Trim(TRUE);
	wxString bookStr;
	wxString chapterStr;
	wxString verseStr;
	int posnSpace = tempRefStr.Find(_T(' '));
	bookStr = tempRefStr.Mid(0,posnSpace);
	bookStr.Trim(FALSE);
	bookStr.Trim(TRUE);
	bookStr = bookStr.MakeUpper(); // whm added 5Jan12
	chapterStr = tempRefStr.Mid(posnSpace);
	chapterStr.Trim(FALSE);
	chapterStr.Trim(TRUE);
	int posnColon = chapterStr.Find(_T(':'));
	verseStr = chapterStr.Mid(posnColon+1);
	verseStr.Trim(FALSE);
	verseStr.Trim(TRUE);
	chapterStr = chapterStr.Mid(0,posnColon);
	chapterStr.Trim(FALSE);
	chapterStr.Trim(TRUE);

	// scan the folderPath and get a list of files which have the \id with the
	// 3-letter book code (bookStr). This could be more than one file since chapter
	// files of a given book would have the same \id and book code within them, so
	// we store the names and paths in a wxArrayString. Later below we open fully
	// only those files that have the right \id and book code, and search for the
	// actual reference. Eventually we find and return the first book that has all
	// three: the book code, the chapter reference, and the verse reference.

	// we may be able to save time by looking at the actual file name and trying to
	// determine the searched-for book from the number prefixed to its name.

	// Gather all of the file names that exist in the folder
	wxArrayString filesInFolder;
	wxDir finder;
	bool bOK = (::wxSetWorkingDirectory(folderPath) && finder.Open(folderPath)); // wxDir
										// must call .Open() before enumerating files!

	if (bOK)
	{
		wxString str = _T("");
		bool bWorking = finder.GetFirst(&str,wxEmptyString,wxDIR_FILES);
		// whm note: wxDIR_FILES finds only files; it ignores directories, and . and ..
		// GetFirst() returns just a file name without the path
		wxString extFilterLower = extensionFilter.MakeLower();
		bool bAddDotToExt = FALSE;
		if (extFilterLower.Find(_T('.')) != wxNOT_FOUND)
		{
			// incoming extenstionFilter has the dot in the extension, so set flag to add dot below
			bAddDotToExt = TRUE;
		}

		while (bWorking)
		{
			if (str.IsEmpty())
				continue;
			wxFileName fn(str);
			wxString fnExt = fn.GetExt(); // extract its extension
			if (bAddDotToExt)
			{
				fnExt = _T('.') + fnExt;
			}
			wxString fnExtLower = fnExt;
			fnExtLower = fnExtLower.MakeLower();
			int nFound = str.Find(fnExt);
			if (fnExtLower == extFilterLower  && nFound != wxNOT_FOUND)
			{
				filesInFolder.Add(fn.GetFullName()); // add the full filename, but not including the path to the list
			}
			bWorking = finder.GetNext(&str);
		}

		// if filesInFolder is empty just return an empty string
		if (filesInFolder.GetCount() == 0)
			return wxEmptyString;

		// At this point filesInFolder contains all file path/names matching our extensionFilter specs.
		// First, using the filename itself as a hint, try to find a file name prefix with the Paratex
		// number scheme corresponding to the 3-letter book code (bookStr).
		int PT_bookNum;
		PT_bookNum = GetNumberFromBookCodeForFileNaming(bookStr);
		wxString pt_bookNumStr;
		pt_bookNumStr << PT_bookNum;
		if (PT_bookNum < 10)
			pt_bookNumStr = _T('0') + pt_bookNumStr;
		// At this point pt_bookNumStr will be something like "01" for GEN, "39"
		// for MAL, "41" for MAT, "67" for REV

		// Now, scan through the filesInFolder array and see if there is one or more
		// there whose filename begins with the pt_bookNumStr number. Collect them
		// into a booksWithNamesToCheck array.
		int totFiles = (int)filesInFolder.GetCount();
		int ct;
		int posnBookNum;
		wxArrayString booksWithNamesToCheck;
		booksWithNamesToCheck.Empty();
		wxString tempFileName;
		for (ct = 0; ct < totFiles; ct++)
		{
			tempFileName = filesInFolder.Item(ct);
			posnBookNum = tempFileName.Find(pt_bookNumStr);
			if (posnBookNum >= 0)
			{
				// the book number string is somewhere in this file's name
				booksWithNamesToCheck.Add(tempFileName);
			}
		}
		// If the booksWithNamesToCheck has one or more array elements, we check
		// those to see if they have a "_CHnn" element in the file name where nn is
		// a chapter number "01", "02", etc. If such a chapter indication exists we
		// will just open that file. If it doesn't exist we will check for \id NNN
		// in that file.
		int totNamesToCheck = booksWithNamesToCheck.GetCount();
		wxString fileNameToCheck = _T("");

		if (totNamesToCheck != 0)
		{
			int ct;
			bool bFoundChapterHintToCheck = FALSE;
			for (ct = 0; ct < totNamesToCheck; ct++)
			{
				fileNameToCheck = booksWithNamesToCheck.Item(ct);
				// Note: our collaboration file name will be of the form: 41MATNYNT_CH01.xml
				// or Collab_41MATNYNT_CH01.xml.
				int posn = fileNameToCheck.Find(_T("_CH"));
				if ((posn != wxNOT_FOUND) && ((posn + 4) < (int)fileNameToCheck.Length()))
				{
					wxChar firstChDigit = fileNameToCheck.GetChar(posn + 3);
					wxChar secondChDigit = fileNameToCheck.GetChar(posn + 4);
					if (wxIsdigit(firstChDigit) && wxIsdigit(secondChDigit))
					{
						wxString chNumAsStr = _T("");
						if (firstChDigit != _T('0'))
							chNumAsStr += firstChDigit;
						chNumAsStr += secondChDigit;
						if (chNumAsStr == chapterStr)
						{
							bFoundChapterHintToCheck = TRUE;
							break;
						}
					}
				}
			}
			if (bFoundChapterHintToCheck)
			{
				wxASSERT(!fileNameToCheck.IsEmpty());
				wxString tempFileAndPath = folderPath + PathSeparator + fileNameToCheck;
				wxString bookCode = GetBookCodeFastFromDiskFile(tempFileAndPath);
				bookCode.MakeUpper(); // ensure it is upper case throughout, as that's what Adapt It wants
				if (bookCode == bookStr)
				{
					// the book code matches, so now verify that the book has the chapter and verse reference
					bool bRefFound = FALSE;
					bRefFound = BookHasChapterAndVerseReference(tempFileAndPath,chapterStr,verseStr);

					if (bRefFound)
					{
						// we found the file containing the book code and the chapter and verse reference
						// so return the file name of the book
						return tempFileAndPath;
					}
				} // end of if (bookCode == bookStr)
			} // end of if (bFoundChapterHintToCheck)
			else
			{
				// The file name had a number hint, but we did not find a file name also
				// containing a _CHnn hint so we'll need to scan, all the files in the
				// booksWithNamesToCheck array.
				for (ct = 0; ct < totNamesToCheck; ct++)
				{
					tempFileName = booksWithNamesToCheck.Item(ct);
					wxASSERT(!tempFileName.IsEmpty());
					wxString tempFileAndPath = folderPath + PathSeparator + tempFileName;
					wxString bookCode = GetBookCodeFastFromDiskFile(tempFileAndPath);
					bookCode.MakeUpper(); // ensure it is upper case throughout, as that's what Adapt It wants
					if (bookCode == bookStr)
					{
						// the book code matches, so now verify that the book has the chapter and verse reference
						bool bRefFound = FALSE;
						bRefFound = BookHasChapterAndVerseReference(tempFileAndPath,chapterStr,verseStr);

						if (bRefFound)
						{
							// we found the file containing the book code and the chapter and verse reference
							// so return the file name of the book
							return tempFileAndPath;
						}
					} // end of if (bookCode == bookStr)
				}
			}
		} // end of if (totNamesToCheck != 0)
		else
		{
			// there were no file names with number hints within their
			// names as used in Paratext, so we will have to do a brute check of all
			// the files in the folder (names stored in filesInFolder array) until we
			// either run out of files to check or find the one with the book code,
			// chapter and reference.
			for (ct = 0; ct < totFiles; ct++)
			{
				tempFileName = filesInFolder.Item(ct);
				wxASSERT(!tempFileName.IsEmpty());
				wxString tempFileAndPath = folderPath + PathSeparator + tempFileName;
				wxString bookCode = GetBookCodeFastFromDiskFile(tempFileAndPath);
				bookCode.MakeUpper(); // ensure it is upper case throughout, as that's what Adapt It wants
				if (bookCode == bookStr)
				{
					// the book code matches, so now verify that the book has the chapter and verse reference
					bool bRefFound = FALSE;
					bRefFound = BookHasChapterAndVerseReference(tempFileAndPath,chapterStr,verseStr);

					if (bRefFound)
					{
						// we found the file containing the book code and the chapter and verse reference
						// so return the file name of the book
						return tempFileAndPath;
					}
				} // end of if (bookCode == bookStr)
			}
		}
	} // end of if (bOK)

	return tempBookPathName;
}

bool CAdapt_ItApp::BookHasChapterAndVerseReference(wxString fileAndPath, wxString chapterStr, wxString verseStr)
{
	bool bRefFound = FALSE;
	wxString fileBuffer;
	// now read the file into a buffer in preparation for scanning for chapters and verses
	wxFile f(fileAndPath,wxFile::read);
	wxFileOffset fileLen;
	fileLen = f.Length();
	// read the raw byte data into pByteBuf (char buffer on the heap)
	char* pByteBuf = (char*)malloc(fileLen + 1);
	memset(pByteBuf,0,fileLen + 1); // fill with nulls
	f.Read(pByteBuf,fileLen);
	wxASSERT(pByteBuf[fileLen] == '\0'); // should end in NULL
	f.Close();
	// convert to wxString so we can use wxChar based parsing of usfm
	fileBuffer = wxString(pByteBuf,wxConvUTF8,fileLen);
	free((void*)pByteBuf);
	// get a read-only buffer pointer
	const wxChar* pBuff = fileBuffer.GetData();
	int len = fileBuffer.Length();
	wxChar* pEnd = (wxChar*)pBuff + len;
	wxASSERT(*pEnd == _T('\0'));
	wxChar* ptr = (wxChar*)pBuff;
	int itemLen = 0;
	wxString lastChNumStr = _T("");
	wxString lastVsNumStr = _T("");
	// scan through buffer looking for chapter and verse markers
	while (ptr < pEnd)
	{
		int nMkrLen = 0;
		if (Is_ChapterMarker(ptr))
		{
			// its a chapter marker
			ptr += 2; // point past the \c marker

			itemLen = Parse_NonEol_WhiteSpace(ptr);
													   // to buffer
			ptr += itemLen; // point at chapter number
			itemLen = Parse_Number(ptr,pEnd);
			lastChNumStr = GetStringFromBuffer(ptr,itemLen); // get the chapter number
			// Are we looking for introductory material and have found chapter 1?
			if (verseStr == _T("0") && chapterStr == _T("1") && lastChNumStr == _T("1"))
			{
				// When the incoming chapter reference is "1" and the incoming verse reference
				// is "0" it means that the reference for sync scrolling points to introductory
				// material before chapter 1. If those are the parameters we are searching for
				// and we've just encountered a chapter 1 in this document, we know that the
				// current document would be the one containing introductory material, at least
				// for Paratext supplied documents, so return TRUE.
				// Note: Bibledit only includes introductory material if we've retrieved a
				// whole book file. So, I've limited the test above to Paratex. This function
				// is a supporting function for the sync scrolling routines. But, the Linux
				// version of Adapt It doesn't yet support sync scrolling. If it ever does this
				// should also work for Bibledit supplied texts.
				return TRUE;

			}
			// Is the desired chapter number greater than the reference we are looking for?
			if (wxAtoi(lastChNumStr) > wxAtoi(chapterStr)) // comparison of strings won't work because "2" > "11"
			{
				// We assume chapters are in numerical order so if we encounter a chapter
				// number higher than the one we are looking for there is no point continuing
				// to search - return FALSE.
				return FALSE;
			}

			ptr += itemLen; // point past chapter number

			itemLen = Parse_NonEol_WhiteSpace(ptr); // parse white space following
											// the number
			ptr += itemLen; // point past it
		} // end of if (Is_ChapterMarker())
		else if (Is_VerseMarker(ptr,nMkrLen))
		{
			if (nMkrLen == 2)
			{
				// its a verse marker
				ptr += 2; // point past the \v marker
			}
			else
			{
				// its an Indonesia branch verse marker \vn
				ptr += 3; // point past the \vn marker
			}

			itemLen = Parse_NonEol_WhiteSpace(ptr);
													   // space to buffer
			ptr += itemLen; // point at verse number

			itemLen = Parse_Number(ptr,pEnd);
			lastVsNumStr = GetStringFromBuffer(ptr,itemLen); // get the verse number
			// If the last chapter encountered matches the chapterStr reference and
			// the last verse encountered matches the verseStr reference we are looking
			// for, we have found the sync scroll reference in this document, so
			// return TRUE.
			if (lastChNumStr == chapterStr && lastVsNumStr == verseStr)
			{
				// we found the reference so return TRUE
				return TRUE;
			}

			ptr += itemLen; // point past verse number

			itemLen = Parse_NonEol_WhiteSpace(ptr); // past white space which is
											// after the marker
			ptr += itemLen; // point past the white space
		} // end of if (Is_VerseMarker())
		else
		{
			ptr++;
		}
	} // end of loop: while (ptrSrc < pEnd)

	/*
	// get the usfm structure of the buffer
	// whm 5Jan12 TODO: items
	// 1. This BookHasChapterAndVerseReference() function could be made faster
	// by examining the fileBuffer directly for verse and chapter numbers, rather than
	// calling GetUsfmStructureAndExtent() to produce structure and extent arrays for
	// the whole book in Adapt It's xml document format. In most cases examining the
	// fileBuffer directly would find out whether a given chapter:verse reference
	// exists long before producing the whole array and examining it.
	// 2. Note also that a Paratext chapter file retrieved during collaboration
	// for chapter 1 will issue a sync scrolling reference of 1:0 for when Paratext
	// is pointing to introductory material before verse 1 (Bibledit has intro
	// material in chapter 0 on disk). In order for sync scrolling to be able to
	// find intro material we need to also account for an incoming reference of 1:0
	// which should be tested for in any revision done for the above TODO.
	// 3. Use the PT defined markers for chapter and verse markers if different
	// from the default \c and \v. Make such changes elsewhere too!
	wxArrayString usfmStructureArray;
	usfmStructureArray = GetUsfmStructureAndExtent(fileBuffer);

	// We here use the usfmStructureArray to quickly determine if the
	// chapter and verse reference exists in the book being examined in
	// the fileBuffer.
	int ct = 0;
	int tot;
	tot = usfmStructureArray.GetCount();
	wxString arrayLine;
	while (ct < tot && !bRefFound)
	{
		arrayLine = usfmStructureArray.Item(ct);
		// arrayLine is of the form \mkr n:nnnn for chapter and verse markers, \mkr:nnnn for others
		if (arrayLine.Find(_T("\\c ")) != wxNOT_FOUND) // TODO: use the PT defined \c
		{
			wxString numStr = GetNumberFromChapterOrVerseStr(arrayLine);
			if (numStr == chapterStr)
			{
				// we've found our chapter reference, now scan further down and
				// see if there is a verse reference for this chapter
				int newCt = ct+1;
				arrayLine = usfmStructureArray.Item(newCt);
				while (newCt < tot && arrayLine.Find(_T("\\c ")) == wxNOT_FOUND) // TODO: use the PT defined \c
				{
					if (arrayLine.Find(_T("\\v ")) != wxNOT_FOUND) // TODO: use the PT defined \v
					{
						if (GetNumberFromChapterOrVerseStr(arrayLine) == verseStr)
						{
							// we have a match for both the chapter and the verse number
							bRefFound = TRUE;
							break;
						}
					}
					newCt++;
					if (newCt < tot)
					{
						arrayLine = usfmStructureArray.Item(newCt);
					}
				}
			}
		}
		ct++;
	} // end of while (ct < tot && !bRefFound)
	*/
	return bRefFound;
}

int CAdapt_ItApp::GetNumberFromBookCodeForFileNaming(wxString bookStr)
{
	int bookNum = -1;
	wxArrayString bookIDArray(123,AllBookIds);
	int ct;
	for (ct = 0; ct < 123; ct++)
	{
		if (bookIDArray.Item(ct) == bookStr)
		{
			bookNum = ct + 1; // the AllBookIds enum is 1 based rather than 0 base
			if (bookNum > 39)
			{
				bookNum++;  // from Malachi MAL to Matthew (MAT) the PT book numbering skips 40,
							// so MAL is 39 and MAT is 41
			}
			break;
		}
	}
	return bookNum;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxString representing the book number as typically used in
///             file names of Scripture books within Paratext.
/// \param      bookName -> the full name of the Scripture book
/// \remarks
/// Called from: CGetSourceTextFromEditorDlg::OnLBBookSelected().
/// Used to get the book's typical number for building unique Paratext style
/// file names, i.e., 41MATNYNT.PTX where 41 is the book number for the book
/// of Matthew.
///////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItApp::GetBookNumberAsStrFromName(wxString bookName)
{
	// The Paratext list of book codes (3-letter Ids) is located in the App's array of
	// wxStrings called AllBookIds. The Paratext list of full book names (English)
	// is located in the App's array of wxStrings called AllBookNames.
	wxString bookNumAsStr;
	bookNumAsStr.Empty();
	wxArrayString bookIDArray(123,AllBookIds);
	wxArrayString bookNameArray(123,AllBookNames);
	wxASSERT(bookIDArray.GetCount() == bookNameArray.GetCount());
	int i,arrayCt;
	arrayCt = (int)bookIDArray.GetCount();
	for (i = 0; i < arrayCt; i++)
	{
		if (bookName == bookNameArray.Item(i))
		{
			// PT books are numbered from index starting at 1 rather than 0
			bookNumAsStr << i+1;
			break;
		}
	}
	return bookNumAsStr;
}

///////////////////////////////////////////////////////////////////////////////
/// \return		a wxArrayString representing the Scripture books that are "present"
///             in a given Paratext/Bibledit project
/// \param      bookFlagsStr -> a string of 123 chars composed of '1' or '0' characters
/// \remarks
/// Called from: CGetSourceTextFromEditorDlg::LoadBookNamesIntoList().
/// Used to get an array of the book names that are present in a Paratext/Bibledit
/// project according to the bookFlagsStr, a string composed of 123 characters in
/// which a 1 indicates the book is present and 0 indicates the book is not present.
/// The index into the bookFlagsStr is parallel to the array of Scripture books
/// called AllBookNames held on the App.
///////////////////////////////////////////////////////////////////////////////
wxArrayString CAdapt_ItApp::GetBooksArrayFromBookFlagsString(wxString bookFlagsStr)
{
	wxArrayString booksArray;
	int ct,strLen;
	strLen = bookFlagsStr.Length();
	for (ct = 0; ct < strLen; ct++)
	{
		if (bookFlagsStr.GetChar(ct) == _T('1'))
			booksArray.Add(AllBookNames[ct]);
	}

	return booksArray;
}

// BEW 10Jul11, for collaborating with external editor..., for
// temporary storage and retieval of "pre-edit" USFM text for
// the current active document

//setters
void CAdapt_ItApp::StoreTargetText_PreEdit(wxString s)
{
	m_targetTextBuffer_PreEdit = s;
}
void CAdapt_ItApp::StoreFreeTransText_PreEdit(wxString s)
{
	m_freeTransTextBuffer_PreEdit = s;
}
// getters
wxString CAdapt_ItApp::GetStoredTargetText_PreEdit()
{
	return m_targetTextBuffer_PreEdit;
}
wxString CAdapt_ItApp::GetStoredFreeTransText_PreEdit()
{
	return m_freeTransTextBuffer_PreEdit;
}

// support for saving and restoring the selection, and clearing saved selection members
// (the members are 3 ints, m_savedSelectionLine, m_nSavedSelectionAnchorIndex, m_savedSelectionCount)
// the first two return TRUE if all went well, FALSE if the selection could not be saved, or not restored
bool CAdapt_ItApp::SaveSelection()
{
    if (m_selectionLine == -1)
        return FALSE; // no valid selection is current
    m_savedSelectionLine = m_selectionLine;
    if (m_selection.IsEmpty())
        return FALSE; // no CCell instances are selected
    if (m_pAnchor == NULL)
        return FALSE; // no anchor is defined
    CPile* pAnchorPile = m_pAnchor->GetPile();
    CSourcePhrase* pAnchorSrcPhrase = pAnchorPile->GetSrcPhrase();
    m_savedSelectionAnchorIndex = pAnchorSrcPhrase->m_nSequNumber;
    m_savedSelectionCount = m_selection.GetCount();
    return TRUE;
}
bool CAdapt_ItApp::RestoreSelection(bool bRestoreCCellsFlagToo)
{
    if (m_savedSelectionLine == -1 || m_savedSelectionAnchorIndex == -1 || m_savedSelectionCount == -1)
    {
        return FALSE; // cannot restore a valid selection if one of the ints is -1
    }
    m_selectionLine = m_savedSelectionLine;
    int count = 0;
    CPile* pPile = NULL;
    CCell* pCell = NULL;
    CLayout* pLayout = m_pLayout;
    //PileList* pPileList = pLayout->GetPileList();
    //PileList::Node* pos = pPileList->Find(m_savedSelectionAnchorIndex); // the position of the anchor pile;
    //wxASSERT(pos != NULL);
    //pPile = pos->GetData();
    pPile = pLayout->GetPile(m_savedSelectionAnchorIndex);
    pCell = pPile->GetCell(m_savedSelectionLine);
    m_pAnchor = pCell;
    if (bRestoreCCellsFlagToo)
    {
        m_pAnchor->SetSelected(TRUE);
    }
    else
    {
        m_pAnchor->SetSelected(FALSE);
    }
    m_selection.Clear();
    m_selection.Append(m_pAnchor);
    count = 1;
    int index = m_savedSelectionAnchorIndex + 1;
    while (count < m_savedSelectionCount)
    {
        //pos = pos->GetNext();
        //if (pos == NULL)
        //{
            // we couldn't finish the restoration, leave what we'd done intact, but return FALSE
        //    return FALSE;
        //}
        //pPile = pos->GetData();
        pPile = pLayout->GetPile(index);

        pCell = pPile->GetCell(m_savedSelectionLine);
        count++;
        index++;
        if (bRestoreCCellsFlagToo)
        {
            pCell->SetSelected(TRUE);
        }
        else
        {
            pCell->SetSelected(FALSE);
        }
        m_selection.Append(pCell);
    }
    // the selection is restored, and if the passed in bool is TRUE, then the selected cells
    // in the view also have their flags set true (a draw of the view would then show these
    // cells as yellow background -- ie. selected) Probably the thing to do is to force the
    // refresh if TRUE was passed in (I may change my mind about this later)
    if (bRestoreCCellsFlagToo)
    {
        CAdapt_ItView* pView = GetView();
        pView->canvas->Refresh();
    }
    return TRUE;
}
void CAdapt_ItApp::ClearSavedSelection()
{
	m_savedSelectionLine = -1;
	m_savedSelectionAnchorIndex = -1;
	m_savedSelectionCount = -1;
} // only makes the above 3 ints have the value -1


