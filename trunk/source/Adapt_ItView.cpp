/////////////////////////////////////////////////////////////////////////////////
/// \project		adaptit
/// \file			Adapt_ItView.cpp
/// \author			Bill Martin
/// \date_created	05 January 2004
/// \date_revised	30 December 2008
/// \copyright		2008 Bruce Waters, Bill Martin, SIL International
/// \license		The Common Public License or The GNU Lesser General Public
///                 License (see license directory)
/// \description	This is the implementation file for the CAdapt_ItView class.
/// The CAdapt_ItView class is the most complex class in the application. It controls every
/// aspect of how the data is presented to the user, and most aspects of the user
/// interface. The data for the view is held entirely in memory and is kept logically
/// separate from and independent of the document class's persistent data structures. This
/// schema is an implementation of the document/view framework.
/// \derivation		The CAdapt_ItView class is derived from wxView.
/////////////////////////////////////////////////////////////////////////////////

//#define DrawFT_Bug
//#define FINDNXT

//#define _debugLayout


#if defined(__GNUG__) && !defined(__APPLE__)
    #pragma implementation "Adapt_ItView.h"
#endif

// For compilers that support precompilation, includes "wx.h".
#include <wx/wxprec.h>

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
// Include your minimal set of headers here, or wx.h
#include <wx/wx.h>
#endif

#if defined(__VISUALC__) && __VISUALC__ >= 1400
#pragma warning(disable:4428)	// VC 8.0 wrongly issues warning C4428: universal-character-name
								// encountered in source for a statement like
								// ellipsis = _T('\u2026');
								// which contains a unicode character \u2026 in a string literal.
								// The MSDN docs for warning C4428 are also misleading!
#endif

//#define _Trace_DrawFreeTrans

#include <wx/docview.h>	// includes wxWidgets doc/view framework
#include <wx/file.h>
#include <wx/clipbrd.h>
#include <wx/filesys.h> // for wxFileName
#include <wx/window.h> // for CaptureMouse()
#include <wx/event.h> // for GetCapturedWindow()
#include <wx/tokenzr.h>
#include <wx/textfile.h> // to get EOL info
#include "Adapt_ItCanvas.h"
#include "Adapt_It_Resources.h"
#include <wx/dir.h> // for wxDir
#include <wx/propdlg.h>
#include <wx/progdlg.h> // for wxProgressDialog
#include <wx/busyinfo.h>
#include <wx/print.h>
#include <wx/dynlib.h> // for wxDynamicLibrary

#ifdef __WXGTK__
#include <wx/dcps.h> // for wxPostScriptDC
#else
#include <wx/dcprint.h> // for wxPrinterDC
#endif

// includes below uncomment as implemented
#include "Adapt_It.h"
#include "ReadOnlyProtection.h"
#include "Adapt_ItDoc.h"
#include "AIPrintPreviewFrame.h"
#include "helpers.h"
#include "CollabUtilities.h"
#include "BString.h"
#include "XML.h"
#if wxCHECK_VERSION(2,9,0)
	// Use the built-in scrolling dialog features available in wxWidgets  2.9.x
#else
	// The wxWidgets library being used is pre-2.9.x, so use our own modified
	// version named wxScrollingDialog located in scrollingdialog.h
#include "scrollingdialog.h"
#endif

#include "EditPreferencesDlg.h"
#include "RefString.h"
#include "RefStringMetadata.h"
#include "KB.h"
#include "SourcePhrase.h"
#include "Strip.h"
#include "Pile.h"
#include "Cell.h"
#include "Layout.h"
#include "PhraseBox.h"
#include "AdaptitConstants.h"
#include "TargetUnit.h"
#include "RetranslationDlg.h"
#include "ChooseTranslation.h"
#include "MainFrm.h"
#include "Welcome.h"
#include "PlaceInternalPunct.h"
#include "KBEditor.h"
//#include "ConsistencyCheckDlg.h" // moved to CAdapt_ItDoc class 17May10
//#include "ChooseConsistencyCheckTypeDlg.h" //whm added 9Feb04, BEW moved to CAdapt_ItDoc class
//#include "ProgressDlg.h" // removed in svn revision #562
#include "GoToDlg.h"
#include "WaitDlg.h"
#include "UnitsDlg.h"
#include "EarlierTranslationDlg.h"
#include "EditSourceTextDlg.h"
#include "SetDelay.h" // added for version 2.0.2
#include "CollectBacktranslations.h" // BEW added 14Sept05
#include "NoteDlg.h"
#include "AIPrintout.h"
#include "ExportFunctions.h"
#include "PrintOptionsDlg.h"
#include "ConsistentChanger.h"
#include "SilConverterSelectDlg.h"
#ifdef USE_SIL_CONVERTERS
#include "ECDriver.h"
#endif
#include "FreeTrans.h"
#include "Adapt_ItView.h"
#include "Notes.h"
#include "Retranslation.h"
#include "Placeholder.h"
#include "GuesserSettingsDlg.h"
#include "MergeUpdatedSrc.h"
#include "KBExportImportOptionsDlg.h"

// rde added the following but, if it is actually needed we'll use wxMax()
//#ifndef max
//#define max(a,b)            (((a) > (b)) ? (a) : (b))
//#endif

/// This global is defined in Adapt_ItView.cpp.
bool gbLegacySourceTextCopy = FALSE; // BEW added 16July08 at Roland Fumey's
									 // request (see CViewPage.h & .cpp)
//#define IDW_TARGET_EDITBOX 1001

// Globals

// next global is for passing to SetupCursorGlobals()'s third parameter, for box_cursor
// enum value of cursor_at_offset
int gnBoxCursorOffset = 0;

extern wxDynamicLibrary ecDriverDynamicLibrary;
extern const wxChar *FUNC_NAME_EC_INITIALIZE_CONVERTER_AW;
extern const wxChar *FUNC_NAME_EC_IS_INSTALLED;
extern const wxChar *FUNC_NAME_EC_CONVERT_STRING_AW;

extern bool gbSavedTargetStringWithPunctInReviewingMode;			// these two are defined in PhraseBox.cpp and are for support
extern wxString gStrSavedTargetStringWithPunctInReviewingMode;	// of preserving a hole when phrase box lands and leaves while
													// Reviewing mode is turned on (added 19Dec07)
/// This global is defined in SplitDialog.cpp.
extern bool gbIsDocumentSplittingDialogActive; // see SplitDialog.cpp

/// This global is defined in PhraseBox.cpp.
extern bool gbSuppressStoreForAltBackspaceKeypress;
extern bool gbNoAdaptationRemovalRequested;

/// This global is defined in MainFrm.cpp.
extern bool gbIgnoreScriptureReference_Receive;

/// This global is defined in MainFrm.cpp.
extern bool gbIgnoreScriptureReference_Send;

// for support of scripture synchronizing messages (the sending side of it) -- the
// following string must differ from the one obtained in the
// SendScriptureReferenceFocusMessage() function before a new scripture reference focus
// message is sent (for example, when first entering a new verse, one is sent; but we don't
// want to send one every time the phrase box lands on another word in the same verse) The
// view's member function SendScriptureReferenceFocusMessage() accesses this global string.
wxString gOldChapVerseStr = _T(""); // the "chapter:verse" string used in the last broadcast message

/// This global is defined in Adapt_ItView.cpp.
extern bool gbLegacySourceTextCopy;	// default is legacy behaviour, to copy the source text (unless
									// the project config file establishes the FALSE value instead)

/// This global is defined in Adapt_It.cpp.
extern bool gbFreeTranslationJustRemovedInVFMdialog;

extern bool gbRetainBoxContents; // from version 1.4.2, see CPhraseBox for comments on its use whm added bool
extern wxString ccErrorStr;	// used in CConsistentChanger

/// This global is defined in Adapt_It.cpp.
extern wxChar gSFescapechar; // the escape char used for start of a standard format marker

/// This global is defined in Adapt_It.cpp.
extern bool gbHasBookFolders; // TRUE when Adaptations folder is found to have Bible book

// Used for inhibiting multiple accesses to MakeTargetStringIncludingPunctuation when only one is needed.
bool gbInhibitMakeTargetStringCall = FALSE;

// for suppressing MakeTargetStringIncludingPunctuation in ReDoPhraseBox( ) when moving to the
// previous pile (which might have internal punct & we don't want to see Place dialog)
extern bool gbMovingToPreviousPile;

// extern declarations for free translation support (whm moved these to the app)

/// GDLC 2010-02-13 gnOffsetInMarkersStr and gnLengthInMarkersStr moved to CFreeTrans

/// The global gpCurFreeTransSectionPileArray was defined in Adapt_It.cpp, but was changed to a member variable
/// of the class CFreeTrans. GDLC 2010-02-16

/// This global is defined in Adapt_It.cpp.
extern wxArrayPtrVoid*	gpFreeTransArray; // new creates on heap in InitInstance, and disposes in ExitInstance

/// This global is defined in Adapt_It.cpp.
extern CPile*		gpFirstPile; // pointer to first pile in a free translation section

/// This global is defined in Adapt_It.cpp.
extern wxString	gSpacelessTgtPunctuation; // contents of app's m_punctuation[1] string with spaces removed

/// This global is defined in Adapt_It.cpp.
extern bool		gbSuppressSetup;

/// This global is defined in Adapt_It.cpp.
extern bool		gbSaveHilightingSetting;

// for support of auto-capitalization

/// This global is defined in Adapt_It.cpp.
extern bool	gbAutoCaps;

/// This global is defined in Adapt_It.cpp.
extern bool	gbSourceIsUpperCase;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNonSourceIsUpperCase;

/// This global is defined in Adapt_It.cpp.
extern bool	gbMatchedKB_UCentry;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNoSourceCaseEquivalents;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNoTargetCaseEquivalents;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNoGlossCaseEquivalents;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharNonSrcLC;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharNonSrcUC;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharSrcLC;

/// This global is defined in Adapt_It.cpp.
extern wxString szProjectConfiguration;

/// This global is defined in Adapt_It.cpp.
extern wxString szAdminProjectConfiguration;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharSrcUC;

bool	gbCallerIsRemoveButton = FALSE;

// for getting source text updated after an edit
//int	gnOldMaxIndex = 0;

// next four are for version 2.0 which includes the option of a 3rd line for glossing

/// When TRUE it indicates that the application is in the "See Glosses" mode. In the
/// "See Glosses" mode any existing glosses are visible in a separate glossing line in
/// the main window, but words and phrases entered into the phrasebox are not entered
/// into the glossing KB unless gbGlossingVisible is also TRUE.
bool	gbIsGlossing = FALSE; // when TRUE, the phrase box and its line have glossing text

/// When TRUE the application is in true glossing mode. The phrasebox appears in the
/// main window's glossing line and contains glosses rather than normal adaptations.
/// The glosses entered or displayed in the phrasebox are stored in and retrieved from
/// the glossing KB.
bool	gbGlossingVisible = FALSE; // TRUE makes Adapt It revert to Shoebox functionality only

/// When TRUE the font used in glossing is the Navigation language font. Glossing uses
/// the Target font & settings by default, but if TRUE then it uses the Navigation language
/// font & direction settings.
bool	gbGlossingUsesNavFont = FALSE;

/// Defaults to FALSE to allow things like 3:sg:Subj or 1.incl to be put into the glossing
/// KB 'as is'. When TRUE punctuation is stripped out before saving the gloss in the glossing
/// KB; or, the stripping is done after the gloss has been saved
//bool	gbRemovePunctuationFromGlosses = FALSE; << BEW removed 13Nov10, it's never set TRUE

/// This flag is used to indicate that the text being processed is unstructured, i.e.,
/// not containing the standard format markers (such as verse and chapter) that would
/// otherwise make the document be structured. This global is used to restore paragraphing
/// in unstructured data, on export of source or target text.
bool	gbIsUnstructuredData = FALSE;

/// This global is defined in Adapt_It.cpp.
extern bool gbDoingInitialSetup;

//extern wxArrayString m_exportBareMarkers;
//extern wxArrayString m_exportMarkerAndDescriptions;
//extern wxArrayInt m_exportFilterFlags;
//extern wxArrayInt m_exportFilterFlagsBeforeEdit; // to detect any changes to list of markers for export

// Note: for the following, when TRUE the item is placed into the body of the output text (as boxed
// paragraphs for non-interlinear RTF output; as separate table row for interlinear RTF output). When
// FALSE the item is placed as a footnote (at bottom of page).
extern bool bPlaceFreeTransInRTFText;	// default is TRUE
extern bool bPlaceBackTransInRTFText;	// default is FALSE
extern bool bPlaceAINotesInRTFText;		// default is FALSE

// whm 9Jun12 changed the type for filterMkr and filterMrkEnd to wxString (and remove const) to agree with the actual
// declaration in Adapt_ItDoc. Otherwise wxWidgets 2.9.3 generates a error LNK2001: unresolved external symbol "wchar_t const * const filterMkr" 
extern wxString filterMkr; // defined in the Doc, used here in OnLButtonDown() & free translation code, etc
extern wxString filterMkrEnd; // defined in the Doc, used in free translation code, etc

// The following string is a list of markers that affect character formatting and the text
// to which they apply should not be filtered when the marker is filtered, only the markers
// themselves should be filtered out. This string of markers are used in RTF output
// routines
wxString charFormatMkrs = _T("\\qac \\qs \\qt \\nd \\tl \\dc \\bk \\pn \\wj \\k \\no \\bd \\it \\bdit \\em \\sc ");
// and the end marker forms
wxString charFormatEndMkrs = _T("\\qac* \\qs* \\qt* \\nd* \\tl* \\dc* \\bk* \\pn* \\wj* \\k* \\no* \\bd* \\it* \\bdit* \\em* \\sc* ");
// The following string is a list of markers that are embedded content
// markers for footnotes, endnotes and crossrefs
wxString embeddedWholeMkrs = _T("\\fr \\fk \\fq \\fqa \\ft \\fdc \\fv \\fm \\xo \\xt \\xk \\xq \\xdc ");
// and the end marker forms
wxString embeddedWholeEndMkrs = _T("\\fr* \\fk* \\fq* \\fqa* \\ft* \\fdc* \\fv* \\fm* \\xo* \\xt* \\xk* \\xq* \\xdc* ");

// The following string is a list of sfms which are significant enough to become a halting
// point for the immediate placement of pending back translation material.
// NOTE: Before checking if a given Marker is included in these strings any numerical level
// part of the Marker to be checked should be removed, i.e., \th1 should be changed to \th,
// \mt1 should be changed to \mt etc. This is done in IsBTMaterialHaltingPoint().
// The following markers should NOT trigger a halt point:
//   end markers of all kinds
//   running header markers \h \h1 \h2 \h3 (these are removed early from buffer)
//	 \note
//   character formatting markers
// BEW 6Sep10, added functions IsEmbeddedWholeMkr(), and IsAHaltingMarker(), for OXES
// export, which make use of the embeddedWholeMrks, embeddedWholeEndMkrs, and, for the
// IsAHaltingMarker() function, the commonHaltingMarkers list. In the latter case, we are
// using it for OXES parsing of SFM or USFM data, and so we want to halt if we parse to a \h
// or \h1 \h2 or \h3 or a \note, so these are included by forming a wxString in the
// USFM2Oxes class at the beginning of processing
wxString commonHaltingMarkers = _T("\\v \\c \\p \\m \\q \\qc \\qm \\qr \\qa \\pi \\mi \\pc \\pt \\ps \\pgi \\cl \\vn \\f \\fe \\x \\gd \\tr \\th \thr \\tc \\tcr \\mt \\st \\mte \\div \\ms \\s \\sr \\sp \\d \\di \\hl \\r \\dvrf \\mr \\br \\rr \\pp \\pq \\pm \\pmc \\pmr \\cls \\imt \\imte \\is \\ip \\ipi \\ipq \\ipr \\iq \\im \\imi \\imq \\io \\iot \\iex \\ie \\li \\qh \\gm \\gs \\gd \\gp \\tis \\tpi \\tps \\tir \\pb \\hr ");
wxString btHaltingMarkers = commonHaltingMarkers;

// The following string is a list of sfms which are significant enough to become a halting
// point for the immediate placement of pending free translation material.
// NOTE: Before checking if a given Marker is included in these strings any numerical level
// part of the Marker to be checked should be removed, i.e., \th1 should be changed to \th,
// \mt1 should be changed to \mt etc. This is done in IsFreeMaterialHaltingPoint().
wxString freeHaltingMarkers = commonHaltingMarkers;

// The following string arrays are used to construct the cell elements of Interlinear RTF
// output They are populated by BuildInterlinearTextStrArrays(), which is patterned after
// the BuildTargetText() function, but populates the elements of the string into the four
// string arrays below rather than as a single wxString.
wxArrayString SrcStrArray;
wxArrayString TgtStrArray;
wxArrayString GlsStrArray;
wxArrayString NavStrArray;

extern bool gbRTLLayout; // defined in FontPage.cpp
extern bool gbLTRLayout;

/// This global is defined in Adapt_It.cpp.
extern bool	gbRTL_Layout;	// ANSI version is always left to right reading; this flag can only
							// be changed in the Unicode version, using the extra Layout menu

/// This global is defined in Adapt_It.cpp.
extern int	gnVerticalBoxBloat; // see CAdapt_ItApp (bloats vertical dim'n of phrasebox for unicode version)

// basic format integer for use in the DrawText() function (see CDC), since unicode will need
// DrawText()
// MFC has the following bitwise flag set as the default nFormat flag in DrawText:
//UINT gnFormat = DT_SINGLELINE | DT_EXTERNALLEADING | DT_NOCLIP | DT_NOPREFIX | DT_TOP;	// DT_LEFT
																							// is default
// The MFC version ORs other DT flags with the gnFormat flag to produce the globals
// gnRTLFormat and gnLTRFormat; this is done in the View's OnInitialUpdate() as follows:
// gnRTLFormat = gnFormat | DT_RIGHT | DT_RTLREADING;
// gnLTRFormat = gnFormat | DT_LEFT;
// Then, later the appropriate gn...Format is assigned to a local nFormat value which is fed to
// the MFC DrawText(str,rect,nFormat) function to effect both right alignment and right-to-left
// reading of the text being drawn.
// whm note: MFC docs say of DT_LEFT, DT_RIGHT and DT_RTLREADING:
//    "DT_LEFT - Aligns text to the left."
//    "DT_RIGHT - Aligns text to the right."
//    "DT_RTLREADING - Layout in right-to-left reading order for bi-directional text when the
//                    font selected into the hdc is a Hebrew or Arabic font. The default
//                    reading order for all text is left-to-right."

// whm NOTE: wxDC::DrawText(const wxString& text, wxCoord x, wxCoord y) does not have an
// equivalent to the MFC DrawText's nFormat parameter, but instead wxDC has a
// SetLayoutDirection(wxLayoutDirection dir) method to change the logical direction or
// mirroring of the display context. In wxDC the display context is mirrored right-to-left
// when wxLayout_RightToLeft is passed as the parameter; Certain controls that contain text
// strings such as wxTextCtrl and wxListBox, etc., also have an undocumented method called
// SetLayoutDirection(wxLayoutDirection dir), where dir is wxLayout_LeftToRight or
// wxLayout_RightToLeft.
// Setting the layout to wxLayout_RightToLeft on these controls also involves some
// mirroring affecting the control itself, so that any scrollbar that gets displayed, for
// example, displays on the left side of the control rather than on the right, etc.
// In the wx version we have to be careful about the automatic mirroring features involved
// in the SetLayoutDirection() function. Since Adapt It MFC was designed to micromanage the
// layout direction itself as well as alignment in the coding of text, cells, piles,
// strips, etc., we no doubt encounter problems in layout and must avoid inadvertently
// "reversing" parts of the RTL layout because of the micromanaged layout done in the
// coding of the MFC version.

bool gbDummyAddedTemporarily = FALSE; // TRUE if an null sourcephrase is to be inserted
        // after the sel'n or after the active location, when the either of those are at
        // the GetMaxIndex() location (we use InsertNullSrcPhrase() which always inserts
        // before a location, so we have to add a dummy at the end until the insert is
        // done, and then remove it.

//////////////////////////////////////////////////////////////////////////////////////
// BEW 7May08: the next globals are for source text editing; the refactored functionality
// may not need all these... and including those for the refactored code (after the old
// ones)

int gnCount; // count of old srcphrases (user selected these) after unmerges, etc
int gnNewCount; // count of the new srcphrases (after user finished editing the source text)

/// A pointer to a sourcephrase immediately preceding the first one in a sublist of old
/// source phrase instances.
CSourcePhrase* gpPrecSrcPhrase;

/// A pointer to a sourcephrase immediately following the ones in a sublist of source
/// phrase instances in which their m_srcPhrase attributes have new (edited) values,
/// or 0 if none; we need access to the following sourcephrase in case the user changes
/// markers and then the m_bFirstOfType flag on gpFollSrcPhrase would often need to be
/// reset TRUE.
CSourcePhrase* gpFollSrcPhrase;

// This global was defined in TransferMarkersDlg.cpp in the legacy MFC app.
/// This global is TRUE if the TextType needs to be propagated to sourcephrase instances
/// following the new sublist, after all housekeeping is done & propagation is done in
/// OnEditSourceText().
bool gbPropagationNeeded;

// This global was defined in TransferMarkersDlg.cpp (now removed) in the legacy MFC app.
/// Indicates the TextType to be propagated when the gbPropagationNeeded global is TRUE
TextType gPropagationType; // the TextType to be propagated

/// This global is defined in Adapt_ItDoc.cpp.
extern bool		gbSpecialText;  // the special text boolean which will need to be propagated,
								// if propagation is required


// BEW additional globals and defines, 14Apr08, for support of the vertical editing process

// The next two globals track the vertical edit update process; when
// gbVerticalEditInProgress is turned on (TRUE), the gEntryPoint value specifies what the
// entry point was; this enables the code for any of the vertical edit processing steps to
// be able to determine what kind of edit initiated the vertical update process (eg. a
// source text edit, or an adaptation edit, etc), which in turn enables that code to know
// what members of the gEditRecord struct can be expected to have data in them which can be
// used by the current processing step of the vertical sequence. Each step also has its own
// enum value in the global gEditStep, so that if backtracking through the steps is
// required, the code can know where it must start from in the total process. Also, if the
// user edited a misspelled SF marker, and the marker which results is one nominated for
// filtering or unfiltering, the filtering or unfiltering will take place - changing the
// number of CSourcePhrase instances in the document. The bail out process must be smart
// enough to restore the original doc state when necessary given such a filtering or
// unfiltering has taken place; and we want exceptions to cause restoration of the pre-edit
// document state, rather than application death
/// Tracks whether or not vertical editing is currently in effect, and it has to be TRUE
/// for the drawing of gray text in preceding and following context of the span which is
/// being updated during the vertical edit process
bool gbVerticalEditInProgress = FALSE; // TRUE while any stage of a vertical edit process is active

/// During editing of the source text, up to a certain stage the native document structures
/// are not modified, making it possible to abandon the source text edit without restoring
/// anything in the document while this boolean remains TRUE; once it is FALSE the native
/// structures have begun to be modified and a different source editing abandonment
/// strategy is required (and implemented)
bool gbEditingSourceAndDocNotYetChanged = TRUE; // programmatically cleared to FALSE when doc is changed

/// This global enum tracks the entry point to the vertical editing process - there are
/// five possible values noEntryPoint (0), sourceTextEntryPoint (1), adaptationsEntryPoint
/// (2), glossesEntryPoint (3), freeTranslationsEntryPoint (4). Definition is in
/// Adapt_ItView.h
EntryPoint	gEntryPoint = noEntryPoint;  // from an enum, the value can be one of
			// noEntryPoint (0), sourceTextEntryPoint (1), adaptationsEntryPoint (2),
			// glossesEntryPoint (3), or freeTranslationsEntryPoint (4) (see Adapt_ItView.h)

/// This global enum tracks which step in the vertical editing process is currently in
/// effect. These "steps" are names for various Adapt It modes which otherwise the user
/// would need to manually turn on by menu commands, such as editing the source text,
/// adapting mode, glossing mode, free translation mode, and collecting data from the
/// adaptation or gloss line in order to store it as a filtered back translation; the
/// default value is noEditStep which is the value in effect when vertical editing is not
/// in progress
EditStep gEditStep = noEditStep; // see Adapt_ItView.h

/// Determines the relative order of the adaptationsStep and glossesStep during the
/// vertical process, the default order is to do the adaptations step prior to the glossing
/// step (the TRUE value); the value determines the program counter's path through the code
/// both when stepping forwards through the vertical edit process and also when rolling
/// back changes made at an earlier stage of the process
bool gbAdaptBeforeGloss = TRUE; // TRUE (default) if adaptationsStep is to be done
        // before glossesStep, FALSE for the opposite order (value of this global stored in
        // project configuration file)

/// The EditRecord is a struct, one instance of which persists as long as the session is
/// alive. It stores information about the vertical edit process which enables rollback and
/// cancellation to be supported. Its members are returned to default values, and most
/// lists emptied, when any one invocation of the vertical edit process is completed.
///
/// EditRecord is defined in Adapt_It.h file, here the comments are removed
/// to make reading the members easier
/// typedef struct
/// {
/// 	bool			bGlossingModeOnEntry;
/// 	bool			bSeeGlossesEnabledOnEntry;
/// 	bool			bEditSpanHasAdaptations;
/// 	bool			bEditSpanHasGlosses;
/// 	bool			bEditSpanHasFreeTranslations;
/// 	bool			bEditSpanHasBackTranslations;
/// 	BOOL			bCollectedFromTargetText;
///
/// 	int				nSaveActiveSequNum;
/// 	wxString		oldPhraseBoxText;
/// 	TextType		nStartingTextType;
/// 	TextType		nEndingTextType;
/// 	wxArrayString		deletedAdaptationsList;
/// 	wxArrayString		deletedGlossesList;
/// 	wxArrayString		deletedFreeTranslationsList;
/// 	wxArrayString		storedNotesList;
/// 	int				nStartingSequNum;
/// 	int				nEndingSequNum;
/// 	int				nFreeTrans_StartingSequNum;
/// 	int				nFreeTrans_EndingSequNum;
/// 	int				nBackTrans_StartingSequNum;
/// 	int				nBackTrans_EndingSequNum;
/// 	int				nCancelSpan_StartingSequNum;
/// 	int				nCancelSpan_EndingSequNum;
/// 	SPList			cancelSpan_SrcPhraseList;
/// 	SPList			modificationsSpan_SrcPhraseList;
/// 	SPList			editableSpan_NewSrcPhraseList;
/// 	SPList			propagationSpan_SrcPhraseList;
/// 	int				nPropagationSpan_StartingSequNum;
/// 	int				nPropagationSpan_EndingSequNum;
/// 	wxArrayInt		arrNotesSequNumbers;
/// 	CArray<int,int> arrNotesSequNumbers;
/// 	int				nOldSpanCount;
/// 	int				nNewSpanCount;
/// 	wxString		strInitialEndmarkers;
/// 	wxString		strFinalEndmarkers;
/// 	wxString		strNewFinalEndmarkers;
/// 	bool			bSpecialText;
/// 	SPList			follNotesMoveSpanList;
/// 	SPList			precNotesMoveSpanList;
/// 	bool			bTransferredFilterStuffFromCarrierSrcPhrase;
/// 	bool			bDocEndPreventedTransfer;
/// 	bool			bExtendedForFiltering;
///
/// 	bool			bAdaptationStepEntered;
/// 	SPList			adaptationStep_SrcPhraseList;
/// 	int				nAdaptationStep_StartingSequNum;
/// 	int				nAdaptationStep_EndingSequNum;
/// 	int				nAdaptationStep_OldSpanCount;
/// 	int				nAdaptationStep_NewSpanCount;
/// 	int				nAdaptationStep_ExtrasFromUserEdits;
///
/// 	bool			bGlossStepEntered;
/// 	SPList			glossStep_SrcPhraseList;
/// 	int				nGlossStep_StartingSequNum;
/// 	int				nGlossStep_EndingSequNum;
/// 	int				nGlossStep_SpanCount;
///
/// 	bool			bFreeTranslationStepEntered;
/// 	bool			bVerseBasedSection;
/// 	SPList			freeTranslationStep_SrcPhraseList;
/// 	int				nFreeTranslationStep_StartingSequNum;
/// 	int				nFreeTranslationStep_EndingSequNum;
/// 	int 			nFreeTranslationStep_SpanCount;
/// } EditRecord;


// The vertical editing process helps the user to edit/update dependent information, when
// editing information at a higher line of a strip invalidates information already entered
// in lower lines which depend on the higher line. The design of the topmost possible level
// of the process, the Edit Source Text functionality, requires a refactored dialog, minus
// the old and complex child dialog where SF markup was separately accessible; the
// refactored design eliminates the latter and shows SF markup and source text together,
// both accessible for editing. To keep the information non-confusing, notes, free
// translations, and any collected back translations defined in any part of the editable
// span, are removed - and retained in lists made accessible to the user later in the
// process (except removed back translations are chucked). The design involves careful
// delineation of four spans where certain types of information are removed from sublists
// -- see the comments for the definition of EditRecord in Adapt_ItView.h for extra
// details. To keep error recovery and cancelling as simple as possible when restoring the
// document to its earlier state, the m_pSourcePhrases list which defines the document is
// not changed until the very last moment when the user's edit is accepted (by the OK
// button press). This means that modifications needed to be done to CSourcePhrase
// instances prior to that, are done on deep copied instances in sublists stored in the
// EditRecord.
// The four spans (implemented as CObList and two int variables per span for the starting
// and ending offsets within the m_pSourcePhrases list on the document) are 1. the editable
// span (the user's selection, but extended to embrace any retranslation/s which the
// selection may overlap), 2. the cancel span - as wide as is necessary to hold deep copies
// of CSourcePhrase instances modified in the edit process (except it perhaps might not
// include all of the propagation span), 3. the modifications span - coextensive with the
// cancel span, but in which needed data modifications (primarily removal of distracting
// information types) are done prior to the Edit Source Text dialog being displayed, and 4.
// the propagation span - a span, possibly empty, or possibly containing numerous deep
// copies of the original CSourcePhrases following the editable span and where propagation
// of a new TextType after the source text edit was done resulted in CSourcePhrase changes.
// Span 1 always lies within spans 2 and 3; span 4 begins, if at all, immediately after
// span 1 and it may overlap completely or partially with instances in the end of spans 2
// and 3.

/// This define specifies the maximum number of etnries in the list of removed data types
/// (whether adaptations, glosses, or free translations) removed programmatically because
/// they have become invalid due to higher level changes during the vertical edit process.
/// Once this limit is reached in any of the three lists, adding more removes drops a
/// corresponding number of entries permanently off the bottom of that particular list
#define DELETIONS_LIST_MAX_ENTRIES 100

/// The vertical edit process tries to determine whether free translation sections, when
/// the user entered the free translations, were defined by punctuation locations, or verse
/// boundaries (for either setting, SF markers also influence the outcome), so that the
/// vertical edit process can use the same setting when the freeTranslationsStep is
/// entered. An algorithm does this but it cannot do it 100% reliably, and if all the
/// strong indicators are absent then it assumes that the 'verse boundaries" setting was in
/// effect if it can count off at least this number of free translation words within the
/// current section being algorithmically checked
#define NUM_WORDS_IMPLYING_VERSE_SECTIONING 15

/// This global provides a persistent location during the current session for storage of
/// vertical edit information
EditRecord gEditRecord; // store info pertinent to generalized editing with entry
		// point for an Edit Source Text request, in this global structure

/// This global string variable stores the previous contents of the edit box (either the
/// phrase box or the compose bar's edit box) when the user has just made a choice from the
/// removals combobox's list which replaces the box's text. It enables the Undo Last Copy
/// button to restore the box's previous contents provided further ducks line line up - see
/// the next four global variables for details
wxString gOldEditBoxTextStr; // a place to store the text replaced by the last copy from one of
							// the Removed combobox list's entries

/// This stores the sequence number at which the phrase box was located when the edit box's
/// contents were replaced. The Undo Last Changes button will not undo the last change
/// unless the phrase box has been placed back at this location by the user (the button is
/// disabled until that happens)
int gnWasSequNum;

/// This stores the the m_nSrcWords value when the edit box's contents were replaced. (Just
/// the sequence number value being the same is not sufficient, because the user may
/// subsequently have merged or unmerged at that location - so the merger state (in terms
/// of number of source words) must be the same as a condition for the Undo Last Copy
/// button to be enabled.)
int gnWasNumWordsInSourcePhrase;

/// A further condition for enabling the Undo Last Copy button is that the mode must be the
/// same as it was at the time the replacement was made; this global stores the earlier
/// mode - the values of relevance are whether it was adapting or glossing mode, and so a
/// boolean is suffient for those
bool gbWasGlossingMode; // the mode at last insert, either glossing mode (TRUE) or adapting mode (FALSE)

/// A final condition for enabling the Undo Last Copy button is that whether or not free
/// translation mode was turned on at the time the replacement was made; this mode can be
/// on or off concurrently with either of adapting or glossing modes, and so a further
/// boolean is needed to store the earlier state's value
bool gbWasFreeTranslationMode; // TRUE if free translation mode was in effect at last
    // insert, in which case gbWasGlossingMode value is ignored, the latter is used if
    // gbWasFreeTranslationMode is FALSE

// end of additional gobals and defines for support of the modeless editing process

// BEW added 15July08; definitions for custom events used in the vertical edit process,
// which typically starts with a source text edit, but in the wxWidgets based apps it could
// also be an adaptation edit, gloss edit, or free translation edit that starts it off;
// these events are UINT
// These custom events are implemented in the CMainFrame class in wx version; I'm leaving
// them commented out here in order to document that they exist - but elsewhere
//UINT CUSTOM_EVENT_ADAPTATIONS_EDIT = RegisterWindowMessage(_T("CustomEventAdaptationsEdit"));
//UINT CUSTOM_EVENT_FREE_TRANSLATIONS_EDIT = RegisterWindowMessage(_T("CustomEventFreeTranslationsEdit"));
//UINT CUSTOM_EVENT_BACK_TRANSLATIONS_EDIT = RegisterWindowMessage(_T("CustomEventBackTranslationsEdit"));
//UINT CUSTOM_EVENT_COLLECTED_BACK_TRANSLATIONS_EDIT
//							= RegisterWindowMessage(_T("CustomEventVCollectedBackTranslationsEdit"));
//UINT CUSTOM_EVENT_END_VERTICAL_EDIT = RegisterWindowMessage(_T("CustomEventEndVerticalEdit"));
//UINT CUSTOM_EVENT_CANCEL_VERTICAL_EDIT = RegisterWindowMessage(_T("CustomEventCancelVerticalEdit"));
//UINT CUSTOM_EVENT_GLOSSES_EDIT = RegisterWindowMessage(_T("CustomEventGlossesEdit"));

bool gbVerticalEdit_SynchronizedScrollReceiveBooleanWasON = FALSE;

// BEW 7May08: end of vertical editing's globals, including those
// for the refactored code for src text editing
/////////////////////////////////////////////////////////////////////////////////////

extern bool		gbByCopyOnly;		  // see CPhraseBox for explanation of its function
extern int		gnLastEarlierChapter; // preserve chapter and verse number used in last call of
extern int		gnLastEarlierVerse;	  // View Earlier Translation dialog

/// Multiply width of 'w' character this many times to get the slop at right-hand-side
/// (RHS) of initial phrase box width, or the amount to expand the box by.
short			gnExpandBox = 8;

/// Use this multiplier to calculate when text gets too near the RHS of the phrase box, so
/// that expansion becomes necessary - see the FixBox() function in CPhraseBox class.
short			gnNearEndFactor = 3;

wxRect			grectViewClient;

/// When TRUE the main window only displays the target text lines.
bool			gbShowTargetOnly = FALSE;

/// Used to store the App's m_curLeading value when switching between views that only
/// display the target language and those that display normal target lines.
int				gnSaveLeading = 4;

/// Used to store the App's m_curGapWidth value when switching between views that only
/// display the target language and those that display normal target lines.
int				gnSaveGap = 8;

extern bool		gbUnmergeJustDone;		 // see CPhraseBox for explanation
extern bool		gbCompletedMergeAndMove; // see CPhraseBox for explanation
extern bool		gbEnterTyped;			 // see CPhraseBox for explanation

extern  wxString	gSaveTargetPhrase; // for use by the SHIFT+END shortcut for unmerging a phrase

//GDLC Removed 2010-02-09
//extern	bool	gbExpanding; // see use in CalcPileWidth // defined in CPhraseBox // changed int to bool

/// This global is defined in Adapt_It.cpp.
extern  int		nSequNumForLastAutoSave;

/// This global is defined in Adapt_ItDoc.cpp.
extern	bool	bUserCancelled;

extern  bool	gbJustCancelled; // set TRUE when Find or Find & Replace dialog
        // window has just been cancelled and needed for view's OnButtonMerge() function,
        // the look ahead code block
bool bSuppressDefaultAdaptation = FALSE;	// normally FALSE, but set TRUE whenever
        // user is wanting a MergeWords done by typing into the phrase box (which also
        // ensures cons.changes won't be done on the typing) - actually more complex than
        // this, see CPhraseBox OnChar()
bool   gbInspectTranslations = FALSE;	// TRUE when user manually opens CChooseTranslation
		// to inspect adaptions
extern bool		gbUserCancelledChooseTranslationDlg;
extern bool		gbSuppressLookup; // see CPhraseBox globals for explanation

// global to make source phrase accessible to dialogs and to the callback functions of the
// xml parser (so this has multiple uses - beware)
CSourcePhrase* gpSrcPhrase;

SPList gSrcPhrases; // for list of CSourcePhrase instances in the retranslation

// global pointer to the punctuation remainder list, for use by CPlaceInternalPunct
wxArrayString* gpRemainderList = (wxArrayString*)NULL; // MFC uses CStringList*

/// TRUE if a consistency check is in progress. Used to supress the placement of the
/// phrase box when documents are opened while performing a consistency check.
bool	gbConsistencyCheckCurrent = FALSE;

// some globals for use in merging
wxString gOldConcatStr = _T("");			// may have punctuation
wxString gOldConcatStrNoPunct = _T("");  // has any punctuation removed
bool	gbMergeSucceeded = FALSE;

// miscellaneous
bool	gbJustClosedProject = FALSE; // use to suppress Welcome to Adapt It window after doc opened

// global, for choosing whether Find... or Find and Replace... comes up
bool	gbFind = TRUE;
bool	gbFindIsCurrent = FALSE;
bool	gbJustReplaced = FALSE;
bool	gbFindOrReplaceCurrent = FALSE; // for use by CMainFrame's OnActive() function

// globals for handling advancement over a found retranslation
//bool gbMatchedRetranslation = FALSE; BEW 3Aug09 changed it to be the app member
//m_bMatchedRetranslation
int  gnRetransEndSequNum; // sequ num of last srcPhrase in a matched retranslation

/// A global for saving a source phrase's old sequence number in case it is required
/// for the toolbar's Back button; or for saving the active location in a variety of
/// command handlers. When there is no earlier location, it is set to -1, but you should
/// never rely on it having the value -1 unless you know you've set -1 earlier
int gnOldSequNum = -1;

// globals defined in CPhraseBox
extern int			nWordsInPhrase;

/// This global is defined in PhraseBox.cpp.
extern wxString		translation; // translation, for a matched source phrase key

extern CTargetUnit*	pCurTargetUnit; // when valid, it is the matched CTargetUnit instance
extern wxString		curKey; // when non empty, it is the current key string which was matched

// global set by ChooseTranslation, when user selects <no adaptation>, then PhraseBox will
// not use CopySource() but instead use an empty string for the adaptation
bool	gbEmptyAdaptationChosen = FALSE;

// global for alerting OnLButtonUp() that selection has been halted at a boundary
// (set in OnMouseMove())
bool	gbHaltedAtBoundary = FALSE;

/// This global is defined in Adapt_It.cpp.
extern wxPoint gptLastClick;

/// For preserving selection across a RecalcLayout() or LayoutStrip().
int		gnSelectionStartSequNum;

/// For preserving selection across a RecalcLayout() or LayoutStrip().
int		gnSelectionEndSequNum;

/// Preserved value of m_selectionLine
int		gnSelectionLine;

bool	gbIsBeingPreviewed = FALSE; // true while a print preview is being done
int		gnPrintingLength; // ditto for the printing length of the page
int		gnFromChapter = 1;
int		gnFromVerse = 1;
int		gnToChapter = 1;
int		gnToVerse = 1;
int		gnRangeStartSequNum;
int		gnRangeEndSequNum;
bool	gbCheckInclFreeTransText = FALSE; // klb 9/9/2011-indicates whether to
					// include Free Translation Text when printing-set in PrintOptionsDlg
bool	gbCheckInclGlossesText = FALSE; // klb 9/9/2011-indicates whether to include
					// Glosses Text when printing-set in PrintOptionsDlg

/// If TRUE print the footer, otherwise skip printing of footer
bool	gbPrintFooter = TRUE;

int		gnTopGap = 100; // units of thousandths of an inch for this and next two
int		gnFooterTextHeight = 150; // for the text of the footer, units of thousandths of an inch
int		gnBottomGap = 0; // assume we can print right to the rtMinMargin.bottom limit on the page
bool	gbSuppressPrecedingHeadingInRange = FALSE;
bool	gbIncludeFollowingHeadingInRange = FALSE;

IMPLEMENT_DYNAMIC_CLASS(CAdapt_ItView, wxView)

BEGIN_EVENT_TABLE(CAdapt_ItView, wxView)
	// Event table data copied from Win AI with ON_COMMAND macro
	// changed to EVT_MENU, and ON_UPDATE_COMMAND_UI changed to
	// EVT_UPDATE_UI for wxWidgets
    EVT_SIZE(CAdapt_ItView::OnSize)

	// File Menu
	EVT_UPDATE_UI(wxID_NEW, CAdapt_ItView::OnUpdateFileNew)
	EVT_UPDATE_UI(wxID_OPEN, CAdapt_ItView::OnUpdateFileOpen)

	// Standard printing commands
	EVT_MENU(wxID_PRINT, CAdapt_ItView::OnPrint)
	EVT_UPDATE_UI(wxID_PRINT, CAdapt_ItView::OnUpdateFilePrint)
	EVT_MENU(wxID_PREVIEW, CAdapt_ItView::OnPrintPreview)
	EVT_UPDATE_UI(wxID_PREVIEW, CAdapt_ItView::OnUpdateFilePrintPreview)
	EVT_MENU(ID_FILE_STARTUP_WIZARD, CAdapt_ItView::OnFileStartupWizard)
	EVT_MENU(ID_FILE_CLOSEKB, CAdapt_ItView::OnFileCloseProject)
	EVT_UPDATE_UI(ID_FILE_CLOSEKB, CAdapt_ItView::OnUpdateFileCloseKB)
	EVT_MENU(ID_FILE_SAVEKB, CAdapt_ItView::OnFileSaveKB)
	EVT_UPDATE_UI(ID_FILE_SAVEKB, CAdapt_ItView::OnUpdateFileSaveKB)
	// End of File Menu

	// Edit Menu
	EVT_MENU(wxID_UNDO, CAdapt_ItView::OnEditUndo)
	EVT_UPDATE_UI(wxID_UNDO, CAdapt_ItView::OnUpdateEditUndo)
	EVT_MENU(ID_EDIT_CUT, CAdapt_ItView::OnEditCut)
	EVT_UPDATE_UI(ID_EDIT_CUT, CAdapt_ItView::OnUpdateEditCut)
	EVT_MENU(ID_EDIT_COPY, CAdapt_ItView::OnEditCopy)
	EVT_UPDATE_UI(ID_EDIT_COPY, CAdapt_ItView::OnUpdateEditCopy)
	EVT_MENU(ID_EDIT_PASTE, CAdapt_ItView::OnEditPaste)
	EVT_UPDATE_UI(ID_EDIT_PASTE, CAdapt_ItView::OnUpdateEditPaste)
	EVT_MENU(ID_GO_TO, CAdapt_ItView::OnGoTo)
	EVT_UPDATE_UI(ID_GO_TO, CAdapt_ItView::OnUpdateGoTo)
	EVT_MENU(ID_EDIT_SOURCE_TEXT, CAdapt_ItView::OnEditSourceText)
	EVT_UPDATE_UI(ID_EDIT_SOURCE_TEXT, CAdapt_ItView::OnUpdateEditSourceText)

	EVT_MENU(wxID_PREFERENCES, CAdapt_ItView::OnEditPreferences)
	EVT_UPDATE_UI(wxID_PREFERENCES, CAdapt_ItView::OnUpdateEditPreferences)
	// End of Edit Menu

	// View Menu
	EVT_MENU(ID_COPY_SOURCE, CAdapt_ItView::OnCopySource)
	EVT_UPDATE_UI(ID_COPY_SOURCE, CAdapt_ItView::OnUpdateCopySource)
	EVT_MENU(ID_MARKER_WRAPS_STRIP, CAdapt_ItView::OnMarkerWrapsStrip)
	EVT_UPDATE_UI(ID_MARKER_WRAPS_STRIP, CAdapt_ItView::OnUpdateMarkerWrapsStrip)
	EVT_MENU(ID_UNITS, CAdapt_ItView::OnUnits)
	EVT_UPDATE_UI(ID_UNITS, CAdapt_ItView::OnUpdateUnits)
	// whm added the following two 16Apr07
	EVT_UPDATE_UI(ID_CHANGE_INTERFACE_LANGUAGE, CAdapt_ItView::OnUpdateChangeInterfaceLanguage)
	EVT_MENU(ID_CHANGE_INTERFACE_LANGUAGE, CAdapt_ItView::OnChangeInterfaceLanguage)
	// End of View Menu

	// Tools Menu
	EVT_MENU(wxID_FIND, CAdapt_ItView::OnFind)
	EVT_UPDATE_UI(wxID_FIND, CAdapt_ItView::OnUpdateFind)
	EVT_MENU(wxID_REPLACE, CAdapt_ItView::OnReplace)
	EVT_UPDATE_UI(wxID_REPLACE, CAdapt_ItView::OnUpdateReplace)
	EVT_MENU(ID_USE_CC, CAdapt_ItView::OnUseConsistentChanges)
	EVT_UPDATE_UI(ID_USE_CC, CAdapt_ItView::OnUpdateUseConsistentChanges)

	EVT_MENU(ID_USE_SILCONVERTER, CAdapt_ItView::OnUseSilConverter)
	EVT_UPDATE_UI(ID_USE_SILCONVERTER, CAdapt_ItView::OnUpdateUseSilConverter)
	EVT_MENU(ID_TOOLS_DEFINE_SILCONVERTER, CAdapt_ItView::OnSelectSilConverters)
	EVT_UPDATE_UI(ID_TOOLS_DEFINE_SILCONVERTER, CAdapt_ItView::OnUpdateSelectSilConverters)

	EVT_MENU(ID_ACCEPT_CHANGES, CAdapt_ItView::OnAcceptChanges)
	EVT_UPDATE_UI(ID_ACCEPT_CHANGES, CAdapt_ItView::OnUpdateAcceptChanges)
	EVT_MENU(ID_TOOLS_KB_EDITOR, CAdapt_ItView::OnToolsKbEditor)
	EVT_UPDATE_UI(ID_TOOLS_KB_EDITOR, CAdapt_ItView::OnUpdateToolsKbEditor)
	// End of Tools Menu

	// Export-Import Menu
	EVT_MENU(ID_FILE_EXPORT_SOURCE, CAdapt_ItView::OnFileExportSource)
	EVT_UPDATE_UI(ID_FILE_EXPORT_SOURCE, CAdapt_ItView::OnUpdateFileExportSource)
	EVT_MENU(ID_FILE_EXPORT, CAdapt_ItView::OnFileExport)
	EVT_UPDATE_UI(ID_FILE_EXPORT, CAdapt_ItView::OnUpdateFileExport)
	EVT_MENU(ID_FILE_EXPORT_TO_RTF, CAdapt_ItView::OnFileExportToRtf)
	EVT_UPDATE_UI(ID_FILE_EXPORT_TO_RTF, CAdapt_ItView::OnUpdateFileExportToRtf)
	EVT_MENU(ID_EXPORT_GLOSSES, CAdapt_ItView::OnExportGlossesAsText)
	EVT_UPDATE_UI(ID_EXPORT_GLOSSES, CAdapt_ItView::OnUpdateExportGlossesAsText)
	EVT_MENU(ID_EXPORT_FREE_TRANS, CAdapt_ItView::OnExportFreeTranslations)
	EVT_UPDATE_UI(ID_EXPORT_FREE_TRANS, CAdapt_ItView::OnUpdateExportFreeTranslations)
	EVT_MENU(ID_IMPORT_TO_KB, CAdapt_ItView::OnImportToKb)
	EVT_UPDATE_UI(ID_IMPORT_TO_KB, CAdapt_ItView::OnUpdateImportToKb)
	EVT_MENU(ID_MENU_IMPORT_EDITED_SOURCE_TEXT, CAdapt_ItView::OnImportEditedSourceText)
	EVT_UPDATE_UI(ID_MENU_IMPORT_EDITED_SOURCE_TEXT, CAdapt_ItView::OnUpdateImportEditedSourceText)
	// End of Export-Import Menu

	// Advanced Menu
	// Event for Enable/Disable Glossing menu item
	EVT_MENU(ID_ADVANCED_SEE_GLOSSES, CAdapt_ItView::OnAdvancedSeeGlosses)
	EVT_UPDATE_UI(ID_ADVANCED_SEE_GLOSSES, CAdapt_ItView::OnUpdateAdvancedEnableglossing)
	// Event for Glossing Uses Nav Font menu item
	EVT_MENU(ID_ADVANCED_GLOSSING_USES_NAV_FONT, CAdapt_ItView::OnAdvancedGlossingUsesNavFont)
	EVT_UPDATE_UI(ID_ADVANCED_GLOSSING_USES_NAV_FONT, CAdapt_ItView::OnUpdateAdvancedGlossingUsesNavFont)
	EVT_MENU(ID_ADVANCED_DELAY, CAdapt_ItView::OnAdvancedDelay)
	EVT_UPDATE_UI(ID_ADVANCED_DELAY, CAdapt_ItView::OnUpdateAdvancedDelay)

	// 12 menu definitions moved to CFreeTrans

	EVT_MENU(ID_ADVANCED_USETRANSLITERATIONMODE, CAdapt_ItView::OnAdvancedUseTransliterationMode)
	EVT_UPDATE_UI(ID_ADVANCED_USETRANSLITERATIONMODE, CAdapt_ItView::OnUpdateAdvancedUseTransliterationMode)
	// End of Advanced Menu

//#ifdef _UNICODE
	// Layout Menu
	EVT_MENU(ID_ALIGNMENT, CAdapt_ItView::OnAlignment)
	EVT_UPDATE_UI(ID_ALIGNMENT, CAdapt_ItView::OnUpdateAlignment)
//#endif

	// Help menu
	//OnAppAbout is in CMainFrame in wxWidgets version

	// ControlBar event handlers
	EVT_CHECKBOX(IDC_CHECK_ISGLOSSING, CAdapt_ItView::OnCheckIsGlossing)
	EVT_RADIOBUTTON(IDC_RADIO_DRAFTING, CAdapt_ItView::OnRadioDrafting)
	EVT_UPDATE_UI(IDC_RADIO_DRAFTING, CAdapt_ItView::OnUpdateRadioDrafting)
	EVT_RADIOBUTTON(IDC_RADIO_REVIEWING, CAdapt_ItView::OnRadioReviewing)
	EVT_UPDATE_UI(IDC_RADIO_REVIEWING, CAdapt_ItView::OnUpdateRadioReviewing)
	EVT_CHECKBOX(IDC_CHECK_SINGLE_STEP, CAdapt_ItView::OnCheckSingleStep)
	EVT_UPDATE_UI(IDC_CHECK_SINGLE_STEP, CAdapt_ItView::OnUpdateCheckSingleStep)
	EVT_CHECKBOX(IDC_CHECK_KB_SAVE, CAdapt_ItView::OnCheckKBSave)
	EVT_CHECKBOX(IDC_CHECK_FORCE_ASK, CAdapt_ItView::OnCheckForceAsk)
	EVT_BUTTON(IDC_BUTTON_NO_ADAPT, CAdapt_ItView::OnButtonNoAdapt)
	EVT_UPDATE_UI(IDC_BUTTON_NO_ADAPT, CAdapt_ItView::OnUpdateButtonNoAdapt)

	// ToolBar event handlers
	// Event for Enable/Disable Punct copy
	EVT_TOOL(ID_BUTTON_ENABLE_PUNCT_COPY, CAdapt_ItView::OnButtonEnablePunctCopy)
	EVT_UPDATE_UI(ID_BUTTON_ENABLE_PUNCT_COPY, CAdapt_ItView::OnUpdateButtonEnablePunctCopy)
	EVT_TOOL(ID_BUTTON_NO_PUNCT_COPY, CAdapt_ItView::OnButtonNoPunctCopy)
	EVT_UPDATE_UI(ID_BUTTON_NO_PUNCT_COPY, CAdapt_ItView::OnUpdateButtonNoPunctCopy)
	// Event for Respect/Ignore boundary controlBar button
    EVT_TOOL(ID_BUTTON_RESPECTING_BDRY, CAdapt_ItView::OnButtonFromRespectingBdryToIgnoringBdry)
    EVT_UPDATE_UI(ID_BUTTON_RESPECTING_BDRY, CAdapt_ItView::OnUpdateButtonRespectBdry)
    EVT_TOOL(ID_BUTTON_IGNORING_BDRY, CAdapt_ItView::OnButtonFromIgnoringBdryToRespectingBdry)
    EVT_UPDATE_UI(ID_BUTTON_IGNORING_BDRY, CAdapt_ItView::OnUpdateButtonIgnoreBdry)
	// Event for Show/Hide Punctuation controlBar button
	EVT_TOOL(ID_BUTTON_SHOWING_PUNCT, CAdapt_ItView::OnButtonFromShowingToHidingPunct)
	EVT_UPDATE_UI(ID_BUTTON_SHOWING_PUNCT, CAdapt_ItView::OnUpdateButtonShowPunct)
    EVT_TOOL(ID_BUTTON_HIDING_PUNCT, CAdapt_ItView::OnButtonFromHidingToShowingPunct)
	EVT_UPDATE_UI(ID_BUTTON_HIDING_PUNCT, CAdapt_ItView::OnUpdateButtonHidePunct)
	// Event for Show Target/Show All controlBar button
	EVT_TOOL(ID_SHOWING_ALL, CAdapt_ItView::OnFromShowingAllToShowingTargetOnly)
	EVT_UPDATE_UI(ID_SHOWING_ALL, CAdapt_ItView::OnUpdateShowTgt)
	EVT_TOOL(ID_SHOWING_TGT, CAdapt_ItView::OnFromShowingTargetOnlyToShowingAll)
	EVT_UPDATE_UI(ID_SHOWING_TGT, CAdapt_ItView::OnUpdateShowAll)

	EVT_TOOL(ID_BUTTON_TO_END, CAdapt_ItView::OnButtonToEnd)
	EVT_UPDATE_UI(ID_BUTTON_TO_END, CAdapt_ItView::OnUpdateButtonToEnd)
	EVT_TOOL(ID_BUTTON_TO_START, CAdapt_ItView::OnButtonToStart)
	EVT_UPDATE_UI(ID_BUTTON_TO_START, CAdapt_ItView::OnUpdateButtonToStart)
	EVT_TOOL(ID_BUTTON_STEP_DOWN, CAdapt_ItView::OnButtonStepDown)
	EVT_UPDATE_UI(ID_BUTTON_STEP_DOWN, CAdapt_ItView::OnUpdateButtonStepDown)
	EVT_TOOL(ID_BUTTON_STEP_UP, CAdapt_ItView::OnButtonStepUp)
	EVT_UPDATE_UI(ID_BUTTON_STEP_UP, CAdapt_ItView::OnUpdateButtonStepUp)
	EVT_TOOL(ID_BUTTON_BACK, CAdapt_ItView::OnButtonBack)
	EVT_UPDATE_UI(ID_BUTTON_BACK, CAdapt_ItView::OnUpdateButtonBack)
	EVT_TOOL(ID_BUTTON_MERGE, CAdapt_ItView::OnButtonMerge)
	EVT_UPDATE_UI(ID_BUTTON_MERGE, CAdapt_ItView::OnUpdateButtonMerge)
	EVT_TOOL(ID_BUTTON_RESTORE, CAdapt_ItView::OnButtonRestore)
	EVT_UPDATE_UI(ID_BUTTON_RESTORE, CAdapt_ItView::OnUpdateButtonRestore)
	EVT_TOOL(ID_BUTTON_CHOOSE_TRANSLATION, CAdapt_ItView::OnButtonChooseTranslation)
	EVT_UPDATE_UI(ID_BUTTON_CHOOSE_TRANSLATION, CAdapt_ItView::OnUpdateButtonChooseTranslation)
	EVT_TOOL(ID_BUTTON_EARLIER_TRANSLATION, CAdapt_ItView::OnButtonEarlierTranslation)
	EVT_UPDATE_UI(ID_BUTTON_EARLIER_TRANSLATION, CAdapt_ItView::OnUpdateButtonEarlierTranslation)
	EVT_TOOL(ID_BUTTON_GUESSER, CAdapt_ItView::OnButtonGuesserSettings)
	EVT_UPDATE_UI(ID_BUTTON_GUESSER, CAdapt_ItView::OnUpdateButtonGuesserSettings)
	// End of ToolBar event handlers

	// ComposeBar handlers
	EVT_BUTTON(IDC_BUTTON_CLEAR, CAdapt_ItView::OnClearContentsButton)
	EVT_BUTTON(IDC_BUTTON_SELECT_ALL, CAdapt_ItView::OnSelectAllButton)

	// Free Translation - 13 Composebar Button definitions moved to CFreeTrans

	// The following added for Vertical Editing, implemented by BEW
	EVT_UPDATE_UI(IDC_BUTTON_UNDO_LAST_COPY, CAdapt_ItView::OnUpdateButtonUndoLastCopy)
	EVT_BUTTON(IDC_BUTTON_UNDO_LAST_COPY, CAdapt_ItView::OnButtonUndoLastCopy)
	EVT_UPDATE_UI(IDC_BUTTON_PREV_STEP, CAdapt_ItView::OnUpdateButtonPrevStep)
	EVT_BUTTON(IDC_BUTTON_PREV_STEP, CAdapt_ItView::OnButtonPrevStep)
	EVT_UPDATE_UI(IDC_BUTTON_NEXT_STEP, CAdapt_ItView::OnUpdateButtonNextStep)
	EVT_BUTTON(IDC_BUTTON_NEXT_STEP, CAdapt_ItView::OnButtonNextStep)
	EVT_UPDATE_UI(ID_BUTTON_END_NOW, CAdapt_ItView::OnUpdateButtonEndNow)
	EVT_BUTTON(ID_BUTTON_END_NOW, CAdapt_ItView::OnButtonEndNow)
	EVT_UPDATE_UI(ID_BUTTON_CANCEL_ALL_STEPS, CAdapt_ItView::OnUpdateButtonCancelAllSteps)
	EVT_BUTTON(ID_BUTTON_CANCEL_ALL_STEPS, CAdapt_ItView::OnButtonCancelAllSteps)

	// Mouse events  --  moved to CAdapt_ItCanvas
END_EVENT_TABLE()

CAdapt_ItView::CAdapt_ItView()
{
	// whm All MFC's View variable initializations moved to the App

	// below unique to wxWidgets version
	canvas = (CAdapt_ItCanvas*) NULL;
	pCanvasFrame = (wxFrame*) NULL;
}

CAdapt_ItView::~CAdapt_ItView() // whm added
{
	// All cleanup is to be done in App's OnExit() function
}

CLayout* CAdapt_ItView::GetLayout()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	return pApp->m_pLayout;
}

// Can be used for default print/preview
// as well as drawing on the screen
void CAdapt_ItView::OnDraw(wxDC *pDC)
{
    // the mechanism Bill has is that the canvas class handles the paint event, and the
    // handler (OnPaint()) ignores the contents of the passed in event but creates a
    // wxPaintDC with the call wxPaintDC paintDC(this); and then he explicitly calls
    // DoPrepareDC(paintDC) to get the origin scrolled to agree with the scrollbar and then
    // excutes the CAdapt_ItView's OnDraw(wxDC* pDC) by calling the canvas member
    // pView->OnDraw(&paintDC); - so the original wxDC passed to view's OnDraw() is ignored
    // and replaced with the scrolled one from the canvas before any drawing is done - I
    // don't see any problem with this mechanism (BEW note, 20Mar09)

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	if (GetLayout() == NULL)
		return; // application not fully initialized yet
	if (GetLayout()->GetPileList()->GetCount() == 0)
		return; // still nothing to draw yet, so can't make any strips
	wxSize canvasViewSize;
	canvasViewSize = pApp->GetMainFrame()->GetCanvasClientSize(); // gets the width and height of canvas in pixels

	pDC->DestroyClippingRegion(); // ensure whole client area is drawable

    // BEW 14Mar11, Gerry Andersen reports that occasionally, for an unknown set of user
    // actions, the display is updated in such a way that the right end of the phrase box
    // overlaps the start of text in the next pile's adaptation. Noone has ever been able
    // to reproduce this error on demand, in the last 6 years or so. The specific
    // screenshot Gerry provided showed a problem I've not ever seen before, the start of
    // the phrase box was overlapping the end of a merger which immediately preceed it (see
    // email of 12 Jan 2011).So here I'm attempting a kludge which will hopefully prevent
    // this, and the more typical occasional problem of the box overlapping what follows,
    // from happening. The errors are different, & cause isn't clear for either, but it's
    // clear what happens. The typical error is that the gap left in the layout for the box
    // isn't wide enough to accomodate the box size. So here I'll test for a box size wider
    // than the gap left for the box at the active pile, and if so, call whatever is
    // required to force a wider gap - probably a RecalcLayout() call initiated from a
    // FixBox() call in which the last param is 1 (ie. base new box size on width of text
    // in it). Hopefully this test will never yield TRUE, but if it does, the code block
    // should prevent the overlap Gerry and others have noted as happening occasionally.
    // The error Gerry reported, is caused by the active pile's left offset being smaller
    // than the previous pile's left offset plus its m_nWidth value. We can test for the
    // latter too, and when that happens, force the recalc before the draw.

    // BEW 5Oct11; Doing a Print Preview after PrintOptionsDlg did a print of physical
    // pages, failed here (pActivePile below was rubbish) due to m_pActivePile having been
    // clobbered. So recalc m_pActivePile before going on... (yes, this fixed the problem)
	pApp->m_pActivePile = pApp->m_pLayout->GetPile(pApp->m_nActiveSequNum);
	CPile* pActivePile = pApp->m_pActivePile;
	CPile* pPrevPile = pApp->m_pLayout->GetPile(pApp->m_nActiveSequNum - 1);
	if (pActivePile != NULL && pApp->m_nActiveSequNum != -1)
	{
		//int activePileWidth = pActivePile->m_nWidth;
		wxSize boxSize = pApp->m_pTargetBox->GetSize();
		int boxWidth = (int)boxSize.y;
		int layoutGapWidth = pApp->m_pLayout->m_curBoxWidth;
		if (boxWidth > layoutGapWidth)
		{
			wxSize textExtent;
			wxString currText = pApp->m_pTargetBox->GetValue();
			pApp->m_pTargetBox->FixBox(this, currText,TRUE,textExtent,1);
		}
		else if (pPrevPile != NULL && !pApp->m_bRTL_Layout)
		{
			// test for left bound of the phrase box (ie. left x-coord of the active pile)
			// having a value less than the sum of the left x-coord of the previous pile
			// plus that piles m_nWidth value. When true, make the above adjustment here
			// too. The error we are kludging around has only been reported for LTR
			// layout, so we'll ignore the RTL layout possibility. (I was able to get
			// control to enter here a couple of times... one time was when I made a three
			// word phrase of stuff already adapted, but couldn't reproduce the entry.
			// Another was after I'd made a 3 word merger at immed left of active location
			// and the merger had a typo needing an extra char to be typed in the target
			// text, active location was immed. after the phrase, I clicked on the phrase
			// and added the extra char and then either Enter to advance or clicked at
			// former active location - and control entered here... so possibly that kind
			// of thing generates the layout error Gerry reported -- important thing,
			// though, is that this kludge works and does not cause a noticeable delay)
			if (pActivePile->Left() < pPrevPile->Left() + pPrevPile->GetWidth())
			{
				wxSize textExtent;
				wxString currText = pApp->m_pTargetBox->GetValue();
				pApp->m_pTargetBox->FixBox(this, currText,TRUE,textExtent,1);
			}
		}
	}

	// draw the layout
	GetLayout()->Draw(pDC);

    // BEW added 7Jul05 for drawing the free translation text substrings in the spaces
    // created under each of the strips - but only when we are not currently printing
    // (drawing is not done outside the client area for the view)
	// BEW 1Oct11, added a new variant for handling printing of free translations; it has
	// to confine its drawing to the strips delineated by the PageOffset struct pointed at
	// by the app member m_nCurPage - which stores indices for first and last strip to be drawn
	// KLB 9/2011 added check for gbCheckInclFreeTransText so free translations would
	// print on print preview
	if (pApp->m_bFreeTranslationMode && !pApp->m_bIsPrinting)
	{
		pApp->GetFreeTrans()->DrawFreeTranslations(pDC, GetLayout());
	}
	else if (pApp->m_bIsPrinting && gbCheckInclFreeTransText)
	{
#if !defined(__WXGTK__)
        // for Windows and Mac, call it here; but for __WXGTK__ build, do this instead in
        // the AIPrintout's OnPrintPage() function
		pApp->GetFreeTrans()->DrawFreeTranslationsForPrinting(pDC, GetLayout());
#endif
	}

}

// return the CPile* at the passed in index, or NULL if the index is out of bounds;
// the pile list is at CLayout::m_pileList
// BEW 26Mar10, no changes needed for support of doc version 5
CPile* CAdapt_ItView::GetPile(const int nSequNum)
{
	// refactored 10Mar09, for new view layout design
	CLayout* pLayout = GetLayout();
	wxASSERT(pLayout != NULL);
	PileList* pPiles = pLayout->GetPileList();
	int nCount = pPiles->GetCount();
	if (nSequNum < 0 || nSequNum >= nCount)
	{
		// bounds error, so return NULL
		return (CPile*)NULL;
	}
	PileList::Node* pos = pPiles->Item(nSequNum); // relies on parallelism of m_pSourcePhrases
												  // and m_pileList lists
	wxASSERT(pos != NULL);
	return pos->GetData();
}

// BEW 26Mar10, no changes needed for support of doc version 5
CCell* CAdapt_ItView::GetNextCell(CCell *pCell, const int cellIndex)
{
    // returns the next cell at the level specified by cellIndex (note: switching levels is
    // allowed because we only care about the level of the cell in the next pile), or
    // returns NULL if there is no next pile (and hence no next cell)
	// refactored 17Mar09
	CPile* pPile = pCell->GetPile();
	PileList* pPiles = GetLayout()->GetPileList();
	int index = pPiles->IndexOf(pPile);
	index++; // index of next CPile instance
	if (index >= (int)pPiles->GetCount())
	{
		return NULL; // bounds error - passed end of document
	}
	else
	{
		// not past end of document
		PileList::Node* pos = pPiles->Item(index);
		pPile = pos->GetData();
		wxASSERT(pPile != NULL);
	}
	return pPile->GetCell(cellIndex);
}


// returns a pointer to the next pile, or NULL if there is none
// BEW 26Mar10, no changes needed for support of doc version 5
CPile* CAdapt_ItView::GetNextPile(CPile *pPile)
{
	// refactored 17Mar09; BEW modified 25Oct09 as pPile can be NULL
	// passed in, in Review mode, so must test for it early!
	if (pPile == NULL)
		return (CPile*)NULL;
	CPile* pNextPile = NULL;
	PileList* pPiles = GetLayout()->GetPileList();
	int index = pPiles->IndexOf(pPile);
	index++; // index of next CPile instance
	if (index >= (int)pPiles->GetCount())
	{
		return (CPile*)NULL; // bounds error - passed end of document
	}
	else
	{
		// not past end of document
		PileList::Node* pos = pPiles->Item(index);
		pNextPile = pos->GetData();
		wxASSERT(pPile != NULL);
	}
	return pNextPile;
}

// BEW 26Mar10, no changes needed for support of doc version 5
CPile* CAdapt_ItView::GetPrevPile(CPile *pPile)
// returns a pointer to the previous pile, or NULL if there is none
{
	// refactored 30Mar09
	CPile* pPrevPile = NULL;
	PileList* pPiles = GetLayout()->GetPileList();
	int index = pPiles->IndexOf(pPile);
	index--; // index of previous CPile instance
	if (index < 0)
	{
		return (CPile*)NULL; // bounds error - passed beginning of document
	}
	else
	{
		// not past beginning of document
		PileList::Node* pos = pPiles->Item(index);
		pPrevPile = pos->GetData();
		wxASSERT(pPile != NULL);
	}
	return pPrevPile;
}

// MFC docs say that OnInitialUpdate() is "Called by the framework after the view
// is first attached to the document, but before the view is initially displayed. The
// default implementation of this function calls the OnUpdate member function with no
// hint information (that is, using the default values of 0 for the IHint parameter
// and NULL for the pHint parameter)."
// Design Note: Test of all MFC routines that could potentially call OnInitialUpdate()
// in the App show that OnInitialUpdate() is actually only called at the following
// times in the MFC code:
// 1. At end of OnInit() when app is initially run before the main frame appears (OnInit
//    explicitly calls pView->OnInitialUpdate().
// 2. When File | New menu selection is made (
// 3. When Loading a file from the MRU list.
// 4. When the main window is split (observed Jan07)
// OnInitialUpdate() should be called for only two main scenarios
// (1) for File | New, and (2) when loading a file from the MRU list. It
// doesn't really need to be called in OnInit() because the CreateDocument()
// call there triggers a File | New scenario which includes the OnInitialUpdate()
// call. See notes in App's OnInit().
// TODO: Splitting of the main window in the wxWidgets version is not yet implemented, but
// if/when it is implemented it should be tested to see if OnInitialUpdate should be
// called for that situation too.
// BEW 26Mar10, no changes needed for support of doc version 5
void CAdapt_ItView::OnInitialUpdate()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxCommandEvent dummyevent; // for use in EVT governed function calls

    // get the checkbox pointer for glossing, and hide it when app is first launched (a
    // command on the Advanced menu can be used for showing it later on); but since we can
    // get here from closing a doc and then creating or opening another, the gbIsGlossing
    // flag might be TRUE - in which case we will leave it unchanged and not hide the
    // checkbox, because presumably once the user is doing glossing, if he works on another
    // document he will most likely be glossing that too (or so we will assume)
	//
	// NOTE: wxWidgets version - this is taken care of in the App's OnInit()
	//
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);

	// update the copy shown on mode bar (it's read only there)
	wxTextCtrl* pDelayBox = (wxTextCtrl*)pControlBar->FindWindowById(IDC_EDIT_DELAY);
	// whm 12Oct10 modified below for user workflow compatibility
	if (pDelayBox != NULL)
	{
		wxString s;
		s.Empty();
		s << pApp->m_nCurDelay; //s = buf;
		pDelayBox->ChangeValue(s);
		pControlBar->Refresh();
	}

	// add the extra menu if it is the Unicode version
#ifdef _RTL_FLAGS
	// Note: The wx version starts with the Layout menu and removes it in the App's OnInit()

	// call AdjustAlignmentMenu to ensure that the Layout menu items text is set correctly
	AdjustAlignmentMenu(gbRTLLayout, gbLTRLayout);
#endif // for _RTL_FLAGS

	pApp->m_selection.Clear();
	pApp->m_pAnchor = (CCell*)NULL;
	pApp->m_selectionLine = -1;

	// need to ensure the initial targetPhrase box's text is not lost across
	// the next calls
	wxString saveText = pApp->m_targetPhrase;

    // WX Note: The App's color member are now set directly without short forms
    // specialTextColor etc.

	if (!gbShowTargetOnly)
	{
		gnSaveLeading = pApp->m_curLeading;
		gnSaveGap = pApp->m_curGapWidth;
		gbShowTargetOnly = TRUE;
		OnFromShowingTargetOnlyToShowingAll(dummyevent); // normal view, showing source & target lines
	}

	// whm Note 22Aug11. I think it is better to call the
	// MakeMenuInitializationsAndPlatformAdjustments() after setting the App's
	// flags to the desired state, than setting them to the opposite value and
	// calling their associated On...() handlers with a dummy wxCommandEvent,
	// designed to reverse the flag to the opposite state again. Nevertheless,
	// I'm leaving the original coding here in OnInitialUpdate()

    // BEW removed 8Aug09, there is no good reason to store a "punctuation hidden"
    // value because it we do that, the user could get confused if next time his
    // document doesn't show and punctuation and he didn't realize he shut down
    // with this setting toggled from the default, so now we'll ignore the config
    // file value, and always launch the app with this m_bHidePunctuation flag set
    // FALSE -- OnInit() initializes it to FALSE, config file is now ignored
	//if (!pApp->m_bHidePunctuation)
	//{
	//	pApp->m_bHidePunctuation = TRUE; // the function call will reset it to FALSE
	//	OnButtonFromHidingToShowingPunct(dummyevent); // make punctuation visible in lines 1 & 2
	//}

	// whm note: The OnButtonEnablePunctCopy() handler functions as one
	// half of the toolbar toggle button that toggles between "Copy Punctuation"
	// and "No Copy Punctuation". It only sets m_bCopySourcePunctuation to TRUE
	// if m_bCopySourcePunctuation is FALSE when OnButtonEnablePunctCopy() is
	// called. The other half of the toggle function is done in
	// OnButtonNoPunctCopy().
	if (pApp->m_bCopySourcePunctuation)
	{
		pApp->m_bCopySourcePunctuation = FALSE; // the function call will reset it to TRUE
		OnButtonEnablePunctCopy(dummyevent); // enable automatic copying of source text punctuation
	}

	if (pApp->m_bMarkerWrapsStrip)
	{
		// make sure the menu item is shown with checkmark
		pApp->m_bMarkerWrapsStrip = FALSE; // the function call will set it to TRUE
		OnMarkerWrapsStrip(dummyevent);
	}
	if (pApp->m_bCopySource)
	{
		// make sure the Copy Source menu item is shown with checkmark
		pApp->m_bCopySource = FALSE;
		OnCopySource(dummyevent); // toggle it ON, and set the checkmark
	}

    // wx version: the Save As XML menu item is always shown with checkmark and cannot be
    // changed

	if (pApp->m_bTransliterationMode)
	{
		// make sure the Use Transliteration Mode menu item is shown with checkmark
		pApp->m_bTransliterationMode = FALSE;
		OnAdvancedUseTransliterationMode(dummyevent); // toggle it ON, and set the checkmark
	}
	else
	{
		// make sure the Use Transliteration Mode menu item is shown without checkmark
		pApp->m_bTransliterationMode = TRUE;
		OnAdvancedUseTransliterationMode(dummyevent); // toggle it OFF, and clear the checkmark
	}

	if (gbIgnoreScriptureReference_Receive)
	{
		// scripture reference receiving starts out turned off, so get
		// the command unticked (meaning 'it is disabled', that is, turned off)
		gbIgnoreScriptureReference_Receive = FALSE;
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedReceiveSynchronizedScrollingMessages(uevent); //toggle flag to TRUE ie. OFF
	}
	if (gbIgnoreScriptureReference_Send)
	{
		// scripture reference sending starts out turned off, so get
		// the command unticked (meaning 'it is disabled', that is, turned off)
		gbIgnoreScriptureReference_Send = FALSE;
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedSendSynchronizedScrollingMessages(uevent); //toggle flag to TRUE ie. OFF
	}

	// turn the Drafting radio button ON, on the toolbar
	//
	// BEW modified 25Oct09, so that if m_bForce_Review_Mode is TRUE, then a call to
	// OnNewDocument() (which calls OnInitialUpdate()) does not change m_bDrafting
	// back to a TRUE setting, thereby ruining the intended effect of the former flag
	// - (m_bForce_Review_Mode, once set TRUE in OnInit() should remain TRUE, and
	// m_bDrafting should remain FALSE, for the life of that session)
	if (!pApp->m_bForce_Review_Mode)
	{
		OnRadioDrafting(dummyevent);
	}

	// set the pointer to the save list
	pApp->m_pSaveList = &pApp->m_saveList;

    // At this point the MFC version copies printing variables from those it had on the App
    // to those it maintined here in the View. Since the wx version maintains its printing
    // variable on the App, and they get updated when the config files are read from the
    // App's OnInit(), it is not necessary to

	pApp->SetPageOrientation(pApp->m_bIsPortraitOrientation);

	wxASSERT(pFrame);
	pFrame->SetSize(pApp->m_ptViewTopLeft.x, pApp->m_ptViewTopLeft.y, pApp->m_szView.x,
					pApp->m_szView.y, wxSIZE_AUTO);

	// Our wxWidgets' wxScrolledWindow is handled by the CAdapt_ItCanvas class.
	// From wxScrolledWindow documentation and samples for info on setting
	// up a sizer to help manage scrolling. Methods of wxScrolledWindow particular
	// interest include:
	// void GetViewStart(int* x, int* y) const. Gets the position at which the
	//		visible portion of the window starts. x receives the first visible x
	//		position in scroll units, y receives the first visible y position in
	//		scroll units. If either of the scrollbars is not at the home position
	//		x and/or y will be greater than zero. Combined with wxWindow::GetClientSize
	//		the application can use this function to efficiently redraw only the
	//		visible portion of the window. The positions are in logical scroll units
	//		not pixels, so to convert to pixels you multiply by the number of
	//		pixels per scroll increment.
	// void GetVirtualSize(int* x, int* y) const. Gets the size in device units of
	//		the scrollable window area (as opposed to the client size, which is the
	//		area of the window currently visible). Parameter x receives the length
	//		of the scrollable window, in pixels. Parameter y receives the height of
	//		the scrollable window, in pixels. Use wxDC::DeviceToLogicalX and
	//		wxDC::DeviceToLogicalY to translate these units to logical units.
	// void Scroll(int x, int y). Scrolls a window so the view start is at the
	//		given point. Parameter x is the x position to scroll to, in scroll units.
	//		Parameter y is the y position to scroll to, in scroll units. The
	//		positions are in scroll units, not pixels, so to convert to pixels
	//		you have to multiply by the number of pixels per scroll increment.
	//		If either parameter is -1, that position will be ignored (no change
	//		in that direction).
	// void SetScrollbars(int pixelsPerUnitX, int pixelsPerUnitY, int noUnitsX,
	//		int noUnitsY, int xPos = 0, int yPos = 0, bool noRefresh = FALSE)
	//		Sets up vertical and/or horizontal scrollbars. Parameters are:
	//		pixelsPerUnitX - pixels per scroll unit in the horizontal direction.
	//		pixelsPerUnitY - pixels per scroll unit in the vertical direction.
	//		noUnitsX - number of units in the horizontal direction.
	//		noUnitsY - number of units in the vertical direction.
	//		xPos - position to initialize the scrollbars in the horizontal
	//			direction, in scroll units.
	//		yPos - Position to initialize the scrollbars in the vertical
	//			direction, in scroll units.
	//		noRefresh - will not refresh window if TRUE.
	//		Remarks: The first pair of parameters give the number of pixels
	//		per 'scroll step', i.e. amount moved when the up or down scroll
	//		arrows are pressed. The second pair gives the length of scrollbar
	//		in scroll steps, which sets the size of the virtual window.
	//		xPos and yPos optionally specify a position to scroll to immediately.
	//		For example, the following gives a window horizontal and vertical
	//		scrollbars with 20 pixels per scroll step, and a size of 50 steps
	//		(1000 pixels) in each direction: window->SetScrollbars(20, 20, 50, 50);
	//		wxScrolledWindow manages the page size itself, using the current
	//		client window size as the page size. Note that for more sophisticated
	//		scrolling applications, for example where scroll steps may be variable
	//		according to the position in the document, it will be necessary to
	//		derive a new class from wxWindow, overriding OnSize and adjusting
	//		the scrollbars appropriately. See also wxWindow::SetVirtualSize
	// void SetScrollRate(int xstep, int ystep).
	//		Set the horizontal and vertical scrolling increment only. See the
	//		pixelsPerUnit parameter in SetScrollbars.
	// wxWindow also has void SetVirtualSize(const wxSize& size), which sets the
	//		virtual size of the window in pixels (i.e., wxMM_TEXT).
	//      SetVirtualSize() is used within the wx app in the following functions:
	//      OnOpenDocument(), OnInitialUpdate() and RecalcLayout().

	//
	// wxWidgets' mapping modes can be one of the following:
	// wxMM_TWIPS		Each lodical unit is 1/20 of a point, or 1/1440 of an inch (same as MFC's)
	// wxMM_POINTS		Each lodical unit is a point, or 1/72 of an inch (= MM_TWIPS*20)
	// wxMM_METRIC		Each lodical unit is 1 mm (= 10*MFC's MM_LOMETRIC below)
	// wxMM_LOMETRIC	Each lodical unit is 1/10 of a mm (same as MFC's MM_LOMETRIC below)
	// wxMM_TEXT		Each lodical unit is 1 pixel (same as MFC's)

	// MFC Docs say of SetScrollSizes: "Call SetScrollSizes when the view is about
	// to be updated. First parameter is the mapping mode to set for this view,
	// where: First paramater can be:
	//		MM_TEXT, one Logical Unit = 1 pizel and positive y-axis extends downward.
	//		MM_HIMETRIC, one Logical Unit = 0.01mm, y-axis extends upward
	//		MM_TWIPS, one Logical Unit = 1/1440 inch, y-axis extends upward
	//		MM_HIENGLISH, one Logical Unit = 0.001 inch, y-axis extends upward
	//		MM_LOWMETRIC, one Logical Unit = 0.1 mm, y-axis extends upward
	//		MM_LOENGLISH, one Logical Unit = 0.01 inch, y-axis extends upward
	// Second parameter is the total size of the scroll view. The cx member contains
	// the horizontal extent. The cy member contains the vertical extent, and sizes
	// are in logical units. Both cx and cy must be >= 0. Call it in your override
	// of the OnUpdate member function to adjust scrolling characteristics when,
	// for example, the document is initially displayed or when it changes size.
	// You will typically obtain size information from the view's associated
	// document by calling a document member function, perhaps called GetMyDocSize,
	// that you supply with your derived document class.

	pApp->GetMainFrame()->canvas->SetVirtualSize(pApp->m_docSize);

	// refactored version:
	CLayout* pLayout = pApp->m_pLayout;
	pLayout->InitializeCLayout(); // sets the app, doc, view, canvas & frame pointers,
								  // and clears m_stripArray
	pLayout->SetLayoutParameters(); // calls InitializeCLayout() and UpdateTextHeights()
									// and other setters
	pApp->m_targetPhrase = saveText;
	pApp->m_nStartChar = -1;
	pApp->m_nEndChar = -1;
	if (pApp->m_pTargetBox != NULL)
	{
		pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar); // select it all
	}
}

// BEW 26Mar10, no changes needed for support of doc version 5
bool CAdapt_ItView::OnCreate(wxDocument* doc, long flags) // a virtual method of wxView
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	doc = doc; // avoid "unreferenced formal parameter" warning
	flags = flags; // avoid "unreferenced formal parameter" warning
	pCanvasFrame = pApp->GetMainFrame();
	canvas = pApp->GetMainFrame()->canvas;
	canvas->pView = this;	// make the view pointer owned by MainFrame's canvas
							// point to the current view
    pCanvasFrame->SetTitle(_T("Adapt It"));
	SetFrame(pCanvasFrame);

#ifdef __X__
    // X seems to require a forced resize
    int x, y;
    pCanvasFrame->GetSize(&x, &y);
    pCanvasFrame->SetSize(-1, -1, x, y);
#endif

	// Create the target box using custom constructor
	// WX Note: Our TargetBox is now a child of the view's canvas (which
	// itself is derived from wxScrolledWindow. As a child of the canvas
	// window, m_pTargetBox will be automatically destroyed when pView->canvas
	// is destroyed during doc/view's normal cleanup. That is, when our View is
	// destroyed, all child windows (including our target box) are automatically
	// destroyed too. Therefore, the target box must not be deleted again in
	// the App's OnExit() method, when the App terminates.

	pApp->m_pTargetBox = new CPhraseBox(pApp->GetMainFrame()->canvas, -1,_T(""),
			wxDefaultPosition,wxDefaultSize,
			wxSIMPLE_BORDER | wxWANTS_CHARS);

	// whm Notes on the wxTextCtrl style flags:
	// wxSIMPLE_BORDER - Displays a thin border around the window.
	// wxWANTS_CHARS - According to the wx docs Use this to indicate that
	// the window wants to get all char/key events for all keys - even for keys like
	// TAB or ENTER which are usually used for dialog navigation and which wouldn't
	// be generated without this style. If you need to use this style in order to
	// get the arrows or etc., but would still like to have normal keyboard navigation
	// take place, you should create and send a wxNavigationKeyEvent in response to
	// the key events for Tab and Shift-Tab.
	// wxTAB_TRAVERSAL - Use this to enable tab traversal for non-dialog windows
	// (not needed for phrasebox).
	pApp->m_pTargetBox->ChangeValue(_T(""));
	// hide and disable the target box until input is expected
	pApp->m_pTargetBox->Hide();
	pApp->m_pTargetBox->Enable(FALSE);

	// Old note: Since wxView's OnUpdate() doesn't seem to be automatically
	// called at the point that the View is created we'll try calling
	// it here in the View's OnCreate() method just before the View's
	// pCanvasFrame is shown.
	// New note: wxView does have a virtual OnUpdate() method. So rather
	// than calling our own OnInitialUpdate() here, I tired to override
	// wxView's OnUpdate() to call OnInitialUpdate only once when our view
	// is first created, but that had problems.
	OnUpdate(NULL,NULL);
    Activate(TRUE);

	// see docview sample view.cpp for code on how to set up the edit menu
	// Undo and Redo items using doc->GetCommandProcessor() here

	if (pApp->m_bControlIsWithinOnInit)
	{
		return TRUE; // exit because in OnInit() no project etc is as yet defined
	}
	// whm 28Aug11 Note: I find any scenario within the version 6.x.x of Adapt It
	// that the remainder of this function ever executes. The only time I've found
	// that it is called is when the call in the App's OnInit() is made as follows:
	//   wxCommandEvent event = wxID_NEW;
	//   OnFileNew(event);
	// which I believe was a hack to get the doc-view black box to work as
	// it did in MFC to ensure that a document class and a view class pointer
	// got created early on in the application startup process, and getting the
	// canvas set into the main frame. At any rate, I am implementing the
	// CreateAndLoadKBs() function to take the place of the KB creation and
	// loading code that was added to OnCreate() (by Bruce I think) at some time
	// subsequently. I doubt if execution control ever gets beyond the
	// if (pApp-m_bControlIsWithinOnInit) test above, but if it ever does, and
	// we still need to create and load KBs from here, it will be ready.


	// Note: Because of doc/view framework differences between MFC and WX,
	// a user File | New selection in WX calls CreateDocument, which
	// after calling OnSaveModified, calls OnCloseDocument which in
	// turn calls EraseKB on the adapting and glossing KBs. Hence, we
	// need to reinitialize our KBs here, since immediately after this
	// OnCreate() method finishes, OnNewDocument() will be called and
	// the KB structures need to be reinitialized before OnNewDocument
	// can succeed.

    // we have the desired directory structures. Now we need to get a KB
    // initialized and stored in the languages-specific folder. Ditto for the glossing
    // KB (version 2)

	// BEW changed 1Aug09, because the code was using the old binary filenames *.KB
	// etc, and so creating a new adaptation document using the File / New command was
	// not finding the KB on disk, creating a new empty one and saving it, thereby
	// clobbering the disk's good KB file. So I removed the wrong code and instead
	// called SetupKBPaths() which, for the wx version, sets up the correct normal and
	// alternate path names, file names, and backup paths and filenames.
	pApp->SetupKBPathsEtc();

	// whm revised 28Aug11 to use the CreateAndLoadKBs() function below instead
	// of the previous code (see commented out code below) that created and loaded
	// the KBs.
	// The CreateAndLoadKBs() is called from here as well as from the the App's
	// SetupDirectories(), the CollabUtilities' HookUpToExistingAIProject() and
	// the ProjectPage::OnWizardPageChanging().
	//
	// open the two knowledge bases and load their contents;
	if (!pApp->CreateAndLoadKBs())
	{
		// deal with failures here
		return TRUE; // whm Note: Or should this be FALSE? Probably doesn't matter
					// since this code doesn't seem to ever be executed other than
					// when m_bControlIsWithinOnInit is TRUE (see above)
	}

	// BEW added 13Nov09: give the local user ownership for writing, or deny it if
	// somehow someone else has gotten ownership of the project folder already
	if (!pApp->m_curProjectPath.IsEmpty())
	{
		// whm added 7Mar12 code for fictitious read only access. If the m_bFictitiousReadOnlyAccess
		// flag is set, ForceFictitiousReadOnlyProtection() should be called before the call to
		// SetReadOnlyProtection().
		if (pApp->m_bFictitiousReadOnlyAccess)
		{
			pApp->m_pROP->ForceFictitiousReadOnlyProtection(pApp->m_curProjectPath);
		}

		// Attempt to set it only if not already set...
		//if (!pApp->m_bReadOnlyAccess)
		pApp->m_bReadOnlyAccess = pApp->m_pROP->SetReadOnlyProtection(pApp->m_curProjectPath);
	}

	/* // whm Note: I'm leaving this code here in case Bruce wants to compare it with
	   // what's in the CreateAndLoadKBs() function call above. I don't think the
	   // issue he raised in his 24Aug10 note would apply any more.

	if (::wxFileExists(pApp->m_curKBPath)) //if (cFile.GetStatus(m_curKBPath,status))
	{
		// there is an existing .KB file, so we need to create a CKB instance in
		// memory, open the .KB file on disk, and fill the memory instance's members

		// BEW 23Aug10, replaced the wxASSERT() here because it is possible to get to
		// here with a non-NULL m_pKB and m_pGlossingKB, in which case the asserts
		// trip, and if omitted we'd leak the KB and GlossingKB memory when they are
		// created here anew on the heap. So, we test for non-null pointers, and if
		// true, then we make sure the in-memory ones are deleted before continuing.
		// The sequence of operations which exposed this bug were:
        // 1. User navigation protection was on (5 loadable files in __SOURCE_INPUTS, four
        // of which had had docs made from them (though that was irrelevant) and one
        // was there for listed. When the NavProtectNewDoc() handler's dialog shows, I
        // clicked Cancel.
		// 2. File / New..., double-clicked the loadable source text filename.
		// 3. When "Type a name..." dialog shows, I Cancelled.
        // 4. File / New... again and got the crash here when the wxASSERT() was
        // tripped. (Very possibly the same error would happen with the legacy Open
        // File... dialog, if the same sequence of Cancel, New, double-click, Cancel,
        // New was done. But I didn't test, as the fix here would take care of that as
        // well.)
		//
		// BEW 24Aug10, the above turns out to be a problem in the wxWidgets black box
		// if the Cancel option is taken within OnNewDocument() - whether nav
		// protection is on or not; our event handlers don't get called. No idea why,
		// but the EraseKB() here will prevent the crash. It's not a full solution
		// though, because the toolbar icon buttons for New and particularly for Open
		// will then still not work right, nor will File / New... or File / Open...;
		// so I need to try fix the Cancel problem at its source.
		// Later on 24Aug10 - the problem was caused by returning FALSE from a
		// OnNewDocument() - this clobbers things (I don't know what) which the
		// doc/view support relies on; the solution was to return TRUE from
		// OnNewDocument() whether cancelling or not. That fixed everything, and the
		// New and Open icon buttons on the toolbar now work right in all circumstances.
		//wxASSERT(pApp->m_pKB == NULL);
		if (pApp->m_pKB != NULL)
		{
			// protect from a crash -- strictly speaking this block should never now
			// be entered due to the 24Aug10 fix discussed above, but it can be left
			// here as a safety measure
			pApp->GetDocument()->EraseKB(pApp->m_pKB);
		}

		pApp->m_pKB = new CKB(FALSE);
		wxASSERT(pApp->m_pKB != NULL);

		// whm Note: LoadKB() has its own wxProgressDialog
		bool bOK = pApp->LoadKB(TRUE); // show the progress dialog
		if (bOK)
		{
			pApp->m_bKBReady = TRUE;
			pApp->LoadGuesser(pApp->m_pKB); // whm added 29Oct10

			// now do it for the glossing KB
			// BEW 23Aug10 removed wxASSERT() - see reason in comment above of same date
			//wxASSERT(pApp->m_pGlossingKB == NULL);
			if (pApp->m_pGlossingKB != NULL  || pApp->m_bGlossingKBReady)
			{
				// protect from a crash -- strictly speaking this block should never now
				// be entered due to the 24Aug10 fix discussed above, but it can be left
				// here as a safety measure
				pApp->GetDocument()->EraseKB(pApp->m_pGlossingKB);
			}

			pApp->m_pGlossingKB = new CKB(TRUE);
			wxASSERT(pApp->m_pGlossingKB != NULL);
			bOK = pApp->LoadGlossingKB(TRUE); // show the glossing KB's progress dialog
			if (bOK)
			{
				pApp->m_bGlossingKBReady = TRUE;
				pApp->LoadGuesser(pApp->m_pGlossingKB); // whm added 29Oct10
			}
			else
			{
				wxMessageBox(_(
"Error: loading the glossing knowledge base failed. The application will now close."),_T(""),
				wxICON_ERROR | wxOK);
				wxASSERT(FALSE);
				wxExit();
			}
		}
		else
		{
			wxMessageBox(_(
		"Error: loading a knowledge base failed. The application will now close."),
			_T(""), wxICON_ERROR | wxOK);
			wxASSERT(FALSE);
			wxExit();
		}
	}
	else
	{
        // the KB file does not exist, so make sure there is an initialized CKB
        // instance on the application ready to receive data, and save it to disk. for
        // version 2, do the same for the glossing KB
		wxASSERT(pApp->m_pKB == NULL);
		pApp->m_pKB = new CKB(FALSE);
		wxASSERT(pApp->m_pKB != NULL);

		// store the language names in it
		pApp->m_pKB->m_sourceLanguageName = pApp->m_sourceName;
		pApp->m_pKB->m_targetLanguageName = pApp->m_targetName;

		bool bOK = pApp->StoreKB(FALSE); // first time, so we can't make a backup
		if (bOK)
		{
			pApp->m_bKBReady = TRUE;

			// now do the same for the glossing KB
			wxASSERT(pApp->m_pGlossingKB == NULL);
			pApp->m_pGlossingKB = new CKB(TRUE);
			wxASSERT(pApp->m_pGlossingKB != NULL);

			bOK = pApp->StoreGlossingKB(FALSE); // first time, so we can't make a backup
			if (bOK)
			{
				pApp->m_bGlossingKBReady = TRUE;
			}
			else
			{
				// IDS_STORE_GLOSSINGKB_FAILURE
				wxMessageBox(_(
"Error: storing the glossing knowledge base to disk for the first time failed. The application will now close."),
				_T(""), wxICON_ERROR | wxOK); // something went wrong
				wxASSERT(FALSE);
				wxExit();
			}
		}
		else
		{
			// IDS_STORE_KB_FAILURE
			wxMessageBox(_(
"Error: saving the knowledge base failed. The application will now close."),
			_T(""), wxICON_ERROR | wxOK); // something went wrong
			wxASSERT(FALSE);
			wxExit();
		}

		// BEW added 13Nov09: give the local user ownership for writing, or deny it if
		// somehow someone else has gotten ownership of the project folder already
		if (!pApp->m_curProjectPath.IsEmpty())
		{
			// Attempt to set it only if not already set...
			//if (!pApp->m_bReadOnlyAccess)
			pApp->m_bReadOnlyAccess = pApp->m_pROP->SetReadOnlyProtection(pApp->m_curProjectPath);
		}
	}
	*/
    return TRUE;
}

int CAdapt_ItView::RecalcPhraseBoxWidth(wxString& phrase)
{
    // a sudden change in the m_targetPhrase's length (eg. due to a paste into the phrase
    // box) and a subsequent RecalcLayout() call, would not allow the box to be smaller
    // than its previous value; so RecalcPhraseBoxWidth() can be called wherever the
    // potential for a resizing of the box is called for
	CAdapt_ItApp* pApp = &wxGetApp();
	wxClientDC dc(pApp->GetMainFrame()->canvas);
	wxClientDC* pDC = &dc;
	int pileWidth;
	int dummyHeight;
	wxFont SaveFont;
	wxFont* pTheFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pTheFont = pApp->m_pNavTextFont;
	else
		pTheFont = pApp->m_pTargetFont;
	SaveFont = dc.GetFont();
	pDC->SetFont(*pTheFont);
	pDC->GetTextExtent(phrase,&pileWidth, &dummyHeight);
	wxString aChar = _T('w');
	int charWidth;
	int charDummyHeight;
	pDC->GetTextExtent(aChar,&charWidth,&charDummyHeight);
	pileWidth += gnExpandBox*charWidth; // allow same slop factor as for
										// RemakePhraseBox & OnChar
	dc.SetFont(SaveFont); // restore original font, don't need wxClientDC any more
	return pileWidth;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pPile        -> the m_pActivePile where the phrasebox is located when paste
///                             command is invoked
/// \remarks
/// Called from the View's OnEditPaste().
/// DoTargetBoxPaste() is generally only called when the user pastes something from the
/// clipboard into the phrase box. DoTargetBoxPaste() applies any necessary modifications as
/// the result of Consistent Changes (if m_bUseConsistentChanges is TRUE) or any modifications
/// made by SIL Converters (if m_bUseSilConverter is TRUE) or any modifications made by the
/// Guesser (if m_bUseAdaptationsGuesser is TRUE) before inserting the string to the
/// m_targetPhrase. The Guesser cannot be used if the SIL Converters is being used.
/// Also, the Guesser can be used only if Consistent Changes is not being used
/// OR if it is being used AND m_bAllowGuesseronUnchangedCCOutput was set to true by the
/// administrator checking the appropriate checkbox in the GuesserSettingsDlg.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::DoTargetBoxPaste(CPile* pPile)
{
	// Modified to handle glossing or adapting
	// whm modified 29Oct10 to handle Guessing
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	gbByCopyOnly = FALSE; // set this flag FALSE, so text put in the box won't
            // be thrown away if user subsequently clicks to place box elsewhere
            // without doing anything in the phrase box first
	wxString pasteStr;

	// In wx we'll use the clipboard GetData function directly
	if (wxTheClipboard->Open())
	{
		if (wxTheClipboard->IsSupported( wxDF_TEXT ))
		{
			wxTextDataObject data;
			wxTheClipboard->GetData( data );
			pasteStr = data.GetText();
		}
		wxTheClipboard->Close();
	}

    // if consistent changes is turned on, the user must be given the option of having the
    // changes applied or not applied, since we cannot assume that the text to be pasted
    // was not copied from source text (if it was, the changes should be applied)
	wxString insertionText = pasteStr;
	wxASSERT( !(pApp->m_bUseConsistentChanges && pApp->m_bUseSilConverter) ); // not both TRUE
	if (pApp->m_bUseConsistentChanges)
    {
		//IDS_ASK_USE_CC
        if( wxMessageBox(_(
"Do you wish consistent changes to be applied to the text to be pasted?"),
		_T(""), wxICON_QUESTION | wxYES_NO | wxYES_DEFAULT) == wxYES )
		{
			insertionText = DoConsistentChanges(pasteStr);
		}
    }
    else if( pApp->m_bUseSilConverter )
    {
		// IDS_ASK_USE_SILCONVERTER
        if( wxMessageBox(_(
"Do you wish the configured SILConverter to be applied to the text to be pasted?"),
		_T(""), wxICON_QUESTION | wxYES_NO | wxYES_DEFAULT) == wxYES )
	    {
		    insertionText = DoSilConvert(pasteStr);
	    }
    }

	bool bIsGuess = FALSE;
	if (pApp->m_bUseAdaptationsGuesser && !pApp->m_bUseSilConverter)
	{
		// The Guesser cannot be used if the SIL Converters is being used.
		// Also, the Guesser can be used only if Consistent Changes is not being used
		// OR if it is being used AND m_bAllowGuesseronUnchangedCCOutput
		// was set to true by the administrator checking the appropriate checkbox
		// in the GuesserSettingsDlg.
		if (!pApp->m_bUseConsistentChanges || (pApp->m_bUseConsistentChanges && pApp->m_bAllowGuesseronUnchangedCCOutput))
		{
			// We don't need to query the user in this case because the
			// m_bAllowGuesseronUnchangedCCOutput flag would have been changed
			// explicitly by the administrator ticking the checkbox in the
			// GuesserSettingsDlg.
			insertionText = DoGuess(pasteStr,bIsGuess);
			pApp->m_bIsGuess = bIsGuess;
		}
	}

    // if there is a text selection in the current targetBox, erase the selected chars,
    // then get its text and the caret offset - this is where pasteStr must be inserted wx
    // Note: MFC's CEdit::Clear() deletes (clears) the current selection (if any) in the
    // edit control. wxTextCtrl::Clear() "clears the text in the control, and generates a
    // wxEVT_COMMAND_TEXT_UPDATED event." I'll first check for any existing selection by
    // calling GetStringSelection. If GetStringSelection isn't empty we know there is a
    // selection. If so, then use wxTextCtrl's Remove() method to only remove the
    // selection.
	long nS, nE;
	if (!pApp->m_pTargetBox->GetStringSelection().IsEmpty()) // whm added to
												// only Remove any selected text
	{
		pApp->m_pTargetBox->GetSelection(&nS,&nE);
		pApp->m_pTargetBox->Remove(nS,nE); //m_targetBox.Clear();
	}
	long nStart; long nEnd;
	pApp->m_pTargetBox->GetSelection(&nStart,&nEnd);
	wxString targetPhrase;
	targetPhrase = pApp->m_pTargetBox->GetValue();
	wxString saveStr = targetPhrase; // make a copy in case we later have to abort
									 // the operation

	// BEW added 18July08, to support leaving cursor at paste location
	// (see Roland Fumey request below)
	int pasteStrLength = insertionText.Length();

    // insert the insertionText into the targetStr at the desired location wxString doesn't
    // have an Insert method, so we'll do it with our own InsertInString (see helpers.h)
	targetPhrase = InsertInString(targetPhrase,(int)nStart,insertionText);

    // We have to recreate the box after measuring the text, because the existing box is
    // almost certainly too small and it will reject any characters it cannot fit in. Note,
    // this code would fail if we try to paste too much text, so we accept the text for
    // pasting only if its extent fits within a strip's width - if not, clear the text &
    // give a warning message, but allow any merge.

	// use the targetPhrase text only if the resulting phrase box can fit within a single strip
	int width = RecalcPhraseBoxWidth(targetPhrase);
	CStrip* pStrip = pPile->GetStrip();
	int stripWidth = pStrip->Width();
	wxASSERT(stripWidth > 0);
	if (width >= stripWidth)
	{
		// it won't fit within a strip, so try to get out of this fix gracefully
		pApp->m_targetPhrase = saveStr; // restore original text back into m_targetPhrase
		// IDS_PASTE_TEXT_TOO_LONG
		wxMessageBox(_(
"Sorry, the paste operation resulted in text which exceeded the maximum width of a strip, so the operation was aborted."),
		_T(""),wxICON_EXCLAMATION | wxOK); // warn user
	}
	else
	{
		pApp->m_targetPhrase = targetPhrase; // put the composite text into m_targetPhrase
	}

    // if there was a selection in line 1, we will honour the assumed intent to merge
    // first, and then the pasted stuff will be assumed to be its adaptation; however, if
    // the selection is too long, we will just remove it (not do Retranslation instead as
    // in OnChar) Do the next block only if glossing is OFF, if it is on, we don't allow a
    // merge and so proceed to the 'else' block
	int nSaveActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber;
	if (!gbIsGlossing && pApp->m_selection.GetCount() > 1 &&
		pApp->m_selection.GetCount() <= MAX_WORDS &&
		pApp->m_pActivePile == pApp->m_pAnchor->GetPile())
	{
        // if we selected backwards, we have to be careful - we want nSaveActiveSequNum to
        // be first pile of the selection, so check it out now & if necessary adjust
        // nSaveActiveSequNum
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = (CCell*)cpos->GetData();
		wxASSERT(pCell != NULL);
		CPile* pFirstPile = pCell->GetPile();
		int nFirstSequNum = pFirstPile->GetSrcPhrase()->m_nSequNumber;
		if (nFirstSequNum < nSaveActiveSequNum)
			nSaveActiveSequNum = nFirstSequNum;

		// do the merge
		bSuppressDefaultAdaptation = TRUE; // the global BOOLEAN for temporary
										   // suppression only
		MergeWords();
		bSuppressDefaultAdaptation = FALSE;

		// restore the active pile pointers
		pPile = GetPile(nSaveActiveSequNum);
		pApp->m_pActivePile = pPile;
	}

	// remove any existing selection, it would be a confusion if left there
	RemoveSelection();

	// setup the phrase box at the same location, but with new size (probably)
	CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
	wxASSERT(pSrcPhrase != NULL);
	pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
	wxASSERT(pApp->m_nActiveSequNum >= 0);

	gnBoxCursorOffset = nStart + pasteStrLength;

	// make the layout adjustments get done and then the draw and showing of the
	// relocated phrase box
	Invalidate();
	GetLayout()->PlaceBox();
}

CSourcePhrase* CAdapt_ItView::GetSrcPhrase(int nSequNum)
{
	// refactored, no change needed (18Mar09)
	// does the same job as Jonathan's GetSourcePhraseByIndex(int index)
	// defined in CAdapt_ItApp
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList);
	int nCount;
	nCount = pList->GetCount();
	wxASSERT(nCount != 0);
	nCount = nCount; // avoid warning TODO: test for failure?
	SPList::Node* pos = pList->Item(nSequNum);
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase);
	return pSrcPhrase;
}

// return the first CSourcePhrase instance after the nStartingSequNum in m_pSourcePhrases
// list, which has an empty m_adaption member, or NULL if no such instance can be found;
// this searches in the list of stored source phrases, so it will search to the very end of
// the doc if necessary For version 2.0 and onwards, test gbIsGlossing and branch
// accordingly.
CSourcePhrase* CAdapt_ItView::GetNextEmptySrcPhrase(int nStartingSequNum)
{
	// refactored 18Mar09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pApp->m_pSourcePhrases->Item(nStartingSequNum);
	do
	{
		pos = pos->GetNext();
		if (pos == NULL)
			return (CSourcePhrase*)NULL; // we have gone past end of document
		pSrcPhrase = pos->GetData();
		wxASSERT(pSrcPhrase);
		if (gbIsGlossing)
		{
			if (!pSrcPhrase->m_bHasGlossingKBEntry)
				return pSrcPhrase;
		}
		else
		{
			if (!pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB &&
				!pSrcPhrase->m_bRetranslation)
				return pSrcPhrase;
		}
	} while (TRUE);
}

CSourcePhrase* CAdapt_ItView::GetFollSafeSrcPhrase(CSourcePhrase* pSrcPhrase)
{
	// refactored 19Mar09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pSrcPhrase);
	int sn = pSrcPhrase->m_nSequNumber;
	CSourcePhrase* pSP;
	SPList::Node* pos = pApp->m_pSourcePhrases->Item(sn);
	do
	{
		pos = pos->GetNext();
		if (pos == NULL)
			return (CSourcePhrase*)NULL; // we have gone past end of document
		pSP = pos->GetData();
		wxASSERT(pSP);
	} while (pSP->m_bRetranslation);
	return pSP; // found one where it is okay to have the phrase box put in the view
}

CSourcePhrase* CAdapt_ItView::GetPrevSafeSrcPhrase(CSourcePhrase* pSrcPhrase)
{
	// refactored 19Mar09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pSrcPhrase);
	int sn = pSrcPhrase->m_nSequNumber;
	CSourcePhrase* pSP;
	SPList::Node* pos = pApp->m_pSourcePhrases->Item(sn);
	do
	{
		pos = pos->GetPrevious();
		if (pos == NULL)
			return (CSourcePhrase*)NULL; // we have gone back past start of document
		pSP = pos->GetData();
		wxASSERT(pSP);
	} while (pSP->m_bRetranslation);
	return pSP; // found one where it is okay to have the phrase box put in the view
}

// nSaveActiveSequNum, on input, should be the tentative sequNum value we hope will be a
// valid location but may not be; and nActiveSequNum, on input, should be the current
// active location's sequNum; on output, nSaveActiveSequNum will be a different value if
// the input value landed the box in a retranslation... pSrcPhrases is the list on the app,
// nSaveActiveSequNum - this could be too large since we try place the active location
// after the retranslation and that might be beyond the end of the document, hence the need
// to try find a safe place somewhere (its passed by reference because we want the caller's
// variable of the same name to be automatically updated too); nActiveSequNum is a ref to
// the App's m_nActiveSequNum and we will set it from here; nFinish is the final number of
// piles in the retranslation after all adjustments have been done.
// BEW 22Feb10 no changes needed for support of doc version 5
bool CAdapt_ItView::SetActivePilePointerSafely(CAdapt_ItApp* pApp,
		SPList* pSrcPhrases,int& nSaveActiveSequNum,int& nActiveSequNum,int nFinish)
{
	// refactored 19Mar09
	if (nSaveActiveSequNum >= (int)pSrcPhrases->GetCount())
	{
		// need to put active location before the retranslation
		int sequNum = nSaveActiveSequNum - nFinish;
		bool bAtStart = FALSE; // if we get to doc start, put it there no matter what
		CSourcePhrase* pSP;
		do
		{
			--sequNum;
			if (sequNum == 0)
			{
				bAtStart = TRUE;
				break;
			}
			SPList::Node* pos = pSrcPhrases->Item(sequNum);
			pSP = (CSourcePhrase*)pos->GetData();
			wxASSERT(pSP != NULL);
		} while (pSP->m_bRetranslation || pSP->m_bNotInKB);
		if (bAtStart)
			nSaveActiveSequNum = 0;
		else
			nSaveActiveSequNum = sequNum; // new value
		pApp->m_pActivePile = GetPile(nSaveActiveSequNum);
	}
	else
	{
		pApp->m_pActivePile = GetPile(nSaveActiveSequNum);

        // this could be a pile containing a retranslation, so check it out, and if so,
        // advance until we find a safe location, and if that process reaches the end of
        // the document without finding a safe location, then go backwards instead until we
        // find one - one of these processes will definitely succeed.
		CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		if (pSrcPhrase->m_bRetranslation)
		{
			// a retranslation is not a valid phrase box location,
			// so hunt for a safe place nearby
			CSourcePhrase* pSaveSP = pSrcPhrase;
			pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);

			if (pSrcPhrase == NULL)
			{
                // reached end of source phrase list without finding a safe place, so look
                // in the opposite direction - this (almost certainly) MUST succeed - it
                // could only fail if the previous active location was in the selection and
                // the selection comprised all of the srcPhrases which are not already in a
                // retranslation, and the whole doc is now a series of consecutive
                // retranslations (most unlikely!)
				pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSP);

				if (pSrcPhrase == NULL)
				{
					// nowhere is a safe location! (Is the user retranslating everything? !!!)
					// so our only option is to go to the end & put it there no matter what
					int lastSequNum = (int)pSrcPhrases->GetCount()- 1;
					CPile* pPile = GetPile(lastSequNum);
					pApp->m_targetPhrase.Empty();
					nActiveSequNum = lastSequNum;
					pApp->m_pTargetBox->ChangeValue(_T(""));
					pApp->m_targetPhrase = pPile->GetSrcPhrase()->m_adaption;
					pApp->m_pActivePile = pPile;
					pApp->m_pRetranslation->SetSuppressRemovalOfRefString(FALSE); // ensure it's turned back off
					return FALSE; // Note: of 9 calls in the app, only 2 actually use this returned
					// FALSE VALUE - once in OnButtonRetranslation() and the other in
					// OnButtonEditRetranslation - where they, in the legacy version, caused a
					// warning message to show and the function exited early; in the refactored
					// version the return call after the message is commented out, so the function
					// proceeds normally and the message still shows and the phrase box is put at
					// the document end, visible.
				}
			}
		}

		// jump to whatever pile is not in a retranslation, as close to wanted loc'n as possible
		nSaveActiveSequNum = pSrcPhrase->m_nSequNumber;
		gnOldSequNum = nSaveActiveSequNum; // the only safe option, since old location may now
										   // be within the retranslation
		Jump(pApp,pSrcPhrase);
	}
	nActiveSequNum = nSaveActiveSequNum; // ensure value of pApp->m_nActiveSequNum agrees with any
										 // adjustments
	pApp->m_pRetranslation->SetSuppressRemovalOfRefString(FALSE); // ensure it's turned back off
	return TRUE;
}

// returns a pointer to the next pile having no target language (adapted) string, or NULL
// if there is no such empty pile later in the document
// for version 2.0 and on, the check is done on m_glossing instead, when glossing is ON
CPile* CAdapt_ItView::GetNextEmptyPile(CPile *pPile)
{
	// refactored 23Mar09
	if (gbIsGlossing)
	{
		do
		{
			pPile = GetNextPile(pPile);
			if (pPile == NULL)
				break;
		} while (pPile->GetSrcPhrase()->m_bHasGlossingKBEntry);
	}
	else // currently adapting
	{
		do
		{
			pPile = GetNextPile(pPile);
			if (pPile == NULL)
				break;
		} while (pPile->GetSrcPhrase()->m_bHasKBEntry ||
					pPile->GetSrcPhrase()->m_bNotInKB);
	}
	return pPile;
}

void CAdapt_ItView::GetVisibleStrips(int& nFirstStrip,int&nLastStrip)
// nFirstStrip = index of first strip visible (or partly visible) in the view
// nLast Strip = index of last strip visible (or partly visible) in the view
{
	// refactored 1Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CLayout* pLayout = GetLayout();
	wxClientDC dc(pLayout->m_pCanvas);
	canvas->DoPrepareDC(dc); // adjust origin

	// find the index of the first strip which is visible
	wxRect rectStrip;
	int nTotalStrips = pLayout->GetStripArray()->GetCount();
	wxRect rectClient;
    // wx note: calling GetClientSize on the canvas produced different results in wxGTK and
    // wxMSW, so I'll use my own GetCanvasClientSize() which calculates it from the main
    // frame's client size.
	wxSize canvasViewSize;
	canvasViewSize = pApp->GetMainFrame()->GetCanvasClientSize();

//#ifdef _DEBUG
//	// Here's sample code for alternative 1:
//	// save a copy of the initial grectViewClient values for use below (alternative 2 changes grectViewClient)
//	wxRect testRectViewClient = rectClient;
//#endif

	//int xScrollUnits, yScrollUnits, xOrigin, yOrigin;
	//pApp->GetMainFrame()->canvas->GetViewStart(&xOrigin, &yOrigin); // gets xOrigin and yOrigin in scroll units
	//pApp->GetMainFrame()->canvas->GetScrollPixelsPerUnit(&xScrollUnits, &yScrollUnits); // gets pixels per scroll unit
	//rectClient.x = xOrigin * xScrollUnits; // number pixels is ScrollUnits * pixelsPerScrollUnit
	//rectClient.y = yOrigin * yScrollUnits;

//#ifdef _DEBUG
//	//wx version uses CalcUnscrolledPosition
//	int newXPos,newYPos;
//	pApp->GetMainFrame()->canvas->CalcUnscrolledPosition(0,0,&newXPos,&newYPos);
//	wxASSERT(newXPos == rectClient.x); //rectClient.x = newXPos; // stays zero since we dont' have horizontal scrolling
//	wxASSERT(newYPos == rectClient.y); //rectClient.y = newYPos;
//#endif

//#ifdef _DEBUG
//	//dc.DPtoLP(&rectClient); // this is like the MFC method
//	int x = dc.DeviceToLogicalX(testRectViewClient.x);// get the device X (width) coord converted to logical coord
//	int y = dc.DeviceToLogicalY(testRectViewClient.y); // get the device Y (height) coord converted to logical coord
//	wxASSERT(x == rectClient.x);
//	wxASSERT(y == rectClient.y);
//#endif

	wxArrayPtrVoid* pStripArray = pLayout->GetStripArray();
	CStrip* pStrip = NULL;
	pLayout->m_pCanvas->CalcUnscrolledPosition(0,0,&rectClient.x,&rectClient.y);
	rectClient.width = canvasViewSize.x;
	rectClient.height = canvasViewSize.y;
	wxPoint ptStripBottomRight;
	wxPoint ptStripTopLeft;
	int i;
	for (i = 0; i < nTotalStrips; i++)
	{
		pStrip = (CStrip*)(*pStripArray)[i];
		pStrip->GetStripRect_CellsOnly(rectStrip);
		ptStripBottomRight.x = rectStrip.GetRight();
		ptStripBottomRight.y = rectStrip.GetBottom();

		if (ptStripBottomRight.y > rectClient.GetTop())
		{
			// this strip is at least partly visible
			nFirstStrip = pStrip->GetStripIndex(); // Hmmm, Bill could have just said
											// nFirstStrip = i; here for the same result
			break;
		}
	}

	int j;
	for (j = i + 1; j < nTotalStrips; j++)
	{
		pStrip = (CStrip*)(*pStripArray)[j];
		pStrip->GetStripRect_CellsOnly(rectStrip);

		ptStripTopLeft.x = rectStrip.GetLeft(); // get TopLeft in 2 steps
		ptStripTopLeft.y = rectStrip.GetTop();
		if (ptStripTopLeft.y >= rectClient.GetBottom())
		{
			nLastStrip = --j;
			wxASSERT(nLastStrip > nFirstStrip);
			break;
		}
	}
	if (j == nTotalStrips)
	{
		// we got to the end of the document
		nLastStrip = nTotalStrips - 1;
		wxASSERT(nLastStrip > nFirstStrip);
	}
}

// DoGetSuitableText_ForPlacePhraseBox() factors out a whole lot of special cases for
// getting suitable text to put in the phrase box when the box is reconstituted at the new
// location at which the user clicked to relocate the box there - it simplifies the flow of
// code in PlacePhraseBox() for the sake of the human trying to follow what is going on
// here
void CAdapt_ItView::DoGetSuitableText_ForPlacePhraseBox(CAdapt_ItApp* pApp,
		CSourcePhrase* pSrcPhrase, int selector, CPile* pActivePile, wxString& str,
		bool bHasNothing, bool bNoValidText, bool bSomethingIsCopied)
{
	selector = selector; // to avoid a compiler warning
	wxASSERT(pApp);
	bool bGotOne = FALSE;

	if (bHasNothing)
	{
		// there is as yet no translation for this source phrase & no copy from source
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
		gbByCopyOnly = FALSE;
	}
	else
	{
        // This block is for when the current active location has adaptation content (or,
        // in glossing mode, gloss content) -- FALSE for bHasNothing is the default value,
        // so in effect control usually routes through this block unless the caller sets
        // bHasNothing to TRUE explicitly. In fact, the app setting m_bCopySource being set
        // with its default value of TRUE is sufficient to ensure the bHasNothing flag is
        // never set TRUE, regardless of the value of the m_bHasKBEntry and m_bNotInKB
		// flags. It's then the bNoValidText which is significant, and that has to be TRUE
		// (indicative of a "hole") for lookup to take place.
		gbByCopyOnly = FALSE;
		if (bNoValidText)
		{
            // BEW added 20Dec07 to prevent lookup when in Reviewing mode (some further
            // comments & supporting code changes are in the blocks below)
			if (pApp->m_bDrafting)
			{
                // BEW added 16Jul09; return an empty string if we are in free translation
                // mode and the phrase box at the next section has been put at a "hole"
				if (pApp->m_bFreeTranslationMode)
				{
					str.Empty();
					return;
				}
				// it's not free translation mode, so try find something
				bGotOne = pApp->m_pTargetBox->LookAhead(pApp->m_pActivePile);
			}
			else // we are in reviewing mode for the code in next block
			{
				// Reviewing mode, we still need to ensure that if the user cancelled a
				// Choose Translation merge, then pSrcPhrase will be valid before we proceed
				pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

				// ensure clicks to a location which is a hole don't, on leaving, result in
				// punctuation being copied from the source text if present there
				if (pSrcPhrase->m_targetStr.IsEmpty() || pSrcPhrase->m_adaption.IsEmpty())
				{
					// no text or punctuation, or no text and punctuation not yet placed,
					// or no text and punctuation was earlier placed -- whichever is the case
					// we need to preserve that state
					gbSavedTargetStringWithPunctInReviewingMode = TRUE;  // it gets cleared again at
															// end of MakeTargetStringIncludingPunctuation()
					gStrSavedTargetStringWithPunctInReviewingMode = pSrcPhrase->m_targetStr; // cleared
															// at end of MakeTargetStringIncludingPunctuation()
				}

				pApp->m_pTargetBox->m_bAbandonable = FALSE;	// don't throw away unedited
                //phrase box contents when the phrase box leaves a location by a user's
                //click and then make sure we retain the contents in the m_targetStr member
                //of pSrcPhrase, since user is reviewing; but use m_gloss if Glossing mode
                //is on
				if (gbIsGlossing)
					str = pSrcPhrase->m_gloss;
				else
					str = pSrcPhrase->m_targetStr;
			} // end block for reviewing mode

			// in Reviewing mode, bGotOne will always be FALSE when control reaches here and so
			// the next block would not be entered - which is fine because in Reviewing mode
			// there is no need to perform a merge when landing on a new pile
			if (bGotOne)
			{
				if (!gbIsGlossing)// do nix here if glossing is on, since glossing disallows merges
				{
					if (!gbCompletedMergeAndMove) // (true means phrase box moved before Choose
					{							  // Translation dialog can be shown, see LookAhead( )
						// do this only if the flag was not set
						pApp->m_pTargetBox->m_bAbandonable = FALSE;
						if (nWordsInPhrase > 1) // nWordsInPhrase is a global
						{
							// do the needed merge, etc.
							pApp->bLookAheadMerge = TRUE; // set static flag to ON
							MergeWords(); // the Choose Translation dialog might be shown in this call
							pApp->bLookAheadMerge = FALSE; // restore static flag to OFF
						}
					}
				}
                // if user cancelled a Choose Translation merge, then pSrcPhrase will be
                // invalid, so we have to make sure the pointer is valid before we proceed
				pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

                // assign the translation text - but check it's not "<Not In KB>", if it
                // is, we leave the phrase box empty, turn OFF the m_bSaveToKB flag, DON'T
                // halt auto-inserting if it is on, (formerly, I made it halt) from v 1.4.0
                // and onwards, we have to just put default null adaptation there, since a
                // successful lookup of 'not in kb' can't possibly assign any adaptation
                // except null text - unless there already is something on the source
                // phrase - in which case use that
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
                // if we are glossing, then the global variable wxString translation, will
                // have the gloss because a successful lookup was done
				if (!gbIsGlossing)
				{
                    // if adapting, check for a not in kb entry and if it is, then adjust
                    // translation; strictly speaking we only want to clear the string when
                    // in Drafting mode, but in Reviewing mode we want to let whatever was
                    // formerly there continue unchanged, so a test would be appropriate
                    // here if it was not for the fact that above we wrap the LookAhead
                    // call in a test of the m_bDrafting flag, and so in Reviewing mode
                    // bGotOne remains FALSE and so this current block would not be entered
					if (translation == _T("<Not In KB>"))
					{
						pApp->m_bSaveToKB = FALSE;
						pSrcPhrase->m_bHasKBEntry = FALSE; // ensures * shows above this srcPhrase
						pSrcPhrase->m_bNotInKB = TRUE;
						if (pSrcPhrase->m_targetStr.IsEmpty())
						{
							translation.Empty(); // clear the global
							pApp->m_targetPhrase.Empty();
						}
						else
						{
							translation = pSrcPhrase->m_targetStr;
						}
					}
				}
				str = translation; // adapting or glossing, put the final translation into str
			}
		}
		else // there is valid text -- this is typically the case when in Reviewing mode; it
			 // also is the case when the user uses the mouse to click on a non-hole location
			 // -- but we exclude doing anything in the latter situation by an explicit test
			 // within this block for review mode - ie. we test for m_bDrafting is FALSE
		{
            // when in Reviewing mode and the user clicks on existing adaptation or gloss
            // text, no lookup is done because bNoValidText is FALSE, and so control will
            // have jumped to the present block. At this point, str is still empty, and so
            // we need here to ensure that what is at the clicked location is retained, so
            // we set str etc.
			if (!pApp->m_bDrafting) // ensure we really *are* in Reviewing mode for this stuff
			{
				// Reviewing mode, we still need to ensure that if the user cancelled a
				// Choose Translation merge, then pSrcPhrase will be valid before we proceed
				pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

				// ensure clicks to a location which is a hole don't, on leaving, result in
				// punctuation being copied from the source text if present there
				if (pSrcPhrase->m_targetStr.IsEmpty() || pSrcPhrase->m_adaption.IsEmpty())
				{
					// no text or punctuation, or no text and punctuation not yet placed,
					// or no text and punctuation was earlier placed -- whichever is the case
					// we need to preserve that state
					gbSavedTargetStringWithPunctInReviewingMode = TRUE;	// it gets cleared again at end
															// of MakeTargetStringIncludingPunctuation()
					gStrSavedTargetStringWithPunctInReviewingMode = pSrcPhrase->m_targetStr; // cleared at
																// end of MakeTargetStringIncludingPunctuation()
				}
				pApp->m_pTargetBox->m_bAbandonable = FALSE; // don't throw away unedited
                    // phrase box contents when the phrase box leaves a location by a click
                    // and then make sure we retain the contents in the m_targetStr member
                    // of pSrcPhrase, since user is reviewing; but use m_gloss if Glossing
                    // mode is on
				if (gbIsGlossing)
					str = pSrcPhrase->m_gloss;
				else
					str = pSrcPhrase->m_targetStr;
			} // end block for check that we really are in reviewing mode
		}

        // BEW added to the test 02Nov05, so that when the SplitDialog is active, any use
        // of a button in that dialog which results in a PlacePhraseBox being done (eg. by
        // Jump()) will not copy the source text into the phrasebox if the box lands at a
        // hitherto unadapted (or unglossed) location -- so if the document split is then
        // made at that location, it won't save into the KB a spurious copy of the source
        // text as the 'adaptation' at whatever location the box happened to land at. The
        // app setter function SetCurrentSourcePhrase sets and clears the global flag
        // gbIsDocumentSplittingDialogActive to effect this.
		if (!bGotOne && !gbIsDocumentSplittingDialogActive)
		{
            // if user cancelled a Choose Translation merge, then pSrcPhrase will be
            // invalid, so we have to make sure the pointer is valid before we proceed
			pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

            // BEW added test 20Dec07: Reviewing mode must not copy down source text into
            // holes (ie. we assume the holes are there by choice, and we don't want
            // spurious text to fill them, although the user is free to manually type at
            // such locations if he wishes)
			if (pApp->m_bDrafting)
			{
                // lookup did not find a suitable adaptation, or gloss if in glossing mode,
                // so we want a copy from the sourcePhrase done instead - but not when in
                // Reviewing mode
				wxString theText;
				if (gbIsGlossing)
					theText = pSrcPhrase->m_gloss;
				else
					theText = pSrcPhrase->m_adaption;
				if (!theText.IsEmpty()) // we want a punctuation-less test here
				{
					if (gbIsGlossing)
					{
						str = theText;
					}
					else // adapting
					{
						str = pSrcPhrase->m_adaption; // no punctuation to be shown
						// BEW changed 28Apr05, this is a better choice for the box contents
						// than to show punctuation if the m_bHidePunctuation flag is FALSE;
						// always using m_adaption means MakeTargetStringIncludingPunctuation() can then be
						// allowed to do its work when the phrase box moves on, that's best
					}
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else
				{
					if (bSomethingIsCopied)
					{
						str = CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
													// and it sets gbByCopyOnly to TRUE
					}
					else // nothing copied, or its a null source phrase, or a null string
					{
                        // we didn't do a copy, so we will want whatever eventually results
                        // to still be stored later on
						gbByCopyOnly = FALSE;
					}
					// if its a null source phrase, or the copy source flag is turned off,
					// or the user stored a null string as the adaption, we don't show anything
					// - but either way it's abandonable
					pApp->m_pTargetBox->m_bAbandonable = TRUE;
				}
			} // end of block for m_bDrafting == TRUE, for Reviewing mode we
			  // don't want a copy done
		} // end block for tests: bGotOne == FALSE and "is split dialog is
		  // active currently?" == FALSE

		// this next call relies for it's success on pActivePile being the CPile* at the
		// new active location, and that the partner CSourcePhrase instance has its
		// m_nSequNumber value set to the same value as the app's member m_nActiveSequNum
		// - these conditions are guaranteed by code in the caller before this function is
		// called
		pActivePile->SetPhraseBoxGapWidth(); // also sets CLayout::m_curBoxWidth to
                    // same value that it sets in the active pile's m_nWidth member
	} // end of else block for test: if (bHasNothing)
}

// Returns nothing.
// This function is called when a match has been made for a Find button click, also when
// no match is possible or user cancels out of the Find operation. The idea is to place
// the phrase box at the start of the match (the user may have stipulated that the match
// be for more than one word and across piles), and the source text selected there, and
// the PlacePhraseBox() call made, followed by ScrollIntoView() in order to give the user
// all options for what to do next. If several words were selected at the take off
// location, then the match should be for the same number of words at the landing location
// and the selection is set up accordingly as possible. A complication is when the matched
// text is within a retranslation - in this circumstance we select the matched text as
// before, but the active location is moved to be "safe" which in this circumstance means
// immediately before the retranslation. In the case of matching source text, the
// selection is normal yellow background. In the case of matching target text, we'll do
// similarly and no try to be smart, and just select all of the phrase box contents - even
// if only part of the text was matched.
void CAdapt_ItView::FindNextHasLanded(int nLandingLocSequNum, bool bSuppressSelectionExtension)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CPile* pPile = NULL;
	if (nLandingLocSequNum == -1)
	{
		// should never be called with a value of -1 passed in, but if so, just do nothing
		return;
	}
	pPile = GetPile(nLandingLocSequNum);

	// preserve enough information to be able to recreate the appropriate selection
	// since placing the phrase box will clobber the earlier selection at last landing
	CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
	int nCount = 0;
	if (!pApp->m_selection.IsEmpty())
	{
		nCount = pApp->m_selection.GetCount();
		wxASSERT(nCount > 0);
	}
	int nSaveSelSequNum = pSrcPhrase->m_nSequNumber; // if in a retrans,
								// selection will not be where phrase box ends up

    // pPile is what we will use for the active pile, so set everything up there,
    // provided it is not in a retranslation - if it is, place the box preceding
    // it, if possible; but if glossing is ON, we can have the box within a
    // retranslation in which case ignore the block of code
	CPile* pSavePile = pPile;
	if (!gbIsGlossing)
	{
		while (pSrcPhrase->m_bRetranslation)
		{
			pPile = GetPrevPile(pPile);
			if (pPile == NULL)
			{
				// if we get to the start, try again, going the other way
				pPile = pSavePile;
				while (pSrcPhrase->m_bRetranslation)
				{
					pPile = GetNextPile(pPile);
					wxASSERT(pPile != NULL); // we'll assume this will never fail
					pSrcPhrase = pPile->GetSrcPhrase();
				}
				break;
			}
			pSrcPhrase = pPile->GetSrcPhrase();
		}
	}
	pSrcPhrase = pPile->GetSrcPhrase();
	pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber; // what we finally will use
	pApp->m_pActivePile = pPile;
	CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

	// place the phrase box
	PlacePhraseBox(pCell,2);

	// get a new active pile pointer, the PlacePhraseBox call did a recal
	// of the layout
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);

	// scroll into view, just in case (but shouldn't be needed) BEW 16Jun09
	// moved this to be after the recalc of the layout, pointless to do it before
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

    // get a new pointer to the pile at the start of the selection, since the
	// recalc also clobbered the old one -- this selection could possibly be removed from
	// the active location if the original landing place was in a retranslation, if it
	// wasn't in a retranslation, it should be starting from the active location
	CPile* pSelPile = GetPile(nSaveSelSequNum);
	wxASSERT(pSelPile != NULL);

	Invalidate(); // get the view window redrawn, and the phrase box
	GetLayout()->PlaceBox();

	// restore focus to the targetBox
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->SetSelection(-1,-1); // -1,-1 selects all
			pApp->m_pTargetBox->SetFocus();
		}
	}

	// recreate the selection to be in top line; we suppress this in places where another
	// external function called after this one returns will do this job for us
	if (!bSuppressSelectionExtension)
	{
		CCell* pAnchorCell = pSelPile->GetCell(0);
		if (nCount > 0 && pAnchorCell != NULL)
		{
			pApp->m_pAnchor = pAnchorCell;
			CCellList* pSelection = &pApp->m_selection;
			wxASSERT(pSelection->IsEmpty());
			pApp->m_selectionLine = 0;
			wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context

			// then do the new selection, start with the anchor cell

			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			pAnchorCell->DrawCell(&aDC, pApp->m_pLayout->GetSrcColor());
			pApp->m_bSelectByArrowKey = FALSE;
			pAnchorCell->SetSelected(TRUE);

			// preserve record of the selection
			pSelection->Append(pAnchorCell);

			// extend the selection to the right, if more than one pile is involved
			if (nCount > 1)
			{
				// extend the selection (shouldn't be called when glossing is ON
				// because we inhibit matching across piles in that circumstance)
				ExtendSelectionForFind(pAnchorCell,nCount);
			}
		}
	}
}

// PlacePhraseBox() selector values: used for inhibiting one or both of two blocks of code.
// The first block should be done only when the user has clicked elsewhere after being in a
// former location, since the first block saves the adaptation text left in the former
// phrase box's location. The second block removes the adaptation text from the KB when the
// focus has moved to the new location clicked. It is not appropriate to do this code when
// returning from being in a dialog such as Choose Translation, since the adaptation text
// will already have been removed before the dialog was entered, so selector = 1 inhibits
// this block. The other two possible situations, a normal click (selector = 0), or the
// target box was previously not at any location - as when the user has just opened a saved
// document file, it is essential to remove the adaption text from the phrase box's
// location, so that when the user hits RETURN to move on, the store will be re-done and
// the ASSERT in start of StoreText function will not trip; so a selector value of 2 is
// used for this case. That is,
// selector = 0 enables both blocks to be done,
// selector = 1 disables both blocks, and
// selector = 2 disables the first block but enables the second block.
// BEW added 27Jun05, For version 3, free translation support requires we can enable
// the first block and disable the second block, so for this combination we will use a
// selector value of 3. For version 2.0, which supports glossing, the function will test
// the gbIsGlossing flag in a number of places; these changes will increase the complexity
// of an already complex function, but it is better than having a separate glossing version
// which would bloat the app's size
// Ammended, July 2003, for auto-capitalization support
// BEW 22Feb10 no changes needed for support of doc version 5
// BEW 22Jun10, no changes needed for support of kbVersion 2
void CAdapt_ItView::PlacePhraseBox(CCell *pCell, int selector)
{
	// refactored 2Apr09
	CLayout* pLayout = GetLayout();
	if (pCell == NULL)
	{
		pLayout->m_docEditOperationType = relocate_box_op;
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	CPile* pClickedPile = pCell->GetPile();
	wxASSERT(pClickedPile);
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),1,pApp->m_nActiveSequNum);
//#endif

	// if there is no active pile defined, construct one at the clicked location,
	// or at whatever cell pointer was passed in - eg. when having just opened a document,
	// the active sequence number can be -1
	if (pApp->m_pActivePile == NULL)
	{
		int sequNum = pCell->GetPile()->GetSrcPhrase()->m_nSequNumber;
		pApp->m_pActivePile = GetPile(sequNum);
	}

	CSourcePhrase* pOldActiveSrcPhrase = NULL;
	CPile* pOldActivePile = GetPile(pApp->m_nActiveSequNum);
						// returns NULL if passed in value is -1
	if (pOldActivePile != NULL)
	{
		pOldActiveSrcPhrase = pOldActivePile->GetSrcPhrase();
		wxASSERT(pOldActiveSrcPhrase);
	}
	gbEnterTyped = FALSE; // ensure its false, only hitting ENTER key
						  // should set it TRUE
	wxASSERT(pCell);
	if (pCell->GetCellIndex() != 1) // index == 1 is the line of cells
									// which has the phrase box
	{
		gSaveTargetPhrase = pApp->m_targetPhrase; // an adaptation, or a gloss, depending on mode
		pLayout->m_docEditOperationType = relocate_box_op;
		return;
	}
	CAdapt_ItDoc* pDoc = GetDocument();
	pDoc->Modify(TRUE);

	// if auto capitalization is on, determine the source text's case propertiess
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		if (pApp->m_pActivePile == NULL)
		{
			// active location is undefined because we are at the end of the document
			bNoError = FALSE;
		}
		else
		{
			bNoError = pApp->GetDocument()->SetCaseParameters(pApp->m_pActivePile->GetSrcPhrase()->m_key);
		}
	}
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),2,pApp->m_nActiveSequNum);
//#endif

    // Also inhibit if it is a "<Not In KB>" location where there is something in the
    // phrase box but the m_bSaveToKB flag is still off (FALSE) - but only provided we are
    // in adapting mode
	if (!(pApp->m_nActiveSequNum == -1)) // can't do the following block if there is no
										 // active pile currently in existence
	{
        // if it's an <Not In KB> entry, from version 1.4.0 and onwards, by Susanna Imrie's
        // suggestion, we allow the document to have a non null adaptation even when <Not
        // In KB> has been chosen; so we don't clear, but we do the check to fix a wrongly
        // edited adaption KB. This check is required only for gbIsGlossing == FALSE, since
        // the glossing KB knows nothing of <Not In KB> behaviour
        // BEW added to test 23Jul05, since m_bNotInKB is also true for retranslations and
        // when in free translation mode if we don't exclude retranslations then <Prev,
        // Next> or Advance buttons, if they land the box in a retranslation, the phrase
        // box text that get's set up is the old location's adaptation, not to mention a
        // spurious save of <Not In KB> to the KB as well.
		if (!gbIsGlossing && pApp->m_pActivePile &&
			!pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry &&
			pApp->m_pActivePile->GetSrcPhrase()->m_bNotInKB &&
			!pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
		{
            // in case the user edited out the <Not In KB> entry from the KB editor, we
            // need to put it back so that the setting is preserved (the "right" way to
            // change the setting is to use the toolbar checkbox)

            // if the user edited out the <Not In KB> entry from the KB editor, we need to
            // put it back so that the setting is preserved (the "right" way to change the
            // setting is to use the toolbar checkbox - this applies when adapting, not
            // glossing)
			pApp->m_pKB->Fix_NotInKB_WronglyEditedOut(pApp->m_pActivePile);
		}
		else // a normal situation, such as a click on a new active location
		{
            // inhibit the save, if we are here not from a click to a new location, eg. as
            // when having exited from the Choose Translation dialog having forced it to
            // show - because when the latter happens, this would be the second time this
            // function is entered for this phrase box location, and so we don't need to do
            // a save. Selector values are used to support these inhibitions on doing the
            // code below.
            // BEW changed 27Jun05, for free translation support - added test for selector
            // == 3 selector values 0 and 3 are the only ones which permit saving the old
            // location's text to the KB
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),3,pApp->m_nActiveSequNum);
//#endif
			if (selector == 0 || selector == 3)
			{
                // mark invalid the strip preceding the active strip, so as to allow
                // migration upwards of a small pile at start of active strip if the active
                // location moves further away and so the old active location's pile
                // becomes less wide and able to fit at the end of the previous strip - the
                // only way to get it there is to make that strip m_bValid = FALSE (if
                // there was no active location and we created one at the destination
                // click's pile in the code above, doing this creates no problem)
				if (pApp->m_nActiveSequNum != -1)
				{
					CPile* pile = GetPile(pApp->m_nActiveSequNum);
					wxASSERT(pile != NULL);
					int stripIndex = pile->GetStripIndex();
					if (stripIndex > 0)
					{
						stripIndex--;
						//pLayout->GetInvalidStripArray()->Add(stripIndex);
						// BEW changed 20Jan11, we want only unique indices in the array
						AddUniqueInt(pLayout->GetInvalidStripArray(), stripIndex);
					}
				}
				// user has not typed anything at the new location yet
				pApp->m_bUserTypedSomething = FALSE;

				// make sure pApp->m_targetPhrase doesn't have any final spaces
				RemoveFinalSpaces(pApp->m_pTargetBox, &pApp->m_targetPhrase);

				// any existing phraseBox text must be saved to the KB, unless its empty
				bool bOK = TRUE;
				if (!pApp->m_targetPhrase.IsEmpty())
				{
					if (pApp->m_pTargetBox->IsModified()) // MFC GetModify()
					{
						if (pApp->m_pTargetBox->m_bAbandonable)
						{
                            // if abandonable, then we want a placement click to throw away
                            // the text in the box; which will make the store operation do
                            // no store
							pApp->m_targetPhrase.Empty();
							pApp->m_pTargetBox->ChangeValue(_T("")); // this doesn't generate
							// a wxEVT_COMMAND_TEXT_UPDATED event, we don't need
							// an OnChar() call for the location we are leaving
						}
						else
						{
                            // its not empty, not abandonable (text), and has been
                            // modified, so do nothing - the storage operation below will
                            // then store the text
							; // formerly, relic code to display the empty adapt dialog was here
						}
					}

					// it has to be saved to the relevant KB now
					if (!pApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
					{
						bOK = pApp->m_pTargetBox->DoStore_ForPlacePhraseBox(pApp, pApp->m_targetPhrase);
					}
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),4,pApp->m_nActiveSequNum);
//#endif
				} // end block for test !pApp->m_targetPhrase.IsEmpty() == TRUE
				else
				{
					// pApp->m_targetPhrase is empty, so let StoreText handle
					// what needs to happen.
					bOK = pApp->m_pTargetBox->DoStore_ForPlacePhraseBox(pApp, pApp->m_targetPhrase);

					// check for a failure, abandon the function if the store failed
					if (!bOK)
					{
						// we must restore the box's selection to what it was
						// earlier before returning
						pApp->m_pTargetBox->SetFocus();
						pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar);
						gSaveTargetPhrase = pApp->m_targetPhrase;
						::wxBell(); // ring the bell to say that something wasn't right
						pLayout->m_docEditOperationType = relocate_box_op;
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),5,pApp->m_nActiveSequNum);
//#endif
						return;
					}
				} // end else block for test:  !pApp->m_targetPhrase.IsEmpty()
				  // i.e. block for empty m_targetPhrase
			} // end block for selector equals 0 or 3
		} // end normal block where saving of the text in the KB, for the
		  // old active loc'n, would be done
	}

	// before we deal with the clicked location, we want to recalculate the width of the
	// pile at the old active location, but suppress the fact that it is still the active
	// location when we do that calculation, and get the index of the changed strip put in
    // CLayout:m_invalidStripArray and mark the strip invalid as well (by setting m_bValid
    // to FALSE)
	if (pOldActiveSrcPhrase != NULL)
	{
		// bNoActiveLocationCalculation is TRUE to suppress the wide gap calculation
		pDoc->ResetPartnerPileWidth(pOldActiveSrcPhrase,TRUE);
	}
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),6,pApp->m_nActiveSequNum);
//#endif

	// honour the click
	CPile* pActivePile = pClickedPile;	// the clicked pile now has to become the
										// new active location
	wxASSERT(pActivePile);

	// remove any existing selection
	RemoveSelection();
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),7,pApp->m_nActiveSequNum);
//#endif

    // setup the layout and phrase box at the new location; in the refactored design this
    // boils down to working out what the new active location's sequence number is, and
    // then setting the active pile to be the correct one, getting an appropriate gap
    // calculated for the "hole" the box is to occupy, tweaking the layout to conform to
    // these changes (either by a RecalcLayout() call, or AdjustForUserEdits() call -
    // either of which will make a new pile pointer, appropriately sized, for that
    // location), updating the m_pActivePile pointer on the app class, and then calling the
    // view class's Invalidate() function to get the tweaked layout drawn and the box made
    // visible, appropriately sized, at the new active location
	pApp->m_pActivePile = pActivePile;
	CSourcePhrase* pSrcPhrase = pActivePile->GetSrcPhrase();
	wxASSERT(pSrcPhrase);
	pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
	wxASSERT(pApp->m_nActiveSequNum >= 0);

	//  uncomment out, for a handy way to check the TextType values at various
	//  locations in the doc
	//	wxString sss;
	//	sss = sss.Format(_T("TextType value: %d\n"),pSrcPhrase->m_curTextType);
	//	wxMessageBox(sss);

	wxString str; // to hold whatever text we find at the new location
	str.Empty();

	// the following three booleans are local flags which we set in code further below,
	// they will help in making decisions about which algorithm to follow in setting up
	// the new location correctly
	bool bHasNothing = FALSE;
	bool bNoValidText = FALSE;
	bool bSomethingIsCopied = FALSE;

    // if we have just chosen an empty adaptation or gloss string in the Choose Translation
    // dialog, then ensure that's what appears in the box; gbEmptyAdaptationChosen will be
    // TRUE if that is how we got here with an empty str
	if (gbEmptyAdaptationChosen)
	{
		// str is already empty, so nothing much to do
		gbEmptyAdaptationChosen = FALSE;

        // this next call relies for it's success on pActivePile being the CPile* at the
        // new active location, and that the partner CSourcePhrase instance has its
        // m_nSequNumber value set to the same value as the app's member m_nActiveSequNum -
        // these conditions are guaranteed by code above in this function
		pActivePile->SetPhraseBoxGapWidth(); // also sets CLayout::m_curBoxWidth to same
                                // value that it sets in the active pile's m_nWidth member
		goto a;
	}
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),8,pApp->m_nActiveSequNum);
//#endif

    // if we are attempting to place the box on a location where the entry is "<Not In
    // KB>", then we do so but adjust the flags to fit this situation; if not locating at a
    // "<Not In KB>" location, we must ensure that m_bSaveToKB is restored to TRUE from
    // version 1.4.0 onwards - but only provided we are not glossing. If there is existing
    // adaptation text at the new location, we leave it there (as per Susanna Imrie's
    // suggestion) even when it's a "not in kb" translation
    // BEW added to test 23Jul05 since m_bNotInKB is also true for retranslations and when
    // in free translation mode if we don't exclude retranslations then <Prev, Next> or
    // Advance buttons, if they land the box in a retranslation, the phrase box text that
    // get's set up is the old location's adaptation, not to mention a spurious save of
    // <Not In KB> to the KB as well.
	if (!gbIsGlossing && ((!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB) ||
				pApp->m_pKB->IsItNotInKB(pSrcPhrase)) && !pSrcPhrase->m_bRetranslation)
	{
        // this ensures user has to explicitly type into the box and explicitly check the
        // checkbox if he wants to override the "not in kb" earlier setting at this
        // location
		pApp->m_bSaveToKB = FALSE;

        // this ensures the flags are appropriately set, so that an asterisk will show when
        // the placement is complete, if we arrived here due to IsItNotInKB() returning
        // TRUE & the other test FALSE
		pSrcPhrase->m_bHasKBEntry = FALSE;
		pSrcPhrase->m_bNotInKB = TRUE;
		str = pSrcPhrase->m_adaption;

		// this next call relies for it's success on pActivePile being the CPile* at the
		// new active location, and that the partner CSourcePhrase instance has its
		// m_nSequNumber value set to the same value as the app's member m_nActiveSequNum
		// - these conditions are guaranteed by code above in this function (360 lines up)
		pActivePile->SetPhraseBoxGapWidth(); // also sets CLayout::m_curBoxWidth to same
							// value that it sets in the active pile's m_nWidth member
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),9,pApp->m_nActiveSequNum);
//#endif
		goto a;
	}
	else
	{
        // when glossing, permit the save to be done to the glossing KB; but don't change
        // the source phrase's m_bNotInKB value since that only applies when adapting
		pApp->m_bSaveToKB = TRUE;
	}

	// BEW added to test, 27Jun05, for free translation support (added selector == 3 test)
	if ((selector == 1 || selector == 3) && !translation.IsEmpty())
	{
		// bypass the removal from KB, since if translation is non-empty, it will have
		// been done within code higher up in the current call tree (that's what
		// selector == 1 possibly means in this context)
		// The selector == 3 case is when the last PlacePhraseBox() call was just to the
		// start of the bundle's sourcephrase as a temporary placement to force bundle
		// adjustment so a second call can be made after the iterating backwards finishes
		// -- but later changes mean we need selector == 3 case anyway, even though we no
		// longer have bundles
		str = translation;

		// this next call relies for it's success on pActivePile being the CPile* at the
		// new active location, and that the partner CSourcePhrase instance has its
		// m_nSequNumber value set to the same value as the app's member m_nActiveSequNum
		// - these conditions are guaranteed by code above in this function (360 lines up)
		pActivePile->SetPhraseBoxGapWidth(); // also sets CLayout::m_curBoxWidth to same
							// value that it sets in the active pile's m_nWidth member
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),10,pApp->m_nActiveSequNum);
//#endif
		goto a;
	}

	// this block added in support of adaption KB versus glossing KB, to get booleans
	// to control branching in the code lower down
	if (gbIsGlossing)
	{
		if (!pSrcPhrase->m_bHasGlossingKBEntry && !pApp->m_bCopySource)
			bHasNothing = TRUE;
		if (!pSrcPhrase->m_bHasGlossingKBEntry)
			bNoValidText = TRUE;
		if ((!pSrcPhrase->m_bNullSourcePhrase && pApp->m_bCopySource) &&
			!pSrcPhrase->m_bHasGlossingKBEntry)
			bSomethingIsCopied = TRUE;
	}
	else // adapting
	{
		if (!pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB && !pApp->m_bCopySource)
			bHasNothing = TRUE;
		if (!pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB)
			bNoValidText = TRUE;
		if ((!pSrcPhrase->m_bNullSourcePhrase && pApp->m_bCopySource) &&
			!pSrcPhrase->m_bHasKBEntry)
			bSomethingIsCopied = TRUE;
	}

	// get the auto capitalization parameters for the sourcephrase's key
	if (gbAutoCaps)
	{
		bNoError = pApp->GetDocument()->SetCaseParameters(pSrcPhrase->m_key);
	}

    // the next call factors out various blocks of code which all have one objective, to
    // find suitable text (adaptation in adapting mode, gloss in glossing mode) to put in
    // the passed in str parameter, which will then on return be used for the phrase box
    // contents which are to be shown in the box when it becomes visible at the new
    // location
	DoGetSuitableText_ForPlacePhraseBox(pApp, pSrcPhrase, selector, pActivePile, str,
										bHasNothing, bNoValidText, bSomethingIsCopied);
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),11,pApp->m_nActiveSequNum);
//#endif

a:	pApp->m_targetPhrase = str; // it will lack punctuation, because of BEW change on
				// 28April05 to the code now in the DoGetSuitableText_ForPlacePhraseBox()
	pApp->m_nStartChar = -1;
	pApp->m_nEndChar = -1; // make sure the text is shown selected
	if (gbAutoCaps)
	{
		if (gbSourceIsUpperCase && !gbMatchedKB_UCentry)
		{
			bNoError = pApp->GetDocument()->SetCaseParameters(pApp->m_targetPhrase, FALSE);
			if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
			{
				// change to upper case initial letter
				pApp->m_targetPhrase.SetChar(0,gcharNonSrcUC);
			}
		}
	}
	gSaveTargetPhrase = pApp->m_targetPhrase;

	// BEW 1Jun10, moved to here from within DoGetSuitableText_ForPlacePhraseBox(), as it
	// logically makes no sense in the latter, and is more relevant here (particularly as
	// a goto to label a: would bypass the latter function call and so this code would be
	// missed (wrongly so) -- what we do here is to auto-adjust the KB CRefString entry
	// for this new location so as to decrement by one the m_refCount, or if it was
	// already just equal to 1, to 'remove' it (ie. set its m_bDeleted flag to TRUE)
	if (!bHasNothing)
	{
        // don't do the following selection when PlacePhraseBox() is called from deep in
        // some other function before the phrasebox is finally rebuilt (such as in the
        // SetActivePilePointerSafely() call in the OnButtonRetranslation() call; since it
        // would then either decrement a refCount, or remove a translation association,
        // wrongly) - in such instances, we must suppress the removal
		if (pApp->GetRetranslation()->GetSuppressRemovalOfRefString() == FALSE)
		{
			// remove the CRefString from the KB if it is referenced only once, otherwise
			// decrement its reference count by one, so that if user edits the string the KB
			// (or if glossing, then the glossing KB) will be kept up to date
			if (selector != 1 && selector != 3) // see comments under the function header
												// for an explanation of the selector values
			{
				// do this for selector values 0 or 2
				wxString emptyStr = _T("");
				if (gbIsGlossing)
					pApp->m_pGlossingKB->GetAndRemoveRefString(pSrcPhrase,
												emptyStr, useGlossOrAdaptationForLookup);
				else
					pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase,
												emptyStr, useGlossOrAdaptationForLookup);
			}
		}
	}

	// mark invalid the strip following the new active strip, so as to allow
	// migration upwards of pile in a strip which sometimes may not be full; but do this
	// only if there is less than 3/4 of the strip's width occupied by piles currently
	if (pApp->m_nActiveSequNum != -1)
	{
		CPile* pile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pile != NULL);
		int stripIndex = pile->GetStripIndex();
		if (stripIndex < (int)pLayout->GetStripArray()->GetCount() - 1)
		{
			stripIndex++;
			CStrip* pStrip = pLayout->GetStripByIndex(stripIndex);
			int stripWidth = pStrip->Width();
			int freeS = pStrip->GetFree();
			if (freeS > stripWidth / 4)
			{
				// BEW changed 20Jan11, we want only unique indices in the array
				AddUniqueInt(pLayout->GetInvalidStripArray(), stripIndex);
			}
		}
	}
	//wxLogDebug(_T("2972 before RecalcLayout in view PlacePhraseBox(), m_bCancelAndSelectButtonPressed = %d"),
	//	pApp->m_pTargetBox->GetCancelAndSelectFlag());

    // recalculate the layout; before the actual strips are rebuilt, doc class member
    // ResetPartnerPileWidth(), with bool param, bNoActiveLocationCalculation, default
    // FALSE is called, to get a fresh active pile pointer in m_pileList, and a new gap
    // calculated for the phrase box's new width, before Draw() has it made visible when
    // the view's Invalidate() call is made below (Note: later, we can replace this
    // RecalcLayout() call with a call to the faster AdjustForUserEdits(), which also
    // likewise calls ResetPartnerPileWidth() - for the same reason as given above)
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),12,pApp->m_nActiveSequNum);
//#endif
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif

    // update the active pile pointer to point at the refreshed pile pointer which the
    // RecalcLayout() call created
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile);
	pLayout->m_docEditOperationType = relocate_box_op;

	CSourcePhrase* pSPhr = pApp->m_pActivePile->GetSrcPhrase();
	if (pSPhr != NULL)
	{
		pDoc->ResetPartnerPileWidth(pSPhr);
	}
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),13,pApp->m_nActiveSequNum);
//#endif

    // we had to delay the call of DoCancelAndSelect() until now because earlier
    // RecalcLayout() calls will clobber any selection we try to make beforehand, so do the
    // selecting now; do it also before recalculating the phrase box, since if anything
    // moves, we want the phrase box location to be correct
	if (pApp->m_pTargetBox->GetCancelAndSelectFlag())
	{
		// this block is entered when the user places the phrase box with a click at a
		// hole and lookup is done and there is more than one KB adaptation (or gloss)
		// available and he clicks the Cancel & Select button; DoCancelAndSelect clears
		// the private bool m_bCancelAndSelectButtonPressed in the CPhraseBox instance
		pApp->m_pTargetBox->DoCancelAndSelect(this, pApp->m_pActivePile);
		pApp->m_bSelectByArrowKey = TRUE; // so it is ready for extending
	}
	gbCompletedMergeAndMove = FALSE;
//#ifdef _DEBUG
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),14,pApp->m_nActiveSequNum);
//#endif

	// whm added 20Nov10 reset the m_bIsGuess flag below. Can't do it in PlaceBox()
	// because PlaceBox() is called first via the MoveToNextPile() call near the beginning
	// of OnePass, then again near the end of OnePass - twice in the normal course of
	// auto-insert adaptations.
	pApp->m_bIsGuess = FALSE;

	Invalidate();
	pLayout->PlaceBox();
}

// OnPrepareDC() was moved to CAdapt_ItCanvas in the wx version

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   -> unused
/// \remarks
/// Called from: The File -> Print menu selection. Note: This handler is not called when
/// the "Print" button in the print preview dialog is pressed. This handler creates a
/// printer object from the wxPrinter class, associates it with our wxPrintDialogData
/// object (pPrintData), sets the print dialog title and invokes the print dialog by
/// calling printer.Print().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnPrint(wxCommandEvent& WXUNUSED(event))
{
	// whm note: The code below is adapted from wxWidgets printing sample
	// See file:.\AIPrintout.cpp#print_flow for the order of calling of OnPrint().

	gbIsBeingPreviewed = FALSE; // from MFC's OnPreparePrinting

	CAdapt_ItApp* pApp = &wxGetApp();
#if defined(__WXGTK__)
    // BEW added 15Nov11  -- set up defaults for page range choice, 'no choice', PageOffsets the initial page only
    pApp->m_bPrintingPageRange = FALSE;
    pApp->m_userPageRangePrintStart = 1; // 1-base indexing
    pApp->m_userPageRangePrintEnd = 1;   // 1-based indexing
    pApp->m_userPageRangeStartPage = 1; // we use this to get a correct number into the printed footer
#endif


	wxPrintDialogData printDialogData(*pApp->pPrintData);

	pApp->m_bIsPrinting = TRUE; // new printing support code needs it set before poDlg InitDialog() is called
	pApp->m_nSaveActiveSequNum = pApp->m_nActiveSequNum; // needed! So Cancel from PrintOptionsDlg
														 // can restore document correctly

	pApp->LogUserAction(_T("Initiated OnPrint()"));
    // In the wx version we implement a chapter and verse selection dialog to supplement the print
    // dialog, since it is not likely we will be able to use custom print dialogs for all platforms.
    // The print options dialog items are:
    // 1. Radio buttons for: "All", "Selection", "Pages", and "Chapter/Verse Range.
    // 2. "from:" and "to:" edit boxes associated with the "Pages" radio button.
	// 3. "from: chapter" and "verse" edit boxes; and "to: chapter" and "verse" edit boxes for range
	//    number(s) entry associated with the "Chapter/Verse Range" radio button.
    // 4. A check box "[ ] Suppress a preceding section heading".
    // 5. A check box "[ ] Include a following section heading".
    // 6. A check box "[ ] Suppress printing of the footer".
	CPrintOptionsDlg poDlg(pApp->GetMainFrame()); //,&printout);
	poDlg.Centre();
	// The CPrintOptionsDlg does all of its own initialization
	if (poDlg.ShowModal() == wxID_OK)
	{
		// Update printDialogData to reflect:
        // 1. Whether the user entered a "from" and a "to" page range so that this carries
        // over to the print dialog below.
		// 2. Whether the user clicked on the "Selection" radio button (if enabled)

		// get user settings for Pages
		if (poDlg.pRadioPages->GetValue() == TRUE)
		{
			wxString strFrom,strTo;
			int nFrom,nTo;
			strFrom = poDlg.pEditPagesFrom->GetValue();
			nFrom = wxAtoi(strFrom);
			strTo = poDlg.pEditPagesTo->GetValue();
			nTo = wxAtoi(strTo);
			printDialogData.SetFromPage(nFrom);
			printDialogData.SetToPage(nTo);
#if defined(__WXGTK__)
            // BEW added 15Nov11  -- a workaround because the Linux build loses the
            // nFrom and nTo values somewhere in the wxGnomeprinter framework
            pApp->m_bPrintingPageRange = TRUE;
            pApp->m_userPageRangePrintStart = nFrom; // 1-base indexing
            pApp->m_userPageRangePrintEnd = nTo; // 1-based indexing
            pApp->m_userPageRangeStartPage = nFrom; //1-based indexing -- this one for footer
#endif
		}
		else if (poDlg.pRadioSelection->GetValue() == TRUE)
		{
			printDialogData.SetSelection(TRUE);
		}
	}
	else
	{
        // User cancelled the print options, so we assume we should also cancel the print
        // dialog which happens if we simply return here. The MFC version did a lot of work
        // to get the document back into its original state, but the wx version doesn't
        // change the doc's state at this early stage.
		//BEW added 20July(), because we no longer do "simulated" recalc of the layout
		//etc, but a real one and real pagination in order to prepare parameters for the
		//PrintOptionsDlg, and so we need to undo all that to get the original document
		//state back.
		pApp->m_nAIPrintout_Destructor_ReentrancyCount = 1;
		pApp->DoPrintCleanup();
		pApp->m_nAIPrintout_Destructor_ReentrancyCount = 0;
		pApp->m_bIsPrinting = FALSE;
		pApp->LogUserAction(_T("Cancelled OnPrint()"));
#if defined(__WXGTK__)
        // BEW added 15Nov11  -- restore defaults for page range choice, 'no choice',
        // PageOffsets the initial page only
        pApp->m_bPrintingPageRange = FALSE;
        pApp->m_userPageRangePrintStart = 1; // 1-base indexing
        pApp->m_userPageRangePrintEnd = 1; // 1-based indexing
        pApp->m_userPageRangeStartPage = 1;
#endif
		return;
	}
	wxPrinter printer(& printDialogData);

	wxString printTitle;
	printTitle = printTitle.Format(_T("Printing %s"),pApp->m_curOutputFilename.c_str());

	// klb 9/2011 : If user has requested printing of Glosses in CPrintOptionsDlg and
	//              Glosses are not currently visible, we need to turn glosses on so
	//              that they are printed. Local variable bNeedToToggleGlossing will tell
	//              us whether we need to switch the main screen back (below) after printing
	bool bNeedToToggleGlossing = FALSE;
	if ((gbCheckInclGlossesText == TRUE) && !gbGlossingVisible)
	{
		bNeedToToggleGlossing = TRUE;
		ShowGlosses();
	}

	AIPrintout printout(printTitle); // this calls Freeze() on the canvas

	// for debugging -- yes, user's range of pages, if set, which was input above at line
	// 3380 does output the correct values when GetPrintDialogData() is called here, but
	// somewhere after that the values are lost and so the GTK printing framework defaults
	// to using page 1 as the fromPage and 0 as the toPage value, and the framework checks
	// and sees the 0 value and substitutes 99999. Can't see a way to fix this. (BEW 12Nov11)
	//wxPrintDialogData printDD = printer.GetPrintDialogData();

	// #printer_Print
    if (!printer.Print(pApp->GetMainFrame(), &printout, true)) // true means 'prompt'
    {
		// whm: Other error messages are issued, so we don't need yet another one here
		pApp->LogUserAction(_T("Printer error from OnPrint()"));
    }
    else
    {
        (*pApp->pPrintData) = printer.GetPrintDialogData().GetPrintData();
    }
    // Do not clear m_bPrintingPageRange to FALSE here, it is needed until DoPrintCleanup()'s
    // internal test of it's value is done in the AIPrintout destructor

	// klb 9/2011 : toggle main screen to hide glosses again if necessary
	if (bNeedToToggleGlossing == TRUE)
		ShowGlosses();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   -> unused
/// \remarks
/// Called from: The File -> Print Preview menu selection. This handler creates a preview
// object from the / wxPrintPreview class, creates a frame object from the wxPreviewFrame
// class, positions, sizes and / initializes the frame, and finally shows the print preview
// frame in modal fashion.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnPrintPreview(wxCommandEvent& WXUNUSED(event))
{
	// whm note: The code below is adapted from wxWidgets printing sample
	// See file:.\AIPrintout.cpp#print_flow for the order of calling of OnPrint().
    // Pass two printout objects: for preview, and possible printing.
	CAdapt_ItApp* pApp = &wxGetApp();

	// whm 25Sep11 modified. As I did in the PrintOptionsDlg::InitDialog() function,
	// we should initialize the values of gbCheckInclGlossesText and gbCheckInclFreeTransText
	// based on whether the document actually has such content or not. If the doc has
	// free translations, we should include them in the Print Preview, otherwise we
	// omit them.
	if (pApp->DocHasFreeTranslations(pApp->m_pSourcePhrases))
	{
		gbCheckInclFreeTransText = TRUE;
	}
	else
	{
		gbCheckInclFreeTransText = FALSE;
	}
	// whm 25Sep11 modified. Likewise, if the doc has glosses, we should include them
	// in the Print Preview, otherwise we omit them.
	if (pApp->DocHasGlosses(pApp->m_pSourcePhrases))
	{
		gbCheckInclGlossesText = TRUE;
	}
	else
	{
		gbCheckInclGlossesText = FALSE;
	}

    // BEW 5Oct11, we'll unilaterally Freeze(), and unlaterally later Thaw(), whether or
    // not we subsequently turn on glossing or free translation modality
	pApp->GetMainFrame()->Freeze();
	pApp->m_bFrozenForPrinting = TRUE;

	// klb 9/2011 : If glosses are not visible, we need to make them visible in the
	// underlying document temporarily to have them show in the print preview frame
	// whm 25Sep11 added test below for gbCheckInclGlossesText.
	bool bHideFreeTranslations = FALSE;
	if (gbCheckInclFreeTransText && !pApp->m_bFreeTranslationMode)
	{
		bHideFreeTranslations = TRUE;
		pApp->GetFreeTrans()->SwitchScreenFreeTranslationMode(ftModeON);
	}
	bool bHideGlosses = FALSE;
	if (gbCheckInclGlossesText && !gbGlossingVisible)
	{
		bHideGlosses = TRUE;
		pApp->GetView()->ShowGlosses();
	}

	GetLayout()->RecalcLayout(pApp->GetSourcePhraseList(),create_strips_and_piles);
	// must reset m_pActivePile after a RecalcLayout(), else view's Draw() will crash
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum); // the param hasn't changed

    pApp->LogUserAction(_T("Initiated OnPrintPreview()"));
	wxString previewTitle,printTitle;
	previewTitle = previewTitle.Format(_T("Print Preview of %s"),
										pApp->m_curOutputFilename.c_str());
	printTitle = printTitle.Format(_T("Printing %s"),pApp->m_curOutputFilename.c_str());
    wxPrintDialogData printDialogData(*pApp->pPrintData);
    wxPrintPreview *preview = new wxPrintPreview(new AIPrintout(previewTitle),
									new AIPrintout(printTitle), & printDialogData);
    if (!preview->Ok())
    {
		if (preview != NULL) // whm 11Jun12 added NULL test
	        delete preview;
        wxMessageBox(_T(
"There was a problem previewing.\nPerhaps your current printer is not set correctly?"),
		_T("Previewing"), wxOK);
        pApp->LogUserAction(_T("There was a problem previewing.\nPerhaps your current printer is not set correctly?"));
		return;
    }

	gbIsBeingPreviewed = TRUE; // from MFC's OnPreparePrinting()

    // Note: If we ever want to use it, an AIPreviewFrame object can be created using the
    // currently commented out class AIPreviewFrame, which is derived from wxPreviewFrame
    // (see AIPrintout.h). It could be used so we can get access to wxPreviewFrame's
    // OnCloseWindow method.
    //wxPreviewFrame *frame = new AIPreviewFrame(preview, pApp->GetMainFrame(),
    //                _T("Adapt It Print Preview"), wxPoint(100, 100), wxSize(600, 650));

    // Since we freeze the canvas against screen updates, we may as well size the preview
    // frame to fully cover the canvas in the main window.
	CMainFrame* pFrame = pApp->GetMainFrame();

	wxSize frameClientSize = pFrame->GetClientSize();
	// The controlbar is always visible on the main frame
	wxSize controlbarSize = pFrame->m_pControlBar->GetSize();
	wxPoint framePosition = pFrame->GetPosition();
	wxPoint canvasPosition = pFrame->canvas->GetPosition();
	wxPoint previewPosition = framePosition + canvasPosition;
	previewPosition.x += wxSystemSettings::GetMetric(wxSYS_FRAMESIZE_X); // move to the
														// right by thickness of frame
	previewPosition.y += controlbarSize.y; // move the preview down just below the toolbar
	CAIPrintPreviewFrame *frame = new CAIPrintPreviewFrame(pApp, preview, pApp->GetMainFrame(),
								previewTitle, previewPosition, frameClientSize);
	//wxPreviewFrame *frame = new wxPreviewFrame(preview, pApp->GetMainFrame()
	//							previewTitle, previewPosition, frameClientSize);
    // We positioned the preview frame explicitly, so don't call Centre() here
    frame->Initialize();
    frame->Show();
	// klb 9/2011 : hide glosses if necessary
	if (bHideGlosses == TRUE)
		frame->HideGlossesOnClose( TRUE);
	if (bHideFreeTranslations == TRUE)
		frame->HideFreeTranslationsOnClose( TRUE);
	// whm note: The preview window is closed automatically
	// when the user exits/closes the preview window.
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if the document is empty, otherwise TRUE
/// \param      nTotalStripCount        -> total number of strips
/// \param      nPagePrintingLength     -> the length of a printed page between top and
//                                          bottom margins expressed in logical units
/// \remarks
/// Called from: AIPrintout::OnPreparePrinting(), and the View's SetupRangePrintOp().
/// Determines the number of strips that will fit on a page (using the current width
/// between left and right margins), and stores the offsets and strip counts for each page
/// in a list of pOffsets it stores in the App's list of PageOffsets.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::PaginateDoc(const int nTotalStripCount, const int nPagePrintingLength)
{
	//wxLogDebug(_T("PaginateDoc() START"));
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();

    // whm Observations: PaginateDoc() basically uses the existing indices for the App's
    // strip count as the max number of strips to be paginated into pages, and determines
    // how many pages it will take to print the document. whm Notes: The MFC version
    // paginates the document and lays it out for print preview and printing to fit the
    // page, regardless of the size of the main window of the application. The MFC version
    // also assumes negative offsets. The wx version also paginates the document and lays
    // it out for print preview and printing to fit the printed page, but it keeps the map
    // mode as wxMM_TEXT, scales the output to fit the print/print preview display context,
    // and uses positive offsets instead of negative offsets.
	//
	POList* pList = &pApp->m_pagesList;
	ClearPagesList(); // start with an empty list
	PageOffsets* pOffsets = NULL;
	// Note: RecalcLayout was previously called with the appropriate dc width
	int nMaxStrips = nTotalStripCount;
	if(nMaxStrips <= 0)
	{
		wxMessageBox(_T("Error: Cannot paginate an empty document."),_T(""),
			wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}

    // BEW 5Oct11: Note, the mode (glossing, or free trans), if either are to be printed,
    // must have been switched prior to control entering here - eg. in InitDialog() of
    // PrintOptionsDlg, and if not done, the pagination will be wrong (strip height too
    // small)

	int pageCount = 0;
	// strip "height" here includes the vertical space preceding it for navText display
	//
	// BEW 5Oct11, if coming here from  the OnOK() handler of the PrintOptionsDlg,
	// gbIsPrinting is still TRUE, but the GetStripHeight() call will just grab the old
	// value of the strip height before the user had a chance to click of either or both
	// of the checkboxes in the PrintOptionsDlg. So we have to explicitly call pLayout's
	// SetStripHeight() now, so that the values of gbCheckInclGlossesText and
	// gbCheckInclFreeTransText can be used to calculate the appropriate strip height (if
	// this is not done, the relevant data is not printed, but the line where it would be
	// printed remains empty, and so more strips don't get into the page)
	pLayout->SetPileAndStripHeight();
	int nStripHeightWithLeading = pLayout->GetCurLeading() + pLayout->GetStripHeight();
    // The nPagePrintingLength passed in represents the height of the printed page between
    // the top and bottom margins (in logical units).
	int nMaxHeightPerPage = nPagePrintingLength; // the page height between top and
												 // bottom margins in logical units

	int nAccumStripHeightThisPage = 0;
	int nStripCountRunningTotal = 0;
	int nFirstStripOnPage = 0;
    // loop to process pages until we've processed all the strips that need processing
	// BEW 11Jul09, added boolean because if a PageOffset was just closed off when one
	// strip remains to be processed, the loop exits with nAccumStripHeightThisPage reset
	// to 0, and then the block following the loop is not entered, so extra help is needed
	// in that block's test to ensure it gets entered in this circumstance
	bool bJustClosedOff = FALSE;
	while (nStripCountRunningTotal < nMaxStrips)
	{
		if (nAccumStripHeightThisPage + nStripHeightWithLeading > nMaxHeightPerPage)
		{
			// can't fit the next strip on this page so create a PageOffset page and save
            // its starting and ending strip offsets
			pOffsets = new PageOffsets;

			pOffsets->nTop = ((CStrip*)
				(*pLayout->GetStripArray())[nFirstStripOnPage])->Top();
			pOffsets->nBottom = ((CStrip*)
				(*pLayout->GetStripArray())[nStripCountRunningTotal - 1])->Top()
				+ ((CStrip*)(*pLayout->GetStripArray())[nStripCountRunningTotal - 1])->Height();

			pOffsets->nFirstStrip = nFirstStripOnPage;
			pOffsets->nLastStrip = nStripCountRunningTotal - 1; // store index
			pageCount++;
			pList->Append(pOffsets); // store the page information

			// prepare for the next iteration of the loop
			nFirstStripOnPage = nStripCountRunningTotal; // index for first strip
														 // of next PageOffsets instance
			nAccumStripHeightThisPage = 0;
			bJustClosedOff = TRUE;
		}
		else
		{
            // The next strip fits on this page so continue adding strips.
			nAccumStripHeightThisPage += nStripHeightWithLeading;
			bJustClosedOff = FALSE;
 			nStripCountRunningTotal++;

			//CStrip* pStrip = (CStrip*)(*pLayout->GetStripArray())[nStripCountRunningTotal - 1];
			//wxLogDebug(_T("CORRECT: Strip[ %d ]     Pile count:  %d"), pStrip->GetStripIndex(), pStrip->GetPilesArray()->GetCount());
		}
	}

	// BEW added to this test on 11July09, for the reason see comments above the loop above
	if (nAccumStripHeightThisPage > 0 || (bJustClosedOff &&
		((CStrip*)pLayout->GetStripArray()->Last())->GetStripIndex() == nFirstStripOnPage))
	{
		// there is material for one final (partial) page
		pOffsets = new PageOffsets;

		pOffsets->nTop = ((CStrip*)
			(*pLayout->GetStripArray())[nFirstStripOnPage])->Top();
		pOffsets->nBottom = ((CStrip*)
			(*pLayout->GetStripArray())[nStripCountRunningTotal - 1])->Top()
			+ ((CStrip*)(*pLayout->GetStripArray())[nStripCountRunningTotal - 1])->Height();

		pOffsets->nFirstStrip = nFirstStripOnPage;
		pOffsets->nLastStrip = nStripCountRunningTotal - 1;
		pageCount++;
		pList->Append(pOffsets); // store the page information
	}
	wxASSERT(pageCount == (int)pList->GetCount());
	//wxLogDebug(_T("PaginateDoc() END"));
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: The View's PaginateDoc() and AIPrintout's OnPreparePrinting() and its
/// destructor. ClearPagesList() is a helper function which simply deletes the list of page
/// offset structs from the POList called m_pagesList on the App.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::ClearPagesList()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	POList* pList = &pApp->m_pagesList;
	if (pList->GetCount() == 0)
	{
		return;
	}
	else
	{
		POList::Node* pos = pList->GetFirst();
		while(pos != NULL)
		{
			// whm note: PageParams and PageOffsets are similar structs
			// (PageParams has an extra member at the end of the struct called nPageNumber.
			// MFC version of code below casts the pList pointers to (PageParams*) but
			// the pList was originally filled with (PageOffsets*) pointers.
			// In MFC it doesn't complain, but in a wxList the pointers it
			// contains are strongly typed, so I'm casting them instead to
			// (PageOffsets*) which is really what was stored in this POList by the
			// PaginateDoc() function above.
			PageOffsets* pOffsets = (PageOffsets*)pos->GetData();
			pos = pos->GetNext();
			if (pOffsets != NULL)
			{
				delete pOffsets;
			}
		}
		pList->Clear();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE in the wx version (FALSE in the MFC version only if a memory
//               error occurrs)
/// \param      pSaveList       <- a SPList to store all items originally in pOriginalList
/// \param      pOriginalList   <- list of Source phrase items of which only a sublist remain
///                                 at the end of the GetSubList operation
/// \param      nBeginSequNum   -> the first list item composing the intended sub list
/// \param      nEndSequNum     -> the last item composing the intended sub list
/// \remarks
/// Called from: the View's SetupRangePrintOp() function and
/// AIPrintout::OnPreparePrinting(). GetSublist() first removes any existing list items
/// from pSaveList, then it copies all list items from pOriginalList into pSaveList; then
/// removes all items from pOriginalList; and adds back to pOriginalList only those source
/// phrases from pSaveList that are within the range nBeginSequNum to nEndSequNum. Finally
/// GetSublist() updates the indices related to printing of sublists.
///
/// Refactored BEW 16Jul09 to support the refactored view where CPile instances are owned
/// not by their strips which contain them, but by an m_pileList member in CLayout.
/// Accesses to partner piles will not work right when dealing with a shallow copy sublist
/// of CSourcePhrase instances unless the subrange of partner piles is moved also to a
/// sublist and the partner CSourcePhrase instances are renumbered in the sublist using
/// UpdateSequNumbers() -- which itself has been modified to accept the sublist pointer as
/// a second parameter.
/// BEW 14Nov11, refactored to do deep copies, rather than shallow; because we do deep
/// copies there are ramifications:
/// (i)Any RecalcLayout() call will use the create_strips_and_piles enum value,
/// (ii) We won't need to store or restore CLayout's pile list. We'll recreate it on
/// demand by passing create_strips_and_piles to RecalcLayout()
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetSublist(SPList* pSaveList, SPList* pOriginalList, int nBeginSequNum,
							   int nEndSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();
	bool bOK = TRUE;
	wxASSERT(pOriginalList->GetCount() > 0); // ensure the list is not empty
	wxASSERT(nBeginSequNum >= 0 && nEndSequNum >= nBeginSequNum); // ensure valid start and end values
	wxASSERT(nEndSequNum < (int)pOriginalList->GetCount()); // make sure both sequence numbers are in range

	m_pDoc->DeleteSourcePhrases(pSaveList, TRUE); // TRUE means 'delete any partner piles too
												  // (it won't matter if there aren't any)
	// copy the original list of CSourcePhrase instances in m_pSourcePhrases to the saveList
	// wxList doesn't support appending one list onto another so do it manually
	int countOriginals = pOriginalList->GetCount();
	bOK = DeepCopySourcePhraseSublist(pOriginalList, 0, countOriginals - 1, pSaveList); // copies full list
	// destroy the originals in m_pSourcePhrases
	m_pDoc->DeleteSourcePhrases(pOriginalList, TRUE); // TRUE means 'delete partner piles too'

    // deep copy across to pOriginalList the pointers to the CSourcePhrase instances which
    // are wanted for the sublist
    bOK = DeepCopySourcePhraseSublist(pSaveList, nBeginSequNum, nEndSequNum, pOriginalList);

	// inhibit printing the phrase box when printing a sublist, and store the active
	// sequence number for later one when RestoreOriginalList() is called in order to set
	// up the m_pSourcePhrases and m_pileList lists again, after range printing or
	// seletion printing is finished (the destructor ~AIPrintout()does this call)
	pApp->m_nSaveActiveSequNum = pApp->m_nActiveSequNum;
	pApp->m_nActiveSequNum = -1;

    // to make our refactored view code work correctly, the sequence numbers in the
    // CSourcePhrase instances now in m_pSourcePhrases have to be renumbered from zero, to
    // maintain the partnering of each CSourcePhrase with the CPile which points to it (the
    // second parameter for UpdateSequNumbers() is strictly speaking not needed, because
    // the only time we use it it points to m_pSourcePhrases anyway, but it's probably a
    // good idea to retain it to make the code a bit better at self-documenting what is
    // happening)
	pApp->GetDocument()->UpdateSequNumbers(0,pOriginalList);

	// inform RecalcLayout() that it won't need to work out a gap for the phrase box
	pLayout->SetBoxInvisibleWhenLayoutIsDrawn(TRUE);

	return bOK;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE, but FALSE if there was a printer error or failure to restore the
///             original list of CSourcePhrase instances
/// \param      pSaveList      -> the (full) list of source phrase items to be moved to
///                                pOriginalList
/// \param      pOriginalList  <- the existing sublist which is to be abandoned and
///                                replaced by the contents of pSaveList
/// \remarks
/// Called from: the AIPrintout's destructor. RestoreOriginalList() is called to restore
/// the original contents of the document's m_pSourcePhrases, after printing the document.
/// During the print operation, the original list from m_pSourcePhrases was stored/saved in
/// pSaveList. RestoreOriginalList() also restores the original active sequence number value
///
/// BEW changed 16Jul09, to support the refactored view code's design. CPile instances are
/// owned by CLayout, not by CStrip, and so for a range print or a selection print, we
/// needed to have separately stored in CLayout::m_pSavePileList the original list of
/// piles, so that CLayout::m_pileList can store just shallow copies of the range of
/// partner piles we need to deal with. After renumbering the m_nSequNumber member of the
/// subset of CSourcePhrase instances, RecalcLayout() will work correctly with what
/// appears to it to be a suddenly shorter, but valid, document. Then RestoreOriginalList
/// has to restore the original document state, putting back both the full set of
/// CSourcePhrase instances, and their partner piles. A call to UpdateSequNumbers() to
/// renumber them from the first CSourcePhrase instance is mandatory, because the shallow
/// copies will have had their m_nSequNumber values reset so that the first in the
/// subrange is 0, and that means a subrange of the original ones will have their sequence
/// number values reset to wrong values. So call UpdateSequNumbers(0) to get everything
/// back as it should be.
/// BEW 14Nov11, print chapter/verse range was not working (all platforms). So I've changed
/// to using deep copies. This means I don't need to save the layout's PileList, and the
/// pile list is recreated by the RecalcLayout() call passin in create_strips_and_piles
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RestoreOriginalList(SPList* pSaveList,SPList* pOriginalList)
// when called, pSaveList has the original (full) list, and pOriginalList has the sublist
// which we wish to abandon in the process of restoring the normal state
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();
	bool bOK = TRUE;

	// BEW changed 21Jul09: it can happen that this function is entered before the culling
	// of a range print's CSourcePhrases to just those needed for printing the range (and
	// the originals saved in m_pSaveList). One scenario I found for this was to do a
	// normal print, specify a range, and turn on and then off a checkbox such as the one
	// for suppressing a preceding header, then click Print to have the print go ahead,
	// but then when the physical print's Print Settings dialog shows, Cancel at that
	// point. The wxWidgets framework correctly calls ~AIPrintout() which is one of the
	// places where the DoPrintCleanup() function is called, and then because
	// gbPrintingRange is TRUE, RestoreOriginalList() is entered - but pOriginalPileList
	// still has the full list of the document's piles, and pSavePileList is empty. So we
	// have to test for this scenario and when we have such a situation, detect it and
	// just return TRUE immediately because there is no restoration required
	if (!pOriginalList->IsEmpty() && pSaveList->IsEmpty())
		return TRUE;

	wxASSERT(pSaveList->GetCount() > 0); // ensure the list is not empty
    // If the list is empty, which may happen if there is a range error, we don't want to
	// copy an empty pSaveList back over a populated pOriginalList
	if (wxPrinter::GetLastError() == wxPRINTER_ERROR)
		return FALSE;

	m_pDoc->DeleteSourcePhrases(pOriginalList, TRUE); // TRUE means 'delete partner piles too'

	// deep copy the saved list back to the original list (i.e. to m_pSourcePhrases list)
	int countOriginals = pSaveList->GetCount();
	bOK = DeepCopySourcePhraseSublist(pSaveList, 0, countOriginals - 1, pOriginalList);
	wxCHECK_MSG(bOK, FALSE, _T("RestoreOriginalList(): DeepCopySourcePhraseSublist() failed, line 3883 in Adapt_ItView.cpp, so the document won't have been restored to its original pre-print state. Shut down WITHOUT saving, and relaunch"));
	// restore the former active sequ number; CSourcePhrase m_nSequNumber values are
	// already correct
	pApp->m_nActiveSequNum = pApp->m_nSaveActiveSequNum;

	// renumber, to get m_nSequNumber members into the correct sequence again (the second
	// parameter for UpdateSequNumbers() is strictly speaking not needed, because the only
	// time we use it it points to m_pSourcePhrases anyway, but it's probably a good idea
	// to retain it to make the code a bit better at self-documenting what is happening)
	pApp->GetDocument()->UpdateSequNumbers(0,pOriginalList); // redundant, but harmless insurance

	// restore assumption that a gap will need to be calculated at the active pile when
	// RecalcLayout() is next called
	pLayout->SetBoxInvisibleWhenLayoutIsDrawn(FALSE);

	// the m_pSavedList contents are no longer needed, so delete them (no partner piles, so the
    // second param can be FALSE)
    m_pDoc->DeleteSourcePhrases(pSaveList, FALSE);

	// Note, with the 14Nov11 changes we have to call RecalcLayout() with create_strips_and_piles
	// rather than with create_strips_keep_piles
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     the m_chapterVerse member of pSrcPhrase
/// \param pSrcPhrase -> the source phrase whose m_chapterVerse member is to be retrieved
/// \remarks
/// Called from: the App's RefreshStatusBarInfo(), the Doc's
/// ReconstituteAfterFilteringChange(), ReconstituteAfterPunctuationChange(), the View's
/// DoConsistencyCheck() and OnEditSourceText().
/// Gets and returns the m_chapterVerse member of pSrcPhrase.
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::GetChapterAndVerse(CSourcePhrase *pSrcPhrase)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxString str; str.Empty();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList);
	int nActiveSequNum = pSrcPhrase->m_nSequNumber;
	SPList::Node* pos = pList->Item(nActiveSequNum); // get the position where this srcphrase is
	wxASSERT(pos != NULL);

	// loop backwards until come to start of a verse or chapter
	str = _T("0:0"); // a nonsense value which, if it gets displayed, tells us we've fouled up
	while (pos != NULL)
	{
		CSourcePhrase* pSP = (CSourcePhrase*)pos->GetData();
		pos = pos->GetPrevious(); // needed for our list
		if (pSP->m_bChapter || pSP->m_bVerse)
		{
			if (!pSP->m_chapterVerse.IsEmpty())
				str = pSP->m_chapterVerse;
			wxASSERT(!str.IsEmpty());
			break;
		}
	}
	return str;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if a valid c:v scripture reference substring has been constructed
///             in strChapVerse, else FALSE
/// \param      pList               -> a list of CSourcePhrase pointer instances (either
///                                    the current document, or a list constructed from
///                                    parsing in an XML document and storing in a
///                                    temporary SPList)
/// \param      pStartingSrcPhrase  -> pointer to the CSourcePhrase instance which defines
///                                    the current location relative to which we wish to
///                                    return the best possible (and nearest) ch:verse
///                                    substring
/// \param      strChapVerse        <- a scripture reference (minus the book code and
///                                    following space) in the form "Chapter:Verse" for
///                                    example "13:25"; or an empty string if the function
///                                    fails
/// \remarks
/// Called from: the View's SendScriptureReferenceFocusMessage(). Gets the current verse's
/// ch:v substring, or at least tries to do the best possible job of it that it can. The
/// pSrcPhrase defines a location (ie. a given sequence number) in the passed in pList of
/// CSourcePhrase instances (if looking in an active document, pList will be
/// pDoc->m_pSourcePhrases; but if scanning through a set of adaptation documents stored on
/// disk, pList will be a temporary SPList created for holding the list returned by parsing
/// in the XML (or *.adt) document file cryptically). First the function checks pSrcPhrase
/// for a non-empty m_chapterVerse member, if it finds it it puts it into strChapVerse and
/// we are done. If not, then the active location may be within a verse - so the function
/// scans back in pList to find the nearst previous pSrcPhrase instance with a non-empty
/// m_chapterVerse - returning that if it finds one; but if pSrcPhrase is near the start of
/// the document, there might be no previous such instance, so it then scans forward from
/// the passed in pSrcPhrase's location to get the nearest following non-empty
/// m_chapterVerse, and returns that. This algorithm means that we get a valid scripture
/// reference substring even if the active location is in something such as a subheading
/// part of the adaptation document (ie. information marked by \s). But if scanning both
/// backwards and forwards yields no non-empty m_chapterVerse member, we assume the
/// document was not created from a (U)SFM marked plain text source text file, and return
/// FALSE so that the caller will block sending an invalid scripture reference focus
/// message, or responding to one by looking in the document being tested for the location
/// to scroll to.
/// Note: CSourcePhrase instances can store, in their m_chapterVerse member, a chapter
/// followed by colon followed by a verse range - something in the form "13:12-15", or even
/// "13:12,15". When a substring like this has been found. We do not return it 'as is', but
/// rather extract the chapter number, colon, and first verse of the range - the rest is
/// not used in a scripture reference focus broadcast message, so we never send it in one.
/// The work of setting a valid "ch:verse" substring is done by the
/// MakeChapVerseStrForSynchronizedScroll() function defined in MainFrame.cpp.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetChapterAndVerse(SPList* pList, CSourcePhrase* pStartingSrcPhrase,
									   wxString& strChapVerse)
{
	CSourcePhrase* pSrcPhrase = NULL;
	wxString chvStr = _T("");
	if (!pStartingSrcPhrase->m_chapterVerse.IsEmpty())
	{
        // this CSourcePhrase instance has a ch:verse or ch:verse_range string, so produce
        // the scripture reference ch:verse substring
		chvStr = MakeChapVerseStrForSynchronizedScroll(pStartingSrcPhrase->m_chapterVerse);
		strChapVerse = chvStr;
		return TRUE;
	}
    // there was no chapter:verse information in the passed in CSourcePhrase instance, so
    // search for it in the neighbourhood - preferably in the preceding neighbourhood, but
    // if not there, then in the following neighbourhood
	SPList::Node* pos = pList->Item(pStartingSrcPhrase->m_nSequNumber);
	SPList::Node* savePos = pos;
	if (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData(); // ignore this one, it is
													 // same as pStartingSrcPhrase
		pos = pos->GetPrevious();
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetPrevious();
			if (!pSrcPhrase->m_chapterVerse.IsEmpty())
			{
                // this CSourcePhrase instance has a ch:verse or ch:verse_range string, so
                // produce the scripture reference ch:verse substring
				chvStr = MakeChapVerseStrForSynchronizedScroll(pSrcPhrase->m_chapterVerse);
				strChapVerse = chvStr;
				return TRUE;
			}
		}
		// didn't find it in the previous neighbourhood, so try again looking ahead instead
		pos = savePos;
		pSrcPhrase = (CSourcePhrase*)pos->GetData(); // ignore this one, it is
													 // same as pStartingSrcPhrase
		pos = pos->GetNext();
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (!pSrcPhrase->m_chapterVerse.IsEmpty())
			{
                // this CSourcePhrase instance has a ch:verse or ch:verse_range string, so
                // produce the scripture reference ch:verse substring
				chvStr = MakeChapVerseStrForSynchronizedScroll(pSrcPhrase->m_chapterVerse);
				strChapVerse = chvStr;
				return TRUE;
			}
		}
		// if control reaches here, then there was no c:v information to be had,
		// so return FALSE
		strChapVerse = chvStr;
		return FALSE; // could not find pSrcPhrase's location in the pList list
	}
	else
	{
		strChapVerse = chvStr;
		return FALSE; // could not find pSrcPhrase's location in the pList list
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pList		->	a list of CSourcePhrase pointer instances (either the current
///                             document, or a list constructed from parsing in an XML document
///                             and storing in a temporary SPList)
/// \param      pSrcPhrase	->	pointer to the CSourcePhrase instance which defines the current
///                             location
/// \remarks
/// Called from: the CPhraseBox::MoveToNextPile() function.
/// This is the function which does the work of determining if a scripture reference focus
/// message needs to be sent, for the current location as defined by where pSrcPhrase
/// happens to be in the document's pList (the list could be pDoc->m_pSourcePhrases, or a
/// tempory SPList pointer used for checking a document not currently open). Internally,
/// the function checks the global CStrings: gOldChapVerseStr and gCurChapVerseStr, and if
/// these are not different then a message is not sent; but if they are, then the message
/// will be sent provided the global bool gbIgnoreScriptureReference_Send is FALSE (the
/// function call needs to be wrapped by an if (!gbIgnoreScriptureReference_Send) test --
/// because the GUI command sets or clears this boolean). Also, internally the overloaded
/// version of the GetChapterAndVerse() function, which returns TRUE if successful and
/// FALSE otherwise, is called - and if FALSE is returned then no message is sent. If the
/// current document has no (U)SFM markup, or no 3-letter book code at the start of the
/// pList entries, then the latter function will return FALSE and so no message will ever
/// be sent for a document file which is not built from a properly constituted and marked
/// up scripture text file.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::SendScriptureReferenceFocusMessage(SPList* pList, CSourcePhrase* pSrcPhrase)
{
	wxASSERT(pList != NULL);
	wxASSERT(pSrcPhrase != NULL);
	wxString strChVerse = _T("");
	bool bAllIsOK = GetChapterAndVerse(pList, pSrcPhrase, strChVerse);
	if (!bAllIsOK)
	{
		return; // don't send any message
	}
	if (gOldChapVerseStr == strChVerse)
	{
        // the currently found scripture reference substring does not differ from that in
        // the last sent message, so don't resend it
		return;
	}
    // so are all is well, next, try to get the 3-letter code for the scripture book - the
    // function for doing this returns FALSE if the code does not exist, or is invalid. The
    // code returned is upper case always (the function forces this internally)
	wxString strBookCode = _T("");
	bool bValidCode = Get3LetterCode(pList,strBookCode);
	if (!bValidCode)
	{
		// the code is either invalid or is not in the document, so we cannot send a valid
		// sync message
		return;
	}
    // we have a valid substring, and the reference is different than for the last one, so
    // send it (but this function won't be called if the global
    // gbIgnoreScriptureReference_Send is TRUE, so if control has got to here, then the
    // global is FALSE and sending is wanted by the user)
	SyncScrollSend(strBookCode, strChVerse);

	// finally, update the global wxString which remembers what the this chap:verse
	// reference was
	gOldChapVerseStr = strChVerse;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if we have chapter:verse form, FALSE if the document has no chapters
/// \param      s               <- a wxString representing the source phrase's m_chapterVerse member
/// \param      nChapter        <- an int representing the chapter number
/// \param      nVerse          <- an int representing the verse number (or 1st verse in a range); 0 if
///                                no verses are indicated
/// \param      bHasChapters    <- a bool TRUE if chapter numbers are present FALSE otherwise
/// \param      bIsVerseRange   <- a bool TRUE if there is a range of verses indicated, FALSE otherwise
/// \param      nFinalVerse     <- an int representing the final verse in a range
/// \remarks
/// Called from: the View's SetupRangePrintOp().
/// The usual form for s's contents is n:m where n is a chapter number, and m a verse
/// number, and bIsVerseRange will be set to FALSE; - s is a reference to the source
/// phrase's m_chapterVerse member. However, the contents could be just a verse number (eg.
/// Book without chapters, such as 2John etc), or n:p-q (for a range of verses), or n:p,q
/// (an alternative style for a range) so for the standard situation we set nChapter to n,
/// nVerse to m, and return TRUE; but for a book with no chapters we return FALSE, and
/// nVerse will have the verse number, or 0 if there are no verses; for the range
/// possibilities nVerse will have p the first verse in the range, nFinalVerse will have q
/// (the end verse in the range), and bIsVerseRange will be set to TRUE.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ExtractChapterAndVerse(wxString& s,int& nChapter,int& nVerse,
							bool& bHasChapters,bool& bIsVerseRange,int& nFinalVerse)
{
	bHasChapters = FALSE;
	bIsVerseRange = FALSE;
	nFinalVerse = 0;
	nChapter = 0;
	nVerse = 0;
	wxString chStr;
	wxString vStr;
	chStr.Empty();
	vStr.Empty();
	wxChar colon = _T(':');
	bool bIsOK = TRUE;
	int nHasChapters = s.Find(colon);
	if (nHasChapters > -1)
	{
		bHasChapters = TRUE;
		chStr = s.Left(nHasChapters);
		wxASSERT(!chStr.IsEmpty());
	}
	if (bHasChapters)
	{
		nChapter = wxAtoi(chStr);
		vStr = s.Mid(nHasChapters + 1);
	}
	else
	{
		// has no chapters, so string must only be a verse number, or number range
		vStr = s;
	}
	wxASSERT(!vStr.IsEmpty());
	if (vStr.IsEmpty())
		return FALSE; // error, so ignore this chap/verse string
	wxString tempStr = vStr;

	// now determine the verse, or verse range
	wxChar hyphen = _T('-');
	wxChar comma = _T(',');
	wxString leftStr;
	wxString rightStr;
	leftStr.Empty();
	rightStr.Empty();
	int	  nHyphenOffset = -1;
	int   nCommaOffset =  vStr.Find(comma);
	if (nCommaOffset == -1)
	{
		// has no comma in the string, so test now for a hyphen
		nHyphenOffset =  vStr.Find(hyphen);
		if (nHyphenOffset == -1)
		{
			// doesn't have a hyphen in the string, so it should only be a verse number
			nVerse = wxAtoi(vStr); // reads digits only until first non-digit, so safe
			//ASSERT(nVerse > 0 && nVerse <= 176); // bible verses are between 1 and about 176
												 // as in (Psalm 119)
            //for version 2.0.5 and onward, we'll allow any value for max verse number,
            //since document may not be scripture, but nevertheless be versified for use by
            //Adapt It eg. film script
			return bIsOK;
		}
		else
		{
			// does have a hyphen, so there must be a range
			bIsVerseRange = TRUE;
			leftStr = vStr.Left(nHyphenOffset);
			wxASSERT(leftStr.Length() > 0);
			nVerse = wxAtoi(leftStr);
			rightStr = vStr.Mid(nHyphenOffset + 1);
			wxASSERT(rightStr.Length() > 0);
			nFinalVerse = wxAtoi(rightStr);
			return bIsOK;
		}
	}
	else
	{
		// has a comma, so there must be a range
		bIsVerseRange = TRUE;
		leftStr = vStr.Left(nCommaOffset);
		wxASSERT(leftStr.Length() > 0);
		nVerse = wxAtoi(leftStr);
a:		rightStr = tempStr.Mid(nCommaOffset + 1);
		wxASSERT(rightStr.Length() > 0);
		// there might be more - continue till we find the final substring in p,q,r,s etc
		nCommaOffset = rightStr.Find(comma);
		if (nCommaOffset > -1)
		{
			// we are not at the rightmost one yet, so iterate
			tempStr = tempStr.Mid(nCommaOffset + 1);
			wxASSERT(tempStr.Length() > 0);
			goto a;
		}
		nFinalVerse = wxAtoi(rightStr);
		return bIsOK;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     the source phrase's m_nSequNumber which has the start of a section heading
/// \param      nStartingSequNum    -> an int representing the starting sequence number
/// \param      startingPos         <- an SPList node representing the starting position in pList
/// \param      pList               <- the source phrase list (not referenced directly, only via
///                                    the startingPos node)
/// \remarks
/// Called from: the View's SetupRangePrintOp().
/// Scans backwards from the starting position looking for a source phrase with a section
/// head marker indicating that it is the start of a preceding section heading.
/////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItView::IncludeAPrecedingSectionHeading(int nStartingSequNum, SPList::Node* startingPos,
												   SPList* WXUNUSED(pList))
{
	// whm revised 15Feb05 to include all markers of sectionHead textType
	CAdapt_ItApp* pApp = &wxGetApp();
	int nOldSN = nStartingSequNum;
	SPList::Node* pos = startingPos;
    // whm Note: since startingPos is a node already pointing into pList, pList doesn't
    // here need to be explicitly referenced, just call pos->GetData() to return the
    // pSrcPhrase at pos in pList.
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetPrevious();
	wxASSERT(pSrcPhrase);
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markerStr;
	wxString nonFilteredMkrs;

	while (pos != NULL)
	{
		pSrcPhrase = pos->GetData();
		pos = pos->GetPrevious();
		wxASSERT(pSrcPhrase);

		if (!pSrcPhrase->m_chapterVerse.IsEmpty())
		{
            // we have come to the start of a preceding verse without encountering any
            // section heading
			break;
		}

        // it is not possible for a section heading to be within a merged source phrase, so
        // we do not need to check for medial markers; so just check contents of the
        // m_markers attribute
		if (!pSrcPhrase->m_markers.IsEmpty())
		{
			// whm added 14Feb05 in support of USFM and SFM Filtering
			markerStr = pSrcPhrase->m_markers;
			nonFilteredMkrs = pDoc->GetUnFilteredMarkers(markerStr);
			// NormalizeToSpaces leaves the markers in m_markers delimited by spaces, at
			// lease medially. We'll use the wxStringTokenizer method here.
			wxString sfm;
			wxStringTokenizer tkz(markerStr,_T(" "));

			while (tkz.HasMoreTokens())
			{
				sfm = tkz.GetNextToken();
				if (sfm[0] == gSFescapechar)	// Only check actual sfms. Some
                    // tokens will be only numbers (those after \c and \v) which we ignore
				{
					sfm.Trim(TRUE); // trim right end
					sfm.Trim(FALSE); // trim left end
						sfm += _T(' '); // ensure the sfm is followed by a space
                                        // for unique find in our wrap strings.
					// If only one of the sfms within m_markers is a wrap
					// marker, we should return TRUE.
					switch (pApp->gCurrentSfmSet)
					{
						case UsfmOnly:
						{
							if (pApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
								// there is a section marker, so we have found the
								// start of a section heading
								return pSrcPhrase->m_nSequNumber;
							break;
						}
						case PngOnly:
						{
							if (pApp->PngSectionHeadMarkersStr.Find(sfm) != -1)
								// there is a section marker, so we have found the
								// start of a section heading
								return pSrcPhrase->m_nSequNumber;
							break;
						}
						case UsfmAndPng:
						{
							if (pApp->UsfmAndPngSectionHeadMarkersStr.Find(sfm) != -1)
								// there is a section marker, so we have found the
								// start of a section heading
								return pSrcPhrase->m_nSequNumber;
							break;
						}
						default:
						{
							// if we got here it would be a program error
							if (pApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
								return pSrcPhrase->m_nSequNumber;
						}
					}
				}
			}
		}
	}
	// if we get here, we couldn't find a preceding section heading
	return nOldSN;
}


/////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if the range op fouled up, otherwise TRUE
/// \param      nBeginSequNum     -> sequence number for the first CSourcePhrase in the range
/// \param      nEndSequNum       -> sequence number for the last CSourcePhrase in the range
/// \param      pPrintData        -> the printer's wxPrintData struct, filled out <<- unused
///                                     we get the value directly from the app (see below)
/// \remarks
/// Called from: view's DoRangePrintOp(); and in the Linux build only, called from a function
/// to handle the printing of a range of pages -- because the page range support in wxGnomeprinter
/// is broken; so we have to get a range print done similarly to the way Bill coded for a
/// chapter/verse range -- the latter converts chapter/verse bounds to sequence numbers for
/// range begining and end, and then uses those; so this DoRangePrintOp() function handles
/// the job from that point onwards. Our __WXGTK__ build function can then call it.
/// NOTE: this function must be entered only once per entrance later on to DoPrintCleanup(),
/// otherwise, double entry but only one cleanup would result in part of the document
/// being lost, and probably a crash
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::DoRangePrintOp(const int nRangeStartSequNum, const int nRangeEndSequNum,
                                   wxPrintData* WXUNUSED(pPrintData))
{
    CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();
	SPList* pList = pApp->m_pSourcePhrases;
	SPList* pSaveList = pApp->m_pSaveList;

	// we have the required range of sequence numbers, so we can reuse the selection code here
	bool bIsOK = GetSublist(pSaveList, pList, nRangeStartSequNum, nRangeEndSequNum);

	// recalc the layout with the shorter range masquerading as the whole document
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pList, create_strips_and_piles);
#else
	pLayout->RecalcLayout(pList, create_strips_and_piles);
#endif

	// hide the box, and set safe values for a non-active location (leave m_targetPhrase
	// untouched)
	pApp->m_pActivePile = NULL;
	pApp->m_nActiveSequNum = -1;
	// wm: I don't think the phrase box needs to be hidden here

	// The stuff below could go into a separate function -
	// see also CPrintOptionsDlg::InitDialog
	// Determine the length of the printed page in logical units.
	int pageHeightBetweenMarginsMM; // pageWidthBetweenMarginsMM; // not used
	wxSize paperSize_mm;
	paperSize_mm = pApp->pPgSetupDlgData->GetPaperSize();
	wxASSERT(paperSize_mm.x != 0);
	wxASSERT(paperSize_mm.y != 0);
     // We should also have valid (non-zero) margins stored in our pPgSetupDlgData object.
	wxPoint topLeft_mm, bottomRight_mm; // MFC uses CRect for margins, wx uses wxPoint
	topLeft_mm = pApp->pPgSetupDlgData->GetMarginTopLeft(); // returns  top (y)
								// and left (x) margins as wxPoint in milimeters
	bottomRight_mm = pApp->pPgSetupDlgData->GetMarginBottomRight(); // returns bottom (y)
								// and right (x) margins as wxPoint in milimeters
	wxASSERT(topLeft_mm.x != 0);
	wxASSERT(topLeft_mm.y != 0);
	wxASSERT(bottomRight_mm.x != 0);
	wxASSERT(bottomRight_mm.y != 0);
    // The size data returned by GetPageSizeMM is not the actual paper size edge to edge,
    // nor the size within the margins, but it is the usual printable area of a paper,
    // i.e., the limit of where most printers are physically able to print; it is the area
    // in between the actual paper size and the usual margins. We therefore start with the
    // raw paperSize and determine the intended print area between the margins.
	//pageWidthBetweenMarginsMM = paperSize_mm.x - topLeft_mm.x - bottomRight_mm.x;
	pageHeightBetweenMarginsMM = paperSize_mm.y - topLeft_mm.y - bottomRight_mm.y;

    // Now, convert the pageHeightBetweenMarginsMM to logical units for use in calling
    // PaginateDoc.
    //
	// Get the logical pixels per inch of screen and printer.
    // whm NOTE: We can't yet use the wxPrintout::GetPPIScreen() and GetPPIPrinter()
    // methods because the wxPrintout object is not created yet at the time this print
    // options dialog is displayed. But, we can do the same calculations by using the
    // wxDC::GetPPI() method call on both a wxPrinterDC and a wxClientDC of our canvas.
	//
    // Set up printer and screen DCs and determine the scaling factors between printer and screen.
	wxASSERT(pApp->pPrintData->IsOk());

#ifdef __WXGTK__
	// Linux requires we use wxPostScriptDC rather than wxPrinterDC
	// Note: If the Print Preview display is drawn with text displaced up and off the display on wxGTK,
	// the wxWidgets libraries probably were not configured properly. They should have included a
	// --with-gnomeprint parameter in the configure call.
	wxPostScriptDC printerDC(*pApp->pPrintData); // MUST use * here otherwise printerDC will not be initialized properly
#else
	wxPrinterDC printerDC(*pApp->pPrintData); // MUST use * here otherwise printerDC will not be initialized properly
#endif

	wxASSERT(printerDC.IsOk());
	wxSize printerSizePPI = printerDC.GetPPI(); // gets the resolution of the printer in pixels per inch (dpi)
	wxClientDC canvasDC(pApp->GetMainFrame()->canvas);
	wxSize canvasSizePPI = canvasDC.GetPPI(); // gets the resolution of the screen/canvas in pixels per inch (dpi)
	float scale = (float)printerSizePPI.GetHeight() / (float)canvasSizePPI.GetHeight();

    // Calculate the conversion factor for converting millimetres into logical units. There
    // are approx. 25.4 mm to the inch. There are ppi device units to the inch. Therefore 1
    // mm corresponds to ppi/25.4 device units. We also divide by the screen-to-printer
    // scaling factor, because we need to unscale to pass logical units to PaginateDoc.
	float logicalUnitsFactor = (float)(printerSizePPI.GetHeight()/(scale*25.4));
									// use the more precise conversion factor
	int nPagePrintingLengthLU; //, nPagePrintingWidthLU; // unused
	//nPagePrintingWidthLU = (int)(pageWidthBetweenMarginsMM * logicalUnitsFactor);
	nPagePrintingLengthLU = (int)(pageHeightBetweenMarginsMM * logicalUnitsFactor);
	// The stuff above could go into a separate function - see also CPrintOptionsDlg::InitDialog

	gnPrintingLength = nPagePrintingLengthLU; //nPrintingLength;

	// Footer adjustments and printing are done in the View's PrintFooter() function

	// do pagination
	//
    // whm: In the following call to PaginateDoc, we use the current m_nStripCount stored
    // on pBundle, because the PaginateDoc() call here is done within SetupRangePrintOp()
    // which is called after the print dialog has been dismissed with OK, and thus we are
    // paginating the actual doc to print and not merely simulating it for purposes of
    // getting the pages edit box values for the print options dialog.
	bIsOK = PaginateDoc(pLayout->GetStripArray()->GetCount(), nPagePrintingLengthLU);
													// doesn't call RecalcLayout()
	if (!bIsOK)
	{
		wxMessageBox(_T("Pagination failed."),_T(""), wxICON_STOP);
		return FALSE;
	}

	wxPrintDialogData printDialogData(*pApp->pPrintData);
	// pagination succeeded, so set the initial values
	int nTotalPages = pApp->m_pagesList.GetCount();
	printDialogData.SetMaxPage(nTotalPages);
	printDialogData.SetMinPage(1);
	printDialogData.SetFromPage(1);
	printDialogData.SetToPage(nTotalPages);

   return TRUE;
}

#if defined(__WXGTK__)
bool CAdapt_ItView::SetupPageRangePrintOp(const int nFromPage, int nToPage, wxPrintData* pPrintData)
{
    CAdapt_ItApp* pApp = &wxGetApp();
    POList* pList = &pApp->m_pagesList;
    int count;
    count = pList->GetCount();
    if (count < 1)
    {
        // there has to be a range
        return FALSE;
    }
    int nFromSequNum = -1;
    int nToSequNum = -1;
    // find the sequence number of the first pile in the top strip in the nFromPage
    // PageOffsets struct
    POList::Node* pos = pList->Item(nFromPage - 1);
    PageOffsets* pPageOffsets = pos->GetData();
    int nFirstStrip = pPageOffsets->nFirstStrip;
    CLayout* pLayout = pApp->GetLayout();
    wxArrayPtrVoid* pStrips = pLayout->GetStripArray();
    CStrip* pStrip = (CStrip*)pStrips->Item(nFirstStrip);
    CPile* pPile = pStrip->GetPileByIndex(0);
    CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
    nFromSequNum = pSrcPhrase->m_nSequNumber;
    wxASSERT(nFromSequNum >= (int)0 && nFromSequNum < (int)pApp->m_pSourcePhrases->GetCount());
    // find the sequence number of the last pile in the last strip in the nToPage
    // PageOffsets struct
    // BEWARE: pagination for the print options dialog was done on the assumption that if the
    // document has free translations and/or glosses, they'd be wanted, and they increase the
    // pages needed for printint the whole doc. If the user selects are range of pages, and also
    // deselects printing of free translations and/or glosses, we can arrive at a situation where
    // he gives a final page number which can never be reached, because with no free trans or
    // glosses the pages needed are fewer, and his choice for the last page may lie beyond the
    // last actual page. So here we must check how many we've got, and adjust the last value
    // smaller if necessary.
    if (nToPage > count)
    {
        nToPage = count;
    }

    pos = pList->Item(nToPage - 1);
    pPageOffsets = pos->GetData();
    int nLastStrip = pPageOffsets->nLastStrip;
    pStrip = (CStrip*)pStrips->Item(nLastStrip);
    wxArrayPtrVoid* pPilesArray = pStrip->GetPilesArray();
    int pileCount = pPilesArray->GetCount();
    pPile = pStrip->GetPileByIndex(pileCount - 1);
    pSrcPhrase = pPile->GetSrcPhrase();
    nToSequNum = pSrcPhrase->m_nSequNumber;
    wxASSERT(nToSequNum >= (int)0 && nToSequNum >= nFromSequNum && nToSequNum < (int)pApp->m_pSourcePhrases->GetCount());

    // get this range printed
    bool bOK = DoRangePrintOp(nFromSequNum, nToSequNum, pPrintData);
    return bOK;
}
#endif

/////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if the range could not be determined or found, otherwise TRUE
/// \param      nFromCh     -> an int representing the chapter at the beginning of the range
/// \param      nFromV      -> an int representing the verse at the beginning of the range
/// \param      nToCh       -> an int representing the chapter at the end of the range
/// \param      nToV        -> an int representing the verse at the end of the range
/// \param      pPrintData  -> (unused)
/// \param      bSuppressPrecedingHeadingInRange  -> (unused)
/// \param      bIncludeFollowingHeadingInRange   -> (unused)
/// \remarks
/// Called from: the View's OnPrint() high level handler after the standard print dialog's
/// OK button has been pressed. Determines the sequence numbers for the indicated chapter
/// and verse range and gets the appropriate sublist of source phrases making up that
/// range. From this data it calls RecalcLayout to format the printout for the correct
/// width, and PaginateDoc().
/// BEW 14Nov11, fixed errors in printing a chapter/verse range (errors on all platforms),
/// mainly by using deep copies for saving m_pSourcePhrases, and creating sublist
/// NOTE: this function must be entered only once per entrance later on to DoPrintCleanup(),
/// otherwise, double entry but only one cleanup would result in part of the document
/// being lost, and probably a crash. I removed the WXUNUSED() - Bill's code uses thse
/// 3 params.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::SetupRangePrintOp(const int nFromCh, const int nFromV, const int nToCh,
									  const int nToV, wxPrintData* pPrintData,
									  bool WXUNUSED(bSuppressPrecedingHeadingInRange),
									  bool WXUNUSED(bIncludeFollowingHeadingInRange))
//bool CAdapt_ItView::SetupRangePrintOp(const int nFromCh, const int nFromV, const int nToCh,
//									  const int nToV, wxPrintData* pPrintData,
//									  bool bSuppressPrecedingHeadingInRange,
//									  bool bIncludeFollowingHeadingInRange)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	//CLayout* pLayout = GetLayout();
	pPrintData = pPrintData; // to avoid a spurious compiler warning

	// whm revised 8Mar08 to correct logic of tests for range inclusion
	if (pApp->m_selectionLine != -1)
		RemoveSelection();
	SPList* pList = pApp->m_pSourcePhrases;
	//SPList* pSaveList = pApp->m_pSaveList;
	wxASSERT(nFromCh >= 0);
	wxASSERT(nToCh >= 0);
	wxASSERT(nFromV >= 1);
	wxASSERT(nToV >= 1);
	wxASSERT(nToCh >= nFromCh);

	// check we have a legal range
	if (nFromCh < 0 || nToCh < 0 || nToCh < nFromCh || nToV < 1 || nFromV < 1)
	{
		// IDS_ILLEGAL_RANGE
		wxMessageBox(_("Sorry, the range you specified is illegal. Try again."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}
	else if (nFromCh == nToCh && nToV < nFromV)
	{
		// IDS_ILLEGAL_RANGE
		wxMessageBox(_("Sorry, the range you specified is illegal. Try again."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}

	int nCh = 0;
	int nV = 0;
	bool bIsVRange = FALSE;
	bool bHasChapters = FALSE;
	int nFinalV = 0;
	SPList::Node* posEnd = NULL;
	SPList::Node* savePos = NULL;

	// find the beginning and ending sequence numbers for the range
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)NULL;
	SPList::Node* pos = pList->GetFirst();
	while (pos != NULL)
	{
		savePos = pos;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		wxString chv = pSrcPhrase->m_chapterVerse;
		if (chv.IsEmpty())
			continue;
		else
		{
			// we are at the start of a verse - see if it is where we want to start
			bool bOK = ExtractChapterAndVerse(chv,nCh,nV,bHasChapters,bIsVRange,nFinalV);

            // if something went wrong, just ignore the chapter and verse - and hope it
            // wasn't the range start!
			if (!bOK)
				continue;
			else
			{
				// test what we found
				if (bHasChapters)
				{
					if (nCh != nFromCh)
						continue;
					else
					{
						// we are in the wanted chapter, so test the verse values
						if (bIsVRange)
						{
							// for a verse range, start printing here if the verse falls within
							// the verse range
							if (nFromV >= nV && nFromV <= nFinalV)
							{
								// we have found the start of the printing range, so check for a
								// preceding section heading, and include it if the suppression
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos; // the position of the current source
														   // phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
														nCurSequNumber, oldPos, pList);
								}

								// set the global for the sequence number of the start of the range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nFromV == nV)
							{
								// we have found the start of the printing range, so check for a
								// preceding section heading, and include it if the suppression
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos;	// the position of the current source
																// phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
																nCurSequNumber, oldPos, pList);
								}

								// set the global for the sequence number of the start of the
								// printing range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
					}
				}
				else
				{
                    // does not have chapters, so all we can test for is verses (ignore
                    // chapter number if the user typed one in the dialog, provided it is 0
                    // or 1)
					if (nFromCh > 1)
					{
						// IDS_NO_CHAPTERS
						wxMessageBox(_(
"Error: a chapter number was specified, but this document does not appear to contain chapter specifications. The print operation has been aborted."),
						_T(""), wxICON_STOP);
						return FALSE; // error condition, non-zero chapter number,
									  // but doc has no chapters
					}
					else
					{
						// try test the verse now, since chapter number is either 0 or 1 & is
						// being ignored
						if (bIsVRange)
						{
							// for a verse range, start printing here if the verse falls within
							// the verse range
							if (nFromV >= nV && nFromV <= nFinalV)
							{
								// we have found the start of the printing range, so check for a
								// preceding section heading, and include it if the suppression
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos; // the position of the current source
														   // phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
															nCurSequNumber, oldPos, pList);
								}

								// set the global for the sequence number of the start of the range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nFromV == nV)
							{
								// we have found the start of the printing range, so check for a
								// preceding section heading, and include it if the suppression
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos; // the position of the current source
														   // phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
															nCurSequNumber, oldPos, pList);
								}

								// set the global for the sequence number of the start of the range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
					}
				}
			}
		}
	}

	// if we get here, we didn't find the start of the range - this is an error condition,
	// so abort the print
	//IDS_RANGE_START_FAILURE
	wxMessageBox(_(
"Error: the specified chapter and verse for the start of the printing range could not be found. The print operation has been aborted."),
	_T(""), wxICON_STOP);
	return FALSE;

	// now continue searching for the end of the printing range
	// first check in case the end chapter and end verse is the same as the start ones
b:	if (bHasChapters)
	{
		if (nCh != nToCh)
			goto d; // end chapter is different from starting one, so keep looking
		else
		{
			// we are in the wanted chapter, so test the verse values
			if (bIsVRange)
			{
				// for a verse range, end printing here if the verse falls within the verse range
				if (nToV >= nV && nToV <= nFinalV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != NULL);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
			else
			{
				// it's not a range, so see if the verse number matches this one
				if (nToV == nV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != NULL);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
		}
	}
	else
	{
        // does not have chapters, so all we can test for is verses (ignore chapter number
        // if the user typed one in the dialog, provided it is 0 or 1)
		if (nToCh > 1)
		{
			// IDS_NO_CHAPTERS
			wxMessageBox(_(
"Error: a chapter number was specified, but this document does not appear to contain chapter specifications. The print operation has been aborted."),
			_T(""), wxICON_STOP);
			return FALSE; // error condition, non-zero or non-1 chapter number,
						  // but doc has no chapters
		}
		else
		{
			// try test the verse now, since chapter number is either 0 or 1 & is being ignored
			if (bIsVRange)
			{
				// for a verse range, end printing here if the verse falls within the verse range
				if (nToV >= nV && nToV <= nFinalV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != NULL);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
			else
			{
				// it's not a range, so see if the verse number matches this one
				if (nToV == nV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != 0);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
		}
	}

d:	;

	while (pos != 0)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		wxString chv = pSrcPhrase->m_chapterVerse;
		if (chv.IsEmpty())
			continue;
		else
		{
			// we are at the start of a verse - see if it is where we want to end the printing
			bool bOK = ExtractChapterAndVerse(chv,nCh,nV,bHasChapters,bIsVRange,nFinalV);

			// if something went wrong, just ignore the chapter and verse - and hope it wasn't
			// the range end!
			if (!bOK)
				continue;
			else
			{
				// test what we found
				if (bHasChapters)
				{
					if (nCh != nToCh)
						continue;
					else
					{
						// we are in the wanted chapter, so test the verse values
						if (bIsVRange)
						{
							// for a verse range, end printing here if the verse falls within
							// the verse range
							if (nToV >= nV && nToV <= nFinalV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != 0);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto e;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nToV == nV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != 0);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
					}
				}
				else
				{
                    // does not have chapters, so all we can test for is verses (ignore
                    // chapter number if the user typed one in the dialog, provided it is 0
                    // or 1)
					if (nToCh > 1)
					{
						// IDS_NO_CHAPTERS
						wxMessageBox(_(
"Error: a chapter number was specified, but this document does not appear to contain chapter specifications. The print operation has been aborted."),
						_T(""), wxICON_STOP);
						return FALSE; // error condition, non-zero chapter number,
									  // but doc has no chapters
					}
					else
					{
						// try test the verse now, since chapter number is either 0 or 1 & is
						// being ignored
						if (bIsVRange)
						{
							// for a verse range, end printing here if the verse falls within
							// the verse range
							if (nToV >= nV && nToV <= nFinalV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != NULL);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto e;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nToV == nV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != NULL);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto e;
							}
							else
								continue; // iterate
						}
					}
				}
			}
		}
	}

    // if we get here, we didn't find the end of the range - this is an error condition, so
    // abort the print
	// IDS_RANGE_END_FAILURE
	wxMessageBox(_(
"Error: the specified chapter and verse for the end of the printing range could not be found. The print operation has been aborted."),
	_T(""), wxICON_STOP);
	return FALSE;

	// we have the required range of sequence numbers, so we can reuse the selection code here
e:	;
    bool bIsOk = DoRangePrintOp(gnRangeStartSequNum, gnRangeEndSequNum, pPrintData);
    return bIsOk;

/*
    bool bIsOK = GetSublist(pSaveList, pList, gnRangeStartSequNum, gnRangeEndSequNum);

	// recalc the layout with the shorter range masquerading as the whole document
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pList, create_strips_and_piles);
#else
	pLayout->RecalcLayout(pList, create_strips_and_piles);
#endif

	// hide the box, and set safe values for a non-active location (leave m_targetPhrase
	// untouched)
	pApp->m_pActivePile = NULL;
	pApp->m_nActiveSequNum = -1;
	// wm: I don't think the phrase box needs to be hidden here

	// The stuff below could go into a separate function -
	// see also CPrintOptionsDlg::InitDialog
	// Determine the length of the printed page in logical units.
	int pageWidthBetweenMarginsMM, pageHeightBetweenMarginsMM;
	wxSize paperSize_mm;
	paperSize_mm = pApp->pPgSetupDlgData->GetPaperSize();
	wxASSERT(paperSize_mm.x != 0);
	wxASSERT(paperSize_mm.y != 0);
     // We should also have valid (non-zero) margins stored in our pPgSetupDlgData object.
	wxPoint topLeft_mm, bottomRight_mm; // MFC uses CRect for margins, wx uses wxPoint
	topLeft_mm = pApp->pPgSetupDlgData->GetMarginTopLeft(); // returns  top (y)
								// and left (x) margins as wxPoint in milimeters
	bottomRight_mm = pApp->pPgSetupDlgData->GetMarginBottomRight(); // returns bottom (y)
								// and right (x) margins as wxPoint in milimeters
	wxASSERT(topLeft_mm.x != 0);
	wxASSERT(topLeft_mm.y != 0);
	wxASSERT(bottomRight_mm.x != 0);
	wxASSERT(bottomRight_mm.y != 0);
    // The size data returned by GetPageSizeMM is not the actual paper size edge to edge,
    // nor the size within the margins, but it is the usual printable area of a paper,
    // i.e., the limit of where most printers are physically able to print; it is the area
    // in between the actual paper size and the usual margins. We therefore start with the
    // raw paperSize and determine the intended print area between the margins.
	pageWidthBetweenMarginsMM = paperSize_mm.x - topLeft_mm.x - bottomRight_mm.x;
	pageHeightBetweenMarginsMM = paperSize_mm.y - topLeft_mm.y - bottomRight_mm.y;

    // Now, convert the pageHeightBetweenMarginsMM to logical units for use in calling
    // PaginateDoc.
    //
	// Get the logical pixels per inch of screen and printer.
    // whm NOTE: We can't yet use the wxPrintout::GetPPIScreen() and GetPPIPrinter()
    // methods because the wxPrintout object is not created yet at the time this print
    // options dialog is displayed. But, we can do the same calculations by using the
    // wxDC::GetPPI() method call on both a wxPrinterDC and a wxClientDC of our canvas.
	//
    // Set up printer and screen DCs and determine the scaling factors between printer and screen.
	wxASSERT(pApp->pPrintData->IsOk());

#ifdef __WXGTK__
	// Linux requires we use wxPostScriptDC rather than wxPrinterDC
	// Note: If the Print Preview display is drawn with text displaced up and off the display on wxGTK,
	// the wxWidgets libraries probably were not configured properly. They should have included a
	// --with-gnomeprint parameter in the configure call.
	wxPostScriptDC printerDC(*pApp->pPrintData); // MUST use * here otherwise printerDC will not be initialized properly
#else
	wxPrinterDC printerDC(*pApp->pPrintData); // MUST use * here otherwise printerDC will not be initialized properly
#endif

	wxASSERT(printerDC.IsOk());
	wxSize printerSizePPI = printerDC.GetPPI(); // gets the resolution of the printer in pixels per inch (dpi)
	wxClientDC canvasDC(pApp->GetMainFrame()->canvas);
	wxSize canvasSizePPI = canvasDC.GetPPI(); // gets the resolution of the screen/canvas in pixels per inch (dpi)
	float scale = (float)printerSizePPI.GetHeight() / (float)canvasSizePPI.GetHeight();

    // Calculate the conversion factor for converting millimetres into logical units. There
    // are approx. 25.4 mm to the inch. There are ppi device units to the inch. Therefore 1
    // mm corresponds to ppi/25.4 device units. We also divide by the screen-to-printer
    // scaling factor, because we need to unscale to pass logical units to PaginateDoc.
	float logicalUnitsFactor = (float)(printerSizePPI.GetHeight()/(scale*25.4));
									// use the more precise conversion factor
	int nPagePrintingWidthLU, nPagePrintingLengthLU;
	nPagePrintingWidthLU = (int)(pageWidthBetweenMarginsMM * logicalUnitsFactor);
	nPagePrintingLengthLU = (int)(pageHeightBetweenMarginsMM * logicalUnitsFactor);
	// The stuff above could go into a separate function - see also CPrintOptionsDlg::InitDialog

	gnPrintingLength = nPagePrintingLengthLU; //nPrintingLength;

	// Footer adjustments and printing are done in the View's PrintFooter() function

	// do pagination
	//
    // whm: In the following call to PaginateDoc, we use the current m_nStripCount stored
    // on pBundle, because the PaginateDoc() call here is done within SetupRangePrintOp()
    // which is called after the print dialog has been dismissed with OK, and thus we are
    // paginating the actual doc to print and not merely simulating it for purposes of
    // getting the pages edit box values for the print options dialog.
	bIsOK = PaginateDoc(pLayout->GetStripArray()->GetCount(), nPagePrintingLengthLU);
													// doesn't call RecalcLayout()
	if (!bIsOK)
	{
		wxMessageBox(_T("Pagination failed."),_T(""), wxICON_STOP);
		return FALSE;
	}

	wxPrintDialogData printDialogData(*pApp->pPrintData);
	// pagination succeeded, so set the initial values
	int nTotalPages = pApp->m_pagesList.GetCount();
	printDialogData.SetMaxPage(nTotalPages);
	printDialogData.SetMinPage(1);
	printDialogData.SetFromPage(1);
	printDialogData.SetToPage(nTotalPages);

	return TRUE;
*/
}

// whm revised 15Feb05 to include all markers of sectionHead textType
void CAdapt_ItView::GetVerseEnd(SPList::Node*& curPos,SPList::Node*& precedingPos,
								SPList* WXUNUSED(pList),SPList::Node*& preLastPos)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList::Node* pos = curPos;
	wxASSERT(curPos != 0);
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* lastPos;
	preLastPos = precedingPos;
	int count = 0;
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markerStr;
	wxString nonFilteredMkrs;
	while (pos != 0)
	{
		lastPos = pos;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase == 0)
			break; // break out if we are at the end of the document
		count++;

		// if a following section heading is not wanted, check for it here & break early
		// if one is found
		if (!gbIncludeFollowingHeadingInRange)
		{
			// it is not possible for a section heading to be within a merged source phrase, so
			// we do not need to check for medial markers; so just check contents of the
			// m_markers attribute
			if (!pSrcPhrase->m_markers.IsEmpty())
			{
				// whm added 14Feb05 in support of USFM and SFM Filtering
				markerStr = pSrcPhrase->m_markers;
				nonFilteredMkrs = pDoc->GetUnFilteredMarkers(markerStr);
				// NormalizeToSpaces leaves the markers in m_markers delimited by spaces, at
				// lease medially. We'll use the Tokenize CString method here.
				wxString sfm;
				wxStringTokenizer tkz(markerStr,_T(" "));

				while (tkz.HasMoreTokens())
				{
					sfm = tkz.GetNextToken();
					if (sfm[0] == gSFescapechar)	// Only check actual sfms. Some tokens will be only
													// numbers (those after \c and \v) which we ignore
					{
						sfm.Trim(TRUE); // trim right end
						sfm.Trim(FALSE); // trim left end
							sfm += _T(' '); // ensure the sfm is followed by a space for unique find in
											// our wrap strings.
						// If only one of the sfms within m_markers is a wrap marker, we should return TRUE.
						switch (pApp->gCurrentSfmSet)
						{
							case UsfmOnly:
							{
								if (pApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
									// there is a section marker, so we have found the place to end the printing range
									return; // preLastPos value is the value the caller wants
								break;
							}
							case PngOnly:
							{
								if (pApp->PngSectionHeadMarkersStr.Find(sfm) != -1)
                                    // there is a section marker, so we have found the
                                    // place to end the printing range
									return; // preLastPos value is the value the caller wants
								break;
							}
							case UsfmAndPng:
							{
								if (pApp->UsfmAndPngSectionHeadMarkersStr.Find(sfm) != -1)
									// there is a section marker, so we have found the
									// place to end the printing range
									return; // preLastPos value is the value the caller wants
								break;
							}
							default:
							{
								// if we got here it would be a program error
								if (pApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
									return; // preLastPos value is the value the caller wants
							}
						}
					}
				}
			}
		}

        // for safety, in a text with no verse numbering, we'll break from the loop after
        // 300 iterations
		if (pSrcPhrase->m_chapterVerse.IsEmpty() && count < 300)
		{
			preLastPos = lastPos;
			continue;
		}
		else
			break;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Enables the "Units of Measurement..." item on the View menu. This menu item is always enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateUnits(wxUpdateUIEvent& event)
{
	event.Enable(TRUE);
}

void CAdapt_ItView::OnUnits(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	pApp->LogUserAction(_T("Initiated OnUnits()"));
	CUnitsDlg dlg(pApp->GetMainFrame());
	dlg.Centre();
	if (dlg.ShowModal() == wxID_OK)
	{
		// The App's m_bIsInches is set in the CUnitsDlg::OnOK() handler
		;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pDC     -> the display context (either print preview, or actual physical printer
/// \param      fitRect -> the rectangle representing the area of the page enclosed by the page margins
/// \param      logicalUnitsFactor -> represents the factor that must be multipled by any linear
///             measurement such as the half inch (12.7mm) that a footer is displaced below fitRect's
///             bottom margin, in order to convert that linear measurement into logical units for
///             correct positioning in the different display contexts
/// \param      page -> the page currently being rendered
/// \remarks
/// Called from: AIPrintout::OnPrintPage(). Composes the text of the footer and draws it at the footer
/// position of the rendered page.
/// BEW 12Nov11, the __GTK__ build does not calculate a correct fitRect param, and so locating the
/// footer a half inch below the bottom of the fitRect would result in the footer being anywhere -
/// mostly off page! The PrintFooter() function for the __GTK__ build takes in parameters for the
/// margin sizes (in pixels, that is logical coords), and the paper (not page) dimensions - again in
/// pixels, and from those we internally constuct a local fitRect based on the paper size - and then
/// we calculate the footer location as a half inch higher than the bottom of the paper.
/////////////////////////////////////////////////////////////////////////////////
#if !defined(__WXGTK__)
void CAdapt_ItView::PrintFooter(wxDC* pDC, wxRect fitRect, float logicalUnitsFactor, int page)
{
    // whm Note: This function's signature has been revised for the wx version. The fitRect
    // parameter is the rectangle that comprises the printing area within the page's
    // margins; its dimensions are in logical units which will differ depending on whether
    // the footer is being drawn on the print preview display context, or on an actual
    // higher resolution printer dc. The logicalUnitsFactor parameter represents the factor
    // that must be multipled by any linear measurement such as the half inch (12.7mm) that
    // a footer is displaced below fitRect's bottom margin, in order to convert that linear
    // measurement into logical units for correct positioning in the different display
    // contexts.

	// get document and app pointers
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString strPageNum;
	strPageNum = strPageNum.Format(_T("%d"),page);
	wxString tgtName = pApp->m_pKB->m_targetLanguageName;
	wxString srcName = pApp->m_pKB->m_sourceLanguageName;

    // get the filename for the document (include the range if we are printing a
    // chapter/verse range)
	wxString strDocName = pDoc->GetFilename();	// get the name of the document (actually filename,
												// with extension. GetFilename() returns the whole
												// absolute path, so just get the name + ext)
	wxFileName fn(strDocName);
	strDocName = fn.GetFullName();
	wxString strLeft;
	wxString strLeftPlusPageNum;
	if (pApp->m_bPrintingRange)
	{
		strLeft = strLeft.Format(_T("%s/%s  %s   %d:%d to %d:%d"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str(),
			gnFromChapter,gnFromVerse,gnToChapter,gnToVerse);
		strLeftPlusPageNum = strLeftPlusPageNum.Format(_T("  %s/%s  %s   %d:%d to %d:%d   %d"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str(),
			gnFromChapter,gnFromVerse,gnToChapter,gnToVerse,page);
	}
	else
	{
		strLeft = strLeft.Format(_T("%s/%s  %s"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str());
		strLeftPlusPageNum = strLeftPlusPageNum.Format(_T("  %s/%s  %s   %d"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str(),page);
	}

	// create a 12 point size copy of the system font, colour black
	wxFont* pFont;
	pFont = new wxFont(*wxNORMAL_FONT);
	pFont->SetPointSize(10);
	pFont->SetWeight(wxBOLD);
	pDC->SetTextForeground(*wxBLACK);
	pDC->SetFont(*pFont);

	// Get the date & time file was last modified on the RHS, if not created yet, use the
	// current system time instead.

    // whm 21Oct07 updated local time calculations below to account for change in Visual
    // Studio from 2003 to 2005. In the process I discovered that CTime::Format already
    // formats the time as local rather than UTC, so no specific call to GetLocalTm is now
    // necessary with its changed parameter behavior between VS 2003 and 2005. whm wx
    // version comment: theTime doesn't need to be initialized, but it doesn't hurt.
    // It is set to the file's modification date/time below.
	wxDateTime theTime = wxDateTime::Now(); //initialize to the current time
	wxString path = pApp->m_curAdaptionsPath + pApp->PathSeparator + strDocName;
	bool bExists;
	bExists = ::wxFileExists(path) && !::wxDirExists(path);
	if (bExists)
	{
		wxFileName fn(path);
		theTime = fn.GetModificationTime(); // use the file's last modified date & time
	}
	wxString timeStr;
	timeStr = theTime.Format(_T("%a, %b %d, %H:%M, %Y")).c_str();

	/*
	// The following code captures the logic for doing a centered header if we decide
	// to print one.
	wxString headerStr = _T("This is a test header");
    // scaling has been done and upper left margin intersection is now 0,0, so we can set
    // coordinates for DrawText based on that reference point in terms of screen
    // coordinates. See AIPrintout::OnPrintPage() for how logicalUnitsFactor is calculated.
	int headerXExt,headerYExt;
	pDC->GetTextExtent(headerStr,&headerXExt,&headerYExt);
    // Position the header 12.7mm (a half inch) above the top margin (the top of fitRect).
    // Since the logical origin is at 0,0, we need to add the fitRect.x position
    // (fitRect.GetLeft()) to xPosHdr. We also calculate in the vertical text extent of the
    // header so that there is 12.7mm of space between the bottom of the header text and
    // the printing margin below it.
	float xPosHdr = (float)(fitRect.GetLeft())+(fitRect.GetWidth()/2.0 - (float)headerXExt/2.0);
	float yPosHdr = (float)(fitRect.GetTop()-12.8*logicalUnitsFactor-headerYExt);
    // Draw header a half inch above top margin. This will be a negative y-axis component
    // because we called SetLogicalOrigin() above on the AIPrintout's DC so that its origin
    // is at the intersection of the top and left page margins. Above this origin is
    // negative y-axis coordinates.
	pDC->DrawText(headerStr, (long)xPosHdr, (long)yPosHdr); // draw header a half inch
															// above top margin
	*/

    // Calculate the position for the footer. The incoming parameter fitRect represents the
    // rectangular printing area within the margins in logical units. The bottom of fitRect
    // is the effective bottom margin, so we'll place the footer 12.7mm (a half inch) in
    // logical units below the bottom of fitRect. Since the logical origin is at 0,0 of the
    // page, we need to add the fitRect.x position (fitRect.GetLeft()) to xPosFtr. In
    // calculating the position of yPosFtr, however, fitRect.GetBottom() returns
    // coordinates in reference to 0,0. See AIPrintout::OnPrintPage() for how
    // logicalUnitsFactor is calculated.
	// BEW added 21Jul09 because '2' is not two spaces of width, but 2 pixels, so need
	// something bigger - otherwise for a range, end of range is too close to page number
	int wXExt; int wYExt;
	pDC->GetTextExtent(_T("W"),&wXExt,&wYExt);
	// Bill's legacy code
	int footerXExt,footerYExt;
	pDC->GetTextExtent(strLeft,&footerXExt,&footerYExt);
	float yPosFtr = (float)(fitRect.GetBottom() + 12.7*logicalUnitsFactor); // y pos is same
														// for all segments of the footer
	float xPosFtrLeft = (float)fitRect.GetLeft();
	int timeXExt,timeYExt;
	pDC->GetTextExtent(timeStr,&timeXExt,&timeYExt);
	if (footerXExt+2*wXExt >= fitRect.GetWidth()/2)
	{
		pDC->GetTextExtent(strLeftPlusPageNum,&footerXExt,&footerYExt);
        // The strLeft (language names and file name) extends past the middle point of the
        // footer, so we will not try to draw the page number centered in the footer, but
        // will just add a couple spaces and the page number to the end of strLeft.
        // The timeStr should fit in the right-hand side of the footer, unless the language
        // names and/or file name are extremently long. Check to see if the time string
        // will fit.
		if (footerXExt + timeXExt + 2*wXExt > fitRect.GetWidth()) // allow 2 W widths
														// between footerXExt and timeXExt
		{
            // There is not enough space for the timeStr to fit on the footer between
            // margins, so we'll position the left part a little higher and draw the time
            // part one line height lower than the left part.
			pDC->DrawText(strLeftPlusPageNum, (long)xPosFtrLeft, (long)yPosFtr - timeYExt/2);
			int xPosTimeStr = fitRect.GetRight() - timeXExt;
			pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr + timeYExt/2);
		}
		else
		{
			// There is enough space for the timeStr to fit
			pDC->DrawText(strLeftPlusPageNum, (long)xPosFtrLeft, (long)yPosFtr);
			int xPosTimeStr = fitRect.GetRight() - timeXExt;
			pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr);
		}
	}
	else
	{
		// There is enough room to draw the page number in the middle of the footer
		pDC->DrawText(strLeft, (long)xPosFtrLeft, (long)yPosFtr);
		int xPosPageNum = fitRect.GetLeft() + fitRect.GetWidth()/2; // don't worry
							// about adjusting for x extent of the page number
		pDC->DrawText(strPageNum, (long)xPosPageNum, (long)yPosFtr);
		int xPosTimeStr = fitRect.GetRight() - timeXExt;
		pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr);
	}

	// delete pFont for no memory leaks
	if (pFont != NULL) // whm 11Jun12 added NULL test
		delete pFont;
}
#endif

#if defined(__WXGTK__)
void  CAdapt_ItView::PrintFooter(wxDC* pDC, wxPoint marginTopLeft, wxPoint marginBottomRight, wxPoint paperDimensions,
                float logicalUnitsFactor, int page)
{
    // whm Note: This function's signature has been revised for the wx version. The fitRect
    // parameter is the rectangle that comprises the printing area within the page's
    // margins; its dimensions are in logical units which will differ depending on whether
    // the footer is being drawn on the print preview display context, or on an actual
    // higher resolution printer dc. The logicalUnitsFactor parameter represents the factor
    // that must be multipled by any linear measurement such as the half inch (12.7mm) that
    // a footer is displaced below fitRect's bottom margin, in order to convert that linear
    // measurement into logical units for correct positioning in the different display
    // contexts.

	// get document and app pointers
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	wxString strPageNum;
	if (pApp->m_bPrintingPageRange)
	{
	    // add the page offset, so the page numbers are what the user chose
	    page += pApp->m_userPageRangeStartPage - 1;
	}
	strPageNum = strPageNum.Format(_T("%d"),page);
	wxString tgtName = pApp->m_pKB->m_targetLanguageName;
	wxString srcName = pApp->m_pKB->m_sourceLanguageName;

	wxRect fitRect;
	fitRect.x = 0;
	fitRect.y = 0;
	fitRect.SetWidth(paperDimensions.x - marginTopLeft.x - marginBottomRight.x);
	fitRect.SetHeight(paperDimensions.y - marginTopLeft.y); // full paper height less the top margin
        // because the caller's SetLogicalOrigin(0,0) puts origin at intersect of left & top margins
	//fitRect.SetHeight(paperDimensions.y); // full paper height
	// remember this is a bigger rectangle than for Win or Mac, the latter two use the page
	// rectangle (which excludes the margins) -- so below we must subtract a half-inch's
	// worth of pixels from the fitRect's bottom to get the yCoord of the footer location
#if defined(Print_failure)
		wxLogDebug(_T("fitRect from paper size & margin settings; x %d  y %d , width %d  height %d"),
			fitRect.GetX(), fitRect.GetY(), fitRect.GetWidth(), fitRect.GetHeight());
#endif
    // get the filename for the document (include the range if we are printing a
    // chapter/verse range)
	wxString strDocName = pDoc->GetFilename();	// get the name of the document (actually filename,
												// with extension. GetFilename() returns the whole
												// absolute path, so just get the name + ext)
	wxFileName fn(strDocName);
	strDocName = fn.GetFullName();
	wxString strLeft;
	wxString strLeftPlusPageNum;
	if (pApp->m_bPrintingRange)
	{
		strLeft = strLeft.Format(_T("%s/%s  %s   %d:%d to %d:%d"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str(),
			gnFromChapter,gnFromVerse,gnToChapter,gnToVerse);
		strLeftPlusPageNum = strLeftPlusPageNum.Format(_T("  %s/%s  %s   %d:%d to %d:%d   %d"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str(),
			gnFromChapter,gnFromVerse,gnToChapter,gnToVerse,page);
	}
	else
	{
		strLeft = strLeft.Format(_T("%s/%s  %s"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str());
		strLeftPlusPageNum = strLeftPlusPageNum.Format(_T("  %s/%s  %s   %d"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str(),page);
	}

	// create a 12 point size copy of the system font, colour black
	wxFont* pFont;
	pFont = new wxFont(*wxNORMAL_FONT);
	pFont->SetPointSize(10);
	pFont->SetWeight(wxBOLD);
	pDC->SetTextForeground(*wxBLACK);
	pDC->SetFont(*pFont);

	// Get the date & time file was last modified on the RHS, if not created yet, use the
	// current system time instead.

    // whm 21Oct07 updated local time calculations below to account for change in Visual
    // Studio from 2003 to 2005. In the process I discovered that CTime::Format already
    // formats the time as local rather than UTC, so no specific call to GetLocalTm is now
    // necessary with its changed parameter behavior between VS 2003 and 2005. whm wx
    // version comment: theTime doesn't need to be initialized, but it doesn't hurt.
    // It is set to the file's modification date/time below.
	wxDateTime theTime = wxDateTime::Now(); //initialize to the current time
	wxString path = pApp->m_curAdaptionsPath + pApp->PathSeparator + strDocName;
	bool bExists;
	bExists = ::wxFileExists(path) && !::wxDirExists(path);
	if (bExists)
	{
		wxFileName fn(path);
		theTime = fn.GetModificationTime(); // use the file's last modified date & time
	}
	wxString timeStr;
	timeStr = theTime.Format(_T("%a, %b %d, %H:%M, %Y")).c_str();

    // Calculate the position for the footer. The incoming parameter fitRect represents the
    // rectangular printing area within the margins in logical units. The bottom of fitRect
    // is the effective bottom margin, so we'll place the footer 12.7mm (a half inch) in
    // logical units below the bottom of fitRect. Since the logical origin is at 0,0 of the
    // page, we need to add the fitRect.x position (fitRect.GetLeft()) to xPosFtr. In
    // calculating the position of yPosFtr, however, fitRect.GetBottom() returns
    // coordinates in reference to 0,0. See AIPrintout::OnPrintPage() for how
    // logicalUnitsFactor is calculated.
	// BEW added 21Jul09 because '2' is not two spaces of width, but 2 pixels, so need
	// something bigger - otherwise for a range, end of range is too close to page number
	int wXExt; int wYExt;
	pDC->GetTextExtent(_T("W"),&wXExt,&wYExt);
	// Bill's legacy code
	int footerXExt,footerYExt;
	pDC->GetTextExtent(strLeft,&footerXExt,&footerYExt);
	//float yPosFtr = (float)(fitRect.GetBottom() + 12.7*logicalUnitsFactor); // y pos is same
	//													// for all segments of the footer
	float yPosFtr = (float)(fitRect.GetBottom() - 12.7*logicalUnitsFactor); // y pos is same
														// for all segments of the footer
	float xPosFtrLeft = (float)fitRect.GetLeft();
	int timeXExt,timeYExt;
	pDC->GetTextExtent(timeStr,&timeXExt,&timeYExt);
	if (footerXExt+2*wXExt >= fitRect.GetWidth()/2)
	{
		pDC->GetTextExtent(strLeftPlusPageNum,&footerXExt,&footerYExt);
        // The strLeft (language names and file name) extends past the middle point of the
        // footer, so we will not try to draw the page number centered in the footer, but
        // will just add a couple spaces and the page number to the end of strLeft.
        // The timeStr should fit in the right-hand side of the footer, unless the language
        // names and/or file name are extremently long. Check to see if the time string
        // will fit.
		if (footerXExt + timeXExt + 2*wXExt > fitRect.GetWidth()) // allow 2 W widths
														// between footerXExt and timeXExt
		{
            // There is not enough space for the timeStr to fit on the footer between
            // margins, so we'll position the left part a little higher and draw the time
            // part one line height lower than the left part.
			pDC->DrawText(strLeftPlusPageNum, (long)xPosFtrLeft, (long)yPosFtr - timeYExt/2);
			int xPosTimeStr = fitRect.GetRight() - timeXExt;
			pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr + timeYExt/2);
		}
		else
		{
			// There is enough space for the timeStr to fit
			pDC->DrawText(strLeftPlusPageNum, (long)xPosFtrLeft, (long)yPosFtr);
			int xPosTimeStr = fitRect.GetRight() - timeXExt;
			pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr);
		}
	}
	else
	{
		// There is enough room to draw the page number in the middle of the footer
		pDC->DrawText(strLeft, (long)xPosFtrLeft, (long)yPosFtr);
		int xPosPageNum = fitRect.GetLeft() + fitRect.GetWidth()/2; // don't worry
							// about adjusting for x extent of the page number
		pDC->DrawText(strPageNum, (long)xPosPageNum, (long)yPosFtr);
		int xPosTimeStr = fitRect.GetRight() - timeXExt;
		pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr);
	}

	// delete pFont for no memory leaks
	if (pFont != NULL) // whm 11Jun12 added NULL test
		delete pFont;
}
#endif


// wxWidgets Note: This function in the MFC version was called CreateBox, but I've combined
// its functionality and that of ResizeBox into a single function now called ResizeBox in
// the wx version. This was possible because the function now calls SetSize() on the
// already existing target box. The target box is created once in the App and lives while
// the app lives. When the target box should not be shown, it is now simply hidden, rather
// than destroyed and reshown.
void CAdapt_ItView::ResizeBox(const wxPoint *pLoc, const int nWidth, const int nHeight,
				wxString &text, int nStartingChar, int nEndingChar, CPile* pActivePile)
{
	//refactored 7Apr09
	#ifdef _Trace_Box_Loc_Wrong
	if (pApp->m_nActiveSequNum >20)
	{
	wxLogDebug(_T("\nCreateBox   pLoc {y= %d ,x= %d } sequ num = %d\n"),
		pLoc->y, pLoc->x,pActivePile->GetSourcePhrase()->m_nSequNumber);
	}
	#endif

    // 7Apr09, in the refactored version, the pActivePile parameter is no longer needed, so
    // I've repurposed it to provide a check of the gap width (active pile's m_nWidth
    // value) against the nWidth value passed in - so that if nWidth exceeds the space left
    // at the active pile's gap, the gap width is used instead
	int nGapWidth = pActivePile->GetPhraseBoxGapWidth();
	int aWidth = nWidth;
	if ( nGapWidth >= 10)
	{
		aWidth = aWidth > nGapWidth ? nGapWidth : aWidth;
	}

	gbEnterTyped = FALSE; // ensure it is FALSE, only ENTER key typed should set it TRUE
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp);
	wxRect rectBox(wxPoint((*pLoc).x, (*pLoc).y), wxPoint((*pLoc).x + aWidth,
					(*pLoc).y + nHeight+4)); // logical coords

	#ifdef _Trace_Box_Loc_Wrong
	if (pApp->m_nActiveSequNum >20)
	{
	wxLogDebug(_T("ResizeBox  rectBox topLeft { %d , %d } BEFORE OnPrepareDC & LPtoDP\n"),
			rectBox.top, rectBox.left);
	}
	#endif

	/*
	{
	#ifdef _DEBUG
		wxLogTrace(_T("\nTrace 0 - Within ResizeBox - before OnPrepareDC call"));
		wxString str;
		str = str.Format("rectBox -- Logical coords: T= %d, L= %d, B= %d, R= %d\n",
			rectBox.GetTop(), rectBox.GetLeft(), rectBox.GetBottom(), rectBox.GetRight());
		wxLogTrace(str);
	#endif
	}
	*/

	// convert to device coords
	wxClientDC aDC(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(aDC); // adjust origin

	//wxPoint ptrLoc = *pLoc; // unused

    // CalcScrolledPosition is the complement of CalcUnscrolledPosition;
    // CalcScrolledPosition translates logical coordinates to device ones.
	int newXPos,newYPos;
	pApp->GetMainFrame()->canvas->CalcScrolledPosition(
								rectBox.x,rectBox.y,&newXPos,&newYPos);
	rectBox.x = newXPos;
	rectBox.y = newYPos;
	// we leave the width and height the same

	// Below are alternates for calculating scrolled position
//#ifdef _DEBUG
//	// The device coords can be found by subtracting the logical coords of the upper left corner as
//	// reported by GetViewStart, from rectBox's upper left corner coords. This doesn't change the
//	// width and height of a wxRect; the width and height were established in the wxRect rectBox()
//	// construction statement above.
//	int xScrollUnits, yScrollUnits, xOrigin, yOrigin;
//	pApp->GetMainFrame()->canvas->GetViewStart(&xOrigin, &yOrigin); // gets xOrigin and yOrigin in scroll units
//	pApp->GetMainFrame()->canvas->GetScrollPixelsPerUnit(&xScrollUnits, &yScrollUnits); // gets pixels per scroll unit
//	rectBox.x -= xOrigin * xScrollUnits; // number pixels is ScrollUnits * pixelsPerScrollUnit
//	rectBox.y -= yOrigin * yScrollUnits;
//#endif


//#ifdef _DEBUG
//	//aDC.LPtoDP(&rectBox);
//	// whm Note: The following LogicalToDeviceXRel and LogicalToDeviceYRel and their non-Rel functions
//	// adjust the logical position of rectBox after scrolling down from the zero scroll position
//	int x = aDC.LogicalToDeviceXRel(rectBox.x);// get the logical X coord converted to device coord
//	int y = aDC.LogicalToDeviceYRel(rectBox.y);// get the logical Y coord converted to device coord
//	// the above should be equivalent to the non-Rel forms below when using saveRect
//	int xx = aDC.LogicalToDeviceX(saveRect.x);// get the logical X coord converted to device coord
//	int yy = aDC.LogicalToDeviceY(saveRect.y);// get the logical Y coord converted to device coord
//	wxASSERT(x == rectBox.x); //rectBox.x = x;
//	wxASSERT(y == rectBox.y); //rectBox.y = y;
//	wxASSERT(x == xx);
//	wxASSERT(y == yy);
//#endif

	#ifdef _Trace_Box_Loc_Wrong
	if (pApp->m_nActiveSequNum >20)
	{
		wxLogDebug(_T("ResizeBox  rectBox topLeft { %d , %d } AFTER OnPrepareDC & LPtoDP\n"),
				rectBox.top, rectBox.left);
	}
	#endif

	// WX version resizes rather than recreating the target box
	pApp->m_pTargetBox->SetSize(rectBox.GetLeft(),rectBox.GetTop(),
								rectBox.GetWidth(),rectBox.GetHeight());

    // whm note: Shouldn't the following adjustment come before the SetSize call above???
    // BEW answer: no, SetSize() would then wipe out the effect.
#ifdef _RTL_FLAGS
	// adjust, otherwise box is a bit too small vertically
	rectBox.SetHeight(rectBox.GetHeight() + 5); // allow for the window borders
	if (gnVerticalBoxBloat > 0)
		rectBox.SetHeight(rectBox.GetHeight() + gnVerticalBoxBloat); // allow for the leadings on the font
	// enable complex rendering
    // whm note for wx version: Right-to-left reading is handled automatically in Uniscribe
    // and Pango, but they differ in how they handle Unicode text chars that are from the
    // first 128 point positions. In wxMSW SetLayoutDirection() aligns these to the right
    // in the phrasebox but in wxGTK (under Pango) SetLahoutDirection() aligns these to the
    // left within the phrasebox.
	if (pApp->m_bTgtRTL)
	{
		pApp->m_pTargetBox->SetLayoutDirection(wxLayout_RightToLeft);
//      whm Note: Pango overrides the following SetStyle() command
//#ifndef __WXMSW__
//		pApp->m_pTargetBox->SetStyle(-1,-1,wxTextAttr(wxTEXT_ALIGNMENT_RIGHT));
//#endif
	}
	else
	{
		pApp->m_pTargetBox->SetLayoutDirection(wxLayout_LeftToRight);
//      whm Note: Pango overrides the following SetStyle() command
//#ifndef __WXMSW__
//		pApp->m_pTargetBox->SetStyle(-1,-1,wxTextAttr(wxTEXT_ALIGNMENT_LEFT));
//#endif
	}
#endif // for _RTL_FLAGS

	pApp->m_pTargetBox->ChangeValue(text);
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pApp->m_pTargetBox->SetFont(*pApp->m_pNavTextFont);

	else
		pApp->m_pTargetBox->SetFont(*pApp->m_pTargetFont);

	// whm modified 29Mar12. As of this date, this is the only
	// location in the whole code base where the m_pTargetBox->Show()
	// call is made. 
	// 
	// Only call m_pTargetBox->Show() if the app is NOT in read-only mode.
	if (!pApp->m_bReadOnlyAccess)
	{
		// whm added following to show and enable the target box
		pApp->m_pTargetBox->Show();
		pApp->m_pTargetBox->Enable(TRUE);
		pApp->m_pTargetBox->SetEditable(TRUE);
	}

	// restore focus and cursor position or selection
	// whm 29Jul11 Note: The following SetFocus() call sometimes
	// generates an API error logged in the Output window during
	// debugging: "..\..\src\msw\window.cpp(643): 'SetFocus' failed
	// with error 0x00000057 (the parameter is incorrect.)."
	// It is annoying to see it appear in the output window but
	// it is of unknown cause and apparently harmless.
	pApp->m_pTargetBox->SetFocus();
	pApp->m_pTargetBox->SetSelection(nStartingChar,nEndingChar);
	pApp->m_nStartChar = (int)nStartingChar;
	pApp->m_nEndChar = (int)nEndingChar;

	if (pApp->m_bFreeTranslationMode)
	{
		// prevent clicks and editing from being done in the phrase box
		// (do also in OnAdvancedFreeTranslationMode())
        // wx version: by setting the targetbox with SetEditable(FALSE) instead of
        // Enable(FALSE) we get to control the background color, keeping it pink in free
        // trans mode
		pApp->m_pTargetBox->SetEditable(FALSE);
		pApp->m_pTargetBox->SetBackgroundColour(pApp->m_freeTransCurrentSectionBackgroundColor);
	}
	else
	{
		// enable clicks and editing to be done in the phrase box
		// (do also in OnAdvancedFreeTranslationMode())
		pApp->m_pTargetBox->SetEditable(TRUE);
		// whm 20Nov10 commented out Guesser color change - here is not the
		// place to set the phrasebox color - it gets overwritten in a later
		// call in pLayout->PlaceBox().
		//if (pApp->m_bIsGuess)
		//{
		//	pApp->m_pTargetBox->SetBackgroundColour(pApp->m_GuessHighlightColor);
		//	// immediately set clear the m_bIsGuess flag
		//	pApp->m_bIsGuess = FALSE;
		//}
		//else
		//{
		pApp->m_pTargetBox->SetBackgroundColour(wxColour(255,255,255)); // white
		//}
	}
}

void CAdapt_ItView::OnEditPreferences(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp);

	pApp->LogUserAction(_T("Initiated OnEditPreferences()"));
	CEditPreferencesDlg editPrefsDlg(
		pApp->GetMainFrame(),
		-1,
		_("Edit Preferences"),
		wxDefaultPosition,
		wxDefaultSize,
		wxCAPTION|wxRESIZE_BORDER|wxSYSTEM_MENU|wxCLOSE_BOX);  // removed |wxDIALOG_MODAL
					// GDLC wxDIALOG_MODAL is obsolete - ShowModal() does what it used to
	editPrefsDlg.Centre();

	pApp->m_nMaxToDisplay = pApp->GetMaxIndex() + 1;

	// preserve the current active pile location, by preserving the srcPhrases's sequNum
	// (because RecalcLayout will recreate everything any any saved pointers will no longer
	// be valid)
	int activeSequNum;
	if (pApp->m_nActiveSequNum < 0)
	{
		// must not have data yet, or we are at EOF, so no pile is currently active
		activeSequNum = -1;
	}
	else
	{
		// we are possibly somewhere in the midst of the data, so a pile will be active,
		// unless we cancelled from the wizard without getting a doc open - in which case
		// activeSequNum may be 0, but m_pActivePile would still be null, so check
		if (pApp->m_pActivePile != NULL)
		{
			activeSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;

			// remove any current selection, as we can't be sure of any pointers
			// depending on what user may choose to alter
			RemoveSelection();
		}
		else
		{
			activeSequNum = 0; // to avoid a compiler warning
		}
	}
	pApp->m_nActiveSequNum = activeSequNum;
	wxString strSavePhraseBox = pApp->m_targetPhrase;

    // whm Design Modification NOTE:
    // !!! DO NOT INITIALIZE DATA IN INDIVIDUAL PREFERENCES PAGES HERE !!!
    // Each of the InitDialog() methods of the individual Preferences pages takes care of
    // the initialization of all of their local members directly from the corresponding
    // members in the App (many of which get initialized previously by config file values).
    // This modification attempts to keep initialization encapsulated more in the classes
    // that know how to handle the data. Because of this modification, we don't need to
    // initialize them from here before the CEditPreferencesDlg's ShowModal() call is made
    // - as does the MFC version.

	// Put up the "Edit Preferences" dialog
    // wx note: Since CEditPreferencesDlg is based on wxPropertySheetDialog rather than on
    // wxDialog, it does not get its idle event processing turned off while it is in modal
    // state, therefore we turn off idle processing here manually just before the ShowModal
    // call; and turn it back on afterwards (below).
	wxIdleEvent::SetMode(wxIDLE_PROCESS_SPECIFIED); // turn idle processing off
	if(editPrefsDlg.ShowModal() == wxID_OK)
	{
		// whm Design Modification NOTE:
		// !!! DO NOT UPDATE DATA FROM INDIVIDUAL PREFERENCES PAGES HERE !!!
        // Each of the OnOK() methods of the individual Preferences pages takes care of the
        // updating the App's data members directly from their local temp... members. This
        // modification attempts to keep settings value changes encapsulated more in the
        // classes that know how to handle the data. Because of this modification, we don't
        // need to update them from here after the CEditPreferencesDlg's ShowModal() call
        // is made - as does the MFC version.
	}
	else
	{
		// user cancelled
		if (pApp->m_bShowAdministratorMenu)
		{
			// don't show it if the user cancelled prefs
			pApp->m_bShowAdministratorMenu = FALSE;
#ifdef _DEBUG
			pApp->m_bShowAdministratorMenu = TRUE; // for debugging convenience
#endif
		}
		pApp->LogUserAction(_T("Cancelled OnEditPreferences()"));
	}

	// show the Administrator menu if the admin person requested it and password was valid
	// if flag is FALSE, check if the menu is visible and if so, hide it. This and more is
	// done through the App's MakeMenuInitializationsAndPlatformAdjustments() function.
	pApp->MakeMenuInitializationsAndPlatformAdjustments(collabIndeterminate);

	// We want to be smarter here so that we don't create piles and strips again
    // unnecessarily - eg. if user changes the colour of text only, no recalculation of the
    // layout would be needed
	// BEW 5Jun09, removed the RecalcLayout() call here, in favour of using the
	// DoRecalcLayoutAfterPreferencesDlg() function, which makes a more intelligent
	// decision about which particular kind of RecalcLayout() call to make
	CLayout* pLayout = GetLayout();
	// whm added 5Nov10 the following test block in support of Preferences being
	// made available when no documen is open.
	if (pApp->GetDocument() == NULL || pApp->m_pSourcePhrases->GetCount() == 0)
	{
		// no document is open so there is no need to do pLayout calls nor phrasebox
		// adjustments, etc. We can return here, but first make sure Idle processing
		// is turned back on and the pLayout boolean flags are cleared.
		wxIdleEvent::SetMode(wxIDLE_PROCESS_ALL); // turn idle processing back on
		// it's not necessary to clear these flags here, as they get cleared automatically in
		// the CEditPreferences::InitDialog() function, which is called when the Preferences
		// dialog is first opened. However, it is good defensive practice not to leave them set
		// until then
		pLayout->m_bViewParamsChanged = FALSE;
		pLayout->m_bUSFMChanged = FALSE;
		pLayout->m_bFilteringChanged = FALSE;
		pLayout->m_bPunctuationChanged = FALSE;
		pLayout->m_bCaseEquivalencesChanged = FALSE;
		pLayout->m_bFontInfoChanged = FALSE;
		// return before performing pLayout calls and phrasebox adjustments
		return;
	}
	pLayout->DoRecalcLayoutAfterPreferencesDlg(); // inside are smarts for making the
												  // best possible RecalcLayout() call
	if (pApp->m_nActiveSequNum == -1)
	{
		pApp->m_pActivePile = NULL; // that ought to be safe in update handlers
	}
	else
	{
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	}
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);

	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}

    // BEW 22May09 moved idle processing down to here so that idle events won't come before
    // the m_pActivePile has a chance to be reset to the valid active pile resulting from
    // the shenanigans that go on in RecalcLayout()! Failure to do so can result in system
    // housekekeping calling command update handlers before m_pActivePile points at a real
    // pile, and that gives a flame & burn crash
	wxIdleEvent::SetMode(wxIDLE_PROCESS_ALL); // turn idle processing back on

	int len;
	// BEW modified 3Apr08, restore focus to the phrase box, except when in free translation
	// mode in which case it needs to be restored to the compose bar's editbox
	if (pApp->m_bFreeTranslationMode)
	{
		CMainFrame* pFrame = pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		if (pFrame->m_pComposeBar != NULL)
			if (pFrame->m_pComposeBar->IsShown())
			{
				wxTextCtrl* pComposeBox = (wxTextCtrl*)
							pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
				wxString text;
				text = pComposeBox->GetValue();
				len = text.Length();
				pComposeBox->SetSelection(len,len);
				pComposeBox->SetFocus();
			}
	}
	else
	{

		if (pApp->m_pTargetBox->IsShown())
		{
			len = pApp->m_targetPhrase.Length();
			pApp->m_nStartChar = len;
			pApp->m_nEndChar = len;
			pApp->m_pTargetBox->SetSelection(len,len);
			pApp->m_pTargetBox->SetFocus();
		}
	}

    // it's not necessary to clear these flags here, as they get cleared automatically in
    // the CEditPreferences::InitDialog() function, which is called when the Preferences
    // dialog is first opened. However, it is good defensive practice not to leave them set
    // until then
	pLayout->m_bViewParamsChanged = FALSE;
	pLayout->m_bUSFMChanged = FALSE;
	pLayout->m_bFilteringChanged = FALSE;
	pLayout->m_bPunctuationChanged = FALSE;
	pLayout->m_bCaseEquivalencesChanged = FALSE;
	pLayout->m_bFontInfoChanged = FALSE;

	// BEW 30Jun09, added Invalidate() and PlaceBox() here, not sure but I think they
	// are needed
	Invalidate();
	pLayout->PlaceBox();
}

void CAdapt_ItView::OnFileSaveKB(wxCommandEvent& event)
{
	// whm modified 15Jan11 to save both glossing and adapting KBs when OnFileSaveKB()
	// is called. This is now more important with transitions possible between the new
	// and old KB xml formats.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp);
	if (event.GetId() == ID_FILE_SAVEKB)
	{
		pApp->LogUserAction(_T("Initiated OnFileSaveKB()"));
	}
	bool bOK1 = FALSE;
	bool bOK2 = FALSE;

	// BEW added 13Nov09, the local user, if he has only read-only access to a remote
	// project folder, must not be able to cause saving of the KB data - otherwise the
	// remote user would probably lose data added to the KB in his machine's memory
	// since his last save; so prevent my machine's in-memory KB copy from being saved
	// to his machine
	if (pApp->m_bReadOnlyAccess)
	{
		pApp->LogUserAction(_T("Aborted OnFileSaveKB() m_bReadOnlyAccess"));
		return;
	}

	wxString mess;
	mess.Empty();
	//if (gbIsGlossing)
	//{
	bOK1 = pApp->SaveGlossingKB(FALSE); // don't want backup produced of the glossing KB
	if (!bOK1)
	{
		mess = _("Failure when trying to save the glossing knowledge base. ");
	}
	//}
	//else
	//{
	bOK2 = pApp->SaveKB(FALSE); // don't want backup produced
	if (!bOK2)
	{
		mess = _("Failure when trying to save the knowledge base. ");
	}
	//}
	if (!bOK1 || !bOK2)
	{
		pApp->m_bAutoBackupKB = FALSE;	// turn it off, so if user reopens the app later, the
										// bad glossing KB will not overwrite the backed up one
		mess += _(" You should immediately save the document, then try again.");
		mess += _(" If you have repeated failures, then exit the application ");
		mess += _("and try one of the recovery strategies (either use the backup one ");
		mess += _("or the Restore Knowledge Base command). DO NOT use ");
		mess += _("the Backup Knowledge Base command now!");
		wxMessageBox(mess, _T(""), wxICON_EXCLAMATION | wxOK);
		pApp->LogUserAction(mess);
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Enables the "Save Knowledge Base" item on the File menu if the appropriate KB is in a
/// ready state, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileSaveKB(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbIsGlossing)
		event.Enable(pApp->m_bGlossingKBReady);
	else
		event.Enable(pApp->m_bKBReady);
}

void CAdapt_ItView::OnFileCloseProject(wxCommandEvent& event)
{
    // Since the Close Project menu item has an accelerator table hot key (CTRL-J see
    // CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even when
    // they are disabled, we must check for a disabled button and return if disabled.
    // On Windows, the accelerator key doesn't appear to call the handler for a disabled
    // menu item, but I'll leave the following code here in case it works differently on
    // other platforms.
	//CMainFrame* pFrame = pApp->GetMainFrame();
	//wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	//wxASSERT(pMenuBar != NULL);
	//if (!pMenuBar->IsEnabled(ID_FILE_CLOSEKB))
	//{
	//	::wxBell();
	//	return;
	//}

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp);
	CAdapt_ItDoc* pDoc = pApp->GetDocument();

	// whm Note: Only log user action when user explicitly closes
	// the project from the File menu, not when other funtions call
	// the handler.
	if (event.GetId() == ID_FILE_CLOSEKB)
	{
		pApp->LogUserAction(_T("User initiated Close Project"));
	}
	else
	{
		pApp->LogUserAction(_T("Program initiated Close Project"));
	}

	// BEW added 6Nov09 because, if recovering within the OnInit() call just after
	// launch because a custom work folder location is not accessible (eg. it may be
	// on a thumb drive not currently plugged in), the GetCustomWorkFolderLocation()
	// call, part of the recovery attempt, will call GetView()->CloseProject(), but
	// that calls OnFileCloseProject() which then tries to set up a pointer to the
	// document class's instance, which at that time does not yet exist. The pointer
	// is returned as NULL, and so the pDoc->OnFileClose() call a little further below
	// would fail unless we here detect a pDoc being NULL and exit immediately
	if (pDoc == NULL)
	{
		wxString msg = _T("Doc == NULL, returned early from OnFileCloseProject(): m_curProjectPath = %s [not reset/emptied in OnFileCloseProject()]");
		msg = msg.Format(msg,pApp->m_curProjectPath.c_str());
		pApp->LogUserAction(msg);
		return; // do nothin because no doc instance exists yet, so prevent crash
	}

	// whm added 28Feb12
	// when the user explicitly selects File > Close Project we want the
	// normal wizard to appear, not the GetSourceTextFromEditor dialog.
	pApp->m_bStartWorkUsingCollaboration = FALSE;

	// whm 28Feb12 modified. With project-specific collaboration the user
	// decides whether collaboration is ON or OFF at the ProjectPage of
	// the wizard. When the user selects Close Project from the File menu
	// we close the project and also turn collaboration OFF, which also
	// is needed to remove the parenthetical information from the
	// File > Open and File > Save labels.
	pApp->m_bCollaboratingWithParatext = FALSE;
	pApp->m_bCollaboratingWithBibledit = FALSE;
	// Remove the parenthetical info from File > Open and File Save menu labels
	pApp->MakeMenuInitializationsAndPlatformAdjustments(collabIndeterminate);

	// whm added 20Feb12. If no project is open, then we should not call
	// pDoc->OnFileClose() below. Although File > Close Projects won't
	// trigger OnFileCloseProject(), the unpacking of a packed document
	// calls CloseProject() which ends up calling this OnFileCloseProject()
	// handler. Then later the app wants to write out a project config
	// file which asserts and isn't appropriate when no project is open.
	// This situation can happen when the user cancels at the
	// Start Working Wizard and then does an Unpack Document... command.
	// Therefore I am adding a test for m_pKB being NULL and if so, we
	// bail out early from OnFileCloseProject().
	if (pApp->m_pKB == NULL)
	{
		wxLogDebug(_T("m_pKB is NULL - project is already closed."));
		// whm added 7Aug12. When the project is closed the m_curProjectPath should be an empty string.
		wxString msg = _T("m_pKB == NULL, returned early from OnFileCloseProject(): m_curProjectPath = %s");
		msg = msg.Format(msg,pApp->m_curProjectPath.c_str());
		pApp->LogUserAction(msg);
		pApp->m_curProjectPath.Empty();
		return;
	}

	// ask for saving of doc & both kbs (normal one and glossing one)
	pDoc->OnFileClose(event);

	if (bUserCancelled)
	{
		bUserCancelled = FALSE; // clear the flag to default situation
		wxString msg = _T("User cancelled from pDoc->OnFileClose() within OnFilecloseProject(): m_curProjectPath = %s");
		msg = msg.Format(msg,pApp->m_curProjectPath.c_str());
		pApp->LogUserAction(msg);
		return;
	}

	if (gbGlossingVisible)
	{
		// glossing is on, so we must ensure the menu toggle is turned off and the
		// glossing checkbox removed, so this can all be done with the following call
		OnAdvancedSeeGlosses(event);
	}

	if (pApp->m_bFreeTranslationMode)
	{
		// free translation mode is on, so we must first turn it off
		wxCommandEvent event;
		pApp->GetFreeTrans()->OnAdvancedFreeTranslationMode(event);
	}

	if (!gbIgnoreScriptureReference_Receive)
	{
		// scripture reference receiving is turned on, and it must be
		// off when there is no project current
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedReceiveSynchronizedScrollingMessages(uevent); //toggle it to TRUE
	}

	if (!gbIgnoreScriptureReference_Send)
	{
		// scripture reference sending is turned on, and it must be
		// off when there is no project current
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedSendSynchronizedScrollingMessages(uevent); //toggle it to TRUE
	}

	/* unneeded, EraseKB() (called twice below) will do this internally
	if (!pApp->m_curProjectPath.IsEmpty())
	{
		bool bRemoved = pApp->m_pROP->RemoveReadOnlyProtection(pApp->m_curProjectPath);
		if (bRemoved)
		{
			pApp->m_bReadOnlyAccess = FALSE; // project folder is now ownable for writing
		}
		// we are leaving this folder, so the local process must have m_bReadOnlyAccess unilaterally
		// returned to a FALSE value - whether or not a ~AIROP-*.lock file remains in the folder
		pApp->m_bReadOnlyAccess = FALSE;
		pApp->GetView()->canvas->Refresh(); // force color change back to normal white background
	}
	*/
	// BEW 28Sep12, moved the KB erasures to be after the writing of the config file,
	// because ReleaseKBServer(), if called, needs to be called after the config file is
	// written (so that the latter stores correct m_bKBServerProject flag value), and the
	// in-memory KBs are still there in case ReleaseKBServer() needs to do any final
	// updating of the local KBs

	// update status bar with project name
	wxString message;
	// IDS_NO_PROJECT
	message = message.Format(_("No project is currently active"));
	if (pApp->m_bBookMode && !pApp->m_bDisableBookMode)
	{
		wxString mssg;
		wxString undef;
		undef = _(" Undefined");
		// IDS_CURFOLDER
		mssg = mssg.Format(_("  Current Folder: %s"),undef.c_str());
		message += mssg;
	}
	StatusBarMessage(message); // don't want a glossing/adapting prefix, since we are closing

    // restore the glossing support flags to their default values, so an open of another
    // project will have the default 2-rows per strip interface in effect
	gbIsGlossing = FALSE;
	gbGlossingVisible = FALSE;
	gbGlossingUsesNavFont = FALSE;

    // book folder mode may have been on; we can't be sure the next project opened will
    // have that mode on, or even that it may have been on in the project at an earlier
    // time, so the safe thing to do is to turn it off
	pApp->m_bBookMode = FALSE;
	if (pApp->m_pBibleBooks != NULL)
		pApp->m_bDisableBookMode = FALSE;
	else
		pApp->m_bDisableBookMode = TRUE;
	pApp->m_nBookIndex = -1;
	pApp->m_nDefaultBookIndex = 39; // default is Matthew
	pApp->m_nLastBookIndex = -1;
	pApp->m_pCurrBookNamePair = NULL;
	
	// whm added 27Apr12. When the project is closed, the project config file should be written
	// out to disk and then the m_curProjectPath should become empty so that the project config
	// file won't get written out at time when no project is open. The m_curProjectPaht is given
	// a new value when a project is subsequently opened.
	// Call WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath,projectConfigFile)
	// to save the settings in the project config file.
	bool bOK;
	if (!pApp->m_curProjectPath.IsEmpty())
	{
		if (pApp->m_bUseCustomWorkFolderPath && !pApp->m_customWorkFolderPath.IsEmpty())
		{
			// whm 10Mar10, must save using what paths are current, but when the custom
			// location has been locked in, the filename lacks "Admin" in it, so that it
			// becomes a "normal" project configuration file in m_curProjectPath at the
			// custom location.
			if (pApp->m_bLockedCustomWorkFolderPath)
				bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath,projectConfigFile);
			else
				bOK = pApp->WriteConfigurationFile(szAdminProjectConfiguration, pApp->m_curProjectPath,projectConfigFile);
		}
		else
		{
			bOK = pApp->WriteConfigurationFile(szProjectConfiguration, pApp->m_curProjectPath,projectConfigFile);
		}
		// we don't expect a write error, but tell the developer or user if the write
		// fails, and keep on processing
		if (!bOK)
		{
			wxString msg = _T("In OnFileCloseProject() WriteConfigurationFile() failed for project config file or admin project config file.");
			wxMessageBox(msg); 
			pApp->LogUserAction(msg);
		}
	}
#if defined(_KBSERVER)
	// BEW 28Sep12, clean up and make persistent any volatile data, if kbserver
	// support is active
	if (pApp->m_bIsKBServerProject)
	{
		pApp->ReleaseKBServer();
		pApp->LogUserAction(_T("ReleaseKBServer() called in OnFileCloseProject()"));
	}
#endif
	// BEW 28Sep12 moved KB erasure code to be here -- see not above
	// Delete each KB and make the app unable to use either further
	gbJustClosedProject = TRUE;
	if (pApp->m_pKB != NULL)
	{
		pDoc->EraseKB(pApp->m_pKB);
		pApp->m_bKBReady = FALSE;
		pApp->m_pKB = (CKB*)NULL; // done in EraseKB too
	}
	// now the glossing KB and flags
	if (pApp->m_pGlossingKB != NULL)
	{
		pDoc->EraseKB(pApp->m_pGlossingKB);
		pApp->m_bGlossingKBReady = FALSE;
		pApp->m_pGlossingKB = (CKB*)NULL; // done in EraseKB too
	}

	// BEW added 22Jan10, clear the KB search string arrays
	pApp->m_arrSearches.Clear(); // set of search strings for dialog's multiline wxTextCtrl
	pApp->m_arrOldSearches.Clear(); // old search strings accumulated while in this project

 
	// whm added 27Apr12. When the project is closed the m_curProjectPath should be an empty string.
	pApp->m_curProjectPath.Empty();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "Close Project" item on the File menu if Vertical Editing is in progress.
/// Enables the item if the KBs are in a ready state, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileCloseKB(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// the kbs are closed or opened together
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "New" item on the File menu if Vertical Editing or Paratext Collaboration
/// is in progress. Enables the item if the KB pointers are not NULL, and if the strip
/// count is zero (meaning no document is loaded), otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileNew(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// whm added 16May11. Disallow File "New" menu item when PT/BE collaboration is active
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}

	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// we can't use m_pSourcePhrases->GetCount() equal to zero because after a File...Close
	// only the view (ie. strips) is clobbered, the source phrases don't get clobbered until
	// DeleteContents() is called, which does not happen until either the user chooses New...
	// or Open... or the Wizard equivalents, or closes the app. So a zero strip count is
	// a sufficient condition.
	if (pApp->m_pKB != NULL && pApp->m_pGlossingKB != NULL &&
		pApp->m_pLayout->GetStripArray()->GetCount() == 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "Open..." item on the File menu if Vertical Editing is in progress.
/// Enables the item if collaborating with Paratext/Bibledit. Enables the item if
/// the KB pointers are not NULL, and if the app's strip count is
/// zero, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileOpen(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}

	// whm added 25May11 When collaborating with Paratext or Bibledit we make the Open... command
	// always available just as we do for the Start Working Wizard in
	// OnUpdateFileStartupWizard().
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		event.Enable(TRUE);
		return;
	}

    // we can't use m_pSourcePhrases->GetCount() equal to zero because after a File...Close
    // only the view (ie. strips) is clobbered, the source phrases don't get clobbered
    // until DeleteContents() is called, which does not happen until either the user
    // chooses New... or Open... or the Wizard equivalents, or closes the app. So a zero
    // strip count is a sufficient condition.
    // I've changed this now, the source phrases now get clobbered, but using the strip
    // count is still perfectly acceptable, so I'll leave it unchanged.
	if (pApp->m_pKB != NULL && pApp->m_pGlossingKB != NULL &&
		pApp->m_pLayout->GetStripArray()->GetCount() == 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "Print..." item on the File menu if Vertical Editing is in progress.
/// Enables the item if the KBs are in a ready state, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFilePrint(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "Print Preview" item on the File menu if Vertical Editing is in progress.
/// Enables the item if the KBs are in a ready state, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFilePrintPreview(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

// Modified by whm 14Feb05 to support USFM and SFM Filtering.
// BEW 22Feb10, modified for support of doc version 5
bool CAdapt_ItView::IsWrapMarker(CSourcePhrase* pSrcPhrase)
{
	// refactored 19Mar09 -- no changes needed
	// Version 3 implementation: We first extract each marker from
	// the pSrcPhrase->m_markers member, and use Find to check if it is
	// in the appropriate wrap string UsfmWrapMarkersStr, PngWrapMarkersStr,
	// or UsfmAndPngWrapMarkersStr, depending on which map set is active.

	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markerStr = pSrcPhrase->m_markers;

	// combine m_markers (but ignore m_endMarkers) and the m_filteredInfo markers other
	// than the filterMkr and filterMkrEnd ones - use for the tests below
	wxString unwrappedMkrs = _T("");
	if (!pSrcPhrase->GetFilteredInfo().IsEmpty())
	{
		unwrappedMkrs = pSrcPhrase->GetFilteredInfo();
		unwrappedMkrs = pDoc->GetUnFilteredMarkers(unwrappedMkrs);
		markerStr += unwrappedMkrs;
	}
	// NormalizeToSpaces leaves the markers in m_markers delimited by spaces, at
	// lease medially. We'll use the Tokenize CString method here.
	wxString sfm;
	bool bValue = FALSE;

	wxStringTokenizer tkz(markerStr,_T(" "));

	while (tkz.HasMoreTokens())
	{
		sfm = tkz.GetNextToken();
		if (sfm[0] == gSFescapechar)	// Only check actual sfms. Some tokens will be only
										// numbers (those after \c and \v) which we ignore
		{
			// there shouldn't be any end marking asterisk * on a wrap marker, but
			// remove any that might exist for a clean search below.
			int endMkrPos = sfm.Find(_T('*'),TRUE); // TRUE finds from right end
			if (endMkrPos != -1)
				sfm = sfm.Left(endMkrPos);
			sfm.Trim(FALSE); // trim left end
			sfm.Trim(TRUE); // trim right end
			sfm += _T(' '); // ensure the sfm is followed by a space for unique find in
							// our wrap strings.
			// If only one of the sfms within markerStr is a wrap marker, we should return TRUE.
			switch (pApp->gCurrentSfmSet)
			{
				case UsfmOnly:
				{
					if (pApp->UsfmWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // it's in the wrap markers list, so start a new strip
					break;
				}
				case PngOnly:
				{
					if (pApp->PngWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // it's in the wrap markers list, so start a new strip
					break;
				}
				case UsfmAndPng:
				{
					if (pApp->UsfmAndPngWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // it's in the wrap markers list, so start a new strip
					break;
				}
				default:
				{
					// if we got here it would be a program error
					if (pApp->UsfmWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // found the sfm, so start a new strip
				}
			}
		}
	}

	// any other marker, we will just let it be ignored & go on setting up piles
	return bValue;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     the pointer to the CCell instance the user clicked
/// \param      pPoint  -> pointer to the wxPoint (logical coords) where the
///                        user clicked
/// \remarks
///
/// Interrogates the m_stripArray to termine which strip, pile and cell was clicked in;
/// returning the cell's pointer; it is the caller's responsibility to convert the client
/// coords for the click as returned from the event record, into a logical point, before
/// passing the result to GetClickedCell()
/////////////////////////////////////////////////////////////////////////////////
CCell* CAdapt_ItView::GetClickedCell(const wxPoint *pPoint)
{
	// refactored 6Apr09
	CLayout* pLayout = GetLayout();
	wxASSERT(pLayout != NULL);
	wxPoint point = *pPoint;
	CStrip* pStrip = NULL; // whm initialized to NULL
	CPile* pPile = NULL; // whm initialized to NULL
	CCell* pCell = NULL; // whm initialized to NULL
	wxRect rect;
	int	pileCountInStrip;
	int	pileIndexInStrip;
	int cellIndex;
	int stripIndex;
	wxArrayPtrVoid* pStripArray = pLayout->GetStripArray();
	int nStripCount = pStripArray->GetCount();

	// find the strip the click was in (we don't count a click on free translation text
	// as a valid click on the strip, neither is a click in the navText whiteboard area)
	for (stripIndex = 0; stripIndex < nStripCount; stripIndex++)
	{
		pStrip = (CStrip*)pStripArray->Item(stripIndex);
		wxASSERT(pStrip != NULL);
		pStrip->GetStripRect_CellsOnly(rect);
		rect = NormalizeRect(rect); // use our own from helpers.h
		if (rect.Contains(point))
			break;
	}
	if (stripIndex == nStripCount || pStrip == NULL)
		return NULL; // did not click within a strip
	else
	{
		// find which pile of the strip the click was in
		wxArrayPtrVoid*	pPilesArray = pStrip->GetPilesArray(); // gets ptr to m_arrPiles
		pileCountInStrip = pPilesArray->GetCount();
		for (pileIndexInStrip = 0; pileIndexInStrip < pileCountInStrip; pileIndexInStrip++)
		{
			pPile = (CPile*)pPilesArray->Item(pileIndexInStrip);
			pPile->GetPileRect(rect);
			rect = NormalizeRect(rect); // use our own from helpers.h
			if (rect.Contains(point))
				break;
		}
		if (pileIndexInStrip == pileCountInStrip || pPile == NULL)
			return NULL; // did not click within a pile - clicked in a gap, or at end, or in margin
		else
		{
			// find which cell the click was in
			for (cellIndex = 0; cellIndex < MAX_CELLS; cellIndex++)
			{
				pCell = pPile->GetCellArray()[cellIndex];
				if (pCell == NULL)
					continue;
				pCell->GetCellRect(rect);
				rect = NormalizeRect(rect); // use our own from helpers.h
				if (rect.Contains(point))
					break;
			}
			if (cellIndex == MAX_CELLS)
				return NULL; // click was not in a cell
		}
	}
	return pCell;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     return NULL if the click was not in a strip or its leading area - it should
///             be impossible to return NULL though; otherwise return the CStrip pointer
/// \param      pPoint  -> pointer to the wxPoint (logical coords) where the user clicked
/// \remarks
///
/// Interrogates the m_stripArray to termine which strip, or the leading just above it, the
/// user clicked in - returning the strip's pointer; it is the caller's responsibility to
/// convert the client coords for the click as returned from the event record, into a
/// logical point, before passing the result to GetNearestStrip()
/// The pStrip pointer passed back is the pointer to a CStrip instance, but we determine
/// that the strip was clicked on if either it or the leading area was clicked on - since
/// the note or wedge icons will be in the leading area.
/////////////////////////////////////////////////////////////////////////////////
CStrip* CAdapt_ItView::GetNearestStrip(const wxPoint *pPoint)
{
	// refactored 6Apr09
	CLayout* pLayout = GetLayout();
	wxASSERT(pLayout != NULL);
	wxArrayPtrVoid* pStripArray = pLayout->GetStripArray();
	int nStripCount = pStripArray->GetCount();

	wxPoint point = *pPoint;
	CStrip* pStrip = NULL;
	wxRect rect;
	int leading = pLayout->GetCurLeading(); // defines the vertical extent of the nav
											// text area above the strip
	int stripIndex;
	for (stripIndex = 0; stripIndex < nStripCount; stripIndex++)
	{
		pStrip = (CStrip*)(*pStripArray)[stripIndex];
		pStrip->GetStripRect_CellsOnly(rect);
		rect = NormalizeRect(rect); // use our own from helpers.h
        // subtract the leading from the top, because it's within there that we expect
        // clicks on the wedge to happen
        rect.SetTop(rect.GetTop()- leading); // In wx's wxRect, this only moves the x,y
                // coordinate and consequently the whole box, leaving the height the same,
                // therefore, we also need to reset the height to include the leading value
		rect.SetHeight(rect.GetHeight() + leading); // whm added
        // BEW changed 02Aug05 to handle RTL layout better - for these the click could be
        // outside the strip rectangle for a wedge offset to the right and at the right
        // edge of the strip; so instead just check that the vertical offset for the click
        // falls on or within the top and bottom coords of the rect
		if (point.y >= rect.GetTop() && point.y <= rect.GetBottom())
			break;
	}
	if (stripIndex == nStripCount)
		return NULL; // did not click within a strip or its leading area above it
	else
		return pStrip;
}

void CAdapt_ItView::RemovePrecedingAnchor(wxClientDC* pDC, CCell *pAnchor)
{
	// refactored 6Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCellList::Node* pos = pApp->m_selection.Find(pAnchor);
	wxASSERT(pos != NULL); // the anchor MUST be in the list!
	//CCell* pCell; // set but unused
	//pCell = (CCell*)pos->GetData(); // the earliest of desired seln
	pos = pos->GetPrevious();
	if (pos != NULL)
	{
		// there is selected CCell previous to the anchor cell,
		// so get rid of it & any earlier ones
		CCell* pPrevCell;
		while (pos != NULL)
		{
			CCellList::Node* savePos = pos;
			pPrevCell = (CCell*)pos->GetData();
			pos = pos->GetPrevious();
			pDC->SetBackgroundMode(pApp->m_backgroundMode);
			pDC->SetTextBackground(wxColour(255,255,255)); // white
			pPrevCell->DrawCell(pDC, GetLayout()->GetSrcColor());
			pPrevCell->SetSelected(FALSE);
			pApp->m_selection.DeleteNode(savePos);
		}
	}
}

void CAdapt_ItView::RemoveFollowingAnchor(wxClientDC *pDC, CCell *pAnchor)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCellList::Node* pos = pApp->m_selection.Find(pAnchor);
	wxASSERT(pos != NULL); // the anchor MUST be in the list!
	//CCell* pCell; // set but unused
	//pCell = (CCell*)pos->GetData(); // the last cell of desired seln
	pos = pos->GetNext();
	if (pos != NULL)
	{
		// there is selected CCell after the anchor cell,
		// so get rid of it & any later ones
		//CText* pText;
		CCell* pFollCell;
		while (pos != NULL)
		{
			CCellList::Node* savePos = pos;
			pFollCell = (CCell*)pos->GetData();
			pos = pos->GetNext();
			pDC->SetBackgroundMode(pApp->m_backgroundMode);
			pDC->SetTextBackground(wxColour(255,255,255)); // white
			pFollCell->DrawCell(pDC, GetLayout()->GetSrcColor());
			pFollCell->SetSelected(FALSE);
			pApp->m_selection.DeleteNode(savePos);
		}
	}
}

void CAdapt_ItView::RemoveEarlierSelForShortening(wxClientDC *pDC, CCell *pEndCell)
{
    // the "end cell" will be towards the left of the selection list (or at its start) when
    // the layout direction is either LTR or RTL, because we store in logical order. (Lower
    // sequence numbers are to the left.)

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	//CCell* pCell; // set but unused
	CCellList::Node* pos = pApp->m_selection.Find(pEndCell);
	if (pos != NULL)
	{
		//pCell = (CCell*)pos->GetData(); // the earliest of desired seln, for LTR
		pos = pos->GetPrevious();
		if (pos != NULL)
		{
			// there is previous selected CCell, so user must have shortened sel'n
			// so get rid of it & any earlier ones
			CCell* pPrevCell;
			while (pos != NULL)
			{
				CCellList::Node* savePos = pos;
				pPrevCell = (CCell*)pos->GetData();
				pos = pos->GetPrevious();
				pDC->SetBackgroundMode(pApp->m_backgroundMode);
				pDC->SetTextBackground(wxColour(255,255,255)); // white
				pPrevCell->DrawCell(pDC, GetLayout()->GetSrcColor());
				pPrevCell->SetSelected(FALSE);
				pApp->m_selection.DeleteNode(savePos);
			}
		}
	}
}

void CAdapt_ItView::RemoveLaterSelForShortening(wxClientDC *pDC, CCell *pEndCell)
{
    // the "end cell" will be towards the right of the selection list (or at its end) when
    // the layout direction is either LTR or RTL, because we store in logical order not
    // visible order (ie. larger sequence numbers are to the right in the list)
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	//CCell* pCell; // set but unused
	CCellList::Node* pos = pApp->m_selection.Find(pEndCell);
	if (pos != NULL)
	{
		//pCell = (CCell*)pos->GetData(); // the last of desired seln
		pos = pos->GetNext();
		if (pos != NULL)
		{
			// there is another selected CCell, so user must have shortened sel'n
			// so get rid of it & any subsequent ones
			CCell* pLaterCell;
			while (pos != NULL)
			{
				CCellList::Node* savePos = pos;
				pLaterCell = (CCell*)pos->GetData();
				pos = pos->GetNext();
				pDC->SetBackgroundMode(pApp->m_backgroundMode);
				pDC->SetTextBackground(wxColour(255,255,255)); // white
				pLaterCell->DrawCell(pDC, GetLayout()->GetSrcColor());
				pLaterCell->SetSelected(FALSE);
				pApp->m_selection.DeleteNode(savePos);
			}
		}
	}
}

bool CAdapt_ItView::IsBoundaryCell(CCell *pCell)
{
	return pCell->GetPile()->GetSrcPhrase()->m_bBoundary;
}

// returns the cell immediately preceding the pCell one, regardless of where boundaries
// are; returns null if no previous cell
CCell* CAdapt_ItView::GetPrevCell(CCell *pCell, int cellIndex)
{
	// refactored 7Apr09
	CPile* pPile = pCell->GetPile();
	PileList* pPiles = GetLayout()->GetPileList();
	int index = pPiles->IndexOf(pPile);
	index--; // index of previous CPile instance, could exceed bound
	if (index < 0)
	{
		return NULL; // bounds error - passed beginning of document
	}
	else
	{
		// not past beginning of document
		PileList::Node* pos = pPiles->Item(index);
		pPile = pos->GetData();
		wxASSERT(pPile != NULL);
	}
	return pPile->GetCell(cellIndex);
}

void CAdapt_ItView::RemoveSelection()
{
	// refactored 7May09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	pApp->m_bSelectByArrowKey = FALSE;
	if (pApp->m_selection.IsEmpty())
	{
		// if no selection is current, just ensure sel'n parameters are zeroed
		pApp->m_selectionLine = -1;
		pApp->m_pAnchor = (CCell*)NULL;

		// and the globals also
		gnSelectionLine = -1;
		gnSelectionStartSequNum = -1;
		gnSelectionEndSequNum = -1;
		return;
	}
	wxClientDC aDC(pApp->GetMainFrame()->canvas);
	CCell* pCell;

	// there is a current selection, so clobber it
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	while (pos != NULL)
	{
		pCell = (CCell*)pos->GetData();
		pos = pos->GetNext();
		aDC.SetBackgroundMode(pApp->m_backgroundMode); // Do not use wxTRANSPARENT!!
												// because background is not updated
		aDC.SetTextBackground(wxColour(255,255,255)); // white
		pCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
		pCell->SetSelected(FALSE);
	}
	pApp->m_selection.Clear();
	pApp->m_selectionLine = -1;
	pApp->m_pAnchor = (CCell*)NULL;

	// and the globals also need to be set to a "no selection" state
	gnSelectionLine = -1;
	gnSelectionStartSequNum = -1;
	gnSelectionEndSequNum = -1;

	// toggle Respect Boundaries button back on, so m_bRespectBoundaries is reset TRUE
	if (!pApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(dummyevent);
}

// DeepCopySublist2Sublist was in Helpers.cpp in the legacy version.
// Copies CSourcePhrase instances to an empty pCopiedSublist, as deep copies, and
// preserves m_nSequNumber values in the copies
// Called only once, in OnEditSourceText()
// BEW 22Mar10, updated for support of doc version 5 (no changes needed)
void CAdapt_ItView::DeepCopySublist2Sublist(SPList* pOriginalList, SPList* pCopiedSublist)
{
	if (pOriginalList->GetCount() == 0)
		return;
	SPList::Node* pos = pOriginalList->Item(0);
	wxASSERT(pos);
	//SPList::Node* savePos = NULL; // set but unused
	CSourcePhrase* pSrcPhrase = NULL;
	while (pos != NULL)
	{
		// deep copy each until all are copied
		//savePos = pos;
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		CSourcePhrase* pNewSP = new CSourcePhrase(*pSrcPhrase); // uses operator=,
															    // does shallow copy
		pNewSP->DeepCopy(); // pNewSP is now a deep copy
		pCopiedSublist->Append(pNewSP);
	}
}

// RemoveFilterWrappersButLeaveContent was in Helpers.cpp in the legacy version.
// removes "\~FILTER" and "\~FILTER*" from str, but leaves the SFM, its content, and any
// following endmarker followed by any whitespace etc.
// BEW 23Mar10 updated for support of doc version 5 (no changes needed)
// BEW 9July10, no changes needed for support of kbVersion 2
void CAdapt_ItView::RemoveFilterWrappersButLeaveContent(wxString& str)
{
	// uses global strings, filterMkr and filterMkrEnd; removes the latter first, and then
	// the former
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	wxString strRemoveThis = filterMkrEnd;
	int len = strRemoveThis.Length();
	wxString strBegin;
	wxString strEnd;
	wxChar ch;
	bool bIsWhitespace = FALSE;
	int offset = -1;
	do {
		offset = str.Find(strRemoveThis);
		if (offset != -1)
		{
			// there is one to be removed
			strBegin = str.Left(offset);
			strEnd = str.Mid(offset);
			strEnd = strEnd.Mid(len); // this removes the "\\~FILTER*" which we found
			// now remove any following whitespace, which now is at the start of strEnd
			ch = strEnd[0];
			bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			while (bIsWhitespace)
			{
				strEnd = strEnd.Mid(1); // remove initial white space character
				ch = strEnd[0];
				bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			}
			// now rejoin the begin and end parts
			str = strBegin + strEnd;
		}
	} while (offset != -1);
	// now do the loop to remove any instances of "\\~FILTER" followed by whitespace
	strRemoveThis = filterMkr;
	len = strRemoveThis.Length();
	offset = -1;
	do {
		offset = str.Find(strRemoveThis);
		if (offset != -1)
		{
			// there is one to be removed
			strBegin = str.Left(offset);
			strEnd = str.Mid(offset);
			strEnd = strEnd.Mid(len); // this removes the "\\~FILTER*" which we found
			// now remove any following whitespace, which now is at the start of strEnd
			bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			while (bIsWhitespace)
			{
				strEnd = strEnd.Mid(1); // remove initial white space character
				bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			}
			// now rejoin the begin and end parts
			str = strBegin + strEnd;
		}
	} while (offset != -1);
}

// ReplaceCSourcePhrasesInSpan was in Helpers.cpp in the legacy version.
/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error. (Also, if either
///             list is empty, nothing is done and the function returns FALSE.)
/// \param      pMasterList        -> pointer to the list of CSourcePhrase pointers where the
///                                   replacements are to be done (typically, the app's
///                                   m_pSourcePhrases list)
/// \param      nStartAt           -> the 0-based index into the pMasterList which is the first
///                                   CSourcePhrase instance to be replaced (the originals
///                                   are deleted, the replacments are inserted in the gap
///                                   where they were located)
/// \param      nHowMany           -> the 1-based count of how many consecutive CSourcePhrase
///                                   pointers are to be removed from pMasterList to make way
///                                   for the replacements; this value must not be zero
/// \param      pReplacementsList  -> pointer to the list from which all or a subrange of
///                                   replacement CSourcePhrase instances are to be inserted
///                                   where the originals were removed from in pMasterList
/// \param      nReplaceStartAt    -> 0-based index into pReplacementsList which locates the
///                                   first CSourcePhrase instance which is to be inserted
///                                   into pMasterList
/// \param      nReplaceCount      -> 1-based count of how many consecutive CSourcePhrase
///                                   pointers are to be inserted into pMasterList.
///                                   (nReplaceCount can be less, equal, or greater than
///                                   nHowMany.) Note: this value can be zero, in which
///                                   case no insertions are done, but the deletions are done
/// \remarks
/// Called from: the View's RestoreDocAfterSrcTextEditModifiedIt(), OnEditSourceText(),
/// OnCustomEventAdaptationsEdit(), OnCustomEventGlossesEdit(),
/// This is a utility function for clearing out a span of CSourcePhrase instances from a
/// list and replacing them with a different span taken from some part (or the whole) of
/// some other list.
/// The ones cleared out are deleted (their contents are lost), the ones inserted are then
/// managed by the pMasterList, and usually that list is persistent, and the
/// pReplacementsList is temporary, but neither assumption is necessary or assumed. The
/// contents of pReplacementsList are not altered; so what actually are inserted are deep
/// copies of the instances in pReplacementsList. The nHowMany and nReplaceCount parameters
/// must not both be zero, if that is the case, it is an error.
///
/// The nReplaceCount value can be zero, if it is, the function is just being used to
/// delete a range of CSourcePhrase instances within a list.
/// The nHowMany value can be zero, if it is, the function is just being used to insert a
/// range of CSourcePhrase instances within a list, preceding the nStartAt instance's
/// location. BEW added to, 19Jun09. If some replacements are to be done at the doc end
/// (eg. after an edit which removed some words, and it goes belly up and the code tries to
/// restore original doc, calling this function) then nStartAt will be just beyond the
/// current end of the document. The older code did not test for this and then the
/// Item(nStartAt) produced a crash. The fix is to test for this bounds error, and send
/// control to a block of code which merely appends the replacements, rather than trying to
/// do insertions.
/// BEW 22Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ReplaceCSourcePhrasesInSpan(SPList* pMasterList, int nStartAt, int nHowMany,
					SPList* pReplacementsList, int nReplaceStartAt, int nReplaceCount)
{
	// 26May08	function created as part of refactoring the Edit Source Text functionality
	// whm note: Bruce has this function in helpers.h and .cpp, but it is only used in the
	// View so I moved it to the View.
    // (BEW 22Mar10, I'd like to see this go back in helpers.cpp as it is a potential
    // utility function which could be used in other places at a later date.)
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	SPList::Node* posMaster = NULL; //POSITION posMaster = NULL;
	SPList::Node* posReplace = NULL; //POSITION posReplace = NULL;
	wxString error;
    // do nothing if either list has no elements, or if nothing; treat it as an error state
	if (pMasterList->GetCount() == 0)
		return FALSE;
	if (pReplacementsList->GetCount() == 0)
		return FALSE;
	if (nHowMany == 0 && nReplaceCount == 0)
		return FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pReplaceSrcPhrase = NULL;
	CSourcePhrase* pDeepCopiedSrcPhrase = NULL;

//#ifdef _debugLayout
//ShowSPandPile(393, 30);
//ShowSPandPile(394, 30);
//ShowInvalidStripRange();
//#endif

	int maxIndex = pApp->GetMaxIndex();
	if (nStartAt > maxIndex)
	{
		// just append the replacements
		posReplace = pReplacementsList->Item(nReplaceStartAt);
		int anIndex;
		SPList::Node* pos2 = NULL;
		int endAt = nReplaceStartAt + nReplaceCount -1;
		for (anIndex = nReplaceStartAt; anIndex <= endAt; anIndex++)
		{
			pReplaceSrcPhrase = posReplace->GetData();
			posReplace = posReplace->GetNext();
			pDeepCopiedSrcPhrase = new CSourcePhrase(*pReplaceSrcPhrase);
			pDeepCopiedSrcPhrase->DeepCopy(); // make the deep copy
			wxASSERT(pDeepCopiedSrcPhrase != NULL);
			// add each deep copy to the end of the master list
			pos2 = pMasterList->Append(pDeepCopiedSrcPhrase);
			pos2 = pos2; // avoid warning
			pDoc->CreatePartnerPile(pDeepCopiedSrcPhrase);
		}
		return TRUE;
	}
	else
	{
		posMaster = pMasterList->Item(nStartAt);
		if (posMaster == NULL)
		{
			// whm note: I don't think this error needs to be translated for localization
			// an unexpected exception, so inform the caller & advise the user of the error
			error = _T(
"FindIndex() failed in helper function ReplaceCSourcePhrasesInSpan(), posMaster value is NULL. ");
			error += _T("Abandoning current operation.");
			error += _T(" (If restoring document's original state, it is not properly restored.");
			wxMessageBox(error, _T(""), wxICON_EXCLAMATION | wxOK);
			return FALSE;
		}
	}
//#ifdef _debugLayout
//ShowSPandPile(393, 31);
//ShowSPandPile(394, 31);
//ShowInvalidStripRange();
//#endif
	posReplace = pReplacementsList->Item(nReplaceStartAt);
	if (posMaster == NULL)
	{
		// whm note: I don't think this error need to be translated for localization
		// an unexpected exception, so inform the caller & advise the user of the error
		error = _T(
"FindIndex() failed in helper function ReplaceCSourcePhrasesInSpan(), posReplace value is NULL. ");
		error += _T("Abandoning current operation.");
		error += _T(" (If restoring document's original state, it is not properly restored.");
		wxMessageBox(error, _T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}

	// First delete the old (ie. unwanted) instances from the main list
	SPList::Node* posSaved = NULL;
	SPList::Node* pos2 = NULL;
	int index;

	// special case 1: only insertions are wanted, no deletions
	if (nHowMany == 0)
	{
		// insertion is wanted, preceding posMaster location
ins:	;
//#ifdef _DEBUG
		//SPList::Node* posDebug = pMasterList->GetFirst();
		//for (index = 0; index < (int)pMasterList->GetCount(); index++)
		//{
		//	CSourcePhrase* pSrcPh;
		//	pSrcPh = posDebug->GetData();
		//	posDebug = posDebug->GetNext();
		//	wxLogDebug(_T("pMasterList BEFORE Insert: pSrcPh->m_srcPhrase = %s"),
		//	pSrcPh->m_srcPhrase.c_str());
		//}
//#endif

		for (index = 0; index < nReplaceCount; index++)
		{
			// insert them in normal order, each preceding the posMaster POSITION
			pReplaceSrcPhrase = posReplace->GetData();
			posReplace = posReplace->GetNext();
			pDeepCopiedSrcPhrase = new CSourcePhrase(*pReplaceSrcPhrase);
			pDeepCopiedSrcPhrase->DeepCopy(); // make the deep copy
			wxASSERT(pDeepCopiedSrcPhrase != NULL);
			// insert each deep copy before the posMaster location each time
			pos2 = pMasterList->Insert(posMaster, pDeepCopiedSrcPhrase);
			pos2 = pos2; // avoid warning
			// BEW added 13Mar09 for refactored layout
			pDoc->CreatePartnerPile(pDeepCopiedSrcPhrase); // also marks its or a
														// nearby strip as invalid

//#ifdef _debugLayout
//ShowSPandPile(393, 34);
//ShowSPandPile(394, 34);
//ShowInvalidStripRange();
//#endif
			// break out of loop if we have come to the end of the replacements list
			if (pReplaceSrcPhrase == NULL)
				break;
		}
//#ifdef _DEBUG
		//posDebug = pMasterList->GetFirst();
		//for (index = 0; index < (int)pMasterList->GetCount(); index++)
		//{
		//	CSourcePhrase* pSrcPh;
		//	pSrcPh = posDebug->GetData();
		//	posDebug = posDebug->GetNext();
		//	wxLogDebug(_T("pMasterList AFTER Insert: pSrcPh->m_srcPhrase = %s"),
		//	pSrcPh->m_srcPhrase.c_str());
		//}
//#endif
		return TRUE;
	}
	else
	{
		// nHowMany is not zero, so deletions are wanted
		if (nReplaceCount == 0)
		{
			// no insertions are wanted, so only the deletions - which have already
			// been done, so return TRUE
			return TRUE;
		}
		else
		{
//#ifdef _debugLayout
//ShowSPandPile(393, 32);
//ShowSPandPile(394, 32);
//ShowInvalidStripRange();
//#endif
			// delete the non-empty range of originals from pMasterList
			for (index = 0; index < nHowMany; index++)
			{
				posSaved = posMaster;
				wxASSERT(posSaved);
				pSrcPhrase = posMaster->GetData(); // assume success
				posMaster = posMaster->GetNext();
				pApp->GetDocument()->DeleteSingleSrcPhrase(pSrcPhrase); // delete pSrcPhrase
					// and its elements from memory locations; also calls DeletePartnerPile()
				pMasterList->DeleteNode(posSaved);	// delete the list's pSrcPhrase element
				// break out of the loop if we have come to the end of the pMasterList
				if (posMaster == NULL)
					break;
			}

			// now insert the non-empty range of replacements at the same location
			if (nStartAt == (int)pMasterList->GetCount())
			{
                // there is no CSourcePhrase instance now at the nStartAt value, because we
                // deleted right to the end of the master list inclusively, so we only need
                // append each to the tail of the pMasterList
				for (index = 0; index < nReplaceCount; index++)
				{
					// get a deep copy
					pReplaceSrcPhrase = posReplace->GetData();
					posReplace = posReplace->GetNext();
					pDeepCopiedSrcPhrase = new CSourcePhrase(*pReplaceSrcPhrase);
					pDeepCopiedSrcPhrase->DeepCopy(); // make the deep copy
					wxASSERT(pDeepCopiedSrcPhrase != NULL);
					// append each deep copy to the master list
					pos2 = pMasterList->Append(pDeepCopiedSrcPhrase);

					// BEW added 13Mar09 for refactored layout
					pDoc->CreatePartnerPile(pDeepCopiedSrcPhrase); // also marks the owning
													// strip, or a nearby one, as invalid

					// break out of loop if we have come to the end of the replacements list
					if (pReplaceSrcPhrase == NULL)
						break;
				}
//#ifdef _debugLayout
//ShowSPandPile(393, 33);
//ShowSPandPile(394, 33);
//ShowInvalidStripRange();
//#endif
			}
			else
			{
                // there is a CSourcePhrase instance at the nStartAt location, it has moved
                // down to occupy the location from which the earlier deletions were
                // started, so we must now insert before it
				posMaster = pMasterList->Item(nStartAt);
				if (posMaster == NULL)
				{
					// an unexpected exception, so inform the caller & advise the user of
					// the error
					error = _T(
			"FindIndex() failed in helper function ReplaceCSourcePhrasesInSpan(), ");
					error += _T(
			"posMaster value is NULL when finding the POSITION of first CSourcePhrase ");
					error += _T("following the gap. Abandoning current operation.");
					error += _T(
			" (If restoring document's original state, it is not properly restored.");
					wxMessageBox(error, _T(""), wxICON_EXCLAMATION | wxOK);
					return FALSE;
				}
//#ifdef _debugLayout
//ShowSPandPile(393, 35);
//ShowSPandPile(394, 35);
//ShowInvalidStripRange();
//#endif
				goto ins;
			}
		}
	}
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////////
///	GetMarkerArrayFromString
///
///	Returns:	a CString containing one or more whole markers (ie. including
///                backslash) and each with a delimiting single space following it,
///                including the last
///	Parameters:
///		pStrArr	<-	populated with CStrings, each being a whole marker
///		            (no delimiting space)
///		str		->	ref to the string containing a mix of markers and text (e.g.
///                 SFM marked up source text) from which the whole markers are
///                 to be found and inserted into the aray returned to the caller
///	Comments:
///    Extracts an array of whole markers, in order of occurrence (not sorted). There might
///    not be might not be any SF markers in the passed in str, in which case an empty
///    array is returned. The array's initial size (0) and growby value (1) are set first
///    here before it is populated. We are not interested in preventing multiple identical
///    entries because the function that will use the returned array is interested only in
///    the unique markers, and works whether there are repeats or not. (Used by the
///    AreMarkerArraysDifferent() helper function, which is used in the Edit Source Text
///    refactored code (see OnEditSourceText()) to detect when the user has modified a
///    marker when doing his edit - such as when correcting a misspelled marker to be what
///    it should be.)
///	History:
///	Created 17June08 by BEW, for support of refactored Source Text Edit functionality
///
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::GetMarkerArrayFromString(wxArrayString* pStrArr, const wxString& str)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	pStrArr->Clear();
	wxString aMarker;
	wxString s(str); // we'll modify only this local copy
	int offset = 0;
	wxChar backslash = _T('\\');
	offset = FindFromPos(s,backslash,offset);
	if (offset == -1)
		return;
	int index = 0;
	while (offset != -1)
	{
		s = s.Mid(offset); // point at the backslash of the marker
		aMarker = pDoc->GetWholeMarker(s);
		// insert in the array
		// whm Note: wxArrayInt doesn't have MFC's SetAtGrow() method, but we can
		// accomplish the same thing. We can use the ::SetCount() method of wxArray to
		// ensure the array has at least anArrayIndex + 1 elements, then assign locIndex
		// to element anArrayIndex. We only call SetCount() if the array is too small.
		if (index+1 > (int)pStrArr->GetCount())
			pStrArr->SetCount(index+1); // any added elements to the array are assigned
										// int(0) by default
		(*pStrArr)[index] = aMarker;
		// point past the backslash & get the offset to the next marker
		offset++;
		offset = FindFromPos(s,backslash,offset);
		index++;
	}
}

/////////////////////////////////////////////////////////////////////////////////
///
///	IsMarkerInArray
///
///	Returns:	TRUE if the array contains at least one instance of the whole marker
///	            being tested, FALSE if the marker is absent from the array, or the
///	            array is empty
///
///	\param	pStrArr	->	populated with CStrings, each being a whole marker (no
///                     delimiting space), derived from a string containing a mix of
///                     markers and their text content
///	\param	marker	->	a SF marker, including initial backslash, and with no
///		                delimiting space at the end
///	\remarks
///    Iterates through the whole array, testing for identity with the passed in marker. As
///    soon as a match is made, it returns. (Used by the AreMarkerArraysDifferent() helper
///    function). If the array contains no elements, the return result is FALSE.
///
///	History:
///	Created 17June08 by BEW, for support of refactored Source Text Edit functionality
///	BEW 23Mar10, no changed needed for support of doc version 5
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsMarkerInArray(wxArrayString* pStrArr, const wxString& marker)
{
	int index;
	wxString aMarker;
	int nSize = pStrArr->GetCount();
	if (nSize == 0)
		return FALSE;
	for (index = 0; index < nSize; index++)
	{
		aMarker = (*pStrArr)[index];
		wxASSERT(!aMarker.IsEmpty());
		if (aMarker == marker)
			return TRUE;
	}
	return FALSE; // no match was made
}

/////////////////////////////////////////////////////////////////////////////////
///	\return    TRUE if the arrays are different (meaning that one or the other has
///            at least one SF marker which is not in the other, repeated markers will
///            have more than one entry in the passed in array(s), but that is not
///            relevant to the result)
///	\param     str1	                   ->	a string containing marked up (SFM or USFM)
///	                                        text, such as source text
///	\param	   str2	                   ->	a string containing marked up (SFM or USFM)
///	                                        text, such as edited source text
///	\param     bUnfilteringRequired	   <-	TRUE if a "to-be-unfiltered" entry is added
///	                                        to m_FilterStatusMap, FALSE if not
///	\param     bFilteringRequired	   <-	TRUE if a "to-be-filtered" entry is added to
///	                                        m_FilterStatusMap, FALSE if not
///\remarks
///    Compares the unique markers in the strings, looking for evidence that there is at
///    least one marker which is not in the other string. It is done in both directions, in
///    case one of the strings has a subset of markers which are in the other - as testing
///    the contents of just one string agains the contents of the other (with perhaps an
///    extra unique marker) could produce a FALSE result, when doing it the other way round
///    would produce a TRUE result. So we do it both ways to make sure the result is
///    correct. An string without markers tested against one with one or more in it will
///    also generate a TRUE result; both strings lacking SF markers generates a FALSE
///    result.
///
///    IMPORTANT note regarding usage: str1 must be the original editable source text
///    string, str2 must be the new source text string, because the code added on 4July08
///    tests each marker in str2 to see if it is included in str1, and each which fails
///    that test will cause an entry to be added to m_FilterStatusMap which is a document
///    class member which controls the operation of RetokenizeText() when filter changes
///    are relevant to the document rebuild. BEW changed, to exclude dependence on
///    m_FilterStatusMap
///
///	History:
///	Created 17June08 by BEW, for support of refactored Source Text Edit functionality
///    4July08, BEW added code for adding entries to m_FilterStatusMap; the code should
///    handle most situations but is not foolproof, and it relies on the caller supplying
///    the original editable text as str1, and the new editable text as str2.
///    6July08, BEW removed the need to use m_FilterStatusMap entries in the
///    OnEditSourceText() refactored code by using DoMarkerHousekeeping() over the whole
///    document, rather than rebuilding the whole document using the RetokenizeText() call
///    as the legacy function used to do; consequently the calls to
///    AddEntryToFilterStatusMap() below are commented out, and two functions are thereby
///    removed from the code because they are no longer needed (the other is
///    CopyStringToStringMap())
/// BEW 23Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::AreMarkerSetsDifferent(const wxString& str1, const wxString& str2,
								bool& bUnfilteringRequired,bool& bFilteringRequired)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	int index;
	wxString aMarker; // use for a whole marker, with no trailing space
					  // (ie. backslash plus bare marker)
	wxString aMkrWithSpace; // construct a string comprised of marker plus trailing
							// space, here
	bool bShouldBeFiltered;
	bool bReturnValue = FALSE; // start with a safe default (ie. marker sets
							   // are the same)
	bool bMatched = TRUE;
	wxArrayString* pStrArr1 = new wxArrayString;
	wxArrayString* pStrArr2 = new wxArrayString;

	// get their marker inventories in the form of wxArrayString arrays
	GetMarkerArrayFromString(pStrArr1, str1);
	GetMarkerArrayFromString(pStrArr2, str2);

	// initialize the flag values to be returned to the caller
	bUnfilteringRequired = FALSE;
	bFilteringRequired = FALSE;

	// get the sizes of these two arrays
	int nSize1 = pStrArr1->GetCount();
	int nSize2 = pStrArr2->GetCount();

	// bleed out the easy cases
	if (nSize1 == 0 && nSize2 == 0)
	{
		if (pStrArr1 != NULL) // whm 11Jun12 added NULL test
			delete pStrArr1;
		if (pStrArr2 != NULL) // whm 11Jun12 added NULL test
			delete pStrArr2;
		return FALSE; // both empty, they can't be different
	}
	// check for new source text with no markers
	if (nSize2 == 0)
	{
		// new source text has no markers, the other must have at
		// least one, so they are different; and no filtering or
		// unfiltering is involved because there is no marker which
		// could be a candidate (sso m_FilterStatusMap remains empty)
		pStrArr1->Clear();
		if (pStrArr1 != NULL) // whm 11Jun12 added NULL test
			delete pStrArr1;
		if (pStrArr2 != NULL) // whm 11Jun12 added NULL test
			delete pStrArr2;
		return TRUE;
	}
	// check for pre-edit source text with no markers
	// NOTE: see the long comment below for a discussion of the (small) weakness of
	// this simple algorithm for determining what entries to add to m_FilterStatusMap
	if (nSize1 == 0)
	{
		// no markers in the pre-edit source text, the new source text therefore
		// must have at least one, so the sets are different. Moreover, every marker
		// in the new source text as a result of the first set being empty, must be
		// given an entry in m_FilterStatusMap
		for (index = 0; index < nSize2; index++)
		{
			aMarker = (*pStrArr2)[index];
			wxASSERT(!aMarker.IsEmpty());
            // this aMarker SF marker is known not to be in the pre-edit source text, so
            // the arrays are different; and so this marker has to generate an entry for
            // the map m_FilterStatusMap
			bReturnValue = TRUE;

			// determine if this is filterable or not, and set up the entry accordingly
			aMkrWithSpace = aMarker + _T(' ');
			bShouldBeFiltered = IsMarkerWithSpaceInFilterMarkersString(aMkrWithSpace,
														pApp->gCurrentFilterMarkers);
			if (bShouldBeFiltered)
				bFilteringRequired = TRUE;
			else
				bUnfilteringRequired = TRUE;
		}
		if (pStrArr1 != NULL) // whm 11Jun12 added NULL test
			delete pStrArr1;
		pStrArr2->Clear();
		if (pStrArr2 != NULL) // whm 11Jun12 added NULL test
			delete pStrArr2;
		goto b;
	}

    // when both arrays have content, we must test each marker against all those in the
    // other array, doing this in both directions - because we must be sure to get a
    // correct BOOL result in the situation where one marker set may be a subset of the
    // other

    // iterate across the markers in the first array, testing for a non-match in the second
    // (all we are interested in for this loop is to find any pre-edit markers which are
    // not in the post-edit source text string
	for (index = 0; index < nSize1; index++)
	{
		aMarker = (*pStrArr1)[index];
		wxASSERT(!aMarker.IsEmpty());
		bMatched = IsMarkerInArray(pStrArr2, aMarker);
		if (!bMatched)
		{
			// this aMarker SF marker is not in array 2, so the arrays are different
			bReturnValue = TRUE;
		}
	}
	// iterate across the markers in the second array, (the new source text),
	// testing for a non-match in the first (the original text before editing happened)
	// -- this loop is where we possibly may add entries to m_FilterStatusMap
	//
    // This algorithm has an obvious weakness: if the original pre-edit source text has
    // \mkr1 (a misspelled marker which the user will edit to be \mkr2 which is filterable)
    // and also has an instance of \mkr2 as well, then changing \mkr1 to \mkr2 in the edit
    // dialog results in the new source text having \mkr2; and when we test \mkr2 to see if
    // it is in the pre-edit text string, we would find that it is, and so no entry would
    // get added to m_FilterStatusMap, when in actual fact it really should have, because a
    // misspelled marker has been fixed so as to be a to-be-filtered one, but the caller
    // will subsequently not call RetokenizeText() to do the filtering because the map has
    // had no entry put in it. The user can reduce the likelihood of such a situation by
    // just selecting the one word where the typo marker is stored, and do the change to
    // the correct marker in the dialog; however, if the typo marker is changed to be one
    // which comes with a matching endmarker, then the user's selection needs to be all the
    // words up to where the endmarker is stored (but not necessarily selecting the
    // CSourcePhrase instance because the TextType may change and prevent it being selected
    // anyway, but our code will still pick up the bad endmarker and show it to the user in
    // the edit source text dialog).
	//
    // So, the rule when making a good selection to correct a typo marker is: if it is
    // supposed to have an endmarker, select all the words which are to be enclosed by the
    // marker - endmarker pair, but if the typo marker is to be changed to one which has no
    // endmarker, just select the word which has the typo marker stored in its
    // CSourcePhrase instance. Doing that makes the algorithm 100% reliable.
	//
    // The likelihood of a selection with a bad marker also having an instance of the
    // filterable marker which the user will change the bad marker to be when he edits, is
    // very very small; so our simplistic algorithm should actually do the job quite well,
    // probably for everyone and every time; and it is guaranteed to work if the user
    // adhere's to the above rules for the selection
	for (index = 0; index < nSize2; index++)
	{
		aMarker = (*pStrArr2)[index];
		wxASSERT(!aMarker.IsEmpty());
		bMatched = IsMarkerInArray(pStrArr1, aMarker);
		if (!bMatched)
		{
			// this aMarker SF marker is not in array 1, so the arrays are different
			// and so this marker has to generate an entry for the map m_FilterStatusMap
			bReturnValue = TRUE;

			// determine if this is filterable or not, and set up the entry accordingly
			aMkrWithSpace = aMarker + _T(' ');
			bShouldBeFiltered = IsMarkerWithSpaceInFilterMarkersString(aMkrWithSpace,
														pApp->gCurrentFilterMarkers);
			if (bShouldBeFiltered)
				bFilteringRequired = TRUE;
			else
				bUnfilteringRequired = TRUE;
		}
	}
	// clean up
	pStrArr1->Clear();
	if (pStrArr1 != NULL) // whm 11Jun12 added NULL test
		delete pStrArr1;
	pStrArr2->Clear();
	if (pStrArr2 != NULL) // whm 11Jun12 added NULL test
		delete pStrArr2;
b:	return bReturnValue;
}

// BEW 23Mar10, no change needed for doc version 5
bool CAdapt_ItView::IsMarkerWithSpaceInFilterMarkersString(wxString& mkrWithSpace,
														   wxString& strFilterMarkers)
{
	int offset = strFilterMarkers.Find(mkrWithSpace); // the trailing space
												// prevents spurious matches
	if (offset == -1)
		return FALSE;
	else
		return TRUE;
}

void CAdapt_ItView::DoSrcPhraseSelCopy()
{
	// refactored 7Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCellList* pCellList = &pApp->m_selection; // get a local pointer
	wxString str; // accumulate the words / phrases here
	str.Empty();
	CCellList::Node* pos = pCellList->GetFirst();
	if (pos == NULL)
		return;
	if (pApp->m_selectionLine == 0)
	{
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData();
			pos = pos->GetNext();
			if (pCell == NULL)
				return;
			CSourcePhrase* pSrcPhrase = pCell->GetPile()->GetSrcPhrase();
			wxASSERT(pSrcPhrase != NULL);

			if (pCell->GetPile() == pApp->m_pActivePile)
			{
				if (!pApp->m_targetPhrase.IsEmpty())
				{
					if (!pApp->m_targetPhrase.IsEmpty())
					{
						if (str.IsEmpty())
							str = pApp->m_targetPhrase;
						else
							str += _T(" ") + pApp->m_targetPhrase;
					}
				}
			}
			else
			{
				if (str.IsEmpty())
				{
					if (gbIsGlossing)
					{
						if (!pSrcPhrase->m_gloss.IsEmpty())
							str = pSrcPhrase->m_gloss;
					}
					else
					{
						if (!pSrcPhrase->m_targetStr.IsEmpty())
							str = pSrcPhrase->m_targetStr;
					}
				}
				else
				{
					if (gbIsGlossing)
					{
						if (!pSrcPhrase->m_gloss.IsEmpty())
							str += _T(" ") + pSrcPhrase->m_gloss;
					}
					else
					{
						if (!pSrcPhrase->m_targetStr.IsEmpty())
							str += _T(" ") + pSrcPhrase->m_targetStr;
					}
				}
			}
		}
	}
	else
		return;

	if (wxTheClipboard->Open())
	{
		// This data objects are held by the clipboard,
		// so do not delete them in the app.
		// SetData clears all previous contents in the clipboard
		// so there is no need to call Clear
		wxTheClipboard->SetData( new wxTextDataObject(str) );
		wxTheClipboard->Close();
	}
	else
	{
		wxMessageBox( _("Cannot open the Clipboard"), _T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
}

// Return value: TRUE if all was well (whether or not an actual store to KB took place -
// because certain flags inhibit saves, or an empty targetBox does not get anything saved
// to a KB if the <no adaptation> button was not pressed), and FALSE if the store could not
// be done (eg. if the embedded call to StoreText returned FALSE) ammended, July 2003, for
// auto-capitalization support
// BEW ***NOTE *** 4Feb11: Do not call this function in the handler for the user having
// just changed the punctuation settings, that is, do not call it in
// DoPunctuationChanges(), which is an app class member function. In such a context, the
// status of each character, whether punctuation or word-building, and whether or not all
// target text word-building characters are restored to the word proper or not, is not
// determinate -- some kinds of punct changes would be benign (such as changing a
// word-initial or word final word-building character to be a punctuation character) would
// give a correct KB entry, but the opposite would give a faulty KB entry because the
// phrase box contents won't have the required string (unless the user has typed it
// manually, which can't be guaranteed) and so a word-building character would be lost from
// the start or end of the target text word or phrase. A further problem is that
// StoreBeforeProceeding calls MakeTargetStringIncludingPunctuation() and the latter has a
// different protocol regarding punctuation than does the code for handling a user's
// punctuation set changes: the MakeTargetStringIncludingPunctuation() interprets
// differences between the punctuation on the target text, and that stored in the
// m_precPunct & m_follPunct & m_follOuterPunct as indicating manual typing which should
// replace the latter with the former - which would be an incorrect assumption if this
// function is called in the handler for doing changes to the punctuation settings - the
// latter scenario regards such differences as additive, not replacive, and gives
// potentially different results.
bool CAdapt_ItView::StoreBeforeProceeding(CSourcePhrase* pSrcPhrase)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	RemoveSelection(); // ensure we don't have any selection current
	bool bOK = FALSE;

    // OnIdle( ) probably will have done any needed case changing, but just in case we will
    // check and if it has not been done, then do it here instead
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = pApp->GetDocument()->SetCaseParameters(pApp->m_pActivePile->GetSrcPhrase()->m_key);
		if (bNoError && gbSourceIsUpperCase)
		{
			bNoError = pApp->GetDocument()->SetCaseParameters(pApp->m_targetPhrase,FALSE);
			if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
			{
				pApp->m_targetPhrase.SetChar(0,gcharNonSrcUC);
			}
		}
	}

	if (gbIsGlossing)
	{
		if (!pSrcPhrase->m_bHasGlossingKBEntry)
		{
			if (!pApp->m_targetPhrase.IsEmpty())
			{
				// it has to be saved to the glossing KB if not empty
				bOK = pApp->m_pGlossingKB->StoreText(pSrcPhrase,pApp->m_targetPhrase);
			}
			else
				bOK = TRUE; // no store, but not an error so return TRUE
		}
		return bOK;
	}
	else
	{
		if (pApp->m_bSaveToKB && !pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB)
		{
			if (!pApp->m_targetPhrase.IsEmpty())
			{
				// it has to be saved to the KB if not empty
				MakeTargetStringIncludingPunctuation(pSrcPhrase,pApp->m_targetPhrase);
				RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);
				gbInhibitMakeTargetStringCall = TRUE;
				bOK = pApp->m_pKB->StoreText(pSrcPhrase,pApp->m_targetPhrase);
				gbInhibitMakeTargetStringCall = FALSE;
			}
			else
				bOK = TRUE; // no store, but not an error so return TRUE
		}
		pApp->m_bSaveToKB = TRUE; // make sure it's turned on
		return bOK;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle
///                        handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// Disables the "Advance To End" toolbar item if Vertical Editing is in progress. If the
/// m_pActivePile pointer is NULL or there are no source phrase in the m_pSourcePhrases
/// list, this handler disables the "Advance To End" toolbar item and returns immediately.
/// It enables the toolbar item if the App's m_endIndex is greater than zero but less than
/// the count in m_pSourcephrases -1, otherwise it disables the toolbar item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonToEnd(wxUpdateUIEvent& event)
{
	// refactored 7Apr09
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum < pApp->GetMaxIndex())
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonToEnd(wxCommandEvent& event)
{
    // refactored 9Apr09 **** TODO **** can be restructured to have only one RecalcLayout()
    // call -- see OnButtonStepDown() for how to do it (relies on fact that the internal
    // code can make all decisions about whether to move or not without having to recalc
    // the layout, and then only do the one recalc call at the end)
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (pApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->ChangeValue(tempStr);
	}
	gnOldSequNum = pApp->m_nActiveSequNum; // save old location

	SPList* pList = pApp->m_pSourcePhrases;

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	wxASSERT(pApp->m_pActivePile != NULL);
	bool bOK;
	bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());
    // BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
    // StoreBeforeProceeding() returns FALSE without doing any store, and in that case we
    // don't want to return from OnButtonToEnd immediately because then we have no way to
    // navigate to the end of the document by this button; instead, just ignore the bOK
    // value
	if (!bOK)
	{
		//return;
		; // just do nothing (avoids compiler warning baout bOK not being accessed)
	}

	int nSequNum = pApp->GetMaxIndex(); // make active element be the last one in the list
	pApp->m_nActiveSequNum = nSequNum;

	SPList::Node* spos = pList->GetLast();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)spos->GetData();

    // if free translation mode is on, we would not want the box to be at the very end if
    // there was already a free translation ending there - so make the adjustment if
    // required so that box goes instead to the last anchor position
	if (pApp->m_bFreeTranslationMode)
	{
		if (pSrcPhrase->m_bHasFreeTrans && !pSrcPhrase->m_bStartFreeTrans)
		{
			// move back to the sequ num for the anchor position
			SPList::Node* pos = pList->GetLast();
			int count = 0;
			while (TRUE)
			{
				count++;
				pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetPrevious();
				wxASSERT(pSrcPhrase != NULL);
				nSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans ||
					(pSrcPhrase->m_nSequNumber == 0) ||
					pSrcPhrase->m_bChapter ||
					pSrcPhrase->m_bVerse)
				{
                    // don't go back more further than start of a free translation section,
                    // of to start of chapter, or start of verse, or start of document, if
                    // any of those conditions are encountered first
					nSequNum = pSrcPhrase->m_nSequNumber;
					pApp->m_nActiveSequNum = nSequNum;
					break;
				}
			}
		}
	}

	// handle the possibility that the new active location might be a "<Not In KB>" one
	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
        // this ensures user has to explicitly type into the box and explicitly check the
        // checkbox if he wants to override the "not in kb" earlier setting at this
        // location
		pApp->m_bSaveToKB = FALSE;
		pApp->m_targetPhrase.Empty();
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
	}
	else if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		pApp->m_targetPhrase = pSrcPhrase->m_adaption;
		pApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	else // the location is a "hole" (ie. empty)
	{
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
		pApp->m_targetPhrase.Empty();// added 31Jul03
        // the above is better, since then the user can use the To End button and not get
        // spurious copied source text entered into the KB if he does not remember to
        // delete the copied text before stepping elsewhere
	}

	// update the layout and get a fresh active pile pointer
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

    // the active pile must not contain a retranslation, since we want to put the phrase
    // box there, so check and if so, back up until we find a src phrase which is not a
    // retranslation
	if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
	{
        // it's a retranslation location, so move active location to earlier sequence
        // numbers until we find a sourcePhrase which is not in the retranslation
		CPile* pPile = pApp->m_pActivePile;
		do
		{
			pPile = GetPrevPile(pPile);
			if (pPile == NULL)
			{
                // we've backed up to the start of the document, so the last active pile
                // location (ie. the first pile in the document) is where we'll remain
				pApp->m_nActiveSequNum = 0;
				pPile = GetPile(0);
				pApp->m_targetPhrase = pPile->GetSrcPhrase()->m_adaption;
#ifdef _NEW_LAYOUT
				GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
				GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
				pApp->m_pActivePile = GetPile(0);
				return;
			}
			pApp->m_pActivePile = pPile;
		} while (pPile->GetSrcPhrase()->m_bRetranslation);

		pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
            // this ensures user has to explicitly type into the box and explicitly check
            // the checkbox if he wants to override the "not in kb" earlier setting at this
            // location
			pApp->m_bSaveToKB = FALSE;
			pApp->m_targetPhrase.Empty();
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			if (!gbIsGlossing && !pSrcPhrase->m_adaption.IsEmpty())
			{
				// there is an adaptation
				pApp->m_targetPhrase = pSrcPhrase->m_adaption;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else if (gbIsGlossing && !pSrcPhrase->m_gloss.IsEmpty())
			{
				// there is a gloss
				pApp->m_targetPhrase = pSrcPhrase->m_gloss;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (pApp->m_bCopySource)
				{
					pApp->m_targetPhrase = CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
				}
				else
				{
					pApp->m_targetPhrase.Empty();
				}
			}
		}
	}

	// remove from the KB, if there is a refString for this source phrase in the KB
	wxString emptyStr = _T("");
	if (gbIsGlossing)
		pApp->m_pGlossingKB->GetAndRemoveRefString(pSrcPhrase,
									emptyStr, useGlossOrAdaptationForLookup);
	else
		pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase,
									emptyStr, useGlossOrAdaptationForLookup);

    // BEW removed call of ResetPartnerPileWidth() 27Apr09, because a call to
    // ResetPartnerPileWidth() is always done in RecalcLayout() for the active pile, just
    // before rebuilding the strips, so we can rely on that one here

	// recalculate the layout
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif

	// recalculate the active pile
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	// scroll the active location into view, if necessary
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	GetLayout()->m_docEditOperationType = default_op;

	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);

	Invalidate(); // get the layout redrawn and the phrase box too
	GetLayout()->PlaceBox();

    // if we are in free translation mode, we want the focus to be in the Compose Bar's
    // edit box after the move has been done
	if (pApp->m_bFreeTranslationMode && pEdit != NULL) // whm added && pEdit != NULL)
	{
		pEdit->SetFocus();
	}
}

/// removes both the entry from the adapting KB and the glossing KB, for the one m_key (the
/// function for removal exits if either does not yet exist in the KB, so the call is
/// always safe) - we need this function for document rebuilding, where both KBs have to be
/// updated in the one operation
void CAdapt_ItView::RemoveKBEntryForRebuild(CSourcePhrase* pSrcPhrase)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxString emptyStr = _T("");

	// remove from the adapting KB, if there is a refString for this source phrase in the KB
	pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase, emptyStr, useGlossOrAdaptationForLookup);

	// now the glossing KB
	pApp->m_pGlossingKB->GetAndRemoveRefString(pSrcPhrase, emptyStr, useGlossOrAdaptationForLookup);
}

/// stores both adaptation for the adapting KB and gloss for the glossing KB, for the one
/// m_key (the function for storage exits if either does not yet exist in the KB, so the
/// call is always safe) - we need this function for document rebuilding, where both KBs
/// have to be updated in the one operation
/// BEW note 13Nov09: we don't want to allow the local user to cause a document rebuild
/// on a remote machine if the local use only has read-only access to the remote project
/// folder. We'll therefore not allow access to the remote running instance's preferences
/// in this circumstance.
void CAdapt_ItView::StoreKBEntryForRebuild(CSourcePhrase* pSrcPhrase,
										wxString& adaptationStr, wxString& glossStr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// save current glossing state, so we can restore afterwards
	bool bSaveEnableFlag = gbGlossingVisible;
	bool bSaveGlossingFlag = gbIsGlossing;

	// store to the adapting KB
	gbGlossingVisible = FALSE;
	gbIsGlossing = FALSE;

    // inhibit the call to MakeTargetStringIncludingPunctuation() within the StoreText()
    // function otherwise it will add punctuation to the m_targetStr field on the
    // document's pSrcPhrase which is currently active, and that member already has the
    // required punctuation because we have copied the old string prior to the rebuild
	gbInhibitMakeTargetStringCall = TRUE;
	bool bOK = pApp->m_pKB->StoreText(pSrcPhrase,adaptationStr);
	bOK = bOK; // avoid warning
	// now the glossing KB
	gbGlossingVisible = TRUE;
	gbIsGlossing = TRUE;
	bOK = pApp->m_pGlossingKB->StoreText(pSrcPhrase,glossStr);

	// restore current mode
	gbGlossingVisible = bSaveEnableFlag;
	gbIsGlossing = bSaveGlossingFlag;
	gbInhibitMakeTargetStringCall = FALSE; // restore the default setting
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Back To Start"
/// toolbar item and returns immediately: Vertical Editing is in progress, the Document
/// pointer is NULL, the m_pActivePile pointer is NULL, or the count of source phrases in
/// m_pSourcePhrases is zero. It enables the toolbar item if the App's m_beginIndex and
/// m_endIndex are both greater than zero, otherwise it disables the toolbar item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonToStart(wxUpdateUIEvent& event)
{
	// refactored 9Apr09
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if ((CAdapt_ItDoc*)GetDocument() == NULL)
	{
		event.Enable(FALSE);
		return;
	}

	if (pApp->m_nActiveSequNum == -1 && pApp->m_pSourcePhrases->GetCount() > 0)
	{
		// we are past the end, so allow the button to be used to go back to start
		event.Enable(TRUE);
		return;
	}

	// any other time when active pile pointer is null, don't let button be used
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	// if the button is at the start, it should be disabled
	if (pApp->m_nActiveSequNum == 0 && pApp->m_pSourcePhrases->GetCount() > 0)
	{
		// we are at the doc start, so can't go back to start
		event.Enable(FALSE);
		return;
	}
	if (pApp->GetMaxIndex() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonToStart(wxCommandEvent& event)
{
    // refactored 9Apr09 **** TODO **** can be restructured to have only one RecalcLayout()
    // call -- see OnButtonStepDown() for how to do it (relies on fact that the internal
    // code can make all decisions about whether to move or not without having to recalc
    // the layout, and then only do the one recalc call at the end)
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (pApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->ChangeValue(tempStr);
	}

	gnOldSequNum = pApp->m_nActiveSequNum; // save old location

	SPList* pList = pApp->m_pSourcePhrases;

	bool bOK;
	if (pApp->m_nActiveSequNum == -1)
	{
		// we are past the end, so skip storage
		bOK = TRUE;

		// and remove any selection, since if it exists then RecalcLayout() would fail when
		// StoreSelection() gets called
		RemoveSelection();
	}
	else
	{
		wxASSERT(pApp->m_pActivePile != NULL);
		bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());
	}
    // BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
    // StoreBeforeProceeding() returns FALSE without doing any store, and in that case we
    // don't want to return from OnButtonToStart immediately because then we have no way to
    // navigate back to the start of the document; instead, just ignore the bOK value
	if (!bOK)
	{
		; // just do nothing (avoids compiler warning baout bOK not being accessed)
	}

	int nSequNum = 0; // active element is first one in the list
	pApp->m_nActiveSequNum = nSequNum;

	SPList::Node* spos = pList->GetFirst();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)spos->GetData();

	// handle the possibility that the new active location might be a "<Not In KB>" one
	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
		// this ensures user has to explicitly type into the box and explicitly check the
		// checkbox if he wants to override the "not in kb" earlier setting at this location
		pApp->m_bSaveToKB = FALSE;
		pApp->m_targetPhrase.Empty();
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
	}
	else if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		pApp->m_targetPhrase = pSrcPhrase->m_adaption;
		pApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	else
	{
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
		pApp->m_targetPhrase.Empty(); // added 31Jul03
        // the above is better, since then the user can use the To Start button and not get
        // spurious copied source text entered into the KB if he does not remember to
        // delete the copied text before stepping elsewhere
	}

	// update the layout and get a fresh active pile pointer
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

    // the active pile must not contain a retranslation, since we want to put the phrase
    // box there, so check and if so, move forward until we find a src phrase which is not
    // a retranslation
	if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
	{
        // its a retranslation location, so move active location to later sequence numbers
        // until we find a sourcePhrase which is not in the retranslation
		CPile* pPile = pApp->m_pActivePile;
		do
		{
			pPile = GetNextPile(pPile);
			if (pPile == NULL)
			{
                // we've moved forward past the end of the document, so the last potential
                // active location is where we'll remain
				pApp->m_nActiveSequNum = pApp->GetMaxIndex();
				pPile = GetPile(pApp->m_nActiveSequNum);
				pApp->m_targetPhrase = pPile->GetSrcPhrase()->m_adaption;
#ifdef _NEW_LAYOUT
				GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
				GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
				pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
				return;
			}
			pApp->m_pActivePile = pPile;
		} while (pPile->GetSrcPhrase()->m_bRetranslation);

		pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
            // this ensures user has to explicitly type into the box and explicitly check
            // the checkbox if he wants to override the "not in kb" earlier setting at this
            // location
			pApp->m_bSaveToKB = FALSE;
			pApp->m_targetPhrase.Empty();
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			if (!gbIsGlossing && !pSrcPhrase->m_adaption.IsEmpty())
			{
				// there is an adaptation
				pApp->m_targetPhrase = pSrcPhrase->m_adaption;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else if (gbIsGlossing && !pSrcPhrase->m_gloss.IsEmpty())
			{
				// there is a gloss
				pApp->m_targetPhrase = pSrcPhrase->m_gloss;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (pApp->m_bCopySource)
				{
					pApp->m_targetPhrase = CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
				}
				else
				{
					pApp->m_targetPhrase.Empty();
				}
			}
		}
	}

	// remove the text from the KB, if refString is not null
	wxString emptyStr = _T("");
	if (gbIsGlossing)
		pApp->m_pGlossingKB->GetAndRemoveRefString(pSrcPhrase,
									emptyStr, useGlossOrAdaptationForLookup);
	else
		pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase,
									emptyStr, useGlossOrAdaptationForLookup);

	// recalculate the layout
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif

	// recalculate the active pile
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	// scroll the active location into view, if necessary
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	GetLayout()->m_docEditOperationType = default_op;

	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);

	Invalidate();
	GetLayout()->PlaceBox();

    // if we are in free translation mode, we want the focus to be in the Compose Bar's
    // edit box after the move has been done
	if (pApp->m_bFreeTranslationMode && pEdit != NULL)
	{
		pEdit->SetFocus();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Move Down One
/// Step" toolbar item and returns immediately: Vertical Editing is in progress, the
/// m_pActivePile pointer is NULL, or the count of source phrases in m_pSourcePhrases is
/// zero.
/// It enables the toolbar item if the App's m_endIndex is greater than zero and less than
/// the count of source phrases in m_pSourcePhrases -1, otherwise it disables the toolbar
/// item. otherwise it disables the toolbar item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonStepDown(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum < (int)pApp->GetMaxIndex() && pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonStepDown(wxCommandEvent& event)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	SPList* pList = pApp->m_pSourcePhrases;
	int nSaveOldSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;
	wxString saveTargetPhrase = pApp->m_targetPhrase;

	gnOldSequNum = pApp->m_nActiveSequNum; // save old location

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();
	wxASSERT(pApp->m_pActivePile != NULL);

	// find the next CSourcePhrase instance which has m_bChapter set TRUE, make it the new
	// active location; but if none is found ahead of the current active location, then
	// just beep and stay at the current active location
	bool bFoundChapterBeginning = FALSE;
	int nSequNum = nSaveOldSequNum + 1;
	CPile* pPile = GetPile(nSequNum); // might return NULL (if at doc end)
	if (nSequNum <= pApp->GetMaxIndex())
	{
		while (pPile != NULL)
		{
			CSourcePhrase* pSrcPhr = pPile->GetSrcPhrase();
			if (pSrcPhr->m_bChapter)
			{
				bFoundChapterBeginning = TRUE;
				break;
			}
			else
			{
				nSequNum++;
				pPile = GetPile(nSequNum);
			}
		}
	}

	// if no chapter beginning was found, then exit with a beep
	if (!bFoundChapterBeginning)
	{
		::wxBell();
		return;
	}

	// continuing, because a chapter beginning was found...
	GetLayout()->m_pDoc->ResetPartnerPileWidth(GetSrcPhrase(nSaveOldSequNum)); // update old loc'n

	// if it is free translation mode, get a pointer to the compose bar's wxTextCtrl
	if (pApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->ChangeValue(tempStr);
	}

	bool bOK;
	bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());
    // BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
    // StoreBeforeProceeding() returns FALSE without doing any store, and in that case we
    // don't want to return from OnButtonStepDown immediately because then we have no way
    // to navigate ahead in the document using this button; instead, just ignore the bOK
    // value
	if (!bOK)
	{
		; // do nothing, need to use bOK to avoid compile warning
	}

	wxASSERT(pPile);
	pApp->m_pActivePile = pPile;
	pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber; // the new location, at chapter
	SPList::Node* pos = pList->Item(pApp->m_nActiveSequNum);
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase != NULL);

	// if free translation mode is on, we would not want the box to be anywhere but at the
	// start of a free translation section, so if the found location is not the start of
	// such a section, make the adjustment if required so that box goes instead to the previous
	// anchor position
	if (pApp->m_bFreeTranslationMode)
	{
		if (pSrcPhrase->m_bHasFreeTrans && !pSrcPhrase->m_bStartFreeTrans)
		{
			// move back to the sequ num for the anchor position
			while (TRUE)
			{
				pos = pos->GetPrevious();
				pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetPrevious();
				wxASSERT(pSrcPhrase != NULL);
				nSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans ||
					(pSrcPhrase->m_nSequNumber == 0) ||
					pSrcPhrase->m_bChapter ||
					pSrcPhrase->m_bVerse)
				{
                    // don't go back more further than start of a free translation section,
                    // of to start of chapter, or start of verse, or start of document, if
                    // any of those conditions are encountered first
					nSequNum = pSrcPhrase->m_nSequNumber;
					pApp->m_nActiveSequNum = nSequNum;
					break;
				}
			}
		}
	}
	else // not free translation mode
	{
		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
            // this ensures user has to explicitly type into the box and explicitly check
            // the checkbox if he wants to override the "not in kb" earlier setting at this
            // location
			pApp->m_bSaveToKB = FALSE;
			pApp->m_targetPhrase.Empty();
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			pApp->m_targetPhrase = pSrcPhrase->m_adaption;
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			pApp->m_targetPhrase.Empty();// added 31Jul03
            // the above is better, since then the user can use the Step Up button
            // repeatedly and not get spurious copied source text entered into the KB each
            // time if he does not remember to delete the copied text first
		}

        // the active pile must not contain a retranslation, since we want to put the
        // phrase box there, so check and if so, move along until we find a src phrase
        // which is not a retranslation
		if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
		{
			// its a retranslation location, so move active location to later sequence numbers
			// until we find a sourcePhrase which is not in the retranslation
			CPile* pPile = pApp->m_pActivePile;
			do
			{
				pPile = GetNextPile(pPile);
				if (pPile == NULL)
				{
                    // we've gone forward past the end of the document, so we won't make
                    // any change of location; because the end of the doc has only
                    // retranslations, so restore the old state & tell user
					//IDS_CANNOT_STEP_DOWN //  BEW changed message 10Apr09
					wxMessageBox(_(
"Adapt It cannot step down to the beginning of the next chapter because it cannot find a legal place to put the phrase box, retranslations at the end of the document prevent it."),
					_T(""),wxICON_INFORMATION | wxOK);
					// restore old location's values (no RecalcLayout() was done, so
					// layout is valid still)
					pApp->m_targetPhrase = saveTargetPhrase;
					pApp->m_nActiveSequNum = nSaveOldSequNum;
					pApp->m_pActivePile = GetPile(nSaveOldSequNum);
					return;
				}
			} while (pPile->GetSrcPhrase()->m_bRetranslation);

			wxASSERT(pPile);
			pApp->m_pActivePile = pPile; // this one is not in the retranslation
			pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

			// handle the possibility that the new active location might be a "<Not In KB>" one
			if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
			{
				// this ensures user has to explicitly type into the box and explicitly check the
				// checkbox if he wants to override the "not in kb" earlier setting at this location
				pApp->m_bSaveToKB = FALSE;
				pApp->m_targetPhrase.Empty();
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
			}
			else // it's not a <Not In KB> location
			{
				if (!gbIsGlossing && !pSrcPhrase->m_adaption.IsEmpty())
				{
					// there is an adaptation
					pApp->m_targetPhrase = pSrcPhrase->m_adaption;
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else if (gbIsGlossing && !pSrcPhrase->m_gloss.IsEmpty())
				{
					// there is a gloss
					pApp->m_targetPhrase = pSrcPhrase->m_gloss;
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else
				{
					pApp->m_pTargetBox->m_bAbandonable = TRUE;
					if (pApp->m_bCopySource)
					{
						pApp->m_targetPhrase = CopySourceKey(
										pSrcPhrase,pApp->m_bUseConsistentChanges);
					}
					else
					{
						pApp->m_targetPhrase.Empty();
					}
				}
			}
		}

		// remove the text from the KB, if refString is not null
		wxString emptyStr = _T("");
		if (gbIsGlossing)
			pApp->m_pGlossingKB->GetAndRemoveRefString(pSrcPhrase,
										emptyStr, useGlossOrAdaptationForLookup);
		else
			pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase,
										emptyStr, useGlossOrAdaptationForLookup);
	} // end block for "not free translation mode"

	// update the layout and get a fresh active pile pointer
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);
	GetLayout()->m_docEditOperationType = default_op;

	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);

	Invalidate();
	GetLayout()->PlaceBox();

    // if we are in free translation mode, we want the focus to be in the Compose Bar's
    // edit box after the move has been done
	if (pApp->m_bFreeTranslationMode && pEdit != NULL)
	{
		pEdit->SetFocus();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Move Up One
/// Step" toolbar item and returns immediately: Vertical Editing is in progress, the
/// Document pointer is NULL, the m_pActivePile pointer is NULL, or the count of source
/// phrases in m_pSourcePhrases is zero.
/// It generally enables the toolbar button if the App's m_beginIndex and m_endIndex are
/// both greater than zero, otherwise it disables the toolbar item. It also enables the
/// toolbar item in the special circumstance when the phrasebox is past the end of the
/// document (m_pActiveSequNum is -1 and the count of source phrases in m_pSourcePhrases is
/// greater than zero).
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonStepUp(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if ((CAdapt_ItDoc*)GetDocument() == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum == -1 && pApp->m_pSourcePhrases->GetCount() > 0)
	{
		// we are past the end, so allow the button to be used to go back to start
		event.Enable(TRUE);
		return;
	}
	// any other time when active pile pointer is null, don't let button be used
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	// if the button is at the start, it should be disabled
	if (pApp->m_nActiveSequNum == 0 && pApp->m_pSourcePhrases->GetCount() > 0)
	{
		// we are at the doc start, so can't go back to start
		event.Enable(FALSE);
		return;
	}
	if (pApp->GetMaxIndex() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonStepUp(wxCommandEvent& event)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	SPList* pList = pApp->m_pSourcePhrases;

	// Beware, the update handler has the button enabled if the active sequ num is -1 and
	// there is data in the document; so we can't try to call GetSrcPhrase() for an active
	// pile pointer which is NULL. The thing to do would be to temporarily place the box
	// at the last CSourcePhrase in the document and let it then search back.
	int nSaveOldSequNum;
	if (pApp->m_nActiveSequNum == -1 || pApp->m_pActivePile == NULL)
	{
		// passed the end of the document
		pApp->m_nActiveSequNum = pApp->GetMaxIndex();
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		pApp->m_targetPhrase = _T("");
	}
	nSaveOldSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;
	wxString saveTargetPhrase = pApp->m_targetPhrase;

	// return if we are at the start of the document
	if (nSaveOldSequNum == 0)
	{
		::wxBell();
		return;
	}

	gnOldSequNum = pApp->m_nActiveSequNum; // save old location

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();
	wxASSERT(pApp->m_pActivePile != NULL);

    // find the previous CSourcePhrase instance which has m_bChapter set TRUE, make it the
    // new active location; but if none is found before the current active location, then
    // just beep and stay at the current active location
	bool bFoundChapterBeginning = FALSE;
	int nSequNum = nSaveOldSequNum - 1; // first preceding location's sequence number
	CPile* pPile = GetPile(nSequNum);
	if (nSequNum >= 0)
	{
		while (pPile != NULL)
		{
			CSourcePhrase* pSrcPhr = pPile->GetSrcPhrase();
			if (pSrcPhr->m_bChapter)
			{
				bFoundChapterBeginning = TRUE;
				break;
			}
			else
			{
				nSequNum--;
				pPile = GetPile(nSequNum);
			}
		}
	}

	// if no chapter beginning was found, then exit with a beep
	// BEW 10Feb11, in response to Bob Buss's email, changed this behaviour to not beep,
	// but just invoke the To Start button to get the phrase box to the beginning of the
	// document (ie over any intro and title stuff which may precede the first chapter)
	if (!bFoundChapterBeginning)
	{
		//::wxBell();
		OnButtonToStart(event);
		return;
	}

	// continuing, because a chapter beginning was found...
	GetLayout()->m_pDoc->ResetPartnerPileWidth(GetSrcPhrase(nSaveOldSequNum)); // update old loc'n

	// if it is free translation mode, get a pointer to the compose bar's wxTextCtrl
	if (pApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->ChangeValue(tempStr);
	}

	bool bOK;
	bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());
    // BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
    // StoreBeforeProceeding() returns FALSE without doing any store, and in that case we
    // don't want to return from OnButtonStepDown immediately because then we have no way
    // to navigate ahead in the document using this button; instead, just ignore the bOK
    // value
	if (!bOK)
	{
		; // do nothing, need to use bOK to avoid compile warning
	}

	wxASSERT(pPile);
	pApp->m_pActivePile = pPile; // the new active location's pile pointer
	pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber; // the new location, at chapter
	SPList::Node* pos = pList->Item(pApp->m_nActiveSequNum);
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase != NULL);

    // if free translation mode is on, we would not want the box to be anywhere but at the
    // start of a free translation section, so if the found location is not the start of
    // such a section, make the adjustment if required so that box goes instead to the
    // previous anchor position
	if (pApp->m_bFreeTranslationMode)
	{
		if (pSrcPhrase->m_bHasFreeTrans && !pSrcPhrase->m_bStartFreeTrans)
		{
			// move back to the sequ num for the anchor position
			while (TRUE)
			{
				pos = pos->GetPrevious();
				pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetPrevious();
				wxASSERT(pSrcPhrase != NULL);
				nSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans ||
					(pSrcPhrase->m_nSequNumber == 0) ||
					pSrcPhrase->m_bChapter ||
					pSrcPhrase->m_bVerse)
				{
					// don't go back more further than start of a free translation section,
					// of to start of chapter, or start of verse, or start of document, if
					// any of those conditions are encountered first
					nSequNum = pSrcPhrase->m_nSequNumber;
					pApp->m_nActiveSequNum = nSequNum;
					break;
				}
			}
		}
	}
	else // not free translation mode
	{
		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
            // this ensures user has to explicitly type into the box and explicitly check
            // the checkbox if he wants to override the "not in kb" earlier setting at this
            // location
			pApp->m_bSaveToKB = FALSE;
			pApp->m_targetPhrase.Empty();
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			pApp->m_targetPhrase = pSrcPhrase->m_adaption;
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			pApp->m_targetPhrase.Empty();// added 31Jul03
            // the above is better, since then the user can use the Step Up button
            // repeatedly and not get spurious copied source text entered into the KB each
            // time if he does not remember to delete the copied text first
		}

        // the active pile must not contain a retranslation, since we want to put the
        // phrase box there, so check and if so, move along until we find a src phrase
        // which is not a retranslation
		if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
		{
            // its a retranslation location, so move active location to earlier sequence
            // numbers until we find a sourcePhrase which is not in the retranslation
			CPile* pPile = pApp->m_pActivePile;
			do
			{
				pPile = GetPrevPile(pPile);
				if (pPile == NULL)
				{
                    // we've gone back past the start of the document, so we won't make any
                    // change of location; because the start of the doc has only
                    // retranslations, so restore the old state & tell user
					//IDS_CANNOT_STEP_UP //  BEW changed message 11Apr09
					wxMessageBox(_(
"Adapt It cannot step up to the beginning of chapter, or to the beginning of the previous chapter because it cannot find a legal place to put the phrase box, retranslations at the beginning of the document prevent it."),
					_T(""),wxICON_INFORMATION | wxOK);
					// restore old location's values (no RecalcLayout() was done, so
					// layout is valid still)
					pApp->m_targetPhrase = saveTargetPhrase;
					pApp->m_nActiveSequNum = nSaveOldSequNum;
					pApp->m_pActivePile = GetPile(nSaveOldSequNum);
					return;
				}
			} while (pPile->GetSrcPhrase()->m_bRetranslation);

			wxASSERT(pPile);
			pApp->m_pActivePile = pPile; // this one is not in the retranslation
			pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

			// handle the possibility that the new active location might be a
			// "<Not In KB>" one
			if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
			{
                // this ensures user has to explicitly type into the box and explicitly
                // check the checkbox if he wants to override the "not in kb" earlier
                // setting at this location
				pApp->m_bSaveToKB = FALSE;
				pApp->m_targetPhrase.Empty();
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
			}
			else // it's not a <Not In KB> location
			{
				if (!gbIsGlossing && !pSrcPhrase->m_adaption.IsEmpty())
				{
					// there is an adaptation
					pApp->m_targetPhrase = pSrcPhrase->m_adaption;
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else if (gbIsGlossing && !pSrcPhrase->m_gloss.IsEmpty())
				{
					// there is a gloss
					pApp->m_targetPhrase = pSrcPhrase->m_gloss;
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else
				{
					pApp->m_pTargetBox->m_bAbandonable = TRUE;
					if (pApp->m_bCopySource)
					{
						pApp->m_targetPhrase = CopySourceKey(pSrcPhrase,pApp->m_bUseConsistentChanges);
					}
					else
					{
						pApp->m_targetPhrase.Empty();
					}
				}
			}
		}

		// remove the text from the KB, if refString is not null
		wxString emptyStr = _T("");
		if (gbIsGlossing)
			pApp->m_pGlossingKB->GetAndRemoveRefString(pSrcPhrase,
										emptyStr, useGlossOrAdaptationForLookup);
		else
			pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase,
										emptyStr, useGlossOrAdaptationForLookup);
	} // end block for "not free translation mode"

	// update the layout and get a fresh active pile pointer
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);
	GetLayout()->m_docEditOperationType = default_op;

	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);

	Invalidate();
	GetLayout()->PlaceBox();

    // if we are in free translation mode, we want the focus to be in the Compose Bar's
    // edit box after the move has been done
	if (pApp->m_bFreeTranslationMode && pEdit != NULL)
	{
		pEdit->SetFocus();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If the application is in glossing mode, or it is showing only the target text, or the m_pActivePile
/// pointer is NULL, this handler disables the "Make A Phrase" toolbar item
/// and returns immediately. If there is an active selection (the App's m_selection list has more than
/// one item in its list), it enables the toolbar button, otherwise it disables the toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonMerge(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	
	// whm added 26Mar12. Disable toolbar button when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selection.GetCount() > 1)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the App's m_pActivePile is NULL this handler disables the "Copy Source" item in the
/// View menu and immediately returns.
/// It enables the "Copy Source" item on the View menu if the number of source phrases in
/// the m_pSourcePhrases list is greater than zero, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateCopySource(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}


// IsFilteredMaterialNonInitial() -- BEW added 08June05, to be used in OnButtonMerge() in
// order to abort the merge operation if the user is trying to merge CSourcePhrase
// instances and one of those which is not the initial one contains filtered material in
// its m_filteredInfo, or m_freeTrans, or m_collectedBackTrans, or m_note member
// BEW 16Feb10, updated for support of doc version 5
bool CAdapt_ItView::IsFilteredMaterialNonInitial(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // there isn't any content in the list
	bool bIsFirst = TRUE;
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		// this test assumes empty notes will never occur in the document (currently, if a
		// note is left empty, it doesn't get stored), empty free translations are permitted
		if (!bIsFirst &&
			(
			(!pSrcPhrase->GetFreeTrans().IsEmpty() || pSrcPhrase->m_bStartFreeTrans) ||
			!pSrcPhrase->GetNote().IsEmpty() ||
			!pSrcPhrase->GetCollectedBackTrans().IsEmpty() ||
			!pSrcPhrase->GetFilteredInfo().IsEmpty()
			)
		)
		/* use this test instead of the above if we ever allow storage of empty notes
			(!pSrcPhrase->GetFreeTrans().IsEmpty() || pSrcPhrase->m_bStartFreeTrans) ||
			(pSrcPhrase->m_bHasNote || !pSrcPhrase->GetNote().IsEmpty()) ||
			!pSrcPhrase->GetCollectedBackTrans().IsEmpty() ||
			!pSrcPhrase->GetFilteredInfo().IsEmpty()
		*/
			return TRUE;
		bIsFirst = FALSE;
	}
	return FALSE;
}

// IsSelectionAcrossFreeTranslationEnd() -- BEW added 22Jul05, to be used in
// OnButtonMerge() in order to abort the merge operation if the user is trying to merge
// CSourcePhrase instances where the selection begins before a sourcephrase which is the
// end of a free translation section and extends further into a part of the document in
// which no free translation is defined (the case where what follows is another free
// translation section is already blocked by the requirement that no merge can be done
// across filtered material); pList is the list of selected CSourcePhrase instances
// BEW 16Feb10, no changes needed for support of doc version 5
bool CAdapt_ItView::IsSelectionAcrossFreeTranslationEnd(SPList* pList)
{
	// For doc version 5, no change is needed herein
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // there isn't any content in the list
	bool bFoundFreeTranslationEnd = FALSE;
	bool bExtendsBeyondFreeTranslation = FALSE;
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (bFoundFreeTranslationEnd)
		{
			bExtendsBeyondFreeTranslation = TRUE;
			continue;
		}
		if (pSrcPhrase->m_bEndFreeTrans)
		{
			bFoundFreeTranslationEnd = TRUE;
			continue;
		}
	}
	return bExtendsBeyondFreeTranslation;
}

// BEW updated OnButtonMerge() 16Feb10, for support of doc version 5
void CAdapt_ItView::OnButtonMerge(wxCommandEvent& WXUNUSED(event))
{
	// 25Mar09 added partner pile updating
	CLayout* pLayout = GetLayout();
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

    // In glossing mode (ie. actually glossing) I think I've managed to silently prevent
    // any merge from happening before OnButtonMerge( ) can get invoked. However, it the
    // user were to explicitly click the button, there is no recourse except to tell him
    // that the merge is not available when doing glossing
	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_(
		"This particular operation is not available when you are glossing."),
		_T(""), wxICON_INFORMATION | wxOK);
		return;
	}

	// not glossing, so continue to process the merge request
	SPList* pList = new SPList; // list of the selected CSourcePhrase objects
	wxASSERT(pList != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;
	CSourcePhrase* pSrcPhrase = NULL;
	int nCount;
	CPile* pPile;
	int nSaveSequNum;
	CCellList::Node* pos = NULL;

    // use strOldAdaptation to accumulate any existing adaptations, which will do so
    // regardless of whether some or all of the srcPhrases are already merged

    // BEW 13Nov10;  remove strAdapt, it just wastes processor time.
    // the strAdapt accumulation variable used later only accumulates after any unmerges
    // are done, so we don't use that unless strOldAdaptation is empty

	wxString strOldAdaptation;
	strOldAdaptation.Empty();
	gOldConcatStr.Empty();
	gOldConcatStrNoPunct.Empty();
	bool bSuppressCopyingExtraSourceWords = FALSE;
	bool bNoninitialSelectionsHaveTranslation = FALSE;	// TRUE if a non-active-location
												// selected pile has a translation in it
	if (gbRetainBoxContents)
	{
        // whenever this is set, the user will have just deselected the default text in the
        // phrase box and selected some source words- and so we get to this present code
        // block when merging. In this circumstance we don't want the deselected phrase box
        // contents to be thrown away (it was, in earlier versions) since the deselection
        // operation was clearly intended in order to retain that text; so when that
        // happens we take the box contents 'as is' as the initial string of text in
        // strOldAdaptation
		wxString s;
		s = pApp->m_pTargetBox->GetValue();
		strOldAdaptation = s;
		pApp->m_targetPhrase = s;
	}

    // if we are merging because of a match when LookAhead was called, set things up using
    // the nWordsInPhrase (global) value in the PhraseBox file; otherwise, use the
    // selection (bLookAheadMerge is a static class boolean defined in the CAdapt_ItApp
    // class & set by the LookAhead function in CPhraseBox class)
	if (pApp->bLookAheadMerge)
	{
		if (gbDoingInitialSetup && pApp->m_pTargetBox->GetHandle() == NULL)
		{
			gbJustCancelled = FALSE;
		}
		else if (pApp->m_pTargetBox->GetHandle() == NULL || pApp->m_pTargetBox->IsShown())
		{
			if (gbJustCancelled)
			{
				gbJustCancelled = FALSE;
			}
			else
			{
				// try skipping to the rest of the process, rather than aborting
				;
			}
		}
		nCount = nWordsInPhrase; // RHS is a global variable defined in PhraseBox.cpp
		pPile = pApp->m_pActivePile;
		wxASSERT(pPile != NULL);
		pStartingPile = pPile; // need this later - see next block for explanation
		pSrcPhrase = pPile->GetSrcPhrase();
		strOldAdaptation = pSrcPhrase->m_adaption; // don't use punctuated string
		pList->Append(pSrcPhrase); // add ptr of first to the temporary list
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything depends
		int i;									  // on this
		for (i = 1; i < nCount; i++)
		{
			pPile = GetNextPile(pPile); // next one in the sequence
			wxASSERT(pPile != NULL);
			pSrcPhrase = pPile->GetSrcPhrase();
			if (strOldAdaptation.IsEmpty())
				strOldAdaptation = pSrcPhrase->m_adaption;
			else
				strOldAdaptation += _T(" ") + pSrcPhrase->m_adaption; // always concat in natural order
			pList->Append(pSrcPhrase);  // add the pointer to the list
		}

        // for a look ahead merge, treat it as if user typed it, so that if there is a
        // user-generated extension done, the inserted translation will not be removed and
        // copied source text used instead
		pApp->m_bUserTypedSomething = TRUE;
	} // end block for bLookAhead merge == TRUE
	else // pApp->bLookAheadMerge is FALSE
	{
        // whm 10Sep08 added: The MFC code assumes that we won't get here if the Make a
        // Phrase button is disabled, however, in wx a CTRL-M and other accelerator keys
        // are propagated as key events even when the control they are associated with is
        // disabled, so we must bail out if there is no selection at this point, otherwise
        // we'll get a crash on pos->GetData() below.
		if (pApp->m_selection.GetCount() == 0)
		{
			pList->Clear();
			if (pList != NULL) // whm 11Jun12 added NULL test
				delete pList;
			pList = (SPList*)NULL;
			RemoveSelection(); // whm this not really needed as there is no selection
							   // (but doesn't hurt)
			// WX Note: There is no ::IsWindow() equivalent in wxWidgets
			if (pApp->m_pTargetBox->GetHandle() != NULL)
			{
				pApp->m_pTargetBox->SetFocus();
				pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar);
			}
			gbMergeSucceeded = FALSE;
			Invalidate(); // get a redraw done, and the phrase box reshown
			GetLayout()->PlaceBox();
			return;
		}

        // get a list of the selected CSourcePhrase instances (some might not be minimal
        // ones so if this is the case we must restore them to minimal ones)
		pos = pApp->m_selection.GetFirst();	//MFC pos = m_selection.GetHeadPosition();
		nCount = pApp->m_selection.GetCount();
		pPile = ((CCell*)pos->GetData())->GetPile();	// get the pile first in selection
		pos = pos->GetNext();  // need this to effect MFC's GetNext()
		pStartingPile = pPile; // need this for later when we look up the strip which
							   // first pile is in prior to calling RecalcLayout()
		pSrcPhrase = pPile->GetSrcPhrase();

		// at the active location, use pApp->m_targetPhrase if it's different from
		// the stored adaptation;
		if (pStartingPile == pApp->m_pActivePile)
		{
			strOldAdaptation = pApp->m_targetPhrase;

            // version 2.3.0, we don't want to have empty piles in the selection ahead of
            // the active location to have their source text copied to the existing
            // translation, because very seldom will that be useful - mostly the user has
            // to delete such additions, so from now on we will suppress the copy operation
            // using a local flag set here.
			bSuppressCopyingExtraSourceWords = TRUE;
		}
		else
		{
            // if the box is not within the selection, we will want to save the box
            // contents first, otherwise the contents will be lost when the merge takes
            // place
            // BEW 05Oct06; commented out next line, because CopySourceKey() sets
            // gbByCopyOnly to TRUE and if a copy has just been done before this merge, it
            // makes no sense to make the flag FALSE here so as to force a copy; so we want
            // the copy skipped if the flag is still TRUE
			//gbByCopyOnly = FALSE;
			if (!pApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
			{
				MakeTargetStringIncludingPunctuation(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);
				RemovePunctuation(pDoc, &pApp->m_targetPhrase, from_target_text);

                // the store will fail if the user edited the entry out of the KB, as the
                // latter cannot know which srcPhrases will be affected, so these will
                // still have their m_bHasKBEntry set true. We have to test for this, ie. a
				// null pRefString or rsEntry returning present_but_deleted. Test, and if
				// the flag is TRUE, set it to FALSE
				CRefString* pRefStr = NULL;
				KB_Entry rsEntry = pApp->m_pKB->GetRefString(pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
							pApp->m_pActivePile->GetSrcPhrase()->m_key, pApp->m_targetPhrase, pRefStr);
				if ((pRefStr == NULL || rsEntry == present_but_deleted) &&
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
				{
								pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
				}
				gbInhibitMakeTargetStringCall = TRUE;
				bool bOK;
				bOK = pApp->m_pKB->StoreText(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);
				bOK = bOK; // avoid warning
				gbInhibitMakeTargetStringCall = FALSE;
			}

			// get the first translation string, or something possibly useful, into the list
			if (pSrcPhrase->m_targetStr.IsEmpty())
			{
				if (pApp->m_bCopySource)
					strOldAdaptation = CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
			}
			else
			{
				if (!pSrcPhrase->m_bNotInKB)
					strOldAdaptation = pSrcPhrase->m_adaption;
			}
		}
		pList->Append(pSrcPhrase); // add first to the temporary list
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, all depends on it

        // while we fill the list, also accumulate the translations; remembering that the
        // pSrcPhrase at the active location will not have its m_adaption or m_targetStr
        // members set yet, but the appropriate value will be in the view's
        // pApp->m_targetPhrase member for RTL support we don't reverse the order of words
        // as we accumulate, (Uniscribe will render the string RTL correctly after it is
        // merged in natural order); and for version 2.3.0 we suppress the copying of
        // selected source words as target text to append to the existing target text since
        // this is usually not helpful
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData();
			pos = pos->GetNext();
			pPile = pCell->GetPile();
			pSrcPhrase = pPile->GetSrcPhrase();
			wxASSERT(pSrcPhrase != NULL);

            // at the active location, use pApp->m_targetPhrase if it is different from the
            // stored adaptation; works right even if user typed punct explicitly

            // BEW changed 05Oct06: this loop begins at the second pSrcPhrase in the list,
            // so when we've selected leftwards, this could be the active location with
            // copied src text and we'd not really want to use copied src text I think (but
            // at non-active locations we'd allow the copy to be done, as in the else block
            // below for the pPile == m_pActivePile test); so the change I'm making here is
            // just in the TRUE block for the pPile == m_pActivePile test:
            // to suppress copied text then for a backwards selection -- we can test for
            // these by m_curDirection's value, and phrase box's m_bAbandonable being still
            // FALSE; however strOldAdaptation is not our primary source for merged
            // adaptation text, it is only a fall back, so further changes are to be done
            // further down
			if (pPile == pApp->m_pActivePile)
			{
				if (!pApp->m_targetPhrase.IsEmpty())
				{
					// skip if selecting left and src text was copied
					if (!(pApp->m_curDirection == left && pApp->m_pTargetBox->m_bAbandonable))
					{
						strOldAdaptation += _T(" ") + pApp->m_targetPhrase;
					}
				}
			}
			else
			{
				// this pile is not at the active location
				if (strOldAdaptation.IsEmpty()) // strOldAdaptation is empty
				{
					if (pSrcPhrase->m_adaption.IsEmpty())
					{
						if (pApp->m_bCopySource && !bSuppressCopyingExtraSourceWords)
							strOldAdaptation =
							CopySourceKey(pSrcPhrase,pApp->m_bUseConsistentChanges);
					}
					else
					{
						strOldAdaptation = pSrcPhrase->m_adaption;
						bNoninitialSelectionsHaveTranslation = TRUE;
					}
				}
				else // strOldAdaptation is not empty
				{
					if (pSrcPhrase->m_adaption.IsEmpty())
					{
						if (pApp->m_bCopySource && !bSuppressCopyingExtraSourceWords)
						if (pApp->m_bCopySource)
							strOldAdaptation += _T(" ") +
							CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
					}
					else
					{
						strOldAdaptation += _T(" ") + pSrcPhrase->m_adaption;
						bNoninitialSelectionsHaveTranslation = TRUE;
					}
				}
			}
			pList->Append(pSrcPhrase);
		}
	}

	// set the global strings, in case they are wanted (eg. in a Find & Replace they may be used)
	gOldConcatStr = strOldAdaptation;
	gOldConcatStrNoPunct = strOldAdaptation;
	RemovePunctuation(pDoc, &gOldConcatStrNoPunct, from_target_text);

	// check for a retranslation in the selection, and abort the merge operation if there is one
	if (IsRetranslationInSelection(pList))
	{
		// IDS_NO_RETRANSLATION_IN_SEL
		wxMessageBox(_(
"This operation is not permitted when the selection contains any part of a retranslation. First remove the retranslation and then try again."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		pList->Clear();
		if (pList != NULL) // whm 11Jun12 added NULL test
			delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		// WX Note: There is no ::IsWindow() equivalent in wxWidgets
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar);
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

    // BEW 11Oct10, added for docVersion5 support: check for a USFM fixedspace symbol (~)
	// in the selection, and abort the merge operation if there is one (while this is
	// strictly speaking not a docVersion5 issue, doc version 5 parses input data
	// containing ~ better - and if there is punctuation before or after then that
	// punctuation is made medial to the word pair, and because we can't distinguish that
	// punctuation from other just-made-medial punctuation due to the merge, it is best to
	// forbid the merger in the first place)
	if (IsFixedSpaceSymbolInSelection(pList))
	{
		wxMessageBox(_(
"Merging is not permitted when the selection contains ~ which is the USFM fixed space marker.\nTry a retranslation instead."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		pList->Clear();
		if (pList != NULL) // whm 11Jun12 added NULL test
			delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar);
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

    // check for a null source phrase in the selection, and abort the merge operation if
    // there is one
	if (IsNullSrcPhraseInSelection(pList))
	{
		// IDS_NO_NULL_SRCPHRASE_IN_SEL
		wxMessageBox(_(
"Merging a selection which contains a placeholder (represented by ... dots) is not permitted."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		pList->Clear();
		if (pList != NULL) // whm 11Jun12 added NULL test
			delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		// WX Note: There is no ::IsWindow() equivalent in wxWidgets
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

	// check for filtered material in a non-initial sourcephrase instance,
	// and abort the merge operation if there is some (we could handle it, but
	// we just don't want to - for instance, nav text might be too long to
	// view properly, and the green wedge would disappear and editability of
	// the filtered stuff would be lost)
	if (IsFilteredMaterialNonInitial(pList))
	{
		//IDS_NO_MERGE_FILTERED
		wxMessageBox(_(
		"Merging words across filtered material is not allowed."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		pList->Clear();
		if (pList != NULL) // whm 11Jun12 added NULL test
			delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

    // check user is not trying to do a merger across the end of a free translation - it
    // can legally be done up to the end, but not across it (BEW added 22Jul05)
	if (IsSelectionAcrossFreeTranslationEnd(pList))
	{
		//IDS_NO_MERGE_ACROSS_FT_END
		wxMessageBox(_(
"Merging across the end of a free translation is not permitted. (You can merge up to the end of the free translation, but not beyond that point in the same merger.)"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		pList->Clear();
		if (pList != NULL) // whm 11Jun12 added NULL test
			delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar);
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

    // there might be some <Not In KB> source phrases in the list, so ensure the srcPhrases
    // have the flag cleared (added 1-Feb-2001)
    // Up to this point pos has been assigned as CCellList::Node* and SPList has not had a
    // node assigned to it, so we'll do that now. We can't use pos here because it is
    // already a node associated with a CCellList. BE CAREFULL not to mix pos and
    // nodeSPTemp below as the condition for while loops, etc!!!
	SPList::Node* nodeSPTemp = pList->GetFirst();

	while (nodeSPTemp != NULL)
	{

		CSourcePhrase* pSP = (CSourcePhrase*)nodeSPTemp->GetData();
		nodeSPTemp = nodeSPTemp->GetNext();
		wxASSERT(pSP != 0);
		pSP->m_bNotInKB = FALSE;
	}

	// if there are too many words in the selection, do a retranslation instead of a merge
	if (GetSelectionWordCount() > MAX_WORDS)
	{
		pApp->GetRetranslation()->DoRetranslation();
		gbMergeSucceeded = FALSE;
		return;
	}

	// make pApp->m_targetPhrase cleared, as it must accumulate any existing translations
	// removed from the KB because of the merge
	pApp->m_targetPhrase.Empty();

	// determine if there are any non-minimal phrases selected. If there are, we must
	// restore the original list of minimal phrases (ie. words), and clear the
	// translations from the KB, before proceeding.
	int nNumElements = 1;
	nodeSPTemp = pList->GetFirst();
	while (nodeSPTemp != NULL)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();
		nodeSPTemp = nodeSPTemp->GetNext();
		int nStartingSequNum = pSrcPhrase->m_nSequNumber;
		nNumElements = 1;
		if (pSrcPhrase->m_nSrcWords > 1)
		{
			// have to restore to original state (RestoreOriginalMinPhrases also
			// appends any adaptation(s) to pApp->m_targetPhrase)
			nNumElements = RestoreOriginalMinPhrases(pSrcPhrase, nStartingSequNum);

			// update nCount
			int nExtras = nNumElements - 1;
			nCount += nExtras;

			// BEW added 30Sep08 in support of vertical editing
			if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
			{
				gEditRecord.nAdaptationStep_EndingSequNum += nExtras;
				gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nExtras;
				gEditRecord.nAdaptationStep_NewSpanCount += nExtras;
			}

		}
		else // block for pSrcPhrase->m_nSrcWords == 1
		{
            // append its m_translation in the CRefString to pApp->m_targetPhrase, then
            // remove the refString from the KB, etc.
			CRefString* pRefString = NULL;
			KB_Entry rsEntry = pApp->m_pKB->GetRefString(pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key, pSrcPhrase->m_adaption,
											pRefString);
			if (pRefString != NULL && rsEntry == really_present)
			{
				if (pRefString->m_translation != _T("<Not In KB>"))
				{
					if (pApp->m_targetPhrase.IsEmpty())
						pApp->m_targetPhrase = pRefString->m_translation;
					else
					{
						if (!pRefString->m_translation.IsEmpty())
						{
							pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") +
															pRefString->m_translation;
						}
					}
                    // the following call needs to be within this block, not after it,
                    // because we don't want to also remove any <Not In KB> entries from
                    // the KB (altered 1-Feb-2001)
					pApp->m_pKB->RemoveRefString(pRefString, pSrcPhrase, pSrcPhrase->m_nSrcWords);
				}
			}
			else // pRefString == NULL or rsEntry == present_but_deleted
			{
                // if all else fails to find some text for this box (provided it is the
                // active location), then pull out whatever is stored in the CEdit itself -
                // since if we got here by a click, then the KB will have been modified
				if (pSrcPhrase == pApp->m_pActivePile->GetSrcPhrase())
				{
					// WX Note: There is no ::IsWindow() equivalent in wxWidgets
					if (pApp->m_pTargetBox->GetHandle() != NULL)
					{
						if (pApp->m_targetPhrase.IsEmpty())
							pApp->m_targetPhrase = pApp->m_pTargetBox->GetValue();
						else
						{
							wxString str;
							str = pApp->m_pTargetBox->GetValue();
							pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + str;
						}
					}
				}
			}
		}
	}

    // delete the temporary list, and then do the merge using the restored minimal phrases
    // for the original selection
	pList->Clear();
	if (pList != NULL) // whm 11Jun12 added NULL test
		delete pList;
	pList = (SPList*)NULL;

    // at this point, pApp->m_targetPhrase may not have anything in it, because no
    // accumulation was possible, so check if it is empty and if so then restore it from
    // the window's title text.
	if (pApp->m_targetPhrase.IsEmpty())
	{
		// WX Note: There is no ::IsWindow() equivalent in wxWidgets
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_targetPhrase = pApp->m_pTargetBox->GetValue();
		}
	}

	/*
	// a block for debugging, to check adaptation span boundaries before the merge
	if (gbVerticalEditInProgress)
	{
		int nStartSN = gEditRecord.nAdaptationStep_StartingSequNum;
		int nEndSN = gEditRecord.nAdaptationStep_EndingSequNum;
		int nExtrasFromEdits = gEditRecord.nAdaptationStep_ExtrasFromUserEdits;
		int nNewSpanCnt = gEditRecord.nAdaptationStep_NewSpanCount;
	}
	*/
	// determine the first srcPhrase in the merge operation
	nodeSPTemp = pSrcPhrases->Item(nSaveSequNum);
	wxASSERT(nodeSPTemp != NULL);
	CSourcePhrase* pFirstSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();
	nodeSPTemp = nodeSPTemp->GetNext();// needed for SPList
	wxASSERT(pFirstSrcPhrase != NULL);
	wxASSERT(pFirstSrcPhrase->m_nSrcWords == 1 ||
							pFirstSrcPhrase->m_nSrcWords == 0); // no phrases allowed
	wxASSERT(nodeSPTemp != NULL);

	// BEW removed strAdapt 13Nov10
	// we will try accumulating a default "adaptation" string, if strOldAdaptation is empty,
	// otherwise use the latter
	//wxString strAdapt;
	//strAdapt.Empty();
	//if (strOldAdaptation.IsEmpty())
	//{
	//	if (pFirstSrcPhrase->m_targetStr.IsEmpty())
	//	{
	//		pApp->m_pTargetBox->m_bAbandonable = TRUE;
	//		if (pApp->m_bCopySource)
	//			strAdapt = CopySourceKey(pFirstSrcPhrase, pApp->m_bUseConsistentChanges);
	//		else
	//			; // leave it empty
	//	}
	//	else
	//	{
	//		strAdapt = pFirstSrcPhrase->m_targetStr;
	//		pApp->m_pTargetBox->m_bAbandonable = FALSE;
	//	}
	//}

	// ensure a correct active sequ num when done
	pApp->m_nActiveSequNum = nSaveSequNum;

    // starting from the next minimal srcPhrase, Merge each succeeding one to
    // pFirstSrcPhrase (whether LTR or RTL layout, we always merge in logical order (ie.
    // order of ascending sequence numbers), and unmerge likewise, it is only the relative
    // order of the words in the text strings which are compiled which reverses for RTL)
    //
	// BEW added 22May09. The new RecalcLayout() code for the keep_piles_keep_strips
	// option relies, in the AdjustForUserEdits() function, on m_pActivePile pointing at a
	// valid CPile instance; for a forwards selection, mergers are done to the active
	// pile, and so m_pActivePile remains in existence; but for a leftwards selection, the
	// mergers are done to an earlier pile than the one which was the active one, and then
	// the merged CSourcePhrase instances are deleted - thereby making m_pActivePile point
	// at freed memory. In the old way of doing the layout, this didn't matter because the
	// piles were all recreated and m_pActivePile reset; but now that we retain piles and
	// just tweak certain of the strips in the changed area of the document, we have to
	// restore m_pActivePile before we call RecalcLayout() later below. It would be
	// sufficient to set it to any valid pile near the active one, but we can do better
	// than this hear, and set it to pFirstSrcPhrase after the merging loop below has
	// finished, and then all will be well as that will be the new active pile anyway
	int i;
	for (i = 1; i < nCount; i++)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();
		nodeSPTemp = nodeSPTemp->GetNext(); // needed for SPList
		wxASSERT(pSrcPhrase != NULL);
		wxASSERT(pSrcPhrase->m_nSrcWords == 1 ||
								pSrcPhrase->m_nSrcWords == 0); // no phrases allowed

		pFirstSrcPhrase->Merge(this, pSrcPhrase); // Merge() is updated for doc version 5

		// compose a default adaptation string, as best we can
		if (strOldAdaptation.IsEmpty())
		{
			// BEW 13Nov10 removed strAdapt support
			//if (pSrcPhrase->m_adaption.IsEmpty())
			//{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;

				//if (pApp->m_bCopySource)
				//{
					// don't add these ones which are additional to the first if
					// the flag wants suppression
				//	if (!bSuppressCopyingExtraSourceWords)
				//		strAdapt += _T(" ") + CopySourceKey(pSrcPhrase,
				//									pApp->m_bUseConsistentChanges);
				//}
				//else
				//	; // leave it empty
			//}
			//else
			//{
			//	strAdapt += _T(" ") + pSrcPhrase->m_adaption;
			//	pApp->m_pTargetBox->m_bAbandonable = FALSE;
			//	bNoninitialSelectionsHaveTranslation = TRUE;
			//}
		}
	} // end of for loop which merges all the non-first to the first in the selection

	// BEW added 22May09 -- see comment above the merge loop just above; here we must
	// re-establish the m_pActivePile pointer, in case we did a leftwards merge
	SPList::Node* aPosition = pSrcPhrases->Item(nSaveSequNum);
	CSourcePhrase* aSrcPhrasePtr = aPosition->GetData();
	wxASSERT(aSrcPhrasePtr);
	int itsSequNumber = aSrcPhrasePtr->m_nSequNumber;
	pApp->m_pActivePile = GetPile(itsSequNumber);
	wxASSERT(pApp->m_pActivePile);

	// Because later below we call DeletePartnerPile() on each of the non-first
	// CSourcePhrase instances of the selection which have now been merged, and
	// DeletePartnerPile() calls CLayout::DestroyPile() - freeing the memory for those
	// ones, we can't call RemoveSelection() after that, because the latter assumes the
	// cell pointers are still valid and they aren't. So here we just set the source text
	// line's first CCell of the selection to have m_bSelected set to FALSE, and Clear()
	// the m_selection list, and appropriately set the other selection parameters to
	// indicate there is no longer any selection.
	{
		int nFirstSequNum = pFirstSrcPhrase->m_nSequNumber;
		CPile* pFirstPile = GetPile(nFirstSequNum);
		CCell* pFirstSrcCell = pFirstPile->GetCell(0);
		pFirstSrcCell->SetSelected(FALSE);
		if (!pApp->m_selection.IsEmpty())
		{
			pApp->m_selection.Clear();
		}
		pApp->m_selectionLine = -1;
		pApp->m_pAnchor = (CCell*)NULL;
		// and globals too
		gnSelectionLine = -1;
		gnSelectionStartSequNum = -1;
		gnSelectionEndSequNum = -1;
	}

    // put our default string into pApp->m_targetPhrase to be shown in the phrase box,
    // provided we have not temporarily suppressed the default adaptation using the global
    // flag...

    // BEW added 05Oct06; here we supply a code block to implement a protocol for deriving
    // text for the phrase box when the selection has been made leftwards, so the active
    // location is at the end of the selection; and we have two scenarios- the box contents
    // are all selected (we'll assume that is due to a copy of source text and therefore
    // use m_bAbandonable == TRUE to detect it; if the selection has been made manually
    // then too bad, the user will have to do a little editing to removed the unwanted word
    // which will have been accepted when it was intended to have been removed by what the
    // user typed); or the active location will not have a selection (use m_bAbandonable ==
    // FALSE) and so we assume that the box's text is to be retained and accumulated with
    // the rest which was accumulated earlier
	if (pApp->m_curDirection == left)
	{
		// implementing a protocol for leftwards selections...

		// get the number of characters in the phrasebox's text, and determine how far from
		// the end is the cursor
		wxString strBox = _T("");
		strBox = pApp->m_pTargetBox->GetValue();
		int strBoxLen = strBox.Length();
		long nStart;
		long nEnd;
		pApp->m_pTargetBox->GetSelection(&nStart, &nEnd);

		if (pApp->m_pTargetBox->m_bAbandonable)
		{
			// user won't have typed anything, so the box text should have been selected when
			// the merge was initiated
			if (nStart == 1 && nEnd == 1 && strBoxLen == 1)
			{
				// the contents were selected and what the user typed replaced them
				pApp->m_targetPhrase = strBox;
				// make RemakePhraseBox() position the cursor after the character which
				// the user typed to replace the selection
				pApp->m_nStartChar = 1;
				pApp->m_nEndChar = 1;
			}
			else
			{
                // anything else, we'll retain the box contents and accumulate it at the
                // end of strOldAdaptation, and try get the cursor where the user left it
				pApp->m_targetPhrase = strOldAdaptation;
				pApp->m_targetPhrase.Trim(FALSE); // trim left end
				pApp->m_targetPhrase.Trim(TRUE); // trim right end
				int itsLen = pApp->m_targetPhrase.Length();
				int nFromEnd = strBoxLen - nEnd;
				pApp->m_nStartChar = itsLen - nFromEnd;
				pApp->m_nEndChar = itsLen - nFromEnd;
			}
		}
		else
		{
			// retain the box contents and accumulate it at the end of
			// strOldAdaptation, and try get the cursor where the user left it
			pApp->m_targetPhrase = strOldAdaptation;
			pApp->m_targetPhrase.Trim(FALSE); // trim left end
			pApp->m_targetPhrase.Trim(TRUE); // trim right end
			int itsLen = pApp->m_targetPhrase.Length();
			int nFromEnd = strBoxLen - nEnd;
			pApp->m_nStartChar = itsLen - nFromEnd;
			pApp->m_nEndChar = itsLen - nFromEnd;
		}
	}
	else
	{
		// legacy behaviour, that is, typically forward selection. Nothing changed here.
		if (!bSuppressDefaultAdaptation)
		{
			if (strOldAdaptation.IsEmpty())
				// BEW 13Nov10 removed strAdapt support
				;//pApp->m_targetPhrase = strAdapt;
			else
				pApp->m_targetPhrase = strOldAdaptation;
		}
	}

	// count how many have to be removed from the m_pSourcePhrases list on the app
	int nRemoveCount = nCount - 1; // that is, all but the first

	// BEW added 09Sep08 in support of vertical editing
	if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
	{
		gEditRecord.nAdaptationStep_EndingSequNum -= nRemoveCount;
		gEditRecord.nAdaptationStep_ExtrasFromUserEdits -= nRemoveCount; // LHS can become -ve legally
		gEditRecord.nAdaptationStep_NewSpanCount -= nRemoveCount;
	}

	/*
	// a block for debugging, to check adaptation span boundaries after the merge
	if (gbVerticalEditInProgress)
	{
		int nStartSN = gEditRecord.nAdaptationStep_StartingSequNum;
		int nEndSN = gEditRecord.nAdaptationStep_EndingSequNum;
		int nExtrasFromEdits = gEditRecord.nAdaptationStep_ExtrasFromUserEdits;
		int nNewSpanCnt = gEditRecord.nAdaptationStep_NewSpanCount;
	}
	*/
	// check all is well (Debug version only)
	wxASSERT(pApp->m_nActiveSequNum == pFirstSrcPhrase->m_nSequNumber);

	// next line added for refactored layout support 25Mar09...
	// puts the affected strip's index in CLayout::m_invalidStripArray and sets the
	// strip's m_bValid boolean to FALSE
	pDoc->ResetPartnerPileWidth(pFirstSrcPhrase);

	// remove from the list the ones which have been merged to the first
	nodeSPTemp = pSrcPhrases->Item(pApp->m_nActiveSequNum + 1); // position of first
																// to be removed
	SPList::Node* savePos; // used below
	wxASSERT(nodeSPTemp != NULL);
	int j = 0;
	while (nodeSPTemp != NULL && j < nRemoveCount)
	{
		savePos = nodeSPTemp;
		CSourcePhrase* pSrcPhrase;
		pSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();

		// next line added for refactored layout support 25Mar09
		pDoc->DeletePartnerPile(pSrcPhrase);

		nodeSPTemp = nodeSPTemp->GetNext();
		pSrcPhrases->DeleteNode(savePos); // remove pointer, but leave srcPhrase
		j++;							  // on the heap, because it is pointed at
	}									  // from within pFirstSrcPhrase now

	// update the sequence numbers which follow the active sequ num
	// BEW 22May09 moved this call to precede the recalculation of the layout, because it
	// is safer to have all the m_nSequNumber members of the elements in m_pSourcePhrases
	// list set correctly sequential before code in any other part of the app is called,
	// particularly the view layout code
	UpdateSequNumbers(pApp->m_nActiveSequNum);

	// recalculate the layout
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	pLayout->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif

	// get a new (valid) active pile pointer, now that the layout is recalculated
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);

    // we don't want the code after the MergeWords( ) call (which calls OnButtonMerge()) to
    // remove the phrase box's translation if the contents of the box hold more than just
    // the last single character which the user typed, provided that the selections beyond
    // the active location don't have any translation - if they do then we would instead
    // interpret the single keypress as an attempt to replace the earlier stuff. We get
    // what we want by setting gbRetainBoxContents since OnChar( ) will test the value on
    // return from MergeWords( ). Two local flags are needed to get this to happen at just
	// the right times.
	int newLen = pApp->m_targetPhrase.Length();
	if (newLen > 1 && !bNoninitialSelectionsHaveTranslation)
		gbRetainBoxContents = TRUE;

	// set up the m_inform attribute, if there are medial markers
	if (pFirstSrcPhrase->m_bHasInternalMarkers)
	{
		wxString s = _(" Medial markers: "); // BEW changed 16Feb10 to make this localizable
		if (!pFirstSrcPhrase->m_pMedialMarkers->IsEmpty())
		{
			// m_pMedialMarkers is a wxArrayString so let iterate
			// through it with a for loop
			for (int i = 0; i < (int)pFirstSrcPhrase->m_pMedialMarkers->GetCount(); i++)
			{
				s += pFirstSrcPhrase->m_pMedialMarkers->Item(i);
			}
			pFirstSrcPhrase->m_inform += s;
		}
	}
	Invalidate();
	GetLayout()->PlaceBox();
	gbMergeSucceeded = TRUE;

//#define MP_MM_BUG
#ifdef MP_MM_BUG
#ifdef _DEBUG
	// In collaboration mode, mergers are getting 3 empty <MP mp=""/> added to xml for the
	// CSourcePhrase and also 6 empty <MM mm=""/> added too. No idea why. Every extra word
	// merged adds an extra 3 & 6 as above, so seems like a merger bug. This block of code
	// will scan for m_pMedialPuncts and m_pMedialMarkers wxArrayString members with
	// m_count greater than zero, and list them, their sequ number, source text, etc in
	// the hope of getting a handle on when & where these bogus empty strings get added in
	{
		SPList* pSrcPhrases = pApp->m_pSourcePhrases;
		//int count = pSrcPhrases->GetCount();
		SPList::Node* pos = pSrcPhrases->GetFirst();
		int mpCount = 0;
		int mmCount = 0;
		wxString mpStr; // in case we get a legitimate one
		wxString mmStr; // ditto
		CSourcePhrase* pSrcPhrase = NULL;

		wxLogDebug(_T("\n ********************* Merger *************************"));
		int thisSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;
		wxString thisSrcPhrase = pApp->m_pActivePile->GetSrcPhrase()->m_srcPhrase;
		wxLogDebug(_T("THIS sequNum = %d ;  THIS srcPhrase = %s"),thisSequNum,thisSrcPhrase.c_str());
		// now scan over the whole doc, show where the bogus MP and MM ones are
		while (pos != NULL)
		{
			bool bGotPuncts = FALSE;
			bool bGotMarkers = FALSE;
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			int sequNum = pSrcPhrase->m_nSequNumber;
			wxString srctext = pSrcPhrase->m_srcPhrase;
			if (!pSrcPhrase->m_pMedialPuncts->IsEmpty())
			{
				bGotPuncts = TRUE;
				mpStr = pSrcPhrase->m_pMedialPuncts->Item(0); // just want first
				mpCount = pSrcPhrase->m_pMedialPuncts->GetCount(); // count how many
			}
			if (!pSrcPhrase->m_pMedialMarkers->IsEmpty())
			{
				bGotMarkers = TRUE;
				mmStr = pSrcPhrase->m_pMedialMarkers->Item(0); // just want first
				mmCount = pSrcPhrase->m_pMedialMarkers->GetCount(); // count how many
			}
			if (bGotPuncts || bGotMarkers)
			{
				wxLogDebug(_T("sn = %d ; srcPhrase = %s ; MP count = %d , MP text = %s ; MM count = %d , MM text = %s"),
					sequNum, srctext.c_str(), mpCount, mpStr.c_str(), mmCount, mmStr.c_str());
			}
		}
		wxLogDebug(_T("    -------------------------------------------------"));
	}
#endif
#endif
}

void CAdapt_ItView::UpdateSequNumbers(int nFirstSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList = pApp->m_pSourcePhrases;

	// get the first
	SPList::Node* pos = NULL;
	if (nFirstSequNum == 0)
	{
		// don't do a Find to get the first one, in case numbers are not
		// currently up to date at the beginning
		pos = pList->GetFirst();
	}
	else
	{
		// for non-zero values, trust a Find will succeed - this is a potential
		// source of error, but since we almost always pass in zero, and we
		// try to keep numbers correct anyway, the risk is pretty small
		pos = pList->Item(nFirstSequNum);
	}
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext(); // needed for SPList
	wxASSERT(pSrcPhrase != NULL);
	pSrcPhrase->m_nSequNumber = nFirstSequNum;
	int index = nFirstSequNum;

	while (pos != 0)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		index++; // next sequence number
		pSrcPhrase->m_nSequNumber = index;
	}
}

// BEW 16Feb10, updated RestoreOriginalMinPhrases for doc version 5
// BEW 17Jul11, changed for GetRefString() to return KB_Entry enum, (and use all 10 maps
// for glossing KB - but that is irrelevant to this function)
int CAdapt_ItView::RestoreOriginalMinPhrases(CSourcePhrase *pSrcPhrase, int nStartingSequNum)
{
	// The following note is copied from Layout.cpp... it is very important
	// NOTE: in the event of an Unmerge operation, the active pile was the one that
	// got unmerged (and hence destroyed and its memory freed) - which; the
	// RestoreOriginalMinPhrases() function inserts the old CSourcePhrase instances
	// back into the app's m_pSourcePhrases list, and creates partner piles for these
	// with CAdapt_ItDoc::CreatePartnerPile() calls. The latter does not know about
	// what strip it will end up in, nor what position in that strip, because when
	// these creations are done the old strips are current (we could have a guess and
	// probably set the strip pointer correctly if the old strips exist, but not reliably
    // set the index within the strip's m_arrPiles array, and sometimes pile creation
    // is done when all strips are destroyed for a full layout rebuild, so there is not
    // much point in trying) - so we only go as far as having RestoreOriginalMinPhrases()
    // point the CAdapt_It::m_pActivePile at the partner pile for the first of the
	// created original minimum CSourcePhrase instances we've replaced in the list -
	// knowing full well that its m_pOwningStrip value will be NULL, and its m_nPile
	// value will be -1. That means that until the strips are updated, those members
	// will have those values, which means any function which depends on them before
	// RecalcLayout() has finished must know what to do if such a pile is the active
	// one - for instance, calling CPile::GetStripIndex() will return the invalid
	// index -1, and any attempt to Draw() such a pile would fail because m_nPile is
	// accessed in order to find its location in a strip in order to work out its
	// drawing rectangle, and garbage would be being accessed.

	// According to the above note, we must (in the refactored layout code) ensure that
	// deleting the pBigOne (merged) pile, which will also be the active pile, does not
	// result in the function exiting with m_pActivePile set to freed memory, so we add
	// code to reset the active pile to the first of the partner CPile pointers created
	// below; this is done at the end, and the passed in nStartingSequNum is the active
	// sequence number we use for resetting m_pActivePile

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int nCount = pSrcPhrase->m_nSrcWords;
	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* pos = pList->Item(nStartingSequNum);
	wxASSERT(pos != NULL);
	SPList::Node* savePos = pos; // used later below
	CSourcePhrase* pBigOne = (CSourcePhrase*)pos->GetData();
	wxASSERT(pBigOne != NULL);

    // BEW added 01Aug05 for free translation support; the merged source phrase may be part
    // of a free translation, but it's original saved sourcephrase pointers may not have
    // any free translation defined on them (because the user did the free translating
    // after the merge was done); or alternatively, there may have been a free translation
    // defined on the original sourcephrase instances in the merger (because the user
    // merged after doing the free translating -- and if the latter is the case then the
    // first of the original sourcephrases will contain a free translation -- and we can be
    // sure that no medial sourcephrase instance stores a free translation because the app
    // will not allow merging across filtered material, the filtered material can only be
    // on the first sourcephrase of the merge, or there must be no filtered material on any
    // sourcephrase in the merge -- this protocol simplifies what we must test for). If the
    // merged source phrase starts a free translation, we will make all the restored
    // original sourcephrases be within that free translation, and if it also ends the free
    // translation, then the last of the restored ones will also end the retranslation

	// in docVersion 4 & earlier, m_markers stored all filtered info, but in 5, it is
	// split between 4 string members; we'll retain the bool's name, but set or clear it
	// by updated criteria
	bool bHasNonEmptyM_Markers = FALSE;
	// any one of the following tests succeeding is enough to set the flag
	if (!pBigOne->GetFilteredInfo().IsEmpty())
	{
		bHasNonEmptyM_Markers = TRUE;
	}
	else if (!pBigOne->GetFreeTrans().IsEmpty())
	{
		bHasNonEmptyM_Markers = TRUE;
	}
	else if (!pBigOne->GetNote().IsEmpty())
	{
		bHasNonEmptyM_Markers = TRUE;
	}
	else if (!pBigOne->GetCollectedBackTrans().IsEmpty())
	{
		bHasNonEmptyM_Markers = TRUE;
	}
	bool bHasFreeTrans = pBigOne->m_bHasFreeTrans ? TRUE : FALSE; // keep this in doc version 5
					// because the m_freeTrans member may have an empty string, but the bool
					// may be TRUE
	bool bStartsAFreeTranslation = pBigOne->m_bStartFreeTrans ? TRUE : FALSE;
	bool bEndsAFreeTranslation = pBigOne->m_bEndFreeTrans ? TRUE : FALSE;

    // BEW added 27Dec07: to handle preservation of any Note's m_bHasNote == TRUE value
    // across the unmerge; since we now allow a merge if filtered info is on the first word
    // or phrase in the selection
	bool bHasNote = pBigOne->m_bHasNote ? TRUE : FALSE; // the value is used below (retain in
					// doc version 5, for same reason as for bHasFreeTrans)

	// set the first in the saved original srcPhrase objects to have sequ number as passed in
	SPList::Node* pos1;
	SPList* pSaved = pBigOne->m_pSavedWords;
	pos1 = pSaved->GetFirst();
	wxASSERT(pos1 != NULL);
	CSourcePhrase* pSP = (CSourcePhrase*)pos1->GetData();
	wxASSERT(pSP != NULL);
	pSP->m_nSequNumber = nStartingSequNum; // this ensures we renumber correctly using
										   // UpdateSequNum()
	pSP->m_bHasKBEntry = FALSE;
	pSP->m_bRetranslation = FALSE; // otherwise, after a wrong retranslation & cancel, it is
								   // possible to have this flag wrongly still set TRUE, & text
								   // of wrong colour shows

	// handle any initial filtered material, including any free translation which is filtered
	// and any Note's flag
	if (bHasNote)
	{
		pSP->m_bHasNote = pBigOne->m_bHasNote; // transfer the Note flag's value when TRUE
		pSP->SetNote(pBigOne->GetNote()); // transfer text of the note
	}
	if (bHasNonEmptyM_Markers)
	{
		// this block needs to handle collected back trans, and m_filteredInfo, and m_markers
		if (!pBigOne->GetFilteredInfo().IsEmpty())
		{
			pSP->SetFilteredInfo(pBigOne->GetFilteredInfo());
		}
		if (!pBigOne->GetCollectedBackTrans().IsEmpty())
		{
			pSP->SetCollectedBackTrans(pBigOne->GetCollectedBackTrans());
		}
		// m_markers is not yet private, so it has no getter or setter
		pSP->m_markers = pBigOne->m_markers; // transfer the material in m_markers to the first one
	}
	// handle the flag for commencement of a free translation section
	if (bStartsAFreeTranslation)
	{
		pSP->m_bStartFreeTrans = TRUE;
		// and since it starts here, transfer it's string as well
		pSP->SetFreeTrans(pBigOne->GetFreeTrans());
	}
	else
	{
		// only clear the flag, the free translation itself is stored on an instance
		// preceding the selected span of CSourcePhrase instances
		pSP->m_bStartFreeTrans = FALSE;
	}
	// insert, starting from tail, after the pBigOne,
	// thereby preserving original element order
	pos1 = pSaved->GetLast();
	// now pos1 points at the last item of pBigOne's pSaved list
	wxASSERT(pos1 != NULL);
	bool bIsLast = TRUE;

    // wx Note: Get a node called newInsertBeforePos which points to the next node beyond
    // savePos in pList and use its position in the Insert() call (which only inserts
    // BEFORE the indicated position). The result should be that the insertions will get
    // placed in the list the same way that MFC's InsertAfter() places them.
	// BEW added 25Oct09: the above logic gives a crash if unmerging a merger at the
	// document's end. Therefore we need to test for this condition and when it occurs
	// we must insert a dummy CSourcePhrase pointer at the doc end so as to use it for
	// the initial "insert before" operation
	bool bDummyAdded = FALSE;
	SPList::Node* newInsertBeforePos = savePos->GetNext();
	if (newInsertBeforePos == NULL)
	{
		bDummyAdded = TRUE;
		CSourcePhrase* pDummySrcPhrase = new CSourcePhrase();
		newInsertBeforePos = pList->Append(pDummySrcPhrase);
		wxASSERT(newInsertBeforePos != NULL);
	}
	while (pos1 != NULL)
	{
		CSourcePhrase* pSP = (CSourcePhrase*)pos1->GetData();
		pos1 = pos1->GetPrevious();
		pSP->m_bHasKBEntry = FALSE;

		// wxList has no equivalent to InsertAfter(). The wxList Insert() method
		// inserts the new node BEFORE the current position/node. To emulate what
		// the MFC code does, we insert before using newInsertBeforePos.
		// wx note: If newInsertBeforePos is NULL, it means the insert position is
		// at the end of the list; in this case we just append the item to the end
		// of the list.
		if (newInsertBeforePos == NULL)
			pList->Append(pSP);
		else
			pList->Insert(newInsertBeforePos,pSP);

		// BEW added 13Mar09 for refactored layout
		GetDocument()->CreatePartnerPile(pSP);

		// since we must now insert before the inserted node above, we need to get a
		// previous node (which will actually be the just inserted source phrase)
		newInsertBeforePos = newInsertBeforePos->GetPrevious();

        // handle any free translation booleans needing to be set; a free translation is
        // either to be defined on all the original instances, or it is defined for none -
        // and if the merger was also the end of a free translation, then the end of the
        // originals must have the m_bEndFreeTrans flag set too
		if (bHasFreeTrans)
			pSP->m_bHasFreeTrans = TRUE;
		else
			pSP->m_bHasFreeTrans = FALSE;
		if (bIsLast)
		{
			if (bEndsAFreeTranslation)
				pSP->m_bEndFreeTrans = TRUE;
			else
				pSP->m_bEndFreeTrans = FALSE;
			bIsLast = FALSE; // prevent subsequent access to this block
		}

        // prior to version 2.0, unmerging cleared the m_adaption and m_targetStr members
        // on the restored original minimal sourcephrases. This is too severe a behaviour,
        // there is no good reason why any original adaptations can't remain in place and
        // their entries restored to the KB (if non-null), so this is what I will do here
        // now.
		if (!pSP->m_adaption.IsEmpty())
		{
			// restore its KB entry
			bool bOK;
			bOK = pApp->m_pKB->StoreText(pSP,pSP->m_adaption);
			bOK = bOK; // avoid waring
		}

		if (pApp->m_pKB->IsItNotInKB(pSP))
			pSP->m_bNotInKB = TRUE;
		else
			pSP->m_bNotInKB = FALSE;
		pSP->m_bRetranslation = FALSE; // otherwise, after a wrong retranslation & cancel, it is
									   // possible to have this flag wrongly still set TRUE, &
									   // text of wrong colour shows
	}
	// BEW added 25Oct09, remove the dummy CSOurcePhrase appended at the list end for
	// supporting insertions, if we appended one above
	if (bDummyAdded)
	{
		SPList::Node* extraPos = pList->GetLast();
		wxASSERT(extraPos != NULL);
		CSourcePhrase* pDummySrcPhrase = extraPos->GetData();
		if (pDummySrcPhrase != NULL) // whm 11Jun12 added NULL test
			delete pDummySrcPhrase;
		pList->Erase(extraPos);
	}

    // pBigOne will not be needed any longer, and its KB stuff must be removed or reference
    // decremented; append any refString's m_translation to the pApp->m_targetPhrase, so
    // user can edit or delete the resulting composite string when the phraseBox is
    // eventually put up (note, next call, pRefString may point to <Not In KB>)
    KB_Entry rsEntry;
	CRefString* pRefString = NULL;
	rsEntry = pApp->m_pKB->GetRefString(pBigOne->m_nSrcWords, pBigOne->m_key,
										pBigOne->m_adaption, pRefString);
	pList->DeleteNode(savePos);
	if (pBigOne->m_bHasKBEntry && rsEntry == really_present)
	{
		pApp->m_pKB->RemoveRefString(pRefString, pBigOne, pBigOne->m_nSrcWords);
		pBigOne->m_bHasKBEntry = FALSE;

		// set up pApp->m_targetPhrase using pBigOne's m_targetStr attribute
		if (pApp->m_targetPhrase.IsEmpty())
			pApp->m_targetPhrase = pBigOne->m_targetStr;
		else
			pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + pBigOne->m_targetStr;
	}
	else // might be a deleted KB entry
	{
        // might have had save to KB suppression turned on, so check this case out too - if
        // the m_bNotInKB flag is set, we don't need to remove anything from the KB, but we
        // do need to set pApp->m_targetPhrase using the m_targetStr string's value
		if (pBigOne->m_bNotInKB)
		{
			if (pApp->m_targetPhrase.IsEmpty())
			{
				pApp->m_targetPhrase = pBigOne->m_targetStr;
			}
			else
			{
				if (!pBigOne->m_targetStr.IsEmpty())
					pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + pBigOne->m_targetStr;
			}
		}
	}

	if (pBigOne->m_pMedialMarkers->GetCount() > 0)
	{
		pBigOne->m_pMedialMarkers->Clear();
	}
	if (pBigOne->m_pMedialMarkers != NULL) // whm 11Jun12 added NULL test
		delete pBigOne->m_pMedialMarkers;
	pBigOne->m_pMedialMarkers = (wxArrayString*)NULL;
	if (pBigOne->m_pMedialPuncts->GetCount() > 0)
	{
		pBigOne->m_pMedialPuncts->Clear();
	}
	if (pBigOne->m_pMedialPuncts != NULL) // whm 11Jun12 added NULL test
		delete pBigOne->m_pMedialPuncts;
	pBigOne->m_pMedialPuncts = (wxArrayString*)NULL;
	if (pBigOne->m_pSavedWords->GetCount() > 0)
	{
		// only remove pointers, never delete the memory they point to, because
		// any copies of this source phrase will only have copied pointers in the sublist
		pBigOne->m_pSavedWords->Clear();
	}
	if (pBigOne->m_pSavedWords != NULL) // whm 11Jun12 added NULL test
		delete pBigOne->m_pSavedWords;
	pBigOne->m_pSavedWords = (SPList*)NULL;

	// BEW added 13Mar09 for refactor of layout; delete its partner pile too
	GetDocument()->DeletePartnerPile(pBigOne);

	if (pBigOne != NULL) // whm 11Jun12 added NULL test
		delete pBigOne;
	pBigOne = (CSourcePhrase*)NULL;

	// update the sequence numbers for elements subsequent to the first
	UpdateSequNumbers(nStartingSequNum);

    // BEW added 20May09, in the refactored layout, restoring original CSourcePhrase
    // instances requires CPile partners be created and inserted into equivalent positions
    // in the m_pileList list as for their CSourcePhrase partners in m_pSourcePhrases list,
    // but the newly created piles won't have their m_pOwningStrip member set (it will be
    // NULL) nor their m_nPile member set to a valid index, but to -1. Deleting the passed
    // in original CSourcePhrase (it was at the active location) results in m_pActivePile
    // which formerly pointed at its partner pile, and which also got freed, not pointing
    // at a valid CPile pointer in memory; so m_pActivePile has to be re-established here
    // before returning (in the legacy layout, m_pActivePile got reset after the layout was
    // rebuilt, but in our refactored approach, piles are persistent and so we have to
    // reestablish the active pile pointer before RecalcLayout() is called, because code in
    // the latter uses it)
	pApp->m_pActivePile = GetPile(nStartingSequNum);

	return nCount;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If the application is in glossing mode, or it is showing only the target text, or the
/// m_pActivePile pointer is NULL, or the active pile's m_pSrcPhrase is NULL, this handler
/// disables the "Unmake A Phrase" toolbar item and returns immediately.
/// If the App's m_selectionLine is not -1, and the App's m_selection list has exactly one
/// item in its list associated with a previous merger, or alternatively, if the App's
/// m_selectioniLine is -1, and the first item in in the active pile's m_selection is
/// associated with a previous merger, it enables the toolbar button, otherwise it disables
/// the toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRestore(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	
	// whm added 26Mar12. Disable tool bar button when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL || pApp->m_pActivePile->GetSrcPhrase() == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1 && pApp->m_selection.GetCount() == 1)
	{
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = cpos->GetData();
		CSourcePhrase* pSP = pCell->GetPile()->GetSrcPhrase();
		if (pSP->m_nSrcWords > 1)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
	else if (pApp->m_selectionLine == -1 && pApp->m_pTargetBox != NULL
										&& pApp->m_pTargetBox->IsShown())
	{
		CSourcePhrase* pSP = pApp->m_pActivePile->GetSrcPhrase();
		if (pSP->m_nSrcWords > 1)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

// BEW 26Mar10, no changes needed for support of doc version 5
void CAdapt_ItView::UnmergePhrase()
{
	wxCommandEvent dummyevent;
	OnButtonRestore(dummyevent); // since is protected, &
			// we want to call it from OnChar() in CPhraseBox class
}

// removes a merged phrase by restoring it to a sequence of the original CSourcePhrase
// instances which were stored on the merged phrase at the time of merger
// BEW changed 27Dec07: unmerging when there was a note stored on the merger did not retain
// the m_bHasNote flag value by setting it on the first CSourcePhrase instance in the
// unmerged sequence, so I fixed it so it would do so
//
// BEW updated OnButtonRestore() 16Feb10 for support of doc version 5 (nothing needed to be done)
void CAdapt_ItView::OnButtonRestore(wxCommandEvent& WXUNUSED(event))
{
    // Since the Restore (Unmerge) toolbar button has an accelerator table hot key (CTRL-U
    // see CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even
    // when they are disabled, we must check for a disabled button and return if disabled.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	// whm 12Oct10 modified for user workflow profile compatibility
	if (pToolBar->GetToolPos(ID_BUTTON_RESTORE) == wxNOT_FOUND)
		return;
	if (!pToolBar->GetToolEnabled(ID_BUTTON_RESTORE))
	{
		::wxBell();
		return;
	}
    // In glossing mode (ie. actually glossing) I think I've managed to silently prevent
    // any unmerge from happening before OnButtonRestore( ) can get invoked. However, it
    // the user were to explicitly click the button, there is no recourse except to tell
    // him that the removing a merger is not available when doing glossing
	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_(
		"This particular operation is not available when you are glossing."),
		_T(""),wxICON_INFORMATION | wxOK);
		return;
	}

	// must be adapting mode, so continue with the request
	CAdapt_ItDoc* pDoc = GetDocument();
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;
	CPile* pActivePile;
	CPile* pPile;
	CCellList::Node* pos;
	CSourcePhrase* pSrcPhrase;
	int nCount;
	int nSaveSequNum;

    // get the single selected CSourcePhrase instance, or the location of phrasebox if no
    // selection
	if (pApp->m_selectionLine != -1)
	{
		pos = pApp->m_selection.GetFirst();
		nCount = pApp->m_selection.GetCount();
		// BEW added 25Jun09 to make it safe if the user selects more than one word
		if (nCount > 1)
		{
			// it shouldn't be possible for control to come here, because the update
			// handlers would detect a multipile selection and disable the Restore button,
			// but just in case, ensure no harm is done if somehow this function is called
			RemoveSelection();
			wxMessageBox(_(
			"To undo a merger using a selection, select only one pile."),
			_T(""),wxICON_INFORMATION | wxOK);
			return;
		}
		wxASSERT(nCount == 1); // must only be one

		CCell* pCell = (CCell*)pos->GetData();
		pos = pos->GetNext();
		pPile = pCell->GetPile(); // get the pile for this selection
		pStartingPile = pPile; // need this for later when we look up the strip which
							   // first pile is in prior to calling RecalcLayout()
		pSrcPhrase = pPile->GetSrcPhrase();
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything
												  // depends on it
		// the active location may be remote from where the unmerge is done, so make sure
		// the active strip is marked invalid too
		pDoc->ResetPartnerPileWidth(pSrcPhrase); // FALSE for param
												 // bNoActiveLocationCalculation

        // there could be an edited phrase waiting for a RETURN key press, and the
        // selection may be on a different pile, in which case unless we update the active
        // pile's srcPhrase before doing the restore, the latter would be wrongly cleared
        // of its adaptation text, so we check for such a condition here & do the necessary
        // fixes before proceeding
		pActivePile = pApp->m_pActivePile;
		if (pActivePile != pStartingPile)
		{
            // the selected pile is not the active one, so update the active one then make
            // the selected one the active one; so store the translation in the knowledge
            // base
			MakeTargetStringIncludingPunctuation(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);
			RemovePunctuation(pDoc, &pApp->m_targetPhrase, from_target_text);
			bool bOK = pApp->m_pKB->StoreText(pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);
			if (!bOK)
				return; // can't proceed until a valid adaption (which could be null)
                        // is supplied for the former active pile's srcPhrase
			else
			{
				// make the pile at start of former strip have a new pointer - new layout
				// code will then tweak the layout from that point on; if there is no
				// former strip, use the current one instead
				int nFormerStrip = pActivePile->GetStripIndex();
				pDoc->ResetPartnerPileWidth(pActivePile->GetSrcPhrase()); // mark the
																// active strip invalid
				pApp->m_pTargetBox->ChangeValue(_T("")); // we don't want the former active
										// pile's text to be carried to the selected pile
				int nCurStripIndex = pStartingPile->GetStripIndex();
				if (nCurStripIndex != nFormerStrip)
				{
					CStrip* pFormerStrip = (CStrip*)
										GetLayout()->GetStripArray()->Item(nFormerStrip);
					CPile* pItsFirstPile = (CPile*)pFormerStrip->GetPilesArray()->Item(0);
					CSourcePhrase* pItsFirstSrcPhrase = pItsFirstPile->GetSrcPhrase();
					// also mark the former strip invalid (ensures we include all piles
					// that might require updating)
					pDoc->ResetPartnerPileWidth(pItsFirstSrcPhrase, TRUE); // TRUE is
														// bNoActiveLocationCalculation
				}
			}
		}
		RemoveSelection();
	}
	else // there is no current selection
	{
        // no selection, so just remove the merger at wherever the phraseBox currently is
        // located
		pPile = pApp->m_pActivePile;
		pStartingPile = pPile;
		pSrcPhrase = pPile->GetSrcPhrase();
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number,
												  // everything depends on it
		pDoc->ResetPartnerPileWidth(pSrcPhrase); // FALSE for
												 // bNoActiveLocationCalculation
	}

	// make m_targetPhrase cleared, as it must accumulate any existing translations
	// removed from the KB because of the earlier merge
	pApp->m_targetPhrase.Empty();

	// determine that it is a genuine non-minimal phrase. If it is, we must
	// restore the original list of minimal phrases (ie. words), and clear the
	// translations from the KB.
	wxASSERT(pSrcPhrase->m_nSrcWords > 1);
	int nNumElements = 1;
    // RestoreOriginalMinPhrases also appends any adaptation to m_targetPhrase; it also
    // updates sequ numbers after the restore is done; it calls CreatePartnerPile() for
    // each CSourcePhrase ptr it restores to the doc list, and calls DeletePartnerPile()
    // for before deleting the merged one
	nNumElements = RestoreOriginalMinPhrases(pSrcPhrase,nSaveSequNum);

    // at this point, m_targetPhrase will have the target text in it if the selection was
    // done by clicking with the mouse on the source line; but if the click was on the
    // target cell then the KB will have had the adaption text cleared (or refCount
    // reduced) and the target text will have been preserved only in the phraseBox itself;
    // so we must check for the latter case and restore the text before proceeding
	if (pApp->m_targetPhrase.IsEmpty())
		pApp->m_targetPhrase = pApp->m_pTargetBox->GetValue();

	// update the bundle indices
	int nExtras = nNumElements - 1;

	// BEW added 09Sep08 in support of vertical editing
	if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
	{
		gEditRecord.nAdaptationStep_EndingSequNum += nExtras;
		gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nExtras; // LHS can become -ve legally
		gEditRecord.nAdaptationStep_NewSpanCount += nExtras;
	}

	// pos is defined as CCellList node above, so we must use a different identifier here
	// since we want a SPList node
	SPList::Node* posSP;
	posSP = pSrcPhrases->Item(nSaveSequNum);
	wxASSERT(posSP != NULL);
	CSourcePhrase* pFirstSrcPhrase;
	pFirstSrcPhrase = (CSourcePhrase*)posSP->GetData();
	posSP = posSP->GetNext();
	wxASSERT(pFirstSrcPhrase != NULL);
	wxASSERT(pFirstSrcPhrase->m_nSrcWords == 1 ||
		pFirstSrcPhrase->m_nSrcWords == 0); // no phrases allowed
	wxASSERT(posSP != NULL);
	pFirstSrcPhrase = pFirstSrcPhrase; // avoid warning (nope, extra stuff for debugging)
	// ensure a correct active sequ num when done
	pApp->m_nActiveSequNum = nSaveSequNum;

	// recalculate the layout
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif

	// get a new (valid) active pile pointer, now that the layout is recalculated
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);

    // look up the single src word in the KB; if we can get a translation for it, use that,
    // if not then just retain the old merged phrase's translation
	bool bWantSelect = FALSE;
	bool bGotTranslation;
	if (!gbSuppressLookup)
	{
		gbUnmergeJustDone = TRUE; // prevent second OnButtonRestore() call from within
								  // ChooseTranslation() within LookUpSrcWord() if user happens
								  // to cancel the Choose Translation dialog (see CPhraseBox code)
		bGotTranslation = pApp->m_pTargetBox->LookUpSrcWord(pApp->m_pActivePile);
		gbUnmergeJustDone = FALSE; // clear flag, ready for next time
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum); // restore pointer, since
											// LookUpSrcWord() now calls RecalcLayout()
		if (bGotTranslation)
		{
			// we have to check here, in case the translation it found was a "<Not In KB>"
			// - in which case, we must display an empty box and ensure that the pile has an
			// asterisk above it, etc
			if (translation == _T("<Not In KB>"))
			{
				pApp->m_targetPhrase.Empty(); // phrase box must be shown empty
				pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
				pApp->m_pActivePile->GetSrcPhrase()->m_bNotInKB = TRUE;
				pApp->m_pActivePile->GetSrcPhrase()->m_adaption.Empty();
				pApp->m_pActivePile->GetSrcPhrase()->m_targetStr.Empty();
				bWantSelect = FALSE;
			}
			else
			{
				pApp->m_targetPhrase = translation; // set using the global var,
													// set in LookUpSrcWord()
				bWantSelect = TRUE;
			}
		}
		else // no translation found
		{
			// do the copy of source instead, or nothing if Copy Source flag is not set
			if (pApp->m_bCopySource)
			{
                // copy source key only provided this is not a null source phrase, don't
                // want "..." copied!
				pApp->m_targetPhrase =
						CopySourceKey(pApp->m_pActivePile->GetSrcPhrase(),
										pApp->m_bUseConsistentChanges);
				bWantSelect = TRUE;
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
			}
			else
			{
				pApp->m_targetPhrase.Empty();
				bWantSelect = FALSE;
			}
		}

		// need to recalc layout again
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pApp->m_pActivePile != NULL);
	}
	else // was suppressed, so clear the flag now
	{
		gbSuppressLookup = FALSE;
	}

	if (bWantSelect)
	{
		pApp->m_nStartChar = 0;
		pApp->m_nEndChar = -1;
	}
	else
	{
		int len = pApp->m_targetPhrase.Length();
		pApp->m_nStartChar = len;
		pApp->m_nEndChar = len;
	}
	Invalidate();
	GetLayout()->PlaceBox();
}

// return TRUE if the selection extended, FALSE if not (would be false only if at a
// boundary) m_pAnchor is always the pile at which the phraseBox currently is; this
// function is only for the ALT plus arrow key selection method
bool CAdapt_ItView::ExtendSelectionRight()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	// can't extend if we are showing only the target line
	if (gbShowTargetOnly)
		return TRUE; // don't want message about boundaries

	// remove an existing selection if it was not done using the arrow key, save
	// m_bRespectBoundaries across this operation
	bool bSaveFlag = pApp->m_bRespectBoundaries;

	if (pApp->m_selection.GetCount() > 0 && !pApp->m_bSelectByArrowKey)
	{
		RemoveSelection();
		Invalidate();
		GetLayout()->PlaceBox();
	}
	// restore flag (and button)
	if (bSaveFlag == FALSE)
	{
		OnButtonFromRespectingBdryToIgnoringBdry(dummyevent);
	}

	// need a CClientDC
	wxClientDC aDC(pApp->GetMainFrame()->canvas);

	canvas->DoPrepareDC(aDC); //OnPrepareDC(&aDC); // adjust the origin

	CPile* pActivePile = pApp->m_pActivePile;
	wxASSERT(pActivePile != NULL);
	//pApp->m_pAnchor = pActivePile->m_pCell[1];
	pApp->m_pAnchor = pActivePile->GetCell(0);
	bool bSelExists = pApp->m_selection.GetCount() > 0;
	if (bSelExists && pApp->m_bSelectByArrowKey)
	{
        // if we are extending to the right in a selection to the left, we have to remove
        // the first pile's selection
		if (pApp->m_curDirection == left)
		{
			// find the leftmost cell of the selection
			CCellList::Node* cpos = pApp->m_selection.GetFirst();
			CCell* pLeftmost = (CCell*)cpos->GetData();

			// remove this cell's selection...
			// (next line, Do not use wxTRANSPARENT here!!
			// it leaves any existing yellow background)
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pLeftmost->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pLeftmost->SetSelected(FALSE);

			// preserve record of the deselection
			CCellList::Node* pos = pApp->m_selection.GetFirst();
			if (pos != NULL)
				pApp->m_selection.DeleteNode(pos);

			// if the deselection brought us back to the anchor cell, then
			// remove the selection entirely (ie. remove anchor cell seln too)
			CCell* pNextCell = GetNextCell(pLeftmost,0);
			if (pNextCell != NULL)
			{
				CPile* pNextPile = pNextCell->GetPile();
				if (pNextPile == pActivePile)
				{
					// remove this pile's selection too
					pNextCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
					pNextCell->SetSelected(FALSE);

					// make all the parameter agree with no selection
					pApp->m_bSelectByArrowKey = FALSE;
					pApp->m_selectionLine = -1;
					pApp->m_pAnchor = NULL;
					pApp->m_selection.Clear();
					// TODO 30Jun09 Check if below is still needed
					gnSelectionLine = -1; // whm added 21Feb09 to get global
										  // back in sync with reality
					gnSelectionStartSequNum = -1; // whm added 21Feb09 to get global
												  // back in sync with reality
					gnSelectionEndSequNum = -1; // whm added 21Feb09 to get global
												// back in sync with reality
				}
			}
			else
			{
				wxMessageBox(_(
				"Error while trying to deselect a cell. Try selecting using the mouse instead.\n"),
                _T(""), wxICON_INFORMATION | wxOK);
				RemoveSelection();	// whm added 7July06 to prevent crash when invoking
						// ALT+Rightarrow at end of document (avoids m_selectionLine becoming 1
						// while m_selection is empty. The crash would happen in a OnUpdateUI
						// handler that tests the status of m_selectionLine != -1
				return FALSE;
			}
#ifdef __WXMAC__
			pApp->GetMainFrame()->SendSizeEvent(); // this is needed for wxMAC to paint
												   // the highlighted source correctly
#endif
			return TRUE;
		}

		// find the rightmost cell of the selection
		CCellList::Node* ccpos = pApp->m_selection.GetLast();
		CCell* pRightmost = (CCell*)ccpos->GetData();
		CPile* pRightPile = pRightmost->GetPile();

		if (pApp->m_bRespectBoundaries)
		{
			if (pRightPile->GetSrcPhrase()->m_bBoundary) // can't extend past a boundary
				return FALSE;
		}

		CCell* pNextCell = GetNextCell(pRightmost,0);

        // if vertical edit is in effect, and we are in adaptationsStep (glossesStep
        // doesn't allow this selection method because glossing mode doesn't), then check
        // that we've not encroached on the gray text to the right, if we have then beep
        // and remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			pRightPile = pNextCell->GetPile();
			if (pRightPile->GetSrcPhrase()->m_nSequNumber >
					gEditRecord.nAdaptationStep_EndingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pNextCell != NULL)
		{
			wxASSERT(pNextCell != NULL);
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			pNextCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pNextCell->SetSelected(TRUE); // set m_bSelected to TRUE

			// preserve record of the selection
			pApp->m_selection.Append(pNextCell);
			pApp->m_selectionLine = 0;
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the next cell. Try selecting with the mouse instead.\n"),
            _T(""), wxICON_INFORMATION | wxOK);
			RemoveSelection();	// whm added 7July06 to prevent crash when invoking
					// ALT+Rightarrow at end of document (avoids m_selectionLine becoming 1
					// while m_selection is empty. The crash would happen in a OnUpdateUI
					// handler that tests the status of m_selectionLine != -1
			return FALSE;
		}
	}
	else
	{
		// no selection yet, so select the cell in the active pile before extending right
		pApp->m_bSelectByArrowKey = TRUE;
		pApp->m_curDirection = right;
		aDC.SetBackgroundMode(pApp->m_backgroundMode);
		aDC.SetTextBackground(wxColour(255,255,0)); // yellow
		CCell* pCell = pActivePile->GetCell(0);
		pCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
		pCell->SetSelected(TRUE);

		// preserve record of the selection
		pApp->m_selection.Append(pCell);
		pApp->m_selectionLine = 0;

		// now try extend it one cell right
		if (pApp->m_bRespectBoundaries)
		{
			if (pActivePile->GetSrcPhrase()->m_bBoundary) // can't extend past a boundary
				return FALSE;
		}
		CCell* pNextCell = GetNextCell(pCell,0);

        // if vertical edit is in effect, and we are in adaptationsStep (glossesStep
        // doesn't allow this selection method because glossing mode doesn't), then check
        // that we've not encroached on the gray text to the right, if we have then beep
        // and remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			CPile* pRightPile = pNextCell->GetPile();
			if (pRightPile->GetSrcPhrase()->m_nSequNumber >
					gEditRecord.nAdaptationStep_EndingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pNextCell != NULL)
		{
			wxASSERT(pNextCell != NULL);
			pNextCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pNextCell->SetSelected(TRUE);

			// preserve record of the selection
			pApp->m_selection.Append(pNextCell);
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the next cell. Try selecting with the mouse instead.\n"),
            _T(""), wxICON_INFORMATION | wxOK);
			RemoveSelection();	// whm added 7July06 to prevent crash when invoking
					// ALT+Rightarrow at end of document (avoids m_selectionLine becoming 1
					// while m_selection is empty. The crash would happen in a OnUpdateUI
					// handler that tests the status of m_selectionLine != -1
			return FALSE;
		}
	}
#ifdef __WXMAC__
	pApp->GetMainFrame()->SendSizeEvent(); // this is needed for wxMAC to paint
										   // the highlighted source correctly
#endif
	return TRUE;
}

// return TRUE if the selection extended, FALSE if not (would be false only if at a
// boundary) this function works with selections on the 2nd line only; m_pAnchor is alway
// the pile at which the phraseBox currently is
bool CAdapt_ItView::ExtendSelectionLeft()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	// can't extend if we are showing only the target line
	if (gbShowTargetOnly)
		return TRUE; // don't want message about boundaries

	// remove an existing selection if it was not done using the arrow key, save
	// m_bRespectBoundaries across this operation
	bool bSaveFlag = pApp->m_bRespectBoundaries;
	if (pApp->m_selection.GetCount() > 0 && !pApp->m_bSelectByArrowKey)
	{
		RemoveSelection();
		Invalidate();
		GetLayout()->PlaceBox();
	}
	// restore flag (and button)
	if (bSaveFlag == FALSE)
	{
		OnButtonFromRespectingBdryToIgnoringBdry(dummyevent);
	}

	// need a CClientDC
	wxClientDC aDC(pApp->GetMainFrame()->canvas);

	canvas->DoPrepareDC(aDC); //OnPrepareDC(&aDC); // adjust the origin

	CPile* pActivePile = pApp->m_pActivePile;
	wxASSERT(pActivePile != NULL);
	pApp->m_pAnchor = pActivePile->GetCell(0);
	bool bSelExists = pApp->m_selection.GetCount() > 0;
	if (bSelExists && pApp->m_bSelectByArrowKey)
	{
		// if we are backing up in a selection to the right, we have to remove
		// the last pile's selection
		if (pApp->m_curDirection == right)
		{
			// find the rightmost cell of the selection
			CCellList::Node* cpos = pApp->m_selection.GetLast();
			CCell* pRightmost = (CCell*)cpos->GetData();

			// remove this cell's selection...
			// For next line, do not use wxTRANSPARENT here!!
			// it leaves any existing yellow background
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pRightmost->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pRightmost->SetSelected(FALSE); // set CCell::m_bSelected to FALSE

			// preserve record of the deselection
			CCellList::Node* pos = pApp->m_selection.GetLast();
			if (pos != NULL)
				pApp->m_selection.DeleteNode(pos);

			// if the deselection brought us back to the anchor cell, then
			// remove the selection entirely (ie. remove anchor cell selection too)
			CCell* pPrevCell = GetPrevCell(pRightmost,0);
			if (pPrevCell != NULL)
			{
				CPile* pPrevPile = pPrevCell->GetPile();
				if (pPrevPile == pActivePile)
				{
					// remove this pile's selection too
					pPrevCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
					pPrevCell->SetSelected(FALSE);

					// make all the parameter agree with no selection
					pApp->m_bSelectByArrowKey = FALSE;
					pApp->m_selectionLine = -1;
					pApp->m_pAnchor = NULL;
					pApp->m_selection.Clear();
					// TODO 30Jun09 Check if below is still needed
					gnSelectionLine = -1; // whm added 21Feb09 to get global
										  // back in sync with reality
					gnSelectionStartSequNum = -1; // whm added 21Feb09 to get global
												  // back in sync with reality
					gnSelectionEndSequNum = -1; // whm added 21Feb09 to get global
												// back in sync with reality
				}
			}
			else // pPrevCell is NULL
			{
				wxMessageBox(_(
				"Error while trying to deselect a cell. Try selecting using the mouse instead.\n"),
                _T(""), wxICON_INFORMATION | wxOK);
				return FALSE;
			}
#ifdef __WXMAC__
			pApp->GetMainFrame()->SendSizeEvent(); // this is needed for wxMAC to paint
												   // the highlighted source correctly
#endif
			return TRUE;
		}
		// find the leftmost cell of the selection
		CCellList::Node* fpos = pApp->m_selection.GetFirst();
		CCell* pLeftmost = fpos->GetData();
		//CCell* pPrevCell = GetPrevCell(pLeftmost,1);
		CCell* pPrevCell = GetPrevCell(pLeftmost,0);

        // if vertical edit is in effect, and we are in adaptationsStep (glossesStep
        // doesn't allow this selection method because glossing mode doesn't), then check
        // that we've not encroached on the gray text to the left, if we have then beep and
        // remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			CPile* pPrevPile = pPrevCell->GetPile();
			if (pPrevPile->GetSrcPhrase()->m_nSequNumber <
					gEditRecord.nAdaptationStep_StartingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pPrevCell != NULL)
		{
			wxASSERT(pPrevCell != NULL);
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			CPile* pPrevPile = pPrevCell->GetPile();

			if (pApp->m_bRespectBoundaries)
			{
				if (pPrevPile->GetSrcPhrase()->m_bBoundary) // can't extend left on to a boundary
					return FALSE;
			}

			pPrevCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pPrevCell->SetSelected(TRUE);

			// preserve record of the selection
			pApp->m_selection.Insert(pPrevCell);
			pApp->m_selectionLine = 0;
		}
		else // pPrevCell is NULL
		{
			wxMessageBox(_(
			"Could not get a pointer to the previous cell. Try selecting with the mouse instead.\n"
			), _T(""), wxICON_INFORMATION | wxOK);
			return FALSE;
		}
	}
	else
	{
		// no selection yet, so select the cell in the active pile before extending left
		pApp->m_bSelectByArrowKey = TRUE;
		pApp->m_curDirection = left;
		aDC.SetBackgroundMode(pApp->m_backgroundMode);
		aDC.SetTextBackground(wxColour(255,255,0)); // yellow
		CCell* pCell = pActivePile->GetCell(0);
		pCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
		pCell->SetSelected(TRUE);

		// preserve record of the selection
		pApp->m_selection.Insert(pCell);
		pApp->m_selectionLine = 0;

		// now try extend it one cell left
		CCell* pPrevCell = GetPrevCell(pCell,0);
		if (pPrevCell == NULL) // whm added to prevent crash when phrasebox is in first pile
		{
			// we're at the first pile in the doc and can't move left
			RemoveSelection(); // whm added; if test were at top of current
							   // else block this wouldn't be needed
			return FALSE;
		}
		wxASSERT(pPrevCell != NULL);
		CPile* pPrevPile = pPrevCell->GetPile();
		wxASSERT(pPrevPile != NULL);
		if (pApp->m_bRespectBoundaries)
		{
			if (pPrevPile->GetSrcPhrase()->m_bBoundary) // can't extend past a boundary
			{
				// whm added below for situation when phrasebox is at last pile in doc and a
				// boundary prevents selecting previous pile.
				CCell* pNextCell = GetNextCell(pCell,0);
				if (pNextCell == NULL)
				{
					RemoveSelection();
				}
				return FALSE;
			}
		}

        // if vertical edit is in effect, and we are in adaptationsStep (glossesStep
        // doesn't allow this selection method because glossing mode doesn't), then check
        // that we've not encroached on the gray text to the left, if we have then beep and
        // remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			if (pPrevPile->GetSrcPhrase()->m_nSequNumber <
					gEditRecord.nAdaptationStep_StartingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pPrevCell != NULL)
		{
			pPrevCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pPrevCell->SetSelected(TRUE);

			// preserve record of the selection
			pApp->m_selection.Insert(pPrevCell);
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the previous cell. Try selecting with the mouse instead.\n"
			), _T(""), wxICON_INFORMATION | wxOK);
			return FALSE;
		}
	}
#ifdef __WXMAC__
	pApp->GetMainFrame()->SendSizeEvent(); // this is needed for wxMAC to paint
										   // the highlighted source correctly
#endif
	return TRUE;
}

// pass in a pile pointer which we want to know whether or not it is in the gray text area;
// the gEditStep is a global, so does not need to be passed in; return TRUE if the pile is
// in the editabe area, FALSE if in the gray area, and if a NULL pile is passed in, treat
// it as equivalent to being in the gray area (ie. return FALSE)
bool CAdapt_ItView::CheckForVerticalEditBoundsError(CPile* pPile)
{
	//bool bBadSwitchValue = FALSE;
	if (pPile == NULL)
		return FALSE;
	int nLeftBoundSN = 0; // whm initialized to avoid "potentially uninitialized local
						  // variable ... used" warning
	int nRightBoundSN = 0; // whm initialized to avoid "potentially uninitialized local
						   // variable ... used" warning
	if (gbVerticalEditInProgress &&
		(gEditStep == adaptationsStep ||
		gEditStep == glossesStep ||
		gEditStep == freeTranslationsStep
		))
	{
		switch(gEditStep)
		{
		case adaptationsStep:
			nLeftBoundSN = gEditRecord.nAdaptationStep_StartingSequNum;
			nRightBoundSN = gEditRecord.nAdaptationStep_EndingSequNum;
			break;
		case glossesStep:
			nLeftBoundSN = gEditRecord.nGlossStep_StartingSequNum;
			nRightBoundSN = gEditRecord.nGlossStep_EndingSequNum;
			break;
		case freeTranslationsStep:
			nLeftBoundSN = gEditRecord.nFreeTranslationStep_StartingSequNum;
			nRightBoundSN = gEditRecord.nFreeTranslationStep_EndingSequNum;
			break;
		case noEditStep:
			break;
		case sourceTextStep:
			break;
		case backTranslationsStep:
			break;
		}
		if ((pPile->GetSrcPhrase()->m_nSequNumber < nLeftBoundSN)
			||(pPile->GetSrcPhrase()->m_nSequNumber > nRightBoundSN))
		{
			RemoveSelection();
			::wxBell();
			return FALSE;
		}
	}
	return TRUE;
}

void CAdapt_ItView::MergeWords()
{
	wxCommandEvent dummyevent;
	OnButtonMerge(dummyevent);
}

void CAdapt_ItView::RemoveFinalSpaces(CPhraseBox* pBox, wxString* pStr)
{
	// empty strings don't need anything done
	if (pStr->IsEmpty())
		return;

	// remove any phrase final space characters
	bool bChanged = FALSE;
	int len = pStr->Length();
	int nIndexLast = len-1;
	do {
		if (pStr->GetChar(nIndexLast) == _T(' '))
		{
			// Note: wsString::Remove must have the second param as 1 here otherwise
			// it will truncate the remainder of the string!
			pStr->Remove(nIndexLast,1);
			// can't trust the Delete's returned value, it exceeds string length by one
			len = pStr->Length();
			nIndexLast = len -1;
			bChanged = TRUE;
		}
		else
		{
			break;
		}
	} while (len > 0 && nIndexLast > -1);

	if (bChanged) // need to do this, because for some reason rubbish is getting
            // left in the earlier box when the ChooseTranslation dialog gets put up. That
            // is, a simple call of SetWindowText with parameter pStr cast to (const char
            // *) doesn't work right; but the creation & setting of str below fixes it
	{
		wxString str = *pStr;
		pBox->ChangeValue(str);
	}

}


// BEW added 30Apr08, an overloaded version which deletes final spaces in any CString's
// text, and if there are only spaces in the string, it reduces it to an empty string
void CAdapt_ItView::RemoveFinalSpaces(wxString& rStr)
{
    // whm Note: This could be done with a single line in wx, i.e., rStr.Trim(TRUE), but
    // we'll go with the MFC version for now.
	if (rStr.IsEmpty())
		return;
	rStr = MakeReverse(rStr);
	wxChar chFirst = rStr[0];
	while (chFirst == _T(' '))
	{
		rStr = rStr.Mid(1);
		chFirst = rStr[0];
	}
	if (rStr.IsEmpty())
		return;
	else
		rStr = MakeReverse(rStr);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// It enables the "Change Interface Language..." item on the View menu. This menu item is
/// always enabled unless Vertical Editing is in progress.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateChangeInterfaceLanguage(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// should always be accessible
	event.Enable(TRUE);
}

void CAdapt_ItView::OnChangeInterfaceLanguage(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	pApp->LogUserAction(_T("Initiated OnChangeInterfaceLanguage()"));
	pApp->ChangeUILanguage();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is doing a vertical edit, only showing the target language, or the
/// Document pointer is NULL, this handler disables the "Preferences..." item on the View
/// menu and immediately returns.
/// It enables the "Preferences..." item on the View menu if a document is loaded (i.e.,
/// the count of source phrases in m_pSourcePhrases list is greater than zero), otherwise
/// it disables the menu item.
/// BEW note 6Nov09, the requirement that a doc be open is unnecessarily stringent,
/// there are times when you'd want access when no doc is loaded - such as getting
/// access to the Administrator menu should only require you be in an open project (and
/// even that is maybe a bit too stringent). However our code won't support this currently
/// because the USFM and Filtering page does a lot of setup for USFM and filtering and for
/// that it looks into the doc- which therefore has to be open.
/// BEW modified 13Nov09: if the local user has read-only access (to a remote project
/// folder) it must not be possible to change the remote settings so as to initiate a
/// rebuild of the remote document while the remote user is working with it, therefore
/// disable the Preferences access in this circumstance
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditPreferences(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	// Allow Edit > Preferences only if a project is open (a doc need not be open)
	if ((!gbIsGlossing && pApp->m_bKBReady) || (gbIsGlossing && pApp->m_bGlossingKBReady))
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

// whm added 26Mar12. Disable mode bar control when in read-only mode
void CAdapt_ItView::OnUpdateCheckSingleStep(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

void CAdapt_ItView::OnCheckSingleStep(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// toggle the m_bSingleStep flag
	pApp->m_bSingleStep = pApp->m_bSingleStep == TRUE ? FALSE : TRUE;

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnCheckForceAsk(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// toggle the m_bForceAsk flag
	pApp->m_bForceAsk = pApp->m_bForceAsk == TRUE ? FALSE : TRUE;

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
void CAdapt_ItView::OnCopySource(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pViewCopySource = pMenuBar->FindItem(ID_COPY_SOURCE);

	// whm Note: Since OnMarkerWrapsStrip() is also called from the View's OnInitialUpdate()
	// we test here to make sure we're logging the actual menu item call and not the
	// OnInitialUpdate call.
	if (event.GetId() == ID_COPY_SOURCE)
	{
		if (pApp->m_bCopySource)
			pApp->LogUserAction(_T("Turned Copy Source OFF"));
		else
			pApp->LogUserAction(_T("Turned Copy Source ON"));
	}

	// toggle the setting
	if (pApp->m_bCopySource)
	{
		// toggle the checkmark to OFF
		if (pViewCopySource != NULL)
		{
			pViewCopySource->Check(FALSE);
		}
		pApp->m_bCopySource = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		if (pViewCopySource != NULL)
		{
			pViewCopySource->Check(TRUE);
		}
		pApp->m_bCopySource = TRUE;
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is in Free Translation Mode, this handler disables the "Use
/// Consistent Changes" item on the Tools menu and immediately returns.
/// If one or more cc tables are loaded (i.e., the App's m_bTablesLoaded flag is TRUE), it
/// enables the "Use Consistent Changes" item on the Tools menu, otherwise it disables the
/// menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateUseConsistentChanges(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// whm added 26Mar12.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}

	// the flags we want are on the view, so get the view
	if (pApp->m_bTablesLoaded)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is in Free Translation Mode, this handler disables the "Use SIL
/// Converter" item on the Tools menu and immediately returns.
/// If there is an SIL Converter table name configured (i.e., the App's
/// m_strSilEncConverterName string is not empty), it enables the "Use SIL Converter" item
/// on the Tools menu, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateUseSilConverter(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	
	// whm added 2i6Mar12.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (pApp->m_bFreeTranslationMode || !pApp->bECDriverDLLLoaded)
	{
		event.Enable(FALSE);
		return;
	}

#ifdef USE_SIL_CONVERTERS
	// whm added 12Jan09 for SIL Converters support
	typedef int (wxSTDCALL *wxECIsInstalledType)();
	wxECIsInstalledType pfnECisInstalled = (wxECIsInstalledType)NULL;
    // whm Note: The IsEcInstalled() function in ECDriver.dll does not have A and W forms
    // so we must call GetSymbol() instead of GetSymbolAorW() here.
	pfnECisInstalled =
		(wxECIsInstalledType)ecDriverDynamicLibrary.GetSymbol(FUNC_NAME_EC_IS_INSTALLED);
    // enable it if ECisInstalled and there's a configured table name
	event.Enable(pfnECisInstalled != NULL && pfnECisInstalled() == TRUE &&
					!pApp->m_strSilEncConverterName.IsEmpty());
#else
	event.Enable(FALSE); // don't enable the menu item if we're not using SIL Converters
#endif
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event (unused)
/// \remarks
/// Called from the Tools menu on selection of the "Use Consistent Changes" menu item. This
/// handler toggles the check on the menu item and the value of the m_bUseConsistentChanges
/// variable on the App. The "Use Consistent Changes" menu selection basically works as a
/// switch to turn on or off any change tables the were previously loaded using the "Load
/// Consistent Changes..." menu item.
/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUseConsistentChanges(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuUseCC = pMenuBar->FindItem(ID_USE_CC);
	//wxASSERT(pToolsMenuUseCC != NULL);
	wxMenuItem * pToolsMenuUseSilConverter = pMenuBar->FindItem(ID_USE_SILCONVERTER);
	//wxASSERT(pToolsMenuUseSilConverter != NULL);

	// toggle the setting
	if (pApp->m_bUseConsistentChanges)
	{
		// toggle the checkmark to OFF
		if (pToolsMenuUseCC != NULL)
		{
			pApp->LogUserAction(_T("Use Consistent Changes OFF"));
			pToolsMenuUseCC->Check(FALSE);
		}
		pApp->m_bUseConsistentChanges = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		if (pToolsMenuUseCC != NULL)
		{
			pApp->LogUserAction(_T("Use Consistent Changes ON"));
			pToolsMenuUseCC->Check(TRUE);
		}
		pApp->m_bUseConsistentChanges = TRUE;

        // reset the SILConverter 'use' menu in case it was set
        // (i.e. these two are mutually exclusive)
		if (pToolsMenuUseSilConverter != NULL)
		{
			pToolsMenuUseSilConverter->Check(FALSE);
		}
		pApp->m_bUseSilConverter = FALSE;
	}

    // if the checkbox was just turned on, then have the phrase box placed there again, so
    // as to give consistent changes a chance to work on the current source phrase
	if (pApp->m_bUseConsistentChanges)
	{
		// ensure we are not at eof with no phrase box currently in existence
		if (pApp->m_pActivePile != NULL)
		{
			CCell* pCell = pApp->m_pActivePile->GetCell(1);
			wxASSERT(pCell != NULL);
			int selector = 1; // this value suppresses both removal from the KB and storing
							  // prior adaptation
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			PlacePhraseBox(pCell,selector);
		}
	}
	else
	{
        // we have just turned off the use of consistent changes, so we must turn off
        // acceptance of defaults too
		pApp->m_bAcceptDefaults = FALSE;

		// and update the menu command to be unchecked
		if (pToolsMenuUseCC != NULL)
		{
			pToolsMenuUseCC->Check(FALSE);
		}
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
void CAdapt_ItView::OnUseSilConverter(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuUseSilConverter;
	pToolsMenuUseSilConverter = pMenuBar->FindItem(ID_USE_SILCONVERTER);
	//wxASSERT(pToolsMenuUseSilConverter != NULL);
	wxMenuItem * pToolsMenuUseCC;
	pToolsMenuUseCC = pMenuBar->FindItem(ID_USE_CC);
	//wxASSERT(pToolsMenuUseCC != NULL);
	wxMenuItem* pToolsMenuAcceptChanges;
	pToolsMenuAcceptChanges = pMenuBar->FindItem(ID_ACCEPT_CHANGES);
	//wxASSERT(pToolsMenuAcceptChanges != NULL);

	// toggle the setting
	if (pApp->m_bUseSilConverter)
	{
		// toggle the checkmark to OFF
		if (pToolsMenuUseSilConverter != NULL)
		{
			pApp->LogUserAction(_T("Use Sil Converters OFF"));
			pToolsMenuUseSilConverter->Check(FALSE);
		}
		pApp->m_bUseSilConverter = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		if (pToolsMenuUseSilConverter != NULL)
		{
			pApp->LogUserAction(_T("Use Sil Converters ON"));
			pToolsMenuUseSilConverter->Check(TRUE);
		}
		pApp->m_bUseSilConverter = TRUE;

        // reset the Consistent Changes 'use' menu in case it was set
        // (i.e. these two are mutually exclusive)
		if (pToolsMenuUseCC != NULL)
		{
			pToolsMenuUseCC->Check(FALSE);
		}
		pApp->m_bUseConsistentChanges = FALSE;
	}

    // if the checkbox was just turned on, then have the phrase box placed there again, so
    // as to give consistent changes a chance to work on the current source phrase
	if (pApp->m_bUseSilConverter)
	{
		// ensure we are not at eof with no phrase box currently in existence
		if (pApp->m_pActivePile != NULL)
		{
			CCell* pCell = pApp->m_pActivePile->GetCell(1);
			wxASSERT(pCell != NULL);
			int selector = 1; // this value suppresses both removal from the KB and storing
							  // prior adaptation
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			PlacePhraseBox(pCell,selector);
		}
	}
	else
	{
        // we have just turned off the use of the SILConverter, so we must turn off
        // acceptance of defaults too
		pApp->m_bAcceptDefaults = FALSE;

		// and update the menu command to be unchecked
		if (pToolsMenuAcceptChanges != NULL)
		{
			pToolsMenuAcceptChanges->Check(FALSE);
		}
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress, the "Accept Changes Without Stopping" item on the
/// Tools menu is disabled and this handler returns immediately.
/// If the application is not in Single Step Mode, but is set to Copy the Source text, and,
/// either m_bUseConsistentChanges is TRUE or m_bUseSilConverter is TRUE, then this handler
/// enables the "Accept Changes Without Stopping" item on the Tools menu, otherwise it
/// disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAcceptChanges(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	// whm added 26Mar12.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// disable if the 3 flags (single step, cc changes, copy source) are not
	// the right values, but if they are, allow value to be changed
	if (!pApp->m_bSingleStep && pApp->m_bCopySource &&
		(pApp->m_bUseConsistentChanges || pApp->m_bUseSilConverter) )
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
void CAdapt_ItView::OnAcceptChanges(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);

	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsAcceptChanges = pMenuBar->FindItem(ID_ACCEPT_CHANGES);
	//wxASSERT(pToolsAcceptChanges != NULL);

	// toggle the setting
	if (pApp->m_bAcceptDefaults)
	{
		// toggle the checkmark to OFF
		if (pToolsAcceptChanges != NULL)
		{
			pApp->LogUserAction(_T("Accept Changes OFF"));
			pToolsAcceptChanges->Check(FALSE);
		}
		pApp->m_bAcceptDefaults = FALSE;

		// restore the highlighting setting
		pApp->m_bSuppressTargetHighlighting = gbSaveHilightingSetting;
	}
	else
	{
		// toggle the checkmark to ON
		if (pToolsAcceptChanges != NULL)
		{
			pApp->LogUserAction(_T("Accept Changes ON"));
			pToolsAcceptChanges->Check(TRUE);
		}
		pApp->m_bAcceptDefaults = TRUE;

		// save the highlighting setting so it can be restored when the toggle
		// is later turned off, and then suppress highlighting till then
		gbSaveHilightingSetting = pApp->m_bSuppressTargetHighlighting;
		pApp->m_bSuppressTargetHighlighting = TRUE;
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

// whm added 26Mar12. Disable mode bar control when read-only mode is active
void CAdapt_ItView::OnUpdateRadioDrafting(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

void CAdapt_ItView::OnRadioDrafting(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar);
	wxRadioButton* pDraftingBtn =
		(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_DRAFTING);
	wxRadioButton* pReviewingBtn =
		(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_REVIEWING);

	// whm Note: Log the action only when OnRadioDrafting() is explicitly
	// called by user clicking on the Drafting radio button, not when
	// OnRadioDrafting() is called by another function.
	if (event.GetId() == IDC_RADIO_DRAFTING)
	{
		pApp->LogUserAction(_T("Drafting selected"));
	}

	// whm modified 12Oct10 for user profiles compatibility
	if (pDraftingBtn != NULL)
	{
		pDraftingBtn->SetValue(TRUE);
	}
	if (pReviewingBtn != NULL)
	{
		pReviewingBtn->SetValue(FALSE);
	}
	pApp->m_bDrafting = TRUE;

	// ensure the Automatic checkbox is enabled
	wxCheckBox* pAuto = (wxCheckBox*)
		pControlBar->FindWindowById(IDC_CHECK_SINGLE_STEP);
	// whm modified 12Oct10 for user profiles compatibility
	if (pAuto != NULL)
	{
		pAuto->Enable(TRUE);
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
	pApp->RefreshStatusBarInfo();
}

// whm added 26Mar12. Disable mode bar control when read-only mode is active
void CAdapt_ItView::OnUpdateRadioReviewing(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

void CAdapt_ItView::OnRadioReviewing(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame);
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxRadioButton* pDraftingBtn =
		(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_DRAFTING);
	wxRadioButton* pReviewingBtn =
		(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_REVIEWING);

	// whm Note: Log the action only when OnRadioReviewing() is explicitly
	// called by user clicking on the Reviewing radio button, not when
	// OnRadioReviewing() is called by another function.
	if (event.GetId() == IDC_RADIO_REVIEWING)
	{
		pApp->LogUserAction(_T("Reviewing selected"));
	}

	// whm 12Oct10 modified for user profiles compatibility
	if (pDraftingBtn != NULL)
	{
		pDraftingBtn->SetValue(FALSE);
	}
	if (pReviewingBtn)
	{
		pReviewingBtn->SetValue(TRUE);
	}
	pApp->m_bDrafting = FALSE;

	// ensure the Automatic checkbox is disabled
	wxCheckBox* pAuto = (wxCheckBox*)
		pControlBar->FindWindowById(IDC_CHECK_SINGLE_STEP);
	// whm 12Oct10 modified for user profiles compatibility
	if (pAuto != NULL)
	{
		pAuto->Enable(FALSE);
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if ((pApp->m_pTargetBox->IsShown()))
			pApp->m_pTargetBox->SetFocus();
	pApp->RefreshStatusBarInfo();
}

void CAdapt_ItView::OnClearContentsButton(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pComposeBar = pFrame->m_pComposeBar;
	if(pComposeBar != NULL && pComposeBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)
			pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			pEdit->ChangeValue(_T(""));
			pEdit->SetFocus();
		}
	}
}

void CAdapt_ItView::OnSelectAllButton(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pComposeBar = pFrame->m_pComposeBar;
	if(pComposeBar != NULL && pComposeBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)
			pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			pEdit->SetSelection(-1,-1);
			pApp->m_nStartChar = -1;
			pApp->m_nEndChar = -1;
			pEdit->SetFocus();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param  pDoc    ->  pointer to document class
/// \param  pStr    ->  pointer to the wxString which may have punctuation, and the
///                     punctuation is to be removed (this is done using ParseWord() so the
///                     method of stripping is consistent with how stripping is done during
///                     parsing of source text data
/// \param  nIndex  ->  selector for the punctuation string which is to be used - 0 for
///                     source, 1 for target
/// \remarks
/// Removes punctuation from the beginning and end of the passed in string, doing it in a
/// way consistent with the (U)SFM parser; does not try to store the stripped off
/// punctuation but just returns the punctuation-less string to the caller via the pointer
/// passed in
/// New version coded on 02April05 by BEW
/// BEW 12Apr10, no changes needed for support of doc version 5
/// BEW 11Oct10, changed to use the new version of ParseWord() and added support for
/// stripping from a conjoined pair using ~ fixedspace symbol
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RemovePunctuation(CAdapt_ItDoc* pDoc, wxString* pStr, int nIndex)
{
	bool bHasFixedSpaceSymbol = IsFixedSpaceSymbolWithin(*pStr);

	CAdapt_ItApp* pApp = &wxGetApp();
	if (pStr->IsEmpty())
		return;

	// get rid of spaces from a temp copy of the punctuation set which we want to use
	wxString spacelessPunctsStr = pApp->m_punctuation[nIndex];
	// remove all spaces, leaving only the list of punctation characters
	int countRemoved;
	countRemoved = spacelessPunctsStr.Replace(_T(" "),_T(""));
	countRemoved = countRemoved; // avoid warning
	// first handle test of no punctuation where we have conjoined words using ~ fixed
	// space
	wxString str = *pStr; // get a convenient local copy
	int offset = wxNOT_FOUND;
	wxString word1;
	wxString word2;
	offset = str.Find(_T('~'));
	if (bHasFixedSpaceSymbol)
	{
		// it's a conjoined word pair - so separate into two parts and test each
		// separately
		word1 = str.Left(offset);
		word2 = str.Mid(offset + 1); // exclude ~ from the tests below
		if ((FindOneOf(word1, spacelessPunctsStr) == wxNOT_FOUND) &&
			(FindOneOf(word2, spacelessPunctsStr) == wxNOT_FOUND))
		{
			// there are no punctuation chars in the substrings
			return;
		}
	}
	else
	{
		// not conjoined; test for no punctuation, if so, then we can return immediately
		word1 = *pStr;
		word2.Empty();
		if (FindOneOf(word1, spacelessPunctsStr) == wxNOT_FOUND)
		{
			// there are no punctuation chars in the string (but there may be spaces),
			// so the caller can use the string immediately
			return;
		}
	}

	wxString strFinal; // accumulate here for returning final result to the caller
	wxString strFinal2; // for use when ~ is in the passed in string, for stripping
						// from word2
	strFinal2.Empty();
	bool bIsInlineNonbindingMkr = FALSE;
	bool bIsInlineBindingMkr = FALSE;
	const wxChar* pBuffStart = word1.GetData();
	wxChar* ptr = (wxChar*)pBuffStart;
	wxChar* pEnd = ptr + word1.Len(); // points to null
	wxASSERT(*pEnd == _T('\0'));
	int itemLen = 0;
	CSourcePhrase* pSrcPhrase = NULL; // temporarily needed to store our data on
	wxString theWord;

	// the following are for word2 when bHasFixedSpaceSymbol is TRUE
	const wxChar* pBuffStart2 = word2.GetData();
	wxChar* ptr2 = (wxChar*)pBuffStart2;
	wxChar* pEnd2 = ptr2 + word2.Len(); // points to null
	wxASSERT(*pEnd2 == _T('\0'));
	CSourcePhrase* pSrcPhrase2 = NULL;
	wxString theWord2;
    // do word1 -- it could be a sequence of words with or without punctuation, or the
    // first word of a conjoined ~ word pair with or without punctuation, or just a single
    // word with or without some punctuation
	while (ptr < pEnd)
	{
        // we are dealing with target text, but ParseWord() will treat it as source
		// text; we just have to make the appropriate adjustments after the parse. We use
		// the appropriate punctuation string though.
		pSrcPhrase = new CSourcePhrase;

		// in the next call, because there are no inline markers to worry about,
		// m_follOuterPunct will always be empty, and any following puncts will only
		// be in m_follPunct
		itemLen = pDoc->ParseWord(ptr, pEnd, pSrcPhrase, spacelessPunctsStr,
					pApp->m_inlineNonbindingMarkers, pApp->m_inlineNonbindingEndMarkers,
					bIsInlineNonbindingMkr, bIsInlineBindingMkr);
		theWord = pSrcPhrase->m_key;

		// update ptr to point at next part of string to be parsed
		ptr += itemLen;

		while (*ptr == _T(' ')) { ptr++; } // skip initial whitespace

		if (strFinal.IsEmpty())
		{
			strFinal = theWord;
		}
		else
		{
			strFinal += _T(" ") + theWord;
		}
		pApp->GetDocument()->DeleteSingleSrcPhrase(pSrcPhrase);
	} // end of while loop: while (ptr < pEnd)

	*pStr = strFinal; // copy result to caller

	// if there is a conjoined pair, deal with word2 in the loop below and append to *pStr
	// before the latter is returned to the caller
	if (bHasFixedSpaceSymbol)
	{
		itemLen = 0;
		while (ptr2 < pEnd2)
		{
			// we are dealing with target text, but ParseWord() will treat it as source
			// text; we just have to make the appropriate adjustments after the parse
			pSrcPhrase2 = new CSourcePhrase;

			// in the next call, because there are no inline markers to worry about,
			// m_follOuterPunct will always be empty, and any following puncts will only
			// be in m_follPunct
			itemLen = pDoc->ParseWord(ptr2, pEnd2, pSrcPhrase2, spacelessPunctsStr,
						pApp->m_inlineNonbindingMarkers, pApp->m_inlineNonbindingEndMarkers,
						bIsInlineNonbindingMkr, bIsInlineBindingMkr);
			theWord2 = pSrcPhrase2->m_key;

			// update ptr to point at next part of string to be parsed
			ptr2 += itemLen;

			while (*ptr2 == _T(' ')) { ptr2++; } // skip initial whitespace

			if (strFinal2.IsEmpty())
			{
				strFinal2 = theWord2;
			}
			else
			{
				strFinal2 += _T(" ") + theWord2;
			}
			pApp->GetDocument()->DeleteSingleSrcPhrase(pSrcPhrase2);
		} // end of while loop: while (ptr2 < pEnd2)
		if (!strFinal2.IsEmpty())
		{
			*pStr += _T('~');
			*pStr += strFinal2;
		}
	}
}

// the copy could be from several places, so these are prioritized. First, if the compose
// box has a selection and has the focus, it is done from there; but if not, then next in
// priority is a selection of source phrases - if such a selection is current, then the
// m_targetStr fields are accumulated as a phrase & copied to the clipboard; if not, the
// phrase box contents is taken, provided it has the focus; if none of these, then nothing
// is copied.
void CAdapt_ItView::OnEditCopy(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// get the window which has the current focus
	wxWindow* pWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the frame window in OnEditCopy\n"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnEditCopy\n"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnEditCopy\n"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
	// In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle
	// from the view menu merely shows or hides the composeBar. In MFC version the
	// compose bar is recreated each time it becomes visible. Hence, I'll add the
	// condition check to ensure the text control in the composeBar IsShown()
	if (pWnd == pEdit && pEdit->IsShown())
	{
		pEdit->Copy(); // copy to the clipboard using wxTextCtrl's built in function
                       // (CF_TEXT format, or CF_UNICODETEXT for the Unicode version)
		return;
	}

	if (pApp->m_selectionLine == 0)
	{
		// this has priority, ie. if there is or are sourcePhrase(s) selected
		DoSrcPhraseSelCopy();
	}
	else
	{
	wxTextCtrl* pEdit2 = pApp->m_pTargetBox;
	if (pEdit2 == pWnd)
		pEdit2->Copy();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the App's m_pActivePile is NULL this handler disables the "Copy" item in the Edit
/// menu and immediately returns.
/// It enables the "Copy" item on the Edit menu if there is a valid selection in either the
/// composeBar's edit box, the targetBox, or a source phrase selection, otherwise it
/// disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditCopy(wxUpdateUIEvent& event)
{
    // whm: Removed the messages which would be issued endlessly if ever the errors
    // happened in the update idler handling.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	bool bComposeSel = FALSE;
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the frame window in OnUpdateEditCopy\n"),
		//	_T(""), wxICON_EXCLAMATION | wxOK);
		event.Enable(FALSE);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnUpdateEditCopy\n"),
		//	_T(""), wxICON_EXCLAMATION | wxOK);
		event.Enable(FALSE);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		//wxMessageBox(_T(
		//	"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnUpdateEditCopy\n"),
		//	_T(""), wxICON_EXCLAMATION | wxOK);
		event.Enable(FALSE);
		return;
	}
	long nStartChar1; long nEndChar1;
	pEdit->GetSelection(&nStartChar1,&nEndChar1);
	bComposeSel = nStartChar1 != nEndChar1;

	bool bTargetBoxSel = FALSE;
	long nStartChar; long nEndChar;
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->GetSelection(&nStartChar,&nEndChar);
			bTargetBoxSel = nStartChar != nEndChar;
		}

	bool bSrcPhraseSel = FALSE;
	if (pApp->m_selectionLine == 0)
		bSrcPhraseSel = TRUE;

	event.Enable(bComposeSel || bTargetBoxSel || bSrcPhraseSel);
}

void CAdapt_ItView::OnEditPaste(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxWindow* pWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the frame window in OnEditPaste\n"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar in OnEditPaste\n"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnEditPaste\n"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
    // In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle from
    // the view menu merely shows or hides the composeBar. In MFC version the compose bar
    // is recreated each time it becomes visible. Hence, I'll add the condition check to
    // ensure the text control in the composeBar IsShown()
	if (pWnd == pEdit && pEdit->IsShown())
	{
		// paste from the clipboard using wxTextCtrl's built in function (CF_TEXT format
		// or CF_UNICODETEXT for Unicode version)
		pEdit->Paste();
	}

	if (pApp->m_pTargetBox->GetHandle() != NULL)
		if (pApp->m_pTargetBox->IsShown() && (pApp->m_pTargetBox == pWnd))
		{
			DoTargetBoxPaste(pApp->m_pActivePile);
		}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the App's main frame pointer is NULL, or the composeBar is NULL, or the composeBar's
/// edit box is NULL, or both the composeBar and targetBox are not shown this handler
/// disables the "Paste" item in the Edit menu and immediately returns.
/// It enables the "Paste" item on the Edit menu if either the composeBar's edit box is
/// shown or the targetBox is shown, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditPaste(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	
	// whm added 26Mar12. Disable the tool bar button when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	bool bComposeWnd = FALSE;

	wxWindow* pFocusWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	// In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle
	// from the view menu merely shows or hides the composeBar. In MFC version the
	// compose bar is recreated each time it becomes visible. Hence, I'll add the
	// condition check to ensure the text control in the composeBar IsShown()
	if (pFocusWnd == pEdit && pEdit->IsShown())
		bComposeWnd = TRUE;

	bool bTargetBox = FALSE;
	if (pApp->m_pTargetBox != NULL)
		bTargetBox = (pApp->m_pTargetBox->IsShown()) &&
			(pApp->m_pTargetBox == pFocusWnd);

	event.Enable(bComposeWnd || bTargetBox);
}

void CAdapt_ItView::OnEditCut(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// get the window which has the current focus
	wxWindow* pWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the frame window in OnEditCut\n"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar in OnEditCut\n"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnEditCut\n"),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return;
	}
    // In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle from
    // the view menu merely shows or hides the composeBar. In MFC version the compose bar
    // is recreated each time it becomes visible. Hence, I'll add the condition check to
    // ensure the text control in the composeBar IsShown()
	if (pWnd == pEdit && pEdit->IsShown())
		pEdit->Cut(); // cut to the clipboard using wxTextCtrl's built in function
					  // (CF_TEXT format)

	wxTextCtrl* pEdit2 = pApp->m_pTargetBox;
	if (pEdit2 == pWnd)
	{
		pEdit2->Cut();

        // the phrase box now has different text, but pApp->m_targetPhrase still has the
        // uncut text, so to prevent the cut text from reappearing on the pile, we must put
        // the text remaining in the phrase box's "title" into pApp->m_targetPhrase;
		wxString text;
		text = pEdit2->GetValue();
		pApp->m_targetPhrase = text; // now it agree's with the window contents for the box
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the App's main frame is NULL, or the composeBar is NULL, or the composeBar's edit
/// box is NULL, or neither the composeBar nor targetBox have a selection, this handler
/// disables the "Cut" item in the Edit menu, otherwise it enables the "Cut" item on the
/// Edit menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditCut(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	
	// whm added 26Mar12 for read-only mode
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	bool bComposeSel = FALSE;
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the frame window in OnUpdateEditCut\n"),
		//	_T(""), wxICON_EXCLAMATION | wxOK);
		event.Enable(FALSE);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnUpdateEditCut\n"),
		//	_T(""), wxICON_EXCLAMATION | wxOK);
		event.Enable(FALSE);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		//wxMessageBox(_T(
		//	"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnUpdateEditCut\n"),
		//	_T(""), wxICON_EXCLAMATION | wxOK);
		event.Enable(FALSE);
		return;
	}
	long nStartChar; long nEndChar;
	pEdit->GetSelection(&nStartChar,&nEndChar);
	bComposeSel = nStartChar != nEndChar;

	bool bTargetBoxSel = FALSE;
	long nStartChar1; long nEndChar1;
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->GetSelection(&nStartChar1,&nEndChar1);
			bTargetBoxSel = nStartChar1 != nEndChar1;
		}


	event.Enable(bComposeSel || bTargetBoxSel);
}

// returns previous source phrase's pointer, or null if there is no previous one
CSourcePhrase* CAdapt_ItView::GetPrevSrcPhrase(SPList::Node*& curPos,SPList::Node*& posPrev)
{
	wxASSERT(curPos != NULL);
	SPList::Node* pos = curPos;
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetPrevious();
	if (pos != NULL)
	{
		posPrev = pos; // this is the previous position
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetPrevious();
		wxASSERT(pSrcPhrase);
		return pSrcPhrase;
	}
	else
	{
		posPrev = (SPList::Node*)NULL;
		return (CSourcePhrase*)0;
	}
}


// gets the preceding & following contexts for a 'retranslation' section of source text.
// We cannot rely on the layout pointers being valid, because if there was an unmerge done,
// they will have been clobbered prior to GetContext being called rather than use GetPile().
// We accumulate 40 words of preceding context and 30 words of following context, and we
// omit any m_markers content from the accumulations - we are just interested in the text.
// BEW 23Mar10, updated for support of doc version 5 (no changes needed)
// BEW 9July10, no changes needed for support of kbVersion 2
void CAdapt_ItView::GetContext(const int nStartSequNum,const int nEndSequNum,wxString& strPre,
							   wxString& strFoll,wxString& strPreTgt, wxString& strFollTgt)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// get the preceding context first
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	SPList::Node* pos = pSrcPhrases->Item(nStartSequNum);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetPrevious();
	TextType textType = pSrcPhrase->m_curTextType;
	wxString str; // temporary buffers
	str.Empty();
	wxString strTgt;
	strTgt.Empty();

	int count = 0;
	while (count < NUM_PREWORDS && pos != NULL)
	{
		TextType type;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetPrevious();
		count++;
		type = pSrcPhrase->m_curTextType;
		if (type != textType)
			break;
		str = pSrcPhrase->m_srcPhrase;
		strTgt = pSrcPhrase->m_targetStr;
		strPre = str + _T(" ") + strPre;
		strPreTgt = strTgt + _T(" ") + strPreTgt;
	}

	// now get the following context
	pos = pSrcPhrases->Item(nEndSequNum);
	pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext();
	count = 0;
	str.Empty();
	strTgt.Empty();

	while (count < NUM_FOLLWORDS && pos != NULL)
	{
		TextType type;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		count++;
		type = pSrcPhrase->m_curTextType;
		if (type != textType)
			break;
		str = pSrcPhrase->m_srcPhrase;
		strTgt = pSrcPhrase->m_targetStr;
		if (strFoll.IsEmpty())
		{
			strFoll = str;
			strFollTgt = strTgt;
		}
		else
		{
			strFoll += _T(" ") + str;
			strFollTgt += _T(" ") + strTgt;
		}
	}
}


int CAdapt_ItView::GetSelectionWordCount()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_selectionLine == -1)
		return 0; // no selection
	int nCount = 0;
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		CCell* pCell = (CCell*)pos->GetData();
		nCount += pCell->GetPile()->GetSrcPhrase()->m_nSrcWords;
		pos = pos->GetNext();
	}
	return nCount;
}

CKB* CAdapt_ItView::GetKB()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	if (gbIsGlossing)
		return pApp->m_pGlossingKB;
	else
		return pApp->m_pKB;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing a copy of the m_key member (which has punctuation
///             stripped off) of pSrcPhrase after m_key has been modified by Consistent Changes
///             (if m_bUseConsistentChanges is TRUE) or by SIL Converters (if m_bUseSilConverter
///             if TRUE) or by the Guesser (if m_bUseAdaptationsGuesser is TRUE)
/// \param      pSrcPhrase              -> the source phrase from which the m_key is copied
/// \param      bUseConsistentChanges   -> flag indicating if Consistent Changes is required
/// \remarks
/// Called from: The CopySourceKey() function is called from the View's PlacePhraseBox(),
/// OnButtonToEnd(), OnButtonToStart(), OnButtonStepDown(), OnButtonStepUp(),
/// OnButtonMerge(), OnButtonRestore(), RestoreTargetBoxText(),
/// JumpForwardToNote_CoreCode(), and JumpBackwardToNote_CoreCode(); and CSourcePhrase's
/// MoveToNextPile(), MoveToPrevPile() and MoveToImmedNextPile().
/// CopySourceKey() is generally only called when the m_bCopySource flag is TRUE and when
/// the m_targetPhrase is empty, because there is no matching translation available from
/// the KB or no previous target phrase has been entered. CopySourceKey() returns the
/// source word or phrase (possibly merged) in a pre-processed form which constitutes a
/// first guess for what might be wanted as a target text in the phrase box. This guess
/// starts as the m_key member of the CSourcePhrase object (which is the form without any
/// punctuation). CopySourceKey() applies any necessary modifications as the result of
/// Consistent Changes (if m_bUseConsistentChanges is TRUE) or any modifications made by
/// SIL Converters (if m_bUseSilConverter if TRUE) before returning the final string to the
/// caller. The Guesser cannot be used if the SIL Converters is being used.
/// Also, the Guesser can be used only if Consistent Changes is not being used
/// OR if it is being used AND m_bAllowGuesseronUnchangedCCOutput was set to true by the
/// administrator checking the appropriate checkbox in the GuesserSettingsDlg.
/// CopySourceKey() is the primary place where Consistent Changes are done, where the SIL
/// Converter changes are done and where Guesser changes are done within the Adapt It
/// application. See also DoTargetBoxPaste() for where these operations can also take
/// place.
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::CopySourceKey(CSourcePhrase *pSrcPhrase, bool bUseConsistentChanges)
{
	// whm modified 29Oct10 to handle Guessing
	CAdapt_ItApp* pApp = &wxGetApp();
	wxString str = pSrcPhrase->m_key;
	if (str.IsEmpty())
		return _T("");

	if (!gbLegacySourceTextCopy)
	{
		// the user wants smart copying done to the phrase box when the active location
		// landed on does not have any existing adaptation (in adapting mode), or, gloss
		// (in glossing mode). In the former case, it tries to copy a gloss to the box
		// if a gloss is available, otherwise source text used instead; in the latter case
		// it tries to copy an adaptation as the default gloss, if an adaptation is
		// available, otherwise source text is used instead
		if (gbIsGlossing)
		{
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				str = pSrcPhrase->m_adaption;
			}
		}
		else
		{
			if (!pSrcPhrase->m_gloss.IsEmpty())
			{
				str = pSrcPhrase->m_gloss;
			}
		}
	}

	gbByCopyOnly = TRUE;

	wxString str2 = _T("");
	if (bUseConsistentChanges)
	{
		// these added spaces are automatically stripped before storage takes place, after cc
		// has had its chance to apply, so no harm is done by these additions
		str = _T(" ") + str;
		str += _T(" ");

		// apply to the merged string (ie. merged with whatever is returned here)
		str2 = DoConsistentChanges(str);

		if (str2 != str)
		{
			str.Trim(FALSE); // in case DoGuess is called below
			str.Trim(TRUE); // in case DoGuess is called below
		}

		// strip the added spaces back off
		// whm comment: the following GetChar() operations assume that str2 can never be an
		// empty string when it returns from DoConsistentChanges; for safety sake, I'm just
		// going to use the Trim() function instead.
		//if (str2.GetChar(0) == _T(' '))
		//	str2 = str2.Mid(1); // remove initial space
		//int len = str2.Length();
		//if (str2.GetChar(len-1) == _T(' '))
		//	str2 = str2.Left(len-1); // remove final space
		str2.Trim(FALSE); // trim the left end
		str2.Trim(TRUE); // trim the right end
	}
	else if( pApp->m_bUseSilConverter )
	{
		return DoSilConvert(str);
	}
	else
	{
		str2 = str;
	}

	bool bIsGuess = FALSE;
	if (pApp->m_bUseAdaptationsGuesser && !pApp->m_bUseSilConverter)
	{
		// The Guesser cannot be used if the SIL Converters is being used.
		// Also, the Guesser can be used only if Consistent Changes is not being used
		// OR if it is being used AND m_bAllowGuesseronUnchangedCCOutput
		// was set to true by the administrator checking the appropriate checkbox
		// in the GuesserSettingsDlg.
		if (!pApp->m_bUseConsistentChanges || (pApp->m_bUseConsistentChanges && pApp->m_bAllowGuesseronUnchangedCCOutput))
		{
			str2 = DoGuess(str,bIsGuess);
			pApp->m_bIsGuess = bIsGuess;
		}
	}
	return str2;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing text after any Consistent Changes have been performed
///             on the text
/// \param      str    -> the incoming string on which Consistent Changes is to be performed
/// \remarks
/// Called from: the View's CopySourceKey() and DoTargetBoxPaste().
/// If str is not empty, DoConsistentChanges passes str through up to four successive Consistent
/// Changes processes, once for each of up to four loaded changes tables. DoConsistentChanges()
/// handles the initialization of an input and an output buffer for processing of changes by
/// calling of up to four m_consistentChager instances on the buffers, employing the
/// utf8ProcessBuffer() method of CConsistentChanger. See the CConsistentChanger and CCModule
/// classes.
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::DoConsistentChanges(wxString& str)
{
	if (str.IsEmpty())
		return _T("");

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

#ifndef _UNICODE
	// new ANSI version, uses buffers, and based on the _UNICODE code...
	// for the ANSI version, str will be a byte-oriented wxString. No conversions needed.
	// the strings stored in the buffers will be null delimited
	int nIn = 0;  // index for current input buffer
	int nOut = 1; // index for current output buffer
	char byteBuff[2][1024]; // two 1k byte buffers which will alternate as input and output iteratively
	int nInLength = 0;
	int nOutLength = 1024;
	int nTableIndex = -1;

	nInLength = str.Length(); // in bytes
	nInLength += 1; // allow for the null byte at the end (note: for 2.2.1 and previous
					// I did not realize that CC will strip off this final null byte
					// reducing the length by one, so I got final character chopped off
					// the changed string - I fixed this for 2.3.0 (the next after 2.2.1)
	const wxChar* pbuffer = str.GetData();

	// whm added pEnd and null char below
	wxChar* pEnd;
	pEnd = (wxChar*)pbuffer + nInLength -1; // -1 to compensate for += 1 increment on nInLength above
	wxASSERT(*pEnd == _T('\0')); // ensure there's a null at end of buffer

	// populate the first of the buffers
	wxStrcpy(byteBuff[nIn],pbuffer);

	// apply the tables
	int iResult = 0;
	bool bPreviouslyUsedTable = FALSE; // TRUE after a table has been used
	for (int i = 0; i < 4; i++)
	{
		nTableIndex++; // keep track of which table, in case we get an error

		// do the next table, if present
		if (pApp->m_bCCTableLoaded[i])
		{
			if (bPreviouslyUsedTable)
			{
				// prepare for this next table
				nIn = nIn == 0 ? 1 : 0;
				nOut = nOut == 0 ? 1 : 0;
				nInLength = nOutLength;
				nOutLength = 1024;
				memset(byteBuff[nOut],0,1024); // clear the string in the new output buffer
											   // (CC does not retain the null bytes, but
											   // fills the unused part with -52 bytes,
											   // and input '\0' is lost)
			}
			bPreviouslyUsedTable = TRUE;

			iResult = pApp->m_pConsistentChanger[i]->utf8ProcessBuffer(byteBuff[nIn],nInLength,
																byteBuff[nOut],&nOutLength);

			// if there was an error, just return the unaltered original string & warn user
			if (iResult)
			{
				ccErrorStr = ccErrorStr.Format(
				_(" Processing a CC table failed. Got error code %d with table having index %d."),
									iResult,nTableIndex);
				wxMessageBox(ccErrorStr, _T(""), wxICON_EXCLAMATION | wxOK);
				return str; // if there was a table procesing error then return the
							// original string, ie. no tables used
			}
			else
			{
				// no errors
				if (i == 3)
					break; // at the end, so go convert the output string back to UTF-16
			}
		}
		else
		{
			// that table was not loaded, so try the next one
			continue;
		}
	}

	byteBuff[nOut][nOutLength] = '\0';    // ensure it is null terminated at the correct
										  // location (it will overwrite the first (byte)-52)
	// wx version note: here we need a writable buffer
	wxChar* pStr = str.GetWriteBuf(nOutLength + 1);  // nOutLength is 1024
	wxStrcpy(pStr,byteBuff[nOut]);            // but I ran into some problems, so I've done it the safety first way
	//wxChar* pEnd;
	pEnd = pStr + nOutLength; // whm added 18Jun06
	wxASSERT(*pEnd == _T('\0')); // whm added 18Jun06
	str.UngetWriteBuf();
	return str;

#else // Unicode version

	// for the unicode version, str will be a UTF-16 wxString. We have to convert to UTF8, run the
	// resulting string through the CCProcessBuffer() function with a minimum of string copying
	// to maximize speed, and then convert back to UTF-16 and return it to the caller as an LPTSTR;
	// the strings stored in the buffers will be null delimited

	// BEW changed 8Apr06 to accomodate the buffer-safe new conversion macros in VS 2003, which
	// use malloc for buffer allocation of long string to be converted, etc.

	int nIn = 0;  // index for current input buffer
	int nOut = 1; // index for current output buffer
	char byteBuff[2][1024]; // two 1k byte buffers which will alternate as input and output iteratively
	int nInLength = 0;
	int nOutLength = 1024;
	int nTableIndex = -1;

	// wx version note:
	// The wxString::mb_str() method returns a wxCharBuffer. The wxConvUTF8 is a predefined
	// instance of the wxMBConvUTF8 class which converts between Unicode (UTF-16) and UTF-8.
	wxCharBuffer tempBuf = str.mb_str(wxConvUTF8);
	CBString psz(tempBuf);

	nInLength = strlen(psz) + 1; // + 1 for the null byte at the end
	strcpy(byteBuff[nIn],psz);

	// apply the tables
	int iResult = 0;
	bool bPreviouslyUsedTable = FALSE; // TRUE after a table has been used
	for (int i = 0; i < 4; i++)
	{
		nTableIndex++; // keep track of which table, in case we get an error

		// do the next table, if present
		if (pApp->m_bCCTableLoaded[i])
		{
			if (bPreviouslyUsedTable)
			{
				// prepare for this next table
				nIn = nIn == 0 ? 1 : 0;
				nOut = nOut == 0 ? 1 : 0;
				nInLength = nOutLength;
				nOutLength = 1024;
				memset(byteBuff[nOut],0,1024); // clear the string in the new output buffer

			}
			bPreviouslyUsedTable = TRUE;

			// whm note: the following line is where consistent changes does its work
			iResult = pApp->m_pConsistentChanger[i]->utf8ProcessBuffer(byteBuff[nIn],nInLength,
															byteBuff[nOut],&nOutLength);

			// if there was an error, just return the unaltered original string & warn user
			if (iResult)
			{
				ccErrorStr.Format(
				_(" Processing a CC table failed. Got error code %d with table having index %d."),
				iResult,nTableIndex);
				wxMessageBox(ccErrorStr, _T(""), wxICON_EXCLAMATION | wxOK);
				return str; // if there was a table procesing error then return the original
							// string, ie. no tables used
			}
			else
			{
				// no errors
				if (i == 3)
					break; // at the end, so go convert the output string back to UTF-16
			}
		}
		else
		{
			// that table was not loaded, so try the next one
			continue;
		}
	}

	// convert back to UTF-16 and return the converted string
	byteBuff[nOut][nOutLength] = '\0';	// ensure it is null terminated at the correct
										// location
	CBString tempBuff(byteBuff[nOut]);
	return pApp->Convert8to16(tempBuff);

#endif // for _UNICODE
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing text after any Guess has been performed
///             on the text
/// \param      str    -> the incoming string on which a Guess of corresponding target text
///                         is to be performe
/// \param      bIsGuess <- set to TRUE if a guess was returned, FALSE otherwise
/// \remarks
/// Called from: the View's CopySourceKey() and DoTargetBoxPaste().
/// If str is not empty, DoGuess passes str through the Guesser processes. DoGuess()
/// takes care of the selection of the appropriate Guesser object, either the
/// m_pAdaptationsGuesser or the m_pGlossesGuesser. If a target guess is not found for
/// the incoming str, str is not changed and is returned just as it was input.
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::DoGuess(const wxString& str, bool& bIsGuess)
{
	wxString tempStr = str;
	if (tempStr.IsEmpty())
		return _T("");

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	wxChar* pszGuess = (wxChar*)malloc( MAX_GUESS_LENGTH ); // Alloc space to pass as pointer, 100 is enough

	bool bGuessReturned = FALSE;
	if (gbIsGlossing)
	{
		bGuessReturned = pApp->m_pGlossesGuesser->bTargetGuess(tempStr,&pszGuess); // Return target guess
	}
	else
	{
		bGuessReturned = pApp->m_pAdaptationsGuesser->bTargetGuess(tempStr,&pszGuess); // Return target guess
	}
	if (bGuessReturned)
	{
		// set the bIsGuess reference parameter for return to the caller
		bIsGuess = bGuessReturned;
		tempStr = pszGuess;
	}
	free (pszGuess);
	return tempStr;
}

void CAdapt_ItView::ChooseTranslation()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	if (pApp->m_pTargetBox == NULL || !pApp->m_pTargetBox->IsShown())
	{
		// whm Note: the m_pTargetBox is never NULL in the wx version, but
		// sometimes it is not shown, so if we are getting a bell sound at
		// wrong times, this may be the cause.
		// TODO: check the logic during Find operations and any other cases
		// where the MFC version assumes that the target box might be NULL
		::wxBell();
	}
	else
	{
		if (pApp->m_pActivePile != NULL && !pApp->m_pActivePile->GetSrcPhrase()->m_bNotInKB)
			OnButtonChooseTranslation(dummyevent);
		else
			::wxBell();
	}
}

// Modified for support of glossing.
// BEW 2July10, updated for support of kbVersion 2
void CAdapt_ItView::OnButtonChooseTranslation(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// ensure blank variables
	translation.Empty();
	curKey.Empty();
	nWordsInPhrase = 0;
	pCurTargetUnit = NULL;

	CKB* pKB;
	int nCurLongest;
	if (gbIsGlossing)
	{
		pKB = pApp->m_pGlossingKB;
		nCurLongest = 1; // only one map in the glossing KB, so treat as
						 // "one word" case whether or not src words or
						 // phrases are put into this one map
	}
	else
	{
		pKB = pApp->m_pKB;
		nCurLongest = pKB->m_nMaxWords; // no matches are possible for phrases
										// longer than nCurLongest
	}

    // BEW added 2July10 if a selection is current, tell the user that the phrase box must
    // first be placed there in order to make the Choose Translation dialog accessible from
    // that location (but say nothing if the box is already at the start of the selection)
	if (!pApp->m_selection.IsEmpty())
	{
		// we don't support opening the dialog on a selection disconnected from the active
		// location because the Choose Translation dialog for an OK click will deposit the
		// selected list item at the active location - which would put a wrong adaptation
		// or gloss at a location for which the source text is not an appropriate
		// translation equivalent
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = cpos->GetData();
		CPile* pPile = pCell->GetPile(); // parent pile for this cell
		if (pApp->m_pActivePile != pPile)
		{
			// we have an illegal situation for opening the dialog, so tell the user and
			// exit when he dismisses the message box
			wxString msg = _(
"The dialog can be opened at a selection only if the phrase box is located at the first word of the selection.");
			wxString title = _("Illegal attempt to open ChooseTranslation dialog");
			wxMessageBox(msg, title, wxICON_EXCLAMATION | wxOK);
			return;
		}
	}

	// check we are within bounds
	CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
	if (gbIsGlossing)
		nWordsInPhrase = 1;
	else
		nWordsInPhrase = pSrcPhrase->m_nSrcWords;

	if (nWordsInPhrase > nCurLongest)
	{
		// something is really wrong, this should not be possible
		wxString str =
		_T(
"Error: longest phrase in KB is shorter than current source phrase's number of words!\n");
		str += _T("So this command will be ignored.\n");
		wxMessageBox(str, _T(""), wxICON_EXCLAMATION | wxOK);
		nWordsInPhrase = 0;
		pApp->m_pTargetBox->SetFocus();
		return;
	}

    // restore the current phrase box's text in the KB, so that potential singly referenced
    // adaptations not yet in the KB will still show in the dialog; but don't do so if the
    // phrasebox is empty (since we want <no adaptation> to show only when the button of
    // that name has been pressed)
	wxString temp;
	bool bOK = TRUE;
	bool bEmptyBox = FALSE;
	if (pApp->m_targetPhrase.IsEmpty())
	{
		bEmptyBox = TRUE;
	}
	else
	{
		temp = pApp->m_targetPhrase;
		// BEW 13Nov10, the flag below is never set TRUE so remove the code which uses it
		if (!gbIsGlossing) // || gbRemovePunctuationFromGlosses)
		{
			RemovePunctuation(GetDocument(),&temp,from_target_text);
		}
		// TRUE in the next call means we can store an empty adaptation or gloss
		bOK = pKB->StoreText(pSrcPhrase, temp, TRUE);
		wxASSERT(bOK);
		bOK = bOK; // avoid warning
	}
	// get a pointer to the target unit for the current key
	pCurTargetUnit = pKB->GetTargetUnit(nWordsInPhrase, pSrcPhrase->m_key);
	if (pCurTargetUnit == NULL)
	{
		// IDS_NO_KB_ENTRY
		wxMessageBox(_(
"Sorry, the knowledge base does not yet have an entry matching this source text, so the Choose Translation dialog cannot be shown."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		nWordsInPhrase = 0;
		pApp->m_pTargetBox->SetFocus();
		return;
	}
	else
	{
		curKey = pSrcPhrase->m_key;
		CChooseTranslation dlg(pApp->GetMainFrame());
		dlg.Centre();
		// initialize m_chosenTranslation, other initialization is in OnInitDialog()
		dlg.m_chosenTranslation.Empty();

		// put up the dialog
		bool bCancelled = FALSE;
		gbInspectTranslations = TRUE; // use TRUE value to hide the "Cancel and Select" button
		if(dlg.ShowModal() == wxID_OK)
		{
			// set the translation static var from the member m_chosenText
			translation = dlg.m_chosenTranslation;
			if (dlg.m_bEmptyAdaptationChosen)
				gbEmptyAdaptationChosen = TRUE; // enable PlacePhraseBox to use the
												// null string chosen
		}
		else
		{
			// must have hit Cancel button
			bCancelled = TRUE;
			gbEmptyAdaptationChosen = FALSE;
		}
		gbInspectTranslations = FALSE;

        // remove the refString again, to restore the phrase box and KB to the proper state
        // for having landed there - if the user removed the refString in the dialog,
        // pRefString will be NULL and no damage will be done as RemoveRefString checks for
        // this condition <<-- BEW 2Jul10, as of kbVersion 2 the user can't physically
        // remove it, but only cause it to be hidden while its m_bDeleted flag is TRUE
		wxString emptyStr = _T("");
		if (!bEmptyBox)
		{
			// "remove" the CRefString instance, or decrement is m_refCount if the latter
			// is > 1
			if (gbIsGlossing)
			{
				pApp->m_pGlossingKB->GetAndRemoveRefString(pSrcPhrase,
										emptyStr, useGlossOrAdaptationForLookup);
			}
			else
			{
				pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase,
										emptyStr, useGlossOrAdaptationForLookup);
			}
		}
		// if user hit the cancell button, we can return immediately
		if (bCancelled)
		{
			nWordsInPhrase = 0;
			pCurTargetUnit = NULL;
			curKey.Empty();
			pApp->m_pTargetBox->SetFocus();
			return;
		}

		// use the translation global variable to set the phrase box to the
		// chosen adaptation
		pApp->m_targetPhrase = translation;
		pApp->m_pTargetBox->ChangeValue(translation);
		PlacePhraseBox(pApp->m_pActivePile->GetCell(1), 1); // selector = 1 inhibits the
							// saving to KB since there was no click to a new location
		gbEmptyAdaptationChosen = FALSE; // ensure its safely defused!

		// get a new (valid) active pile pointer, now that the layout is recalculated (again!)
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pApp->m_pActivePile);
		int len = pApp->m_pTargetBox->GetLineLength(0);
		pApp->m_nStartChar = len;
		pApp->m_nEndChar = len; // cursor at end of text in the box
		pApp->m_pTargetBox->SetModify(TRUE);

		// scroll into view, just in case a lot were inserted
		pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

		pApp->m_pTargetBox->SetFocus();
		translation.Empty(); // clear the globals
		curKey.Empty();
		Invalidate();
		GetLayout()->PlaceBox();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Show the Choose
/// Translation Dialog" toolbar item and returns immediately: The application is in Free
/// Translation mode, the targetBox is NULL or is not shown, or the application is in
/// glossing mode. Otherwise, it enables the toolbar button if the active pile is valid and
/// the source phrase at that point does not have the m_bNotInKB flag set.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonChooseTranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pTargetBox == NULL || !pApp->m_pTargetBox->IsShown())
	{
		// whm 12Aug08 Note: the m_pTargetBox is never NULL in the wx version, but
		// sometimes it is not shown, so if the ChooseTranslation button is
		// not enabled when it should be, this may be the cause.
		// TODO: check the logic during Find operations and any other cases
		// where the MFC version assumes that the target box might be NULL
		event.Enable(FALSE);
		return;
	}
	else
	{
		if (!gbIsGlossing && pApp->m_pActivePile != NULL &&
			!pApp->m_pActivePile->GetSrcPhrase()->m_bNotInKB)
		{
			event.Enable(TRUE);
		}
		else
		{
			if (gbIsGlossing)
				event.Enable(TRUE);
			else
				event.Enable(FALSE);
		}
	}
}

void CAdapt_ItView::StatusBarMessage(wxString &message)
{
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
 	wxStatusBar* pStatusBar = pFrame->GetStatusBar();
	if (pStatusBar != NULL)
	{
		pStatusBar->SetStatusText(message,0); // use first field 0
	}
}

// whm 28Feb12 modified. This OnFileStartupWizard() handler is now called only
// by the File > Start Working... menu item. It is no longer called by
// DoStartupWizardOnLaunch(). The original code in this handler that called
// DoStartWorkingWizard() was moved to DoStartupWizardOnLaunch().
void CAdapt_ItView::OnFileStartupWizard(wxCommandEvent& WXUNUSED(event))
{
	// whm Note 28Feb12
	// when the user explicitly clicks on the File > Start Working... item we
	// the App's behavior to be the following:
	// 1. If collaboration is ON at the time File > Start Working... is selected,
	// we want the GetSourceTextFromEditor dialog to appear so the user can select
	// a different book and/or chapter in collaboration mode.
	// 2. If collaboration is OFF at the time File > Start Working... is selected,
	// we want the normal wizard to appear, not the GetSourceTextFromEditor dialog.

	// whm 28Feb12 moved the original code to DoStartupWizardOnLaunch() and
	// this handler now calls DoStartupWizardOnLaunch().
	DoStartupWizardOnLaunch();
}

void CAdapt_ItView::DoStartupWizardOnLaunch()
{
	// whm modified 28Feb12. Moved the code from OnFileStartupWizard() to this
	// function. The OnFileStartupWizard() handler now calls this function instead
	// of this function calling OnFileStartupWizard().

    // Since the Startup Wizard menu item has an accelerator table hot key (CTRL-W see
    // CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even when
    // they are disabled, we must check for a disabled button and return if disabled.
    // On Windows, the accelerator key doesn't appear to call the handler for a disabled
    // menu item, but I'll leave the following code here in case it works differently on
    // other platforms.
    // whm 20Aug11 note: only log errors in OnFileStartupWizard()

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// for debugging
	//{
	//	bool bExpectsFreeTrans;
	//	bExpectsFreeTrans = pApp->m_bCollaborationExpectsFreeTrans;
	//}
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_FILE_STARTUP_WIZARD))
	{
		::wxBell();
		pApp->LogUserAction(_T("Start working wizard called but disabled"));
		return;
	}

	pApp->m_bStartViaWizard = TRUE; // allows the OnIdle handler to force
									// phrase box text to be selected
	bool bSuppress = pApp->m_bSuppressWelcome;

	if (pApp->m_pSourcePhrases->GetCount() > 0)
		goto a;
	if (pApp->m_pKB != NULL)
		goto a;
	if (gbJustClosedProject)
		goto a;

	if (!bSuppress)
	{
		CWelcome wdlg(pApp->GetMainFrame()); // make the view the parent
		wdlg.Centre();
		wdlg.ShowModal();
		pApp->m_bSuppressWelcome = wdlg.m_bSuppressWelcome; // update flag
	}

a:	if (pApp->m_bJustLaunched && !pApp->m_bUseStartupWizardOnLaunch)
		return; // suppress its use if user wants, but only for the program launch
	else
	{
		wxCommandEvent evt;
		bool bSuccess = pApp->DoStartWorkingWizard(evt);
		if (!bSuccess)
		{
			wxMessageBox(_T(
"The Startup Wizard failed. Try using either the New...\nor Open... items on the File... menu instead."),
			_T(""), wxICON_EXCLAMATION | wxOK);
			pApp->LogUserAction(_T("The Startup Wizard failed. Try using either the New...\nor Open... items on the File... menu instead."));
		}
	}
}

void CAdapt_ItView::OnCheckKBSave(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing)
	{
		// if glossing is ON, keep the box checked at all times since
		// we won't allow <Not In KB> option when gbIsGlossing is TRUE
		pApp->m_bSaveToKB = TRUE;
		return;
	}
	// glossing is OFF, so box can be toggled on or off
	if (pApp->m_pActivePile == NULL)
		return;
	CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
	if (pSrcPhrase == NULL)
		return;

	// call DoNotInKB & then toggle the m_bSaveToKB flag
	if (pApp->m_bSaveToKB)
	{
		// user does not want it to be in the KB
		// we must do the call with m_bSaveToKB TRUE, otherwise the store
		// of "<Not In KB>" will not happen
		pApp->m_pKB->DoNotInKB(pSrcPhrase,TRUE);
		pApp->m_bSaveToKB = FALSE;
	}
	else
	{
		// user wants it in the KB
		pApp->m_bSaveToKB = TRUE;
		pApp->m_pKB->DoNotInKB(pSrcPhrase,FALSE);
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();

	// BEW added 20May09, next line required in order to get * shown
	GetLayout()->Redraw();
	GetLayout()->PlaceBox(); // this call probably unneeded but no harm done
}

// BEW changed 25Aug11, removed the code for unloading the KBs, it is bad design to have
// it in here
void CAdapt_ItView::ClobberDocument()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = (CAdapt_ItDoc*)GetDocument();
	wxASSERT(pDoc != NULL);
	CLayout* pLayout = GetLayout();

	// when collaborating on a doc is finished, restore the Copy Source flag value to what
	// it was before it was automatically turned off
	if (pApp->m_bSaveCopySourceFlag_For_Collaboration)
	{
		pApp->m_bCopySource = FALSE;
		pApp->GetView()->ToggleCopySource(); // toggles m_bCopySource's value & resets menu item
		pApp->m_bSaveCopySourceFlag_For_Collaboration = FALSE; // when closing doc, always clear
	}

    // BEW added 21Apr08; clean out the global struct gEditRecord & clear its deletion
    // lists, because each document, on opening it, it must start with a truly empty
    // EditRecord; and on doc closure and app closure, it likewise must be cleaned out
    // entirely (the deletion lists in it have content which persists only for the life of
    // the document currently open)
	InitializeEditRecord(gEditRecord); // clears all except the deletion list
	gEditRecord.deletedAdaptationsList.Clear(); // remove any stored deleted adaptations
	gEditRecord.deletedGlossesList.Clear(); // remove any stored deleted gloss strings
	gEditRecord.deletedFreeTranslationsList.Clear(); // remove stored deleted free translns

	// save settings for restoration from config file
	if (pApp->m_nActiveSequNum == -1)
		pApp->m_nActiveSequNum = 0;
	pApp->m_lastDocPath = pApp->m_curOutputPath;
	pApp->nLastActiveSequNum = pApp->m_nActiveSequNum;

    // now clobber it all the view stuff associated with the document, leaving an empty
    // document object
	pDoc->Modify(FALSE); // MFC has SetModifiedFlag(FALSE)
	pDoc->DeleteSourcePhrases();
	pLayout->GetInvalidStripArray()->Clear();
	pLayout->DestroyStrips();
	pLayout->DestroyPiles(); // restored, DestroySourcePhrases() no longer destorys
							 // the partner piles
	pApp->m_pActivePile = (CPile*)NULL;
	pApp->m_pTargetBox->ChangeValue(_T("")); //pApp->m_targetBox.Destroy();
	pApp->m_nActiveSequNum = -1;
	pApp->m_selectionLine = -1;
	Invalidate(); // our own
	GetLayout()->PlaceBox();

	// this is called from a number of places, and is not the appropriate place for trying
	// to remove read-only protection; on doc closure, do it instead from the more
	// specific document class's function OnFileClose() which calls ClobberDocument()

	gbDoingInitialSetup = TRUE; // MFC note: Needed because the phrase box will not
        //exist after the close is done, so if a <New Document> command is issued, then
        //OnButtonMerge() would otherwise fail if a LookAhead() merge was required on the
        //first words of the new document. I put it here because this is called for a doc
        //close by any method
    // NOTE: we don't change he values of the four flags associated with glossing, because
    // this function will be called for processes which serially open and close each
    // document of a project, and the flags will have to maintain their values across the
    // calls to ClobberDocument()

	// hide and disable the target box until input is expected
	pApp->m_pTargetBox->Hide(); // whm note: ChangeValue(_T("")) is called above
	pApp->m_pTargetBox->Enable(FALSE);
}

void CAdapt_ItView::CloseProject()
{
	wxCommandEvent dummyevent;
	OnFileCloseProject(dummyevent);
}

// targetStr will normally be the contents of the Phrase Box, but sometimes (such as when
// restoring punctuation when a placeholder is removed), it could be the m_targetStr member
// of a CSourcePhrase; it could have initial punctuation, it may not have, and/or final
// punctuation, or even in the case of a merger it may have medial punctuation, and it
// could have text starting with lower case and needing to become upper. BEW added 20 Apr
// 2005 checking of the app's flag m_bCopySourcePunctuation - which typically is TRUE, but
// for version 3 we wish to be able to temporarily suppress punctuation copy if the user
// clicks the No Punctuation Copy button on the command bar - so this flag was added to
// support this new functionality. The flag is automatically reset TRUE once the phrase box
// moves to a different location by any method.
// BEW 11Oct10, added more members for doc version 5, so changes needed for supporting
// m_follOuterPunct and USFM fixedspace symbol ~ (which we now handle as a merger of two
// words) in order to cope with all punctuation possibilities on a ~ bound pair
// BEW 23Feb12, for docVersion 6, added support for suppression of redundant punctuation
// placement dialog as well as support for redundant marker placement dialogs in the event
// of doing an export; the how and why of all this is explain below in extensive comments
// about a third of the way into the function.
void CAdapt_ItView::MakeTargetStringIncludingPunctuation(CSourcePhrase *pSrcPhrase, wxString targetStr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();

	pApp->m_nPlacePunctDlgCallNumber++;
	int theSequNum = pSrcPhrase->m_nSequNumber;

    // BEW added 19Dec07: bleed out the case when Reviewing mode is on and the box is about
    // to leave a hole which may or may not have had punctuation there; the former
    // m_targetStr is preserved in gStrSavedTargetStringWithPunctInReviewingMode, and the
    // test for needing to do this restoration is that the global flag
    // gbSavedTargetStringWithPunctInReviewingMode is TRUE, and we must clear the flag
    // before returning
    // Don't do the next block if the function was called before at same location
	if ( !(theSequNum == pApp->m_nCurSequNum_ForPlacementDialog &&
		  pApp->m_nPlacePunctDlgCallNumber > 1) )
	{
		if (gbSavedTargetStringWithPunctInReviewingMode)
		{
			// the flag will only be true when the location was a hole when the box
			// landed there, so we can rely on m_targetPhrase being empty provided the
			// user has not decided to edit the document by typing something. So we
			// check for a still empty m_targetPhrase, and if so we restore m_targetStr
			// to what it was before and return; but if the user has typed something
			// then we abandon what we saved and we do a normal pass through the rest
			// of this function
			if (pApp->m_targetPhrase.IsEmpty())
			{
				// it is still empty, so do the restoration etc.
				pSrcPhrase->m_targetStr = gStrSavedTargetStringWithPunctInReviewingMode;
				gStrSavedTargetStringWithPunctInReviewingMode.Empty();
				gbSavedTargetStringWithPunctInReviewingMode = FALSE; // restore default value
				return;
			}
			// user must have typed something, so clean up and control can fall thru
			// to the rest
			gStrSavedTargetStringWithPunctInReviewingMode.Empty();
			gbSavedTargetStringWithPunctInReviewingMode = FALSE; // restore default value
		}
	}

    // BEW added 1Jul09, don't do the code in this function if the function has been called
    // once before at this current active location
	if ( !(theSequNum == pApp->m_nCurSequNum_ForPlacementDialog &&
		  pApp->m_nPlacePunctDlgCallNumber > 1) )
	{
        // BEW 11Oct10, have to handle ~ -- need a separate block for this as it is more
        // complex, and also need to take m_follOuterPunct into consideration in both
        // blocks
		if (!IsFixedSpaceSymbolWithin(pSrcPhrase))
		{
			// the legacy situation, no ~ fixedspace conjoining...

			wxString str = targetStr; // make a copy
			wxArrayString remainderList;
			wxString strCorresp;	// where we build target punctuation strings (from the
				// punctuation correspondences pairs) before inserting them into m_targetStr
			strCorresp.Empty();

            // for auto-capitalization we will attempt to do any needed change to upper
            // case, no matter what the punctuation behaviour is. If a lookup was done
            // earlier, and a store not yet done, then the value of the gbMatchedKB_UCentry
            // flag will also be valid here (if it is TRUE then we don't want a change to
            // upper case done because the lookup was done with upper case source data - so
            // we take the adaptation or gloss 'as is')

			// first find out what the key's case status is
			bool bNoError = TRUE;
			bool bWantChangeToUC = FALSE; // if TRUE, we want the change to upper case
										  // done if possible
			if (gbAutoCaps)
			{
				bNoError = pDoc->SetCaseParameters(pSrcPhrase->m_key);
				if (bNoError && gbSourceIsUpperCase && !gbMatchedKB_UCentry)
				{
					bWantChangeToUC = TRUE;
				}
			}

			// if it is <Not In KB> then suppress punctuation insertion - there is nothing
			// supposed to be "there" anyway -- from version 1.4.0 and onwards, by Susanna
			// Imrie's suggestion, we will allow a non-null adaptation for a <not in kb> entry;
			// we just won't store it in the kb -- so just go on...

			// we don't worry about internal punctuation in the target if the target is empty
			// in fact, we don't want any punctuation if the target is empty
			bool bEmptyTarget = FALSE;
			if (!str.IsEmpty() && pApp->m_bCopySourcePunctuation)
			{
                // check for any medial punctuation, if there is any, see if it is all in
                // the targetStr already; if not, ask user for whatever is missing (if he
                // wants he can then place the extra stuff, or ignore it).
				if (pSrcPhrase->m_bHasInternalPunct)
				{
					// BEW 23Feb12, added code for docVersion 6 support of suppression of
					// redundant showings of the placement dialog for puncts (and if the
					// new storage strings for preserving state are cleared here, then
					// that will cause placement dialog for markers to appear, if there is
					// marker placement ambiguity, in an export

                    // The first thing to do is to check if m_lastAdaptionsPattern has
                    // previous state stored in it; and if so, we've some work to do to
                    // determine what we do next. There are two situations we must check
                    // for here first, and setup accordingly within the block below. Check
                    // if each and every one of the tokenized list of substrings (with no
                    // puncts removed before the check is made, though there may be no
                    // puncts in it anyway)formed from the contents of the passed in
                    // targetStr parameter, has a match within m_lastAdaptionsPattern (the
                    // latter we know has all puncts stripped out earlier), and that the
                    // matches are made in natural order & increasing offset values.
                    // Failure to satisfy those conditions means that the user has typed
                    // something different for the adaptation - whether a change of
                    // punctuation by typing some explicitly in the phrase box, or the
                    // fixing of a typo, or the substitution of a different more suitable
                    // phrase as a better translation of the source text at the active
                    // location - and no matter which is the case, the former stored state
                    // cannot then be relied on. We'll do all this work in a function, and
                    // return a boolean. TRUE will mean that no user-change was detected,
                    // FALSE that something differed.
					// Then, still in the block below, if FALSE was returned, we clear the
					// following four CSourcePhrase wxString members before exiting the block:
					// m_lastAdaptionsPattern
					// m_punctsPattern
					// m_tgtMkrsPattern
					// m_glossMkrsPattern
                    // which will then have the desired side-effect, namely, that the
                    // relevant punctuation placement dialog (when punctuation placement by
                    // algorithm would otherwise be unreliable due to ambiguity as to the
                    // correct location it is to be put in), and/or the relevant marker
                    // placement dialog (when marker placement is ambiguous - this can
                    // happen only at export time, because markers are removed from needing
                    // to be handled explicitly until then - when they have to be put back
                    // in the right spots in order to export correct USFM markup for the
                    // target text, or glosses-as-text export)
					if (!pSrcPhrase->m_lastAdaptionsPattern.IsEmpty())
					{
						// m_lastAdaptionsPattern is not empty, therefore it contains the
						// m_adaptions value (& that NEVER has punctuation not stripped
						// off) as it was at the last time the above placement dialog was
						// invoked -- so now we compare with the contents of the passed in
						// targetStr parameter, with the m_lastAdaptionsPattern member of
						// the current active pSrcPhrase instance passed in
						bool bNoChange =  IsPhraseBoxAdaptionUnchanged(pSrcPhrase, str);
						if (bNoChange)
						{
							// let control continue to the block further below
							;
						}
						else
						{
							// there has been a change, so empty the 4 state-storing
							// docVersion 6 string members (we empty them all for safety's
							// sake, because the change may also require that in an export
							// of the target text, or glosses-as-text, marker placement
							// may need redoing as well. At worst this can only result in
							// one further showing of a relevant placement dialog at a
							// later export invocation.
							pSrcPhrase->m_lastAdaptionsPattern = _T("");
							pSrcPhrase->m_tgtMkrPattern = _T("");
							pSrcPhrase->m_glossMkrPattern = _T("");
							pSrcPhrase->m_punctsPattern = _T("");
						}
					}

					// If the m_lastAdaptionsPattern is empty, for any reason, we must do
					// a punctuation placement using the dialog for that purpose
					if (pSrcPhrase->m_lastAdaptionsPattern.IsEmpty())
					{
						// the placement dialog needs to be shown
						wxString punct;
						wxArrayString* pList = pSrcPhrase->m_pMedialPuncts; // the CSourcePhrase might
																		  // contain a phrase or a word
						int count = pList->GetCount();

						for ( int n = 0; n < count; n++ )
						{
							punct = pList->Item(n); // can be several punct characters in the
														 // stored string
							wxASSERT(!punct.IsEmpty());
							strCorresp = GetConvertedPunct(punct); // uses PUNCTPAIRS and TWOPUNCTPAIRS
																   // for converting
							remainderList.Add(strCorresp);
						}

						// put them all in interactively using a dialog
						gpRemainderList = &remainderList; // set the global so dialog can access it
						CPlaceInternalPunct dlg(wxGetApp().GetMainFrame());
						dlg.Centre();
						dlg.m_pSrcPhrase = pSrcPhrase; // set the dialog's local member
						dlg.ShowModal(); // display the dialog

						// get the result, and fix the source phrase accordingly
						str = dlg.m_tgtPhrase; // remember str could be a phrase, and so
											   //contain one or more spaces

						// anything left in the list can be thrown away now
						gpRemainderList->Clear();
						gpRemainderList = (wxArrayString*)NULL; // the remainderList will be
												// destroyed when it goes out of scope
						strCorresp.Empty();

                        // BEW 23Feb12, Store the placed-punctuation state pending the
                        // possibility that this current active location may be returned to
						// at some later time, by the user -- if so, we want the stored
						// state to be used for setting m_targetStr, rather than showing
						// the placement dialog again. Two strings need to be stored,
						// m_adaptions (and we call RemovePunction() on it to ensure no
						// punctuation slips through the net here), and the value of str
						// as set from the dialog's m_tgtPhrase member above - the latter
						// has, of course, the punctuation unambiguously placed (that, of
						// course, doesn't preclude the possibility of user error in doing
						// the placement; for that eventuality, there is a Change
						// Punctuation or Markers Pattern menu item in the GUI by which
						// the user can, after putting the phrase box back at the current
						// active location, click the menu item and answer Yes in the
						// resulting Yes/No message box, which will force all four of the
						// state-saving wxString members discussed above, to be emptied
						// (which in turn causes the relevant placement dialog(s) to open
						// at this location again, at the appropriate time, for the user
						// to correct his former placement error(s).)
						wxString nopunctsForSureStr = pSrcPhrase->m_adaption;
						RemovePunctuation(pDoc, &nopunctsForSureStr, 1); // 1 means "tgt
														// text punctuation is to be used"
						// now save state as described above
						pSrcPhrase->m_lastAdaptionsPattern = nopunctsForSureStr;
						pSrcPhrase->m_punctsPattern = str;
					} // end of TRUE block for test: if (pSrcPhrase->m_lastAdaptionsPattern.IsEmpty())
					else
					{
						// if control enters here, we've determined that the word or words
						// of the target text aren't changed, and the user hasn't
						// explicitly typed punctuation into the phrase box, so we've
						// every reason to expect that the former saved state for
						// punctuation placement, and word spellings, are unchanged and so
						// can be restored here without recourse to the placement dialog
						str = pSrcPhrase->m_punctsPattern;
					}
				} // end of TRUE block for test: if (pSrcPhrase->m_bHasInternalPunct)
			}
			else
			{
				bEmptyTarget = TRUE;
			}

            // BEW addition 23March05, to allow detached punctuation to be reconstructed in
            // the target text I do it here and not for the internal punctuation case above
            // because it would make no sense to do the block of code above when the target
            // is empty
			bool bWantPrevCopy;
			int punctLen;
			// BEW 31Mar12, commented the switching of the value out, because we don't
			// want an empty string to have punctuation prefixed or suffixed to it; so if
			// bEmptyTarget is TRUE, let that value continue for the code which follows
			//if (bEmptyTarget) 
			//{
			//	bEmptyTarget = FALSE;
			//}

            // BEW added 20 April 2005 to support the use of the new No Punctuation Copy
            // button. Don't restore the TRUE value for this flag at the end of this
            // function because the function can be called more than once while the phrase
            // box is unmoved. Do the flag restoration to TRUE in code which moves the
            // phrase box elsewhere
			if (!pApp->m_bCopySourcePunctuation)
			{
				pSrcPhrase->m_targetStr = str;
			}
			else
			{
                // preceding punctuation can be handled silently. If the user typed
                // different punctuation, then the user's must override the original
                // punctuation. The target text string might be a phrase and hence contain
                // spaces, but space is a delimiter in m_punctSet from version 1.3.6
                // onwards, so we must be careful in the next code blocks - SpanIncluding()
                // can still be used safely, because there will be nonpunctuation and
                // nonspace characters prior to any spaces in the phrase; and similarly
                // when reversed
				bWantPrevCopy = FALSE;
				punctLen = 0; // for auto caps support
				if (!bEmptyTarget)
				{
					if (!pSrcPhrase->m_precPunct.IsEmpty())
					{
						// span using target lang's punctuation - wxWidgets version
						// SpanIncluding() in helpers.h
						wxString strInitialPunct = SpanIncluding(str, pApp->m_punctuation[1]);
						if (strInitialPunct.IsEmpty())
						{
							// there was no initial punctuation typed, so silently copy
							// original's to the target later on (not here, in case it mucks up
							// the check for following punct)
							bWantPrevCopy = TRUE;
						}
						else
						{
							// let the punctuation typed by the user stand unchanged, but for
							// auto caps ON get the case change done if it is required
							punctLen = strInitialPunct.Length();
						}

						if (bWantChangeToUC)
						{
							// check first that the change to upper case is possible
							wxString noInitialPunctStr = str.Mid(punctLen);
							bNoError = pDoc->SetCaseParameters(noInitialPunctStr,FALSE);
							if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
							{
								// do the change to upper case at the wxChar at [punctLen] index
								str.SetChar(punctLen,gcharNonSrcUC);
							}
						}
					}
                    // if the word or phrase in the source had no preceding punctuation,
                    // then MakeTargetStringIncludingPunctuation will do nothing, so that
                    // if the user elects to explicitly type some preceding punctuation, it
                    // will be accepted unconditionally

					// ditto, for following punctuation
					if (!pSrcPhrase->m_follPunct.IsEmpty())
					{
						wxString reverse = str;
						reverse = MakeReverse(reverse); // see helpers.h

						wxString strFollPunct = SpanIncluding(reverse,pApp->m_punctuation[1]);
						if (strFollPunct.IsEmpty())
						{
							// there was no final punctuation typed, so silently copy
							// original's to the target; and also copy any in m_follOuterPunct
							wxString tgtFollPunct;
							tgtFollPunct.Empty();
							tgtFollPunct = GetConvertedPunct(pSrcPhrase->m_follPunct);
							// BEW 11Oct10, added to support m_follOuterPunct
							if (!pSrcPhrase->GetFollowingOuterPunct().IsEmpty())
							{
								wxString tgtFollPunctOuter;
								tgtFollPunctOuter.Empty();
								tgtFollPunctOuter = GetConvertedPunct(pSrcPhrase->GetFollowingOuterPunct());
								tgtFollPunct += tgtFollPunctOuter; // join it together
								// put a space between consecutive curly quotes
								size_t length = tgtFollPunct.Len();
								size_t index;
								for (index = 0; index < length - 1; index++)
								{

									wxChar aChar = tgtFollPunct[index];
									wxChar nxtChar = tgtFollPunct[index + 1];
									if (pDoc->IsClosingQuote(&aChar) && pDoc->IsClosingQuote(&nxtChar))
									{
										// this handles not just curly endquotes, but
										// straights as well
										wxString leftStr = tgtFollPunct.Left(index + 1);
										wxString rightStr = tgtFollPunct.Mid(index + 1);
										leftStr += _T(" ");
										tgtFollPunct = leftStr + rightStr;
										length = tgtFollPunct.Len();
										index += 1;
									}
								}
							}
							// references in the text like 10:27 give this algorithm problems;
							// the first time the phrasebox is accessed, :27 gets appended to
							// 10, resulting in 10:27 as the target text - correctly; but if
							// the user backtracks to that CSourcePhrase instance later on (by
							// any means), then MakeTargetStringIncludingPunctuation will be
							// called at least two more times, and the next time round the
							// passed in text would be 10:27 to which a further :27 gets added,
							// producing 10:27:27 and then the caller would call
							// RemovePunctuation( ) which is coded in such a way that this
							// "word" would result in 1027 being saved to the KB and the final
							// :27 retained as following punctuation, and that gets added
							// producing 1027:27 - and so it goes on, next we'd get 102727:27,
							// and so on ad infinitum. To break this sequence of errors, we
							// need to do a test for "following punctuation" strings which have
							// already been added to the word, such as "10". So we use the
							// reversed string and also reverse tgtFollPunct and check if the
							// latter is the initial string already - if so, we assume nothing
							// more needs to be done.
							wxString reverseFollPunct = tgtFollPunct;
							reverseFollPunct = MakeReverse(reverseFollPunct);
							int nFind = reverse.Find(reverseFollPunct);
							if (nFind == 0)
							{
								// we have a situation where it looks like the 'following
								// punctuation' has already been added so we'll do nothing
								;
							}
							else
							{
								// looks like it has not been added yet, so do so
								str += tgtFollPunct;
							}
						}
						else
						{
							; // let the punctuation typed by the user stand unchanged
						}
					}
					// if the word or phrase in the source had no following punctuation, then
					// MakeTargetStringIncludingPunctuation will do nothing, so that if the
					// user elects to explicitly type some following punctuation, it will be
					// accepted unconditionally

					// add the preceding punctuation, if any
					if (bWantPrevCopy)
					{
						wxString tgtPrecPunct;
						tgtPrecPunct.Empty();
						tgtPrecPunct = GetConvertedPunct(pSrcPhrase->m_precPunct);
						str = tgtPrecPunct + str;
					}
				}
				// now add the final form of the target string to the source phrase
				pSrcPhrase->m_targetStr = str;
			} // end of else block for test: if (!pApp->m_bCopySourcePunctuation)
		} // end of TRUE block for test: if (!IsFixedSpaceSymbolWithin(pSrcPhrase))
		else
		{
            // BEW 11Oct10, when control enters here, we have a m_srcPhrase like this:
            // <puncts1>word1<puncts2>~<puncts3>word2<puncts4> stored as a merger, where
            // any or all of <punctsi> where i = 1,2,3, or 4 may be empty or contain
            // punctuation; if <puncts2> is non-empty, it is stored in the first child
            // pSrcPhrase in m_pSavedWords, in its m_follPunct member, ; if
            // <puncts3> is non-empty, it is stored in the second child pSrcPhrase in
            // m_pSavedWords, in its m_precPunct member.
			// So, because we have to allow the user to type his own new punctuation to
			// replace any of these four potential punctuation substrings, we've a lot of
			// work to do to analyse what is there and what, if anything, the user has
			// typed different punctuation for, and hence when to copy what is stored to
			// m_targetStr and when to refrain and let the user's replacement puncts stand
			// as is.

			// Task 1: parse: to break down the input string into the two parts
			int offset = wxNOT_FOUND;
			wxString word1;
			wxString word2;
			offset = targetStr.Find(_T('~'));
			word1 = targetStr.Left(offset);
			word2 = targetStr.Mid(offset + 1); // jump to what follows ~ & accept the rest
			// word1 and word2 may each have punctuation before or after or both

			// Task2: further parse, break these down until we have the punctuation strings and
			// the word strings separated
			wxString word1PrecPunct;
			wxString word1FollPunct;
			wxString word2PrecPunct;
			wxString word2FollPunct;
			wxString word1Proper;
			wxString word2Proper;
			word1PrecPunct = SpanIncluding(word1, pApp->m_punctuation[1]);
			word2PrecPunct = SpanIncluding(word2, pApp->m_punctuation[1]);
			wxString reversedWord1 = MakeReverse(word1);
			wxString reversedWord2 = MakeReverse(word2);
			word1FollPunct = SpanIncluding(reversedWord1, pApp->m_punctuation[1]);
			word2FollPunct = SpanIncluding(reversedWord2, pApp->m_punctuation[1]);
			word1FollPunct = MakeReverse(word1FollPunct); // punct now in natural order
			word2FollPunct = MakeReverse(word2FollPunct); // ditto
			int preclen1 = word1PrecPunct.Len();
			int preclen2 = word2PrecPunct.Len();
			word1Proper = word1.Mid(preclen1); // may still have following puncts
			word2Proper = word2.Mid(preclen2); // may still have following puncts
			word1Proper = MakeReverse(word1Proper); // is reversed
			word2Proper = MakeReverse(word2Proper); // is reversed
			int folllen1 = word1FollPunct.Len();
			int folllen2 = word2FollPunct.Len();
			word1Proper = word1Proper.Mid(folllen1);
			word2Proper = word2Proper.Mid(folllen2);
			word1Proper = MakeReverse(word1Proper); // normal order
			word2Proper = MakeReverse(word2Proper); // normal order
			// We now have, for each word, the actual word, preceding and following
			// punctuation for each, if either or both locations have punctuation, and the
			// length of any punctuation string or zero if absent. The ParseWord() call in
			// TokenizeText() has put any punctuation strings both in pSrcPhrase (the
			// m_precPunct and m_follPunct members) and in the same members, as
			// appropriate, for the two child pSrcPhrase instances in m_pSavedWords -- in
			// fact, the ONLY place punctuation preceding ~ is stored is in the
			// m_follPunct member of the first child pSrcPhrase, and the ONLY place
			// punctuation following ~ is stored is in the m_precPunctMember of the
			// second child pSrcPhrase. So we are in a position now to make comparisons
			// between what we obtained above, and what was stored in the original
			// document creation parse - hence we can determine when/if the user has typed
			// different punctuation in the phrasebox, and if he has we just accept it as
			// typed, if he didn't type any in one of the four possible locations, then we
			// copy what was originally stored for that location, provided it is
			// non-empty, and convert it to target language punctuation.
			if (targetStr.IsEmpty() || offset == wxNOT_FOUND)
			{
				// if the phrase box is empty, don't make a "contents" of punctuation
				// characters, leave it truly empty (& capable of having <no adaptation>
				// nothing entry if the user does the toolbar button click)
				word1Proper.Empty();
				word2Proper.Empty();
				if (!pSrcPhrase->m_pSavedWords->IsEmpty())
				{
					SPList::Node* pos1 = pSrcPhrase->m_pSavedWords->GetFirst();
					SPList::Node* pos2 = pSrcPhrase->m_pSavedWords->GetLast();
					CSourcePhrase* pSrcPhrWord1 = pos1->GetData();
					CSourcePhrase* pSrcPhrWord2 = pos2->GetData();
					wxASSERT(pSrcPhrWord1 != NULL && pSrcPhrWord2 != NULL);
					pSrcPhrWord1->m_adaption = word1Proper;
					pSrcPhrWord1->m_targetStr = word1Proper;
					pSrcPhrWord2->m_adaption = word2Proper;
					pSrcPhrWord2->m_targetStr = word2Proper;
				}
				// and the parent should then be empty for m_adaption and m_targetStr
				pSrcPhrase->m_adaption.Empty();
				pSrcPhrase->m_targetStr.Empty();

				pApp->m_nCurSequNum_ForPlacementDialog = theSequNum;
				return;
			}

			// Task 3: do any automatic capitalization. We assume it is only ever going to
			// be appropriate for the start of the first of the two words; capitals anywhere
			// else in the conjoined word pair will have to be manually typed if wanted

			// first find out what the key's case status is
			bool bNoError = TRUE;
			bool bWantChangeToUC = FALSE; // if TRUE, we want the change to upper case
										  // done if possible
			if (gbAutoCaps)
			{
				// next call will work fine because ~ is not at the start of m_key
				bNoError = pDoc->SetCaseParameters(pSrcPhrase->m_key);
				if (bNoError && gbSourceIsUpperCase && !gbMatchedKB_UCentry)
				{
					bWantChangeToUC = TRUE;
				}
			}
			if (bWantChangeToUC)
			{
				// check first that the change to upper case is possible
				bNoError = pDoc->SetCaseParameters(word1Proper,FALSE);
				if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
				{
					// do the change to upper case
					word1Proper.SetChar(0,gcharNonSrcUC);
				}
			}

			// Task 4: do the punctuation conversions and any changes the user wants for
			// the punctuation strings
			if (!pSrcPhrase->m_pSavedWords->IsEmpty())
			{
				// we can do the following only if there are child CSourcePhrase instances
				// stored in the m_pSavedWords member; if there aren't any (eg. as when
				// processing a document parsed for doc version 4) just use the passed in
				// targetStr value 'as is'
				SPList::Node* pos1 = pSrcPhrase->m_pSavedWords->GetFirst();
				SPList::Node* pos2 = pSrcPhrase->m_pSavedWords->GetLast();
				CSourcePhrase* pSrcPhrWord1 = pos1->GetData();
				CSourcePhrase* pSrcPhrWord2 = pos2->GetData();
				wxASSERT(pSrcPhrWord1 != NULL && pSrcPhrWord2 != NULL);

				wxString storedPuncts; // a scratch variable
				wxString parsedPuncts; // a scratch variable
				wxString finalW1PrecPuncts;
				wxString finalW1FollPuncts;
				wxString finalW2PrecPuncts;
				wxString finalW2FollPuncts;

                // NOTE: in what follows the variable names differ by whether the
                // punctuation is "stored" versus "parsed". The stored stuff will be source
                // text punctuation stored in the CSourcePhrase at document creation time,
                // when the source text is parsed in to make the document. The parsedPuncts
                // are not those identified at doc creation time, but rather are typed by
                // the user in the phrase box, and so have just been parsed by the code
                // above. The protocol we follow is that if there is, in pre-word location,
                // or post-word location, both parsed puncts and stored puncts, then the
                // parsed puncts replace the stored ones, because we assume the user typed
                // the ones just now identified above by the parsing code, and so he wants
                // what he typed to be used rather than what was in the source text to be
                // converted to the equivalent target text puncts.
				// This "replacive" protocol is used throughout the application except in
				// one scenario -- it must not be used when doing the document rebuild
				// after the user has changed the punctuation settings. In the latter
				// scenario, the replacive protocol is not appropriate. See the
				// descriptive comments above the StoreBeforeProceeding() function,
				// also defined in the view class.

				// start with the preceding puncts of word1
				storedPuncts = pSrcPhrWord1->m_precPunct;
				parsedPuncts = word1PrecPunct;
				if (!parsedPuncts.IsEmpty())
				{
					// the user has typed preceding punctuation for word1, so we use it
					parsedPuncts.Trim(FALSE); // trim off any initial whitespace
					finalW1PrecPuncts = parsedPuncts;
				}
				else if (!storedPuncts.IsEmpty() && pApp->m_bCopySourcePunctuation)
				{
					// the user has not typed any preceding punctuation for word1, and there is
					// stored preceding punctuation available, so providing copying of the
					// source is permitted, we'll copy the stored preceding punctuation
					storedPuncts.Trim(FALSE);
					storedPuncts = GetConvertedPunct(storedPuncts);
					finalW1PrecPuncts = storedPuncts;
				}
				// this completes handling of preceding punctuation on word1

				// next, following punctuation on word1
				storedPuncts = pSrcPhrWord1->m_follPunct;
				parsedPuncts = word1FollPunct;
				if (!parsedPuncts.IsEmpty())
				{
					// the user has typed following punctuation for word1, so we use it
					parsedPuncts.Trim(TRUE); // trim off any final whitespace
					finalW1FollPuncts = parsedPuncts;
				}
				else if (!storedPuncts.IsEmpty() && pApp->m_bCopySourcePunctuation)
				{
					// user has not typed any following punctuation for word1, and there is
					// stored following punctuation available, so providing copying of the
					// source is permitted, we'll copy the stored following punctuation
					storedPuncts.Trim(TRUE);
					storedPuncts = GetConvertedPunct(storedPuncts);
					finalW1FollPuncts = storedPuncts;
				}
				// this completes handling of following punctuation on word1

				// next, handle preceding punctuation on word2
				storedPuncts = pSrcPhrWord2->m_precPunct;
				parsedPuncts = word2PrecPunct;
				if (!parsedPuncts.IsEmpty())
				{
					// the user has typed preceding punctuation for word2, so we use it
					parsedPuncts.Trim(FALSE); // trim off any initial whitespace
					finalW2PrecPuncts = parsedPuncts;
				}
				else if (!storedPuncts.IsEmpty() && pApp->m_bCopySourcePunctuation)
				{
					// user has not typed any preceding punctuation for word2, and there is
					// stored preceding punctuation available, so providing copying of the
					// source is permitted, we'll copy the stored preceding punctuation
					storedPuncts.Trim(FALSE);
					storedPuncts = GetConvertedPunct(storedPuncts);
					finalW2PrecPuncts = storedPuncts;
				}
				// this completes handling of preceding punctuation on word2

				// finally, handle following punctuation on word2
				storedPuncts = pSrcPhrWord2->m_follPunct;
				parsedPuncts = word2FollPunct;
				if (!parsedPuncts.IsEmpty())
				{
					// the user has typed following punctuation for word2, so we use it
					parsedPuncts.Trim(TRUE); // trim off any final whitespace
					finalW2FollPuncts = parsedPuncts;
				}
				else if (!storedPuncts.IsEmpty() && pApp->m_bCopySourcePunctuation)
				{
					// user has not typed any following punctuation for word2, and there is
					// stored following punctuation available, so providing copying of the
					// source is permitted, we'll copy the stored following punctuation
					storedPuncts.Trim(TRUE);
					storedPuncts = GetConvertedPunct(storedPuncts);
					finalW2FollPuncts = storedPuncts;
				}
				// this completes handling of following punctuation on word2

				// Final Task: build the punctuated final string, and assign it to
				// pSrcPhrase's m_targetStr member
				wxString str;
				str += finalW1PrecPuncts + word1Proper + finalW1FollPuncts;
				str += _T('~');
				str += finalW2PrecPuncts + word2Proper + finalW2FollPuncts;

				// now add the final form of the target string to the source phrase
				pSrcPhrase->m_targetStr = str;

			}
			else
			{
				// best we can do in this circumstance is just use targetStr 'as is'
				pSrcPhrase->m_targetStr = targetStr;
			}

		} // end of else block for test: if (!IsFixedSpaceSymbolWithin(pSrcPhrase))
	}
    // store the sequence number on the app class, so that if we reenter while at the same
    // sequence number, the test at the top of the function can detect this and if the
    // m_nPlacePunctDlgCallNumber value has just been incremented to be 2 or higher, we
    // will skip the code contained in this function; the m_nPlacePunctDlgCallNumber value
    // is reset to 0 at the end of CLayout::Draw(), and at the same place the
    // m_nCurSequNum_ForPlacementDialog is reset to default -1
	pApp->m_nCurSequNum_ForPlacementDialog = theSequNum;
}

void CAdapt_ItView::DoFileSaveKB()
{
	wxCommandEvent dummyevent;
	OnFileSaveKB(dummyevent); // protected, so make it accessible
}


// BEW added 16Apr08; pList is a passed in list of CSourcePhrase pointers, such as
// m_pSourcePhrases; parameters two and three define which part of the passed in list is
// used for doing the deep copies, and the pCopiedSublist passes the sublist back to the
// caller. Normally pCopiedSublist will be empty when passed in, but it does not have to
// be. Internally AddTail() is used, and so the function can also be used to append deep
// copies to an existing sublist of deep copies (but I've no plans to do the latter, at
// least none yet).
// returns TRUE if there was no error, FALSE if there was an error
// BEW 22Mar10, updated for support of doc version 5 (no changes needed)
// BEW 9July10, no changes needed for support of kbVersion 2
bool CAdapt_ItView::DeepCopySourcePhraseSublist(SPList* pList, int nStartingSequNum,
								int nEndingSequNum, SPList* pCopiedSublist)
{
	wxString errStr;
    // it is the caller's responsibility to ensure that nStartingSequNum and nEndingSequNum
    // are valid indexes into the pList list
	SPList::Node* pos = pList->Item(nStartingSequNum);
	if (pos == NULL)
	{
		// error condition exists
		// whm Note: Leave these error strings untranslated; not for localization
		errStr = _T(
"DeepCopySourcePhraseSublist() returned NULL for POSITION pos on .FindIndex() call. Saving document. ");
		errStr += _T(
		"Edit process abandoned. Document restored to pre-edit state.");
		wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}
	SPList::Node* endpos = pList->Item(nEndingSequNum);
	if (endpos == NULL)
	{
		// error condition exists
		errStr = _T(
"DeepCopySourcePhraseSublist() returned NULL for POSITION endpos on .FindIndex() call. Saving document. ");
		errStr += _T(
		"Edit process abandoned. Document restored to pre-edit state.");
		wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}

	SPList::Node* savePos = NULL; // POSITION savePos = NULL;
	CSourcePhrase* pSrcPhrase = NULL;
	// BEW added 7Sep10, because if the nStartingSequNum and nEndingSequNum are the same
	// value (ie. only one CSourcePhrase in the editable span), then the while loop below
	// ran to the end of the document, so we need to handle this case in a bleeding block
	if (nStartingSequNum == nEndingSequNum)
	{
		pSrcPhrase = pos->GetData();
		CSourcePhrase* pNewSP = new CSourcePhrase(*pSrcPhrase); // a shallow copy
		pNewSP->DeepCopy(); // pNewSP is now a deep copy
		pCopiedSublist->Append(pNewSP);
		return TRUE;
	}
	// if control gets to here, the while loop is safe
	while (pos != NULL)
	{
		savePos = pos;
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
        // whm Checked that the CSourcePhrase(*pSrcPhrase) call below actually does use
        // operator= shallow copy in wx version. Probably wouldn't make any difference in
        // this case since DeepCopy() is called on pNewSP immediately after creation of
        // pNewSP.
		CSourcePhrase* pNewSP = new CSourcePhrase(*pSrcPhrase); // uses operator=,
																// does shallow copy
		pNewSP->DeepCopy(); // pNewSP is now a deep copy
		pCopiedSublist->Append(pNewSP);
		if (savePos == endpos)
		{
			// we have just added the final deep copy to pCopiedSublist, so break out
			break;
		}
	}
	return TRUE;
}


// Tokenize the source text string, str, storing the CSourcePhrase instances in pNewList.
// nInitialSequNum is what will be used for the sequence number of the first element
// tokenized. The tokenizing creates one CSourcePhrase instance per word in str, where
// "word" is a sequence of non-punctuation characters (the parser will skip word-internal
// punctuation, if present, as it works from both ends inwards); and the parser will deal
// with fixed-space (~) marker, SFM or USFM markup, distinquishing between inline binding
// (ie. next to the word, inside of any punctuation) markers, non-binding inline markers,
// and non-inline markers; and strip off and store punctuation at either or both ends of
// the word - it also supports USFM markup where punctuation can both precede and follow an
// endmarker such as \f* (footnote) \fe* (endnote) or \x* (cross reference). The grunt work
// is done by the ParseWord() function which is called within the internal TokenizeText()
// call. Punctuation settings for the source text are used by default. A count of how many
// CSourcePhrase instances were created is returned.
// BEW 23Mar10, updated for support of doc version 5 (no changes needed, except in internally
// called function)
// BEW 9July10, no changes needed for support of kbVersion 2
int CAdapt_ItView::TokenizeTextString(SPList* pNewList, wxString& str, int nInitialSequNum)
{
	CAdapt_ItDoc* pDoc = GetDocument();
	int	length = str.Length();
	if (!str.IsEmpty())
	{
		return pDoc->TokenizeText(nInitialSequNum,pNewList,str,length);
	}
	else
		return 0;
}

// TokenizeTargetTextString() overloads TokenizeTextString, to do the parsing with str
// assumed to containing target text (it is up to the caller to ensure that is so), and the
// TokenizeText() internal call will use the m_punctuation[1] (target text punctuation
// characters delimited by space between each) to calculate the spaceless punctuation
// string to be used for tokenizing. If pUseTargetTextPuncts is passed in as FALSE, or
// omitted, then source text punctuation characters are used when parsing the contents of
// str - often source and target punctuation sets are identical and which set is used wouldn't
// then matter, but it can't be assumed that is so, and so the caller should specify TRUE
// when str is target text, in order to guarantee correct results
int CAdapt_ItView::TokenizeTargetTextString(SPList* pNewList, wxString& str,
											int nInitialSequNum, bool bUseTargetTextPuncts)
{
	CAdapt_ItDoc* pDoc = GetDocument();
	int	length = str.Length();
	if (!str.IsEmpty())
	{
		return pDoc->TokenizeText(nInitialSequNum,pNewList,str,length,bUseTargetTextPuncts);
	}
	else
		return 0;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. This handler disables the "Knowledge Base Editor..."
/// item in the Tools menu if the appropriate KB is not in a ready state, otherwise it
/// enables the "Knowledge Base Editor..." item on the Tools menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateToolsKbEditor(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT( pApp != NULL );

	if ((!gbIsGlossing && pApp->m_bKBReady && pApp->m_pKB != NULL) ||
		(gbIsGlossing && pApp->m_bGlossingKBReady && pApp->m_pGlossingKB != NULL))
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::OnToolsKbEditor(wxCommandEvent& WXUNUSED(event))
{
 	CAdapt_ItApp* pApp = &wxGetApp();
	pApp->LogUserAction(_T("Initiated OnToolsKbEditor()"));
	// whm 23Jan09 Refactored the CKBEditor class and this handler. Changes to this handler
    // involved moving most of the intitializations of CKBEditor members to the CKBEditor
    // class itself, and eliminating several global variables that were only used in this
    // handler and in CKBEditor.
    //
    // wx version: Since the Tools KB Edit menu item has an accelerator table hot key
    // (CTRL-K see CMainFrame) and wxWidgets accelerator keys call menu and toolbar
    // handlers even when they are disabled, we must check for a disabled button and return
    // if disabled. On Windows, the accelerator key doesn't appear to call the handler for
    // a disabled menu item, but I'll leave the following code here in case it works
    // differently on other platforms.
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_TOOLS_KB_EDITOR))
	{
		::wxBell();
		pApp->LogUserAction(_T("KB Editor menu item disabled"));
		return;
	}

	CKBEditor editorPage(pApp->GetMainFrame());
	editorPage.Centre();

	if (editorPage.ShowModal() == wxID_OK)
	{
		// make the user's changes to the KB persistent (FALSE = no Auto backup)
		// whm TODO: Saving of KBs should only be done if a change was made in the KB Editor
		if (gbIsGlossing)
			pApp->SaveGlossingKB(FALSE);
		else
			pApp->SaveKB(FALSE);

	}

	// restore focus to the targetBox
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_pTargetBox->IsShown())
		{
			int len = pApp->m_targetPhrase.Length();
			pApp->m_nStartChar = len;
			pApp->m_nEndChar = len;
			pApp->m_pTargetBox->SetSelection(len,len);
			pApp->m_pTargetBox->SetFocus();
		}
	}

	// BEW added 20May09, next line required in order to remove the selection
	// Note, this function can be called after having done a Restore Knowledge Base
	// command and the latter requires no document be open, and in that case a call to
	// Redraw() will fail, so we have to wrap the Redraw() and PlaceBox() calls with a
	// test to ensure the box exists and a layout is available for redrawing - but the
	// latter is sufficient, because if the layout is available, so will the phrase box be
	if (GetLayout()->GetPileList()->GetCount() > 0 && GetLayout()->GetStripArray()->GetCount() > 0)
	{
		// a layout exists
		GetLayout()->Redraw();
		GetLayout()->PlaceBox(); // this call probably unneeded but no harm done
	}

	if (pApp->m_bForceFullConsistencyCheck)
	{
		// actually, let user choose current doc only, or full check
		wxCommandEvent dummy;
		GetDocument()->OnEditConsistencyCheck(dummy);
	}
	pApp->m_bForceFullConsistencyCheck = FALSE; // restore default value
}


// BEW 17Jul11, changed for GetRefString() to return KB_Entry enum, and use all 10 maps
// for glossing KB
void CAdapt_ItView::OnGoTo(wxCommandEvent& WXUNUSED(event))
{
	// refactored 17Apr09
    // Since the Edit Go To... menu item has an accelerator table hot key (CTRL-G see
    // CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even when
    // they are disabled, we must check for a disabled button and return if disabled. On
    // Windows, the accelerator key doesn't appear to call the handler for a disabled menu
    // item, but I'll leave the following code here in case it works differently on other
    // platforms.
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	pApp->LogUserAction(_T("Initiated OnGoTo()"));
	CAdapt_ItDoc* pDoc = GetDocument();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_GO_TO))
	{
		::wxBell();
		pApp->LogUserAction(_T("But Go To menu item disabled"));
		return;
	}

	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos;
	if (pList->IsEmpty())
	{
		::wxBell();
		pApp->LogUserAction(_T("Doc is empty in OnGoTo()"));
		return;
	}

    // provided the phrase box exists, unconditionally enter the old phrase box's text into
    // the KB - we assume it is complete, if not, too bad - it can be fixed later if it's
    // wrong. Oct 2004, Wolfgang Stradner requested that nothing be put in KB when Go To...
    // is being used to move around. So we look at the srcphrase and if it's m_adaption
    // member is null and the m_bAbandonable flag on the box is TRUE, then the m_targetBox
    // contents can be assumed to be unwanted and so not stored. (The step up/down buttons
    // make this kind of check already.)
	bool bOK;
	CRefString* pRefStr = NULL;
	KB_Entry rsEntry;
	if (pApp->m_nActiveSequNum != -1)
	{
		gnOldSequNum = pApp->m_nActiveSequNum; // preserve old location
		if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
			// abandon storage when not wanted (test added Oct 2004 - see above comment)
			bool bSkipStorage = FALSE;
			if (!pApp->m_pActivePile->GetSrcPhrase()->m_adaption.IsEmpty())
			{
				pApp->m_targetPhrase = pApp->m_pActivePile->GetSrcPhrase()->m_adaption;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				pApp->m_targetPhrase.Empty();
				bSkipStorage = TRUE;
			}

			if (!bSkipStorage && gbIsGlossing)
			{
                // the store will fail if the user edited the entry out of the glossing KB,
                // the latter cannot know which srcPhrases will be affected, so these will
                // still have their m_bHasGlossingKBEntry set true. We have to test for
                // this, ie. a null pRefString but the m_bHasGlossing KBEntry set TRUE is a
                // sufficient test, and if so, set the flag to FALSE
				rsEntry = pApp->m_pGlossingKB->GetRefString(pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
						pApp->m_pActivePile->GetSrcPhrase()->m_key,pApp->m_targetPhrase, pRefStr);
				if ((pRefStr == NULL || rsEntry == present_but_deleted) &&
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
				{
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
				}
				bOK = pApp->m_pGlossingKB->StoreText(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);
				bOK = bOK; // avoid warning
			}
			else if (!bSkipStorage && !gbIsGlossing)
			{
				MakeTargetStringIncludingPunctuation(pApp->m_pActivePile->GetSrcPhrase(),pApp->m_targetPhrase);
				RemovePunctuation(pDoc, &pApp->m_targetPhrase, from_target_text);

                // the store will fail if the user edited the entry out of the KB, as the
                // latter cannot know which srcPhrases will be affected, so these will
                // still have their m_bHasKBEntry set true. We have to test for this, ie. a
                // null pRefString but the m_bHasKBEntry set TRUE is a sufficient test, and
                // if so, set the flag to FALSE
				rsEntry = pApp->m_pKB->GetRefString(pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
								pApp->m_pActivePile->GetSrcPhrase()->m_key,pApp->m_targetPhrase, pRefStr);
				if ((pRefStr == NULL || rsEntry == present_but_deleted) &&
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
				{
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
				}
				gbInhibitMakeTargetStringCall = TRUE;
				bOK = pApp->m_pKB->StoreText(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);
				gbInhibitMakeTargetStringCall = FALSE;
			}
		}
	}
	else
	{
		gnOldSequNum = -1; // if we were at the eof, need -1
						   // to signal no earlier valid location
	}

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	wxString str;
	int nWantedChapter = 1;
	int nWantedVerse = 1;
	CGoToDlg dlg(pApp->GetMainFrame());
	if (dlg.ShowModal() == wxID_OK)
	{
		nWantedChapter = dlg.m_nChapter;
		nWantedVerse = dlg.m_nVerse; // from Oct 2004 extended version, this can be 0
						// which means "ignore the verse number, use chapter number only"

		// find the nominated chapter and verse, if possible, using the CString for chapt:verse;
		// if it fails, assume a range & try again with integers; but if verse is 0, then go straight
		// to the range block
		if (dlg.m_nVerse == 0)
			goto v;
		if (dlg.m_nChapter == 0)
		{
			// special case, either its non-scripture, or a chapterless book like 2John
			pos = pList->GetFirst();
			wxASSERT(pos != NULL);

			// first, assume it's a chapterless book like 2 John, try find the verse
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_chapterVerse == dlg.m_verse)
				{
					if (!gbIsGlossing)
					{
						// when adapting, we must prevent placing the phrasebox within a
						// retranslation, but when glossing this does not matter
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									//IDS_GOTO_FAILED
									wxMessageBox(_(
"Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"),
									_T(""), wxICON_EXCLAMATION | wxOK);
									pApp->m_pTargetBox->SetFocus();
									pApp->LogUserAction(_T("Go To command failed. No valid location for the phrase box..."));
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation,
					// as close to wanted loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}
					return;
				}
			}

			// didn't find the verse, so instead put the phrase box at the first sourcephrase
			// with TextType of 'verse'
			pos = pList->GetFirst();
			wxASSERT(pos != NULL);
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_curTextType == verse)
				{
					if (!gbIsGlossing)
					{
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									// IDS_GOTO_FAILED
									wxMessageBox(_(
"Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"),
									_T(""),wxICON_EXCLAMATION | wxOK);
									pApp->m_pTargetBox->SetFocus();
									pApp->LogUserAction(_T("Go To command failed. No valid location for the phrase box..."));
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}

					return;
				}
			}
		} // end chapter number == zero block
		else
		{
			// look for chapter & verse in the form  n:m
			pos = pList->GetFirst();
			wxASSERT(pos != NULL);
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_chapterVerse == dlg.m_chapterVerse)
				{
					if (!gbIsGlossing)
					{
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									// IDS_GOTO_FAILED
									wxMessageBox(_(
"Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"),
									_T(""), wxICON_EXCLAMATION | wxOK);
									pApp->m_pTargetBox->SetFocus();
									pApp->LogUserAction(_T("Go To command failed. No valid location for the phrase box..."));
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}

					return;
				}
			}

			// not found, so try again, this time assuming we may have the wanted ch & verse
			// within a range in the text, such as 3-7, or 3,4 etc; or the verse may have been
			// set to zero so that only chapter numbers are to be considered
v:			pos = pList->GetFirst();
			wxASSERT(pos != NULL);
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);

				int chapter;
				int firstVerse;
				int lastVerse;
                // BW, Oct 04, extended the signature to take the nWantedVerse as an extra
                // parameter, so that when it is zero in value we can force a return once a
                // chapter beginning has been located; this extra parameter has no other
                // internal function in the AnalyseReference function, and since this
                // function is called in nearly a dozen other places, those places just
                // need an arbitrary non-zero number passed in for the nWantedVerse number
                // so as to retain the previous functionality unchanged
				bool bOK =
					AnalyseReference(pSrcPhrase->m_chapterVerse,chapter,firstVerse,
									lastVerse,nWantedVerse);

				// if we've already passed the chapter, return
				if (bOK && chapter > nWantedChapter)
					goto a;

				if (bOK && chapter == nWantedChapter && nWantedVerse == 0)
					goto f;

				if (bOK && chapter == nWantedChapter && (nWantedVerse >= firstVerse
					&& nWantedVerse <= lastVerse))
				{
f:					if (!gbIsGlossing)
					{
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									// IDS_GOTO_FAILED
									wxMessageBox(_(
"Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"),
									_T(""), wxICON_EXCLAMATION | wxOK);
									pApp->m_pTargetBox->SetFocus();
									pApp->LogUserAction(_T("Go To command failed. No valid location for the phrase box..."));
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}

					return;
				}

				if (bOK && chapter == nWantedChapter &&  nWantedVerse != 0
						&& lastVerse > nWantedVerse) // if passed the wanted verse
					goto a;
			}

			// not found, so tell the user
			//IDS_NO_SUCH_CHAPTER
a:			str = str.Format(_(
"Sorry, but the chapter and verse combination  %s  does not exist in this document. The command will be ignored."),
			dlg.m_chapterVerse.c_str());
			wxMessageBox(str,_T(""), wxICON_EXCLAMATION | wxOK);
			pApp->m_pTargetBox->SetFocus();
			pApp->LogUserAction(str);
			goto b;
		}
	}
	else
	{
        // user cancelled, so do nothing except remove the ref string that we stored above
        // (and most importantly, this will clear the m_bHasKBEntry on the source phrase
        // too)
b:		if (gbIsGlossing)
			pApp->m_pGlossingKB->GetAndRemoveRefString(pApp->m_pActivePile->GetSrcPhrase(),
												pApp->m_targetPhrase, useTargetPhraseForLookup);
		else
			pApp->m_pKB->GetAndRemoveRefString(pApp->m_pActivePile->GetSrcPhrase(),
												pApp->m_targetPhrase, useTargetPhraseForLookup);
	}
}

// BEW 10Apr10, no changes for support of doc version 5;
// returns FALSE only if there is no : in the chapter:verse string passed in string
bool CAdapt_ItView::AnalyseReference(wxString& chVerse,int& chapter,int& vFirst,
									 int& vLast,int nWantedVerse)
{
	int chap = -1;
	int firstVerse = -1;
	int lastVerse = -1;
	if (chVerse.IsEmpty())
		return FALSE; // premature exit, no chapter or verse on this srcPhrase
	wxString range;
	range.Empty();

	// first determine if there is a chapter number present
	int nFound = chVerse.Find(_T(':'));
	if (nFound < 0)
	{
		// no chapter number, so  set chapter to zero
		range = chVerse;
		chap = 0;
	}
	else
	{
		// chapter number exists, extract it and put the remainder after the colon into range
		wxString strChapter = SpanExcluding(chVerse,_T(":"));
#ifdef __WXMAC__
// Kludge because the atoi() function in the MacOS X standard library can't handle Arabic digits
		for (size_t imak=0; imak < strChapter.Len(); imak++)
		{
			wxChar imaCh = strChapter.GetChar(imak);
			if (imaCh >= (wchar_t)0x6f0 && imaCh <= (wchar_t)0x6f9)
				strChapter.SetChar(imak, imaCh & (wchar_t)0x3f);	// zero out the higher bits of these Arabic digits
		}
#endif /* __WXMAC__ */
		chap = wxAtoi(strChapter);

		nFound++; // index the first char after the colon
		range = chVerse.Mid(nFound);

		// if wanted verse is zero, then exit now since we have a chapter located
		if (nWantedVerse == 0)
		{
			chapter = chap;
			return TRUE;
		}
	}

	// potentially we have a range, so first see if it is a range specified by a hyphen separator
	nFound = range.Find(_T('-'));
	if (nFound >= 0)
	{
		// it is a range, find first & last verse numbers
		wxASSERT(nFound != 0); // must be an initial verse number
		wxString verseFirst = SpanExcluding(range,_T("-"));
		firstVerse = wxAtoi(verseFirst);
		nFound++;
		wxString verseLast = range.Mid(nFound);
		lastVerse = wxAtoi(verseLast);
	}
	else
	{
		// no hyphenated range, so try a comma-delimited range
		nFound = range.Find(_T(','));
		if (nFound < 0)
		{
			// its neither, so it's something unknown, so assume its just a single verse number
			firstVerse = lastVerse = wxAtoi(range);
			// from version 2.0.5 and onwards we allow verse numbers to have unlimited maximum
			// value
			chapter = chap;
			vFirst = firstVerse;
			vLast = lastVerse;
			return TRUE;
		}
		else
		{
            // it's a comma-delimited range, so get first and last verse numbers (assume
            // n,m structure) note: printing code will allow comma delimited ranges of form
            // n,m,o,p,q etc (see ExtractChapterAndVerse in ..view.cpp), so if the fact
            // that AnalyseReference permits only n,m ever becomes an issue for someone,
            // the copy the extra bit of code needed into the block below (actually, it may
            // be possible to get rid of the latter function and just use the Extract....
            // one.)
			wxASSERT(nFound != 0); // must be an initial verse number
			wxString verseFirst = SpanExcluding(range,_T(","));
			firstVerse = wxAtoi(verseFirst);
			nFound++;
			wxString verseLast = range.Mid(nFound);
			lastVerse = wxAtoi(verseLast);
		}
	}

	// return the values found
	chapter = chap;
	vFirst = firstVerse;
	vLast = lastVerse;
	return TRUE;
}

// while this appears to be coded for a forward jump only, actually it works equally well
// for arbitrary distance forward or backwards jumps
void CAdapt_ItView::Jump(CAdapt_ItApp* pApp, CSourcePhrase* pNewSrcPhrase)
{
	wxASSERT(pNewSrcPhrase);

	// jump to here
	int nNewSequNum = pNewSrcPhrase->m_nSequNumber;
	pApp->m_pActivePile = GetPile(nNewSequNum);
	CCell* pCell = pApp->m_pActivePile->GetCell(1); // the cell where the phraseBox is to be
	pApp->m_targetPhrase = pNewSrcPhrase->m_adaption; // make it look normal,
													  // don't use m_targetStr here
	PlacePhraseBox(pCell,2);
	pApp->GetMainFrame()->canvas->ScrollIntoView(nNewSequNum);

	// update status bar with project name
	pApp->RefreshStatusBarInfo();
	Invalidate();
	GetLayout()->PlaceBox();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If Vertical Editing is in progress, or the pointers
/// to the KBs are NULL or the bundle's m_nStripCount is not greater than zero, this
/// handler disables the "Go To..." item in the Edit menu, otherwise it enables the "Go
/// To..." item on the Edit menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateGoTo(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pKB != NULL && pApp->m_pGlossingKB != NULL &&
		GetLayout()->GetStripArray()->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// nNewSequNum is the index of the first srcPhrase in the new selection, nCount is how many
// srcPhrases are to be selected, and nSelectionLine is the 0-based line index to put the
// selection it - it can be any of the first two line indices in a strip (ie. 0 or 1)
// Called from CAdapt_ItView::DoFindNext() and CPhraseBox::DoCancelAndSelect().
// CPhraseBox::DoCancelAndSelect() requires that a RecalcLayout() call, and resetting of
// the active sequence number and active pile be done internally, but DoFindNext() doesn't
// require these calls because they are done further up in the call hierarchy - and in fact
// if done when a match is made for text in a retranslation, the active location would be
// set wrongly if done here. So we use the bDoRecalcLayout flag to suppress the unwanted
// code when used in the context of a Find operation.
// BEW added 2Aug09, the bDoRecalcLayout flag
// BEW 26Mar10 updated for support of doc version 5 (changes needed, and also did removal of a
// global boolean, gbUserWantsSelection which was default FALSE, throughout the app -- it
// made the logic unnecessarily convoluted here and elsewhere)
void CAdapt_ItView::MakeSelectionForFind(int nNewSequNum, int nCount, int nSelectionLine,
											bool bDoRecalcLayout)
{
	// refactored 17Apr09
	wxASSERT(nSelectionLine == 0);
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();
	wxASSERT(pApp != NULL);

	// BEW 26Mar10, added the second param to the test, this makes a match in a
	// retranslation automatically skip the recalc layout and placement
	if (bDoRecalcLayout)
	{
        // the above flag is never TRUE when this function is being called in association
        // with a Find Next operation; but since this function is also used for making a
        // selection when user hits the "Cancel And Select" button in CChooseTranslation
        // dialog when called from LookAhead(), the flag will be TRUE when that happens
        // BEW added 19Dec08: also we will use this function witht TRUE passed to create
        // the needed selection, along with a recalc of the layout, within the
        // RecreateCollectedBackTranslationsInVerticalEdit() function
		if (!pApp->m_bMatchedRetranslation)
			// don't put the active location at the match location if the match was in a
			// retranslation
			pApp->m_nActiveSequNum = nNewSequNum;

#ifdef _NEW_LAYOUT
		pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
		pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		pApp->GetMainFrame()->canvas->ScrollIntoView(nNewSequNum);
	}
	// get the cell which will show the selection
	CCell* pCell;
	if (pApp->m_bMatchedRetranslation)
	{
		// active pile is outside the retranslation, so the matched location will be the
		// first cell of the retranslation, but we must put the phrase box there - put it
		// at the previous CSourcePhrase, if it exists
		CPile* pFirstPileInRetrans = GetPile(nNewSequNum);
		pCell = pFirstPileInRetrans->GetCell(nSelectionLine);
		CPile* pPrevPile = GetPile( nNewSequNum - 1);
		if (pPrevPile != NULL)
		{
			pApp->m_pActivePile = pPrevPile;
			pApp->m_nActiveSequNum = nNewSequNum - 1;
		}
		else
		{
			// for no previous pile, we have to use the pFirstPileInRetrans one instead
			pApp->m_pActivePile = pFirstPileInRetrans;
			pApp->m_nActiveSequNum = nNewSequNum;

		}
	}
	else
	{
		// the new active location needs to be at the match location
		pApp->m_pActivePile = GetPile(nNewSequNum);
		pApp->m_nActiveSequNum = nNewSequNum;
		pCell = pApp->m_pActivePile->GetCell(nSelectionLine);
	}

    // make the selection; first, get rid of any old selection
	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context
	if (pApp->m_selection.GetCount() != 0)
	{
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		CCell* pOldSel;
		while (pos != NULL)
		{
			pOldSel = (CCell*)pos->GetData();
			pos = pos->GetNext();
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pOldSel->SetSelected(FALSE);
			pOldSel->DrawCell(&aDC,pOldSel->GetColor());
		}
		pApp->m_selection.Clear();
		pApp->m_selectionLine = -1; // no selection
		pApp->m_pAnchor = (CCell*)NULL;
	}

	// then do the new selection
	aDC.SetBackgroundMode(pApp->m_backgroundMode);
	aDC.SetTextBackground(wxColour(255,255,0));// yellow
	pApp->m_bSelectByArrowKey = FALSE;
	pCell->SetSelected(TRUE);
	pCell->DrawCell(&aDC, pCell->GetColor());

	// preserve record of the selection
	pApp->m_selection.Append(pCell);
	pApp->m_selectionLine = nSelectionLine;
	pApp->m_pAnchor = pCell;

	if (nCount > 1)
	{
		// extend the selection
		ExtendSelectionForFind(pCell,nCount);
	}
	else
	{
		// if not extending, we still need a Redraw() in order to get the highlighted
		// single cell shown selected
		GetLayout()->Redraw();
	}
	Invalidate();
	GetLayout()->PlaceBox();
}

// pAchorCell is pointer to the first cell in the selection, nCount is the number cells in
// the selection (there is always one in existence, the first, when this function is
// entered) Because the caller supports selections in src and phrase box line (either tgt
// or gloss), the pAnchorCell's m_nCell index value may be 0 or 1)
// BEW 26Mar10, no changes needed for support of doc version 5
void CAdapt_ItView::ExtendSelectionForFind(CCell* pAnchorCell, int nCount)
{
	// refactored 17Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context

	// local variables to use in the loops below
	CPile*	pCurPile; // the one we use in the loop
	//CStrip* pCurStrip; // the strip the starting pile is in // set but unused
	CCell*	pCurCell; // the current cell in the current pile (used in loop)
	//int nCurPileCount; // how many piles in current strip // set but unused
	//int nCurPile; // index of current pile (in loop) // set but unused
	//int nCurStrip; // index of current strip in which the current pile is located // set but unused
	CSourcePhrase* pCurSrcPhrase; // the current pile's source phrase pointer (in loop)

	// set the above local variables from pAnchorCell
	pCurPile = pAnchorCell->GetPile();
	//pCurStrip = pCurPile->GetStrip();
	//nCurPileCount = pCurStrip->GetPileCount();
	//nCurPile = pCurPile->GetPileIndex();
	//nCurStrip = pCurStrip->GetStripIndex();

	int nAnchorSequNum = pCurPile->GetSrcPhrase()->m_nSequNumber;
	int nEndSequNum = nAnchorSequNum + nCount - 1;
	wxASSERT(nEndSequNum > 0 && nEndSequNum <= pApp->GetMaxIndex());
	int sequ = nAnchorSequNum;
	while (sequ < nEndSequNum)
	{
		sequ++; // next one

		// get the next cell
		pCurPile = GetPile(sequ);
		wxASSERT(pCurPile != NULL);
		pCurSrcPhrase = pCurPile->GetSrcPhrase();
		wxASSERT(pCurSrcPhrase->m_nSequNumber == sequ); // must match
		pCurSrcPhrase = pCurSrcPhrase; // avoid warning
		pCurCell = pCurPile->GetCell(pApp->m_selectionLine); // get the cell...
					// Note: pApp->m_selectionLine might be 0 or 1, not just 0

		// if it is already selected then iterate to do next one, else select it
		if (!pCurCell->IsSelected())
		{
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			pCurCell->DrawCell(&aDC, pCurCell->GetColor());
			pCurCell->SetSelected(TRUE);

			// keep a record of it
			pApp->m_selection.Append(pCurCell);
		}
	}
}

// BEW 26Mar10, no changes needed for support of doc version 5
void CAdapt_ItView::OnFind(wxCommandEvent& event)
{
	// refactored 17Apr09
 	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
   // check that a Find & Replace dialog is not currently open, if it is, delete it
    // preserving contents of the src & tgt edit boxes
	wxString saveSrc;
	saveSrc.Empty();
	wxString saveTgt;
	saveTgt.Empty();
	pApp->LogUserAction(_T("Initiated OnFind()"));

	if (pApp->m_pFindDlg != NULL)
	{
		if (gbFind == FALSE)
		{
			pApp->m_pFindDlg->TransferDataFromWindow();
			saveSrc = pApp->m_pFindDlg->m_srcStr;
			saveTgt = pApp->m_pFindDlg->m_tgtStr;
			pApp->m_pFindDlg->Destroy();
			pApp->m_pFindDlg = NULL;
		}
	}
	gbFind = TRUE;
	gbJustReplaced = FALSE;

	// we must not be in 'show target only' mode,
	// so if so, switch back to normal view mode
	if (gbShowTargetOnly)
	{
		OnFromShowingTargetOnlyToShowingAll(event);
	}
	if (pApp->m_pFindDlg == NULL)
	{
		pApp->m_pFindDlg = new CFindDlg(pApp->GetMainFrame());

		// set default parameter values
		pApp->m_pFindDlg->m_srcStr = saveSrc;
		pApp->m_pFindDlg->m_tgtStr = saveTgt;
		pApp->m_pFindDlg->m_replaceStr.Empty();
		pApp->m_pFindDlg->m_marker = 0;
		pApp->m_pFindDlg->m_markerStr.Empty();
		pApp->m_pFindDlg->m_sfm.Empty();
		pApp->m_pFindDlg->m_bFindRetranslation = FALSE;
		pApp->m_pFindDlg->m_bFindNullSrcPhrase = FALSE;
		pApp->m_pFindDlg->m_bFindSFM = FALSE;
		pApp->m_pFindDlg->m_bSrcOnly = TRUE;
		pApp->m_pFindDlg->m_bTgtOnly = FALSE;
		pApp->m_pFindDlg->m_bSrcAndTgt = FALSE;
		pApp->m_pFindDlg->m_bSpecialSearch = FALSE;
		pApp->m_pFindDlg->m_bFindDlg = TRUE;
		pApp->m_pFindDlg->m_bSpanSrcPhrases = FALSE;
		pApp->m_pFindDlg->m_bIncludePunct = FALSE;
		pApp->m_pFindDlg->m_bIgnoreCase = FALSE;
		pApp->m_pFindDlg->TransferDataToWindow();

		pApp->m_pFindDlg->Centre(); // this sets the horizontal pos,
				// AdjustDialogPosition below overrides the vertical one
		AdjustDialogPosition(pApp->m_pFindDlg);
		pApp->m_pFindDlg->Show(TRUE);
		gbFindOrReplaceCurrent = TRUE;
	}
	else
	{
		// set default parameter values
		pApp->m_pFindDlg->m_srcStr = saveSrc;
		pApp->m_pFindDlg->m_tgtStr = saveTgt;
		pApp->m_pFindDlg->m_replaceStr.Empty();
		pApp->m_pFindDlg->m_marker = 0;
		pApp->m_pFindDlg->m_markerStr.Empty();
		pApp->m_pFindDlg->m_sfm.Empty();
		pApp->m_pFindDlg->m_bFindRetranslation = FALSE;
		pApp->m_pFindDlg->m_bFindNullSrcPhrase = FALSE;
		pApp->m_pFindDlg->m_bFindSFM = FALSE;
		pApp->m_pFindDlg->m_bSrcOnly = TRUE;
		pApp->m_pFindDlg->m_bTgtOnly = FALSE;
		pApp->m_pFindDlg->m_bSrcAndTgt = FALSE;
		pApp->m_pFindDlg->m_bSpecialSearch = FALSE;
		pApp->m_pFindDlg->m_bFindDlg = TRUE;
		pApp->m_pFindDlg->m_bSpanSrcPhrases = FALSE;
		pApp->m_pFindDlg->m_bIncludePunct = FALSE;
		pApp->m_pFindDlg->m_bIgnoreCase = FALSE;
		pApp->m_pFindDlg->TransferDataToWindow();

		pApp->m_pFindDlg->Centre(); // this sets the horizontal pos,
				// AdjustDialogPosition below overrides the vertical one
		AdjustDialogPosition(pApp->m_pFindDlg);
		pApp->m_pFindDlg->Show(TRUE);
		gbFindOrReplaceCurrent = TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// This handler disables the "Find..." item in the Tools menu if Vertical Editing is in
/// progress, or if the application is in Free Translation mode, or if there are no source
/// phrases in the App's m_pSourcePhrases list. Otherwise it enables the "Find..." item on
/// the Tools menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFind(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::AdjustDialogPosition(wxDialog* pDlg)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();
	wxASSERT(pApp != NULL);
	// place the dialog window so as not to obscure things
	// work out where to place the dialog window
	int nTwoLineDepth = 2 * pLayout->GetTgtTextHeight();
	wxPoint ptBoxTopLeft = pApp->m_pActivePile->GetCell(1)->GetTopLeft();
	wxRect rectScreen;

    // The wxWidgets docs say, "::wxClientDisplayRect() method returns the dimensions of
    // the work area on the display. On Windows this means the area not covered by the
    // taskbar, etc. Other platforms are currently defaulting to the whole display until a
    // way is found to provide this info for all window managers, etc."
    // Note: All calls that have no wxDC as a parameter deal in display device/pixels, and
    // MM_TEXT mapping mode, never in logical coordinates (or other mapping modes).
	int displayX;
	int displayY;
	int displayWidth;
	int displayHeight;
	::wxClientDisplayRect(&displayX,&displayY,&displayWidth,&displayHeight);
	// units for returned values from next call are in screen/device coords (pixels)
	rectScreen = wxRect(displayX,displayY,displayWidth,displayHeight);
	wxClientDC dc(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(dc); //OnPrepareDC(&dc); // adjust origin

	// CalcScrolledPosition translates logical coordinates to device ones
	int newXPos, newYPos;
	pApp->GetMainFrame()->canvas->CalcScrolledPosition(ptBoxTopLeft.x,
										ptBoxTopLeft.y,&newXPos,&newYPos);
	ptBoxTopLeft.x = newXPos;
	ptBoxTopLeft.y = newYPos;

    // In the ClientToScreen call below the x and y coords are adjusted; in wxRect the
    // width and height remain unchanged, i.e., the rectangle retains the same size
    // dimensions, but the x and y coords change from (0,0) to a new (x,y) position for
    // the rectangle in relation to screen coords.
	pApp->GetMainFrame()->canvas->ClientToScreen(&ptBoxTopLeft.x,&ptBoxTopLeft.y);

	int height = nTwoLineDepth;
	int dlgWidth;
	int dlgHeight;
	wxASSERT(pDlg != NULL);
    // whm - for the dialog we should use GetSize, rather than GetClientSize as we want to
    // include the whole window
	pDlg->Centre(); // start with centered as default (for horizontal position especially)
	pDlg->GetSize(&dlgWidth,&dlgHeight); // dialog's window; gets the width and height in pixels
	wxASSERT(dlgHeight > 0);
    // wx note: displayWidth determined above (takes place of rectScreen.right -
    // rectScreen.left) below: because the actual width (before items are hidden) is much
    // greater than the displayed width, the following calculations place the dialog much
    // left of center. We won't bother setting the horizontal position.
	if (ptBoxTopLeft.y + height < rectScreen.GetBottom() - 50 - dlgHeight)
	{
        // put dlg near the bottom of screen, or 30 pixels under the box's strip Roland
        // Fumey is reporting the Choose Translation dialog being shown above the client
        // area and so invisible, so my fix for 2.4.1f did not work, so try do something
        // here and send to Roland for evaluation (BEW changed, 12Jul05)
		int topAdjusted = wxMin(ptBoxTopLeft.y + height + 30,
								rectScreen.GetBottom()-dlgHeight-80);
		if (topAdjusted < rectScreen.GetTop())
			topAdjusted = rectScreen.GetBottom() - dlgHeight - 80;
		// WX Note: We'll use the wxWindow::SetSize() method
		pDlg->SetSize( // set size in device/screen pixels
			-1, //left,
			topAdjusted,
			wxDefaultCoord, //300, // width, dummy value overridden by wxSIZE_USE_EXISTING below
			wxDefaultCoord, //200, // height, ditto
			wxSIZE_USE_EXISTING);
	}
	else
	{
        // put dlg near the top of the screen, or if possible, 60 pixels above the strip
        // (version 2.4.0 altered this below from max(ptBoxTopLeft.y - dlgHeight - height -
        // 60, rectScreen.top+40) so that now we put the box 2 pixels down from the top of
        // the screen, to minimize the need to scroll or move the box because it may be
        // obscuring some of the automatically inserted text); BEW altered 09Sep05 for it
        // to be 100 pixels down from the screen top - even if it sometimes obscures some
        // inserted text, it is better to have a reasonable chance of not obscuring the
        // command bar buttons
		pDlg->SetSize(
			-1, //left,
			rectScreen.GetTop()+100,
			wxDefaultCoord, //300, // width, dummy value overridden by wxSIZE_USE_EXISTING below
			wxDefaultCoord, //200, // height, ditto
			wxSIZE_USE_EXISTING);
	}
	pDlg->Update();
}

void CAdapt_ItView::SetWhichBookPosition(wxDialog* pDlg)
{
	// WX NOTE: This is used only in WhichBook.cpp's InitDialog()
	int xPos,yPos;
	pDlg->GetPosition(&xPos,&yPos); // whatever position the OS assigns to it by default
	pDlg->Move(xPos,200); // use the xPos but move it down 200 pixels from top

	pDlg->Update();
}

void CAdapt_ItView::AdjustDialogPositionByClick(wxDialog* pDlg,wxPoint ptClick)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();

    // place the dialog window so as not to obscure things work out where to place the
    // dialog window; the passed in ptClick value comes from the saved point value for the
    // user's click in the client area of the view, and the coords for that point will be
    // device coords (ie. relative to top left of the client area of the view)

	// first calculate the height of two target text lines
	int height = 2 * pLayout->GetTgtTextHeight();

	// get the size of the screen - use screen coords
	wxRect rectScreen;
    // wx note: According to wx docs, wxGetClientDisplayRect() "returns the dimensions of
    // the work area on the display. On Windows this means the area not covered by the
    // taskbar, etc. Other platforms are currently defaulting to the whole display until a
    // way is found to provide this info for all window managers, etc."
	rectScreen = wxGetClientDisplayRect();

	// we need to know where the view's client rect is located, in screen coords
	wxRect rectView;
    // wx note: calling GetClientSize on the canvas produced different results in wxGTK and
    // wxMSW, so I'll use my own GetCanvasClientSize() which calculates it from the main
    // frame's client size.
	wxSize canvasSize;
	canvasSize = pApp->GetMainFrame()->GetCanvasClientSize();
	rectView.width = canvasSize.x;
	rectView.height = canvasSize.y;

    // In the ClientToScreen call below the x and y coords are adjusted; in wxRect the
    // width and height remain unchanged, i.e., the rectangle retains the same size
    // dimensions, but the x and y coords change from (0,0) to a new (x,y) position for
    // the rectangle in relation to screen coords.
	pApp->GetMainFrame()->canvas->ClientToScreen(&rectView.x,&rectView.y);

	// we need to know the location and size of the dialog which is to have
	// its location adjusted
	wxRect rectDlg;
	pDlg->GetClientSize(&rectDlg.width,&rectDlg.height); // dialog's window
	rectDlg = NormalizeRect(rectDlg); // use our own from helpers.h
	int dlgHeight = rectDlg.GetHeight();
	int dlgWidth = rectDlg.GetWidth();
	wxASSERT(dlgHeight > 0);

    // determine how far from the left of the screen we will make the left side of the
    // dialog be so it is centered
	int left = (rectScreen.GetWidth() - dlgWidth)/2;

    // put it above the click if there is enough screen real estate to fit it between the
    // command bar and a 1.5 linepair height values above the click's y coordinate; else
    // put it near the screen bottom, making sure it clears the status bar
	if (dlgHeight + ((height * 3) / 2) < ptClick.y)
	{
		pDlg->SetSize(left,rectView.GetTop() + 5,300,200,wxSIZE_USE_EXISTING);
	}
	else
	{
		pDlg->SetSize(left,rectScreen.GetBottom() - dlgHeight - 80,300,200,wxSIZE_USE_EXISTING);
	}
	pDlg->Update();
}

void CAdapt_ItView::OnReplace(wxCommandEvent& event)
{
	// refactored 17Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	if (event.GetId() == wxID_REPLACE)
	{
		pApp->LogUserAction(_T("Initiated OnReplace()"));
	}
	//CLayout* pLayout = GetLayout();
	// check that a Find dialog is not currently open, if it is, delete it
	// preserving contents of the src & tgt edit boxes
	wxString saveSrc;
	saveSrc.Empty();
	wxString saveTgt;
	saveTgt.Empty();

	if (pApp->m_pReplaceDlg != NULL)
	{
		if (gbFind == TRUE)
		{
			pApp->m_pReplaceDlg->TransferDataFromWindow();
			saveSrc = pApp->m_pReplaceDlg->m_srcStr;
			saveTgt = pApp->m_pReplaceDlg->m_tgtStr;
			pApp->m_pReplaceDlg->Destroy();
			pApp->m_pReplaceDlg = NULL;
		}
	}

	gbFind = FALSE; // make dialog appearance be for Find & Replace
	gbJustReplaced = FALSE;

	// we must not be in 'show target only' mode, so if so, switch back to normal view mode
	if (gbShowTargetOnly)
	{
		OnFromShowingTargetOnlyToShowingAll(event);
	}

	if (pApp->m_pReplaceDlg == NULL)
	{
		pApp->m_pReplaceDlg = new CReplaceDlg(pApp->GetMainFrame());

		gbJustReplaced = FALSE;

		// set default parameter values
		pApp->m_pReplaceDlg->m_srcStr = saveSrc;
		pApp->m_pReplaceDlg->m_tgtStr = saveTgt;
		pApp->m_pReplaceDlg->m_replaceStr.Empty();
		pApp->m_pReplaceDlg->m_markerStr.Empty();
		pApp->m_pReplaceDlg->m_sfm.Empty();
		pApp->m_pReplaceDlg->m_bSrcOnly = FALSE;
		pApp->m_pReplaceDlg->m_bTgtOnly = TRUE;
		pApp->m_pReplaceDlg->m_bSrcAndTgt = FALSE;
		pApp->m_pReplaceDlg->m_bFindDlg = FALSE;
		pApp->m_pReplaceDlg->m_bSpanSrcPhrases = FALSE;
		pApp->m_pReplaceDlg->m_bIncludePunct = FALSE;
		pApp->m_pReplaceDlg->m_bIgnoreCase = FALSE;
		pApp->m_pReplaceDlg->TransferDataToWindow();

		pApp->m_pReplaceDlg->Centre(); // this sets the horizontal pos,
				// AdjustDialogPosition below overrides the vertical one
		AdjustDialogPosition(pApp->m_pReplaceDlg);
		pApp->m_pReplaceDlg->Show(TRUE);
		gbFindOrReplaceCurrent = TRUE;
	}
	else
	{
		if (pApp->m_pReplaceDlg != NULL)
		{
			AdjustDialogPosition(pApp->m_pReplaceDlg);
			pApp->m_pReplaceDlg->Show(TRUE);
			gbFindOrReplaceCurrent = TRUE;
		}
		else
		{
			// wx doesn't need to call Create
			gbJustReplaced = FALSE;

			// set default parameter values
			pApp->m_pReplaceDlg->m_srcStr = saveSrc;
			pApp->m_pReplaceDlg->m_tgtStr = saveTgt;
			pApp->m_pReplaceDlg->m_replaceStr.Empty();
			pApp->m_pReplaceDlg->m_markerStr.Empty();
			pApp->m_pReplaceDlg->m_sfm.Empty();
			pApp->m_pReplaceDlg->m_bSrcOnly = FALSE;
			pApp->m_pReplaceDlg->m_bTgtOnly = TRUE;
			pApp->m_pReplaceDlg->m_bSrcAndTgt = FALSE;
			pApp->m_pReplaceDlg->m_bFindDlg = FALSE;
			pApp->m_pReplaceDlg->m_bSpanSrcPhrases = FALSE;
			pApp->m_pReplaceDlg->m_bIncludePunct = FALSE;
			pApp->m_pReplaceDlg->m_bIgnoreCase = FALSE;
			pApp->m_pReplaceDlg->TransferDataToWindow();

			pApp->m_pReplaceDlg->Centre(); // this sets the horizontal position,
						// AdjustDialogPosition() below sets vertical position
			AdjustDialogPosition(pApp->m_pReplaceDlg);
			pApp->m_pReplaceDlg->Show(TRUE);
			gbFindOrReplaceCurrent = TRUE;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. This handler disables the "Find And Replace..." item
/// in the Tools menu if Vertical Editing is in progress, or if the application is in Free
/// Translation mode, or if there are no source phrases in the App's m_pSourcePhrases list.
/// Otherwise it enables the "Find And Replace..." item on the Tools menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateReplace(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	// whm added 26Mar12. Disable the Find and Replace menu item when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// All parameters relevant when glossing is OFF. When glossing is ON, the following
// applies: bIncludePunct and bSpanSrcPhrases will be FALSE, since the checkboxes
// for those flags are hidden; tgt parameter will hold, if relevant, text to be searched
// for in the m_gloss line; and nCount should never be anything except 1 when glossing.
// BEW 26Mar10, some changes needed for support of doc version 5
bool CAdapt_ItView::DoFindNext(int nCurSequNum, bool bIncludePunct, bool bSpanSrcPhrases,
						bool bSpecialSearch,bool bSrcOnly, bool bTgtOnly,
						bool bSrcAndTgt, bool bFindRetranslation, bool bFindNullSrcPhrase,
						bool bFindSFM, wxString& src, wxString& tgt, wxString& sfm,
						bool bIgnoreCase, int& nSequNum, int& nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbIsGlossing)
	{
		wxASSERT(nCount == 1);;
	}
	wxASSERT(!(nCurSequNum > pApp->GetMaxIndex()));
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);

    // if the targetBox is visible, store the contents in KB since we will advance the
    // active location to the pile having the text matched in the source phrase; and even
    // if there is no match, we want to do the save to KB before any bundle advances,
    // otherwise the old active location's pointer will be garbage & we'll crash if we try
    // to use it
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_pTargetBox->IsShown())
		{
			if (!gbIsGlossing)
				MakeTargetStringIncludingPunctuation(pApp->m_pActivePile->GetSrcPhrase(),pApp->m_targetPhrase);
			if (!gbIsGlossing)
				RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);

			// the store will fail if the user edited the entry out of the KB, as the latter
			// cannot know which srcPhrases will be affected, so these will still have their
			// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString but
			// the above flag TRUE is a sufficient test, and if so, set the flag to FALSE
			// BEW modified 17Jul11 to use KB_Entry enum as the return value...
			CRefString* pRefStr = NULL;
			KB_Entry rsEntry;
			bool bOK;
			if (gbIsGlossing)
			{
				rsEntry = pApp->m_pGlossingKB->GetRefString(pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
							pApp->m_pActivePile->GetSrcPhrase()->m_key, pApp->m_targetPhrase, pRefStr);
				if ((pRefStr == NULL || rsEntry == present_but_deleted) &&
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
				{
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
				}
				// now do the store
				bOK = pApp->m_pGlossingKB->StoreText(pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_targetPhrase);
			}
			else
			{
				rsEntry = pApp->m_pKB->GetRefString(pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
							pApp->m_pActivePile->GetSrcPhrase()->m_key, pApp->m_targetPhrase, pRefStr);
				if ((pRefStr == NULL || rsEntry == present_but_deleted) &&
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
				{
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
				}
				// now do the store
				gbInhibitMakeTargetStringCall = TRUE;
				bOK = pApp->m_pKB->StoreText(pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_targetPhrase);
				gbInhibitMakeTargetStringCall = FALSE;
			}
			bOK = bOK; // avoid warning
			// now get rid of the phrase box, until we need it again
			pApp->m_pTargetBox->Hide();
			pApp->m_pTargetBox->ChangeValue(_T("")); // need to set it to null str
													 // since it won't get recreated
			pApp->m_targetPhrase.Empty(); // the box will move on, so this old
										  // location is now invalid
		}
	}

	if (nCurSequNum == pApp->GetMaxIndex() || nCurSequNum == -1)
		return FALSE; // we are at the end, so cannot search further
					  // (we won't wrap the search)
	if (bSpecialSearch)
	{
		bool bFound;

		// a special search is wanted
		if (bFindRetranslation)
		{
			bFound = pApp->GetRetranslation()->DoFindRetranslation(nCurSequNum+1,nSequNum,nCount);
		}
		else if (bFindNullSrcPhrase)
		{
			bFound = DoFindNullSrcPhrase(nCurSequNum+1,nSequNum,nCount);
		}
		else
		{
			// must want to find a standard format marker
			if (bFindSFM != TRUE)
			{
				::wxBell();
				wxASSERT(FALSE);
			}
			// the following function had changes for support of doc version 5
			bFound = DoFindSFM(sfm,nCurSequNum+1,nSequNum,nCount);
		}
		if (!bFound)
		{
			// clear the globals
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			::wxBell(); // alert user there was no match
			Invalidate();
			GetLayout()->PlaceBox();
			return FALSE;
		}
		else
		{
			if (gbIsGlossing)
			{
				wxASSERT(nCount == 1);
			}
			// BEW changed 3Aug09 to always have the selection display be on the source
			// text line for Find Next - this makes the interface more consistent
			int nSelLineIndex = 0;

			// make the appropriate selection... recalc of layout not wanted yet (that's
			// the meaning of FALSE param in the call), MakeSelectionForFind()
			// automatically refrains from putting the active location at the match point
			// if the app boolean flag m_bMatchedRetranslation is TRUE
			MakeSelectionForFind(nSequNum,nCount,nSelLineIndex, FALSE);

			// update the active sequ number, only if not matching text in a pile of a
			// retranslation (because we can't put the phrase box at such a pile)
			if (!pApp->m_bMatchedRetranslation)
				pApp->m_nActiveSequNum = nSequNum;
			return TRUE;
		}
	}
	else
	{
		// not a special search, just a normal one
		bool bFound;
		//bool bInSrc = TRUE; // set but not used

        // if we previously matched a retranslation, we have to advance to its end before
        // we can continue searching for a new match; but if glossing is ON, retranslations
        // are irrelevant, so we would skip the block in that case
		if (!gbIsGlossing && pApp->m_bMatchedRetranslation)
		{
			wxASSERT(gnRetransEndSequNum >= 0);
			nCurSequNum = gnRetransEndSequNum;
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
		}

		// a normal type of search is wanted & the following functions search in
		// m_pSourcePhrases list
		if (bSrcOnly)
		{
			// search only in m_srcPhrase field or m_key field, depending on bIncludePunct
			// flag value
			bFound = DoSrcOnlyFind(nCurSequNum+1,bIncludePunct,bSpanSrcPhrases,src,
									bIgnoreCase,nSequNum,nCount);
		}
		else if (bTgtOnly)
		{
			// search only in m_targetStr field or m_adaption field
			bFound = DoTgtOnlyFind(nCurSequNum+1,bIncludePunct,bSpanSrcPhrases,tgt,
									bIgnoreCase,nSequNum,nCount);
			//bInSrc = FALSE;
		}
		else
		{
			// search both m_srcPhrase and m_targetStr fields, trying to match both
			if (bSrcAndTgt != TRUE)
			{
				::wxBell();
				wxASSERT(FALSE);
			}
			bFound = DoSrcAndTgtFind(nCurSequNum+1,bIncludePunct,bSpanSrcPhrases,src,tgt,
									bIgnoreCase,nSequNum,nCount);
			//bInSrc = FALSE;
		}
		if (!bFound)
		{
			// clear the globals
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			::wxBell(); // alert user there was no match
			Invalidate();
			GetLayout()->PlaceBox();
			return FALSE;
		}
		else
		{
			// found a matching string, in the srcPhrase with sequ num nSequNum
			FindNextHasLanded(nSequNum); // bSuppressSelectionExtention is default TRUE
										 // because SelectFoundSrcPhrases() will do it
			if (gbIsGlossing)
			{
				wxASSERT(nCount == 1);
			}
			// BEW changed 3Aug09 to always have the selection display be on the source
			// text line for Find Next - this makes the interface more consistent
			int nSelLineIndex = 0;

			// make the appropriate selection... recalc of layout not wanted yet (that's
			// the meaning of FALSE param in the call), MakeSelectionForFind()
			// automatically refrains from putting the active location at the match point
			// if the app boolean flag m_bMatchedRetranslation is TRUE
			MakeSelectionForFind(nSequNum,nCount,nSelLineIndex, FALSE);

			// update the active sequ number, only if not matching text in a pile of a
			// retranslation (because we can't put the phrase box at such a pile)
			if (!pApp->m_bMatchedRetranslation)
				pApp->m_nActiveSequNum = nSequNum;
			return TRUE;
		}
	}
}


// finds only those null src phases (ie. placeholders) which are not within a retranslation
// for padding purposes; the search is also allowed when glossing is ON
// BEW 26Mar10, no changes needed for support of doc version 5
bool CAdapt_ItView::DoFindNullSrcPhrase(int nStartSequNum, int& nSequNum, int& nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;

	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bNullSourcePhrase && !pSrcPhrase->m_bRetranslation)
		{
			// we found a null source phrase (exclude those which may be in a retranslation)
			nSequNum = sn;
			nCount = 1;
			return TRUE;
		}
		else
		{
			sn++; // index for next CSourcePhrase instance to be searched
		}
	}

	// if we get here, we didn't find a match
	return FALSE;
}

// BEW 26Mar10, no changes needed for support of doc version 5
bool CAdapt_ItView::IsSameMarker(int str1Len, int nFirstChar, const wxString& str1,
								 const wxString& testStr)
{
	wxASSERT(str1.Length() > 1);
	wxString extracted = testStr.Mid(nFirstChar,str1Len);

    // if the testStr has a marker which has the str1 marker in it as a substring, we have
    // to extend the "extracted" string, otherwise we will end up returning a TRUE value
    // incorrectly
	int nNext = nFirstChar + str1Len;
	int totalLen = testStr.Length();

	wxChar c;
    // while we are not beyond the textStr bounds, and the character at the nNext offset is
    // not a space character, add the next character to the extracted marker stub, and
    // iterate until the whole marker is built
	while ( nNext < totalLen && (c = testStr.GetChar(nNext)) != _T(' '))
	{
		extracted += c;
		nNext++;
	}

	if ((int)extracted.Length() < str1Len)
		return FALSE; // can't be the same, since it's shorter
	return (extracted == str1);
}

// we allow this search when glossing or when adapting
// BEW 26Mar10, some changes needed for support of doc version 5
bool CAdapt_ItView::DoFindSFM(wxString& sfm, int nStartSequNum, int& nSequNum, int& nCount)
{
	// nCount just returns how many were found, this is a bit of a white elephant as we
	// only ever find one instance at a time, so just return 1
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int len = sfm.Length();
	wxString freeTransMkr = _T("\\free");
	wxString noteMkr = _T("\\note");
	wxString backTransMkr = _T("\\bt");

	int nFound = -1; // assume not found
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);

		// For doc version 5, we don't actually have \free, \free*, \note, \note*, nor \bt
		// markers actually stored with the content of free translations, notes, or
		// collected back translations. The list which the user saw lists the \free,
		// \note, and \bt as findable markers - but the list was populated from
		// AI_USFM.xml, and we are keeping our custom markers in that file. We'll trick
		// the user - he or she doesn't need to know that in the data model for version
		// these data types are stored in wxString members with name m_freeTrans, m_note,
		// and m_collectedBackTrans, and hence our GUI stuff will show the markers, but
		// our search will actually check for non-empty member strings as above. Also, our
		// filtered markers are now stored in m_filteredInfo, not m_markers, and so we'll
		// also have to search in there too. We'll do these searches before we hand over
		// to the legacy code which just checks the m_markers member. (When checking the
		// wxString members for non-empty content, we don't need to make the call to
		// IsSameMarker(), as there is no possibility of a spurious 'find'.)
		if (sfm == freeTransMkr)
		{
			if (!pSrcPhrase->GetFreeTrans().IsEmpty())
			{
#ifdef _DEBUG
#ifdef FINDNXT
				//wxLogDebug(_T("Found free translation: at sn = %d  word is:  %s"),sn,pSrcPhrase->m_srcPhrase);
#endif
#endif
				// found location where a free translation commences
				nSequNum = sn;
				nCount = 1;
				return TRUE;
			}
		}
		if (sfm == noteMkr)
		{
			if (!pSrcPhrase->GetNote().IsEmpty())
			{
				// found location where a note is stored
#ifdef _DEBUG
#ifdef FINDNXT
				//wxLogDebug(_T("Found note: at sn = %d  word is:  %s"),sn,pSrcPhrase->m_srcPhrase);
#endif
#endif
				nSequNum = sn;
				nCount = 1;
				return TRUE;
			}
		}
		wxString filteredInfo = pSrcPhrase->GetFilteredInfo();
		if (sfm == backTransMkr)
		{
			if (!pSrcPhrase->GetCollectedBackTrans().IsEmpty())
			{
#ifdef _DEBUG
#ifdef FINDNXT
				//wxLogDebug(_T("Found back trans: at sn = %d  word is:  %s"),sn,pSrcPhrase->m_srcPhrase);
#endif
#endif
				// found location where a collected back translation is stored
				nSequNum = sn;
				nCount = 1;
				return TRUE;
			}
			else
			{
				// We have to search also for a \bt-derived marker - any of these would be
				// stored in the m_filteredInfo member, each wrapped with \~FILTER and
				// \~FILTER* filter markers. So we'll have to search.
				if (!filteredInfo.IsEmpty())
				{
					nFound = filteredInfo.Find(sfm); // we search just for \bt because we
													 // don't know what the inventory of
													 // such custom markers might be - eg.
													 // \btv \bth and so forth
					if (nFound >= 0)
					{
#ifdef _DEBUG
#ifdef FINDNXT
						//wxLogDebug(_T("Found bt-derived marker in m_filteredInfo: at sn = %d  word is:  %s"),sn,pSrcPhrase->m_srcPhrase);
#endif
#endif
						// we'll make the reasonable assumption that the marker will not
						// be in any content string for some other marker, and so not try
						// test for this - we just assume we've found one
						nSequNum = sn;
						nCount = 1;
						return TRUE;
					}
				}
			}
		}
		else
		{
            // if control gets to here, we know we have not located a \free, \note, \bt nor
            // \bt-derived marker, so all that remains is to check any other marker passed
            // in. We must here check if the passed in marker occurs in the filteredInfo
            // string. If it does, we handle it like the legacy code below (ie. call
            // IsSameMarker() etc), but if we don't match anything, then only m_markers
            // remains to be checked, and we can leave that for the legacy code further
            // below
			if (!filteredInfo.IsEmpty())
			{
				nFound = filteredInfo.Find(sfm);
				if (nFound >= 0)
				{
                    // we can assume m_filteredInfo does not have two markers one of which
                    // is a substring of the other (if that was the case, and the longer
                    // was first and we were looking for the shorter, we'd never find the
                    // shorter one with the following code)
					bool bSame = IsSameMarker(len,nFound,sfm,filteredInfo);
					if (bSame)
					{
#ifdef _DEBUG
#ifdef FINDNXT
						//wxLogDebug(_T("Found chosen filterable marker in m_filteredInfo: at sn = %d  word is:  %s"),sn,pSrcPhrase->m_srcPhrase);
#endif
#endif
						// we found a matching standard format marker
						nSequNum = sn;
						nCount = 1;
						return TRUE;
					}
				}
			}
		}

		// this is the legacy code, before doc version 5; if control reaches here, no
		// target marker has been matched yet, so we check for it in m_markers
		nFound = pSrcPhrase->m_markers.Find(sfm); // nFound is index of first
												  // char of matched str
		if (nFound >= 0)
		{
            // we can assume m_markers does not have two markers one of which is a
            // substring of the other (if that was the case, and the longer was first and
            // we were looking for the shorter, we'd never find the shorter one with the
            // following code)
			bool bSame = IsSameMarker(len,nFound,sfm,pSrcPhrase->m_markers);
			if (!bSame)
			{
				nFound = -1;
				goto b;
			}
			else
			{
#ifdef _DEBUG
#ifdef FINDNXT
				//wxLogDebug(_T("Found the chosen marker in m_markers: at sn = %d  word is:  %s"),sn,pSrcPhrase->m_srcPhrase);
#endif
#endif
				// we found a matching standard format marker in m_markers
				nSequNum = sn;
				nCount = 1;
				return TRUE;
			}
		}
		else
		{
b:			if (pSrcPhrase->m_nSrcWords > 1)
			{
				// there could be medial markers in the phrase, so check it out
				if (!pSrcPhrase->m_pMedialMarkers->IsEmpty())
				{
					wxArrayString* pSL = pSrcPhrase->m_pMedialMarkers;
					int ct;
					for (ct = 0; ct < (int)pSL->GetCount(); ct++)
					{
						wxString markers = pSL->Item(ct);
						nFound = markers.Find(sfm);
						if (nFound >= 0)
						{
							bool bSame = IsSameMarker(len,nFound,sfm,markers);
							if (bSame)
							{
#ifdef _DEBUG
#ifdef FINDNXT
								//wxLogDebug(_T("Found the marker among medial markers: at sn = %d  word is:  %s"),sn,pSrcPhrase->m_srcPhrase);
#endif
#endif
								// we found a matching standard format marker,in the
								// stored medial markers for a merger
								nSequNum = sn;
								nCount = 1;
								return TRUE;
							}
							else
							{
								nFound = -1;
							}
						}
					}
				}
			}
		} // end else block for last nFound >= 0 test
		sn++; // increment index for next CSourcePhrase instance to be searched
	} // end of loop

	// if we get here, we didn't find a match
	return FALSE;
}

void CAdapt_ItView::DeleteTempList(SPList* pList)
{
	// BEW refactor 13Mar09, do nothing here, these are temporary incomplete ones,
	// no partner piles
	SPList::Node* p;
	if (pList->IsEmpty())
	{
		if (pList != NULL) // whm 11Jun12 added NULL test
			delete pList;
		pList = (SPList*)NULL;
		return;
	}
	p = pList->GetFirst();
	while (p != 0)
	{
		CSourcePhrase* pSP = (CSourcePhrase*)p->GetData();
		p = p->GetNext();
		if (pSP->m_pMedialMarkers != NULL) // whm 11Jun12 added NULL test
			delete pSP->m_pMedialMarkers;
		pSP->m_pMedialMarkers = (wxArrayString*)NULL;
		if (pSP->m_pMedialPuncts != NULL) // whm 11Jun12 added NULL test
			delete pSP->m_pMedialPuncts;
		pSP->m_pMedialPuncts = (wxArrayString*)NULL;
		if (pSP->m_pSavedWords != NULL) // whm 11Jun12 added NULL test
			delete pSP->m_pSavedWords;
		pSP->m_pSavedWords = (SPList*)NULL;
		if (pSP != NULL) // whm 11Jun12 added NULL test
			delete pSP;
		pSP = (CSourcePhrase*)NULL;
	}
	pList->Clear();
	if (pList != NULL) // whm 11Jun12 added NULL test
		delete pList;
	pList = (SPList*)NULL;
}

// when IsMatchedToEnd is called, it will be the case that we are trying to match less than
// the whole of the user's typed search string, and we will be doing the test for the match
// only in the text supplied from the first source phrase of a potential multi-sourcePhrase
// match. In the first srcPhrse, we have no way of knowing how many of the user's first
// typed words will be able to match, so we have to test all possibilities - in the caller,
// an nIteration variable keeps track of which attempt we are making, each iteration tests
// a string one word shorter than the one tested earlier in the last call to
// IsMatchedToEnd(). However, any match within IsMatchedToEnd is not valid unless the last
// matched character is also the very last character of the strTarget string. The reason
// for this is that since there is more to be matched in a later sourcePhrase, we cannot
// allow a discontinuity between what is matched in the current one, and any potential
// match in the next one. So IsMatchedToEnd looks specifically for a match which is
// coextensive with the end of the strTarget string; returns the offset to the first
// matched character if it finds such a match, or -1 otherwise (mimicking CString's Find()
// function)
// BEW 26Mar10, no changes needed for support of doc version 5
int CAdapt_ItView::IsMatchedToEnd(wxString& strSearch, wxString& strTarget)
{
	int nTargetLen = strTarget.Length();
	int nSearchLen = strSearch.Length();
	int nFirstChar = -1;
	int nStart = 0;
a:	nFirstChar = FindFromPos(strTarget,strSearch,nStart);
	if (nFirstChar == -1)
	{
		// no match
		return -1;
	}
	else
	{
		// got a match, check it out
		if (nFirstChar + nSearchLen == nTargetLen)
		{
			// it matches up to the end, so we have a successful match
			return nFirstChar;
		}
		else
		{
			// not coextensive with the end, so see if we can get a match
			// later in the string
			nStart = ++nFirstChar;
			goto a;
		}
	}
}

// selector = 0 means, a src only search
// selector = 1 means, a tgt only search
// pList is a pointer to the list of CSourcePhrase instances in the document's
// m_pSourcePhrases member, pTempList holds a temporary list created in the caller, of
// pSrcPhrase instances which are the result of parsing src string using TokenizeText()
// function - we use these to construct search strings which we wish to match within the
// appropriate members of each pSrcPhrase in the pList, starting from the location pos
// If glossing is ON, this should never get called.
//
/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if an extended match was made, FALSE if not
/// \param      selector    ->  0 means, a src search, 1 means a tgt search
/// \param      pos         ->  iterator through the list of CSourcePhrase instances in
///                             the application's m_pSourcePhrases member; if selector is
///                             0, the tests for matches will be done in the m_key or
///                             m_srcPhrase members of CSourcePhrase instances from that
///                             list; if selector = 1, the tests for matches will be done
///                             in the m_adaption or m_targetStr members, depending on the
///                             bIncludePunct value passed in
/// \param      pDoc        ->  pointer to CAdapt_ItDoc class, needed for accessing
///                             TokenizeText() function
/// \param      pTempList   ->  pointer to a temporary list created in the caller, of
///                             pSrcPhrase instances which are the result of parsing src
///                             string using TokenizeText() function - we use these to
///                             construct search strings which we wish to match within the
///                             appropriate members of each pSrcPhrase in the pList,
///                             starting from the location pos
/// \param      nElements   ->  the number of elements in pTempList. If matching across
///                             multiple piles, nElements will be greater than 1; or if
///                             matching even a single word but the "unit" to be searched
///                             is a retranslation's target text (since we treat
///                             retranslations as a whole), nElements can be 1 but still
///                             require extended matching by this function because there
///                             may be more than one pile in the retranslation
/// \param      bIncludePunct -> if TRUE, uses m_srcPhrase for tests in src, m_targetStr
///                             for tests in tgt. Otherwise, m_key & m_adaption, respectively
/// \param      bIgnoreCase ->  Default is FALSE in caller, if TRUE passed in, strings are
///                             reset to lower case before testing for a match
/// \param      nCount      ->  a count of how many words are to be matched (note, the
///                             function is required event when nCount is 1 if the source
///                             text matched within a retranslation)
/// \remarks
/// Used for matching several words across more than one pile, or matching within a
/// retranslation. In the case of a retranslation, the matching, if source and target text
/// matches are required, does not have to be for piles vertically aligned; so for
/// retranslations a single source text word may match at one point in the retranslation
/// but the target text line might match at a different pile within the retranslation,
/// because we consider retranslations a textual "unit", and so when that is the case, a
/// TRUE value would be returned.
/// This is a complex function, BEWARE.
/// If glossing is ON, this function should never get called.
// BEW 26Mar10, no changes needed for support of doc version 5
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::DoExtendedSearch(int			selector,
									 SPList::Node*&	pos,
									 CAdapt_ItDoc*	pDoc,
									 SPList*		pTempList,
									 int			nElements,
									 bool			bIncludePunct,
                                     bool			bIgnoreCase,
									 int&			nCount)
{
	wxASSERT(!gbIsGlossing);
	SPList::Node* pos1 = pos;  // local copy to use in iterations
	SPList::Node* pos2 = NULL; // position within the pTempList
	bool bFirstOnly = TRUE; // true when we are dealing with the first of a
			// possible string of srcPhrases in the m_pSourcePhrases list of pDoc
	int nTotal = nElements; // number of words (ie. elements in pTempList)
							// in search string
	wxString strConstruct;	// we construct strings in this, in which to search
							// for a match using src
	strConstruct.Empty();
	nCount = 0; // count of how many m_pSourcePhrases elements were used in
				// making the match, garbage if no match
	int bFirstAttempt = TRUE; // used when making first attempt at a match - the
                // first matching character does not have to be at the start of the string
                // being searched in this instance, but subsequent matches must match
                // exactly from the start
	wxString strSearchTarget; // we search in this string for a match
	strSearchTarget.Empty();
	CSourcePhrase* pSrcPhrase = NULL; // a source phase in doc's m_pSourcePhrases list
	CSourcePhrase* pSP = NULL; // a source phrase in the tokenized pTempList,
							   // from which we build search strings
	int nTargetLength = 0;
	int nSearchLength = 0;
	int nAddParts= 0;
	int nFound = -1;
	int nWordCount = 0;
	int count = 0;
	int nIteration = 0; // iteration number for the try in first source phrase,
                        // starting with longest & decreasing by one word per iteration
	int nLimit = 0; // max number of search words which can be constructed in strConstruct for
					// matching in the strSearchTarget string built from the current pSrcPhrase
					// in the loop
	if (pos == 0)
		return FALSE;
	switch (selector)
	{
	case 0: // source only
		while (pos1 != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetNext();
			wxASSERT(pSrcPhrase != NULL);
			nWordCount = pSrcPhrase->m_nSrcWords;
			nLimit = wxMin(nTotal,nWordCount);
			nCount++; // count this source phrase (it could have more than
					  // one word in its m_key or m_srcPhrase)
			if (bFirstOnly)
			{
				bFirstOnly = FALSE;
				pos = pos1; // we need to return only this one, because the caller
                            // needs to know when the end of pList has been reached, so
                            // that the caller's loop can be exited cleanly
			}
			else
			{
				nIteration = 0; // no iterations allowed for src phrases
								// other than the first
			}
			if(pSrcPhrase->m_bNullSourcePhrase)
			{
				if (nCount == 1)
					return FALSE; // if first is a null source phrase,
								  // cause progression to next
				else
				{
					// not the first srcPhrase, so just skip it
					continue;
				}
			}

			// compute strSearchTarget
			if (bIncludePunct)
			{
				strSearchTarget = pSrcPhrase->m_srcPhrase;
			}
			else
			{
				strSearchTarget = pSrcPhrase->m_key;
			}
			if (bIgnoreCase)
				strSearchTarget.MakeLower();

			// how many iterations left to be tried, for the first phrase
a:			if (nCount == 1)
			{
				nTotal = nElements; // reset, for each iteration
				nIteration++;  // which iteration within the nCount == 1 loop are we on
				nLimit = wxMin(nTotal,nWordCount) - nIteration + 1;
			}
			else
				nLimit = wxMin(nTotal,nWordCount);

			if (nIteration > wxMin(nTotal,nWordCount))
				return FALSE; // couldn't make a match in the first source phrase,
							  // and the rest match also

            // we use nWordCount together with pTempList data in order to build a
            // strConstruct which has nWordCount words in it - either with or without
            // punctuation depending on the bIncludePunct value, (or there can be less than
            // nWordCount words, if the search string is short enough); then for each
            // nIterations decrement, try building one word less each time (provided no
            // earlier iteration produced a match)
			if (nCount == 1)
			{
				// go back to the start of the user's typed string,
				// for every iteration while nCount == 1
				pos2 = pTempList->GetFirst();
			}
			count = 0; // count of words from user's typed string which
					   // are to be used for this test
			while (pos2 != NULL)
			{
				pSP = (CSourcePhrase*)pos2->GetData();
				pos2 = pos2->GetNext();
				wxASSERT(pSP != NULL);
				if (bIncludePunct)
				{
					if (count == 0)
					{
						strConstruct = pSP->m_srcPhrase;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_srcPhrase;
					}
				}
				else
				{
					if (count == 0)
					{
						strConstruct = pSP->m_key;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_key;
					}
				}
				count++; // count the word represented by this source phrase
				if (count == nLimit)
				{
					break;
				}
			}
			if (bIgnoreCase)
				strConstruct.MakeLower();

            // we exit either because nTotal is less than nLimit (in which case pos2 became
            // null before count was able to become equal to nLimit), or because count
            // equals nLimit. So now we must update the value of nTotal, so that it equals
            // the number of remaining words (ie. srcPhrases) in the pTempList list.
			nTotal -= count;
			wxASSERT(nTotal >= 0);

            // now we must check for a match. If nTotal is zero, the match can be a
            // substring, and if bFirstAttempt is TRUE, that substring can be not at the
            // start of the search string, etc. The test is different if we are on an
            // iteration other than 1st, for nCount == 1
			if (nCount == 1 && nIteration > 1)
			{
				nFound = IsMatchedToEnd(strConstruct,strSearchTarget);
			}
			else
			{
				nFound = strSearchTarget.Find(strConstruct);
			}
			if (nFound == -1)
			{
                // no match, so goto a: to try next iteration, provided nCount is still 1;
                // if nCount is greater than 1 we are not in the first SrcPhrase, and so a
                // non-match means we must return FALSE
				if (nCount == 1)
				{
					// try next iteration (with a shorter search string)
					goto a;
				}
				else
				{
					return FALSE;
				}
			}

			// we have a match, so check out whether it is exact, or a substring, etc.
			nTargetLength = strSearchTarget.Length();
			nSearchLength = strConstruct.Length();
			nAddParts = 0;
			if (nTotal > 0)
			{
                // there is more in the search string yet to be matched, so we are not at
                // the last source phrase to be tested when in this nTotal > 0 == TRUE code
                // block
				if (bFirstAttempt)
				{
                    // nFound can be non-zero, but the matching must be done up to the end
                    // of the strSearchTarget string, else we have a discontinuity and so
                    // return FALSE or iterate
					nAddParts = nFound + nSearchLength;
					if (nAddParts < nTargetLength)
					{
						if (nCount == 1 && nIteration < nLimit)
						{
                            // no match: we can try with a shorter search string, so
                            // iterate
							goto a;
						}
						else
						{
							// nCount > 1, can't possibly match because of discontinuity,
							// so return FALSE
							return FALSE;
						}
					}
					wxASSERT(nAddParts == nTargetLength); // we can continue,
														  // valid matching so far
				}
				else
				{
                    // there was a previous match or matches, so this matched string must
                    // be coextensive with strSearchTarget itself, to avoid a discontinuity
                    // in the matching, since there is yet more waiting to be tested for a
                    // match in a later srcPhrase; if there is a discontinuity, check for
                    // the possibility of an iteration and do so if the conditions are
                    // right, else return FALSE
					if (nSearchLength != nTargetLength)
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto a; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
					wxASSERT(nSearchLength == nTargetLength); // okay so far, so continue
				}
			}
			else
			{
                // nTotal must be zero, and so this current match is the last - but it must
                // match from the beginning of strSearchTarget, unless bFirstAttempt is
                // also TRUE
				wxASSERT(nTotal == 0);
				if (bFirstAttempt)
				{
                    // we have just made our first match, ie, we are at the start of the
                    // search string, so nFind can be non-zero legitimately, so we can
                    // return TRUE, since we are done
					return TRUE;
				}
				else
				{
                    // we are at the end of the search string, and there were previous
                    // matches, so the offset to the first matched character must be zero,
                    // if not, we do not have continuity in the matching, hence not a
                    // legitimate match
					if (nFound == 0)
					{
						return TRUE;
					}
					else
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto a; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
				}
			}

            // we have finished our first attempt (ie. trying to match in first srcPhrase),
            // so make bFirstAttempt FALSE for subsequent traverses through the loop
			bFirstAttempt = FALSE;
		}
		return FALSE;
		break;

	case 1: // target only
	default:
		while (pos1 != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetNext();
			wxASSERT(pSrcPhrase != NULL);

            // count the words in the m_adaption member, using TokenizeText, which is more
            // sophisticated than just counting white space etc.
			wxString aString = pSrcPhrase->m_adaption;
			SPList* pAList = new SPList;
			int	length = aString.Length();
			int numElements = 0;
			if (!aString.IsEmpty())
			{
				numElements = pDoc->TokenizeText(0,pAList,aString,length);
				DeleteTempList(pAList);
			}
			else
			{
				// if aString is empty, we've nothing to search in on this srcPhrase,
				// so cause progression
				if (pAList != NULL) // whm 11Jun12 added NULL test
					delete pAList; // don't leak memory
				if (bFirstOnly)
					pos = pos1;
				return FALSE;
			}
			nWordCount = numElements;

			nLimit = wxMin(nTotal,nWordCount);
			nCount++; // count this source phrase (it could have more than one word in its
					  // m_key or m_srcPhrase)
			if (bFirstOnly)
			{
				bFirstOnly = FALSE;
				pos = pos1; // we need to return only this one, because the caller needs to
							// know when the end of pList has been reached, so that the
							// caller's loop can be exited cleanly
			}
			else
			{
				nIteration = 0; // no iterations allowed for src phrases other than the first
			}

			// compute strSearchTarget
			if (bIncludePunct)
			{
				strSearchTarget = pSrcPhrase->m_targetStr;
			}
			else
			{
				strSearchTarget = pSrcPhrase->m_adaption;
			}
			if (bIgnoreCase)
				strSearchTarget.MakeLower();

			// how many iterations left to be tried, for the first phrase
b:			if (nCount == 1)
			{
				nTotal = nElements; // reset, for each iteration
				nIteration++;  // which iteration within the nCount == 1 loop are we on
				nLimit = wxMin(nTotal,nWordCount) - nIteration + 1;
			}
			else
				nLimit = wxMin(nTotal,nWordCount);

			if (nIteration > wxMin(nTotal,nWordCount))
				return FALSE; // couldn't make a match in the first source phrase,
							  // and the rest match also

            // we use nWordCount together with pTempList data in order to build a
            // strConstruct which has nWordCount words in it - either with or without
            // punctuation depending on the bIncludePunct value, (or there can be less than
            // nWordCount words, if the search string is short enough); then for each
            // nIterations decrement, try building one word less each time (provided no
            // earlier iteration produced a match)
			if (nCount == 1)
			{
				// go back to the start of the user's typed string, for every
				// iteration while nCount == 1
				pos2 = pTempList->GetFirst();
			}
			count = 0; // count of words from user's typed string which are
					   // to be used for this test
			while (pos2 != NULL)
			{
				pSP = (CSourcePhrase*)pos2->GetData();
				pos2 = pos2->GetNext();
				wxASSERT(pSP != NULL);
				if (bIncludePunct)
				{
					if (count == 0)
					{
						strConstruct = pSP->m_srcPhrase;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_srcPhrase;
					}
				}
				else
				{
					if (count == 0)
					{
						strConstruct = pSP->m_key;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_key;
					}
				}
				count++; // count the word represented by this source phrase
				if (count == nLimit)
				{
					break;
				}
			}
			if (bIgnoreCase)
				strConstruct.MakeLower();

            // we exit either because nTotal is less than nLimit (in which case pos2 became
            // null before count was able to become equal to nLimit), or because count
            // equals nLimit. So now we must update the value of nTotal, so that it equals
            // the number of remaining words (ie. srcPhrases) in the pTempList list.
			nTotal -= count;
			wxASSERT(nTotal >= 0);

            // now we must check for a match. If nTotal is zero, the match can be a
            // substring, and if bFirstAttempt is TRUE, that substring can be not at the
            // start of the search string, etc. The test is different if we are on an
            // iteration other than 1st, for nCount == 1
			if (nCount == 1 && nIteration > 1)
			{
				nFound = IsMatchedToEnd(strConstruct,strSearchTarget);
			}
			else
			{
				nFound = strSearchTarget.Find(strConstruct);
			}
			if (nFound == -1)
			{
                // no match, so goto a: to try next iteration, provided nCount is still 1;
                // if nCount is greater than 1 we are not in the first SrcPhrase, and so a
                // non-match means we must return FALSE
				if (nCount == 1)
				{
					// try next iteration (with a shorter search string)
					goto b;
				}
				else
				{
					return FALSE;
				}
			}

			// we have a match, so check out whether it is exact, or a substring, etc.
			nTargetLength = strSearchTarget.Length();
			nSearchLength = strConstruct.Length();
			nAddParts = 0;
			if (nTotal > 0)
			{
                // there is more in the search string yet to be matched, so we are not at
                // the last source phrase to be tested when in this nTotal > 0 == TRUE code
                // block
				if (bFirstAttempt)
				{
                    // nFound can be non-zero, but the matching must be done up to the end
                    // of the strSearchTarget string, else we have a discontinuity and so
                    // return FALSE or iterate
					nAddParts = nFound + nSearchLength;
					if (nAddParts < nTargetLength)
					{
						if (nCount == 1 && nIteration < nLimit)
						{
							// no match: we can try with a shorter search string,
							// so iterate
							goto b;
						}
						else
						{
							// nCount > 1, can't possibly match because of discontinuity,
							// so return FALSE
							return FALSE;
						}
					}
					wxASSERT(nAddParts == nTargetLength); // we can continue,
														  // valid matching so far
				}
				else
				{
                    // there was a previous match or matches, so this matched string must
                    // be coextensive with strSearchTarget itself, to avoid a discontinuity
                    // in the matching, since there is yet more waiting to be tested for a
                    // match in a later srcPhrase; if there is a discontinuity, check for
                    // the possibility of an iteration and do so if the conditions are
                    // right, else return FALSE
					if (nSearchLength != nTargetLength)
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto b; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
					wxASSERT(nSearchLength == nTargetLength); // okay so far, so continue
				}
			}
			else
			{
                // nTotal must be zero, and so this current match is the last - but it must
                // match from the beginning of strSearchTarget, unless bFirstAttempt is
                // also TRUE
				wxASSERT(nTotal == 0);
				if (bFirstAttempt)
				{
                    // we have just made our first match, ie, we are at the start of the
                    // search string, so nFind can be non-zero legitimately, so we can
                    // return TRUE, since we are done
					return TRUE;
				}
				else
				{
                    // we are at the end of the search string, and there were previous
                    // matches, so the offset to the first matched character must be zero,
                    // if not, we do not have continuity in the matching, hence not a
                    // legitimate match
					if (nFound == 0)
					{
						return TRUE;
					}
					else
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto b; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
				}
			}

            // we have finished our first attempt (ie. trying to match in first srcPhrase),
            // so make bFirstAttempt FALSE for subsequent traverses through the loop
			bFirstAttempt = FALSE;
		}
		return FALSE;
		break;
	}
#ifndef __VISUALC__
	return FALSE; // unreachable according to VC7.1, but gcc says it is needed!!!
#endif
}

// searches in the list of source phrases for a match, ignores the view; if glossing is ON
// then bIncludePunct and bSpanSrcPhrases will be obligatorily FALSE; and nCount should not
// get set to anything except 1 (when glossing is ON)
// ALSO NOTE: for simplicity I had a test of gbIsGlossing set the bIncludePunct flag to FALSE,
// which strictly speaking is too strong a condition when the search is done only in the
// source text; however, since few people use the Find... command, and fewer still are likely
// to use it with glossing ON and at the same time want a punctuated search in the source text,
// I figure I can get this past muster without anyone ever discovering it! In other words, when
// glossing is ON, the search will be in source text where punctuation has been excluded.
// BEW 26Mar10, no changes needed for support of doc version 5
bool CAdapt_ItView::DoSrcOnlyFind(int nStartSequNum, bool bIncludePunct, bool bSpanSrcPhrases,
								  wxString& src,bool bIgnoreCase, int& nSequNum, int& nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbIsGlossing)
	{
		wxASSERT(!bIncludePunct && !bSpanSrcPhrases);
	}
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int nRetransFirst = -1;
	int nRetransLast = -1;
	bool bInRetrans = FALSE;
	int nFound;
	wxString srcCopy; // for caseless matching
	wxString searchCopy; // for caseless searching in it
	wxString srcNoPunct; // for making a copy from which we can remove punctuation

	if (bSpanSrcPhrases)
	{
		// must never enter here when glossing is ON
		bool bFound = FALSE;

        // parse a copy of the src text string, storing the results in temporary
        // CSourcePhrase instances so that the m_key members hold the punctuation-less
        // words, and the m_srcPhrase members the punctuated words
		SPList* pTempList = new SPList; // a temporary list
		wxASSERT(pTempList != NULL);

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		wxString theString = src;
		int	length = theString.Length();
		int nElements = 0;
		if (!theString.IsEmpty())
		{
			nElements = pDoc->TokenizeText(0,pTempList,theString,length);
		}
		else
		{
			// if theString is empty, we've nothing to search for, so return FALSE
			if (pTempList != NULL) // whm 11Jun12 added NULL test
				delete pTempList; // don't leak memory
			return FALSE;
		}

		// do the search, and permit matching text across discrete CSourcePhrase instances
		SPList::Node* savePos;
e:		while (pos != NULL)
		{
			wxString tgt;
			tgt.Empty();
			savePos = pos; // test for initial matched srcPhrase in a retranslation
			bFound = DoExtendedSearch(0,pos,pDoc,pTempList,nElements,
										bIncludePunct,bIgnoreCase,nCount);
			if (bFound)
			{
				nSequNum = sn;
				goto d;
			}
			else
			{
				sn++;
			}
		}
		// if we get here, pos is null, and so we have no match possible
		DeleteTempList(pTempList);
		return FALSE;

		// we found a match, check if it is in a retranslation & adjust nCount &
		// nSequNum if it is contained within the retranslation
d:		pSrcPhrase = (CSourcePhrase*)savePos->GetData();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bRetranslation)
		{
			bInRetrans = IsContainedByRetranslation(nSequNum,nCount,
													nRetransFirst,nRetransLast);
			if (bInRetrans)
			{
				// adjust values, so that the match is the whole retranslation
				CPile* pP = GetPile(nRetransFirst);
				wxASSERT(pP != NULL);
				CSourcePhrase* pSP = pP->GetSrcPhrase();
				wxASSERT(pSP != NULL);
				nSequNum = pSP->m_nSequNumber;
				nCount = nRetransLast - nRetransFirst + 1;

				// set the globals
				pApp->m_bMatchedRetranslation = TRUE;
				gnRetransEndSequNum = nRetransLast;
				DeleteTempList(pTempList);
				return TRUE;
			}
			else
			{
				// clear the globals
				pApp->m_bMatchedRetranslation = FALSE;
				gnRetransEndSequNum = -1;
				goto e; // continue iterating, looking for a match
			}
		}
		// clear the globals
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		DeleteTempList(pTempList);
		return TRUE; // return with unchanged nSequNum and nCount values
	}
	else // could be glossing or adapting
	{
		// do the search, confining attempts to match the text within
		// a single CSourcePhrase instance
		nFound = -1; // assume not found
		srcCopy = src; // for caseless matching
		srcNoPunct = src; // make a copy from which we can remove punctuation
		RemovePunctuation(pDoc,&srcNoPunct,from_source_text);
		if (bIgnoreCase)
		{
			srcCopy.MakeLower();
			srcNoPunct.MakeLower();
		}
f:		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

			// do the searching either in m_srcPhrase or m_key, depending on
			// whether punctuation is to be included in the search or not
			if (bIncludePunct)
			{
				// use the m_srcPhrase attribute if adapting; don't enter this block
				// if glossing is ON
				if (pSrcPhrase->m_srcPhrase.IsEmpty() || pSrcPhrase->m_bNullSourcePhrase)
				{
					goto b;
				}
				searchCopy = pSrcPhrase->m_srcPhrase;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				nFound = searchCopy.Find(srcCopy);
b:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto c;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
			else // bIncludePunct is FALSE, so if glossing is ON it too will use this block
			{
				// use the m_key attribute
				if (pSrcPhrase->m_key.IsEmpty() || pSrcPhrase->m_bNullSourcePhrase)
				{
					goto a;
				}
				searchCopy = pSrcPhrase->m_key;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				nFound = searchCopy.Find(srcNoPunct);
a:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto c;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
		}
	}

	// if we get here, we didn't find a match
	return FALSE;

    // we found a match, check if it is in a retranslation & adjust nCount & nSequNum if it
    // is contained within the retranslation; but we don't want to test this if glossing is
    // ON because matching can be within a translation in that circumstance
c: if (gbIsGlossing)
   {
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
   }
   // when not glossing we have to consider the possibility that we may be in, out, or
   // partially within a retranslation
	if (pSrcPhrase->m_bRetranslation)
	{
		bInRetrans = IsContainedByRetranslation(nSequNum,nCount,
												nRetransFirst,nRetransLast);
		if (bInRetrans)
		{
			// adjust values, so that the match is the whole retranslation
			CPile* pP = GetPile(nRetransFirst);
			wxASSERT(pP != NULL);
			CSourcePhrase* pSP = pP->GetSrcPhrase();
			wxASSERT(pSP != NULL);
			nSequNum = pSP->m_nSequNumber;
			nCount = nRetransLast - nRetransFirst + 1;

			// set the globals
			pApp->m_bMatchedRetranslation = TRUE;
			gnRetransEndSequNum = nRetransLast;
			return TRUE;
		}
		else
		{
			// clear the globals
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			goto f; // continue iterating, looking for a match
		}
	}
	// clear the globals
	pApp->m_bMatchedRetranslation = FALSE;
	gnRetransEndSequNum = -1;
	return TRUE; // return with unchanged nSequNum and nCount values
}

// searches in the list of source phrases for a match, ignores the view; when glossing is
// ON the 'tgt' will be the glossing line; and the 2nd and 3rd parameters will be FALSE,
// and nCount must only return 1 (when glossing is ON). Glossing text by default allows any
// typed punctuation to be stored; so bIncludePunct == FALSE does nothing to affect whether
// gloss text has punctuation, it just stops certain blocks of code being entered.
bool CAdapt_ItView::DoTgtOnlyFind(int		nStartSequNum,
								  bool		bIncludePunct,
								  bool		bSpanSrcPhrases,
								  wxString& tgt,
								  bool		bIgnoreCase,
								  int&		nSequNum,
								  int&		nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int nRetransFirst = -1;
	int nRetransLast = -1;
	bool bInRetrans = FALSE;
	int nFound; // -1 = assume not found
	wxString tgtCopy; // for caseless matching
	wxString searchCopy; // for caseless searching in it
	wxString tgtNoPunct; // for making a copy from which we can remove punctuation

    // if bSpanSrcPhrases is TRUE,but the tgt string is empty, then it makes no sense to
    // span source phrases, so this case reduces to a normal search within a single
    // srcPhrase
	if (bSpanSrcPhrases && tgt.IsEmpty())
		goto c;

	if (bSpanSrcPhrases)
	{
		wxASSERT(!gbIsGlossing); // must not be glossing if we enter this block
		// do the search, and permit matching text across discrete
		// CSourcePhrase instances
		bool bFound = FALSE;

        // parse a copy of the tgt text string, storing the results in temporary
        // CSourcePhrase instances so that the m_key members hold the punctuation-less
        // words, and the m_srcPhrase members the punctuated words
		SPList* pTempList = new SPList; // a temporary list
		wxASSERT(pTempList != NULL);

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		wxString theString = tgt;
		int	length = theString.Length();
		int nElements = 0;
		if (!theString.IsEmpty())
		{
			nElements = pDoc->TokenizeText(0,pTempList,theString,length);
		}
		else
		{
			// if theString is empty, we've nothing to search for, so return FALSE
			if (pTempList != NULL) // whm 11Jun12 added NULL test
				delete pTempList; // don't leak memory
			return FALSE;
		}

		// do the search, and permit matching text across discrete CSourcePhrase instances
		SPList::Node* savePos;
h:		while (pos != NULL)
		{
			wxString src;
			src.Empty();
			savePos = pos;
			bFound = DoExtendedSearch(1,pos,pDoc,pTempList,nElements,
									bIncludePunct,bIgnoreCase,nCount);
			if (bFound)
			{
				nSequNum = sn;
				goto d;
			}
			else
			{
				sn++;
			}
		}
		// if we get here, pos is null, and so we have no match possible
		DeleteTempList(pTempList);
		return FALSE;

		// we found a match, check if it is in a retranslation & adjust nCount &
		// nSequNum if it is contained within the retranslation
d:		pSrcPhrase = (CSourcePhrase*)savePos->GetData();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bRetranslation)
		{
			bInRetrans = IsContainedByRetranslation(nSequNum,nCount,
												nRetransFirst,nRetransLast);
			if (bInRetrans)
			{
				// adjust values, so that the match is the whole retranslation
				CPile* pP = GetPile(nRetransFirst);
				wxASSERT(pP != NULL);
				CSourcePhrase* pSP = pP->GetSrcPhrase();
				wxASSERT(pSP != NULL);
				nSequNum = pSP->m_nSequNumber;
				nCount = nRetransLast - nRetransFirst + 1;

				// set the globals
				pApp->m_bMatchedRetranslation = TRUE;
				gnRetransEndSequNum = nRetransLast;
				DeleteTempList(pTempList);
				return TRUE;
			}
			else
			{
				// clear the globals
				pApp->m_bMatchedRetranslation = FALSE;
				gnRetransEndSequNum = -1;
				goto h; // continue iterating, looking for a match
			}
		}
		// clear the globals
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		DeleteTempList(pTempList);
		return TRUE; // return with unchanged nSequNum and nCount values
	}
	else // bSpanSrcPhrases == FALSE branch; glossing ON uses this branch always
	{
		// do the search, confining attempts to match the text within
		// a single CSourcePhrase instance
c:		nFound = -1; // assume not found
		tgtCopy = tgt; // for caseless matching (tgt would contain search string
					   // for finding within glosses if glossing is ON)
		tgtNoPunct = tgt; // make a copy from which we can remove punctuation
		if (!gbIsGlossing)
			RemovePunctuation(pDoc,&tgtNoPunct,from_target_text);
		if (bIgnoreCase)
		{
			tgtCopy.MakeLower();
			tgtNoPunct.MakeLower();
		}
i:		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

            // do the searching either in m_targetStr or m_adaption, depending on whether
            // punctuation is to be included in the search or not
			if (bIncludePunct) // glossing ON forces this boolean FALSE in the caller,
				// so glossing does not use this block, but only the ELSE block
			{
				// use the m_targetStr attribute
				if (pSrcPhrase->m_targetStr.IsEmpty())
				{
					// since we allow null matches, check for this
					if (tgt.IsEmpty())
					{
						// we have a null match, so success
						nSequNum = sn;
						nCount = 1;
						goto e;
					}
					else
						goto b;
				}
				else
				{
					if (tgt.IsEmpty())
						goto b; // can't allow a Find with a null phrase,
								// it would match anything
				}
				searchCopy = pSrcPhrase->m_targetStr;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				nFound = searchCopy.Find(tgtCopy);
b:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto e;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
			else // bIncludePunct == FALSE branch; glossing ON also uses this branch
			{
				// use the m_adaption attribute when adapting, m_gloss when glossing
				bool bTest;
				if (gbIsGlossing)
					bTest = pSrcPhrase->m_gloss.IsEmpty();
				else
					bTest = pSrcPhrase->m_adaption.IsEmpty();
				if (bTest)
				{
					// no text, since we allow null matches check for a null match
					if (tgt.IsEmpty())
					{
						// we have a null match, so success
						nSequNum = sn;
						nCount = 1;
						goto e;
					}
					else
						goto a;
				}
				else // there is some adaptation, or gloss, text
				{
					if (tgt.IsEmpty())
						goto a; // can't allow a Find with a null phrase,
							// (except for a null match) because it would match anything
				}
				if (gbIsGlossing)
					searchCopy = pSrcPhrase->m_gloss;
				else
					searchCopy = pSrcPhrase->m_adaption;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				if (gbIsGlossing)
				{
					nFound = pSrcPhrase->m_gloss.Find(tgt); // possibly
										// a punctuation-containing search
				}
				else // not glossing
				{
					nFound = pSrcPhrase->m_adaption.Find(tgtNoPunct);
				}
a:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto e;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
		}
	}

	// if we get here, we didn't find a match
	return FALSE;

	// we found a match, check if it is in a retranslation & adjust nCount &
	// nSequNum if it is contained within the retranslation
e:	if (gbIsGlossing)
	{
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
	}
	// if not glossing, we have to check out if we landed in, or partly in, or out of
	// a retranslation - and fix things accordingly.
	if (pSrcPhrase->m_bRetranslation)
	{
		bInRetrans = IsContainedByRetranslation(nSequNum,nCount,
												nRetransFirst,nRetransLast);
		if (bInRetrans)
		{
			// adjust values, so that the match is the whole retranslation
			CPile* pP = GetPile(nRetransFirst);
			wxASSERT(pP != NULL);
			CSourcePhrase* pSP = pP->GetSrcPhrase();
			wxASSERT(pSP != NULL);
			nSequNum = pSP->m_nSequNumber;
			nCount = nRetransLast - nRetransFirst + 1;

			// set the globals
			pApp->m_bMatchedRetranslation = TRUE;
			gnRetransEndSequNum = nRetransLast;
			return TRUE;
		}
		else
		{

			// clear the globals
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			goto i; // continue iterating, looking for a match
		}
	}
	// clear the globals
	pApp->m_bMatchedRetranslation = FALSE;
	gnRetransEndSequNum = -1;
	return TRUE; // return with unchanged nSequNum and nCount values
}

// see the comments at the start of the DoSrcOnlyFind( ) and DoTgtOnlyFind( ) - same stuff
// applies here; and tgt could be text to check in adaptations, or glosses, depending on
// gbIsGlossing value
bool CAdapt_ItView::DoSrcAndTgtFind(int			nStartSequNum,
									bool		bIncludePunct,
									bool		bSpanSrcPhrases,
									wxString&	src,
									wxString&	tgt,
									bool		bIgnoreCase,
									int&		nSequNum,
									int&		nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int nSaveSrcSequNum = -1;
	int nCount1 = 0;
	int nCount2 = 0;
	int nRetransFirst = -1;
	int nRetransLast = -1;
	bool bInRetrans = FALSE;
	bool bSrcMatchIsRetrans = FALSE;
	bool bFound = FALSE;
	SPList* pTempList = NULL;
	int length = 0;
	int nElements = 0;
	int nElements2 = 0;
	wxString theString;
	theString.Empty();
	SPList::Node* savePos = NULL;
	int nFound; // -1 = assume not found
	wxString srcCopy;
	wxString tgtCopy;
	wxString searchStr;
	wxString srcNoPunct; // for making a copy from which we can remove punctuation

	if (bSpanSrcPhrases)
	{
		wxASSERT(!gbIsGlossing); // cannot enter this block when glossing is ON
		// do the search, and permit matching text across discrete
		// CSourcePhrase instances
		bFound = FALSE;

        // parse a copy of the src text string, storing the results in temporary
        // CSourcePhrase instances so that the m_key members hold the punctuation-less
        // words, and the m_srcPhrase members the punctuated words
		pTempList = new SPList; // a temporary list
		wxASSERT(pTempList != NULL);

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		theString = src;
		length = theString.Length();
		nElements = 0;
		if (!theString.IsEmpty())
		{
			nElements = pDoc->TokenizeText(0,pTempList,theString,length);
		}
		else
		{
			// if theString is empty, we've nothing to search for, so return FALSE
			if (pTempList != NULL) // whm 11Jun12 added NULL test
				delete pTempList; // don't leak memory
			return FALSE;
		}

		// do the search, and permit matching text across discrete
		// CSourcePhrase instances
		SPList::Node* savePos = NULL; // whm initialized to NULL
e:		while (pos != NULL)
		{
			wxString tgt;
			tgt.Empty();
			savePos = pos;
			bFound = DoExtendedSearch(0,pos,pDoc,pTempList,nElements,
									bIncludePunct,bIgnoreCase,nCount1);
			if (bFound)
			{
				nSaveSrcSequNum = sn;
				break;
			}
			else
			{
				sn++;
			}
		}
		// if we get here, pos is null, or we have a src match, if the latter,
		// do the target search
		if (pos == NULL || nSaveSrcSequNum == -1 || savePos == NULL)
		{
			// we didn't get a src match, so return
			DeleteTempList(pTempList);
			return FALSE;
		}

		// we found a match, check if it is in a retranslation & adjust nCount1 &
		// nSequNum if it is contained within the retranslation
		pSrcPhrase = (CSourcePhrase*)savePos->GetData();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bRetranslation)
		{
			bInRetrans = IsContainedByRetranslation(nSaveSrcSequNum,nCount1,
													nRetransFirst,nRetransLast);
			if (bInRetrans)
			{
                 // adjust values, so that the match is the whole retranslation
				CPile* pP = GetPile(nRetransFirst);
				wxASSERT(pP != NULL);
				CSourcePhrase* pSP = pP->GetSrcPhrase();
				wxASSERT(pSP != NULL);
				nSaveSrcSequNum = pSP->m_nSequNumber;
				nCount1 = nRetransLast - nRetransFirst + 1;
				bSrcMatchIsRetrans = TRUE;
			}
			else
			{
				// clear the globals
				bSrcMatchIsRetrans = FALSE;
				pApp->m_bMatchedRetranslation = FALSE;
				gnRetransEndSequNum = -1;
				sn++;
				nSaveSrcSequNum = -1;
				goto e; // continue iterating, looking for a match
			}
		}
		else
		{
			bSrcMatchIsRetrans = FALSE;
		}

        // before doing the target search, we must check for an empty tgt string. If it is
        // empty, then the only meaningful "match" is that nCount1 source phrases matched
        // so far must each have an empty string in their m_adaption member. So if that is
        // so, we have a null match and can exit TRUE. So do the check next.
		if (tgt.IsEmpty())
		{
			SPList::Node* pos3 = pList->Item(nSaveSrcSequNum);
			wxASSERT(pos3 != 0);
			for (int j=0; j < nCount1; j++)
			{
				CSourcePhrase* pSP = (CSourcePhrase*)pos3->GetData();
				pos3 = pos3->GetNext();
				wxASSERT(pos3 != 0);
				if (!pSP->m_adaption.IsEmpty())
				{
					bSrcMatchIsRetrans = FALSE;
					pApp->m_bMatchedRetranslation = FALSE;
					gnRetransEndSequNum = -1;
					sn++;
					nSaveSrcSequNum = -1;
					goto e; // continue iterating, looking for a match
				}
			}

			// if we get here, we have a valid match, so return
			nSequNum = nSaveSrcSequNum;
			nCount = nCount1;
			DeleteTempList(pTempList);
			return TRUE;
		}

		// now try the target search - (use code copied from
		// DoTgtFindOnly() & modified a bit)
		bFound = FALSE;

		// start at the sequ number just defined
		SPList::Node* pos2 = pList->Item(nSaveSrcSequNum);
		sn = nSaveSrcSequNum;

        // parse a copy of the tgt text string, storing the results in temporary
        // CSourcePhrase instances so that the m_key members hold the punctuation-less
        // words, and the m_srcPhrase members the punctuated words
		SPList* pTempList2 = new SPList; // a temporary list for the tgt ones
		wxASSERT(pTempList2 != NULL);

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		theString = tgt;
		length = theString.Length();
		nElements2 = 0;
		if (!theString.IsEmpty())
		{
			nElements2 = pDoc->TokenizeText(0,pTempList2,theString,length);
		}
		// note, we will permit "matching" an empty string in the target text

        // if the target's nElements2 > nElements, no match is possible (the target must
        // match within the scope of the source match), though it may be possible if the
        // source match was in a retranslation
		if (nElements2 > nElements && !bSrcMatchIsRetrans)
		{
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			sn = nSaveSrcSequNum; // prepare for outer loop
			sn++;
			nSaveSrcSequNum = -1;
			goto e;
		}

		// do the search, and permit matching text across discrete
		// CSourcePhrase instances
		while (pos2 != NULL)
		{
			wxString src;
			src.Empty();
			savePos = pos2; // DoExtendedSearch returns pos value at next
							// location to the input parameter pos2 value,
							// so to preserve the input one, we need savePos as well
			bFound = DoExtendedSearch(1,pos2,pDoc,pTempList2,nElements2,
									bIncludePunct,bIgnoreCase,nCount2);
			if (bFound)
			{
				nSequNum = sn;
				DeleteTempList(pTempList2);

                // we have a double match only if the sequence number for the first
                // srcPhrase of each match is the same and the target selection is no
                // longer than the source one; or if not the same, then both nSequNum and
                // the end of the target match lie within the source text selection, which
                // amounts to conditions on nCount1 and nCount2 values

				// we found a match, check if it is in same retranslation if the
				// first match was in one
				pSrcPhrase = (CSourcePhrase*)savePos->GetData();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_bRetranslation && bSrcMatchIsRetrans)
				{
					bInRetrans = IsContainedByRetranslation(nSequNum,nCount2,
															nRetransFirst,nRetransLast);
					if (bInRetrans)
					{
						// the match is the whole retranslation
						nSequNum = nSaveSrcSequNum;
						nCount = nCount1;

						// set the globals
						pApp->m_bMatchedRetranslation = TRUE;
						gnRetransEndSequNum = nRetransLast;
						if (pTempList != NULL) DeleteTempList(pTempList);
						return TRUE;
					}
					else
					{
                        // continue iterating the source loop, since the src string matched
                        // the retranslation but the tgt string matched at best only part
                        // of the retranslation which makes it a non-match for the src/tgt
                        // string pair (caller clears the globals)
						bSrcMatchIsRetrans = FALSE;
						pApp->m_bMatchedRetranslation = FALSE;
						gnRetransEndSequNum = -1;
						sn = nSaveSrcSequNum; // prepare for outer loop
						sn++;
						nSaveSrcSequNum = -1;
						goto e;
					}
				}
				else
				{
					// not a retranslation match
					if (nSaveSrcSequNum == nSequNum)
					{
						if (nCount2 <= nCount1)
						{
							// we have a valid match, but not to a retranslation
							pApp->m_bMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							nCount = nCount1;
							if (pTempList != NULL) DeleteTempList(pTempList);
							return TRUE;
						}
						else
						{
							// match is not valid
							bSrcMatchIsRetrans = FALSE;
							pApp->m_bMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							sn = nSaveSrcSequNum; // prepare for outer loop
							sn++;
							nSaveSrcSequNum = -1;
							goto e;
						}
					}
					else if (nSequNum < nSaveSrcSequNum + nCount1)
					{
						if (nSequNum + nCount2 <= nSaveSrcSequNum + nCount1)
						{
							// we have a valid match
							pApp->m_bMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							nSequNum = nSaveSrcSequNum;
							nCount = nCount1;
							if (pTempList != NULL) DeleteTempList(pTempList);
							return TRUE;
						}
						else
						{
							// match is not valid
							bSrcMatchIsRetrans = FALSE;
							pApp->m_bMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							sn = nSaveSrcSequNum; // prepare for outer loop
							sn++;
							nSaveSrcSequNum = -1;
							goto e;
						}
					}
					else
					{
						bSrcMatchIsRetrans = FALSE;
						pApp->m_bMatchedRetranslation = FALSE;
						gnRetransEndSequNum = -1;
						sn = nSaveSrcSequNum; // prepare for outer loop
						sn++;
						nSaveSrcSequNum = -1;
						goto e;
					}
				}
			}
			else // no match, so continue at next sequ number
				 // in the inner pos2 loop, until invalid
			{
				sn++;

				// discontinue tgt search & continue src search if sn gets
				// beyond range for the src match
				if (sn >= nSaveSrcSequNum + nCount1)
				{
					bSrcMatchIsRetrans = FALSE;
					pApp->m_bMatchedRetranslation = FALSE;
					gnRetransEndSequNum = -1;
					sn = nSaveSrcSequNum; // prepare for outer loop
					sn++;
					nSaveSrcSequNum = -1;
					goto e;
				}
			}
		}
        // if we get here, pos2 is null, and so we have no later target match possible, so
        // there is no point to trying further source matches
		DeleteTempList(pTempList2);
		if (pTempList != NULL) DeleteTempList(pTempList);
		return FALSE;
	}
	else // bSpanSrcPhrases == FALSE block; also glossing ON always uses this block
	{
		// do the search, confining attempts to match the text within a single
		// CSourcePhrase instance
		nFound = -1; // assume not found
		srcCopy = src;
		tgtCopy = tgt;
		srcNoPunct = src; // make a copy from which we can remove punctuation
		RemovePunctuation(pDoc,&srcNoPunct,from_source_text); // independent of gbIsGlossing
		wxString tgtNoPunct = tgt; // make a copy from which we can remove punctuation
		if (!gbIsGlossing)
			RemovePunctuation(pDoc,&tgtNoPunct,from_target_text);
		if (bIgnoreCase)
		{
			srcCopy.MakeLower();
			tgtCopy.MakeLower();
			srcNoPunct.MakeLower();
			tgtNoPunct.MakeLower();
		}

		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

			// do the searching either in the pair m_srcPhrase &m_targetStr, or in the pair
			// m_key and m_adaption, depending on whether punctuation is to be included in the
			// search or not
			if (bIncludePunct) // if glossing is ON, this flag will be FALSE
			{
				// use the m_srcPhrase attribute
				if (pSrcPhrase->m_targetStr.IsEmpty())
				{
					if (pSrcPhrase->m_srcPhrase.IsEmpty())
					{
						goto b; // no match
					}
					// we allow a null match in the target, check for this, by continuing
				}
				searchStr = pSrcPhrase->m_srcPhrase;
				if (bIgnoreCase)
					searchStr.MakeLower();
				nFound = searchStr.Find(srcCopy);
			}
			else
			{
				// use the m_adaption attribute
				if (pSrcPhrase->m_adaption.IsEmpty())
				{
					if (pSrcPhrase->m_key.IsEmpty())
					{
						goto b; // no match
					}
					// we allow a null match in the target, check for this, by continuing
				}
				searchStr = pSrcPhrase->m_key;
				if (bIgnoreCase)
					searchStr.MakeLower();
				nFound = searchStr.Find(srcCopy);
			}
			if (nFound == -1)
				goto b;
			nFound = -1; // prepare for attempt to match in target text

			// we matched in the source text, check if the match was in a retranslation.
			// If it is, then we must make the whole retranslation be "matched", in which
			// case we cannot arbitrarily pick one of the target language m_targetStr or
			// m_adaption members as a corresponding since srcPhrase location in which to
			// search for the target, instead, we have to treat the target match as a
			// bSpanSrcPhrases == TRUE case, and try make the match anywhere within the
			// appropriate target text of the retranslation

            // check if the match is in a retranslation & adjust nCount & nSequNum if it is
            // contained within a retranslation; if glossing is ON we don't enter next
            // block
			if (!gbIsGlossing && pSrcPhrase->m_bRetranslation)
			{
				bInRetrans = IsContainedByRetranslation(sn,1,nRetransFirst,nRetransLast);
				if (bInRetrans)
				{
					// adjust values, so that the match is the whole retranslation
					CPile* pP = GetPile(nRetransFirst);
					wxASSERT(pP != NULL);
					CSourcePhrase* pSP = pP->GetSrcPhrase();
					wxASSERT(pSP != NULL);
					nSaveSrcSequNum = pSP->m_nSequNumber;
					nCount1 = nRetransLast - nRetransFirst + 1;

					// do a multi-element search for the target text, because retranslations
					// typically are longer than one sourcePhrase in length
					bSrcMatchIsRetrans = TRUE;

					// this block is copied code from above, & changed a bit
					bFound = FALSE;

					// start at the sequ number just defined
					SPList::Node* pos2 = pList->Item(nSaveSrcSequNum);
					sn = nSaveSrcSequNum;

					// parse a copy of the tgt text string, storing the results in temporary
					// CSourcePhrase instances so that the m_key members hold the
					// punctuation-less words, and the m_srcPhrase members the punctuated words
					SPList* pTempList2 = new SPList; // a temporary list for the tgt ones
					wxASSERT(pTempList2 != NULL);

					// tokenize the string into a list of new CSourcePhrase instances on the heap
					// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
					theString = tgt;
					length = theString.Length();
					nElements = 0;
					if (!theString.IsEmpty())
					{
						nElements = pDoc->TokenizeText(0,pTempList2,theString,length);
					}
					// note, we will permit "matching" an empty string in the target text

					// do the search, and permit matching text across discrete
					// CSourcePhrase instances
					while (pos2 != NULL)
					{
						wxString src;
						src.Empty();
						savePos = pos2; // DoExtendedSearch returns pos value at next location
										// to the input parameter pos2 value, so to preserve the
										// input one, we need savePos as well
						bFound = DoExtendedSearch(1,pos2,pDoc,pTempList2,
												nElements,bIncludePunct,bIgnoreCase,nCount2);
						if (bFound)
						{
							nSequNum = sn;
							DeleteTempList(pTempList2);

							// we have a double match only if the sequence number for the first
							// srcPhrase of each match is the same and the target selection is
							// no longer than the source one; or if not the same, then both
							// nSequNum and the end of the target  match lie within the source
							// text selection, which amounts to conditions on nCount1 and nCount2
							// values

							// we found a match, check if it is in same retranslation if the
							// first match was in one
							pSrcPhrase = (CSourcePhrase*)savePos->GetData();
							wxASSERT(pSrcPhrase != NULL);
							if (pSrcPhrase->m_bRetranslation && bSrcMatchIsRetrans)
							{
								bInRetrans = IsContainedByRetranslation(nSequNum,nCount2,
															nRetransFirst,nRetransLast);
								if (bInRetrans)
								{
									// the match is the whole retranslation
									nSequNum = nSaveSrcSequNum;
									nCount = nCount1;

									// set the globals
									pApp->m_bMatchedRetranslation = TRUE;
									gnRetransEndSequNum = nRetransLast;
									if (pTempList != NULL) DeleteTempList(pTempList);
									return TRUE;
								}
								else
								{
                                    // continue iterating the source loop, since the src
                                    // string matched the retranslation but the tgt string
                                    // matched at best only part of the retranslation which
                                    // makes it a non-match for the src/tgt string pair
                                    // (caller clears the globals)
									bSrcMatchIsRetrans = FALSE;
									pApp->m_bMatchedRetranslation = FALSE;
									gnRetransEndSequNum = -1;
									sn = nSaveSrcSequNum; // prepare to continue in outer loop
									goto g;
								}
							}
							else
							{
								// not a retranslation match
								if (nSaveSrcSequNum == nSequNum)
								{
									if (nCount2 <= nCount1)
									{
										// we have a valid match, but not to a retranslation
										pApp->m_bMatchedRetranslation = FALSE;
										gnRetransEndSequNum = -1;
										nCount = nCount1;
										if (pTempList != NULL) DeleteTempList(pTempList);
										return TRUE;
									}
									else
									{
										// match is not valid
										bSrcMatchIsRetrans = FALSE;
										sn = nSaveSrcSequNum; // prepare for outer loop
										goto g;
									}
								}
								else if (nSequNum < nSaveSrcSequNum + nCount1)
								{
									if (nSequNum + nCount2 <= nSaveSrcSequNum + nCount1)
									{
										// we have a valid match
										pApp->m_bMatchedRetranslation = FALSE;
										gnRetransEndSequNum = -1;
										nSequNum = nSaveSrcSequNum;
										nCount = nCount1;
										if (pTempList != NULL) DeleteTempList(pTempList);
										return TRUE;
									}
									else
									{
										// match is not valid
										bSrcMatchIsRetrans = FALSE;
										sn = nSaveSrcSequNum; // prepare for outer loop
										goto g;
									}
								}
								else
								{
									bSrcMatchIsRetrans = FALSE;
									sn = nSaveSrcSequNum; // prepare for outer loop
									goto g; // the match in tgt was to the right
											// of end of src match
								}
							}
						}
						else // no match, so continue at next sequ number,
							 // in the pos2 loop for tgt
						{
							sn++;

							if (sn >= nSaveSrcSequNum + nCount1)
							{
								bSrcMatchIsRetrans = FALSE;
								sn = nSaveSrcSequNum;
								goto g;
							}
						}
					}
					// if we get here, pos2 is null, and so we have no later target match
					// possible, so there is no point to trying further source matches
					DeleteTempList(pTempList2);
					if (pTempList != NULL) DeleteTempList(pTempList);
					return FALSE;
					// end of the copied & modified code block
				}
				else
				{
					// clear the globals
					bSrcMatchIsRetrans = FALSE;
					pApp->m_bMatchedRetranslation = FALSE;
					gnRetransEndSequNum = -1;
					sn++;
					nSaveSrcSequNum = -1;
					continue; // continue iterating, looking for a match
				}
			} // end of block for testing if the srcPhrase is in a retranslation

			// we are now back in the outer pos loop:
			// continue searching in the single srcPhrase's target text for a match
			if (bIncludePunct)
				searchStr = pSrcPhrase->m_targetStr;
			else
			{
				if (gbIsGlossing)
				{
						searchStr = pSrcPhrase->m_gloss; // do it 'as is'
				}
				else
				{
					searchStr = pSrcPhrase->m_adaption;
				}
			}
			if (bIgnoreCase)
				searchStr.MakeLower();
			if (searchStr.IsEmpty())
			{
				// check for a null match
				if (tgt.IsEmpty())
				{
					// we have a null match, so success
					nSequNum = sn;
					nCount = 1;
					return TRUE;
				}
				else
				{
					// can't match, so try at a later source match if we can find one
					bSrcMatchIsRetrans = FALSE;
					sn++;
					nSaveSrcSequNum = -1;
					continue;
				}
			}
			else
			{
				if (tgt.IsEmpty())
				{
					bSrcMatchIsRetrans = FALSE;
					sn++;
					nSaveSrcSequNum = -1;
					continue; // can't allow a Find with a null string, it would
							  // match anything so try for a new source match
				}
			}
			nFound = searchStr.Find(tgtCopy);
b:			if (nFound >= 0)
			{
				// we found matching (sub)strings
				nSequNum = sn;
				nCount = 1;
				return TRUE;
			}
			else
			{
g:					sn++; // index for next CSourcePhrase instance to be searched
					nSaveSrcSequNum = -1;
			}
		}
	}

	// if we get here, we didn't find a match
	return FALSE;
}

bool CAdapt_ItView::DoReplace(int		nActiveSequNum,
							  bool		bIncludePunct,
							  wxString& tgt,
							  wxString& replStr,
							  int		nCount)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);

	wxASSERT(nCount >= 1);
	wxASSERT(nActiveSequNum >= 0 && nActiveSequNum <= pApp->GetMaxIndex());
	wxASSERT(nActiveSequNum == pApp->m_nActiveSequNum);
	// both or either of the strings can be empty

	wxString tgtNoPunct = tgt;
	if (!gbIsGlossing)
		RemovePunctuation(pDoc,&tgtNoPunct,from_target_text);
	wxString oldTgtNoPunct;
	oldTgtNoPunct.Empty();
	wxString oldTgt;
	oldTgt.Empty();
	wxString finalStr;
	finalStr.Empty();

	CPile* pPile = GetPile(nActiveSequNum);
	wxASSERT(pPile != NULL);
	CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
	wxASSERT(pSrcPhrase != NULL);

    // if it's a retranslation, the whole will be selected, so nCount will not be 1, even
    // if we didn't choose the multi-srcphrase match option, so check this case out first;
    // if glossing is ON, we ignore the fact that we matched within a retranslation
	if (!gbIsGlossing && pSrcPhrase->m_bRetranslation)
	{
        // we have matched something in a retranslation, so this has to invoke the
        // retranslation editor's dialog which will show the replacement done already when
        // the dialog is shown, user can edit it before dismissing the dialog, or just
        // accept what was done; initialize the globals that OnButtonEditRetranslation()
        // will use
		pApp->GetRetranslation()->SetReplaceInTranslation(TRUE);
		m_SearchStr = tgt;
		m_ReplaceStr = replStr;

		// allow user to edit result
		wxCommandEvent event;
		pApp->GetRetranslation()->OnButtonEditRetranslation(event);

		// clear the globals
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
	}

	// we have to merge first, if nCount is greater than one
	// if glossing is ON, nCount being greater than 1 should not be possible since in
	// that circumstance we don't permit matching across piles
	if (nCount == 1)
	{
		// get the m_adaption member's contents, & m_targetStr;
		// if glossing is ON, then use m_gloss instead
		if (gbIsGlossing)
		{
			oldTgtNoPunct = pSrcPhrase->m_gloss;
			oldTgt = pSrcPhrase->m_gloss;
		}
		else
		{
			oldTgtNoPunct = pSrcPhrase->m_adaption;
			oldTgt = pSrcPhrase->m_targetStr;
		}

        // if we are at a <Not In KB> entry, clear this state because we are going to store
        // something for this entry now (and be sure its not in a retranslation - that is
        // handled differently above
		if (!gbIsGlossing && !pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB &&
			!pSrcPhrase->m_bRetranslation)
		{
			wxString str = _T("<Not In KB>");
			CRefString* pRefString = NULL;
			KB_Entry rsEntry;
			rsEntry = pApp->m_pKB->GetRefString(
							pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
							pApp->m_pActivePile->GetSrcPhrase()->m_key, str, pRefString);
			if (pRefString != NULL && rsEntry == really_present)
			{
                // BEW 17Jul11, we must remove the <Not In KB> entry, and undelete any
                // other deleted entries present, as is done in the CKB::DoNotInKB()
                // function
				CTargetUnit* pTgtUnit = pRefString->m_pTgtUnit;
				wxASSERT(pTgtUnit != NULL);
				TranslationsList* pList = pTgtUnit->m_pTranslations;
				wxASSERT(!pList->IsEmpty());
				TranslationsList::Node* pos = pList->GetFirst();
				// BEW 17Jul11 this while loop is copied verbatim from CKB::DoNotInKB()
				while (pos != NULL)
				{
					CRefString* pRefStr = (CRefString*)pos->GetData();
					pos = pos->GetNext();
					if (pRefStr == pRefString)
					{
						if (rsEntry == present_but_deleted)
						{
							// our work is done for this one, it's deleted already
							;
						}
						else
						{
							wxASSERT(rsEntry == really_present);

							// make the <Not In KB> entry become the deleted one
							pRefString->SetDeletedFlag(TRUE);
							pRefString->GetRefStringMetadata()->SetDeletedDateTime(GetDateTimeNow());
						}
					}
					else
					{
						// it's not the "<Not In KB>" one we matched above, but is currently
						// deleted, so undelete it
						if (pRefStr != NULL && pRefStr->GetDeletedFlag())
						{
							pRefStr->SetDeletedFlag(FALSE);
							pRefStr->GetRefStringMetadata()->SetDeletedDateTime(_T(""));
							// we could leave the old creation datetime intact, but since the
							// entry was 'deleted' it is probably more appropriate to give it
							// the current time as it's (re-)creation datetime
							pRefString->GetRefStringMetadata()->SetCreationDateTime(GetDateTimeNow());
						}
					}
				} // end of while loop
			}

			// fix the flags that will make a save to KB possible
			pSrcPhrase->m_bNotInKB = FALSE;
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pApp->m_bSaveToKB = TRUE;

            // put the replacement string into the global translation variable, which with
            // selector value of 1 in the PlacePhraseBox call, will ensure it goes into
            // m_targetPhrase member, and ends up in the created phrase box
			translation = replStr;

			// prepare for phrase box creation
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = pPile;
			CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

			// place the phrase box
			PlacePhraseBox(pCell,1);

			translation.Empty(); // clear it, no longer needed

			// get a new active pile pointer, the PlacePhraseBox call
			// did a recalc of the layout
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile != NULL);
			pSrcPhrase->m_bHasKBEntry = FALSE; // ensure StoreText won't
											   // crash when later called

            // save old sequ number in case required for toolbar's Back button - after a
            // Replace, the only safe location is the now current active location
			gnOldSequNum = pApp->m_nActiveSequNum;

			Invalidate();
			GetLayout()->PlaceBox();
			return TRUE;
		}
		else if (!gbIsGlossing && pSrcPhrase->m_bNullSourcePhrase && !pSrcPhrase->m_bRetranslation)
		{
			// we are changing tgt text in a null src phrase which is not in a retranslation
			int nFound = -1;
			int lenOldTgt = 0;
			int lenTgt = 0;
			int nRight;
			wxString left;
			left.Empty();
			wxString right;
			right.Empty();
			if (bIncludePunct)
			{
				lenTgt = tgt.Length(); // the search string's length
				lenOldTgt = oldTgt.Length(); // length of the string in
											 // which the search is done
				nFound = oldTgt.Find(tgt);
				wxASSERT(nFound != -1); // must not have failed, since this
									    // was the match done in caller
				left = oldTgt.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgt.Right(nRight);
			}
			else
			{
				lenTgt = tgtNoPunct.Length(); // the search string's length
				lenOldTgt = oldTgtNoPunct.Length(); // length of the string in
													// which the search is done
				nFound = oldTgtNoPunct.Find(tgtNoPunct);
				wxASSERT(nFound != -1); // must not have failed, since this was
									    // the match done in caller
				left = oldTgtNoPunct.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgtNoPunct.Right(nRight);
			}

            // put the final string into the global translation variable, which with
            // selector value of 1 in the PlacePhraseBox call, will ensure it goes into
            // m_targetPhrase member, and ends up in the created phrase box
			translation = left + replStr + right;

			// prepare for phrase box creation
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = pPile;
			CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

            // update pSrcPhrase so it shows the new stuff (we can do this because no KB
            // storage is involved)
			wxString adaptionStr = translation;
			RemovePunctuation(pDoc,&adaptionStr,from_target_text);
			pSrcPhrase->m_adaption = adaptionStr;
			pApp->m_targetPhrase = translation;
			MakeTargetStringIncludingPunctuation(pSrcPhrase,pApp->m_targetPhrase);

			// place the phrase box
			PlacePhraseBox(pCell,1); // selector == 1 inhibits both the
									 // internal restore code blocks
			translation.Empty(); // clear it, no longer needed

			// get a new active pile pointer, the PlacePhraseBox call did a
			// recalc of the layout
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile != NULL);
			pSrcPhrase->m_bHasKBEntry = FALSE;  // ensure its FALSE,
												// since it's a null src phrase
            // save old sequ number in case required for toolbar's Back button - use
            // current location
			gnOldSequNum = pApp->m_nActiveSequNum;

			Invalidate();
			GetLayout()->PlaceBox();
			return TRUE;
		}
		else // normal srcPhrase, or if glossing it could be a null one or
			 // retranslation as well as possibly being just a normal one
		{
			// it's a normal srcPhrase, so go ahead and do the replacement
			int nFound = -1;
			int lenOldTgt = 0;
			int lenTgt = 0;
			int nRight;
			wxString left;
			left.Empty();
			wxString right;
			right.Empty();
			if (bIncludePunct)
			{
				// bIncludePunct is always FALSE for glossing, so this block
				// can never be entered when glossing is ON
				wxASSERT(!gbIsGlossing);
				lenTgt = tgt.Length(); // the search string's length
				lenOldTgt = oldTgt.Length(); // length of the string in
											 // which the search is done
				nFound = oldTgt.Find(tgt);
				wxASSERT(nFound != -1); // must not have failed, since this
									    // was the match done in caller
				left = oldTgt.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgt.Right(nRight);
			}
			else
			{
                // no punctuation case; but can be punctuated string if glossing is ON
                // since glossing being ON will always cause this block to be done
				lenTgt = tgtNoPunct.Length(); // the search string's length
				lenOldTgt = oldTgtNoPunct.Length(); // length of the string in
													// which the search is done
				nFound = oldTgtNoPunct.Find(tgtNoPunct);
				wxASSERT(nFound != -1); // must not have failed, since this was
									    // the match done in caller
				left = oldTgtNoPunct.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgtNoPunct.Right(nRight);
			}

			// put the final string into the temporary store
			finalStr = left + replStr + right;

			// prepare for phrase box creation
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = pPile;
			CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

			// *** TODO *** fix the next bit, we don't want two RecalcLayout()
			// calls - same in 2 blocks above

			// place the phrase box
			PlacePhraseBox(pCell,2); // selector == 2 means location's KB entry will
									 // be removed or ref count decremented if > 1

			// now put the new content in the box
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			pCell = pApp->m_pActivePile->GetCell(1); // we want the 2nd line, for phrase box
			pApp->m_targetPhrase = finalStr;
			RemoveSelection();

#ifdef _NEW_LAYOUT
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			GetLayout()->m_docEditOperationType = default_op; // sets 0,-1 'select all'

			// get a new active pile pointer, the PlacePhraseBox call did a
			// recalc of the layout
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile != NULL);

			// save old sequ number in case required for toolbar's Back button
			// - use current location
			gnOldSequNum = pApp->m_nActiveSequNum;

			Invalidate();
			GetLayout()->PlaceBox();
			return TRUE;
		}
	}
	else // nCount > 1
	{
		// more than one srcPhrase involved, so merge first
		wxASSERT(!gbIsGlossing); // should never get here when glossing is ON
		wxCommandEvent event;
		OnButtonMerge(event);

		if (gbMergeSucceeded)
		{
			// restore the clobbered pointers
			pPile = GetPile(pApp->m_nActiveSequNum);
			pApp->m_pActivePile = pPile;

			// set up the strings in which searching is done, using
			// the globals defined by OnButtonMerge()
			oldTgtNoPunct = gOldConcatStrNoPunct;
			oldTgt = gOldConcatStr;

			// it's now a normal single srcPhrase replacement, so go ahead and do it
			int nFound = -1;
			int lenOldTgt = 0;
			int lenTgt = 0;
			int nRight;
			wxString left;
			left.Empty();
			wxString right;
			right.Empty();
			if (bIncludePunct)
			{
				lenTgt = tgt.Length(); // the search string's length
				lenOldTgt = oldTgt.Length(); // length of the string in
											 // which the search is done
				nFound = oldTgt.Find(tgt);
				wxASSERT(nFound != -1); // must not have failed, since this
									    // was the match done in caller
				left = oldTgt.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgt.Right(nRight);
			}
			else
			{
				lenTgt = tgtNoPunct.Length(); // the search string's length
				lenOldTgt = oldTgtNoPunct.Length(); // length of the string in
													// which the search is done
				nFound = oldTgtNoPunct.Find(tgtNoPunct);
				wxASSERT(nFound != -1); // must not have failed, since this was
									    // the match done in caller
				left = oldTgtNoPunct.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgtNoPunct.Right(nRight);
			}

			// put the final string into the temporary store
			finalStr = left + replStr + right;

			// prepare for phrase box creation
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = pPile;
			CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

			// *** TODO *** fix the next bit, we don't want two RecalcLayout()
			//  calls & same above

			// place the phrase box
			PlacePhraseBox(pCell,2); // selector == 2 means location's KB entry
									 // will be removed or ref count decremented if > 1

			// now put the new content in the box
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			pCell = pApp->m_pActivePile->GetCell(1); // we want the 2nd line,
													 // for phrase box
			pApp->m_targetPhrase = finalStr;
			RemoveSelection();

#ifdef _NEW_LAYOUT
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			GetLayout()->m_docEditOperationType = default_op; // sets 0,-1 'select all'

			// get a new active pile pointer, the PlacePhraseBox call did a
			// recalc of the layout
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile != NULL);

            // update pSrcPhrase here, rather than waiting for another Find Next button
            // click, so than in the event of the latter, the view reflects the changed
            // m_adaption, etc. members
			wxString adaptionStr = finalStr;
			RemovePunctuation(pDoc,&adaptionStr,from_target_text);
			pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
			wxASSERT(pSrcPhrase != NULL);
			pSrcPhrase->m_adaption = adaptionStr;

			// save old sequ number in case required for toolbar's Back button
			// - use current location
			gnOldSequNum = pApp->m_nActiveSequNum;

		}
		else
		{
			RemoveSelection();
			::wxBell();
		}

		Invalidate();
		GetLayout()->PlaceBox();

		// clear the globals
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
	}
}


/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Layout Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. This handler always enables the "Layout Window Right
/// To Left" (or "Layout Window Left To Right") item in the Layout menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAlignment(wxUpdateUIEvent& event)
{
	event.Enable(TRUE); // always enabled
}

/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
void CAdapt_ItView::OnAlignment(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	pApp->LogUserAction(_T("Initiated OnAlignment()"));

	// don't permit a CTRL + 1 accidental keycombo press to flip the layout
	// if we are running the regular app
	if (sizeof(wxChar) == 1)
	{
		// we are running in the regular app, so bale out without doing anything
		return;
	}

	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pLayoutMenuAlignment = pMenuBar->FindItem(ID_ALIGNMENT);
	//wxASSERT(pLayoutMenuAlignment != NULL);

	// toggle the setting & update the display accordingly
	wxString menuItem;
	if (pApp->m_bRTL_Layout)
	{
		// we have an RTL layout and user has just chosen LTR layout
		pApp->m_bRTL_Layout = FALSE; // toggle
		gbRTL_Layout = FALSE; // do the global too
		pApp->LogUserAction(_T("Selected LTR Layout"));

		// change text of the menu item
		//IDS_RTL_LAYOUT
		if (pLayoutMenuAlignment != NULL)
		{
#ifdef __WXMAC__
			pLayoutMenuAlignment->SetItemLabel(_("Layout Window Right To Left\tCtrl-Shift-1"));
#else
			pLayoutMenuAlignment->SetItemLabel(_("Layout Window Right To Left\tCtrl-1"));
#endif
		}
	}
	else
	{
		// we have an LTR layout and user has just chosen RTL layout
		pApp->m_bRTL_Layout = TRUE; // toggle
		gbRTL_Layout = TRUE; // do the global too
		pApp->LogUserAction(_T("Selected RTL Layout"));

		// change text of the menu item
		//IDS_LTR_LAYOUT
		if (pLayoutMenuAlignment != NULL)
		{
#ifdef __WXMAC__
			pLayoutMenuAlignment->SetItemLabel(_("Layout Window Left To Right\tCtrl-Shift-1"));
#else
			pLayoutMenuAlignment->SetItemLabel(_("Layout Window Left To Right\tCtrl-1"));
#endif
		}
	}
#ifdef __WXMAC__
	// GDLC 2011-04-08 The Mac version of AI needs only the two commands not commented out!
	// Question: Will Windows and Linux work correctly with only the two commands PlaceBox() and ClearBackground()?
//	Invalidate();				// Doesn't do anything useful on Mac
//	canvas->ClearBackground();	// On Mac this does the redraw rather than merely clearing the background!
//	GetLayout()->Redraw();		// Not needed on Mac
	GetLayout()->PlaceBox();	// Sets the parameters for the updated placement of the phrase box without changing the screen
	canvas->ClearBackground();	// Updates the contents of the window to show the changed layout direction
#else
	Invalidate();
	canvas->ClearBackground(); // BEW added 23Feb11, because without it, if the layout
		// direction is changed when scrolled away from the top, the screen is garbled
		// until a refresh is forced, and the Invalidate() plus Redraw() calls were not
		// sufficient
	GetLayout()->Redraw(); // yep, works nicely
	GetLayout()->PlaceBox();
#endif
}

// use this function when user changes, or potentially changes, the RTL checkboxes in
// either the wizard, or the preferences fonts page; if both source and target checkboxes
// are off then we silently ensure the layout is switched to LTR, and if both are on, then
// we silently ensure the layout will appear as RTL. The user can subsequently override the
// auto setting with the Layout menu if he chooses.
/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
void CAdapt_ItView::AdjustAlignmentMenu(bool bRTL,bool bLTR)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxMenuItem * pLayoutMenuAlignment = pMenuBar->FindItem(ID_ALIGNMENT);
	//wxASSERT(pLayoutMenuAlignment != NULL);

	// adjust the menu item to fit with the flag values
	wxString menuItem;
	if (bRTL == TRUE && bLTR == FALSE)
	{
		// we should have an RTL layout so set up accordingly
		pApp->m_bRTL_Layout = TRUE;
		gbRTL_Layout = TRUE; // do the global too

		// change text of the menu item ready for next time user accesses it
#ifdef __WXMAC__
		menuItem = _("Layout Window Left To Right\tCtrl-Shift-1"); //menuItem.Format(IDS_LTR_LAYOUT);
#else
		menuItem = _("Layout Window Left To Right\tCtrl-1"); //menuItem.Format(IDS_LTR_LAYOUT);
#endif
		if (pLayoutMenuAlignment != NULL)
		{
			pLayoutMenuAlignment->SetItemLabel(menuItem);
		}
	}
	else
	{
		if (bRTL == FALSE && bLTR == TRUE)
		{
			// we should have an LTR layout so do it
			pApp->m_bRTL_Layout = FALSE;
			gbRTL_Layout = FALSE; // do the global too

			// change text of the menu item ready for next time user accesses it
#ifdef __WXMAC__
			menuItem = _("Layout Window Right To Left\tCtrl-Shift-1"); //IDS_RTL_LAYOUT
#else
			menuItem = _("Layout Window Right To Left\tCtrl-1"); //IDS_RTL_LAYOUT
#endif
			if (pLayoutMenuAlignment != NULL)
			{
				pLayoutMenuAlignment->SetItemLabel(menuItem);
			}
		}
		else
		{
			// do nothing if we have a mixed reading direction situation
			;
		}
	}
}

// BEW 22Feb10 no changes needed for support of doc version 5
bool CAdapt_ItView::IsUnstructuredData(SPList* pList)
{
	// the markers below can just have terminating space, because we call the
	// function on marker strings which have been normalized (ie. newlines
	// replaced by spaces)
	wxString s1 = gSFescapechar;
	wxString verseMkr = s1 + _T("v ");
	wxString verseNumberMkr = s1 + _T("vn ");
	wxString verseTextMkr = s1 + _T("vt ");
	wxString idMkr = s1 + _T("id ");
	wxString chapterMkr = s1 + _T("c ");

	if (pList->GetCount() == 0)
		return TRUE; // certainly data is unstructured, in fact it doesn't exist!
	SPList::Node* posx = pList->GetFirst();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)posx->GetData();
	wxASSERT(pSrcPhrase);
	wxString markers = pSrcPhrase->m_markers;
	int nFound = -1;
	nFound = markers.Find(idMkr);
	if (nFound >= 0)
		return FALSE; // it's structured data because it has an \id line;
            // that would only be there if the \v and other markers were too
            // - at least that's what we will assume
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos);
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase);
		markers = pSrcPhrase->m_markers;
		if (!markers.IsEmpty())
		{
			nFound = -1;
			nFound = markers.Find(verseMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(verseNumberMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(verseTextMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(chapterMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data

            // BEW added 10Apr06 to agree with similar changes in IsUnstructuredPlainText()
            // in the Adapt_ItDoc.cpp file (BEW 18April06, don't include \p here, since it
            // gets temporarily inserted into a non-SFM file, so detecting it would give
            // wrong result!)
			nFound = -1;
			nFound = markers.Find(s1 + _T("s "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("f "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q1 "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q2 "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q3 "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("x "));
			if (nFound >= 0)
				return FALSE; // it's structured data
		}
	}
	return TRUE; // it's unstructured data
}

void CAdapt_ItView::OnSize(wxSizeEvent& event)
{
 	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

    // wx note: event.Skip() must be called here in order to pass the size event
    // on to be handled by the CMainFrame::OnSize() method.
	event.Skip();

    // BEW added 05Mar06: Bill Martin reported (email 3 March) that if user is in free
    // translation mode, and uses either the Shorten of Lengthen buttons (these set
    // gbSuppressSetup to TRUE in the beginning of their handlers, to suppress resetting up
    // of the section for the change in the layout), and then he resizes the window, the
    // app will crash (invalid pile pointer usually). The easiest solution is just to allow
    // the section to be reset - this loses the effect of the shortening or lengthening,
    // but that can easily be done again by hitting the relevant button(s) after the
    // resized layout is redrawn.
	if (pApp->m_bFreeTranslationMode)
	{
		gbSuppressSetup = FALSE;
	}

	// need to initiate a recalc of the layout with new m_docSize value,
	// since strip-wrap is on
	CLayout* pLayout = GetLayout();

    // BEW added this test 6May09, because in the refactored design, an size event was
    // posted from (I think, somewhere in a CreatePiles() call within a RecalcLayout()
    // call, and the event was posted after the list of piles was deleted and before it
    // was recreated - and unfortunately in the legacy OnSize() function there was the
    // following RecalcLayout() call, which then crashes because the pile pointers
    // point at freed memory. The original call of RecalcLayout() was from within
    // OnInitialUpdate(), and that from end of OnNewDocument() and all this re-calling
    // of RecalcLayout() is bad design. Let's see if this safety first test gets us
    // past the crash, and maybe later we can tidy up the design to be less redundant
    // on the layout calls. *** TODO *** Appears to have worked!
	if (!pLayout->GetPileList()->IsEmpty())
	{
		// BEW added 1Aug09, to prevent a crash as follows. If a RecalcLayout() is done
		// with parameter keep_strips_keep_piles when there are piles in the m_pileList
		// but no strips in m_stripArray, then we'll get a (spectacular) crash. This
		// scenario can happen in the following scenario:
		// 1. Run the app, load a document,
		// 2. do File command and chose a different document from the MRU list (same or
		// different project doesn't matter).
        // 3. All proceeds nicely, but during the view's OnInitialUpdate() call, a SetSize
        // is done on the canvas.
        // 4. wxWidgets then posts a size event, and then
        // 5. the view's OnSize() handler is called, and so
        // 6. we get here with a populated pile list, but an empty (or destroyed - not sure
		// which) strip list. So we'll get a crash now unless we do the RecalcLayout()
		// call which takes the parameter create_strips_keep_piles. Hence the following
		// test and the two RecalcLayout() blocks.
		// BEW 20Jan11, added OR gbVerticalEditInProgress to the following test, so that
		// if the user in vertical edit hits a button like Cancel All Steps, we will have
		// the strips rebuilt to be in sync with whatever the restored partner piles happen to
		// be - otherwise there could be a crash because a pile has m_pOwningStrip still
		// set to default NULL value
		if (pLayout->GetStripArray()->IsEmpty() || gbVerticalEditInProgress)
		{
			// we've come here probably from an MRU document opening, strips need building;
			// or from within vertical edit
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
		}
		else
		{
			// we've come here for some other reason, but not a window frame resize
			// because that will use CMainFrame::OnSize() which contains a call to
			// RecalcLayout() using the parameter create_strips_keep_piles; other situations
			// which result in this CAdapt_ItView::OnSize() being called will enter this
			// block and work acceptably without having to change the strip lengths and so
			// keep_strips_keep_piles can be used here (I believe Bill has used the view's
			// OnSize() function to force a frame update in situations where no view
			// resizing is required  **TODO** remove those misused OnSize() calls someday)
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
		}
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		Invalidate();
		GetLayout()->PlaceBox();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Stop Selection At
/// Boundaries" toolbar item and returns immediately: The application is in Free
/// Translation mode, in glossing mode, is showing only the target language text, the
/// active pile is NULL, or there are no source phrases in the m_pSourcePhrases list.
/// Otherwise, it enables the toolbar button if the m_curIndex represents a valid location.
/// Note: The "Stop Selection At Boundaries" toolbar button is the opposite state toggle of
/// the "Ignore Boundaries" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRespectBdry(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	
	// whm added 26Mar12. Disable tool bar button when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Ignore Boundaries"
/// toolbar item and returns immediately: The application is in Free Translation mode, in
/// glossing mode, is showing only the target language text, the active pile is NULL, or
/// there are no source phrases in the m_pSourcePhrases list. Otherwise, it enables the
/// toolbar button if the m_curIndex represents a valid location. Note: The "Ignore
/// Boundaries" toolbar button is the opposite state toggle of the "Stop Selection At
/// Boundaries" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonIgnoreBdry(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	
	// whm added 26Mar12. Disable tool bar button when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_RESPECTING_BDRY bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_RESPECTING_BDRY bitmap image (road with fence across it).
/// Note: The Button image depicts what the current state of boundary respecting/ignoring
/// is, but the tooltip and help text describe what clicking the button will accomplish. If
/// m_bRespectBoundaries is TRUE, this handler insures that the ID_BUTTON_IGNORING_BDRY
/// bitmap image is displayed in the Toolbar, and changes m_bRespectBoundaries to FALSE.
/// The "Ignoring Boundaries" button (witn ID_BUTTON_IGNORING_BDRY image having a road
/// ahead with no fence across it) is displayed on the toolBar after this handler finishes
/// because it shows the user what state the respect/ignore boundaries functionality would
/// be if the user were to press that toolbar button, i.e., the opposite of the current
/// state. Note: The "Respecting Boundaries" toolbar button (having a fence across the
/// road) is the opposite state toggle of the "Ignoring Boundaries" toolbar button . See
/// also OnButtonFromIgnoringBdryToRespectingBdry().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromRespectingBdryToIgnoringBdry(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnButtonRespectBdry() in the MFC version. Since it is a
    // toggle button which changes its appearance I've changed the name of the handler and
    // its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_IGNORING_BDRY);
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_RESPECTING_BDRY);
	// whm 12Oct10 note: these buttons for ignoring/respecting boundaries will probably never
	// be candidates for hiding in a user workflow profile, but in case they do, the
	// wxASSERT and the following test will give notice and prevent a crash.
	wxASSERT(toolPos != wxNOT_FOUND);
	if (toolPos == wxNOT_FOUND)
		return; // whm 12Oct10 added
	if (pApp->m_bRespectBoundaries)
	{
        // The app is currently respecting boundaries. The user wants to switch from
        // respecting to ignoring them. This is effected by setting m_bRespectBoundaries to
        // FALSE.
		pApp->m_bRespectBoundaries = FALSE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the respecting image to the ignoring image. We do
        // this by inserting the ID_BUTTON_IGNORING_BDRY button into position on the
        // toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_IGNORING_BDRY, _T(""),
					AIToolBarBitmapsToggled32x30Func( 0 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Stop Selection At Boundaries"),
					_("Respect boundaries when selecting"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_IGNORING_BDRY, _T(""),
					AIToolBarBitmapsToggledFunc( 0 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Stop Selection At Boundaries"),
					_("Respect boundaries when selecting"));
			}
            // whm Note: Now, the ignoring bdry button is showing on the toolbar. Remember:
            // The tooltip and help text tell what clicking on this hiding button would do,
            // i.e., Respect Boundaries. must call Realize() after adding a new button
			pToolBar->Realize();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_IGNORING_BDRY bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_IGNORING_BDRY bitmap image (road with no fence across
/// it). Note: The Button image depicts what the current state of boundary
/// respecting/ignoring is, but the tooltip and help text describe what clicking the button
/// will accomplish. If m_bRespectBoundaries is FALSE, this handler insures that the
/// ID_BUTTON_RESPECTING_BDRY bitmap image is displayed in the Toolbar, and changes
/// m_bRespectBoundaries to TRUE. The "Respecting Boundaries" button (witn
/// ID_BUTTON_RESPECTING_BDRY image having a fence across the road) is displayed on the
/// toolBar after this handler finishes because it shows the user what state the
/// respect/ignore boundaries functionality would be if the user were to press that toolbar
/// button, i.e., the opposite of the current state. Note: The "Ignoring Boundaries"
/// toolbar button (road ahead with no fence across it) is the opposite state toggle of the
/// "Respecting Boundaries" toolbar button . See also
/// OnButtonFromRespectingBdryToIgnoringBdry().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromIgnoringBdryToRespectingBdry(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnButtonIgnoreBdry() in the MFC version. Since it is a
    // toggle button which changes its appearance I've changed the name of the handler and
    // its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// user or the app wants to restore respect for boundarires, fix accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_IGNORING_BDRY);
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_RESPECTING_BDRY);
	// whm 12Oct10 note: these buttons for ignoring/respecting boundaries will probably never
	// be candidates for hiding in a user workflow profile, but in case they do, the
	// wxASSERT and the following test will give notice and prevent a crash.
	wxASSERT(toolPos != wxNOT_FOUND);
	if (toolPos == wxNOT_FOUND)
		return; // whm 12Oct10 added
	if (!pApp->m_bRespectBoundaries)
	{
		// The app is currently ingoring boundaries. The user wants to switch from ignoring
		// to respecting them. This is effected by setting m_bRespectBoundaries to TRUE.
		pApp->m_bRespectBoundaries = TRUE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the ignoring image to the respecting image. We do
        // this by inserting the ID_BUTTON_RESPECTING_BDRY button into position on the
        // toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if(tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_RESPECTING_BDRY, _T(""),
					AIToolBarBitmapsUnToggled32x30Func( 9 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Ignore Boundaries"),
					_("Ignore boundaries when making selections"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_RESPECTING_BDRY, _T(""),
					AIToolBarBitmapsUnToggledFunc( 9 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Ignore Boundaries"),
					_("Ignore boundaries when making selections"));
			}
            // whm Note: Now, the respecting bdry button is showing on the toolbar.
            // Remember: The tooltip and help text tell what clicking on this hiding button
            // would do, i.e., Ignore Boundaries. must call Realize() after adding a new
            // button
			pToolBar->Realize();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Show Punctuation"
/// toolbar item and returns immediately: The application is in Free Translation mode, in
/// glossing mode, the active pile is NULL, or there are no source phrases in the
/// m_pSourcePhrases list. Otherwise, it enables the toolbar button if the m_curIndex
/// represents a valid location. Note: The "Show Punctuation" toolbar button is the
/// opposite state toggle of the "Hide Punctuation" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonShowPunct(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	
	// whm added 26Mar12. Disable tool bar button when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
    if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_SHOWING_PUNCT bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_SHOWING_PUNCT bitmap image. Note: The Button image
/// depicts what the current state of punctuation showing/hiding is, but the tooltip and
/// help text describe what clicking the button will accomplish. If m_bHidePunctuation is
/// FALSE, this handler insures that the ID_BUTTON_HIDING_PUNCT bitmap image is displayed
/// in the Toolbar, and changes m_bHidePunctuation to TRUE. The "Hiding Punctuation" button
/// (witn ID_BUTTON_HIDING_PUNCT image having curtains closed on stage) is displayed on the
/// toolBar after this handler finishes because it shows the user what state the show/hide
/// punctuation functionality would be if the user were to press that toolbar button, i.e.,
/// the opposite of the current state. Note: The "Showing Punctuation" toolbar button
/// (curtains drawn back revealing an exclamation point) is the opposite state toggle of
/// the "Hiding Punctuation" toolbar button . See also OnButtonFromHidingToShowingPunct().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromShowingToHidingPunct(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnButtonShowPunct() in the MFC version. Since it is a toggle
    // button which changes its appearance I've changed the name of the handler and its ID
    // symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_HIDING_PUNCT);
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_SHOWING_PUNCT);
	// whm 12Oct10 note: these buttons for hiding/showing punctuation will probably never
	// be candidates for hiding in a user workflow profile, but in case they do, the
	// wxASSERT and the following test will give notice and prevent a crash.
	wxASSERT(toolPos != wxNOT_FOUND);
	if (toolPos == wxNOT_FOUND)
		return; // whm 12Oct10 added
	if (!pApp->m_bHidePunctuation)
	{
        // The app is currently showing (not hiding) punctuation. The user wants to switch
        // from showing to hiding. This is effected by setting m_bHidePunctuation to TRUE.
		pApp->m_bHidePunctuation = TRUE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the showing image to the hiding image. We do this
        // by inserting the ID_BUTTON_HIDING_PUNCT button into position on the toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_HIDING_PUNCT, _T(""),
					AIToolBarBitmapsToggled32x30Func( 1 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show Punctuation"),
					_("Show text with punctuation"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_HIDING_PUNCT, _T(""),
					AIToolBarBitmapsToggledFunc( 1 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show Punctuation"),
					_("Show text with punctuation"));
			}
            // whm Note: Now, the hiding punct button is showing on the toolbar. Remember:
            // The tooltip and help text tell what clicking on this hiding button would do,
            // i.e., Show Punctuation. must call Realize() after adding a new button
			pToolBar->Realize();

			if (pApp->m_nActiveSequNum != -1)
			{
				CPile* pPile = GetPile(pApp->m_nActiveSequNum);
				wxASSERT(pPile);
				CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();

				// reset the pApp->m_targetPhrase to hold the source phrase's other member
				pApp->m_targetPhrase = pSrcPhrase->m_adaption;
			}
			CLayout* pLayout = GetLayout();
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			Invalidate();
			GetLayout()->PlaceBox();
		}
	}
	else
	{
		// oops, the boolean was out of sync with the state shown by the view's icon, so
		// have this else block to fix the value; next click of the same button will then work
		// right - but we need to do a Redraw() here, to get punctuation shown - in
		// agreement with this fix of the flag value
		pApp->m_bHidePunctuation = FALSE;

		CLayout* pLayout = GetLayout();
		pLayout->Redraw();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Enable Punctuation
/// Copy" toolbar item (black punctuation characters on a green background) and returns
/// immediately: The application is in Free Translation mode, in glossing mode, the active
/// pile is NULL, or there are no source phrases in the m_pSourcePhrases list. Otherwise,
/// it enables the toolbar button if the m_curIndex represents a valid location. Note: The
/// "Enable Punctuation Copy" toolbar button is the opposite state toggle of the "No
/// Punctuation Copy" toolbar button (black punctuation with yellow background and a red
/// circle and red diagonal bar).
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonEnablePunctCopy(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
 	
	// whm added 26Mar12. Disable tool bar button when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
   if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_ENABLE_PUNCT_COPY bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_ENABLE_PUNCT_COPY bitmap image. The
/// OnButtonEnablePunctCopy() handler is also called directly from the View's
/// OnInitialUpdate(), OnButtonToEnd(), OnButtonToStart(), OnButtonStepDown(),
/// OnButtonStepUp(), JumpForwardToNote_CoreCode(), JumpBackwardToNote_CoreCode(), and from
/// CPhraseBox's MoveToNextPile(), MoveToPrevPile(), MoveToImmedNextPile().
/// If m_bCopySourcePunctuation is FALSE, this handler insures that the
/// ID_BUTTON_NO_PUNCT_COPY bitmap image is displayed in the Toolbar, and changes
/// m_bCopySourcePunctuation to TRUE. The "No Punctuation Copy" button (witn
/// ID_BUTTON_NO_PUNCT_COPY image having black punctuation with yellow background and a red
/// circle and red diagonal bar) is displayed on the toolBar after this handler finishes
/// because it shows the user what state the punctuation copy functionality would be if the
/// user were to press that toolbar button, i.e., the opposite of the current state. Note:
/// The "Enable Punctuation Copy" toolbar button is the opposite state toggle of the "No
/// Punctuation Copy" toolbar button (black punctuation with yellow background and a red
/// circle and red diagonal bar). See also OnButtonNoPunctCopy().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonEnablePunctCopy(wxCommandEvent& event)
{
	// whm note: This OnButtonEnablePunctCopy() handler functions as one
	// half of the toolbar toggle button that toggles between "Copy Punctuation"
	// and "No Copy Punctuation". It only sets m_bCopySourcePunctuation to TRUE
	// if m_bCopySourcePunctuation is FALSE when OnButtonEnablePunctCopy() is
	// called. The other half of the toggle function is done in
	// OnButtonNoPunctCopy().
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// We only want to call the LogUserAction() when this OnButtonEnablePunctCopy()
	// handler is initiated from the toolbar and not when it is being called from other
	// functions, so we look at the id associated with the event.
	if (event.GetId()  == ID_BUTTON_ENABLE_PUNCT_COPY)
	{
		pApp->LogUserAction(_T("Enable Punctation Copy"));
	}

	// toggle the setting and adjust the button image accordingly
    // whm Note: The MFC version starts with both toggle state images in the toolbar images
    // and simply hides one and shows the other as appropriate. The wxToolBar class does
    // not have a HideButton() method, so we Delete the unwanted image from the toolBar,
    // and Insert the image we want into the toolBar. The MFC version also used this
    // OnButtonEnablePunctCopy() handler to set the initial state of the punctuation copy
    // function to TRUE in OnInitialUpdate() and other places, so to be safe we will get
    // the toolPos from either the ID_BUTTON_NO_PUNCT_COPY image or the
    // ID_BUTTON_ENABLE_PUNCT_COPY image, delete whatever image was there, but then
    // unilaterally we insert the ID_BUTTON_NO_PUNCT_COPY into the position of the deleted
    // image. The image names reflect the toggle state that would ensue if the button were
    // pressed, rather than the present state as indicated by the value of
    // m_bCopySourcePunctuation as set at the end of this handler.
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_NO_PUNCT_COPY);
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_ENABLE_PUNCT_COPY);
	// whm 12Oct10 note: these buttons for no/yes punctuation copy will probably never
	// be candidates for hiding in a user workflow profile, but in case they do, the
	// wxASSERT and the following test will give notice and prevent a crash.
	wxASSERT(toolPos != wxNOT_FOUND);
	if (toolPos == wxNOT_FOUND)
		return; // whm 12Oct10 added
	if (!pApp->m_bCopySourcePunctuation)
	{
		// In WX we delete the unwanted button and insert the wanted button to create
		// the toggle effect
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_NO_PUNCT_COPY, _T(""),
					AIToolBarBitmapsUnToggled32x30Func( 27 ), wxNullBitmap,
					wxITEM_CHECK,
					_("No Punctuation Copy"),
					_("Suppress the copying of source text punctuation temporarily"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_NO_PUNCT_COPY, _T(""),
					AIToolBarBitmapsUnToggledFunc( 27 ), wxNullBitmap,
					wxITEM_CHECK,
					_("No Punctuation Copy"),
					_("Suppress the copying of source text punctuation temporarily"));
			}
			// must call Realize() after adding a new button
			pToolBar->Realize();
		}
		// toggle the setting
		pApp->m_bCopySourcePunctuation = TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "No Punctuation Copy"
/// toolbar item (black punctuation with yellow background and a red circle and red
/// diagonal bar) and returns immediately: The application is in Free Translation mode, in
/// glossing mode, the active pile is NULL, or there are no source phrases in the
/// m_pSourcePhrases list. Otherwise, it enables the toolbar button if the m_curIndex
/// represents a valid location. Note: The "No Punctuation Copy" toolbar button is the
/// opposite state toggle of the "Enable Punctuation Copy" toolbar button (black
/// punctuation characters on a green background).
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonNoPunctCopy(wxUpdateUIEvent& event)
{
 	CAdapt_ItApp* pApp = &wxGetApp();
	
	// whm added 26Mar12. Disable tool bar button when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
   if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_NO_PUNCT_COPY bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_NO_PUNCT_COPY bitmap image. If m_bCopySourcePunctuation
/// is TRUE, this handler insures that the ID_BUTTON_ENABLE_PUNCT_COPY bitmap image is
/// displayed in the Toolbar, and changes m_bCopySourcePunctuation to FALSE. The "Enable
/// Punctuation Copy" button (witn ID_BUTTON_ENABLE_PUNCT_COPY image having black
/// punctuation with green background) is displayed on the toolBar after this handler
/// finishes because it shows the user what state the punctuation copy functionality would
/// be if the user were to press that toolbar button, i.e., the opposite of the current
/// state. Note: The "No Punctuation Copy" toolbar button (black punctuation with yellow
/// background and a red circle and red diagonal bar) is the opposite state toggle of the
/// "Enable Punctuation Copy" toolbar button . See also OnUpdateButtonEnablePunctCopy().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonNoPunctCopy(wxCommandEvent& event)
{
	// whm note: This OnButtonNoPunctCopy() handler functions as one
	// half of the toolbar toggle button that toggles between "No Copy Punctuation"
	// and "Copy Punctuation". It only sets m_bCopySourcePunctuation to FALSE
	// if m_bCopySourcePunctuation is TRUE when OnButtonNoPunctCopy() is
	// called. The other half of the toggle function is done in
	// OnButtonEnablePunctCopy().
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// We only want to call the LogUserAction() when this OnButtonNoPunctCopy()
	// handler is initiated from the toolbar and not when it is being called from other
	// functions, so we look at the id associated with the toolbar event.
	if (event.GetId()  == ID_BUTTON_NO_PUNCT_COPY)
	{
		pApp->LogUserAction(_T("No Punctuation Copy"));
	}

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_NO_PUNCT_COPY);
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_ENABLE_PUNCT_COPY);
	// whm 12Oct10 note: these buttons for no/yes punctuation copy will probably never
	// be candidates for hiding in a user workflow profile, but in case they do, the
	// wxASSERT and the following test will give notice and prevent a crash.
	wxASSERT(toolPos != wxNOT_FOUND);
	if (toolPos == wxNOT_FOUND)
		return; // whm 12Oct10 added
	if (pApp->m_bCopySourcePunctuation)
	{
		// In WX we delete the unwanted button and insert the wanted button to
		// create the toggle effect
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_ENABLE_PUNCT_COPY, _T(""),
					AIToolBarBitmapsToggled32x30Func( 3 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Enable Punctuation Copy"),
					_("Re-enable automatic copying of source text punctuation"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_ENABLE_PUNCT_COPY, _T(""),
					AIToolBarBitmapsToggledFunc( 3 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Enable Punctuation Copy"),
					_("Re-enable automatic copying of source text punctuation"));
			}
			// must call Realize() after adding a new button
			pToolBar->Realize();
		}
		// toggle the setting
		pApp->m_bCopySourcePunctuation = FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Hide Punctuation"
/// toolbar item and returns immediately: The application is in Free Translation mode, in
/// glossing mode, the active pile is NULL, or there are no source phrases in the
/// m_pSourcePhrases list. Otherwise, it enables the toolbar button if the m_curIndex
/// represents a valid location. Note: The "Hide Punctuation" toolbar button is the
/// opposite state toggle of the "Show Punctuation" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonHidePunct(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
  	
	// whm added 26Mar12. Disable tool bar button when in read-only mode
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
   if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_HIDING_PUNCT bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_HIDING_PUNCT bitmap image (image with curtains closed).
/// Note: The Button image depicts what the current state of punctuation showing/hiding is,
/// but the tooltip and help text describe what clicking the button will accomplish. If
/// m_bHidePunctuation is TRUE, this handler insures that the ID_BUTTON_SHOWING_PUNCT
/// bitmap image is displayed in the Toolbar, and changes m_bHidePunctuation to FALSE. The
/// "Showing Punctuation" button (witn ID_BUTTON_SHOWING_PUNCT image having curtains drawn
/// back revealing an exclamation point) is displayed on the toolBar after this handler
/// finishes because it shows the user what state the show/hide punctuation functionality
/// would be if the user were to press that toolbar button, i.e., the opposite of the
/// current state. Note: The "Hiding Punctuation" toolbar button (curtains closed on stage)
/// is the opposite state toggle of the "Showing Punctuation" toolbar button . See also
/// OnButtonFromShowingToHidingPunct().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromHidingToShowingPunct(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnButtonHidePunct() in the MFC version. Since it is a toggle
    // button which changes its appearance I've changed the name of the handler and its ID
    // symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_HIDING_PUNCT);
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_SHOWING_PUNCT);
	// whm 12Oct10 note: these buttons for hiding/showing punctuation will probably never
	// be candidates for hiding in a user workflow profile, but in case they do, the
	// wxASSERT and the following test will give notice and prevent a crash.
	wxASSERT(toolPos != wxNOT_FOUND);
	if (toolPos == wxNOT_FOUND)
		return; // whm 12Oct10 added
	if (pApp->m_bHidePunctuation)
	{
        // The app is currently hiding punctuation. The user wants to switch from hiding
        // to showing. This is effected by setting m_bHidePunctuation to FALSE.
		pApp->m_bHidePunctuation = FALSE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the hiding image to the showing image. We do this
        // by inserting the ID_BUTTON_SHOWING_PUNCT button into position on the toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_SHOWING_PUNCT, _T(""),
					AIToolBarBitmapsUnToggled32x30Func( 10 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Hide Punctuation"),
					_("Don't show punctuation with the text"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_SHOWING_PUNCT, _T(""),
					AIToolBarBitmapsUnToggledFunc( 10 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Hide Punctuation"),
					_("Don't show punctuation with the text"));
			}
            // whm Note: Now, the showing punct button is showing on the toolbar. Remember:
            // The tooltip and help text tell what clicking on this hiding button would do,
            // i.e., Hide Punctuation. must call Realize() after adding a new button
			pToolBar->Realize();
			CLayout* pLayout = GetLayout();
			if (pApp->m_nActiveSequNum != -1 && !pLayout->GetPileList()->IsEmpty())
			{
				CPile* pPile = GetPile(pApp->m_nActiveSequNum);
				wxASSERT(pPile);
				CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();

				// reset the pApp->m_targetPhrase to hold the source phrase's other member
				pApp->m_targetPhrase = pSrcPhrase->m_targetStr;
			}
			if (pApp->m_pSourcePhrases != NULL)
			{
				if (!pApp->m_pSourcePhrases->IsEmpty())
				{
#ifdef _NEW_LAYOUT
					pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
					pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
					pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
					Invalidate();
					GetLayout()->PlaceBox();
				}
			}
		}
	}
	else
	{
		// oops, the boolean was out of sync with the state shown by the view's icon, so
		// have this else block to fix the value; next click of the same button will then work
		// right - but we need to do a Redraw() here, to get punctuation hidden - in
		// agreement with this fix of the flag value
		pApp->m_bHidePunctuation = TRUE;

		CLayout* pLayout = GetLayout();
		pLayout->Redraw();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Show Target Text Only"
/// toolbar item and returns immediately: Vertical Editing is in progress, the active pile
/// is NULL, or there are no source phrases in the m_pSourcePhrases list. Otherwise, it
/// enables the toolbar button if m_endIndex is within a valid range. Note: The "Show
/// Target Text Only" toolbar button is the opposite state toggle of the "Show Source And
/// Target Text" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateShowTgt(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_SHOWING_ALL
///                        bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_SHOWING_ALL bitmap image. Note: The Button image depicts what
/// the current state of showing-all/showing-target-only is, but the tooltip and help text
/// describe what clicking the button will accomplish. If gbShowTargetOnly is FALSE, this
/// handler insures that the ID_SHOWING_TGT bitmap image is displayed in the Toolbar, and
/// changes gbShowTargetOnly to TRUE. The "Showing Source And Target Text" button (witn
/// ID_SHOWING_ALL image having pairs of lines representing strips of source and target
/// together) is displayed on the toolBar after this handler finishes because it shows the
/// user what state the target text only functionality would be if the user were to press
/// that toolbar button, i.e., the opposite of the current state. Note: The "Show Source
/// And Target Text" toolbar button is the opposite state toggle of the "Show Target Text
/// Only" toolbar button. See also OnFromShowingAllToShowingTargetOnly().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnFromShowingAllToShowingTargetOnly(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnShowTgt() in the MFC version. Since it is a toggle button
    // which changes its appearance I've changed the name of the handler and its ID symbol
    // names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_SHOWING_TGT);
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_SHOWING_ALL);
	// whm 12Oct10 note: these buttons for showing only target/showing all will probably never
	// be candidates for hiding in a user workflow profile, but in case they do, the
	// wxASSERT and the following test will give notice and prevent a crash.
	wxASSERT(toolPos != wxNOT_FOUND);
	if (toolPos == wxNOT_FOUND)
		return; // whm 12Oct10 added
	if (!gbShowTargetOnly)
	{
		// The app is currently showing all. The user wants to switch from showing all
		// to showing only TGT text. This is effected by setting gbShowTargetOnly to TRUE.

		// must remove any selection first
		RemoveSelection();

		// user wants to show only the target lines, so fix accordingly
		gbShowTargetOnly = TRUE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the showing all image to the showing only target
        // text image. We do this by inserting the ID_SHOWING_TGT button into position on
        // the toolbar.
		gnSaveLeading = pApp->m_curLeading;
		gnSaveGap = pApp->m_curGapWidth;
		pApp->m_curLeading = pApp->m_nTgtHeight / 4;
		int newGapWidth = pApp->m_curGapWidth / 3;
		pApp->m_curGapWidth = wxMax(newGapWidth,10);
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_SHOWING_TGT, _T(""),
					AIToolBarBitmapsToggled32x30Func( 2 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show normal view"),
					_("Show Source And Target Text"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_SHOWING_TGT, _T(""),
					AIToolBarBitmapsToggledFunc( 2 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show normal view"),
					_("Show Source And Target Text"));
			}
            // whm Note: Now, the showing tgt only button is showing on the toolbar.
            // Remember: The tooltip and help text tell what clicking on this hiding button
            // would do, i.e., Show Source and Target Text. Must call Realize() after
            // adding a new button
			pToolBar->Realize();
			CLayout* pLayout = GetLayout();
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			Invalidate();
			GetLayout()->PlaceBox();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Show Source And
/// Target Text" toolbar item (pairs of lines representing strips) and returns immediately:
/// Vertical Editing is in progress, the active pile is NULL, or there are no source
/// phrases in the m_pSourcePhrases list. Otherwise, it enables the toolbar button if
/// m_endIndex is within a valid range.
/// Note: The "Show Source And Target Text" toolbar button is the opposite state toggle of
/// the "Show Target Text Only" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateShowAll(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_SHOWING_TGT
///                        bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_SHOWING_TGT bitmap image. The
/// OnFromShowingTargetOnlyToShowingAll() handler is also called directly from the View's
/// OnInitialUpdate(), OnFind(), and OnReplace(). Note: The Button image depicts what the
/// current state of showing-all/showing-target-only is, but the tooltip and help text
/// describe what clicking the button will accomplish. If gbShowTargetOnly is TRUE, this
/// handler insures that the ID_SHOWING_ALL bitmap image is displayed in the Toolbar, and
/// changes gbShowTargetOnly to FALSE. The "Showing ALL" button (witn ID_SHOWING_ALL image
/// having pairs of lines representing strips of source and target together) is displayed
/// on the toolBar after this handler finishes because it shows the user what state the
/// showing-all/showing-target-text-only functionality would be if the user were to press
/// that toolbar button, i.e., the opposite of the current state. Note: The "Showing Target
/// Text Only" toolbar button is the opposite state toggle of the "Showing All" toolbar
/// button. See also OnFromShowingAllToShowingTargetOnly().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnFromShowingTargetOnlyToShowingAll(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnShowAll() in the MFC version. Since it is a toggle button
    // which changes its appearance I've changed the name of the handler and its ID symbol
    // names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_SHOWING_TGT);
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_SHOWING_ALL);
	// whm 12Oct10 note: these buttons for showing only target/showing all will probably never
	// be candidates for hiding in a user workflow profile, but in case they do, the
	// wxASSERT and the following test will give notice and prevent a crash.
	wxASSERT(toolPos != wxNOT_FOUND);
	if (toolPos == wxNOT_FOUND)
		return; // whm 12Oct10 added
	if (gbShowTargetOnly)
	{
        // The app is currently showing only target lines. The user wants to switch from
        // showing only the target text to showing all. This is effected by setting
        // gbShowTargetOnly to FALSE.
		gbShowTargetOnly = FALSE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the showing target only image to the showing all
        // image. We do this by inserting the ID_SHOWING_ALL button into position on the
        // toolbar.
		pApp->m_curLeading = gnSaveLeading;
		pApp->m_curGapWidth = gnSaveGap;
		gnSaveLeading = 4;
		gnSaveGap = 8;
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if(tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_SHOWING_ALL, _T(""),
					AIToolBarBitmapsUnToggled32x30Func( 24 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show Target Text Only"),
					_("Show target text only"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_SHOWING_ALL, _T(""),
					AIToolBarBitmapsUnToggledFunc( 24 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show Target Text Only"),
					_("Show target text only"));
			}
            // whm Note: Now, the showing all button is showing on the toolbar. Remember:
            // The tooltip and help text tell what clicking on this hiding button would do,
            // i.e., Show Target Text Only. Must call Realize() after adding a new button
			pToolBar->Realize();
			CLayout* pLayout = GetLayout();
			if (pApp->m_pSourcePhrases != NULL)
			{
				if (!pApp->m_pSourcePhrases->IsEmpty())
				{
#ifdef _NEW_LAYOUT
					pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
					pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
					pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
					Invalidate();
					GetLayout()->PlaceBox();
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the KB is in a ready state the "Wrap At Standard
/// Format Markers" item on the View menu is enabled, otherwise the menu item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateMarkerWrapsStrip(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT( pApp != NULL);

	// testing one kb is enough
	if (pApp->m_bKBReady && pApp->m_pKB != NULL)
	{
		event.Enable(TRUE); // enable, whether doc open or not
	}
	else
	{
		event.Enable(FALSE); // disable if not got an open project
	}
}

/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
void CAdapt_ItView::OnMarkerWrapsStrip(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pViewMarkerWrapsStrip = pMenuBar->FindItem(ID_MARKER_WRAPS_STRIP);

	// whm Note: Since OnMarkerWrapsStrip() is also called from the View's OnInitialUpdate()
	// we test here to make sure we're logging the actual menu item call and not the
	// OnInitialUpdate call.
	if (event.GetId() == ID_MARKER_WRAPS_STRIP)
	{
		if (pApp->m_bMarkerWrapsStrip)
			pApp->LogUserAction(_T("Turn Marker Wraps Strip OFF"));
		else
			pApp->LogUserAction(_T("Turn Marker Wraps Strip ON"));
	}

	// toggle the setting & update the display accordingly
	if (pApp->m_bMarkerWrapsStrip)
	{
		// toggle the checkmark to OFF & recalc the layout with wrap caused by
		// markers turned off
		if (pViewMarkerWrapsStrip != NULL)
		{
			pViewMarkerWrapsStrip->Check(FALSE);
		}
		pApp->m_bMarkerWrapsStrip = FALSE;
	}
	else
	{
		// toggle the checkmark to ON, and recalc the layout with wrap caused by
		// markers turned on
		if (pViewMarkerWrapsStrip != NULL)
		{
			pViewMarkerWrapsStrip->Check(TRUE);
		}
		pApp->m_bMarkerWrapsStrip = TRUE;
	}

	// redraw everything -- CreateStrip() in RecalcLayout uses the
	// m_bMarkerWrapsStrip flag to do the wanted wraps
	CLayout* pLayout = GetLayout();
	if (pApp->m_pSourcePhrases != NULL)
	{
		if (!pApp->m_pSourcePhrases->IsEmpty())
		{
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			Invalidate();
			GetLayout()->PlaceBox();
		}
	}
}

void CAdapt_ItView::ReDoMerge(int nSequNum,SPList* pNewList,SPList::Node* posNext,
							  CSourcePhrase* pFirstSrcPhrase, int nCount)
{
	SPList::Node* pos = posNext; // since posNext comes from the caller,
								 // it is already the 'next' position
	// starting from the next minimal srcPhrase, Merge each succeeding one to
	// pFirstSrcPhrase
	for (int i = 1; i < nCount; i++)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase);
		// no phrases allowed
		wxASSERT(pSrcPhrase->m_nSrcWords == 1 || pSrcPhrase->m_nSrcWords == 0);

		pFirstSrcPhrase->Merge(this,pSrcPhrase);
	}

	// count how many have to be removed from the m_pSourcePhrases list on the app
	int nRemoveCount = nCount - 1; // that is, all but the first

	// remove from the list the ones which have been merged to the first
	pos = pNewList->Item(nSequNum + 1); // position of first to be removed
	SPList::Node* savePos;
	wxASSERT(pos != NULL);
	int j = 0;
	while (pos != NULL && j < nRemoveCount)
	{
		savePos = pos;
		//CSourcePhrase* pSrcPhrase;
		//pSrcPhrase = (CSourcePhrase*)pos->GetData(); // not really used
		pos = pos->GetNext();
		pNewList->DeleteNode(savePos); // remove pointer, but leave srcPhrase
		j++;						   // on the heap, because it is pointed at
									   // from within pFirstSrcPhrase now
	}

	// update the sequence numbers which follow the first src phrase
	UpdateSequNumbers(nSequNum);

	// set up the m_inform attribute, if there are medial markers
	if (pFirstSrcPhrase->m_bHasInternalMarkers)
	{
		wxString s = _(" Medial markers: ");
		if (!pFirstSrcPhrase->m_pMedialMarkers->IsEmpty())
		{
			// We'll iterate through the array with a for loop
			for (int i = 0; i < (int)pFirstSrcPhrase->m_pMedialMarkers->GetCount(); i++)
			{
				s += pFirstSrcPhrase->m_pMedialMarkers->Item(i);
			}
			pFirstSrcPhrase->m_inform += s;
		}
	}
}

void CAdapt_ItView::SelectDragRange(CCell* pAnchor,CCell* pCurrent)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pCurrent != NULL);
	if (pAnchor == NULL)
		return;

	// are boundaries to be ignored?
    // if m_bRespectBoundaries is FALSE because user clicked the button, for a SHIFT
    // select, SelectDragRange sometimes gets called, and if we unilaterally start with
    // bIgnoreBoundaries as FALSE then it can result in a long selection being wrongly
	// shortened to the loc'n of the first bounding srcPhrase when what would be wanted is
	// the long selection should be honoured. So we test for either the control key down,
	// or the Ignore Boundaries button having been clicked - if either or both is true,
	// then we ignore boundaries
	bool bIgnoreBoundaries = FALSE;
	if (!pApp->m_bRespectBoundaries || wxGetKeyState(WXK_CONTROL))
		bIgnoreBoundaries = TRUE;

	if (pAnchor->GetCellIndex() != pCurrent->GetCellIndex())
	{
		// cells are on different line, so cannot make a valid selection
		SelectAnchorOnly(); // just sets the selection to the anchor pile's cell
		return;
	}

	// set the direction
	if (pAnchor->GetPile()->GetSrcPhrase()->m_nSequNumber <
					pCurrent->GetPile()->GetSrcPhrase()->m_nSequNumber)
		pApp->m_curDirection = right;
	else if (pAnchor->GetPile()->GetSrcPhrase()->m_nSequNumber >
					pCurrent->GetPile()->GetSrcPhrase()->m_nSequNumber)
		pApp->m_curDirection = left;
	else
		return; // since we must be at the anchor which is already selected,
				// so nothing to be done yet

	SelectAnchorOnly(); // reduce to just the anchor, before we rebuild the selection
	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context
	canvas->DoPrepareDC(aDC); // get origin adjusted
	aDC.SetBackgroundMode(pApp->m_backgroundMode);
	aDC.SetTextBackground(wxColour(255,255,0)); // yellow

	int cellIndex = pAnchor->GetCellIndex();
	CCell* pCell = pAnchor;
	bool bAtEnd = FALSE;
	bool bAtBoundary = FALSE;
	if (pApp->m_curDirection == right)
	{
a:		pCell = GetNextCell(pCell,cellIndex);

		if (IsTypeDifferent(pApp->m_pAnchor,pCell))
		{
			CMainFrame *pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame != NULL);
			if (pFrame->canvas->HasCapture())
			{
				pFrame->canvas->ReleaseMouse(); // assume no failure
			}
			// IDS_DIFF_TEXT_TYPE
			wxMessageBox(_(
"Sorry, you are trying to select text of different types, such as a heading and verse text, or some other illegal combination. Combining verse text with poetry is acceptable, other combinations are not."),
			_T(""), wxICON_INFORMATION | wxOK);
			RemoveSelection();
			pApp->m_mouse.x = pApp->m_mouse.y = -1;
			pApp->m_pAnchor = NULL;
			Invalidate();  // UpdateWindow() doesn't work, need the delayed update
			GetLayout()->PlaceBox();
			gbHaltedAtBoundary = FALSE;
			return;
		}

		if (pCell == pCurrent)
			bAtEnd = TRUE; // use this in our break out test later
		if (!bIgnoreBoundaries && pCell->GetPile()->GetSrcPhrase()->m_bBoundary)
		{
			bAtBoundary = TRUE; // can't go further, must respect this boundary
								// because CTRL key not down
			gbHaltedAtBoundary = TRUE; // for use by OnLButtonUp()
		}
		if (cellIndex == 0)
		{
			pCell->DrawCell(&aDC, GetLayout()->GetSrcColor()); // draw it
							// selected (background is set yellow already)
		}
		else
		{
			pCell->DrawCell(&aDC, GetLayout()->GetTgtColor()); // draw it
							// selected (background is set yellow already)
		}
		pCell->SetSelected(TRUE); // ensure updates continue to show it selected
		pApp->m_selection.Append(pCell); // store pointer in the selection list
		if (!(bAtEnd || bAtBoundary))
			goto a;
	}
	else
	{
b:		pCell = GetPrevCell(pCell,cellIndex);

		if (IsTypeDifferent(pApp->m_pAnchor,pCell))
		{
			CMainFrame *pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame != NULL);
			if (pFrame->canvas->HasCapture())
			{
				pFrame->canvas->ReleaseMouse(); // assume no failure
			}
			// IDS_DIFF_TEXT_TYPE
			wxMessageBox(_(
"Sorry, you are trying to select text of different types, such as a heading and verse text, or some other illegal combination. Combining verse text with poetry is acceptable, other combinations are not."),
			_T(""), wxICON_INFORMATION | wxOK);
			RemoveSelection();
			pApp->m_mouse.x = pApp->m_mouse.y = -1;
			pApp->m_pAnchor = NULL;
			Invalidate();
			GetLayout()->PlaceBox();
			gbHaltedAtBoundary = FALSE;
			return;
		}

		if (pCell == pCurrent)
			bAtEnd = TRUE; // use this in our break out test later
		if (!bIgnoreBoundaries && pCell->GetPile()->GetSrcPhrase()->m_bBoundary)
		{
			bAtBoundary = TRUE; // can't go further, must respect this
								// boundary because CTRL key not down
			gbHaltedAtBoundary = TRUE; // for use by OnLButtonUp()
		}
		if (!bAtBoundary)
		{
			if (cellIndex == 0)
			{
				pCell->DrawCell(&aDC, GetLayout()->GetSrcColor()); // draw it
								// selected (background is set yellow already)
			}
			else
			{
				pCell->DrawCell(&aDC, GetLayout()->GetTgtColor()); // draw it
								// selected (background is set yellow already)
			}
			pCell->SetSelected(TRUE); // ensure updates continue to show it selected
			pApp->m_selection.Insert(pCell); // store pointer in the selection list
		}
		if (!bAtEnd)
			goto b;
	}
	CMainFrame *pFrame = pApp->GetMainFrame();
#ifdef __WXMAC__
	// Mac needs this to eliminate shadow printing of values displaced on lower part
	// of screen - due to double buffering?
	pFrame->SendSizeEvent(); // whm added 21Feb09 This causes more flicker during drag
#else
	// Windows and Linux seem to only require Update()
	pFrame->canvas->Update();
#endif
}

// shortens the selection so that it is just the anchor cell
void CAdapt_ItView::SelectAnchorOnly()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pApp->m_pAnchor != NULL);
	CCell* pAnchor = pApp->m_pAnchor;
	wxASSERT(pAnchor);
	int cellIndex = pAnchor->GetCellIndex();

	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context
	canvas->DoPrepareDC(aDC); // get origin adjusted

	CCellList* pList = &pApp->m_selection;
	wxASSERT(pList);
	CCellList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		CCell* pCell = (CCell*)pos->GetData();
		pos = pos->GetNext();
		if (pCell == pAnchor)
			continue;
		else
		{
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			if (cellIndex == 0)
			{
				pCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			}
			else
			{
				pCell->DrawCell(&aDC, GetLayout()->GetTgtColor());
			}
			pCell->SetSelected(FALSE);
		}
	}
	// now remove from the selection list the cells which were deselected
	pList->Clear(); //pList->RemoveAll();
	pList->Insert(pAnchor);
	wxASSERT(pList->GetCount() == 1); // should only be one left in the list
	CMainFrame *pFrame = pApp->GetMainFrame();
#ifdef __WXMAC__
	// Mac needs this to eliminate shadow printing of values displaced on
	// lower part of screen - due to double buffering?
	pFrame->SendSizeEvent(); // whm added 21Feb09 This causes more flicker during drag
#else
	// Windows and Linux seem to only require Update()
	pFrame->canvas->Update();
#endif
}

// poetry is not treated as different than verse, but any other mismatch
// is considered to be a real mismatch
bool CAdapt_ItView::IsTypeDifferent(CCell* pAnchor, CCell* pCurrent)
{
	TextType aType = pAnchor->GetPile()->GetSrcPhrase()->m_curTextType;
	TextType curType = pCurrent->GetPile()->GetSrcPhrase()->m_curTextType;
	if (curType == aType)
		return FALSE;
	if (aType == verse)
	{
		if (curType == poetry)
			return FALSE;
		else
			return TRUE;
	}
	else if (aType == poetry)
	{
		if (curType == verse)
			return FALSE;
		else
			return TRUE;
	}
	else
		return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the TargetBox is in focus this handler enables the
/// Edit Undo menu item, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditUndo(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxWindow* pWnd = wxWindow::FindFocus();
	if (pWnd == (wxWindow*)pApp->m_pTargetBox)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::OnEditUndo(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxWindow* pWnd = wxWindow::FindFocus();
	if (pWnd == (wxWindow*)pApp->m_pTargetBox)
	{
		if (pApp->m_pTargetBox->m_backspaceUndoStr.IsEmpty())
		{
			pApp->m_pTargetBox->Undo();
		}
		else
		{
			pApp->m_pTargetBox->OnEditUndo(event);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the idle handler
///                        and responded to by the Guesser tool bar button
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism as it enables/disables the associated
/// tool bar item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonGuesserSettings(wxUpdateUIEvent& event)
{
	// enable when a project is open since changes may require reading
	// kb correspondences
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	
	// whm added 26Mar12. Disable tool bar button when in read-only mode.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is generated when the Guesser
///                         tool bar button is pressed
/// \remarks
/// Calls up the GuesserSettingsDlg dialog.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonGuesserSettings(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CGuesserSettingsDlg gsDlg(pApp->GetMainFrame());
	if (gsDlg.ShowModal() == wxID_OK)
	{
		// Assign any new settings to the App's corresponding members if we
		// detect any changes made in GuesserSettingsDlg.

		// Generally the Guesser's correspondence lists are populated when a
		// project is opened by calling LoadGuesser() after a LoadKB() or a
		// LoadGlossingKB() call. If an administrator previously turned OFF
		// the guesser, and is now turning it back on, or adjusted the guesser
		// level we need to load/reload the Guesser instances here
		if ((gsDlg.bUseAdaptationsGuesser && !pApp->m_bUseAdaptationsGuesser)
			|| gsDlg.nGuessingLevel != pApp->m_nGuessingLevel)
		{
			pApp->LoadGuesser(pApp->m_pGlossingKB);
			pApp->LoadGuesser(pApp->m_pKB);
		}
		pApp->m_bUseAdaptationsGuesser = gsDlg.bUseAdaptationsGuesser;
		pApp->m_nGuessingLevel = gsDlg.nGuessingLevel;
		pApp->m_GuessHighlightColor = gsDlg.tempGuessHighlightColor;

		pApp->m_bAllowGuesseronUnchangedCCOutput = gsDlg.bAllowCConUnchangedGuesserOutput;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the KBs are in a ready state this handler enables
/// the "Import to Knowledge Base..." item on the File menu, otherwise it disables the menu
/// item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateImportToKb(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// whm added 26Mar12.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

// BEW 13May10, changes needed for support of glossing; calls CKB::DoKBImport( )
void CAdapt_ItView::OnImportToKb(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	pApp->LogUserAction(_T("Initiated OnImportToKb()"));

	// whm revised 6Aug11. See the App's OnFileExportToKb() for similar revisions.
	// We don't know what protected folder to use for KB imports
	// until the user specifies either SFM or LIFT. That specification previously
	// would occur at the time the user gets the wxFileDialog and accesses the
	// "File Type" drop-down list of options. However, with navigation protection we
	// don't provide a standard wxFileDialog where a user can make that selection.
	// Therefore, we get that decision earlier via a KBExportImportOptionsDlg, and
	// not from the wxFileDialog - even when no protection is in effect. Doing so, I
	// think will simplify the file naming process too.

	// While nav protection is ON, the user doesn't see a wxFileDialog where the
	// Open File of Type dropdown box is an option. So, we have to ask the user directly
	// whether s/he wants LIFT or SFM (\lx \ge) format of KB export. We'll set the
	// kbImportType according to the user's response.
	KBImportFileOfType kbImportType = KBImportFileOfSFM_TXT;
	CKBExportImportOptionsDlg dlg(pApp->GetMainFrame());
	dlg.Center();

	wxString actionTypeStr = _("Import to Knowledge Base");
	// set dialog's title
	dlg.SetTitle(actionTypeStr);
	// set the %s substitution strings in the dialog's controls
	wxString tempStr;
	tempStr = dlg.pRadioBoxSfmOrLIFT->GetLabel();
	tempStr = tempStr.Format(tempStr,actionTypeStr.c_str());
	dlg.pRadioBoxSfmOrLIFT->SetLabel(tempStr);

	// for Import to KB, we hide the Filename options in the dialog, and resize the dialog
	// Note: this requires that the first parameter of the call of
	// KBExportImportOptionsFunc(this, false, TRUE) in KBExportImportOptionsDlg's
	// constructor be false
	dlg.pKBExportImportOptionsDlgSizer->Hide(pKBExpImpCheckBoxesSizer,TRUE);
	dlg.pKBExportImportOptionsDlgSizer->Layout();
	dlg.m_computedDlgSize = dlg.pKBExportImportOptionsDlgSizer->ComputeFittingWindowSize(&dlg);
	dlg.SetSize(dlg.m_computedDlgSize);
	dlg.CenterOnParent();

	if (dlg.ShowModal() == wxID_CANCEL)
	{
		// user canceled
		pApp->LogUserAction(_T("Cancelled from OnFileExportKb()"));
		return;
	}

	// if we get here user has clicked OK to proceed
	int nRadioBoxSel;
	nRadioBoxSel = dlg.pRadioBoxSfmOrLIFT->GetSelection();
	wxASSERT(nRadioBoxSel == 0 || nRadioBoxSel == 1);
	kbImportType = (KBImportFileOfType)nRadioBoxSel; // cast int to KBExportSaveAsType enum
	wxASSERT(kbImportType == KBImportFileOfSFM_TXT || kbImportType == KBImportFileOfLIFT_XML);

	wxString defaultDir;
	bool bBypassFileDialog_ProtectedNavigation = FALSE;
	if (kbImportType == KBImportFileOfSFM_TXT)
	{
		pApp->LogUserAction(_T("Import Type SFM"));
		// The user wants KB import in standard format (\x and \ge).
		// Check whether navigation protection is in effect for _KB_INPUTS_OUTPUTS,
		// and whether the App's m_lastKbOutputPath is empty or has a valid path,
		// and set the defaultDir for the export accordingly.
		if (pApp->m_bProtectKbInputsAndOutputsFolder)
		{
			// Navigation protection is ON, so set the flag to bypass the wxFileDialog
			// and force the use of the special protected folder for the export.
			bBypassFileDialog_ProtectedNavigation = TRUE;
			defaultDir = pApp->m_kbInputsAndOutputsFolderPath;
		}
		else if (pApp->m_lastKbOutputPath.IsEmpty()
			|| (!pApp->m_lastKbOutputPath.IsEmpty() && !::wxDirExists(pApp->m_lastKbOutputPath)))
		{
			// Navigation protection is OFF so we set the flag to allow the wxFileDialog
			// to appear. But the m_lastKbOutputPath is either empty or, if not empty,
			// it points to an invalid path, so we initialize the defaultDir to point to
			// the special protected folder, even though Navigation protection is not ON.
			// In this case, the user could point the export path elsewhere using the
			// wxFileDialog that will appear.
			bBypassFileDialog_ProtectedNavigation = FALSE;
			defaultDir = pApp->m_kbInputsAndOutputsFolderPath;
		}
		else
		{
			// Navigation protection is OFF and we have a valid path in m_lastKbOutputPath,
			// so we initialize the defaultDir to point to the m_lastKbOutputPath for the
			// location of the export. The user could still point the export path elsewhere
			// in the wxFileDialog that will appear.
			bBypassFileDialog_ProtectedNavigation = FALSE;
			defaultDir = pApp->m_lastKbOutputPath;
		}
	}
	else if (kbImportType == KBImportFileOfLIFT_XML)
	{
		pApp->LogUserAction(_T("Import Type LIFT"));
		// Check whether navigation protection is in effect for _LIFT_INPUTS_OUTPUTS,
		// and whether the App's m_lastKbLiftOutputPath is empty or has a valid path,
		// and set the defaultDir for the export accordingly.
		if (pApp->m_bProtectLiftInputsAndOutputsFolder)
		{
			// Navigation protection is ON, so set the flag to bypass the wxFileDialog
			// and force the use of the special protected folder for the export.
			bBypassFileDialog_ProtectedNavigation = TRUE;
			defaultDir = pApp->m_liftInputsAndOutputsFolderPath;
		}
		else if (pApp->m_lastKbLiftOutputPath.IsEmpty()
			|| (!pApp->m_lastKbLiftOutputPath.IsEmpty() && !::wxDirExists(pApp->m_lastKbLiftOutputPath)))
		{
			// Navigation protection is OFF so we set the flag to allow the wxFileDialog
			// to appear. But the m_lastKbLiftOutputPath is either empty or, if not empty,
			// it points to an invalid path, so we initialize the defaultDir to point to
			// the special protected folder, even though Navigation protection is not ON.
			// In this case, the user could point the export path elsewhere using the
			// wxFileDialog that will appear.
			bBypassFileDialog_ProtectedNavigation = FALSE;
			defaultDir = pApp->m_liftInputsAndOutputsFolderPath;
		}
		else
		{
			// Navigation protection is OFF and we have a valid path in m_lastKbLiftOutputPath,
			// so we initialize the defaultDir to point to the m_lastKbLiftOutputPath for the
			// location of the export. The user could still point the export path elsewhere
			// in the wxFileDialog that will appear.
			bBypassFileDialog_ProtectedNavigation = FALSE;
			defaultDir = pApp->m_lastKbLiftOutputPath;
		}
	}

	// whm modified 7Jul11 to bypass the wxFileDialog when the import is protected from
	// navigation.
	wxString inputPath;
	if (!bBypassFileDialog_ProtectedNavigation)
	{
		wxString filter;

		if (kbImportType == KBImportFileOfSFM_TXT)
		{
			filter = _(
			"SFM plain text import (from \\lx & \\ge fields) (*.txt)|*.txt|All Files (*.*)|*.*||");
		}
		else if (kbImportType == KBImportFileOfLIFT_XML)
		{
			filter = _(
			"XML LIFT import (*.lift)|*.lift|All Files (*.*)|*.*||");
		}
		wxString importFilename = _T(""); // empty string
		wxFileDialog fileDlg(
			(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
			_("Filename for KB import"),
			defaultDir,	// empty string causes it to use the
						// current working directory (set above)
			importFilename,	// default filename
			filter,
			wxFD_OPEN);
			// | wxHIDE_READONLY); wxHIDE_READONLY deprecated in 2.6 - the checkbox is never shown
			// GDLC wxOPEN deprecated in 2.8
		fileDlg.Centre();

		// open as modal dialog
		if (fileDlg.ShowModal() != wxID_OK)
		{
			pApp->LogUserAction(_T("Cancelled OnImportToKb() at wxFileDialog()"));
			return; // user cancelled
		}

		// get the user's desired path and file name
		inputPath = fileDlg.GetPath();
	}
	else
	{
		// While nav protection is ON, the user doesn't see a wxFileDialog. We set
		// the path automatically to the special folder at m_kbInputsAndOutputsFolderPath
		// and collect a list of possible filenames from that folder from which
		// the user can choose from a monocline list via a wxGetSingleChoiceIndex()
		// dialog.
		wxString extStr;
		wxString myCaption;
		if (kbImportType == KBImportFileOfSFM_TXT)
		{
			// determine exportPath to the _KB_INPUTS_OUTPUTS folder using the dictFilename
			inputPath = pApp->m_kbInputsAndOutputsFolderPath;
			extStr = _T("*.txt");
			myCaption = _("Import KB Records from SFM File");
		}
		else if (kbImportType == KBImportFileOfLIFT_XML)
		{
			// determine exportPath to the _LIFT_INPUTS_OUTPUTS folder using the dictFilename
			inputPath = pApp->m_liftInputsAndOutputsFolderPath;
			extStr = _T("*.lift");
			myCaption = _("Import KB Records from LIFT File");
		}

		wxArrayString kbImportFilesIncludingPaths;
		wxArrayString kbImportFilesNamesOnly;
		// Get an array list of possible imput files. Note: wxDIR_FILES gets files only,
		// no directories. The wxArrayString will contain file names only, no paths.
		wxDir::GetAllFiles(inputPath,&kbImportFilesIncludingPaths,extStr,wxDIR_FILES);
		int totFiles = (int)kbImportFilesIncludingPaths.GetCount();
		if (totFiles > 0)
		{
			int ct;
			for (ct = 0; ct < totFiles; ct++)
			{
				wxFileName fn(kbImportFilesIncludingPaths.Item(ct));
				wxString fNameOnly = fn.GetFullName();
				kbImportFilesNamesOnly.Add(fNameOnly);
			}
		}
		wxString message = _("Choose a file from the following list:\n(from the location: %s):");
		message = message.Format(message,inputPath.c_str());
		// whm 6Aug11 Note: We could use a ::wxGetMultipleChoices() call here which
		// would enable a user to import multiple files into the KB (but would require
		// changing the logic below to loop over each selected file).
		int returnValue = wxGetSingleChoiceIndex(message,myCaption,
			kbImportFilesNamesOnly,(wxWindow*)pApp->GetMainFrame(),-1,-1,true,250,100);
		if (returnValue == -1)
		{
			pApp->LogUserAction(_T("Cancelled OnImportToKb() at wxGetSingleChoiceIndex()"));
			return; // user pressed Cancel or OK with nothing selected (list empty)
		}
		inputPath = inputPath + pApp->PathSeparator + kbImportFilesNamesOnly.Item(returnValue); // this has just the file name
	}

	// update m_lastKbOutputPath
	// whm Note: We set the App's m_lastKbOutputPath variable with the
	// path part of the exportPath just used. We do this even when navigation
	// protection is on, so that the special folders would be the initial path
	// suggested if the administrator were to switch Navigation Protection OFF.
	wxString path, fname, ext;
	wxFileName::SplitPath(inputPath, &path, &fname, &ext);
	if (kbImportType == KBImportFileOfSFM_TXT)
	{
		// the  user chose File Of Type of "SFM plain text import (from \\lx & \\ge fields) (*.txt)"
		// or "All Files (*.*)" which we assume would be same as "SFM plain text import..."
		if (gbIsGlossing)
			pApp->m_pGlossingKB->DoKBImport(inputPath,KBImportFileOfSFM_TXT);
		else
			pApp->m_pKB->DoKBImport(inputPath,KBImportFileOfSFM_TXT);

		// update the last kb output path
		pApp->m_lastKbOutputPath = path;
	}
	else if (kbImportType == KBImportFileOfLIFT_XML)
	{
		if (gbIsGlossing)
			pApp->m_pGlossingKB->DoKBImport(inputPath,KBImportFileOfLIFT_XML);
		else
			pApp->m_pKB->DoKBImport(inputPath,KBImportFileOfLIFT_XML);

		// update the last kb Lift output path
		pApp->m_lastKbLiftOutputPath = path;
	}
}

void CAdapt_ItView::OnImportEditedSourceText(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	CAdapt_ItView* pView = pApp->GetView();
	pApp->LogUserAction(_T("Initiated OnImportEditedSourceText()"));

	// choose a spanlimit int value, (a restricted range of CSourcePhrase instances), use
	// the AdaptitConstant.h value SPAN_LIMIT, set currently to 60. This should be large
	// enough to guarantee some "in common" text which wasn't user-edited, within a span
	// of that size.
	int nSpanLimit = SPAN_LIMIT;

	// get an input buffer for the new source text
// GDLC Do we really need this wxString buffer???
	wxString buffer;
	wxString* pBuffer = &buffer;

	wxString message;
	message = _(
"Import your edited version of the source text which belongs to the currently open document");

	wxString filter;
	filter = _("SFM plain text import(*.txt)|*.txt|All Files (*.*)|*.*||");
	wxString importFilename = _T(""); // empty string
	wxString defaultDir = pApp->m_curProjectPath;
	wxFileDialog fileDlg(
		(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
		message,
		defaultDir,	// empty string causes it to use the
					// current working directory (set above)
		importFilename,	// default filename
		filter,
		wxFD_OPEN);
	fileDlg.Centre();
	// open as modal dialog
	if (fileDlg.ShowModal() != wxID_OK)
	{
		pApp->LogUserAction(_T("Cancelled OnImportEditedSourceText()"));
		return; // user cancelled
	}

	wxString pathName;
	pathName = fileDlg.GetPath(); // gets directory and filename

	// copied from OnNewDocument() -- better, failsafe code with file contents checking;
	// but using a local pBuffer pointer instead of the m_pBuffer in the application class
	switch(GetNewFile(pBuffer,pApp->m_nInputFileLength,pathName))
	{
	case getNewFile_success:
	{
        // BEW added 26Aug10. In case we are loading a marked up file we earlier
        // exported, our custom markers in the exported output would have been changed
        // to \z-prefixed forms, \zfree, \zfree*, \znote, etc. Here we must convert
        // back to our internal marker forms, which lack the 'z'. (The z was to support
        // Paratext import of data containing 3rd party markers unknown to
        // Paratext/USFM.)
		ChangeParatextPrivatesToCustomMarkers(*pBuffer);

		// whm wx version: moved the following OverwriteUSFMFixedSpaces and
        // OverwriteUSFMDiscretionaryLineBreaks calls here from within TokenizeText
        // if user requires, change USFM fixed spaces (marked by the ~ character) to a space - this does not change the
        // length of the data in the buffer
		if (pApp->m_bChangeFixedSpaceToRegularSpace)
			pDoc->OverwriteUSFMFixedSpaces(pBuffer);

        // Change USFM discretionary line breaks // to a pair of spaces. We do this
        // unconditionally because these types of breaks are not likely to be
        // located in the same place if allowed to pass through to the target text,
        // and are usually placed in the translation in the final typesetting
        // stage. This does not change the length of the data in the buffer.
		pDoc->OverwriteUSFMDiscretionaryLineBreaks(pBuffer);

#ifndef __WXMSW__
#ifndef _UNICODE
		// whm added 12Apr2007
		OverwriteSmartQuotesWithRegularQuotes(pBuffer);
#endif
#endif

		// parse the input file
		int nHowMany;
		SPList* pSourcePhrases = new SPList; // for storing the new tokenizations
		nHowMany = TokenizeTextString(pSourcePhrases, *pBuffer, 0); // 0 = initial sequ number value
		SPList* pMergedList = new SPList; // to store the results of the importing & merging

		// compute the new list from the old one plus the tokenized newly updated list
		if (nHowMany > 0)
		{
			MergeUpdatedSourceText(*pApp->m_pSourcePhrases, *pSourcePhrases, pMergedList, nSpanLimit);

            // take the pMergedList list, delete the app's m_pSourcePhrases list's
            // contents, & move to m_pSourcePhrases the pointers in pMergedList...
 			SPList::Node* posCur = pApp->m_pSourcePhrases->GetFirst();
			while (posCur != NULL)
			{
				CSourcePhrase* pSrcPhrase = posCur->GetData();
				posCur = posCur->GetNext();
				pDoc->DeleteSingleSrcPhrase(pSrcPhrase); // also delete partner piles
			}
			// now clear the pointers from the list
			pApp->m_pSourcePhrases->Clear();
			wxASSERT(pApp->m_pSourcePhrases->IsEmpty());

			// make deep copies of the pMergedList instances and add them to the emptied
			// m_pSourcePhrases list, and delete the instance in pMergedList each time
			SPList::Node* posnew = pMergedList->GetFirst();
			CSourcePhrase* pSP = NULL;
			while (posnew != NULL)
			{
				CSourcePhrase* pSrcPhrase = posnew->GetData();
				posnew = posnew->GetNext();
				pSP = new CSourcePhrase(*pSrcPhrase); // shallow copy
				pSP->DeepCopy(); // make shallow copy into a deep one
				pApp->m_pSourcePhrases->Append(pSP); // ignore the Node* returned
				// we no longer need the one in pMergedList
				pDoc->DeleteSingleSrcPhrase(pSrcPhrase, FALSE);
			}
			pMergedList->Clear(); // doesn't try to delete the pointers' memory because
								  // DeleteContents(TRUE) was not called beforehand
			if (pMergedList != NULL) // whm 11Jun12 added NULL test
				delete pMergedList; // don't leak memory

            // after the above changes that result in the modifications to m_pSourcePhrases
            // being finished ... delete the temporary new list of CSourcePhrase instances
            // created by tokenizing the edited source text read in above
			SPList::Node* pos = pSourcePhrases->GetFirst();
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = pos->GetData();
				pos = pos->GetNext();
				pDoc->DeleteSingleSrcPhrase(pSrcPhrase, FALSE); // don't delete partner piles,
																// as there are none anyway
			}
			pSourcePhrases->Clear();
			if (pSourcePhrases != NULL) // whm 11Jun12 added NULL test
				delete pSourcePhrases; // don't leak memory

			// get the nav text stuff updated
			int unusedInt = 0;
			TextType dummyType = verse;
			bool bPropagationRequired = FALSE;
			pDoc->DoMarkerHousekeeping(pApp->m_pSourcePhrases, unusedInt, dummyType, bPropagationRequired);
		}
		else
		{
			// no CSourcePhrase token instances...
			if (pApp->m_pSourcePhrases->IsEmpty())
			{
				wxMessageBox(_(
"Warning: there was no source language data in the file you imported, so the document has not been changed."),
					_T(""), wxICON_EXCLAMATION | wxOK);

				// restore everything
				//pApp->m_pTargetBox->ChangeValue(_T(""));
				pView->Invalidate();
				GetLayout()->PlaceBox();
				pApp->LogUserAction(_T("Warning: there was no source language data in the file you imported, so the document has not been changed."));
				return;
			}
		}

        // Get any unknown markers stored in the m_markers member of the Doc's
        // source phrases whm ammended 29May06: Bruce desired that the filter
        // status of unk markers be preserved for new documents created within the
        // same project within the same session, so I've changed the last parameter
        // of GetUnknownMarkersFromDoc from setAllUnfiltered to
		// useCurrentUnkMkrFilterStatus. (Re-call this because the user may have removed,
		// added or edited USFM or SFM markers before importing the edited source text)
		pDoc->GetUnknownMarkersFromDoc(pApp->gCurrentSfmSet, &pApp->m_unknownMarkers,
								&pApp->m_filterFlagsUnkMkrs,
								pApp->m_currentUnknownMarkersStr,
								useCurrentUnkMkrFilterStatus);

		// calculate the layout in the view

		CLayout* pLayout = GetLayout();
		pLayout->SetLayoutParameters(); // calls InitializeCLayout() and
					// UpdateTextHeights() and calls other relevant setters
#ifdef _NEW_LAYOUT
		bool bIsOK = pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#else
		bool bIsOK = pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#endif
		if (!bIsOK)
		{
			// unlikely to fail, so just have something for the developer here
			wxMessageBox(_T("Error. RecalcLayout(TRUE) failed in OnImportEditedSourceText()"),
			_T(""), wxICON_STOP);
			wxASSERT(FALSE);
			pApp->LogUserAction(_T("Error. RecalcLayout(TRUE) failed in OnImportEditedSourceText()"));
			wxExit();
		}

		// mark document as modified
		pDoc->Modify(TRUE);

		// show the initial phraseBox - place it at the first empty target slot
		pApp->m_pActivePile = GetPile(0);

		pApp->m_nActiveSequNum = 0;
		bool bTestForKBEntry = FALSE;
		//CKB* pKB; // set but not used
		if (gbIsGlossing) // should not be allowed to be TRUE when OnNewDocument is called,
						  // but I will code for safety, since it can be handled okay
		{
			bTestForKBEntry = pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry;
			//pKB = pApp->m_pGlossingKB;
		}
		else
		{
			bTestForKBEntry = pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry;
			//pKB = pApp->m_pKB;
		}
		if (bTestForKBEntry)
		{
			// it's not an empty slot, so search for the first empty one & do it there; but if
			// there are no empty ones, then revert to the first pile
			CPile* pPile = pApp->m_pActivePile;
			pPile = pView->GetNextEmptyPile(pPile);
			if (pPile == NULL)
			{
				// there was none, so we must place the box at the first pile
				pApp->m_pTargetBox->m_textColor = pApp->m_targetColor;
				pView->PlacePhraseBox(pApp->m_pActivePile->GetCell(1));
				pView->Invalidate();
				pApp->m_nActiveSequNum = 0;
				gnOldSequNum = -1; // no previous location exists yet
				return;
			}
			else
			{
				pApp->m_pActivePile = pPile;
				pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber;
			}
		}

		// BEW added 10Jun09, support phrase box matching of the text colour chosen
		if (gbIsGlossing && gbGlossingUsesNavFont)
		{
			pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
		}
		else
		{
			pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
		}

		// set initial location of the targetBox
		pApp->m_targetPhrase = pView->CopySourceKey(pApp->m_pActivePile->GetSrcPhrase(),FALSE);
		translation = pApp->m_targetPhrase;
		pApp->m_pTargetBox->m_textColor = pApp->m_targetColor;
		pView->PlacePhraseBox(pApp->m_pActivePile->GetCell(1),2); // calls RecalcLayout()

		// set the initial global position variable
		pApp->LogUserAction(_T("Import edited source text completed"));
		break;
	}// end of case getNewFile_success
	case getNewFile_error_at_open:
	{
		wxString strMessage;
		strMessage = strMessage.Format(_("Error opening file %s."),pathName.c_str());
		wxMessageBox(strMessage,_T(""), wxICON_ERROR | wxOK);
		pApp->LogUserAction(strMessage);
		break;
	}
	case getNewFile_error_opening_binary:
	{
        // A binary file - probably not a valid input file such as a MS Word doc.
        // Notify user that Adapt It cannot read binary input files, and abort the
        // loading of the file.
		wxString strMessage = _(
		"The file you selected for input appears to be a binary file.");
		wxString strMessage2;
		strMessage2 = strMessage2.Format(_("Error opening file %s."),pathName.c_str());
		strMessage2 += _T("\n");
		strMessage2 += strMessage;
		wxMessageBox(strMessage2,_T(""), wxICON_ERROR | wxOK);
		pApp->LogUserAction(strMessage2);
		break;
	}
	case getNewFile_error_ansi_CRLF_not_in_sequence:
	{
        // this error cannot occur, because the code where it may be generated is
        // never entered for a GetNewFile() call made in OnNewDocument, but the
        // compiler needs a case for this enum value otherwise there is a warning
        // generated
		wxMessageBox(_T("Input data malformed: CR and LF not in sequence"),
		_T(""),wxICON_ERROR | wxOK);
		pApp->LogUserAction(_T("Input data malformed: CR and LF not in sequence"));
		break;
	}
	case getNewFile_error_no_data_read:
	{
		// we got no data, so this constitutes a read failure
		wxMessageBox(_("File read error: no data was read in"),_T(""),wxICON_ERROR | wxOK);
		pApp->LogUserAction(_T("File read error: no data was read in"));
		break;
	}
	case getNewFile_error_unicode_in_ansi:
	{
		// The file is a type of Unicode, which is an error since this is the ANSI build. Notify
		// user that Adapt It Regular cannot read Unicode input files, and abort the loading of the
		// file.
		wxString strMessage = _("The file you selected for input is a Unicode file.");
		strMessage += _T("\n");
		strMessage += _("This Regular version of Adapt It cannot process Unicode text files.");
		strMessage += _T("\n");
		strMessage += _(
		"You should install and use the Unicode version of Adapt It to process Unicode text files.");
		wxString strMessage2;
		strMessage2 = strMessage2.Format(_("Error opening file %s."),pathName.c_str());
		strMessage2 += _T("\n");
		strMessage2 += strMessage;
		wxMessageBox(strMessage2,_T(""), wxICON_ERROR | wxOK);
		pApp->LogUserAction(strMessage2);
		break;
	}
	}// end of switch()
}

void CAdapt_ItView::OnUpdateImportEditedSourceText(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	
	// whm added 26Mar12.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	
	if (pApp->m_bCollaboratingWithParatext || pApp->m_bCollaboratingWithBibledit)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
	{
		// BEW 26Mar12, removed the test for gnOldSequNum as it is irrelevant for whether
		// or not to import edited source text (it's designed primarily for support of the
		// Back button, and I think I cloned this code from elsewhere and didn't realize that
		// this test here would wrongly prevent an import to a just-opened document in which the
		// phrase box has not yet been moved)
		//if (gnOldSequNum == -1)
		//	event.Enable(FALSE);
		//else
			event.Enable(TRUE);
	}
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If
/// Vertical editing is in progress this handler disables the Back button and returns
/// immediately. Otherwise, if there are source phrases in the App's m_pSourcePhrases list,
/// if the App's m_endIndex is within a valid range, and if the global gnOldSequNum does
/// not equal -1, this handler enables the toolBar's "Jump Back" button, otherwise it
/// disables the toolBar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonBack(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() &&
		pApp->m_nActiveSequNum >= 0)
	{
		if (gnOldSequNum == -1)
			event.Enable(FALSE);
		else
			event.Enable(TRUE);
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonBack(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	if (gnOldSequNum == -1)
	{
		::wxBell();
		return;
	}

	// there must be a valid earlier active location, so jump to there
	int nOldSequNum;
	if (pApp->m_nActiveSequNum == -1)
	{
		// current location is at eof, so gnOldSequNum will need to be set to -1
		nOldSequNum = -1;
	}
	else
	{
		nOldSequNum = pApp->m_nActiveSequNum; // location we are about to leave
											  // becomes new old one
	}
	CPile* pPile = GetPile(gnOldSequNum);
	if (pPile != NULL)
	{
		// define the new active location & jump there
		pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber;
		Jump(pApp,pPile->GetSrcPhrase());
	}
	// update its value from the saved one in the local variable
	gnOldSequNum = nOldSequNum;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If the
/// active pile pointer is NULL or there are no source phrases in the App's
/// m_pSourcePhrases list, or the App's m_endIndex is not within a valid range, the
/// toolBar's "View Translation or Glosses Elsewhere In The Document" button is disabled,
/// otherwise it is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonEarlierTranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonEarlierTranslation(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// check that the dialog is not currently open, if it is, delete it
	wxString saveSrc;
	saveSrc.Empty();
	wxString saveTgt; // for version 2.0 and onwards, this can double
					 // for either adaptation text or glossing text,
					 // depending on the gbIsGlossing flag
	saveTgt.Empty();
	if (pApp->m_pEarlierTransDlg != NULL)
	{
		pApp->m_pEarlierTransDlg->Destroy();
		pApp->m_pEarlierTransDlg = NULL;
	}

	if (pApp->m_pEarlierTransDlg == NULL)
	{
		pApp->m_pEarlierTransDlg = new CEarlierTranslationDlg(pApp->GetMainFrame());
		// don't use Create in wx dialogs

		// set default parameter values
		pApp->m_pEarlierTransDlg->m_srcText = _T("");
		pApp->m_pEarlierTransDlg->m_tgtText = _T("");
		pApp->m_pEarlierTransDlg->m_strBeginChVerse = _T("");
		pApp->m_pEarlierTransDlg->m_strEndChVerse = _T("");
		pApp->m_pEarlierTransDlg->m_bIsVerseRange = FALSE;
		pApp->m_pEarlierTransDlg->m_nChapter = 0;
		pApp->m_pEarlierTransDlg->m_nVerse = 0;
		pApp->m_pEarlierTransDlg->m_nVerseRangeEnd = 0;

		AdjustDialogPosition(pApp->m_pEarlierTransDlg);
		pApp->m_pEarlierTransDlg->Show(TRUE);
	}
	else
	{
		AdjustDialogPosition(pApp->m_pEarlierTransDlg);
		pApp->m_pEarlierTransDlg->Show(TRUE);
	}
}

// whm added 26Mar12. Disable mode bar control when in read-only mode
void CAdapt_ItView::OnUpdateButtonNoAdapt(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

void CAdapt_ItView::OnButtonNoAdapt(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	pApp->m_bForceAsk = FALSE; // ensure it's off
	CPile* pCurPile = pApp->m_pActivePile;

    // make sure the store will succeed, and if the pApp->m_targetPhrase has a gloss or
    // adaptation in the appropriate KB then remove it or reduce its reference count before
    // we clear out the contents of m_targetPhrase; but if a selection is current, then
    // don't do the above, but instead assume a merge is wanted first - so do the merge,
    // and then make the <no adaptation> button click apply to the merged phrase thereby
    // produced. (Feature change requested by Wolfgang Stradner, Oct 28 04)
	if (pApp->m_selectionLine != -1 && pApp->m_selection.GetCount() > 1 && !gbIsGlossing)
	{
		// move the active location for restoration of the view to first
		// cell of the selection, if not there already
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = cpos->GetData();
		int saveSequNum = pCell->GetPile()->GetSrcPhrase()->m_nSequNumber;
		pApp->m_nActiveSequNum = saveSequNum; // BEW added 18Apr09
		OnButtonMerge(event);
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(saveSequNum);
		pCurPile = pApp->m_pActivePile;
	}
	else
	{

        // remove the ref string for the active location, if it exists
		if (gbIsGlossing)
			pApp->m_pGlossingKB->GetAndRemoveRefString(pApp->m_pActivePile->GetSrcPhrase(),
												pApp->m_targetPhrase, useTargetPhraseForLookup);
		else
			pApp->m_pKB->GetAndRemoveRefString(pApp->m_pActivePile->GetSrcPhrase(),
												pApp->m_targetPhrase, useTargetPhraseForLookup);
	}

	pApp->m_targetPhrase.Empty(); // clear out the attribute on the view
	pApp->m_pTargetBox->ChangeValue(_T("")); // clear out the box too
	if (gbIsGlossing)
		pApp->m_pActivePile->GetSrcPhrase()->m_gloss.Empty();
	else
	{
		pApp->m_pActivePile->GetSrcPhrase()->m_adaption.Empty();
		pApp->m_pActivePile->GetSrcPhrase()->m_targetStr.Empty();
	}

    // the TRUE flag is required, since it leads to the store being automatically
    // done - otherwise, no store would be done for the empty adaptation
	bool bOK;
	if (gbIsGlossing)
		bOK = pApp->m_pGlossingKB->StoreText(pCurPile->GetSrcPhrase(),
						pApp->m_targetPhrase,TRUE);
	else
		bOK = pApp->m_pKB->StoreText(pCurPile->GetSrcPhrase(),
						pApp->m_targetPhrase,TRUE);
	bOK = bOK; // avoid warning
	// layout the strips
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

    // remove any selection, but don't redraw, so need to do it without calling
    // RemoveSelection() because the layout's pointers are now not matched by those in
    // m_selection.
	gnSelectionLine = -1;
	gnSelectionStartSequNum = -1;
	gnSelectionEndSequNum = -1;
	pApp->m_selectionLine = -1;
	pApp->m_pAnchor = NULL;
	if (pApp->m_selection.GetCount() > 0)
		pApp->m_selection.Clear();

	GetLayout()->m_docEditOperationType = on_button_no_adaptation_op;
	Invalidate();
	GetLayout()->PlaceBox();
}

// whm added 14Aug06 as a temporary measure to prevent editing of source text when
// the selection contains any filtered information (BEW 15 Aug 06: it will probably be
// a permanent measure as source editing when there is filtered info would be hard to
// control since the editing could do anything and the filtered info be anything!)
bool CAdapt_ItView::IsFilteredInfoInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // let the caller have the burden of
					  // aborting the edit it the list is empty

	// BEW added next (two) lines 27Dec07 to only reject the attempt when
	// filtered info is on non-first
	pSrcPhrase = (CSourcePhrase*)pos->GetData(); // allow filtered info
												 // on first in the list
	pos = pos->GetNext();

	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_markers.Find(filterMkr) != -1)
			return TRUE;
	}
	return FALSE;
}

bool CAdapt_ItView::IsFreeTranslationInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // let the caller have the burden of aborting
					  // the edit it the list is empty

    // BEW added next (two) lines 27Dec07 to only reject the attempt when starting of a
    // free trans is not on the first CSourcePhrase instance in the selection
	pSrcPhrase = (CSourcePhrase*)pos->GetData(); // allow filtered info
												 // on first in the list
	pos = pos->GetNext();

	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		// BEW changed 27Dec07, see above: if (pSrcPhrase->m_bHasFreeTrans)
		if (pSrcPhrase->m_bStartFreeTrans)
			return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Edit Source Text..." item on the Edit menu is
/// disabled if any of the following conditions is TRUE: Vertical Editing is in progress,
/// the m_pActivePile is NULL, the application is in Free Translation mode. Otherwise it is
/// enabled only if some source text selected.
/// BEW modified 13Nov09 - don't allow local user with read-only access to cause
/// update of a remote user's document's source text!
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditSourceText(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	// whm added 25May11 We disable the Edit Source Text... menu command when collaborating
	// with Paratext or Bibledit - it is in the external editor where the source text should be
	// edited - otherwise source text can get out of sync with what is in the external
	// editor, since we don't transfer source text back to PT or BE
	if (pApp->m_bCollaboratingWithBibledit || pApp->m_bCollaboratingWithParatext)
	{
		event.Enable(FALSE);
		return;
	}

	// BEW updated, 11Apr08, to remove the "not when in free translation mode" modality
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
    // added test for no phrase box currently defined (this can happen when user has
    // advanced the box past the last pile within the document) -- we'll not allow editing
    // of the source when the app is in this state, as there is no valid current sequence
    // number (formerly, this test was in the edit source text command handler, but is more
    // appropriate here)
	if (pApp->m_pActivePile == NULL)
	{
		// The phrase box must first must be placed at
		// one of the piles before the edit is enabled
		event.Enable(FALSE);
		return;
	}

	// currently, we won't allow it when free translation mode is turned on; but when vertical
	// editing as a multi-step process is implemented, we can remove this constraint
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there were no internal errors; FALSE if something went belly up
///             requiring the edit to be aborted (but the app continues, the document
///             isn't changed)
/// \param      pSrcPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		<->	(input)reference to the sequence number for the first pile
///                                 in the user's selection; (output) the sequence number value
///                                 for the first pile after any extension leftwards was done
/// \param      nEndingSN		<->	(input)reference to the sequence number for the last pile
///                                 in the user's selection; (output) the sequence number value
///                                 for the last pile after any extension rightwards was done
/// \param      bIsExtended		<-	reference to BOOL indicating whether extension was required
///                                 and done (TRUE) or not required and not done (FALSE)
/// \remarks
/// Called from: The View's OnEditSourceText().
/// Automatically extends the user's selection of the source text to be edited where
/// necessary to include source text material (and filtered/hidden material) that should be
/// dealt with when editing the source text. We save processing time by not bothering to
/// actually use the m_selection list; extension only is required if we have a
/// retranslation in or partly in the span of the user's manual selection, and we can
/// easily test for that by looking at flag values on CSourcePhrase instances. The caller
/// only needs to know what the final sequence numbers of the span for editing are.
/// "Leftwards" in this function is to be interpretted as "to lower sequence numbers", & so
/// if we are dealing with a right-to-left language data, it would be rightwards to the
/// user.
/// BEW checked 18Feb10, no changes needed for support of doc version 5
/// BEW 9July10, no changes needed for support of kbVersion 2
/// BEW 11Oct10, added a check for placeholders at either end, if needing data transfer,
/// then the selection has to be extended to ensure the transfer can be done
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ExtendEditSourceTextSelection(SPList* pSrcPhrases, int& nStartingSN,
												  int& nEndingSN, bool& bIsExtended)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// 12Apr08, BEW added this function
	bIsExtended = FALSE;
	int nIteratorSN = 0; // use when scanning forwards or backwards
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		// whm Note: The following error message does not need to be available for localization
		wxMessageBox(_T(
"FindIndex() failed in ExtendEditSourceTextSelection(), pos value is NULL. Saving document & cancelling this editing attempt..."),
		 _T(""), wxICON_EXCLAMATION | wxOK);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* savePos = pos; // keep for when we later scan forwards
	pSrcPhrase = pos->GetData();
	pos = pos->GetPrevious();
	if (pSrcPhrase->m_bRetranslation)
	{
		// the user's first selected pile is within a retranslation,
		// so possibly extension left is required
		if (!pSrcPhrase->m_bBeginRetranslation)
		{
			// the first pile of the user's selection is not the first pile in
			// the retranslation, so extension leftwards is needed
			while (TRUE)
			{
				if (pos == NULL)
				{
					// we have come to the start of the document, so extending
					// further left is not possible
					break;
				}
				// get the previous CSourcePhrase at the new POSITION
				pSrcPhrase = pos->GetData();
				pos = pos->GetPrevious();
				nStartingSN = pSrcPhrase->m_nSequNumber;
				bIsExtended = TRUE;
				if (pSrcPhrase->m_bBeginRetranslation)
				{
					// we are at the start of the retranslation, so break out
					break;
				}
			}
		}
		// We have established the nStartingSN value, now we need to work out
		// where this particular retranslation ends - it may end before, at, or
		// after the user's selection's end (in fact, there may be more than one
		// retranslation in his selection). So now we must here scan across the
		// current retranslation to its end, then work out if it contains the
		// end of the user's selection - if so, we are done, if not, we must
		// proceed to the outer block to continue scanning to higher sequence numbers
		pos = savePos; // restore starting POSITION; we must start from here because the
					   // user may have selected only a single word
		while (pos != NULL)
		{
			savePos = pos; // save the POSITION
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			nIteratorSN = pSrcPhrase->m_nSequNumber;

			// if we get to a higher sequence number than the end of the user's
			// selection, the selection is being extended and we must register
			// that fact using the next test
			if (nIteratorSN > nEndingSN)
			{
				bIsExtended = TRUE;
			}
			if (pSrcPhrase->m_bEndRetranslation)
			{
				// we are at the end of the retranslation, so break out
				break;
			}
		}
		// return if we have inclusion or are at the doc end
		if (nIteratorSN >= nEndingSN || pos == NULL)
		{
			// the end of the user's original selection is earlier than the
			// end of the retranslation, or coincides with it, or we
			// are at the end of the document; hence we are done
			nEndingSN = nIteratorSN; // update the value being returned to the caller
			return TRUE; // no errors
		}

	}
	// If control gets to here, then either the starting pile of the user's selection
	// was not in a retranslation (in which case no exending leftwards was needed) and
	// the POSITION value is still at the start of the user's selection; or we have just
	// iterated across a retranslation but have not yet reached the final pile of the
	// user's selection. In either case, we must continue iterating rightwards until we
	// get to the user's selection end - then, once there, if that is within a(nother)
	// retranslation, we must extend further rightwards to the end of that one, but
	// if not, we are done
	pos = savePos; // initialize iterator
	pSrcPhrase = pos->GetData(); // get the next pos value
	pos = pos->GetNext();
	nIteratorSN = pSrcPhrase->m_nSequNumber; // initialize sequence number iterator
	while (pos != NULL && nIteratorSN < nEndingSN)
	{
		// iterate forwards to the end of the user's selection
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nIteratorSN = pSrcPhrase->m_nSequNumber;
	}
	if (pos == NULL)
	{
		// we reached the end of the document
		nEndingSN = nIteratorSN; // pass back the last CSourcePhrase instance's sequ num
		return TRUE; // if we return here, we've not done any rightwards extension
	}

    // If control gets to here, then we are not at the document's end, but have reached the
    // last pile of the user's selection. This may be as far as we need go, but we must
    // test for this pile being within a(nother) retranslation, and if it is, we must
    // extend rightwards to the end of that retranslation & end there; otherwise, we are
    // done
    bool bGotAnEnd = FALSE;
	if (!pSrcPhrase->m_bRetranslation)
	{
		// no extending is needed for this reason
		nEndingSN = nIteratorSN;
		//return TRUE; // no errors
		bGotAnEnd = TRUE;
	}
	else
	{
		// extending rightwards is needed
		bIsExtended = TRUE;
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			nIteratorSN = pSrcPhrase->m_nSequNumber; // update the sequ num iterator
			if (pSrcPhrase->m_bEndRetranslation)
			{
				// we don't extend any further, the whole retranslation is in
				// the span we've now identified
				nEndingSN = nIteratorSN;
				//return TRUE; // no errors
				bGotAnEnd = TRUE;
				break;
			}
		} // end of while loop
	}
	if (bGotAnEnd)
	{
		// We have got an end of the span, at least as far as extension due to
		// retranslation is concerned; or there was no extension and we are at the user's
		// last selected pile. We now have to protect our code from there being a
		// placeholder at the start or end of the span, and data transfer is needed to a
		// CSourcePhrase instance which is, so far, still outside the span - we can't do
		// the transfers needed unless we pull the needed CSourcePhrase into the span too.
		// So this protection is what we guarantee in this block - it may require
		// extending one instance to the left, or to the right, or both, depending on where the
		// placeholders are and whether or not they have data needing to be transferred.
		SPList::Node* posSpanStart = pSrcPhrases->Item(nStartingSN);
		SPList::Node* posSpanEnd = pSrcPhrases->Item(nEndingSN);
		CSourcePhrase* pSrcPhrase_AtStart = posSpanStart->GetData();
		CSourcePhrase* pSrcPhrase_AtEnd = posSpanEnd->GetData();
		CPlaceholder* pPH = pApp->GetPlaceholder();
		if (pSrcPhrase_AtStart->m_bNullSourcePhrase)
		{
			if (pPH->NeedsTransferBackwards(pSrcPhrase_AtStart))
			{
				// extend one instance to left (right, if RTL reading order), but both are
				// handled here as a decrease by one in the nStartingSN value (if the
				// transfer is needed, we can be certain there is a CSourcePhrase instance
				// in existence with that m_nSequNumber value)
				nStartingSN--;
			}
		}
		// now, check the other end, to see if protection is needed there
		if (pSrcPhrase_AtEnd->m_bNullSourcePhrase)
		{
			if (pPH->NeedsTransferForwards(pSrcPhrase_AtEnd))
			{
				// extend one instance to right (left, if RTL reading order), but both are
				// handled here as an increase by one in the nEndingSN value (if the
				// transfer is needed, we can be certain there is a CSourcePhrase instance
				// in existence with that m_nSequNumber value)
				nEndingSN++;
			}
		}
		return TRUE;
	}

	// if we get here, we've reached the document end, so set nEndingSN and return
	nEndingSN = nIteratorSN;
	return TRUE; // no errors
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error, FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	index into the pSrcPhrases list at which the span to
///                                 be investigated starts
/// \param      nEndingSN		->	index at which the span ends
/// \param      pbHasAdaptations <-	pointer to bool, returns TRUE if there is at least one
///                                 adaptation in the span, FALSE if there were none
/// \remarks
/// Called from: The View's OnEditSourceText(). Determines if there is at least one
/// adaptation in the span of text determined by nStartingSN and nEndingSN. We check only
/// as far as the end of the span, or till we find the first adaptation, whichever comes
/// first. Used to set or clear the bEditSpanHasAdaptations flag in the global struct
/// gEditRecord.
/// BEW 22Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsAdaptationInformationInThisSpan(SPList* pSrcPhrases, int& nStartingSN,
													 int& nEndingSN, bool* pbHasAdaptations)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	(*pbHasAdaptations) = FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	int nThisSN;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		// An English message would be ok here.
		wxMessageBox(_T(
"FindIndex() failed in IsAdaptationInformationInThisSpan(), pos value is NULL. Saving the document. Exiting the edit process."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}

	// scan over the editable span looking for any m_adaption non-empty strings in the
	// CSourcePhrase instances; exit TRUE when the first such is found, we don't need
	// to know how many there are
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;
		if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			// there is at least one non-empty adaptation string in this span
			(*pbHasAdaptations) = TRUE;
			return TRUE;
		}
		if (nThisSN >= nEndingSN)
		{
			// we are at the end of the span which is to be tested, so break out
			break;
		}
	}
	(*pbHasAdaptations) = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error, FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	index into the pSrcPhrases list at which the span to
///                                 be investigated starts
/// \param      nEndingSN		->	index at which the span ends
/// \param      pbHasGlosses    <-	pointer to bool, returns TRUE if there is at least
///                                 one gloss in the span, FALSE if there were none
/// \remarks
/// Called from: The View's OnEditSourceText(). Determines if there is at least one gloss
/// in the span of text determined by nStartingSN and nEndingSN. We check only as far as
/// the end of the span, or till we find the first gloss, whichever comes first. Used to
/// set or clear the bEditSpanHasGlosses flag in the global struct gEditRecord.
/// BEW 22Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsGlossInformationInThisSpan(SPList* pSrcPhrases, int& nStartingSN,
												 int& nEndingSN, bool* pbHasGlosses)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	(*pbHasGlosses) = FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	int nThisSN;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in IsGlossInformationInThisSpan(), pos value is NULL. Saving the document. Exiting the edit process."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}

	// scan over the editable span looking for any m_gloss non-empty strings in the
	// CSourcePhrase instances; exit TRUE when the first such is found, we don't need
	// to know how many there are
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;
		if (!pSrcPhrase->m_gloss.IsEmpty())
		{
			// there is at least one non-empty gloss string in this span
			(*pbHasGlosses) = TRUE;
			return TRUE;
		}
		if (nThisSN >= nEndingSN)
		{
			// we are at the end of the span which is to be tested, so break out
			break;
		}
	}
	(*pbHasGlosses) = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error; FALSE if there was an error
/// \param      pScrPhrases	->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN	->	reference to the sequence number for the first pile
///                             in the span which is to have its source text shown to
///                             the user (this could be more than the user's original
///                             selection, if extension was done because of the presence
///                             of a retranslation or even more than one retranslation)
/// \param      nEndingSN	->	reference to the sequence number for the last pile in
///                             the span referred to by the preceding parameter's comment
/// \param      nStartingFreeTransSequNum	<- ref to the start of any free translation found
///                             at the start of the above span, or if there
///                             were no free translation there, then it is
///                             the same as the nStartingSN value
/// \param      nEndingFreeTransSequNum	<- ref to the end of any free translation found at
///                             the end of the above span, or if there were
///                             no free translation there, then it is the
///                             same as the nEndingSN value
/// \param      bFreeTransPresent	<-	return TRUE if at least one free translation
///                             section is in or partly overlaps the passed
///                             in span; FALSE if none were detected (a
///                             \free .... \free* section with no content
///                             would be regarded as a free translation
///                             section and would cause TRUE to be
///                             returned)
/// \remarks
/// Called from: The View's OnEditSourceText(). Gets the starting and ending sequence
/// numbers of any free translation within the span. "Leftwards" in this function is to be
/// interpretted as "to lower sequence numbers", & so if we are dealing with a
/// right-to-left language data, it would be rightwards to the user. Free translations are
/// defined over document 'sections', and there is no reason why we could assume that the
/// boundaries of the user's selection for edit purposes would coincide with the start of a
/// free translation section and the end of that or another free translation section. In
/// general, if free translations are present then there is a real possibility that the one
/// or more whole free translations defined over the user's selection will start earlier
/// than his selection, and end later; but we can't be sure of that because the free
/// translations might happen to end partway through the user's selection simply because
/// he's not yet managed to free translate past that point yet. So this function works
/// out the span of CSourcePhrase instances which have retranslations defined over them,
/// and makes sure the span starts at the start of the free translation or the passed in
/// nStartingSN value, whichever is lesser, and ends at the end of a whole free translation
/// section at higher sequence number than nEndingSN, or at nEndingSN if there was no free
/// translation at the end of the passed in span, whichever is the case.
/// BEW 22Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetEditSourceTextFreeTranslationSpan(SPList* pSrcPhrases,
						int& nStartingSN, int& nEndingSN,int& nStartingFreeTransSequNum,
						int& nEndingFreeTransSequNum, bool& bFreeTransPresent)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// 22Apr08, BEW added this function
	bFreeTransPresent = FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in GetEditSourceTextFreeTranslationSpan(), pos value is NULL. Saving document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* savePos = pos; // we may need this if we need to verify
            // there are no editable span internal free translation sections (which don't
            // reach either end)

	// initialize the nStartingFreeTransSequNum value to the passed in nStartingSN value
	nStartingFreeTransSequNum = nStartingSN;

	pSrcPhrase = pos->GetData();
	pos = pos->GetPrevious();
	gEditRecord.bSpecialText = pSrcPhrase->m_bSpecialText; // store the special text
													// value in the global EditRecord
	if (pSrcPhrase->m_bHasFreeTrans)
	{
        // the first pile's word or phrase which is to be shown to the user as editable,
        // has a free translation defined on it; so scan back to the start of that free
        // translation if the current pile is not the beginning of the free translation
        // section
		bFreeTransPresent = TRUE;
		if (!pSrcPhrase->m_bStartFreeTrans)
		{
			// the current pile is not the beginning of the section,
			// so scan to lower sequ numbers
			while (pos != NULL)
			{
				// get the previous CSourcePhrase at the new POSITION
				pSrcPhrase = pos->GetData();
				pos = pos->GetPrevious();
				nStartingFreeTransSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans)
				{
					// we are at the start of the free translation section, so break out
					break;
				}
			}
		}
	} // end of block for test pSrcPhrase->m_bHasFreeTrans == TRUE

    // We have established the nStartingSN value, now we need to work out if at the
    // CSourcePhrase instance indexed by the nEndingSN value (the last one whose source
    // text data will be made visible to the user for editing purposes) also has a free
    // translation defined on it, and if it has, then whether or not the free translation
    // ends there - if so, we are done, or if there is no free translation there we are
    // done; but if either is not the case, we must continue scanning to higher sequence
    // numbers until we find the end of that particular free translation section

	// initialize the nEndingFreeTransSequNum value to the passed in nEndingSN value
	nEndingFreeTransSequNum = nEndingSN;

	pos = pSrcPhrases->Item(nEndingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in GetEditSourceTextFreeTranslationSpan(), pos value is NULL, for index nEndingSN. Saving document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	pSrcPhrase = pos->GetData();
	pos = pos->GetNext();
	if (pSrcPhrase->m_bHasFreeTrans)
	{
        // the last pile's word or phrase which is to be shown to the user as editable, has
        // a free translation defined on it; so scan forward to the end of that free
        // translation if the current pile is not the end location of that free translation
        // section
		bFreeTransPresent = TRUE;
		if (!pSrcPhrase->m_bEndFreeTrans)
		{
			// the current pile is not the end of the section,
			// so scan to higher sequ numbers
			while (pos != NULL)
			{
				// get the CSourcePhrase at the new POSITION
				pSrcPhrase = pos->GetData();
				pos = pos->GetNext();
				nEndingFreeTransSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bEndFreeTrans)
				{
					// we are at the end of the free translation section, so break out
					break;
				}
			}
		}
	} // end of block for test pSrcPhrase->m_bHasFreeTrans == TRUE

	if (!bFreeTransPresent)
	{
		// we found no free translation at the start or end of the editable span, but
		// that does not mean that there is no free translation defined within the span,
		// so scan across the span to verify that there really is none defined on it
		pos = savePos; // restore editable span's beginning POSITION
		int width = nEndingSN - nStartingSN + 1;
		int index;
		for (index = 0; index < width; index++)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			if (pSrcPhrase->m_bHasFreeTrans)
				bFreeTransPresent = TRUE;
		}
	}

	// BEW 27Feb12, changed to support saving the radio button state in the docV6
	// CSourcePhrase member flag, m_bSectionByVerse (formerly it was an unused boolean
	// called m_bHasBookmark)
	// Set the flag in the EditRecord which later, entering freeTranslationsStep,
    // allows us to get the original value used for the defining of the section.
    // (The app uses m_bDefineFreeTransByPunctuation now to store the user setting, and
	// it can no longer be changed except by explicit user choice to do so. Whenever an
	// active location is an anchor, with a different setting to that flag, the anchor's
	// m_bSectionByVerse value is used there only temporarily, and the GUI radio button's
	// change to reflect the value there, but revert to the value specified by the app
	// flag, m_bDefineFreeTransByPunctuation, whenever setting up a new section somewhere
	// So deprecate the legacy function
	//	gEditRecord.bVerseBasedSection = GetLikelyValueOfFreeTranslationSectioningFlag(
	//									pSrcPhrases, nStartingFreeTransSequNum,
	//									nEndingFreeTransSequNum ,bFreeTransPresent);
	if (bFreeTransPresent)
	{
		gEditRecord.bVerseBasedSection = pApp->GetFreeTrans()->GetValueOfFreeTranslationSectioningFlag(
										pSrcPhrases, nStartingFreeTransSequNum, nEndingFreeTransSequNum);
	}
	return TRUE; // there was no error
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error; FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	reference to the sequence number for the first
///                                 pile in the span which is to have its source text shown
///                                 to the user (this could be more than the user's
///                                 original selection, if extension was done because of
///                                 the presence of a retranslation or even more than one
///                                 retranslation)
/// \param nEndingSN            -> reference to the sequence number for the last pile in
///                                the span referred to by the preceding parameter's
///                                comment
/// \param      nStartingFreeTransSequNum	-> 	ref to the start of any free translation
///                                             found at the start of the above span, or if
///                                             there were no free translation there, then
///                                             it is -1
/// \param      nEndingFreeTransSequNum		-> 	ref to the end of any free translation
///                                             found at the end of the above span, or if
///                                             there were no free translation there, then
///                                             it is -1
/// \param      nStartingBackTransSequNum	<- 	ref to the first back translation deemed to
///                                             overlap or be within the passed in
///                                             nStartingSequNum to nEndingSequNum span;
///                                             return -1 if no back translation span was
///                                             able to be defined for the passed in
///                                             editable span
/// \param      nEndingBackTransSequNum		<- 	ref to the last CSourcePhrase location in
///                                             the final (or only) back translation
///                                             section deemed to overlap the end of the
///                                             passed in editable span given by
///                                             nStartingSequNum to nEndingSequNum; return
///                                             -1 if no back translation span was able to
///                                             be defined for the passed in editable span
/// \param      bHasBackTranslations		<- 	ref to BOOL to inform caller that the span
///                                             has at least one collected back translation
///                                             defined on it (even if the collected \bt
///                                             marker's content was empty)
/// \param	bCollectedFromTargetText	    <-	ref to BOOL to inform caller which line the
///                                             original collection was done from, return
///                                             TRUE if from the target text line, FALSE if
///                                             from the glossing line
/// \remarks
/// Called from: The View's OnEditSourceText(). Gets the starting and ending sequence
/// numbers of any back translation within the span. Note: parameters 2 to 7 reference
/// members in the struct gEditRecord, and of those 2 to 5 should have been set already, or
/// set to -1 if inapplicable, by previous function calls). "Leftwards" in this function is
/// to be interpretted as "to lower sequence numbers", & so if we are dealing with a
/// right-to-left language data, it would be rightwards to the user. The intent of this
/// function is to define the start and end of a span in which there is one or more
/// collected back translations overlapping any or all of the editable span defined by
/// nStartingSN to nEndingSN values. This is tricky to do, because collection does not
/// occur from CSourcePhrase instances which have certain TextTypes (footnote -- used for
/// true footnotes and also for endnotes, crossReference, and markers with TextType of
/// none), but such material could be selected wholely or in part by the user. These
/// possibilities complicate the algorithm. Back translation markers (\bt or any marker
/// starting with \bt) have to eventually be removed, and their contents thrown away, by
/// another function which the caller calls. Members of gEditRecord are set by being passed
/// in directly. In the algorithm described below, we speak of "halt locations" - these are
/// the CSourcePhrase instances where the view class's HaltCurrentCollection() function
/// returns; the function returns TRUE if a SF marker has been found which is of the kind
/// deemed able to halt the collecting operation, FALSE if collecting should continue, and
/// the function also returns, via its parameter list, whether or not the marker which
/// halted collection was a \bt type of marker. Because HaltCurrentCollection() has all the
/// smarts we need for the present function, we'll use it in the algorithms described below
/// - so that the collection halting criteria are the same over all code for collecting
/// back translations within the application. (Back translation sections don't have a
/// terminating endmarker, and so it is not a simple matter to work out what the span of
/// any \bt marker happens to be, and the CSourcePhrase instances in any such span have no
/// flag indicating they belong to a \bt section, except that the first of them stores,
/// in m_collectedBackTrans, the filtered back translation itself.)(note: derived \bt
/// markers, if any, are stord in the member m_filteredInfo and these take no part in the
/// collection operation -- however, we will use the presence of such a marker as as
/// defining a halt location - so that if ever it was unfiltered, the document adaptations
/// structures would remain internally consistent)
///
/// Note 1: nStartingBackTransSequNum value is not necessarily the same as the starting
/// value of either the editable span nor any free translation span that was earlier
/// defined. (The design also does not require the back translation span subsume the free
/// translation span or the editable span - the ends of all these can be different.)
///
/// Note 2. gEditRecord preserves the span involved in back translation deletions, so if
/// the user elects to have recollection done, we can then use the stored locations and the
/// new length of the edited source text to work out the span over which the collection
/// operation has to be automatically done.
///
/// To understand the algorithm used in GetEditSourceTextBackTranslationSpan(), it is best
/// to break it up into 5 sequential sub-algorithms as follows:
///
/// 1. Determine the starting location (a sequence number) for the first \bt marker
/// destined for removal
///
/// 2. Determine where to scan forward from - it will be the location found in 1. if a back
/// translation was actually found by 1.'s algorithm, but if none was found, we start
/// scanning at the start of the editable span
///
/// 3. Halt locations are examined wherever the back translation collect operation would
/// have halted during the collection operation which defined the back translation spans
/// found in the current document. At these halt locations nothing is done if no \bt marker
/// has yet been found, but if one has been found, then we check for presence of another
/// \bt and remove it if we find one there and we are not at that point past the end of the
/// editable span. Also we maintain a boolean flag, bHasBackTranslations which we set only
/// if we find a \bt marker at some point in all this, and its span does not halt before
/// the start of the editable span, and that marker is not stored at some location after
/// the editable span (because if it was, its back translation would remain valid no matter
/// what editing the user did within the text shown to him for editing).
///
/// 4. Eventually scanning will come to the last CSourcePhrase instance in the editable
/// span, here we must test whether the bHasBackTranslations flag has been set yet, and
/// whether or not it is a halt location, and if it is a halt location, whether or not
/// another \bt marker (or the first such marker if none was found up to that point) is
/// stored there. Depending on the results of these tests, we either declare there is no
/// collected backtranslation defined on any part of the editable span, or the span we are
/// defining ends there, or it ends at a halt location further along which has to now be
/// found.
///
/// 5. Find the final halt location if within 4. it could not be determined.
///
/// The appropriate value of bHasBackTranslations is then returned to the caller, where it
/// is used to set or clear the gEditRecord member bEditSpanHasBackTranslations, and if the
/// the latter is cleared, the caller will also reset the struct's
/// nStartingBackTransSequNum and nEndingBackTransSequNum values to -1.
///
/// History:
/// 23Apr08, BEW added this function
/// BEW 22Mar10, updated for support of doc version 5 (no changes needed, but some alterations
/// to the explanatory comments were added)
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetEditSourceTextBackTranslationSpan(
                                    SPList*	pSrcPhrases,
									int&	nStartingSN,
									int&	nEndingSN,
                                    int&	WXUNUSED(nStartingFreeTransSequNum),
									int&	WXUNUSED(nEndingFreeTransSequNum),
									int&	nStartingBackTransSequNum,
									int&	nEndingBackTransSequNum,
									bool&	bHasBackTranslations,
									bool&	bCollectedFromTargetText)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// 23Apr08, BEW added this function
    // use BOOL CAdapt_ItView::HaltCurrentCollection(CSourcePhrase* pSrcPhrase, BOOL&
    // bFound_bt_mkr) as the way, when scanning forward, to determine halt locations - and
    // remember that the last CSourcePhrase instance within the span thus delineated is the
    // one which precedes the halt location (the halt location is actually the kick off
    // location for a new collection span, as it stores the marker which lead to the halt,
    // and is the place where the next filtered collected back translation would be stored)
	bHasBackTranslations = FALSE;
	bool bFound_bt_mkr = FALSE;
	bool bIsHaltLocation = FALSE;
	bool bItsHereAnyway = FALSE;
	//EditRecord* pRec = &gEditRecord; // get a local pointer to the  // unused
									// EditRecord global struct
	wxString markers;
	nStartingBackTransSequNum = -1; // initialize to 'no value set'
	nEndingBackTransSequNum = -1; // ditto
	bool bCollectionLineTestCompleted = FALSE; // set TRUE when
        // IsCollectionDoneFromTargetTextLine() has been called once, so that we can
        // suppress later calls which might destroy the returned value already obtained by
        // the first call

	int nIteratorSN = nStartingSN; // start from the commencement of the editable span
	CSourcePhrase* pSrcPhrase = NULL;
	bool bBtMarkerFoundAtEndOfEditableSpan = FALSE;
	bool bEndOfEditableSpanIsAHaltLocation = FALSE;
	SPList::Node* pos = pSrcPhrases->Item(nIteratorSN);
    // no error is expected, but we'll check and abort the edit with an English message if
    // a valid pos was not found, but do a save to retain user's work; the document
    // structures are still unchanged
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in GetEditSourceTextBackTranslationSpan(), pos value is NULL. Saving document. Abandoning edit."),
		 _T(""), wxICON_EXCLAMATION | wxOK);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* savePos = pos; // keep for when we later scan forwards
	pSrcPhrase = pos->GetData();
	pos = pos->GetPrevious();

    // The collection operation for back translations does no collecting of filtered
    // information which is inLine, & has a TextType of footnote, or crossReference; these
    // are for things such as footnotes, endnotes, cross references, and we don't allow
    // Adapt It notes' text to be collected. The user could do a selection in things like
    // visible footnotes, endnotes or cross references, but not AI Notes. But the AI
    // interface will not accept selection attempts across a TextType boundary (except for
    // verse and poetry) and so we can be sure than any selection made will be wholely
    // within the one text type. Since there won't be any \bt marker defined on such spans,
    // we must make the function check for a selection within these information types
    // (checking the first CSourcePhrase instance of the user's selection suffices) and if
    // that is where the selection was done, we exit without setting up any bt span
	TextType aType = pSrcPhrase->m_curTextType;
	if (aType == footnote || aType == crossReference)
		return TRUE;

    // check if this first CSourcePhrase in the editable span is a halt location, and if it
    // is, whether or not a \bt marker is stored there; even if not a halt location, we
    // still must check for the presence of a \bt marker there because using a selection
    // the user is able to force any CSourcePhrase instance to be the start of a back
    // translation collection span and hence the place where the back translation text for
    // that span would be stored, so use ContainsBtMarker() to check for that possibility
    // as well
	bIsHaltLocation = pApp->m_pFreeTrans->HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
	if (bIsHaltLocation)
	{
        // its a halt location, so any bt span will either start here (if bFound_bt_mkr is
        // TRUE) or will start at a later location, or not at all; whichever is the case we
        // don't have to scan back (to lower sequence numbers) to get the start of any
        // potential bt span because any prior one will have terminated its collection at
        // the CSourcePhrase instance preceding this current location, and so that one's
        // back translation cannot be affected by the user's editing of the text shown to
        // him
		if (bFound_bt_mkr)
		{
			// the \bt deletion subspan starts here
			nStartingBackTransSequNum = nIteratorSN;
			bHasBackTranslations = TRUE;
			// BEW added 7Sep10
			if (nStartingSN == nEndingSN)
			{
				bBtMarkerFoundAtEndOfEditableSpan = TRUE;
				bEndOfEditableSpanIsAHaltLocation = TRUE;
			}
		}
	}
	else
	{
        // it's not a halt location, but nevertheless a collection could have been manually
        // forced here in some earlier session, so we must check for that; otherwise, we
        // must scan back to the first previous halt location to see if there is a \bt
        // stored there - if so, that would be the start of the bt deletion span we are
        // trying to delimit
		// Note: for doc version 5, ContainsBtMarker returns true if either
		// m_collectedBackTrans member is non-empty and or m_filteredInfo member contains
		// at least one \bt-derived marker (while we don't "collect" using the latter, we
		// do allow these to define a halt location for a current collection)
		bItsHereAnyway = pApp->m_pFreeTrans->ContainsBtMarker(pSrcPhrase);
		if (bItsHereAnyway)
		{
			// the \bt deletion subspan starts here
			nStartingBackTransSequNum = nIteratorSN;
			bHasBackTranslations = TRUE;
			if (nStartingSN == nEndingSN)
			{
				bBtMarkerFoundAtEndOfEditableSpan = TRUE;
			}
		}
		else
		{
			// scan back to see if there is a \bt at the previous halt location,
			// it would start the subspan
			while (pos != NULL)
			{
				pSrcPhrase = pos->GetData();
				pos = pos->GetPrevious();
				nIteratorSN = pSrcPhrase->m_nSequNumber;
				bIsHaltLocation = pApp->m_pFreeTrans->HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
				if (bIsHaltLocation)
				{
					if (bFound_bt_mkr)
					{
						// we have found the location where the \bt deletion span starts
						nStartingBackTransSequNum = nIteratorSN;
						bHasBackTranslations = TRUE;
						break;
					}
					else
					{
                        // there is no \bt marker at this halt location, so we can assume
                        // that in this part of the document there is no back translation
                        // data collected here - just prior to the start of the editable
                        // span
						break;
					}
				} // end of block for test:  bIsHaltLocation == TRUE
				else
				{
                    // it's not a halt location, but still check for storage of \bt
                    // manually forced to be here; otherwise do next iteration of the loop
					bItsHereAnyway = pApp->m_pFreeTrans->ContainsBtMarker(pSrcPhrase);
					if (bItsHereAnyway)
					{
						// the bt deletion span starts here
						nStartingBackTransSequNum = nIteratorSN;
						bHasBackTranslations = TRUE;
						break;
					}
				}
			} // end of while loop with pos != NULL test
		} // end of else block for test: bItsHereAnyway == TRUE
	} // end of else block for bIsHaltLocation == TRUE test

    // that finishes the first stage of the overall algorithm; when control gets here,
    // either nStartingBackTransSequNum has been set to a non-negative sequence number
    // value for the start of the back translation deletion span; or it is still -1 because
    // no beginning for such a span has been detected at or prior to the start of the
    // editable span. Now we commence the subalgorithm number 2, which is to determine the
    // location for scanning forward
	if (bHasBackTranslations)
	{
		nIteratorSN = nStartingBackTransSequNum;
		pos = pSrcPhrases->Item(nIteratorSN);
		wxASSERT(pos != NULL); // we'll assume FindIndex() won't fail,
							   // so just ASSERT for a debug mode check
		pSrcPhrase = pos->GetData();// get the pos for next POSITION
		pos = pos->GetNext();

		// BEW added 26Oct08
		bCollectedFromTargetText = IsCollectionDoneFromTargetTextLine(pSrcPhrases,
														nStartingBackTransSequNum);
		bCollectionLineTestCompleted = TRUE; // use TRUE value to suppress subsequent
											 // calls of above function
	}
	else
	{
		// no \bt found yet, so start scanning forward
		// from the start of the editable span
		nIteratorSN = nStartingSN;
		pos = savePos;
		wxASSERT(pos);
	}
    // that finishes subalgorithm number 2, commence subalgorithm number 3 in which we scan
    // forward looking for halt locations and manually assigned \bt storage locations prior
    // to coming to the end of the editable span

	// BEW 7Sep10, added next test, otherwise the loop wrongly scans to doc end
	if (pos != NULL && (nStartingSN == nEndingSN))
	{
		; // skip this while loop because we already have the information needed and
		  // the iterator location is already at the end of the editable span
	}
	else
	{
		while (pos != NULL)
		{
			// get the CSourcePhrase data for the current pos
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			nIteratorSN = pSrcPhrase->m_nSequNumber;
			bIsHaltLocation = pApp->m_pFreeTrans->HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
			if (bIsHaltLocation)
			{
				// it's a halt location, so check out whether \bt is there, etc
				if (bFound_bt_mkr)
				{
					// a \bt marker was found here, so either the bt deletion span starts here,
					// or this is another collection storage point for back translations which
					// happens to be located within the editable span of source text shown to
					// the user
					bHasBackTranslations = TRUE;
					if (nIteratorSN == nEndingSN)
					{
						// this \bt marker was stored at the very end of the editable span,
						// we need to know this when the loop is exitted
						bBtMarkerFoundAtEndOfEditableSpan = TRUE;
						bEndOfEditableSpanIsAHaltLocation = TRUE;
					}
					if (nStartingBackTransSequNum == -1)
					{
						// the bt deletion span has not been commenced yet, so start it here
						nStartingBackTransSequNum = nIteratorSN;
					}

					// BEW added 26Oct08
					if (!bCollectionLineTestCompleted)
					{
						bCollectedFromTargetText = IsCollectionDoneFromTargetTextLine(
																pSrcPhrases,nIteratorSN);
						bCollectionLineTestCompleted = TRUE; // use TRUE value to suppress
													// subsequent calls of above function
					}
				}
				// if no \bt marker was found, we continue looping
			}
			else
			{
				// not a halt location, but there may be a \bt marker nevertheless because the
				// user at some earlier time manually forced a collection to be stored here
				bItsHereAnyway = pApp->m_pFreeTrans->ContainsBtMarker(pSrcPhrase);
				if (bItsHereAnyway)
				{
					// a \bt marker was found here, so either the \bt deletion span starts
					// here, or this is another collection storage point for back translations
					// which happens to be located within the editable span of source text
					// shown to the user
					bHasBackTranslations = TRUE;
					if (nIteratorSN == nEndingSN)
					{
						// this \bt marker was stored at the very end of the editable span,
						// we need to know this when the loop is exitted
						bBtMarkerFoundAtEndOfEditableSpan = TRUE;
					}
					if (nStartingBackTransSequNum == -1)
					{
						// the bt deletion span has not been commenced yet, so start it here
						nStartingBackTransSequNum = nIteratorSN;
					}

					// BEW added 26Oct08
					if (!bCollectionLineTestCompleted)
					{
						bCollectedFromTargetText = IsCollectionDoneFromTargetTextLine(
																	pSrcPhrases,nIteratorSN);
						bCollectionLineTestCompleted = TRUE; // use TRUE value to suppress
													// subsequent calls of above function
					}
				}
			}
			// if we are at the end of the editable span then exit this loop
			if (nIteratorSN == nEndingSN)
			{
				break;
			}
		} // end of while loop with test pos != NULL
	} // location is at the end of the editable span once control is past here

    // We are now about to start subalgorithm 4; the loop will have been exitted either
    // because pos is NULL (we've reached the end of the document), or because we've landed
    // at the end CSourcePhrase instance in the editable span. Now we use the booleans
    // defined preceding the last loop, and the other flags and sequence numbers to work
    // out whether we have a bt deletion span being defined, and if so then where to
    // terminate its span, but if not, we return to the caller with appropriate EditRecord
    // values indicating there were no back translations defined over any part of the
    // editable span of text which the user sees for editing purposes
	if (pos == NULL)
	{
		// iterating came to the document's end, the \bt subspan,
		// if it exists, must end here
		if (!bHasBackTranslations || nStartingBackTransSequNum == -1)
		{
            // the span was never started, so there are no back translations defined over
            // any part of the editable text span
			nStartingBackTransSequNum = -1;
			nEndingBackTransSequNum = -1;
			bHasBackTranslations = FALSE;
			return TRUE;
		}
		else
		{
			// a span is being delineated, so it must end here
			nEndingBackTransSequNum = nIteratorSN;
			bHasBackTranslations = TRUE;
			return TRUE;
		}
	}
	else
	{
        // control is not at the end of the document on exit of the loop, so work out what
        // has to be done (this stuff is subalgorithm 5 of the description above)
		if (!bHasBackTranslations || nStartingBackTransSequNum == -1)
		{
            // the span delineation was never started, so there are no back translations
            // defined over any part of the editable text span
			nStartingBackTransSequNum = -1;
			nEndingBackTransSequNum = -1;
			bHasBackTranslations = FALSE;
			return TRUE;
		}
		else
		{
			// a span is being delineated, so work out where it ends
			if (!bBtMarkerFoundAtEndOfEditableSpan && bEndOfEditableSpanIsAHaltLocation)
			{
                // the end CSourcePhrase of the editable span is a halt location and there
                // was no \bt marker stored there, so the end of the current bt span must
                // originally have been at the penultimate instance in the editable span;
                // and there is no collection previously done starting from the end of the
                // editable span
				nEndingBackTransSequNum = nIteratorSN - 1;
			}
			else
			{
                // either there was a \bt marker stored at the very end of the editable
                // span (which implies its collected text was drawn from CSourcePhrase
                // instances lying beyond the end of the editable span - as far as the next
                // halt location), or the current bt collection span doesn't end at the end
                // of the editable span because the latter is not a halt location. In the
                // former case, the \bt subspan will end at the CSourcePhrase instance
                // which is immediately preceding wherever the next halt location is; so we
                // must try to find it. In the latter case, we can't assume we'll find a
                // halt location because we may be editing source text close to or at the
                // end of the document - in this case the best we can do is make the end of
                // the editable span be the end of the back translation span, when the loop
                // below exits
				wxASSERT(pos != NULL);
				while (pos != NULL)
				{
					pSrcPhrase = pos->GetData();
					pos = pos->GetNext();
					nIteratorSN = pSrcPhrase->m_nSequNumber;

					// BEW added 26Oct08
					if (!bCollectionLineTestCompleted)
					{
						bCollectedFromTargetText = IsCollectionDoneFromTargetTextLine(
																pSrcPhrases,nIteratorSN);
						bCollectionLineTestCompleted = TRUE; // use TRUE value to suppress
													// subsequent calls of above function
					}
					bIsHaltLocation = pApp->m_pFreeTrans->HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
					if (bIsHaltLocation)
					{
						nEndingBackTransSequNum = nIteratorSN - 1; // the location
														// preceding the halt location
						return TRUE;
					}
				}
                // if control gets to here, then we have no clear idea where to end, so end
                // at end of the editable span
				nEndingBackTransSequNum = nEndingSN;
			}
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      editRec  <- an enum of type EditRecord
/// \remarks
/// Called from: The Doc's OnNewDocument(), OnCloseDocument(), OnOpenDocument(),
/// the View's ClobberDocument(), BailOutFromEditProcess(), OnEditSourceText(), and
/// OnCustomEventEndVerticalEdit().
/// Initializes the gEditRecord global struct's members. The struct members must be
/// initialized when the document is created or reopened for work, and also when closing
/// down the document either using ClobberDocument()(which is called by the document
/// class's OnFileClose() function) or the document class's OnCloseDocument() function; and
/// when closing or opening or creating we also remove the constents of the three deletion
/// lists in the caller after calling InitializeEditRecord(). Note: the
/// deletedAdaptationsList, deletedGlossesList, and DeletedFreeTranslationsList members'
/// contents persist for the life of the current document's RAM presence, and so those
/// lists must empty when the doc is just created or launched and will generally be added
/// to by the user's work, and will only lose their contents when the user or the
/// application at exit time closes the document. Default values are FALSE for booleans,
/// except for one which is better with TRUE as the default, and -1 for integers (meaning
/// "unset"), for TextType the default is verse, and empty for lists (except the deletion
/// lists, which are empty only at the point that the document has just been created or
/// reopened, and emptied again when it is closed).
/// BEW 26Mar10, some changes needed for support of doc version 5
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::InitializeEditRecord(EditRecord& editRec)
{
	// BEW added 17Apr08
	// first clear the global boolean which tracks whether or not
	// vertical editing is currently happening
	gbVerticalEditInProgress = FALSE;
	// and reset the entry point indicator to the non-edit value
	gEntryPoint = noEntryPoint;

	// now clear EditRecord members which should be cleared once any one
	// instance of vertical editing is completed, or cancelled, or abandoned
	CAdapt_ItDoc* pDoc = (CAdapt_ItDoc*)GetDocument();
	editRec.bGlossingModeOnEntry = FALSE; // default is adaptations mode is
            // currently ON, even even when it isn't; this is safe because the flag is only
            // looked at when vertical editing is currently in progress, and it's only then
            // that its value is taken seriously
	editRec.bSeeGlossesEnabledOnEntry = FALSE; // default is FALSE, whether on or off,
										// same reasons apply as for bGlossingModeOnEntry
	editRec.bEditSpanHasAdaptations = FALSE;
	editRec.bEditSpanHasGlosses = FALSE;
	editRec.bEditSpanHasFreeTranslations = FALSE;
	editRec.bEditSpanHasBackTranslations = FALSE;
	editRec.bCollectedFromTargetText = TRUE;
	editRec.nSaveActiveSequNum = -1;
	editRec.nStartingTextType = verse;
	editRec.nEndingTextType = verse;
	editRec.storedNotesList.Clear();
	editRec.nStartingSequNum = -1;
	editRec.nEndingSequNum = -1;
	editRec.nFreeTrans_StartingSequNum = -1;
	editRec.nFreeTrans_EndingSequNum = -1;
	editRec.nBackTrans_StartingSequNum = -1;
	editRec.nBackTrans_EndingSequNum = -1;
	editRec.nCancelSpan_StartingSequNum = -1;
	editRec.nCancelSpan_EndingSequNum = -1;
	pDoc->DeleteSourcePhrases(&editRec.cancelSpan_SrcPhraseList);
	pDoc->DeleteSourcePhrases(&editRec.modificationsSpan_SrcPhraseList);
	pDoc->DeleteSourcePhrases(&editRec.propagationSpan_SrcPhraseList);
    // the editableSpan_NewSrcPhraseList's pointers are not taken over and managed by a
    // section of the document's m_pSourcePhrase list, because the replacement process
    // inserts deep copies into the document list, leaving editableSpan_NewSrcPhraseList
    // unchanged, so we must delete those too
	pDoc->DeleteSourcePhrases(&editRec.editableSpan_NewSrcPhraseList);
	editRec.nPropagationSpan_StartingSequNum = -1;
	editRec.nPropagationSpan_EndingSequNum = -1;
	editRec.arrNotesSequNumbers.Clear();
	editRec.nOldSpanCount = -1;
	editRec.nNewSpanCount = -1;
	editRec.bSpecialText = FALSE;
	pDoc->DeleteSourcePhrases(&editRec.follNotesMoveSpanList);
	pDoc->DeleteSourcePhrases(&editRec.precNotesMoveSpanList);
	editRec.bTransferredFilterStuffFromCarrierSrcPhrase = FALSE;
	editRec.bDocEndPreventedTransfer = FALSE;
	editRec.bExtendedForFiltering = FALSE;

	// now the ones unique to the adaptations step
	editRec.bAdaptationStepEntered = FALSE;
	pDoc->DeleteSourcePhrases(&editRec.adaptationStep_SrcPhraseList);
	editRec.nAdaptationStep_StartingSequNum = -1;
	editRec.nAdaptationStep_EndingSequNum = -1;
	editRec.nAdaptationStep_OldSpanCount = -1;
	editRec.nAdaptationStep_NewSpanCount = -1;
	editRec.nAdaptationStep_ExtrasFromUserEdits = 0;

	// now the ones unique to the glosses step
	editRec.bGlossStepEntered = FALSE;
	pDoc->DeleteSourcePhrases(&editRec.glossStep_SrcPhraseList);
	editRec.nGlossStep_StartingSequNum = -1;
	editRec.nGlossStep_EndingSequNum = -1;
	editRec.nGlossStep_SpanCount = -1;

	// now the ones unique to the freeTranslations step
	editRec.bFreeTranslationStepEntered = FALSE;
	editRec.bVerseBasedSection =  FALSE;
	pDoc->DeleteSourcePhrases(&editRec.freeTranslationStep_SrcPhraseList);
	editRec.nFreeTranslationStep_StartingSequNum = -1;
	editRec.nFreeTranslationStep_EndingSequNum = -1;
	editRec.nFreeTranslationStep_SpanCount = -1;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error, FALSE if something went wrong
/// \param      pSublist	->	pointer to a temporary ordered list of CString instances,
///                             added in the caller by successive .Append() calls as a
///                             scan is done from left to right over a span of CSourcePhrase
///                             instances (typically, in the m_pSourcePhrases list in the
///                             App class)
/// \param      whichList	->	an enum which specifies the list to store in
/// \param      pRec    	->	pointer to the global EditRecord struct, gEditRecord, which
///                             contains amongst its members the various wxArrayString
///                             instances into which the passed in string is inserted
/// \remarks
/// Called from: The View's RestoreNotesAfterSourceTextEdit(), and OnEditSourceText(). This
/// is a helper function for storage of a passed in sublist (either removed adaptations,
/// glosses, free translations, or notes) in the appropriate CStringList within
/// gEditRecord. The sublist is inserted at the head, so that the first removal will be at
/// the top of the final list, the second will be next, and so forth. The final list (the
/// one in gEditRecord, a pointer to which is passed in as the last parameter) is kept to a
/// maximum of DELETIONS_LIST_MAX_ENTRIES which is #defined to be 100 entries, adding extra
/// ones which cause the limit to be exceeded causes the oldest extra entries to drop off
/// the end of the list and be lost. Entries can persist, however, only for the life of the
/// session.
/// 29Apr08 function created as part of refactoring the Edit Source Text functionality
/// BEW 23Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::InsertSublistAtHeadOfList(wxArrayString* pSublist, ListEnum whichList, EditRecord* pRec)
{
	int numElements = 0;
	wxArrayString* pList = NULL;
	switch (whichList)
	{
	case adaptationsList:
		pList = &pRec->deletedAdaptationsList;
		break;
	case glossesList:
		pList = &pRec->deletedGlossesList;
		break;
	case freeTranslationsList:
		pList = &pRec->deletedFreeTranslationsList;
		break;
	case notesList:
		pList = &pRec->storedNotesList;
		break;
	default:
		return FALSE; // unknown list, must be a bad enum value passed in
	}
    // In wx we don't have an equivalent of AddHead() where one array is being inserted at
    // the head of another array. Wx has Insert() which by default inserts a single item
    // into the arrau at a position n in the array. In this case we want to preserve the
    // original order of the array we're inserting, so we can use Insert() as long as we
    // insert items of the sublist array in reverse order, inserting them at position 0 in
    // the base array. We do the insertions manually.
	int ct;
	for (ct = (int)pSublist->GetCount()-1; ct >= 0; ct--)
	{
		pList->Insert(pSublist->Item(ct),0);
	}
	numElements = pList->GetCount();
	if (numElements > (int)DELETIONS_LIST_MAX_ENTRIES)
	{
		// inserting a sublist can result in several more than the limit being present, so
		// we must find out how many overlong we are and remove the bottommost excess ones
		int extras = numElements - (int)DELETIONS_LIST_MAX_ENTRIES;
		int i;
		wxString removedStr;
		for (i = 0; i < extras; i++)
		{
			//removedStr = pList->RemoveTail();
			// WX Note: wxStringArray does not have RemoveTail(). To remove the last element
			// of the array, we call RemoveAt using an index value of count - 1.
			int nLast;
			nLast = pList->GetCount();
			pList->RemoveAt(nLast - 1);
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the removals were done successfully, or if there were no removals
///             needing to be done; FALSE if a removal attempt failed, or if no edit operation
///             is currently in effect
/// \param      pSrcPhrase	->	pointer to the CSourcePhrase instance from which information
///                             is to be removed
/// \param      nSequNum	->	the sequence number in m_pSourcePhrases list in the document
///                             for the pSrcPhrase passed in as first parameter (but it will
///                             not be the index of the pointer in the caller's sublist
///                             (the modifications list); rather the value is obtained from
///                             the pSrcPhrase->m_nSequNumber member)
/// \param      pRec		<->	pointer to the global EditRecord struct, gEditRecord, which
///                             records spans, lists of CSourcePhrase instances, lists of
///                             removed strings, starting and ending TextType values, and
///                             various booleans reflecting the state of the edit process, etc
/// \param      pAdaptList	<->	list for removed adadptations
/// \param      pGlossList	<->	list for removed glosses
/// \param      pFTList	<->	list for removed free translations
/// \param      pNoteList	<->	list for removed notes
/// \param      remAd		->	BOOL indicating whether to remove or retain adaptation
///                             information
/// \param      remGl		->	BOOLindicating whether to remove or retain gloss information
/// \param      remNt		->	BOOL indicating whether to remove or retain note information
/// \param      remFT		->	BOOL indicating whether to remove or retain free translation
///                             information
/// \param      remBT		->	BOOL indicating whether to remove or retain back translation
///                             information
/// \remarks
/// Called from: the View's ScanSpanDoingRemovals().
/// Information which is potentially large and/or invalidated by the edit process (eg.
/// source text editing invalidates the adaptations, glosses, free translations and
/// collected back translations within the span of the edit, and possibly notes stored in
/// the span as well) is removed - collected back translations are abandoned (because they
/// are easily recollected) but the other information types are preserved in lists - the
/// persistence of the data in these lists depends on what is stored: notes are preserved
/// only until, at the end of the edit, they are reconstituted in the document (at possibly
/// different locations, but unchanged content), while free translations, glosses and
/// adaptations are stored for the session, or until the document is closed, or until
/// further information of the same type inserted in the list causes them to drop off the
/// list's bottom - the max list length being given by #define DELETIONS_LIST_MAX_ENTRIES
/// which has the value 100. What information is to be removed is controlled by a set of
/// enum values, because we want to use this function eventually for all vertical editing,
/// not just source text editing. The main reason for removing large information like
/// notes, free translations and collected backtranslations is that these would otherwise
/// be displayed in line in the span of source text being edited, and that would tend to
/// make the source text difficult to find, and be a source of potential confusion or error
/// to a user not expecting to see all filtered information suddenly made visible.
///
/// Note: adaptations glosses and notes are removed only from the editable span, any free
/// translations are removed from a span which potentially is larger than the editable
/// span, and back translations are removed from a span which could be considerably larger
/// than that for back translations. Hence the gEditRecord must be checked, for each
/// removal type, to ensure that the passed in pSrcPhrase has a m_nSequNumber value which
/// lies within the span appropriate for whatever marker type's content is being removed,
/// and if CSourcePhrase instance lies outside the appropriate range of sequence numbers,
/// the marker and content are not removed. That member's value is passed in as the
/// nSequNum parameter, and so that is the value which is tested for inclusion in the
/// various kinds of subspan. (The caller does only a single scan across the modification's
/// list's span, so all the required removals have to be done, per passed in pSrcPhrase, as
/// necessary for each span type, in that one pass through the caller's list.)
/// 27Apr08	function created as part of refactoring the Edit Source Text functionality; no
/// list for removed collected back translations, we throw them away & recollect later
/// BEW 23Mar10, updated for support of doc version 5 (changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RemoveInformationDuringEdit(CSourcePhrase*	pSrcPhrase,
												int				nSequNum,
												EditRecord*		pRec,
												wxArrayString*	pAdaptList,
												wxArrayString*	pGlossList,
												wxArrayString*	pFTList,
												wxArrayString*	pNoteList,
												bool			remAd,
												bool			remGl,
												bool			remNt,
												bool			remFT,
												bool			remBT)
{

	wxString str; // use as a scratch variable
	wxString errStr;
	int nEditableSpanStart;
	int nEditableSpanEnd;
	int nFreeTranslationSpanStart;
	int nFreeTranslationSpanEnd;
	int nBackTranslationSpanStart;
	int nBackTranslationSpanEnd;

	// If there is no current edit operation in effect, return FALSE immediately
	if (!gbVerticalEditInProgress)
	{
		return FALSE;
	}

    // set the sequence numbers which define each span; any undefined span will have both
    // starting and ending values set to -1, but the editable span never has -1 for its
    // indices; each type of removal is valid within only its own span, but the spans
    // potentially overlap significantly or perhaps are each the same span
	nEditableSpanStart = pRec->nStartingSequNum;
	nEditableSpanEnd = pRec->nEndingSequNum;
	nFreeTranslationSpanStart = pRec->nFreeTrans_StartingSequNum;
	nFreeTranslationSpanEnd = pRec->nFreeTrans_EndingSequNum;
	nBackTranslationSpanStart = pRec->nBackTrans_StartingSequNum;
	nBackTranslationSpanEnd = pRec->nBackTrans_EndingSequNum;

	// Note removal and storage is done unilaterally; in many edit situations the note is
	// restored to the same location and the user won't be aware of the temporary removal
	// and restoration; but when source text is edited, note locations can't be guaranteed
	// to remain fixed
    // handle removal of a Note stored here, preserve the note contents in the appropriate
    // CString list, but only do the removal provided the note lies in the editable span
	if (nSequNum >= nEditableSpanStart && nSequNum <= nEditableSpanEnd)
	{
		if (remNt)
		{
            // do this only if removal of notes has been requested, and a note is stored on
            // this pSrcPhrase and it is not an empty string (we won't put an empty note
            // into the wxArrayString in gEditRecord -- the user would probably not care
            // about the fact that there will later be no reconstruction of the empty note,
            // and certainly Adapt It shouldn't care that it has disappeared)
			if (!pSrcPhrase->GetNote().IsEmpty())
			{
				str = pSrcPhrase->GetNote();
				str.Trim(); // remove final white space, if any
                // if the content is an empty string, we don't insert it in the list, but
                // if not we must insert it so the end of the source text edit process can
                // reinsert it somewhere appropriate (we can't guarantee the final location
                // will be as meaningful as the original location, but the user can later
                // move it very easily; Adapt It will therefore just do the best it can
                // when it comes to choosing where to relocate it)
				size_t Inspos = pNoteList->Add(str);
				if ((int)Inspos == -1)
				{
                    // the .Add() call failed, so bail out of this edit process with a
                    // message to the user - we expect this never to happen, so it can be
                    // an English hard-coded message
					errStr = _T(".Add() for note string, failed. ");
					errStr += _T(
					"Edit process abandoned. Document restored to pre-edit state.");
					wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
					return FALSE;
				}

                // preserve the Note's former location in the CArray in gEditRecord, to
                // help us later on restore the Note in a similar location as far as
                // possible
				pRec->arrNotesSequNumbers.Add(nSequNum);
				pSrcPhrase->m_bHasNote = FALSE; // clear it
			} // end block for having tested for presence of a note and found one
		}
	}

	// which actions of the total edit process are to be done depend on what the entry
	// condition was, whether editing source, adaptation, gloss, etc. Thus far (March 2010),
	// we support only the editingSourceText entry point. Later in the wxWidgets port,
	// the other entry points as in the switch may be supported, and vertical editing
	// would then be supported right across the application's modalities.
	switch (gEntryPoint)
	{
		case sourceTextEntryPoint:
			goto s;
		case adaptationsEntryPoint:
			goto a;
		case glossesEntryPoint:
			goto g;
		case freeTranslationsEntryPoint:
			goto f;
		case noEntryPoint: // not expected and would imply an error occurred
		default:
		{
			errStr = _T(
			"gEntryPoint was undefined in RemoveInformationDuringEdit() function. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
			return FALSE; // indicate an error state
		}
	}

	// find the adaptation & if non-empty transfer a copy to the temporary string list
	// for later insertion in the string list within pRec (done in the caller); but only
	// provided this CSourcePhrase instance passed in is within the editable span
s:	if (nSequNum >= nEditableSpanStart && nSequNum <= nEditableSpanEnd)
	{
		// (to save time we don't bother to actually remove, but just save a copy)
		if (remAd)
		{
			// do this only if removal of adaptations has been requested, and the
			// adaptation is not an empty string
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				// there is some adaptation text that can be copied, so do so, etc
				str = pSrcPhrase->m_adaption; // copy punctuation-less m_adaption member
				size_t Inspos = pAdaptList->Add(str);
				if ((int)Inspos == -1)
				{
                    // the Add() call failed, so bail out of this edit process with a
                    // message to the user - we expect this never to happen, so it can be
                    // an English hard-coded message
					errStr = _T(".Add() for adaptation string, failed. ");
					errStr += _T(
					"Edit process abandoned. Document restored to pre-edit state.");
					wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
					return FALSE;
				}
			}
		}
	}
    // find the gloss, if it exists, & if non-empty transfer a copy to the temporary string
    // list for later insertion in the string list within pRec (done in the caller); but
    // only provided this CSourcePhrase instance passed in is within the editable span
a:	if (nSequNum >= nEditableSpanStart && nSequNum <= nEditableSpanEnd)
	{
		// (we don't bother to remove, just do the copy)
		if (remGl)
		{
			// do this only if removal of glosses has been requested, and the gloss
			// is not an empty string, and the caller has determined there is at least
			// one gloss somewhere in the span to which this CSourcePhrase belongs
			if (pRec->bEditSpanHasGlosses)
			{
				if (!pSrcPhrase->m_gloss.IsEmpty())
				{
					// there is some gloss text that can be copied, so do so, etc
					str = pSrcPhrase->m_gloss;
					size_t Inspos = pGlossList->Add(str);
					if ((int)Inspos == -1)
					{
                        // the .Add() call failed, so bail out of this edit process with a
                        // message to the user - we expect this never to happen, so it can
                        // be an English hard-coded message
						errStr = _T(".Add() for gloss string, failed. ");
						errStr += _T(
						"Edit process abandoned. Document restored to pre-edit state.");
						wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
						return FALSE;
					}
				}
			}
		}
	}
    // next, do any free translation removal & transfer it to the temporary string list in
    // the caller, but only do it if the CSourcePhrase is within the free translation span;
    // also clear the three free translation-related flags
g:	if ((nFreeTranslationSpanStart != -1 && nSequNum >= nFreeTranslationSpanStart) &&
		(nFreeTranslationSpanEnd != -1 && nSequNum <= nFreeTranslationSpanEnd))
	{
		if (remFT)
		{
			// do this only if removal of free translations has been requested, and the
            // free translation is actually stored on this pSrcPhrase (remove even if the
            // free translation is itself an empty string, but don't put an empty free
            // translation into the CStringList in gEditRecord)
			if (pRec->bEditSpanHasFreeTranslations)
			{
                // there may be a free translation stored here, if so remove it and insert
                // it at the head of the caller's temporary list for retaining removed free
                // translations for later insertion in the similar list in gEditRecord
				if (!pSrcPhrase->GetFreeTrans().IsEmpty())
				{
					str = pSrcPhrase->GetFreeTrans();
					str.Trim(); // remove any final white space characters
                    // if the content is an empty string, we don't insert it in the list,
                    // but if not we must insert it so the user later has a chance to reuse
                    // it and/or modify it (it might be just a space and Trim() removed it)
					if (!str.IsEmpty())
					{
						size_t Inspos = pFTList->Add(str);
						if ((int)Inspos == -1)
						{
                            // the .Add() call failed, so bail out of this edit process
                            // with a message to the user - we expect this never to happen,
                            // so it can be an English hard-coded message
							errStr = _T(".Add() for free translation string, failed. ");
							errStr += _T(
							"Edit process abandoned. Document restored to pre-edit state.");
							wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
							return FALSE;
						}
					} // end block for testing for non-empty str
				} // end block for having tested for a free translation string and found one

                // clear the three flags; this ensures that if the user edits considerably
                // - especially within the adaptations step, then the free translation
                // step's update will do the required resegmenting to comply with the
                // result of those edits
				pSrcPhrase->m_bHasFreeTrans = FALSE;
				pSrcPhrase->m_bStartFreeTrans = FALSE;
				pSrcPhrase->m_bEndFreeTrans = FALSE;

			} // end block for testing for presence of free translations in the editable span
		}
	}
    // handle removal of any collected back translation stored on this CSourcePhrase
    // instance, provided the passed in CSourcePhrase instance lies within the back
	// translation span (for doc version 5, only m_collectedBackTrans member is examined,
	// and any \bt-derived markers and their content will remain in m_filteredInfo, and be
	// shown in-line to the user in the editing window (but without wrapping filter markers)
f:	if ((nBackTranslationSpanStart != -1 && nSequNum >= nBackTranslationSpanStart) &&
		(nBackTranslationSpanEnd != -1 && nSequNum <= nBackTranslationSpanEnd))
	{
		if (remBT)
		{
            // do this only if removal of back translations has been requested, and the
            // back translation is present on this pSrcPhrase
			if (pRec->bEditSpanHasBackTranslations)
			{
                // there may be a back translation stored here, if so remove it
				if (!pSrcPhrase->GetCollectedBackTrans().IsEmpty())
				{
					str.Empty();
					pSrcPhrase->SetCollectedBackTrans(str); // just chuck it away, as we
								// can programmatically recollect as the last step of the
								// edit process, so no need to store it
				}
			} // end block for testing for presence of back translations in the editable span
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the removals were done successfully, or if there were no removals
///             needing to be done; FALSE if a removal attempt failed, or if no edit
///             operation is currently in effect
/// \param      pSrcPhrase	->	pointer to the modifications list, a SPList, within
///                             gEditRecord, where the modifiable deep copied
///                             CSourcePhrase instances are stored temporarily (there are
///                             potentially many more instances in this list than belong
///                             within the editable span, because of the possibility of
///                             span expansion due to the presence of free and/or back
///                             translations)
/// \param      pRec		<->	pointer to the global EditRecord struct, gEditRecord,
///                             which records edit spans, lists of CSourcePhrase
///                             instances, lists of removed strings, starting and ending
///                             TextType values, and various booleans reflecting the state
///                             of the edit process
/// \param      pAdaptList	->	an empty list which is to receive any removed adaptations
/// \param      pGlossList	->	an empty list which is to receive any removed glosses
/// \param      pFTList		->	an empty list which is to receive any removed free
///                             translations
/// \param      pNoteList	->	an empty list which is to receive any removed notes
/// \remarks
/// Called from: the View's OnEditSourceText().
/// Scans a span of Source Phrases and removes adaptations, glosses, free translations and
/// notes storing them in lists for later processing and incorporation into the document
/// after the user edits the source text. Iterating forward it starts from the end of the
/// sublist, but removals are potentially done only from the CSourcePhrase instances which
/// fall within the appropriate span. The internal function call,
/// RemoveInformationDuringEdit(), has all the smarts needed so that it removes each
/// information type only in the subspan appropriate for that type. Information removed is
/// stored in lists, within gEditRecord, except that removed back translations are
/// abandoned because they can be re-collected automatically (once the user indicates which
/// line of the strips to collect from) at the end of the edit process. (While we could
/// remove adaptations and glosses that are within the editable span, there is really no
/// need because their parent CSourcePhrase instances will be recreated from the edited
/// source text and will replace the older ones, so we will leave them in place in order to
/// save processing time, and just put copies in the storage lists for these two types of
/// information.)
///
/// Note: this function does nothing to the CSourcePhrase instances stored in the App
/// class's m_pSourcePhrases list, so if there is an error herein, the document is still
/// intact on return.
/// 19May08	function created as part of refactoring the Edit Source Text functionality
/// BEW 23Mar10, updated for support of doc version 5 (no changes needed, except in function call)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ScanSpanDoingRemovals(SPList* pSrcPhrases, EditRecord* pRec,
							wxArrayString* pAdaptList, wxArrayString* pGlossList,
							wxArrayString* pFTList, wxArrayString* pNoteList)
{
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->GetFirst();
	bool bAllWasOK = TRUE;
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		// whm: No need to localize the following error message.
		wxMessageBox(_T(
"GetHeadPosition() failed in ScanSpanDoingRemovals(), pos value is NULL. Saving document, abandoning edit."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}

	// scan over the modifications span
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
        // do the smart information removals for this pSrcPhrase, but for adaptations and
        // glosses, place copies in the respective lists, but don't do any removals; the
        // pRec parameter passes in the knowledge of where the various subspans (editable
        // span, free translation span, collected back translations span) begin and end
		bAllWasOK = RemoveInformationDuringEdit(pSrcPhrase, pSrcPhrase->m_nSequNumber,
									pRec, pAdaptList, pGlossList, pFTList, pNoteList,
									TRUE, TRUE, TRUE, TRUE, TRUE);
		if (!bAllWasOK)
		{
			// whm: No need to localize the following error message.
			wxMessageBox(_T(
"RemoveInformationDuringEdit() returned FALSE in loop within ScanSpanDoingRemovals(). Saving document, abandoning edit."),
			_T(""), wxICON_EXCLAMATION | wxOK);
			return FALSE;
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the reconstruction was done successfully, FALSE if the
///             reconstruction attempt failed, or if no edit operation is currently
///             in effect
/// \param      pSrcPhrases	->	pointer to the deep copied sublist of CSourcePhrase
///                             instances found in modifications list, (but only that
///                             subspan of it which is the editable span part actually
///                             used for the reconstruction)
/// \param      pRec		<->	pointer to the global EditRecord struct, gEditRecord,
///                             which records edit spans, lists of CSourcePhrase
///                             instances, lists of removed strings, starting and ending
///                             TextType values, and various booleans reflecting the state
///                             of the edit process, etc.
/// \param      nStartingSN	->	the sequence number value in pSrcPhrases where the
///                             editable span commences (note: the CSourcePhrase's
///                             m_nSequNumber member has to be examined, not the index for
///                             the list's elements, because the list is a sublist copied
///                             from the document's list)
/// \param      nEndingSN	->	the sequence number value in pSrcPhrases where the
///                             editable span ends, including the CSourcePhrase instance
///                             at this index value (& likewise, the index value we check
///                             is that in the m_nSequNumber member)
/// \param      strSource	<-	returns the accumulated editable source text
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The span used for this scan is the editable span, but the sublist traversed in the scan
/// is potentially wider - depending on whether free translations and / or collected back
/// translations earlier caused the original editable span to be widened when forming the
/// modifications span, and it is the modifications span which is passed in. The editable
/// subspan will coincide with the user's selection, except if/when the user's selection
/// partly overlapped a retranslation - in the latter case, the span will have been
/// extended to include all of the retranslation; the result, whichever is the case, is
/// what we are calling the "editable span", and this is the span of source text which the
/// user will see and which is available for editing.
/// When this function is called, free translations, notes, and collected back translations
/// will already have been removed and, for the first two, stored in the EditRecord's
/// members
/// 5May08	function created as part of refactoring the Edit Source Text functionality
/// BEW 23Mar10 updated for support of doc version 5 (some changes were needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/// BEW 11Oct10, extensively changed, to use the protocols built into FromMergerMakeStr()
/// and FromSingleMakeSstr(), and also to handle placeholders within the span better (the
/// old code just ignored them, but if info had been transferred to the placeholder that
/// would be inadequate, a better solution is (after having collected the old adaptations
/// and glosses - which has been done by the time this function is called) to get the span
/// deep copied into a sublist, and remove the placeholders in the sublist (this undoes
/// any info transfers), and then collect strSource from the non-placeholder instances
/// which remain. That's what we do.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ScanSpanDoingSourceTextReconstruction(SPList* pSrcPhrases,
									EditRecord* pRec, int nStartingSN, int nEndingSN,
									wxString& strSource)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CSourcePhrase* pSrcPhrase = NULL;
	int nThisSN;
	SPList::Node* pos = pSrcPhrases->GetFirst();
	pRec->bEditSpanHasAdaptations = pRec->bEditSpanHasAdaptations; // avoid compiler warning
						// (as doc version 5 doesn't require pRec in this function now)
	strSource.Empty(); // ensure strSource starts out empty

    // no error is expected, but we'll check and abort the app with an English message
    // if a valid pos was not found, but have the caller do a save to retain user's
    // work & terminate the edit attempt
	if (pos == NULL)
	{
		// whm: no need to localize this type of error message
		wxMessageBox(_T(
"GetHeadPosition() failed in ScanSpanDoingSourceTextReconstruction(), pos value is NULL. Saving document and abandoning edit."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		return FALSE;
	}

    // Legacy comment: scan over the list, and test for pSrcPhrase pointers within the
    // editable span; for those, we collect the source text with its punctuation (if any),
    // and precede it with the contents of any non-empty m_filteredInfo member, and then
    // the contents of any non-empty m_markers member, and follow it with any non-empty
    // m_endMarkers member

	// BEW 11Oct10, doc version 5 additions add m_follOuterPunct, and storage for inline
	// binding and non-binding markers - these are not handled by the legacy protocol
	// described above, and also cross references are not handled right in the above way
	// either (they follow m_markers stuff, not preceded it, if unfiltered & placed in the
	// text stream). So, instead of modifying the code below, a better approach is to use
	// the export functions FromMergerMakeSstr() and FromSingleMakeStr(), which have all
	// the correct protocols for marker placement built in.

	// create the sublist, make deep copies (ignore returned bool from the
	// DeepCopy...() call)
	SPList myList;
	SPList* pSublist = &myList;
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current Node, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;
		if (nThisSN >= nStartingSN && nThisSN <= nEndingSN)
		{
            // any sequence number meeting that condition lies within
            // the editable span,
			CSourcePhrase* pSP = new CSourcePhrase(*pSrcPhrase);
			pSP->DeepCopy();
			pSublist->Append(pSP);
		}
	}
	wxASSERT(pSublist->GetCount() > 0);

	// untransfer transferred info from any placeholders and then remove them from the
	// sublist
	bool AllsWell = pApp->GetPlaceholder()->RemovePlaceholdersFromSublist(pSublist);
	if (!AllsWell)
	{
		// oops, something went wrong - about the Edit Source Text operation
		pApp->GetDocument()->DeleteSourcePhrases(pSublist, FALSE); // don't leak memory
		return FALSE;
	}

	wxString srcStr; // collect in this
	// Next three needed for the calls, but we don't use them, because the information is
	// already placed in the returned string with markers where they need to be etc. The
	// two booleans we pass in as TRUE, meaning "attach any filtered info to the returned
	// string" and "attach any m_markers content to the returned string".
	wxString unused_mMarkers; // any m_markers content
	wxString unused_xRef;	// any \x .... \x* content (only that, or empty string)
	wxString unused_filtdInfo; // any content from m_filteredInfo, with \x ... \x* removed
	int length = 0;
	pos = pSublist->GetFirst(); // re-initialize pos to start of sublist
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;
		if (nThisSN >= nStartingSN && nThisSN <= nEndingSN)
		{
            // any sequence number meeting that condition lies within the editable span,
            // so collect from it...
			if (pSrcPhrase->m_nSrcWords > 1 && !IsFixedSpaceSymbolWithin(pSrcPhrase))
			{
				// it's a genuine merger
				srcStr = FromMergerMakeSstr(pSrcPhrase);
			}
			else
			{
				// FALSE and FALSE is bDoCount and bCountInTargetText; we are not
				// interested in the wordcounting because any free translations have been
				// removed already when this function is called from OnEditSourceText()
				srcStr = FromSingleMakeSstr(pSrcPhrase, TRUE, TRUE, unused_mMarkers,
											unused_xRef, unused_filtdInfo, FALSE, FALSE);
			}
			// figure out how to concatenate the substrings - after an endmarker (we'll
			// assume USFM, it's unlikely we'll have to bother with PNG 1998 SFM now, and
			// even if we did we'd just assume \fe or \F were not endmarkers and put a
			// space after them for concatenation, and that would comply with what the old
			// markup standard used to so anyway, so we are safe) For USFM endmarker,
			// we'll not put a space after it unless the to-be-concatenated string does
			// not belong with a backslash (ie. if punctuation or a word starts it, then
			// we'd want an intervening space)
			strSource.Trim(); // remove any space from its end
			length = strSource.Len();
			if (length == 0)
			{
				strSource = srcStr;
			}
			else if (strSource[length-1] != _T('*'))
			{
				// no endmarker at its end
				if (srcStr[0] == gSFescapechar)
				{
					// srcStr starts with an SF marker - it's safe then to tuck it up to
					// whatever precedes without any intervening space, but it will be
					// more readable with a space, and this is a context where we won't
					// have punctuation & filtering interacting, so add the space
					strSource += _T(" ") + srcStr;
				}
				else
				{
					// srcStr doesn't start with a marker, so we'll need to insert a space
					// provided strSource is not empty
					if (strSource.IsEmpty())
					{
						strSource = srcStr;
					}
					else
					{
						strSource += _T(" ") + srcStr;
					}
				}
			}
			else
			{
				// there's an endmarker at its end - we'll add a space only if srcStr does
				// not begin with an SF marker
				if (srcStr[0] == gSFescapechar)
				{
					// srcStr begins with a marker so we can tuck it up to the end of strSource
					strSource += srcStr;
				}
				else
				{
					// no marker at the start of srcStr, so a space would help readability (though
					// otherwise unnecessary)
					strSource += _T(" ") + srcStr;
				}
			}
			srcStr.Empty();
		} // end of block for TRUE result from test of sequence number
	} // end of loop

	// Don't leak memory. In the next call, FALSE is bDoPartnerPileDeletionAlso; calls
	// DeleteSingleSrcPhrase() on each instance in pSublist
	pApp->GetDocument()->DeleteSourcePhrases(pSublist, FALSE);
	myList.Clear();

	// finally, the above code will have included any notes, free translations and
	// collected back translations, so we must remove them; permit only 3 iterations of
	// the following loop
	wxString oldStr = strSource;
	wxString newStr = RemoveCustomFilteredInfoFrom(strSource);
	int count = 0;
	while (newStr != oldStr && count < 3)
	{
		// if they changed, repeat, until no more removals are done, or 3 iterations,
		// whichever comes first
		oldStr = newStr;
		newStr = RemoveCustomFilteredInfoFrom(oldStr);
		count++;
	}
	strSource = newStr;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error
/// \param      pOriginalList        ->	 pointer to an CObList (short) list containing
///                                      deep copies of a subspan of CSourcePhrase
///                                      instances from the m_pSourcePhrases list in
///                                      the app
/// \param      pDestinationList     <-> pointer to the list which is potentially to
///                                      have CSourcePhrase instances (their pointers,
///                                      actually) inserted in it at the start, and
///                                      possibly at the end as well, in order to extend
///                                      the original pDestinationList to comply with a
///                                      desired wider span
/// \param      nOldList_StartingSN  ->	the sequence number index which determines the
///                                     starting sequence number value for the instances
///                                     already in pDestination list at the time that
///                                     that list is passed in
/// \param      nOldList_EndingSN    ->	the sequence number index which determines the
///                                     ending (inclusive) sequence number value for the
///                                     instances already in pDestination list at the
///                                     time that that list is passed in
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The algorith is as follows. The pOriginalList (which is potentially wider than
/// pDestinationList) is scanned from its beginning, and each pSrcPhrase's m_nSequNumber
/// value is tested against the nOldList_StartingSN value; if the former is less than the
/// latter, then that particular pSrcPhrase also needs to be put in the pDestinationList -
/// so we make a deep copy and insert it; we iterate this until the m_nSequNumber value
/// reaches nOldList_StartingSN and break out, because that pSrcPhrase instance is already
/// in pDestinationList. Then we skip to the nOldList_EndingSN location, and when we find
/// it, we test to see if any pSrcPhrase instances from the end of the pOriginalList follow
/// that location -- that is, if their m_nSequNumber values are greater than
/// nOldList_EndingSN. Any that are deep copied and appended to the pDestinationList.
/// (Copies are inserted or appended, and so the caller must delete the deep copies in the
/// pOriginalList, if appropriate, on return.)
/// BEW 13May08	function created as part of refactoring the Edit Source Text functionality
/// BEW 22Mar10, updated for support of doc version 5 (no changes needed)
/// BEEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::CopyCSourcePhrasesToExtendSpan(SPList* pOriginalList,
							SPList* pDestinationList, int nOldList_StartingSN,
							int nOldList_EndingSN)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList::Node* posOrig = pOriginalList->GetFirst();
	if (posOrig == NULL)
	{
		// whm Note: no translation for localization need be done
		// for this type of error message
		wxMessageBox(_T(
"FindIndex() failed in MoveCSourcePhrasesToExtendSpan(), posOrig value is NULL. Saving document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		BailOutFromEditProcess(pApp->m_pSourcePhrases, &gEditRecord); // restore
														// original document state
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* posInsert = pDestinationList->GetFirst();
	if (posInsert == NULL)
	{
		// whm Note: no translation for localization need be done
		// for this type of error message
		wxMessageBox(_T(
"FindIndex() failed in MoveCSourcePhrasesToExtendSpan(), posInsert value is NULL. Saving document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		BailOutFromEditProcess(pApp->m_pSourcePhrases, &gEditRecord); // restore
														// original document state
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	int nSequNum = -1;
	bool bIsFirst = TRUE;
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pNewOne = NULL;
	while (posOrig != NULL)
	{
		pSrcPhrase = posOrig->GetData();
		posOrig = posOrig->GetNext();
		wxASSERT(pSrcPhrase);
		nSequNum = pSrcPhrase->m_nSequNumber;
		if (nSequNum < nOldList_StartingSN)
		{
            // a deep copy of this CSourcePhrase instance needs to be inserted following
            // earlier insertions into the pDestinationList, or if this is the first to be
            // inserted, then at the start of that list
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			if (bIsFirst)
			{
				// whm: In wxList Insert inserts by default at the head/beginning of the list
				posInsert = pDestinationList->Insert(pNewOne);
				bIsFirst = FALSE;
			}
			else
			{
                // wxList has no equivalent to InsertAfter(). The wxList Insert() method
                // inserts the new node BEFORE the current position/node. To emulate what
                // the MFC code does, we can advance one node before calling Insert()
                // geting a node called posNextHigher which points to the next node beyond
                // the current position, and use its position in the Insert() call (which
                // only inserts BEFORE the indicated position). The result should be that
                // the insertions will get placed in the list the same way that MFC's
                // InsertAfter() places them. wx additional note: If the item is to be
                // inserted after the last item in the list posNextHigher will return NULL,
                // in that case, just append the new item to the list.
				SPList::Node* posNextHigher = posInsert->GetNext();
				if (posNextHigher == NULL)
					posInsert = pDestinationList->Append(pNewOne);
				else
					posInsert = pDestinationList->Insert(posNextHigher,pNewOne);
			}
		}
		if (nSequNum >= nOldList_StartingSN && nSequNum <= nOldList_EndingSN)
			continue;
		if (nSequNum > nOldList_EndingSN)
		{
			// Any which remain have to be appended to the destination list
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			posInsert = pDestinationList->Append(pNewOne);
		}
	}
#ifdef _DEBUG
		SPList::Node* testpos = pOriginalList->GetFirst();
		//int ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			pSrcP = pSrcP; // avoid warning
			testpos = testpos->GetNext();
			//wxLogDebug(_T("CopyCSourcePhrasesToExtendSpan() pOriginalList item %d at %x = %s"),
			//ct++,pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
		testpos = pDestinationList->GetFirst();
		//ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			pSrcP = pSrcP; // avoid warning
			testpos = testpos->GetNext();
			//wxLogDebug(_T("CopyCSourcePhrasesToExtendSpan() pDestinationList item %d at %x = %s"),
			//ct++,pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
#endif
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrases  ->	pointer to the m_pSourcePhrases list in the app
/// \param      pRec         ->	pointer to the EditRecord for the vertical edit process
/// \remarks
/// Called from: the View's BailOutFromEditProcess().
/// This function restores the contents of pSrcPhrases list to what it was prior to
/// the source text edit being attempted.
///
/// The passed in EditRecord, pRec, contains the information about the source text edit
/// which has just been completed, and in particular it includes the CSourcePhrase
/// instances in the cancel span, and the potentially overlapping (at the large sequence
/// numbers end) propagation span. It also has the starting and ending sequence number
/// values for each relevant span, and so it just requires some arithmetic, deletions and
/// insertions in order to reconstitute the original document state, now that the
/// document's underlying native structures have been modified.
///
/// There are four possible circumstances in which this function may be called.
///
/// (1) After the edit source text dialog is dismissed by an OK button click, and the
/// document has undergone modifications subsequent to that according to how the used
/// edited the source text, but somewhere along the way in doing those modifications an
/// exception was encountered.
///
/// (2) The user has progressed down somewhat in the vertical edit process, past the source
/// text edit step, and has decided to backtrack all the way to the original document
/// state. (This is unlikely, but must be allowed for. He's more likely though to just
/// Cancel the whole process in order to get back to the original doc state.) For this to
/// work, any changes to the number of source phrases made during the adaptations update
/// step must be removed (eg. mergers, placeholder insertions, retranslations), so that the
/// entry point for RestoreDocAfterSrcTextEditModifiedIt() is exactly as it was at the
/// earlier end of the source text edit step. (Other restoration functions will have been
/// called prior to this function being entered, for whatever other steps were completed
/// before the backtrack was initiated.)
///
/// (3) As in (2) the user has progessed down somewhere in the vertical edit process, then
/// decides to cancel out of the whole process. Same caveat applies as in (2) about what
/// the initial conditions must be prior to RestoreDocAfterSrcTextEditModifiedIt() being
/// entered, and any completed lower steps having their restoration functions called first
/// before RestoreDocAfterSrcTextEditModifiedIt() is entered.
///
/// (4) As in (2) or (3), but an exception in one of the processing steps lower than source
/// text editing was encountered, so that the whole vertical edit must be abandoned - same
/// caveats as for (2) and (3) apply here also.
/// BEW 26May08	function created as part of refactoring the Edit Source Text functionality
/// BEW 22Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RestoreDocAfterSrcTextEditModifiedIt(SPList* pSrcPhrases, EditRecord* pRec)
{
	int nCount = 0;
	int nReplaceCount = 0;
	bool bReplacedOK = TRUE;
	wxString error;
    // since replacement of temporarily removed Notes is done last, the bailout must first
    // replace any subspans involved in potential Note moves in the preceding or following
    // context; the array storing removed Notes' sequence numbers can be used as a flag, if
    // there were none removed, the array will be empty, and then no such context
    // restoration is required
	int nStartingAtSN;
	if (pRec->arrNotesSequNumbers.GetCount() > 0)
	{
		// do the restorations, if there are sublists to restore;
		// first do the following context
		nCount = pRec->follNotesMoveSpanList.GetCount();
		if (nCount > 0)
		{
            // if the user deleted all the source text, start at the first CSourcePhrase
            // of the following context -- which will have become the same index as
            // nStartingSequNum; otherwise work out the first CSourcePhrase of the
            // following context using the nNewSpanCount value
			if (pRec->nNewSpanCount == 0)
			{
				nStartingAtSN = pRec->nStartingSequNum;
			}
			else
			{
				nStartingAtSN = pRec->nStartingSequNum + pRec->nNewSpanCount;
				// the above index will definitely lie within the document's list
				// because follNotesMoveSpanList is not empty
			}
			nReplaceCount = nCount;
			bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartingAtSN,
				nCount, &pRec->follNotesMoveSpanList, 0, nReplaceCount);
			if (!bReplacedOK)
			{
                // if we have an error while restoring the original document, then we can't
                // get back the document as it was, so it is best to abort the app and lose
                // recent changes than to continue and risk a malformed document or with
                // content lacking somewhere within. Error is unlikely, so English will do
				error = _T(
"Restoration of the following context's span of potentially moved notes failed, so rather than save a bad document, we abort the application now, losing the work done since the last save.");
				wxMessageBox(error, _T("Source Text Edit: error"), wxICON_ERROR | wxOK);
				wxExit();
			}
		}
		// now the preceding context's subspan
		nCount = pRec->precNotesMoveSpanList.GetCount();
		if (nCount > 0)
		{
			nStartingAtSN = pRec->nStartingSequNum - 1; // the instance just
														// prior to the edit span
			nStartingAtSN = nStartingAtSN - nCount + 1; // allow for the sublist's
                    // content; the above index will definitely lie within the
                    // document's list because precNotesMoveSpanList is not empty
			nReplaceCount = nCount;
			bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartingAtSN,
				nCount, &pRec->precNotesMoveSpanList, 0, nReplaceCount);
			if (!bReplacedOK)
			{
                // if we have an error while restoring the original document, then we can't
                // get back the document as it was, so it is best to abort the app and lose
                // recent changes than to continue and risk a malformed document or with
                // content lacking somewhere within. English will do, error is unlikely.
				error = _T(
"Restoration of the preceding context's span of potential moved notes failed, so rather than save a bad document, we abort the application now, losing the work done since the last save.");
				wxMessageBox(error, _T("Source Text Edit: error"), wxICON_ERROR | wxOK);
				wxExit();
			}
		}
	}

    // if the cancel span has instances to the left of the nStartingSequNum value for the
    // commencement of the former editable span, then replace the m_pSourcePhrases
    // instances in that range with the deep copies from the same subrange in the cancel
    // list; the consecutive values of the sequence numbers stored on the instances are
    // still correct after this next block is done
	if (pRec->nCancelSpan_StartingSequNum < pRec->nStartingSequNum)
	{
		nCount = pRec->nStartingSequNum - pRec->nCancelSpan_StartingSequNum;
		nReplaceCount = nCount;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases,
							pRec->nCancelSpan_StartingSequNum, nCount,
							&pRec->cancelSpan_SrcPhraseList, 0, nReplaceCount);
		if (!bReplacedOK)
		{
            // if we have an error while restoring the original document, then we can't get
            // back the document as it was, so it is best to abort the app and lose recent
            // changes than to continue and risk a malformed document or with content
            // lacking somewhere within. Don't localize the message
			error = _T(
"Restoration of the document failed in the initial replacements from the cancel span, so rather than save a bad document, we abort the application now, losing the work done since the last save.");
			wxMessageBox(error, _T("Source Text Edit: error"), wxICON_ERROR | wxOK);
			wxExit();
		}
	}
    // now we must replace the CSourcePhrase instances which were the result of the user's
    // edit, with those which were in the original (possibly extended by a retranslation)
    // editable span
	bReplacedOK = ReplaceCSourcePhrasesInSpan(
		pSrcPhrases,
		pRec->nStartingSequNum, // could be beyond doc end if the edit
								// removed data from doc end
		pRec->nNewSpanCount, // could be zero, or small, or large
		&pRec->cancelSpan_SrcPhraseList, // where the replacements are to be taken from
		pRec->nStartingSequNum - pRec->nCancelSpan_StartingSequNum, // offset in cancel
							// span where the insertions are to be done from (inclusive)
		pRec->nOldSpanCount // how many old instances were in the editable span
	);
	if (!bReplacedOK)
	{
        // if we have an error while restoring the original document, then we can't get
        // back the document as it was, so it is best to abort the app and lose recent
        // changes than to continue and risk a malformed document or with content lacking
        // somewhere within
		error = _T(
"Restoration of the document failed in the replacements from the editable span within the cancel span, so rather than save a bad document, we abort the application now, losing the work done since the last save.");
		wxMessageBox(error, _T("Source Text Edit: error"), wxICON_ERROR | wxOK);
		wxExit();
	}
	// update the sequence numbers, starting from the start of the cancel span
	UpdateSequNumbers(pRec->nCancelSpan_StartingSequNum);

    // now replace any CSourcePhrase instances at the end of the cancel span, provided they
    // lie beyond the end of the just replaced editable span
	if (pRec->nCancelSpan_EndingSequNum > pRec->nEndingSequNum)
	{
		// there are are some instances in the cancel span not yet replaced, so do so
		int nStartAt_InCancelSpan = pRec->nEndingSequNum -
										pRec->nCancelSpan_StartingSequNum + 1;
		int nHowMany_InCancelSpan = pRec->nCancelSpan_EndingSequNum -
										pRec->nEndingSequNum;
		int nStartAt_InDocList = pRec->nEndingSequNum + 1;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartAt_InDocList,
								nHowMany_InCancelSpan, &pRec->cancelSpan_SrcPhraseList,
								nStartAt_InCancelSpan, nHowMany_InCancelSpan);
		if (!bReplacedOK)
		{
            // if we have an error while restoring the original document, then we can't get
            // back the document as it was, so it is best to abort the app and lose recent
            // changes than to continue and risk a malformed document or with content
            // lacking somewhere within. Don't localize message
			error = _T(
"Restoration of the document failed in the final replacements from the cancel span, so rather than save a bad document, we abort the application now, losing the work done since the last save.");
			wxMessageBox(error, _T("Source Text Edit: error"), wxICON_EXCLAMATION | wxOK);
			wxExit();
		}
	}

    // The attempt to do source text editing could, if the SF markup was altered, result in
    // a new TextType having to be propagated forward into the following context. The
    // propagation would continue until a marker was encountered which changed the
    // TextType, and so such a propagation conceivably may sometimes go beyond the end of
    // the cancel span. The text type would be different on those CSourcePhrase instances,
    // and also possibly the special text boolean, and m_inform member. So the final task
    // is to work out now if are any CSourcePhrase instances in the propagation span (in
    // the EditRecord) which lie beyond the end of the cancel span; if so, we must replace
    // that subspan of the document's list with the relevant deep copies from the
    // propagation span list in the EditRecord.
	if (pRec->nPropagationSpan_EndingSequNum > pRec->nCancelSpan_EndingSequNum)
	{
		// there are are some instances in the propagation span not yet replaced, so do so
		int nStartAt_InPropSpan = pRec->nCancelSpan_EndingSequNum -
									pRec->nPropagationSpan_StartingSequNum + 1;
		int nHowMany_InPropSpan = pRec->nPropagationSpan_EndingSequNum -
									pRec->nCancelSpan_EndingSequNum;
		int nStartAt_InDocList = pRec->nCancelSpan_EndingSequNum + 1;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartAt_InDocList,
							nHowMany_InPropSpan, &pRec->propagationSpan_SrcPhraseList,
							nStartAt_InPropSpan, nHowMany_InPropSpan);
		if (!bReplacedOK)
		{
            // if we have an error while restoring the original document, then we can't get
            // back the document as it was, so it is best to abort the app and lose recent
            // changes than to continue and risk a malformed document or with content
            // lacking somewhere within. Don't localize the message
			error = _T(
"Restoration of the document failed in the replacements from the propagation span, so rather than save a bad document, we abort the application now, losing the work done since the last save.");
			wxMessageBox(error, _T("Source Text Edit: error"), wxICON_ERROR | wxOK);
			wxExit();
		}
	}
	// if we haven't aborted, then the original document state prior to
	// the source text edit has now been successfully restored
}


/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there was no error, FALSE if some kind of exception or bad value
///             happened
/// \param      pRec           -> pointer to the EditRecord which has the info about
///                               bounds and spans etc
/// \param      pSrcPhrases    -> pointer to the document's m_pSourcePhrases member
/// \param      strNewSource   -> reference to the current (post-edit) new source text
///                               which we potentially will be appending additional words
///                               to from the following context to the current editable
///                               span (and also, in parallel, extending the width of the
///                               editable span, etc)
/// \param      pMap           <- pointer to the document's map called m_FilterStatusMap,
///                               which contains the "to-be-filtered" entries (probably
///                               never more than one) which specify the particular SFM
///                               we need to search for in order to determine where its
///                               filterable content commences
/// \param      bWasExtended   <- returns TRUE to the caller if the function actually
///                               extended the editable span -- the caller may not need to
///                               know this, but just in case we give it the knowledge of
///                               whether or not pRec had its contents altered; returns
///                               FALSE if the editable span was not extended (and
///                               therefore no changes made to pRec's contents)
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The prototypical situation we have designed this function for is the following. \yy
/// would be an "unknown" marker, because it is not a marker in any known SFM set, not the
/// USFM set, not the 1998 PNG set. The document may contain ?\yy? in the navigation text
/// where there is word1 word2 word3 word4 etc, and the user decides to edit \yy to, say,
/// \r (a reference marker which is filterable by default). He then just selects word1 and
/// does Edit / Edit Source Text, and in the dialog changes \yy to \r and clicks OK. The \r
/// marker's content is, because it is a to-be-filtered marker, all supposed to be filtered
/// out, but his word selection for the editable span was only word1, rather than word1
/// word2 ... down to whatever word is last before the next SFM location (other than a
/// 'none' TextType one which we want to ignore). Adapt It then just filters the \r and
/// word1 as its content, and word2 word3 etc are left in the document as if they were
/// sacred text to be adapted. What the user should have done was to include all the word1
/// word2 word3 ... down to the end of the filterable content, in his original selection -
/// then Adapt It would filter the whole word string out properly. The
/// ExtendEditableSpanForFiltering() function, therefore, permits the user to do the
/// obvious thing (ie. select just word1 where the bad marker is stored under the hood) and
/// nevertheless get the whole of the bad marker's text contents filtered out, as if he'd
/// really selected all of the words of that material. The way the function works is to
/// scan rightwards from the end of the passed in editable span (pRec has that information)
/// until the end of the marker's filterable contents is found, where it will halt. We use
/// the HaltCurrentCollection() function to find the halt location, because it has the
/// smarts about the SFM set currently in operation, and it ignores the markers which have
/// their associated TextType with the value none. Each CSourcePhrase traversed without
/// causing a halt yields a source text word or phrase to be appended to strNewSource, a
/// deep copy of the CSourcePhrase is made and inserted in the appropriate spans - a very
/// tricky process because we throw away any Notes, free translations and/or collected back
/// translations which the user may have erroneously defined on that filterable material
/// (though we'd expect he wouldn't have ever put such things there, and usually the bad
/// marker would be edited long before he'd add such things to his document). Because of
/// the complexity of what is to be done in this function, we'll just make the insertions
/// of deep copied CSourcePhrase instances in the lists, and increment the "Ending"
/// sequence numbers for the various spans to comply with the extension of the editable
/// span. This should suffice, but if bailout of the vertical edit process happens then any
/// notes, free translations or collected back translations defined on this extra material
/// won't be recreated. The chances of that being a problem, however, are miniscule.
/// BEW created 5July08, for support of refactored Source Text Edit functionality
/// BEW 23Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ExtendEditableSpanForFiltering(
										EditRecord*					pRec,
										SPList*						pSrcPhrases,
										wxString&					strNewSource,
										MapWholeMkrToFilterStatus*	WXUNUSED(pMap),
										bool&						bWasExtended)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	bWasExtended = FALSE; // default starting value
	bool bFound_bt_mkr = FALSE;
	bool bIsHaltLocation = FALSE;
	//CString markers;
	int nIteratorSN = pRec->nEndingSequNum + 1;
	if (nIteratorSN > pApp->GetMaxIndex())
		return TRUE; // do nothing if the editable span ended at the document end
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nIteratorSN);
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in ExtendEditableSpanForFiltering(), pos value is NULL. Saving and restoring document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION | wxOK);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	int nCancelSpanEnd = pRec->nCancelSpan_EndingSequNum; // it's also where the
														  // modificationsSpan ends
	wxString aSpace = _T(' ');

    // scan forwards, until at a halt location (the very first CSourcePhrase might be a
    // halt location, so the scan might exit without any extension to the editable span)
	while (pos != NULL)
	{
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nIteratorSN = pSrcPhrase->m_nSequNumber;
		bIsHaltLocation = pApp->m_pFreeTrans->HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
		if (bIsHaltLocation)
		{
			// no further extension is needed, so exit the loop
			break;
		}
		else
		{
            // we need to add to the new source text, and increment the index for the end
            // of the editable span, and we also must check if we've gone past the end of
            // the cancel span - if the latter is true, then we must extend both the cancel
            // and modifications spans and increment their ending index (they always have
            // the same extent) and append a deep copy to each list
			bWasExtended = TRUE; // tell the caller an extension was done
								 // (caller will put the value into pRec)
			strNewSource += aSpace + pSrcPhrase->m_srcPhrase;
			pRec->nEndingSequNum = nIteratorSN; // set the new end to the editable span
			pRec->nOldSpanCount += 1; // we are widening the old editable span
			pRec->nNewSpanCount += 1; // and also widening the new source text span
			pRec->nEndingTextType = pSrcPhrase->m_curTextType; // update, in case
															   // it is different
			if (nIteratorSN > nCancelSpanEnd)
			{
				pRec->nCancelSpan_EndingSequNum = nIteratorSN;
				CSourcePhrase* 	pNewOne = new CSourcePhrase(*pSrcPhrase);
				pNewOne->DeepCopy();
				pRec->cancelSpan_SrcPhraseList.Append(pNewOne); // add a copy to the
																// cancelSpan's list
				CSourcePhrase* 	pNewTwo = new CSourcePhrase(*pSrcPhrase);
				pNewTwo->DeepCopy();
				pRec->modificationsSpan_SrcPhraseList.Append(pNewTwo); // add a new
												// copy to the modificationsSpan's list
				nCancelSpanEnd = nIteratorSN; // update; not nessessary, but harmless
			}
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrases -> pointer to the app's m_pSourcePhrases list
/// \param      pRec        -> pointer to the EditRecord for the vertical edit process
/// \remarks
/// Called from: the View's CopyCSourcePhrasesToExtendSpan(), and OnEditSourceText().
/// Cancels out from the source text editing process. It clears the clearable parts of
/// the EditRecord, rolls back through the lists of CSourcePhrases using the user's
/// chosen order and restores the former document state
/// BEW 22Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::BailOutFromEditProcess(SPList* pSrcPhrases, EditRecord* pRec)
{
    // this must clear the clearable parts of the EditRecord, roll back through the lists
    // of CSourcePhrases using the user's chosen order .. anything else? No.

	CAdapt_ItApp* pApp = &wxGetApp();
	if (gEditStep == sourceTextStep && gEntryPoint == sourceTextEntryPoint)
	{
        // What has to be done depends on whether the document's native structures have as
        // yet been modified. If they are as yet unchanged, we only need reinitialize the
        // edit record. If they have been changed, we have to use the cancel span and
        // propagation span and other parameters to get the document restored to what it
        // originally was prior to the commencement of the vertical edit at the source text
        // edit step
		if (!gbEditingSourceAndDocNotYetChanged)
		{
			// doc is modified, so undo what has been done, and then proceed
			// to the reinitialization
			RestoreDocAfterSrcTextEditModifiedIt(pSrcPhrases, pRec);
		}
	}

	// do the resetting of the globals, so that we are ready for a new
	// vertical edit process
	gbVerticalEditInProgress = FALSE;
	gEntryPoint = noEntryPoint;
	gEditStep = noEditStep;
	gbEditingSourceAndDocNotYetChanged = TRUE;

	// get the phrase box restored, and set up the m_targetStr member of
	// source phrase at that location
	wxString str3;
	if (pRec->nSaveActiveSequNum != -1)
	{
		pApp->m_nActiveSequNum = pRec->nSaveActiveSequNum;
		if (pApp->m_nActiveSequNum > pApp->GetMaxIndex())
			pApp->m_nActiveSequNum = pApp->GetMaxIndex();
	}
	else
	{
		// assume it is -1 because data was chopped off the end of the doc, so set active
		// sn to the last current sequence number, to give RecalcLayout() a chance
		pApp->m_nActiveSequNum = pApp->GetMaxIndex();
	}

    // BEW changed 19Jun09, the refactored code may well be able to restore correctly, let
    // it try - all we want to do here is make the old active sequ number and old box
    // contents be reestablished, and set a spurious active pile, even though wrong it
    // should make RecalcLayout() able to succeed
	pApp->m_pActivePile = GetPile(0);
	if (pApp->m_pActivePile != NULL)
	{
		str3 = pRec->oldPhraseBoxText;
		pApp->m_targetPhrase = str3;
		pApp->m_pTargetBox->ChangeValue(str3);
	}
	else
	{
		// layout not valid, shouldn't happen so just give a message & abort
		wxMessageBox(_T(
		"Null active pile pointer in BailOutFromEditProcess(), so will abort..."),
		_T(""), wxICON_ERROR | wxOK);
		wxExit();
	}

	// remove selection
	RemoveSelection();

	// layout to ensurer that the targetBox won't encroach on the next cell's
	// adaption text
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif

	// get a new valid active pile pointer
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	GetLayout()->m_docEditOperationType = vert_edit_bailout_op;

	// ensure respect for boundaries is turned back on
	if (!pApp->m_bRespectBoundaries)
	{
		wxCommandEvent ev;
		OnButtonFromIgnoringBdryToRespectingBdry(ev);
	}
	pApp->GetRetranslation()->SetIsInsertingWithinFootnote(FALSE);

	// scroll into view if necessary
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	// get the restored layout and phrase box redrawn
	pApp->m_pTargetBox->SetFocus();
	Invalidate();
	GetLayout()->PlaceBox();
	InitializeEditRecord(*pRec);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      bOnlyWithinSpan  -> default TRUE; explicitly set to FALSE to cause a
///                                 unilateral storage attempt regardless of whether
///                                 or not the active location is within the span of
///                                 the adaptationsStep or glossesStep
/// \remarks
/// Called from: the View's OnEditSourceText() and OnCustomEventEndVerticalEdit().
/// StoreText() always attempts the store. DoConditionalStore() wraps the StoreText() call
/// in a lot of tests, so that the store is only done when really wanted (eg, when the
/// phrase box contents were not copied). Store is not wanted if contents were copied, &
/// the user has not yet typed something nor clicked in the box, and the CPhraseBox class
/// member m_bAbandonable is still TRUE, and the box text is non-empty). When those things
/// don't obtain, we can be pretty certain the user has done some editing in the box and so
/// we'd expect to save that work if the box contents are about to be cleared. The flags we
/// need to look at are all globals (or, for the wxWidgets versions, they'd all be members
/// of the app class), and so we don't need to pass anything in; nor return anything. The
/// distinction between glossing and adapting modes is also handled internally too. And we
/// make sure that if the user had earlier removed the relevant entry from the KB or
/// glossing KB, whichever applies, then the store won't fail by having flags set on the
/// document at that point which are incompatible with the KB contents after said removal.
///
/// BEW created 1Aug08 by BEW, for support of refactored Source Text Edit functionality,
/// but could be used elsewhere if we ever refactor other code - the code here is cloned
/// from part of PlacePhraseBox() and tweaked a bit
/// BEW 23Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::DoConditionalStore(bool bOnlyWithinSpan)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	EditRecord* pRec = &gEditRecord;
	wxString strBoxText;
	strBoxText = pApp->m_pTargetBox->GetValue(); // save, in case later failure requires
												// the box contents be reconstructed

    // what we do depends on where the active pile is when this function is called. If the
    // user has clicked the End Now button while the phrase box is still in an active
    // editing step of Vertical Edit, then it is appropriate to save the box contents to
    // the KB before restoring the phrase box to the original position or suitable place
    // nearby. On the other hand, if the box has been advanced in the lookup loop and has
    // reached the end of the current span and the dialog asking the user to either click
    // Next Step, Previous Step, End Now or Cancel All Steps is showing and he elects to
    // End Now, then the phrase box will be disengaged from the active pile: the box will
    // be showing at the last pile in the current span, but the active location will have
    // moved forward to the first hole beyond the end of the editing span currently active
    // (it could be adaptationsStep, glossesStep, or freeTranslationsStep) and so doing a
    // store would store garbage in such a situation. So we have to test for which end
    // state we have, and either do a store or restore the active location back to where
    // the phrase box is and not do a store (since it would have been done already at the
    // start of the lookahead loop); and then set up the phrase box at the appropriate
    // place in the document for when vertical editig mode is off. We use the current
    // m_pActivePile to determine where the active location is, and act accordingly.
	CPile* pPile = pApp->m_pActivePile;
	if (pPile == NULL)
	{
		// no active location is defined, so we can't store an adaptation or gloss, so exit
		return;
	}
	wxASSERT(pPile != NULL);
	bool bWithinSpan = FALSE;
	bool bFreeTransStepIsCurrent = FALSE; // storing to KB or glossingKB is needed
										  // when FALSE, not when TRUE
	bool bUnknownStep = FALSE;
	int nCurSequNum = pPile->GetSrcPhrase()->m_nSequNumber;
	switch (gEditStep) {
		case adaptationsStep:
			if (nCurSequNum >= pRec->nAdaptationStep_StartingSequNum &&
				nCurSequNum <= pRec->nAdaptationStep_EndingSequNum)
			{
				bWithinSpan = TRUE;
			}
			break;
		case glossesStep:
			if (nCurSequNum >= pRec->nGlossStep_StartingSequNum &&
				nCurSequNum <= pRec->nGlossStep_EndingSequNum)
			{
				bWithinSpan = TRUE;
			}
			break;
		case freeTranslationsStep:
			bFreeTransStepIsCurrent = TRUE;
			if (nCurSequNum >= pRec->nFreeTranslationStep_StartingSequNum &&
				nCurSequNum <= pRec->nFreeTranslationStep_EndingSequNum)
			{
				bWithinSpan = TRUE;
			}
			break;
		default:
			bUnknownStep = TRUE;
	}

	if (!bOnlyWithinSpan)
	{
		// cause unilateral store attempt, provided other conditions are met
		bWithinSpan =  TRUE;
	}
	if (!bUnknownStep && bWithinSpan && !bFreeTransStepIsCurrent)
	{
		// any one of the following 3 tests is sufficient cause for attempting to store
		if (pApp->m_bUserTypedSomething || !pApp->m_pTargetBox->m_bAbandonable ||
			!gbByCopyOnly)
		{
			// make sure m_targetPhrase doesn't have any final spaces
			RemoveFinalSpaces(pApp->m_pTargetBox,&pApp->m_targetPhrase);

			// any existing phraseBox text must be saved to the KB or glossingKB,
			// unless it's empty
			if (!pApp->m_targetPhrase.IsEmpty())
			{
				if (pApp->m_pTargetBox->IsModified()) //MFC uses GetModify()
				{
					// only save if something (eg a click or typing) has set the box's
					// dirty flag
					if (pApp->m_pTargetBox->m_bAbandonable)
					{
                        // if abandonable, we want to throw away the text in the box, so
                        // clearing it will do the trick -- it makes the store operation do
                        // no store
						pApp->m_targetPhrase.Empty();
						pApp->m_pTargetBox->ChangeValue(_T(""));
					}
				}

				// it has to be saved to the relevant KB now
				if (!pApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
				{
					KB_Entry rsEntry;
					if (gbIsGlossing)
					{
                        // the store attempt would fail if the user earlier edited the
                        // entry out of the glossing KB, as the glossing KB cannot know
                        // which srcPhrases will be affected by such a change, so these in
                        // the document would still have their m_bHasGlossingKBEntry set
                        // true. We have to test for this, ie. a null pRefString, but that
                        // flag being TRUE is a sufficient test, and if so, set the flag to
                        // FALSE
						CRefString* pRefStr = NULL;
						rsEntry = pApp->m_pGlossingKB->GetRefString(
							pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
							pApp->m_pActivePile->GetSrcPhrase()->m_key, pApp->m_targetPhrase, pRefStr);
						if ((pRefStr == NULL || rsEntry == present_but_deleted) &&
							pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
						{
							pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
						}
						bool bOK;
						bOK = pApp->m_pGlossingKB->StoreText(pApp->m_pActivePile->GetSrcPhrase(),
															pApp->m_targetPhrase);
						bOK = bOK; // avoid warning
					}
					else
					{
						MakeTargetStringIncludingPunctuation(pApp->m_pActivePile->GetSrcPhrase(),
											pApp->m_targetPhrase);
						RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);

                        // the store attempt would fail if the user earlier edited the
                        // entry out of the adaptation KB, as the adaptation KB cannot know
                        // which srcPhrases will be affected by such a change, so these in
                        // the document would still have their m_bHasKBEntry set true. We
                        // have to test for this, ie. a null pRefString, but that flag
                        // being TRUE is a sufficient test, and if so, set the flag to
                        // FALSE
						CRefString* pRefStr = NULL;
						rsEntry = pApp->m_pKB->GetRefString(
							pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
							pApp->m_pActivePile->GetSrcPhrase()->m_key, pApp->m_targetPhrase, pRefStr);
						if ((pRefStr == NULL || rsEntry == present_but_deleted) &&
							pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
						{
							pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
						}
						gbInhibitMakeTargetStringCall = TRUE;
						bool bOK;
						bOK = pApp->m_pKB->StoreText(pApp->m_pActivePile->GetSrcPhrase(),
															pApp->m_targetPhrase);
						bOK = bOK; // avoid warning
						gbInhibitMakeTargetStringCall = FALSE;
					}
				}
			} // end block for non-empty box contents
			else
			{
				// m_targetPhrase is empty, so let StoreText handle what needs to happen.
				bool bOK = FALSE;
				KB_Entry rsEntry;
				if (gbIsGlossing)
				{
					// see above for why we do this
					CRefString* pRefStr = NULL;
					rsEntry = pApp->m_pGlossingKB->GetRefString(
									pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
									pApp->m_pActivePile->GetSrcPhrase()->m_key,
									pApp->m_targetPhrase, pRefStr);
					if ((pRefStr == NULL || rsEntry == present_but_deleted) &&
						pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
					{
						pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
					}
					bOK = pApp->m_pGlossingKB->StoreText(pApp->m_pActivePile->GetSrcPhrase(),
														pApp->m_targetPhrase);
				}
				else // is adapting
				{
					MakeTargetStringIncludingPunctuation(pApp->m_pActivePile->GetSrcPhrase(),
										pApp->m_targetPhrase);
					RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);

					// see above for why we do this
					CRefString* pRefStr = NULL;
					rsEntry = pApp->m_pKB->GetRefString(
									pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
									pApp->m_pActivePile->GetSrcPhrase()->m_key,
									pApp->m_targetPhrase, pRefStr);
					if ((pRefStr == NULL || rsEntry == present_but_deleted) &&
						pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
					{
						pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
					}
					gbInhibitMakeTargetStringCall = TRUE;
					bOK = pApp->m_pKB->StoreText(pApp->m_pActivePile->GetSrcPhrase(),
														pApp->m_targetPhrase);
					gbInhibitMakeTargetStringCall = FALSE;
				}

				// check for a failure, abandon the function if the store failed? No, we'll
				// just continue processing - the store failure is not a major problem
				if (!bOK)
				{
					// for the present, do nothing
					;
				}
			}
		} // end block for m_bUserTypedSomething == TRUE
	}
}

/// BEW 26Mar10, no changes needed for support of doc version 5
/// BEW 9July10, no changes needed for support of kbVersion 2
void CAdapt_ItView::RestoreBoxOnFinishVerticalMode()
{
	EditRecord* pRec = &gEditRecord;
	CAdapt_ItApp* pApp = &wxGetApp();

    // when this function is called, the original pre-Vertical Edit Process mode (either
    // glossing or adapting) will have been restored, but the gEditRecord has not yet been
    // initialized so as to clear it; so use its contents to work out where the active
    // location should be put
	int nSequNum = pRec->nSaveActiveSequNum; // original location
	bool bOriginalLocationWithinSpan = FALSE;
	if (!gbIsGlossing)
	{
		// we are in adapting mode
		if (pRec->nAdaptationStep_NewSpanCount != 0)
		{
			if (nSequNum >= pRec->nAdaptationStep_StartingSequNum &&
				nSequNum <= pRec->nAdaptationStep_EndingSequNum)
			{
				bOriginalLocationWithinSpan = TRUE;
			}
		}
	}
	else
	{
		// we are in glossing mode
		if (pRec->nAdaptationStep_NewSpanCount != 0)
		{
			if (nSequNum >= pRec->nGlossStep_StartingSequNum &&
				nSequNum <= pRec->nGlossStep_EndingSequNum)
			{
				bOriginalLocationWithinSpan = TRUE;
			}
		}
	}

    // now we attempt to find a safe final active location; and it can be within a
    // retranslation if we are restoring glossing mode, but not if we are restoring
    // adapting mode; vertical edit in MFC legacy app is only available from a Source Text
    // Edit, and it is not possible to do that from free translations mode, so we know we
    // are not restoring to the latter mode (**** NOT TRUE for wxWidgets *** where
    // eventually vert edit will be available in any mode except when collecting back
    // translations -- in that case extend this function to handle those extra options)
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pOldSrcPhrase = NULL;
	if (!gbIsGlossing)
	{
		// adapting mode was on when the user first entered the edit process
		// & is now back on
		if (bOriginalLocationWithinSpan || pRec->nAdaptationStep_NewSpanCount == 0)
		{
            // the original location was either within the (non-empty) span, or the span is
            // now empty because the user deleted all of its CSourcePhrase instances - in
            // which case the old sequence number at entry would now be somewhere in the
            // context or even possibly beyond the end of the document, so we have to look
            // carefully for a suitable place to rebuild the box -- it could be within a
            // retranslation, so find a safe place to put the box
			if (nSequNum > pApp->GetMaxIndex())
			{
				// the old location is beyond the end of the document, so initialize to the
				// last CSourcePhrase instance in the document, and then check it is safe
				nSequNum =  pApp->GetMaxIndex();
			}
			pSrcPhrase = GetSrcPhrase(nSequNum); // won't return NULL because the
												 // CSourcePhrase at nSequNum we know exists
			pOldSrcPhrase = pSrcPhrase; // in case we want to try again from same initial one
			wxASSERT(pSrcPhrase != NULL);
			if (pSrcPhrase->m_bRetranslation)
			{
                // this location is within a retranslation, and because of the possibility
                // the edit span may be at the end of the document, we'll look for a safe
                // location preceding the retranslation rather than following it
				pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);
				if (pSrcPhrase == NULL)
				{
                    // we expect this never to happen, but if we can't find such a
                    // location, try following the the retranslation
					pSrcPhrase = pOldSrcPhrase;
					pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);
					if (pSrcPhrase == NULL)
					{
						// unthinkable, but if it happens, violate rule about retranslations
						// and put the box within it!
						pSrcPhrase = pOldSrcPhrase;
					}
				}
			}
			// get the safe sequence number index
			nSequNum = pSrcPhrase->m_nSequNumber;
		}
		else
		{
            // the original location, being outside the span, must already be a safe
            // location, so do the restoration at nSequNum's location
			;
		}
	}

	// we now have the nSequNum at which we want to restore the box, so do it
	// BEW 10Jan12, bug fix needed here - use GetSrcPhrase() and gbIsGlossing
	// to find the appropriate text for the box, don't use the translation (wxString)
	// global variable's value - it isn't guaranteed to contain the wanted string
	bool bOldIsOK = TRUE;
	if (nSequNum == pRec->nSaveActiveSequNum)
	{
		// the old location is still good, use it -- grab whatever is the
		// appropriate text in the CSourcePhrase instance at that location
		CSourcePhrase* spPtr = GetSrcPhrase(nSequNum);
		wxASSERT(spPtr != NULL);
		if (gbIsGlossing)
		{
			pApp->m_targetPhrase = spPtr->m_gloss;
		}
		else
		{
			pApp->m_targetPhrase = spPtr->m_adaption;
		}
		translation.Empty();
	}
	else
	{
		// clear, and do a lookup below instead
		translation.Empty();
		pApp->m_targetPhrase.Empty();
		bOldIsOK = FALSE;
	}

	// now set up the phrase box
	pApp->m_nActiveSequNum = nSequNum; // needed, as a test for m_nActiveSequNum
				// < 0 done internally will have box placement skipped if we get
				// here and it is -1
	pApp->m_pActivePile = GetPile(nSequNum);
	bool bFoundSomething = FALSE;
	if (!bOldIsOK)
	{
		if (!pRec->bGlossingModeOnEntry)
		{
			if (pApp->m_pActivePile->GetSrcPhrase()->m_adaption.IsEmpty())
				bFoundSomething = pApp->m_pTargetBox->LookUpSrcWord(pApp->m_pActivePile);
			if (bFoundSomething)
			{
				pApp->m_targetPhrase = translation;
			}
			else
			{
				translation = pApp->m_pActivePile->GetSrcPhrase()->m_adaption;
				pApp->m_targetPhrase = translation;
			}
		}
		else
		{
			// it was glossing mode on entry
			if (pApp->m_pActivePile->GetSrcPhrase()->m_gloss.IsEmpty())
				bFoundSomething = pApp->m_pTargetBox->LookUpSrcWord(pApp->m_pActivePile);
			if (bFoundSomething)
			{
				pApp->m_targetPhrase = translation;
			}
			else
			{
				translation = pApp->m_pActivePile->GetSrcPhrase()->m_gloss;
				pApp->m_targetPhrase = translation;
			}
		}
	}
	CLayout* pLayout = GetLayout();
#ifdef _NEW_LAYOUT
	//pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
	// BEW 20Jan11, need to recreate the strips on Restoration because there will have
	// been piles replaced and possibly some created in order to restore the original
	// state, and they will still have default value for m_pOwningStrip of NULL, and that
	// will cause a crash unless the strips are rebuilt so as to be synched to whatever
	// pile array was reestablished
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum); // BEW added 12June09

	pLayout->m_docEditOperationType = vert_edit_exit_op;
    // call Invalidate() in the caller, which is OnCustomEventEndVerticalEdit() & that is
    // the only place in the application where RestoreBoxOnFinishVerticalMode() is called
}

// public accessor
void CAdapt_ItView::EditSourceText(wxCommandEvent& event)
{
	OnEditSourceText(event);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event       ->  (unused)
/// \remarks
/// OnEditSourceText handles the editing of one or more selected source text words or
/// phrases, or editing of the unselected source text word or phrase at the active pile.
/// On completion of the edit, it automatically checks for dependent information
/// (adaptation, gloss, free translation, back translation) at or overlapping the edited
/// region of the document, and if there is any such, it drops into a 'vertical edit' mode
/// at the appropriate entry point - depending on what dependent information is present
/// This function relinguishes responsibility for managing the document and view once
/// vertical edit has been entered; the vertical edit process manages itself (using custom
/// events) until completion or until the user exits it in one of a few prescribed ways.
///
/// BEW updated, 11Apr08++ to remove modalities, show filtered info with selected text,
/// extend selection if necessary to accomodate editing within or overlapping a
/// retranslation, handle endmarkers of the USFM standard adequately, and remove the child
/// dialog for marker transfer (This refactored version is part of a staged process, called
/// "vertical editing" which makes use of a global struct, gEditRecord, defined at the top
/// of this file. The struct, EditRecord, is itself defined in Adapt_It.h)
/// BEW modified 13Nov09, if the local user has only read-only access to a remote
/// project folder, do not permit him to force a source text edit upon the remote
/// user! (suppress here, and also in the update handler)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnEditSourceText(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_bReadOnlyAccess)
	{
		::wxBell(); // whm 15Mar12 added wxBell()
		return;
	}
	CAdapt_ItDoc* pDoc = GetDocument();
	EditRecord* pRec = &gEditRecord; // local pointer to the global EditRecord

	pApp->LogUserAction(_T("Initiated OnEditSourceText()"));

	// we cannot have any synchronized scrolling messages be received, throwing the active
    // location to any old place during vertical edit mode, we have to keep total control
    // of the active location; so if it is currently on, save the setting, turn it off, and
    // use the saved setting to restore it back to its on state when we are done
	if (gbIgnoreScriptureReference_Receive == FALSE)
	{
		// it is currently ON, so save it and turn off
		gbVerticalEdit_SynchronizedScrollReceiveBooleanWasON = TRUE;
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedReceiveSynchronizedScrollingMessages(uevent);
													// toggle receiving to OFF
	}

	pRec->bGlossingModeOnEntry = gbIsGlossing; // save, for when original mode
											   // is to be set up again
	pRec->bSeeGlossesEnabledOnEntry = gbGlossingVisible; // ditto

	gbEditingSourceAndDocNotYetChanged = TRUE;
	bool bUserCancelled = FALSE;
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;	// will change if the selection is programmatically
							//extended leftwards (see above)
	CPile* pEndingPile;		// will change if the selection is programmatically
							//extended rightwards
	//int nStartingStripIndex; // may decrease if the selection is programmatically // set but not used
							// extended leftwards
    // int nStartingSequNum, and int nEndingSequNum are in the EditRecord struct; these to
    // track the sequence number for the start of the (possibly extended programmatically)
    // selection (we don't actually extend the selection but just work out the new starting
    // and ending sequence number values)
	pRec->nNewSpanCount = -1; // -1 means "this value is undefined thus far"
	wxString str; // a temporary storage string
	str.Empty();
	wxString str2; // second temporary storage string
	str2.Empty();
	wxString strSource; // the source text which is to be retranslated
						// (from m_srcPhrase values)
	strSource.Empty();
	pApp->m_FilterStatusMap.clear(); // BEW added 16Jun05, entries will be \mrkr=0 or
                // \mkr=1 for \mkr as key, with =0 meaning 'now to be unfiltered' and
                // =1 meaning 'now to be filtered'
    // save the active sequ number, so we can later determine whether or not the active
    // location lies within the selection (if it's not in the selection, we will need to
    // recreate the phrase box at the former active location when done - BE CAREFUL,
    // because if the active location lies after the selection and the selection contains
    // null src phrases or merged phrases, then the value of nFormerActiveSequNum will need
    // to be updated as we remove null src phrases and / or unmerge merged phrases); and
    // (for 11Apr08 code changes) the active location may start out outside the selection
    // but for acceptance of the user's edit, we put it always at the start of the new
    // source text (ready for updating adaptations in next step of the vertical edit
    // process), or if there is no new text, at the start of the following context (or a
    // safe location if that is a retranslation) -- so our refactored code probably won't
    // make use of the saved value much
	pRec->nSaveActiveSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;
	pDoc->ResetPartnerPileWidth(pApp->m_pActivePile->GetSrcPhrase()); // mark its strip
																	  // as invalid
	// preserve the active location's phrase box text, in case
	// the phrase box is recreated there when done
	pRec->oldPhraseBoxText = pApp->m_targetPhrase;

	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pEndingSrcPhrase = NULL;
	wxString strAdapt; // accumulates the existing adaptation text for the selection
        // using the m_targetStr member of each CSourcePhrase instance (ie. includes
        // punctuation) but in the refactored code we don't make any use of this nor let
        // the user see it
	strAdapt.Empty();

    // NOTE: for the wxWidgets version, we need to add a CStringList to store the m_key
    // members (not m_srcPhrase members, because punctuation location may get changed in
    // the edit) which will assist us to work out what the former mergers were so we can
    // reconstitute them whenever their source text was unchanged (other than punctuation
    // changes) in the edit; we won't build that functionality yet however --- (may or may
    // not happen, jury still out)

	// Jim Henderson requested that CTRL + Q be able to invoke the handler without a
	// selection and just use the active location -- so made the OnUpdateEditSourceText()
	// handler not check for a selection, and need to check here for no selection and
	// provide a one-pile one at the active location
	if (pApp->m_selectionLine == -1 && pApp->m_selection.IsEmpty())
	{
		// there is no selection defined, so set up the active pile's source text as
		// the current selection (but no need to set m_bSelected to TRUE in the CCell
		// because this programmatically defined selection will never become visible
		pApp->m_selectionLine = 0;
		wxASSERT(pApp->m_pActivePile != NULL);
		CCell* pActiveCell = pApp->m_pActivePile->GetCell(0);
		pApp->m_pAnchor = pActiveCell;
		pApp->m_selection.Append(pActiveCell);
	}

	CPile* pPile; // to be used as a scratch variable
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	CCell* pCell = pos->GetData();
	pos = pos->GetNext();
	pPile = pCell->GetPile();
	pStartingPile = pPile; // need this for later when we look up the strip which
						   // first pile is in prior to calling RecalcLayout()
	// store start location for the user's selection
	pRec->nStartingSequNum = pStartingPile->GetSrcPhrase()->m_nSequNumber;

	// get the pointer to the CSourcePhrase at the start of the user's selection
	pSrcPhrase = pStartingPile->GetSrcPhrase();
	pRec->nStartingTextType = pSrcPhrase->m_curTextType; // so we can set it on
											// any extra inserted sourcephrases
	pos = pApp->m_selection.GetLast();
	pCell = pos->GetData();
	pPile = pCell->GetPile(); // pile at end of unextended selection
	pEndingPile = pPile;
	pEndingSrcPhrase = pEndingPile->GetSrcPhrase();
	wxASSERT(pEndingSrcPhrase != NULL);
	pRec->nEndingSequNum = pEndingSrcPhrase->m_nSequNumber;
	pRec->nEndingTextType = pEndingSrcPhrase->m_curTextType;
    // (if the selection is extended at either or both ends because of a retranslation
    // being present and is not co-terminous with both ends of the selection, then the
    // values of the sequence number and TextType stored in pRec will be changed as a
    // result of code which follows below)

	gbVerticalEditInProgress = TRUE; // as soon as we change the EditRecord, we set
				// this boolean - even though the user may Cancel the edit later on
	gEntryPoint = sourceTextEntryPoint; // set the global enum variable to the
				// starting type for this vertical edit
	gEditStep = sourceTextStep; // indicate that editing of source text is the
				// current step within the vertical edit process

	int nSaveSequNum = pSrcPhrase->m_nSequNumber; // save the sequ number of the
        // start of user's selection -- though we must update this value to a smaller value
        // if automatic selection extension to earlier sequence numbers happens below (for
        // example, if user selected some source text words in the middle of a
        // retranslation)... nSaveSequNum is from the legacy code, in this refactored 2008
        // code it is retained as an alias for nStartingSequNum

    // initialize the cancel span from the user's selection span (the modifications span
    // does not need separate indices, as it is always co-extensive with the cancel span,
    // so the same indices apply to both spans)
	pRec->nCancelSpan_StartingSequNum = pRec->nStartingSequNum;
	pRec->nCancelSpan_EndingSequNum = pRec->nEndingSequNum;

    // do any required selection 'extension' (actually only possibly new sequence numbers
    // are returned), returning TRUE if there was no error, FALSE there was an error. The
    // bWasExtended BOOL parameter returns TRUE if extension and either or both ends was
    // done, FALSE if no extension was required
	// BEW 11Oct10, added internally to ExtendEditSourceTextSelection() to handle when
	// there may be, at either or both ends, a placeholder with information to be
	// transferred to a neighbour before it gets deleted (we extend the selection one more
	// in either direction if necessary)
	bool bWasExtended;
	bool bNoErrors = ExtendEditSourceTextSelection(pSrcPhrases, pRec->nStartingSequNum,
													pRec->nEndingSequNum, bWasExtended);
	if (!bNoErrors)
	{
		// something went wrong, bail out (m_pSourcePhrases list contents have not yet
		// been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level,
			// so we can do so here;
exit:		BailOutFromEditProcess(pSrcPhrases, pRec); // clears the
										// gbVerticalEditInProgress flag when done
			wxCommandEvent evt;
			pApp->GetDocument()->OnFileSave(evt);
		}
		pApp->LogUserAction(_T("Error from ExtendEditSourceTextSelection() in OnEditSourceText()"));
		return;
	}
	if (bWasExtended)
	{
        // extension to left or right or in both directions was done, so we have to reset
        // the relevant parameters above to new values (check later, I'm doing it
        // differently so we may not need all these parameters)
		pStartingPile = GetPile(pRec->nStartingSequNum); // returns NULL if it couldn't get it
		wxASSERT(pStartingPile != NULL);
		//nStartingStripIndex = pStartingPile->GetStrip()->GetStripIndex();
		pSrcPhrase = pStartingPile->GetSrcPhrase();
		pRec->nStartingTextType = pSrcPhrase->m_curTextType; // the TextType value at the
															// start of the new span
		pRec->bSpecialText = pSrcPhrase->m_bSpecialText;	// update the initial special
															// text boolean value
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // update the alias
		pEndingPile = GetPile(pRec->nEndingSequNum); // returns NULL if it couldn't get it
		wxASSERT(pEndingPile != NULL);
		pEndingSrcPhrase = pEndingPile->GetSrcPhrase();
		pRec->nEndingTextType = pEndingSrcPhrase->m_curTextType;

		// update the cancel span indices to comply with the extension just done
		pRec->nCancelSpan_StartingSequNum = pRec->nStartingSequNum;
		pRec->nCancelSpan_EndingSequNum = pRec->nEndingSequNum;
	}
	// set the EditRecord's value for the nOldSpanCount member
	pRec->nOldSpanCount = pRec->nCancelSpan_EndingSequNum -
									pRec->nCancelSpan_StartingSequNum + 1;

	// make the required deep copy and store in the CObList for this
	// in the EditRecord as the cancel span's list
	bool bAllWasOK;
	bAllWasOK = DeepCopySourcePhraseSublist(pSrcPhrases, pRec->nCancelSpan_StartingSequNum,
					pRec->nCancelSpan_EndingSequNum, &pRec->cancelSpan_SrcPhraseList);
	if (!bAllWasOK)
	{
        // something went wrong, bail out (m_pSourcePhrases list contents
        // have not yet been modified)
        if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level,
			// so we can do so here;
			pApp->LogUserAction(_T("Error from DeepCopySourcePhraseSublist() in OnEditSourceText()"));
			goto exit;
		}
	}

    // the cancelSpan_SrcPhraseList is always co-extensive with the modifications span, so
    // deep copy the one just delineated; we don't ever expect this to fail
	DeepCopySublist2Sublist(&pRec->cancelSpan_SrcPhraseList,
							&pRec->modificationsSpan_SrcPhraseList);

    // now that we have the editable span delineated, (this is the material the user will
    // see), we need to determine if there are any glosses in this span and set the
    // gEditRecord's flag accordingly; and likewise for adaptations
	bool bHasGlosses = FALSE;
	bool bHasAdaptations = FALSE;
	bAllWasOK = IsGlossInformationInThisSpan(pSrcPhrases,pRec->nStartingSequNum,
													pRec->nEndingSequNum,&bHasGlosses);
	if (!bAllWasOK)
	{
		// something went belly up, so restore original document state and
		// bail out of the process
		pApp->LogUserAction(_T("Error from IsGlossInformationInThisSpan() in OnEditSourceText()"));
		goto exit;
	}
	pRec->bEditSpanHasGlosses = bHasGlosses;
	bAllWasOK = IsAdaptationInformationInThisSpan(pSrcPhrases,pRec->nStartingSequNum,
											pRec->nEndingSequNum,&bHasAdaptations);
	if (!bAllWasOK)
	{
		// something went belly up, so restore original document state and
		// bail out of the process
		pApp->LogUserAction(_T("Error from IsAdaptationInformationInThisSpan() in OnEditSourceText()"));
		goto exit;
	}
	pRec->bEditSpanHasAdaptations = bHasAdaptations;

    // The next sections of code determine if we need to widen the cancel span, and
    // modifications span, to include free translation whole sections; and then again, do
    // the same for collected back translations. If one or neither of these information
    // types is not present, clear the relevant flag(s) in the EditRecord struct. The way
    // we do this processing is to scan the present cancel span and determine what the
    // starting and ending sequence number bounds are, eg. for free translations
    // overlapping the editable subspan, then make a temporary list of deep copies of the
    // CSourcePhrase instances in the potentially wider span, then test the bounds to see
    // if extension before or after is needed, and if so, copy the relevant CSourcePhrase
    // deep copies to the cancel span's list and the modifications span's list (as both
    // these must contain the same instances). Doing these things, the original
    // m_pSourcePhrases list contents in the document class remains unchanged in any way,
    // so that if any of these processing steps fails, the document remains valid.
	SPList* pTempList = new SPList;

    // First: do any required extra scanning to left and right if the beginning of a free
    // translation section and/or the end of a free translation section, if present, are
    // not coterminous with the start and end of the span (possibly extended earlier)
    // derived from the user's original selection, returning TRUE in the bFreeTransPresent
    // parameter if there was some free translation data defined over the span, FALSE if
    // not; and the function returns TRUE if there was no error, FALSE if there was an
    // error
	bool bFreeTransPresent;
	bAllWasOK = GetEditSourceTextFreeTranslationSpan(pSrcPhrases, pRec->nStartingSequNum,
					pRec->nEndingSequNum, pRec->nFreeTrans_StartingSequNum,
					pRec->nFreeTrans_EndingSequNum, bFreeTransPresent);
	if (!bAllWasOK)
	{
		// something went wrong, bail out (m_pSourcePhrases list contents have
		// not yet been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called
			// from a lower level, so we can do so here;
			goto exit;
		}
		else
		{
			wxExit();
		}
		pApp->LogUserAction(_T("Error from GetEditSourceTextFreeTranslationSpan() in OnEditSourceText()"));
	}
	if (bFreeTransPresent)
	{
        // extension to left or right or in both directions was done if needed, but we
        // don't show any of the extra stuff to the user; we just use the wider span to
        // ensure we remove whole free translation sections because otherwise we'd corrupt
        // the document; so all we need do is do the relevant deep copy for the wider span,
        // and set the EditRecord flag
		pRec->bEditSpanHasFreeTranslations = TRUE;
		bAllWasOK = DeepCopySourcePhraseSublist(pSrcPhrases, pRec->nFreeTrans_StartingSequNum,
												pRec->nFreeTrans_EndingSequNum, pTempList);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			if (pTempList != NULL) // whm 11Jun12 added NULL test
				delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents have not
			// yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level,
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
			pApp->LogUserAction(_T("Error from DeepCopySourcePhraseSublist() in OnEditSourceText()"));
		}

        // work out if the subspan for free translations starts earlier, or ends later,
        // than the current bounds for the cancel span; if so, work out the new bounds for
        // the cancel span's indices
		pRec->nCancelSpan_StartingSequNum = wxMin(pRec->nCancelSpan_StartingSequNum,
												pRec->nFreeTrans_StartingSequNum);
		pRec->nCancelSpan_EndingSequNum = wxMax(pRec->nCancelSpan_EndingSequNum,
												pRec->nFreeTrans_EndingSequNum);

        // Do any required extension of the "cancel span" list (extension is not assumed,
        // the function internally works out if it is needed and where, and does whatever
        // extending is required)
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList,
							&pRec->cancelSpan_SrcPhraseList,
							pRec->nStartingSequNum, pRec->nEndingSequNum);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			if (pTempList != NULL) // whm 11Jun12 added NULL test
				delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents have not
			// yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level,
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
			pApp->LogUserAction(_T("Error from CopyCSourcePhrasesToExtendSpan() in OnEditSourceText()"));
		}

        // Also do any required extension of the "modifications span" list (an alternative
        // way to do this would be to just do a deep copy of the cancel list using
        // CopyCSourcePhrasesToExtendSpan())
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList,
										&pRec->modificationsSpan_SrcPhraseList,
										pRec->nStartingSequNum, pRec->nEndingSequNum);

#ifdef _DEBUG
		SPList::Node* testpos = pRec->modificationsSpan_SrcPhraseList.GetFirst();
		//int ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			pSrcP = pSrcP; // avoid warning
			testpos = testpos->GetNext();
			//wxLogDebug(_T("pRec->modificationsSpan_SrcPhraseList item %d at %x = %s"),
			//ct++, pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
#endif
#ifdef _DEBUG
		testpos = pTempList->GetFirst();
		//ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			pSrcP = pSrcP; // avoid warning
			testpos = testpos->GetNext();
			//wxLogDebug(_T("pTempList item %d at %x = %s"),ct++,
			//pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
#endif
		if (!bAllWasOK)
		{
 			pDoc->DeleteSourcePhrases(pTempList);
			if (pTempList != NULL) // whm 11Jun12 added NULL test
				delete pTempList;
 			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents
            // have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level,
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
			pApp->LogUserAction(_T("Error from CopyCSourcePhrasesToExtendSpan() in OnEditSourceText()"));
		}

#ifdef _DEBUG
		testpos = pRec->modificationsSpan_SrcPhraseList.GetFirst();
		//ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			pSrcP = pSrcP; // avoid warning
			testpos = testpos->GetNext();
			//wxLogDebug(_T(
			//"After DeleteSourcePhrases pRec->modificationsSpan_SrcPhraseList item %d at %x = %s"),
			//ct++,pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
#endif
	} // end block for test (bFreeTransPresent == TRUE)
	else
	{
        // clear the flag, and don't do a deep copy as we've no free translations
        // to remove later on; & set the stored sequence number values back to -1
        // since this span is undefined
		pRec->bEditSpanHasFreeTranslations = FALSE;
		pRec->nFreeTrans_StartingSequNum = -1;
		pRec->nFreeTrans_EndingSequNum = -1;
	}

    // do a third subspan, if it exists, for the collected back translations; the start of
    // such a span (if it exists) will usually be somewhere preceding the
    // pRec->nStartingSequNum value, and may even be preceding the
    // pRec->nFreeTrans_StartingSequNum value (if free translations are defined on this
    // editing context); but we don't require that the end of any back translation
    // collection span(s) be made to coincide with the end of the free translations span
    // nor with the end of the editable span - though typically if will end somewhere
    // shortly after the pRec->nEndingSequNum value.
	bool bBackTransPresent;
	bool bCollectedFromTargetText = TRUE; // initialize to default value

	bAllWasOK = GetEditSourceTextBackTranslationSpan(pSrcPhrases, pRec->nStartingSequNum,
			pRec->nEndingSequNum, pRec->nFreeTrans_StartingSequNum,
			pRec->nFreeTrans_EndingSequNum, pRec->nBackTrans_StartingSequNum,
			pRec->nBackTrans_EndingSequNum, bBackTransPresent, bCollectedFromTargetText);
	if (!bAllWasOK)
	{
		// clear out the contents of the temporary list & delete the list itself
		pDoc->DeleteSourcePhrases(pTempList);
		if (pTempList != NULL) // whm 11Jun12 added NULL test
			delete pTempList;
		pTempList = NULL;
		// something went wrong, bail out (m_pSourcePhrases list contents have not yet
		// been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level,
			// so we can do so here;
			goto exit;
		}
		else
			wxExit();
		pApp->LogUserAction(_T("Error from GetEditSourceTextBackTranslationSpan() in OnEditSourceText()"));
	}
	pRec->bCollectedFromTargetText = bCollectedFromTargetText; // store the returned
            // value for later use in the backTranslationsStep (if there is no
            // collected back translation defined on the editable span, a default value
            // of TRUE is nevertheless stored in gEditRecord, but would not later be
            // used)
	if (bBackTransPresent)
	{
        // set the EditRecord's flag, and get the deep copy done of all the CSourcePhrases
        // in the back translation span (the back translations in this span will be later
        // removed so the user won't have to bother dealing with them while editing the
        // source text; they are abandoned rather than stored, because they can be
        // recollected later easily once this span is delineated
		pRec->bEditSpanHasBackTranslations = TRUE;
		bAllWasOK = DeepCopySourcePhraseSublist(pSrcPhrases,
								pRec->nBackTrans_StartingSequNum,
								pRec->nBackTrans_EndingSequNum, pTempList);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			if (pTempList != NULL) // whm 11Jun12 added NULL test
				delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list
			// contents have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called
				// from a lower level, so we can do so here;
				goto exit;
			}
			else
				wxExit();
			pApp->LogUserAction(_T("Error from DeepCopySourcePhraseSublist() in OnEditSourceText()"));
		}

        // work out if the subspan for back translations starts earlier, or ends later,
        // than the current bounds for the cancel span; if so, work out the new bounds
        // for the cancel span's indices
		pRec->nCancelSpan_StartingSequNum = wxMin(pRec->nCancelSpan_StartingSequNum,
												pRec->nBackTrans_StartingSequNum);
		pRec->nCancelSpan_EndingSequNum = wxMax(pRec->nCancelSpan_EndingSequNum,
												pRec->nBackTrans_EndingSequNum);

        // Do any required extension of the "cancel span" list; take care, only the
        // instances prior to the minimum index for the start of the editable span and the
        // free translation span (if the latter exists) need be inserted, and only the
        // instances after than the maximim index for the end of the editable span and the
        // free translation span (if the latter exists) need to be appended
		int nEarliestAlreadyPresent = pRec->nStartingSequNum;
		int nLatestAlreadyPresent = pRec->nEndingSequNum;
		if (pRec->bEditSpanHasFreeTranslations)
		{
			nEarliestAlreadyPresent =
				wxMin(pRec->nStartingSequNum,pRec->nFreeTrans_StartingSequNum);
			nLatestAlreadyPresent =
				wxMax(pRec->nEndingSequNum,pRec->nFreeTrans_EndingSequNum);
		}
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList,
						&pRec->cancelSpan_SrcPhraseList, nEarliestAlreadyPresent,
						nLatestAlreadyPresent);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			if (pTempList != NULL) // whm 11Jun12 added NULL test
				delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents have not
			// yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level,
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
			pApp->LogUserAction(_T("Error from CopyCSourcePhrasesToExtendSpan() in OnEditSourceText()"));
		}

        // Do any required extension of the "modifications span" list; take care, only the
        // instances prior to the minimum index for the start of the editable span and the
        // free translation span (if the latter exists) need be inserted, and only the
        // instances after than the maximum index for the end of the editable span and the
        // free translation span (if the latter exists) need to be appended
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList,
						&pRec->modificationsSpan_SrcPhraseList, nEarliestAlreadyPresent,
						nLatestAlreadyPresent);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			if (pTempList != NULL) // whm 11Jun12 added NULL test
				delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents have not
			// yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level,
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
			pApp->LogUserAction(_T("Error from CopyCSourcePhrasesToExtendSpan() in OnEditSourceText()"));
		}
	} // end of block for test (bBackTransPresent == TRUE)
	else
	{
        // no back translations were defined on this editable span, so do no deep copy and
        // make sure the edit record has the appropriate values (redundant, but helps
        // understanding if we do it)
		pRec->bEditSpanHasBackTranslations = FALSE;
		pRec->nBackTrans_StartingSequNum = -1;
		pRec->nBackTrans_EndingSequNum = -1;
	}
	/*
	// check we got correct spans
	TRACE2("\n Editable   Span = %d , %d\n",pRec->nStartingSequNum,pRec->nEndingSequNum);
	TRACE2(" Free Trans Span = %d , %d\n",pRec->nFreeTrans_StartingSequNum,
														pRec->nFreeTrans_EndingSequNum);
	TRACE2(" Back Trans Span = %d , %d\n",pRec->nBackTrans_StartingSequNum,
														pRec->nBackTrans_EndingSequNum);
	TRACE2(" Cancel Span = %d , %d\n",pRec->nCancelSpan_StartingSequNum,
														pRec->nCancelSpan_EndingSequNum);
	int ii = 1; // a do-nothing statement for a break point for the TRACE macros
	*/
	// clear out the contents of the temporary list & delete the list itself
	pDoc->DeleteSourcePhrases(pTempList);
	if (pTempList != NULL) // whm 11Jun12 added NULL test
		delete pTempList;
	pTempList = NULL;

    // Up to now, the CAdapt_ItDoc class's m_pSourcePhrases list which defines the document
    // contents has not been altered in any way. We are now about to do modifications of
    // the information in the CSourcePhrase instances in the (deep copied) modifications
    // list, the modifications being to remove potentially large slabs of information which
    // the user would find distracting to see while trying to edit the source text - such
    // info is notes, collected back translations, free translations; also since the source
    // will change, old adaptations and glosses (we'll preserve copies of these for access
    // in the combobox later, but not remove them from the editable span because the
    // editable span will be abandoned and replaced by newly parsed material, so there is
    // no point in removing anything from what is going to be thrown away anyway). The
    // removed information types are preserved in lists which are made accessible in a
    // combobox at each stage of the overall process - except that back translations are
    // unilaterally abandoned, and notes are automatically restored (albeit, probably at
    // different locations, depending on how the user edits the source text). In keeping
    // with out design being not to alter any of the original document until after the user
    // commits to his changes in the dialog by hitting the OK key, the modifications will
    // be done on the deep copies in the modifications list; the cancel list will remain
    // untouched, as it must persist through the total vertical edit process in case the
    // use elects to Cancel out of the whole edit process, in which case the cancel list is
    // needed in order to help restore the original document state.
    //
    // The next major function call will scan across the modification list's CSourcePhrase
    // instances, (smartly, using knowledge stored in gEditRecord) the required information
    // removals and sequestering in lists within gEditRecord.
    // When it completes, various CSourcePhrase instances will be simplified in some of their
    // members(we don't bother to unmerger any mergers, as there is no need to do
    // so), and then afterwards we accumulate the source text string from the simplified
    // instances in order to show it to the user for editing.

    // To keep removals done left to right in the order top to bottom in lists, we must add
    // the removed information types to temporary lists, using AddTail(), and then insert
    // the sublists at the head of the final storage lists. The strings saved are copies,
    // so later deletion of the old CSourcePhrase edited instances will leave the string
    // copies in the wxArrayString instances intact.
	wxArrayString* pAdaptList = new wxArrayString; // MFC uses CStringList
	wxArrayString* pGlossList = new wxArrayString;
	wxArrayString* pFTList = new wxArrayString;
	wxArrayString* pNoteList = new wxArrayString;

    // Do the scan for removing and sequestering removed information; the CSourcePhrase
    // instances scanned are those in the modifications list - these are deep copies of
    // those on the document, and so we still will not have changed any of the document
    // as yet, only fiddled with copies so far
	bool bAllsWell = ScanSpanDoingRemovals(&pRec->modificationsSpan_SrcPhraseList, pRec,
											pAdaptList, pGlossList, pFTList, pNoteList);
	if (!bAllsWell)
	{
        // something fouled up, the bailout function has not already been called from a
        // lower level, so we can do so here; but first remove the temp string lists and
        // their data, to avoid memory leaks
bailout:	pAdaptList->Clear();
		pGlossList->Clear();
		pFTList->Clear();
		pNoteList->Clear();
		if (pAdaptList != NULL) // whm 11Jun12 added NULL test
			delete pAdaptList;
		if (pGlossList != NULL) // whm 11Jun12 added NULL test
			delete pGlossList;
		if (pFTList != NULL) // whm 11Jun12 added NULL test
			delete pFTList;
		if (pNoteList != NULL) // whm 11Jun12 added NULL test
			delete pNoteList;
		pApp->LogUserAction(_T("Error from ScanSpanDoingRemovals() in OnEditSourceText()"));
		goto exit;
	}

    // Get the insertions done for the removed information, putting the information into
    // gEditRecord, and then deleting the temporary CStringList instances (but leave their
    // contents unremoved because the gEditRecord will manage those strings instead)
	bool bResult = TRUE;
	wxString errStr;
	if (pAdaptList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pAdaptList, adaptationsList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T(
"InsertSublistAtHeadOfList() for adaptations sublist, failed. Unknown list requested. ");
			errStr += _T(
			"Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
			pApp->LogUserAction(errStr);
			goto bailout;
		}
	}
	if (pGlossList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pGlossList, glossesList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T(
"InsertSublistAtHeadOfList() for glosses sublist, failed. Unknown list requested. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
			pApp->LogUserAction(errStr);
			goto bailout;
		}
	}
	if (pFTList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pFTList, freeTranslationsList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T(
"InsertSublistAtHeadOfList() for free translations sublist, failed. Unknown list requested. ");
			errStr += _T(
			"Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
			pApp->LogUserAction(errStr);
			goto bailout;
		}
	}
	if (pNoteList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pNoteList, notesList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T(
"InsertSublistAtHeadOfList() for notes sublist, failed. Unknown list requested. ");
			errStr += _T(
			"Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
			pApp->LogUserAction(errStr);
			goto bailout;
		}
	}

	// don't leak memory, delete the local lists now their contents have been inserted at
	// the top of the respective persistent lists
	if (pNoteList != NULL) // whm 11Jun12 added NULL test
		delete pNoteList;
	if (pFTList != NULL) // whm 11Jun12 added NULL test
		delete pFTList;
	if (pGlossList != NULL) // whm 11Jun12 added NULL test
		delete pGlossList;
	if (pAdaptList != NULL) // whm 11Jun12 added NULL test
		delete pAdaptList;

    // We are now ready to accumulate the editable text from the editable span. The
    // accumulation, however, is not done from the unmodified CSourcePhrase instances in
    // the m_pSourcePhrases list in the document, but from the modified deep copies in the
	// modifications list. At this point, free translations, notes, collected back
	// translations are removed, but potentially other filtered info still resides in the
	// m_filteredInfo member - this information will be shown explicitly to the user, if
	// it is "there", (but with filter markers removed by the
	// RemoveFilterWrappersButLeaveContent() call further below, so we have to clear the
	// m_filteredInfo member while in ScanSpanDoingSourceTextReconstruction() in order to
	// avoid ending up, after the source text edit, with two copies of such information
	// stored in the m_filteredInfo member.
	bAllsWell = ScanSpanDoingSourceTextReconstruction(&pRec->modificationsSpan_SrcPhraseList,
					pRec, pRec->nStartingSequNum, pRec->nEndingSequNum, strSource);
	if (!bAllsWell)
	{
        // there was an error (could not obtain a valid pos value within the function, an
        // error message has already been shown, so try safely preserve the document and
        // then abort)
		pApp->LogUserAction(_T("Error from ScanSpanDoingSourceTextReconstruction() in OnEditSourceText()"));
		goto bailout;
	}

    // There could be other filtered information in the reconstructed source text, which is
    // not a note, free translation or back translation, and it does not get removed. It
    // will therefore have \~FILTER and \~FILTER* marker and endmarker pairs wrapping each
    // such filtered marker and its content, eg. cross reference material. We must now
    // remove these filter wrapping markers because the parse of the edited source text
    // will refilter such material, and if we don't remove the \~FILTER and \~FILTER*
    // pairs, we'd end up with extra ones wrapping the ones already present. The global C
    // strings filterMkr and filterMkrEnd store these markers. Search for them and the
    // following space for each, and remove them.
	RemoveFilterWrappersButLeaveContent(strSource);

    // BEW changed 7May08: update to keep the KB properly updated, provided the active
    // location is not in the selection, but if it is, then we don't update because the
    // active location's source word may no longer exist after the user finishes editing
    // the source. The box, and m_targetPhrase, will be reconstituted later appropriately,
    // depending on what the user does in the edit -- if there was some text remaining
    // after his edit, the box will be placed at the CSourcePhrase instance which stores
    // the edited source's first word.
	int nOldSaveActiveSequNum = pRec->nSaveActiveSequNum;
	bool bActiveLocationWithinEditableSpan =
		(nOldSaveActiveSequNum >= pRec->nStartingSequNum) &&
		(nOldSaveActiveSequNum <= pRec->nEndingSequNum) ? TRUE :  FALSE;
	if (!bActiveLocationWithinEditableSpan  && pApp->m_pActivePile != NULL)
	{
        // the active location is not within the retranslation section, and the layout is
        // still valid, so update KB for this location's phrase box contents (if the user
        // has not finished making it a valid string when he invoked the source text edit,
        // then too bad - it will go 'as is' into the KB, unless internal tests require the
        // store be skipped)
		DoConditionalStore(FALSE); // FALSE is bOnlyWithinSpan, it forces unilateral
								   // store if other conditions are met
	}
	pApp->m_targetPhrase.Empty();	// empty m_targetPhrase; because the box may be built
									// elsewhere after editing
	if (pApp->m_pTargetBox != NULL)
	{
		pApp->m_pTargetBox->ChangeValue(pApp->m_targetPhrase);
	}

    // need to clobber the selection now, so the selection globals will be set to -1, etc,
    // otherwise RecalcLayout will fail at its RestoreSelection() call
	RemoveSelection();

	// The document's native structures are as yet still unchanged.

    // create the edit source text dialog; then prepare the preceding and following context
    // strings (we decline to display the SFM markup in the context strings, because we
    // want to make it easy for the user to just follow what the source text meaning
    // actually is
	CEditSourceTextDlg dlg(pApp->GetMainFrame());

	// initialize the edit boxes
	dlg.m_strOldSourceText = strSource;
	dlg.m_strNewSourceText = strSource;
	wxString precedingSrc;
	precedingSrc.Empty();
	wxString followingSrc;
	followingSrc.Empty();
	wxString precedingTgt;
	precedingTgt.Empty();
	wxString followingTgt;
	followingTgt.Empty();
    // the following call needs the target text's CString variables passed in, but the Edit
    // Source Text functionality does not use the values returned in them; these context
    // strings are built up from the meanings in the document's m_pSourcePhrases list,
    // because getting sufficient context may require looking at CSourcePhrase instances
    // preceding and/or following those in any of the sublists thus far populated
	GetContext(pRec->nStartingSequNum,pRec->nEndingSequNum, precedingSrc, followingSrc,
				precedingTgt, followingTgt);
	dlg.m_preContext = precedingSrc;
	dlg.m_follContext = followingSrc;

	// put up the Edit Source Text dialog's window
	bool bMarkerSetsAreDifferent = FALSE;
	if (dlg.ShowModal() == wxID_OK)
	{
		// the user has committed to the edit changes he has made, so from here on we
		// can now actually modify the document's contents
		wxString strNewSrcText = dlg.m_strNewSourceText;
		int nNewCount = 0; // number of CSourcePhrase instances to be returned from the
						   // tokenization operation
		bool bFirstIsFirstOfType = FALSE; // BEW added 6Aug08 to help control text type
						// and colour if the user deletes the whole of the editable span
		CPile* pFirst = GetPile(pRec->nStartingSequNum);
		bFirstIsFirstOfType = pFirst->GetSrcPhrase()->m_bFirstOfType; // use this below

		// treat the doc as dirty, regardeless of the outcome
		pDoc->Modify(TRUE);

        // Before we do anything to the CSourcePhrase instances, we have to set up a
        // correct value for the chapter number used in the Document's member m_curChapter,
        // which is to have a value of the form "n:" where n is the chapter number. We have
        // a legacy function for detecting what chapter we are in given a passed in pointer
        // to a CSourcePhrase, so we use that, passing in the instance which is at the
        // start of the editable span. We need to do this here before TokenizeTextString()
        // is called, because the latter calls TokenizeText(), which in turn uses
        // m_curChapter. Remember, we can't assume there will have been a \c marker within
        // the user's selection, but there may well be a \v, and on that CSourcePhrase
        // instance we need to set a valid m_chapterVerse, of the form "n:m", and
        // TokenizeText() uses the m_curChapter value to set the "n:" part, so now we must
        // make sure the value it is going to use is correct now get the preceding
        // CSourcePhrase's pointer (ie. preceding the editable span), it could be NULL
		CSourcePhrase* pInitialSrcPhrase = NULL;
		int aSequNum = pRec->nStartingSequNum; // location of start of edit span (possibly
											   // extended)
		SPList::Node* aPos = pSrcPhrases->Item(aSequNum); // returns NULL if out of bounds
		if (aPos != NULL)
		{
			// we are not at the start of the document, so there is preceding context
			pInitialSrcPhrase = aPos->GetData();

            // set the doc's m_curChapter string, because it could have any arbitrary value
            // left in it from some earlier parse (with colon following it), and since our
            // editable span might have a verse number before the chapter number, or no
            // chapter number at all, in either of those cases we would have a wrong n:m
            // value being set
			pApp->m_curChapter = _T("0:"); // default if there are no chapter markers
			if (pInitialSrcPhrase != 0)
			{
				// get chapter and verse (internally it scans backwards till it finds the
				// information needed, or comes to doc start)
				wxString cv = GetChapterAndVerse(pInitialSrcPhrase);
				// whm 11Jun12 added test for !cv.IsEmpty() && since GetChar(0) should never
				// be called on an empty string
				if (!cv.IsEmpty() && cv.GetChar(0) == _T('0'))
				{
					// there are no chapter numbers, so leave the default zero at the
					// start to flag this fact
					;
				}
				else
				{
					// remove verse numbers from n:m until only n: remains
					int offset = cv.Find(_T(':'));
					if (offset != -1)
					{
						// found it
						wxString left = cv.Left(offset + 1);
						pApp->m_curChapter = left;
					}
				}
			}
		}

        // Detect whether or not the user has edited the SF markers - specifically, if
        // there is at least one SF marker in the edited text which is not in the original
        // text, or vise versa. If either is the case, we later want to call
        // DoMarkerHousekeeping() over the whole document to ensure that any typo markers
        // get appropriately handled as far as nav text, text colour and TextType are
        // concerned. The TokenizeTextString() call will do any needed unfiltering or
        // filtering. The AreMarkerSetsDifferent() function below (see Helpers.cpp) also
        // does tests, if the return value is TRUE, to determine if unfiltering, and/or
        // filtering will get done. We need to know about any filtering due to a respelled
        // marker in order to make sure all the filterable content is included in the
        // editable span - so if the user has not done that, we'll do it further below
        // programmatically. The algorithm checking marker status is not foolproof, but it
        // should take care of all or most situations that are reasonably expected to be
        // handleable. We really only need it to handle a filtered marker which the user
        // edits so as to be a marker which should be unfiltered (that original marker may
        // or may not be an unknown one, it doesn't matter either way, and the destination
        // marker can likewise be, or not be, an unknown one); or, an unfiltered marker
        // which the user edits to be a marker which should be filtered (and similarly,
        // either being known or unknown doesn't matter). Marker edits which require no
        // filtering change, whether unfiltered and remain so, or filtered and remain so,
        // don't need any attention here. The application class's global string
        // gCurrentFilterMarkers is used internally to determine filterable status
		bool bFilteringRequired = FALSE;	// these two are set or cleared by the
											// following call, but it is the first with
		bool bUnfilteringRequired = FALSE;  // a TRUE value that we are interested in
		bMarkerSetsAreDifferent = AreMarkerSetsDifferent(strSource, strNewSrcText,
										bUnfilteringRequired, bFilteringRequired);

        // Any unfiltering & filtering will be handled by the TokenizeTextString(), but it
        // doesn't necessarily handle required filtering completely because only the user's
        // selected words will get into the filtered content of a now-to-be-filtered marker
        // which has had its spelling changed in the edit source text dialog, and the user
        // may have intended to only edit the marker and so may have just selected the
        // first word (which carries the marker) rather than it and all subsequent words
        // which are to be filtered - in which case unless we do an edit span expansion
        // here, only the single selected word would be filtered and the rest of the
        // filterable content will stay unfiltered in the document. So, we check that
        // filtering of an edited marker has been called for, and if so, we check that the
        // whole of the marker's content (as far as preceding, but not including the first
        // CSourcePhrase instance which stores a marker for which the associated TextType
        // is not 'none' - the latter are things like keyword markup, italic markup, bold
        // markup, etc, and we just want Adapt It to completely ignore SFMs associated with
        // such things) is included in the editable span, and if not, we now extend the
        // editable span rightwards, altering the ending sequence numbers etc, and adding
        // copies of the CSourcePhrase instances thereby added at the end to the spans in
        // the EditRecord, etc, and adding the m_srcPhrase words, space delimited, to the
        // end of the strNewSrcText string, so that these extra words will be included in
        // the TokenizeTextString() call below. Doing these modifications right now gets
        // them done before the editableSpan_NewSrcPhrase List and
        // propagationSpan_SrcPhraseList are populated, and their spans' starting and
        // ending indices evaluated, and similarly for other EditRecord members having to
        // do with the location and properties of the "following context". We are doing
        // here what we'd prefer to have done before the dialog was opened but couldn't,
        // because we had to wait for the user to actually effect the respelling of a
        // marker.
		bool bWasExtended = FALSE;
		if (bFilteringRequired)
		{
			bool bIsOK;
			bIsOK = ExtendEditableSpanForFiltering(pRec, pSrcPhrases, strNewSrcText,
								&pApp->m_FilterStatusMap, bWasExtended);
			if (!bIsOK)
			{
                // something went wrong and so we have to bail out; the document's
                // m_pSourcePhrases list's contents has not been altered by what happens
                // within ExtendEditableSpanForFiltering(), and so bailout is simple
				errStr = _T(
				"Failure when extending the editable span to handle filterable content. ");
				errStr += _T("Vertical edit process abandoned. ");
				errStr += _T("Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				pApp->LogUserAction(errStr);
				goto exit;
			}
			if (bWasExtended)
				pRec->bExtendedForFiltering = TRUE; // record the fact
		}

        // Tokenize the edited source text into a list of new CSourcePhrase instances on
        // the heap, pRec->nStartingSequNum is the absolute sequence number for first
        // source phrase in the sublist - it is used to define the starting sequence number
        // to be stored on the first element of the sublist, and higher numbers on
        // succeeding ones. Note: if marker status was changed in the edit, then any
        // filtering or unfiltering will be done here and all we need later do is call
        // DoMarkerHousekeeping() over the whole document to clean up the navigation text,
        // text types, colours, etc
		// For doc version 5, the internal call to TokenizeText() will store filtered
		// material in the new members m_freeTrans, m_note, m_collectedBackTrans, and
		// m_filteredInfo, and any endmarkers will not be in the following CSourcePhrase's
		// m_markers member's start, but in their own new member, m_endMarkers in the
		// CSourcePhrase for the word following which they occur (as in the source text file)
		wxString chvStr = pApp->m_curChapter;

		nNewCount = TokenizeTextString(&pRec->editableSpan_NewSrcPhraseList, strNewSrcText,
										pRec->nStartingSequNum);
		pRec->nNewSpanCount = nNewCount; // this value may decrease by one if a
                                // CSourcePhrase carrier of final endmarkers, but with no
                                // source text, is found to be present and therefore gets
                                // removed in the code below
        // *** from this point on, *** the document itself will be changed, so we indicate
        //     this is the case by setting the following global boolean to FALSE; the
        //     BailOut() function uses this value to work out what needs to be done if
        //     there was a cancel, or a failure after the document has been modified
		gbEditingSourceAndDocNotYetChanged = FALSE;

        // Before going further, we must replace the CSourcePhrase instances in the cancel
        // span with the modified ones in the modifications list. This is to ensure that
        // the changed CSourcePhrase instances resulting from the removed information which
        // was removed prior to displaying the dialog, actually find their way into the
        // document -- the instances we are particularly concerned with are those (if any)
        // preceding the start of the editable span, and those (if any) which follow the
        // end of the editable span, because those are not changed when the editable span's
        // content is replaced by the CSourcePhrase instances resulting from the parse of
        // the user's edited source text; so if we didn't do this substitution now, we'd
        // run the risk of the old free translations, & collected back translations,
        // remaining present (filtered) in those preceding and following contexts, when in
        // actual fact we want them removed so that the vertical edit process can help the
        // user to reconstitute them with appropriate changes.

		// do a while loop for looking at the pSrcPhrase instances of the modifications
		// span in debug mode
		/*
		SPList::Node* posTemp = pRec->modificationsSpan_SrcPhraseList.GetFirst();
		int modsCountFromCancelSpanBounds =
			pRec->nCancelSpan_EndingSequNum - pRec->nCancelSpan_StartingSequNum + 1;
		int modsCountFromSublist =
			(int)pRec->modificationsSpan_SrcPhraseList.GetCount();
		while (posTemp != NULL) {
			CSourcePhrase* pSP = posTemp->GetData();
			posTemp = posTemp->GetNext();
			int itsSequNum = pSP->m_nSequNumber;
			wxString itsSrcPhrase = pSP->m_srcPhrase;
			wxString itsMarkers = pSP->m_markers;
            // if this code block is used for doc version 5, additional lines need to be
            // added so as to look at m_freeTrans, m_note, m_collectedBackTrans,
            // m_filteredInfo and m_endMarkers
			bool bItsFreeTransFlag = pSP->m_bHasFreeTrans;
			bool bItsStartFTflag = pSP->m_bStartFreeTrans;
			bool bItsEndFTflag = pSP->m_bEndFreeTrans;
		}
		*/
		int nHowMany = pRec->nCancelSpan_EndingSequNum - pRec->nCancelSpan_StartingSequNum + 1;
		int nReplacementCount = nHowMany;

        // As explained above, replace, in m_pSourcePhrases list, all of the instances in
        // the cancel span, with the parallel list of instances in the modification span --
        // the latter are identical copies to those in the former, except that any notes,
        // free translations, filtered info (ie. m_filteredInfo contents) and/or collected
        // back translations have been removed (and because this modifies the doc, partner
        // piles are created too) note: doing this is just to PREPARE the edit span's
        // CONTEXT in document for the results of the user's source text editing, the
        // deletions and replacements for the actual edit span itself are done about 500
        // lines below at the TransferCompletedSrcPhrases() call
		bool bReplacedOK;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases,
							pRec->nCancelSpan_StartingSequNum, nHowMany,
							&pRec->modificationsSpan_SrcPhraseList, 0, nReplacementCount);
		if (!bReplacedOK)
		{
            // if we had an error while replacing the modifications, we have to bail out
            // of the whole edit process, so try to save the document too
			errStr = _T(
			"Replacing with modified CSourcePhrases after dialog dismissal failed. ");
			errStr += _T("Vertical edit process abandoned. ");
			errStr += _T("Will try now to restore the document to its pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
			BailOutFromEditProcess(pSrcPhrases,pRec);
			pApp->LogUserAction(errStr);
			goto exit;
		}

		// do a while loop for looking at the pSrcPhrase instances after the
		// replacements, in debug mode

        // Because the user can edit the markup as readily as the source text, we cannot
        // assume that the old source text without any final endmarkers will remain that
        // way, nor the old source text with final endmarkers will remain that way, or even
        // that markers (and therefore TextType) won't change from what was in effect
        // before. The user may also have respelled a mispelled marker, resulting in
        // content being filtered. So we must assume nothing and check to see what is
        // there, and do processing appropriate for what we find.

        // The first task is to check the list of new CSourcePhrase instances to see if the
        // end one is an insertion just to carry widowed filtered info (other than free
        // trans, note or collected back trans) that was at the end of the edited source
        // text string. If that is the case, we need to move that now-filtered information
        // (it's stored in the m_filteredInfo member) to the start of the m_filteredInfo
        // member of the following CSourcePhrase - but only provided the latter exists, and
        // if it doesn't exist, the carrier stays; but if it does exist, we can remove the
        // carrier -- however, not if m_precPunct is non-empty and m_key is empty (that's
        // when punctuation follows an endmarker - we can't do anything about that and for
        // that scenario the carrier must remain). In either case we can't remove the
        // carrier if there is no following context (ie. the user's edit was done at the
        // very end of the document). We set up members of the EditRecord to store the
        // pre-edit information (in case the user Cancels, or an exception forces bail out
        // back to the pre-edit document state).

        // BEW additions 24Jan09: we must also handle (1) user's edit leaves just SF
        // markers in the edit box; (2) user's edit leaves SF markers other than endmarkers
        // at the end of the edited string. Situation (1) generates an empty single
        // CSourcePhrase storing the markers in m_markers, so we need to move those
        // contents to the following context's first CSourcePhrase and remove the empty
        // CSourcePhrase if was on. Situation (2) - we just need to ensure that the
        // existing code moves any initial markers to the first CSourcePhrase in the
        // following context(no check is done on the markers if more than one, we just
        // assume the user got them right - he can edit again if he didn't).

		gpFollSrcPhrase = NULL; // a global CSourcePhrase*
		int nFollowingSequNum = pRec->nEndingSequNum + 1; // could be beyond end of doc!
		SPList::Node* posFoll = NULL; // use this value if beyond end of doc
		int maxIndex = pSrcPhrases->GetCount() - 1;
		if (nFollowingSequNum <= maxIndex)
		{
			// we are in range, so a following CSourcePhrase instance exists, else use NULL
			posFoll = pSrcPhrases->Item(nFollowingSequNum);
		}
		if (posFoll != NULL)
		{
			// we are not at the end of the document, so there is following context
			gpFollSrcPhrase = posFoll->GetData();

            // there may be propagation, and we must make a deep copy of the
            // gpFollSrcPhrase as the first in the following context, storing it in pRec's
            // propagationSpan_SrcPhraseList member as the first of any propagation
			// modifications (in case it is modified by having filtered info -- from
			// m_filteredInf -- transferred there, and in case propagation of
            // parameters to suceeding instances happens in code further below).
			CSourcePhrase* pOldFollSrcPhrase = new CSourcePhrase(*gpFollSrcPhrase);
			pOldFollSrcPhrase->DeepCopy(); // fills out any in it's m_pSavedWords member
										   // with copies
			// (wx Note: wxList::Insert() Inserts object at front of list)
			// save the deep copy
			pRec->propagationSpan_SrcPhraseList.Insert(pOldFollSrcPhrase);
			 // initialize values
			pRec->nPropagationSpan_StartingSequNum = pOldFollSrcPhrase->m_nSequNumber;
			pRec->nPropagationSpan_EndingSequNum = pOldFollSrcPhrase->m_nSequNumber;
            // NOTE: additional deep copies may be added below to this list, and the
            // pRec->nPropagationSpan_EndingSequNum value incremented, if propagation
            // across some of the following context takes place after the
            // DoMarkerHousekeeping() call below.

			// record the fact that any now-filtered information is transferrable to the
			// following context
			pRec->bDocEndPreventedTransfer = FALSE;
		}
		else
		{
            // record the fact that there is no following context available for any
            // transfer of information to a following CSourcePhrase instance
			pRec->bDocEndPreventedTransfer = TRUE;
		}
		// note, we must set gpFollSrcPhrase because our later DoMarkerHousekeeping() call
		// uses it internally

		// now get the preceding CSourcePhrase's pointer (ie. preceding the editable span),
		// it could be NULL if we edited right at the start of the doc
		gpPrecSrcPhrase = NULL; // a global CSourcePhrase*
		int nPrecedingSequNum = pRec->nStartingSequNum - 1; // could be -ve!
		SPList::Node* posPrec = NULL; // the value if there is no preceding context
		if (nPrecedingSequNum >= 0)
		{
			// there is preceding context, so set the iterator
			posPrec = pSrcPhrases->Item(nPrecedingSequNum);
		}
		if (posPrec != NULL)
		{
			// we are not at the start of the document, and there is preceding context
			gpPrecSrcPhrase = posPrec->GetData();
		}
		// note, we must set gpPrecSrcPhrase because our later DoMarkerHousekeeping() call
		// uses it internally; but it is left NULL if there is no preceding context

		// next bit not needed anymore for doc version 5 (correct endmarker behaviour is
		// guaranteed by the TokenizeTextString() call above)

        // In the following call, gpFollSrcPhrase will be NULL if there is no following
        // context; a return value of TRUE means there was either m_filteredInfo content
        // transferred from the new list, or nonEndmarkers transferred, or both AND
        // deletion of the last CSourcePhrase instance, to a following instance - the first
        // of the following context. In the special case where filtered info is
        // transferred, it's most likely to be because the user edited a misspelled marker
        // near the end of the edit span. The former misspelled marker will have caused the
        // first CSourcePhrase of the following context to have its m_bFirstOfType flag set
        // TRUE, and the m_inform member will have something like "?\mkr?" where mkr is
        // whatever was the bare (misspelled) marker. The m_bFirstOfType value being TRUE
        // halts propagation of correct parameter values in the block further down, if we
        // left it TRUE; and the fix to the marker should at the very least cause the
        // ?\mkr? navigation text to disappear - so the function will also attempt to
        // remedy those things before returning.
		bool bNonEndmarkersOrFilteredInfoTransferred = TransportWidowedFilteredInfoToFollowingContext(
							&pRec->editableSpan_NewSrcPhraseList, gpFollSrcPhrase, pRec);
		if (bNonEndmarkersOrFilteredInfoTransferred)
		{
            // the list is shorter, so adjust the local count value which we set
            // earlier (note: the list could actually have been made empty -- see below for
            // a discussion of where that matters, before the DoMarkerHousekeeping() call)
			nNewCount = pRec->nNewSpanCount;
		}

        // We now come to the point where we have to possibly propagate the new list's
        // final TextType and m_bSpecialText values forward past the end of the editable
        // span - depending on what the user has done in his editing of markers and / or
        // source text. DoMarkerHousekeeping() fixes this up, and it returns a boolean and
        // TextType value to the caller which we can use to propagate as necessary past the
        // end. There are 3 globals for preserving the values needed for such propagation;
        // we'll set them to some good guesses here, based on what is currently known;
        // DoMarkerHousekeeping() will adjust them as, needed later, or if the sublist is
        // empty, we'll set best-possible-values directly ('verse' and m_bSpecialText =
        // FALSE)and not call DoMarkerHousekeeping()
		gbPropagationNeeded = FALSE; // the most likely scenario
		gPropagationType = pRec->nStartingTextType; // the TextType at the start of the
                // editable span, (DoMarkerHousekeeping(), if called, will provide the
                // value stored in the last CSourcePhrase of the passed in new list, but
                // usually these two are the same; but if the passed in list is empty, we
                // can't use DoMarkerHousekeeping's default as it uses gpFollSrcPhrase
                // which could be quite wrong if the user is editing the source to correct
                // a misspelled marker
		gbSpecialText = pRec->bSpecialText;  // the special text boolean which may be
                // propagated, however (DoMarkerHousekeeping() , if called, will provide
                // the value stored in the last CSourcePhrase of the passed in new list,
                // but usually these two are the same; but if the passed in list is empty,
                // we can't use DoMarkerHousekeeping's default as it uses gpFollSrcPhrase
                // which could be quite wrong if the user is editing the source to correct
                // a misspelled marker

        // Get the text type, etc, correct for the list contents. Care is needed here,
        // depending on what happened within the above
        // TransportWidowedFilterredInfoToFollowingContext() call. Passing the editable
        // span's new CSourcePhrase list into DoMarkerHousekeeping will cause the latter to
        // fail and crash the app if there was only a single CSourcePhrase in the new list,
        // and it was a carrier for now-filtered information (because the user edited a SF
        // marker and the reparse then filtered out the material shown to the user in the
        // dialog); in this case, if information was tranferred to the following context,
        // the last CSourcePhrase in the new substring may have been deleted by code in
        // TransportWidowedFilteredInfoToFollowingContext(), and if that was the only
        // instance, then the sublist is empty. The potential for user's marker correction
        // resulting in all the content being filtered is very real, and if the filtered
        // info is tranferred to the first CSourcePhrase in the following context, then
        // that one will probably need to have a new TextType which must be propagated
        // forward, and other things will need fixing eg. an unknown marker will be in the
        // navigation area shown as ?mkr?, and that needs to be removed, the m_inform
        // member needs resetting, and some flags changing. DoMarkerHousekeeping() does
        // those jobs, but although we can call it on an empty list, it isn't helpful to do
        // so for the following reason:
        // It defaults to TextType of verse (that's okay) but it takes the m_bSpecialText
        // value from the value on the gpFollSrcPhrase (the first in the context following)
        // which is decidely wrong if the user has just edited a wrongly spelled marker
        // (which would have earlier given the text there a type of noType) and it's almost
        // certain that we'd not want to be propagating a noType value into the following
        // context.
        // The solution is to check pRec for the editableSpan_NewSrcPhraseList having
        // become an empty list, and if so, check that bEndmarkersOrFilteredInfoTransferred
        // flag was set TRUE (meaning, in part, that the carrier CSourcePhrase was deleted
        // from new edit span's list of CSourcePhrases, and it was the only one in that
        // list) and in that case set the propagation parameters to default values without
        // making any DoMarkerHousekeeping call, and assume propagation is needed.
        // BEW changed 6Aug08: because Roland Fumey found that if he deleted some words (but
        // the whole of his selection) within a \s section, which is special text, the
        // colouring and text type is only correct for the preceding word, and rest of the
        // \s material gets wrongly formatted as verse TextType and the specialText flag is
		// FALSE - so I have to do cleverer code in the TRUE block just below -- we bleed
		// out the verse or poetry possibilities, and if neither then assume its special text.
		if (pRec->editableSpan_NewSrcPhraseList.IsEmpty())
		{
            // probably a typo marker was edited, and it and its contents were filtered, so
            // assume the type should now revert to verse; on the other hand, we might be
            // editing within special text, etc, so care is needed
			if (bFirstIsFirstOfType)
			{
				// use the type of the last CSourcePhrase in the preceding context
				if (gpPrecSrcPhrase != NULL)
				{
					gPropagationType = gpPrecSrcPhrase->m_curTextType;
					gbSpecialText = gpPrecSrcPhrase->m_bSpecialText;
				}
				else
				{
                    // everything removed from start of document - we can assume it's not
                    // \id information, so probably just a plain text file without SF
                    // markup, so assume the type is verse
					gPropagationType = verse;
					gbSpecialText = FALSE;
				}
			}
			else
			{
				// use the type stored in pRec's nStartingTextType member
				if (pRec->nStartingTextType == verse)
				{
					gPropagationType = verse;
					gbSpecialText = FALSE;
				}
				else if(pRec->nStartingTextType == poetry)
				{
					gPropagationType = poetry;
					gbSpecialText = FALSE;
				}
				else
				{
					// defaut to special text
					gPropagationType = noType;
					gbSpecialText = TRUE;
				}
			}
			gbPropagationNeeded = TRUE;

		}
		else
		{
			// a non-empty list means the type and special text values can be
			// obtained from the list contents (this call will set or clear the global
			// gbPropagationNeeded)
			GetDocument()->DoMarkerHousekeeping(&pRec->editableSpan_NewSrcPhraseList,
								pRec->nNewSpanCount, gPropagationType,
								gbPropagationNeeded); // sets gbSpecialText internally
		}
		if (gbPropagationNeeded)
			pRec->bSpecialText = gbSpecialText; // update the EditRecord,
												// to keep everything straight

        // do any forward propagation, halting at the first CSourcePhrase in the following
        // context which has the member flag m_bFirstOfType set TRUE (Note; so far, nothing
        // has been done to the contents of the pSrcPhrases list to invalidate any pointer in
        // it, so we don't need any layout update yet)
		if (gbPropagationNeeded && gpFollSrcPhrase != NULL)
		{
			SPList::Node* pos = pSrcPhrases->Item(nFollowingSequNum); // won't fail, as we
																	 // computed this above
			CSourcePhrase* pSP = NULL;
			bool bIsFirst = TRUE;
			while (pos != NULL)
			{
				pSP = pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSP != NULL);
				if (pSP->m_bFirstOfType)
				{
					break; // propagation ends, don't change this one
				}
				else
				{
                    // the first CSourcePhrase of the following context already has a deep
                    // copy stored at the start of pRec's propagationSpan_SrcPhraseList, so
                    // we only need to store the deep copies of the additional ones (making
                    // the deep copy before it is changed), and then we can do the
                    // propagation on the one in the m_pSourcePhrases list of the document
                    // class
					if (bIsFirst)
					{
						// skip, we've got this one
						bIsFirst = FALSE;
					}
					else
					{
                        // we've not got this one in the propagation list, so do the pRec
                        // changes so as to preserve the old one's contents in case we bail
                        // out later
						CSourcePhrase* pADeepCopiedSrcPhrase = new CSourcePhrase(*pSP);
						pADeepCopiedSrcPhrase->DeepCopy();
						pRec->propagationSpan_SrcPhraseList.Append(pADeepCopiedSrcPhrase);
						pRec->nPropagationSpan_EndingSequNum =
													pADeepCopiedSrcPhrase->m_nSequNumber;
                        // NOTE: we fill this list, and get the starting and ending
                        // sequence numbers, unilaterally -- without consideration of
                        // whether or not the free translation span, and the back
                        // translation span, have made the cancel span already encompass
                        // the CSourcePhrase instances in the propagation span. When we
                        // need to know whether or not that is the case (ie. if we are
                        // required to do a bail out so as to restore the original document
                        // state), we can compare indices for these spans, and whenever the
                        // propagation span is subsumed by the cancel span, we can just
                        // restore the cancel span and ignore the propagation span; but in
                        // the event that the propagation span extends further than the end
                        // of the cancel span, we use the former's contents to restore
                        // those CSourcePhrase instances which lie beyond the end of the
                        // cancel span
					}

					// now we can propagate the special text value, and the TextType
					pSP->m_bSpecialText = pRec->bSpecialText;
					pSP->m_curTextType = gPropagationType;
				}
			}
		}
		gbPropagationNeeded = FALSE; // turn it off, restoring the default value

        // the new CSourcePhrase instances are now ready to be put into the document's
        // m_pSourcePhrases list at the editable span location, replacing the (possibly
        // modified) ones in the editable span due to the replacements done above (about
        // 500 lines up). Beware, the new list might be empty, or shorter, or the same
        // length, or longer than the former editable span. The
        // TransferCompletedSrcPhrases() function also adjusts the active location, and
        // the stored value in the edit record, if the user's edits have made either or
		// both outside the document's bounds. (Partner piles are created as necessary
		// within the TransferCompletedSrcPhrases() function as well.)
		int nBeginAt = pRec->nStartingSequNum;
		int nFinishAt = pRec->nEndingSequNum;
		TransferCompletedSrcPhrases(pRec,&pRec->editableSpan_NewSrcPhraseList,
									pSrcPhrases,nBeginAt,nFinishAt);

        // get a new valid starting pile pointer for the inserted new source text --
        // because for a source text edit, this is where the active location needs to be
        // put
		nSaveSequNum = pRec->nStartingSequNum; // the start of the new material,
											   // if there was some new material
		if (pRec->nNewSpanCount == 0)
		{
			// there was no new material, so put the location as the previous
			// CSourcePhrase instance
			nSaveSequNum -= 1;
			// check we didn't go negative, if so, then make the document start
			// be the location
			if (nSaveSequNum < 0)
				nSaveSequNum = 0;
		}
		pApp->m_nActiveSequNum = nSaveSequNum; // this ensures any later call to
											   // InsertNullSrcPhrase() won't crash
        // we must have a valid layout, because the last function call will have clobbered
        // some of the original layout's pointers
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pStartingPile = GetPile(nSaveSequNum);
		wxASSERT(pStartingPile != NULL);
		pApp->m_pActivePile = pStartingPile;

		// restore removed Notes, provided there are some to be restored
		//int nNewSrcPhraseCount = -1;
		bool bNotesRestorationWorkedOK = TRUE;
		if (pRec->arrNotesSequNumbers.GetCount() > 0)
		{
            // we must first get preceding and following contexts which may get Notes
            // moved, so that a user Cancel operation will be able to be done successfully
			bool bGotSpanSuccessfully = pApp->GetNotes()->GetMovedNotesSpan(pSrcPhrases, pRec,
														  precedingContext);
			if (!bGotSpanSuccessfully)
			{
                // remove the contents of the arrNotesSequNumbers array first, before
                // bailout is attempted, and also the follNotesMoveSpanList and prec
                // NotesMoveSpanList need to be cleared, as one or the other may have not
                // yet been cleared; and since Note restoration has not yet been attempted,
                // no Notes in either preceing or final context can possibly have been
                // moved as yet, so Bailout doesn't need these lists if done from before
                // the RestorNotesAfterSourceTextEdit() function is called
				pRec->arrNotesSequNumbers.Clear();
				pDoc->DeleteSourcePhrases(&pRec->follNotesMoveSpanList);
				pDoc->DeleteSourcePhrases(&pRec->precNotesMoveSpanList);
				// create the user message
				errStr = _T("Notes restoration unexpectedly failed when ");
				errStr += _T(
				"getting the potential moved notes (preceding context) span. ");
				errStr += _T("Vertical edit process abandoned. ");
				errStr += _T(
				"Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
				pApp->LogUserAction(errStr);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto exit;
			}

			// do the restoration of the removed Notes
			bNotesRestorationWorkedOK = pApp->GetNotes()->RestoreNotesAfterSourceTextEdit(pSrcPhrases,pRec);
			// if there was an error, we can't continue with the vertical edit process so
            // call the BailOutFromEditProcess() function, as it knows how to bail out when
            // the document has been modified already - it relies on some globals to give
            // it the smarts it needs
			if (!bNotesRestorationWorkedOK)
			{
                // we don't expect note restoration would ever fail, so a hard coded
                // English message for the developer's benefit will suffice here, then do
                // the bail out
				errStr = _T("Notes restoration unexpectedly failed. ");
				errStr += _T("Vertical edit process abandoned. ");
				errStr += _T(
				"Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION | wxOK);
				pApp->LogUserAction(errStr);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto exit;
			}
		}

        // the restoration of markers did not attend to making sure every Note recreated
        // has its parent CSourcePhrase's m_bHasNote boolean set TRUE. We do that check now
        // and fix any in which the flag is still clear. (Do this in the editable span and
        // 5 CSourcePhrase instances or so either side - that should be enough to catch all
        // which neeed this fix.)
		pApp->GetNotes()->CheckAndFixNoteFlagInSpans(pSrcPhrases, pRec);
		/* uncomment these 6 lines to check document restoration from this point in process
		// test bailout at this point, when editing a typo marker produced automatic filtering
		errStr = _T("Testing only. ");
		errStr += _T("Vertical edit process abandoned. ");
		errStr += _T("Will try now to restore the document to its pre-edit state.");
		AfxMessageBox(errStr,MB_ICONEXCLAMATION);
		BailOutFromEditProcess(pSrcPhrases,pRec);
		goto exit;
		*/
		// BEW added next block 16Jun05
		// handle any filtering needed because one or more markers
		// were edited to be markers which should be filtered out...
		// if any filtering is needed, we check for it and if so,
		// get it done by the RetokenizeText() call below
		if (bMarkerSetsAreDifferent)
		{
            // There is at least one place (could be more if changed endmarker(s) are
            // involved) where the document's screen appearance would probably now be
            // incorrect - because the user has edited one or more SF markers. The
            // following comment from the code for the document class's RetokenizeText()
            // function explains... "Typically, ..., there will be errors remaining in the
            // document - these are old pSrcPhrase->m_inform strings which are now out of
            // date, TextType values which are set or changed at the wrong places and now
            // inappropriately propagated in the light of the edited SFM change(s) now in
            // effect, and likewise m_bSpecialText will in many places be wrong, or changed
            // when it shouldn't be. To fix all this stuff we will scan across the whole
            // document with the DoMarkerHousekeeping() function, which duplicates some of
            // TokenizeText()'s code, to get the TextType, m_bSpecialText, and m_inform
            // members of pSrcPhrase correct at each location (doing it over the whole doc
            // is, of course, overkill, but it will catch anything wrong from other
            // operations and fix them too, so worth doing & it is quick/unnoticed)

			//int activeSequNum = pApp->m_nActiveSequNum; // set but not used
			if (pApp->m_nActiveSequNum < 0)
			{
				// must not have data yet, or we are at EOF and so no pile is currently active
				; //activeSequNum = -1;
			}
			else
			{
				// we are somewhere in the midst of the data, so a pile will be active
				//activeSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;

				// remove any current selection, as we can't be sure of any pointers
				// depending on what user may choose to alter
				RemoveSelection();
			}
			TextType aDontCare_PropagationType = verse; // we won't use the returned value
			bool bDontCare_PropagationNeeded = FALSE; // we won't use the returned value
			int docSrcPhraseCount = pSrcPhrases->GetCount(); // current doc size
			GetDocument()->DoMarkerHousekeeping(pSrcPhrases,docSrcPhraseCount,
								aDontCare_PropagationType, bDontCare_PropagationNeeded);


			pApp->m_targetPhrase.Empty(); // when editing src text, the box will be
										  // at the start of the new material hopefully,
										  // so we don't expect any adaptation to be known
			Invalidate();
			GetLayout()->PlaceBox();
		}

		// prepare for next step, eg, combobox etc

		// post the custom event for adaptations step of the vertical edit, or for the
		// glossing step, depending on the user's preference (I want return immediately,
		// so I don't use SendMessage())
		if (gbAdaptBeforeGloss)
		{
            // whm note: MFC docs say of PostMessage, "Places a message in the window's
            // message queue and then returns without waiting for the corresponding window
            // to process the message." For SendMessage, they say, "Sends a message to the
            // window and does not return until the window procedure has processed the
            // message."
			// MFC code:
			//this->PostMessage(CUSTOM_EVENT_ADAPTATIONS_EDIT,0,0);

			// wx example code for sending custom event:
			// user code sending the event
			//void MyWindow::SendEvent()
			//{
			//    wxCommandEvent event( wxEVT_MY_EVENT, GetId() );
			//    event.SetEventObject( this );
			//    // Give it some contents
			//    event.SetText( wxT("Hallo") );
			//    // Send it
			//    GetEventHandler()->ProcessEvent( event );
			//}
			// wx code:
			wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
			wxPostEvent(pApp->GetMainFrame(), eventCustom); // the event handlers are
															// in CMainFrame

		}
		else
		{
			wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
			wxPostEvent(pApp->GetMainFrame(), eventCustom); // the event handlers
															// are in CMainFrame
		}
	}
	else
	{
		bUserCancelled = TRUE;

		// old phrase box location should be valid, so put value back
		pApp->m_targetPhrase = pRec->oldPhraseBoxText;
		pApp->m_pTargetBox->ChangeValue(pApp->m_targetPhrase);
		pApp->m_pTargetBox->SetSelection(-1,-1); // select it all
		pApp->LogUserAction(_T("Cancelled from OnEditSourceText()"));
	}

	// delay cancel cleanup to here, as the restoration of the view needed
	// to use the pRec values which are to be initialized here
	if (bUserCancelled)
	{
		// user cancelled, so restore initial state...
		// The document is not modified until after the dialog is dismissed, so a Cancel
		// button press only requires that that the edit record will have its stored
		// information cleared
		InitializeEditRecord(*pRec); // clears gbVerticalEditInProgress as well
		gEntryPoint = noEntryPoint;
		gEditStep = noEditStep;
		gbEditingSourceAndDocNotYetChanged = TRUE;
		GetLayout()->Redraw();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if filtered information (from m_filteredInfo only) was transferred,
///             (and if so then the carrier CSourcePhrase instance will have also been
///             deleted from the end of the pNewSrcPhrases list). The caller will want to
///             pass knowledge of this fact to the function which adjusts the TextType in
///             the new section of source text, so that proper propagation of altered
///             TextType can be done if the user has modified the markup.
///             Or return FALSE if no filtered info was transferred.
/// \param      pNewSrcPhrases	->	pointer to the SPList pointer in the EditRecord which
///                                 holds the list of CSourcePhrase instances resulting
///                                 from the parse of the new source text as edited by the
///                                 user
/// \param      pFollSrcPhrase	<->	pointer to the first CSourcePhrase instance in the
///                                 context which follows the editable span of instances in
///                                 m_pSourcePhrases list in the app; this is the instance
///                                 whose m_filteredInfo member will receive any transferred
///                                 m_filteredInfo content. Pass in NULL if there is no
///                                 following context (because we are at the end of the
///                                 document) - in such a circumstance no transfer can be
///                                 done and the carrier CSourcePhrase in pNewSrcPhrases
///                                 for the now-filtered information will have to be
///                                 included in the document where it would continue to
///                                 carry that filtered info
/// \param      pRec		    <->	pointer to the global EditRecord struct, gEditRecord,
///                                 which records edit spans, lists of CSourcePhrase
///                                 instances, lists of removed strings, starting and
///                                 ending TextType values, and various booleans reflecting
///                                 the state of the edit process
/// \remarks
/// Called from: the View's OnEditSourceText().
/// This function does several jobs.
/// (1) It detects if the new source text ends with filtered information other than that
/// which goes into m_freeTrans, m_notes or m_collectedBackTrans, that is, information
/// which goes into m_filteredInfo. It is unlikely that the user's editing will result in
/// the edited text string ending with such information, but we can't discount the
/// possibility. If it is present it will manifest in the new list of CSourcePhrase
/// instances as the final one in the list, with m_key empty, m_follPunct empty, and
/// m_filteredInfo containing the filtered content wrapped with pairs of \~FILTER and
/// \~FILTER* markers, for as many filtered info pieces as there may be present. When there
/// is such filtered content "widowed" in this way, it really belongs on the CSourcePhrase
/// which is first in the following context. So that transfer is done here.
/// (2) If moving filtered info leaves a CSourcePhrase instance whose only reason for existing
/// was to carry that stuff; then once it's gone, this carrier instance must be deleted.
/// (3) Knowledge of what happened is passed back to the caller by the returned BOOL
/// parameter.
/// Note 1: we check for m_precPunct non-empty, because a CSourcePhrase instance that
/// results from a parse of endmarker followed by punctuation without any intervening space
/// will manifest as m_prevPunct carrying the punctuation on a CSourcePhrase final widow,
/// but the endmarker will be in m_endMarkers of the penultimate CSourcePhrase. In such a
/// circumstance, if we transferred the preceding punctuation to the following
/// CSourcePhrase then we'd effect a bogus change to the document, so we need to let the
/// widow remain instead. Hence we bleed that case out by testing and returning FALSE if
/// there is preceding punctuation. Only after that do we look at the m_follPunct and
/// m_markers members as explained for 1. above.
/// (4) if the last CSourcePhrase instance has m_markers non-empty, then there were
/// non-endmarker final markers at the end of the user's edited string, and those would
/// require an inserted CSourcePhrase with empty m_key to carry them. The TokenizeText()
/// parser would have them stored on an instance with non-empty m_key, so we should move
/// them to the next CSourcePhrase instance, but only provided m_key and m_follPunct
/// members are both empty.
/// (5) A fifth task, but only when a typo marker has been corrected, is to clear the
/// m_bFirstOfType flag and clear "?\mkr?" from the m_inform member, both done on the
/// gpFollSrcPhrase which is first in the following context.
/// BEW 7May08, function created as part of refactoring the Edit Source Text functionality
/// BEW 23Mar10, updated for support of doc version 5 (some changes were needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::TransportWidowedFilteredInfoToFollowingContext(SPList* pNewSrcPhrases,
			CSourcePhrase* pFollSrcPhrase, EditRecord* pRec)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pFollSrcPhrase == NULL)
	{
        // there is no following context, so no transfer can be done, so the carrier
        // CSourcePhrase (if there is one) must be retained as it is - so we've nothing to
        // do but tell the caller no transfer was done
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
		pRec->bDocEndPreventedTransfer = TRUE;
		return FALSE;
	}

    // get the final CSourcePhrase in the list; but if the list is empty (ie. the user used
    // the edit source text dialog to remove all the displayed source text) then there may
    // not be anything to transfer (otherwise the list would have at least one
	// entry), so return FALSE
	int nCount = pNewSrcPhrases->GetCount();
	if (nCount == 0)
	{
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
		pRec->bDocEndPreventedTransfer = FALSE; // a TRUE value is pointless if nothing
												// is there to transfer
		return FALSE;
	}
	SPList::Node* lastPos = pNewSrcPhrases->GetLast();
	CSourcePhrase* pLastSrcPhrase = lastPos->GetData();
	wxASSERT(pLastSrcPhrase != NULL);

    // m_filteredInfo may have some content. We handle filtered info first.
    // BEW added 24Jan09: support for non-endmarker(s) in m_markers of a carrier
    // CSourcePhrase with m_srcPhrase and m_follPunct members empty (this can happen if, in
    // the dialog, after the user's edit, there is only non-endmarkers in the edit box, or,
    // at the end of the edited string he adds final non-endmarkers for some reason) -- we
    // need a bHasNonEndmarkers bool flag, and a code block for processing any such
	wxString filteredInfo;
	bool bFilteredInfoToBeTransferred = FALSE;
	pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // start off assuming there
															   // is none to be handled
	if (!pLastSrcPhrase->GetFilteredInfo().IsEmpty())
	{
		// there is now-filtered information present on the last CSourcePhrase instance,
		// so indicate it has to be handled further down in the function -- but don't do
        // it yet because it only needs to be transferred provided pLastSrcPhrase's m_key
        // and m_follPunct CString members are both empty
		bFilteredInfoToBeTransferred = TRUE;
		filteredInfo = pLastSrcPhrase->GetFilteredInfo();
	}
	// if there are final non-endmarkers, they'll be within m_markers, so that being
	// non-empty is sufficient for setting the boolean
	bool bHasNonEndmarkers = FALSE; // default; BEW added 24Jan09
	wxString nonEndmarkers; // BEW added 24Jan09
	bHasNonEndmarkers = !pLastSrcPhrase->m_markers.IsEmpty();
	if (bHasNonEndmarkers)
	{
		nonEndmarkers = pLastSrcPhrase->m_markers; // these may need to be transferred
						// to the first CSourcePhrase instance of the following context
	}


    // we have some filtered info (in m_filteredInfo) and/or non-endmarkers to transfer -
    // do so, but only provided pLastSrcPhrase's m_key and m_precPunct CString members are
    // both empty
    bool bRemoveSrcPhrase = FALSE;
	if (bFilteredInfoToBeTransferred || bHasNonEndmarkers)
	{
        // only do the transfer provided there is something there to be transferred in the
        // first place; and only if the relevant members are empty (which indicates a
        // CSourcePhrase otherwise unwanted)
		if (pLastSrcPhrase->m_key.IsEmpty() && pLastSrcPhrase->m_precPunct.IsEmpty())
		{
            // if we are transferring something, then transfer a m_bFirstOfType == TRUE
            // value, provided the pFollSrcPhrase member of same name is not itself TRUE
			if (!pFollSrcPhrase->m_bFirstOfType && pLastSrcPhrase->m_bFirstOfType)
			{
				pFollSrcPhrase->m_bFirstOfType = TRUE; // needs to be set to ensure
													   // nav text gets rewritten
			}

			// now do the transfers
			if (bFilteredInfoToBeTransferred)
			{
				// it's filtered information we are dealing with (and it might have one or
                // more non-endmarkers following it - if so, they go along for the ride)
				wxString strAlreadyFiltered = pFollSrcPhrase->GetFilteredInfo();
				if (strAlreadyFiltered.IsEmpty())
				{
					pFollSrcPhrase->SetFilteredInfo(filteredInfo);
				}
				else
				{
					filteredInfo += strAlreadyFiltered;
					pFollSrcPhrase->SetFilteredInfo(filteredInfo);
				}
				// record, in the EditRecord, what we just did
				pRec->bTransferredFilterStuffFromCarrierSrcPhrase = TRUE;
				bRemoveSrcPhrase = TRUE;
			}
			// now transfer non-endmarkers, if any
			if (bHasNonEndmarkers)
			{
				pFollSrcPhrase->m_markers = nonEndmarkers + pFollSrcPhrase->m_markers;

				// make sure the marker info we are transferring ends with a space
				// delimiter, to ensure we don't do something bad like butting a verse
				// number right at the start of a word which is supposed to be adapted
				nonEndmarkers.Trim();
				nonEndmarkers += _T(" ");

				// pFollSrcPhrase may or may not have information in m_inform, and so
				// might pLastSrcPhrase, so transfer that information too
				pFollSrcPhrase->m_inform = pLastSrcPhrase->m_inform + pFollSrcPhrase->m_inform;
			}

			// Because the user may have edited a bogus (ie. misspelled) marker, we
			// need to search for the nav text marking with wrapping ? characters.
            // So clear the "?\mkr?" string from m_inform. Even if we don't manage
            // to make the navigation text show the corrected marker name, at worse
            // that is benign and does not affect the integrity of the document (and if
            // RetokenizeText() is later called by the caller, which it should be, that
            // should fix up the navigation text to be what it should be - I think
			int anOffset = -1;
			wxString accumulateStr;
			wxString inform = pFollSrcPhrase->m_inform;
			anOffset = inform.Find(_T('?'));
			if (anOffset != -1)
			{
				// there is a bogus marker name to be removed
				accumulateStr += inform.Left(anOffset);
				anOffset++; // get past the first ? character
				inform = inform.Mid(anOffset); // use the remainder for next test
				anOffset = inform.Find(_T('?'));
				if (anOffset != -1)
				{
					// go through with the rest only provided we have found the
					// matching ? which delimits the end of the "?\mkr?" substring
					anOffset++; // get past the final ? character
					inform = inform.Mid(anOffset); // get whatever remains,
												   // possibly nothing
					accumulateStr += inform; // add it to the initial material
                    // we have done this just in case there is also the name of one or
                    // more non-bogus markers in the m_inform member; we want to retain
                    // those
					pFollSrcPhrase->m_inform = accumulateStr;
				}

				// since the bogus marker may be now fixed and the filtered info
				// transferred could be just-filtered because of that, we'll assume so,
				// and make the TextType which precedes that just-filtered stuff
				// propagatable by clearing the m_bFirstOfType flag
				pFollSrcPhrase->m_bFirstOfType = FALSE;
			}

			if (bHasNonEndmarkers || bRemoveSrcPhrase)
			{
				// delete the carrier, pLastSrcPhrase, which is no longer needed & update
				// the count value stored in pRec to comply with this deletion; remove the
				// pointer at the tail of the list too
				pApp->GetDocument()->DeleteSingleSrcPhrase(pLastSrcPhrase);
				pRec->nNewSpanCount -= 1;
				SPList::Node* spLast = pNewSrcPhrases->GetLast();
				pNewSrcPhrases->DeleteNode(spLast);
				pRec->bDocEndPreventedTransfer = FALSE; // make sure we get value correct
			}

            // reset the partner pile & its width - not strictly necessary as probably
            // the pile width is unchanged, but no harm in it, and it is a fail-safe
			// thing to do for updating of the view, since it guarantees the strip
			// gets invalidated and its index saved in CLayout::m_invalidStripArray
			pApp->GetDocument()->ResetPartnerPileWidth(pFollSrcPhrase);

			return TRUE;
		} // end of TRUE block for test of empty m_key and empty m_precPunct members
	}
	// if control gets to here, we've done no transfers, so inform the caller
	return FALSE;
}



/////////////////////////////////////////////////////////////////////////////////
///	\return        nothing
///
///	\param bSeeGlossesEnabled	->	TRUE of glosses are visible currently in the
///                                 main window (caller passes in the global bool
///                                 gbGlossingVisible flag), FALSE if not
///	\param bIsGlossing			->	TRUE if glossing mode is currently ON, FALSE if
///	                                adapting mode is currently ON (caller passes in the
///	                                global bool gbIsGlossing flag)
///	\param pRec				    ->	pointer to the EditRecord struct which, among
///	                                other things, stores the value of the passed in
///	                                global booleans at the time when the vertical edit
///	                                process was entered
///	\remarks
/// Used to restore the mode to whatever it was when the vertical edit process was
/// initiated, including making glosses visible or hidden if the original mode was
/// adaptations mode and they were visible or hidden, respectively. There are handlers
/// for menu commands for these mode changes, so we just need to provide a set of tests
/// to determine how, if at all, the original state differs from the current state and
/// make the appropriate handler calls to get the state back to what it should be.
///
///	BEW created 1Aug08, for support of vertical editing in the refactored
///	Edit Source Text handler
/// BEW 26Mar10, no changes needed for support of doc version 5
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RestoreMode(bool WXUNUSED(bSeeGlossesEnabled),
								bool WXUNUSED(bIsGlossing), EditRecord* pRec)
{
    // Protocol: start from the 3 possible current states (1. glossing, 2. adapting &
    // seeing glosses, 3. adapting & hidden glosses), and for each of these three starting
    // points, use pRec to determine what the original state was, and then set up the calls
    // needed to restore to any particular starting state (again, the same 3 possibilities
    // obtain)
	if (gbIsGlossing)
	{
		// glossing mode is currently ON, so gbEnableGlosses must be TRUE as well
		if (pRec->bGlossingModeOnEntry)
		{
            // glossing mode was ON at entry also, so pRec->bSeeGlossesEnabledOnEntry must
            // be TRUE as well so the current flag values are correct - hence nothing to do
			;
		}
		else
		{
            // adapting mode was ON at entry, but gbGlossingVisible could have been ON (ie.
            // glosses visible) or OFF (ie. glosses hidden) on entry, so find out which was
            // the case
			if (pRec->bSeeGlossesEnabledOnEntry)
			{
                // the "See Glosses" menu item was ticked when the vertical edit was
                // entered, glosses were visible in adapting mode
				ToggleGlossingMode();
			}
			else
			{
                // the "See Glosses" menu item was unticked on entry, glosses were hidden,
                // we had a standard 2-line strip on entry
				ToggleSeeGlossesMode();
			}
		} // end of tests for original state
	}
	else
	{
        // adapting mode is currently ON, but gbEnableGlosses could be ON (ie. glosses
        // visible) or OFF (ie. glosses hidden
		if (gbGlossingVisible)
		{
			// the "See Glosses" menu item is ticked, glosses are visible in adapting mode
			if (pRec->bGlossingModeOnEntry)
			{
				// glossing mode was ON at entry, so pRec->bSeeGlossesEnabledOnEntry must
				// be TRUE as well
				ToggleGlossingMode();
			}
			else
			{
                // adapting mode was ON at entry, but gbGlossingVisible could have been ON
                // (ie. glosses visible) or OFF (ie. glosses hidden) on entry, so find out
                // which was the case
				if (pRec->bSeeGlossesEnabledOnEntry)
				{
                    // the "See Glosses" menu item was ticked when the vertical edit was
                    // entered, glosses were visible in adapting mode so the current flag
                    // values are correct - hence nothing to do
					;
				}
				else
				{
                    // the "See Glosses" menu item was unticked on entry, glosses were
                    // hidden, we had a standard 2-line strip on entry
					ToggleSeeGlossesMode();
				}
			} // end of tests for original state
		}
		else
		{
			// the "See Glosses" menu item is unticked, glosses are hidden, we have
			// a standard 2-line strip currently
			if (pRec->bGlossingModeOnEntry)
			{
				// glossing mode was ON at entry, so pRec->bSeeGlossesEnabledOnEntry must
				// be TRUE as well
				ToggleSeeGlossesMode();
				ToggleGlossingMode();
			}
			else
			{
                // adapting mode was ON at entry, but gbGlossingVisible could have been ON
                // (ie. glosses visible) or OFF (ie. glosses hidden) on entry, so find out
                // which was the case
				if (pRec->bSeeGlossesEnabledOnEntry)
				{
                    // the "See Glosses" menu item was ticked when the vertical edit was
                    // entered, glosses were visible in adapting mode
					ToggleSeeGlossesMode();
				}
				else
				{
                    // the "See Glosses" menu item was unticked on entry, glosses were
                    // hidden, we had a standard 2-line strip on entry so the current flag
                    // values are correct - hence nothing to do
					;
				}
			} // end of tests for original state
		}
	}
}

// return a pointer to a specific vertical edit bar of the frame window, or NULL if there
// is an error when trying to get the pointer
wxPanel* CAdapt_ItView::GetBar(enum VertEditBarType vertEditBarType)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// whm modified to use enum VertEditBarType defined in Adapt_It.h
	// BEW modified 10Nov08 to include the Compose bar in the enum, so as to get
	// access to the TextBox there, for support of the Undo Last Copy button
	wxPanel* pBar = (wxPanel*)NULL;
	// In the wx version all the vertical edit bars reside as members of CMainFrame
	// and they all are created at the startup of the application, but are hidden
	// until needed by the vertical editing process.
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);

	switch (vertEditBarType)
	{
	case Vert_Edit_RemovalsBar:
		pBar = pFrame->m_pRemovalsBar;
		break;
	case Vert_Edit_Bar:
		pBar = pFrame->m_pVertEditBar;
		break;
	case Vert_Edit_ComposeBar:
		pBar = pFrame->m_pComposeBar;
		break;
	default:
		pBar = (wxPanel*)NULL;
	}
	return pBar;
}

// return a pointer to the CComboBox in the m_wndRemovalsBar of the frame window,
// or NULL if there is an error when trying to get the pointer
wxComboBox* CAdapt_ItView::GetRemovalsComboBox()
{
	wxComboBox* pCombo = NULL;
	wxPanel* pBar = GetBar(Vert_Edit_RemovalsBar);
	if (pBar == NULL)
		return NULL;
	pCombo = (wxComboBox*)pBar->FindWindowById(IDC_COMBO_REMOVALS);
	wxASSERT(pCombo != NULL);
	if (pCombo == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the ComboBox control in GetRemovalsComboBox()"),
		_T(""), wxICON_EXCLAMATION | wxOK);
	}
	return pCombo;
}

// Get a pointer to the CComboBox control in the m_wndRemovalsBar CDialogBar member of the
// frame window (see MainFrm.cpp and .h), and then check which step is passed in, and
// populate the combo box with the removed data strings in gEditRecord's appropriate
// CStringList; there may be no entries to put in the list, in which case a single entry
// which is space is retained so that the comboxbox stays visible, and this is not an
// error. Return TRUE when there was no error, and FALSE if there was an error leading to
// the list not being populated.
// Note, this function can be called when vertical editing is not currently on, to
// repopulate the combobox list with whatever desired data we want, whether adaptations,
// glosses, or free translations - by passing in the appropriate enum value, rather than
// the current value in the global gEditStep
// BEW 22Feb10 no changes needed for support of doc version 5
// BEW 9July10, no changes needed for support of kbVersion 2
bool CAdapt_ItView::PopulateRemovalsComboBox(enum EditStep step, EditRecord* pRec)
{
	wxComboBox* pCombo = GetRemovalsComboBox();
	if (pCombo == NULL)
		return FALSE; // could not get the required pointer
					  // (an error warning will have been seen already)
	wxASSERT(pRec);
	wxArrayString* pStrList = NULL;

	wxString aString;
	int index;
	bool bIsEmpty = FALSE;

    // determine which list we are dealing with for this vertical editing step...
    // Note: this function can be called when no vertical editing is in progress, in
    // which case the caller does not pass in gEditStep's current value (which would be
    // noEditStep) but rather the particular enum value which results in the population
    // being done with the appropriate data (whether adaptations, glosses, of free
    // translations)
	switch (step)
	{
		case glossesStep:
		{
			pStrList = &pRec->deletedGlossesList;
			break;
		}
		case freeTranslationsStep:
		{
			pStrList = &pRec->deletedFreeTranslationsList;
			break;
		}
		default:
		case adaptationsStep:
		{
			pStrList = &pRec->deletedAdaptationsList;
			break;
		}
	}

	// populate the combo's list, etc...

	// don't do anything if pRec's CStringList has no entries in it, except
	// remove whatever is already in the combo's list -- because anything already
	// in it is quite likely data from a different step, and so inappropriate now
	bIsEmpty = pStrList->IsEmpty();
	if (bIsEmpty)
	{
		// no populating to be done, but this is no error; but make sure there is
		// a space there at least, to keep the combobox visible
		pCombo->Clear(); // remove old content, it could be glosses or free translations
		index = pCombo->Append(_T(" "));
		index = index; // avoid warning
		return TRUE;
	}
	// the pRec list has content to be put in the combo box... first remove old content
	pCombo->Clear();
	// and now loop over the stored list, adding its strings to the combo's list --
    // the pRec lists are maintained externally with a maximum of 100 entries, so we can
    // safely loop over all there are (#define DELETIONS_LIST_MAX_ENTRIES 100 at top of
    // Adapt_ItView.cpp)
	int ct;
	for (ct = 0; ct < (int)pStrList->GetCount(); ct++)
	{
		aString = pStrList->Item(ct);
		// we don't bother having empty strings in the list,
		// the user can make those himself easily
		if (!aString.IsEmpty())
		{
			index = pCombo->Append(aString);
			index = index; // avoid warning
		}
	}

    // set up the list's visual dimensions and the combo width, visually it must fit within
    // the frame window's vertical extent of the client rectangle
    // whm Note: wxComboBox derives from wxControlWithItems which has a SetSelection()
    // method with a single parameter - this method sets the item in the list. The
    // wxComboBox class itself has another methos called SetSelection() which takes two
    // parameters - this method is used to set the selection highlight of the line showing
    // in the text field of the combo box!
	pCombo->SetSelection(0); // show the first in the list in top position
	pCombo->SetSelection(0,0); // show that top item unselected
	return TRUE;
}

// BEW 26Mar10, no changes needed for support of doc version 5
void CAdapt_ItView::SetVerticalEditModeMessage(wxString messageText)
{
	wxPanel* pBar;
	pBar = GetBar(Vert_Edit_Bar);
	wxASSERT(pBar != NULL);
	wxTextCtrl* pMsgBox = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_MSG_TEXT);
	wxASSERT(pMsgBox != NULL);
	pMsgBox->ChangeValue(messageText);
}

// use the following when placing the phrase box in vertical editing moode's steps
// BEW 26Mar10, no changes needed for support of doc version 5
// BEW 9July10, no changes needed for support of kbVersion 2
// BEW 10Jan12, fixed bug in which the unqualified nSequNum == pRec->nSaveActiveSequNum
// test overwrites a found value from the lookup with the original phrasebox text if
// the source text for editing was just a single word
void CAdapt_ItView::PutPhraseBoxAtSequNumAndLayout(EditRecord* pRec, int nSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();

    // first make sure any pile's CSourcePhrase instance's source text or
    // translation or gloss is not carried forward or back to a different step
	translation.Empty();
	pApp->m_targetPhrase.Empty();

	// now set up the phrase box
	pApp->m_nActiveSequNum = nSequNum; // needed, as a test for m_nActiveSequNum < 0
									   // done internally will have box placement
									   // skipped if we get here and it is -1
	pApp->m_pActivePile = GetPile(nSequNum);
	bool bFoundSomething = FALSE;
	if (gbIsGlossing)
	{
		translation = pApp->m_pActivePile->GetSrcPhrase()->m_gloss;
	}
	else
	{
		translation = pApp->m_pActivePile->GetSrcPhrase()->m_adaption;
	}
	if (translation.IsEmpty())
	{
		// this call sets translation to something, or leaves it empty if the lookup
		// found nothing
		bFoundSomething = pApp->m_pTargetBox->LookUpSrcWord(pApp->m_pActivePile);
	}
	pApp->m_targetPhrase = translation; // global CString  translation is set
        // by whatever is adaptation or gloss if user switched modes, and if there is no
        // such string yet, then do LookUpSrcWord() and if there is an entry in the KB, use
        // that, else leave empty

	// BEW added 16Nov10, one final thing we can do is test if the saved initial active
	// sequ number is the same as that passed in, if so, then reset the phrase box to the
	// stored string in pRec, provided nothing was found above
	if (!bFoundSomething && nSequNum == pRec->nSaveActiveSequNum)
	{
		translation = pRec->oldPhraseBoxText;
		pApp->m_targetPhrase = translation;
	}
	CLayout* pLayout = GetLayout();
#ifdef _NEW_LAYOUT
	//pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
    // BEW changed 20Jan11: Need to use create_strips_keep_piles to ensure that any
    // replaced piles are properly embedded into the layout, and each partner pile's
	// members all correctly set (otherwise, in particular, pPile's m_pOwningStrip pointer
	// will be default NULL, and the ScrollIntoView() call below will fail)
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	GetLayout()->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum); // BEW added 20Jun09
	Invalidate();
	GetLayout()->PlaceBox();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there was no error, FALSE if there was an error
/// \param      pRec   ->   pointer to the EditRecord struct which stores the information
///                         needed for recreating the one or more collected back
///                         translations pertinent to the editable span for the current
///                         vertical edit operation
/// \remarks
/// Called only once, in OnCustomEventBackTranslationsEdit() in MainFrm.cpp.
/// The last step in the vertical edit process is to restore any collected
/// backtranslations, using the updated adaptation or gloss information resulting from
/// earlier user-interactive steps in the vertical edit process. This restoration is done
/// without intervention from the user being required. All the information pertinent to
/// doing the restoration is passed in within the pRec parameter.
///
/// The function checks that a restoration is required. If it is, then information in the
/// pRec parameter is used to set up a programmatically generated selection for the
/// CSourcePhrase instances involved in the (limited) span of the recollection - because
/// without a selection, the collection would be done over the whole document which would
/// be overkill. The work of doing the recollection is then given to the
/// DoCollectBacktranslations() function.
/// BEW 26Mar10, no changes needed for support of doc version 5 (but a couple of called
/// functions do have some changes)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RecreateCollectedBackTranslationsInVerticalEdit(EditRecord* pRec,
														enum EntryPoint anEntryPoint)
{
	CAdapt_ItApp* pApp = &wxGetApp();
    // if there were no back translations removed from the edit span, then none need be
    // recollected and if so just return without doing anything
	if (!pRec->bEditSpanHasBackTranslations)
		return TRUE;

	if (pRec->nBackTrans_StartingSequNum == -1)
		return FALSE; // should not be -1 if bEditSpanHasBackTranslations is TRUE

	int nBackTranslationSpanExtent = pRec->nBackTrans_EndingSequNum -
										pRec->nBackTrans_StartingSequNum + 1;
	wxASSERT(nBackTranslationSpanExtent > 0);

	// remove any selection
	RemoveSelection();

    // save the current active pile's sequ num,, we need to change the active location for
    // the call of MakeSelectionForFind() below, so we must restore the former active
    // location before exitting; then set the active location to be at the location where
    // the first \bt marker was removed
	int nSaveActiveSequNum = pApp->m_nActiveSequNum;
	pApp->m_pActivePile = GetPile(pRec->nBackTrans_StartingSequNum);

    // the extent of the edit span may have been changed in one or two ways - if the entry
    // point was sourceTextEntryPoint, then the source text may have been edited to be
    // longer or shorter, and subsequently, in adaptationsStep of the vertical edit, the
    // user may have used retranslations, inserted placeholders, or mergers, all of which
    // potentially change the extend of the edit span. Which of these applies must now be
    // determined and the appropriate span adjustment made
	switch (anEntryPoint)
	{
	case noEntryPoint:
        // this should never happen, but if it does it means no source text or vertical
        // edit was done -- in which case we just return and no do anything
		return TRUE;
	case sourceTextEntryPoint:
		nBackTranslationSpanExtent += (pRec->nNewSpanCount - pRec->nOldSpanCount);
		nBackTranslationSpanExtent += pRec->nAdaptationStep_ExtrasFromUserEdits;
		break;
	case adaptationsEntryPoint:
        // the only possibility for span extent changes is due to mergers, retranslations,
        // or placeholder insertions
		nBackTranslationSpanExtent += pRec->nAdaptationStep_ExtrasFromUserEdits;
		break;
	// the next two cases involve no change to the span length, so they have no work to do
	case glossesEntryPoint:
	case freeTranslationsEntryPoint:
		;
	}

    // use the final value of nBackTranslationSpanExtent, together with
    // nBackTrans_StartingSequNum to define which CSourcePhrase instances in the
    // m_pSourcePhrases list in the document need to be programmatically set as selected &
    // create the selection; MakeSelectionForFind() can be used to make the selection even
    // though we are not doing a Find command
	int nSelectionLine = 0; // select in the punctuated source text line
	MakeSelectionForFind(pRec->nBackTrans_StartingSequNum, nBackTranslationSpanExtent,
							nSelectionLine,TRUE);
	// hand over to the function which does the collecting,
	// using the selection defined above
	pApp->m_pFreeTrans->DoCollectBacktranslations(pRec->bCollectedFromTargetText);

	// do cleanup housekeeping
	RemoveSelection();
	pApp->m_pActivePile = GetPile(nSaveActiveSequNum);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the end of the vertical edit step has been reached, so that an
///             event for transitioning to the next vertical edit step has been posted (in
///             other words, a PostMessage() has been done); FALSE if the step end has not
///             yet been reached
/// \param      nSequNum          -> the sequence number for the landing location that the
///                                  phrase box would want to stop at
/// \param      select            -> no matter where it is invoked from it will be one of
///                                  the enum values nextStep, previousStep, endNow, or
///                                  cancelAllSteps
/// \param      bForceTransition  -> default is FALSE; when FALSE the normal tests for
///                                  landing the box in the gray area are done, to see if
///                                  transition to the next step is required; when TRUE,
///                                  the transition is done unilaterally
/// \remarks
/// Called from: the View's OnButtonRetranslation(), OnButtonEditRetranslation(),
/// OnAdvanceButton(), OnNextButton(), OnButtonNextStep(), OnButtonPrevStep(),
/// CPhraseBox::JumpForward(), CPhraseBox::MoveToNextPile().
/// While vertical editing is in progress, this function checks for a landing location
/// (using the passed in nSequNum value) to see if it lies beyond the end bound for the
/// editable span for the current step; it so, then the appropriate custom event is posted
/// to cause transition to the next step.
/// As the user advances through the edit span, doing updates in either adaptationsStep,
/// glossesStep or freeTranslationsStep, control will eventually get to the end of the span
/// and the action for advancing to the next CSourcePhrase appropriate for that step will
/// take the phrase box into the gray text area. When that happens, we want to suppress
/// landing the phrase box in that context, and instead transition vertical edit mode to
/// whatever editing step is logically next. This function therefore checks for a landing
/// location (using the passed in nSequNum value) to see if it lies beyond the end bound
/// for the editable span for the current step; it so, then the appropriate custom event is
/// posted to cause transition to the next step. In some circumstandes it may be necessary
/// or expedient to force the transition, so that can be done by passing in TRUE for the
/// final parameter. Typical scenarios for that would be
/// 1. that the end of the document was reached without finding a landing location; or
/// 2. the function is invoked from the Vertical Edit control bar buttons - which force
///    transition without checking if the active location is beyond the edit span or not;
/// 3. bundle end has been reached in the search for a "hole" to jump to, in which case
///    this really means we've moved into the gray area, so TRUE would be appropriate.
/// BEW 22Feb10 no changes needed for support of doc version 5
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::VerticalEdit_CheckForEndRequiringTransition(int nSequNum,
							ActionSelector select, bool bForceTransition)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	EditRecord* pRec = &gEditRecord;
	if (bForceTransition)
	{
		switch (gEditStep)
		{
		case adaptationsStep:
			{
				switch (select)
				{
				case pleaseIgnore:
					return FALSE; // **TODO** eliminate this case,
								  // the return, and the enum value later on
				case nextStep:
					if (gbAdaptBeforeGloss)
					{
						wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					}
					else
					{
						wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					}
					return TRUE;
				case previousStep:
					if (gbAdaptBeforeGloss)
						::wxBell(); // cannot roll back to the edit source text
									// dialog, cancel is better
					else
					{
						wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					}
					return TRUE;
				case endNow:
					{
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					return TRUE;
					}
				case cancelAllSteps:
					{
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					return TRUE;
					}
				}
				break;
			}
		case glossesStep:
			{
				switch (select)
				{
				case pleaseIgnore:
					return FALSE; // **TODO** eliminate this case,
								  // the return, and the enum value later on
				case nextStep:
					if (gbAdaptBeforeGloss)
					{
						wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
										// the event handlers are in CMainFrame
					}
					else
					{
						wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
										// the event handlers are in CMainFrame
					}
					return TRUE;
				case previousStep:
					if (gbAdaptBeforeGloss)
					{
						wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
										// the event handlers are in CMainFrame
					}
					else
						::wxBell(); // cannot roll back to the edit source text
									// dialog, cancel is better
					return TRUE;
				case endNow:
					{
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					return TRUE;
					}
				case cancelAllSteps:
					{
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					return TRUE;
					}
				}
				break;
			}
		case freeTranslationsStep:
			{
				switch (select)
				{
				case pleaseIgnore:
					return FALSE; // **TODO** eliminate this case,
								  // the return, and the enum value later on
				case nextStep:
					{
						pApp->GetFreeTrans()->StoreFreeTranslationOnLeaving();
						wxCommandEvent eventCustom(wxEVT_Back_Translations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					return TRUE;
					}
				case previousStep:
					if (gbAdaptBeforeGloss)
					{
						wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					}
					else
					{
						wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					}
					return TRUE;
				case endNow:
					{
						pApp->GetFreeTrans()->StoreFreeTranslationOnLeaving();
						wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
					return TRUE;
					}
				case cancelAllSteps:
					{
						wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom);
									// the event handlers are in CMainFrame
						return TRUE;
					}
				}
				break;
			}
		default:
			{
				// control should never come here, but if it does,
				// make vertical edit mode end immediately
				wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
				wxPostEvent(pApp->GetMainFrame(), eventCustom);
							// the event handlers are in CMainFrame
			}
		}
		return TRUE;
	} // end block for test (bForceTransition == TRUE)

    // for the unforced case, make the tests for the landing location being in the gray
    // area; pleaseIgnore is not a valid option if control gets this far
	switch (gEditStep)
	{
	case adaptationsStep:
		if (nSequNum > pRec->nAdaptationStep_EndingSequNum)
		{
			switch (select)
			{
			case pleaseIgnore:
				return FALSE; // **TODO** eliminate this case,
							  // the return, and the enum value later on
			case nextStep:
				if (gbAdaptBeforeGloss)
				{
					wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
				}
				else
				{
					wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
				}
				return TRUE;
			case previousStep:
				if (gbAdaptBeforeGloss)
					::wxBell(); // cannot roll back to the edit source text
								// dialog, cancel is better
				else
				{
					// rollback to glossesStep
					wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
				}
				return TRUE;
			case endNow:
				{
					// end vertical edit immediately
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
					return TRUE;
				}
			case cancelAllSteps:
				{
					// cancel vertical edit (restores original state)
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
				return TRUE;
				}
			}
		}
		break;
	case glossesStep:
		if (nSequNum > pRec->nGlossStep_EndingSequNum)
		{
			switch (select)
			{
			case pleaseIgnore:
				return FALSE; // **TODO** eliminate this case,
							  // the return, and the enum value later on
			case nextStep:
				if (gbAdaptBeforeGloss)
				{
					wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
				}
				else
				{
					wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
				}
				return TRUE;
			case previousStep:
				if (gbAdaptBeforeGloss)
				{
					// rollback to adaptationsStep
					wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
							// the event handlers are in CMainFrame
				}
				else
					::wxBell(); // cannot roll back to the edit source text
								// dialog, cancel is better
				return TRUE;
			case endNow:
				{
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
					return TRUE;
				}
			case cancelAllSteps:
				{
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
					return TRUE;
				}
			}
		}
		break;
	case freeTranslationsStep:
		if (nSequNum > pRec->nFreeTranslationStep_EndingSequNum)
		{
			switch (select)
			{
			case pleaseIgnore:
				return FALSE; // **TODO** eliminate this case,
							  // the return, and the enum value later on
			case nextStep:
				{
					pApp->GetFreeTrans()->StoreFreeTranslationOnLeaving(); // may result in
							// re-storing an already stored f.t. but it's safety first
					wxCommandEvent eventCustom(wxEVT_Back_Translations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
					return TRUE;
				}
			case previousStep:
				if (gbAdaptBeforeGloss)
				{
					// rollback to glossesStep
					wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
				}
				else
				{
					// rollback to adaptationsStep
					wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
				}
				return TRUE;
			case endNow:
				{
					pApp->GetFreeTrans()->StoreFreeTranslationOnLeaving(); // may result in
							// re-storing an already stored f.t. but it's safety first
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
					return TRUE;
				}
			case cancelAllSteps:
				{
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom);
								// the event handlers are in CMainFrame
					return TRUE;
				}
			}
		}
		break;
	default:
		{
		// control should never come here, but if it does,
		// make vertical edit mode end immediately
		wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
		wxPostEvent(pApp->GetMainFrame(), eventCustom);
					// the event handlers are in CMainFrame
		}
	}
	return FALSE; // no PostMessage() has been done,
				  // so caller can just continue processing

    // we don't need a case for backTranslationsStep, because that is always the last step
    // and if it is entered, it unilaterally ends the vertical edit process when it
    // finishes and the user is never given a chance to do otherwise
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pRec				-> pointer to the global EditRecode struct, gEditRecord
/// \param      pNewSrcPhrasesList	-> a list of pointers to CSourcePhrase instances from
///                                    parsing the user's edited source text
/// \param      pSrcPhrases			-> pointer to the document' m_pSourcePhrases list being
///                                    edited
/// \param      nBeginAtSN			-> sequence number in m_pSourcePhrases list at which
///                                    transfer begins (inclusive)
/// \param      nFinishAtSN			-> sequence number in m_pSourcePhrases list at which
///                                    transfer finishes (inclusive)
/// \remarks
/// Called from:
/// Remove the now unwanted original edited span of CSourcePhrase instances. Insert their
/// replacements, (possibly zero), and tidy up various document parameters so that a
/// recalculation of the layout can be done in the caller on return. An important step,
/// done last, is to call the document function UpdateSequNumbers(0) to get all these
/// numbers into consecutive order. (If the user has deleted the whole editable span, then
/// nBeginAtSN and nFinishAtSN are the same and index the first CSourcePhrase instance of
/// the context following the editable span.)
/// BEW added 8May08 to support refactored Edit Source Text functionality
/// BEW 24Mar10, updated for support of doc version 5 (no changes needed)
/// BEW 9July10, no changes needed for support of kbVersion 2
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::TransferCompletedSrcPhrases(EditRecord* pRec,
									SPList* pNewSrcPhrasesList, SPList* pSrcPhrases,
									int nBeginAtSN, int nFinishAtSN)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pNewSrcPhrasesList);
	SPList::Node* posMain;
	SPList::Node* posNew;
	SPList* pMainList = pSrcPhrases;
	wxASSERT(pMainList != NULL);
	int nHowManyToDelete = nFinishAtSN - nBeginAtSN + 1;
	int nHowManyToInsert = pNewSrcPhrasesList->GetCount();
	int nExtras = nHowManyToInsert - nHowManyToDelete; // can be +ve, 0, or -ve

	int nBeginAt = nBeginAtSN; // this is the first one to be deleted and
							   // pointer removed from list
    // first delete the old instances from the m_pSourcePhrases list in the document
    SPList::Node* posSaved = NULL;
	int index;
	CSourcePhrase* pSP = NULL;
	posMain = pMainList->Item(nBeginAt);
	wxASSERT(posMain != 0);
	for (index = 0; index < nHowManyToDelete; index++)
	{
		posSaved = posMain;
		wxASSERT(posSaved);
		pSP = posMain->GetData();

		// first delete the partner pile
		pDoc->DeletePartnerPile(pSP);

		// now delete the CSourcePhrase instance
		posMain = posMain->GetNext();
		GetDocument()->DeleteSingleSrcPhrase(pSP);
		pMainList->DeleteNode(posSaved);
        // NOTE: this does **NOT** remove the deep copies which are in the
        // pRec->originalSrcPhraseList because that list must persist until the end of the
        // whole edit process, in case the user wants to Cancel out of the edit -- then
        // that list would be used to restore the original document state.
	}

	// user could have deleted the whole editable span, so allow for this possibility
	// - check here
	if (nHowManyToInsert == 0)
	{
		// do updates that are relevant, then return (in this block, nExtras will be -ve)
		if (pRec->nSaveActiveSequNum >= pRec->nStartingSequNum + nHowManyToInsert)
		{
			if (pApp->m_nActiveSequNum > pApp->GetMaxIndex())
			{
				// if the old active location is now out of bounds, decrease it
				pApp->m_nActiveSequNum += nExtras;
				pRec->nSaveActiveSequNum = pApp->m_nActiveSequNum;
			}
		}
		pDoc->UpdateSequNumbers(0); // update from the beginning of m_pSourcePhrases
		return;
	}

    // if we get here, there is at least one sourcephrase in the new list now insert the
    // new ones - distinguish doing so at the start of the doc versus somewhere within it
	posNew = pNewSrcPhrasesList->GetLast(); // insert in reverse order, to preserve order
	wxASSERT(posNew != 0);
	SPList::Node* posAt = NULL;
	if (nBeginAt == 0)
	{
		// insert at the document start
		posAt = pMainList->Item(0); // always the start // MFC uses FindIndex
		for (index = 0; index < nHowManyToInsert; index++)
		{
			if (posNew == NULL)
				break;
			pSP = posNew->GetData();
			pSP->m_nSequNumber = 0;

			posNew = posNew->GetPrevious();
			wxASSERT(pSP != NULL);
			posAt = pMainList->Insert(posAt, pSP);

			// create a partner pile for it -- it will be inserted at start of m_pileList
			// note: the pSP pointer has to have been inserted in m_pSourcePhrases list
			// before CreatePartnerPile() is called, to ensure correct final location of
			// the partner pile's pointer in m_pileList
			pDoc->CreatePartnerPile(pSP);
		}
		pDoc->UpdateSequNumbers(0); // update from the beginning of m_pSourcePhrases
	}
	else
	{
		// insert within the document (nBeginAt - 1 will not be negative)
		posAt = pMainList->Item(nBeginAt - 1); // always the start
		wxASSERT(posAt != NULL);
		for (index = 0; index < nHowManyToInsert; index++)
		{
			if (posNew == NULL)
				break;
			pSP = posNew->GetData();
			posNew = posNew->GetPrevious();
			wxASSERT(pSP != NULL);
			SPList::Node* newInsertBeforePos = posAt->GetNext();
			if (newInsertBeforePos == NULL)
				pMainList->Append(pSP);
			else
				pMainList->Insert(newInsertBeforePos,pSP);

            // create a partner pile for it -- it will be inserted before the Node* of
            // m_pileList as for the Node* of same index as in the m_pSourcePhrases list;
            // note: the pSP pointer has to have been inserted in m_pSourcePhrases list
            // before CreatePartnerPile() is called, to ensure correct final location of
            // the partner pile's pointer in m_pileList
			pDoc->CreatePartnerPile(pSP);
		}
	}
	// the main list is managing these pointers now, so RemoveAll on the list in pRec
	pNewSrcPhrasesList->Clear();

	pDoc->UpdateSequNumbers(0); // update from the beginning of m_pSourcePhrases

	// update the relevant parameters
	if (pRec->nSaveActiveSequNum >= pRec->nStartingSequNum + nHowManyToInsert)
	{
		if (pApp->m_nActiveSequNum > pApp->GetMaxIndex())
		{
			pApp->m_nActiveSequNum  = pRec->nStartingSequNum; // this is probably a
															  // better active loc
			pRec->nSaveActiveSequNum = pApp->m_nActiveSequNum;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If there are no source phrases in the App's
/// m_pSourcePhrases list this handler disables the "Export Source Text..." item on the
/// File menu, otherwise it enables the "Export Source Text..." item on the File menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExportSource(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// whm revised Revised 1Aug03; bw revised 15 April 2004 to derive the source data
// from the CSourcePhrase instances
void CAdapt_ItView::OnFileExportSource(wxCommandEvent& WXUNUSED(event))
{
	DoExportAsType(sourceTextExport); // BEW changed 21Jul2
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress, or if the application is in glossing mode this
/// handler disables the "Export Translation Text..." item in the File menu, otherwise it
/// enables the "Export Translation Text..." item on the File menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExport(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
	{
		if (gbIsGlossing)
			event.Enable(FALSE); // don't allow target text export when glossing
		else
			event.Enable(TRUE); // not glossing, so allow target text export
	}
	else
		event.Enable(FALSE); // nothing to export since doc is empty
}

void CAdapt_ItView::OnFileExport(wxCommandEvent& WXUNUSED(event))
{
	DoExportAsType(targetTextExport); // BEW changed 21Jul12
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If there are no source phrases in the App's
/// m_pSourcePhrases list, or glossing mode is not on, this handler disables the "Export
/// Glosses As Text..." item on the File menu, otherwise it enables the "Export Glosses As
/// Text..." item on the Export-Import menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateExportGlossesAsText(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// whm 14Aug09 modified test below to allow export of glosses whether or not
	// gbIsGlossing is true or false.
	if (pApp->m_pSourcePhrases->GetCount() > 0) // && gbIsGlossing)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// BEW created 6Aug09 to derive the a text formed by accumulating the contents of the
// m_gloss members with an intervening space betwen each, and adding the SF markers where
// appropriate, from the CSourcePhrase instances
void CAdapt_ItView::OnExportGlossesAsText(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	pApp->m_bExportingGlossesAsText = TRUE;   // set TRUE during export of glosses
	DoExportAsType(glossesTextExport); // BEW changed 21Jul12
	pApp->m_bExportingGlossesAsText = FALSE;   // restore default value
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If there are no source phrases in the App's
/// m_pSourcePhrases list, or free translations mode is on, this handler disables the
/// "Export Free Translation..." item on the File menu, otherwise it enables it
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateExportFreeTranslations(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// whm 14Aug09 modified test below to allow export of free translations whether or not
	// m_bFreeTranslationMode is true or false.
	if (pApp->m_pSourcePhrases->GetCount() > 0) // && !pApp->m_bFreeTranslationMode)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// BEW created 6Aug09 to derive the a text formed by accumulating the contents of the
// filtered free translation sections with an intervening space betwen each, and adding the
// SF markers where appropriate, from the CSourcePhrase instances
void CAdapt_ItView::OnExportFreeTranslations(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	pApp->m_bExportingFreeTranslation = TRUE; // set TRUE during export of free translations
	DoExportAsType(freeTransTextExport); // BEW changed 21Jul12
	pApp->m_bExportingFreeTranslation = FALSE; // restore default value
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "See Glossing" item on the Advanced menu is
/// enabled if the KBs are in a ready state, otherwise the menu item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedEnableglossing(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// we'll allow it to be toggled on or off provided a project is open; the two
	// kb flags being TRUE will be a sufficient test.
	if (pApp->m_bKBReady && pApp->m_bGlossingKBReady)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// BEW added 19Sep08 in support of mode changing within the vertical edit process
// BEW 26Mar10, no changes needed for support of doc version 5
// BEW 9July10, no changes needed for support of kbVersion 2
/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
/// TODO: Check if it makes sense for the caller of ToggleSeeGlossesMode() to actually call
/// this function when the current user workflow profile removes the Advanced menu's
/// "See Glosses" item, or the mode bar's "[] Glossing" checkbox
/// whm 30Aug11 Note: No need to switch between <no adaptation> and <no gloss> in
/// ToggelSeeGlossesMode() because it doesn't actually switch the app into "Is Glossing"
/// mode
void CAdapt_ItView::ToggleSeeGlossesMode()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		CMainFrame* pFrame;
		pFrame = pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxMenuBar* pMenuBar = pApp->GetMainFrame()->GetMenuBar();
		wxASSERT(pMenuBar != NULL);
		//wxMenuItem * pAdvancedFreeTranslation;
		//pAdvancedFreeTranslation = pMenuBar->FindItem(ID_ADVANCED_FREE_TRANSLATION_MODE);
		//wxASSERT(pAdvancedFreeTranslation != NULL);

		// get the checkbox pointer from the "Glossing" checkbox on the controlBar
		wxASSERT(pFrame->m_pControlBar != NULL);
		wxCheckBox* pCheckboxIsGlossing =
			(wxCheckBox*)pFrame->m_pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
		//wxASSERT(pCheckboxIsGlossing != NULL);

        // toggle the setting: note; whether going to or from glossing we will not change
        // the current values of gbGlossingUsesNavFont because the user might go back and
        // forwards from having glossing allowed or actually on (in the one session,) and
        // it would be a nuisance to have to manually restore this flag to its former
        // setting each time the user enables glossing again in the one session. (Leaving
        // the flag ON is benign when adapting.)
		wxMenuItem * pAdvancedSeeGlosses = pMenuBar->FindItem(ID_ADVANCED_SEE_GLOSSES);
		if (gbGlossingVisible)
		{
			// toggle the checkmark to OFF
			if (pAdvancedSeeGlosses != NULL)
			{
				pAdvancedSeeGlosses->Check(FALSE);
			}
			gbGlossingVisible = FALSE;
			gbIsGlossing = FALSE; // must be off whenever the other flag is off

			// hide the mode bar checkbox when glossing is not allowed to be visible
			// and when not visible it obligatorily must be adapting
			if (pCheckboxIsGlossing != NULL)
			{
				pCheckboxIsGlossing->SetValue(FALSE); // not glossing, ie. is adapting
				pCheckboxIsGlossing->Hide();
			}
		}
		else
		{
			// toggle the checkmark to ON
			if (pAdvancedSeeGlosses != NULL)
			{
				pAdvancedSeeGlosses->Check(TRUE);
			}
			gbGlossingVisible = TRUE;

            // show the mode bar checkbox when glossing is allowed to be visible
            // - user can then choose either to do glossing, or to do adapting
			if (pCheckboxIsGlossing != NULL)
			{
				pCheckboxIsGlossing->Show(TRUE);
			}
		}
	}
	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	CLayout* pLayout = GetLayout();
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}
}

/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
/// whm modified 30Aug111 to remove the label and jump
void CAdapt_ItView::OnAdvancedSeeGlosses(wxCommandEvent& event)
{

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	/*
	CSourcePhrase* pSrcPhrase;
	bool bOK;
	CSourcePhrase* pSaveSrcPhrase;
	int nSequNum;
	*/
	// whm Note: Only log user action when explicitly interacting with
	// the menu item, not when OnAdvancedEnablglossing() is called by
	// other functions.
	if (event.GetId() == ID_ADVANCED_SEE_GLOSSES)
	{
		if (gbGlossingVisible)
			pApp->LogUserAction(_T("See Glosses OFF"));
		else
			pApp->LogUserAction(_T("See Glosses ON"));
	}

	ShowGlosses();
	/*
	// save the current sequence number
	int nSaveSequNum = pApp->m_nActiveSequNum;

	// won't allow a selection to be preserved, this is too major a modality change
	if (pApp->m_selectionLine != -1)
		RemoveSelection();

    // before we redraw the layout and phrasebox, we have to save what is in the box
    // (provided it's contents are not abandonable or null text) in the appropriate KB,
    // then ready the pApp->m_targetPhrase member to have the correct text before
    // the layout is recalculated
	pApp->m_bSaveToKB = TRUE;

	if (pApp->m_pActivePile != NULL)
	{
		pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		if (gbIsGlossing) // flag has not been toggled yet
		{
			// we are changing from glossing to adapting, so we must store to the glossing
			// KB and then ready the pApp->m_targetPhrase member with the sourcephrase's
			// m_adaption contents and remove its refString from the adapting KB
			if (!(pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
			{
				// we can assume no errors for StoreTest call
				bOK = pApp->m_pGlossingKB->StoreText(pSrcPhrase,pApp->m_targetPhrase);
			}

			// if the active location is within a retranslation, we can't leave the box there
			// when we are in adapting mode, so if that is the case then find a safe location
			if (pSrcPhrase->m_bRetranslation)
			{
				pSaveSrcPhrase = pSrcPhrase;
				pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase); // try first for a location
															   // after retranslation section
				if (pSrcPhrase == NULL)
				{
					pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSrcPhrase);
				}
				// we assume (we won't test) one of the above Get... calls will succeed
				nSequNum = pSrcPhrase->m_nSequNumber;
				pApp->m_nActiveSequNum = nSaveSequNum = nSequNum;
				pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			}

			// now the adaptation stuff
			pApp->m_targetPhrase = pSrcPhrase->m_adaption; // get the adaptation text
			pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase, pApp->m_targetPhrase, useTargetPhraseForLookup);
		}
	}

	// get the Enable Glossing menu pointer
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedMenuSeeGlosses = pMenuBar->FindItem(ID_ADVANCED_SEE_GLOSSES);

	// get the checkbox pointer
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxCheckBox* pCheckboxIsGlossing =
				(wxCheckBox*)pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);

 	// whm 30Aug11 Note: We do not switch between "<no adaptation>" and "<no gloss>" here
 	// because the OnAdvancedSeeGlosses() does not actually switch the app into glossing
 	// mode. That is done in OnCheckIsGlossing() and ToggleGlossingMode().

	// toggle the setting: note; whether going to or from glossing we will not change the
    // current values of gbGlossingUsesNavFont because the user might go back and forwards
    // from having glossing allowed or actually on (in the one session,) and it would be a
    // nuisance to have to manually restore this flag to its former setting each time the
    // user enables glossing again in the one session. (Leaving the flag ON is benign when
    // adapting.)
	if (gbGlossingVisible)
	{
		// toggle the checkmark to OFF
		if (pAdvancedMenuSeeGlosses != NULL)
		{
			pAdvancedMenuSeeGlosses->Check(FALSE);
		}
		gbGlossingVisible = FALSE;
		gbIsGlossing = FALSE; // must be off whenever the other flag is off

		// hide the mode bar checkbox when glossing is not allowed to be visible
		// and when not visible it obligatorily must be adapting
		if (pCheckboxIsGlossing != NULL)
		{
			pCheckboxIsGlossing->SetValue(FALSE); // not glossing, ie. is adapting
			pCheckboxIsGlossing->Show(FALSE);
		}
	}
	else
	{
		// toggle the checkmark to ON
		if (pAdvancedMenuSeeGlosses != NULL)
		{
			pAdvancedMenuSeeGlosses->Check(TRUE);
		}
		gbGlossingVisible = TRUE;

		// show the mode bar checkbox when glossing is allowed to be visible - user can
		// then choose either to do glossing, or to do adapting
		if (pCheckboxIsGlossing != NULL)
		{
			pCheckboxIsGlossing->Show(TRUE);
		}
	}

	// redraw the layout etc.
	CLayout* pLayout = GetLayout();

	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);

	pApp->m_pTargetBox->m_bAbandonable = FALSE; // we assume the new contents are wanted

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
	Invalidate();
	GetLayout()->PlaceBox();
	*/
}

// BEW added 19Sep08, for support of mode transitions within vertical edit mode
// BEW 26Mar10, no changes needed for support of doc version 5
// BEW 9July10, no changes needed for support of kbVersion 2
// whm 30Aug11 modified to switch between "<no adaptation>" and "<no gloss>"
void CAdapt_ItView::ToggleGlossingMode()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		if (gbIsGlossing) // flag has not been toggled yet
		{
			// we are changing from glossing to adapting

			// get any removed adaptations in gEditRecord into the GUI list; but if the
			// mode current on is free translations mode, don't do so
			bool bAllsWell;
			if (!pApp->m_bFreeTranslationMode)
			{
				bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);
				bAllsWell = bAllsWell; // avoid warning (it can return FALSE, in which
									   // case the Combobox is empty - we can tolerate that)
			}
		}
		else
		{
			// we are changing from adapting to glossing

			// get any removed glosses in gEditRecord into the GUI list; but if the
			// mode current on is free translations mode, don't do so
			bool bAllsWell;
			if (!pApp->m_bFreeTranslationMode)
			{
				bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
				bAllsWell = bAllsWell; // avoid warning (it can return FALSE, in which
									   // case the Combobox is empty - we can tolerate that)
			}
		}

		// set the tick or clear the tick on the menu command
		CMainFrame* pFrame;
		pFrame = pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pControlBar != NULL);
		wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)
						pFrame->m_pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
 		wxButton* pNoAdaptationOrNoGloss = (wxButton*)pFrame->m_pControlBar->FindWindowById(IDC_BUTTON_NO_ADAPT);

		if (gbIsGlossing)
		{
			if (pCheckboxIsGlossing != NULL)
			{
				pCheckboxIsGlossing->SetValue(FALSE);
			}
			if (pNoAdaptationOrNoGloss != NULL)
			{
				pNoAdaptationOrNoGloss->SetLabel(_("<no adaptation>"));
			}
			gbIsGlossing = FALSE;
		}
		else
		{
			if (pCheckboxIsGlossing != NULL)
			{
				pCheckboxIsGlossing->SetValue(TRUE);
			}
			if (pNoAdaptationOrNoGloss != NULL)
			{
				pNoAdaptationOrNoGloss->SetLabel(_("<no gloss>"));
			}
			gbIsGlossing = TRUE;
		}
	}
}

void CAdapt_ItView::OnCheckIsGlossing(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CSourcePhrase* pSrcPhrase;
	bool bOK;
	CSourcePhrase* pSaveSrcPhrase;
	//CPile* pPile;
	int nSequNum;
	wxString str;

	// save the current sequence number
	int nSaveSequNum = pApp->m_nActiveSequNum;

	// won't allow a selection to be preserved, this is too major a modality change
	if (pApp->m_selectionLine != -1)
		RemoveSelection();

    // before we redraw the layout and phrasebox, we have to save what is in the box
    // (provided it's contents are not abandonable or null text) in the appropriate KB,
    // then ready the pApp->m_targetPhrase member to have the correct text before
    // RedrawEverything is called
	pApp->m_bSaveToKB = TRUE;

	// whm modified 30Aug11 to remove the a label jump
	if (pApp->m_pActivePile != NULL)
	{
		pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

		if (gbIsGlossing) // flag has not been toggled yet
		{
			// we are changing from glossing to adapting, so we must store to the glossing KB
			// and then ready the pApp->m_targetPhrase member with the sourcephrase's
			// m_adaption contents and remove its refString from the adapting KB; and if the
			// box is within a retranslation then we need to find a safe location for it as
			// close as possible
			if (!(pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
			{
				// BEW 13Nov10, gbRemovePunctuationFromGlosses is nowhere set TRUE, so remove
				//if (gbRemovePunctuationFromGlosses)
				//	RemovePunctuation(GetDocument(),&pApp->m_targetPhrase,from_target_text);
				bOK = pApp->m_pGlossingKB->StoreText(pSrcPhrase,pApp->m_targetPhrase);
				bOK = bOK; // avoid warning
			}

			// now the adaptation stuff
			gbIsGlossing = FALSE; // so RemoveRefString will get the adaptation KB
									// but it also gives us the toggle we need too

			// if the active location is within a retranslation, we can't leave the box there
			// when we are in adapting mode, so if that is the case then find a safe location
			if (pSrcPhrase->m_bRetranslation)
			{
				pSaveSrcPhrase = pSrcPhrase;
				pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase); // try first for a
															   // location after retrans
				if (pSrcPhrase == NULL)
				{
					pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSrcPhrase);
				}
				// we assume (we won't test) one of the above Get... calls will succeed
				nSequNum = pSrcPhrase->m_nSequNumber;
				pApp->m_nActiveSequNum = nSaveSequNum = nSequNum;
				pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			}

			pApp->m_targetPhrase = pSrcPhrase->m_adaption; // get the adaptation text
			if (pSrcPhrase->m_bNotInKB)
			{
				pApp->m_bSaveToKB = FALSE;
				pSrcPhrase->m_bHasKBEntry = FALSE;
				pApp->m_bForceAsk = FALSE;
			}
			else // it's a normal type of entry, so can be in the KB
			{
				pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase,
										pApp->m_targetPhrase, useTargetPhraseForLookup);
			}

			// get any removed adaptations in gEditRecord into the GUI list; but if the
			// mode current on is free translations mode, don't do so
			bool bAllsWell;
			if (!pApp->m_bFreeTranslationMode)
			{
				bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);
				bAllsWell = bAllsWell; // avoid warning (it can return FALSE, in which
									   // case the Combobox is empty - we can tolerate that)
			}
		}
		else
		{
			// we are changing from adapting to glossing, so we must store to the adaptation
			// KB and then ready the pApp->m_targetPhrase member with the sourcephrase's
			// m_gloss contents and remove its refString from the glossing KB; but if it is
			// a "not in kb" entry, then don't store, but just set up pApp->m_targetPhrase
			if (pSrcPhrase->m_bNotInKB)
			{
				str = pApp->m_targetPhrase;
				RemovePunctuation(GetDocument(),&str,from_target_text);
				pSrcPhrase->m_adaption = str;
				MakeTargetStringIncludingPunctuation(pSrcPhrase,pApp->m_targetPhrase);
				pApp->m_bSaveToKB = FALSE;
				pSrcPhrase->m_bHasKBEntry = FALSE;
				pApp->m_bForceAsk = FALSE;
			}
			else
			{
				if (!( pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
				{
					str = pApp->m_targetPhrase;
					RemovePunctuation(GetDocument(),&str,from_target_text);
					pSrcPhrase->m_adaption = str;
					MakeTargetStringIncludingPunctuation(pSrcPhrase,pApp->m_targetPhrase);
					bOK = pApp->m_pKB->StoreText(pSrcPhrase,str);
				}
			}
			// now the glossing stuff
			pApp->m_targetPhrase = pSrcPhrase->m_gloss; // get the gloss text
			gbIsGlossing = TRUE; // so GetRefString( ) will get the glossing KB
								 // but it also gives us the needed toggle too
			pApp->m_pGlossingKB->GetAndRemoveRefString(pSrcPhrase, pApp->m_targetPhrase,
														useTargetPhraseForLookup);

			// get any removed glosses in gEditRecord into the GUI list; but if the
			// mode current on is free translations mode, don't do so
			bool bAllsWell;
			if (!pApp->m_bFreeTranslationMode)
			{
				bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
				bAllsWell = bAllsWell; // avoid warning (it can return FALSE, in which
									   // case the Combobox is empty - we can tolerate that)
			}
		}
	}

	// set the tick or clear the tick on the menu command
	// whm 30Aug11 modified to switch the controlbar button betweeen <no adaptation> and <no gloss>
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)
						pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
	//wxASSERT(pCheckboxIsGlossing != NULL);

	wxButton* pNoAdaptationOrNoGloss = (wxButton*)pControlBar->FindWindowById(IDC_BUTTON_NO_ADAPT);
	//wxASSERT(pNoAdaptationOrNoGloss != NULL);

	if (gbIsGlossing)
	{
		if (pCheckboxIsGlossing != NULL)
		{
			pCheckboxIsGlossing->SetValue(TRUE);
		}
		if (pNoAdaptationOrNoGloss != NULL)
		{
			pNoAdaptationOrNoGloss->SetLabel(_("<no gloss>"));
		}
	}
	else
	{
		if (pCheckboxIsGlossing != NULL)
		{
			pCheckboxIsGlossing->SetValue(FALSE);
		}
		if (pNoAdaptationOrNoGloss != NULL)
		{
			pNoAdaptationOrNoGloss->SetLabel(_("<no adaptation>"));
		}
	}

	// is the document open? If not, return here
	if (pApp->m_pSourcePhrases->IsEmpty())
	{
		return;
	}

    // redraw the layout etc. (Must do it after the flag is toggled, otherwise
    // RecalcLayout( ) will think that the untoggled setting is still in effect
    // and lay the pile out wrong)
	CLayout* pLayout = GetLayout();

	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}

#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);
	pApp->m_pTargetBox->m_bAbandonable = FALSE; // we assume the new
												// contents are wanted
	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
	Invalidate();
	GetLayout()->PlaceBox();
}

/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
void CAdapt_ItView::OnAdvancedGlossingUsesNavFont(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedGlossingUsesNavFont =
						pMenuBar->FindItem(ID_ADVANCED_GLOSSING_USES_NAV_FONT);
	//wxASSERT(pAdvancedGlossingUsesNavFont != NULL);

	// toggle the setting & update the display accordingly
	if (gbGlossingUsesNavFont)
	{
		// toggle the checkmark to OFF & recalc the layout with glossing using target font
		if (pAdvancedGlossingUsesNavFont != NULL)
		{
			pApp->LogUserAction(_T("Glossing Uses Nav Text Font OFF"));
			pAdvancedGlossingUsesNavFont->Check(FALSE);
		}
		gbGlossingUsesNavFont = FALSE;
	}
	else
	{
		// toggle the checkmark to ON, and recalc the layout with glossing using the
		// navText font
		if (pAdvancedGlossingUsesNavFont != NULL)
		{
			pApp->LogUserAction(_T("Glossing Uses Nav Text Font ON"));
			pAdvancedGlossingUsesNavFont->Check(TRUE);
		}
		gbGlossingUsesNavFont = TRUE;
	}

	// redraw everything with the other Font and directionality setting
	CLayout* pLayout = GetLayout();

	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
        // set the colour to the navText's colour, and also set its size to that of the
        // target text's font (the user may have navText smaller in the view in order to
        // keep it unobtrusive, but we don't want it unobtrusive in the phrase box!)
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
		/*
		// BEW 12Jun09, regretably the next 3 lines are not enough to do the job, because
		// the navText height setting is still unchanged and if I increase that, it will
		// increase it in the navigation text whiteboard area too, and that throws even
		// more stuff out of kilter.
		//                                     *** TODO *** someday
        // -- a proper solution would be to define a further dedicated
        // m_pNavTextAtTgtSizeFont wxFont object, and in CLayout have a bool
        // m_bGlossingUsesNavTextFontAtTargetSize member, which is TRUE when glossing and
        // user has chosen the Glossing Uses Nav Text Font menu item, and which is FALSE
        // when that menu item is off; and have the layout code use whichever wxFont member
        // is appropriate given the context
		int pointSize = 12;
		pointSize = pApp->m_pTargetFont->GetPointSize();
		pApp->m_pNavTextFont->SetPointSize(pointSize);
		*/
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}

#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_update_pile_widths);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);

	Invalidate();
	GetLayout()->PlaceBox(); // this call probably unneeded but no harm done
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Glossing Uses Navigation Text's Font" item on
/// the Advanced menu is enabled if the gbGlossingVisible global is TRUE, otherwise the menu
/// item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedGlossingUsesNavFont(wxUpdateUIEvent& event)
{
	if (gbGlossingVisible)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// Called by the application class's DoTransformationsToGlosses( ) function. pSrcPhrase
// points to a source phrase on the heap, and the source phrase belongs to the list of
// m_pSourcePhrases (but are loaded from another project) currently being transformed. When
// all such belonging to the current document are transformed, the document is resaved but
// as a document belonging to the current project. The latter fact allows us to simply
// transform each CSourcePhrase instance that is on the heap, rather than doing the changes
// on copies.
// The transformations ALWAYS take the m_adaption member and transform it, never the
// m_srcPhrase member since the latter may contain unwanted punctuation. If the
// CSourcePhrase needs to be removed by the caller, return TRUE; placeholder CSourcePhrase
// instances are an example of such. The current and next iterator positions are passed in,
// in case the function needs to access the previous, current or next sourcephrase entry in
// the list
// BEW ammended 30Aug05 to bring it into line with version 3; note, m_markers etc content
// is untouched and so the transformation process preserves filtering, notes, free
// translations, and the like
// BEW addition 05Jan06 except when m_markers containing a note was moved leftwards by
// right association to a placeholder (pSrcPhrase) in which case we must move it back to
// the CSourcePhrase which follows the placeholder
// BEW changes 2July10, handle mergers better by converting the CSourcePhrase instances in
// the m_pSavedWords list also; we also changed the protocols so that retranslations and
// placeholders (whether in retranslations or not) are retained, but the adaptations are
// made into glosses for these. Glossing mode can sustain placeholders entered into the
// document earlier in a different mode, so this decision does not impinge on robustness
// BEW 11Oct10, changed to support extra doc version 5 CSourcePhrase members, and handling
// of USFM fixedspace marker ~ adequately
bool CAdapt_ItView::TransformSourcePhraseAdaptationsToGlosses(CAdapt_ItApp* pApp,
			SPList::Node* curPos, SPList::Node* nextPos, CSourcePhrase* pSrcPhrase)
{
	// BEW 2Julyl10, changes herein render the nextPos and curPos parameters unused, so
	// we'll do identity assignments to avoid compiler warnings. We retain the parameters
	// for the present in case we later decide to restore legacy code in part or whole
	curPos = curPos;
	nextPos = nextPos;

    // <Not In KB> instances are changed to normal instances, and if there is an adaptation
    // then make it the gloss, but if not then it is assumed to be not in the glossing KB

    // Start with checking for any <Not In KB> entries; which are not within
    // retranslations; our transform of the adapting KB simply ignored any entries marked
    // "<Not In KB>" because we could not transform those because there was no adaptation
    // information present -- that means we had to defer handling those until now, when we
    // transform the documents' entries. So we look for any with m_bNotInKB set true, and
    // get the adaptation string and here call StoreText() in order to make them normal
    // glossing KB entries. We also pass TRUE as the second parameter of the StoreTextIO
    // call to force any empty string adaptations to be stored as empty strings in the
    // glossing KB, for these entries.
	if (pSrcPhrase->m_bNotInKB && !pSrcPhrase->m_bRetranslation)
	{
		pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
		pSrcPhrase->m_adaption.Empty( );
		pSrcPhrase->m_targetStr.Empty();

		pSrcPhrase->m_bNotInKB = FALSE;
		pSrcPhrase->m_bNullSourcePhrase = FALSE;
		pSrcPhrase->m_bHasKBEntry = FALSE;
		pSrcPhrase->m_bHasGlossingKBEntry = TRUE;

		pApp->m_pGlossingKB->StoreText(pSrcPhrase, pSrcPhrase->m_gloss, TRUE);

		return FALSE; // we are done with this one, but don't remove it
	}

    // Legacy behaviour: any null sourcephrase instances have to be removed, whether in a
    // retranslation or not, but first we need to check if punctuation was moved from a
    // neighbouring sourcephrase instance, and it so, move it back there
	// BEW changed 2July10 - throwing away placeholders is not what we want to do,
	// instead, we'll retain them, and make the adaptation into glosses as per normal,
	// since glossing mode can sustain placeholders already put into the doc in adapting
	// mode, it's just that glossing mode doesn't allow their creation, so we now don't
	// tell the caller to remove these, and we retain any retranslation, but do the
	// transforms for the data
	if (pSrcPhrase->m_bNullSourcePhrase)
	{
        // Legacy comment: content can differ depending on whether the null source phrase
        // is part of a retranslation or not. If it is, then no transfers of punctuation
        // will have been done, and we can just throw the null source phrase away; but if
        // it is not then it may be the case that punctuation was moved on to it, so we
        // have to do more tests and move the punctuation back if it was moved, then
        // indicate that the caller must remove the null source phrase
		// BEW 2July10, if we now keep the placeholders, we no longer have to bother about
		// moving any punctuation
		if (pSrcPhrase->m_bRetranslation)
		{
            // Legacy comment: it is part of a retranslation, so we can abandon it (note:
            // boundary flag settings are not moved when a retranslation is padded with
            // nulls, so we don't have to worry about restoring a boundary when we delete
            // the null source phrase in a retranslation) retranslations, when they accept
            // null sourcephrase padding, only fiddle with the m_bRetranslation and
            // m_bNotInKB flag values, nothing else is affected.
            // BEW changed 30Aug05 -- but in version 3 we have to consider the possibility
            // that the last placeholder may be a free translation end (which was moved to
            // the last inserted placeholder) and move it back to where it was originally
			//
			// BEW changed 2July10, we now retain placeholders in a retranslation, and we
			// retain the retranslation too
			pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
			pSrcPhrase->m_adaption.Empty();
			pSrcPhrase->m_targetStr.Empty();
			pSrcPhrase->m_bNotInKB = TRUE;
			pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // retranslations are not in the KB
										// so no entry will be in the glossingKB & we
										// won't call StoreText() to put one in for any
										// placeholder within a retranslation; but the
										// document can show nonempty glosses & indeed, it
										// should do so because the former adaptations for
										// these placeholders were 'real' translations
			return FALSE; // don't remove it
			/* legacy code
			if (pSrcPhrase->m_bEndFreeTrans)
			{
				// move it back to the last non-placeholder sourcephrase
				SPList::Node* prevPos = curPos;
				CSourcePhrase* pPrevSrcPhrase = (CSourcePhrase*)prevPos->GetData();
				prevPos = prevPos->GetPrevious();
				wxASSERT(pPrevSrcPhrase != NULL);
				pPrevSrcPhrase->m_bEndFreeTrans = TRUE;
			}
			return TRUE; //  remove now
			*/
		}
		else
		{
            // Legacy comment: it is not part of a retranslation, so do the extra checks
            // related to punctuation... first, get the the previous source phrase, if it
            // exists, in case we need it
			// BEW 2July10, all of the legacy code here becomes redundant by the choice to
			// retain placeholders - so we can comment it out, and just do the required
			// data transformation, & a StoreText() call to have it go into the glossing KB
			//
			// BEW 11Oct10, we have to handle word1~word2 conjoining - here is a suitable
			// place. Such conjoinings are a pseudo merger, so we just transform
			// m_adaptation into m_gloss for the parent (single) instance, pSrcPhrase, and
			// similarly for the embedded pair, and do the store to the glossing KB
			if (IsFixedSpaceSymbolWithin(pSrcPhrase))
			{
				pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
				pSrcPhrase->m_adaption.Empty();
				pSrcPhrase->m_targetStr.Empty();
				pSrcPhrase->m_bHasGlossingKBEntry = FALSE;

				SPList::Node* pos1 = pSrcPhrase->m_pSavedWords->GetFirst();
				SPList::Node* pos2 = pSrcPhrase->m_pSavedWords->GetLast();
				CSourcePhrase* pWd1SP = pos1->GetData();
				CSourcePhrase* pWd2SP = pos2->GetData();
				pWd1SP->m_gloss = pWd1SP->m_adaption;
				pWd1SP->m_adaption.Empty();
				pWd1SP->m_targetStr.Empty();
				pWd1SP->m_bHasGlossingKBEntry = FALSE;
				pWd2SP->m_gloss = pWd1SP->m_adaption;
				pWd2SP->m_adaption.Empty();
				pWd2SP->m_targetStr.Empty();
				pWd2SP->m_bHasGlossingKBEntry = FALSE;
			}
			else
			{
				pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
				pSrcPhrase->m_adaption.Empty();
				pSrcPhrase->m_targetStr.Empty();
				pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
			}
            // bSupportNoAdaptationButton is default FALSE in the next call because we
            // assume nobody would, in adaptation mode, have a placeholder inserted only to
            // leave it's adaptation empty, so if it was left empty we assume it was a user
            // mistake and we'll just here refrain from saving to KB
			pApp->m_pGlossingKB->StoreText(pSrcPhrase, pSrcPhrase->m_gloss);
			return FALSE;

		} // end block for null source phrase not a part of a retranslation
	} // end block for null source phrases

    // Legacy comment: now we have to check for retranslation sourcephrases which are not
    // placeholders - these have no KB presence, so all we can do is leave the m_gloss
    // member empty under the transform operation
	// BEW changed 2July10, since we now retain retranslations and placeholders, we do the
	// minimal set of data transforms here
	if (pSrcPhrase->m_bRetranslation)
	{
		pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
		//pSrcPhrase->m_gloss.Empty();
		pSrcPhrase->m_adaption.Empty();
		pSrcPhrase->m_targetStr.Empty();
		pSrcPhrase->m_bHasKBEntry = FALSE;
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
		pSrcPhrase->m_bNotInKB = TRUE;
		//pSrcPhrase->m_bNotInKB = FALSE;
		//pSrcPhrase->m_bRetranslation = FALSE;
		//pSrcPhrase->m_bBeginRetranslation = FALSE;
		//pSrcPhrase->m_bEndRetranslation = FALSE;
		return FALSE; // don't remove this one
	}

	// Legacy comment: anything else is normal srcphrase and just do the
	// transformations required
	// BEW changed 2July10, we add code here for transforming the CSourcePhrase instances
	// within the m_pSavedWords list member of a merger too, in case the user of the new
	// transformed project decides to unmerge the merger, we'll want him to see glosses,
	// not adaptations untransformed
	pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
	pSrcPhrase->m_adaption.Empty();
	pSrcPhrase->m_targetStr.Empty();
	pSrcPhrase->m_bHasKBEntry = FALSE;
	pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
	if (pSrcPhrase->m_nSrcWords > 1)
	{
		// we have a merger, so process m_pSavedWords too
		SPList* pOriginals = pSrcPhrase->m_pSavedWords;
		wxASSERT(!pOriginals->IsEmpty());
		SPList::Node* pos = pOriginals->GetFirst();
		while (pos != NULL)
		{
			CSourcePhrase* pSPhr = pos->GetData();
			wxASSERT(pSPhr);
			pos = pos->GetNext();
            // the transformations for these are simple; however as we can't be certain the
            // originals were formerly adapted and had presence in the KB, we'll examine
            // their flags and if m_bHasKBEntry is TRUE, we'll set m_bHasGlossingKBEntry to
            // TRUE (provided the adaptation string was non-empty), otherwise we won't
			pSPhr->m_gloss = pSPhr->m_adaption; // could be an empty string
			pSPhr->m_adaption.Empty();
			pSPhr->m_targetStr.Empty();
			if (pSPhr->m_bHasKBEntry)
			{
				if (pSPhr->m_gloss.IsEmpty())
				{
					pSPhr->m_bHasGlossingKBEntry = FALSE;
				}
				else
				{
					pSPhr->m_bHasGlossingKBEntry = TRUE;
				}
			}
			else
			{
				pSPhr->m_bHasGlossingKBEntry = FALSE;
			}
			pSPhr->m_bHasKBEntry = FALSE;
		}
	}
	return FALSE; // don't delete this one
}

// added by Bill Martin 1June2003
void CAdapt_ItView::OnFileExportToRtf(wxCommandEvent& WXUNUSED(event))
{
	DoExportInterlinearRTF(); // now located in ExportFunctions.cpp and .h
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If there are no source phrases in the App's
/// m_pSourcePhrases list this handler disables the "Export Interlinear Text..." item on
/// the File menu, otherwise it enables the "Export Interlinear Text..." item on the File
/// menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExportToRtf(wxUpdateUIEvent& event)
{
	// added by Bill Martin 1June2003
	// make sure there are some CSourcePhrase instances to work with
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAdvancedDelay(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	pApp->LogUserAction(_T("Initiated OnAdvancedDelay()"));
	/*
	// test SyncScrollReceive() code here (delay is unrelated, just use its button)
	wxString strValue = _T("1JN 2:19");
	wxString strThreeLetterBook;
	wxString strChapVerse;
	int nChapter;
	int nVerse;
	ExtractScriptureReferenceParticulars(strValue,strThreeLetterBook,
										strChapVerse,nChapter,nVerse);
	bool bSuccess;
	bSuccess = SyncScrollReceive(strThreeLetterBook, nChapter,
								nVerse, strChapVerse);
	// end of code test
	*/
	CSetDelay dlg(pApp->GetMainFrame());

	dlg.m_nDelay = pApp->m_nCurDelay;

	if (dlg.ShowModal() == wxID_OK)
	{
		pApp->m_nCurDelay = dlg.m_nDelay;

		// update the copy shown on mode bar (it's read only there)
		CMainFrame* pMainFrame = pApp->GetMainFrame();
		wxASSERT(pMainFrame);
		wxPanel* pControlBar = pMainFrame->m_pControlBar;
		wxASSERT(pControlBar);
		wxTextCtrl* pDelayBox = (wxTextCtrl*)pControlBar->FindWindowById(IDC_EDIT_DELAY);
		// whm 12Oct10 modified to be safe for user profile hiding
		if (pDelayBox != NULL)
		{
			wxString s;
			s.Empty();
			s << dlg.m_nDelay; //s = buf;
			pDelayBox->SetValue(s);
		}
		pControlBar->Refresh();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Delay..." item on the Advanced menu is disabled
/// if the application is in Free Translation mode, but enabled if the KB is in a ready
/// state.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedDelay(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bKBReady)
	{
		event.Enable(TRUE); // always enabled if a project is active
	}
}

/////////////////////////////////////////////////////////////////////////////////
///
/// Free translation support moved to FreeTrans.h/.cpp
///
/////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////
// moved back translation support to CFreeTrans for the present

// GetPrevMarker, HaltCurrentCollection, InsertCollectedBackTranslation,
// DoCollectedBackTranslations, WhichMarker, OnAdvancedRemoveFilteredBackTranslations
// moved to CFreeTrans





/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// The "SIL Converters..." item on the Edit menu is enabled on a Windows port if the
/// ECDriver.dll is loaded and SIL Converters is installed on the local machine,
/// otherwise the menu item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateSelectSilConverters(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
    
	// whm added 26Mar12.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	// Only enable the SILConverters menu item if we're building for SIL Converters
    // and SIL Converters is installed on the local machine.
	if (!pApp->bECDriverDLLLoaded)
	{
		event.Enable(FALSE);
		return;
	}
#ifdef USE_SIL_CONVERTERS
	// whm added 30Dec08 for SIL Converters support
	typedef int (wxSTDCALL *wxECIsInstalledType)();
	wxECIsInstalledType pfnECisInstalled = (wxECIsInstalledType)NULL;
    // whm Note: The IsEcInstalled() function in ECDriver.dll does not have
    // A and W forms so we must call GetSymbol() instead of GetSymbolAorW() here.
	pfnECisInstalled = (wxECIsInstalledType)
					ecDriverDynamicLibrary.GetSymbol(FUNC_NAME_EC_IS_INSTALLED);

	event.Enable(pfnECisInstalled != NULL && pfnECisInstalled() == TRUE);
#else
	event.Enable(FALSE); // don't enable the menu item if we're not using SIL Converters
#endif
}

/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
void CAdapt_ItView::OnSelectSilConverters(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	
	pApp->LogUserAction(_T("Initiated OnSelectSilConverters()"));
	// bring up the SilConverter select dialog to allow
    // the user to pick a converter
    CSilConverterSelectDlg dlg
    (
    pApp->m_strSilEncConverterName,
    pApp->m_bSilConverterDirForward,
    pApp->m_eSilConverterNormalizeOutput,
    pApp->GetMainFrame()
    );

    if( dlg.ShowModal() == wxID_OK )
    {
        // save these values in the app, so they get written to the
        //project settings file (i.e. to be retentive across program launches)
        pApp->m_strSilEncConverterName = dlg.ConverterName;
		if (dlg.DirectionForward == 0)
			pApp->m_bSilConverterDirForward = FALSE;
		else
			pApp->m_bSilConverterDirForward = TRUE;
        pApp->m_eSilConverterNormalizeOutput = dlg.NormalizeOutput;

        // if no converter configured, then turn off the 'use' if it was on
        // (NOTE: this is the equivalent of "Unload")
        if( dlg.ConverterName.IsEmpty() )
        {
	        CMainFrame *pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame != NULL);
			wxMenuBar* pMenuBar = pFrame->GetMenuBar();
			wxASSERT(pMenuBar != NULL);
			wxMenuItem * pToolsMenuUseSilConverter =
									pMenuBar->FindItem(ID_USE_SILCONVERTER);
			//wxASSERT(pToolsMenuUseSilConverter != NULL);

		    // toggle the checkmark to OFF
		    if (pToolsMenuUseSilConverter != NULL)
			{
				pToolsMenuUseSilConverter->Check(FALSE);
			}
		    pApp->m_bUseSilConverter = FALSE;
			pApp->LogUserAction(_T("No Sil Converter name entered"));
			return;
        }
        else if( pApp->m_bUseSilConverter )
        {
            // otherwise, if it *was* being used before, then reset it now
            // (to trigger the not-in-use check below (which in turn triggers
            // the reevaluation of the source word))
            OnUseSilConverter(event);
        }

        // if it isn't on, then make it on. This causes the current word to
        // be re-run thru the converter
        if( !pApp->m_bUseSilConverter )
        {
            OnUseSilConverter(event);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the input str after it is modified by the
///             action of the SIL Converter; or a null/empty str if str was initially
///             empty or if the SILConverter could not be found
/// \param      str     -> the wxString to be processed by an SIL Converter
/// \remarks
/// Called from: the View's CopySourceKey() and DoTargetBoxPaste() functions.
/// Calls the configured SilConverter to pre-process the data and return the result to
/// the caller. First, DoSilConvert() sets up a function pointer to use in accessing the
/// appropriate form of the EncConverterInitializeConverter() function in the external
/// ECDriver.dll. It calls that function and returns an empty string if the converter
/// initialization fails, otherwise the function proceeds to set up a function pointer to
/// use in accessing the appropriate form of the EncConverterConvertString() function in
/// ECDriver.dll. If calls that function to process the input string str by the external
/// SIL Converter; then returns the result. If the str input string was originally a null
/// string, DoSilConvert() simply returns a null string.
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::DoSilConvert(const wxString& str)
{
#ifdef USE_SIL_CONVERTERS
	CAdapt_ItApp* pApp = &wxGetApp();
	// whm added 30Dec08 for SIL Converters support
	typedef int (wxSTDCALL *wxECInitConverterType)(const wxChar*,int,int);
	wxECInitConverterType pfnECInitializeConverterAorW = (wxECInitConverterType)NULL;
	// whm Note: The EncConverterInitializeConverter() function in ECDriver.dll only
	// has A and W forms so we must call GetSymbolAorW() instead of GetSymbol() here.
	pfnECInitializeConverterAorW = (wxECInitConverterType)
		ecDriverDynamicLibrary.GetSymbolAorW(FUNC_NAME_EC_INITIALIZE_CONVERTER_AW);

	if (!pApp->m_bECConnected && pfnECInitializeConverterAorW != NULL)
        pApp->m_bECConnected = (pfnECInitializeConverterAorW(pApp->m_strSilEncConverterName,
			pApp->m_bSilConverterDirForward, pApp->m_eSilConverterNormalizeOutput) == S_OK);

	if (!pApp->m_bECConnected)
		return _T("");

    // whm Note: I assume Bob's EncConverterConvertString() function is internally limited
    // to a 1000 TCHAR length. Therefore I've made a local copy of the incoming string
    // "str" and check its length, and truncate if at 1000 char if it happens to exceed
    // that length - to avoid any buffer overrun problems.
	wxString tempStr = str;
	if (tempStr.Length() > 1000)
		tempStr.Mid(0,1000);

	// whm added 30Dec08 for SIL Converters support
	typedef int (wxSTDCALL *wxECConvertStringType)(const wxChar*,const wxChar*,
													wxChar*,int);
	wxECConvertStringType pfnECConvertStringAorW = (wxECConvertStringType)NULL;
	// whm Note: The EncConverterConvertString() function in ECDriver.dll only has
	// A and W forms so we must call GetSymbolAorW() instead of GetSymbol() here.
	pfnECConvertStringAorW = (wxECConvertStringType)
		ecDriverDynamicLibrary.GetSymbolAorW(FUNC_NAME_EC_CONVERT_STRING_AW);

	TCHAR szOutput[1001];
	szOutput[0] = NULL; // whm added
	if (pfnECConvertStringAorW != NULL)
		pfnECConvertStringAorW(pApp->m_strSilEncConverterName, tempStr, szOutput, 1000);
	return szOutput;
#else
	int strLen;
	strLen = str.Length(); // avoid warnings
	strLen = strLen; // avoid warning
	return _T("");
#endif // end of if USE_SIL_CONVERTERS
}

/// whm modified 21Sep10 to make safe for when selected user profile removes this menu item.
void CAdapt_ItView::OnAdvancedUseTransliterationMode(wxCommandEvent& event)
{
	// toggle the mode on or off
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);

	// whm Note: Only log when the even comes from the menu item, not
	// when OnAdvancedUseTransliterationMode() is called from the View's
	// OnInitialUpdate()
	if (event.GetId() == ID_ADVANCED_USETRANSLITERATIONMODE)
	{
		if (pApp->m_bTransliterationMode)
			pApp->LogUserAction(_T("Use Transliteration Mode OFF"));
		else
			pApp->LogUserAction(_T("Use Transliteration Mode ON"));
	}

	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuUseUseTransLMode =
						pMenuBar->FindItem(ID_ADVANCED_USETRANSLITERATIONMODE);

	if (pApp->m_bTransliterationMode)
	{
		// toggle the checkmark to OFF
		if (pToolsMenuUseUseTransLMode != NULL)
		{
			pToolsMenuUseUseTransLMode->Check(FALSE);
		}
		pApp->m_bTransliterationMode  = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		if (pToolsMenuUseUseTransLMode != NULL)
		{
			pToolsMenuUseUseTransLMode->Check(TRUE);
		}
		pApp->m_bTransliterationMode = TRUE;
	}

	// update status bar information
	pApp->RefreshStatusBarInfo();

	// restore focus to the phrase box (free translations cannot be on for this mode)
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced
///                        Menu is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// The "Use Transliteration Mode" item on the Advanced menu is disabled if any of the
/// following conditions are TRUE: the build/port does not support SIL Converters, the KB
/// is not ready, there are no source phrases in the App's m_pSourcePhrases list, the
/// application is in free translation mode or glossing mode. Otherwise, if the
/// m_strSilEncConverterName string has a name loaded, the menu item is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedUseTransliterationMode(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// whm added 26Mar12.
	if (pApp->m_bReadOnlyAccess)
	{
		event.Enable(FALSE);
		return;
	}

	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
#ifdef USE_SIL_CONVERTERS
	// toggle the mode on or off
    // whm 15Aug06 added && !pApp->m_strSilEncConverterName.IsEmpty() condition
    // to disable the menu item unless a SIL converter is loaded
	if (pApp->m_bKBReady && pApp->m_pSourcePhrases->GetCount() > 0 &&
		!pApp->m_bFreeTranslationMode && !gbIsGlossing &&
		!pApp->m_strSilEncConverterName.IsEmpty()) // whm 15Aug06 added
						// the !pApp->m_strSilEncConverterName.IsEmpty() condition
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
#else
	event.Enable(FALSE); // don't enable the menu item if
						 // we're not using SIL Converters
#endif
}

void CAdapt_ItView::OnUpdateButtonNextStep(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(TRUE);
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonNextStep(wxCommandEvent& WXUNUSED(event))
{
	int sequNum = -1; // value not needed
	bool bCustomMessageSent;
	bCustomMessageSent = VerticalEdit_CheckForEndRequiringTransition(
												sequNum,nextStep,TRUE);
	bCustomMessageSent = bCustomMessageSent; // avoid warning
	// no need to use returned BOOL value; TRUE means "force transition"
}

void CAdapt_ItView::OnUpdateButtonPrevStep(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		if (gEditStep == adaptationsStep && gbAdaptBeforeGloss)
		{
			event.Enable(FALSE); // don't permit rollback to the
                    // edit source text dialog, instead the user should cancel the whole
                    // process and reselect & do Edit Source Text command again
			return;
		}
		else if (gEditStep == glossesStep && !gbAdaptBeforeGloss)
		{
			event.Enable(FALSE); // don't permit rollback to the
                    // edit source text dialog, instead the user should cancel the whole
                    // process and reselect & do Edit Source Text command again
			return;
		}
		else if (gEditRecord.nNewSpanCount == 0)
		{
			event.Enable(FALSE); // don't permit rollback at all
                    // if the user deleted all the CSourcePhrase instances he
                    // selected for editing using the Edit Source Text dialog
			return;
		}
		else
		{
			event.Enable(TRUE);
			return;
		}
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonPrevStep(wxCommandEvent& WXUNUSED(event))
{
	int sequNum = -1; // value not needed
	bool bCustomMessageSent;
	bCustomMessageSent = VerticalEdit_CheckForEndRequiringTransition(sequNum,
														previousStep,TRUE);
	bCustomMessageSent = bCustomMessageSent; // avoid warning
	// no need to use returned BOOL value; TRUE means "force transition"
}

void CAdapt_ItView::OnUpdateButtonEndNow(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonEndNow(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// instead of calling VerticalEdit_CheckForEndRequiringTransition(),
	// just post the required message immediately
	wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
	wxPostEvent(pApp->GetMainFrame(), eventCustom); // the event handlers
													// are in CMainFrame
}

void CAdapt_ItView::OnUpdateButtonCancelAllSteps(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonCancelAllSteps(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// instead of calling VerticalEdit_CheckForEndRequiringTransition(),
	// just post the required message immediately
	wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
	wxPostEvent(pApp->GetMainFrame(), eventCustom); // the event handlers
													// are in CMainFrame
}

void CAdapt_ItView::OnUpdateButtonUndoLastCopy(wxUpdateUIEvent& event)
{
	// in the next test we don't require that gOldEditBoxTextStr be non-empty,
	// so that the button can replace with an empty string too
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		if (pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber == gnWasSequNum &&
			pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords == gnWasNumWordsInSourcePhrase
			&& gbWasFreeTranslationMode == pApp->m_bFreeTranslationMode &&
			gbIsGlossing == gbWasGlossingMode)
		{
			event.Enable(TRUE);
		}
		else
		{
			event.Enable(FALSE);
		}
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::OnButtonUndoLastCopy(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxPanel* pBar;
	pBar = GetBar(Vert_Edit_ComposeBar);
	wxASSERT(pBar != NULL);
	wxTextCtrl* pTextBox;
	pTextBox = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	wxASSERT(pTextBox != NULL);

    // if free translation mode is current, then copy the contents of the
    // gOldEditBoxTextStr CString to the CEdit in the ComposeBar; otherwise,
    // copy it to the phrase box, because the update handler has already
    // determined the needed conditions are satisfied
	wxString theText = gOldEditBoxTextStr;
	gOldEditBoxTextStr.Empty();
	if (pApp->m_bFreeTranslationMode)
	{
		if (pTextBox == NULL)
		{
			wxMessageBox(_T(
"OnButtonUndoLastCopy error, compose bar's wxTextCtrl pointer is null; copy not done."),
			_T(""), wxICON_EXCLAMATION | wxOK);
			gnWasSequNum = -1;
			gnWasNumWordsInSourcePhrase = 0;
			gbWasGlossingMode = FALSE;
			gbWasFreeTranslationMode = FALSE;
			return;
		}
		pTextBox->ChangeValue(theText); // change the string in the
										// wxTextCtrl in the compose bar
		long len = theText.Len();
		pTextBox->SetSelection(len,len);
		pTextBox->SetFocus();
		pApp->GetMainFrame()->SendSizeEvent(); // forces the CMainFrame::SetSize() handler
											   // to run and do the needed redraw
		// **TODO** have the free translation text displayed under the active section
		// updated to comply with the change of free translation that has just happened
	}
	else
	{
		pApp->m_pTargetBox->ChangeValue(_T("")); // clear current box contents

		// if auto capitalization is on, determine the source text's
		// case properties
		bool bNoError = TRUE;
		if (gbAutoCaps)
		{
			bNoError = pApp->GetDocument()->SetCaseParameters(
				pApp->m_pActivePile->GetSrcPhrase()->m_key); // bIsSrcText is TRUE
			if (bNoError && gbSourceIsUpperCase && !gbMatchedKB_UCentry)
			{
				bNoError = pApp->GetDocument()->SetCaseParameters(theText,FALSE); // testing the non-source text
				if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
				{
					// a change to upper case is called for
					theText.SetChar((long)0,gcharNonSrcUC);
				}
			}
		}
		pApp->m_targetPhrase = theText;

		// the box may be bigger because of the text, so do a recalc of the layout
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
        // recalculate the active pile pointer
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pApp->m_pActivePile != NULL);

		// do a scroll if needed
		pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

		// place cursor at end of the inserted text
		long length = theText.Len();
		pApp->m_nEndChar = length;
		pApp->m_nStartChar = length;

		// restore focus to the targetBox, if it is visible,
		// and make non-abandonable
		if (pApp->m_pTargetBox != NULL)
		{
			if (pApp->m_pTargetBox->IsShown())
			{
				pApp->m_pTargetBox->SetFocus();
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
		}
		Invalidate();
		GetLayout()->PlaceBox();
	}

	// give bad values to the state-recording variables to ensure the
	// Undo Last Copy button will be disabled after the Undo is completed
	gnWasSequNum = -1;
	gnWasNumWordsInSourcePhrase = 0;
	gbWasGlossingMode = FALSE;
	gbWasFreeTranslationMode = FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
// Some material used by wxWidgets version below
/////////////////////////////////////////////////////////////////////////////////

// Clean up windows used for displaying the view. - from docview sample
bool CAdapt_ItView::OnClose(bool deleteWindow)
{
	deleteWindow = deleteWindow; // avoids "unreferenced formal parameter" warning

	// Clear the canvas in  case we're in single-window mode,
	// and the canvas stays.
	canvas->ClearBackground();

	canvas->pView = (CAdapt_ItView *) NULL;
	canvas = (CAdapt_ItCanvas *) NULL;

	wxString s(wxTheApp->GetAppName());
	if (pCanvasFrame)
		pCanvasFrame->SetTitle(s);

	SetFrame((wxFrame*)NULL);
	Activate(FALSE);

	return TRUE;
}

void CAdapt_ItView::Invalidate() // for MFC compatibility & flicker suppression
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// wxWidgets' wxView class does not itself have an Invalidate() method like MFC
	// The wxWindow class has Refresh(), so we'll get the window associated with
	// the current View and refresh it.

#ifdef Do_Clipping
	CLayout* pLayout = GetLayout();
    // if scrolling, or the phrase box is beyond the document's end, or a full window draw
    // was requested by RecalcLayout() or Redraw(), then do it; otherise assume the user is
    // typing or deleting in the phrase box and clip to the active pile's rectangle
	bool bCurrentlyScrolling =  pLayout->GetScrollingFlag();
	bool bDoFullWindowDraw = pLayout->GetFullWindowDrawFlag();

	if (bCurrentlyScrolling || bDoFullWindowDraw ||
		(pApp->m_nActiveSequNum == -1 || pApp->m_pActivePile == NULL) ||
		pApp->m_bFreeTranslationMode)
	{
		// no clipping this time, either scrolling or full window draw wanted
		pApp->GetMainFrame()->canvas->Refresh();
	}
	else
	{
		if (pApp->m_pActivePile != NULL)
		{
			/* BEW changed 3Jul09, see comment below, a zero rectangle suffices for clipping
			//pLayout->SetClipRectangle(pApp->m_pActivePile);
			//wxRect r = pLayout->GetClipRect();

            // debug test: halve the height, it appears to be too deep a rectangle because
            // there is drawing (because we see flicker there) under the phrase box's width
            // for two strips below the box -- test if this can be stopped? Yes, the strip
            // below had no content, but the second did, and halving the height stopped the
            // blink. However, it appears that the phrase box typing goes in and is visible
            // regardless of how big the view's clip rectangle is, is that so? Yes indeed,
            // so there is no point in wasting time on calculating the clip rectangle to be
            // just the box's rectangle or the pile's rectangle, just make it a zero
            // rectange so the Draw() of the view draws nothing, to save time.
			//int height = r.GetHeight();
			//r.SetHeight(height / 2);
			*/
			wxRect r;
			r.SetTop(0); r.SetLeft(0); r.SetWidth(0); r.SetHeight(0);

			// we clip to update only the innards of the phrase box control
			pLayout->m_pMainFrame->canvas->Refresh(TRUE,&r);
		}
		else
		{
			// no clipping this time, refresh whole client area (control should never
			// enter this block)
			pApp->GetMainFrame()->canvas->Refresh();
		}
	}
#else
	// no clipping support, refresh whole client area every time
	// RecalcLayout() is called
	pApp->GetMainFrame()->canvas->Refresh();
#endif
}

// whm added 12Jun07
// BEW 19Feb10, no change needed for support of doc version 5
void CAdapt_ItView::DrawTextRTL(wxDC* pDC, wxString& str, wxRect& rect)
{
    // This function attempts to alieviate the limitations of wxDC::DrawText() which does
    // not have an nFormat parameter as does the MFC function CDC::DrawText() and which
    // currently (as of wxWidgets 2.8.4) has different behaviors on wxMSW, wxGTK and wxMAC.
    //
    // The challenge here is due in part to the fact that the wxDC::SetLayoutDirection()
    // method applies to the whole DC and, on wxMSW (but not the other ports)
    // SetLayoutDirection() effectively mirrors the underlying coordinate system (requiring
    // coordinate values input to DrawText and other drawing methods be reversed on the
    // x-axis while SetLayoutDirection() is set to RTL. Hence, for wxMSW, we must transform
    // the coordinates in such a way that, while mirroring is in effect, the logical 0,0
    // coordinate for drawing text is located at the upper right corner of the logical
    // document and x coordinate values increase toward the left rather than toward the
    // right. The wxGTK and wxMac ports do not require the use of SetLayoutDirection() to
    // render punctuation correctly for RTL text, but drawing RTL text in those cases
    // requires that we must adjust the drawing coordinates of RTL text to start drawing at
    // the left end of the resulting RTL text, rather than at the right end (as MFC does).
    // I've also used a wxRect as parameter rather than wxCoord x and wxCoord y coordinate
    // parameters to make the upper right corner of the wxRect more readily available to
    // the function.
	//
	// TODO: Since the wxWidgets RTL rendering behaviors are obviously still somewhat in an
	// immature state of development (and may change in future library releases to become
	// more uniform across platforms) this issue needs to be visited again upon any
	// anticipated upgrade to newer versions of wxWidgets beyond version 2.8.4.
	//
	// For wxMSW we must transform the coordinates of rect's upper right corner to
	// account for the mirroring of the underlying coordinate system on Windows
	// (the wxGTK and wxMac do not seem to do the mirroring of the underlying
	// coordinates).
	// first get the upper right coords of the drawing rect
	wxPoint urPt(rect.GetRight(),rect.GetTop());
	// transform this point to have mirrored x-axis coordinates. grectViewClient should
	// indicate the current client view's total width, so if we subtract the urPt.x value
	// from grectViewClient.GetWidth(), we should have the "mirrored" x-axis coordinate
	// value for RTL layout.

	// wxGTK and wxMac need to start drawing text at the point urPt less the width/extent
	// of the text to be drawn
	wxSize sizeOfPhrase = pDC->GetTextExtent(str);
	pDC->DrawText(str,urPt.x - sizeOfPhrase.x,urPt.y);


#ifdef __WXMSW__
	// turning off RTL layout of the DC after calling DrawText() seems to be necessary
	// to best emulate what MFC's DrawText() does with its nFormat parameter
	pDC->SetLayoutDirection(wxLayout_LeftToRight); // need this???
#endif
}

// toggles the app's m_pCopySource flag's value, and makes the View menu's Copy Source be
// ticked or unticked as the case may be (it's public, as OnCopySource() is protected)
void CAdapt_ItView::ToggleCopySource()
{
	wxCommandEvent dummy;
	OnCopySource(dummy);
}

/// klb moved this logic out of OnAdvancedSeeGlosses to allow us to switch view
/// klb    to Show Glosses before invoking Print Preview
void CAdapt_ItView::ShowGlosses()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CSourcePhrase* pSrcPhrase;
	bool bOK;
	CSourcePhrase* pSaveSrcPhrase;
	int nSequNum;

	// save the current sequence number
	int nSaveSequNum = pApp->m_nActiveSequNum;

	// won't allow a selection to be preserved, this is too major a modality change
	if (pApp->m_selectionLine != -1)
		RemoveSelection();

    // before we redraw the layout and phrasebox, we have to save what is in the box
    // (provided it's contents are not abandonable or null text) in the appropriate KB,
    // then ready the pApp->m_targetPhrase member to have the correct text before
    // the layout is recalculated
	pApp->m_bSaveToKB = TRUE;

	if (pApp->m_pActivePile != NULL)
	{
		pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		if (gbIsGlossing) // flag has not been toggled yet
		{
			// we are changing from glossing to adapting, so we must store to the glossing
			// KB and then ready the pApp->m_targetPhrase member with the sourcephrase's
			// m_adaption contents and remove its refString from the adapting KB
			if (!(pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
			{
				// we can assume no errors for StoreTest call
				bOK = pApp->m_pGlossingKB->StoreText(pSrcPhrase,pApp->m_targetPhrase);
				bOK = bOK; // avoid warning
			}

			// if the active location is within a retranslation, we can't leave the box there
			// when we are in adapting mode, so if that is the case then find a safe location
			if (pSrcPhrase->m_bRetranslation)
			{
				pSaveSrcPhrase = pSrcPhrase;
				pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase); // try first for a location
															   // after retranslation section
				if (pSrcPhrase == NULL)
				{
					pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSrcPhrase);
				}
				// we assume (we won't test) one of the above Get... calls will succeed
				nSequNum = pSrcPhrase->m_nSequNumber;
				pApp->m_nActiveSequNum = nSaveSequNum = nSequNum;
				pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			}

			// now the adaptation stuff
			pApp->m_targetPhrase = pSrcPhrase->m_adaption; // get the adaptation text
			pApp->m_pKB->GetAndRemoveRefString(pSrcPhrase, pApp->m_targetPhrase, useTargetPhraseForLookup);
		}
	}

	// get the Enable Glossing menu pointer
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedMenuSeeGlosses = pMenuBar->FindItem(ID_ADVANCED_SEE_GLOSSES);

	// get the checkbox pointer
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxCheckBox* pCheckboxIsGlossing =
				(wxCheckBox*)pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);

 	// whm 30Aug11 Note: We do not switch between "<no adaptation>" and "<no gloss>" here
 	// because the OnAdvancedSeeGlosses() does not actually switch the app into glossing
 	// mode. That is done in OnCheckIsGlossing() and ToggleGlossingMode().

	// toggle the setting: note; whether going to or from glossing we will not change the
    // current values of gbGlossingUsesNavFont because the user might go back and forwards
    // from having glossing allowed or actually on (in the one session,) and it would be a
    // nuisance to have to manually restore this flag to its former setting each time the
    // user enables glossing again in the one session. (Leaving the flag ON is benign when
    // adapting.)
	if (gbGlossingVisible)
	{
		// toggle the checkmark to OFF
		if (pAdvancedMenuSeeGlosses != NULL)
		{
			pAdvancedMenuSeeGlosses->Check(FALSE);
		}
		gbGlossingVisible = FALSE;
		gbIsGlossing = FALSE; // must be off whenever the other flag is off

		// hide the mode bar checkbox when glossing is not allowed to be visible
		// and when not visible it obligatorily must be adapting
		if (pCheckboxIsGlossing != NULL)
		{
			pCheckboxIsGlossing->SetValue(FALSE); // not glossing, ie. is adapting
			pCheckboxIsGlossing->Show(FALSE);
		}
	}
	else
	{
		// toggle the checkmark to ON
		if (pAdvancedMenuSeeGlosses != NULL)
		{
			pAdvancedMenuSeeGlosses->Check(TRUE);
		}
		gbGlossingVisible = TRUE;

		// show the mode bar checkbox when glossing is allowed to be visible - user can
		// then choose either to do glossing, or to do adapting
		if (pCheckboxIsGlossing != NULL)
		{
			pCheckboxIsGlossing->Show(TRUE);
		}
	}

	// redraw the layout etc.
	CLayout* pLayout = GetLayout();

	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);

	pApp->m_pTargetBox->m_bAbandonable = FALSE; // we assume the new contents are wanted

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
	Invalidate();
	GetLayout()->PlaceBox();
}
