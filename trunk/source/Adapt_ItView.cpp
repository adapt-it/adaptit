// ///////////////////////////////////////////////////////////////////////////
/// \project		adaptit
/// \file			Adapt_ItView.cpp
/// \author			Bill Martin
/// \date_created	05 January 2004
/// \date_revised	15 January 2008
/// \copyright		2008 Bruce Waters, Bill Martin, SIL International
/// \license		The Common Public License or The GNU Lesser General Public License (see license directory)
/// \description	This is the implementation file for the CAdapt_ItView class. 
/// The CAdapt_ItView class is the most
/// complex class in the application. It controls every aspect of how the
/// data is presented to the user, and most aspects of the user interface.
/// The data for the view is held entirely in memory and is kept logically
/// separate from and independent of the document class's persistent data
/// structures. This schema is an implementation of the document/view
/// framework.
/// \derivation		The CAdapt_ItView class is derived from wxView.
// ///////////////////////////////////////////////////////////////////////////
// Pending Implementation Items in MainFrm (in order of importance): (search for "TODO")
// 1.
//
// Unanswered questions: (search for "???")
// 1.
//
// ///////////////////////////////////////////////////////////////////////////

#if defined(__GNUG__) && !defined(__APPLE__)
    #pragma implementation "Adapt_ItView.h"
#endif

// For compilers that support precompilation, includes "wx.h".
#include <wx/wxprec.h>

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
// Include your minimal set of headers here, or wx.h
#include <wx/wx.h>
#endif

#if defined(__VISUALC__) && __VISUALC__ >= 1400
#pragma warning(disable:4428)	// VC 8.0 wrongly issues warning C4428: universal-character-name 
								// encountered in source for a statement like 
								// ellipsis = _T('\u2026');
								// which contains a unicode character \u2026 in a string literal.
								// The MSDN docs for warning C4428 are also misleading!
#endif

#include <wx/docview.h>	// includes wxWidgets doc/view framework
#include <wx/file.h>
#include <wx/clipbrd.h>
#include <wx/filesys.h> // for wxFileName
#include <wx/window.h> // for CaptureMouse()
#include <wx/event.h> // for GetCapturedWindow()
#include <wx/config.h> // for wxConfig
#include <wx/tokenzr.h>
#include <wx/textfile.h> // to get EOL info
#include "Adapt_ItCanvas.h"
#include "Adapt_It_Resources.h"
#include <wx/dir.h> // for wxDir
#include <wx/propdlg.h>
#include <wx/progdlg.h> // for wxProgressDialog
#include <wx/busyinfo.h>
#include <wx/print.h>

#ifdef __WXGTK__
#include <wx/dcps.h> // for wxPostScriptDC
#else
#include <wx/dcprint.h> // for wxPrinterDC
#endif

// includes below uncomment as implemented
#include "Adapt_It.h"
#include "Text.h"
#include "Adapt_ItDoc.h"
#include "Adapt_ItView.h"
#include "helpers.h"
#include "EditPreferencesDlg.h" 
#include "KB.h"
#include "SourceBundle.h"
#include "SourcePhrase.h"
#include "Strip.h"
#include "Pile.h"
#include "Cell.h"
#include "AdaptitConstants.h"
#include "RefString.h"
#include "TargetUnit.h"
#include "PhraseBox.h"
#include "RetranslationDlg.h"
#include "ChooseTranslation.h"
#include "MainFrm.h"
#include "Welcome.h"
#include "PlaceInternalPunct.h"
#include "KBEditor.h"
#include "ConsistencyCheckDlg.h"
#include "ProgressDlg.h" // formerly called RestoreKBProgress.h
#include "GoToDlg.h"
//#include "PrintingDlg.h"
#include "WaitDlg.h" 
#include "UnitsDlg.h"
#include "EarlierTranslationDlg.h"
#include "EditSourceTextDlg.h"
//#include "TransferMarkersDlg.h" // whm: not needed with new vertical editing of source text
#include "ChooseConsistencyCheckTypeDlg.h" //whm added 9Feb04
#include "SetDelay.h" // added for version 2.0.2
#include "CollectBacktranslations.h" // BEW added 14Sept05
#include "NoteDlg.h"
#include "AIPrintout.h"
#include "ExportFunctions.h"
#include "PrintOptionsDlg.h"
#include "ConsistentChanger.h"
#include "SilConverterSelectDlg.h"

/// This global is defined in Adapt_ItView.cpp.
bool gbLegacySourceTextCopy = FALSE; // BEW added 16July08 at Roland Fumey's request (see CViewPage.h & .cpp)

#define IDW_TARGET_EDITBOX 1001

// Globals
extern bool gbSavedLineFourInReviewingMode;			// these two are defined in PhraseBox.cpp and are for support
extern wxString gStrSaveLineFourInReviewingMode;	// of preserving a hole when phrase box lands and leaves while
													// Reviewing mode is turned on (added 19Dec07)
/// This global is defined in SplitDialog.cpp.
extern bool gbIsDocumentSplittingDialogActive; // see SplitDialog.cpp

/// This global is defined in PhraseBox.cpp.
extern bool gbSuppressStoreForAltBackspaceKeypress;
extern bool gbNoAdaptationRemovalRequested;

/// This global is defined in MainFrm.cpp.
extern bool gbIgnoreScriptureReference_Receive;

/// This global is defined in MainFrm.cpp.
extern bool gbIgnoreScriptureReference_Send;

// for support of scripture synchronizing messages (the sending side of it) -- the following string
// must differ from the one obtained in the SendScriptureReferenceFocusMessage() function before a
// new scripture reference focus message is sent (for example, when first entering a new verse, one
// is sent; but we don't want to send one every time the phrase box lands on another word in the same
// verse) The view's member function SendScriptureReferenceFocusMessage() accesses this global string.
wxString gOldChapVerseStr = _T(""); // the "chapter:verse" string used in the last broadcast message
	
/// This global is defined in Adapt_ItView.cpp.
extern bool gbLegacySourceTextCopy;	// default is legacy behaviour, to copy the source text (unless
									// the project config file establishes the FALSE value instead)

/// This global is defined in Adapt_It.cpp.
extern bool gbFreeTranslationJustRemovedInVFMdialog;

extern bool gbRetainBoxContents; // from version 1.4.2, see CPhraseBox for comments on its use whm added bool
extern wxString ccErrorStr;	// used in CConsistentChanger

/// This global is defined in Adapt_It.cpp.
extern wxChar gSFescapechar; // the escape char used for start of a standard format marker

/// This global is defined in Adapt_It.cpp.
extern bool gbHasBookFolders; // TRUE when Adaptations folder is found to have Bible book

// for support of fast access to a selected CSourcePhrase's entry in the KB
int gnWordsInPhrase = -1; // use -1 as a flag for disabling the feature
wxString gTheSelectedKey = _T(""); // if multiple keys selected, take only the first

/// Used for inhibiting multiple accesses to MakeLineFourString when only one is needed.
bool gbInhibitLine4StrCall = FALSE;
// for suppressing MakeLineFourString in ReDoPhraseBox( ) when moving to the
// previous pile (which might have internal punct & we don't want to see Place dialog)
extern bool gbMovingToPreviousPile;

// extern declarations for free translation support (whm moved these to the app)

/// This global is defined in Adapt_It.cpp.
extern bool		gbBundleStartIteratingBack; // default FALSE, TRUE if pile pointer is NULL on GetPrevPile() call

/// This global is defined in Adapt_It.cpp.
extern int			gnOffsetInMarkersStr; // offset to current free translation string in pSrcPhrase->m_markers

/// This global is defined in Adapt_It.cpp.
extern int			gnLengthInMarkersStr; // free translation length, including final space if any, in pSrcPhrase->m_markers

/// This global is defined in Adapt_It.cpp.
extern wxArrayPtrVoid*	gpCurFreeTransSectionPileArray; // new creates on heap in InitInstance, and disposes in ExitInstance

/// This global is defined in Adapt_It.cpp.
extern wxArrayPtrVoid*	gpFreeTransArray; // new creates on heap in InitInstance, and disposes in ExitInstance

/// This global is defined in Adapt_It.cpp.
extern CPile*		gpFirstPile; // pointer to first pile in a free translation section

/// This global is defined in Adapt_It.cpp.
extern CPile*		gpLastPile; // pointer to last pile in the same section

/// This global is defined in Adapt_It.cpp.
extern wxString	gSpacelessTgtPunctuation; // contents of app's m_punctuation[1] string with spaces removed

/// This global is defined in Adapt_It.cpp.
extern bool		gbSuppressSetup;

/// This global is defined in Adapt_It.cpp.
extern bool		gbSaveHilightingSetting;

// for support of auto-capitalization

/// This global is defined in Adapt_It.cpp.
extern bool	gbAutoCaps;

/// This global is defined in Adapt_It.cpp.
extern bool	gbSourceIsUpperCase;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNonSourceIsUpperCase;

/// This global is defined in Adapt_It.cpp.
extern bool	gbMatchedKB_UCentry;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNoSourceCaseEquivalents;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNoTargetCaseEquivalents;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNoGlossCaseEquivalents;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharNonSrcLC;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharNonSrcUC;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharSrcLC;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharSrcUC;

bool	gbCallerIsRemoveButton = FALSE;

/// This global is defined in Adapt_It.cpp.
extern CAdapt_ItApp* gpApp;// for rapid access to the app class

// for getting source text updated after an edit
int	gnOldMaxIndex = 0;

// next four are for version 2.0 which includes the option of a 3rd line for glossing

/// When TRUE it indicates that the application is in the "See Glosses" mode. In the 
/// "See Glosses" mode any existing glosses are visible in a separate glossing line in 
/// the main window, but words and phrases entered into the phrasebox are not entered 
/// into the glossing KB unless gbEnableGlossing is also TRUE.
bool	gbIsGlossing = FALSE; // when TRUE, the phrase box and its line have glossing text

/// When TRUE the application is in true glossing mode. The phrasebox appears in the 
/// main window's glossing line and contains glosses rather than normal adaptations. 
/// The glosses entered or displayed in the phrasebox are stored in and retrieved from 
/// the glossing KB.
bool	gbEnableGlossing = FALSE; // TRUE makes Adapt It revert to Shoebox functionality only

/// When TRUE the font used in glossing is the Navigation language font. Glossing uses 
/// the Target font & settings by default, but if TRUE then it uses the Navigation language
/// font & direction settings.
bool	gbGlossingUsesNavFont = FALSE; 

/// Defaults to FALSE to allow things like 3:sg:Subj or 1.incl to be put into the glossing 
/// KB 'as is'. When TRUE punctuation is stripped out before saving the gloss in the glossing
/// KB.
bool	gbRemovePunctuationFromGlosses = FALSE; 

/// This flag is used to indicate that the text being processed is unstructured, i.e.,
/// not containing the standard format markers (such as verse and chapter) that would 
/// otherwise make the document be structured. This global is used to restore paragraphing 
/// in unstructured data, on export of source or target text.
bool	gbIsUnstructuredData = FALSE; 

/// When no highlighting is wanted for insertions the value is -1, otherwise this global 
/// holds the sequence number of the first pile where highlighted background of automatically 
/// inserted target text is to be drawn (current active pile + 1).
int	gnBeginInsertionsSequNum = -1;	

/// When no highlighting is wanted for insertions the value is -1, otherwise this global holds the
/// sequence number of the last pile where highlighted background of automatically inserted target text
/// is to be drawn. The ending sequence number is the value for the pile of the phrasebox when it has
/// halted (such as when a KB item can't be found for a match, or when the user uses the Cancel or
/// Cancel and Select buttons in the Choose Translation dialog. Highlight on the cell with the ending
/// value is not apparent as long at the phrase box is located there, but becomes visible if the phrase
/// box is moved away. This also helps the user see where the stopping place was after moving away.)
int	gnEndInsertionsSequNum = -1;	

// This global is defined in Adapt_It.cpp.
//extern bool gbSfmOnlyAfterNewlines; // for handling the optional ignoring of sfms which are not line initial

/// This global is defined in Adapt_It.cpp.
extern bool gbDoingInitialSetup;

// whm added 6Apr05 for support of export filtering of sfms and RTF output of the same
// in the appropriate functions in the View. These globals are defined in ExportSaveAsDlg.cpp
extern wxArrayString m_exportBareMarkers;
extern wxArrayString m_exportMarkerAndDescriptions;
extern wxArrayInt m_exportFilterFlags;
extern wxArrayInt m_exportFilterFlagsBeforeEdit; // to detect any changes to list of markers for export

// Note: for the following, when TRUE the item is placed into the body of the output text (as boxed
// paragraphs for non-interlinear RTF output; as separate table row for interlinear RTF output). When
// FALSE the item is placed as a footnote (at bottom of page).
extern bool bPlaceFreeTransInRTFText;	// default is TRUE
extern bool bPlaceBackTransInRTFText;	// default is FALSE
extern bool bPlaceAINotesInRTFText;		// default is FALSE

extern const wxChar* filterMkr; // defined in the Doc, used here in OnLButtonDown() & free translation code, etc
extern const wxChar* filterMkrEnd; // defined in the Doc, used in free translation code, etc

// The following string is a list of markers that affect character formatting and the text to which they
// apply should not be filtered when the marker is filtered, only the markers themselves should be filtered
// out. This string of markers are used in RTF output routines
wxString charFormatMkrs = _T("\\qac \\qs \\qt \\nd \\tl \\dc \\bk \\pn \\wj \\k \\no \\bd \\it \\bdit \\em \\sc ");
// and the end marker forms
wxString charFormatEndMkrs = _T("\\qac* \\qs* \\qt* \\nd* \\tl* \\dc* \\bk* \\pn* \\wj* \\k* \\no* \\bd* \\it* \\bdit* \\em* \\sc* ");
// The following string is a list of markers that are embedded content markers for footnotes, endnotes and crossrefs
wxString embeddedWholeMkrs = _T("\\fr \\fk \\fq \\fqa \\ft \\fdc \\fv \\fm \\xo \\xt \\xk \\xq \\xdc ");
// and the end marker forms
wxString embeddedWholeEndMkrs = _T("\\fr* \\fk* \\fq* \\fqa* \\ft* \\fdc* \\fv* \\fm* \\xo* \\xt* \\xk* \\xq* \\xdc* ");

// The following string is a list of sfms which are significant enough to become a halting point
// for the immediate placement of pending back translation material.
// NOTE: Before checking if a given Marker is included in these strings any numerical level part of
// the Marker to be checked should be removed, i.e., \th1 should be changed to \th, \mt1 should be
// changed to \mt etc. This is done in IsBTMaterialHaltingPoint().
// The following markers should NOT trigger a halt point:
//   end markers of all kinds
//   running header markers \h \h1 \h2 \h3 (these are removed early from buffer)
//	 \note
//   character formatting markers
wxString commonHaltingMarkers = _T("\\v \\c \\p \\m \\q \\qc \\qm \\qr \\qa \\pi \\mi \\pc \\pt \\ps \\pgi \\cl \\vn \\f \\fe \\x \\gd \\tr \\th \thr \\tc \tcr \\mt \\st \\mte \\div \\ms \\s \\sr \\sp \\d \\di \\hl \\r \\dvrf \\mr \\br \\rr \\pp \\pq \\pm \\pmc \\pmr \\cls \\imt \\imte \\is \\ip \\ipi \\ipq \\ipr \\iq \\im \\imi \\imq \\io \\iot \\iex \\ie \\li \\qh \\gm \\gs \\gd \\gp \\tis \\tpi \\tps \\tir \\pb \\hr ");
wxString btHaltingMarkers = commonHaltingMarkers;

// The following string is a list of sfms which are significant enough to become a halting point
// for the immediate placement of pending free translation material.
// NOTE: Before checking if a given Marker is included in these strings any numerical level part of
// the Marker to be checked should be removed, i.e., \th1 should be changed to \th, \mt1 should be
// changed to \mt etc. This is done in IsFreeMaterialHaltingPoint().
wxString freeHaltingMarkers = commonHaltingMarkers;

// The following string arrays are used to construct the cell elements of Interlinear RTF output
// They are populated by BuildInterlinearTextStrArrays(), which is patterned after the
// BuildTargetText() function, but populates the elements of the string into the four string arrays
// below rather than as a single wxString.
wxArrayString SrcStrArray;
wxArrayString TgtStrArray;
wxArrayString GlsStrArray;
wxArrayString NavStrArray;

extern bool gbRTLLayout; // defined in FontPage.cpp
extern bool gbLTRLayout;

/// This global is defined in Adapt_It.cpp.
extern bool	gbRTL_Layout;	// ANSI version is always left to right reading; this flag can only
							// be changed in the Unicode version, using the extra Layout menu

/// This global is defined in Adapt_It.cpp.
extern int	gnVerticalBoxBloat; // see CAdapt_ItApp (bloats vertical dim'n of phrasebox for unicode version)

// basic format integer for use in the DrawText() function (see CDC), since unicode will need
// DrawText()
// MFC has the following bitwise flag set as the default nFormat flag in DrawText:
//UINT gnFormat = DT_SINGLELINE | DT_EXTERNALLEADING | DT_NOCLIP | DT_NOPREFIX | DT_TOP;	// DT_LEFT
																							// is default
// The MFC version ORs other DT flags with the gnFormat flag to produce the globals 
// gnRTLFormat and gnLTRFormat; this is done in the View's OnInitialUpdate() as follows:
// gnRTLFormat = gnFormat | DT_RIGHT | DT_RTLREADING;
// gnLTRFormat = gnFormat | DT_LEFT;
// Then, later the appropriate gn...Format is assigned to a local nFormat value which is fed to
// the MFC DrawText(str,rect,nFormat) function to effect both right alignment and right-to-left 
// reading of the text being drawn.
// whm note: MFC docs say of DT_LEFT, DT_RIGHT and DT_RTLREADING:
//    "DT_LEFT - Aligns text to the left."
//    "DT_RIGHT - Aligns text to the right."
//    "DT_RTLREADING - Layout in right-to-left reading order for bi-directional text when the 
//                    font selected into the hdc is a Hebrew or Arabic font. The default 
//                    reading order for all text is left-to-right."

// whm NOTE: wxDC::DrawText(const wxString& text, wxCoord x, wxCoord y) does not have an equivalent
// to the MFC DrawText's nFormat parameter, but instead wxDC has a SetLayoutDirection(wxLayoutDirection 
// dir) method to change the logical direction or mirroring of the display context. In wxDC the display 
// context is mirrored right-to-left when wxLayout_RightToLeft is passed as the parameter; 
// Certain controls that contain text strings such as wxTextCtrl and wxListBox, etc., also have an 
// undocumented method called SetLayoutDirection(wxLayoutDirection dir), where dir is wxLayout_LeftToRight 
// or wxLayout_RightToLeft. 
// Setting the layout to wxLayout_RightToLeft on these controls also involves some mirroring affecting
// the control itself, so that any scrollbar that gets displayed, for example, displays on the left side
// of the control rather than on the right, etc.
// In the wx version we have to be careful about the automatic mirroring features involved in the
// SetLayoutDirection() function. Since Adapt It MFC was designed to micromanage the layout direction
// itself as well as alignment in the coding of text, cells, piles, strips, etc., we no doubt encounter 
// problems in layout and must avoid inadvertently "reversing" parts of the RTL layout because of the 
// micromanaged layout done in the coding of the MFC version. 

//UINT gnRTLFormat; // for RTL - set in OnInitUpdate()
//UINT gnLTRFormat; // for LTR - ditto

bool gbDummyAddedTemporarily = FALSE; // TRUE if an null sourcephrase is to be inserted after
									  // the sel'n or after the active location, when the either
									  // of those are at the m_maxIndex location (we use
									  // InsertNullSrcPhrase() which always inserts before a
									  // location, so we have to add a dummy at the end
									  // until the insert is done, and then remove it.

// ****************************************************************************************************************
// BEW 7May08: the next globals are for source text editing; the refactored functionality may not need all these...
// and including those for the refactored code (after the old ones)

// the following globals make it easy to access the sublists and their counts; for use in
// CEditSourceTextDlg and in the subsequent CTransferMarkersDlg especialy
SPList* gpOldSrcPhraseList; // TransferMarkersDlg needs this, so be careful about removing, because of flow on link errors
SPList* gpNewSrcPhraseList; // TransferMarkersDlg needs this, so be careful about removing, because of flow on link errors
int gnCount; // count of old srcphrases (user selected these) after unmerges, etc
int gnNewCount; // count of the new srcphrases (after user finished editing the source text)
//bool	 gbForceOpenMarkerTransferDialog = FALSE; // TRUE if use uses checkbox in Edit Source Text
												  // dialog to unconditionally force open a
												  // subsequent Transfer Markers dialog

/// A pointer to a sourcephrase immediately preceding the first one in a sublist of old source 
/// phrase instances.
CSourcePhrase* gpPrecSrcPhrase; 

/// A pointer to a sourcephrase immediately following the ones in a sublist of source 
/// phrase instances in which their m_srcPhrase attributes have new (edited) values, 
/// or 0 if none; we need access to the following sourcephrase in case the user changes 
/// markers and then the m_bFirstOfType flag on gpFollSrcPhrase would often need to be
/// reset TRUE.
CSourcePhrase* gpFollSrcPhrase; 

// This global was defined in TransferMarkersDlg.cpp in the legacy MFC app.
/// This global is TRUE if the TextType needs to be propagated to sourcephrase instances 
/// following the new sublist, after all housekeeping is done & propagation is done in 
/// OnEditSourceText().
bool gbPropagationNeeded; 

// This global was defined in TransferMarkersDlg.cpp (now removed) in the legacy MFC app.
/// Indicates the TextType to be propagated when the gbPropagationNeeded global is TRUE
TextType gPropagationType; // the TextType to be propagated

/// This global is defined in Adapt_ItDoc.cpp.
extern bool		gbSpecialText;  // the special text boolean which will need to be propagated,
								// if propagation is required


// BEW additional globals and defines, 14Apr08, for support of the vertical editing process

// The next two globals track the vertical edit update process; when gbVerticalEditInProgress is
// turned on (TRUE), the gEntryPoint value specifies what the entry point was; this enables the
// code for any of the vertical edit processing steps to be able to determine what kind of
// edit initiated the vertical update process (eg. a source text edit, or an adaptation edit, etc),
// which in turn enables that code to know what members of the gEditRecord struct can be expected
// to have data in them which can be used by the current processing step of the vertical sequence.
// Each step also has its own enum value in the global gEditStep, so that if backtracking through
// the steps is required, the code can know where it must start from in the total process. Also,
// if the user edited a misspelled SF marker, and the marker which results is one nominated for
// filtering or unfiltering, the filtering or unfiltering will take place - changing the number
// of CSourcePhrase instances in the document. The bail out process must be smart enough to restore
// the original doc state when necessary given such a filtering or unfiltering has taken place; and
// we want exceptions to cause restoration of the pre-edit document state, rather than application
// death
bool gbVerticalEditInProgress = FALSE; // TRUE while any stage of a vertical edit process is active
bool gbEditingSourceAndDocNotYetChanged = TRUE; // programmatically cleared to FALSE when doc is changed
EntryPoint	gEntryPoint = noEntryPoint;  // from an enum, the value can be one of 
					// noEntryPoint (0), sourceTextEntryPoint (1), adaptationsEntryPoint (2),
					// glossesEntryPoint (3), or freeTranslationsEntryPoint (4) (see Adapt_ItView.h)
EditStep gEditStep = noEditStep; // see Adapt_ItView.h
bool gbAdaptBeforeGloss = TRUE; // TRUE (default) if adaptationsStep is to be done before glossesStep,
						 // FALSE for the opposite order (value of this global stored in project 
						 // configuration file)

/* EditRecord is defined in Adapt_It.h file, here the comments are removed
   to make reading the members easier
typedef struct
{
	bool			bGlossingModeOnEntry;
	bool			bSeeGlossesEnabledOnEntry;
	bool			bEditSpanHasAdaptations;
	bool			bEditSpanHasGlosses;
	bool			bEditSpanHasFreeTranslations;
	bool			bEditSpanHasBackTranslations;
	int				nSaveActiveSequNum;
	wxString		oldPhraseBoxText;
	TextType		nStartingTextType;
	TextType		nEndingTextType;
	wxArrayString	deletedAdaptationsList;
	wxArrayString	deletedGlossesList;
	wxArrayString	deletedFreeTranslationsList;
	wxArrayString	storedNotesList;
	int				nStartingSequNum;
	int				nEndingSequNum;
	int				nFreeTrans_StartingSequNum;
	int				nFreeTrans_EndingSequNum;
	int				nBackTrans_StartingSequNum;
	int				nBackTrans_EndingSequNum;
	int				nCancelSpan_StartingSequNum;
	int				nCancelSpan_EndingSequNum;
	SPList			cancelSpan_SrcPhraseList;
	SPList			modificationsSpan_SrcPhraseList;
	SPList			editableSpan_NewSrcPhraseList;
	SPList			propagationSpan_SrcPhraseList;
	int				nPropagationSpan_StartingSequNum;
	int				nPropagationSpan_EndingSequNum;
	wxArrayInt		arrNotesSequNumbers; //CArray<int,int> arrNotesSequNumbers;
	int				nOldMaxIndex;
	int				nOldSpanCount;
	int				nNewSpanCount;
	wxString		strInitialEndmarkers; 
	wxString		strFinalEndmarkers;
	wxString		strNewFinalEndmarkers;
	bool			bSpecialText;
	SPList			follNotesMoveSpanList;
	SPList			precNotesMoveSpanList;
	bool			bTransferredFilterStuffFromCarrierSrcPhrase;
	bool			bDocEndPreventedTransfer;
	bool			bExtendedForFiltering;
	
	bool			bAdaptationStepEntered;
	SPList			adaptationStep_SrcPhraseList;
	int				nAdaptationStep_StartingSequNum;
	int				nAdaptationStep_EndingSequNum;
	int				nAdaptationStep_OldSpanCount;
	int				nAdaptationStep_NewSpanCount;
	int				nAdaptationStep_ExtrasFromUserEdits;

	bool			bGlossStepEntered;
	SPList			glossStep_SrcPhraseList;
	int				nGlossStep_StartingSequNum;
	int				nGlossStep_EndingSequNum;
	int				nGlossStep_SpanCount;

	bool			bFreeTranslationStepEntered;
	bool			bVerseBasedSection;
	SPList			freeTranslationStep_SrcPhraseList;
	int				nFreeTranslationStep_StartingSequNum;
	int				nFreeTranslationStep_EndingSequNum;
	int 			nFreeTranslationStep_SpanCount;
} EditRecord;
*/
// The vertical editing process helps the user to edit/update dependent information, when editing information at
// a higher line of a strip invalidates information already entered in lower lines which depend on the higher line.
// The design of the topmost possible level of the process, the Edit Source Text functionality, requires a
// refactored dialog, minus the old and complex child dialog where SF markup was separately accessible; the
// refactored design eliminates the latter and shows SF markup and source text together, both accessible for
// editing. To keep the information non-confusing, notes, free translations, and any collected back translations
// defined in any part of the editable span, are removed - and retained in lists made accessible to the user
// later in the process (except removed back translations are chucked). The design involves careful delineation
// of four spans where certain types of information are removed from sublists -- see the comments for the
// definition of EditRecord in Adapt_ItView.h for extra details. To keep error recovery and cancelling as simple
// as possible when restoring the document to its earlier state, the m_pSourcePhrases list which defines the
// document is not changed until the very last moment when the user's edit is accepted (by the OK button press).
// This means that modifications needed to be done to CSourcePhrase instances prior to that, are done on deep
// copied instances in sublists stored in the EditRecord.
// The four spans (implemented as CObList and two int variables per span for the starting and ending offsets within
// the m_pSourcePhrases list on the document) are 1. the editable span (the user's selection, but extended to
// embrace any retranslation/s which the selection may overlap), 2. the cancel span - as wide as is necessary to
// hold deep copies of CSourcePhrase instances modified in the edit process (except it perhaps might not include
// all of the propagation span), 3. the modifications span - coextensive with the cancel span, but in which
// needed data modifications (primarily removal of distracting information types) are done prior to the Edit
// Source Text dialog being displayed, and 4. the propagation span - a span, possibly empty, or possibly containing
// numerouse deep copies of the original CSourcePhrases following the editable span and where propagation of a
// new TextType after the source text edit was done resulted in CSourcePhrase changes. Span 1 always lies within
// spans 2 and 3; span 4 begins, if at all, immediately after span 1 and it may overlap completely or partially
// with instances in the end of spans 2 and 3.

// The MFC legacy applications will support modeless editing for Edit Source Text operations only. The wxWidgets
// port will support it in all relevant editing contexts where vertical information is invalidated by an edit
// of information on which it depends.

#define DELETIONS_LIST_MAX_ENTRIES 100
#define NUM_WORDS_IMPLYING_VERSE_SECTIONING 15

EditRecord gEditRecord; // store info pertinent to generalized editing with entry point for an
								   // Edit Source Text request, in this global structure
wxString gOldEditBoxTextStr; // a place to store the text replaced by the last copy from one of 
							// the Removed combobox list's entries
int gReplacementLocation_SequNum; // sequence number of the CSourcePhrase where the phrase box is when
								  // the last insert into gOldEditBoxTextStr was done (for the Undo Last Copy
								  // button to work, the active sequ num has to be the same as this value)

// end of additional gobals and defines for support of the modeless editing process

// BEW added 15July08; definitions for custom events used in the vertical edit process, which typically
// starts with a source text edit, but in the wxWidgets based apps it could also be an adaptation edit,
// gloss edit, or free translation edit that starts it off; these events are UINT
// There custom events are implemented in CMainFrame in wx version
//UINT CUSTOM_EVENT_ADAPTATIONS_EDIT = RegisterWindowMessage(_T("CustomEventAdaptationsEdit"));
//UINT CUSTOM_EVENT_FREE_TRANSLATIONS_EDIT = RegisterWindowMessage(_T("CustomEventFreeTranslationsEdit"));
//UINT CUSTOM_EVENT_BACK_TRANSLATIONS_EDIT = RegisterWindowMessage(_T("CustomEventBackTranslationsEdit"));
//UINT CUSTOM_EVENT_COLLECTED_BACK_TRANSLATIONS_EDIT 
//							= RegisterWindowMessage(_T("CustomEventVCollectedBackTranslationsEdit"));
//UINT CUSTOM_EVENT_END_VERTICAL_EDIT = RegisterWindowMessage(_T("CustomEventEndVerticalEdit"));
//UINT CUSTOM_EVENT_CANCEL_VERTICAL_EDIT = RegisterWindowMessage(_T("CustomEventCancelVerticalEdit"));
//UINT CUSTOM_EVENT_GLOSSES_EDIT = RegisterWindowMessage(_T("CustomEventGlossesEdit"));

bool gbVerticalEdit_SynchronizedScrollReceiveBooleanWasON = FALSE;

// BEW 7May08: end of vertical editing's globals, including those for the refactored code for src text editing
//*******************************************************************************************************************

bool			gbInsertingWithinFootnote = FALSE; // TRUE if inserting a null sourcephrase
								// within a footnote; eg. if a retranslation is within a
								// footnote and gets padded with null sourcephrases.
								// We need to know this so that we can propagate the
								// footnote TextType to the padding, or for any other insertion
								// within a footnote.
bool			gbSuppressRemovalOfRefString = FALSE; // set TRUE in SetActivePilePointerSafely,
						// otherwise nested PlacePhraseBox call will result in a RemoveRefString
						// spurious call before the phrasebox is rebuilt, which could remove a
						// source to target translation association wrongly.
extern bool		gbByCopyOnly;		  // see CPhraseBox for explanation of its function
extern int		gnLastEarlierChapter; // preserve chapter and verse number used in last call of
extern int		gnLastEarlierVerse;	  // View Earlier Translation dialog

/// Multiply width of 'w' character this many times to get the slop at right-hand-side (RHS) of initial
/// phrase box width, or the amount to expand the box by.
short			gnExpandBox = 8; 

/// Use this multiplier to calculate when text gets too near the RHS of the phrase box, so that
/// expansion becomes necessary - see the FixBox() function in CPhraseBox class.
short			gnNearEndFactor = 3; 

wxRect			grectViewClient;

/// When TRUE the main window only displays the target text lines.
bool			gbShowTargetOnly = FALSE;

/// Used to store the App's m_curLeading value when switching between views that only
/// display the target language and those that display normal target lines.
int				gnSaveLeading = 4;

/// Used to store the App's m_curGapWidth value when switching between views that only
/// display the target language and those that display normal target lines.
int				gnSaveGap = 8;

//bool			gbRebuildingDoc = TRUE; // unused
bool			gbIgnoreIt = FALSE; // used when "Ignore it, I will fix it later" button was hit
									// in consistency check dlg

bool			gbSaveSuppressFirst; // save the toggled state of the lines in the strips
bool			gbSaveSuppressLast;  // (across Find or Find and Replace operations)

extern bool		gbUnmergeJustDone;		 // see CPhraseBox for explanation
extern bool		gbCompletedMergeAndMove; // see CPhraseBox for explanation
extern bool		gbEnterTyped;			 // see CPhraseBox for explanation

// This global is defined in PhraseBox.cpp.
//extern SPList::Node* gLastSrcPhrasePos; // used in GetSrcPhrasePos() call in BuildPhrases() to speed
								   // up ... MFC uses POSITION
bool			gbBundleChanged = FALSE;

extern  wxString	gSaveTargetPhrase; // for use by the SHIFT+END shortcut for unmerging a phrase

/// This global is defined in PhraseBox.cpp.
extern  long	gnStart;

/// This global is defined in PhraseBox.cpp.
extern  long	gnEnd;

extern	bool	gbExpanding; // see use in CalcPileWidth // defined in CPhraseBox // changed int to bool

/// This global is defined in Adapt_It.cpp.
extern  int		nSequNumForLastAutoSave;

/// This global is defined in Adapt_ItDoc.cpp.
extern	bool	bUserCancelled;

extern  bool	gbJustCancelled; // set TRUE when Find or Find & Replace dialog window has just
								 // been cancelled and needed for view's OnButtonMerge() function,
								 // the look ahead code block
bool bSuppressDefaultAdaptation = FALSE;	// normally FALSE, but set TRUE whenever user is
											// wanting a MergeWords done by typing into the phrase
											// box (which also ensures cons.changes won't be done
											// on the typing) - actually more complex than this,
											// see CPhraseBox OnChar()
bool   gbInspectTranslations = FALSE;	// TRUE when user manually opens CChooseTranslation
										// to inspect adaptions
extern bool		gbUserWantsSelection; // carries value from CPhraseBox to caller of LookAhead()
									  // - see there
extern bool		gbUserCancelledChooseTranslationDlg;
extern bool		gbSuppressLookup; // see CPhraseBox globals for explanation

// global to make source phrase accessible to dialogs
CSourcePhrase* gpSrcPhrase;

SPList gSrcPhrases; // for list of CSourcePhrase instances in the retranslation

// global pointer to the punctuation remainder list, for use by CPlaceInternalPunct
wxArrayString* gpRemainderList = (wxArrayString*)NULL; // MFC uses CStringList*

/// TRUE if a consistency check is in progress. Used to supress the placement of the 
/// phrase box when documents are opened while performing a consistency check.
bool	gbConsistencyCheckCurrent = FALSE;

// some globals for use in merging
wxString gOldConcatStr = _T("");			// may have punctuation
wxString gOldConcatStrNoPunct = _T("");  // has any punctuation removed
bool	gbMergeSucceeded = FALSE;

// miscellaneous
bool	gbJustClosedProject = FALSE; // use to suppress Welcome to Adapt It window after doc opened

// global, for choosing whether Find... or Find and Replace... comes up
bool	gbFind = TRUE;
bool	gbFindIsCurrent = FALSE;
bool	gbJustReplaced = FALSE;
//extern  bool    gbReplaceAllIsCurrent; // for use by OnIdle() in CAdapt_ItApp
bool	gbFindOrReplaceCurrent = FALSE; // for use by CMainFrame's OnActive() function

// BEW added 20March07: for suppressing removal of KB entries when a retranslation or edit
// of a retranslation is currently being done
bool	gbIsRetranslationCurrent = FALSE;

// globals for inserting a replacement target text into a retranslation, when the latter is
// wholly or partly matched (invokes OnButtonEditRetranslation() which uses these globals)
wxString gSrchStr = _T("");
wxString gReplStr = _T("");
bool	gbReplaceInRetranslation = FALSE;

// globals for handling advancement over a found retranslation
bool gbMatchedRetranslation = FALSE;
int  gnRetransEndSequNum; // sequ num of last srcPhrase in a matched retranslation

/// A global for saving a source phrase's old sequence number in case it is required 
/// for the toolbar's Back button. When there is no earlier location, it is set to -1.
int gnOldSequNum = -1;

// globals defined in CPhraseBox
extern int			nWordsInPhrase;

/// This global is defined in PhraseBox.cpp.
extern wxString		translation; // translation, for a matched source phrase key

extern CTargetUnit*	pCurTargetUnit; // when valid, it is the matched CTargetUnit instance
extern wxString		curKey; // when non empty, it is the current key string which was matched

// global set by ChooseTranslation, when user selects <no adaptation>, then PhraseBox will not
// use CopySource() but instead use an empty string for the adaptation
bool	gbEmptyAdaptationChosen = FALSE;

// global for alerting OnLButtonUp() that selection has been halted at a boundary
// (set in OnMouseMove())
bool	gbHaltedAtBoundary = FALSE;

/// This global is defined in Adapt_It.cpp.
extern	int		gnMapLength[10];

/// This global is defined in Adapt_It.cpp.
extern wxPoint gptLastClick;

// globals relevant to the printing process
bool	gbPrintingSelection = FALSE;
bool	gbIsPrinting = FALSE; // TRUE when when OnPreparePrinting is called, cleared only in
							  // the AIPrintout destructor.
bool	gbPrintingRange = FALSE; // TRUE when the user wants to print a chapter/verse range
int		gnCurPage = 0; // to make number of current page being printed accessible to CStrip's Draw()

/// For preserving selection across a RecalcLayout() or LayoutStrip().
int		gnSelectionStartSequNum; 

/// For preserving selection across a RecalcLayout() or LayoutStrip().
int		gnSelectionEndSequNum;

/// Preserved value of m_selectionLine
int		gnSelectionLine;

bool	gbIsBeingPreviewed = FALSE; // true while a print preview is being done
int		gnPrintingWidth;  // copy of the (logical coords) printing width for current paper
						  // & margin settings
int		gnPrintingLength; // ditto for the printing length of the page
int		gnFromChapter = 1;
int		gnFromVerse = 1;
int		gnToChapter = 1;
int		gnToVerse = 1;
int		gnRangeStartSequNum;
int		gnRangeEndSequNum;

//extern	float englishToMetric;

/// If TRUE print the footer, otherwise skip printing of footer
bool	gbPrintFooter = TRUE;

int		gnTopGap = 100; // units of thousandths of an inch for this and next two
int		gnFooterTextHeight = 150; // for the text of the footer, units of thousandths of an inch
int		gnBottomGap = 0; // assume we can print right to the rtMinMargin.bottom limit on the page
bool	gbSuppressPrecedingHeadingInRange = FALSE;
bool	gbIncludeFollowingHeadingInRange = FALSE;

// struct for storing auto-fix inconsistencies when doing "Consistency Check..." menu item;
// for glossing we can use the same structure with the understanding that the oldAdaptation
// and finalAdaptation will in reality contain the old gloss and the final gloss, respectively;
// and nWords for glossing will always be 1.
struct	AutoFixRecord
{
	wxString	key;
	wxString	oldAdaptation;
	wxString finalAdaptation;
	int		nWords;
};

// Define type safe pointer lists
#include "wx/listimpl.cpp"

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called AFList.
WX_DEFINE_LIST(AFList);

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called WordList.
WX_DEFINE_LIST(WordList);

IMPLEMENT_DYNAMIC_CLASS(CAdapt_ItView, wxView)
// MFC uses IMPLEMENT_DYNCREATE(CAdapt_ItView, CScrollView)

BEGIN_EVENT_TABLE(CAdapt_ItView, wxView)
	// Event table data copied from Win AI with ON_COMMAND macro
	// changed to EVT_MENU, and ON_UPDATE_COMMAND_UI changed to
	// EVT_UPDATE_UI for wxWidgets
    EVT_SIZE(CAdapt_ItView::OnSize)
    //EVT_SCROLLWIN(CAdapt_ItView::OnScroll) // doesn't do anything in the view, only in the canvas

	// File Menu /////////////////////////////////////////////
	EVT_UPDATE_UI(wxID_NEW, CAdapt_ItView::OnUpdateFileNew)
	EVT_UPDATE_UI(wxID_OPEN, CAdapt_ItView::OnUpdateFileOpen)
	EVT_MENU(ID_FILE_EXPORT_SOURCE, CAdapt_ItView::OnFileExportSource)
	EVT_UPDATE_UI(ID_FILE_EXPORT_SOURCE, CAdapt_ItView::OnUpdateFileExportSource)
	EVT_MENU(ID_FILE_EXPORT, CAdapt_ItView::OnFileExport)
	EVT_UPDATE_UI(ID_FILE_EXPORT, CAdapt_ItView::OnUpdateFileExport)
	// BEW removed 9Dec06, because OnFileExport()
	// will now force UTF-8 conversion always in Unicode app
//#ifdef _UNICODE
//	EVT_MENU(ID_FORCEUTF8, CAdapt_ItView::OnExportTgtTextAsUTF8)
//	EVT_UPDATE_UI(ID_FORCEUTF8, CAdapt_ItView::OnUpdateExportTgtTextAsUTF8)
//#endif
	EVT_MENU(ID_FILE_EXPORT_TO_RTF, CAdapt_ItView::OnFileExportToRtf)
	EVT_UPDATE_UI(ID_FILE_EXPORT_TO_RTF, CAdapt_ItView::OnUpdateFileExportToRtf)
	// Standard printing commands
	EVT_MENU(wxID_PRINT, CAdapt_ItView::OnPrint) // OnFilePrint is the standard MFC one
	EVT_UPDATE_UI(wxID_PRINT, CAdapt_ItView::OnUpdateFilePrint)
	EVT_MENU(wxID_PREVIEW, CAdapt_ItView::OnPrintPreview)
	EVT_UPDATE_UI(wxID_PREVIEW, CAdapt_ItView::OnUpdateFilePrintPreview)
	// According to the wxWidgets developers, the "Print Setup..." menu selection is obsolete since
	// Windows 95. Users are expecte to do any necessary print setup from the main print dialog.
	//EVT_UPDATE_UI(wxID_PRINT_SETUP, CAdapt_ItView::OnUpdateFilePrintSetup)
	EVT_MENU(ID_FILE_STARTUP_WIZARD, CAdapt_ItView::OnFileStartupWizard)
	// OnUpdateFileStartupWizard is in the App
	EVT_MENU(ID_FILE_CLOSEKB, CAdapt_ItView::OnFileCloseProject)
	EVT_UPDATE_UI(ID_FILE_CLOSEKB, CAdapt_ItView::OnUpdateFileCloseKB)
	EVT_MENU(ID_FILE_SAVEKB, CAdapt_ItView::OnFileSaveKB)
	EVT_UPDATE_UI(ID_FILE_SAVEKB, CAdapt_ItView::OnUpdateFileSaveKB)
	// OnFileBackupKb and OnUpdateFileBackupKb are in the App
	// OnFileCheckKb and OnUpdateFileCheckKb are in the App
	// OnFileRestoreKb and OnUpdateFileRestoreKb are in the App
	EVT_MENU(ID_FILE_EXPORT_KB, CAdapt_ItView::OnFileExportKb)
	EVT_UPDATE_UI(ID_FILE_EXPORT_KB, CAdapt_ItView::OnUpdateFileExportKb)
	EVT_MENU(ID_IMPORT_TO_KB, CAdapt_ItView::OnImportToKb)
	EVT_UPDATE_UI(ID_IMPORT_TO_KB, CAdapt_ItView::OnUpdateImportToKb)
	// End of File Menu ///////////////////////////////////

	// Edit Menu //////////////////////////////////////////////////
	EVT_MENU(wxID_UNDO, CAdapt_ItView::OnEditUndo)
	EVT_UPDATE_UI(wxID_UNDO, CAdapt_ItView::OnUpdateEditUndo)
	EVT_MENU(ID_EDIT_CUT, CAdapt_ItView::OnEditCut)
	EVT_UPDATE_UI(ID_EDIT_CUT, CAdapt_ItView::OnUpdateEditCut)
	EVT_MENU(ID_EDIT_COPY, CAdapt_ItView::OnEditCopy)
	EVT_UPDATE_UI(ID_EDIT_COPY, CAdapt_ItView::OnUpdateEditCopy)
	EVT_MENU(ID_EDIT_PASTE, CAdapt_ItView::OnEditPaste)
	EVT_UPDATE_UI(ID_EDIT_PASTE, CAdapt_ItView::OnUpdateEditPaste)
	EVT_MENU(ID_GO_TO, CAdapt_ItView::OnGoTo)
	EVT_UPDATE_UI(ID_GO_TO, CAdapt_ItView::OnUpdateGoTo)
	//EVT_MENU(ID_EDIT_PUNCT_CORRESP, CAdapt_ItView::OnEditPunctCorresp) // incorporated into Edit|Preferences
	//EVT_UPDATE_UI(ID_EDIT_PUNCT_CORRESP, CAdapt_ItView::OnUpdateEditPunctCorresp)// incorporated into Edit|Preferences
	EVT_MENU(ID_EDIT_SOURCE_TEXT, CAdapt_ItView::OnEditSourceText)
	EVT_UPDATE_UI(ID_EDIT_SOURCE_TEXT, CAdapt_ItView::OnUpdateEditSourceText)
	EVT_MENU(ID_EDIT_CONSISTENCY_CHECK, CAdapt_ItView::OnEditConsistencyCheck)
	EVT_UPDATE_UI(ID_EDIT_CONSISTENCY_CHECK, CAdapt_ItView::OnUpdateEditConsistencyCheck)
	EVT_MENU(ID_EDIT_MOVE_NOTE_FORWARD, CAdapt_ItView::OnEditMoveNoteForward)
	EVT_UPDATE_UI(ID_EDIT_MOVE_NOTE_FORWARD, CAdapt_ItView::OnUpdateEditMoveNoteForward)
	EVT_MENU(ID_EDIT_MOVE_NOTE_BACKWARD, CAdapt_ItView::OnEditMoveNoteBackward)
	EVT_UPDATE_UI(ID_EDIT_MOVE_NOTE_BACKWARD, CAdapt_ItView::OnUpdateEditMoveNoteBackward)
	EVT_MENU(wxID_PREFERENCES, CAdapt_ItView::OnEditPreferences)
	EVT_UPDATE_UI(wxID_PREFERENCES, CAdapt_ItView::OnUpdateEditPreferences)
	// End of Edit Menu ///////////////////////////////////////////

	// View Menu //////////////////////////////////////////////////
	//OnViewToolBar is in the MainFrame
	//OnUpdateViewToolBar is in the MainFrame
	//OnViewStatusBar is in the MainFrame
	//OnUpdateViewStatusBar is in the MainFrame
	//OnViewComposeBar is in the MainFrame
	//OnUpdateViewComposeBar is in the MainFrame
	EVT_MENU(ID_COPY_SOURCE, CAdapt_ItView::OnCopySource)
	EVT_UPDATE_UI(ID_COPY_SOURCE, CAdapt_ItView::OnUpdateCopySource) // not in MFC version
	EVT_MENU(ID_MARKER_WRAPS_STRIP, CAdapt_ItView::OnMarkerWrapsStrip)
	EVT_UPDATE_UI(ID_MARKER_WRAPS_STRIP, CAdapt_ItView::OnUpdateMarkerWrapsStrip)
	EVT_MENU(ID_UNITS, CAdapt_ItView::OnUnits)
	EVT_UPDATE_UI(ID_UNITS, CAdapt_ItView::OnUpdateUnits)
	// whm added the following two 16Apr07
	EVT_UPDATE_UI(ID_CHANGE_INTERFACE_LANGUAGE, CAdapt_ItView::OnUpdateChangeInterfaceLanguage)
	EVT_MENU(ID_CHANGE_INTERFACE_LANGUAGE, CAdapt_ItView::OnChangeInterfaceLanguage)
	// End of View Menu ///////////////////////////////////////////

	// Tools Menu /////////////////////////////////////////////////
	EVT_MENU(wxID_FIND, CAdapt_ItView::OnFind)
	EVT_UPDATE_UI(wxID_FIND, CAdapt_ItView::OnUpdateFind)
	EVT_MENU(wxID_REPLACE, CAdapt_ItView::OnReplace)
	EVT_UPDATE_UI(wxID_REPLACE, CAdapt_ItView::OnUpdateReplace)
	// OnToolsDefineCC is in the App
	// OnUpdateLoadCcTables is in the App
	// OnToolsUnloadCcTables is in the App
	// OnUpdateUnloadCcTables is in the App
	EVT_MENU(ID_USE_CC, CAdapt_ItView::OnUseConsistentChanges)
	EVT_UPDATE_UI(ID_USE_CC, CAdapt_ItView::OnUpdateUseConsistentChanges)

	EVT_MENU(ID_USE_SILCONVERTER, CAdapt_ItView::OnUseSilConverter)
	EVT_UPDATE_UI(ID_USE_SILCONVERTER, CAdapt_ItView::OnUpdateUseSilConverter)

	EVT_MENU(ID_TOOLS_DEFINE_SILCONVERTER, CAdapt_ItView::OnSelectSilConverters)
	EVT_UPDATE_UI(ID_TOOLS_DEFINE_SILCONVERTER, CAdapt_ItView::OnUpdateSelectSilConverters)


	EVT_MENU(ID_ACCEPT_CHANGES, CAdapt_ItView::OnAcceptChanges)
	EVT_UPDATE_UI(ID_ACCEPT_CHANGES, CAdapt_ItView::OnUpdateAcceptChanges)
	EVT_MENU(ID_TOOLS_KB_EDITOR, CAdapt_ItView::OnToolsKbEditor)
	EVT_UPDATE_UI(ID_TOOLS_KB_EDITOR, CAdapt_ItView::OnUpdateToolsKbEditor)
	// OnToolsAutoCapitalization is in the App
	// OnUpdateToolsAutoCapitalization is in the App
	EVT_MENU(ID_RETRANS_REPORT, CAdapt_ItView::OnRetransReport) // uncomment to activate
	EVT_UPDATE_UI(ID_RETRANS_REPORT, CAdapt_ItView::OnUpdateRetransReport)
	// End of Tools Menu //////////////////////////////////////////

	// Advanced Menu //////////////////////////////////////////////
	// Event for Enable/Disable Glossing menu item
	EVT_MENU(ID_ADVANCED_ENABLEGLOSSING, CAdapt_ItView::OnAdvancedEnableglossing)
	EVT_UPDATE_UI(ID_ADVANCED_ENABLEGLOSSING, CAdapt_ItView::OnUpdateAdvancedEnableglossing)
	// Event for Glossing Uses Nav Font menu item
	EVT_MENU(ID_ADVANCED_GLOSSING_USES_NAV_FONT, CAdapt_ItView::OnAdvancedGlossingUsesNavFont)
	EVT_UPDATE_UI(ID_ADVANCED_GLOSSING_USES_NAV_FONT, CAdapt_ItView::OnUpdateAdvancedGlossingUsesNavFont)
	// Event for Remove Punctuations When Storing Glosses menu item - two below removed in version 3
	// OnAdvancedTransformAdaptationsIntoGlosses is in the App
	// OnUpdateAdvancedTransformAdaptationsIntoGlosses is in the App
	EVT_MENU(ID_ADVANCED_DELAY, CAdapt_ItView::OnAdvancedDelay) // uncomment to activate
	EVT_UPDATE_UI(ID_ADVANCED_DELAY, CAdapt_ItView::OnUpdateAdvancedDelay)
	EVT_MENU(ID_ADVANCED_FREE_TRANSLATION_MODE, CAdapt_ItView::OnAdvancedFreeTranslationMode)
	EVT_UPDATE_UI(ID_ADVANCED_FREE_TRANSLATION_MODE, CAdapt_ItView::OnUpdateAdvancedFreeTranslationMode)
	EVT_MENU(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT, CAdapt_ItView::OnAdvancedTargetTextIsDefault)
	EVT_UPDATE_UI(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT, CAdapt_ItView::OnUpdateAdvancedTargetTextIsDefault)
	EVT_MENU(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT, CAdapt_ItView::OnAdvancedGlossTextIsDefault)
	EVT_UPDATE_UI(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT, CAdapt_ItView::OnUpdateAdvancedGlossTextIsDefault)
	EVT_UPDATE_UI(ID_ADVANCED_COLLECT_BACKTRANSLATIONS, CAdapt_ItView::OnUpdateAdvancedCollectBacktranslations)
	EVT_MENU(ID_ADVANCED_COLLECT_BACKTRANSLATIONS, CAdapt_ItView::OnAdvancedCollectBacktranslations)
	EVT_MENU(ID_ADVANCED_REMOVE_FILTERED_BACKTRANSLATIONS, CAdapt_ItView::OnAdvancedRemoveFilteredBacktranslations)
	EVT_UPDATE_UI(ID_ADVANCED_REMOVE_FILTERED_BACKTRANSLATIONS, CAdapt_ItView::OnUpdateAdvancedRemoveFilteredBacktranslations)
	EVT_MENU(ID_ADVANCED_REMOVE_FILTERED_FREE_TRANSLATIONS, CAdapt_ItView::OnAdvancedRemoveFilteredFreeTranslations)
	EVT_UPDATE_UI(ID_ADVANCED_REMOVE_FILTERED_FREE_TRANSLATIONS, CAdapt_ItView::OnUpdateAdvancedRemoveFilteredFreeTranslations)
	//EVT_MENU(ID_EDIT_MOVE_NOTE_FORWARD, CAdapt_ItView::OnEditMoveNoteForward)
	//EVT_UPDATE_UI(ID_EDIT_MOVE_NOTE_FORWARD, CAdapt_ItView::OnUpdateEditMoveNoteForward)
	//EVT_MENU(ID_EDIT_MOVE_NOTE_BACKWARD, CAdapt_ItView::OnEditMoveNoteBackward)
	//EVT_UPDATE_UI(ID_EDIT_MOVE_NOTE_BACKWARD, CAdapt_ItView::OnUpdateEditMoveNoteBackward)

	// TODO: Uncomment these after COM equivalent is implemented
	EVT_MENU(ID_ADVANCED_USETRANSLITERATIONMODE, CAdapt_ItView::OnAdvancedUseTransliterationMode)
	EVT_UPDATE_UI(ID_ADVANCED_USETRANSLITERATIONMODE, CAdapt_ItView::OnUpdateAdvancedUseTransliterationMode)
	// End of Advanced Menu ////////////////////////////////////////

//#ifdef _UNICODE
	// Layout Menu
	EVT_MENU(ID_ALIGNMENT, CAdapt_ItView::OnAlignment)
	EVT_UPDATE_UI(ID_ALIGNMENT, CAdapt_ItView::OnUpdateAlignment)
//#endif

	// Help menu
	//OnAppAbout is in CMainFrame in wxWidgets version

	// ControlBar event handlers
	EVT_CHECKBOX(IDC_CHECK_ISGLOSSING, CAdapt_ItView::OnCheckIsGlossing)
	EVT_RADIOBUTTON(IDC_RADIO_DRAFTING, CAdapt_ItView::OnRadioDrafting)
	EVT_RADIOBUTTON(IDC_RADIO_REVIEWING, CAdapt_ItView::OnRadioReviewing)
	EVT_CHECKBOX(IDC_CHECK_SINGLE_STEP, CAdapt_ItView::OnCheckSingleStep)
	EVT_CHECKBOX(IDC_CHECK_KB_SAVE, CAdapt_ItView::OnCheckKBSave)
	EVT_CHECKBOX(IDC_CHECK_FORCE_ASK, CAdapt_ItView::OnCheckForceAsk)
	EVT_BUTTON(IDC_BUTTON_NO_ADAPT, CAdapt_ItView::OnButtonNoAdapt)

	// ToolBar event handlers ////////////////////////////////////
	// whm modified 21Sep08 Removed the two toggle buttons that switch from 1 line to 2 line source/target display
	// Toggle source lines
	//EVT_TOOL(ID_BUTTON_TOGGLE_SOURCE_LINES, CAdapt_ItView::OnButtonToggleSourceLines)
	//EVT_UPDATE_UI(ID_BUTTON_TOGGLE_SOURCE_LINES, CAdapt_ItView::OnUpdateButtonToggleSourceLines)
	// Toggle target lines
	//EVT_TOOL(ID_BUTTON_TOGGLE_TARGET_LINES, CAdapt_ItView::OnButtonToggleTargetLines)
	//EVT_UPDATE_UI(ID_BUTTON_TOGGLE_TARGET_LINES, CAdapt_ItView::OnUpdateButtonToggleTargetLines)
	// Event for Enable/Disable Punct copy
	EVT_TOOL(ID_BUTTON_ENABLE_PUNCT_COPY, CAdapt_ItView::OnButtonEnablePunctCopy)
	EVT_UPDATE_UI(ID_BUTTON_ENABLE_PUNCT_COPY, CAdapt_ItView::OnUpdateButtonEnablePunctCopy)
	EVT_TOOL(ID_BUTTON_NO_PUNCT_COPY, CAdapt_ItView::OnButtonNoPunctCopy)
	EVT_UPDATE_UI(ID_BUTTON_NO_PUNCT_COPY, CAdapt_ItView::OnUpdateButtonNoPunctCopy)
	// Event for Respect/Ignore boundary controlBar button
    EVT_TOOL(ID_BUTTON_RESPECTING_BDRY, CAdapt_ItView::OnButtonFromRespectingBdryToIgnoringBdry)
    EVT_UPDATE_UI(ID_BUTTON_RESPECTING_BDRY, CAdapt_ItView::OnUpdateButtonRespectBdry)
    EVT_TOOL(ID_BUTTON_IGNORING_BDRY, CAdapt_ItView::OnButtonFromIgnoringBdryToRespectingBdry)
    EVT_UPDATE_UI(ID_BUTTON_IGNORING_BDRY, CAdapt_ItView::OnUpdateButtonIgnoreBdry)
	// Event for Show/Hide Punctuation controlBar button
	EVT_TOOL(ID_BUTTON_SHOWING_PUNCT, CAdapt_ItView::OnButtonFromShowingToHidingPunct)
	EVT_UPDATE_UI(ID_BUTTON_SHOWING_PUNCT, CAdapt_ItView::OnUpdateButtonShowPunct)
    EVT_TOOL(ID_BUTTON_HIDING_PUNCT, CAdapt_ItView::OnButtonFromHidingToShowingPunct)
	EVT_UPDATE_UI(ID_BUTTON_HIDING_PUNCT, CAdapt_ItView::OnUpdateButtonHidePunct)
	// Event for Show Target/Show All controlBar button
	EVT_TOOL(ID_SHOWING_ALL, CAdapt_ItView::OnFromShowingAllToShowingTargetOnly)
	EVT_UPDATE_UI(ID_SHOWING_ALL, CAdapt_ItView::OnUpdateShowTgt)
	EVT_TOOL(ID_SHOWING_TGT, CAdapt_ItView::OnFromShowingTargetOnlyToShowingAll)
	EVT_UPDATE_UI(ID_SHOWING_TGT, CAdapt_ItView::OnUpdateShowAll)
	EVT_TOOL(ID_BUTTON_CREATE_NOTE, CAdapt_ItView::OnButtonCreateNote)
	EVT_UPDATE_UI(ID_BUTTON_CREATE_NOTE, CAdapt_ItView::OnUpdateButtonCreateNote)
	EVT_TOOL(ID_BUTTON_PREV_NOTE, CAdapt_ItView::OnButtonPrevNote)
	EVT_UPDATE_UI(ID_BUTTON_PREV_NOTE, CAdapt_ItView::OnUpdateButtonPrevNote)
	EVT_TOOL(ID_BUTTON_NEXT_NOTE, CAdapt_ItView::OnButtonNextNote)
	EVT_UPDATE_UI(ID_BUTTON_NEXT_NOTE, CAdapt_ItView::OnUpdateButtonNextNote)
	EVT_TOOL(ID_BUTTON_DELETE_ALL_NOTES, CAdapt_ItView::OnButtonDeleteAllNotes)
	EVT_UPDATE_UI(ID_BUTTON_DELETE_ALL_NOTES, CAdapt_ItView::OnUpdateButtonDeleteAllNotes)
	EVT_TOOL(ID_BUTTON_TO_END, CAdapt_ItView::OnButtonToEnd)
	EVT_UPDATE_UI(ID_BUTTON_TO_END, CAdapt_ItView::OnUpdateButtonToEnd)
	EVT_TOOL(ID_BUTTON_TO_START, CAdapt_ItView::OnButtonToStart)
	EVT_UPDATE_UI(ID_BUTTON_TO_START, CAdapt_ItView::OnUpdateButtonToStart)
	EVT_TOOL(ID_BUTTON_STEP_DOWN, CAdapt_ItView::OnButtonStepDown)
	EVT_UPDATE_UI(ID_BUTTON_STEP_DOWN, CAdapt_ItView::OnUpdateButtonStepDown)
	EVT_TOOL(ID_BUTTON_STEP_UP, CAdapt_ItView::OnButtonStepUp)
	EVT_UPDATE_UI(ID_BUTTON_STEP_UP, CAdapt_ItView::OnUpdateButtonStepUp)
	EVT_TOOL(ID_BUTTON_BACK, CAdapt_ItView::OnButtonBack)
	EVT_UPDATE_UI(ID_BUTTON_BACK, CAdapt_ItView::OnUpdateButtonBack)
	EVT_TOOL(ID_BUTTON_MERGE, CAdapt_ItView::OnButtonMerge)
	EVT_UPDATE_UI(ID_BUTTON_MERGE, CAdapt_ItView::OnUpdateButtonMerge)
	EVT_TOOL(ID_BUTTON_RESTORE, CAdapt_ItView::OnButtonRestore)
	EVT_UPDATE_UI(ID_BUTTON_RESTORE, CAdapt_ItView::OnUpdateButtonRestore)
	EVT_TOOL(ID_BUTTON_RETRANSLATION, CAdapt_ItView::OnButtonRetranslation)
	EVT_UPDATE_UI(ID_BUTTON_RETRANSLATION, CAdapt_ItView::OnUpdateButtonRetranslation)
	EVT_TOOL(ID_BUTTON_EDIT_RETRANSLATION, CAdapt_ItView::OnButtonEditRetranslation)
	EVT_UPDATE_UI(ID_BUTTON_EDIT_RETRANSLATION, CAdapt_ItView::OnUpdateButtonEditRetranslation)
	EVT_TOOL(ID_REMOVE_RETRANSLATION, CAdapt_ItView::OnRemoveRetranslation)
	EVT_UPDATE_UI(ID_REMOVE_RETRANSLATION, CAdapt_ItView::OnUpdateRemoveRetranslation)
	EVT_TOOL(ID_BUTTON_NULL_SRC, CAdapt_ItView::OnButtonNullSrc)
    EVT_UPDATE_UI(ID_BUTTON_NULL_SRC, CAdapt_ItView::OnUpdateButtonNullSrc)
	EVT_TOOL(ID_BUTTON_REMOVE_NULL_SRCPHRASE, CAdapt_ItView::OnButtonRemoveNullSrcPhrase)
	EVT_UPDATE_UI(ID_BUTTON_REMOVE_NULL_SRCPHRASE, CAdapt_ItView::OnUpdateButtonRemoveNullSrcPhrase)
	EVT_TOOL(ID_BUTTON_CHOOSE_TRANSLATION, CAdapt_ItView::OnButtonChooseTranslation)
	EVT_UPDATE_UI(ID_BUTTON_CHOOSE_TRANSLATION, CAdapt_ItView::OnUpdateButtonChooseTranslation)
	EVT_TOOL(ID_BUTTON_EARLIER_TRANSLATION, CAdapt_ItView::OnButtonEarlierTranslation)
	EVT_UPDATE_UI(ID_BUTTON_EARLIER_TRANSLATION, CAdapt_ItView::OnUpdateButtonEarlierTranslation)
	// handler for Help button here
	// End of ToolBar event handlers ///////////////////////////////

	// ComposeBar handlers
	EVT_BUTTON(IDC_BUTTON_CLEAR, CAdapt_ItView::OnClearContentsButton)
	EVT_BUTTON(IDC_BUTTON_SELECT_ALL, CAdapt_ItView::OnSelectAllButton)

	// Free Translation - Composebar Buttons ///////////////////////
	EVT_BUTTON(IDC_BUTTON_APPLY, CAdapt_ItView::OnAdvanceButton)
	EVT_UPDATE_UI(IDC_BUTTON_NEXT, CAdapt_ItView::OnUpdateNextButton)
	EVT_BUTTON(IDC_BUTTON_NEXT, CAdapt_ItView::OnNextButton)
	EVT_UPDATE_UI(IDC_BUTTON_PREV, CAdapt_ItView::OnUpdatePrevButton)
	EVT_BUTTON(IDC_BUTTON_PREV, CAdapt_ItView::OnPrevButton)
	EVT_UPDATE_UI(IDC_BUTTON_REMOVE, CAdapt_ItView::OnUpdateRemoveFreeTranslationButton)
	EVT_BUTTON(IDC_BUTTON_REMOVE, CAdapt_ItView::OnRemoveFreeTranslationButton)
	EVT_UPDATE_UI(IDC_BUTTON_LENGTHEN, CAdapt_ItView::OnUpdateLengthenButton)
	EVT_BUTTON(IDC_BUTTON_LENGTHEN, CAdapt_ItView::OnLengthenButton)
	EVT_UPDATE_UI(IDC_BUTTON_SHORTEN, CAdapt_ItView::OnUpdateShortenButton)
	EVT_BUTTON(IDC_BUTTON_SHORTEN, CAdapt_ItView::OnShortenButton)
	EVT_RADIOBUTTON(IDC_RADIO_PUNCT_SECTION, CAdapt_ItView::OnRadioDefineByPunctuation)
	EVT_RADIOBUTTON(IDC_RADIO_VERSE_SECTION, CAdapt_ItView::OnRadioDefineByVerse)

	// The following added for Vertical Editing by BEW
	EVT_UPDATE_UI(IDC_BUTTON_UNDO_LAST_COPY, CAdapt_ItView::OnUpdateButtonUndoLastCopy)
	EVT_BUTTON(IDC_BUTTON_UNDO_LAST_COPY, CAdapt_ItView::OnButtonUndoLastCopy)
	EVT_UPDATE_UI(IDC_BUTTON_PREV_STEP, CAdapt_ItView::OnUpdateButtonPrevStep)
	EVT_BUTTON(IDC_BUTTON_PREV_STEP, CAdapt_ItView::OnButtonPrevStep)
	EVT_UPDATE_UI(IDC_BUTTON_NEXT_STEP, CAdapt_ItView::OnUpdateButtonNextStep)
	EVT_BUTTON(IDC_BUTTON_NEXT_STEP, CAdapt_ItView::OnButtonNextStep)
	EVT_UPDATE_UI(ID_BUTTON_END_NOW, CAdapt_ItView::OnUpdateButtonEndNow)
	EVT_BUTTON(ID_BUTTON_END_NOW, CAdapt_ItView::OnButtonEndNow)
	EVT_UPDATE_UI(ID_BUTTON_CANCEL_ALL_STEPS, CAdapt_ItView::OnUpdateButtonCancelAllSteps)
	EVT_BUTTON(ID_BUTTON_CANCEL_ALL_STEPS, CAdapt_ItView::OnButtonCancelAllSteps)
	// handlers for custom events
	// These custom events are implemented in CMainFrame in the wx version:
	//ON_REGISTERED_MESSAGE(CUSTOM_EVENT_ADAPTATIONS_EDIT, OnCustomEventAdaptationsEdit)
	//ON_REGISTERED_MESSAGE(CUSTOM_EVENT_GLOSSES_EDIT, OnCustomEventGlossesEdit)
	//ON_REGISTERED_MESSAGE(CUSTOM_EVENT_FREE_TRANSLATIONS_EDIT, OnCustomEventFreeTranslationsEdit)
	//ON_REGISTERED_MESSAGE(CUSTOM_EVENT_END_VERTICAL_EDIT, OnCustomEventEndVerticalEdit)
	//ON_REGISTERED_MESSAGE(CUSTOM_EVENT_END_VERTICAL_EDIT, OnCustomEventCancelVerticalEdit)
	//ON_REGISTERED_MESSAGE(CUSTOM_EVENT_BACK_TRANSLATIONS_EDIT, OnCustomEventBackTranslationsEdit)

	// Mouse events
	//EVT_LEFT_DOWN(CAdapt_ItView::OnLButtonDown) // moved to CAdapt_ItCanvas
	//EVT_LEFT_UP(CAdapt_ItView::OnLButtonUp) // moved to CAdapt_ItCanvas
	//EVT_MOTION(CAdapt_ItView::OnMouseMove) // moved to CAdapt_ItCanvas
END_EVENT_TABLE()

/*
The following are the remaining event handlers from the MFC version:
BEGIN_MESSAGE_MAP(CAdapt_ItView, CScrollView)
	ON_WM_SIZE()
	ON_WM_LBUTTONUP()
	ON_WM_CAPTURECHANGED()
//	ON_UPDATE_COMMAND_UI(ID_RICH_ED, OnUpdateRichEd)
//	ON_COMMAND(ID_RICH_ED, OnRichEd)
//	ON_UPDATE_COMMAND_UI(ID_EDIT_MARKERS, OnUpdateEditMarkers)
//	ON_COMMAND(ID_EDIT_MARKERS, OnEditMarkers)
END_MESSAGE_MAP()
*/

CAdapt_ItView::CAdapt_ItView()
{
	// whm All MFC's View variable initializations moved to the App

	// below unique to wxWidgets version
	canvas = (CAdapt_ItCanvas*) NULL;
	pCanvasFrame = (wxFrame*) NULL;
}

CAdapt_ItView::~CAdapt_ItView() // whm added
{
	// All cleanup is to be done in App's OnExit() function
}

// Can be used for default print/preview
// as well as drawing on the screen
void CAdapt_ItView::OnDraw(wxDC *pDC)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	if (pApp->m_pBundle == NULL) // MFC had == 0
		return; // nothing to draw
	if (pApp->m_pBundle->m_nStripCount == 0)
		return; // still nothing to draw

	// BEW added 7Jul05,calculate the global rectangle, in logical coords and offset as appropriate,
	// which is to be used in rectangle intersection calculations to suppress unneeded drawing and
	// calculations for this not visible in the client area of the view (moved to here from Strip.cpp)
	// whm Note: The idea here is to only draw the piles for strips
	// which are visible within the client view area of the screen (the
	// pApp->m_curLeading taken into account).
	wxClientDC viewDC((wxWindow*)pApp->GetMainFrame()->canvas);//wxClientDC viewDC((wxWindow*)m_pBundle->m_pView->canvas);
	canvas->DoPrepareDC(viewDC); //pApp->m_pBundle->m_pView->OnPrepareDC(&viewDC);	// sets the origins and extents, calls the OnPrepareDC base classe
								// in MFC, calls DoPrepareDC in wx.
	canvas->pFrame->PrepareDC(viewDC); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame


	// NOTE: The docs on MFC's GetClientRect() say: "The client coordinates
	// specify the upper-left and lower-right corners of the client area. Since
	// client coordinates are relative to the upper-left corners of the CWnd
	// client area, the coordinates of the upper-left corner are (0,0)."
	// The wxWidgets docs on wxWindow::GetClientSize (which takes
	// int width and int height values), say, GetClientSize "gets the size of the
	// window 'client area' in pixels. The client area is the area which may be
	// drawn on by the programmer, excluding title bar, border, scrollbars,
	// etc." and "...GetClientSize is "more device-independent than wxWindow::GetSize,
	// since the application need not worry about what dimensions the border or title
	// bar have when trying to fit the windows around panel items, for example."
	// whm additional note: for grectViewClient, we must get the visible size of the
	// Adapt It canvas, not just the client size reported for the main frame (CMainFrame), 
	// and its managed sub-windows. The reason is because, MFC's main frame manages 
	// more of its sub-windows than the wx version's main frame when it comes to the
	// reporting of the actual client view's dimensions. We use our own GetCanvasClientSize()
	// which is on the main frame.

	//m_pBundle->m_pView->GetClientRect(&grectViewClient); // set the global rect used for speeding drawing
	//pApp->GetMainFrame()->canvas->GetClientSize(&grectViewClient.width,&grectViewClient.height);// gets the width and height in pixels
	wxSize canvasViewSize;
	canvasViewSize = pApp->GetMainFrame()->GetCanvasClientSize(); // gets the width and height of canvas in pixels

	// Note on setting up grectViewClient global for speed drawing in other routines:
	// The upper left coordinates of grectViewClient need to be in logical units. Once
	// in logical units, the upper-left coord is not (0,0) unless the canvas has not been
	// scrolled down. For Adapt It, the x coordinate always remains 0 because we don't do
	// horizontal scrolling. Once in logical units, the y coordinate varies depending on
	// the current scroll position.
	// GetClientSize() always returns device units (not logical ones) so the upper-left x,y
	// coordinate of grectViewClient will always be (0,0) after the GetClientSize call.
	// Hence we must convert the y coord of the current view's upper left coord to logical units
	// representing the number of pixels from the actual (logical) window origin regardless of
	// the window's scrolled position.

	// Possible alternatives for converting the client view coords to logical ones are:
	// 1. Use the DC's DeviceToLogicalX, DeviceToLogicalY functions (similar to MFC code).
	// 2. Use GetViewStart (which gets the current coords of the viewport in logical
	//    scroll units) along with GetScrollPixelsPerUnit (which gets the number of
	//    pixels per scroll unit);
	// 3. Use CalcUnscrolledPosition which takes care of the conversion of scroll units to pixels.
	// WX Implementation: After thorough testing it is clear that any of the three possibilities 
	// works ok when correctly implemented. Since CalcUnscrolledPosition involves the least
	// amount of variable declarations and calculations, I think it is the best choice for
	// calculating logical positions in most of our scrolling and positioning routines.

//#ifdef _DEBUG
//	// Here's sample code for alternative 1:
//	// save a copy of the initial grectViewClient values for use below (alternative 2 changes grectViewClient)
//	wxRect testRectViewClient = grectViewClient;
//#endif

	//// Here's sample code for alternative 2:
	//int xScrollUnits, yScrollUnits, xOrigin, yOrigin;
	//pApp->GetMainFrame()->canvas->GetViewStart(&xOrigin, &yOrigin); // gets xOrigin and yOrigin in scroll units
	//pApp->GetMainFrame()->canvas->GetScrollPixelsPerUnit(&xScrollUnits, &yScrollUnits); // gets pixels per scroll unit
	//grectViewClient.x = xOrigin * xScrollUnits; // number pixels is ScrollUnits * pixelsPerScrollUnit
	//grectViewClient.y = yOrigin * yScrollUnits;


//#ifdef _DEBUG
//	// Here's the code for alternative 3: (with CalcUnscrolledPosition)
//	int newXPos,newYPos;
//	pApp->GetMainFrame()->canvas->CalcUnscrolledPosition(0,0,&newXPos,&newYPos);
//	wxASSERT(newXPos == grectViewClient.x); //grectViewClient.x = newXPos;
//	wxASSERT(newYPos == grectViewClient.y); //grectViewClient.y = newYPos;
//#endif

//#ifdef _DEBUG
	//viewDC.DPtoLP(&grectViewClient); // MFC: get the point converted to logical coords
//	// alternative 1 (continued from above)
//	int x = viewDC.DeviceToLogicalX(testRectViewClient.x);// get the device X (width) coord converted to logical coord
//	int y = viewDC.DeviceToLogicalY(testRectViewClient.y); // get the device Y (height) coord converted to logical coord
//	wxASSERT(x == grectViewClient.x);
//	wxASSERT(y == grectViewClient.y);
//#endif
	
	// set grectViewClient's upper left coords to be the logical scrolled position
	pApp->GetMainFrame()->canvas->CalcUnscrolledPosition(0,0,&grectViewClient.x,&grectViewClient.y);
	//wxLogDebug(_T("View::OnDraw CalcUnscrolledPosition: grectViewClient.x = %d grectViewClient.y = %d"),grectViewClient.x,grectViewClient.y);
	// set the width and height of the grectViewClient rect
	grectViewClient.width = canvasViewSize.x;
	grectViewClient.height = canvasViewSize.y;

#ifdef _LOG_DEBUG_DRAWING
		wxLogDebug(_T("\nBundle Start:"));
#endif

	pDC->DestroyClippingRegion(); // whm added 2May07 to try to resolve the paint issue on wxMac
	
	// draw the layout
	pApp->m_pBundle->Draw(pDC);

	// BEW added 7Jul05 for drawing the free translation text substrings in the spaces created under
	// each of the strips (drawing is not done outside the client area for the view)- but only when
	// we are not currently printing
	if (gpApp->m_bFreeTranslationMode && !gbIsPrinting)
	{
		//const wxString nullStr = _T("");
		DrawFreeTranslations(pDC, pApp->m_pBundle, call_from_ondraw);
	}

	//m_targetBox.Invalidate(); // Bruce's MFC Note 20Dec07: ensure a box draw is done later than any paint of the layout
							    // (Review mode needs this for a click at a hole & subsequent Enter press,
								// as that leaves the box invisible & it remains so for subsequent holes)
							    // Nope, this don't work either, neither does UpdateWindow() here, .... 
								// back to the drawing board
}

// MFC docs say that OnInitialUpdate() is "Called by the framework after the view
// is first attached to the document, but before the view is initially displayed. The
// default implementation of this function calls the OnUpdate member function with no
// hint information (that is, using the default values of 0 for the IHint parameter
// and NULL for the pHint parameter)."
// Design Note: Test of all MFC routines that could potentially call OnInitialUpdate()
// in the App show that OnInitialUpdate() is actually only called at the following
// times in the MFC code:
// 1. At end of OnInit() when app is initially run before the main frame appears (OnInit
//    explicitly calls pView->OnInitialUpdate().
// 2. When File | New menu selection is made (
// 3. When Loading a file from the MRU list.
// 4. When the main window is split (observed Jan07)
// OnInitialUpdate() should be called for only two main scenarios
// (1) for File | New, and (2) when loading a file from the MRU list. It
// doesn't really need to be called in OnInit() because the CreateDocument()
// call there triggers a File | New scenario which includes the OnInitialUpdate()
// call. See notes in App's OnInit().
// TODO: Splitting of the main window in the wxWidgets version is not yet implemented, but
// if/when it is implemented it should be tested to see if OnInitialUpdate should be
// called for that situation too.
void CAdapt_ItView::OnInitialUpdate()
{
	// CScrollView::OnInitialUpdate(); // not in wx
	wxCommandEvent dummyevent; // for use in EVT governed function calls
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();

	// get the checkbox pointer for glossing, and hide it when app is first launched
	// (a command on the Advanced menu can be used for showing it later on); but since we
	// can get here from closing a doc and then creating or opening another, the gbIsGlossing
	// flag might be TRUE - in which case we will leave it unchanged and not hide the checkbox,
	// because presumably once the user is doing glossing, if he works on another document he
	// will most likely be glossing that too (or so we will assume)
	//
	// NOTE: wxWidgets version - this is taken care of in the App's OnInit()
	//
	CMainFrame *pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	// This below done in the App's OnInit()
	//CButton* pCheckboxIsGlossing = (CButton*)pBar->GetDlgItem(IDC_CHECK_ISGLOSSING);
	//if (!gbIsGlossing)
	//{
	//	pCheckboxIsGlossing->SetCheck(0); // not glossing, ie. is adapting
	//	pCheckboxIsGlossing->ShowWindow(SW_HIDE);
	//}

	// update the copy shown on mode bar (it's read only there)
	//CEdit* pDelayBox = (CEdit*)pBar->GetDlgItem(IDC_EDIT_DELAY);
	//ASSERT(pDelayBox);
	wxTextCtrl* pDelayBox = (wxTextCtrl*)pControlBar->FindWindowById(IDC_EDIT_DELAY);
	wxASSERT(pDelayBox != NULL);
	wxString s;
	//wxChar buf[34];
	////_itot(pApp->m_nCurDelay,buf,10); // MFC had gpApp but gpApp was null so changed it to pApp->m_nCurDelay
	//wxSnprintf(buf, 34, "%d", pApp->m_nCurDelay);
	s.Empty();
	s << gpApp->m_nCurDelay; //s = buf;
	pDelayBox->SetValue(s); // MFC has SetWindowText()
	pControlBar->Refresh(); // MFC has Invalidate()

	// MFC code below:
	// add the extra menu if it is the Unicode version
#ifdef _RTL_FLAGS
	// Note: The wx version starts with the Layout menu and removes it in the App's OnInit()
	//pApp->AddMenuForNR();
	// call AdjustAlignmentMenu to insure that the Layout menu items text is set correctly
	AdjustAlignmentMenu(gbRTLLayout,gbLTRLayout);

	// set the global formats for RTL and LTR based on gnFormat which has basic style bits set
	// MFC has the following flags set:
	//gnRTLFormat = gnFormat | DT_RIGHT | DT_RTLREADING;
	//gnLTRFormat = gnFormat | DT_LEFT;
	// whm note: MFC docs say of DT_LEFT, DT_RIGHT and DT_RTLREADING:
	//    "DT_LEFT - Aligns text to the left."
	//    "DT_RIGHT - Aligns text to the right."
	//    "DT_RTLREADING - Layout in right-to-left reading order for bi-directional text when the 
	//                    font selected into the hdc is a Hebrew or Arabic font. The default 
	//                    reading order for all text is left-to-right."

#endif // for _RTL_FLAGS


	// MFC docs say for CObList::RemoveAll() that it "Removes all the elements
	// from this list and frees the associated CObList memory...No error is
	// generated if the list is already empty. When you remove elements from
	// a CObList, you remove the object pointers from the list. It is your
	// responsibility to delete the objects themselves."
	// I assume the best wxList equivalent is wxList::Clear() which "Clears
	// the list (but does not delete the client data stored with each node
	// unless you called DeleteContents(TRUE), in which case it deletes data)."
	gpApp->m_selection.Clear(); // MFC had RemoveAll()
	gpApp->m_pAnchor = (CCell*)NULL;
	gpApp->m_selectionLine = -1;

	// need to ensure the initial targetPhrase box's text is not lost across the next calls
	wxString saveText = gpApp->m_targetPhrase;
	int saveActiveSN = gpApp->m_nActiveSequNum;

	// WX Note: The App's color member are now set directly without short forms specialTextColor etc.
	
	if (!gbShowTargetOnly)
	{
		gnSaveLeading = gpApp->m_curLeading;
		gnSaveGap = gpApp->m_curGapWidth;
		gbShowTargetOnly = TRUE;
		OnFromShowingTargetOnlyToShowingAll(dummyevent); // normal view, showing source & target lines
	}
	if (!gpApp->m_bHidePunctuation)
	{
		gpApp->m_bHidePunctuation = TRUE; // the function call will reset it to FALSE
		OnButtonFromHidingToShowingPunct(dummyevent); // make punctuation visible in lines 2 & 3, if 2-line display
	}
	if (gpApp->m_bCopySourcePunctuation)
	{
		gpApp->m_bCopySourcePunctuation = FALSE; // the function call will reset it to TRUE
		OnButtonEnablePunctCopy(dummyevent); // enable automatic copying of source text punctuation
	}

	if (gpApp->m_bMarkerWrapsStrip)
	{
		// make sure the menu item is shown with checkmark
		gpApp->m_bMarkerWrapsStrip = FALSE; // the function call will set it to TRUE
		OnMarkerWrapsStrip(dummyevent);
	}
	if (gpApp->m_bCopySource)
	{
		// make sure the Copy Source menu item is shown with checkmark
		gpApp->m_bCopySource = FALSE;
		OnCopySource(dummyevent); // toggle it ON, and set the checkmark
	}

	// wx version: the Save As XML menu item is always shown with checkmark and cannot be changed

	// TODO: Uncomment below after COM equivalent is implemented
	//if (gpApp->m_bTransliterationMode)
	//{
	//	// make sure the Use Transliteration Mode menu item is shown with checkmark
	//	gpApp->m_bTransliterationMode = FALSE;
	//	OnAdvancedUseTransliterationMode(dummyevent); // toggle it ON, and set the checkmark
	//}
	//else
	//{
	//	// make sure the Use Transliteration Mode menu item is shown without checkmark
	//	gpApp->m_bTransliterationMode = TRUE;
	//	OnAdvancedUseTransliterationMode(dummyevent); // toggle it OFF, and clear the checkmark
	//}

	if (gbIgnoreScriptureReference_Receive)
	{
		// scripture reference receiving starts out turned off, so get
		// the command unticked (meaning 'it is disabled', that is, turned off)
		gbIgnoreScriptureReference_Receive = FALSE;
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedReceiveSynchronizedScrollingMessages(uevent); //toggle flag to TRUE ie. OFF
	}
	if (gbIgnoreScriptureReference_Send)
	{
		// scripture reference sending starts out turned off, so get
		// the command unticked (meaning 'it is disabled', that is, turned off)
		gbIgnoreScriptureReference_Send = FALSE;
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedSendSynchronizedScrollingMessages(uevent); //toggle flag to TRUE ie. OFF
	}

	// turn the Drafting radio button ON, on the toolbar
	OnRadioDrafting(dummyevent);

	// set the pointer to the save list
	gpApp->m_pSaveList = &gpApp->m_saveList;
	
	// At this point the MFC version copies printing variables from those it had on the App to those it
	// maintined here in the View. Since the wx version maintains its printing variable on the App, and
	// they get updated when the config files are read from the App's OnInit(), it is not necessary to 

	gpApp->SetPageOrientation(gpApp->m_bIsPortraitOrientation);

	wxASSERT(pFrame);
	pFrame->SetSize(gpApp->m_ptViewTopLeft.x,
											gpApp->m_ptViewTopLeft.y,
											gpApp->m_szView.x,
											gpApp->m_szView.y,
											wxSIZE_AUTO);

	// Our wxWidgets' wxScrolledWindow is handled by the CAdapt_ItCanvas class.
	// From wxScrolledWindow documentation and samples for info on setting
	// up a sizer to help manage scrolling. Methods of wxScrolledWindow particular
	// interest include:
	// void GetViewStart(int* x, int* y) const. Gets the position at which the
	//		visible portion of the window starts. x receives the first visible x
	//		position in scroll units, y receives the first visible y position in
	//		scroll units. If either of the scrollbars is not at the home position
	//		x and/or y will be greater than zero. Combined with wxWindow::GetClientSize
	//		the application can use this function to efficiently redraw only the
	//		visible portion of the window. The positions are in logical scroll units
	//		not pixels, so to convert to pixels you multiply by the number of
	//		pixels per scroll increment.
	// void GetVirtualSize(int* x, int* y) const. Gets the size in device units of
	//		the scrollable window area (as opposed to the client size, which is the
	//		area of the window currently visible). Parameter x receives the length
	//		of the scrollable window, in pixels. Parameter y receives the height of
	//		the scrollable window, in pixels. Use wxDC::DeviceToLogicalX and
	//		wxDC::DeviceToLogicalY to translate these units to logical units.
	// void Scroll(int x, int y). Scrolls a window so the view start is at the
	//		given point. Parameter x is the x position to scroll to, in scroll units.
	//		Parameter y is the y position to scroll to, in scroll units. The
	//		positions are in scroll units, not pixels, so to convert to pixels
	//		you have to multiply by the number of pixels per scroll increment.
	//		If either parameter is -1, that position will be ignored (no change
	//		in that direction).
	// void SetScrollbars(int pixelsPerUnitX, int pixelsPerUnitY, int noUnitsX,
	//		int noUnitsY, int xPos = 0, int yPos = 0, bool noRefresh = FALSE)
	//		Sets up vertical and/or horizontal scrollbars. Parameters are:
	//		pixelsPerUnitX - pixels per scroll unit in the horizontal direction.
	//		pixelsPerUnitY - pixels per scroll unit in the vertical direction.
	//		noUnitsX - number of units in the horizontal direction.
	//		noUnitsY - number of units in the vertical direction.
	//		xPos - position to initialize the scrollbars in the horizontal
	//			direction, in scroll units.
	//		yPos - Position to initialize the scrollbars in the vertical
	//			direction, in scroll units.
	//		noRefresh - will not refresh window if TRUE.
	//		Remarks: The first pair of parameters give the number of pixels
	//		per 'scroll step', i.e. amount moved when the up or down scroll
	//		arrows are pressed. The second pair gives the length of scrollbar
	//		in scroll steps, which sets the size of the virtual window.
	//		xPos and yPos optionally specify a position to scroll to immediately.
	//		For example, the following gives a window horizontal and vertical
	//		scrollbars with 20 pixels per scroll step, and a size of 50 steps
	//		(1000 pixels) in each direction: window->SetScrollbars(20, 20, 50, 50);
	//		wxScrolledWindow manages the page size itself, using the current
	//		client window size as the page size. Note that for more sophisticated
	//		scrolling applications, for example where scroll steps may be variable
	//		according to the position in the document, it will be necessary to
	//		derive a new class from wxWindow, overriding OnSize and adjusting
	//		the scrollbars appropriately. See also wxWindow::SetVirtualSize
	// void SetScrollRate(int xstep, int ystep).
	//		Set the horizontal and vertical scrolling increment only. See the
	//		pixelsPerUnit parameter in SetScrollbars.
	// wxWindow also has void SetVirtualSize(const wxSize& size), which sets the
	//		virtual size of the window in pixels (i.e., wxMM_TEXT).
	//      SetVirtualSize() is used within the wx app in the following functions:
	//      OnOpenDocument(), OnInitialUpdate() and RecalcLayout().

	//
	// wxWidgets' mapping modes can be one of the following:
	// wxMM_TWIPS		Each lodical unit is 1/20 of a point, or 1/1440 of an inch (same as MFC's)
	// wxMM_POINTS		Each lodical unit is a point, or 1/72 of an inch (= MM_TWIPS*20)
	// wxMM_METRIC		Each lodical unit is 1 mm (= 10*MFC's MM_LOMETRIC below)
	// wxMM_LOMETRIC	Each lodical unit is 1/10 of a mm (same as MFC's MM_LOMETRIC below)
	// wxMM_TEXT		Each lodical unit is 1 pixel (same as MFC's)

	// MFC Docs say of SetScrollSizes: "Call SetScrollSizes when the view is about
	// to be updated. First parameter is the mapping mode to set for this view,
	// where: First paramater can be:
	//		MM_TEXT, one Logical Unit = 1 pizel and positive y-axis extends downward.
	//		MM_HIMETRIC, one Logical Unit = 0.01mm, y-axis extends upward
	//		MM_TWIPS, one Logical Unit = 1/1440 inch, y-axis extends upward
	//		MM_HIENGLISH, one Logical Unit = 0.001 inch, y-axis extends upward
	//		MM_LOWMETRIC, one Logical Unit = 0.1 mm, y-axis extends upward
	//		MM_LOENGLISH, one Logical Unit = 0.01 inch, y-axis extends upward
	// Second parameter is the total size of the scroll view. The cx member contains
	// the horizontal extent. The cy member contains the vertical extent, and sizes
	// are in logical units. Both cx and cy must be >= 0. Call it in your override
	// of the OnUpdate member function to adjust scrolling characteristics when,
	// for example, the document is initially displayed or when it changes size.
	// You will typically obtain size information from the view's associated
	// document by calling a document member function, perhaps called GetMyDocSize,
	// that you supply with your derived document class.

	gpApp->GetMainFrame()->canvas->SetVirtualSize(gpApp->m_docSize); //SetScrollSizes(MM_TEXT, pDoc->m_docSize);

	// make sure there is a CSourceBundle instance ready for use;
	// MFC Note adds: "...and remember that OnInitInstance is called each time OnFileNew is called,
	// so we have to ensure that old data is cleaned out first."
	// whm Note: I think Bruce's "OnInitInstance" here is actually a reference to OnInitialUpdate.
	// OnInitialUpdate is NOT called each time OnFileNew is called, but only once each time
	// the app is launched. OnInitialUpdate is called by our OnInit() at program startup, and
	// by the doc/view framework in response to File | New and when loading a doc from MRU.
	if (gpApp->m_pBundle == NULL) // MFC had == 0
	{
		// No CSourceBundle instance yet, so create one & initialize it.
		// Creation of a CSourceBundle also allocates pointers for its
		// embedded CStrips, CPiles, CCells, and CText. These embedded
		// CStrips, CPiles, CCells, and CText are themselves not yet
		// dynamically created. Only CSourceBundle's constructor gets
		// called below on the new CSourceBundle call, and it sets all
		// 6,000 CStrip pointers to NULL.
		gpApp->m_pBundle = new CSourceBundle(pDoc,this); //pApp->m_pBundle = new CSourceBundle(pDoc,this);
		wxASSERT(gpApp->m_pBundle != NULL);

		// initial value for count of strips in the bundle
		gpApp->m_pBundle->m_nStripCount = 0;

		// add this in support of splitting the window (& must have SetScrollSizes
		// called prior to this)
		CalcInitialIndices();
		gpApp->UpdateTextHeights(this); // check this ???
		RecalcLayout(gpApp->m_pSourcePhrases,0,gpApp->m_pBundle);

		nSequNumForLastAutoSave = 0;
	}

	gpApp->m_targetPhrase = saveText;
	gnStart = 0;
	gnEnd = -1;
	gpApp->m_nStartChar = gnStart;
	gpApp->m_nEndChar = gnEnd;
	RedrawEverything(saveActiveSN); // first call of RedrawEverything in the View

	// RedrawEverything clobbers the selection, we want initial text shown selected, so
	// do it again
	if (gpApp->m_pTargetBox != NULL)
	{
		gnStart = 0;
		gnEnd = -1;
		gpApp->m_nStartChar = gnStart;
		gpApp->m_nEndChar = gnEnd;
		gpApp->m_pTargetBox->SetSelection(gpApp->m_nStartChar,gpApp->m_nEndChar); // select it all // MFC uses SetSel
	}

	Invalidate(); // our own

// Is the following necessary? Code from docvwmdi sample came commented out
#ifdef __WXMSW__
  if (gpApp->GetMainFrame()->canvas)
    gpApp->GetMainFrame()->canvas->Refresh();
#else
  if (gpApp->GetMainFrame()->canvas)
    {
      wxClientDC dc(gpApp->GetMainFrame()->canvas);
      dc.Clear();
      OnDraw(& dc);
    }
#endif
}

bool CAdapt_ItView::OnCreate(wxDocument* doc, long flags) // a virtual method of wxView
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	doc = doc; // avoid "unreferenced formal parameter" warning
	flags = flags; // avoid "unreferenced formal parameter" warning

	pCanvasFrame = pApp->GetMainFrame();

	canvas = pApp->GetMainFrame()->canvas;

	canvas->pView = this;	// make the view pointer owned by MainFrame's canvas
							// point to the current view
    pCanvasFrame->SetTitle(_T("CAdapt_ItView"));

	SetFrame(pCanvasFrame);

#ifdef __X__
    // X seems to require a forced resize
    int x, y;
    pCanvasFrame->GetSize(&x, &y);
    pCanvasFrame->SetSize(-1, -1, x, y);
#endif

	// Create the target box using custom constructor
	// WX Note: Our TargetBox is now a child of the view's canvas (which
	// itself is derived from wxScrolledWindow. As a child of the canvas
	// window, m_pTargetBox will be automatically destroyed when pView->canvas
	// is destroyed during doc/view's normal cleanup. That is, when our View is
	// destroyed, all child windows (including our target box) are automatically
	// destroyed too. Therefore, the target box must not be deleted again in
	// the App's OnExit() method, when the App terminates.
	pApp->m_pTargetBox = new CPhraseBox(pApp->GetMainFrame()->canvas, -1,_T(""), //pApp->m_targetBox.Create(canvas, IDW_TARGET_EDITBOX,_T(""),
			wxDefaultPosition,wxDefaultSize,
			wxSIMPLE_BORDER | wxWANTS_CHARS);
	// whm Notes on the wxTextCtrl style flags:
	// wxSIMPLE_BORDER - Displays a thin border around the window.
	// wxWANTS_CHARS - According to the wx docs Use this to indicate that 
	// the window wants to get all char/key events for all keys - even for keys like 
	// TAB or ENTER which are usually used for dialog navigation and which wouldn't 
	// be generated without this style. If you need to use this style in order to 
	// get the arrows or etc., but would still like to have normal keyboard navigation 
	// take place, you should create and send a wxNavigationKeyEvent in response to 
	// the key events for Tab and Shift-Tab.
	// wxTAB_TRAVERSAL - Use this to enable tab traversal for non-dialog windows (not needed for phrasebox).
	pApp->m_pTargetBox->SetValue(_T(""));
	// hide and disable the target box until input is expected
	pApp->m_pTargetBox->Hide(); // MFC version calls DestroyWindow(); SetValue(_T("")) is called above
	pApp->m_pTargetBox->Enable(FALSE);

	// Old note: Since wxView's OnUpdate() doesn't seem to be automatically
	// called at the point that the View is created we'll try calling
	// it here in the View's OnCreate() method just before the View's
	// pCanvasFrame is shown.
	// New note: wxView does have a virtual OnUpdate() method. So rather
	// than calling our own OnInitialUpdate() here, I tired to override
	// wxView's OnUpdate() to call OnInitialUpdate only once when our view
	// is first created, but that had problems.
	//OnInitialUpdate(); // not in docview sample
	OnUpdate(NULL,NULL);

    Activate(TRUE);

	// see docview sample view.cpp for code on how to set up the edit menu
	// Undo and Redo items using doc->GetCommandProcessor() here

	if (pApp->bUserSelectedFileNew)
	{
		// Note: Because of doc/view framework differences between MFC and WX,
		// a user File | New selection in WX calls CreateDocument, which
		// after calling OnSaveModified, calls OnCloseDocument which in
		// turn calls EraseKB on the adapting and glossing KBs. Hence, we
		// need to reinitialize our KBs here, since immediately after this
		// OnCreate() method finishes, OnNewDocument() will be called and
		// the KB structures need to be reinitialized before OnNewDocument
		// can succeed. I borrowed the code below from the App's
		// SetupDirectories().

		// we have the desired directory structures. Now we need to get a KB initialized
		// and stored in the languages-specific folder. Ditto for the glossing KB (version 2)
		pApp->m_curKBName = pApp->m_curProjectName + _T(".KB");
		pApp->m_curKBPath = pApp->m_curProjectPath + pApp->PathSeparator + pApp->m_curKBName;
		pApp->m_curKBBackupPath = pApp->m_curProjectPath + pApp->PathSeparator + pApp->m_curProjectName + _T(".BAK");

		// now the same stuff for the glossing KB
		pApp->m_curGlossingKBPath = pApp->m_curProjectPath + pApp->PathSeparator + pApp->m_curGlossingKBName; // version 2
		pApp->m_curGlossingKBPath  += _T(".KB"); // version 2
		pApp->m_curGlossingKBBackupPath = pApp->m_curProjectPath + pApp->PathSeparator + pApp->m_curGlossingKBName + _T(".BAK");

		if (::wxFileExists(pApp->m_curKBPath)) //if (cFile.GetStatus(m_curKBPath,status))
		{
			// there is an existing .KB file, so we need to create a CKB instance in
			// memory, open the .KB file on disk, and fill the memory instance's members
			wxASSERT(pApp->m_pKB == NULL);
			pApp->m_pKB = new CKB;
			wxASSERT(pApp->m_pKB != NULL);
			bool bOK = pApp->LoadKB();
			if (bOK)
			{
				pApp->m_bKBReady = TRUE;

				// now do it for the glossing KB
				wxASSERT(pApp->m_pGlossingKB == NULL);
				pApp->m_pGlossingKB = new CKB;
				wxASSERT(pApp->m_pGlossingKB != NULL);
				bOK = pApp->LoadGlossingKB();
				if (bOK)
				{
					pApp->m_bGlossingKBReady = TRUE;
				}
				else
				{
					// IDS_LOAD_GLOSSINGKB_FAILURE
					wxMessageBox(_("Error: loading the glossing knowledge base failed. The application will now close."),_T(""), wxICON_ERROR);
					wxASSERT(FALSE);
					wxExit();
				}
			}
			else
			{
				// IDS_LOAD_KB_FAILURE
				wxMessageBox(_("Error: loading a knowledge base failed. The application will now close."),_T(""), wxICON_ERROR);
				wxASSERT(FALSE);
				wxExit();
			}
		}
		else
		{
			// the KB file does not exist, so make sure there is an initialized CKB instance
			// on the application ready to receive data, and save it to disk.
			// for version 2, do the same for the glossing KB
			wxASSERT(pApp->m_pKB == NULL);
			pApp->m_pKB = new CKB;
			wxASSERT(pApp->m_pKB != NULL);

			// store the language names in it
			pApp->m_pKB->m_sourceLanguageName = pApp->m_sourceName;
			pApp->m_pKB->m_targetLanguageName = pApp->m_targetName;

			bool bOK = pApp->StoreKB(FALSE); // first time, so we can't make a backup
			if (bOK)
			{
				pApp->m_bKBReady = TRUE;

				// now do the same for the glossing KB
				wxASSERT(pApp->m_pGlossingKB == NULL);
				pApp->m_pGlossingKB = new CKB;
				wxASSERT(pApp->m_pGlossingKB != NULL);

				bOK = pApp->StoreGlossingKB(FALSE); // first time, so we can't make a backup
				if (bOK)
				{
					pApp->m_bGlossingKBReady = TRUE;
				}
				else
				{
					// IDS_STORE_GLOSSINGKB_FAILURE
					wxMessageBox(_("Error: storing the glossing knowledge base to disk for the first time failed. The application will now close."),_T(""), wxICON_ERROR); // something went wrong
					wxASSERT(FALSE);
					wxExit();
				}
			}
			else
			{
				// IDS_STORE_KB_FAILURE
				wxMessageBox(_("Error: saving the knowledge base failed. The application will now close."),_T(""), wxICON_ERROR); // something went wrong
				wxASSERT(FALSE);
				wxExit();
			}
		}
		// whm added 13Jun04 need to make m_pBundle's view member also point
		// to the current view
		pApp->m_pBundle->m_pView = this;
	}


    return TRUE;
}

// OnPrepareDC() was moved to CAdapt_ItCanvas in the wx version

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   -> unused
/// \remarks
/// Called from: The File -> Print menu selection. Note: This handler is not called when the "Print" button in
/// the print preview dialog is pressed. This handler creates a printer object from the wxPrinter
/// class, associates it with our wxPrintDialogData object (pPrintData), sets the print dialog title
/// and invokes the print dialog by calling printer.Print().
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnPrint(wxCommandEvent& WXUNUSED(event)) 
{
	// whm note: The code below is adapted from wxWidgets printing sample
	// See file:.\AIPrintout.cpp#print_flow for the order of calling of OnPrint().

	gbIsBeingPreviewed = FALSE; // from MFC's OnPreparePrinting
   
	wxPrintDialogData printDialogData(*gpApp->pPrintData);
	
    // In the wx version we implement a chapter and verse selection dialog to supplement the print
    // dialog, since it is not likely we will be able to use custom print dialogs for all platforms. 
    // The print options dialog items are:
    // 1. Radio buttons for: "All", "Selection", "Pages", and "Chapter/Verse Range.
    // 2. "from:" and "to:" edit boxes associated with the "Pages" radio button.
	// 3. "from: chapter" and "verse" edit boxes; and "to: chapter" and "verse" edit boxes for range 
	//    number(s) entry associated with the "Chapter/Verse Range" radio button.
    // 4. A check box "[ ] Suppress a preceding section heading". 
    // 5. A check box "[ ] Include a following section heading". 
    // 6. A check box "[ ] Suppress printing of the footer".
	CPrintOptionsDlg poDlg(gpApp->GetMainFrame()); //,&printout);
	poDlg.Centre();
	// The CPrintOptionsDlg does all of its own initialization
	if (poDlg.ShowModal() == wxID_OK)
	{
		// Update printDialogData to reflect:
		// 1. Whether the user entered a "from" and a "to" page range so that this carries over to the print
		// dialog below.
		// 2. Whether the user clicked on the "Selection" radio button (if enabled)
		
		// get user settings for Pages 
		if (poDlg.pRadioPages->GetValue() == TRUE)
		{
			wxString strFrom,strTo;
			int nFrom,nTo;
			strFrom = poDlg.pEditPagesFrom->GetValue();
			nFrom = wxAtoi(strFrom);
			strTo = poDlg.pEditPagesTo->GetValue();
			nTo = wxAtoi(strTo);
			printDialogData.SetFromPage(nFrom);
			printDialogData.SetToPage(nTo);
		}
		else if (poDlg.pRadioSelection->GetValue() == TRUE)
		{
			printDialogData.SetSelection(TRUE);
		}
	}
	else
	{
		// User cancelled the print options, so we assume we should also cancel the print dialog which
		// happens if we simply return here. The MFC version did a lot of work to get the document back
		// into its original state, but the wx version doesn't change the doc's state at this early
		// stage.
		return;
	}
	
	wxPrinter printer(& printDialogData);
	
	wxString printTitle;
	printTitle = printTitle.Format(_T("Printing %s"),gpApp->m_curOutputFilename.c_str());
	AIPrintout printout(printTitle); // this calls Freeze() on the canvas
	// #printer_Print
    if (!printer.Print(gpApp->GetMainFrame(), &printout, true /*prompt*/))
    {
		// whm: Other error messages are issued, so we don't need yet another one here
        //if (wxPrinter::GetLastError() == wxPRINTER_ERROR)
        //    wxMessageBox(_T("There was a problem printing.\nPerhaps your current printer is not set correctly?"), _T("Printing"), wxOK);
        //    
		// OnPreparePrinting() is not called when user cancels from the printer dialog or on printer
		// error. OnPreparePrinting calls SaveIndicesForRange() and SaveAndSetIndices() as part of its
		// setup for printing operations, but since we're now exiting prematurely, we need to make
		// those calls, because the AIPrintout destructor calls the cleanup code including
		// RestoreIndices (which assumes a previous call to SaveAndSetIndices). If we don't call SaveIndicesForRange()
		// and SaveAndSetIndices() here RestoreIndices() in the destructor's cleanup code will trash
		// the indices causing a later crash when RecalcLayout calls CreateStrip, etc.
		SaveIndicesForRange();
		SaveAndSetIndices(gpApp->m_maxIndex);
		// can query if (wxPrinter::GetLastError() == wxPRINTER_CANCELLED) to determine if user cancelled
    }
    else
    {
        (*gpApp->pPrintData) = printer.GetPrintDialogData().GetPrintData();
    }

}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   -> unused
/// \remarks
/// Called from: The File -> Print Preview menu selection. This handler creates a preview object from the
/// wxPrintPreview class, creates a frame object from the wxPreviewFrame class, positions, sizes and
/// initializes the frame, and finally shows the print preview frame in modal fashion.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnPrintPreview(wxCommandEvent& WXUNUSED(event))
{
	// whm note: The code below is adapted from wxWidgets printing sample
	// See file:.\AIPrintout.cpp#print_flow for the order of calling of OnPrint().
    // Pass two printout objects: for preview, and possible printing.
    wxString previewTitle,printTitle;
	previewTitle = previewTitle.Format(_T("Print Preview of %s"),gpApp->m_curOutputFilename.c_str());
	printTitle = printTitle.Format(_T("Printing %s"),gpApp->m_curOutputFilename.c_str());
    wxPrintDialogData printDialogData(*gpApp->pPrintData);
    wxPrintPreview *preview = new wxPrintPreview(new AIPrintout(previewTitle), new AIPrintout(printTitle), & printDialogData);
    if (!preview->Ok())
    {
        delete preview;
        wxMessageBox(_T("There was a problem previewing.\nPerhaps your current printer is not set correctly?"), _T("Previewing"), wxOK);
        return;
    }

	gbIsBeingPreviewed = TRUE; // from MFC's OnPreparePrinting()

	// Note: If we ever want to use it, an AIPreviewFrame object can be created using the currently
	// commented out class AIPreviewFrame, which is derived from wxPreviewFrame (see AIPrintout.h). It
	// could be used so we can get access to wxPreviewFrame's OnCloseWindow method. 
    //wxPreviewFrame *frame = new AIPreviewFrame(preview, gpApp->GetMainFrame(), _T("Adapt It Print Preview"), wxPoint(100, 100), wxSize(600, 650));
    
	// Since we freeze the canvas against screen updates, we may as well size the preview frame to
	// fully cover the canvas in the main window.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxSize frameClientSize = pFrame->GetClientSize();
	// The controlbar is always visible on the main frame
	wxSize controlbarSize = pFrame->m_pControlBar->GetSize();
	wxPoint framePosition = pFrame->GetPosition();
	wxPoint canvasPosition = pFrame->canvas->GetPosition();
	wxPoint previewPosition = framePosition + canvasPosition;
	previewPosition.x += wxSystemSettings::GetMetric(wxSYS_FRAMESIZE_X); // move to the right by thickness of frame
	previewPosition.y += controlbarSize.y; // move the preview down just below the toolbar
    //wxPreviewFrame *frame = new wxPreviewFrame(preview, gpApp->GetMainFrame(), previewTitle, wxPoint(100, 100), wxSize(600, 650));
    wxPreviewFrame *frame = new wxPreviewFrame(preview, gpApp->GetMainFrame(), previewTitle, previewPosition, frameClientSize);
    // We positioned the preview frame explicitly, so don't call Centre() here
    frame->Initialize();
    frame->Show();
	// whm note: The preview window is closed automatically when the user exits/closes the preview window.
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if the document is empty, otherwise TRUE
/// \param      nPagePrintingWidth      -> unused
/// \param      nPagePrintingLength     -> the length of a printed page between top and bottom margins
///                                         expressed in logical units
/// \param      paginationType          -> either NoSimulation or DoSimulation. NoSimulation stores
///                                         top and bottom offsets in the PageOffsets list; 
///                                         DoSimulation does not store top and bottom offsets in the
///                                         PageOffsets list
/// \remarks
/// Called from: AIPrintout::OnPreparePrinting(), and the View's SetupRangePrintOp(). Determines the
/// number of strips that will fit on a page (using the current width between left and right margins), and
/// stores the offsets and strip counts for each page in a list of pOffsets it stores in the App's list of
/// PageOffsets.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::PaginateDoc(const int nTotalStripCount, const int nPagePrintingLength, enum PaginationType paginationType)
{
	// whm Observations: PaginateDoc() basically uses the existing indices for the App's
	// m_pBundle->m_nStripCount as the max number of strips to be paginated into pages, and
	// determines how many pages it will take to print the document.
	// whm Notes: The MFC version paginates the document and lays it out for print preview and 
	// printing to fit the page, regardless of the size of the main window of the application.
	// The MFC version also assumes negative offsets. The wx version also paginates the document and
	// lays it out for print preview and printing to fit the printed page, but it keeps the map mode as
	// wxMM_TEXT, scales the output to fit the print/print preview display context, and uses positive 
	// offsets instead of negative offsets. PaginateDoc() depends on RecalcLayout() or
	// RecalcLayout_SimulateOnly() being called previously 
	// 
	POList* pList = &gpApp->m_pagesList;
	ClearPagesList(); // start with an empty list
	CSourceBundle* pBundle = gpApp->m_pBundle;
	wxASSERT(pBundle != NULL);
	PageOffsets* pOffsets = NULL;
	// Note: RecalcLayout was previously called with the appropriate dc width
	int nMaxStrips = nTotalStripCount; // whm: use the incoming parameter rather than pBundle->m_nStripCount; 
	if(nMaxStrips <= 0)
	{
		wxMessageBox(_T("Error: Cannot paginate an empty document."),_T(""), wxICON_ERROR);
		return FALSE;
	}
	int pageCount = 0;
	int nStripHeightWithLeading = gpApp->m_curLeading + gpApp->m_curPileHeight; //added includes the following gap
    // The nPagePrintingLength passed in represents the height of the printed page between the top and
    // bottom margins (in logical units).
	int nMaxHeightPerPage = nPagePrintingLength; // the page height between top and bottom margins in logical units
	// m_curLeading defaults to 32 pixels of height before each line including the first strip on the
	// main window.
	int nSafeBottomPaddingPerStrip = (nStripHeightWithLeading / (nMaxHeightPerPage / nStripHeightWithLeading));
	int nAccumStripHeightThisPage = 0;
	int nStripCountRunningTotal = 0;
	int nFirstStripOnPage = 0;
	// process pages until we've processed all the strips that need processing
	while (nStripCountRunningTotal < nMaxStrips)
	{
		if (nAccumStripHeightThisPage + nStripHeightWithLeading > nMaxHeightPerPage)
		{
			// can't fit the next strip on this page so create a PageOffset page and save its starting
			// and ending strip offsets
			pOffsets = new PageOffsets;
			if (paginationType == NoSimulation)
			{
				pOffsets->nTop = pBundle->m_pStrip[nFirstStripOnPage]->m_rectStrip.GetTop();
				pOffsets->nBottom = pBundle->m_pStrip[nStripCountRunningTotal]->m_rectStrip.GetBottom();
			}
			else
			{
				pOffsets->nTop = 0;
				pOffsets->nBottom = 0;
			}
			pOffsets->nFirstStrip = nFirstStripOnPage; 
			pOffsets->nLastStrip = nStripCountRunningTotal;
			pList->Append(pOffsets); // store the page information
			nFirstStripOnPage = nStripCountRunningTotal + 1;
			nAccumStripHeightThisPage = 0;
			pageCount++;
		}
		else
		{
			// The next strip fits on this page so continue adding strips. 
			// Pad with a few extra pixels per strip to account for CRect vs wxRect differences in reportable
			// rect heights. One pixel per strip might be enough, but two or three is probably safer to
			// prevent printing beyond the bottom of the page, in case paper size isn't set properly.
			nAccumStripHeightThisPage += nStripHeightWithLeading + nSafeBottomPaddingPerStrip; 
		}
		nStripCountRunningTotal++;
	}

	if (nAccumStripHeightThisPage > 0)
	{
		// there is material for one final (partial) page
		pOffsets = new PageOffsets;
		if (paginationType == NoSimulation)
		{
			pOffsets->nTop = pBundle->m_pStrip[nFirstStripOnPage]->m_rectStrip.GetTop();
			pOffsets->nBottom = pBundle->m_pStrip[nStripCountRunningTotal - 1]->m_rectStrip.GetBottom(); // note: -1 here
		}
		else
		{
			pOffsets->nTop = 0;
			pOffsets->nBottom = 0;
		}
		pOffsets->nFirstStrip = nFirstStripOnPage;
		pOffsets->nLastStrip = nStripCountRunningTotal - 1;
		pList->Append(pOffsets); // store the page information
		pageCount++;
	}
	wxASSERT(pageCount == (int)pList->GetCount());
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: The View's PaginateDoc() and AIPrintout's OnPreparePrinting() and its destructor.
/// ClearPagesList() is a helper function which simply deletes the list of page offset structs from the
/// POList called m_pagesList on the App.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::ClearPagesList()
{
	POList* pList = &gpApp->m_pagesList;
	if (pList->GetCount() == 0)
	{
		return;
	}
	else
	{
		
		POList::Node* pos = pList->GetFirst();
		while(pos != NULL)
		{
			// whm note: PageParams and PageOffsets are similar structs
			// (PageParams has an extra member at the end of the struct called nPageNumber.
			// MFC version of code below casts the pList pointers to (PageParams*) but
			// the pList was originally filled with (PageOffsets*) pointers.
			// In MFC it doesn't complain, but in a wxList the pointers it
			// contains are strongly typed, so I'm casting them instead to
			// (PageOffsets*) which is really what was stored in this POList by the
			// PaginateDoc() function above.
			PageOffsets* pOffsets = (PageOffsets*)pos->GetData(); // MFC used PageParams*
			pos = pos->GetNext();
			if (pOffsets != NULL)
			{
				delete pOffsets;
			}
		}
		pList->Clear();
	}
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      nNewMaxIndex      -> used to initialize the App's m_endIndex and m_upperIndex values at
///                                     the start of printing
/// \remarks
/// Called from: the View's OnPrint() top level menu handler when File | Print is invoked by the user;
/// and from the AIPrintout's OnPreparePrinting(). SaveAndSetIndices() saves a copy of certain indices 
/// associated with the current document, and initializes certain printing variables to default values, 
/// at the beginning of the printing operation. At the end of printing operations (in AIPrintout's 
/// destructor), RestoreIndices() is called to reset those indices using the values saved by 
/// SaveAndSetIndices().
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::SaveAndSetIndices(int nNewMaxIndex)
{
	// save current values
	gpApp->m_saveBeginIndex = gpApp->m_beginIndex;
	gpApp->m_saveEndIndex = gpApp->m_endIndex;
	gpApp->m_saveCurIndex = gpApp->m_curIndex;
	gpApp->m_saveLowerIndex = gpApp->m_lowerIndex;
	gpApp->m_saveUpperIndex = gpApp->m_upperIndex;
	gpApp->m_saveMaxIndex = gpApp->m_maxIndex;
	
	// now set default printing values
	gpApp->m_beginIndex = 0;
	gpApp->m_endIndex = nNewMaxIndex;
	gpApp->m_lowerIndex = 0;
	gpApp->m_upperIndex = nNewMaxIndex;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the View's RestoreOriginalList() and from within the AIPrintout's destructor at the
/// end of a print or print preview operation. At the beginning of a print operation SaveAndSetIndices() 
/// saved a copy of certain indices associated with the current document, and initialized certain 
/// printing variables to default values. RestoreIndices() restores the values that were saved by
/// SaveAndSetIndices() so that the document can be put back into the state it was in before the
/// printing operation.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RestoreIndices()
{
	gpApp->m_beginIndex = gpApp->m_saveBeginIndex;
	gpApp->m_endIndex = gpApp->m_saveEndIndex;
	gpApp->m_curIndex = gpApp->m_saveCurIndex;
	gpApp->m_lowerIndex = gpApp->m_saveLowerIndex;
	gpApp->m_upperIndex = gpApp->m_saveUpperIndex;
	gpApp->m_maxIndex = gpApp->m_saveMaxIndex;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the View's OnPrint() top level menu handler when File | Print is invoked by the user;
/// and from the AIPrintout's OnPreparePrinting(). SaveIndicesForRange() saves a copy of certain indices 
/// associated with printing a range of the current document, at the beginning of the printing operation. 
/// At the end of printing operations (in AIPrintout's destructor), RestoreIndicesFromRange() is called 
/// to reset those indices using the values saved by SaveIndicesForRange().
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::SaveIndicesForRange()
{
	// save current values
	gpApp->m_saveRangeBeginIndex = gpApp->m_beginIndex;
	gpApp->m_saveRangeEndIndex = gpApp->m_endIndex;
	gpApp->m_saveRangeCurIndex = gpApp->m_curIndex;
	gpApp->m_saveRangeLowerIndex = gpApp->m_lowerIndex;
	gpApp->m_saveRangeUpperIndex = gpApp->m_upperIndex;
	gpApp->m_saveRangeMaxIndex = gpApp->m_maxIndex;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the View's RestoreOriginalList() at the end of a print or print preview operation (in
/// AIPrintout's destructor). At the beginning of a print operation SaveIndicesForRange() 
/// saved a copy of certain indices associated with printing a range of the current document. 
/// RestoreIndicesFromRange() restores the values that were saved by SaveIndicesForRange() so that the 
/// document can be put back into the state it was in before the printing operation.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RestoreIndicesFromRange()
{
	gpApp->m_beginIndex = gpApp->m_saveRangeBeginIndex;
	gpApp->m_endIndex = gpApp->m_saveRangeEndIndex;
	gpApp->m_curIndex = gpApp->m_saveRangeCurIndex;
	gpApp->m_lowerIndex = gpApp->m_saveRangeLowerIndex;
	gpApp->m_upperIndex = gpApp->m_saveRangeUpperIndex;
	gpApp->m_maxIndex = gpApp->m_saveRangeMaxIndex;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE in the wx version (FALSE in the MFC version only if a memory error occurrs)
/// \param      pSaveList       <- a SPList to store all items originally in pOriginalList
/// \param      pOriginalList   <- list of Source phrase items of which only a sublist remain
///                                 at the end of the GetSubList operation
/// \param      nBeginSequNum   -> the first list item composing the intended sub list
/// \param      nEndSequNum     -> the last item composing the intended sub list
/// \remarks
/// Called from: the View's SetupRangePrintOp() function and AIPrintout::OnPreparePrinting().
/// GetSublist() first removes any existing list items from pSaveList, then it copies all list items
/// from pOriginalList into pSaveList; then removes all items from pOriginalList; and adds back to
/// pOriginalList only those source phrases from pSaveList that are within the range nBeginSequNum 
/// to nEndSequNum. Finally GetSublist() updates the indices related to printing of sublists.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetSublist(SPList* pSaveList,SPList* pOriginalList,int nBeginSequNum,
							   int nEndSequNum)
{
	bool bOK = TRUE;
	wxASSERT(pOriginalList->GetCount() > 0); // ensure the list is not empty
	wxASSERT(nBeginSequNum >= 0 && nEndSequNum >= nBeginSequNum); // ensure valid start and end values
	wxASSERT(nEndSequNum < (int)pOriginalList->GetCount()); // make sure both sequence numbers are in range
	if (pSaveList->GetCount() > 0)
	{
		pSaveList->Clear();
	}

	// copy the original list to the saveList
	// wxList doesn't support appending one list onto another so do it manually.
	for (SPList::Node *node = pOriginalList->GetFirst(); node; node = node->GetNext())
	{
		CSourcePhrase *pData = node->GetData();
		pSaveList->Append(pData); // copy the pointers across
		// above two lines could be shortened to the single line: pSaveList->Append(node->GetData());
	}
	pOriginalList->Clear();

	// copy across to pOriginalList the pointers to the source phrases which are wanted for the 
	// sublist
	SPList::Node* pos = pSaveList->Item(nBeginSequNum);
	int sn = nBeginSequNum;
	while (sn <= nEndSequNum)
	{
		CSourcePhrase* pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		sn++;
		wxASSERT(pSrcPhrase != NULL);
		pOriginalList->Append(pSrcPhrase);
	}

	// we now must save the indices, and set temporary smaller ones consistent with the new 
	// short list
	gpApp->m_maxIndex = nEndSequNum - nBeginSequNum;
	gpApp->m_endIndex = gpApp->m_maxIndex;
	gpApp->m_upperIndex = gpApp->m_maxIndex;
	gpApp->m_lowerIndex = 0;
	gpApp->m_beginIndex = 0;

	// inhibit printing the phrase box when printing a sublist (I may change this later)
	gpApp->m_nSaveActiveSequNum = gpApp->m_nActiveSequNum;
	gpApp->m_nActiveSequNum = -1;

	return bOK;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE
/// \param      pSaveList      -> the (full) list of source phrase items to be moved to pOriginalList
/// \param      pOriginalList  <- the existing sublist which is to be abandoned and replaced by the 
///                                 contents of pSaveList
/// \remarks
/// Called from: the AIPrintout's destructor. RestoreOriginalList() is called to restore the original
/// contents of the document's m_pSourcePhrases, after printing the document.
/// During the print operation, the original list from m_pSourcePhrases was stored/saved in pSaveList.
/// RestoreOriginalList() also calls RestoreIndicesFromRange() if a range print was done, or
/// RestoreIndices() for a non-range print operation.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RestoreOriginalList(SPList* pSaveList,SPList* pOriginalList)
// when called, pSaveList has the original (full) list, and pOriginalList has the sublist which 
// we wish to abandon in the process of restoring the normal state
{
	wxASSERT(pSaveList->GetCount() > 0); // ensure the list is not empty
	// If the list is empty, which may happen if there is a range error, we don't want to copy an empty
	// pSaveList back over a populated pOriginalList, so just return
	if (wxPrinter::GetLastError() == wxPRINTER_ERROR)
		return FALSE;

	if (pOriginalList->GetCount() > 0)
	{
		// abandon the now unwanted sublist
		pOriginalList->Clear();
	}

	// copy the saved list to the originalList
	// wxList doesn't support appending one list directly onto another so do it manually.
	for (SPList::Node *node = pSaveList->GetFirst(); node; node = node->GetNext())
	{
		CSourcePhrase *pData = node->GetData();
		pOriginalList->Append(pData); // copy the pointers across
		// above two lines could be shortened to the single line: pSaveList->Append(node->GetData());
	}
	pSaveList->Clear();

	// we now must restore the saved indices
	if (gbPrintingRange)
	{
		RestoreIndicesFromRange();

		// restore the former active sequ number
		gpApp->m_nActiveSequNum = gpApp->m_nSaveActiveSequNum;
//		m_nSaveActiveSequNum = -1;  // don't do this, we might still choose a ch/verse range, 
									// so need the saved value
	}
	else
	{
		RestoreIndices();

		// restore the former active sequ number
		gpApp->m_nActiveSequNum = gpApp->m_nSaveActiveSequNum;
//		m_nSaveActiveSequNum = -1; // don't do this, we might still choose a ch/verse range, 
								   // so need the saved value
	}

	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      nSelectionLine   -> an int representing the selected line
/// \remarks
/// Called from: the View's RecalcLayout() and AIPrintout::OnPreparePrinting if a selection 
/// is current. Stores data concerning the selection in global variables on the App. In particular,
/// the selection line is stored in gnSelectionLine, the sequence number of the starting source 
/// phrase in gnSelectionStartSequNum, and the sequence number of the ending source phrase in
/// gnSelectionEndSequNum.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::StoreSelection(int nSelectionLine)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbPrintingSelection || gbPrintingRange)
	{
		// when printing a selection,or a chapter verse range, the selection has been made the
		// whole document, so we don't want to try to store anything - especially at the start of
		// a RecalcLayout() call.
		return;
	}

	if (nSelectionLine == -1)
	{
		// no selection is current (leave the globals, we may want them set for a selection)
		// so only clear them in RemoveSelection() or explicitly
//		gnSelectionStartSequNum = -1;
//		gnSelectionEndSequNum = -1;
//		gnSelectionLine = -1;
		return;
	}
	else
	{
		// a selection is current, so preserve its essential details
		gnSelectionLine = nSelectionLine;
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = cpos->GetData();
		gnSelectionStartSequNum = pCell->m_pPile->m_pSrcPhrase->m_nSequNumber;

		cpos = pApp->m_selection.GetLast();
		pCell = cpos->GetData();
		gnSelectionEndSequNum = pCell->m_pPile->m_pSrcPhrase->m_nSequNumber;
	}
	//wxLogTrace("StoreSel: count = %d m_bRespectBoundaries %d\n",pApp->m_selection.GetCount(),
	//		pApp->m_bRespectBoundaries);
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: the View's RecalcLayout(). Restores data that was stored by the StoreSelection()
/// function. Data is restored from the global variables on the App. 
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RestoreSelection()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbPrintingSelection || gbPrintingRange)
	{
		// when printing a selection, or a chapter/verse range, the selection  or range has been
		// made the  whole document, so we don't want to restore the selection, otherwise we'd crash
		return;
	}

	if (gnSelectionLine == -1)
	{
		// no selection is current, so do nothing
		return;
	}
	else
	{
		// a selection is current, so restore it
		pApp->m_selectionLine = gnSelectionLine;

		// clear the old selection list, the saved pointers will no longer be valid
		pApp->m_selection.Clear();

		// recreate the selection list
		CPile* pPile = (CPile*)NULL;
		CCell* pCell = (CCell*)NULL;
		int sn;
		if (gnSelectionStartSequNum > gnSelectionEndSequNum)
		{
			// reverse order - I don't know if this ever happens, but if it does, I'll make
			// sure I handle it properly by having a code block for the eventuality
			sn = gnSelectionEndSequNum;
			while (sn >= gnSelectionStartSequNum)
			{
				pPile = GetPile(sn);
				sn--;
				wxASSERT(pPile != NULL); // it must be there in the layout
				pCell = pPile->m_pCell[gnSelectionLine]; // the cell which user previously selected
				// AddHead and wxWindow's Insert place the object at the front of the list.
				pApp->m_selection.Insert(pCell);
				pCell->m_pText->m_bSelected = TRUE;
			}
		}
		else
		{
			// normal order
			sn = gnSelectionStartSequNum;
			while (sn <= gnSelectionEndSequNum)
			{
				pPile = GetPile(sn);
				sn++;
				wxASSERT(pPile != NULL); // it must be there in the layout
				pCell = pPile->m_pCell[gnSelectionLine]; // the cell which user previously selected
				pApp->m_selection.Append(pCell);
				pCell->m_pText->m_bSelected = TRUE;
			}
		}
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		pCell = cpos->GetData();
		pApp->m_pAnchor = pCell;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     the m_chapterVerse member of pSrcPhrase
/// \param      pSrcPhrase   -> the source phrase whose m_chapterVerse member is to be retrieved
/// \remarks
/// Called from: the App's RefreshStatusBarInfo(), the Doc's ReconstituteAfterFilteringChange(),
/// ReconstituteAfterPunctuationChange(), the View's DoConsistencyCheck() and OnEditSourceText().
/// Gets and returns the m_chapterVerse member of pSrcPhrase.
////////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::GetChapterAndVerse(CSourcePhrase *pSrcPhrase)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxString str; str.Empty();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList);
	int nActiveSequNum = pSrcPhrase->m_nSequNumber;
	SPList::Node* pos = pList->Item(nActiveSequNum); // get the position where this srcphrase is
	wxASSERT(pos != NULL);

	// loop backwards until come to start of a verse or chapter
	str = _T("0:0"); // a nonsense value which, if it gets displayed, tells us we've fouled up
	while (pos != NULL)
	{
		CSourcePhrase* pSP = (CSourcePhrase*)pos->GetData();
		pos = pos->GetPrevious(); // needed for our list
		if (pSP->m_bChapter || pSP->m_bVerse)
		{
			if (!pSP->m_chapterVerse.IsEmpty())
				str = pSP->m_chapterVerse;
			wxASSERT(!str.IsEmpty());
			break;
		}
	}
	return str;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if a valid c:v scripture reference substring has been constructed in strChapVerse, 
///             else FALSE
/// \param      pList               -> a list of CSourcePhrase pointer instances (either the current document, 
///                                 or a list constructed from parsing in an XML document and storing 
///                                 in a temporary SPList)
/// \param      pStartingSrcPhrase  -> pointer to the CSourcePhrase instance which defines the 
///                                 current location relative to which we wish to return the best possible 
///                                 (and nearest) ch:verse substring
/// \param      strChapVerse        <- a scripture reference (minus the book code and following space) 
///                                 in the form "Chapter:Verse" for example "13:25"; or an empty string if  
///                                 the function fails
/// \remarks
/// Called from: the View's SendScriptureReferenceFocusMessage(). Gets the current verse's ch:v substring, 
/// or at least tries to do the best possible job of it that it can. The pSrcPhrase defines a location (ie. 
/// a given sequence number) in the passed in pList of CSourcePhrase instances (if looking in an active 
/// document, pList will be pDoc->m_pSourcePhrases; but if scanning through a set of adaptation documents 
/// stored on disk, pList will be a temporary SPList created for holding the list returned by parsing in 
/// the XML (or *.adt) document file cryptically). First the function checks pSrcPhrase for a non-empty 
/// m_chapterVerse member, if it finds it it puts it into strChapVerse and we are done. If not, then the 
/// active location may be within a verse - so the function scans back in pList to find the nearst
/// previous pSrcPhrase instance with a non-empty m_chapterVerse - returning that if it finds one; but if 
/// pSrcPhrase is near the start of the document, there might be no previous such instance, so it then 
/// scans forward from the passed in pSrcPhrase's location to get the nearest following non-empty 
/// m_chapterVerse, and returns that. This algorithm means that we get a valid scripture reference substring 
/// even if the active location is in something such as a subheading part of the adaptation document (ie. 
/// information marked by \s). But if scanning both backwards and forwards yields no non-empty m_chapterVerse 
/// member, we assume the document was not created from a (U)SFM marked plain text source text file, and 
/// return FALSE so that the caller will block sending an invalid scripture reference focus message, or 
/// responding to one by looking in the document being tested for the location to scroll to.
/// Note: CSourcePhrase instances can store, in their m_chapterVerse member, a chapter followed by colon 
/// followed by a verse range - something in the form "13:12-15", or even "13:12,15". When a substring 
/// like this has been found. We do not return it 'as is', but rather extract the chapter number, colon, 
/// and first verse of the range - the rest is not used in a scripture reference focus broadcast message, 
/// so we never send it in one. The work of setting a valid "ch:verse" substring is done by the 
/// MakeChapVerseStrForSynchronizedScroll() function defined in MainFrame.cpp.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetChapterAndVerse(SPList* pList, CSourcePhrase* pStartingSrcPhrase, wxString& strChapVerse)
{
	CSourcePhrase* pSrcPhrase = NULL;
	wxString chvStr = _T("");
	if (!pStartingSrcPhrase->m_chapterVerse.IsEmpty())
	{
		// this CSourcePhrase instance has a ch:verse or ch:verse_range string, so produce the scripture reference
		// ch:verse substring
		chvStr = MakeChapVerseStrForSynchronizedScroll(pStartingSrcPhrase->m_chapterVerse);
		strChapVerse = chvStr;
		return TRUE;
	}
	// there was no chapter:verse information in the passed in CSourcePhrase instance, so search for it in the
	// neighbourhood - preferably in the preceding neighbourhood, but if not there, then in the following neighbourhood
	SPList::Node* pos = pList->Item(pStartingSrcPhrase->m_nSequNumber);
	SPList::Node* savePos = pos;
	if (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData(); // ignore this one, it is same as pStartingSrcPhrase
		pos = pos->GetPrevious();
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetPrevious();
			if (!pSrcPhrase->m_chapterVerse.IsEmpty())
			{
				// this CSourcePhrase instance has a ch:verse or ch:verse_range string, so produce the 
				// scripture reference ch:verse substring
				chvStr = MakeChapVerseStrForSynchronizedScroll(pSrcPhrase->m_chapterVerse);
				strChapVerse = chvStr;
				return TRUE;
			}
		}
		// didn't find it in the previous neighbourhood, so try again looking ahead instead
		pos = savePos;
		pSrcPhrase = (CSourcePhrase*)pos->GetData(); // ignore this one, it is same as pStartingSrcPhrase
		pos = pos->GetNext();
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (!pSrcPhrase->m_chapterVerse.IsEmpty())
			{
				// this CSourcePhrase instance has a ch:verse or ch:verse_range string, so produce the 
				// scripture reference ch:verse substring
				chvStr = MakeChapVerseStrForSynchronizedScroll(pSrcPhrase->m_chapterVerse);
				strChapVerse = chvStr;
				return TRUE;
			}
		}
		// if control reaches here, then there was no c:v information to be had, so return FALSE
		strChapVerse = chvStr;
		return FALSE; // could not find pSrcPhrase's location in the pList list
	}
	else
	{
		strChapVerse = chvStr;
		return FALSE; // could not find pSrcPhrase's location in the pList list
	}
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pList		->	a list of CSourcePhrase pointer instances (either the current
///                             document, or a list constructed from parsing in an XML document 
///                             and storing in a temporary SPList)
/// \param      pSrcPhrase	->	pointer to the CSourcePhrase instance which defines the current 
///                             location
/// \remarks
/// Called from: the CPhraseBox::MoveToNextPile() function.
/// This is the function which does the work of determining if a scripture reference focus message 
/// needs to be sent, for the current location as defined by where pSrcPhrase happens to be in the 
/// document's pList (the list could be pDoc->m_pSourcePhrases, or a tempory SPList pointer used 
/// for checking a document not currently open). Internally, the function checks the global 
/// CStrings: gOldChapVerseStr and gCurChapVerseStr, and if these are not different then a message 
/// is not sent; but if they are, then the message will be sent provided the global bool 
/// gbIgnoreScriptureReference_Send is FALSE (the function call needs to be wrapped by an 
/// if (!gbIgnoreScriptureReference_Send) test -- because the GUI command sets or clears this 
/// boolean). Also, internally the overloaded version of the GetChapterAndVerse() function, which 
/// returns TRUE if successful and FALSE otherwise, is called - and if FALSE is returned then no 
/// message is sent. If the current document has no (U)SFM markup, or no 3-letter book code at the 
/// start of the pList entries, then the latter function will return FALSE and so no message will 
/// ever be sent for a document file which is not built from a properly constituted and marked up 
/// scripture text file.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::SendScriptureReferenceFocusMessage(SPList* pList, CSourcePhrase* pSrcPhrase)
{
	wxASSERT(pList != NULL);
	wxASSERT(pSrcPhrase != NULL);
	wxString strChVerse = _T("");
	bool bAllIsOK = GetChapterAndVerse(pList, pSrcPhrase, strChVerse);
	if (!bAllIsOK)
	{
		return; // don't send any message
	}
	if (gOldChapVerseStr == strChVerse)
	{
		// the currently found scripture reference substring does not differ from that in the
		// last sent message, so don't resend it
		return;
	}
	// so are all is well, next, try to get the 3-letter code for the scripture book - the function
	// for doing this returns FALSE if the code does not exist, or is invalid. The code returned is
	// upper case always (the function forces this internally)
	wxString strBookCode = _T("");
	bool bValidCode = Get3LetterCode(pList,strBookCode);
	if (!bValidCode)
	{
		// the code is either invalid or is not in the document, so we cannot send a valid
		// sync message
		return;
	}
	// we have a valid substring, and the reference is different than for the last one, so send it
	// (but this function won't be called if the global gbIgnoreScriptureReference_Send is TRUE, so
	// if control has got to here, then the global is FALSE and sending is wanted by the user)
	SyncScrollSend(strBookCode, strChVerse);

	// finally, update the global wxString which remembers what the this chap:verse reference was
	gOldChapVerseStr = strChVerse;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if we have chapter:verse form, FALSE if the document has no chapters
/// \param      s               <- a wxString representing the source phrase's m_chapterVerse member
/// \param      nChapter        <- an int representing the chapter number
/// \param      nVerse          <- an int representing the verse number (or 1st verse in a range); 0 if
///                                no verses are indicated
/// \param      bHasChapters    <- a bool TRUE if chapter numbers are present FALSE otherwise
/// \param      bIsVerseRange   <- a bool TRUE if there is a range of verses indicated, FALSE otherwise
/// \param      nFinalVerse     <- an int representing the final verse in a range
/// \remarks
/// Called from: the View's SetupRangePrintOp().
/// The usual form for s's contents is n:m where n is a chapter number, and m a verse number,
/// and bIsVerseRange will be set to FALSE; - s is a reference to the source phrase's m_chapterVerse
/// member. However, the contents could be just a verse number (eg. Book without chapters, such as
/// 2John etc), or n:p-q (for a range of verses), or n:p,q (an alternative style for a range) so for
/// the standard situation we set nChapter to n, nVerse to m, and return TRUE; but for a book with
/// no chapters we return FALSE, and nVerse will have the verse number, or 0 if there are no verses;
/// for the range possibilities nVerse will have p the first verse in the range, nFinalVerse will
/// have q (the end verse in the range), and bIsVerseRange will be set to TRUE.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ExtractChapterAndVerse(wxString& s,int& nChapter,int& nVerse,bool& bHasChapters,
										   bool& bIsVerseRange,int& nFinalVerse)
{
	bHasChapters = FALSE;
	bIsVerseRange = FALSE;
	nFinalVerse = 0;
	nChapter = 0;
	nVerse = 0;
	wxString chStr;
	wxString vStr;
	chStr.Empty();
	vStr.Empty();
	wxChar colon = _T(':');
	bool bIsOK = TRUE;
	int nHasChapters = s.Find(colon);
	if (nHasChapters > -1)
	{
		bHasChapters = TRUE;
		chStr = s.Left(nHasChapters);
		wxASSERT(!chStr.IsEmpty());
	}
	if (bHasChapters)
	{
		nChapter = wxAtoi(chStr);
		vStr = s.Mid(nHasChapters + 1);
	}
	else
	{
		// has no chapters, so string must only be a verse number, or number range
		vStr = s;
	}
	wxASSERT(!vStr.IsEmpty());
	if (vStr.IsEmpty())
		return FALSE; // error, so ignore this chap/verse string
	wxString tempStr = vStr;

	// now determine the verse, or verse range
	wxChar hyphen = _T('-');
	wxChar comma = _T(',');
	wxString leftStr;
	wxString rightStr;
	leftStr.Empty();
	rightStr.Empty();
	int	  nHyphenOffset = -1;
	int   nCommaOffset =  vStr.Find(comma);
	if (nCommaOffset == -1)
	{
		// has no comma in the string, so test now for a hyphen
		nHyphenOffset =  vStr.Find(hyphen);
		if (nHyphenOffset == -1)
		{
			// doesn't have a hyphen in the string, so it should only be a verse number
			nVerse = wxAtoi(vStr); // reads digits only until first non-digit, so safe
	//		ASSERT(nVerse > 0 && nVerse <= 176); // bible verses are between 1 and about 176
												 // as in (Psalm 119)
	//		for version 2.0.5 and onward, we'll allow any value for max verse number, since document
	//		may not be scripture, but nevertheless be versified for use by Adapt It eg. film script
	//		if (nVerse <= 0 || nVerse > 176)
	//			return FALSE; // error
	//		else
			return bIsOK;
		}
		else
		{
			// does have a hyphen, so there must be a range
			bIsVerseRange = TRUE;
			leftStr = vStr.Left(nHyphenOffset);
			wxASSERT(leftStr.Length() > 0);
			nVerse = wxAtoi(leftStr);
//			ASSERT(nVerse > 0 && nVerse <= 176);
//			if (nVerse <= 0 || nVerse > 176)
//				return FALSE; // error
			rightStr = vStr.Mid(nHyphenOffset + 1);
			wxASSERT(rightStr.Length() > 0);
			nFinalVerse = wxAtoi(rightStr);
//			ASSERT(nFinalVerse > 0 && nFinalVerse <= 176);
//			if (nFinalVerse <= 0 || nFinalVerse > 176)
//				return FALSE; // error
//			else
			return bIsOK;
		}
	}
	else
	{
		// has a comma, so there must be a range
		bIsVerseRange = TRUE;
		leftStr = vStr.Left(nCommaOffset);
		wxASSERT(leftStr.Length() > 0);
		nVerse = wxAtoi(leftStr);
//		ASSERT(nVerse > 0 && nVerse <= 176);
//		if (nVerse <= 0 || nVerse > 176)
//			return FALSE; // error
a:		rightStr = tempStr.Mid(nCommaOffset + 1);
		wxASSERT(rightStr.Length() > 0);
		// there might be more - continue till we find the final substring in p,q,r,s etc
		nCommaOffset = rightStr.Find(comma);
		if (nCommaOffset > -1)
		{
			// we are not at the rightmost one yet, so iterate
			tempStr = tempStr.Mid(nCommaOffset + 1);
			wxASSERT(tempStr.Length() > 0);
			goto a;
		}
		nFinalVerse = wxAtoi(rightStr);
//		ASSERT(nFinalVerse > 0 && nFinalVerse <= 176);
//		if (nFinalVerse <= 0 || nFinalVerse > 176)
//			return FALSE; // error
//		else
		return bIsOK;
	}
	// return bHasChapters; // unreachable
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     the source phrase's m_nSequNumber which has the start of a section heading
/// \param      nStartingSequNum    -> an int representing the starting sequence number
/// \param      startingPos         <- an SPList node representing the starting position in pList
/// \param      pList               <- the source phrase list (not referenced directly, only via 
///                                    the startingPos node)
/// \remarks
/// Called from: the View's SetupRangePrintOp().
/// Scans backwards from the starting position looking for a source phrase with a section head marker
/// indicating that it is the start of a preceding section heading.
////////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItView::IncludeAPrecedingSectionHeading(int nStartingSequNum, SPList::Node* startingPos, SPList* WXUNUSED(pList))
{
	// whm revised 15Feb05 to include all markers of sectionHead textType
	int nOldSN = nStartingSequNum;
	SPList::Node* pos = startingPos;
	// whm Note: since startingPos is a node already pointing into pList, pList doesn't here need 
	// to be explicitly referenced, just call pos->GetData() to return the pSrcPhrase at pos in pList.
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetPrevious();
	wxASSERT(pSrcPhrase);
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markerStr; 
	wxString nonFilteredMkrs;

	while (pos != NULL)
	{
		pSrcPhrase = pos->GetData();
		pos = pos->GetPrevious();
		wxASSERT(pSrcPhrase);

		if (!pSrcPhrase->m_chapterVerse.IsEmpty())
		{
			// we have come to the start of a preceding verse without encountering any section
			// heading
			break;
		}

		// it is not possible for a section heading to be within a merged source phrase, so we do 
		// not need to check for medial markers; so just check contents of the m_markers attribute
		if (!pSrcPhrase->m_markers.IsEmpty())
		{
			//if (pSrcPhrase->m_markers.Find(sectionMarker) != -1)
			//{
			//	// there is a section marker, so we have found the start of a section heading
			//	return pSrcPhrase->m_nSequNumber;
			//}

			// whm added 14Feb05 in support of USFM and SFM Filtering
			markerStr = pSrcPhrase->m_markers;
			nonFilteredMkrs = pDoc->GetUnFilteredMarkers(markerStr);
			// NormalizeToSpaces leaves the markers in m_markers delimited by spaces, at
			// lease medially. We'll use the wxStringTokenizer method here.
			wxString sfm;
			wxStringTokenizer tkz(markerStr,_T(" "));
			
			while (tkz.HasMoreTokens())
			{
				sfm = tkz.GetNextToken();
				if (sfm[0] == gSFescapechar)	// Only check actual sfms. Some tokens will be only		 
												// numbers (those after \c and \v) which we ignore
				{
					sfm.Trim(TRUE); // trim right end
					sfm.Trim(FALSE); // trim left end
						sfm += _T(' '); // insure the sfm is followed by a space for unique find in
										// our wrap strings.
					// If only one of the sfms within m_markers is a wrap marker, we should return TRUE.
					switch (gpApp->gCurrentSfmSet)
					{
						case UsfmOnly: 
						{
							if (gpApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
								// there is a section marker, so we have found the start of a section heading
								return pSrcPhrase->m_nSequNumber;
							break;
						}
						case PngOnly:
						{
							if (gpApp->PngSectionHeadMarkersStr.Find(sfm) != -1)
								// there is a section marker, so we have found the start of a section heading
								return pSrcPhrase->m_nSequNumber;
							break;
						}
						case UsfmAndPng:
						{
							if (gpApp->UsfmAndPngSectionHeadMarkersStr.Find(sfm) != -1)
								// there is a section marker, so we have found the start of a section heading
								return pSrcPhrase->m_nSequNumber;
							break;
						}
						default: 
						{
							// if we got here it would be a program error
							if (gpApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
								return pSrcPhrase->m_nSequNumber;
						}
					}
				}
			}
		}
	}
	// if we get here, we couldn't find a preceding section heading
	return nOldSN;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if the range could not be determined or found, otherwise TRUE
/// \param      nFromCh     -> an int representing the chapter at the beginning of the range
/// \param      nFromV      -> an int representing the verse at the beginning of the range
/// \param      nToCh       -> an int representing the chapter at the end of the range
/// \param      nToV        -> an int representing the verse at the end of the range
/// \param      pPrintData  -> (unused)
/// \param      bSuppressPrecedingHeadingInRange  -> (unused)
/// \param      bIncludeFollowingHeadingInRange   -> (unused)
/// \remarks
/// Called from: the View's OnPrint() high level handler after the standard print dialog's OK button
/// has been pressed. Determines the sequence numbers for the indicated chapter and verse range and 
/// gets the appropriate sublist of source phrases making up that range. From this data it calls 
/// RecalcLayout to format the printout for the correct width, and PaginateDoc().
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::SetupRangePrintOp(const int nFromCh, const int nFromV, const int nToCh, 
									  const int nToV, wxPrintData* WXUNUSED(pPrintData), 
									  bool WXUNUSED(bSuppressPrecedingHeadingInRange), 
									  bool WXUNUSED(bIncludeFollowingHeadingInRange))
{
	// whm revised 8Mar08 to correct logic of tests for range inclusion
	if (gpApp->m_selectionLine != -1)
		RemoveSelection();
	SPList* pList = gpApp->m_pSourcePhrases;
	SPList* pSaveList = gpApp->m_pSaveList;
	wxASSERT(nFromCh >= 0);
	wxASSERT(nToCh >= 0);
	wxASSERT(nFromV >= 1);
	wxASSERT(nToV >= 1);
	wxASSERT(nToCh >= nFromCh);

	// check we have a legal range
	if (nFromCh < 0 || nToCh < 0 || nToCh < nFromCh || nToV < 1 || nFromV < 1)
	{
		// IDS_ILLEGAL_RANGE
		wxMessageBox(_("Sorry, the range you specified is illegal. Try again."),_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	else if (nFromCh == nToCh && nToV < nFromV)
	{
		// IDS_ILLEGAL_RANGE
		wxMessageBox(_("Sorry, the range you specified is illegal. Try again."),_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

	int nCh = 0;
	int nV = 0;
	bool bIsVRange = FALSE;
	bool bHasChapters = FALSE;
	int nFinalV = 0;
	SPList::Node* posEnd = NULL;
	SPList::Node* savePos = NULL;

	// find the beginning and ending sequence numbers for the range
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)NULL;
	SPList::Node* pos = pList->GetFirst();
	while (pos != NULL)
	{
		savePos = pos;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		wxString chv = pSrcPhrase->m_chapterVerse;
		if (chv.IsEmpty())
			continue;
		else
		{
			// we are at the start of a verse - see if it is where we want to start
			bool bOK = ExtractChapterAndVerse(chv,nCh,nV,bHasChapters,bIsVRange,nFinalV);

			// if something went wrong, just ignore the chapter and verse - and hope it wasn't 
			// the range start!
			if (!bOK)
				continue;
			else
			{
				// test what we found
				if (bHasChapters)
				{
					if (nCh != nFromCh)
						continue;
					else
					{
						// we are in the wanted chapter, so test the verse values
						if (bIsVRange)
						{
							// for a verse range, start printing here if the verse falls within 
							// the verse range
							//if (nV >= nFromV && nV <= nFinalV)
							// whm: the MFC version has the line above, but I don't think its logic
							// is correct. For example, if the source text has a 9:3-4 range, and the
							// user wants to print 9:4 (the last verse of the range), the above test
							// would fail even though the user's verse falls within the 9:3-4 range. 
							// The check should instead be as follows:
							if (nFromV >= nV && nFromV <= nFinalV)
							{
								// we have found the start of the printing range, so check for a 
								// preceding section heading, and include it if the suppression 
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos; // the position of the current source 
														   // phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
														nCurSequNumber, oldPos, pList);
								}
								
								// set the global for the sequence number of the start of the range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nFromV == nV)
							{
								// we have found the start of the printing range, so check for a 
								// preceding section heading, and include it if the suppression 
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos;	// the position of the current source 
																// phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
																nCurSequNumber, oldPos, pList);
								}
								
								// set the global for the sequence number of the start of the 
								// printing range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
					}
				}
				else
				{
					// does not have chapters, so all we can test for is verses (ignore chapter 
					// number if the user typed one in the dialog, provided it is 0 or 1)
					if (nFromCh > 1)
					{
						// IDS_NO_CHAPTERS
						wxMessageBox(_("Error: a chapter number was specified, but this document does not appear to contain chapter specifications. The print operation has been aborted."), _T(""), wxICON_STOP);
						return FALSE; // error condition, non-zero chapter number, 
									  // but doc has no chapters
					}
					else
					{
						// try test the verse now, since chapter number is either 0 or 1 & is 
						// being ignored
						if (bIsVRange)
						{
							// for a verse range, start printing here if the verse falls within 
							// the verse range
							//if (nV >= nFromV && nV <= nFinalV)
							// whm changed logic of test to the following:
							if (nFromV >= nV && nFromV <= nFinalV)
							{
								// we have found the start of the printing range, so check for a 
								// preceding section heading, and include it if the suppression 
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos; // the position of the current source
														   // phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
															nCurSequNumber, oldPos, pList);
								}
								
								// set the global for the sequence number of the start of the range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nFromV == nV)
							{
								// we have found the start of the printing range, so check for a 
								// preceding section heading, and include it if the suppression 
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos; // the position of the current source 
														   // phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
															nCurSequNumber, oldPos, pList);
								}
								
								// set the global for the sequence number of the start of the range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
					}
				}
			}
		}
	}

	// if we get here, we didn't find the start of the range - this is an error condition, 
	// so abort the print
	//IDS_RANGE_START_FAILURE
	wxMessageBox(_("Error: the specified chapter and verse for the start of the printing range could not be found. The print operation has been aborted."), _T(""), wxICON_STOP);
	return FALSE;

	// now continue searching for the end of the printing range
	// first check in case the end chapter and end verse is the same as the start ones
b:	if (bHasChapters)
	{
		if (nCh != nToCh)
			goto d; // end chapter is different from starting one, so keep looking
		else
		{
			// we are in the wanted chapter, so test the verse values
			if (bIsVRange)
			{
				// for a verse range, end printing here if the verse falls within the verse range
				//if (nV >= nToV && nV <= nFinalV)
				// whm: Again the logic here is not correct if the user's verse is at the end of a
				// range in the source text (see comment above). The logic should be as follows:
				if (nToV >= nV && nToV <= nFinalV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != NULL);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
			else
			{
				// it's not a range, so see if the verse number matches this one
				if (nToV == nV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != NULL);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
		}
	}
	else
	{
		// does not have chapters, so all we can test for is verses (ignore chapter number
		// if the user typed one in the dialog, provided it is 0 or 1)
		if (nToCh > 1)
		{
			// IDS_NO_CHAPTERS
			wxMessageBox(_("Error: a chapter number was specified, but this document does not appear to contain chapter specifications. The print operation has been aborted."),_T(""), wxICON_STOP);
			return FALSE; // error condition, non-zero or non-1 chapter number, 
						  // but doc has no chapters
		}
		else
		{
			// try test the verse now, since chapter number is either 0 or 1 & is being ignored
			if (bIsVRange)
			{
				// for a verse range, end printing here if the verse falls within the verse range
				//if (nV >= nToV && nV <= nFinalV)
				// whm changed logic of test the following:
				if (nToV >= nV && nToV <= nFinalV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != NULL);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
			else
			{
				// it's not a range, so see if the verse number matches this one
				if (nToV == nV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != 0);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
		}
	}

d:	;

	while (pos != 0)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		wxString chv = pSrcPhrase->m_chapterVerse;
		if (chv.IsEmpty())
			continue;
		else
		{
			// we are at the start of a verse - see if it is where we want to end the printing
			bool bOK = ExtractChapterAndVerse(chv,nCh,nV,bHasChapters,bIsVRange,nFinalV);

			// if something went wrong, just ignore the chapter and verse - and hope it wasn't 
			// the range end!
			if (!bOK)
				continue;
			else
			{
				// test what we found
				if (bHasChapters)
				{
					if (nCh != nToCh)
						continue;
					else
					{
						// we are in the wanted chapter, so test the verse values
						if (bIsVRange)
						{
							// for a verse range, end printing here if the verse falls within 
							// the verse range
							//if (nV >= nToV && nV <= nFinalV)
							// whm changed the logic to the following:
							if (nToV >= nV && nToV <= nFinalV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != 0);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto e;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nToV == nV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != 0);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
					}
				}
				else
				{
					// does not have chapters, so all we can test for is verses (ignore chapter 
					// number if the user typed one in the dialog, provided it is 0 or 1)
					if (nToCh > 1)
					{
						// IDS_NO_CHAPTERS
						wxMessageBox(_("Error: a chapter number was specified, but this document does not appear to contain chapter specifications. The print operation has been aborted."),_T(""), wxICON_STOP);
						return FALSE; // error condition, non-zero chapter number, 
									  // but doc has no chapters
					}
					else
					{
						// try test the verse now, since chapter number is either 0 or 1 & is 
						// being ignored
						if (bIsVRange)
						{
							// for a verse range, end printing here if the verse falls within 
							// the verse range
							//if (nV >= nToV && nV <= nFinalV)
							// whm changed the logic to the following:
							if (nToV >= nV && nToV <= nFinalV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != NULL);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto e;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nToV == nV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != NULL);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto e;
							}
							else
								continue; // iterate
						}
					}
				}
			}
		}
	}

	// if we get here, we didn't find the end of the range - this is an error condition, 
	// so abort the print
	// IDS_RANGE_END_FAILURE
	wxMessageBox(_("Error: the specified chapter and verse for the end of the printing range could not be found. The print operation has been aborted."),_T(""), wxICON_STOP);
	return FALSE;

	// we have the required range of sequence numbers, so we can reuse the selection code here
e:	bool bIsOK = GetSublist(pSaveList,pList,gnRangeStartSequNum,gnRangeEndSequNum);

	// recalc the layout with the new width (note, the gbPrintingRange value being TRUE means
	// that the SaveSelection() and RestoreSelection() calls in RecalcLayout() do nothing)
	RecalcLayout(pList,0,gpApp->m_pBundle);

	// destroy the box, and set safe values for a non-active location (leave m_targetPhrase
	// untouched)
	gpApp->m_pActivePile = NULL;
	gpApp->m_nActiveSequNum = gpApp->m_curIndex = -1;
	
	// we don't destroy the targetbox in the wx version, and I don't think it needs to be hidden here
	// either. 

	// ////////////////////////////////////////////////////////////////////////////////////////////
	// The stuff below could go into a separate function - see also CPrintOptionsDlg::InitDialog
	// Determine the length of the printed page in logical units.
	int pageWidthBetweenMarginsMM, pageHeightBetweenMarginsMM;
	wxSize paperSize_mm;
	paperSize_mm = gpApp->pPgSetupDlgData->GetPaperSize();
	wxASSERT(paperSize_mm.x != 0);
	wxASSERT(paperSize_mm.y != 0);
     // We should also have valid (non-zero) margins stored in our pPgSetupDlgData object.
	wxPoint topLeft_mm, bottomRight_mm; // MFC uses CRect for margins, wx uses wxPoint
	topLeft_mm = gpApp->pPgSetupDlgData->GetMarginTopLeft(); // returns top (y) and left (x) margins as wxPoint in milimeters
	bottomRight_mm = gpApp->pPgSetupDlgData->GetMarginBottomRight(); // returns bottom (y) and right (x) margins as wxPoint in milimeters
	wxASSERT(topLeft_mm.x != 0);
	wxASSERT(topLeft_mm.y != 0);
	wxASSERT(bottomRight_mm.x != 0);
	wxASSERT(bottomRight_mm.y != 0);
	// The size data returned by GetPageSizeMM is not the actual paper size edge to edge, nor the size
    // within the margins, but it is the usual printable area of a paper, i.e., the limit of where most
    // printers are physically able to print; it is the area in between the actual paper size and the
	// usual margins. We therefore start with the raw paperSize and determine the intended print area
	// between the margins.
	pageWidthBetweenMarginsMM = paperSize_mm.x - topLeft_mm.x - bottomRight_mm.x;
	pageHeightBetweenMarginsMM = paperSize_mm.y - topLeft_mm.y - bottomRight_mm.y;
	
	// Now, convert the pageHeightBetweenMarginsMM to logical units for use in calling PaginateDoc.
	// 
	// Get the logical pixels per inch of screen and printer.
	// whm NOTE: We can't yet use the wxPrintout::GetPPIScreen() and GetPPIPrinter() methods because
	// the wxPrintout object is not created yet at the time this print options dialog is displayed.
	// But, we can do the same calculations by using the wxDC::GetPPI() method call on both a
	// wxPrinterDC and a wxClientDC of our canvas.
	//
    // Set up printer and screen DCs and determine the scaling factors between printer and screen.
	wxASSERT(gpApp->pPrintData->IsOk());

#ifdef __WXGTK__
	// Linux requires we use wxPostScriptDC rather than wxPrinterDC
	// Note: If the Print Preview display is drawn with text displaced up and off the display on wxGTK,
	// the wxWidgets libraries probably were not configured properly. They should have included a
	// --with-gnomeprint parameter in the configure call.
	wxPostScriptDC printerDC(*gpApp->pPrintData); // MUST use * here otherwise printerDC will not be initialized properly
#else
	wxPrinterDC printerDC(*gpApp->pPrintData); // MUST use * here otherwise printerDC will not be initialized properly
#endif
	
	wxASSERT(printerDC.IsOk());
	wxSize printerSizePPI = printerDC.GetPPI(); // gets the resolution of the printer in pixels per inch (dpi)
	wxClientDC canvasDC(gpApp->GetMainFrame()->canvas);
	wxSize canvasSizePPI = canvasDC.GetPPI(); // gets the resolution of the screen/canvas in pixels per inch (dpi)
	float scale = (float)printerSizePPI.GetHeight() / (float)canvasSizePPI.GetHeight();

    // Calculate the conversion factor for converting millimetres into logical units. There are approx.
    // 25.4 mm to the inch. There are ppi device units to the inch. Therefore 1 mm corresponds to
    // ppi/25.4 device units. We also divide by the screen-to-printer scaling factor, because we need to
    // unscale to pass logical units to PaginateDoc.
	float logicalUnitsFactor = (float)(printerSizePPI.GetHeight()/(scale*25.4)); // use the more precise conversion factor
	int nPagePrintingWidthLU, nPagePrintingLengthLU;
	nPagePrintingWidthLU = (int)(pageWidthBetweenMarginsMM * logicalUnitsFactor);
	nPagePrintingLengthLU = (int)(pageHeightBetweenMarginsMM * logicalUnitsFactor);
	// The stuff above could go into a separate function - see also CPrintOptionsDlg::InitDialog
	// ////////////////////////////////////////////////////////////////////////////////////////////

	gnPrintingLength = nPagePrintingLengthLU; //nPrintingLength;

	// Footer adjustments and printing are done in the View's PrintFooter() function

	// do pagination
	//
	// whm: In the following call to PaginateDoc, we use the current m_nStripCount stored on pBundle,
	// because the PaginateDoc() call here is done within SetupRangePrintOp() which is called after the
	// print dialog has been dismissed with OK, and thus we are paginating the actual doc to print and
	// not merely simulating it for purposes of getting the pages edit box values for the print options
	// dialog.
	bIsOK = PaginateDoc(gpApp->m_pBundle->m_nStripCount,nPagePrintingLengthLU,NoSimulation); // doesn't call RecalcLayout(), uses m_nStripCount
	if (!bIsOK)
	{
		wxMessageBox(_T("Pagination failed."),_T(""), wxICON_STOP);
		return FALSE;
	}

	wxPrintDialogData printDialogData(*gpApp->pPrintData); 
	// pagination succeeded, so set the initial values
	int nTotalPages = gpApp->m_pagesList.GetCount();
	printDialogData.SetMaxPage(nTotalPages);
	printDialogData.SetMinPage(1);
	printDialogData.SetFromPage(1);
	printDialogData.SetToPage(nTotalPages);

	return TRUE;
}

// whm revised 15Feb05 to include all markers of sectionHead textType
void CAdapt_ItView::GetVerseEnd(SPList::Node*& curPos,SPList::Node*& precedingPos,SPList* WXUNUSED(pList),SPList::Node*& preLastPos)
{ 
	SPList::Node* pos = curPos;
	wxASSERT(curPos != 0);
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* lastPos;
	preLastPos = precedingPos;
	int count = 0;
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markerStr; 
	wxString nonFilteredMkrs;
	while (pos != 0)
	{
		lastPos = pos;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase == 0)
			break; // break out if we are at the end of the document
		count++;

		// if a following section heading is not wanted, check for it here & break early
		// if one is found
		if (!gbIncludeFollowingHeadingInRange)
		{
			// it is not possible for a section heading to be within a merged source phrase, so
			// we do not need to check for medial markers; so just check contents of the 
			// m_markers attribute
			if (!pSrcPhrase->m_markers.IsEmpty())
			{
				// whm added 14Feb05 in support of USFM and SFM Filtering
				markerStr = pSrcPhrase->m_markers;
				nonFilteredMkrs = pDoc->GetUnFilteredMarkers(markerStr);
				// NormalizeToSpaces leaves the markers in m_markers delimited by spaces, at
				// lease medially. We'll use the Tokenize CString method here.
				wxString sfm;
				wxStringTokenizer tkz(markerStr,_T(" "));
				
				while (tkz.HasMoreTokens())
				{
					sfm = tkz.GetNextToken();
					if (sfm[0] == gSFescapechar)	// Only check actual sfms. Some tokens will be only		 
													// numbers (those after \c and \v) which we ignore
					{
						sfm.Trim(TRUE); // trim right end
						sfm.Trim(FALSE); // trim left end
							sfm += _T(' '); // insure the sfm is followed by a space for unique find in
											// our wrap strings.
						// If only one of the sfms within m_markers is a wrap marker, we should return TRUE.
						switch (gpApp->gCurrentSfmSet)
						{
							case UsfmOnly: 
							{
								if (gpApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
									// there is a section marker, so we have found the place to end the printing range
									return; // preLastPos value is the value the caller wants
								break;
							}
							case PngOnly:
							{
								if (gpApp->PngSectionHeadMarkersStr.Find(sfm) != -1)
									// there is a section marker, so we have found the place to end the printing range
									return; // preLastPos value is the value the caller wants
								break;
							}
							case UsfmAndPng:
							{
								if (gpApp->UsfmAndPngSectionHeadMarkersStr.Find(sfm) != -1)
									// there is a section marker, so we have found the place to end the printing range
									return; // preLastPos value is the value the caller wants
								break;
							}
							default: 
							{
								// if we got here it would be a program error
								if (gpApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
									return; // preLastPos value is the value the caller wants
							}
						}
					}
				}
			}
		}

		// for safety, in a text with no verse numbering, we'll break from the loop after 300 
		// iterations
		if (pSrcPhrase->m_chapterVerse.IsEmpty() && count < 300)
		{
			preLastPos = lastPos;
			continue;
		}
		else
			break;
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Enables the "Units of Measurement..." item on the View menu. This menu item is always enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateUnits(wxUpdateUIEvent& event)
{
	event.Enable(TRUE);
}

void CAdapt_ItView::OnUnits(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CUnitsDlg dlg(pApp->GetMainFrame());
	dlg.Centre();
	if (dlg.ShowModal() == wxID_OK)
	{
		pApp->m_bIsInches = dlg.m_bIsInches;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pDC     -> the display context (either print preview, or actual physical printer
/// \param      fitRect -> the rectangle representing the area of the page enclosed by the page margins
/// \param      logicalUnitsFactor -> represents the factor that must be multipled by any linear 
///             measurement such as the half inch (12.7mm) that a footer is displaced below fitRect's 
///             bottom margin, in order to convert that linear measurement into logical units for 
///             correct positioning in the different display contexts 
/// \param      page -> the page currently being rendered
/// \remarks
/// Called from: AIPrintout::OnPrintPage(). Composes the text of the footer and draws it at the footer
/// position of the rendered page.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::PrintFooter(wxDC* pDC, wxRect fitRect, float logicalUnitsFactor, int page)
{
	// whm Note: This function's signature has been revised for the wx version. The fitRect parameter
	// is the rectangle that comprises the printing area within the page's margins; its dimensions are
	// in logical units which will differ depending on whether the footer is being drawn on the print
	// preview display context, or on an actual higher resolution printer dc. The logicalUnitsFactor
	// parameter represents the factor that must be multipled by any linear measurement such as the half
	// inch (12.7mm) that a footer is displaced below fitRect's bottom margin, in order to convert that
	// linear measurement into logical units for correct positioning in the different display contexts.
	
	// get document and app pointers
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString strPageNum;
	strPageNum = strPageNum.Format(_T("%d"),page);
	wxString tgtName = gpApp->m_pKB->m_targetLanguageName;
	wxString srcName = gpApp->m_pKB->m_sourceLanguageName;

	// get the filename  for the document (include the range if we are printing a chapter/verse
	// range)
	wxString strDocName = pDoc->GetFilename();	// get the name of the document (actually filename, 
												// with extension. GetFilename() returns the whole
												// absolute path, so just get the name + ext)
	wxFileName fn(strDocName);
	strDocName = fn.GetFullName();
	wxString strLeft;
	wxString strLeftPlusPageNum;
	if (gbPrintingRange)
	{
		strLeft = strLeft.Format(_T("%s/%s  %s   %d:%d to %d:%d"),srcName.c_str(),tgtName.c_str(),strDocName.c_str(),
										gnFromChapter,gnFromVerse,gnToChapter,gnToVerse);
		strLeftPlusPageNum = strLeftPlusPageNum.Format(_T("%s/%s  %s   %d:%d to %d:%d   %d"),srcName.c_str(),tgtName.c_str(),strDocName.c_str(),
										gnFromChapter,gnFromVerse,gnToChapter,gnToVerse,page);
	}
	else
	{
		strLeft = strLeft.Format(_T("%s/%s  %s"),srcName.c_str(),tgtName.c_str(),strDocName.c_str());
		strLeftPlusPageNum = strLeftPlusPageNum.Format(_T("%s/%s  %s   %d"),srcName.c_str(),tgtName.c_str(),strDocName.c_str(),page);
	}

	// create a 12 point size copy of the system font, colour black
	wxFont* pFont;
	pFont = new wxFont(*wxNORMAL_FONT);
	pFont->SetPointSize(10);
	pFont->SetWeight(wxBOLD);
	pDC->SetTextForeground(*wxBLACK);
	pDC->SetFont(*pFont);

	// Get the date & time file was last modified on the RHS, if not created yet, use the 
	// current system time instead.

	// whm 21Oct07 updated local time calculations below to account for change in Visual 
	// Studio from 2003 to 2005. In the process I discovered that CTime::Format already
	// formats the time as local rather than UTC, so no specific call to GetLocalTm is
	// now necessary with its changed parameter behavior between VS 2003 and 2005.
	// whm wx version comment: theTime doesn't need to be initialized, but it doesn't hurt. It
	// is set to the file's modification date/time below.
	wxDateTime theTime = wxDateTime::Now(); //initialize to the current time
	wxString path = gpApp->m_curAdaptionsPath + gpApp->PathSeparator + strDocName;
	bool bExists;
	bExists = ::wxFileExists(path) && !::wxDirExists(path);
	if (bExists)
	{
		wxFileName fn(path);
		theTime = fn.GetModificationTime(); // use the file's last modified date & time
	}
	wxString timeStr;
	timeStr = theTime.Format(_T("%a, %b %d, %H:%M, %Y")).c_str();

	/*
	// The following code captures the logic for doing a centered header if we decide to print one.
	wxString headerStr = _T("This is a test header");
	// scaling has been done and upper left margin intersection is now 0,0, so we can set coordinates
	// for DrawText based on that reference point in terms of screen coordinates. See
	// AIPrintout::OnPrintPage() for how logicalUnitsFactor is calculated.
	int headerXExt,headerYExt;
	pDC->GetTextExtent(headerStr,&headerXExt,&headerYExt);
    // Position the header 12.7mm (a half inch) above the top margin (the top of fitRect). Since the
    // logical origin is at 0,0, we need to add the fitRect.x position (fitRect.GetLeft()) to xPosHdr.
    // We also calculate in the vertical text extent of the header so that there is 12.7mm of space
    // between the bottom of the header text and the printing margin below it.
	float xPosHdr = (float)(fitRect.GetLeft())+(fitRect.GetWidth()/2.0 - (float)headerXExt/2.0);
	float yPosHdr = (float)(fitRect.GetTop()-12.8*logicalUnitsFactor-headerYExt);
    // Draw header a half inch above top margin. This will be a negative y-axis component because we
    // called SetLogicalOrigin() above on the AIPrintout's DC so that its origin is at the intersection
    // of the top and left page margins. Above this origin is negative y-axis coordinates.
	pDC->DrawText(headerStr, (long)xPosHdr, (long)yPosHdr); // draw header a half inch above top margin
	*/

    // Calculate the position for the footer. The incoming parameter fitRect represents the rectangular
    // printing area within the margins in logical units. The bottom of fitRect is the effective bottom
    // margin, so we'll place the footer 12.7mm (a half inch) in logical units below the bottom of
    // fitRect. Since the logical origin is at 0,0 of the page, we need to add the fitRect.x position
    // (fitRect.GetLeft()) to xPosFtr. In calculating the position of yPosFtr, however,
    // fitRect.GetBottom() returns coordinates in reference to 0,0. See AIPrintout::OnPrintPage() for
    // how logicalUnitsFactor is calculated.
	int footerXExt,footerYExt;
	pDC->GetTextExtent(strLeft,&footerXExt,&footerYExt);
	float yPosFtr = (float)(fitRect.GetBottom() + 12.7*logicalUnitsFactor); // y pos same for all segments of the footer
	float xPosFtrLeft = (float)fitRect.GetLeft();
	int timeXExt,timeYExt;
	pDC->GetTextExtent(timeStr,&timeXExt,&timeYExt);
	if (footerXExt+2 >= fitRect.GetWidth()/2)
	{
		pDC->GetTextExtent(strLeftPlusPageNum,&footerXExt,&footerYExt);
		// The strLeft (language names and file name) extends past the middle point of the footer, so
		// we will not try to draw the page number centered in the footer, but will just add a couple
		// spaces and the page number to the end of strLeft.
		// The timeStr should fit in the right-hand side of the footer, unless the language names
		// and/or file name are extremently long. Check to see if the time string will fit.
		if (footerXExt + timeXExt + 2 > fitRect.GetWidth()) // allow 2 spaces between footerXExt and timeXExt
		{
			// There is not enough space for the timeStr to fit on the footer between margins, so we'll
			// position the left part a little higher and draw the time part one line height lower than
			// the left part.
			pDC->DrawText(strLeftPlusPageNum, (long)xPosFtrLeft, (long)yPosFtr - timeYExt/2);
			int xPosTimeStr = fitRect.GetRight() - timeXExt;
			pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr + timeYExt/2);
		}
		else
		{
			// There is enough space for the timeStr to fit
			pDC->DrawText(strLeftPlusPageNum, (long)xPosFtrLeft, (long)yPosFtr);
			int xPosTimeStr = fitRect.GetRight() - timeXExt;
			pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr);
		}
	}
	else
	{
		// There is enough room to draw the page number in the middle of the footer
		pDC->DrawText(strLeft, (long)xPosFtrLeft, (long)yPosFtr);
		int xPosPageNum = fitRect.GetLeft() + fitRect.GetWidth()/2; // don't worry about adjusting for x extent of the page number
		pDC->DrawText(strPageNum, (long)xPosPageNum, (long)yPosFtr);
		int xPosTimeStr = fitRect.GetRight() - timeXExt;
		pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr);
	}

	// delete pFont for no memory leaks
	delete pFont;
}

// wxWidgets Note: This function in the MFC version was called CreateBox, but I've combined
// its functionality and that of ResizeBox into a single function now called ResizeBox in
// the wx version. This was possible because the function now calls SetSize() on the
// already existing target box. The target box is created once in the App and lives while the
// app lives. When the target box should not be shown, it is now simply hidden, rather than
// destroyed and reshown.
void CAdapt_ItView::ResizeBox(const wxPoint *pLoc, const int nWidth, const int nHeight,
							   wxString &text, int nStartChar, int nEndChar, CPile* pActivePile)
{
	#ifdef _Trace_Box_Loc_Wrong
	if (gpApp->m_nActiveSequNum >20)
	{
	TRACE3("\nCreateBox   pLoc {y= %d ,x= %d } sequ num = %d\n", pLoc->y, pLoc->x,pActivePile->m_pSrcPhrase->m_nSequNumber);
	}
	#endif

	gbEnterTyped = FALSE; // ensure it is FALSE, only ENTER key typed should set it TRUE
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp);
	wxRect rectBox(wxPoint((*pLoc).x,(*pLoc).y),wxPoint((*pLoc).x + nWidth,(*pLoc).y + nHeight+4)); // logical coords

	#ifdef _Trace_Box_Loc_Wrong
	if (gpApp->m_nActiveSequNum >20)
	{
	TRACE2("ResizeBox  rectBox topLeft { %d , %d } BEFORE OnPrepareDC & LPtoDP\n", rectBox.top, rectBox.left);
	}
	#endif

	int nStartingChar = nStartChar;
	int nEndingChar = nEndChar;
	/*{
	#ifdef __WXDEBUG__
		wxLogTrace("\nTrace 0 - Within ResizeBox - before OnPrepareDC call");
		wxString str;
		str = str.Format("rectBox -- Logical coords: T= %d, L= %d, B= %d, R= %d\n",
			rectBox.GetTop(), rectBox.GetLeft(), rectBox.GetBottom(), rectBox.GetRight());
		wxLogTrace(str);
	#endif
	}
	*/

	// convert to device coords
	wxClientDC aDC(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(aDC); //OnPrepareDC(&aDC); // adjust origin
	canvas->pFrame->PrepareDC(aDC); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame

	wxPoint ptrLoc = *pLoc;

	// CalcScrolledPosition is the complement of CalcUnscrolledPosition; CalcScrolledPosition translates 
	// logical coordinates to device ones.
	int newXPos,newYPos;
	pApp->GetMainFrame()->canvas->CalcScrolledPosition(rectBox.x,rectBox.y,&newXPos,&newYPos);
	rectBox.x = newXPos;
	rectBox.y = newYPos;
	// we leave the width and height the same
	
	// Below are alternates for calculating scrolled position
//#ifdef _DEBUG
//	// The device coords can be found by subtracting the logical coords of the upper left corner as
//	// reported by GetViewStart, from rectBox's upper left corner coords. This doesn't change the
//	// width and height of a wxRect; the width and height were established in the wxRect rectBox()
//	// construction statement above.
//	int xScrollUnits, yScrollUnits, xOrigin, yOrigin;
//	pApp->GetMainFrame()->canvas->GetViewStart(&xOrigin, &yOrigin); // gets xOrigin and yOrigin in scroll units
//	pApp->GetMainFrame()->canvas->GetScrollPixelsPerUnit(&xScrollUnits, &yScrollUnits); // gets pixels per scroll unit
//	rectBox.x -= xOrigin * xScrollUnits; // number pixels is ScrollUnits * pixelsPerScrollUnit
//	rectBox.y -= yOrigin * yScrollUnits;
//#endif

	
//#ifdef _DEBUG
//	//aDC.LPtoDP(&rectBox);
//	// whm Note: The following LogicalToDeviceXRel and LogicalToDeviceYRel and their non-Rel functions
//	// adjust the logical position of rectBox after scrolling down from the zero scroll position
//	int x = aDC.LogicalToDeviceXRel(rectBox.x);// get the logical X coord converted to device coord
//	int y = aDC.LogicalToDeviceYRel(rectBox.y);// get the logical Y coord converted to device coord
//	// the above should be equivalent to the non-Rel forms below when using saveRect
//	int xx = aDC.LogicalToDeviceX(saveRect.x);// get the logical X coord converted to device coord
//	int yy = aDC.LogicalToDeviceY(saveRect.y);// get the logical Y coord converted to device coord
//	wxASSERT(x == rectBox.x); //rectBox.x = x;
//	wxASSERT(y == rectBox.y); //rectBox.y = y;
//	wxASSERT(x == xx);
//	wxASSERT(y == yy);
//#endif

	#ifdef _Trace_Box_Loc_Wrong
	if (gpApp->m_nActiveSequNum >20)
	{
	TRACE2("ResizeBox  rectBox topLeft { %d , %d } AFTER OnPrepareDC & LPtoDP\n", rectBox.top, rectBox.left);
	}
	#endif

	// WX version resizes rather than recreating the target box
	pApp->m_pTargetBox->SetSize(rectBox.GetLeft(),rectBox.GetTop(),
								rectBox.GetWidth(),rectBox.GetHeight());

	// our NR version will use CEdit, not rich edit, so we need to enable it for complex script
	// rendering add RTL support for NR version
	// whm note: TODO: Shouldn't the following adjustment come before the SetSize call above???
	// The MFC version also has it after the m_targetBox.Create(...,rectBox,...), but seems to
	// me like the code below doesn't do anything to the size of the target box in its current
	// position here and in the MFC version. The MFC legacy ResizeBox() routine which does a 
	// similar thing, but the RTL Flags stuff there preceeds the SetWindowPos (wx equivalent 
	// is SetSize).
#ifdef _RTL_FLAGS
	// adjust, otherwise box is a bit too small vertically
	rectBox.SetHeight(rectBox.GetHeight() + 5); //rectBox.bottom += 5; // allow for the window borders
	if (gnVerticalBoxBloat > 0)
		rectBox.SetHeight(rectBox.GetHeight() + gnVerticalBoxBloat); //rectBox.bottom += gnVerticalBoxBloat; // allow for the leadings on the font

	// enable complex rendering
	// whm note for wx version: Right-to-left reading is handled automatically in Uniscribe and
	// Pango, but they differ in how they handle Unicode text chars that are from the first 128
	// point positions. In wxMSW SetLayoutDirection() aligns these to the right in the phrasebox
	// but in wxGTK (under Pango) SetLahoutDirection() aligns these to the left within the
	// phrasebox.
	if (gpApp->m_bTgtRTL)
	{
		pApp->m_pTargetBox->SetLayoutDirection(wxLayout_RightToLeft);
// whm Note: Pango overrides the following SetStyle() command
//#ifndef __WXMSW__
//		pApp->m_pTargetBox->SetStyle(-1,-1,wxTextAttr(wxTEXT_ALIGNMENT_RIGHT));
//#endif
	}
	else
	{
		pApp->m_pTargetBox->SetLayoutDirection(wxLayout_LeftToRight);
// whm Note: Pango overrides the following SetStyle() command
//#ifndef __WXMSW__
//		pApp->m_pTargetBox->SetStyle(-1,-1,wxTextAttr(wxTEXT_ALIGNMENT_LEFT));
//#endif
	}
#endif // for _RTL_FLAGS

	//pApp->m_targetBox.SetWindowText(text);
	pApp->m_pTargetBox->SetValue(text);
	if (gbIsGlossing && gbGlossingUsesNavFont)
		//pApp->m_pTargetBox->SetDefaultStyle(wxTextAttr(wxNullColour, wxNullColour,*pApp->m_pNavTextFont));
		pApp->m_pTargetBox->SetFont(*pApp->m_pNavTextFont);

	else
		//pApp->m_pTargetBox->SetDefaultStyle(wxTextAttr(wxNullColour, wxNullColour,*pApp->m_pTargetFont));
		pApp->m_pTargetBox->SetFont(*pApp->m_pTargetFont);

	// whm added following to show and enable the target box
	pApp->m_pTargetBox->Show();
	pApp->m_pTargetBox->Enable(TRUE);
	pApp->m_pTargetBox->SetEditable(TRUE);
	
	// restore focus and cursor position or selection
	pApp->m_pTargetBox->SetFocus();
	pApp->m_pTargetBox->SetSelection(nStartingChar,nEndingChar); // TRUE = no scroll // MFC has SetSel and TRUE
	gnStart = (int)nStartingChar;
	gnEnd = (int)nEndingChar;
	pApp->m_pTargetBox->m_pActivePile = pActivePile; //pApp->m_pTargetBox->m_pActivePile = pActivePile;

	if (gpApp->m_bFreeTranslationMode)
	{
		// prevent clicks and editing being done in phrase box
		// (do also in OnAdvancedFreeTranslationMode())
		// wx version: by setting the targetbox with SetEditable(FALSE) instead of Enable(FALSE) we
		// get to control the background color, keeping it pink in free trans mode
		gpApp->m_pTargetBox->SetEditable(FALSE); //gpApp->m_pTargetBox->Enable(FALSE);
		gpApp->m_pTargetBox->SetBackgroundColour(gpApp->m_freeTransCurrentSectionBackgroundColor);
	}
	else
	{
		// enable clicks and editing being to be done in phrase box
		// (do also in OnAdvancedFreeTranslationMode())
		gpApp->m_pTargetBox->SetEditable(TRUE); //gpApp->m_pTargetBox->Enable(TRUE);
		gpApp->m_pTargetBox->SetBackgroundColour(wxColour(255,255,255)); // white
	}

	/* whm commented out because problem of invisible phrase box doesn't happen on the
	// wx version.
	// BEW added 20Dec07: in Review mode when box is resized to show on next line when
	// box moves, it does not appear and doesn't appear for a for a few more Enter presses
	m_targetBox.Invalidate(); // hopefully this will fix it - it did, but it didn't fix the
							  // invisible box problem when user clicks on a hole in reviewing
							  // mode and then uses Enter key to advance - the box remains invisible
    */
}

void CAdapt_ItView::OnEditPreferences(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp);

	CEditPreferencesDlg editPrefsDlg(
		pApp->GetMainFrame(),
		-1,
		_("Edit Preferences"),
		wxDefaultPosition,
		wxDefaultSize,
		wxCAPTION|wxRESIZE_BORDER|wxSYSTEM_MENU|wxCLOSE_BOX|wxDIALOG_MODAL );
	editPrefsDlg.Centre();

	// need to set size hints otherwise the preferences dialog is way too tall
	// testing below //////////////////////////////////////////
	//wxSize dummySize = editPrefsDlg.GetSizer()->GetSize();
	//editPrefsDlg.SetSize(wxSize(640,480));
	//editPrefsDlg.GetSizer()->SetVirtualSizeHints(editPrefsDlg.GetParent());
	//wxWindow* dlgWnd = editPrefsDlg.GetParent();
	//wxSize frameSize = dlgWnd->GetSize(); // this gets the size of CMainFrame
	//wxSize dialogSize = editPrefsDlg.GetSize();
	//editPrefsDlg.SetSize(dialogSize);
	// testing above ///////////////////////////////////////////

	// TODO: Check how the individual notebook pages of the CEditPreferencesDlg
	// are initialized. Are their InitDialog() handlers called when the above
	// CEDitPreferencesDlg dialog is instantiated? or, are their InitDialog()
	// handlers called when user clicks on the appropriate tab in the notebook
	// for that page? If not, we need to call their InitDialog() handlers here.

	int nSaveMaxToDisplay;
	nSaveMaxToDisplay = pApp->m_nMaxToDisplay; // save value in case user changes it

	// preserve the current active pile location, by preserving the srcPhrases's sequNum
	// (because RecalcLayout will recreate everything any any saved pointers will no longer
	// be valid)
	int activeSequNum;
	if (pApp->m_nActiveSequNum < 0)
	{
		// must not have data yet, or we are at EOF, so no pile is currently active
		activeSequNum = -1;
	}
	else
	{
		// we are somewhere in the midst of the data, so a pile will be active
		activeSequNum = pApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;
		pApp->m_curIndex = activeSequNum;

		// remove any current selection, as we can't be sure of any pointers
		// depending on what user may choose to alter
		RemoveSelection();
	}
	wxString strSavePhraseBox = pApp->m_targetPhrase;

    // whm Design Modification NOTE:
    // !!! DO NOT INITIALIZE DATA IN INDIVIDUAL PREFERENCES PAGES HERE !!!
    // Each of the InitDialog() methods of the individual Preferences pages takes care of the
    // initialization of all of their local members directly from the corresponding members in the App
    // (many of which get initialized previously by config file values). This modification attempts to
    // keep initialization encapsulated more in the classes that know how to handle the data. Because of
	// this modification, we don't need to initialize them from here before the CEditPreferencesDlg's
	// ShowModal() call is made - as does the MFC version.

	// Put up the "Edit Preferences" dialog
	// wx note: Since CEditPreferencesDlg is based on wxPropertySheetDialog rather than
	// on wxDialog, it does not get its idle event processing turned off while it is in
	// modal state, therefore we turn off idle processing here manually just before
	// the ShowModal call; and turn it back on afterwards (below).
	wxIdleEvent::SetMode(wxIDLE_PROCESS_SPECIFIED); // turn idle processing off
	if(editPrefsDlg.ShowModal() == wxID_OK)
	{
		// whm Design Modification NOTE:
		// !!! DO NOT UPDATE DATA FROM INDIVIDUAL PREFERENCES PAGES HERE !!!
		// Each of the OnOK() methods of the individual Preferences pages takes care of the
		// updating the App's data members directly from their local temp... members. This modification attempts to
		// keep settings value changes encapsulated more in the classes that know how to handle the data. Because of
		// this modification, we don't need to update them from here after the CEditPreferencesDlg's
		// ShowModal() call is made - as does the MFC version.
	}
	wxIdleEvent::SetMode(wxIDLE_PROCESS_ALL); // turn idle processing back on

	// redraw, since all the pointers will be invalid
	/* BEW removed 31Jan08 because the global's value cannot always be relied upon
	gLastSrcPhrasePos = 0; // ensure we use the safe but longer algorithm to find new position
	*/
	RedrawEverything(activeSequNum);

	int len;
	// BEW modified 3Apr08, restore focus to the phrase box, except when in free translation
	// mode in which case it needs to be restored to the compose bar's editbox
	if (gpApp->m_bFreeTranslationMode)
	{
		CMainFrame* pFrame = gpApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		if (pFrame->m_pComposeBar != NULL)
			if (pFrame->m_pComposeBar->IsShown())
			{
				wxTextCtrl* pComposeBox = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
				wxString text;
				text = pComposeBox->GetValue(); 
				len = text.Length();
				pComposeBox->SetSelection(len,len);
				pComposeBox->SetFocus();
			}
	}
	else
	{

		if (gpApp->m_pTargetBox->IsShown())
		{
			len = gpApp->m_targetPhrase.Length();
			gnStart = len;
			gnEnd = len;
			gpApp->m_pTargetBox->SetSelection(len,len);
			gpApp->m_pTargetBox->SetFocus();
		}
	}

}

void CAdapt_ItView::OnFileSaveKB(wxCommandEvent& WXUNUSED(event))
// ammended for version 2.0 which supports glossing and/or adapting
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp);
	bool bOK = FALSE;
	wxString mess;
	mess.Empty();
	if (gbIsGlossing)
	{
		bOK = pApp->SaveGlossingKB(FALSE); // don't want backup produced of the glossing KB
		if (!bOK)
		{
			mess = _("Failure when trying to save the glossing knowledge base. ");
		}
	}
	else
	{
		bOK = pApp->SaveKB(FALSE); // don't want backup produced
		if (!bOK)
		{
			mess = _("Failure when trying to save the knowledge base. ");
		}
	}
	if (!bOK)
	{
		pApp->m_bAutoBackupKB = FALSE;	// turn it off, so if user reopens the app later, the
										// bad glossing KB will not overwrite the backed up one
		mess += _(" You should immediately save the document, then try again.");
		mess += _(" If you have repeated failures, then exit the application ");
		mess += _("and try one of the recovery strategies (either use the backup one ");
		mess += _("or the Restore Knowledge Base command). DO NOT use ");
		mess += _("the Backup Knowledge Base command now!");
		wxMessageBox(mess, _T(""), wxICON_EXCLAMATION);
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Enables the "Save Knowledge Base" item on the File menu if the appropriate KB is in a ready state,
/// otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileSaveKB(wxUpdateUIEvent& event)
// ammended for version 2.0
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbIsGlossing)
		event.Enable(pApp->m_bGlossingKBReady);
	else
		event.Enable(pApp->m_bKBReady);
}

void CAdapt_ItView::OnFileCloseProject(wxCommandEvent& event)
// ammended for version 2.0 which supports glossing and/or adapting
{
	// Since the Close Project menu item has an accelerator table hot key (CTRL-J see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	// On Windows, the accelerator key doesn't appear to call the handler for a disabled menu item, but
	// I'll leave the following code here in case it works differently on other platforms.
	//CMainFrame* pFrame = gpApp->GetMainFrame();
	//wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	//wxASSERT(pMenuBar != NULL);
	//if (!pMenuBar->IsEnabled(ID_FILE_CLOSEKB))
	//{
	//	::wxBell();
	//	return;
	//}

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp);
	CAdapt_ItDoc* pDoc = pApp->GetDocument();

	if (gbEnableGlossing)
	{
		// glossing is on, so we must ensure the menu toggle is turned off and the
		// glossing checkbox removed, so this can all be done with the following call
		OnAdvancedEnableglossing(event);
	}

	if (pApp->m_bFreeTranslationMode)
	{
		// free translation mode is on, so we must first turn it off
		wxCommandEvent event;
		OnAdvancedFreeTranslationMode(event);
	}

	if (!gbIgnoreScriptureReference_Receive)
	{
		// scripture reference receiving is turned on, and it must be
		// off when there is no project current
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedReceiveSynchronizedScrollingMessages(uevent); //toggle it to TRUE
	}

	if (!gbIgnoreScriptureReference_Send)
	{
		// scripture reference sending is turned on, and it must be
		// off when there is no project current
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedSendSynchronizedScrollingMessages(uevent); //toggle it to TRUE
	}

	// ask for saving of doc & both kbs (normal one and glossing one)
	pDoc->OnFileClose(event);

	if (bUserCancelled)
	{
		bUserCancelled = FALSE; // clear the flag to default situation
		return;
	}

	// then delete each KB and make the app unable to use either further
	gbJustClosedProject = TRUE;
	pDoc->EraseKB(pApp->m_pKB);
	pApp->m_bKBReady = FALSE;
	pApp->m_pKB = (CKB*)NULL; // done in EraseKB too
	// now the glossing KB and flags
	pDoc->EraseKB(pApp->m_pGlossingKB);
	pApp->m_bGlossingKBReady = FALSE;
	pApp->m_pGlossingKB = (CKB*)NULL; // done in EraseKB too

	// update status bar with project name
	wxString message;
	// IDS_NO_PROJECT
	message = message.Format(_("No project is currently active"));
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
	{
		wxString mssg;
		wxString undef;
		undef = _(" Undefined");
		// IDS_CURFOLDER
		mssg = mssg.Format(_("  Current Folder: %s"),undef.c_str());
		message += mssg;
	}
	StatusBarMessage(message); // don't want a glossing/adapting prefix, since we are closing

	// restore the glossing support flags to their default values, so an open of another
	// project will have the default 2-rows per strip interface in effect
	gbIsGlossing = FALSE;
	gbEnableGlossing = FALSE;
	gbGlossingUsesNavFont = FALSE;

	// book folder mode may have been on; we can't be sure the next project opened will have that
	// mode on, or even that it may have been on in the project at an earlier time, so the safe
	// thing to do is to turn it off
	gpApp->m_bBookMode = FALSE;
	if (gpApp->m_pBibleBooks != NULL)
		gpApp->m_bDisableBookMode = FALSE;
	else
		gpApp->m_bDisableBookMode = TRUE;
	gpApp->m_nBookIndex = -1;
	gpApp->m_nDefaultBookIndex = 39; // default is Matthew
	gpApp->m_nLastBookIndex = -1;
	gpApp->m_pCurrBookNamePair = NULL;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Disables the "Close Project" item on the File menu if Vertical Editing is in progress. Enables 
/// the item if the KBs are in a ready state, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileCloseKB(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// the kbs are closed or opened together
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Disables the "New" item on the File menu if Vertical Editing is in progress. Enables the item if 
/// the KB pointers are not NULL, if the m_pBundle is not NULL and if the bundle's m_nStripCount is 
/// zero, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileNew(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// we can't use m_pSourcePhrases->GetCount() equal to zero because after a File...Close
	// only the view (ie. strips) is clobbered, the source phrases don't get clobbered until
	// DeleteContents() is called, which does not happen until either the user chooses New...
	// or Open... or the Wizard equivalents, or closes the app. So a zero strip count is
	// a sufficient condition.
	// whm added 27May04 the check && m_pBundle != NULL
	if (pApp->m_pKB != NULL && pApp->m_pGlossingKB != NULL && pApp->m_pBundle != NULL && pApp->m_pBundle->m_nStripCount == 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Disables the "Open..." item on the File menu if Vertical Editing is in progress. Enables the 
/// item if the KB pointers are not NULL, and if the bundle's m_nStripCount is zero, otherwise 
/// it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileOpen(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// we can't use m_pSourcePhrases->GetCount() equal to zero because after a File...Close
	// only the view (ie. strips) is clobbered, the source phrases don't get clobbered until
	// DeleteContents() is called, which does not happen until either the user chooses New...
	// or Open... or the Wizard equivalents, or closes the app. So a zero strip count is
	// a sufficient condition.
	// I've changed this now, the source phrases now get clobbered, but using the strip count
	// is still perfectly acceptable, so I'll leave it unchanged.
	if (pApp->m_pKB != NULL && pApp->m_pGlossingKB != NULL && pApp->m_pBundle->m_nStripCount == 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Disables the "Print..." item on the File menu if Vertical Editing is in progress. Enables the 
/// item if the KBs are in a ready state, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFilePrint(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Disables the "Print Preview" item on the File menu if Vertical Editing is in progress. 
/// Enables the item if the KBs are in a ready state, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFilePrintPreview(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

// According to the wxWidgets developers, the "Print Setup..." menu selection is obsolete since
// Windows 95. Users are expecte to do any necessary print setup from the main print dialog.
/*
// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Disables the "Print Setup" item on the File menu if Vertical Editing is in progress.
/// Enables the item if the KBs are in a ready state, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFilePrintSetup(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}
*/

int CAdapt_ItView::SetPileHeight(const int curRows, const int srcHeight, const int tgtHeight,
				 const int navTextHeight, const bool bSuppressFirst, const bool bSuppressLast)
// version 2.0 and onwards adds the height of the glossing line when gbEnableGlossing is TRUE
// BEW added, 23Jun05: version 3 and onwards adds the height of the free translation line when
// app's m_bFreeTranslationMode is TRUE, plus 3 extra pixels to set it off from the rest of the
// strip above - provided we are not currently printing
{
	if (curRows != MAX_CELLS) // wxASSERT(curRows == MAX_CELLS); // to avoid warning
	{
		::wxBell(); 
		wxASSERT(FALSE);
	}
	int	pileHeight = 0;
	if (bSuppressLast)
		pileHeight = bSuppressFirst ? srcHeight + tgtHeight : 2*srcHeight + tgtHeight;
	else
		pileHeight = bSuppressFirst ? srcHeight + 2*tgtHeight : 2*srcHeight + 2*tgtHeight;
	if (gbEnableGlossing)
	{
		if (gbGlossingUsesNavFont)
			pileHeight += navTextHeight;
		else
			pileHeight += tgtHeight;
		pileHeight += 3; // add 3 more pixels because we will space the glossing line off from
						 // whatever line it follows by an extra 3 pixels, in CreatePile( ) - since
						 // with many fonts it appears to encroach on the bottom of the line above
	}
	if (gpApp->m_bFreeTranslationMode && !gbIsPrinting)
	{
		// add enough space for a single line of the height given by the target text's height + 3
		pileHeight += tgtHeight + 3;
	}
	return pileHeight;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     the number of Strips determined to compose the current layout (in simulation)
/// \param      pSrcPhrases   -> the list of source phrases of the current document
/// \param      sizeTotal     -> the layout size consisting of the nPagePrintingWidthLU and
///                                 nPagePrintingLengthLU dimensions (logical units)
/// \param      nBeginSN      -> the sequence number of the first source phrase in the layout
/// \param      nEndSN        -> the sequence number of the last source phrase in the layout
/// \remarks
/// Called from: CPrintOptionsDlg::InitDialog().
/// RecalcLayout_SimulateOnly() does not create any objects; it only calculates the layout
/// to the degree that it determines the number of Strips that will be needed and returns 
/// that number for simulating a printed layout. This number is then used as input to 
/// PaginateDoc() when it is called in the PrintOptionsDlg's InitDialog().
////////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItView::RecalcLayout_SimulateOnly(SPList *pSrcPhrases, const wxSize sizeTotal,const int nBeginSN,const int nEndSN)
{
	SPList* pSrcList = pSrcPhrases;
	if (pSrcPhrases == NULL)// || pBundle == NULL)
		return 0; // in support of window splitting
	if (pSrcPhrases->GetCount() == 0)
		return 0; // in support of window splitting

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	// set the pile height value
	int nPileHeight_SimulationOnly;
	if (gbShowTargetOnly)
	{
		if (gbIsGlossing)
		{
			if (gbGlossingUsesNavFont)
				nPileHeight_SimulationOnly = pApp->m_nNavTextHeight;
			else
				nPileHeight_SimulationOnly = pApp->m_nTgtHeight;
		}
		else
			nPileHeight_SimulationOnly = pApp->m_nTgtHeight;
	}
	else
	{
		nPileHeight_SimulationOnly =
			SetPileHeight(MAX_CELLS,pApp->m_nSrcHeight,pApp->m_nTgtHeight,pApp->m_nNavTextHeight,
														pApp->m_bSuppressFirst,pApp->m_bSuppressLast);
	}

	// get a device context, and get the origin adjusted (gRectViewClient is ignored when printing)
	wxClientDC viewDC(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(viewDC); //  adjust origin
	canvas->pFrame->PrepareDC(viewDC); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame
	
	// The map mode remains wxMM_TEXT for both normal screen rendering and for printing/previewing.
	viewDC.SetMapMode(wxMM_TEXT); // equivalent to MFC's MM_TEXT for drawing to the screen

	int		nVertOffset;
	int		nLastSequNumber;
	int		nEndIndex;
	
	// we are starting from the beginning as far as vertical offset
	nVertOffset = 0;
	// we're simulating so we don't use the App's indices for m_beginIndex and m_endIndex, instead we
	// use those we pass in to RecalcLayout_SimulateOnly
	nLastSequNumber = nBeginSN; // nBeginSN is incoming parameter
	nEndIndex = nEndSN; // nEndSN is incoming parameter
	// for _SimulateOnly we don't change the pBundle, but use local variables for the strip index and count
	int nStripIndex = -1;
	int nStripCount = 0;
	// Our incoming sizeTotal parameter contains the page printing dimensions in logical units (LU)
	// which we need to pass on to CreateStrip_SimulateOnly for the width of its rectStrip creation.
	int nPagePrintWidthLU = sizeTotal.x;

	while (nLastSequNumber < nEndIndex)
	{
		nStripIndex++; // set local index for this strip
		nVertOffset = CreateStrip_SimulateOnly(&viewDC,pSrcList,nVertOffset,nPagePrintWidthLU,nLastSequNumber,nEndIndex);
		nStripCount++; // increment local strip count
		// whm: don't store anything in pBundle
	}
	// Simulating only - we don't set the App's m_docSize, nor do we call SetVirtualSize on the canvas
	return nStripCount; // just return our non-pBundle nStripCount here for return value
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrases   -> the list of source phrases of the current document
/// \param      nFirstStrip   -> the strip at which to start recalculations (usually 0)
/// \param      pBundle       -> a pointer to the bundle
/// \remarks
/// Called from: the CAdapt_ItCanvas::OnLButtonDown(), the Doc's OnNewDocument(), OnOpenDocument(),
/// ReconstituteAfterFilteringChange(), RetokenizeText(), the View's OnInitialUpdate(),
/// SetupRangePrintOp(), DoTargetBoxPaste(), PlacePhraseBox(), ReDoPhraseBox(), AdvanceBundle(),
/// RetreatBundle(), OnButtonToEnd(), OnButtonToStart(), RetreatBundleToStart(), OnButtonStepDown(),
/// OnButtonStepUp(), OnButtonMerge(), OnButtonRestore(), InsertNullSrcPhraseAfter(),
/// OnButtonNullSrc(), InsertNullSourcePhrase(), RemoveNullSourcePhrase(), RedrawEverything(),
/// PadWithNullSourcePhrasesAtEnd(), OnButtonRetranslation(), OnButtonEditRetranslation(),
/// OnRemoveRetranslation(), OnButtonNoAdapt(), OnEditSourceText(), PadOrShortenAtEnd(),
/// JumpForwardToNote_CoreCode(), JumpBackwardToNote_CoreCode(), the ~AIPrintout() destructor,
/// OnPreparePrinting(), CPhraseBox's JumpForward(), MoveToNextPile(), MoveToPrevPile(),
/// MoveToImmedNextPile(), LookAhead(), LookUpSrcWord(), FixBox().
/// Calculates and creates the layout of the view according to the current size of the client view (for
/// layout on the screen), or according to the (logical unit) size of the display context (for layout
/// in print preview or actual printing). RecalcLayout calls CreateStrip() to continue the process of
/// creating each successively smaller part of the Bundle, Strip, Pile, Cell, and Text hierarchy making
/// up the view. See also RecalcLayout_SimulateOnly(). See notes in function.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RecalcLayout(SPList *pSrcPhrases, int nFirstStrip, CSourceBundle* pBundle)
{
	// whm Note: RecalcLayout does the following things:
	// 1. Preserves selection parameters across recalculations
	// 2. Updates current size and position data on the app for saving in config file on closure
	// 3. Calculates and sets m_curPileHeight
	// 4. Sets global grectViewClient for speed drawing (set w GetClientSize) & converts its coords to logical ones
	// 5. MFC version sets mapping mode to wxMM_TEXT (wxMM_LOENGLISH when printing); wx versions always
	//    uses wxMM_TEXT even for printing
	// 6. Destroy old strips from nFirstStrip and recreate new strips from nFirstStrip through remainder of doc
	// 7. Set the virtual size of the document based on the newly layed out app's m_docSize
	// 8. Set the line and page oriented scrolling parameters to account for any change in m_curPileHeight
	//    and m_curLeading
	// 9. If free translation mode is turned on, get the current section delimited and made visible (when not printing)
	//
	SPList* pSrcList = pSrcPhrases;
	if (pSrcPhrases == NULL || pBundle == NULL)
		return; // in support of window splitting
	if (pSrcPhrases->GetCount() == 0)
		return; // in support of window splitting

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	// preserve selection parameters, so it can be preserved across the recalculation
	StoreSelection(pApp->m_selectionLine);

	// send the app the current size & position data, for saving to config file on closure
	wxRect rectFrame;
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);

	// Note: MFC's GetWindowRect() docs say "The dimensions are given in screen
	// coordinates relative to the upper-left corner of the display screen. The
	// dimensions of the caption, border, and scroll bars, if present, are included."
	// The wxWidgets' GetRect() docs say, "Returns the size and position of the
	// window as a wxRect object." Testing shows that they are the same.
	rectFrame = pFrame->GetRect(); // screen coords
	rectFrame = NormalizeRect(rectFrame); // use our own from helpers.h
	// MFC docs say about NormalizeRect: "Normalizes CRect so that both the height and width
	// are positive. The rectangle is normalized for fourth-quadrant positioning, which Windows
	// typically uses for coordinates. NormalizeRect compares the top and bottom values, and
	// swaps them if the top is greater than the bottom. Similarly, it swaps the left and right
	// values if the left is greater than the right. This function is useful when dealing with
	// different mapping modes and inverted rectangles."
	//m_ptViewTopLeft = rectFrame.TopLeft(); // see two lines below:
	pApp->m_ptViewTopLeft.x = rectFrame.x;
	pApp->m_ptViewTopLeft.y = rectFrame.y;
	pApp->m_szView.SetWidth(rectFrame.GetWidth()); 
	pApp->m_szView.SetHeight(rectFrame.GetHeight());
	pApp->m_bZoomed = pFrame->IsMaximized();

	// GetClientRect gets a rectangle in which upper left coords are always 0,0
	//pApp->GetMainFrame()->canvas->GetClientSize(&fwidth,&fheight); // gets the width and height in pixels
	// wx note: calling GetClientSize on the canvas produced different results in wxGTK and
	// wxMSW, so I'll use my own GetCanvasClientSize() which calculates it from the main frame's
	// client size.
	wxSize canvasViewSize;
	canvasViewSize = pApp->GetMainFrame()->GetCanvasClientSize();
	
	int nViewWidth = canvasViewSize.x;

	// at this stage we can't set m_docSize.cy correctly, but we can set m_docSize.cx depending
	// on whether strip-wrap is on (width is tied to client area width), or off (width is tied
	// to screen width) - later in this function the .cy member gets set, after all the strips are
	// laid out

	// whm Note: RecalcLayout is called in many places, but it goes quickly even in long documents
	// so I've removed the CWaitDlg in the the wx version
	if (gbIsPrinting)
	{
		// the document width will be set by the page dimensions and margins, externally,
		// so do nothing here 
		;
	}
	else
	{
		// not printing, so the layout is being done for the screen
		pApp->m_docSize.x = nViewWidth - RH_SLOP;	// RH_SLOP is currently 40,
													// set in AdaptitConstants.h
	}

	// set the pile height value
	if (gbShowTargetOnly)
	{
		if (gbIsGlossing)
		{
			if (gbGlossingUsesNavFont)
				pApp->m_curPileHeight = pApp->m_nNavTextHeight;
			else
				pApp->m_curPileHeight = pApp->m_nTgtHeight;
		}
		else
			pApp->m_curPileHeight = pApp->m_nTgtHeight;
	}
	else
	{
		pApp->m_curPileHeight =
			SetPileHeight(MAX_CELLS,pApp->m_nSrcHeight,pApp->m_nTgtHeight,pApp->m_nNavTextHeight,
														pApp->m_bSuppressFirst,pApp->m_bSuppressLast);
	}

	// get a device context, and get the origin adjusted (gRectViewClient is ignored when printing)
	wxClientDC viewDC(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(viewDC); //  adjust origin
	canvas->pFrame->PrepareDC(viewDC); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame
	
//#ifdef _DEBUG
//	// Here's sample code for alternative 1:
//	// save a copy of the initial grectViewClient values for use below (alternative 2 changes grectViewClient)
//	wxRect testRectViewClient = grectViewClient;
//#endif

	//int xScrollUnits, yScrollUnits, xOrigin, yOrigin;
	//pApp->GetMainFrame()->canvas->GetViewStart(&xOrigin, &yOrigin); // gets xOrigin and yOrigin in scroll units
	//pApp->GetMainFrame()->canvas->GetScrollPixelsPerUnit(&xScrollUnits, &yScrollUnits); // gets pixels per scroll unit
	//grectViewClient.x = xOrigin * xScrollUnits; // number pixels is ScrollUnits * pixelsPerScrollUnit
	//grectViewClient.y = yOrigin * yScrollUnits;

//#ifdef _DEBUG
//	// wx version use: CalcUnscrolledPosition
//	int newXPos,newYPos;
//	pApp->GetMainFrame()->canvas->CalcUnscrolledPosition(0,0,&newXPos,&newYPos);
//	wxASSERT(newXPos == grectViewClient.x); //grectViewClient.x = newXPos; // stays zero since we dont' have horizontal scrolling
//	wxASSERT(newYPos == grectViewClient.y); //grectViewClient.y = newYPos;
//	// width and height of grectViewClient was set above; changing the rect's x,y coordinates maintains these
//#endif

//#ifdef _DEBUG
	// alternative 1 (continued from above)
	//viewDC.DPtoLP(&grectViewClient); // get the point converted to logical coords
	// MFC docs say of DPtoLP(), "Converts device units into logical units. The function maps
	// the coordinates of each point, or dimension of a size, from the device coordinate system
	// into GDI's logical coordinate system. The conversion depends on the current mapping mode
	// and the settings of the origins and extents for the device's window and viewport."
	// It isn't clear from the docs, but testing shows that the upper left coordinates are
	// adjusted down when scrolling down, so the upper-left coord is no longer (0,0), but
	// something like (0,172).
//	int x = viewDC.DeviceToLogicalX(testRectViewClient.x);// get the device X (width) coord converted to logical coord
//	int y = viewDC.DeviceToLogicalY(testRectViewClient.y); // get the device Y (height) coord converted to logical coord
//	wxASSERT(x == grectViewClient.x); //grectViewClient.x = x; // stays zero since we dont' have horizontal scrolling
//	wxASSERT(y == grectViewClient.y); //grectViewClient.y = y;
//	// width and height of grectViewClient was set above; changing the rect's x,y coordinates maintains these
//#endif

	pApp->GetMainFrame()->canvas->CalcUnscrolledPosition(0,0,&grectViewClient.x,&grectViewClient.y);
	//wxLogDebug(_T("RecalcLayout CalcUnscrolledPosition: grectViewClient.x = %d grectViewClient.y = %d"),grectViewClient.x,grectViewClient.y);
	// set the width and height of the grectViewClient rect
	//GetCanvasClientSize() was called farther above
	grectViewClient.width = canvasViewSize.GetWidth();
	grectViewClient.height = canvasViewSize.GetHeight();
	
	// if we are printing, then we will want text extents (which use viewDC for their calculation)
	// to be done for MM_LOENGLISH mapping mode
	// whm notes:
	// wxWidgets has the following defined mapping modes:
	// wxMM_TWIPS		Each logical unit is 1/20 of a point, or 1/1440 of an inch.
	// wxMM_POINTS		Each logical unit is a point, or 1/72 of an inch.
	// wxMM_METRIC		Each logical unit is 1 mm.
	// wxMM_LOMETRIC	Each logical unit is 1/10 of a mm.
	// wxMM_TEXT		Each logical unit is 1 pixel.
	// MFC has the following defined mapping modes:
	// MM_ANISOTROPIC	Logical units are converted to arbitrary units with arbitrarily scaled axes. Setting the mapping mode to MM_ANISOTROPIC does not change the current window or viewport settings. To change the units, orientation, and scaling, call the SetWindowExt and SetViewportExt member functions. 
	// MM_HIENGLISH		Each logical unit is converted to 0.001 inch. Positive x is to the right; positive y is up. 
	// MM_HIMETRIC		Each logical unit is converted to 0.01 millimeter. Positive x is to the right; positive y is up. 
	// MM_ISOTROPIC		Logical units are converted to arbitrary units with equally scaled axes; that is, 1 unit along the x-axis is equal to 1 unit along the y-axis. Use the SetWindowExt and SetViewportExt member functions to specify the desired units and the orientation of the axes. GDI makes adjustments as necessary to ensure that the x and y units remain the same size. 
	// MM_LOENGLISH		Each logical unit is converted to 0.01 inch. Positive x is to the right; positive y is up. 
	// MM_LOMETRIC		Each logical unit is converted to 0.1 millimeter. Positive x is to the right; positive y is up. 
	// MM_TEXT			Each logical unit is converted to 1 device pixel. Positive x is to the right; positive y is down. 
	// MM_TWIPS			Each logical unit is converted to 1/20 of a point. (Because a point is 1/72 inch, a twip is 1/1440 inch.) Positive x is to the right; positive y is up. 
	// There are only 3 mapping modes that use the same units between MFC and wxWidgets which are:
	// wxMM_TWIPS is same as MM_TWIPS - in both each logical unit is converted to 1/20 of a point or 1/1440 inch. Positive x to the right, positive y is up.
	// wxMM_TEXT is same as MM_TEXT - in both each logical unit is converted to 1 device pixel. Positive x to the right, positive y is down.
	// wxMM_LOMETRIC is same as MM_LOMETRIC - in both each logical unit is converted to 1/10 of a mm
	// All other mapping modes are different units or scales
	
	// The map mode remains wxMM_TEXT for both normal screen rendering and for printing/previewing.
	// MFC had MM_LOENGLISH, in which each logical unit is converted to 0.01 inch.
	// and Positive x is to the right; positive y is up.
	// wxMM_LOENGLISH compiles OK but give a run time error/assert "unknown mapping mode in
	// SetMapMode." Therefore if we use anything other than wxMM_TEXT, we will need to use wxMM_LOMETRIC
	// for printing in the wx version. Since MFC uses MM_LOENGLISH which reverses the y axis
	// component during printing and previewing, we'll use wxMM_LOMETRIC, the closest equivalent which
	// also reverses the y axis component during printing.
	viewDC.SetMapMode(wxMM_TEXT); // equivalent to MFC's MM_TEXT for drawing to the screen

	int		nVertOffset;
	int		nLastSequNumber;
	// add some fail-safe code here, in case a functionality has reduced the m_maxIndex value (such
	// as editing source text and removing some) in a bundle at the document end, and m_endIndex
	// was not checked and also reset appropriately. However, doc-length altering functionalities
	// should not rely on this check, but do the proper calculations in their handlers.
	if (pApp->m_endIndex > pApp->m_maxIndex)
	{
		pApp->m_endIndex = pApp->m_maxIndex;
		if (pApp->m_upperIndex > pApp->m_maxIndex)
			pApp->m_upperIndex = pApp->m_maxIndex;
	}
	int		nEndIndex = pApp->m_endIndex;

	// if the nFirstStrip value is non-zero, then we must find the sequNumber of the last srcPhrase
	// in the preceding strip, as the next one will be first in the new strip
	if (nFirstStrip > 0)
	{
		wxASSERT(pBundle->m_nStripCount > 0);

		CPile* pPile = pBundle->m_pStrip[nFirstStrip]->m_pPile[0]; // first in stuff to be deleted
		pPile = GetPrevPile(pPile); // last in previous strip (can assume pPile will be non null)
		wxASSERT(pPile != 0);
		int nLastStrip = nFirstStrip -1;
		CStrip* pLastStrip = pBundle->m_pStrip[nLastStrip];
		nVertOffset = pLastStrip->m_nVertOffset; // offset to bottom of this strip
		nLastSequNumber = pPile->m_pSrcPhrase->m_nSequNumber;

		// now we can delete the unwanted strips		pBundle->DestroyStrips(nFirstStrip);

		// now (Aug 2001, for printing) we no longer always remove the selection, because a Print
		// Preview calls OnSize() before OnPreparePrinting is entered, and OnSize() calls
		// RecalculateEverything() which in turn calls RecalcLayout() - so if we made the
		// recalculation clobber the selection as used to be the case, we can never know there was
		// a selection current when doing a Print Preview, the solution is therefore to preserve
		// selections over the layout recalculation, and to use RemoveSelection() explicitly
		// wherever such preservation is not appropriate for other operations

		// set some more parameter values
		pBundle->m_nStripIndex = nLastStrip;
		pBundle->m_nStripCount = nLastStrip + 1;

		while (nLastSequNumber < nEndIndex)
		{
			pBundle->m_nStripIndex++; // set the index for this strip
			nVertOffset = CreateStrip(&viewDC,pSrcList,nVertOffset,nLastSequNumber,nEndIndex);
			pBundle->m_nStripCount++; // count it
			pBundle->m_pStrip[pBundle->m_nStripIndex]->m_nVertOffset = nVertOffset; // store offset
			pBundle->m_pStrip[pBundle->m_nStripIndex]->m_nStripIndex =
															pBundle->m_nStripIndex; // store index
		}
		wxSize sizeTotal;
		sizeTotal.SetWidth(pApp->m_docSize.GetWidth());

		// set the sizeTotal height + 40 pixels for a little margin at bottom of document
		sizeTotal.SetHeight(nVertOffset+40); // offset is positive even for printing
		pApp->m_docSize = sizeTotal; // update doc size (in pixels) stored on app
        // In the MFC version SetScrollSizes has a parameter to set the mapping mode, and for
        // printing, MFC sets the mapping mode here to MM_LOENGLISH, even though setting the mapping
        // mode at this point is redundant because it is explicitly set earlier in RecalcLayout
        // above. In the wx version we continue to just use the wxMM_TEXT mapping mode during
        // printing and print preview operations, so it doesn't need to be changed here.
        // 
        // whm: SetVirtualSize() appears to be the equivalent of MFC's SetScrollSizes
        // SetVirtualSize() sets the virtual size of the window in pixels.
		pApp->GetMainFrame()->canvas->SetVirtualSize(sizeTotal);	// MFC: uses wxMM_LOMETRIC,
																	// logical unit = .1 mm
	}
	else
	{
		// destroy old strips, if there are any
				pBundle->DestroyStrips(0); // destroy from 0th to end

		/* no longer want this - see above block for the reason
		m_selection.RemoveAll(); // make sure the record of an existing selection is cleared too
		m_selectionLine = -1;
		m_pAnchor = NULL;
		*/

		// we are starting from the beginning
		nVertOffset = 0;
		nLastSequNumber = pApp->m_beginIndex-1; // this will be -1 if starting from beginning
		pBundle->m_nStripIndex = -1;
		pBundle->m_nStripCount = 0;

		while (nLastSequNumber < nEndIndex)
		{
			pBundle->m_nStripIndex++; // set the index for this strip
			nVertOffset = CreateStrip(&viewDC,pSrcList,nVertOffset,nLastSequNumber,nEndIndex);
			pBundle->m_nStripCount++; // count it
			pBundle->m_pStrip[pBundle->m_nStripIndex]->m_nVertOffset = nVertOffset; // store offset
			pBundle->m_pStrip[pBundle->m_nStripIndex]->m_nStripIndex =
															pBundle->m_nStripIndex; // store index
		}
		wxSize sizeTotal;
		sizeTotal.SetWidth(pApp->m_docSize.GetWidth());
		pApp->m_docSize = sizeTotal; // update doc size stored on app
		
		sizeTotal.SetHeight(nVertOffset+40); // offset always positive even for printing
		pApp->m_docSize = sizeTotal; // update doc size stored on app
		// In the MFC version SetScrollSizes has a parameter to set the mapping mode and for
		// printing, MFC sets the mapping mode here to MM_LOENGLISH. Setting the mapping mode here
		// is redundant because it is explicitly set earlier in RecalcLayout above. In the wx
		// version we've also set the mapping mode above in RecalcLayout, so it doesn't need to be
		// set again here.
		// whm: SetVirtualSize() is the equivalent of MFC's SetScrollSizes.
		// SetVirtualSize() sets the virtual size of the window in pixels.
		pApp->GetMainFrame()->canvas->SetVirtualSize(sizeTotal);	// MFC uses wxMM_LOMETRIC,
																	// logical unit = .1 mm
	}

	// The MFC identifiers m_pageDev and m_lineDev are internal members of CScrollView.
	// I cannot find them anywhere in MFC docs, but looking at CScrollView's sources, it
	// is evident that they are used to set the scrolling parameters within the scrolled
	// view in the MFC app. We'll convert the values to the proper units and use
	// SetScrollbars() to set the scrolling parameters.
	//wxSize nSize = m_pageDev; // m_pageDev is "per page scroll size in device units"
	//wxSize mSize = m_lineDev; // m_lineDev is "per line scroll size in device units"
	// wx note: the m_lineDev value in MFC is equivalent to the first two parameters of
	// wxScrollWindow's SetScrollbars (pixelsPerUnitX, and pixelsPerUnitY). Both MFC and
	// WX values are in pixels.
	// The m_pageDev value in MFC is set below as twice the height of a strip (including leading).
	// In WX the height of a page of scrolled stuff should be determined automatically from the
	// length of the document (in scroll units), divided by the height of the client view (also in
	// scroll units).
	// The parameters needed for SetScrollbars are:
	int pixelsPerUnitX, pixelsPerUnitY, noUnitsX, noUnitsY;
	int xPos, yPos; // xPos and yPos default to 0 if unspecified
	bool noRefresh; // noRefresh defaults to FALSE if unspecified

	// whm note: We allow our wxScrolledWindow to govern our scroll
	// parameters based on the width and height of the virtual document
	// MFC has:
	//if (pApp->m_curPileHeight > 0 && pApp->m_curPileHeight < 300)
	//{
	//	//m_pageDev.cy = 2* pApp->m_curPileHeight + 2*pApp->m_curLeading;
	//	//m_pageDev.cx = 100;
	//	pixelsPerUnitY = pApp->m_curPileHeight/2; //m_lineDev.cy = pApp->m_curPileHeight/2;
	//	pixelsPerUnitX = 40; //m_lineDev.cx = 40;
	//}
	//else
	//{
	//	//m_pageDev.cy = 300;
	//	//m_pageDev.cx = 100;
	//	pixelsPerUnitY = 120; //m_lineDev.cy = 120;
	//	pixelsPerUnitX = 60; //m_lineDev.cx = 60;
	//}

	// WX version: We only need to specify the length of the scrollbar in scroll steps/units.
	// Before we can call SetScrollbars we must calculate the size of the document in scroll units, which
	// is the size in pixels divided by the pixels per unit.
	pFrame->canvas->GetScrollPixelsPerUnit(&pixelsPerUnitX,&pixelsPerUnitY);
	noUnitsX = pApp->m_docSize.GetWidth() / pixelsPerUnitX;
	noUnitsY = pApp->m_docSize.GetHeight() / pixelsPerUnitY;
	// we need to specify xPos and yPos in the SetScrollbars call, otherwise it will cause the window
	// to scroll to the zero position everytime RecalcLayout is called.
	// We'll use GetViewStart instead of CalcUnscrolledPosition here since SetScrollbars below takes 
	// scroll units rather than pixels.
	pApp->GetMainFrame()->canvas->GetViewStart(&xPos, &yPos); // gets xOrigin and yOrigin in scroll units
	noRefresh = FALSE; // do a refresh
    // Now call SetScrollbars - this is the only place where the scrolling parameters are established
    // for our wxScrolledWindow (canvas). The scrolling parameters are reset everytime RecalcLayout is
    // called. This is the only location where SetScrollbars() is called on the canvas.
    
	// whm IMPORTANT NOTE: We need to use the last position of the scrolled window here. 
	// If we don't include xPos and yPos here, the scrollbar immediately scrolls to the zero/initial
	// position in the recalculated bundle, which fouls up the calculations in other routines such
	// as MoveToPrevPile.
    pApp->GetMainFrame()->canvas->SetScrollbars(
			pixelsPerUnitX,pixelsPerUnitY,	// number of pixels per "scroll step"
        	noUnitsX,noUnitsY,				// sets the length of scrollbar in scroll steps, i.e., the size of the virtual window
    		xPos,yPos,						// sets initial position of scrollbars NEEDED!
    		noRefresh);						// SetScrollPos called elsewhere
    
	//UpdateBars();	// whm: UpdateBars is not a documented member of CView or CScrolledView, but snooping in
					// MFC source file viewscrl.cpp, its function is found there. Some comments there
					// indicate it updates things when the view changes size and "handles locking out
					// recursion" - probably if the size no longer requires a scroll bar to be displayed,
					// it resizes the window to accommodate the presence/absence of the scroll bar.
					// Since UpdateBars() is not documented, and is called internally several places
					// within viewscrl.cpp, we probably don't need to worry about it and this call in
					// RecalcLayout is probably superfluous, and in any case, RecalcLayout is usually
					// followed immediately by a call to RedrawEverything, which should update things
					// in the wx version.

	// restore the selection, if there was one
	RestoreSelection();

	// if free translation mode is turned on, get the current section
	// delimited and made visible - but only when not currently printing
	if (gpApp->m_bFreeTranslationMode && !gbIsPrinting)
	{
		if (!gbSuppressSetup)
		{
			SetupCurrentFreeTransSection(gpApp->m_nActiveSequNum);
		}
		else
		{
			// when suppressing, we need the active pile set
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
		}

		CMainFrame* pFrame;
		pFrame = gpApp->GetMainFrame();
		wxASSERT(pFrame);
		wxTextCtrl* pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		pEdit->SetFocus();
		if (!gpApp->m_pActivePile->m_pSrcPhrase->m_bHasFreeTrans)
		{
			pEdit->SetSelection(-1,-1); // -1, -1 selects it all
		}
		else
		{
			int len = pEdit->GetValue().Length(); 
			if (len > 0)
			{
				pEdit->SetSelection(len,len);
			}
		}
	}
/*
  #ifdef __WXDEBUG__
	wxLogTrace("\n");
	int count = pBundle->m_nStripCount;
	CStrip* pStrip;
	for (int i=0; i<count; i++)
	{
		pStrip = pBundle->m_pStrip[i];
		wxString str;
		str = str.Format("strip index = %d ; pileHeight = %d ; pileCount %d ; vertOffset = %d ; slop= %d, T= %d, B= %d, L= %d, R= %d\n",
			pStrip->m_nStripIndex, pStrip->m_nPileHeight, pStrip->m_nPileCount,
			pStrip->m_nVertOffset, pStrip->m_nFree, pStrip->m_rectStrip.GetTop(),
			pStrip->m_rectStrip.GetBottom(), pStrip->m_rectStrip.GetLeft(),
			pStrip->m_rectStrip.GetRight());
		wxLogTrace(str);
		wxLogTrace("\n");
		wxString strPile;
		CPile* pPile;
		int pileCount = pStrip->m_nPileCount;
		for (int j=0; j<pileCount; j++)
		{
			pPile = pStrip->m_pPile[j];
			strPile = strPile.Format("** PILE index= %d ; Rect: T= %d, B= %d, L= %d, R= %d, nHorzOffset = %d, width= %d, sequNum= %d\n",
				pPile->m_nPileIndex, pPile->m_rectPile.GetTop(),  pPile->m_rectPile.GetBottom(),
				pPile->m_rectPile.GetLeft(), pPile->m_rectPile.GetRight(), pPile->m_nHorzOffset,
				pPile->m_nWidth, pPile->m_pSrcPhrase->m_nSequNumber);
			wxLogTrace(strPile);
			CText* pText;
			wxString text1;
			wxString text2;
			pText = pPile->m_pCell[0]->m_pText;
			text1 = text1.Format("     CELL[0]'s CTEXT:  Rect: T= %d, B= %d, L= %d, R= %d\n",
				pText->m_enclosingRect.GetTop(), pText->m_enclosingRect.GetBottom(),
				pText->m_enclosingRect.GetLeft(), pText->m_enclosingRect.GetRight());
			wxLogTrace(text1);
			pText = pPile->m_pCell[1]->m_pText;
			text2 = text2.Format("     CELL[1]'s CTEXT:  Rect: T= %d, B= %d, L= %d, R= %d\n",
				pText->m_enclosingRect.GetTop(), pText->m_enclosingRect.GetBottom(),
				pText->m_enclosingRect.GetLeft(), pText->m_enclosingRect.GetRight());
			wxLogTrace(text2);
			wxLogTrace("\n");
		}
	}
  #endif
*/
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     the vertical offset (a new nVertOffset) of the strip that was created
/// \param      pDC                 -> the display context for strip creation
/// \param      pSrcList            -> the list of source phrases from which strips are composed
/// \param      nVertOffset         -> the starting vertical offset for the strip being created
/// \param      nPagePrintWidthLU   -> the page printing width in logical units
/// \param      nLastSequNumber     <- the sequence number (gets incremented by one and returned)
/// \param      nEndIndex           -> the sequence number upper limit
/// \remarks
/// Called from: the View's RecalcLayout_SimulateOnly().
/// CreateStrip_SimulateOnly() does the same calculations that the normal CreateStrip() does, but
/// RecalcLayout_SimulateOnly() does not modify any of the document's variables or indices. It only
/// simulates the creation of Strips for a document as a helper for RecalcLayout_SimulateOnly(). Both
/// simulations functions are used to provide the data the PaginateDoc needs to determine the range of
/// pages that could be printed in order to populate the Pages from: and Pages to: edit boxes in the
/// Print Options dialog.
////////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItView::CreateStrip_SimulateOnly(wxClientDC *pDC, SPList* pSrcList, int nVertOffset,
										int nPagePrintWidthLU, int &nLastSequNumber, int nEndIndex)
// whm Note: CreateStrip returns positive offsets even when printing, and in the wx version we always
// use wxMM_TEXT map mode.
// 
// BEW 12Jul05 - I don't think WYSIWYG printing of the free translation mode display is worth the
// bother - the user should get it with the interlinear export option instead, so I'll suppress
// free translation support in CreateStrip if gbIsPrinting is TRUE.
{
	wxASSERT(nLastSequNumber >= -1);
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	int nextNumber = nLastSequNumber;
	nextNumber++; // index of first CSourcePhrase element to be placed
	wxRect rectStrip;
	wxPoint topLeft;
	wxPoint botRight;

	if (gbRTL_Layout)
	{
		// Unicode version, and Right to Left layout is wanted

		// calculate the strip's rectangle
		// wx note: the wx version does not use negative offsets, but uses the same code in this
		// gbIsPrinting block as it does when gbIsPrinting is FALSE.
		topLeft = wxPoint(0, nVertOffset + pApp->m_curLeading);
        // for simulating the width of our rectStrip we use nPagePrintWidthLU rather than
        // pApp->m_docSize.GetWidth().
		botRight = wxPoint(nPagePrintWidthLU - pApp->m_curLMargin, topLeft.y + pApp->m_curPileHeight);
		rectStrip = wxRect(topLeft,botRight);

		// whm: Simulating Strip creation is only done when printing, so we can leave out the block
		// relating to m_bFreeTranslationMode (which isn't applicable anyway when printing)

		// calculate the piles which belong in this strip
		int pileIndex = 0;
		int horzOffset = 0; // from start of strip rectangle to right edge of last pile (followed
							// by gap) (or to left edge of last pile if laying out right to left)
							// for RTL layout horzOffset measures offset in pixels from the right
							// of the strip's rectangle
		wxRect rectPile;
		while (pileIndex < MAX_PILES && nextNumber <= nEndIndex)
		{
			SPList::Node* pos = pSrcList->Item(nextNumber); // POSITION of the CSourcePhrase for
															// this pile
			CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
			wxASSERT(pSrcPhrase != NULL);

			// cause source phrases with standard format markers to begin a new strip
			if (pApp->m_bMarkerWrapsStrip) // set by menu item on View menu, defaut is TRUE
			{
				if (!pSrcPhrase->m_markers.IsEmpty())
				{
					// this a potential candidate for starting a new strip, so check it out
					if (pSrcPhrase->m_nSequNumber > 0 && pileIndex > 0)
					{
						if (IsWrapMarker(pSrcPhrase))
							break;
					}
				}
			}

			// work out the pile's rectangle, this involves measuring text extents to get a max
			// width for all the phrases in the pile
			int pileWidth = CalcPileWidth(pDC,pApp,pSrcPhrase);

			// check there is room for this next pile & following gap - if not, break out of the
			// loop; but we must allow at least one pile, even if it is too long, otherwise we
			// will not advance through the list of source phrases, and just create empty strips
			// until we get a bounds error
			bool bNeedOne = FALSE;
			// wx note: we'll use rectStrip.GetWidth() instead of .right - left
			if (horzOffset + pApp->m_curGapWidth + pileWidth > rectStrip.GetWidth())
			{
				if (pileIndex == 0)
				{
					// we must have at least this one
					bNeedOne = TRUE;
					goto c;
				}
				else
				{
					break; // exit the loop, this strip is full
				}
			}

			// set the rectPile for this pile instance (uses logical coordinates)
c:			topLeft = wxPoint(rectStrip.GetRight() - horzOffset - pileWidth, rectStrip.GetTop());
			botRight = wxPoint(rectStrip.GetRight() - horzOffset, rectStrip.GetBottom());
			// wx note: creating the rectPile from the two points avoids height adjustments, but
			// CAUTION: if coordinates of the points are negative (as when printing/previewing), the result
			// may be a different spatial position for the wxRect than MFC has for its CRect created with the
			// same negative coordinates!!!
			rectPile = wxRect(topLeft,botRight);

			nLastSequNumber = nextNumber;
			nextNumber++; // for next source phrase & its pile
			horzOffset += pileWidth + pApp->m_curGapWidth; // for next pile

			// increment pile index for next time through the loop, & count this pile
			pileIndex++;
			if (bNeedOne)
				goto d;
		} // end of while (...) loop
d:		;
	}
	else
	{
		// NR or ANSI version, Left to Right layout is wanted

		// calculate the strip's rectangle
		// wx note: the wx version does not use negative offsets, but uses the same code in this
		// gbIsPrinting block as it does when gbIsPrinting is FALSE.
		topLeft = wxPoint(pApp->m_curLMargin, nVertOffset + pApp->m_curLeading);
        // for simulating the width of our rectStrip we use nPagePrintWidthLU rather than
        // pApp->m_docSize.GetWidth().
		botRight = wxPoint(nPagePrintWidthLU, topLeft.y + pApp->m_curPileHeight);
		rectStrip = wxRect(topLeft,botRight); // added for simulated calc

		// whm: Simulating Strip creation is only done when printing, so we can leave out the block
		// relating to m_bFreeTranslationMode (which isn't applicable anyway when printing)

		// calculate the piles which belong in this strip
		int pileIndex = 0;
		int horzOffset = 0; // from start of strip rectangle to right edge of last pile
							// (followed by gap)
		wxRect rectPile;
		while (pileIndex < MAX_PILES && nextNumber <= nEndIndex)
		{
			SPList::Node* pos = pSrcList->Item(nextNumber); // POSITION of the CSourcePhrase
														    // for this pile
			CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
			wxASSERT(pSrcPhrase != NULL);

			// cause source phrases with certain standard format markers to begin a new strip
			if (pApp->m_bMarkerWrapsStrip) // set by menu item on View menu, default is TRUE
			{
				if (!pSrcPhrase->m_markers.IsEmpty())
				{
					// this a potential candidate for starting a new strip, so check it out
					if (pSrcPhrase->m_nSequNumber > 0 && pileIndex > 0)
					{
						if (IsWrapMarker(pSrcPhrase))
							break; // if we need to wrap, discontinue pile creation in this strip
					}
				}
			}

			// work out the pile's rectangle, this involves measuring text extents to get a max
			// width for all the phrases in the pile
			int pileWidth = CalcPileWidth(pDC,pApp,pSrcPhrase);

			// check there is room for this next pile & following gap - if not, break out of the
			// loop; but we must allow at least one pile, even if it is too long, otherwise we
			// will not advance through the list of source phrases, and just create empty strips
			// until we get a bounds error
			bool bNeedOne = FALSE;
			// wx note: we'll use rectStrip.GetWidth() instead of .right - left
			if (horzOffset + pApp->m_curGapWidth + pileWidth > rectStrip.GetWidth())
			{
				if (pileIndex == 0)
				{
					// we must have at least this one
					bNeedOne = TRUE;
					goto a;
				}
				else
				{
					break; // exit the loop, this strip is full
				}
			}

			// set the rectPile for this pile instance (uses logical coordinates)
a:			topLeft = wxPoint(rectStrip.GetLeft() + horzOffset, rectStrip.GetTop());
			botRight = wxPoint(rectStrip.GetLeft() + horzOffset + pileWidth, rectStrip.GetBottom());
			rectPile = wxRect(topLeft,botRight);

			// whm: For simulation we don't create any piles
			// increment sequNum, etc.
			nLastSequNumber = nextNumber;
			nextNumber++; // for next source phrase & its pile
			horzOffset += pileWidth + pApp->m_curGapWidth; // for next pile

			// increment pile index for next time through the loop, & count this pile
			pileIndex++;
			if (bNeedOne)
				goto b;
		} // end of while (...) loop
b:		;
	}

	// update variables ready for next one
	// whm: for wx version we don't use negative offsets during printing
	nVertOffset += pApp->m_curPileHeight + pApp->m_curLeading; // offset for bottom of this strip
	return nVertOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     the vertical offset (a new nVertOffset) of the strip that was created
/// \param      pDC                 -> the display context for strip creation
/// \param      pSrcList            -> the list of source phrases from which strips are composed
/// \param      nVertOffset         -> the starting vertical offset for the strip being created
/// \param      nLastSequNumber     <- the sequence number (gets incremented by one and returned)
/// \param      nEndIndex           -> the sequence number upper limit
/// \remarks
/// Called from: the View's RecalcLayout() and LayoutStrip().
/// CreateStrip() calculates and creates a new strip for display within the main window, or on a
/// printer or print preview display context. It uses the layout parameters and indices that were
/// established by a previous call of RecalcLayout(). CreateStrip also calls CreatePile() for each 
/// pile that will fit within the strip. See CreateStrip_SimulateOnly() for a related function 
/// which only simulates the calculations made by CreateStrip().
////////////////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItView::CreateStrip(wxClientDC *pDC, SPList* pSrcList, int nVertOffset,
								int &nLastSequNumber, int nEndIndex)
// MFC Note: returns the nVertOffset value for the strip, if it creates it, or -1 if it doesn't get created
// nVertOffset will be +ve for MM_Text mapping mode, and -ve for other modes, such as MM_LOENGLISH
// the global flag gbIsPrinting selects which will be the case, TRUE for a y axis increasing
// upwards pDC will be set to MM_LOENGLISH if the gbIsPrinting flag is true, else it will be
// MM_TEXT.
// 
// whm Note: CreateStrip returns positive offsets even when printing, and in the wx version we always
// use wxMM_TEXT map mode.
// 
// BEW 12Jul05 - I don't think WYSIWYG printing of the free translation mode display is worth the
// bother - the user should get it with the interlinear export option instead, so I'll suppress
// free translation support in CreateStrip if gbIsPrinting is TRUE.
{
	wxASSERT(nLastSequNumber >= -1);
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	int nextNumber = nLastSequNumber;
	nextNumber++; // index of first CSourcePhrase element to be placed
	wxRect rectStrip;
	wxPoint topLeft;
	wxPoint botRight;

	CSourceBundle* pBundle = pApp->m_pBundle;
	int stripIndex = pBundle->m_nStripIndex; // index of current strip
	pBundle->m_pStrip[stripIndex] = new CStrip(pDoc,pBundle);
	wxASSERT(pBundle->m_pStrip[stripIndex] != NULL);
	CStrip* pStrip = pBundle->m_pStrip[stripIndex]; // get a convenient local pointer to it

	if (gbRTL_Layout)
	{
		// Unicode version, and Right to Left layout is wanted

		// calculate the strip's rectangle
		// wx note: the wx version does not use negative offsets, but uses the same code whether
		// gbIsPrinting is TRUE or FALSE. Also when creating a wxRect from two points, the constructor
		// normalizes the wxRect.
		topLeft = wxPoint(0, nVertOffset + pApp->m_curLeading);
		botRight = wxPoint(pApp->m_docSize.GetWidth() - pApp->m_curLMargin,
											topLeft.y + pApp->m_curPileHeight);
		pStrip->m_rectStrip = wxRect(topLeft,botRight);

		// BEW added next block 24Jun05 for free translation support - if the first flag is TRUE, and
		// we are not currently printing, then compute the m_rectFreeTrans rectangle for this strip in
		// which any free translation or part thereof can be written out
		if (gpApp->m_bFreeTranslationMode && !gbIsPrinting)
		{
			pStrip->m_rectFreeTrans = pStrip->m_rectStrip; // copy strip rect, only top is wrong
			pStrip->m_rectFreeTrans.x -= RH_SLOP/5; // there was RH_SLOP/4 (10 pixels) left margin, 
													// so use some (8 pixels) of it
			// wx note: in the line above we're decreasing the left coord of an existing rect resulting in 
			// an increase in the width of the rectangle (in MFC's CRect), so in wx we need to INCREASE 
			// the width of m_rectFreeTrans by the same amount, to achieve the same results as in the 
			// MFC version with the addition of the following line:
			pStrip->m_rectFreeTrans.width += RH_SLOP/5; // whm added for wx
			if (gbIsPrinting)
			{
				// adjust the top member (this block never used, unless we later decide to support
				// printing the free translation mode display)
				pStrip->m_rectFreeTrans.y = pStrip->m_rectStrip.GetBottom() + pApp->m_nTgtHeight;
				// wx note: In the MFC version this block can never be entered when !gbIsPrinting
				// TODO: if printing the free translation mode display is implemented
				// the m_rectFreeTrans height would need adjusting (see non-printing block below)
			}
			else
			{
				// make the top be a tgt text line height above the strip bottom - this also leaves
				// an extra 3 pixels of space below last pile, the 3 pixels was added in SetPileHeight()
				pStrip->m_rectFreeTrans.y = pStrip->m_rectStrip.GetBottom() - pApp->m_nTgtHeight;
				// wx notes:
				// 1. GetBottom() actually returns one pixel less than MFC's .bottom value, but it 
				// shouldn't matter that much.
				// 2. The effect of setting the y coord changes both the position of the rect
				// and its height in the MFC version. In the WX version it only changes the original
				// rect's position. To do the equivalent changes in the wx version, we need to also
				// adjust the height of the free trans rect to be one target line height by adding
				// the following line in the wx version:
				pStrip->m_rectFreeTrans.SetHeight(pApp->m_nTgtHeight);
				// Observation: the actual height of the m_rectFreeTrans rect is also significant for 
				// drawing free translation, because in DrawFreeTranslations, the wx version calls 
				// pDC->Clear() on a clipped rectangle (pElement->subRect) which is based on the 
				// m_rectFreeTransatext rectangular area. If m_rectFreeTrans is not the correct height
				// the clipping region will cause the top part of the next strip to be wrongly clipped.
			}
		}

		rectStrip = pStrip->m_rectStrip; // get a convenient local copy
		pStrip->m_nPileHeight = pApp->m_curPileHeight;	// store pile height (I don't think I'll need
														// to use this)

		// create the piles which belong in this strip
		int pileIndex = 0;
		int horzOffset = 0; // from start of strip rectangle to right edge of last pile (followed
							// by gap) (or to left edge of last pile if laying out right to left)
							// for RTL layout horzOffset measures offset in pixels from the right
							// of the strip's rectangle
		pStrip->m_nPileCount = 0; // initialize
		wxRect rectPile;
		while (pileIndex < MAX_PILES && nextNumber <= nEndIndex)
		{
			SPList::Node* pos = pSrcList->Item(nextNumber); // POSITION of the CSourcePhrase for
															// this pile
			CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
			wxASSERT(pSrcPhrase != NULL);

			// cause source phrases with standard format markers to begin a new strip
			if (pApp->m_bMarkerWrapsStrip) // set by menu item on View menu, defaut is TRUE
			{
				if (!pSrcPhrase->m_markers.IsEmpty())
				{
					// this a potential candidate for starting a new strip, so check it out
					if (pSrcPhrase->m_nSequNumber > 0 && pileIndex > 0)
					{
						if (IsWrapMarker(pSrcPhrase))
							break;
					}
				}
			}

			// work out the pile's rectangle, this involves measuring text extents to get a max
			// width for all the phrases in the pile
			int pileWidth = CalcPileWidth(pDC,pApp,pSrcPhrase);

			// check there is room for this next pile & following gap - if not, break out of the
			// loop; but we must allow at least one pile, even if it is too long, otherwise we
			// will not advance through the list of source phrases, and just create empty strips
			// until we get a bounds error
			bool bNeedOne = FALSE;
			// wx note: we'll use rectStrip.GetWidth() instead of .right - left
			if (horzOffset + pApp->m_curGapWidth + pileWidth > rectStrip.GetWidth())
			{
				if (pileIndex == 0)
				{
					// we must have at least this one
					bNeedOne = TRUE;
					goto c;
				}
				else
				{
					break; // exit the loop, this strip is full
				}
			}

			// set the rectPile for this pile instance (uses logical coordinates)
c:			topLeft = wxPoint(rectStrip.GetRight() - horzOffset - pileWidth, rectStrip.GetTop());
			botRight = wxPoint(rectStrip.GetRight() - horzOffset, rectStrip.GetBottom());
			// wx note: creating the rectPile from the two points avoids height adjustments, but
			// CAUTION: if coordinates of the points are negative (as when printing/previewing), the result
			// may be a different spatial position for the wxRect than MFC has for its CRect created with the
			// same negative coordinates!!!
			rectPile = wxRect(topLeft,botRight);

			// call a CreatePile function, passing it the rectangle, etc, and return the CPile
			// pointer for storage in the pile array
			pStrip->m_pPile[pileIndex] = CreatePile(pDC,pApp,pDoc,pBundle,pStrip,pSrcPhrase,
																					&rectPile);
			pStrip->m_pPile[pileIndex]->m_nPileIndex = pileIndex; // so the pile will know which
																  // it is
			pStrip->m_pPile[pileIndex]->m_nHorzOffset = horzOffset; // so it will know where to
																	// lay itself out again if
																	// user turns it into a phrase
			// increment sequNum, etc.
			nLastSequNumber = nextNumber;
			nextNumber++; // for next source phrase & its pile
			horzOffset += pileWidth + pApp->m_curGapWidth; // for next pile

			// increment pile index for next time through the loop, & count this pile
			pileIndex++;
			pStrip->m_nPileCount++;
			if (bNeedOne)
				goto d;
		} // end of while (...) loop
		// wx note: GetRight() below returns one pixel less that .right value in MFC, so we'll
		// simply substitute rectStrip.GetWidth()
		// matter here.
d:		pStrip->m_nFree = rectStrip.GetWidth() - horzOffset;	// slop remaining at
																// right (or left for RTL)
	}
	else
	{
		// NR or ANSI version, Left to Right layout is wanted

		// calculate the strip's rectangle
		// MFC note says, "(this block never used, unless we later decide to support
		// printing the free translation mode display)", but it is entered when printing.
		// wx note: the wx version does not use negative offsets, but uses the same code whether
		// gbIsPrinting is TRUE or FALSE. Also when creating a wxRect from two points, the constructor
		// normalizes the wxRect.
		topLeft = wxPoint(pApp->m_curLMargin, nVertOffset + pApp->m_curLeading);
		botRight = wxPoint(pApp->m_docSize.GetWidth(), topLeft.y + pApp->m_curPileHeight);
		pStrip->m_rectStrip = wxRect(topLeft,botRight);
		
		rectStrip = pStrip->m_rectStrip; // get a convenient local copy
		pStrip->m_nPileHeight = pApp->m_curPileHeight;	// store pile height (I don't think I'll need to
														// use this)

		// BEW added next block 24Jun05 for free translation support - if the flag is TRUE, then
		// compute the m_rectFreeTrans rectangle for this strip in which any free translation
		// or part thereof can be written out
		if (gpApp->m_bFreeTranslationMode && !gbIsPrinting)
		{
			pStrip->m_rectFreeTrans = pStrip->m_rectStrip; // copy strip rect, only top is wrong
			//pStrip->m_rectFreeTrans.right += RH_SLOP/2; // there was RH_SLOP right margin, so use half of it
			// wx note: in the commented out MFC line above we're increasing the right bound of the
			// rectangle resulting in an increase in the width, so in wx we just need to INCREASE the width.
			// In either case the upper left point remains fixed
			pStrip->m_rectFreeTrans.width += RH_SLOP/2; // whm added for wx
			if (gbIsPrinting)
			{
				// adjust the top member (this block never used, unless we later decide to support
				// printing the free translation mode display
				pStrip->m_rectFreeTrans.y = pStrip->m_rectStrip.GetBottom() + pApp->m_nTgtHeight;
				// wx note: In the MFC version this block can never be entered when !gbIsPrinting
				// TODO: if printing the free translation mode display is implemented
				// the m_rectFreeTrans height would need adjusting (see non-printing block below)
			}
			else
			{
				// make the top be a tgt text line height above the strip bottom - this also leaves
				// an extra 3 pixels of space below last pile, the 3 pixels was added in SetPileHeight()
				pStrip->m_rectFreeTrans.y = pStrip->m_rectStrip.GetBottom() - pApp->m_nTgtHeight;
				// wx notes:
				// 1. GetBottom() actually returns one pixel less than MFC's .bottom value, but it 
				// shouldn't matter that much.
				// 2. The effect of setting the y coord changes both the position of the rect
				// and its height in the MFC version. In the WX version it only changes the original
				// rect's position. To do the equivalent changes in the wx version, we need to also
				// adjust the height of the free trans rect to be one target line height by adding
				// the following line in the wx version:
				pStrip->m_rectFreeTrans.SetHeight(pApp->m_nTgtHeight);
				// Observation: the actual height of the m_rectFreeTrans rect is also significant for 
				// drawing free translation, because in DrawFreeTranslations, the wx version calls 
				// pDC->Clear() on a clipped rectangle (pElement->subRect) which is based on the 
				// m_rectFreeTransatext rectangular area. If m_rectFreeTrans is not the correct height
				// the clipping region will cause the top part of the next strip to be wrongly clipped.
			}
		}

		// create the piles which belong in this strip
		int pileIndex = 0;
		int horzOffset = 0; // from start of strip rectangle to right edge of last pile
							// (followed by gap)
		pStrip->m_nPileCount = 0; // initialize
		wxRect rectPile;
		while (pileIndex < MAX_PILES && nextNumber <= nEndIndex)
		{
			/*
			#ifdef __WXDEBUG__
			wxLogTrace(" ### while loop nextNumber value = %d   nEndIndex = %d    ",nextNumber,
																					nEndIndex);
			#endif
			*/
			SPList::Node* pos = pSrcList->Item(nextNumber); // POSITION of the CSourcePhrase
														    // for this pile
			CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
			wxASSERT(pSrcPhrase != NULL);

			// cause source phrases with certain standard format markers to begin a new strip
			if (pApp->m_bMarkerWrapsStrip) // set by menu item on View menu, default is TRUE
			{
				if (!pSrcPhrase->m_markers.IsEmpty())
				{
					// this a potential candidate for starting a new strip, so check it out
					if (pSrcPhrase->m_nSequNumber > 0 && pileIndex > 0)
					{
						if (IsWrapMarker(pSrcPhrase))
							break; // if we need to wrap, discontinue pile creation in this strip
					}
				}
			}

			// work out the pile's rectangle, this involves measuring text extents to get a max
			// width for all the phrases in the pile
			int pileWidth = CalcPileWidth(pDC,pApp,pSrcPhrase);

			// check there is room for this next pile & following gap - if not, break out of the
			// loop; but we must allow at least one pile, even if it is too long, otherwise we
			// will not advance through the list of source phrases, and just create empty strips
			// until we get a bounds error
			bool bNeedOne = FALSE;
			//if (horzOffset + m_curGapWidth + pileWidth > rectStrip.right - rectStrip.left)
			// wx note: horzOffset will be one pixel less width in wx version than in MFC if
			// do right - left calc, should be same if simply use GetWidth()
			if (horzOffset + pApp->m_curGapWidth + pileWidth > rectStrip.GetWidth())
			{
				if (pileIndex == 0)
				{
					// we must have at least this one
					bNeedOne = TRUE;
					goto a;
				}
				else
				{
					break; // exit the loop, this strip is full
				}
			}

			// set the rectPile for this pile instance (uses logical coordinates)
a:			topLeft = wxPoint(rectStrip.GetLeft() + horzOffset, rectStrip.GetTop());
			botRight = wxPoint(rectStrip.GetLeft() + horzOffset + pileWidth, rectStrip.GetBottom());
			rectPile = wxRect(topLeft,botRight);

			// call a CreatePile function, passing it the rectangle, etc, and return the CPile
			// pointer for storage in the pile array
			pStrip->m_pPile[pileIndex] = CreatePile(pDC,pApp,pDoc,pBundle,pStrip,pSrcPhrase,
																					&rectPile);
			pStrip->m_pPile[pileIndex]->m_nPileIndex = pileIndex; // so the pile will know which
																  // it is
			pStrip->m_pPile[pileIndex]->m_nHorzOffset = horzOffset; // so it will know where to
																	// lay itself out again if
																	// user turns it into a phrase
			// increment sequNum, etc.
			nLastSequNumber = nextNumber;
			nextNumber++; // for next source phrase & its pile
			horzOffset += pileWidth + pApp->m_curGapWidth; // for next pile

			// increment pile index for next time through the loop, & count this pile
			pileIndex++;
			pStrip->m_nPileCount++;
			if (bNeedOne)
				goto b;
		} // end of while (...) loop
b:		pStrip->m_nFree = rectStrip.GetRight() - rectStrip.GetLeft() - horzOffset; // slop remaining at right
	}

	// update variables ready for next one
	// whm: for wx version we don't use negative offsets during printing
	nVertOffset += pApp->m_curPileHeight + pApp->m_curLeading; // offset for bottom of this strip
	return nVertOffset;
}

// Modified by whm 14Feb05 to support USFM and SFM Filtering.
bool CAdapt_ItView::IsWrapMarker(CSourcePhrase* pSrcPhrase)
{
	// Version 3 implementation: We first extract each marker from
	// the pSrcPhrase->m_markers member, and use Find to check if it is
	// in the appropriate wrap string UsfmWrapMarkersStr, PngWrapMarkersStr,
	// or UsfmAndPngWrapMarkersStr, depending on which map set is active.

	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markerStr = pSrcPhrase->m_markers;
	wxString nonFilteredMkrs = pDoc->GetUnFilteredMarkers(markerStr);
	// NormalizeToSpaces leaves the markers in m_markers delimited by spaces, at
	// lease medially. We'll use the Tokenize CString method here.
	//int curPos = 0; // unused
	wxString sfm;
	bool bValue = FALSE;

	wxStringTokenizer tkz(markerStr,_T(" "));

	while (tkz.HasMoreTokens())
	{
		sfm = tkz.GetNextToken();
		if (sfm[0] == gSFescapechar)	// Only check actual sfms. Some tokens will be only
										// numbers (those after \c and \v) which we ignore
		{
			// there shouldn't be any end marking asterisk * on a wrap marker, but
			// remove any that might exist for a clean search below.
			int endMkrPos = sfm.Find(_T('*'),TRUE); // TRUE finds from right end
			if (endMkrPos != -1)
				sfm = sfm.Left(endMkrPos);
			sfm.Trim(FALSE); // trim left end
			sfm.Trim(TRUE); // trim right end
			sfm += _T(' '); // insure the sfm is followed by a space for unique find in
							// our wrap strings.
			// If only one of the sfms within m_markers is a wrap marker, we should return TRUE.
			switch (gpApp->gCurrentSfmSet)
			{
				case UsfmOnly:
				{
					if (gpApp->UsfmWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // it's in the wrap markers list, so start a new strip
					break;
				}
				case PngOnly:
				{
					if (gpApp->PngWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // it's in the wrap markers list, so start a new strip
					break;
				}
				case UsfmAndPng:
				{
					if (gpApp->UsfmAndPngWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // it's in the wrap markers list, so start a new strip
					break;
				}
				default:
				{
					// if we got here it would be a program error
					if (gpApp->UsfmWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // found the sfm, so start a new strip
				}
			}
		}
	}

	// any other marker, we will just let it be ignored & go on setting up piles
	return bValue;
}

CPile* CAdapt_ItView::CreatePile(wxClientDC *pDC, CAdapt_ItApp *pApp, CAdapt_ItDoc *pDoc,
			CSourceBundle *pBundle, CStrip *pStrip, CSourcePhrase *pSrcPhrase, wxRect *pRectPile)
{
	// create the pile on the heap, initializing its cells to MAX_CELLS nulls
	CPile* pPile = new CPile(pDoc,pBundle,pStrip,pSrcPhrase);
	wxASSERT(pPile != NULL);

	// now set the attributes not already set by the constructor's defaults
	pPile->m_rectPile = *pRectPile;
	pPile->m_nWidth = pRectPile->GetRight() - pRectPile->GetLeft();

	// the m_nMinWidth value needs to be set to the initial text-extent-based size of the editBox,
	// so that if user removes text from the box it will contract back to this minimum size; the
	// needed value will have been placed in the app's m_nCurPileMinWidth attr by the preceding
	// GetPileWidth() call in the loop within the CreateStrip() function.
	pPile->m_nMinWidth = pApp->m_nCurPileMinWidth;

	// now we have to create the cells which this particular pile owns; this will depend on
	// MAX_CELLS ( == 5 in version 2.0 and onwards), whether or not glossing is allowed, & the user's
	// choice whether or not to suppress display of either 1st or last row (if 4 rows available);
	// and whether or not to show or hide punctuation in lines 2 & 3 (see m_bHidePunctuation flag),
	// and whether or not only the target line is to be shown. When glossing is allowed, the order
	// of the cells from top to bottom will be: if adapting, src, src, tgt, tgt, gloss; if glossing
	// src, src, gloss, tgt, tgt.
	wxPoint  topLeft;
	wxPoint  botRight;
	wxFont*  pSrcFont = pApp->m_pSourceFont;
	wxFont*  pTgtFont = pApp->m_pTargetFont;
	wxFont*  pNavTextFont = pApp->m_pNavTextFont;
	wxSize   extent;
	wxColour color; // MFC had COLORREF color;

	int cellIndex = -1;
	cellIndex++; // set cellIndex to zero

	// set the required color for the text, but if target only, it has only target's color
	// (which can be navText's color if we are glossing - we'll set the target text's color
	// further down in the block.)
	if (!gbShowTargetOnly)
	{
		if (pSrcPhrase->m_bSpecialText)
			color = pApp->m_specialTextColor;
		else
			color = pApp->m_sourceColor;
		if (pSrcPhrase->m_bRetranslation)
			color = pApp->m_reTranslnTextColor;
	}

	// first two src lines are same whether glossing is enabled or not
	if (pApp->m_bSuppressFirst)
	{
		// the first source line is to be suppressed
		cellIndex++; // == 1, so this will be cell[1] not cell[0]

		// suppress the cell if we want to only show target text line; otherwise
		// for gbShowTargetOnly == FALSE we want to show the source line too
		if (!gbShowTargetOnly)
		{
			// calculate the cell's topLeft and botRight points (CText calculates the CRect)
			topLeft = wxPoint(pRectPile->GetLeft(),pRectPile->GetTop());
			botRight = wxPoint(pRectPile->GetRight(), pRectPile->GetBottom());
			// whm: the wx version doesn't use negative offsets
			botRight.y = pRectPile->GetTop() + pApp->m_nSrcHeight;

			// calculate the extent of the text
			int keyWidth;
			int keyDummyHeight;
			pDC->SetFont(*pSrcFont);
			if (pApp->m_bHidePunctuation)
			{
				pDC->GetTextExtent(pSrcPhrase->m_key, &keyWidth, &keyDummyHeight);

				// create the CCell and set its attributes
				pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
						pSrcPhrase->m_key,keyWidth,pSrcFont,&color,&topLeft,&botRight,
						cellIndex);
			}
			else
			{
				pDC->GetTextExtent(pSrcPhrase->m_srcPhrase, &keyWidth, &keyDummyHeight);

				// create the CCell and set its attributes
				pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
						pSrcPhrase->m_srcPhrase,keyWidth,pSrcFont,&color,&topLeft,
						&botRight,cellIndex);
			}
		}
	}
	else // two src lines are to be visible
	{
		// this is cell[0]

		if (!gbShowTargetOnly) // don't suppress the cell if we want to show src text line
		{
			// calculate the cell's topLeft and botRight points (CText calculates the CRect)
			topLeft = wxPoint(pRectPile->GetLeft(), pRectPile->GetTop());
			botRight = wxPoint(pRectPile->GetRight(), pRectPile->GetBottom());
			// whm: the wx version doesn't use negative offsets
			botRight.y = pRectPile->GetTop() + pApp->m_nSrcHeight;

			// calculate the extent of the text
			int spWidth;
			int spDummyHeight;
			pDC->SetFont(*pSrcFont);
			pDC->GetTextExtent(pSrcPhrase->m_srcPhrase, &spWidth, &spDummyHeight);

			pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
											pSrcPhrase->m_srcPhrase,spWidth,pSrcFont,
											&color,&topLeft,&botRight,cellIndex);

			// now the second cell, cell[1]
			cellIndex++;

			// whm: the wx version doesn't use negative offsets
			topLeft.y = topLeft.y+pApp->m_nSrcHeight;
			botRight.y = botRight.y+pApp->m_nSrcHeight;

			// calculate the extent of the text
			int keyWidth;
			int keyDummyHeight;
			pDC->GetTextExtent(pSrcPhrase->m_key, &keyWidth, &keyDummyHeight);

			pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
											pSrcPhrase->m_key,keyWidth,pSrcFont,&color,
											&topLeft,&botRight,cellIndex);
		}
		else
		{
			cellIndex++; // suppress of both wanted, so just ready the index for next increment
		}
	} // end of blocks for one or two source text rows

	if (gbIsGlossing)
	{
		// we are glossing and gbEnableGlossing is TRUE, so glosses will be visible
		// as the 2nd line of the strip (or third if both src lines are visible,) so set up
		// the cell with cellIndex == 2 (and note, if the flag gbShowTargetOnly is TRUE, this
		// would be the only line in the strip which is visible)
		if (gbEnableGlossing)
		{
			// set the gloss text color, and if using navText's font for the glossing
			// then set up the device context to use it; else use target font
			color = pApp->m_navTextColor; // glossing uses navText color always
			if (gbGlossingUsesNavFont)
			{
				pDC->SetFont(*pNavTextFont);
			}
			else
			{
				pDC->SetFont(*pTgtFont);
			}

			// a gloss line is wanted, so construct its cell
			cellIndex++; // cellIndex == 2

			// calculate the cell's topLeft and botRight points
			if (!gbShowTargetOnly) // this flag refers to glosses when gbIsGlossing is TRUE
			{
				if (gbGlossingUsesNavFont)
				{
					// give 3 pixel extra offset, for glossing line only
					// whm: the wx version doesn't use negative offsets
					topLeft.y = topLeft.y+pApp->m_nSrcHeight + 3;
					botRight.y = botRight.y+pApp->m_nNavTextHeight + 3;
				}
				else
				{
					// whm: the wx version doesn't use negative offsets
					topLeft.y = topLeft.y+pApp->m_nSrcHeight + 3;
					botRight.y = botRight.y+pApp->m_nTgtHeight + 3;
				}
			}
			else // we are showing only the glossing text (ie. no source and no target lines)
			{
				// calculate the cell's topLeft and botRight points (CText calculates the CRect),
				// as it is the only cell in the pile, for this mode
				topLeft = wxPoint(pRectPile->GetLeft(), pRectPile->GetTop());
				botRight = wxPoint(pRectPile->GetRight(), pRectPile->GetBottom());
				if (gbGlossingUsesNavFont)
				{
					// whm: the wx version doesn't use negative offsets
					botRight.y = pRectPile->GetTop() + pApp->m_nNavTextHeight;
				}
				else
				{
					// whm: the wx version doesn't use negative offsets
					botRight.y = pRectPile->GetTop() + pApp->m_nTgtHeight;
				}
			}

			// calculate the extent of the text -- but if there is no text, then make
			// the extent equal to the pileWidth (use m_adaption, so will be correct
			// for retranslations, etc)
			int glossWidth;
			int glossDummyHeight;
			if (pSrcPhrase->m_gloss.IsEmpty())
			{
				// no translation or retranslation, etc, so use pileWidth for extent
				glossWidth = pPile->m_nWidth;
			}
			else
			{
				// get the extent of the text
				pDC->GetTextExtent(pSrcPhrase->m_gloss, &glossWidth, &glossDummyHeight);
			}

			// create the cell and set its attributes; which font gets used will
			// depend on the gbGlossingUsesNavFont flag
			if (gbGlossingUsesNavFont)
				pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
					pSrcPhrase->m_gloss,glossWidth,pNavTextFont,&color,&topLeft,
					&botRight,cellIndex);
			else
				pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
					pSrcPhrase->m_gloss,glossWidth,pTgtFont,&color,&topLeft,
					&botRight,cellIndex);
		}

		if (!gbShowTargetOnly)
		{
			// continue to 4th visible line (or 3nd visible line if m_bSuppressFirst is TRUE),
			// this is cell[3] and is the first of the lines which may have target text
			cellIndex++; // set cellIndex to 3

			// set the target language's text color
			color = pApp->m_targetColor;

			// calculate the cell's topLeft and botRight points
			if (gbGlossingUsesNavFont)
			{
				// whm: the wx version doesn't use negative offsets
				topLeft.y = topLeft.y+pApp->m_nNavTextHeight;
				botRight.y = botRight.y+pApp->m_nTgtHeight;
			}
			else
			{
				// whm: the wx version doesn't use negative offsets
				topLeft.y = topLeft.y+pApp->m_nTgtHeight;
				botRight.y = botRight.y+pApp->m_nTgtHeight;
			}

			// calculate the extent of the text -- but if there is no text, then make the extent
			// equal to the pileWidth (use m_adaption, so will be correct for retranslations, etc)
			// (if this cell is at the active location, displaying it will be suppressed externally)
			pDC->SetFont(*pTgtFont);
			if (!pApp->m_bHidePunctuation && pApp->m_bSuppressLast)
			{
				int tgtWidth;
				int tgtDummyHeight;
				if (pSrcPhrase->m_targetStr.IsEmpty())
				{
					// no translation or retranslation, etc, so use pileWidth for extent
					tgtWidth = pPile->m_nWidth; 
				}
				else
				{
					// get the extent of the text
					pDC->GetTextExtent(pSrcPhrase->m_targetStr, &tgtWidth, &tgtDummyHeight);
				}

				// create the cell and set its attributes
				pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
						pSrcPhrase->m_targetStr,tgtWidth,pTgtFont,&color,&topLeft,&botRight,
						cellIndex);
			}
			else // either hiding punctuation or not suppressing the last target line
				// (cellIndex == 3)still
			{
				int aWidth;
				int aDummyHeight;
				if (pSrcPhrase->m_adaption.IsEmpty())
				{
					// no translation or retranslation, etc, so use pileWidth for extent
					aWidth = pPile->m_nWidth; // don't care about extent.cy
				}
				else
				{
					// get the extent of the text
					pDC->GetTextExtent(pSrcPhrase->m_adaption, &aWidth, &aDummyHeight);
				}

				// create the cell and set its attributes
				pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
						pSrcPhrase->m_adaption,aWidth,pTgtFont,&color,&topLeft,&botRight,
						cellIndex);
			}

			// now the 5th line, provided it is not suppressed (it's a punctuated target
			// text line, if visible)
			if (!pApp->m_bSuppressLast)
			{
				// a fifth line is wanted, construct its cell
				cellIndex++; // cellIndex == 4

				// calculate the cell's topLeft and botRight points
				// whm: the wx version doesn't use negative offsets
				topLeft.y = topLeft.y+pApp->m_nTgtHeight; 
				botRight.y = botRight.y+pApp->m_nTgtHeight;

				// calculate the extent of the text -- but if there is no text, then make
				// the extent equal to the pileWidth (use m_adaption, so will be correct
				// for retranslations, etc)
				int tgtWidth;
				int tgtDummyHeight;
				if (pSrcPhrase->m_targetStr.IsEmpty())
				{
					// no translation or retranslation, etc, so use pileWidth for extent
					//extent.cx = pPile->m_nWidth; // don't care about extent.cy
					tgtWidth = pPile->m_nWidth; // don't care about extent.cy
				}
				else
				{
					// get the extent of the text
					pDC->GetTextExtent(pSrcPhrase->m_targetStr, &tgtWidth, &tgtDummyHeight);
				}

				// create the cell and set its attributes
				pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
						pSrcPhrase->m_targetStr,tgtWidth,pTgtFont,&color,&topLeft,
						&botRight,cellIndex);
			}
		}
	}
	else // the user is adapting (rather than glossing)
	{
		// continue to 3rd visible line (or 2nd visible line if m_bSuppressFirst is TRUE),
		// this is cell[2], and it will contain target text
		cellIndex++; // set cellIndex to 2

		// set the target language's text color
		color = pApp->m_targetColor;

		if (!gbShowTargetOnly)
		{
			// calculate the cell's topLeft and botRight points
			// whm: the wx version doesn't use negative offsets
			topLeft.y = topLeft.y+pApp->m_nSrcHeight;
			botRight.y = botRight.y+pApp->m_nTgtHeight;
		}
		else // we are showing only the target text
		{
			// calculate the cell's topLeft and botRight points (CText calculates the CRect),
			// as it is the only cell in the pile, for this mode
			topLeft = wxPoint(pRectPile->GetLeft(), pRectPile->GetTop());
			botRight = wxPoint(pRectPile->GetRight(), pRectPile->GetBottom());
			// whm: the wx version doesn't use negative offsets
			botRight.y = pRectPile->GetTop() + pApp->m_nTgtHeight;
		}

		// calculate the extent of the text -- but if there is no text, then make the extent
		// equal to the pileWidth (use m_adaption, so will be correct for retranslations, etc)
		// (if this cell is at the active location, displaying it will be suppressed externally)
		pDC->SetFont(*pTgtFont);
		if (!pApp->m_bHidePunctuation && pApp->m_bSuppressLast)
		{
			int tgtWidth;
			int tgtDummyHeight;
			if (pSrcPhrase->m_targetStr.IsEmpty())
			{
				// no translation or retranslation, etc, so use pileWidth for extent
				tgtWidth = pPile->m_nWidth; // don't care about extent.cy
			}
			else
			{
				// get the extent of the text
				pDC->GetTextExtent(pSrcPhrase->m_targetStr, &tgtWidth, &tgtDummyHeight);
			}

			// create the cell and set its attributes
			pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
					pSrcPhrase->m_targetStr,tgtWidth,pTgtFont,&color,&topLeft,&botRight,
					cellIndex);
		}
		else // either hiding punctuation or not suppressing the last target line
		{
			int aWidth;
			int aDummyHeight;
			if (pSrcPhrase->m_adaption.IsEmpty())
			{
				// no translation or retranslation, etc, so use pileWidth for extent
				aWidth = pPile->m_nWidth; // don't care about extent.cy
			}
			else
			{
				// get the extent of the text
				pDC->GetTextExtent(pSrcPhrase->m_adaption, &aWidth, &aDummyHeight);
			}

			// create the cell and set its attributes
			pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
					pSrcPhrase->m_adaption,aWidth,pTgtFont,&color,&topLeft,&botRight,
					cellIndex);
		}

		// now the 4th line, provided it is not suppressed
		if (!pApp->m_bSuppressLast)
		{
			if (!gbShowTargetOnly)
			{
				// a fourth line is wanted, construct its cell
				cellIndex++; // cellIndex == 3

				// calculate the cell's topLeft and botRight points
				// whm: the wx version doesn't use negative offsets
				topLeft.y = topLeft.y+pApp->m_nTgtHeight;
				botRight.y = botRight.y+pApp->m_nTgtHeight;

				// calculate the extent of the text -- but if there is no text, then make
				// the extent equal to the pileWidth (use m_adaption, so will be correct
				// for retranslations, etc)
				int tgtWidth;
				int tgtDummyHeight;
				if (pSrcPhrase->m_targetStr.IsEmpty())
				{
					// no translation or retranslation, etc, so use pileWidth for extent
					tgtWidth = pPile->m_nWidth; // don't care about extent.cy
				}
				else
				{
					// get the extent of the text
					pDC->GetTextExtent(pSrcPhrase->m_targetStr, &tgtWidth, &tgtDummyHeight);
				}

				// create the cell and set its attributes
				pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
						pSrcPhrase->m_targetStr,tgtWidth,pTgtFont,&color,&topLeft,
						&botRight,cellIndex);
			}
			else
			{
				cellIndex++; // cellIndex == 3, to keep indices right for any gloss line
			}

		}

		// not glossing, but if gbEnableGlossing is TRUE, then glosses will be visible
		// as the last line of the strip, so set up the 5th cell to contain the gloss
		if (gbEnableGlossing)
		{
			if (!gbShowTargetOnly) // don't calculate the cell if we are showing tgt only
			{
				// set the gloss text color, and if using navText's font for the glossing
				// then set up the device context to use it
				color = pApp->m_navTextColor; // glossing always uses navText's color
				if (gbGlossingUsesNavFont)
				{
					pDC->SetFont(*pNavTextFont);
				}

				// a gloss line is wanted, so construct its cell
				cellIndex++; // cellIndex == 3 (if one tgt line) or 4

				// calculate the cell's topLeft and botRight points; we will offset the
				// gloss line an extra 3 pixels from the line above it, since there appears
				// to be some unwanted encroachment for some fonts in some sizes
				if (gbGlossingUsesNavFont)
				{
					// whm: the wx version doesn't use negative offsets
					topLeft.y = topLeft.y+pApp->m_nTgtHeight + 3;
					botRight.y = botRight.y+pApp->m_nNavTextHeight + 3;
				}
				else
				{
					// whm: the wx version doesn't use negative offsets
					topLeft.y = topLeft.y+pApp->m_nTgtHeight + 3;
					botRight.y = botRight.y+pApp->m_nTgtHeight + 3;
				}

				// calculate the extent of the text -- but if there is no text, then make
				// the extent equal to the pileWidth (use m_adaption, so will be correct
				// for retranslations, etc)
				int glossWidth;
				int glossDummyHeight;
				if (pSrcPhrase->m_gloss.IsEmpty())
				{
					// no translation or retranslation, etc, so use pileWidth for extent
					glossWidth = pPile->m_nWidth; // don't care about extent.cy
				}
				else
				{
					// get the extent of the text
					pDC->GetTextExtent(pSrcPhrase->m_gloss, &glossWidth, &glossDummyHeight);
				}

				// create the cell and set its attributes; which font gets used will
				// depend on the gbGlossingUsesNavFont flag
				if (gbGlossingUsesNavFont)
					pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
						pSrcPhrase->m_gloss,glossWidth,pNavTextFont,&color,&topLeft,
						&botRight,cellIndex);
				else
					pPile->m_pCell[cellIndex] = CreateCell(pDoc,pBundle,pStrip,pPile,
						pSrcPhrase->m_gloss,glossWidth,pTgtFont,&color,&topLeft,
						&botRight,cellIndex);
			}
		}
	}
	return pPile;
}

CCell* CAdapt_ItView::CreateCell(CAdapt_ItDoc *pDoc,
				CSourceBundle *pBundle, CStrip *pStrip, CPile *pPile, wxString phrase, int xExtent,
				wxFont *pFont, wxColour *pColor, wxPoint *pTopLeft, wxPoint *pBotRight, int index)
{
	// create the cell
	CCell* pCell = new CCell(pDoc,pBundle,pStrip,pPile);
	wxASSERT(pCell != NULL);

	// set its attributes
	pCell->m_color = *pColor;
	pCell->m_pFont = pFont;
	pCell->m_ptTopLeft = *pTopLeft;
	pCell->m_ptBotRight = *pBotRight;
	pCell->m_nTextExtent = xExtent;
	pCell->m_phrase = phrase;
	pCell->m_nCellIndex = index;

	// create a CText for displaying the cell's string --
	// (for ANSI build, CText is based on CObject, and will use TextOut() for drawing; but for the
	// nonRoman build, it will use DrawText() which has the RTLReading smarts, etc.
	pCell->m_pText = new CText(*pTopLeft,*pBotRight,pFont,phrase,*pColor,index);
	wxASSERT(pCell->m_pText != NULL);
	return pCell;
}

int CAdapt_ItView::CalcPileWidth(wxClientDC *pDC, CAdapt_ItApp* pApp, CSourcePhrase *pSrcPhrase)
// Calculates the pile's width before laying out the current pile in a strip. The function
// is not interested in the relative ordering of the glossing and adapting cells, and so
// does not access CCell instances; rather, it just examines extent of the four text members
// (or five when gbEnableGlossing is TRUE) in the sourcephrase instance passed in. (The fifth
// is, of course, the m_gloss member, which is needed for version 2.0 and onwards.)
{
	int pileWidth;
	wxFont* pSrcFont = pApp->m_pSourceFont;
	wxFont* pTgtFont = pApp->m_pTargetFont;
	wxFont* pNavTextFont = pApp->m_pNavTextFont; // optionally for glossing
	wxSize extent;
	wxSize keyExtent;
	pDC->SetFont(*pSrcFont);

	if (gbShowTargetOnly)
	{
		pileWidth = 6; // default small value
	}
	else
	{
		pDC->GetTextExtent(pSrcPhrase->m_srcPhrase, &extent.x, &extent.y);
		pDC->GetTextExtent(pSrcPhrase->m_key, &keyExtent.x, &keyExtent.y);
		if (pApp->m_bSuppressFirst)
		{
			if (pApp->m_bHidePunctuation)
				pileWidth = keyExtent.x; // never any punctuation, so key's width 
			else
				pileWidth = extent.x; // has punctuation 
		}
		else
		{
			pileWidth = extent.x; // can assume >= to key's width, as differ only by 
									// possible punctuation
		}
	}
	// BEW added 06Jun06, to ensure there is never a zero pile width
	if (pileWidth == 0)
		pileWidth = 10; // a safe default, so something will be seen if the calcs fail

	// is there an adaptation of this key string?
	// (When glossing is ON, an adaptation (if defined) will appear at the active location
	// so when glossing we must always compute the adaptation's width - use m_targetStr)
	if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		// there is a translation in the KB, use source phrase's m_adaption member to
		// get the horz extent of the string; unless m_bHidePunctuation is FALSE, meaning that
		// we are showing m_targetStr in line 3, in such case use the latter
		pDC->SetFont(*pTgtFont);
		wxSize tgtExtent;
		if (gbIsGlossing)
		{
			pDC->GetTextExtent(pSrcPhrase->m_targetStr, &tgtExtent.x, &tgtExtent.y);
		}
		else // use the following block when adapting
		{
			if (!pApp->m_bHidePunctuation && pApp->m_bSuppressLast)
			{
				pDC->GetTextExtent(pSrcPhrase->m_targetStr, &tgtExtent.x, &tgtExtent.y);
			}
			else
			{
				pDC->GetTextExtent(pSrcPhrase->m_adaption, &tgtExtent.x, &tgtExtent.y);
			}
		}
		if (tgtExtent.x == 0) 
			tgtExtent.x = 10; 
		pileWidth = tgtExtent.x > pileWidth ? tgtExtent.x : pileWidth; 
	}

	// note, the use of m_adapation & m_targetStr (neither of which change when the user edits
	// the phrase box text smaller) means that the phrase box can contract only until it gets
	// to the length of the larger of the above two strings. This is not a bug, but is
	// necessary because if the phrase box could contract continuously, then a large
	// m_targetStr would start to get overridden from the right as the source phrases to the
	// right of the active location move further and further left. This would not be a problem
	// if there was no translation to the right, but it is a major problem if the user clicks
	// to place the phrase box earlier, and then starts deleting content from the phrase box.

	// is this pile the active one? If so, recalc using pApp->m_targetPhrase for
	// the pile extent (plus some slop), because at the active location the
	// m_adaption & m_targetStr members of pSrcPhrase are not set, and won't
	// be until the user hits RET to leave the phrase box, so only pApp->m_targetPhrase
	// is valid; note, for version 2 which supports a glossing line, the box will
	// contain a gloss rather than an adaptation whenever gbIsGlossing is TRUE. Glossing
	// could be using the target font, or the navText font.
	if (pSrcPhrase->m_nSequNumber == pApp->m_nActiveSequNum)
	{
		wxSize boxExtent;
		if (gbIsGlossing)
		{
			if (gbGlossingUsesNavFont)
			{
				pDC->SetFont(*pNavTextFont);// it's using the navText font
				pDC->GetTextExtent(pApp->m_targetPhrase, &boxExtent.x, &boxExtent.y); 
			}
			else // it's using the target font
			{
				pDC->SetFont(*pTgtFont);
				pDC->GetTextExtent(pApp->m_targetPhrase, &boxExtent.x, &boxExtent.y);
			}
		}
		else
		{

			pDC->SetFont(*pTgtFont);
			pDC->GetTextExtent(pApp->m_targetPhrase, &boxExtent.x, &boxExtent.y);
		}
		if (boxExtent.x < 10)
			boxExtent.x = 10; // in case m_targetPhrase was empty or very small 
		wxString aChar = _T('w');
		wxSize charSize;
		pDC->GetTextExtent(aChar, &charSize.x, &charSize.y); 
		boxExtent.x += gnExpandBox*charSize.x;	// allow same slop factor as for 
												// RemakePhraseBox & OnChar
		pileWidth = boxExtent.x > pileWidth ? boxExtent.x : pileWidth;

		// this value will still be too small if in the OnChar function there has just been an
		// expansion of the phrase box width. If that is the case, its new width will be found
		// preserved in the view's m_curBoxWidth member variable (the box's window is currently
		// destroyed); so check if the value is bigger, and if so, use that instead for the
		// pile width. But we can only do this adjustment when the box is expanding, not
		// contracting, because unless we distinguish these too cases the pileWidth will always
		// be adjusted large and box contraction will be quashed. So we use a boolean (global)
		// gbExpanding which is set only for the call to RecalcLayout which is done immediately
		// following a box expansion - otherwise it is always FALSE, permitting box contraction
		if (gbExpanding)
			pileWidth = pileWidth < pApp->m_curBoxWidth ? pApp->m_curBoxWidth : pileWidth;
	}

	// if we have the glossing line showing, then compute the gloss's width too
	if (gbEnableGlossing)
	{
		if (!pSrcPhrase->m_gloss.IsEmpty())
		{
			// there is a gloss, so adjust the pile width if the gloss is widest
			if (gbGlossingUsesNavFont)
			{
				pDC->SetFont(*pNavTextFont);
			}
			else
			{
				pDC->SetFont(*pTgtFont);
			}
			wxSize glossExtent;

			pDC->GetTextExtent(pSrcPhrase->m_gloss, &glossExtent.x, &glossExtent.y);
			if (glossExtent.x < 10)
				glossExtent.x = 10;
			pileWidth = glossExtent.x > pileWidth ? glossExtent.x : pileWidth; 
		}
	}
	pApp->m_nCurPileMinWidth = pileWidth; // put it on the view so that CreatePile can use it
									// m_nMinWidth note, this value is text-extent-based, so
									// does not depend on the current expansion state of the
									// phraseBox

	return pileWidth;
}

void CAdapt_ItView::CalcInitialIndices()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int srcCount = pApp->m_pSourcePhrases->GetCount();
	if (srcCount == 0) return;
	int maxIndex = srcCount-1;
	pApp->m_maxIndex = maxIndex;

	if (pApp->m_nMaxToDisplay > maxIndex)
	{
		pApp->m_beginIndex = pApp->m_lowerIndex = pApp->m_curIndex = 0;
		pApp->m_endIndex = maxIndex;
		pApp->m_upperIndex = pApp->m_endIndex - pApp->m_nFollowingContext; // BEW changed 4Sept06, logic was wrong, also next line
		if (pApp->m_upperIndex < pApp->m_lowerIndex)
			pApp->m_upperIndex = maxIndex;
	}
	else
	{
		pApp->m_beginIndex = pApp->m_lowerIndex = pApp->m_curIndex = 0;
		pApp->m_endIndex = pApp->m_nMaxToDisplay-1;
		pApp->m_upperIndex = pApp->m_endIndex - pApp->m_nFollowingContext;
	}
}

CCell* CAdapt_ItView::GetClickedCell(const wxPoint *pPoint)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxPoint point = *pPoint;
	CStrip* pStrip = NULL; // whm initialized to NULL
	CPile* pPile = NULL; // whm initialized to NULL 
	CCell* pCell = NULL; // whm initialized to NULL
	wxRect rect;
	int	pileCount;
	int	pileIndex;
	int cellIndex;
	int stripIndex;
	for (stripIndex = 0; stripIndex < pApp->m_pBundle->m_nStripCount; stripIndex++)
	{
		pStrip = pApp->m_pBundle->m_pStrip[stripIndex];
		wxASSERT(pStrip != NULL);
		rect = pStrip->m_rectStrip;
		rect = NormalizeRect(rect); // use our own from helpers.h
		if (rect.Contains(point))
			break;
	}
	if (stripIndex == pApp->m_pBundle->m_nStripCount || pStrip == NULL) // whm added || pStrip == NULL
		return NULL; // did not click within a strip
	else
	{
		// find which pile the click was in
		pileCount = pStrip->m_nPileCount;
		for (pileIndex = 0; pileIndex < pileCount; pileIndex++)
		{
			pPile = pStrip->m_pPile[pileIndex];
			rect = pPile->m_rectPile;
			rect = NormalizeRect(rect); // use our own from helpers.h
			if (rect.Contains(point))
				break;
		}
		if (pileIndex == pileCount || pPile == NULL) // whm added || pPile == NULL
			return NULL; // did not click within a pile - clicked in a gap, or at end, or in margin
		else
		{
			// find which cell the click was in
			for (cellIndex = 0; cellIndex < MAX_CELLS; cellIndex++)
			{
				pCell = pPile->m_pCell[cellIndex];
				if (pCell == NULL)
					continue;
				rect = pCell->m_pText->m_enclosingRect;
				rect = NormalizeRect(rect); // use our own from helpers.h
				if (rect.Contains(point))
					break;
			}
			if (cellIndex == MAX_CELLS)
				return NULL; // click was not in a cell
		}
	}
	return pCell;
}

// return FALSE if the click was not in a strip or its leading area - it should
// be impossible to return FALSE though
CStrip* CAdapt_ItView::GetNearestStrip(const wxPoint *pPoint)
{
	wxPoint point = *pPoint;
	CStrip* pStrip;
	wxRect rect;
	int leading = gpApp->m_pBundle->m_nLeading; // defines the vertical extent of the nav text area above the strip
	int stripIndex;
	for (stripIndex = 0; stripIndex < gpApp->m_pBundle->m_nStripCount; stripIndex++)
	{
		pStrip = gpApp->m_pBundle->m_pStrip[stripIndex];
		rect = pStrip->m_rectStrip;
		rect = NormalizeRect(rect); // use our own from helpers.h
		// add the leading to the top, because it's within there that we expect clicks on the wedge to happen

		//rect.top -= leading;	// In MFC's CRect this reduces the top coord by leading and increases the
								// rect's height by leading amount (the bottom, left and right sides are unchanged.
		rect.SetTop(rect.GetTop()- leading);	// In wx's wxRect, this only moves the x,y coordinate and
												// consequently the whole box, leaving the height the same,
												// therefore, we also need to reset the height to include
												// the leading value
		rect.SetHeight(rect.GetHeight() + leading); // whm added
		// BEW changed 02Aug05 to handle RTL layout better - for these the click could be outside the strip
		// rectangle for a wedge offset to the right and at the right edge of the strip; so instead just check
		// that the vertical offset for the click falls on or within the top and bottom coords of the rect
		if (point.y >= rect.GetTop() && point.y <= rect.GetBottom()) // was   if (rect.PtInRect(point))
			break;
	}
	if (stripIndex == gpApp->m_pBundle->m_nStripCount)
		return NULL; // did not click within a strip or its leading area above it
	else
		return gpApp->m_pBundle->m_pStrip[stripIndex];
}

// Moved to CAdapt_ItCanvas in WX version:
//void CAdapt_ItView::OnLButtonDown(wxMouseEvent& event)

void CAdapt_ItView::RemovePrecedingAnchor(wxClientDC* pDC, CCell *pAnchor)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCellList::Node* pos = pApp->m_selection.Find(pAnchor);
	wxASSERT(pos != NULL); // the anchor MUST be in the list!
	CCell* pCell;
	pCell = (CCell*)pos->GetData(); // the earliest of desired seln
	pos = pos->GetPrevious();
	if (pos != NULL)
	{
		// there is selected CCell previous to the anchor cell,
		// so get rid of it & any earlier ones
		CText* pText;
		while (pos != NULL)
		{
			CCellList::Node* savePos = pos;
			pText = ((CCell*)pos->GetData())->m_pText;
			pos = pos->GetPrevious();
			pDC->SetBackgroundMode(pApp->m_backgroundMode);
			pDC->SetTextBackground(wxColour(255,255,255)); // white
			pText->Draw(pDC);
			pText->m_bSelected = FALSE;
			pApp->m_selection.DeleteNode(savePos);
		}
	}
}

void CAdapt_ItView::RemoveFollowingAnchor(wxClientDC *pDC, CCell *pAnchor)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCellList::Node* pos = pApp->m_selection.Find(pAnchor);
	wxASSERT(pos != NULL); // the anchor MUST be in the list!
	CCell* pCell;
	pCell = (CCell*)pos->GetData(); // the last cell of desired seln
	pos = pos->GetNext();
	if (pos != NULL)
	{
		// there is selected CCell after the anchor cell,
		// so get rid of it & any later ones
		CText* pText;
		while (pos != NULL)
		{
			CCellList::Node* savePos = pos;
			pText = ((CCell*)pos->GetData())->m_pText;
			pos = pos->GetNext();
			pDC->SetBackgroundMode(pApp->m_backgroundMode);
			pDC->SetTextBackground(wxColour(255,255,255)); // white
			pText->Draw(pDC);
			pText->m_bSelected = FALSE;
			pApp->m_selection.DeleteNode(savePos);
		}
	}
}

void CAdapt_ItView::RemoveEarlierSelForShortening(wxClientDC *pDC, CCell *pEndCell)
// the "end cell" will be towards the left of the selection list (or at its start) when
// the layout direction is either LTR or RTL, because we store in logical order.
// (Lower sequence numbers are to the left.)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCell* pCell;
	CCellList::Node* pos = pApp->m_selection.Find(pEndCell); // MFC .Find takes 2nd BOOL param
	if (pos != NULL)
	{
		pCell = (CCell*)pos->GetData(); // the earliest of desired seln, for LTR
		pos = pos->GetPrevious();
		if (pos != NULL)
		{
			// there is previous selected CCell, so user must have shortened sel'n
			// so get rid of it & any earlier ones
			CText* pText;
			while (pos != NULL)
			{
				CCellList::Node* savePos = pos;
				pText = ((CCell*)pos->GetData())->m_pText;
				pos = pos->GetPrevious();
				pDC->SetBackgroundMode(pApp->m_backgroundMode);
				pDC->SetTextBackground(wxColour(255,255,255)); // white
				pText->Draw(pDC);
				pText->m_bSelected = FALSE;
				pApp->m_selection.DeleteNode(savePos);
			}
		}
	}
}

void CAdapt_ItView::RemoveLaterSelForShortening(wxClientDC *pDC, CCell *pEndCell)
// the "end cell" will be towards the right of the selection list (or at its end) when
// the layout direction is either LTR or RTL, because we store in logical order not
// visible order (ie. larger sequence numbers are to the right in the list)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCell* pCell;
	CCellList::Node* pos = pApp->m_selection.Find(pEndCell);
	if (pos != NULL)
	{
		pCell = (CCell*)pos->GetData(); // the last of desired seln
		pos = pos->GetNext();
		if (pos != NULL)
		{
			// there is another selected CCell, so user must have shortened sel'n
			// so get rid of it & any subsequent ones
			CText* pText;
			while (pos != NULL)
			{
				CCellList::Node* savePos = pos;
				pText = ((CCell*)pos->GetData())->m_pText;
				pos = pos->GetNext();
				pDC->SetBackgroundMode(pApp->m_backgroundMode);
				pDC->SetTextBackground(wxColour(255,255,255)); // white
				pText->Draw(pDC);
				pText->m_bSelected = FALSE;
				pApp->m_selection.DeleteNode(savePos);
			}
		}
	}
}

bool CAdapt_ItView::IsBoundaryCell(CCell *pCell)
{
	return pCell->m_pPile->m_pSrcPhrase->m_bBoundary;
}

CCell* CAdapt_ItView::GetPrevCell(CCell *pCell, int index)
// returns the cell immediately preceding the pCell one, regardless of where boundaries are;
// returns null if no previous cell
{
	CCell* pPrevCell;
	CPile* pPrevPile;
	CPile* pPile = pCell->m_pPile;
	CStrip* pStrip = pPile->m_pStrip;
	CSourceBundle* pBundle = pStrip->m_pBundle;
	int nCurPile = pPile->m_nPileIndex;
	if (nCurPile > 0)
	{
		// there is a previous pile in the current strip
		nCurPile--;
		pPrevPile = pStrip->m_pPile[nCurPile];
		pPrevCell = pPrevPile->m_pCell[index];
	}
	else
	{
		// prev pile is in previous strip, so get it from there
		int nCurStrip = pStrip->m_nStripIndex;
		nCurStrip--; // the previous strip
		if (nCurStrip < 0)
			return (CCell*)0; // we are at start, so there is no previous cell
		pStrip = pBundle->m_pStrip[nCurStrip];
		int nPileCount = pStrip->m_nPileCount;
		nCurPile = nPileCount-1; // index of last pile in the strip
		pPrevPile = pStrip->m_pPile[nCurPile];
		pPrevCell = pPrevPile->m_pCell[index];
	}
	return pPrevCell;
}

void CAdapt_ItView::RemoveSelection()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	pApp->m_bSelectByArrowKey = FALSE;
	if (pApp->m_selection.IsEmpty())
	{
		// if no selection is current, just ensure sel'n parameters are zeroed
		pApp->m_selectionLine = -1;
		pApp->m_pAnchor = (CCell*)NULL;

		// and the globals also
		gnSelectionLine = -1;
		gnSelectionStartSequNum = -1;
		gnSelectionEndSequNum = -1;
		return;
	}
	wxClientDC aDC(pApp->GetMainFrame()->canvas);
	CText* pText;

	// there is a current selection, so clobber it
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	while (pos != NULL)
	{
		CCell* pCell = (CCell*)pos->GetData();
		pText = pCell->m_pText;
		pos = pos->GetNext();
		aDC.SetBackgroundMode(pApp->m_backgroundMode); // Do not use wxTRANSPARENT!! because background is not updated
		aDC.SetTextBackground(wxColour(255,255,255)); // white
		pText->Draw(&aDC);
		pText->m_bSelected = FALSE;
	}
	pApp->m_selection.Clear();
	pApp->m_selectionLine = -1;
	pApp->m_pAnchor = (CCell*)NULL;

	// and the globals also need to be set to a "no selection" state
	gnSelectionLine = -1;
	gnSelectionStartSequNum = -1;
	gnSelectionEndSequNum = -1;

	// toggle Respect Boundaries button back on, so m_bRespectBoundaries is reset TRUE
	if (!pApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(dummyevent);
}

// DeepCopySublist2Sublist was in Helpers.cpp in the legacy version.
// of deep copied CSourcePhrase instances, to an empty pCopiedSublist, as deep copies and
// preserves m_nSequNumber values in the copies
void CAdapt_ItView::DeepCopySublist2Sublist(SPList* pOriginalList, SPList* pCopiedSublist)
{
	// use a try/catch block, as we don't expect this to ever fail, and the only possible way
	// would be for a memory full situation preventing new allocations, so the app is unlikely
	// to be able to close down gracefully anyway
	//try
	//{
		if (pOriginalList->GetCount() == 0)
			return;
		SPList::Node* pos = pOriginalList->Item(0); //POSITION pos = pOriginalList->FindIndex(0);
		wxASSERT(pos);
		SPList::Node* savePos = NULL; //POSITION savePos = NULL;
		CSourcePhrase* pSrcPhrase = NULL;
		while (pos != NULL)
		{
			// deep copy each until all are copied
			savePos = pos;
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			CSourcePhrase* pNewSP = new CSourcePhrase(*pSrcPhrase); // uses operator=, does shallow copy
			pNewSP->DeepCopy(); // pNewSP is now a deep copy
			pCopiedSublist->Append(pNewSP);
		}
	//}
	//catch (CMemoryException* e)
	//{
	//	// notify user, almost certainly the only reason for a failure would be not enough
	//	// space on the storage medium to accept the whole file. We'll assume so, tell the
	//	// user that, and advise him to make more space available or use other media; and
	//	// let the app continue without producing the packed doc file.
	//	wxString thismsg = _T("Unexpected DeepCopySublist2Sublist() function failure - maybe memory is full. App will abort. Doc should be okay on relaunch.");
	//	wxMessageBox(thismsg,_T(""), wxICON_WARNING);
	//	e->Delete();
	//	AfxAbort();
	//} 
}

// RemoveFilterWrappersButLeaveContent was in Helpers.cpp in the legacy version.
// removes "\~FILTER" and "\~FILTER*" from
// str, but leaves the SFM, its content, and any following endmarker followed by any whitespace etc.
void CAdapt_ItView::RemoveFilterWrappersButLeaveContent(wxString& str)
{
	// uses global strings, filterMkr and filterMkrEnd
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	wxString strRemoveThis = filterMkrEnd;
	int len = strRemoveThis.Length();
	wxString strBegin;
	wxString strEnd;
	wxChar ch;
	bool bIsWhitespace = FALSE;
	int offset = -1;
	do {
		offset = str.Find(strRemoveThis);
		if (offset != -1)
		{
			// there is one to be removed
			strBegin = str.Left(offset);
			strEnd = str.Mid(offset);
			strEnd = strEnd.Mid(len); // this removes the "\\~FILTER*" which we found
			// now remove any following whitespace, which now is at the start of strEnd
			ch = strEnd[0];
			bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			while (bIsWhitespace)
			{
				strEnd = strEnd.Mid(1); // remove initial white space character
				ch = strEnd[0];
				bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			}
			// now rejoin the begin and end parts
			str = strBegin + strEnd;
		}
	} while (offset != -1);
	// now do the loop to remove any instances of "\\~FILTER" followed by whitespace
	strRemoveThis = filterMkr;
	len = strRemoveThis.Length();
	offset = -1;
	do {
		offset = str.Find(strRemoveThis);
		if (offset != -1)
		{
			// there is one to be removed
			strBegin = str.Left(offset);
			strEnd = str.Mid(offset);
			strEnd = strEnd.Mid(len); // this removes the "\\~FILTER*" which we found
			// now remove any following whitespace, which now is at the start of strEnd
			bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			while (bIsWhitespace)
			{
				strEnd = strEnd.Mid(1); // remove initial white space character
				bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			}
			// now rejoin the begin and end parts
			str = strBegin + strEnd;
		}
	} while (offset != -1);
}

// ReplaceCSourcePhrasesInSpan was in Helpers.cpp in the legacy version.
////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error. (Also, if either 
///             list is empty, nothing is done and the function returns FALSE.)
/// \param      pMasterList        -> pointer to the list of CSourcePhrase pointers where the 
///                                   replacements are to be done (typically, the app's 
///                                   m_pSourcePhrases list)
/// \param      nStartAt           -> the 0-based index into the pMasterList which is the first 
///                                   CSourcePhrase instance to be replaced (the originals 
///                                   are deleted, the replacments are inserted in the gap 
///                                   where they were located)
/// \param      nHowMany           -> the 1-based count of how many consecutive CSourcePhrase 
///                                   pointers are to be removed from pMasterList to make way 
///                                   for the replacements; this value must not be zero
/// \param      pReplacementsList  -> pointer to the list from which all or a subrange of 
///                                   replacement CSourcePhrase instances are to be inserted 
///                                   where the originals were removed from in pMasterList
/// \param      nReplaceStartAt    -> 0-based index into pReplacementsList which locates the 
///                                   first CSourcePhrase instance which is to be inserted 
///                                   into pMasterList
/// \param      nReplaceCount      -> 1-based count of how many consecutive CSourcePhrase 
///                                   pointers are to be inserted into pMasterList. 
///                                   (nReplaceCount can be less, equal, or greater than 
///                                   nHowMany.) Note: this value can be zero, in which
///                                   case no insertions are done, but the deletions are done
/// \remarks
/// Called from: the View's RestoreDocAfterSrcTextEditModifiedIt(), OnEditSourceText(),
/// OnCustomEventAdaptationsEdit(), OnCustomEventGlossesEdit(), 
/// This is a utility function for clearing out a span of CSourcePhrase instances from a list 
/// and replacing them with a different span taken from some part (or the whole) of some other 
/// list.
/// The ones cleared out are deleted (their contents are lost), the ones inserted are then managed
/// by the pMasterList, and usually that list is persistent, and the pReplacementsList is temporary,
/// but neither assumption is necessary or assumed. The contents of pReplacementsList are not altered;
/// so what actually are inserted are deep copies of the instances in pReplacementsList. The nHowMany
/// and nReplaceCount parameters must not both be zero, if that is the case, it is an error. 
/// 
/// The nReplaceCount value can be zero, if it is, the function is just being used to delete a range
/// of CSourcePhrase instances within a list.
/// The nHowMany value can be zero, if it is, the function is just being used to insert a range
/// of CSourcePhrase instances within a list, preceding the nStartAt instance's location.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ReplaceCSourcePhrasesInSpan(SPList* pMasterList, int nStartAt, int nHowMany,
					SPList* pReplacementsList, int nReplaceStartAt, int nReplaceCount)
{
	// 26May08	function created as part of refactoring the Edit Source Text functionality
	// whm note: Bruce has this function in helpers.h and .cpp, but it is only used in the
	// View so I moved it to the View.
	SPList::Node* posMaster = NULL; //POSITION posMaster = NULL;
	SPList::Node* posReplace = NULL; //POSITION posReplace = NULL;
	wxString error;
	// do nothing if either list has no elements, or if nothing; treat it as an error state
	if (pMasterList->GetCount() == 0)
		return FALSE;
	if (pReplacementsList->GetCount() == 0)
		return FALSE;
	if (nHowMany == 0 && nReplaceCount == 0)
		return FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pReplaceSrcPhrase = NULL;
	CSourcePhrase* pDeepCopiedSrcPhrase = NULL;
	posMaster = pMasterList->Item(nStartAt); //posMaster = pMasterList->FindIndex(nStartAt);
	if (posMaster == NULL)
	{
		// whm note: I don't think this error needs to be translated for localization
		// an unexpected exception, so inform the caller & advise the user of the error
		error = _T("FindIndex() failed in helper function ReplaceCSourcePhrasesInSpan(), posMaster value is NULL. ");
		error += _T("Abandoning current operation.");
		error += _T(" (If restoring document's original state, it is not properly restored.");
		wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	posReplace = pReplacementsList->Item(nReplaceStartAt); //posReplace = pReplacementsList->FindIndex(nReplaceStartAt);
	if (posMaster == NULL)
	{
		// whm note: I don't think this error need to be translated for localization
		// an unexpected exception, so inform the caller & advise the user of the error
		error = _T("FindIndex() failed in helper function ReplaceCSourcePhrasesInSpan(), posReplace value is NULL. ");
		error += _T("Abandoning current operation.");
		error += _T(" (If restoring document's original state, it is not properly restored.");
		wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

	// First delete the old (ie. unwanted) instances from the main list
	SPList::Node* posSaved = NULL; //POSITION posSaved = NULL;
	SPList::Node* pos2 = NULL; //POSITION pos2 = NULL;
	int index;

	// special case 1: only insertions are wanted, no deletions
	if (nHowMany == 0)
	{
		// insertion is wanted, preceding posMaster location
ins:	;
#ifdef _DEBUG
		SPList::Node* posDebug = pMasterList->GetFirst();
		for (index = 0; index < (int)pMasterList->GetCount(); index++)
		{
			CSourcePhrase* pSrcPh = posDebug->GetData();
			posDebug = posDebug->GetNext();
			wxLogDebug(_T("pMasterList BEFORE Insert: pSrcPh->m_srcPhrase = %s"),pSrcPh->m_srcPhrase.c_str());
		}
#endif

		for (index = 0; index < nReplaceCount; index++)
		{
			// insert them in normal order, each preceding the posMaster POSITION
			pReplaceSrcPhrase = posReplace->GetData();
			posReplace = posReplace->GetNext();
			pDeepCopiedSrcPhrase = new CSourcePhrase(*pReplaceSrcPhrase);
			pDeepCopiedSrcPhrase->DeepCopy(); // make the deep copy
			wxASSERT(pDeepCopiedSrcPhrase != NULL);
			// insert each deep copy before the posMaster location each time
			pos2 = pMasterList->Insert(posMaster, pDeepCopiedSrcPhrase); // wx Insert() does the same thing as MFC's InsertBefore()
			// break out of loop if we have come to the end of the replacements list
			if (pReplaceSrcPhrase == NULL)
				break;
		}
#ifdef _DEBUG
		posDebug = pMasterList->GetFirst();
		for (index = 0; index < (int)pMasterList->GetCount(); index++)
		{
			CSourcePhrase* pSrcPh = posDebug->GetData();
			posDebug = posDebug->GetNext();
			wxLogDebug(_T("pMasterList AFTER Insert: pSrcPh->m_srcPhrase = %s"),pSrcPh->m_srcPhrase.c_str());
		}
#endif
		return TRUE;
	}
	else
	{
		// nHowMany is not zero, so deletions are wanted
		if (nReplaceCount == 0)
		{
			// no insertions are wanted, so only the deletions - which have already
			// been done, so return TRUE
			return TRUE;
		}
		else
		{
			// delete the non-empty range of originals from pMasterList
			for (posMaster, index = 0; (posSaved = posMaster) != NULL, index < nHowMany; index++)
			{
				wxASSERT(posSaved);
				pSrcPhrase = posMaster->GetData(); // assume success
				posMaster = posMaster->GetNext();
				gpApp->GetDocument()->DeleteSingleSrcPhrase(pSrcPhrase); // delete pSrcPhrase and its elements from memory locations
				pMasterList->DeleteNode(posSaved);						 // delete 
				// break out of the loop if we have come to the end of the pMasterList
				if (posMaster == NULL)
					break;
			}

			// now insert the non-empty range of replacements at the same location
			if (nStartAt == (int)pMasterList->GetCount())
			{
				// there is no CSourcePhrase instance now at the nStartAt value, because we
				// deleted right to the end of the master list inclusively, so we only need append
				// each to the tail of the pMasterList
				for (index = 0; index < nReplaceCount; index++)
				{
					// get a deep copy
					pReplaceSrcPhrase = posReplace->GetData();
					posReplace = posReplace->GetNext();
					pDeepCopiedSrcPhrase = new CSourcePhrase(*pReplaceSrcPhrase);
					pDeepCopiedSrcPhrase->DeepCopy(); // make the deep copy
					wxASSERT(pDeepCopiedSrcPhrase != NULL);
					// append each deep copy to the master list
					pos2 = pMasterList->Append(pDeepCopiedSrcPhrase);
					// break out of loop if we have come to the end of the replacements list
					if (pReplaceSrcPhrase == NULL)
						break;
				}
			}
			else
			{
				// there is a CSourcePhrase instance at  the nStartAt location, it has moved down
				// to occupy the location from which the earlier deletions were started, so we
				// must now insert before it
				posMaster = pMasterList->Item(nStartAt);
				if (posMaster == NULL)
				{
					// an unexpected exception, so inform the caller & advise the user of the error
					error = _T("FindIndex() failed in helper function ReplaceCSourcePhrasesInSpan(), ");
					error += _T("posMaster value is NULL when finding the POSITION of first CSourcePhrase ");
					error += _T("following the gap. Abandoning current operation.");
					error += _T(" (If restoring document's original state, it is not properly restored.");
					wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
					return FALSE;
				}
				goto ins;
			}
		}
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     Return TRUE if there was no error, FALSE for an error (such as a bounds error) 
/// \param      pList          -> pointer to a list of source phrases
/// \param      nStartLoc      -> starting
/// \param      nFoundAt       <- receives the index value of the next note found, or -1 if none found
/// \param      bFindForwards  -> the direction in which to search for notes
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// This function is used in the vertical edit process, when restoring removed notes after a source text
/// edit. It finds the index value in pList at which the next Note is found, either forwards (or at the current
/// location), or backwards, and return it in nFoundAt, or return -1 in nFoundAt if no note was found in
/// the nominated direction. 
/// Note: while typically used with pList set to the app's m_pSourcePhrases list, in which the
/// list indices always match the stored m_nSequNumber value in each POSITION's CSourcePhrase instance,
/// the function can be used for arbitrary sublists of CSourcePhrase instances because it returns the
/// stored m_nSequNumber value for the found note in the CSourcePhrase which stores it, not the index
/// value in pList at which that CSourcePhrase was located.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::FindNote(SPList* pList, int nStartLoc, int& nFoundAt, bool bFindForwards)
{
	// BEW created 29May08
	wxString errStr;
	if (nStartLoc < 0 || nStartLoc >= (int)pList->GetCount())
	{
		// bounds error, starting location is not within the list (hard coded English
		// error messages will suffice because we don't expect to ever see them)
		errStr = _T("Bounds error in helper function FindNote(). The current operation will be abandoned.");
		wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	//int aSequNum = -1; // unused
	CSourcePhrase* pSrcPhrase = NULL;
	wxString strSFM = _T("\\note");
	SPList::Node* pos = pList->Item(nStartLoc); // POSITION pos = pList->FindIndex(nStartLoc);
	int offset = -1;
	if (pos == NULL)
	{
		// unexpected error, the location should be findable
		errStr = _T("Error in helper function FindNote(); the POSITION value returned from ");
		errStr += _T("FindIndex() was null. The current operation will be abandoned.");
		wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	if (bFindForwards)
	{
		// examine the starting location first
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		offset = pSrcPhrase->m_markers.Find(strSFM);
		if (offset >= 0)
		{
			// there is one at the current location
			nFoundAt = pSrcPhrase->m_nSequNumber;
			return TRUE;
		}
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			offset = pSrcPhrase->m_markers.Find(strSFM);
			if (offset >= 0)
			{
				// there is one at the current POSITION
				nFoundAt = pSrcPhrase->m_nSequNumber;
				return TRUE;
			}
		}
	}
	else
	{
		// ignore the starting location
		pSrcPhrase = pos->GetData();
		pos = pos->GetPrevious();
		// search from the preceding location, backwards
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetPrevious();
			offset = pSrcPhrase->m_markers.Find(strSFM);
			if (offset >= 0)
			{
				// there is one at the current POSITION
				nFoundAt = pSrcPhrase->m_nSequNumber;
				return TRUE;
			}
		}
	}
	// none was found, so return -1
	nFoundAt = -1;
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if successful, FALSE if the move could not be done
/// \param      pLocationsList  -> an array of consecutive sequence numbers where (squeezed) Notes will be 
///                                 reconstituted (because they would not fit in the new edit span)
/// \param      nLeftBoundSN    -> enables us to detect when leftwards movement is no longer possible, 
///                                 and FALSE is returned
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// Moves a note to the left one place.
/// pLocationsList is an array of consecutive sequence numbers where (squeezed) Notes will be reconstituted
/// (because they would not fit in the new edit span), and the caller has determined that the next consecutive
/// location in the document would be a right bound (that is, a non-removed note already is there) and so the
/// location about to be added to the squeezed array can't be used. In this circumstances, we need to call
/// this function to move all the locations in the pLocationsList one place leftwards (ie. decrease the stored
/// indices by one) in order to open a gap between the last stored index and the right bound location so that
/// the next note location can be added as the gap location. This works, as often as necessary, unless the
/// stored index values come to the left bound (which is either the start of the document, or an unremoved
/// note's location lying to the left of the edit span). The nLeftBoundSN enables us to detect when leftwards
/// movement is no longer possible, and FALSE is returned. A successful leftwards movement returns TRUE.
/// (If all the locations between left and right bounds are used up and still there are notes to be placed,
/// the caller will attempt to move the note which is the right bound to the right to create the needed gaps.)
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::MoveNoteLocationsLeftwardsOnce(wxArrayInt* pLocationsList, int nLeftBoundSN)
{
	// BEW added 30May08 in support of the source text editing step of the vertical editing process
	int aSequNum;
	// get the first sequence number index from the list
	aSequNum = (*pLocationsList)[0];
	// if there is a gap between it and the left bound, then shift all the values one
	// place to the left and return TRUE, otherwise do not shift and return FALSE
	if (nLeftBoundSN + 1 < aSequNum)
	{
		// a gap exists, so leftshift
		int count = pLocationsList->GetCount();
		int i;
		int value;
		for (i=0;i<count;i++)
		{
			value = (*pLocationsList)[i];
			(*pLocationsList)[i] = value - 1;
		}
		return TRUE;
	}
	// the attempt was unsuccessful
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if successful, FALSE if the move could not be done
/// \param      pSrcPhrases  -> the app's m_pSourcePhrases list
/// \param      nNoteSN      -> the sequence number index for the CSourcePhrase which stores 
///                             the Note which we want to move rightwards to the next 
///                             CSourcePhrase
/// \remarks
/// Called from: the View's ShiftASeriesOfConsecutiveNotesRightwardsOnce().
/// Moves a note to the right one place.
/// The move can be done only if not at the end of the document, and provided the next 
/// CSourcePhrase does not already store a different Note.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ShiftANoteRightwardsOnce(SPList* pSrcPhrases, int nNoteSN)
{
	// BEW added 30May08 in support of the source text editing step of the vertical editing process
	//CAdapt_ItView* pView = gpApp->GetView();
	SPList::Node* pos = pSrcPhrases->Item(nNoteSN); //POSITION pos = pSrcPhrases->FindIndex(nNoteSN);
	wxString strSFM = _T("\\note");
	CSourcePhrase* pOriginalSrcPhrase = pos->GetData();
	pos = pos->GetNext();
	// check the original src phrase actually has a note
	bool bOriginalHasANote = IsNoteStoredHere(pSrcPhrases, nNoteSN);
	if (!bOriginalHasANote)
	{
		// no note at the passed in location
		return FALSE;
	}
	// check there is a following CSourcePhrase instance 
	if (pos == NULL)
	{
		// we are at the end of the document, so no destination CSourcePhrase exists
		return FALSE;
	}
	// check there is no note on the following CSourcePhrase instance, 
	// if there is, we can't shift the note to this instance
	CSourcePhrase* pDestSrcPhrase = pos->GetData(); // MFC used GetAt(pos);
	wxASSERT(pDestSrcPhrase != NULL);
	int offset = -1;
	offset = pDestSrcPhrase->m_markers.Find(strSFM);
	if (offset != -1)
	{
		// it contains a note already, so we can't move another to here
		return FALSE;
	}
	// the shift is possible, so do it
	MoveNote(pOriginalSrcPhrase,pDestSrcPhrase);
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if a note exists there, FALSE if not
/// \param      pSrcPhrases  -> the app's m_pSourcePhrases list
/// \param      nNoteSN      -> the sequence number index for the CSourcePhrase which we want 
///                             to know whether or not it stores a Note
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// Determines is a Note is stored at nNoteSN location in the pSrcPhrases list.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsNoteStoredHere(SPList* pSrcPhrases, int nNoteSN)
{
	// BEW added 30May08 in support of the source text editing step of the vertical editing process
	SPList::Node* pos = pSrcPhrases->Item(nNoteSN); //POSITION pos = pSrcPhrases->FindIndex(nNoteSN);
	wxString strSFM = _T("\\note");
	CSourcePhrase* pSrcPhrase = pos->GetData();
	pos = pos->GetNext();
	// check if the src phrase has a note, return FALSE if it hasn't got one, TRUE if it has
	int offset = -1;
	offset = pSrcPhrase->m_markers.Find(strSFM);
	if (offset == -1)
	{
		// no Note stored here
		return FALSE;
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if successful, FALSE if the moves could not be done
/// \param      pSrcPhrases  -> the app's m_pSourcePhrases list
/// \param      nFirstNoteSN -> the sequence number index for the CSourcePhrase which stores 
///                             the first Note of the consecutive series which we want to 
///                             move rightwards one location
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// Moves a series of consecutive notes to the right during source text editing.
/// The move can be done only if not at the end of the document, and provided there is a 
/// CSourcePhrase without a Note after the consecutive series ends. The function can be 
/// used even when the location passed in is the only one which has a stored Note.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ShiftASeriesOfConsecutiveNotesRightwardsOnce(SPList* pSrcPhrases, int nFirstNoteSN)
{
	// BEW added 30May08 in support of the source text editing step of the vertical editing process
	// first compile an array of consecutive note locations which need to be shifted right
	// and return FALSE if we come to the end of the document without finding a CSourcePhrase
	// instance which lacks a note (and which could otherwise have accepted a moved Note)
	//CAdapt_ItView* pView = gpApp->GetView();
	wxArrayInt locationsArr; //CArray<int,int> locationsArr;
	int locIndex = nFirstNoteSN;
	bool bHasNote = FALSE;
	int anArrayIndex = -1;
	while (TRUE)
	{
		anArrayIndex++;
		if (locIndex > gpApp->m_maxIndex)
		{
			// we've passed the end of the document without finding a location
			// that does not have a note, so we cannot succeed
			return FALSE;
		}
		bHasNote = IsNoteStoredHere(pSrcPhrases,locIndex);
		if (bHasNote)
		{
			// insert into the array of noted locations and iterate
			//
			//locationsArr.SetAtGrow(anArrayIndex,locIndex);
			// whm Note: wxArrayInt doesn't have MFC's SetAtGrow() method, but we can 
			// accomplish the same thing. We can use the ::SetCount() method of wxArray to 
			// insure the array has at least anArrayIndex + 1 elements, then assign locIndex 
			// to element anArrayIndex. We only call SetCount() if the array is too small.
			// The MFC docs for CAtlArray::SetAtGrow say SetAtGrow does the same thing, "If
			// iElement is larger than the current size of the array, the array is automatically 
			// increased using a call to CAtrArray::SetCount."
			if (anArrayIndex+1 > (int)locationsArr.GetCount())
				locationsArr.SetCount(anArrayIndex+1); // any added elements to the array are assigned int(0) by default // MFC uses SetAtGrow()
			locationsArr[anArrayIndex] = locIndex;
			locIndex++;
		}
		else
		{
			// the CSourcePhrase at this locIndex value does not have a Note
			// so we have found an instance that will permit right-shifting all
			// the consecutive noted locations in the array
			break;
		}
	}
	// now iterate backwards across the array of stored locations, moving the
	// note on each one rightwards once
	int nHowMany = locationsArr.GetCount();
	int aSequNum;
	bool bShiftedOK;
	for (anArrayIndex = nHowMany - 1; anArrayIndex >= 0; anArrayIndex--)
	{
		aSequNum = locationsArr[anArrayIndex];
		bShiftedOK = ShiftANoteRightwardsOnce(pSrcPhrases, aSequNum);
		wxASSERT(bShiftedOK); // this should not have failed
	}
	// success, the passed in nFirstNoteSN location is not a 'gap' as far
	// as stored Notes are concerned
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the Note was successfully created and stored as filtered info, FALSE if there was failure
/// \param      pSrcPhrases  -> the app's m_pSourcePhrases list
/// \param      nLocationSN  -> the location where the note is to be created
/// \param      strNote      -> the text of the note
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// Creates a filtered note on the CSourcePhrase instance in pSrcPhrases which has location nLocationSN for
/// the sequence number. It is the caller's responsibility to ensure there is no note already present there.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::CreateNoteAtLocation(SPList* pSrcPhrases, int nLocationSN, wxString& strNote)
{
	// pSrcPhrases has to be the m_pSourcePhrases list, or a list of CSourcePhrase
	// instances where the list index stays in synch with the stored m_nSequNumber
	// value in each CSourcePhrase instance of the list, for this function to work
	// right
	//CAdapt_ItView* pView = gpApp->GetView();
	wxString noteMkr = _T("\\note");
	wxString noteEndMkr = noteMkr + _T('*');
	bool bHasNote = IsNoteStoredHere(pSrcPhrases, nLocationSN);
	if (bHasNote)
	{
		// this location has a Note already, (the caller should have checked for
		// this and not made the call)
		wxString errStr = _T("There is already a Note at the passed in index, in CreateNoteAtLocation.");
		wxMessageBox(errStr, _T(""), wxICON_WARNING);
		return FALSE;
	}
	else
	{
		// there is no Note at that location, so go ahead and create it there
		if (nLocationSN > gpApp->m_maxIndex)
		{
			// bounds error
			wxString errStr = _T("Bounds error for text nLocationSN > pView->m_maxIndex in CreateNoteAtLocation.");
			wxMessageBox(errStr, _T(""), wxICON_WARNING);
			return FALSE;
		}
		CSourcePhrase* pToSrcPhrase = NULL;
		SPList::Node* pos = pSrcPhrases->Item(nLocationSN); //POSITION pos = pSrcPhrases->FindIndex(nLocationSN);
		wxASSERT(pos != NULL);
		pToSrcPhrase = pos->GetData(); // MFC has GetAt(pos)
		int nInsertionOffset = FindFilteredInsertionLocation(pToSrcPhrase->m_markers,noteMkr);
		bool bInsertContentOnly = FALSE; // need the whole lot done, including wrapping filter markers
		InsertFilteredMaterial(noteMkr,noteEndMkr,strNote,pToSrcPhrase,nInsertionOffset,bInsertContentOnly);
		pToSrcPhrase->m_bHasNote = TRUE;
	}
	return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if all Notes were relocated, FALSE if not
/// \param      nStartOfEditSpan -> 
/// \param      nEditSpanCount   -> 
/// \param      pUnsqueezedArr   <- 
/// \param      pSqueezedArr     <- 
/// \param      nRightBound      -> is used to make sure that when locating notes consecutively, 
///                                 we don't transgress the bound and so cause a note reordering
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// This is sort of like a leftwards version of ShiftASeriesOfConsecutiveNotesRightwardsOnce() but with
/// some important differences. 1. It doesn't relocate notes, it just decrements note locations stored in
/// the passed in pLocationsList. 2. The locations it operates on are not necessarily consecutive, because
/// this function is intended to work with the "unsqueezed" array (ie. as many note locations as possible
/// kept the same as they were before the edit of source text was commenced), and the idea is to start with
/// locations at the end of the array and try to create a gap by moving the last leftwards one location,
/// creating a gap. This iterative decrementing of the final location index may eventually bump up against
/// a previous note's location also stored in the array, and if that is the case, then both those locations
/// get moved left one location, creating a gap. Ultimately, if there are enough removed Notes to be replaced,
/// all the stored locations might have been closed up leftwards to be consecutive after the first one - if 
/// that happens, and more gaps are needed, then the whole lot are decremented by one, -- that process can
/// happen only so long as the first index in the list is greater in value than the passed in nStartOfEditSpan
/// index value. We won't move the locations to precede the final edit span, but if we get to the point where
/// we still need gaps, we'll try relocating the remainder in the following context, and if necessary, they can
/// be created by moving real notes in the following context rightwards. If not all could be relocated, we
/// will return FALSE to the caller and with the pSqueezedArr still containing unlocated stored indices for the
/// Notes unable to be relocated by this function. The caller can then try moving unremoved Notes rightwards to
/// make more gaps, and if that can't get enough, the remainder of the Notes text's will be stored in the top of
/// the removed free translations list.  So, return TRUE if all were relocated, FALSE if not.
/// A second scenario is that there are no entries in the "unsqueezed" array, so that all the entries are
/// in the squeezed array, with unchanged values, put there by the caller.
/// When this is the case, the function will relocate them consecutively from the start of the following
/// context to the start of the edit span; because we want removals (which are all done from within the
/// old edit span) to be reconstituted within the new bounds of the edit span after the user's edit is done.
/// The nRightBound parameter is the location of the first unremoved note in the following context, or if
/// there are none, then m_maxIndex (the location of the last CSourcePhrase in the document). The nRightBound
/// value is used to make sure that when locating notes consecutively, we don't transgress the bound and so
/// cause a note reordering. If we come to this bound, we'll return to the caller to let the above algorithm
/// for placing the remainder do its job.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::BunchUpUnsqueezedLocationsLeftwardsFromEndByOnePlace(int nStartOfEditSpan, int nEditSpanCount,
				wxArrayInt* pUnsqueezedArr, wxArrayInt* pSqueezedArr, int WXUNUSED(nRightBound))
{
	// BEW added 30May08 in support of the source text editing step of the vertical editing process
	// **** Note: in this function, the capital letter pair SN used in variable naming is an acronym
	// for 'sequence number', that is, the variable for which it is a part of its name is an index value
	// into the document's list, m_pSourcePhrases, which stores CSourcePhrase instances ****

	wxASSERT(nEditSpanCount > 0); // == 0 case should have been dealt with in the caller
	int nNumInSqueezedArray = pSqueezedArr->GetCount();
	wxASSERT(nNumInSqueezedArray != 0); // the function should never be called if there is nothing
									  // needing to be relocated by it
	int aNoteSN = 0; // whm: I've initialized it here to prevent warning, but see its use below
	int index;
	int nEditSpanEndLoc = nStartOfEditSpan + nEditSpanCount - 1;
	int nLastLocInUnsqueezedArr;
	int nNumInUnsqueezedArray = pUnsqueezedArr->GetCount();
	if (nNumInUnsqueezedArray == 0)
	{
		// nothing was relocated within the edit span, so the location indices are in the "squeezed"
		// array and unlocated as yet ('unlocated' means they have their old, invalid, sequence
		// numbers unchanged as yet, but are at least in the squeezed array); and the new edit span
		// has at least one CSourcePhrase instance in it. We'll just locate them consecutively within
		// the edit span, rightwards so that the last to be relocated is at the end of the edit span - if
		// if necessary starting the sequence from the start of the edit span, but no earlier; so if any
		// are still are unrelocated at that stage, we return FALSE to the caller so that the caller can
		// handle those that remain (which didn't fit within the span)
		if (nNumInSqueezedArray > nEditSpanCount)
		{
			// not all will fit, so relocate starting from nStartOfEditSpan index value,
			//as many as will fit
			for (index = 0; index < nEditSpanCount; index++)
			{
				pSqueezedArr->RemoveAt(0);
				// create an alternative location for that location just removed
				aNoteSN = nStartOfEditSpan + index;
				// whm note: wxArrayInt's Insert method reverses the parameters! Caution: wx docs also
				// says of wxArray::Insert() "Insert the given number of copies of the item into the array
				// before the existing item n. This resulted in incorrect ordering of source phrases, so
				// we use array[] = assignment notation instead. Bruce's note indicates that it is going
				// to "insert at the array's end", so to be safe we insure that the array has at least
				// nNumInUnsqueezedArray elements by calling SetCount()
				if (nNumInUnsqueezedArray+1 > (int)pUnsqueezedArr->GetCount())
					pUnsqueezedArr->SetCount(nNumInUnsqueezedArray+1);
				(*pUnsqueezedArr)[nNumInUnsqueezedArray] = aNoteSN; //pUnsqueezedArr->InsertAt(nNumInUnsqueezedArray, aNoteSN); // insert at the array's end
				nNumInUnsqueezedArray = pUnsqueezedArr->GetCount(); // update its value
				nNumInSqueezedArray = pSqueezedArr->GetCount(); // update its value
			}
		}
		else
		{
			// all will fit, so relocate starting from wherever in the span will result in them
			// all being bunched up at the end of the span
			int nBeginAt = nEditSpanEndLoc - nNumInSqueezedArray + 1;
			int nHowManyToDo = nNumInSqueezedArray;
			for (index = 0; index < nHowManyToDo; index++)
			{
				pSqueezedArr->RemoveAt(0);
				// create an alternative location for that location just removed
				aNoteSN = nBeginAt + index;
				// whm: See note in block above
				if (nNumInUnsqueezedArray+1 > (int)pUnsqueezedArr->GetCount())
					pUnsqueezedArr->SetCount(nNumInUnsqueezedArray+1);
				(*pUnsqueezedArr)[nNumInUnsqueezedArray] = aNoteSN; //pUnsqueezedArr->InsertAt(nNumInUnsqueezedArray, aNoteSN); // insert at the array's end
				nNumInUnsqueezedArray = pUnsqueezedArr->GetCount(); // update its value
				nNumInSqueezedArray = pSqueezedArr->GetCount(); // update its value
				if (nNumInSqueezedArray == 0)
				{
					return TRUE; // success, all are relocated now within the final edit span
				}
			}
		}
		// if control gets here, then there is still at least one unrelocated index remaining in
		// pSqueezedArr, in which case we'll return FALSE and let the caller deal with what remains
		return FALSE;
	}
	else
	{
		// there is at least one replacement location within the edit span; this suggests that the edit span
		// may be large enough for the ones which didn't fit within the span resulting from the user's edit
		// to be squeezed in there at its end, so now we attempt to do that, leftshifting as necessary.
		nLastLocInUnsqueezedArr = (*pUnsqueezedArr)[nNumInUnsqueezedArray - 1];

		// find the number of locations in the gap betwen the last in the unsqueezed array, and the end of
		// the edit span - if we can place all of the ones in the squeezed array there using successive
		// locations, then do so; otherwise, we'll need to uses a left-shifting strategy to open up gaps;
		// anything we successfully relocate will be added at the tail of the unsqueezed array and removed
		// from the squeezed array, so that the final content of the squeezed array is what remains to be
		// relocated somewhere
		int nNumberPossibleAtEnd = nEditSpanEndLoc - nLastLocInUnsqueezedArr; // size of the gap there

		// if an end gap exists try to fill it to whatever extent is possible
		if (nNumberPossibleAtEnd > 0 )
		{
			// do as many as possible by filling the gap, and then exit the loop to use a left-shifting
			// strategy for as many of the remainders as possible - unless there are no remainders in which
			// case we are done
			for (index = 0; index < nNumberPossibleAtEnd; index++)
			{
				// remove the first of those remaining in the squeezed list
				pSqueezedArr->RemoveAt(0);
				// create an alternative location for that location just removed
				aNoteSN = nLastLocInUnsqueezedArr + 1 + index;
				// store it at the end of the unsqueezed array - (forming one or more
				// consecutive locations there, depending on how many iterations
				// this loop can do before it exits)
				// whm note: wxArrayInt's Insert method reverses the parameters! Caution: wx docs also
				// says of wxArray::Insert() "Insert the given number of copies of the item into the array
				// before the existing item n. This resulted in incorrect ordering of source phrases, so
				// we use array[] = assignment notation instead. Bruce's note indicates that it is going
				// to "insert at the array's end", so to be safe we insure that the array has at least
				// nNumInUnsqueezedArray elements by calling SetCount()
				if (nNumInUnsqueezedArray+1 > (int)pUnsqueezedArr->GetCount())
					pUnsqueezedArr->SetCount(nNumInUnsqueezedArray+1);
				(*pUnsqueezedArr)[nNumInUnsqueezedArray] = aNoteSN; //pUnsqueezedArr->InsertAt(nNumInUnsqueezedArray, aNoteSN);
				nNumInUnsqueezedArray = pUnsqueezedArr->GetCount(); // update its value for below
				nNumInSqueezedArray = pSqueezedArr->GetCount(); // update its value
				if (nNumInSqueezedArray == 0)
				{
					return TRUE; // success, all are relocated now within the final edit span
				}
			}
		}
		// If control gets here, we've more to locate, so use left-shifts to do it, at least until the 
		// leftshifts bring the replacement locations to the start of the final edit span - and if that
		// happens we won't let leftshifting go any further, but rather we exit and let the caller
		// relocate those remaining in the squeezed array by a filling strategy for the immediate
		// context of CSourcePhrase instances which follow the end of the final edit span
		wxASSERT(nNumInSqueezedArray > 0);
		int nNumberToRelocate = nNumInSqueezedArray;
		int nPotentialGapSN;
		int nBackIndex;
		int anUnsqueezedArrIndex;
		while(nNumberToRelocate > 0) // loop for how many times we have to try
		{
			// inner loop iterates backwards over the relocation SN values stored in the unsqueezed array now,
			// looking for gaps and leftshifting rightmost stored values as necessary to create gaps
			for (anUnsqueezedArrIndex = 0; anUnsqueezedArrIndex < nNumInUnsqueezedArray; anUnsqueezedArrIndex++)
			{
				nBackIndex = nNumInUnsqueezedArray - 1 - anUnsqueezedArrIndex; // indexing from the end of the array
				// find next gap
				nPotentialGapSN = (*pUnsqueezedArr)[nBackIndex] - 1; // subtract 1 from the stored value
				if (nPotentialGapSN < nStartOfEditSpan)
				{
					// we can't go back that far in SN values, so break out of loop, the caller must finish it
					return FALSE;
				}
				// we have not gone past the bounding nStartOfEditSpan sequ number value, so the nPotentialGapSN
				// value is still a potential gap; it won't be a gap if the previously stored SN value in 
				// the pUnsqeezedArr has the same value as nPotentialGapSN, in which case we keep iterating
				// back over stored values in the unsqueezed array; but if there is no previous entry, we
				// have come to the gap region (it could be empty) from the nStartOfEditSpan value (inclusive)
				// to the SN value immediately preceding the first stored SN value in the pUnsqueezedArr array -
				// where we can shift left as often as we like provided no shifted stored SN value becomes less
				// than the nStartOfEditSpan. So we have to test for these conditions etc.
  				if (nBackIndex == 0)
				{
					// there isn't any earlier stored SN entry, so we've come to the region we potentially
					// multiple leftshifts can be done, to create multiple gaps at the end of the list of
					// leftshifted stored SN values; either we can do enough leftshifts in this code block
					// to relocate those that remain in pSqueezedArr and return TRUE, or we do as many as
					// possible here and return FALSE, so that the caller can handle the remainder -- either
					// we control will return to the caller at the end of this code block
					int nVacantLocations = (*pUnsqueezedArr)[nBackIndex] - nStartOfEditSpan;
					if (nVacantLocations > 0 )
					{
						// do as many as possible by leftshifting, and fill the gaps created at the end
						// and then return TRUE or FALSE depending on whether or not all were handled
						int index3;
						int nDecrementBy;
						nNumInSqueezedArray = pSqueezedArr->GetCount(); // make sure the value is uptodate
						if (nNumInSqueezedArray <= nVacantLocations)
						{
							// we can handle all of those that remain
							nDecrementBy = nNumInSqueezedArray;
							pSqueezedArr->Clear(); // abandon these, as we'll calculate new loc'n values
							// decrement the pUnsqueezedArr stored values so as to leftshift into the gap
							for (index3 = 0; index3 < nNumInUnsqueezedArray; index3++)
							{
								// decrement the unsqueezed array stored SN values, creating a gap at the end
								aNoteSN = (*pUnsqueezedArr)[index3]; // get next
								aNoteSN -= nDecrementBy; // decrement its stored value by nDecrementBy
								(*pUnsqueezedArr)[index3] = aNoteSN; // restore the new value at same index
							}
							// the aNoteSN value on exit of the preceding loop is the last stored SN value,
							// in pUnsqueezedArr, and so there are nDecrementBy locations available for creating
							// the new consecutive entries required for handling the rest of the needed 
							// replacement locations not yet assigned
							int nNewSN;
							int nItsLocation;
							for (index3 = 0; index3 < nDecrementBy; index3++)
							{
								// store the new ones at the end of the unsqueezed array
								// whm Note: aNoteSN here is "potentially uninitialized local variable"
								// I've initialized it at the top of this function to 0, but the logic
								// should be checked. TODO:
								nNewSN = aNoteSN + 1 + index3; // the SN value to be stored
								nItsLocation = nNumInUnsqueezedArray + index3;
								// whm: See notes above on MFC's InsertAt vs wx Insert
								if (nItsLocation+1 > (int)pUnsqueezedArr->GetCount())
									pUnsqueezedArr->SetCount(nItsLocation+1);
								(*pUnsqueezedArr)[nItsLocation] = nNewSN; //(*pUnsqueezedArr).InsertAt(nItsLocation,nNewSN);
							}
							return TRUE;
						}
						else
						{
							// we can handle only some of those that remain
							nDecrementBy = nVacantLocations;
							//pSqueezedArr->RemoveAt(0,nDecrementBy); // abandon only this many, we'll calculate
							// whm Note: the STL erase doesn't have a second parameter for number of
							// removals, so we'll do it in a for loop
							int ct;
							for (ct = 0; ct < nDecrementBy; ct++)
								pSqueezedArr->RemoveAt(0);
							// this many new loc'n values by decrementing all the pUnsqueezedArr stored values
							// so as to leftshift into the this gap, and the remainder will be the caller's job
							for (index3 = 0; index3 < nNumInUnsqueezedArray; index3++)
							{
								// decrement the unsqueezed array stored SN values, creating a gap at the end
								aNoteSN = (*pUnsqueezedArr)[index3]; // get next
								aNoteSN -= nDecrementBy; // decrement its stored value by nDecrementBy
								(*pUnsqueezedArr)[index3] = aNoteSN; // restore the new value at same index
							}
							// create and store the required new SN indices at the end of the edit span
							int nNewSN;
							int nItsLocation;
							for (index3 = 0; index3 < nDecrementBy; index3++)
							{
								// store the new ones at the end of the unsqueezed array
								nNewSN = aNoteSN + 1 + index3; // the SN value to be stored
								nItsLocation = nNumInUnsqueezedArray + index3;
								// whm: See notes above on MFC's InsertAt vs wx Insert
								if (nItsLocation+1 > (int)pUnsqueezedArr->GetCount())
									pUnsqueezedArr->SetCount(nItsLocation+1);
								(*pUnsqueezedArr)[nItsLocation] = nNewSN; //(*pUnsqueezedArr).InsertAt(nItsLocation,nNewSN);
							}						
						}
						return FALSE;
					}
					else
					{
						// the stored SN value at nBackIndex == 0 is already the value nStartOfEditSpan
						// and so we can't relocate any more, so hand it back to the caller to do
						return FALSE;
					}
				} // end of block for loop end condition being satisfied, that is,
				  // nBackIndex having reached 0 with at least one more not yet relocated
				else
				{
					// there is at least one earlier stored SN entry, so get it's value so we can compare it
					// with the nPotentialGapSN value (reuse the aNoteSN variable for this purpose)
					aNoteSN = (*pUnsqueezedArr)[nBackIndex - 1];
					if (aNoteSN < nPotentialGapSN)
					{
						// nPotentialGapSN is a genuine gap, so we can leftshift entry values by one to fill 
						// this gap, and then we can fill the opened gap at the nEditSpanEndLoc SN value by
						// removing the next first element from the pSqueezedArr array, and storing a
						// nEditSpanEndLoc as the new relation value for it in the tail of the pUnsqueezedArr
						// array; then adjust the appropriate values to comply, and then iterate the outer loop
						int index2;
						for (index2 = nNumInUnsqueezedArray - 1; index2 >= nBackIndex; index2--)
						{
							// decrement by 1 the stored values at the end of the unsqueezed array (aNoteSN
							// can be reused here for this too
							aNoteSN = (*pUnsqueezedArr)[index2];
							aNoteSN--; // decrement it, leftshifting thereby by 1
							(*pUnsqueezedArr)[index2] = aNoteSN; // overwrite with the decremented SN value
						}
						// now we have a 'gap' at the sequence number nEditSpanEndLoc which we can use
						// for the next so-far-unrelocated Note index, so do the relocation etc
						pSqueezedArr->RemoveAt(0); // chuck this one
						// whm note: wxArrayInt's Insert method reverses the parameters! Caution: wx docs also
						// says of wxArray::Insert() "Insert the given number of copies of the item into the array
						// before the existing item n. This resulted in incorrect ordering of source phrases, so
						// we use array[] = assignment notation instead. Bruce's note indicates that it is going
						// to "insert at the array's end", so to be safe we insure that the array has at least
						// nNumInUnsqueezedArray elements by calling SetCount()
						if (nNumInUnsqueezedArray+1 > (int)pUnsqueezedArr->GetCount())
							pUnsqueezedArr->SetCount(nNumInUnsqueezedArray+1);
						(*pUnsqueezedArr)[nNumInUnsqueezedArray] = nEditSpanEndLoc; //(*pUnsqueezedArr).InsertAt(nNumInUnsqueezedArray,nEditSpanEndLoc); // store relocation SN
						nNumInUnsqueezedArray = pUnsqueezedArr->GetCount(); // update size
						nNumInSqueezedArray = pSqueezedArr->GetCount(); // update size
						nNumberToRelocate--; // decrement the count of how many remain to be handled
											 // by the outer loop
						break; // iterate in the outer loop
					}
					else
					{
						// aNoteSN must equal nPotentialGapSN, so these entries are consecutive, so
						// keep iterating the inner loop to look for a gap into which we can leftshift
						continue;
					}
				} // end of the test for whether or not there is an earlier stored SN value preceding
				  // the currently accessed one
			} // end of inner loop
		} // end of outer loop
	}
	return FALSE; // we didn't manage to relocate them all, caller can do the rest
}

/*************************************************************************************************
*
*	GetMarkerArrayFromString	
*
*	Returns:	a CString containing one or more whole markers (ie. including backslash) and each
*				with a delimiting single space following it, including the last
*	Parameters:
*		pStrArr	<-	populated with CStrings, each being a whole marker (no delimiting space)
*		str		->	ref to the string containing a mix of markers and text (e.g. SFM marked up
*					source text) from which the whole markers are to be found and inserted into
*					the aray returned to the caller
*	Comments:
*	Extracts an array of whole markers, in order of occurrence (not sorted). There might not be
*	might not be any SF markers in the passed in str, in which case an empty array is returned.
*	The array's initial size (0) and growby value (1) are set first here before it is populated.
*	We are not interested in preventing multiple identical entries because the function that will
*	use the returned array is interested only in the unique markers, and works whether there are
*	repeats or not. (Used by the AreMarkerArraysDifferent() helper function, which is used in the
*	Edit Source Text refactored code (see OnEditSourceText()) to detect when the user has modified
*	a marker when doing his	edit - such as when correcting a misspelled marker to be what it should
*	be.)
*	History:
*	Created 17June08 by BEW, for support of refactored Source Text Edit functionality
*
*****************************************************************************************************/
void CAdapt_ItView::GetMarkerArrayFromString(wxArrayString* pStrArr, const wxString& str)
{
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	pStrArr->Clear();
	//pStrArr->SetSize(0,1);
	wxString aMarker;
	wxString s(str); // we'll modify only this local copy
	int offset = 0;
	wxChar backslash = _T('\\');
	offset = FindFromPos(s,backslash,offset);
	if (offset == -1)
		return;
	int index = 0;
	while (offset != -1)
	{
		s = s.Mid(offset); // point at the backslash of the marker
		aMarker = pDoc->GetWholeMarker(s);
		// insert in the array
		//pStrArr->SetAtGrow(index, aMarker);
		// whm Note: wxArrayInt doesn't have MFC's SetAtGrow() method, but we can 
		// accomplish the same thing. We can use the ::SetCount() method of wxArray to 
		// insure the array has at least anArrayIndex + 1 elements, then assign locIndex 
		// to element anArrayIndex. We only call SetCount() if the array is too small. 
		if (index+1 > (int)pStrArr->GetCount())
			pStrArr->SetCount(index+1); // any added elements to the array are assigned int(0) by default
		(*pStrArr)[index] = aMarker;
		// point past the backslash & get the offset to the next marker
		offset++;
		offset = FindFromPos(s,backslash,offset);
		index++;
	}
}

/*************************************************************************************************
*
*	IsMarkerInArray	
*
*	Returns:	TRUE if the array contains at least one instance of the whole marker being tested,
*				FALSE if the marker is absent from the array, or the array is empty
*	Parameters:
*		pStrArr	->	populated with CStrings, each being a whole marker (no delimiting space),
*					derived from a string containing a mix of markers and their text content
*		marker	->	a SF marker, including initial backslash, and with no delimiting space at the end
*
*	Comments:
*	Iterates through the whole array, testing for identity with the passed in marker. As soon as
*	a match is made, it returns. (Used by the AreMarkerArraysDifferent() helper function). If the
*	array contains no elements, the return result is FALSE.
*	
*	History:
*	Created 17June08 by BEW, for support of refactored Source Text Edit functionality
*
*****************************************************************************************************/

bool CAdapt_ItView::IsMarkerInArray(wxArrayString* pStrArr, const wxString& marker)
{
	int index;
	wxString aMarker;
	int nSize = pStrArr->GetCount();
	if (nSize == 0)
		return FALSE;
	for (index = 0; index < nSize; index++)
	{
		aMarker = (*pStrArr)[index];
		wxASSERT(!aMarker.IsEmpty());
		if (aMarker == marker)
			return TRUE;
	}
	return FALSE; // no match was made
}


/*************************************************************************************************
*
*	AreMarkerSetsDifferent	
*
*	Returns:	TRUE if the arrays are different (meaning that one or the other has at least one
*				SF marker which is not in the other, repeated markers will have more than one
*				entry in the passed in array(s), but that is not relevant to the result)
*	Parameters:
*		str1	->	a string containing marked up (SFM or USFM) text, such as source text
*		str2	->	a string containing marked up (SFM or USFM) text, such as edited source text
*		bUnfilteringRequired	<-	TRUE if a "to-be-unfiltered" entry is added to m_FilterStatusMap
*									FALSE if not
*		bFilteringRequired		<-	TRUE if a "to-be-filtered" entry is added to m_FilterStatusMap
*									FALSE if not
*	Comments:
*	Compares the unique markers in the strings, looking for evidence that there is at least one marker
*	which is not in the other string. It is done in both directions, in case one of the strings has a
*	subset of markers which are in the other - as testing the contents of just one string agains the
*	contents of the other (with perhaps an extra unique marker) could produce a FALSE result, when doing
*	it the other way round would produce a TRUE result. So we do it both ways to make sure the result is
*	correct. An string without markers tested against one with one or more in it will also generate a TRUE
*	result; both strings lacking SF markers generates a FALSE result.
*
*	IMPORTANT note regarding usage: str1 must be the original editable source text string, str2 must be the
*	new source text string, because the code added on 4July08 tests each marker in str2 to see if it is
*	included in str1, and each which fails that test will cause an entry to be added to m_FilterStatusMap
*	which is a document class member which controls the operation of RetokenizeText() when filter changes
*	are relevant to the document rebuild. BEW changed, to exclude dependence on m_FilterStatusMap
*	
*	History:
*	Created 17June08 by BEW, for support of refactored Source Text Edit functionality
*	4July08, BEW added code for adding entries to m_FilterStatusMap; the code should handle most situations
*	but is not foolproof, and it relies on the caller supplying the original editable text as str1, and
*	the new editable text as str2.
*	6July08, BEW removed the need to use m_FilterStatusMap entries in the OnEditSourceText() refactored code
*	by using DoMarkerHousekeeping() over the whole document, rather than rebuilding the whole document using
*	the RetokenizeText() call as the legacy function used to do; consequently the calls to
*	AddEntryToFilterStatusMap() below are commented out, and two functions are thereby removed from the code
*	because they are no longer needed (the other is CopyStringToStringMap())
*
*****************************************************************************************************/
bool CAdapt_ItView::AreMarkerSetsDifferent(const wxString& str1, const wxString& str2, bool& bUnfilteringRequired,
							bool& bFilteringRequired)
{
	int index;
	wxString aMarker; // use for a whole marker, with no trailing space (ie. backslash plus bare marker)
	wxString aMkrWithSpace; // construct a string comprised of marker plus trailing space, here
	bool bShouldBeFiltered;
	bool bReturnValue = FALSE; // start with a safe default (ie. marker sets are the same)
	bool bMatched = TRUE;
	wxArrayString* pStrArr1 = new wxArrayString; //CArray<CString,CString>* pStrArr1 = new CArray<CString,CString>;
	wxArrayString* pStrArr2 = new wxArrayString; //CArray<CString,CString>* pStrArr2 = new CArray<CString,CString>;

	// get their marker inventories in the form of CArray<CString,CString> arrays
	GetMarkerArrayFromString(pStrArr1, str1);
	GetMarkerArrayFromString(pStrArr2, str2);

	// initialize the flag values to be returned to the caller
	bUnfilteringRequired = FALSE;
	bFilteringRequired = FALSE;

	// get the sizes of these two arrays
	int nSize1 = pStrArr1->GetCount();
	int nSize2 = pStrArr2->GetCount();

	// bleed out the easy cases
	if (nSize1 == 0 && nSize2 == 0)
	{
		delete pStrArr1;
		delete pStrArr2;
		return FALSE; // both empty, they can't be different
	}
	// check for new source text with no markers
	if (nSize2 == 0)
	{
		// new source text has no markers, the other must have at
		// least one, so they are different; and no filtering or
		// unfiltering is involved because there is no marker which
		// could be a candidate (sso m_FilterStatusMap remains empty)
		pStrArr1->Clear();
		delete pStrArr1;
		delete pStrArr2;
		return TRUE;
	}
	// check for pre-edit source text with no markers
	// NOTE: see the long comment below for a discussion of the (small) weakness of
	// this simple algorithm for determining what entries to add to m_FilterStatusMap
	if (nSize1 == 0)
	{
		// no markers in the pre-edit source text, the new source text therefore
		// must have at least one, so the sets are different. Moreover, every marker
		// in the new source text as a result of the first set being empty, must be
		// given an entry in m_FilterStatusMap
		for (index = 0; index < nSize2; index++)
		{
			aMarker = (*pStrArr2)[index];
			wxASSERT(!aMarker.IsEmpty());
			// this aMarker SF marker is known not to be in the pre-edit source text,
			// so the arrays are different;
			// and so this marker has to generate an entry for the map m_FilterStatusMap
			bReturnValue = TRUE;

			// determine if this is filterable or not, and set up the entry accordingly
			aMkrWithSpace = aMarker + _T(' ');
			bShouldBeFiltered = IsMarkerWithSpaceInFilterMarkersString(aMkrWithSpace,
														gpApp->gCurrentFilterMarkers);
			// the following call is not needed if OnEditSourceText() uses DoMarkerHousekeeping()
			// over the whole doc instead of RetokenizeText(), which turned out to be the case
			//AddEntryToFilterStatusMap(aMarker, bShouldBeFiltered);
			if (bShouldBeFiltered)
				bFilteringRequired = TRUE;
			else
				bUnfilteringRequired = TRUE;
		}
		delete pStrArr1;
		pStrArr2->Clear();
		delete pStrArr2;
		goto b;
	}

	// when both arrays have content, we must test each marker against all those in the other array,
	// doing this in both directions - because we must be sure to get a correct BOOL result in the
	// situation where one marker set may be a subset of the other

	// iterate across the markers in the first array, testing for a non-match in the second
	// (all we are interested in for this loop is to find any pre-edit markers which are not
	// in the post-edit source text string
	for (index = 0; index < nSize1; index++)
	{
		aMarker = (*pStrArr1)[index];
		wxASSERT(!aMarker.IsEmpty());
		bMatched = IsMarkerInArray(pStrArr2, aMarker);
		if (!bMatched)
		{
			// this aMarker SF marker is not in array 2, so the arrays are different
			bReturnValue = TRUE;
		}
	}
	// iterate across the markers in the second array, (the new source text),
	// testing for a non-match in the first (the original text before editing happened)
	// -- this loop is where we possibly may add entries to m_FilterStatusMap
	//
	// This algorithm has an obvious weakness: if the original pre-edit source text has
	// \mkr1 (a misspelled marker which the user will edit to be \mkr2 which is filterable)
	// and also has an instance of \mkr2 as well, then changing \mkr1 to \mkr2 in the edit
	// dialog results in the new source text having \mkr2; and when we test \mkr2 to see if
	// it is in the pre-edit text string, we would find that it is, and so no entry would
	// get added to m_FilterStatusMap, when in actual fact it really should have, because
	// a misspelled marker has been fixed so as to be a to-be-filtered one, but the caller
	// will subsequently not call RetokenizeText() to do the filtering because the map has
	// had no entry put in it. The user can reduce the likelihood of such a situation by just
	// selecting the one word where the typo marker is stored, and do the change to the correct
	// marker in the dialog; however, if the typo marker is changed to be one which comes with
	// a matching endmarker, then the user's selection needs to be all the words up to where
	// the endmarker is stored (but not necessarily selecting the CSourcePhrase instance because
	// the TextType may change and prevent it being selected anyway, but our code will still
	// pick up the bad endmarker and show it to the user in the edit source text dialog). 
	//
	// So, the rule when making a good selection to correct a typo marker is: if it is supposed to
	// have an endmarker, select all the words which are to be enclosed by the marker - endmarker
	// pair, but if the typo marker is to be changed to one which has no endmarker, just select
	// the word which has the typo marker stored in its CSourcePhrase instance. Doing that makes 
	// the algorithm 100% reliable.
	//
	// The likelihood of a selection with a bad marker also having an instance of the filterable
	// marker which the user will change the bad marker to be when he edits, is very very small;
	// so our simplistic algorithm should actually do the job quite well, probably for everyone
	// and every time; and it is guaranteed to work if the user adhere's to the above rules for
	// the selection
	for (index = 0; index < nSize2; index++)
	{
		aMarker = (*pStrArr2)[index];
		wxASSERT(!aMarker.IsEmpty());
		bMatched = IsMarkerInArray(pStrArr1, aMarker);
		if (!bMatched)
		{
			// this aMarker SF marker is not in array 1, so the arrays are different
			// and so this marker has to generate an entry for the map m_FilterStatusMap
			bReturnValue = TRUE;

			// determine if this is filterable or not, and set up the entry accordingly
			aMkrWithSpace = aMarker + _T(' ');
			bShouldBeFiltered = IsMarkerWithSpaceInFilterMarkersString(aMkrWithSpace,
														gpApp->gCurrentFilterMarkers);
			// the following call is not needed if OnEditSourceText() uses DoMarkerHousekeeping()
			// over the whole doc instead of RetokenizeText(), which turned out to be the case
			//AddEntryToFilterStatusMap(aMarker, bShouldBeFiltered);
			if (bShouldBeFiltered)
				bFilteringRequired = TRUE;
			else
				bUnfilteringRequired = TRUE;
		}
	}
	// clean up
	pStrArr1->Clear();
	delete pStrArr1;
	pStrArr2->Clear();
	delete pStrArr2;
b:	return bReturnValue;
}

bool CAdapt_ItView::IsMarkerWithSpaceInFilterMarkersString(wxString& mkrWithSpace, wxString& strFilterMarkers)
{
	int offset = strFilterMarkers.Find(mkrWithSpace); // the trailing space prevents spurious matches
	if (offset == -1)
		return FALSE;
	else
		return TRUE;
}

void CAdapt_ItView::RemakePhraseBox(CPile* pActivePile, wxString& phrase)
// this version works whether the phrase box's window currently exists at the old
// location or not; the earlier version required the phrase (usually m_targetPhrase) to
// be put in the phrase box window using SetWindowText in the caller - which became
// a problem if we wanted to use RemakePhraseBox when the phrase box had been destroyed
// (eg. at EOF); so this new version removes that restriction. The caller can still
// have the SetWindowText call preceding the call to RemakePhraseBox, as it is a benign
// call, since RemakePhraseBox will clobber the window without using the contents of
// the window in this new version
// Version 2.0 and onwards we have to test gbIsGlossing to set the colour; the caller
// supplies the text (either gloss or adaptation)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// we need the text metrics for the chosen font for the target language
	wxClientDC dC(pApp->GetMainFrame()->canvas); // get a device context
	wxFont SaveFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
			SaveFont = dC.GetFont();
			dC.SetFont(*pApp->m_pNavTextFont);
	}
	else
	{
			SaveFont = dC.GetFont();
			dC.SetFont(*pApp->m_pTargetFont);
	}

	// wx version problem: the target box (pBox) pointer has problems with the
	// Destroy() call below. I tried doing the destroy directly on pApp->m_targetBox
	// pointer below but got the same Debug Assertion Failed message.
	//CPhraseBox* pBox = pApp->m_pTargetBox; //CPhraseBox* pBox = &pApp->m_targetBox;

	// calculate the extent
	if ( phrase.IsEmpty())
		pApp->m_curBoxWidth = pActivePile->m_nMinWidth;
	else
	{
		// do the same calculation as is done in CalcPileWidth, so that the box extent matches
		// the gap that RecalcLayout will put at the active location
		int phraseWidth;
		int phraseDummyHeight;
		dC.GetTextExtent(phrase,&phraseWidth,&phraseDummyHeight);
		wxString aChar = _T('w');
		int charWidth;
		int charDummyHeight;
		dC.GetTextExtent(aChar,&charWidth,&charDummyHeight);
		phraseWidth += gnExpandBox*charWidth;
		pApp->m_curBoxWidth = phraseWidth;
	}

	dC.SetFont(SaveFont); // restore original font, don't need CDC any mor

	// recreate the text box with new parameters
	pApp->m_targetPhrase = phrase; // ensure current typed string is stored on the view's member

	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nNavTextHeight,pApp->m_targetPhrase,pApp->m_nStartChar,
																	pApp->m_nEndChar,pApp->m_pActivePile);
		pApp->m_pTargetBox->SetFont(*pApp->m_pNavTextFont); // set the font // MFC has 2nd param TRUE
	}
	else
	{
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nTgtHeight,pApp->m_targetPhrase,pApp->m_nStartChar,
																	pApp->m_nEndChar,pApp->m_pActivePile);
		pApp->m_pTargetBox->SetFont(*pApp->m_pTargetFont); // set the font // MFC has 2nd param TRUE
	}

	// set the color - CPhraseBox has a color variable for the text color & uses
	// reflected notification. Glossing uses navText's colour, but target text's font.
	if (gbIsGlossing)
		pApp->m_pTargetBox->m_textColor = pApp->m_navTextColor;
	else
		pApp->m_pTargetBox->m_textColor = pApp->m_targetColor;
}

CPile* CAdapt_ItView::GetNextPile(const CPile *pPile)
// returns a pointer to the next pile, or NULL if there is none
{
	CPile* pNextPile;
	CStrip* pStrip = pPile->m_pStrip;
	CSourceBundle* pBundle = pStrip->m_pBundle;
	int nCurPile = pPile->m_nPileIndex;
	int nPileCount = pStrip->m_nPileCount;
	if (nCurPile < nPileCount - 1)
	{
		// there is a next pile in the current strip
		nCurPile++;
		pNextPile = pStrip->m_pPile[nCurPile];
	}
	else
	{
		// next pile is in next strip, so get it from there, provided there is a next strip
		int nCurStrip = pStrip->m_nStripIndex;
		nCurStrip++; // the next strip
		int nStripCount = pBundle->m_nStripCount;
		if (nCurStrip > nStripCount - 1)
		{
			return (CPile*)0; // there is no next pile to be had
		}
		else
		{
			pStrip = pBundle->m_pStrip[nCurStrip];
			pNextPile = pStrip->m_pPile[0]; // can only be the first one in the strip
		}
	}
	return pNextPile;
}

CCell* CAdapt_ItView::GetNextCell(const CCell *pCell, const int cellIndex)
// returns the next cell at the level specified by cellIndex (note: switching levels is allowed
// because we only care about the level of the cell in the next pile), or returns NULL if
// there is no next pile (and hence no next cell)
{
	CPile* pPile = pCell->m_pPile;
	pPile = GetNextPile(pPile);
	if (pPile == 0)
		return (CCell*)0;
	else
		return pPile->m_pCell[cellIndex];
}

CPile* CAdapt_ItView::GetPile(const int nSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList = pApp->m_pSourcePhrases;
	if (pList->GetCount() == 0)
		return NULL;

	int nCount = pList->GetCount();
	wxASSERT(nCount != 0);
	CPile* pPile;
	// version 2.4.0 added second test, else inserting to the end would crash ScrollIntoView()
	if (nSequNum == -1 || nSequNum >= nCount)
		return (CPile*)0; // we are at EOF, so can't return a pile pointer
	SPList::Node* pos = pList->Item(nSequNum);
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase != NULL); 
	bool bFirstTry = TRUE;

	// now scan the strips and their piles to find a matching pSrcPhrase pointer
a:	CSourceBundle* pBundle = pApp->m_pBundle;
	wxASSERT(pBundle);

	pPile = pBundle->m_pStrip[0]->m_pPile[0]; // first pile (sequ num could be 0, or >0
											  // if advanced bundle)
	CSourcePhrase* pSP;

	// check if its the first one, if not, then loop to find which it is
	pSP = pPile->m_pSrcPhrase;
	if (pSP == pSrcPhrase)
		return pPile; // its the first one

	bool bFound = FALSE;
	do {
		pPile = GetNextPile(pPile);
		if (pPile == NULL)
		{
			// we are at the end, without a match, so break out
			break;
		}
		else
		{
			pSP = pPile->m_pSrcPhrase;
			if (pSP == pSrcPhrase)
			{
				bFound = TRUE;
				break;
			}
		}

	} while (TRUE);

	// this bundle might be distant from where the active location is wanted, hence
	// if we didn't find the source phrase, we must advance the bundle and try again
	if (!bFound && bFirstTry)
	{
		bFirstTry = FALSE;
		AdvanceBundle(nSequNum); // this makes a recursive GetPile() call, but it should find
								 // pPile on the first iteration, and hence not loop infinitely,
								 // because AdvanceBundle calculates indices which put the active
								 // location within the bundle
		goto a;
	}


	if (bFound)
		return pPile;
	else
		return (CPile*)0;
}

void CAdapt_ItView::SetupPhraseBoxParameters(CPile *pActivePile)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	pApp->m_nActiveSequNum = pActivePile->m_pSrcPhrase->m_nSequNumber;
	if (pApp->m_targetPhrase.IsEmpty())
	{
		pApp->m_curBoxWidth = pActivePile->m_nWidth;
	}
	else
	{
		// current pApp->m_curBoxWidth value will be used
	}
	pApp->m_nStartChar = gnStart;
	pApp->m_nEndChar = gnEnd;
	pApp->m_curIndex = pApp->m_nActiveSequNum;
	pApp->m_ptCurBoxLocation = pActivePile->m_pCell[2]->m_ptTopLeft;
}

CPile* CAdapt_ItView::GetPrevPile(const CPile *pPile)
// returns the previous pile, or NULL if there is no previous one
{
	CPile* pPrevPile;
	CStrip* pStrip = pPile->m_pStrip;
	CSourceBundle* pBundle = pStrip->m_pBundle;
	int nCurPile = pPile->m_nPileIndex;
	if (nCurPile > 0)
	{
		// there is a previous pile in the current strip
		nCurPile--;
		pPrevPile = pStrip->m_pPile[nCurPile];
	}
	else
	{
		// prev pile is in previous strip, so get it from there
		int nCurStrip = pStrip->m_nStripIndex;
		nCurStrip--; // the previous strip
		if (nCurStrip < 0)
			return (CPile*)0;
		pStrip = pBundle->m_pStrip[nCurStrip];
		int nPileCount = pStrip->m_nPileCount;
		nCurPile = nPileCount-1; // index of last pile in the strip
		pPrevPile = pStrip->m_pPile[nCurPile];
	}
	return pPrevPile;
}

void CAdapt_ItView::LayoutStrip(SPList *pSrcPhrases, int nStripIndex, CSourceBundle *pBundle)
{
	SPList* pSrcList = pSrcPhrases;
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	int fwidth;
	int fheight;
	// wx note: calling GetClientSize on the canvas produced different results in wxGTK and
	// wxMSW, so I'll use my own GetCanvasClientSize() which calculates it from the main frame's
	// client size.
	wxSize canvasSize;
	canvasSize = pApp->GetMainFrame()->GetCanvasClientSize();
	fwidth = canvasSize.x;
	fheight = canvasSize.y;
	int nViewWidth = fwidth; //fwidth will be one pixel more than viewRect.GetRight()

	//  we set m_docSize.cx depending
	// on whether strip-wrap is on (width is tied to client area width), or off (width is tied to
	// screen width) - later in this function the .cy member gets set, after all the strips are
	// laid out -- version 2.4.0, removes test since we always wrap to fit the window size
	pApp->m_docSize.SetWidth(nViewWidth - RH_SLOP); // RH_SLOP is currently 40,

	// set the pile height value
	if (gbShowTargetOnly)
	{
		if (gbIsGlossing)
		{
			if (gbGlossingUsesNavFont)
				pApp->m_curPileHeight = pApp->m_nNavTextHeight;
			else
				pApp->m_curPileHeight = pApp->m_nTgtHeight;
		}
		else
			pApp->m_curPileHeight = pApp->m_nTgtHeight;
	}
	else
	{
		pApp->m_curPileHeight =
			SetPileHeight(MAX_CELLS,pApp->m_nSrcHeight,pApp->m_nTgtHeight,pApp->m_nNavTextHeight,
													pApp->m_bSuppressFirst,pApp->m_bSuppressLast);
	}

	// get a device context, and get the origin adjusted
	wxClientDC viewDC(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(viewDC); // adjust origin
	canvas->pFrame->PrepareDC(viewDC); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame

	int		nVertOffset;
	int		nLastSequNumber;
	int		nEndIndex;
	wxASSERT(pBundle->m_nStripCount > 0);

	// if the nStripIndex value is non-zero, then we must find the sequNumber of the last srcPhrase
	// in the preceding strip, as the next one will be first in the strip to be re-laid out; but if
	// it is zero then we use a -1 value as there is no previous strip in this case
	if (nStripIndex > 0)
	{
		CPile* pPile = pBundle->m_pStrip[nStripIndex]->m_pPile[0]; // first in stuff to be deleted
		pPile = GetPrevPile(pPile); // last in previous strip (can assume pPile will be non null)
		wxASSERT(pPile != NULL);
		int nLastStrip = nStripIndex -1;
		CStrip* pLastStrip = pBundle->m_pStrip[nLastStrip];
		nVertOffset = pLastStrip->m_nVertOffset; // offset to bottom of last strip
		nLastSequNumber = pPile->m_pSrcPhrase->m_nSequNumber;
	}
	else
	{
		// we are doing the beginning strip
		nVertOffset = 0;
		nLastSequNumber = pApp->m_beginIndex-1; // this will be -1 if starting from beginning
		nLastSequNumber = -1;
	}
	pBundle->m_nStripIndex = nStripIndex;

	// get how many piles in this strip - we'll keep that many only, no more or less, even if
	// blanks in the target lines mean that there is room left for more; so we will set an
	// artificial nEndIndex value to prevent extra unwanted piles being created in any free space
	// at the end

// **** ACTUALLY,
	// the assumption that the number of piles in the strip will remain constant in all contexts
	// where we would want to use LayoutStrip() is a false assumption. Editing can flip piles back
	// to the end of the last strip, or to the start of the next; which invalidates this
	// assumption. This assumption then resulted in occasional errors in the layout & crashes,
	// etc; I fixed this by replacing most LayoutStrip() calls with RecalcLayout() calls with the
	// second parameter = 0 (layout from first strip every time), which of course results in a
	// flashing screen when too many layout adjustments are done in a short space of time. What I
	// should have done was to take the time to fix the code here in LayoutStrip() - probably I
	// should just allow the strip being recalculated to be filled to the end, rather than assume
	// the pile count will not have changed.  -- actually, I think I improved it later on, but I
	// forget where...
//	*************************************************

	int count = pBundle->m_pStrip[nStripIndex]->m_nPileCount;
	nEndIndex = nLastSequNumber + count;

	// destroy the strip
	pBundle->m_pStrip[nStripIndex]->DestroyPiles();
	delete pBundle->m_pStrip[nStripIndex];
	pBundle->m_pStrip[nStripIndex] = (CStrip*)NULL;

	//	LockWindowUpdate(); // prevent updates till we are done -- comment out, the Unlock creates
	// a bad flicker for a deletion which is done by a press of backspace key

	nVertOffset = CreateStrip(&viewDC,pSrcList,nVertOffset,nLastSequNumber,nEndIndex);
	pBundle->m_pStrip[pBundle->m_nStripIndex]->m_nVertOffset = nVertOffset; // store its offset
	pBundle->m_pStrip[pBundle->m_nStripIndex]->m_nStripIndex = pBundle->m_nStripIndex; // store
																					   // index
//	UnlockWindowUpdate();

	// update, including the leading area
	// the height by m_curLeading too. Adjusting the top of an MFC CRect increases/decreases the height
	// at the same time; but with wxWidgets' wxRect adjusting the top maintains the rects size (height) and
	// just moves it. So we need to also explicitly adjust the height of the wxRect.
	wxRect rectInvalid = pBundle->m_pStrip[pBundle->m_nStripIndex]->m_rectStrip;
	// whm: the wx version doesn't use negative offsets
	rectInvalid.SetTop(rectInvalid.GetTop() - pApp->m_curLeading);
	// decreasing the top value increases the height of rectInvalid, so increase wxRect's height too
	rectInvalid.SetHeight(rectInvalid.GetHeight() + pApp->m_curLeading); // whm added for wxRect
	InvalidateRect(rectInvalid); // our own
}

void CAdapt_ItView::DoSrcPhraseSelCopy()
// Modified to handle glossing or adapting
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCellList* pCellList = &pApp->m_selection; // get a local pointer
	wxString str; // accumulate the words / phrases here
	str.Empty();
	CCellList::Node* pos = pCellList->GetFirst();
	if (pos == NULL)
		return;
	if (pApp->m_selectionLine == 0 || pApp->m_selectionLine == 1)
	{
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData();
			pos = pos->GetNext();
			if (pCell == NULL)
				return;
			CSourcePhrase* pSrcPhrase = pCell->m_pPile->m_pSrcPhrase;
			wxASSERT(pSrcPhrase != NULL);

			if (pCell->m_pPile == pApp->m_pActivePile)
			{
				if (!pApp->m_targetPhrase.IsEmpty())
				{
					if (!pApp->m_targetPhrase.IsEmpty())
					{
						if (str.IsEmpty())
							str = pApp->m_targetPhrase;
						else
							str += _T(" ") + pApp->m_targetPhrase;
					}
				}
			}
			else
			{
				if (str.IsEmpty())
				{
					if (gbIsGlossing)
					{
						if (!pSrcPhrase->m_gloss.IsEmpty())
							str = pSrcPhrase->m_gloss;
					}
					else
					{
						if (!pSrcPhrase->m_targetStr.IsEmpty())
							str = pSrcPhrase->m_targetStr;
					}
				}
				else
				{
					if (gbIsGlossing)
					{
						if (!pSrcPhrase->m_gloss.IsEmpty())
							str += _T(" ") + pSrcPhrase->m_gloss;
					}
					else
					{
						if (!pSrcPhrase->m_targetStr.IsEmpty())
							str += _T(" ") + pSrcPhrase->m_targetStr;
					}
				}
			}
		}
	}
	else
		return;

	if (wxTheClipboard->Open())
	{
		// This data objects are held by the clipboard,
		// so do not delete them in the app.
		// SetData clears all previous contents in the clipboard
		// so there is no need to call Clear
		wxTheClipboard->SetData( new wxTextDataObject(str) );
		wxTheClipboard->Close();
	}
	else
	{
		wxMessageBox( _("Cannot open the Clipboard"), _T(""), wxICON_EXCLAMATION);
		return;
	}
}

void CAdapt_ItView::DoTargetBoxPaste(CPile* pPile)
// Modified to handle glossing or adapting
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	gbByCopyOnly = FALSE; // set this flag FALSE, so text put in the box won't be thrown away if
						  // user subsequently clicks to place box elsewhere without doing anything
						  // in the phrase box first
	wxString pasteStr;

	// In wx we'll use the clipboard GetData function directly
	if (wxTheClipboard->Open())
	{
		if (wxTheClipboard->IsSupported( wxDF_TEXT ))
		{
			wxTextDataObject data;
			wxTheClipboard->GetData( data );
			pasteStr = data.GetText();
		}
		wxTheClipboard->Close();
	}

	// if consistent changes is turned on, the user must be given the option of having the
	// changes applied or not applied, since we cannot assume that the text to be pasted was
	// not copied from source text (if it was, the changes should be applied)
	wxString insertionText = pasteStr;
	wxASSERT( !(gpApp->m_bUseConsistentChanges && gpApp->m_bUseSilConverter) ); // can't be both TRUE
	if (pApp->m_bUseConsistentChanges)
    {
		//IDS_ASK_USE_CC
        if( wxMessageBox(_("Do you wish consistent changes to be applied to the text to be pasted?"),_T(""),wxYES_NO) == wxYES )
		{
			insertionText = DoConsistentChanges(pasteStr);
		}
    }
    else if( gpApp->m_bUseSilConverter )
    {
		// IDS_ASK_USE_SILCONVERTER
        if( wxMessageBox(_("Do you wish the configured SILConverter to be applied to the text to be pasted?"),_T(""),wxYES_NO) == wxYES )
	    {
		    insertionText = DoSilConvert(pasteStr);
	    }
    }

	// if there is a text selection in the current targetBox, erase the selected chars, then get
	// its text and the caret offset - this is where pasteStr must be inserted
	// wx Note: MFC's CEdit::Clear() deletes (clears) the current selection (if any) in the
	// edit control. wxTextCtrl::Clear() "clears the text in the control, and generates
	// a wxEVT_COMMAND_TEXT_UPDATED event." I'll first check for any existing selection by calling
	// GetStringSelection. If GetStringSelection isn't empty we know there is a selection. If so,
	// then use wxTextCtrl's Remove() method to only remove the selection.
	long nS, nE;
	if (!pApp->m_pTargetBox->GetStringSelection().IsEmpty()) // whm added to only Remove any selected text
	{
		pApp->m_pTargetBox->GetSelection(&nS,&nE);
		pApp->m_pTargetBox->Remove(nS,nE); //m_targetBox.Clear();
	}
	long nStart; long nEnd;
	pApp->m_pTargetBox->GetSelection(&nStart,&nEnd);
	wxString targetPhrase;
	targetPhrase = pApp->m_pTargetBox->GetValue();
	wxString saveStr = targetPhrase; // make a copy in case we later have to abort the operation

	// BEW added 18July08, to support leaving cursor at paste location (see Roland Fumey request below)
	int pasteStrLength = insertionText.Length();

	// insert the insertionText into the targetStr at the desired location
	// wxString doesn't have an Insert method, so we'll do it with our own InsertInString (see helpers.h)
	targetPhrase = InsertInString(targetPhrase,(int)nStart,insertionText); //targetPhrase.Insert((int)nStart,insertionText);

	// if there was a selection in lines 1 or 2, we will honour the assumed intent to merge
	// first, and then the pasted stuff will be assumed to be its adaptation; however, if the
	// selection is too long, we will just remove it (not do Retranslation instead as in OnChar)
	// Do the next block only if glossing is OFF, if it is on, we don't allow a merge and
	// so proceed to the 'else' block
	int nSaveSequNum = pPile->m_pSrcPhrase->m_nSequNumber;
	if (!gbIsGlossing && pApp->m_selection.GetCount() > 1 && pApp->m_selection.GetCount() <= MAX_WORDS
									&& pApp->m_pActivePile == pApp->m_pAnchor->m_pPile)
	{
		// if we selected backwards, we have to be careful - we want nSaveSequNum to be first
		// pile of the selection, so check it out now & if necessary adjust nSaveSequNum
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = (CCell*)cpos->GetData();
		wxASSERT(pCell != NULL);
		CPile* pFirstPile = pCell->m_pPile;
		int nFirstSequNum = pFirstPile->m_pSrcPhrase->m_nSequNumber;
		if (nFirstSequNum < nSaveSequNum)
			nSaveSequNum = nFirstSequNum;

		// do the merge
		bSuppressDefaultAdaptation = TRUE; // the global BOOLEAN for temporary suppression only
		MergeWords();
		bSuppressDefaultAdaptation = FALSE;

		// restore the clobbered pointers
		pPile = GetPile(nSaveSequNum);
		pApp->m_pActivePile = pPile;
		pApp->m_pTargetBox->m_pActivePile = pPile;
	}
	else
	{
		// if there is a selection, but the anchor is removed from the active location, we don't
		// want to make a phrase elsewhere, so just remove the selection; or if glossing is ON
		RemoveSelection();
	}

	// the following code is copied and adapted from PlacePhraseBox. We have to recreate the
	// box after measuring the text, because the existing box is almost certainly too small
	// and it will reject any characters it cannot fit in. Note, this code would fail if we
	// try to paste too much text, so we accept the text for pasting only if its extent fits within
	// a strip's width - if not, clear the text & give a warning message, but allow any merge.

	// we now allow punctuation in the phrase box, since MoveToNextPile & MoveToPrevPile will now
	// call MakeLineFourString so as to allow any punct etc. the user has typed

	// nOldStripIndex unused
	//int nOldStripIndex = pPile->m_pStrip->m_nStripIndex; // the strip we are in (we may be thrown
	//													 // to the next strip if the text is long,
	//													 // or to the previous strip if the text is
	//													 // short & we are at the end of the strip)

	// remove any existing selection, it would be a confusion if left there
	RemoveSelection();

	// setup the phrase box at the same location, but with new size (probably)
	CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;
	wxASSERT(pSrcPhrase != NULL);
	pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
	wxASSERT(pApp->m_nActiveSequNum >= 0);

	// set initial location of the phraseBox (it may be changed when we call RecalcLayout)
	pApp->m_ptCurBoxLocation = pPile->m_pCell[2]->m_ptTopLeft;

	// calculate the box's horz extent - will be pileWidth if the string is empty, else we should
	// measure the cell's text & add some slop; if the text extent is less than the pile
	// width, use the pile's current min width instead.
	pApp->m_nCurPileMinWidth = pPile->m_nMinWidth; // this is the pile's text-extent-based min width
	wxClientDC aDC(pApp->GetMainFrame()->canvas);
	wxFont* pFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pFont = pApp->m_pNavTextFont;
	else
		pFont = pApp->m_pTargetFont;
	aDC.SetFont(*pFont);

	int strWidth;
	int strDummyHeight;
	aDC.GetTextExtent(targetPhrase, &strWidth, &strDummyHeight);
	int charWidth;
	int charDummyHeight;
	wxString aChar = _T('w');
	aDC.GetTextExtent(aChar,&charWidth, &charDummyHeight);
	int width = strWidth + gnExpandBox*charWidth;
	pApp->m_nCurPileMinWidth = width <= pApp->m_nCurPileMinWidth ? pApp->m_nCurPileMinWidth : width;
	pApp->m_curBoxWidth = pApp->m_nCurPileMinWidth;

	// use the targetPhrase text only if the resulting phrase box can fit within a single strip
	CStrip* pStrip = pPile->m_pStrip;
	int stripWidth = pStrip->m_rectStrip.GetWidth(); 
	wxASSERT(stripWidth > 0);
	if (width >= stripWidth)
	{
		// it won't fit within a strip, so try to get out of this fix gracefully
		pApp->m_targetPhrase = saveStr;
		// IDS_PASTE_TEXT_TOO_LONG
		wxMessageBox(_("Sorry, the paste operation resulted in text which exceeded the maximum width of a strip, so the operation was aborted."),_T(""),wxICON_EXCLAMATION); // warn user
	}
	else
	{
		pApp->m_targetPhrase = targetPhrase;
	}
	// Roland Fumey (18July08) said this is unhelpful, rather we should leave the cursor at
	// the paste location - so I've commented out the next line and set the offsets to
	// comply with his request
	//gpApp->m_nStartChar = 0; gpApp->m_nEndChar = -1; // make sure the text is shown selected
	gpApp->m_nStartChar = nStart + pasteStrLength;
	gpApp->m_nEndChar = gpApp->m_nStartChar;

	// wx Note: we don't destroy the target box, just set its text to null
	pApp->m_pTargetBox->SetValue(_T(""));

	// recalculate the layout
	RecalcLayout(pApp->m_pSourcePhrases,0 /* nOldStripIndex unsafe if bundle contracts */,pApp->m_pBundle);

	// if a phrase jumps back on to the line due to the recalc of the layout, then the
	// current location for the box will end up too far right, so we must find out where the
	// active pile now is and reset m_ptCurBoxLocation before calling ResizeBox, so
	// recalculate the active pile pointer (old was clobbered by the RecalcLayout call)
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);
	pApp->m_pTargetBox->m_pActivePile = pApp->m_pActivePile; // put copy in the CPhraseBox too
	pApp->m_ptCurBoxLocation = pApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	// do a scroll if needed
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	// recreate the box window
	pApp->m_curBoxWidth = RecalcPhraseBoxWidth(pApp->m_targetPhrase); // recalc, since the pasted text might
														  // be shorter
	pApp->m_nCurPileMinWidth = pApp->m_curBoxWidth; // update this too, so box can be shorter if necessary
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nNavTextHeight,pApp->m_targetPhrase,
													pApp->m_nStartChar,pApp->m_nEndChar,pApp->m_pActivePile);
		// set the color - CPhraseBox has a color variable & uses reflected notification
		pApp->m_pTargetBox->m_textColor = pApp->m_navTextColor;
	}
	else
	{
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nTgtHeight,pApp->m_targetPhrase,
													pApp->m_nStartChar,pApp->m_nEndChar,pApp->m_pActivePile);
		// set the color - CPhraseBox has a color variable & uses reflected notification
		pApp->m_pTargetBox->m_textColor = pApp->m_targetColor;
	}

	pApp->m_pTargetBox->SetModify(FALSE); //calls our own SetModify(FALSE) which calls DiscardEdits() (see Phrasebox.cpp)

	Invalidate();
}

int CAdapt_ItView::RecalcPhraseBoxWidth(wxString& phrase)
// a sudden change in the m_targetPhrase's length (eg. due to a paste into the phrase box) and
// a subsequent RecalcLayout() call, would not allow the box to be smaller than its previous
// value; so RecalcPhraseBoxWidth() can be called wherever the potential for a resizing of the box
// is called for, (and m_nCurPileMinWidth needs to be set to the returned value in the caller too)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxClientDC dc(pApp->GetMainFrame()->canvas);
	wxClientDC* pDC = &dc;
	int pileWidth;
	int dummyHeight;
	wxFont* pTheFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pTheFont = pApp->m_pNavTextFont;
	else
		pTheFont = pApp->m_pTargetFont;
	pDC->SetFont(*pTheFont);
	pDC->GetTextExtent(phrase,&pileWidth, &dummyHeight);
	wxString aChar = _T('w');
	int charWidth;
	int charDummyHeight;
	pDC->GetTextExtent(aChar,&charWidth,&charDummyHeight);
	pileWidth += gnExpandBox*charWidth; // allow same slop factor as for RemakePhraseBox & OnChar

	return pileWidth;
}

void CAdapt_ItView::PlacePhraseBox(const CCell *pCell, int selector)
// selector values: used for inhibiting one or both of two blocks of code. The first block
// should be done only when the user has clicked elsewhere after being in a former location,
// since the first block saves the adaptation text left in the former phrase box's location.
// The second block removes the adaptation text from the KB when the focus has moved to the new
// location clicked. It is not appropriate to do this code when returning from being in a dialog
// such as Choose Translation, since the adaptation text will already have been removed before
// the dialog was entered, so selector = 1 inhibits this block. The other two possible situations,
// a normal click (selector = 0), or the target box was previously not at any location - as when
// the user has just opened a saved document file, it is essential to remove the adaption text
// from the phrase box's location, so that when the user hits RETURN to move on, the store will
// be re-done and the ASSERT in start of StoreText function will not trip; so a selector
// value of 2 is used for this case. That is, selector = 0 enables both blocks to be done,
// selector = 1 disables both blocks, and selector = 2 disables the first block but enables the
// second block.
// BEW added 27Jun05, For version 3, free translation support requires we can enable the first block
// and disable the second block, so for this combination we will use a selector value of 3.
// For version 2.0, which supports glossing, the function will test the gbIsGlossing flag in a
// number of places; these changes will increase the complexity of an already complex function,
// but it is better than having a separate glossing version which would bloat the app's size
// Ammended, July 2003, for auto-capitalization support
{
	// if there is no active pile defined, construct one at the clicked location
	if (gpApp->m_pActivePile == NULL)
	{
		int sequNum = pCell->m_pPile->m_pSrcPhrase->m_nSequNumber;
		gpApp->m_pActivePile = GetPile(sequNum);
	}
	gbEnterTyped = FALSE; // ensure its false, only hitting ENTER key should set it TRUE
	wxASSERT(pCell);
	if (pCell->m_nCellIndex != 2)
	{
		gSaveTargetPhrase = gpApp->m_targetPhrase; // an adaptation, or a gloss, depending on mode
		return;
	}
	CAdapt_ItDoc* pDoc = GetDocument();
	pDoc->Modify(TRUE);

	// if auto capitalization is on, determine the source text's case propertiess
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		if (gpApp->m_pActivePile == NULL)
		{
			// active location is undefined because we are at the end of the document
			bNoError = FALSE;
		}
		else
		{
			bNoError = SetCaseParameters(gpApp->m_pActivePile->m_pSrcPhrase->m_key);
		}
	}

	// Also inhibit if it is a
	// "<Not In KB>" location where there is something in the phrase box but the m_bSaveToKB
	// flag is still off (FALSE) - but only provided we are in adapting mode
	if (!(gpApp->m_nActiveSequNum == -1)) // can't do this if there is no active pile currently
								   // in existence
	{
		// if it's an <Not In KB> entry, clear the target phrase etc.
		// - from version 1.4.0 and onwards, by Susanna Imrie's suggestion, we allow the document
		// to have a non null adaptation even when <Not In KB> has been chosen; so we don't clear,
		// but we do the check to fix a wrongly edited adaption KB. This check is required only
		// for gbIsGlossing == FALSE, since the glossing KB knows nothing of <Not In KB> behaviour
		// BEW added to test 23Jul05, since m_bNotInKB is also true for retranslations and when in free
		// translation mode if we don't exclude retranslations then <Prev, Next> or Advance buttons,
		// if they land the box in a retranslation, the phrase box text that get's set up is the old
		// location's adaptation, not to mention a spurious save of <Not In KB> to the KB as well.
		if (!gbIsGlossing && gpApp->m_pActivePile && !gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry
			&& gpApp->m_pActivePile->m_pSrcPhrase->m_bNotInKB && !gpApp->m_pActivePile->m_pSrcPhrase->m_bRetranslation)
		{
			// in case we did a "Find" and ended up at this particular pile and no targetBox
			// window is in existence, detect this & goto b because no save is possible, and
			// otherwise the SetWindowText call would fail as well
			// WX Note: There is no ::IsWindow() equivalent in wxWidgets
			//if (!::IsWindow((HWND)gpApp->m_targetBox.GetHandle()))
			//	goto b;
			//	whm note: 12Aug08. In the wx version the target box is never NULL.
			//	TODO: The fact that the target box is never null, may have side effects since
			//	the code below the goto b jump below will always occur even in a Find operation.
			//	I have a hard time with unconditional goto x statements so I think Bruce will 
			//	need to evgentually check the logic here down to the next goto b block below
			//	after the "if (gbAutoCaps)" block to see if they should always be executed even
			//	after a Find operation.
			if (gpApp->m_pTargetBox == NULL)
				goto b;

			// in case the user edited out the <Not In KB> entry from the KB editor, we need to
			// put it back so that the setting is preserved (the "right" way to change the setting
			// is to use the toolbar checkbox)
			wxString str = _T("<Not In KB>");
			CRefString* pRefStr = GetRefString(gpApp->m_pKB,
				gpApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,gpApp->m_pActivePile->m_pSrcPhrase->m_key,str);
			if (pRefStr == NULL)
			{
				gpApp->m_bSaveToKB = TRUE;	// it will be off, so we must turn it back on to get the
											// string restored
				bool bOK;
				bOK = StoreText(gpApp->m_pKB,gpApp->m_pActivePile->m_pSrcPhrase,str);
				// set the flags to ensure the asterisk shows above the pile, etc.
				gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
				gpApp->m_pActivePile->m_pSrcPhrase->m_bNotInKB = TRUE;
			}

			// from v 1.4.0 and onwards we will have to set up the punctuated line
			wxString str1 = gpApp->m_targetPhrase;
			RemovePunctuation(pDoc,&str1,1 /*from tgt*/);
			if (gbAutoCaps)
			{
				if (bNoError && gbSourceIsUpperCase && !gbMatchedKB_UCentry)
				{
					bNoError = SetCaseParameters(str1,FALSE);
					if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
					{
						// a change to upper case is called for
						str1.SetChar(0,gcharNonSrcUC);
					}
				}
			}
			gpApp->m_pActivePile->m_pSrcPhrase->m_adaption = str1;
			MakeLineFourString(gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
			goto b;
		}

		// inhibit the save, if we are here not from a click to a new location, eg. as when
		// having exited from the Choose Translation dialog having forced it to show - because
		// when the latter happens, this would be the second time this function is entered for
		// this phrase box location, and so we don't need to do a save.
		// BEW changed 27Jun05, for free translation support - added test for selector == 3
		if (selector == 0 || selector == 3)
		{
			// user has not typed anything at the new location yet
			gpApp->m_bUserTypedSomething = FALSE;

			// make sure gpApp->m_targetPhrase doesn't have any final spaces
			RemoveFinalSpaces(gpApp->m_pTargetBox,&gpApp->m_targetPhrase);

			// any existing phraseBox text must be saved to the KB, unless its empty
			if (!gpApp->m_targetPhrase.IsEmpty())
			{
				if (gpApp->m_pTargetBox->IsModified()) // MFC GetModify()
				{
					if (gpApp->m_pTargetBox->m_bAbandonable)
					{
						// if abandonable, then we want a placement click to throw away
						// the text in the box; which will make the store operation do no store
						gpApp->m_targetPhrase.Empty();
						gpApp->m_pTargetBox->SetValue(_T(""));
					}
					else
					{
						// its not empty, not abandonable (text), and has been modified, so
						// do nothing - the storage operation below will then store the text
						; // formerly, relic code to display the empty adapt dialog was here
					}
				}

				// it has to be saved to the relevant KB now
				if (!gpApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
				{
					if (gbIsGlossing)
					{
						// the store will fail if the user edited the entry out of the glossingKB, as
						// the latter cannot know which srcPhrases will be affected, so these will
						// still have their m_bHasKBEntry set true. We have to test for this, ie. a
						// null pRefString but the above flag TRUE is a sufficient test, and if so,
						// set the flag to FALSE
						CRefString* pRefStr = GetRefString(gpApp->m_pGlossingKB, 1,
							gpApp->m_pActivePile->m_pSrcPhrase->m_key, gpApp->m_targetPhrase);
						if (pRefStr == NULL && gpApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry)
							gpApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
						bool bOK;
						bOK = StoreText(gpApp->m_pGlossingKB,gpApp->m_pActivePile->m_pSrcPhrase,
													gpApp->m_targetPhrase);
					}
					else
					{
						MakeLineFourString(gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
						RemovePunctuation(pDoc,&gpApp->m_targetPhrase,1 /*from tgt*/);

						// the store will fail if the user edited the entry out of the KB, as the
						// latter cannot know which srcPhrases will be affected, so these will still
						// have their m_bHasKBEntry set true. We have to test for this, ie. a null
						// pRefString but the above flag TRUE is a sufficient test, and if so, set
						// the flag to FALSE
						CRefString* pRefStr = GetRefString(gpApp->m_pKB,
							gpApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
							gpApp->m_pActivePile->m_pSrcPhrase->m_key,gpApp->m_targetPhrase);
						if (pRefStr == NULL && gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
							gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
						gbInhibitLine4StrCall = TRUE;
						bool bOK;
						bOK = StoreText(gpApp->m_pKB,gpApp->m_pActivePile->m_pSrcPhrase,
													gpApp->m_targetPhrase);
						gbInhibitLine4StrCall = FALSE;
					}
				}
			}
			else
			{
				// gpApp->m_targetPhrase is empty, so let StoreText handle what needs to happen.
				bool bOK = FALSE;
				if (gbIsGlossing)
				{
					gpApp->m_pActivePile->m_pSrcPhrase->m_gloss = gpApp->m_targetPhrase;

					// store will fail if the user edited the entry out of the glossing KB, since it
					// cannot know which srcPhrases will be affected, so these will still have their
					// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString but
					// the above flag TRUE is a sufficient test, and if so, set the flag to FALSE
					CRefString* pRefStr = GetRefString(gpApp->m_pGlossingKB, 1,
						gpApp->m_pActivePile->m_pSrcPhrase->m_key,gpApp->m_targetPhrase);
					if (pRefStr == NULL && gpApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry)
						gpApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
					bOK = StoreText(gpApp->m_pGlossingKB,gpApp->m_pActivePile->m_pSrcPhrase,
																				gpApp->m_targetPhrase);
				}
				else // is adapting
				{
					gpApp->m_pActivePile->m_pSrcPhrase->m_adaption = gpApp->m_targetPhrase;
					MakeLineFourString(gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);	// punctuation is
																									// re-expressed
					RemovePunctuation(pDoc,&gpApp->m_targetPhrase, 1 /*from tgt*/);

					// the store will fail if the user edited the entry out of the KB, as the latter
					// cannot know which srcPhrases will be affected, so these will still have their
					// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString but
					// the above flag TRUE is a sufficient test, and if so, set the flag to FALSE
					CRefString* pRefStr = GetRefString(gpApp->m_pKB,
						gpApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
						gpApp->m_pActivePile->m_pSrcPhrase->m_key,gpApp->m_targetPhrase);
					if (pRefStr == NULL && gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
						gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
					gbInhibitLine4StrCall = TRUE;
					bOK = StoreText(gpApp->m_pKB,gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
					gbInhibitLine4StrCall = TRUE;
				}

				// check for a failure, abandon the function if the store failed
				if (!bOK)
				{
					// we must restore the box's selection to what it was earlier before returning
					gpApp->m_pTargetBox->SetFocus();
					gpApp->m_pTargetBox->SetSelection(gpApp->m_nStartChar,gpApp->m_nEndChar);
					gnStart = gpApp->m_nStartChar;
					gnEnd = gpApp->m_nEndChar;
					gSaveTargetPhrase = gpApp->m_targetPhrase;
					return;
				}
			}
		} // end block for selector equals 0 or 3
	}

	// honour the click, but first preserve which strip we were in, in case we click on a cell
	// in a different strip, then we'll have to update the old strip too
b:	int nOldStripIndex;
	if (gpApp->m_curIndex == -1 || gpApp->m_nActiveSequNum == -1 || gpApp->m_pActivePile == NULL)
	{
		// we are at EOF, so active pile is not valid, so set old strip index using the
		// bundle's members
		nOldStripIndex = gpApp->m_pBundle->m_nStripCount - 1;
	}
	else
	{
		// we are not at the end, so m_pActivePile is valid so can use it to set the old strip
		// index value
		nOldStripIndex = gpApp->m_pActivePile->m_pStrip->m_nStripIndex;
	}

	CPile* pActivePile = pCell->m_pPile;	wxASSERT(pActivePile);

	// remove any existing selection
	RemoveSelection();

	// setup the phrase box at the new location
	gpApp->m_pActivePile = pActivePile;
	CSourcePhrase* pSrcPhrase = pActivePile->m_pSrcPhrase;
	wxASSERT(pSrcPhrase);
	gpApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
	wxASSERT(gpApp->m_nActiveSequNum >= 0);
	gpApp->m_curIndex = gpApp->m_nActiveSequNum;

//  uncomment out, for a handy way to check the TextType values at various locations in the doc
//	wxString sss;
//	sss = sss.Format(_T("TextType value: %d\n"),pSrcPhrase->m_curTextType);
//	wxMessageBox(sss);

	// set initial location of the phraseBox
	gpApp->m_ptCurBoxLocation = pActivePile->m_pCell[2]->m_ptTopLeft;

	// calculate the box's horz extent - will be pileWidth if the cell is empty, else we should
	// measure the cell's text & add some slop; if the text extent is less than the pile
	// width, use the pile's current min width instead.
	gpApp->m_nCurPileMinWidth = pActivePile->m_nMinWidth;	// this is the pile's text-extent-based
															// min width
	wxString str; // to hold whatever text we find
	str.Empty();

	bool bHasNothing = FALSE;
	bool bNoValidText = FALSE;
	bool bSomethingIsCopied = FALSE;

	// if we have just chosen an empty adaptation or gloss string in the Choose Translation
	// dialog, then ensure that's what appears in the box; gbEmptyAdaptationChosen will be
	// TRUE if that is how we got here with an empty str
	if (gbEmptyAdaptationChosen)
	{
		gbEmptyAdaptationChosen = FALSE;
		goto a; // str is already empty, so nothing more to do
	}

	// if we are attempting to place the box on a location where the entry is "<Not In KB>", then
	// we do so but adjust the flags to fit this situation; if not, we must ensure that m_bSaveToKB
	// is restored to TRUE from version 1.4.0 onwards - but only provided we are not glossing though.
	// If there is existing adaptation text at the new location, we leave it there (as per Susanna
	// Imrie's suggestion) even when it's a "not in kb" translation
	// BEW added to test 23Jul05 since m_bNotInKB is also true for retranslations and when in free translation
	// mode if we don't exclude retranslations then <Prev, Next> or Advance buttons, if they land the box
	// in a retranslation, the phrase box text that get's set up is the old location's adaptation, not to
	// mention a spurious save of <Not In KB> to the KB as well.
	if (!gbIsGlossing && ((!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB) || IsItNotInKB(pSrcPhrase))
		&& !pSrcPhrase->m_bRetranslation)
	{
		// this ensures user has to explicitly type into the box and explicitly check the checkbox
		// if he wants to override the "not in kb" earlier setting at this location
		gpApp->m_bSaveToKB = FALSE;

		// this ensures the flags are appropriately set, so that an asterisk will show when the
		//placement is complete, if we arrived here due to IsItNotInKB() returning TRUE & the
		// other test FALSE
		pSrcPhrase->m_bHasKBEntry = FALSE;
		pSrcPhrase->m_bNotInKB = TRUE;

		// version 1.4.0 next line is new code
		str = pSrcPhrase->m_adaption;
		goto a;
	}
	else
	{
		// when glossing, permit the save to be done to the glossing KB; but don't change
		// the source phrase's m_bNotInKB value since that only applies when adapting
		gpApp->m_bSaveToKB = TRUE;
	}

	bool bGotOne;
	// BEW added to test, 27Jun05, for free translation support (added selector == 3 test)
	if ((selector == 1 || selector == 3) && !translation.IsEmpty())
	{
		str = translation;
		goto a; // bypass the removal from KB, since if translation is non-empty, it will have
				// been done within code higher up in the current call tree (that's what
				// selector == 1 possibly means in this context)
				// The selector == 3 case is when the last PlacePhraseBox call was just to the
				// start of the bundle's sourcephrase as a temporary placement to force bundle
				// adjustment so a second call can be made after the iterating backwards finishes
	}

	// this block added in support of adaption KB versus glossing KB, to get booleans
	// to control branching in the code lower down
	if (gbIsGlossing)
	{
		if (!pSrcPhrase->m_bHasGlossingKBEntry && !gpApp->m_bCopySource)
			bHasNothing = TRUE;
		if (!pSrcPhrase->m_bHasGlossingKBEntry)
			bNoValidText = TRUE;
		if ((!pSrcPhrase->m_bNullSourcePhrase && gpApp->m_bCopySource) &&
														!pSrcPhrase->m_bHasGlossingKBEntry)
			bSomethingIsCopied = TRUE;
	}
	else // adapting
	{
		if (!pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB && !gpApp->m_bCopySource)
			bHasNothing = TRUE;
		if (!pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB)
			bNoValidText = TRUE;
		if ((!pSrcPhrase->m_bNullSourcePhrase && gpApp->m_bCopySource) &&
																!pSrcPhrase->m_bHasKBEntry)
			bSomethingIsCopied = TRUE;
	}

	// get the auto capitalization parameters for the sourcephrase's key
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pSrcPhrase->m_key);
	}

	if (bHasNothing)
	{
		// there is as yet no translation for this source phrase & no copy from source
		gpApp->m_curBoxWidth = gpApp->m_nCurPileMinWidth;
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		gbByCopyOnly = FALSE;
	}
	else
	{
		// this block is for lookup, merger, and failure to find a KB entry
		gbByCopyOnly = FALSE;
		bGotOne = FALSE;
		if (bNoValidText)
		{
			// BEW added 20Dec07 to prevent lookup when in Reviewing mode (some further comments &
			// supporting code changes are in the blocks below)
			if (gpApp->m_bDrafting)
			{
				bGotOne = gpApp->m_pTargetBox->LookAhead(this,gpApp->m_pActivePile);
			}
			else
			{
				// Reviewing mode, we still need to ensure that if the user cancelled a 
				// Choose Translation merge, then pSrcPhrase will be valid before we proceed
				pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;

				// ensure clicks to a location which is a hole don't, on leaving, result in
				// punctuation being copied from the source text if present there
				if (pSrcPhrase->m_targetStr.IsEmpty() || pSrcPhrase->m_adaption.IsEmpty())
				{
					// no text or punctuation, or no text and punctuation not yet placed,
					// or no text and punctuation was earlier placed -- whichever is the case
					// we need to preserve that state
					gbSavedLineFourInReviewingMode = TRUE; // it gets cleared again at end of MakeLineFourString()
					gStrSaveLineFourInReviewingMode = pSrcPhrase->m_targetStr; // cleared at end of MakeLineFourString()
				}

				gpApp->m_pTargetBox->m_bAbandonable = FALSE;	// don't throw away unedited phrase box contents
																// when the phrase box leaves a location by a click
				// and then make sure we retain the contents in the m_targetStr member of
				// pSrcPhrase, since user is reviewing; but use m_gloss if Glossing mode is on
				if (gbIsGlossing)
					str = pSrcPhrase->m_gloss;
				else
					str = pSrcPhrase->m_targetStr;
			}
			// in Reviewing mode, bGotOne will always be FALSE when control reaches here and so
			// the next block would not be entered - which is fine because in Reviewing mode
			// there is no need to perform a merge when landing on a new pile
			if (bGotOne)
			{
				if (!gbIsGlossing)// do nix here if glossing is on, since glossing disallows merges
				{
					if (!gbCompletedMergeAndMove) // (true means phrase box moved before Choose
					{							  // Translation dialog can be shown, see LookAhead( )
						// do this only if the flag was not set
						gpApp->m_pTargetBox->m_bAbandonable = FALSE;
						if (nWordsInPhrase > 1) // nWordsInPhrase is a global
						{
							// do the needed merge, etc.
							gpApp->bLookAheadMerge = TRUE; // set static flag to ON
							MergeWords();
							gpApp->bLookAheadMerge = FALSE; // restore static flag to OFF
						}
					}
				}
				// if user cancelled a Choose Translation merge, then pSrcPhrase will be invalid,
				// so we have to make sure the pointer is valid before we proceed
				pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;

				// assign the translation text - but check it's not "<Not In KB>", if it is, we
				// leave the phrase box empty, turn OFF the m_bSaveToKB flag, DON'T halt
				// auto-inserting if it is on, (formerly, I made it halt) from v 1.4.0 and onwards,
				// we have to just put default null adaptation there, since a successful lookup of
				// 'not in kb' can't possibly assign any adaptation except null text - unless there
				// already is something on the source phrase - in which case use that
				gpApp->m_pTargetBox->m_bAbandonable = FALSE; // formerly TRUE;
				// if we are glossing, then the global var translation will have the gloss because
				// a successful lookup was done
				if (!gbIsGlossing)
				{
					// if adapting, check for a not in kb entry and if it is, then adjust translation;
					// strictly speaking we only want to clear the string when in Drafting mode, but
					// in Reviewing mode we want to let whatever was formerly there continue unchanged,
					// so a test would be appropriate here if it was not for the fact that above we
					// wrap the LookAhead call in a test of the m_bDrafting flag, and so in Reviewing
					// mode bGodOne remains FALSE and so this current block would not be entered
					if (translation == _T("<Not In KB>"))
					{
						gpApp->m_bSaveToKB = FALSE;
						pSrcPhrase->m_bHasKBEntry = FALSE; // ensures * shows above this srcPhrase
						pSrcPhrase->m_bNotInKB = TRUE;
						if (pSrcPhrase->m_targetStr.IsEmpty())
						{
							translation.Empty(); // clear the global
							gpApp->m_targetPhrase.Empty();
						}
						else
						{
							translation = pSrcPhrase->m_targetStr;
						}
					}
				}
				str = translation; // adapting or glossing, put the final translation into str
			}
		}
		else // there is valid text -- this is typically the case when in Reviewing mode
		{
			// when in Reviewing mode and the user clicks on existing adaptation or gloss text,
			// no lookup is done because bNoValidText is FALSE, and so control will have jumped
			// to the present block. At this point, str is still empty, and so we need here to 
			// ensure that what is at the clicked location is retained, so we set str etc.
			if (!gpApp->m_bDrafting) // ensure we really *are* in Reviewing mode for this stuff
			{
				// Reviewing mode, we still need to ensure that if the user cancelled a 
				// Choose Translation merge, then pSrcPhrase will be valid before we proceed
				pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;

				// ensure clicks to a location which is a hole don't, on leaving, result in
				// punctuation being copied from the source text if present there
				if (pSrcPhrase->m_targetStr.IsEmpty() || pSrcPhrase->m_adaption.IsEmpty())
				{
					// no text or punctuation, or no text and punctuation not yet placed,
					// or no text and punctuation was earlier placed -- whichever is the case
					// we need to preserve that state
					gbSavedLineFourInReviewingMode = TRUE; // it gets cleared again at end of MakeLineFourString()
					gStrSaveLineFourInReviewingMode = pSrcPhrase->m_targetStr; // cleared at end of MakeLineFourString()
				}

				gpApp->m_pTargetBox->m_bAbandonable = FALSE; // don't throw away unedited phrase box contents
													// when the phrase box leaves a location by a click
				// and then make sure we retain the contents in the m_targetStr member of
				// pSrcPhrase, since user is reviewing; but use m_gloss if Glossing mode is on
				if (gbIsGlossing)
					str = pSrcPhrase->m_gloss;
				else
					str = pSrcPhrase->m_targetStr;
			}
		}

		// BEW added to the test 02Nov05, so that when the SplitDialog is active, any use of
		// a button in that dialog which results in a PlacePhraseBox being done (eg. by Jump())
		// will not copy the source text into the phrasebox if the box lands at a hitherto
		// unadapted (or unglossed) location -- so if the document split is then made at that
		// location, it won't save into the KB a spurious copy of the source text as the 'adaptation'
		// at whatever location the box happened to land at. The app setter function SetCurrentSourcePhrase
		// sets and clears the global flag gbIsDocumentSplittingDialogActive to effect this.
		if (!bGotOne && !gbIsDocumentSplittingDialogActive)
		{
			// if user cancelled a Choose Translation merge, then pSrcPhrase will be invalid,
			// so we have to make sure the pointer is valid before we proceed
			pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;

			// BEW added test 20Dec07: Reviewing mode must not copy down source text into holes (ie. we
			// assume the holes are there by choice, and we don't want spurious text to fill them,
			// although the user is free to manually type at such locations if he wishes)
			if (gpApp->m_bDrafting)
			{
				// lookup did not find a suitable adaptation, or gloss if in glossing mode, so we want
				// a copy from the sourcePhrase done instead - but not when in Reviewing mode
				wxString theText;
				if (gbIsGlossing)
					theText = pSrcPhrase->m_gloss;
				else
					theText = pSrcPhrase->m_adaption;
				if (!theText.IsEmpty()) // we want a punctuation-less test here
				{
					if (gbIsGlossing)
					{
						str = theText;
					}
					else // adapting
					{
						if (gpApp->m_bHidePunctuation)
							str = pSrcPhrase->m_adaption; // no punctuation to be shown
						else
							str = pSrcPhrase->m_adaption; // no punctuation to be shown
							// BEW changed 28Apr05, this is a better choice for the box contents
							// than to show punctuation as well - MakeLineFourString() can then
							// be allowed to do its work when the phrase box moves on
							//str = pSrcPhrase->m_targetStr; // show text with punctuation
					}
					gpApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else
				{
					if (bSomethingIsCopied)
					{
						str = CopySourceKey(pSrcPhrase,gpApp->m_bUseConsistentChanges); // and sets
																						// gbByCopyOnly to TRUE
					}
					else // nothing copied, or its a null source phrase, or a null string
					{
						// we didn't do a copy, so we will want whatever eventually results to still
						// be stored later on
						gbByCopyOnly = FALSE;
					}
					// if its a null source phrase, or the copy source flag is turned off,
					// or the user stored a null string as the adaption, we don't show anything
					// - but either way it's abandonable
					gpApp->m_pTargetBox->m_bAbandonable = TRUE;
				}
			} // end of block for m_bDrafting == TRUE, for Reviewing mode we don't want a copy done
		}

		// don't do the following selection when PlacePhraseBox() is called from deep in some
		// other function before the phrasebox is finally rebuilt (such as in the
		// SetActivePilePointerSafely() call in the OnButtonRetranslation() call; since it would
		// then either decrement a refCount, or remove a translation association, wrongly) - in
		// such instances, we must suppress the removal
		if (!gbSuppressRemovalOfRefString)
		{
			// remove the CRefString from the KB if it is referenced only once, otherwise
			// decrement its reference count by one, so that if user edits the string the KB
			// (or if glossing, then the glossing KB) will be kept up to date
			if (selector != 1) // see comments under the function header for explanation
			{
				// do this for selector values 0 or 2
				CRefString* pRefString;
				if (gbIsGlossing)
					pRefString = GetRefString(GetKB(),1,pSrcPhrase->m_key,pSrcPhrase->m_gloss);
				else
					pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
												pSrcPhrase->m_key,pSrcPhrase->m_adaption);

				// it is okay to do the following call with pRefString == NULL, in fact, it must
				// be done whether NULL or not; since if it is NULL, RemoveRefString will clear
				// pSrcPhrase's m_bHasKBEntry to FALSE, which if not done, would result in a crash
				// if the user clicked on a source phrase which had its reference string manually
				// removed from the KB and then clicked on another source phrase.
				// (The StoreAdaption call in the second click would trip the first line's ASSERT.)
				if (gbIsGlossing)
					RemoveRefString(pRefString,pSrcPhrase,1); // pRefString is from glossing KB
				else
					RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords); // pRefString is
																					// from adaption KB
			}
		}

		// get a device context
a:		wxClientDC aDC(gpApp->GetMainFrame()->canvas);
		wxFont* pFont;
		if (gbIsGlossing && gbGlossingUsesNavFont)
			pFont = gpApp->m_pNavTextFont;
		else
			pFont = gpApp->m_pTargetFont;
		aDC.SetFont(*pFont); // aDC.SelectObject(pFont);
		int strWidth;
		int strDummyHeight;
		//wxSize extent = aDC.GetTextExtent(str);
		aDC.GetTextExtent(str, &strWidth, &strDummyHeight);
		int charWidth;
		int charDummyHeight;
		wxString aChar = _T('w');
		aDC.GetTextExtent(aChar,&charWidth, &charDummyHeight);
		int width = strWidth + gnExpandBox*charWidth;
		gpApp->m_nCurPileMinWidth = width <= gpApp->m_nCurPileMinWidth ? gpApp->m_nCurPileMinWidth : width;
		gpApp->m_curBoxWidth = gpApp->m_nCurPileMinWidth;
	} // end of block for lookup, merger, and failure to find a KB entry

	gpApp->m_targetPhrase = str; // it will lack punctuation, because of BEW change on 28April05 above
	gpApp->m_nStartChar = 0; gpApp->m_nEndChar = -1; // make sure the text is shown selected
	if (gbAutoCaps)
	{
		if (gbSourceIsUpperCase && !gbMatchedKB_UCentry)
		{
			bNoError = SetCaseParameters(gpApp->m_targetPhrase,FALSE);
			if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
			{
				// change to upper case initial letter
				gpApp->m_targetPhrase.SetChar(0,gcharNonSrcUC);
			}
		}
	}
	gSaveTargetPhrase = gpApp->m_targetPhrase;

	// wx version: The Destroy() call is not needed in wx version.

	// recalculate the layout - BEWARE: if the former target box was on the last strip, and that
	// last strip had only that pile within it, it is possible for this recalc of the layout to
	// move the last pile to the end of the preceding strip - effectively removing the former last
	// strip from the layout. So if we preserve the nOldStripIndex value across this recalculation
	// (and we do) then it will cause LayoutStrip to fail at the end of the code below. We can
	// prevent this happening' by later checking that the nOldStripIndex value still is a valid
	// strip (check source bundle's m_nStripCount value), and if not, just omit the call to
	// LayoutStrip, as the RecalcLayout call we do now will have already done what we need.
	RecalcLayout(gpApp->m_pSourcePhrases,0 /* nFirstStrip unsafe if bundle constracts */,gpApp->m_pBundle);

	// if a phrase jumps back on to the line due to the recalc of the layout, then the
	// current location for the box will end up to far right, so we must find out where the
	// active pile now is and reset m_ptCurBoxLocation before calling ResizeBox, so
	// recalculate the active pile pointer (old was clobbered by the RecalcLayout call)
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	wxASSERT(gpApp->m_pActivePile);
	gpApp->m_pTargetBox->m_pActivePile = gpApp->m_pActivePile; // put copy in the CPhraseBox too
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	// we had to delay the call of DoCancelAndSelect() until now because earlier RecalcLayout()
	// calls will clobber any selection we try to make beforehand, so do the selecting now; do
	// it also before recalculating the phrase box, since if anything moves, we want
	// m_ptCurBoxLocation to be correct
	if (gbUserWantsSelection)
	{
		gpApp->m_pTargetBox->DoCancelAndSelect(this,gpApp->m_pActivePile);
		gbUserWantsSelection = FALSE; // must be turned off before we do anything else!
		gpApp->m_bSelectByArrowKey = TRUE; // so it is ready for extending
	}

	// recreate the box window
	gpApp->m_curBoxWidth = RecalcPhraseBoxWidth(gpApp->m_targetPhrase); // recalc, since the pasted text might
														  // be shorter
	gpApp->m_nCurPileMinWidth = gpApp->m_curBoxWidth; // update this too, so box can be shorter if necessary

	if (gbIsGlossing && gbGlossingUsesNavFont)
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&gpApp->m_ptCurBoxLocation,gpApp->m_curBoxWidth,gpApp->m_nNavTextHeight,gpApp->m_targetPhrase,
													gpApp->m_nStartChar,gpApp->m_nEndChar,gpApp->m_pActivePile);
	else
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&gpApp->m_ptCurBoxLocation,gpApp->m_curBoxWidth,gpApp->m_nTgtHeight,gpApp->m_targetPhrase,
													gpApp->m_nStartChar,gpApp->m_nEndChar,gpApp->m_pActivePile);

	// update the gLastSrcPhrasePos global value
	/* BEW removed 31Jan08 because the global's value is not always reliable
	gLastSrcPhrasePos = gpApp->m_pSourcePhrases->Item(gpApp->m_nActiveSequNum);
	wxASSERT(gLastSrcPhrasePos != NULL);
	*/
	// set the color - CPhraseBox has a color variable & uses reflected notification
	if (gbIsGlossing)
		gpApp->m_pTargetBox->m_textColor = gpApp->m_navTextColor; // MFC app uses gpApp->navTextColor; // BEW changed 28Sep05
	else
		gpApp->m_pTargetBox->m_textColor = gpApp->m_targetColor;

	gpApp->m_pTargetBox->SetModify(FALSE); // calls our own SetModify() in CPhraseBox; calls wxTextCtrl::DiscardEdits()

	gbCompletedMergeAndMove = FALSE;
	Invalidate();
}

bool CAdapt_ItView::IsItNotInKB(CSourcePhrase* pSrcPhrase)
// determine if it is an <Not In KB> entry in the KB
// modified, July 2003, for Auto-Capitalization support (ie. use AutoCapsLookup function)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp);
	CKB* pKB = pApp->m_pKB;
	int nMapIndex = pSrcPhrase->m_nSrcWords - 1; // compute the index to the map

	// if we have too many source words, then it is not in the KB, but not a "<Not In KB>" entry
	if (pSrcPhrase->m_nSrcWords > MAX_WORDS)
	{
		return FALSE;
	}

	wxString key = pSrcPhrase->m_key;
	CTargetUnit* pTU;
	if (pKB->m_pMap[nMapIndex]->empty())
	{
		return FALSE;
	}
	else
	{
		bool bFound = AutoCapsLookup(pKB->m_pMap[nMapIndex], pTU, key);
		if(!bFound)
		{
			// not found
			return FALSE;
		}
		else
		{
			// pTU exists, so check its first refString to see if it stores <Not In KB>
			TranslationsList::Node* tpos = pTU->m_pTranslations->GetFirst();
			CRefString* pRefStr = (CRefString*)tpos->GetData();
			if (pRefStr->m_translation == _T("<Not In KB>"))
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
	}
}

void CAdapt_ItView::ReDoPhraseBox(const CCell *pCell)
// for version 2, the colour will be the nav text colour when glossing is on, and otherwise
// when adapting it will be the normal target text colour;
// modified, July 2003, for support of auto capitalization
{
	wxASSERT(pCell);
	if (pCell->m_nCellIndex != 2)
		return;
	CPile* pActivePile = pCell->m_pPile;
	wxASSERT(pActivePile != NULL);

	// if auto capitalization is on, determine the source text's case propertiess
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pActivePile->m_pSrcPhrase->m_key);
	}

	// remove any existing selection
	RemoveSelection();

	// setup the phrase box at the new location again
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	pApp->m_pActivePile = pActivePile;
	CSourcePhrase* pSrcPhrase = pActivePile->m_pSrcPhrase;
	wxASSERT(pSrcPhrase != NULL);
	pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
	wxASSERT(pApp->m_nActiveSequNum >= 0);

	// set initial location of the phraseBox
	pApp->m_ptCurBoxLocation = pActivePile->m_pCell[2]->m_ptTopLeft;

	// calculate the box's horz extent - we use the m_targetPhrase string for this calculation
	wxString str = pApp->m_targetPhrase;
	if (gbAutoCaps)
	{
		if (bNoError && gbSourceIsUpperCase)
		{
			bNoError = SetCaseParameters(str,FALSE);
			if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
			{
				// change to upper case initial letter
				str.SetChar(0,gcharNonSrcUC);
			}
		}
	}
	if (!gbIsGlossing && !gbMovingToPreviousPile)
		MakeLineFourString(pSrcPhrase,str);
	pApp->m_nCurPileMinWidth = pActivePile->m_nMinWidth;	// this is the pile's text-extent-based
															// min width
	// get a device context & do the calculation of the extent, set m_curBoxWidth
	wxClientDC aDC(pApp->GetMainFrame()->canvas); 
	wxFont* pFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pFont = pApp->m_pNavTextFont;
	else
		pFont = pApp->m_pTargetFont;
	aDC.SetFont(*pFont);
	int strWidth;
	int dummyHeight;
	aDC.GetTextExtent(str,&strWidth,&dummyHeight);
	wxString aChar = _T('w');
	int charWidth;
	int charDummyHeight;
	aDC.GetTextExtent(aChar,&charWidth,&charDummyHeight);
	int width = strWidth + gnExpandBox*charWidth;
	pApp->m_nCurPileMinWidth = width <= pApp->m_nCurPileMinWidth ? pApp->m_nCurPileMinWidth : width;
	pApp->m_curBoxWidth = pApp->m_nCurPileMinWidth;
	pApp->m_nStartChar = 0; pApp->m_nEndChar = -1;

	// we must destroy the edit box's window, if not, an assert is tripped in Wincore.cpp,
	// since it expects a null handle
	// wx Note: we don't destroy the taget box; we just make its contents a null string.
	// ResizeBox below calls SetSize and causes it to be visible
	pApp->m_pTargetBox->SetValue(_T(""));

	// recalculate the layout
	RecalcLayout(pApp->m_pSourcePhrases, 0 /* nFirstStrip unsafe if bundle contracts */,pApp->m_pBundle);

	// if a phrase jumps back on to the line due to the recalc of the layout, then the
	// current location for the box will end up to far right, so we must find out where the
	// active pile now is and reset m_ptCurBoxLocation before calling ResizeBox, so
	// recalculate the active pile pointer (old was clobbered by the RecalcLayout call)
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);
	pApp->m_pTargetBox->m_pActivePile = pApp->m_pActivePile; // put copy in the CPhraseBox too
	pApp->m_ptCurBoxLocation = pApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	// recreate the box window
	if (gbIsGlossing && gbGlossingUsesNavFont)
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nNavTextHeight,pApp->m_targetPhrase,
													pApp->m_nStartChar,pApp->m_nEndChar,pApp->m_pActivePile);
	else
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nTgtHeight,pApp->m_targetPhrase,
													pApp->m_nStartChar,pApp->m_nEndChar,pApp->m_pActivePile);

	// set the color - CPhraseBox has a color variable & uses reflected notification
	if (gbIsGlossing)
		pApp->m_pTargetBox->m_textColor = pApp->m_navTextColor;
	else
		pApp->m_pTargetBox->m_textColor = pApp->m_targetColor;

	Invalidate();
}

void CAdapt_ItView::RemoveRefString(CRefString *pRefString, CSourcePhrase* pSrcPhrase,
									int nWordsInPhrase)
// If pRefString is referenced only once, remove it from KB (since the phraseBox will hold
// a copy of its string if it is still wanted), or if it is referenced more than once, then just
// decrement the reference count by one, and set the srcPhrase's m_bHasKBEntry flag to FALSE;
// also make sure m_bAlwaysAsk is set or cleared as the case may be. For version 2.0 and onwards
// we must test gbIsGlossing in order to set the KB pointer to either the adaption KB or the
// glossing KB; and the caller must supply the appropriate first and last parameters (ie. a
// pRefString from the glossing KB and nWordsInPhrase set to 1 when gbIsGlossing is TRUE)
// Ammended, July 2003, to support auto capitalization
// BEW changed 05July2006 to fix a long-standing error where the m_bHasKBEntry flag, or the
// m_bHasGlossingKBEntry flag, was not cleared when the phrase box lands at a location which
// earlier contributed an entry to the KB. The reason it wasn't cleared was because I put the
// code for that in an "if (pRefString == NULL)" test's true block, so it wouldn't get called
// except at locations which did not as yet have any KB entry! So I commented out the test.
// (In StoreText() and StoreTextGoingBack() I unilaterally cleared the flags at its start so
// that the store would not fail; I've now removed that bit of code & tested - seems fine now.)
// BEW 20Mar07: code added to suppress the decrement or kb entry removal if retranslating is
// currenty going on, or editing of a retranslation (we don't want to dumb down the KB)
// needlessly
{
	if (gbIsGlossing)
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
	else
		pSrcPhrase->m_bHasKBEntry = FALSE;
	if (!gbIsGlossing && pSrcPhrase->m_bNotInKB)
	{
		// version 2 can do this block only when the adaption KB is in use
		pSrcPhrase->m_bHasKBEntry = FALSE;
		return; // return because nothing was put in KB for this source phrase anyway
	}

	// BEW added 06Sept06: the above tests handle what must be done to the document's pSrcPhrase 
	// instance passed in, but it could be the case that the preceding GetRefString() call did
	// not find a KB entry with the given reference string instance, in which case it would have
	// returned NULL. In that case there is nothing to remove, and no more to be done here, so
	// test for this possibility and return immediately if so.
	if (pRefString == NULL)
		return;

	// for autocapitalization support, we have to be careful that the translation (or gloss)
	// which we delete in the case when the ref count drops to zero is the actual one in
	// the KB - we can't always take it from pSrcPhrase->m_key because if auto caps is ON
	// it might be the case that the entry was put in when auto caps is OFF and then we'd
	// wrongly change to lower case and not succeed in removing the entry from the map, so
	// we have to be a bit more clever. So we'll set s to the key as on the sourcephrase,
	// and a second string s1 will have the other case equivalent, and if the first does not
	// get removed, we try the second (which should work); we still need to form the second
	// only when gbAutoCaps is TRUE, since when it is OFF, a failed GetRefString( ) call will
	// not result in an attempt to remove a lower case entry stored when gbAutoCaps was ON
	wxString s = pSrcPhrase->m_key;
	wxString s1 = s;
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(s1);
		if (bNoError && gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
		{
			// make it start with lower case letter
			s1.SetChar(0,gcharSrcLC);
		}
	}
	int nRefCount = pRefString->m_refCount;
	wxASSERT(nRefCount > 0);
	if (nRefCount > 1)
	{
		// more than one reference to it, so just decrement & remove the srcPhrase's knowledge
		// of it, this does not affect the count of how many translations there are, so
		// m_bAlwaysAsk is unaffected. Version 2 has to test gbIsGlossing and set the relevant
		// flag to FALSE.
		if (!gbIsRetranslationCurrent)
		{
			// BEW 20Mar07: don't decrement if retranslation, or editing of same, is currently happening
			pRefString->m_refCount = --nRefCount;
		}
		if (gbIsGlossing)
		{
			pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
		}
		else
		{
			pSrcPhrase->m_bHasKBEntry = FALSE;
		}
	}
	else
	{
		// from version 1.2.9 onwards, since <no adaptation> has to be caused manually, we no
		// longer want to automatically remove an empty adaptation whenever we land on one - well,
		// not quite true, we can remove automatically provided the ref count is greater than one,
		// but we have to block automatic decrements which would result in a count of zero - else
		// we'd lose the value from the KB altogether and user would not know. We need this
		// protection because an ENTER will not cause automatic re-storing of it. So now, we will
		// just not remove the last one. This will possibly skew the ref counts a bit for empty
		// adaptations, if the user hits the <no adaptation> button more than once for an entry
		// (making them too large) or landing on an empty one several times (makes count to small),
		// would not matter anyway. To manually remove empty adaptations from the KB the user still
		// has the option of doing it in the KB Editor, or in the ChooseTranslation dialog.

		//BEW changed behaviour 20Jun06 because unilaterally returning here whenever the m_translation
		// string was empty meant that if the user wanted to remove his earlier "<no adaptation>"
		// choice, there was no way to effect it from the interface. So now we have a global flag
		// gbNoAdaptationRemovalRequested which is TRUE whenever the user hits backspace or Del key
		// in an empty phrasebox, provided that locatation's CSourcePhrase has m_bHasKBEntry (when
		// in adapting mode) set TRUE, or m_bHasGlossingKBEntry (when in glossing mode) set TRUE. Hence
		// if neither BS or DEL key is pressed, we'll get the legacy (no deletion & retaining of the
		// flag value) behaviour as before.
		if (pRefString->m_translation.IsEmpty())
		{
			if (!gbNoAdaptationRemovalRequested)
				return; // never automatically reduce count to zero; if user wants to be rid of it,
						// he must do so manually -- no, there was no 'manual' way to do it for the
						// document CSourcePhrase instance, so 20Jun06 change introduces a backspace or
						// DEL key press to effect the removal
		}
		gbNoAdaptationRemovalRequested = FALSE; // ensure cleared to default value, & permit removal
												  // after the flag may have been used in previous block

		if (gbIsRetranslationCurrent)
		{
			// BEW 20Mar07: don't remove if retranslation, or editing of same, is currently happening
			// because we don't want retranslations to effect the 'dumbing down' of the KB by removal
			// of perfectly valid KB entries belonging to the retranslation span formerly
			return;
		}

		// this reference string is only referenced once, so remove it entirely from KB or
		// from the glossing KB, depending on gbIsGlossing flag's value
		CTargetUnit* pTU = pRefString->m_pTgtUnit; // point to the owning targetUnit
		wxASSERT(pTU != NULL);
		int nTranslations = pTU->m_pTranslations->GetCount();
		wxASSERT(nTranslations > 0); // must be at least one
		if (nTranslations == 1)
		{
			// we are removing the only CRefString in the owning targetUnit, so the latter must
			// go as well
			CTargetUnit* pTgtUnit;
			CAdapt_ItApp* pApp = GetDocument()->GetApp();
			CKB* pKB;
			if (gbIsGlossing)
				pKB = pApp->m_pGlossingKB; // point to the glossing KB when glossing is on
			else
				pKB = pApp->m_pKB; // point to the adaptation knowledge base when adapting

			delete pRefString;
			pRefString = (CRefString*)NULL;
			// since we delete pRefString, TranslationsList::Clear() should do the job below
			pTU->m_pTranslations->Clear();

			TUList::Node* pos;

			pos = pKB->m_pTargetUnits->Find(pTU); // find position of pRefString's
												  // owning targetUnit

			// Note: A check for NULL should probably be done here anyway even if when working
			// properly a NULL return value on Find shouldn't happen.
			pTgtUnit = (CTargetUnit*)pos->GetData(); // get the targetUnit in
																	// the list
			wxASSERT(pTgtUnit != NULL);
			pKB->m_pTargetUnits->DeleteNode(pos); // remove its pointer from the list
			delete pTgtUnit; // delete its instance from the heap
			pTgtUnit = (CTargetUnit*)NULL;

			MapKeyStringToTgtUnit* pMap = pKB->m_pMap[nWordsInPhrase - 1];
			int bRemoved = 0;
			if (gbAutoCaps)
			{
				// try removing the lower case one first, this is the most likely one that
				// was found by GetRefString( ) in the caller
				bRemoved = pMap->erase(s1); // also remove it from the map
			}
			if (bRemoved == 0)
			{
				// have a second shot using the unmodified string s
				bRemoved = pMap->erase(s); // also remove it from the map
			}
			wxASSERT(bRemoved == 1);
			// the above algorith will handle all possibilites except one; if earlier auto caps
			// is ON, and the user stores an entry with source text starting with upper case,
			// (which will be changed to lower case for the storage), and then later on s/he
			// turns auto caps OFF, then the entry would not be found by the above line:
			// bRemoved = pMap->RemoveKey(s);  and then the wxASSERT would trip;
			// however, we are saved from this happening because the pRefString passed in is
			// provided by a prior GetRefString( ) call in the caller, and that would not find the
			// pRefString, and as a consequence it would return NULL, and so the in this block of
			// RemoveRefString( ) the removal would not be asked for; so the wxASSERT would not trip.
		}
		else
		{
			// there are other CRefString instances, so don't remove its owning targetUnit
			TranslationsList::Node* pos = pTU->m_pTranslations->Find(pRefString);
			wxASSERT(pos != NULL); // it must be in the list somewhere
			pTU->m_pTranslations->DeleteNode(pos); // remove that refString from the list in the
											   // targetUnit
			delete pRefString; // delete it from the heap
			pRefString = (CRefString*)NULL;
		}

		// inform the srcPhrase that it no longer has a KB entry (or a glossing KB entry)
		if (gbIsGlossing)
			pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
		else
			pSrcPhrase->m_bHasKBEntry = FALSE;
	}
}

CPile* CAdapt_ItView::CalcPile(CPile *pPile)
// helper for GetNextEmptyPile function; for version 2.0 and onwards
{
	CPile* pNextPile = (CPile*)NULL;
	CStrip* pStrip = pPile->m_pStrip;;
	CSourceBundle* pBundle = pStrip->m_pBundle;
	int nCurPile;
	int nPileCount;
	nCurPile = pPile->m_nPileIndex;
	nPileCount = pStrip->m_nPileCount;
	if (nCurPile < nPileCount - 1)
	{
		// there is a next pile in the current strip
		nCurPile++;
		pNextPile = pStrip->m_pPile[nCurPile];
	}
	else
	{
		// next pile is in next strip, so get it from there, provided there is a next strip
		int nCurStrip = pStrip->m_nStripIndex;
		nCurStrip++; // the next strip
		int nStripCount = pBundle->m_nStripCount;
		if (nCurStrip > nStripCount - 1)
		{
			return NULL; // there is no "empty" next pile to be had in the current bundle
		}
		else
		{
			pStrip = pBundle->m_pStrip[nCurStrip];
			pNextPile = pStrip->m_pPile[0]; // can only be the first one in the strip
		}
	}
	return pNextPile;
}

CPile* CAdapt_ItView::GetNextEmptyPile(CPile *pPile)
// returns a pointer to the next pile having no target language (adapted) string,
// or NULL if there is no such empty pile later in the bundle; the search is restricted
// to the current bundle - to advance here would clobber pointers in any function which
// calls GetNextEmptyPile when an advance is required.
// for version 2.0 and onwards, the check is done on m_glossing instead, when glossing is ON
{
	if (gbIsGlossing)
	{
		do
		{
			pPile = CalcPile(pPile);
			if (pPile == NULL)
				break;
		} while (pPile->m_pSrcPhrase->m_bHasGlossingKBEntry);
	}
	else // currently adapting
	{
		do
		{
			pPile = CalcPile(pPile);
			if (pPile == NULL)
				break;
		} while (pPile->m_pSrcPhrase->m_bHasKBEntry || pPile->m_pSrcPhrase->m_bNotInKB);
	}
	return pPile;
}

void CAdapt_ItView::CalcIndicesForAdvance(int nSequNum)
// recalculate all the indices when an advance of the bundle is required
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int pc = pApp->m_nPrecedingContext;
	int fc = pApp->m_nFollowingContext;
	int mtd = pApp->m_nMaxToDisplay;

	// get the max index value
	SPList* pList = pApp->m_pSourcePhrases;
	int mi = pList->GetCount() - 1;
	int delta;
	int lower = nSequNum - pc;

	// set the new values
	if (lower < 0)
		pApp->m_beginIndex = pApp->m_lowerIndex = 0;
	else
		pApp->m_beginIndex = pApp->m_lowerIndex = lower;

	int upper = pApp->m_beginIndex + mtd - 1;
	if (upper > mi)
		pApp->m_endIndex = mi;
	else
		pApp->m_endIndex = upper;

	delta = (pApp->m_endIndex - nSequNum)/2;
	int danger = pApp->m_endIndex - fc;

	if (danger < nSequNum)
		pApp->m_upperIndex = pApp->m_endIndex - wxMin(delta,10);
	else
		pApp->m_upperIndex = danger;
}

CPile* CAdapt_ItView::AdvanceBundle(int nSaveSequNum)
// advances the bundle, returning the pile which has srcPhrase with nSaveSequNum
// (typically this is the active sequ number, and pPile will be the active pile therefore)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CalcIndicesForAdvance(nSaveSequNum);
	RecalcLayout(pApp->m_pSourcePhrases,0,pApp->m_pBundle);

	// recalculate the active pile & update location for phraseBox creation
	CPile* pPile = GetPile(nSaveSequNum);
	pApp->m_ptCurBoxLocation = pPile->m_pCell[2]->m_ptTopLeft;

	return pPile;
}

//void CAdapt_ItView::ScrollIntoView(int nSequNum) // Moved to CAdapt_ItCanvas in WX version:

//int CAdapt_ItView::ScrollDown(int nStrips) // Moved to CAdapt_ItCanvas in WX version:

//int CAdapt_ItView::ScrollUp(int nStrips) // Moved to CAdapt_ItCanvas in WX version:

bool CAdapt_ItView::NeedBundleAdvance(int nCurSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int ei = pApp->m_endIndex;
	int ui = pApp->m_upperIndex;
	int fc = pApp->m_nFollowingContext;

	// get the max index value
	SPList* pList = pApp->m_pSourcePhrases;
	int mi = pList->GetCount() - 1;

	// if we are already at the end of the file's data, no advance is possible
	if (mi == ei)
		return FALSE;

	// determine if we are past the upperIndex value
	if (nCurSequNum > ui)
		return TRUE; // we've passed it

	// ei is not yet at the end of the file's data, and we've not passed ei but
	// has the following context been reduced below the desired value? If so, then
	// move up
	if (nCurSequNum + fc >= ei)
		return TRUE;
	else
		return FALSE; // we've still got enough context, so no advance required
}

bool CAdapt_ItView::NeedBundleRetreat(int nSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int bi = pApp->m_beginIndex;
	int li = pApp->m_lowerIndex;
	int pc = pApp->m_nPrecedingContext;

	// if we are already at the beginning of the file's data, no retreat is possible
	if (bi == 0)
		return FALSE;

	// determine if we are to the left of the m_lowerIndex value
	if (nSequNum < li)
		return TRUE; // we've passed it

	// bi is not yet at the beginning of the file's data, and we've not passed li but
	// has the preceding context been reduced below the desired value? If so, then
	// move back down
	if (nSequNum - pc <= bi)
		return TRUE;
	else
		return FALSE; // we've still got enough context, so no retreat required
}

void CAdapt_ItView::CalcIndicesForRetreat(int nSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int pc = pApp->m_nPrecedingContext;
	int fc = pApp->m_nFollowingContext;
	int mtd = pApp->m_nMaxToDisplay;

	// get the max index value
	SPList* pList = pApp->m_pSourcePhrases;
	int mi = pList->GetCount() - 1;
	int delta;
	int upper = nSequNum + fc;

	// set the new values
	if (upper > mi)
		pApp->m_endIndex = pApp->m_upperIndex = mi;
	else
		pApp->m_endIndex = wxMax(upper,wxMin(mi,mtd-1));

	int lower = pApp->m_endIndex - mtd;
	if (lower < 0)
		pApp->m_beginIndex = 0;
	else
		pApp->m_beginIndex = lower;

	delta = (nSequNum - pApp->m_beginIndex)/2;
	int danger = pApp->m_beginIndex + pc;

	if (danger > nSequNum)
		pApp->m_lowerIndex = pApp->m_beginIndex + wxMin(delta,10);
	else
		pApp->m_lowerIndex = danger;
}

bool CAdapt_ItView::StoreBeforeProceeding(CSourcePhrase* pSrcPhrase)
// Return value: TRUE if all was well (whether or not an actual store to KB took place -
// because certain flags inhibit saves, or an empty targetBox does not get anything saved
// to a KB if the <no adaptation> button was not pressed), and FALSE if the store could not
// be done (eg. if the embedded call to StoreText returned FALSE)
// ammended, July 2003, for auto-capitalization support
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	RemoveSelection(); // ensure we don't have any selection current
	bool bOK = FALSE;

	// OnIdle( ) probably will have done any needed case changing, but just in case we
	// will check and if it has not been done, then do it here instead
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(gpApp->m_pActivePile->m_pSrcPhrase->m_key);
		if (bNoError && gbSourceIsUpperCase)
		{
			bNoError = SetCaseParameters(gpApp->m_targetPhrase,FALSE);
			if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
			{
				gpApp->m_targetPhrase.SetChar(0,gcharNonSrcUC);
			}
		}
	}

	if (gbIsGlossing)
	{
		if (!pSrcPhrase->m_bHasGlossingKBEntry)
		{
			if (!gpApp->m_targetPhrase.IsEmpty())
			{
				// it has to be saved to the glossing KB if not empty
				bOK = StoreText(pApp->m_pGlossingKB,pSrcPhrase,gpApp->m_targetPhrase);
			}
			else
				bOK = TRUE; // no store, but not an error so return TRUE
		}
		return bOK;
	}
	else
	{
		if (gpApp->m_bSaveToKB && !pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB)
		{
			if (!gpApp->m_targetPhrase.IsEmpty())
			{
				// it has to be saved to the KB if not empty
				MakeLineFourString(pSrcPhrase,gpApp->m_targetPhrase);
				RemovePunctuation(pDoc,&gpApp->m_targetPhrase,1 /*from tgt*/);
				gbInhibitLine4StrCall = TRUE;
				bOK = StoreText(pApp->m_pKB,pSrcPhrase,gpApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
			}
			else
				bOK = TRUE; // no store, but not an error so return TRUE
		}
		gpApp->m_bSaveToKB = TRUE; // make sure it's turned on
		return bOK;
	}
}

CPile* CAdapt_ItView::RetreatBundle(int nSaveSequNum)
// retreats the bundle, returning the pile which has srcPhrase with nSaveSequNum
// (typically this is the active sequ number, and pPile will be the active pile therefore)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CalcIndicesForRetreat(nSaveSequNum);
	RecalcLayout(pApp->m_pSourcePhrases,0,pApp->m_pBundle);

	// recalculate the active pile & update location for phraseBox creation
	CPile* pPile = GetPile(nSaveSequNum);
	pApp->m_ptCurBoxLocation = pPile->m_pCell[2]->m_ptTopLeft;
	return pPile;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// Disables the "Advance To End" toolbar item if Vertical Editing is in progress.
/// If the m_pActivePile pointer is NULL or there are no source phrase in the m_pSourcePhrases list,
/// this handler disables the "Advance To End" toolbar item and returns immediately.
/// It enables the toolbar item if the App's m_endIndex is greater than zero but
/// less than the count in m_pSourcephrases -1, otherwise it disables the toolbar item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonToEnd(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_endIndex < (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonToEnd(wxCommandEvent& event)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	if (gpApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)gpApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL); 
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->SetValue(tempStr);
	}
	gnOldSequNum = gpApp->m_nActiveSequNum; // save old location
	/* BEW removed 31Jan08 because the global's value is not always reliable
	gLastSrcPhrasePos = 0; // ensure we use the safe but longer algorithm to find new position
	*/
	// BEW added 28Sep05, to fix the following bug. It the globals below are not here reset,
	// and especially to the same value, then when we are in a bundle at the start of the doc
	// we'll not get trouble, but when we've been doing autoinseting at a location way down in
	// the document, and we stop the process (eg. Cancel a Choose Translation dialog choice)
	// and click the ToStart button, the button's handler eventually recreates the layout at
	// the start of the document (where we hope to end up), but in the handler ScrollIntoView()
	// gets called, and it has "smart" code in it that takes the two globals below and if they
	// are different, it will ask for a recalculation of the pile pointers for the beginning
	// and end of the last inserted set of adaptations -- and these require GetPile() calls
	// which, because that old location was miles away further down in the document, a bundle
	// advance and layout recalculation get done in order to get valid pointers - and on return
	// from ScrollIntoView() the layout is no longer at the start and the active pointer has
	// be put back where we had been when we clicked ToStart to get back to the doc start. Then,
	// not only does the window not scroll and the phrase box get written over the old window
	// contents, but the bad active pile pointer causes any Update handler which requires that
	// value to crash (eg. OnUpdateButtonRestore()). Setting both globals to zero avoids all
	// and causes the legacy scrolling block to be used in ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	SPList* pList = gpApp->m_pSourcePhrases;

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	wxASSERT(gpApp->m_pActivePile != NULL);
	bool bOK;
	bOK = StoreBeforeProceeding(gpApp->m_pActivePile->m_pSrcPhrase);
	// BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
	// StoreBeforeProceeding() returns FALSE without doing any store, and in that case
	// we don't want to return from OnButtonToEnd immediately because then we have no
	// way to navigate to the end of the document by this button; instead, just ignore
	// the bOK value
	//if (!bOK)
	//{
	//	return;
	//}

	int nSequNum = pList->GetCount() - 1; // active element is last one in the list
	gpApp->m_nActiveSequNum = nSequNum;

	SPList::Node* spos = pList->GetLast();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)spos->GetData();

	// if free translation mode is on, we would not want the box to be at the very end if
	// there was already a free translation ending there - so make the adjustment if required
	// so that box goes instead to the last anchor position
	if (gpApp->m_bFreeTranslationMode)
	{
		if (pSrcPhrase->m_bHasFreeTrans && !pSrcPhrase->m_bStartFreeTrans)
		{
			// move back to the sequ num for the anchor position
			SPList::Node* pos = pList->GetLast();
			int count = 0;
			while (TRUE)
			{
				count++;
				pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetPrevious();
				wxASSERT(pSrcPhrase != NULL); 
				nSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans || count > 20)
				{
					// don't go back more than 20 words/phrases
					nSequNum = pSrcPhrase->m_nSequNumber;
					gpApp->m_nActiveSequNum = nSequNum;
					break;
				}
			}
		}
	}

	// handle the possibility that the new active location might be a "<Not In KB>" one
	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
		// this ensures user has to explicitly type into the box and explicitly check the
		// checkbox if he wants to override the "not in kb" earlier setting at this location
		gpApp->m_bSaveToKB = FALSE;
		gpApp->m_targetPhrase.Empty();
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		goto a;
	}

	if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
		gpApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	else
	{
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		gpApp->m_targetPhrase.Empty();// added 31Jul03
		// the above is better, since then the user can use the To End button
		// and not get spurious copied source text entered into the KB
		// if he does not remember to delete the copied text before stepping elsewhere
	}

	// calculate the bundle's indices
a:	gpApp->m_pActivePile = AdvanceBundle(gpApp->m_nActiveSequNum);

	// the active pile must not contain a retranslation, since we want to put the phrase box
	// there, so check and if so, back up until we find a src phrase which is not a retranslation
	// (this conceivably might require one or more additional step ups, if there are lots of
	// consecutive retranslations in the preceding context)
	if (gpApp->m_pActivePile->m_pSrcPhrase->m_bRetranslation)
	{
		// its a retranslation location, so move active location to earlier sequence numbers until
		// we find a sourcePhrase which is not in the retranslation
		CPile* pPile = gpApp->m_pActivePile;
		do
		{
			pPile = GetPrevPile(pPile);
			if (pPile == NULL)
			{
				// we've backed up to the start of the bundle, so must step up
				OnButtonStepUp(event); // this iterates internally if necessary, till a valid pile
								  // found, etc.
				return;
			}
			gpApp->m_pActivePile = pPile;
		} while (pPile->m_pSrcPhrase->m_bRetranslation);

		pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
		gpApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
			// this ensures user has to explicitly type into the box and explicitly check the
			// checkbox if he wants to override the "not in kb" earlier setting at this location
			gpApp->m_bSaveToKB = FALSE;
			gpApp->m_targetPhrase.Empty();
			gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
				gpApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				gpApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (gpApp->m_bCopySource)
				{
					gpApp->m_targetPhrase = CopySourceKey(pSrcPhrase,gpApp->m_bUseConsistentChanges);
				}
				else
				{
					gpApp->m_targetPhrase.Empty();
				}
			}
		}
	}

	// remove from the KB, if there is a refString for this source phrase in the KB
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
												pSrcPhrase->m_key,pSrcPhrase->m_adaption);

	// it is okay to do the following call with pRefString == NULL, in fact, it must be done
	// whether NULL or not; since if it is NULL, RemoveRefString will clear pSrcPhrase's
	// m_bHasKBEntry to FALSE, which if not done, would result in a crash if the user clicked on
	// a source phrase which had its reference string manually removed from the KB and then
	// clicked on another source phrase. (The StoreAdaption call in the second click would trip
	// the first line's ASSERT.)
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// get a device context, and work out the targetBox initial size, since there is
	// a stored adaption it could be long, so we'll need to recalc the layout again
	wxClientDC aDC(gpApp->GetMainFrame()->canvas);
	wxString str = gpApp->m_targetPhrase;
	wxFont* pFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pFont = pApp->m_pNavTextFont;
	else
		pFont = pApp->m_pTargetFont;
	aDC.SetFont(*pFont);
	wxSize extent;
	aDC.GetTextExtent(str,&extent.x,&extent.y);
	wxString aChar = _T('w');
	wxSize charSize;
	aDC.GetTextExtent(aChar,&charSize.x,&charSize.y);
	int width = extent.GetWidth() + gnExpandBox*charSize.GetWidth();
	gpApp->m_nCurPileMinWidth = width <= gpApp->m_nCurPileMinWidth ? gpApp->m_nCurPileMinWidth : width;
	gpApp->m_curBoxWidth = gpApp->m_nCurPileMinWidth;

	// recalculate the layout
	RecalcLayout(gpApp->m_pSourcePhrases,0 /* nFirstStrip safer from 0 */,gpApp->m_pBundle);

	// recalculate the active pile & update location for phraseBox creation
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);
	gpApp->m_nStartChar = 0;
	gpApp->m_nEndChar = -1; // ensure initially all is selected
	RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);
	Invalidate();

	// if we are in free translation mode, we want the focus to be in the Compose Bar's edit box
	// after the move has been done
	if (gpApp->m_bFreeTranslationMode && pEdit != NULL) // whm added && pEdit != NULL)
	{
		pEdit->SetFocus();
	}
}

void CAdapt_ItView::RemoveKBEntryForRebuild(CSourcePhrase* pSrcPhrase)
// removes both the entry from the adapting KB and the glossing KB, for the one m_key
// (the function for removal exits if either does not yet exist in the KB, so the call is
// always safe) - we need this function for document rebuilding, where both KBs have
// to be updated in the one operation
{
	// save current glossing state, so we can restore afterwards
	bool bSaveEnableFlag = gbEnableGlossing;
	bool bSaveGlossingFlag = gbIsGlossing;

	// remove from the adapting KB, if there is a refString for this source phrase in the KB
	// (GetRefString may return NULL)
	gbEnableGlossing = FALSE;
	gbIsGlossing = FALSE;
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
												pSrcPhrase->m_key,pSrcPhrase->m_adaption);
	// it is okay to do the following call with pRefString == NULL
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// now the glossing KB
	gbEnableGlossing = TRUE;
	gbIsGlossing = TRUE;
	pRefString = GetRefString(GetKB(),1,pSrcPhrase->m_key,pSrcPhrase->m_gloss);
	RemoveRefString(pRefString,pSrcPhrase,1);

	// restore current mode
	gbEnableGlossing = bSaveEnableFlag;
	gbIsGlossing = bSaveGlossingFlag;
}

void CAdapt_ItView::StoreKBEntryForRebuild(CSourcePhrase* pSrcPhrase, wxString& adaptationStr, wxString& glossStr)
// stores both adaptation for the adapting KB and gloss for the glossing KB, for the one m_key
// (the function for storage exits if either does not yet exist in the KB, so the call is
// always safe) - we need this function for document rebuilding, where both KBs have
// to be updated in the one operation
{
	// save current glossing state, so we can restore afterwards
	bool bSaveEnableFlag = gbEnableGlossing;
	bool bSaveGlossingFlag = gbIsGlossing;

	// store to the adapting KB
	gbEnableGlossing = FALSE;
	gbIsGlossing = FALSE;

	// inhibit the call to MakeLineFourString() within the StoreText() function
	// otherwise it will add punctuation to the m_targetStr field on the document's
	// pSrcPhrase which is currently active, and that member already has the required
	// punctuation because we have copied the old string prior to the rebuild
	gbInhibitLine4StrCall = TRUE;

	bool bOK = StoreText(gpApp->m_pKB,pSrcPhrase,adaptationStr);

	// now the glossing KB
	gbEnableGlossing = TRUE;
	gbIsGlossing = TRUE;

	bOK = StoreText(gpApp->m_pGlossingKB,pSrcPhrase,glossStr);

	// restore current mode
	gbEnableGlossing = bSaveEnableFlag;
	gbIsGlossing = bSaveGlossingFlag;

	gbInhibitLine4StrCall = FALSE; // restore the default setting
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Back To Start" toolbar item 
/// and returns immediately: Vertical Editing is in progress, the Document pointer is NULL, 
/// the m_pActivePile pointer is NULL, or the count of source phrases in m_pSourcePhrases is zero. 
/// It enables the toolbar item if the App's m_beginIndex and m_endIndex are both greater than zero, 
/// otherwise it disables the toolbar item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonToStart(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if ((CAdapt_ItDoc*)GetDocument() == NULL)
	{
		event.Enable(FALSE);
		return;
	}

	if (pApp->m_nActiveSequNum == -1 && pApp->m_pSourcePhrases->GetCount() > 0)
	{
		// we are past the end, so allow the button to be used to go back to start
		event.Enable(TRUE);
		return;
	}

	// any other time when active pile pointer is null, don't let button be used
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_beginIndex > 0 && pApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonToStart(wxCommandEvent& event)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	if (gpApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)gpApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->SetValue(tempStr);
	}

	// BEW added 28Sep05, to fix the following bug. It the globals below are not here reset,
	// and especially to the same value, then when we are in a bundle at the start of the doc
	// we'll not get trouble, but when we've been doing autoinseting at a location way down in
	// the document, and we stop the process (eg. Cancel a Choose Translation dialog choice)
	// and click the ToStart button, the button's handler eventually recreates the layout at
	// the start of the document (where we hope to end up), but in the handler ScrollIntoView()
	// gets called, and it has "smart" code in it that takes the two globals below and if they
	// are different, it will ask for a recalculation of the pile pointers for the beginning
	// and end of the last inserted set of adaptations -- and these require GetPile() calls
	// which, because that old location was miles away further down in the document, a bundle
	// advance and layout recalculation get done in order to get valid pointers - and on return
	// from ScrollIntoView() the layout is no longer at the start and the active pointer has
	// be put back where we had been when we clicked ToStart to get back to the doc start. Then,
	// not only does the window not scroll and the phrase box get written over the old window
	// contents, but the bad active pile pointer causes any Update handler which requires that
	// value to crash (eg. OnUpdateButtonRestore()). Setting both globals to zero avoids all
	// and causes the legacy scrolling block to be used in ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	gnOldSequNum = gpApp->m_nActiveSequNum; // save old location
	/* BEW removed 31Jan01 because the global's value is not always reliable
	gLastSrcPhrasePos = 0; // ensure we use the safe but longer algorithm to find new position
	*/
	SPList* pList = gpApp->m_pSourcePhrases;
	bool bOK;

	if (gpApp->m_nActiveSequNum == -1)
	{
		// we are past the end, so skip storage
		bOK = TRUE;

		// and remove any selection, since if it exists then RecalcLayout() would fail when
		// StoreSelection() gets called
		RemoveSelection();
	}
	else
	{
		wxASSERT(gpApp->m_pActivePile != NULL);
		bOK = StoreBeforeProceeding(gpApp->m_pActivePile->m_pSrcPhrase);
	}
	// BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
	// StoreBeforeProceeding() returns FALSE without doing any store, and in that case
	// we don't want to return from OnButtonToStart immediately because then we have no
	// way to navigate back to the start of the document; instead, just ignore the bOK value
	//if (!bOK)
	//{
	//	return;
	//}

	int nSequNum = 0; // active element is first one in the list
	gpApp->m_nActiveSequNum = nSequNum;

	SPList::Node* spos = pList->GetFirst();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)spos->GetData(); //pList->GetHead();

	// handle the possibility that the new active location might be a "<Not In KB>" one
	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
		// this ensures user has to explicitly type into the box and explicitly check the
		// checkbox if he wants to override the "not in kb" earlier setting at this location
		gpApp->m_bSaveToKB = FALSE;
		gpApp->m_targetPhrase.Empty();
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		goto a;
	}

	if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
		gpApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	else
	{
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		gpApp->m_targetPhrase.Empty(); // added 31Jul03
		// the above is better, since then the user can use the To Start button
		// and not get spurious copied source text entered into the KB
		// if he does not remember to delete the copied text before stepping elsewhere
	}

	// go back to the start of the file's data
a:	gpApp->m_pActivePile = RetreatBundleToStart();

	// the active pile must not contain a retranslation, since we want to put the phrase box
	// there, so check and if so, move forward until we find a src phrase which is not a
	// retranslation (this conceivably might require one or more step downs, if there are lots
	// of consecutive retranslations in the following context)
	if (gpApp->m_pActivePile->m_pSrcPhrase->m_bRetranslation)
	{
		// its a retranslation location, so move active location to later sequence numbers until
		// we find a sourcePhrase which is not in the retranslation
		CPile* pPile = gpApp->m_pActivePile;
		do
		{
			pPile = GetNextPile(pPile);
			if (pPile == NULL)
			{
				// we've moved forward to the start of the next bundle, so must step down
				OnButtonStepDown(event); // this iterates internally if necessary, till a valid pile
									// found, etc.
				return;
			}
			gpApp->m_pActivePile = pPile;
		} while (pPile->m_pSrcPhrase->m_bRetranslation);

		pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
		gpApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
			// this ensures user has to explicitly type into the box and explicitly check the
			// checkbox if he wants to override the "not in kb" earlier setting at this location
			gpApp->m_bSaveToKB = FALSE;
			gpApp->m_targetPhrase.Empty();
			gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
				gpApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				gpApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (gpApp->m_bCopySource)
				{
					gpApp->m_targetPhrase = CopySourceKey(pSrcPhrase,gpApp->m_bUseConsistentChanges);
				}
				else
				{
					gpApp->m_targetPhrase.Empty();
				}
			}
		}
	}

	// remove the text from the KB, if refString is not null
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key,pSrcPhrase->m_adaption);

	// it is okay to do the following call with pRefString == NULL, in fact, it must be done
	// whether NULL or not; since if it is NULL, RemoveRefString will clear pSrcPhrase's
	// m_bHasKBEntry to FALSE, which if not done, would result in a crash if the user clicked on
	// a source phrase which had its reference string manually removed from the KB and then
	// clicked on another source phrase. (The StoreAdaption call in the second click would trip
	// the first line's wxASSERT.)
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// get a device context, and work out the targetBox initial size, since there is
	// a stored adaption it could be long, so we'll need to recalc the layout again
	wxClientDC aDC(gpApp->GetMainFrame()->canvas);
	wxString str = gpApp->m_targetPhrase;
	wxFont* pFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pFont = gpApp->m_pNavTextFont;
	else
		pFont = gpApp->m_pTargetFont;
	aDC.SetFont(*pFont); //aDC.SelectObject(pFont);
	wxSize extent;
	aDC.GetTextExtent(str,&extent.x,&extent.y);
	wxString aChar = _T('w'); // a wide character 'w'
	wxSize charSize;
	aDC.GetTextExtent(aChar,&charSize.x,&charSize.y);
	int width = extent.GetWidth() + gnExpandBox*charSize.GetWidth();
	gpApp->m_nCurPileMinWidth = width <= gpApp->m_nCurPileMinWidth ? gpApp->m_nCurPileMinWidth : width;
	gpApp->m_curBoxWidth = gpApp->m_nCurPileMinWidth;

	// recalculate the layout
	//int nFirstStrip = 0; // we don't need this calculation gpApp->m_pActivePile->m_pStrip->m_nStripIndex;
	RecalcLayout(gpApp->m_pSourcePhrases,0 /* nFirstStrip safer from 0 */,gpApp->m_pBundle);

	// recalculate the active pile & update location for phraseBox creation
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);
	gpApp->m_nStartChar = 0;
	gpApp->m_nEndChar = -1; // ensure initially all is selected
	RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);
	Invalidate();

	// if we are in free translation mode, we want the focus to be in the Compose Bar's edit box
	// after the move has been done
	if (gpApp->m_bFreeTranslationMode && pEdit != NULL) // whm added && pEdit != NULL
	{
		pEdit->SetFocus();
	}
}

CPile* CAdapt_ItView::RetreatBundleToStart()
{
// retreats the bundle, returning the pile which has srcPhrase with nSaveSequNum
// (typically this is the active sequ number, and pPile will be the active pile therefore)
	gpApp->m_nActiveSequNum = 0;
	gpApp->m_curIndex = 0;
	CalcInitialIndices();
	gpApp->m_curBoxWidth = 2;
	RecalcLayout(gpApp->m_pSourcePhrases,0,gpApp->m_pBundle);

	// recalculate the active pile & update location for phraseBox creation
	CPile* pPile = GetPile(gpApp->m_nActiveSequNum);
	gpApp->m_ptCurBoxLocation = pPile->m_pCell[2]->m_ptTopLeft;
	return pPile;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Move Down One Step" toolbar item 
/// and returns immediately: Vertical Editing is in progress, the m_pActivePile pointer is NULL, 
/// or the count of source phrases in m_pSourcePhrases is zero. 
/// It enables the toolbar item if the App's m_endIndex is greater than zero and less than the count
/// of source phrases in m_pSourcePhrases -1, otherwise it disables the toolbar item.
/// otherwise it disables the toolbar item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonStepDown(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_endIndex < (int)gpApp->m_pSourcePhrases->GetCount() - 1 && gpApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonStepDown(wxCommandEvent& event)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	if (gpApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)gpApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->SetValue(tempStr);
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	SPList* pList = gpApp->m_pSourcePhrases;
	int nSaveOldSequNum = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;
	wxString saveTargetPhrase = gpApp->m_targetPhrase;

	// BEW added 28Sep05, to fix the following bug. It the globals below are not here reset,
	// and especially to the same value, then when we are in a bundle at the start of the doc
	// we'll not get trouble, but when we've been doing autoinseting at a location way down in
	// the document, and we stop the process (eg. Cancel a Choose Translation dialog choice)
	// and click the ToStart button, the button's handler eventually recreates the layout at
	// the start of the document (where we hope to end up), but in the handler ScrollIntoView()
	// gets called, and it has "smart" code in it that takes the two globals below and if they
	// are different, it will ask for a recalculation of the pile pointers for the beginning
	// and end of the last inserted set of adaptations -- and these require GetPile() calls
	// which, because that old location was miles away further down in the document, a bundle
	// advance and layout recalculation get done in order to get valid pointers - and on return
	// from ScrollIntoView() the layout is no longer at the start and the active pointer has
	// be put back where we had been when we clicked ToStart to get back to the doc start. Then,
	// not only does the window not scroll and the phrase box get written over the old window
	// contents, but the bad active pile pointer causes any Update handler which requires that
	// value to crash (eg. OnUpdateButtonRestore()). Setting both globals to zero avoids all
	// and causes the legacy scrolling block to be used in ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	gnOldSequNum = gpApp->m_nActiveSequNum; // save old location
	/* BEW removed 31Jan01 because the global's value is not always reliable
	gLastSrcPhrasePos = 0; // ensure we use the safe but longer algorithm to find new position
	*/
	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	wxASSERT(gpApp->m_pActivePile != NULL); 
	bool bOK;
	bOK = StoreBeforeProceeding(gpApp->m_pActivePile->m_pSrcPhrase);
	// BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
	// StoreBeforeProceeding() returns FALSE without doing any store, and in that case
	// we don't want to return from OnButtonStepDown immediately because then we have no way
	// to navigate ahead in the document using this button; instead, just ignore the bOK value
	//if (!bOK)
	//{
	//	return;
	//}

	int mi = pList->GetCount() - 1;
b:	int nSequNum = gpApp->m_endIndex + 1; // active element is first past end of the list
	gpApp->m_nActiveSequNum = nSequNum;

	SPList::Node* pos = pList->Item(gpApp->m_nActiveSequNum); 
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase != NULL);

	// handle the possibility that the new active location might be a "<Not In KB>" one
	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
		// this ensures user has to explicitly type into the box and explicitly check the
		// checkbox if he wants to override the "not in kb" earlier setting at this location
		gpApp->m_bSaveToKB = FALSE;
		gpApp->m_targetPhrase.Empty();
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		goto a;
	}

	if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
		gpApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	else
	{
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		gpApp->m_targetPhrase.Empty();// added 31Jul03
		// the above is better, since then the user can use the Step Up button
		// repeatedly and not get spurious copied source text entered into the KB each
		// time if he does not remember to delete the copied text first
	}

	// calculate the bundle's indices
a:	CalcIndicesForAdvance(nSequNum);
	gpApp->m_pActivePile = AdvanceBundle(gpApp->m_nActiveSequNum);

	// the active pile must not contain a retranslation, since we want to put the phrase box
	// there, so check and if so, move along until we find a src phrase which is not a
	// retranslation (this conceivably might require one or more additional step downs, if there
	// are lots of consecutive retranslations in the following context)
	if (gpApp->m_pActivePile->m_pSrcPhrase->m_bRetranslation)
	{
		// its a retranslation location, so move active location to later sequence numbers until
		// we find a sourcePhrase which is not in the retranslation
		CPile* pPile = gpApp->m_pActivePile;
		do
		{
			pPile = GetNextPile(pPile);
			if (pPile == NULL)
			{
				// we've gone forward to the start of the next bundle, so must step down again
				if (gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber >= mi)
				{
					// we can't step down, the final bundle is full of only retranslations,
					// so restore the old state & tell user what to do next (need a bigger bundle)
					//IDS_CANNOT_STEP_DOWN
					wxMessageBox(_("Sorry, Adapt It cannot step down because it cannot find a legal place to put the phrase box. Open the View tab of the Preferences dialog, set a larger value for the \"Maximum source words displayed\" parameter, and then try to step down again."), _T(""), wxICON_INFORMATION);
					gpApp->m_pActivePile = AdvanceBundle(nSaveOldSequNum);
					gpApp->m_targetPhrase = saveTargetPhrase;
					gpApp->m_nActiveSequNum = nSaveOldSequNum;
					pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
					goto c;
				}
				else
					goto b;
			}
			gpApp->m_pActivePile = pPile;
		} while (pPile->m_pSrcPhrase->m_bRetranslation);

		pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
		gpApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
			// this ensures user has to explicitly type into the box and explicitly check the
			// checkbox if he wants to override the "not in kb" earlier setting at this location
			gpApp->m_bSaveToKB = FALSE;
			gpApp->m_targetPhrase.Empty();
			gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
				gpApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				gpApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (gpApp->m_bCopySource)
				{
					gpApp->m_targetPhrase = CopySourceKey(pSrcPhrase,gpApp->m_bUseConsistentChanges);
				}
				else
				{
					gpApp->m_targetPhrase.Empty();
				}
			}
		}
	}

	// remove the text from the KB, if refString is not null
c:	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key,pSrcPhrase->m_adaption);

	// it is okay to do the following call with pRefString == NULL, in fact, it must be done
	// whether NULL or not; since if it is NULL, RemoveRefString will clear pSrcPhrase's
	// m_bHasKBEntry to FALSE, which if not done, would result in a crash if the user clicked on
	// a source phrase which had its reference string manually removed from the KB and then
	// clicked on another source phrase. (The StoreAdaption call in the second click would trip
	// the first line's wxASSERT.)
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// get a device context, and work out the targetBox initial size, since there is
	// a stored adaption it could be long, so we'll need to recalc the layout again
	wxClientDC aDC(gpApp->GetMainFrame()->canvas);
	wxString str = gpApp->m_targetPhrase;
	wxFont* pFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pFont = pApp->m_pNavTextFont;
	else
		pFont = pApp->m_pTargetFont;
	aDC.SetFont(*pFont);
	wxSize extent;
	aDC.GetTextExtent(str,&extent.x,&extent.y);
	wxString aChar = _T('w');
	wxSize charSize;
	aDC.GetTextExtent(aChar,&charSize.x,&charSize.y);
	int width = extent.GetWidth() + gnExpandBox*charSize.GetWidth();
	gpApp->m_nCurPileMinWidth = width <= gpApp->m_nCurPileMinWidth ? gpApp->m_nCurPileMinWidth : width;
	gpApp->m_curBoxWidth = gpApp->m_nCurPileMinWidth;

	// recalculate the layout
	RecalcLayout(gpApp->m_pSourcePhrases,0 /* nFirstStrip safer from 0 */,gpApp->m_pBundle);

	// recalculate the active pile & update location for phraseBox creation
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);
	gpApp->m_nStartChar = 0;
	gpApp->m_nEndChar = -1; // ensure initially all is selected
	RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);
	Invalidate();
	// if we are in free translation mode, we want the focus to be in the Compose Bar's edit box
	// after the move has been done
	if (gpApp->m_bFreeTranslationMode && pEdit != NULL) // whm added && pEdit != NULL
	{
		pEdit->SetFocus();
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Move Up One Step" toolbar item 
/// and returns immediately: Vertical Editing is in progress, the Document pointer is NULL, 
/// the m_pActivePile pointer is NULL, or the count of source phrases in m_pSourcePhrases is zero. 
/// It generally enables the toolbar button if the App's m_beginIndex and m_endIndex are both greater than zero, 
/// otherwise it disables the toolbar item. It also enables the toolbar item in the special circumstance when 
/// the phrasebox is past the end of the document (m_pActiveSequNum is -1 and the count of source phrases in 
/// m_pSourcePhrases is greater than zero).
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonStepUp(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if ((CAdapt_ItDoc*)GetDocument() == NULL)
	{
		event.Enable(FALSE);
		return;
	}

	if (gpApp->m_nActiveSequNum == -1 && gpApp->m_pSourcePhrases->GetCount() > 0)
	{
		// we are past the end, so allow the button to be used to go back to start
		event.Enable(TRUE);
		return;
	}

	// any other time when active pile pointer is null, don't let button be used
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_beginIndex > 0 && gpApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonStepUp(wxCommandEvent& event)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	if (gpApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)gpApp->GetMainFrame();
		wxASSERT(pFrame != NULL); 
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->SetValue(tempStr);
	}
	/* BEW removed 31Jan01 because the global's value is not always reliable
	gLastSrcPhrasePos = 0; // ensure we use the safe but longer algorithm to find new position
	*/

	// BEW added 28Sep05, to fix the following bug. It the globals below are not here reset,
	// and especially to the same value, then when we are in a bundle at the start of the doc
	// we'll not get trouble, but when we've been doing autoinseting at a location way down in
	// the document, and we stop the process (eg. Cancel a Choose Translation dialog choice)
	// and click the ToStart button, the button's handler eventually recreates the layout at
	// the start of the document (where we hope to end up), but in the handler ScrollIntoView()
	// gets called, and it has "smart" code in it that takes the two globals below and if they
	// are different, it will ask for a recalculation of the pile pointers for the beginning
	// and end of the last inserted set of adaptations -- and these require GetPile() calls
	// which, because that old location was miles away further down in the document, a bundle
	// advance and layout recalculation get done in order to get valid pointers - and on return
	// from ScrollIntoView() the layout is no longer at the start and the active pointer has
	// be put back where we had been when we clicked ToStart to get back to the doc start. Then,
	// not only does the window not scroll and the phrase box get written over the old window
	// contents, but the bad active pile pointer causes any Update handler which requires that
	// value to crash (eg. OnUpdateButtonRestore()). Setting both globals to zero avoids all
	// and causes the legacy scrolling block to be used in ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	SPList* pList = gpApp->m_pSourcePhrases;
	bool bOK;

	if (gpApp->m_nActiveSequNum == -1)
	{
		// we are past the end, so skip storage
		bOK = TRUE;

		// and remove any selection, since if it exists then RecalcLayout() would fail when
		// StoreSelection() gets called
		RemoveSelection();
	}
	else
	{
		wxASSERT(gpApp->m_pActivePile != NULL);
		bOK = StoreBeforeProceeding(gpApp->m_pActivePile->m_pSrcPhrase);
	}
	// BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
	// StoreBeforeProceeding() returns FALSE without doing any store, and in that case
	// we don't want to return from OnButtonStepUp immediately because then we have no way
	// to navigate back in the document using this button; instead, just ignore the bOK value
	//if (!bOK)
	//{
	//	return;
	//}

	gnOldSequNum = gpApp->m_nActiveSequNum; // save old location

b:	int nSequNum = gpApp->m_beginIndex - 1; // if possible, active element will be last one earlier than
								// start of the current bundle (but back over any retranslations)
	gpApp->m_nActiveSequNum = nSequNum;

	SPList::Node* pos = pList->Item(gpApp->m_nActiveSequNum);
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase != NULL); 

	// handle the possibility that the new active location might be a "<Not In KB>" one
	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
		// this ensures user has to explicitly type into the box and explicitly check the
		// checkbox if he wants to override the "not in kb" earlier setting at this location
		gpApp->m_bSaveToKB = FALSE;
		gpApp->m_targetPhrase.Empty();
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		goto a;
	}

	if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
		gpApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	else
	{
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		gpApp->m_targetPhrase.Empty();// added 31Jul03
		// the above is better, since then the user can use the Step Up button
		// repeatedly and not get spurious copied source text entered into the KB each
		// time if he does not remember to delete the copied text first
	}

	// go back to the end of the previous bundle
a:	gpApp->m_pActivePile = RetreatBundle(gpApp->m_nActiveSequNum);

	// the active pile must not contain a retranslation, since we want to put the phrase box
	// there, so check and if so, back up until we find a src phrase which is not a retranslation
	// (this conceivably might require one or more additional step ups, if there are lots of
	// consecutive retranslations in the preceding context)
	if (gpApp->m_pActivePile->m_pSrcPhrase->m_bRetranslation)
	{
		// its a retranslation location, so move active location to earlier sequence numbers until
		// we find a sourcePhrase which is not in the retranslation
		CPile* pPile = gpApp->m_pActivePile;
		do
		{
			pPile = GetPrevPile(pPile);
			if (pPile == NULL)
			{
				// we've backed up to the start of the bundle, so must step up again
				goto b; // we will assume this process will terminate somewhere before the start
						// of the document, and so will not check for the latter
			}
			gpApp->m_pActivePile = pPile;
		} while (pPile->m_pSrcPhrase->m_bRetranslation);

		pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
		gpApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
			// this ensures user has to explicitly type into the box and explicitly check the
			// checkbox if he wants to override the "not in kb" earlier setting at this location
			gpApp->m_bSaveToKB = FALSE;
			gpApp->m_targetPhrase.Empty();
			gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
				gpApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				gpApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (gpApp->m_bCopySource)
				{
					gpApp->m_targetPhrase = CopySourceKey(pSrcPhrase,gpApp->m_bUseConsistentChanges);
				}
				else
				{
					gpApp->m_targetPhrase.Empty();
				}
			}
		}
	}

	// remove the text from the KB, if refString is not null
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key,pSrcPhrase->m_adaption);

	// it is okay to do the following call with pRefString == NULL, in fact, it must be done
	// whether NULL or not; since if it is NULL, RemoveRefString will clear pSrcPhrase's
	// m_bHasKBEntry to FALSE, which if not done, would result in a crash if the user clicked on
	// a source phrase which had its reference string manually removed from the KB and then
	// clicked on another source phrase. (The StoreAdaption call in the second click would trip
	// the first line's wxASSERT.)
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// get a device context, and work out the targetBox initial size, since there is
	// a stored adaption it could be long, so we'll need to recalc the layout again
	wxClientDC aDC(gpApp->GetMainFrame()->canvas);
	wxString str = gpApp->m_targetPhrase;
	wxFont* pFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pFont = pApp->m_pNavTextFont;
	else
		pFont = pApp->m_pTargetFont;
	aDC.SetFont(*pFont);
	wxSize extent;
	aDC.GetTextExtent(str,&extent.x,&extent.y);
	wxString aChar = _T('w');
	wxSize charSize;
	aDC.GetTextExtent(aChar,&charSize.x,&charSize.y);
	int width = extent.GetWidth() + gnExpandBox*charSize.GetWidth();
	gpApp->m_nCurPileMinWidth = width <= gpApp->m_nCurPileMinWidth ? gpApp->m_nCurPileMinWidth : width;
	gpApp->m_curBoxWidth = gpApp->m_nCurPileMinWidth;

	// recalculate the layout
	RecalcLayout(gpApp->m_pSourcePhrases,0 /* nFirstStrip safer from 0 */,gpApp->m_pBundle);

	// recalculate the active pile & update location for phraseBox creation
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);
	gpApp->m_nStartChar = 0;
	gpApp->m_nEndChar = -1; // ensure initially all is selected
	RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);
	Invalidate();
	// if we are in free translation mode, we want the focus to be in the Compose Bar's edit box
	// after the move has been done
	if (gpApp->m_bFreeTranslationMode && pEdit != NULL) // whm added && pEdit != NULL
	{
		pEdit->SetFocus();
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If the application is in glossing mode, or it is showing only the target text, or the m_pActivePile 
/// pointer is NULL, this handler disables the "Make A Phrase" toolbar item 
/// and returns immediately. If there is an active selection (the App's m_selection list has more than 
/// one item in its list), it enables the toolbar button, otherwise it disables the toolbar button. 
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonMerge(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selection.GetCount() > 1)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the App's m_pActivePile is NULL this handler disables the "Copy Source" item in the View menu
/// and immediately returns.
/// It enables the "Copy Source" item on the View menu if the number of source phrases in the
/// m_pSourcePhrases list is greater than zero, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateCopySource(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

bool CAdapt_ItView::IsNullSrcPhraseInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // there isn't any selection
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_bNullSourcePhrase)
			return TRUE;
	}
	return FALSE;
}

bool CAdapt_ItView::IsRetranslationInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst(); 
	if (pos == NULL)
		return FALSE; // there isn't any selection
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext(); 
		if (pSrcPhrase->m_bRetranslation)
			return TRUE;
	}
	return FALSE;
}

// IsFilteredMaterialNonInitial() -- BEW added 08June05, to be used in OnButtonMerge() in order
// to abort the merge operation if the user is trying to merge CSourcePhrase instances and
// one of those which is not the initial one contains filtered material in its m_markers member
bool CAdapt_ItView::IsFilteredMaterialNonInitial(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // there isn't any content in the list
	bool bIsFirst = TRUE;
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (!bIsFirst && (pSrcPhrase->m_markers.Find(filterMkr) != -1))
			return TRUE;
		bIsFirst = FALSE;
	}
	return FALSE;
}

// IsSelectionAcrossFreeTranslationEnd() -- BEW added 22Jul05, to be used in OnButtonMerge() in order
// to abort the merge operation if the user is trying to merge CSourcePhrase instances the selection
// begins before a sourcephrase which is the end of a free translation section and extends further
// into a part of the document in which no free translation is defined (the case where what follows is
// another free translation section is already blocked by the requirement that no merge can be done
// across filtered material)
bool CAdapt_ItView::IsSelectionAcrossFreeTranslationEnd(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // there isn't any content in the list
	bool bFoundFreeTranslationEnd = FALSE;
	bool bExtendsBeyondFreeTranslation = FALSE;
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (bFoundFreeTranslationEnd)
		{
			bExtendsBeyondFreeTranslation = TRUE;
			continue;
		}
		if (pSrcPhrase->m_bEndFreeTrans)
		{
			bFoundFreeTranslationEnd = TRUE;
			continue;
		}
	}
	return bExtendsBeyondFreeTranslation;
}

void CAdapt_ItView::OnButtonMerge(wxCommandEvent& WXUNUSED(event))
{
	// whm note: the code below was preventing the automatic merging of words
	// Since the Merge Phrase toolbar button has an accelerator table hot key (CTRL-M see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	//CMainFrame* pFrame = gpApp->GetMainFrame();
	//wxToolBarBase* pToolBar = pFrame->GetToolBar();
	//wxASSERT(pToolBar != NULL);
	//if (!pToolBar->GetToolEnabled(ID_BUTTON_MERGE))
	//{
	//	::wxBell();
	//	return;
	//}

	// In glossing mode (ie. actually glossing) I think I've managed to silently prevent
	// any merge from happening before OnButtonMerge( ) can get invoked. However, it the
	// user were to explicitly click the button, there is no recourse except to tell him
	// that the merge is not available when doing glossing
	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),_T(""), wxICON_INFORMATION);
		return;
	}

	// not glossing, so continue to process the merge request
	CAdapt_ItApp* pApp = GetDocument()->GetApp();
	SPList* pList = new SPList; // list of the selected CSourcePhrase objects
	wxASSERT(pList != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;
	CSourcePhrase* pSrcPhrase;
	int nCount;
	CPile* pPile;
	int nSaveSequNum;
	CCellList::Node* pos;

	// use strOldAdaptation to accumulate any existing adaptations, which will do so regardless of
	// whether some or all of the srcPhrases are already merged; the strAdapt accumulation variable
	// used later only accumulates after any unmerges are done, so we don't use that unless
	// strOldAdaptation is empty
	wxString strOldAdaptation;
	strOldAdaptation.Empty();
	gOldConcatStr.Empty();
	gOldConcatStrNoPunct.Empty();
	bool bSuppressCopyingExtraSourceWords = FALSE;
	bool bNoninitialSelectionsHaveTranslation = FALSE; // TRUE if a non-active-location selected pile has a translation in it

	if (gbRetainBoxContents)
	{
		// whenever this is set, the user will have just deselected the default text in the
		// phrase box and selected some source words- and so we get to this present code block
		// when merging. In this circumstance we don't want the deselected phrase box contents to
		// be thrown away (it was, in earlier versions) since the deselection operation was clearly
		// intended in order to retain that text; so when that happens we take the box contents
		// 'as is' as the initial string of text in strOldAdaptation
		wxString s;
		s = pApp->m_pTargetBox->GetValue(); //m_targetBox.GetWindowText(s);
		strOldAdaptation = s;
		pApp->m_targetPhrase = s;
	}

	// if we are merging because of a match when LookAhead was called, set things up using
	// the nWordsInPhrase (global) value in the PhraseBox file; otherwise, use the selection
	// (bLookAheadMerge is a static class boolean defined in the CAdapt_ItApp class & set by the
	// LookAhead function in CPhraseBox class)
	if (pApp->bLookAheadMerge)
	{
		if (gbDoingInitialSetup && pApp->m_pTargetBox->GetHandle() == NULL)
		{
			gbJustCancelled = FALSE;
			goto x;
		}
		if (pApp->m_pTargetBox->GetHandle() == NULL || pApp->m_pTargetBox->IsShown())
		{
			if (gbJustCancelled)
			{
				gbJustCancelled = FALSE;
			}
			else
			{
				// try skipping to the rest of the process, rather than aborting
				goto x;
			}
		}
x:		nCount = nWordsInPhrase; // RHS is a global variable defined in PhraseBox.cpp
		pPile = pApp->m_pActivePile;
		wxASSERT(pPile != NULL);
		pStartingPile = pPile; // need this later - see next block for explanation
		pSrcPhrase = pPile->m_pSrcPhrase;
		strOldAdaptation = pSrcPhrase->m_adaption; // don't use punctuated string
		pList->Append(pSrcPhrase); // add first to the temporary list
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything depends
												  // on this
		for (int i = 1; i < nCount; i++)
		{
			pPile = GetNextPile(pPile); // next one in the sequence
			wxASSERT(pPile != NULL);
			pSrcPhrase = pPile->m_pSrcPhrase;
			if (strOldAdaptation.IsEmpty())
				strOldAdaptation = pSrcPhrase->m_adaption;
			else
				strOldAdaptation += _T(" ") + pSrcPhrase->m_adaption; // always concat in natural order
			pList->Append(pSrcPhrase); //pList->AddTail(pSrcPhrase); // add its source phrase pointer to the list
		}

		// for a look ahead merge, treat it as if user typed it, so that if there is a
		// user-generated extension done, the inserted translation will not be removed and
		// copied source text used instead
		pApp->m_bUserTypedSomething = TRUE;
	} // end block for bLookAhead merge == TRUE
	else
	{
        // whm 10Sep08 added: The MFC code assumes that we won't get here if the Make a Phrase button is
        // disabled, however, in wx a CTRL-M and other accelerator keys are propagated as key events
        // even when the control they are associated with is disabled, so we must bail out if there is
        // no selection at this point, otherwise we'll get a crash on pod-GetData() below.
		if (pApp->m_selection.GetCount() == 0)
		{
			pList->Clear();
			delete pList;
			pList = (SPList*)NULL;
			RemoveSelection(); // whm this not really needed as there is no selection (but doesn't hurt)
			// WX Note: There is no ::IsWindow() equivalent in wxWidgets
			if (pApp->m_pTargetBox->GetHandle() != NULL)
			{
				pApp->m_pTargetBox->SetFocus();
				pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
				gnStart = pApp->m_nStartChar;
				gnEnd = pApp->m_nEndChar;
			}
			gbMergeSucceeded = FALSE;
			Invalidate();
			return;
		}
		
		// get a list of the selected CSourcePhrase instances (some might not be minimal ones
		// so if this is the case we must restore them to minimal ones)
		pos = pApp->m_selection.GetFirst();//pos = m_selection.GetHeadPosition();
		nCount = pApp->m_selection.GetCount();
		pPile = ((CCell*)pos->GetData())->m_pPile;// get the pile first in selection
		pos = pos->GetNext(); // need this to effect MFC's GetNext()
		pStartingPile = pPile; // need this for later when we look up the strip which first pile
							   // is in prior to calling RecalcLayout
		pSrcPhrase = pPile->m_pSrcPhrase;

		// at the active location, use pApp->m_targetPhrase if it's different from the stored adaptation;
		if (pStartingPile == pApp->m_pActivePile)
		{
			strOldAdaptation = pApp->m_targetPhrase;

			// version 2.3.0, we don't want to have empty piles in the selection ahead of the
			// active location to have their source text copied to the existing translation, because
			// very seldom will that be useful - mostly the user has to delete such additions, so
			// from now on we will suppress the copy operation using a local flag set here.
			bSuppressCopyingExtraSourceWords = TRUE;
		}
		else
		{
			// if the box is not within the selection, we will want to save the box contents first,
			// otherwise the contents will be lost when the merge takes place
			// BEW 05Oct06; commented out next line, because CopySourceKey() sets gbByCopyOnly to TRUE and if 
			// a copy has just been done before this merge, it makes no sense to make the flag FALSE here so
			// as to force a copy; so we want the copy skipped if the flag is still TRUE
			//gbByCopyOnly = FALSE;
			if (!pApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
			{
				MakeLineFourString(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
				RemovePunctuation(pDoc,&pApp->m_targetPhrase,1 /*from tgt*/);

				// the store will fail if the user edited the entry out of the KB, as the latter
				// cannot know which srcPhrases will be affected, so these will still have their
				// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString but
				// the above flag TRUE is a sufficient test, and if so, set the flag to FALSE
				CRefString* pRefStr = GetRefString(pApp->m_pKB,
									pApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
									pApp->m_pActivePile->m_pSrcPhrase->m_key,pApp->m_targetPhrase);
				if (pRefStr == NULL && pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
									pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
				gbInhibitLine4StrCall = TRUE;
				bool bOK;
				bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
			}

			// get the first translation string, or something possibly useful, into the list
			if (pSrcPhrase->m_targetStr.IsEmpty())
			{
				if (pApp->m_bCopySource)
					strOldAdaptation = CopySourceKey(pSrcPhrase,pApp->m_bUseConsistentChanges);
			}
			else
			{
				if (!pSrcPhrase->m_bNotInKB)
					strOldAdaptation = pSrcPhrase->m_adaption;
			}
		}
		pList->Append(pSrcPhrase); // add first to the temporary list
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, all depends on it


		// while we fill the list, also accumulate the translations; remembering that the
		// pSrcPhrase at the active location will not have its m_adaption or m_targetStr
		// members set yet, but the appropriate value will be in the view's pApp->m_targetPhrase member
		// for RTL support we don't reverse the order of words as we accumulate, (Uniscribe will
		// render the string RTL correctly after it is merged in natural order); and for version 2.3.0
		// we suppress the copying of selected source words as target text to append to the existing
		// target text since this is usually not helpful
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData(); 
			pos = pos->GetNext(); 
			pPile = pCell->m_pPile;
			pSrcPhrase = pPile->m_pSrcPhrase;
			wxASSERT(pSrcPhrase != NULL);

			// at the active location, use pApp->m_targetPhrase if it is different from the stored
			// adaptation; works right even if user typed punct explicitly

			// BEW changed 05Oct06: this loop begins at the second pSrcPhrase in the list, so
			// when we've selected leftwards, this could be the active location with copied src text
			// and we'd not really want to use copied src text I think (but at non-active locations we'd
			// allow the copy to be done, as in the else block below for the pPile == m_pActivePile test);
			// so the change I'm making here is just in the TRUE block for the pPile == m_pActivePile test:
			// to suppress copied text then for a backwards selection -- we can test for these by
			// m_curDirection's value, and phrase box's m_bAbandonable being still FALSE; however
			// strOldAdaptation is not our primary source for merged adaptation text, it is only
			// a fall back, so further changes are to be done further down
			if (pPile == pApp->m_pActivePile)
			{
				if (!pApp->m_targetPhrase.IsEmpty())
				{
					// skip if selecting left and src text was copied
					if (!(pApp->m_curDirection == left && pApp->m_pTargetBox->m_bAbandonable))
					{
						strOldAdaptation += _T(" ") + pApp->m_targetPhrase;
					}
				}
			}
			else
			{
				// this pile is not at the active location
				if (strOldAdaptation.IsEmpty()) // strOldAdaptation is empty
				{
					if (pSrcPhrase->m_adaption.IsEmpty())
					{
						if (pApp->m_bCopySource && !bSuppressCopyingExtraSourceWords) // version 2.3.0 adds 2nd boolean
							strOldAdaptation = CopySourceKey(pSrcPhrase,pApp->m_bUseConsistentChanges);
					}
					else
					{
						strOldAdaptation = pSrcPhrase->m_adaption;
						bNoninitialSelectionsHaveTranslation = TRUE;
					}
				}
				else // strOldAdaptation is not empty
				{
					if (pSrcPhrase->m_adaption.IsEmpty())
					{
						if (pApp->m_bCopySource && !bSuppressCopyingExtraSourceWords) // 2.3.0 adds 2nd boolean
						if (pApp->m_bCopySource)
							strOldAdaptation += _T(" ") + CopySourceKey(pSrcPhrase,pApp->m_bUseConsistentChanges);
					}
					else
					{
						strOldAdaptation += _T(" ") + pSrcPhrase->m_adaption;
						bNoninitialSelectionsHaveTranslation = TRUE;
					}
				}
			}
			pList->Append(pSrcPhrase);
		}
	}

	// set the global strings, in case they are wanted (eg. in a Find & Replace they may be used)
	gOldConcatStr = strOldAdaptation;
	gOldConcatStrNoPunct = strOldAdaptation;
	RemovePunctuation(pDoc,&gOldConcatStrNoPunct,1 /*from tgt*/);

	// check for a retranslation in the selection, and abort the merge operation if there is one
	if (IsRetranslationInSelection(pList))
	{
		// IDS_NO_RETRANSLATION_IN_SEL
		wxMessageBox(_("Sorry, but this operation is not permitted when the selection contains any part of a retranslation. First remove the retranslation and then try again."), _T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		// WX Note: There is no ::IsWindow() equivalent in wxWidgets
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar); 
			gnStart = pApp->m_nStartChar;
			gnEnd = pApp->m_nEndChar;
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		return;
	}

	// check for a null source phrase in the selection, and abort the merge operation if there
	// is one
	if (IsNullSrcPhraseInSelection(pList))
	{
		// IDS_NO_NULL_SRCPHRASE_IN_SEL
		wxMessageBox(_("Sorry, but merging a selection which contains a placeholder (represented by ... dots) is not permitted."),_T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		// WX Note: There is no ::IsWindow() equivalent in wxWidgets
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
			gnStart = pApp->m_nStartChar;
			gnEnd = pApp->m_nEndChar;
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		return;
	}

	// check for filtered material in a non-initial sourcephrase instance,
	// and abort the merge operation if there is some (we could handle it, but
	// we just don't want to - for instance, nav text might be too long to
	// view properly, and the green wedge would disappear and editability of
	// the filtered stuff would be lost)
	if (IsFilteredMaterialNonInitial(pList))
	{
		//IDS_NO_MERGE_FILTERED
		wxMessageBox(_("Merging words across filtered material is not allowed."), _T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
			gnStart = pApp->m_nStartChar;
			gnEnd = pApp->m_nEndChar;
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		return;
	}

	// check user is not trying to do a merger across the end of a free translation - it
	// can legally be done up to the end, but not across it (BEW added 22Jul05)
	if (IsSelectionAcrossFreeTranslationEnd(pList))
	{
		//IDS_NO_MERGE_ACROSS_FT_END
		wxMessageBox(_("Merging across the end of a free translation is not permitted. (You can merge up to the end of the free translation, but not beyond that point in the same merger.)"), _T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar); 
			gnStart = pApp->m_nStartChar;
			gnEnd = pApp->m_nEndChar;
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		return;
	}

	// there might be some <Not In KB> source phrases in the list, so ensure the srcPhrases
	// have the flag cleared (added 1-Feb-2001)
	// Up to this point pos has been assigned as CCellList::Node* and SPList has not had a
	// node assigned to it, so we'll do that now. We can't use pos here because it is already
	// a node associated with a CCellList. BE CAREFULL not to mix pos and nodeSPTemp below as the
	// condition for while loops, etc!!!
	SPList::Node* nodeSPTemp = pList->GetFirst(); 

	while (nodeSPTemp != NULL)
	{

		CSourcePhrase* pSP = (CSourcePhrase*)nodeSPTemp->GetData();
		nodeSPTemp = nodeSPTemp->GetNext();
		wxASSERT(pSP != 0);
		pSP->m_bNotInKB = FALSE;
	}

	// if there are too many words in the selection, do a retranslation instead of a merge
	if (GetSelectionWordCount() > MAX_WORDS)
	{
		DoRetranslation();
		gbMergeSucceeded = FALSE;
		return;
	}

	// make pApp->m_targetPhrase cleared, as it must accumulate any existing translations
	// removed from the KB because of the merge
	pApp->m_targetPhrase.Empty();

	// determine if there are any non-minimal phrases selected. If there are, we must
	// restore the original list of minimal phrases (ie. words), and clear the
	// translations from the KB, before proceeding.
	int nNumElements = 1;
	nodeSPTemp = pList->GetFirst();
	while (nodeSPTemp != NULL)
	{
		//POSITION savePos = pos; // savePos is not used in this loop/block

		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();
		nodeSPTemp = nodeSPTemp->GetNext(); 
		int nStartingSequNum = pSrcPhrase->m_nSequNumber;
		nNumElements = 1;
		if (pSrcPhrase->m_nSrcWords > 1)
		{
			// have to restore to original state (RestoreOriginalMinPhrases also
			// appends any adaptation(s) to pApp->m_targetPhrase)
			nNumElements = RestoreOriginalMinPhrases(pSrcPhrase,nStartingSequNum);

			// update the bundle indices, and nCount
			int nExtras = nNumElements - 1;
			pApp->m_endIndex += nExtras;
			pApp->m_upperIndex += nExtras;
			pApp->m_maxIndex += nExtras;
			nCount += nExtras;

			// BEW added 30Sep08 in support of vertical editing
			if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
			{
				gEditRecord.nAdaptationStep_EndingSequNum += nExtras;
				gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nExtras;
				gEditRecord.nAdaptationStep_NewSpanCount += nExtras;
			}

		}
		else
		{
			// append its m_translation in the CRefString to pApp->m_targetPhrase, then remove
			// the refString from the KB, etc.
			CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
														pSrcPhrase->m_key,pSrcPhrase->m_adaption);
			if (pRefString != NULL)
			{
				if (pRefString->m_translation != _T("<Not In KB>"))
				{
					if (pApp->m_targetPhrase.IsEmpty())
						pApp->m_targetPhrase = pRefString->m_translation;
					else
					{
						if (!pRefString->m_translation.IsEmpty())
						{
							pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + pRefString->m_translation;
						}
					}
					// the following call needs to be within this block, not after it, because we
					// don't want to also remove any <Not In KB> entries from the KB
					// (altered 1-Feb-2001)
					RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);
				}
			}
			else
			{
				// if all else fails to find some text for this box (provided it is the active
				// location), then pull out whatever is stored in the CEdit itself - since if we
				// got here by a click, then the KB will have been modified
				if (pSrcPhrase == pApp->m_pActivePile->m_pSrcPhrase)
				{
					// WX Note: There is no ::IsWindow() equivalent in wxWidgets
					if (pApp->m_pTargetBox->GetHandle() != NULL)
					{
						if (pApp->m_targetPhrase.IsEmpty())
							pApp->m_targetPhrase = pApp->m_pTargetBox->GetValue();
						else
						{
							wxString str;
							str = pApp->m_pTargetBox->GetValue();
							pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + str;
						}
					}
				}
			}
		}
	}

	// delete the temporary list, and then do the merge using the restored minimal phrases for
	// the original selection
	pList->Clear();
	delete pList;
	pList = (SPList*)NULL;

	// at this point, pApp->m_targetPhrase may not have anything in it, because no accumulation was
	// possible, so check if it is empty and if so then restore it from the window's title text.
	if (pApp->m_targetPhrase.IsEmpty())
	{
		// WX Note: There is no ::IsWindow() equivalent in wxWidgets
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_targetPhrase = pApp->m_pTargetBox->GetValue();
		}
	}

	/*
	// a block for debugging, to check adaptation span boundaries before the merge
	if (gbVerticalEditInProgress)
	{
		int nStartSN = gEditRecord.nAdaptationStep_StartingSequNum;
		int nEndSN = gEditRecord.nAdaptationStep_EndingSequNum;
		int nExtrasFromEdits = gEditRecord.nAdaptationStep_ExtrasFromUserEdits;
		int nNewSpanCnt = gEditRecord.nAdaptationStep_NewSpanCount;
	}
	*/
	// determine the first srcPhrase in the merge operation
	nodeSPTemp = pSrcPhrases->Item(nSaveSequNum);
	wxASSERT(nodeSPTemp != NULL);
	CSourcePhrase* pFirstSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();
	nodeSPTemp = nodeSPTemp->GetNext();// needed for SPList
	wxASSERT(pFirstSrcPhrase != NULL);
	wxASSERT(pFirstSrcPhrase->m_nSrcWords == 1 || pFirstSrcPhrase->m_nSrcWords == 0); // no phrases
																					// allowed
	wxASSERT(nodeSPTemp != NULL); 

	// we will try accumulating a default "adaptation" string, if strOldAdaptation is empty,
	// otherwise use the latter
	wxString strAdapt;
	strAdapt.Empty();
	if (strOldAdaptation.IsEmpty())
	{
		if (pFirstSrcPhrase->m_targetStr.IsEmpty())
		{
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			if (pApp->m_bCopySource)
				strAdapt = CopySourceKey(pFirstSrcPhrase,pApp->m_bUseConsistentChanges);
			else
				; // leave it empty
		}
		else
		{
			strAdapt = pFirstSrcPhrase->m_targetStr;
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
	}

	// ensure a correct active sequ num when done
	pApp->m_nActiveSequNum = nSaveSequNum;

	// starting from the next minimal srcPhrase, Merge each succeeding one to pFirstSrcPhrase
	// (whether LTR or RTL layout, we always merge in logical order (ie. order of ascending
	// sequence numbers), and unmerge likewise, it is only the relative order of the words in
	// the text strings which are compiled which reverses for RTL)
	for (int i = 1; i < nCount; i++)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData(); //CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pSrcPhrases->GetNext(pos);
		nodeSPTemp = nodeSPTemp->GetNext(); // needed for SPList
		wxASSERT(pSrcPhrase != NULL);
		wxASSERT(pSrcPhrase->m_nSrcWords == 1 || pSrcPhrase->m_nSrcWords == 0); // no phrases allowed

		pFirstSrcPhrase->Merge(this,pSrcPhrase);

		// compose a default adaptation string, as best we can
		if (strOldAdaptation.IsEmpty())
		{
			if (pSrcPhrase->m_adaption.IsEmpty())
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (pApp->m_bCopySource)
				{
					// don't add these ones which are additional to the first if the flag wants suppression
					if (!bSuppressCopyingExtraSourceWords)
						strAdapt += _T(" ") + CopySourceKey(pSrcPhrase,pApp->m_bUseConsistentChanges);
				}
				else
					; // leave it empty
			}
			else
			{
				strAdapt += _T(" ") + pSrcPhrase->m_adaption;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
				bNoninitialSelectionsHaveTranslation = TRUE;
			}
		}
	}

	// put our default string into pApp->m_targetPhrase to be shown in the phrase box, provided we
	// have not temporarily suppressed the default adaptation using the global flag...

	// BEW added 05Oct06; here we supply a code block to implement a protocol for deriving
	// text for the phrase box when the selection has been made leftwards, so the active
	// location is at the end of the selection; and we have two scenarios- the box contents
	// are all selected (we'll assume that is due to a copy of source text and therefore use
	// m_bAbandonable == TRUE to detect it; if the selection has been made manually then too
	// bad, the user will have to do a little editing to removed the unwanted word which will
	// have been accepted when it was intended to have been removed by what the user typed); or
	// the active location will not have a selection (use m_bAbandonable == FALSE) and so we
	// assume that the box's text is to be retained and accumulated with the rest which was
	// accumulated earlier
	if (pApp->m_curDirection == left)
	{
		// implementing a protocol for leftwards selections...

		// get the number of characters in the phrasebox's text, and determine how far from
		// the end is the cursor
		wxString strBox = _T("");
		strBox = pApp->m_pTargetBox->GetValue();
		int strBoxLen = strBox.Length();
		long nStart;
		long nEnd;
		pApp->m_pTargetBox->GetSelection(&nStart,&nEnd);

		if (pApp->m_pTargetBox->m_bAbandonable)
		{
			// user won't have typed anything, so the box text should have been selected when
			// the merge was initiated
			if (nStart == 1 && nEnd == 1 && strBoxLen == 1)
			{
				// the contents were selected and what the user typed replaced them
				pApp->m_targetPhrase = strBox;
				pApp->m_nStartChar = pApp->m_nEndChar = 1; // make RemakePhraseBox() position the cursor after the
											   // character which the user typed to replace the selection
			}
			else
			{
				// anything else, we'll retain the box contents and accumulate it at the end of
				// strOldAdaptation, and try get the cursor where the user left it
				pApp->m_targetPhrase = strOldAdaptation;
				pApp->m_targetPhrase.Trim(FALSE); // trim left end
				pApp->m_targetPhrase.Trim(TRUE); // trim right end
				int itsLen = pApp->m_targetPhrase.Length();
				int nFromEnd = strBoxLen - nEnd;
				pApp->m_nStartChar = itsLen - nFromEnd;
				pApp->m_nEndChar = itsLen - nFromEnd;
			}
		}
		else
		{
			// retain the box contents and accumulate it at the end of
			// strOldAdaptation, and try get the cursor where the user left it
			pApp->m_targetPhrase = strOldAdaptation;
			pApp->m_targetPhrase.Trim(FALSE); // trim left end
			pApp->m_targetPhrase.Trim(TRUE); // trim right end
			int itsLen = pApp->m_targetPhrase.Length();
			int nFromEnd = strBoxLen - nEnd;
			pApp->m_nStartChar = itsLen - nFromEnd;
			pApp->m_nEndChar = itsLen - nFromEnd;
		}
	}
	else
	{
		// legacy behaviour, that is, typically forward selection. Nothing changed here.
		if (!bSuppressDefaultAdaptation)
		{
			if (strOldAdaptation.IsEmpty())
				pApp->m_targetPhrase = strAdapt;
			else
				pApp->m_targetPhrase = strOldAdaptation;
		}
	}

	// count how many have to be removed from the m_pSourcePhrases list on the app
	int nRemoveCount = nCount - 1; // that is, all but the first

	// BEW added 09Sep08 in support of vertical editing
	if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
	{
		gEditRecord.nAdaptationStep_EndingSequNum -= nRemoveCount;
		gEditRecord.nAdaptationStep_ExtrasFromUserEdits -= nRemoveCount; // LHS can become -ve legally
		gEditRecord.nAdaptationStep_NewSpanCount -= nRemoveCount;
	}

	/*
	// a block for debugging, to check adaptation span boundaries after the merge
	if (gbVerticalEditInProgress)
	{
		int nStartSN = gEditRecord.nAdaptationStep_StartingSequNum;
		int nEndSN = gEditRecord.nAdaptationStep_EndingSequNum;
		int nExtrasFromEdits = gEditRecord.nAdaptationStep_ExtrasFromUserEdits;
		int nNewSpanCnt = gEditRecord.nAdaptationStep_NewSpanCount;
	}
	*/
	// check all is well (Debug version only)
	wxASSERT(pApp->m_nActiveSequNum == pFirstSrcPhrase->m_nSequNumber);

	// remove from the list the ones which have been merged to the first
	nodeSPTemp = pSrcPhrases->Item(pApp->m_nActiveSequNum + 1); // position of first to be removed
	SPList::Node* savePos; // used below
	wxASSERT(nodeSPTemp != NULL);
	int j = 0;
	while (nodeSPTemp != NULL && j < nRemoveCount)
	{
		savePos = nodeSPTemp;
		CSourcePhrase* pSrcPhrase;
		pSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData(); 
		nodeSPTemp = nodeSPTemp->GetNext(); 
		pSrcPhrases->DeleteNode(savePos); // remove pointer, but leave srcPhrase on the heap,
		j++;							// because it is pointed at from within pFirstSrcPhrase now
	}

	// fix up the bundle's indices
	pApp->m_maxIndex -= nRemoveCount;
	pApp->m_endIndex -= nRemoveCount;
	pApp->m_upperIndex -= nRemoveCount;

	// ensure there is no selection, if we don't do this here, then the RestoreSelection() call at
	// the end of RecalcLayout() will fail
	RemoveSelection();

	// get the strip index
	CSourceBundle* pBundle = pStartingPile->m_pBundle;
	RecalcLayout(pSrcPhrases,0 /* nStripIndex safer from 0 */, pBundle); // recalculate from
																		 // nStripIndex onwards
	// get a new (valid) active pile pointer, now that the layout is recalculated
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);

	// update the sequence numbers which follow the active sequ num
	UpdateSequNumbers(pApp->m_nActiveSequNum);

	// create the phraseBox at the active pile...
	// BEW added note 05OctO6: the RemakePhraseBox call uses the view class's members m_nStartChar
	// and m_nEndChar to set the selection or cursor position in the phrase box, and those have been
	// set correctly for a leftwards selection in code added above; but OnButtonMerge() returns to
	// OnChar() if merging was by the user typing a key; and OnChar() has already preserved initial
	// values for the start and end positions for the selection which it would then proceed to use
	// and, for a leftwards selection, almost certainly, wipe out the values we want to be used,
	// so a test has been added in OnChar() (it involves gbMergeSucceeded == TRUE which is set just
	// before OnButtonMerge() returns, and m_curDirection == left) to suppress using the values saved
	// at the start of OnChar() in that circumstance, so that the ones set here are used
	pApp->m_ptCurBoxLocation = pApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;
	RemakePhraseBox(pApp->m_pActivePile,pApp->m_targetPhrase);

	// we don't want the code after the MergeWords( ) call (which calls OnButtonMerge()) to
	// remove this remade box's translation if the contents of the box hold more than just the last
	// single character which the user typed, provided that the selections beyond the active
	// location don't have any translation - if they do then we would instead interpret the single
	// keypress as an attempt to replace the earlier stuff. We get what we want by setting
	// gbRetainBoxContents since OnChar( ) will test the value on return from MergeWords( ).
	// Two local flags are needed to get this to happen at just the right times.
	int newLen = pApp->m_targetPhrase.Length();
	if (newLen > 1 && !bNoninitialSelectionsHaveTranslation)
		gbRetainBoxContents = TRUE;

	// set gLastSrcPhrasePos, in case we merged backwards (in which case the former POSITION value
	// for the old phrase box location no longer is valid)
	/* BEW removed 31Jan01 because the global's value is not always reliable
	gLastSrcPhrasePos = pApp->m_pSourcePhrases->Item(pApp->m_nActiveSequNum);
	*/

	// set up the m_inform attribute, if there are medial markers
	if (pFirstSrcPhrase->m_bHasInternalMarkers)
	{
		wxString s = _T(" Medial markers: "); // English for this string might be a problem?
		if (!pFirstSrcPhrase->m_pMedialMarkers->IsEmpty())
		{
			// m_pMedialMarkers is a wxArrayString so let iterate through it with a for loop
			for (int i = 0; i < (int)pFirstSrcPhrase->m_pMedialMarkers->GetCount(); i++)
			{
				s += pFirstSrcPhrase->m_pMedialMarkers->Item(i);
			}
			pFirstSrcPhrase->m_inform += s;
		}
	}
	Invalidate();
	gbMergeSucceeded = TRUE;
}

void CAdapt_ItView::UpdateSequNumbers(int nFirstSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList = pApp->m_pSourcePhrases;

	// get the first
	SPList::Node* pos = NULL;
	if (nFirstSequNum == 0)
	{
		// don't do a Find to get the first one, in case numbers are not
		// currently up to date at the beginning
		pos = pList->GetFirst();
	}
	else
	{
		// for non-zero values, trust a Find will succeed - this is a potential
		// source of error, but since we almost always pass in zero, and we
		// try to keep numbers correct anyway, the risk is pretty small
		pos = pList->Item(nFirstSequNum);
	}
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext(); // needed for SPList
	wxASSERT(pSrcPhrase != NULL);
	pSrcPhrase->m_nSequNumber = nFirstSequNum;
	int index = nFirstSequNum;

	while (pos != 0)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		index++; // next sequence number
		pSrcPhrase->m_nSequNumber = index;
	}
}

int CAdapt_ItView::RestoreOriginalMinPhrases(CSourcePhrase *pSrcPhrase, int nStartingSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int nCount = pSrcPhrase->m_nSrcWords;
	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* pos = pList->Item(nStartingSequNum);
	wxASSERT(pos != NULL);
	SPList::Node* savePos = pos; // used later below
	CSourcePhrase* pBigOne = (CSourcePhrase*)pos->GetData();
	wxASSERT(pBigOne != NULL);

	// BEW added 01Aug05 for free translation support; the merged source phrase may be part of
	// a free translation, but it's original saved sourcephrase pointers may not have any free
	// translation defined on them (because the user did the free translating after the merge
	// was done); or alternatively, there may have been a free translation defined on the original
	// sourcephrase instances in the merger (because the user merged after doing the free translating --
	// and if the latter is the case then the first of the original sourcephrases may, or may not
	// contain a non-empty m_markers member which stores the filtered free translation -- but we can
	// be sure that no medial sourcephrase instance stores a free translation because the app will
	// not allow merging across filtered material, the filtered material can only be on the first
	// sourcephrase of the merge, or there must be no filtered material on any sourcephrase in the merge
	// -- this protocol simplifies what we must test for). If the merged source phrase starts a free
	// translation, we will make all the restored original sourcephrases be within that free translation,
	// and if it also ends the free translation, then the last of the restored ones will also end the
	// retranslation
	bool bHasNonEmptyM_Markers = !pBigOne->m_markers.IsEmpty() ? TRUE : FALSE;
	bool bHasFreeTrans = pBigOne->m_bHasFreeTrans ? TRUE : FALSE;
	bool bStartsAFreeTranslation = pBigOne->m_bStartFreeTrans ? TRUE : FALSE;
	bool bEndsAFreeTranslation = pBigOne->m_bEndFreeTrans ? TRUE : FALSE;

	// BEW added 27Dec07: to handle preservation of any Note's m_bHasNote == TRUE value
	// across the unmerge; since we now allow a merge if filtered info is on the first word or phrase
	// in the selection
	bool bHasNote = pBigOne->m_bHasNote ? TRUE : FALSE; // the value is used below

	// set the first in the saved original srcPhrase objects to have sequ number as passed in
	SPList::Node* pos1;
	SPList* pSaved = pBigOne->m_pSavedWords;
	pos1 = pSaved->GetFirst();
	wxASSERT(pos1 != NULL);
	CSourcePhrase* pSP = (CSourcePhrase*)pos1->GetData();
	wxASSERT(pSP != NULL);
	pSP->m_nSequNumber = nStartingSequNum; // this ensures we renumber correctly using
										   // UpdateSequNum()
	pSP->m_bHasKBEntry = FALSE;
	pSP->m_bRetranslation = FALSE; // otherwise, after a wrong retranslation & cancel, it is
								   // possible to have this flag wrongly still set TRUE, & text
								   // of wrong colour shows

	// handle any initial filtered material, including any free translation which is filtered
	// and any Note's flag
	if (bHasNote)
	{
		pSP->m_bHasNote = pBigOne->m_bHasNote; // transfer the Note flag's value when TRUE
	}
	if (bHasNonEmptyM_Markers)
	{
		pSP->m_markers = pBigOne->m_markers; // transfer the material in m_markers to the first one
	}
	// handle the flag for commencement of a free translation section
	if (bStartsAFreeTranslation)
	{
		pSP->m_bStartFreeTrans = TRUE;
	}
	else
	{
		pSP->m_bStartFreeTrans = FALSE;
	}

	// insert, starting from tail, after the pBigOne, thereby preserving original element order
	pos1 = pSaved->GetLast(); 
	// now pos1 points at the last item of pBigOne's pSaved list
	wxASSERT(pos1 != NULL);
	bool bIsLast = TRUE;

	// wx Note: Get a node called newInsertBeforePos which points to the next node beyond savePos
	// in pList and use its position in the Insert() call (which only inserts
	// BEFORE the indicated position). The result should be that the insertions
	// will get placed in the list the same way that MFC's InsertAfter() places them.
	SPList::Node* newInsertBeforePos = savePos->GetNext();
	while (pos1 != NULL)
	{
		CSourcePhrase* pSP = (CSourcePhrase*)pos1->GetData();
		pos1 = pos1->GetPrevious();
		pSP->m_bHasKBEntry = FALSE;

		// wxList has no equivalent to InsertAfter(). The wxList Insert() method
		// inserts the new node BEFORE the current position/node. To emulate what
		// the MFC code does, we insert before using newInsertBeforePos.
		// wx note: If newInsertBeforePos is NULL, it means the insert position is
		// at the end of the list; in this case we just append the item to the end
		// of the list.
		if (newInsertBeforePos == NULL)
			pList->Append(pSP);
		else
			pList->Insert(newInsertBeforePos,pSP);

		// since we must now insert before the inserted node above, we need to get a
		// previous node (which will actually be the just inserted source phrase)
		newInsertBeforePos = newInsertBeforePos->GetPrevious();

		// handle any free translation booleans needing to be set; a free translation is either to be defined
		// on all the original instances, or it is defined for none - and if the merger was also the end
		// of a free translation, then the end of the originals must have the m_bEndFreeTrans flag set too
		if (bHasFreeTrans)
			pSP->m_bHasFreeTrans = TRUE;
		else
			pSP->m_bHasFreeTrans = FALSE;
		if (bIsLast)
		{
			if (bEndsAFreeTranslation)
				pSP->m_bEndFreeTrans = TRUE;
			else
				pSP->m_bEndFreeTrans = FALSE;
			bIsLast = FALSE; // prevent subsequent access to this block
		}

		// prior to version 2.0, unmerging cleared the m_adaption and m_targetStr members on
		// the restored original minimal sourcephrases. This is too severe a behaviour, there is
		// no good reason why any original adaptations can't remain in place and their entries
		// restored to the KB (if non-null), so this is what I will do here now.
		if (!pSP->m_adaption.IsEmpty())
		{
			// restore its KB entry
			bool bOK;
			bOK = StoreText(gpApp->m_pKB,pSP,pSP->m_adaption);
		}

		if (IsItNotInKB(pSP))
			pSP->m_bNotInKB = TRUE;
		else
			pSP->m_bNotInKB = FALSE;
		pSP->m_bRetranslation = FALSE; // otherwise, after a wrong retranslation & cancel, it is
									   // possible to have this flag wrongly still set TRUE, &
									   // text of wrong colour shows
	}

	// pBigOne will not be needed any longer, and its KB stuff must be removed or reference
	// decremented; append any refString's m_translation to the pApp->m_targetPhrase, so user can edit
	// or delete the resulting composite string when the phraseBox is eventually put up  (note,
	// next call, pRefString may point to <Not In KB>)
	CRefString* pRefString = GetRefString(GetKB(),pBigOne->m_nSrcWords,
														pBigOne->m_key,pBigOne->m_adaption);
	pList->DeleteNode(savePos);
	if (pBigOne->m_bHasKBEntry)
	{
		RemoveRefString(pRefString,pBigOne,pBigOne->m_nSrcWords);
		pBigOne->m_bHasKBEntry = FALSE;

		// set up pApp->m_targetPhrase using pBigOne's m_targetStr attribute
		if (pApp->m_targetPhrase.IsEmpty())
			pApp->m_targetPhrase = pBigOne->m_targetStr;
		else
			pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + pBigOne->m_targetStr;
	}
	else
	{
		// might have had save to KB suppression turned on, so check this case out too -
		// if the flag is set, we don't need to remove anything from the KB, but we do need to set
		// pApp->m_targetPhrase using the m_targetStr string's value
		if (pBigOne->m_bNotInKB)
		{
			if (pApp->m_targetPhrase.IsEmpty())
				pApp->m_targetPhrase = pBigOne->m_targetStr;
			else
			{
				if (!pBigOne->m_targetStr.IsEmpty())
					pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + pBigOne->m_targetStr;
			}
		}
	}

	if (pBigOne->m_pMedialMarkers->GetCount() > 0)
	{
		pBigOne->m_pMedialMarkers->Clear();
	}
	delete pBigOne->m_pMedialMarkers;
	pBigOne->m_pMedialMarkers = (wxArrayString*)NULL;
	if (pBigOne->m_pMedialPuncts->GetCount() > 0)
	{
		pBigOne->m_pMedialPuncts->Clear();
	}
	delete pBigOne->m_pMedialPuncts;
	pBigOne->m_pMedialPuncts = (wxArrayString*)NULL;
	if (pBigOne->m_pSavedWords->GetCount() > 0)
	{
		// only remove pointers, never delete the memory they point to, because
		// any copies of this source phrase will only have copied pointers in the sublist
		pBigOne->m_pSavedWords->Clear();
	}
	delete pBigOne->m_pSavedWords;
	pBigOne->m_pSavedWords = (SPList*)NULL;
	delete pBigOne;
	pBigOne = (CSourcePhrase*)NULL;

	// update the sequence numbers for elements subsequent to the first
	UpdateSequNumbers(nStartingSequNum);

	return nCount;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If the application is in glossing mode, or it is showing only the target text, or the m_pActivePile 
/// pointer is NULL, or the active pile's m_pSrcPhrase is NULL, this handler disables the "Unmake A 
/// Phrase" toolbar item and returns immediately. 
/// If the App's m_selectionLine is not -1, and the App's m_selection list has exactly one item in its
/// list associated with a previous merger, or alternatively, if the App's m_selectioniLine is -1, and 
/// the first item in in the active pile's m_selection is associated with a previous merger, it 
/// enables the toolbar button, otherwise it disables the toolbar button. 
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRestore(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL || pApp->m_pActivePile->m_pSrcPhrase == NULL)//whm added last || m_pSrcPhrase == NULL
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1 && pApp->m_selection.GetCount() == 1)
	{
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = cpos->GetData();
		CSourcePhrase* pSP = pCell->m_pPile->m_pSrcPhrase;
		if (pSP->m_nSrcWords > 1)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
	else if (pApp->m_selectionLine == -1 && pApp->m_pTargetBox != NULL
											&& pApp->m_pTargetBox->IsShown())
	{
		CSourcePhrase* pSP = pApp->m_pActivePile->m_pSrcPhrase;
		if (pSP->m_nSrcWords > 1)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::UnmergePhrase()
{
	wxCommandEvent dummyevent;
	OnButtonRestore(dummyevent); // since is protected, & we want to call it from OnChar in CPhraseBox class
}

void CAdapt_ItView::OnButtonRestore(wxCommandEvent& WXUNUSED(event))
// removes a merged phrase by restoring it to a sequence of the original CSourcePhrase instances
// which were stored on the merged phrase at the time of merger
// BEW changed 27Dec07: unmerging when there was a note stored on the merger did not retain the m_bHasNote
// flag value by setting it on the first CSourcePhrase instance in the unmerged sequence, so I fixed it
// so it would do so
{
	// Since the Restore (Unmerge) toolbar button has an accelerator table hot key (CTRL-U see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_RESTORE))
	{
		::wxBell();
		return;
	}

	// In glossing mode (ie. actually glossing) I think I've managed to silently prevent
	// any unmerge from happening before OnButtonRestore( ) can get invoked. However, it the
	// user were to explicitly click the button, there is no recourse except to tell him
	// that the removing a merger is not available when doing glossing
	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),_T(""),wxICON_INFORMATION);
		return;
	}

	// must be adapting mode, so continue with the request
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;
	CPile* pActivePile;
	CPile* pPile;
	CCellList::Node* pos;
	CSourcePhrase* pSrcPhrase;
	int nCount;
	int nSaveSequNum;

	// get the single selected CSourcePhrase instance, or the location of phrasebox if no selection
	if (pApp->m_selectionLine != -1)
	{
		pos = pApp->m_selection.GetFirst();
		nCount = pApp->m_selection.GetCount();
		wxASSERT(nCount == 1); // must only be one

		CCell* pCell = (CCell*)pos->GetData();
		pos = pos->GetNext();
		pPile = pCell->m_pPile; // get the pile for this selection
		pStartingPile = pPile; // need this for later when we look up the strip which first pile
							   // is in prior to calling RecalcLayout
		pSrcPhrase = pPile->m_pSrcPhrase;
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything depends on it

		// there could be an edited phrase waiting for a RETURN key press, and the selection may be
		// on a different pile, in which case unless we update the active pile's srcPhrase
		// before doing the restore, the latter would be wrongly cleared of its adaptation text, so
		// we check for such a condition here & do the necessary fixes before proceeding
		pActivePile = pApp->m_pActivePile;
		if (pActivePile != pStartingPile)
		{
			// the selected pile is not the active one, so update the active one then make the
			// selected one the active one; so store the translation in the knowledge base
			MakeLineFourString(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
			RemovePunctuation(pDoc,&pApp->m_targetPhrase,1 /*from tgt*/);
			gbInhibitLine4StrCall = TRUE;
			bool bOK = StoreText(pApp->m_pKB,pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
			gbInhibitLine4StrCall = FALSE;
			if (!bOK)
				return; // can't proceed until a valid adaption (which could be null) is supplied
						// for the former active pile's srcPhrase
			else
			{
				int nFormerStrip = pActivePile->m_pStrip->m_nStripIndex;
				pApp->m_pActivePile = pStartingPile;
				pApp->m_pTargetBox->SetValue(_T("")); // we don't want the former active pile's text
												   // to be carried to the selected pile
				int nCurStripIndex = pStartingPile->m_pStrip->m_nStripIndex;
				if (nCurStripIndex != nFormerStrip)
				{
					// layout the former strip too, if it is not the current one
					LayoutStrip(pSrcPhrases,nFormerStrip,pApp->m_pBundle);
					Invalidate();
				}
			}
		}
	}
	else
	{
		// no selection, so just remove the merger at wherever the phraseBox currently is located
		pPile = pApp->m_pActivePile;
		pStartingPile = pPile;
		pSrcPhrase = pPile->m_pSrcPhrase;
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything depends on it
	}

	// make m_targetPhrase cleared, as it must accumulate any existing translations
	// removed from the KB because of the earlier merge
	pApp->m_targetPhrase.Empty();


	// determine that it is a genuine non-minimal phrase. If it is, we must
	// restore the original list of minimal phrases (ie. words), and clear the
	// translations from the KB.
	wxASSERT(pSrcPhrase->m_nSrcWords > 1);
	int nNumElements = 1;
	// RestoreOriginalMinPhrases also appends any adaptation to m_targetPhrase;
	// it also updates sequ numbers after the restore is done
	nNumElements = RestoreOriginalMinPhrases(pSrcPhrase,nSaveSequNum);

	// at this point, m_targetPhrase will have the target text in it if the selection was done
	// by clicking with the mouse on the source line 2; but if the click was on the target cell
	// then the KB will have had the adaption text cleared (or refCount reduced) and the target
	// text will have been preserved only in the phraseBox itself; so we must check for the
	// latter case and restore the text before proceeding
	if (pApp->m_targetPhrase.IsEmpty())
		pApp->m_targetPhrase = pApp->m_pTargetBox->GetValue();

	// update the bundle indices
	int nExtras = nNumElements - 1;
	pApp->m_endIndex += nExtras;
	pApp->m_upperIndex += nExtras;
	pApp->m_maxIndex += nExtras;

	// BEW added 09Sep08 in support of vertical editing
	if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
	{
		gEditRecord.nAdaptationStep_EndingSequNum += nExtras;
		gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nExtras; // LHS can become -ve legally
		gEditRecord.nAdaptationStep_NewSpanCount += nExtras;
	}

	// pos is defined as CCellList node above, so we must use a different identifier here
	// since we want a SPList node
	SPList::Node* posSP;
	posSP = pSrcPhrases->Item(nSaveSequNum); //pos = pSrcPhrases->FindIndex(nSaveSequNum);
	wxASSERT(posSP != NULL);
	CSourcePhrase* pFirstSrcPhrase;
	pFirstSrcPhrase = (CSourcePhrase*)posSP->GetData();
	posSP = posSP->GetNext();
	wxASSERT(pFirstSrcPhrase != NULL);
	wxASSERT(pFirstSrcPhrase->m_nSrcWords == 1 || pFirstSrcPhrase->m_nSrcWords == 0); // no phrases
																					// allowed
	wxASSERT(posSP != NULL);

	// ensure a correct active sequ num when done
	pApp->m_nActiveSequNum = nSaveSequNum;

	// must ensure there is no selection & the selection globals are set to -1, otherwise
	// RecalcLayout will fail
	RemoveSelection();

	// get the strip index
	CSourceBundle* pBundle = pStartingPile->m_pBundle;
	pApp->m_curBoxWidth = 2; // force a small value, so that a large gap is not left where the long
					   // phraseBox formerly was
	RecalcLayout(pSrcPhrases, 0 /* nStripIndex safer from 0 */, pBundle); // recalculate from
																		  // nStripIndex onwards

	// get a new (valid) active pile pointer, now that the layout is recalculated
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);

	// look up the single src word in the KB; if we can get a translation for it, use that, if not
	// then just retain the old merged phrase's translation
	bool bWantSelect = FALSE;
	bool bGotTranslation;
	if (!gbSuppressLookup)
	{
		gbUnmergeJustDone = TRUE; // prevent second OnButtonRestore() call from within
								  // ChooseTranslation() within LookUpSrcWord() if user happens
								  // to cancel the Choose Translation dialog (see CPhraseBox code)
		bGotTranslation = pApp->m_pTargetBox->LookUpSrcWord(this,pApp->m_pActivePile);
		gbUnmergeJustDone = FALSE; // clear flag, ready for next time
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum); // restore pointer, since LookUpSrcWord()
															  // now calls RecalcLayout
		if (bGotTranslation)
		{
			// we have to check here, in case the translation it found was a "<Not In KB>"
			// - in which case, we must display an empty box and ensure that the pile has an
			// asterisk above it, etc
			if (translation == _T("<Not In KB>"))
			{
				pApp->m_targetPhrase.Empty(); // phrase box must be shown empty
				pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
				pApp->m_pActivePile->m_pSrcPhrase->m_bNotInKB = TRUE;
				pApp->m_pActivePile->m_pSrcPhrase->m_adaption.Empty();
				pApp->m_pActivePile->m_pSrcPhrase->m_targetStr.Empty();
				bWantSelect = FALSE;
			}
			else
			{
				pApp->m_targetPhrase = translation; // set using the global var, set in LookUpSrcWord()
				bWantSelect = TRUE;
			}
		}
		else // no translation found
		{
			// do the copy of source instead, or nothing if Copy Source flag is not set
			if (pApp->m_bCopySource)
			{
				// copy source key only provided this is not a null source phrase, don't want
				// "..." copied!
				pApp->m_targetPhrase =
						CopySourceKey(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_bUseConsistentChanges);
				bWantSelect = TRUE;
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
			}
			else
			{
				pApp->m_targetPhrase.Empty();
				bWantSelect = FALSE;
			}
		}

		// need to recalc layout again
		pApp->m_curBoxWidth = 2;
		RecalcLayout(pSrcPhrases, 0, pBundle); // recalculate from nStripIndex onwards
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pApp->m_pActivePile != NULL);
	}
	else // was suppressed, so clear the flag now
	{
		gbSuppressLookup = FALSE;
	}

	if (bWantSelect)
	{
		pApp->m_nStartChar = 0; pApp->m_nEndChar = -1;
	}
	else
	{
		int len = pApp->m_targetPhrase.Length();
		pApp->m_nStartChar = pApp->m_nEndChar = len;
	}

	// create the phraseBox at the active pile
	pApp->m_ptCurBoxLocation = pApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;
	RemakePhraseBox(pApp->m_pActivePile,pApp->m_targetPhrase);

	// reset gLastSrcPhrasePos to new location, since the old box position could have been clobbered
	// by the unmerge, which would make the global invalid
	/* BEW removed 31Jan01 because the global's value is not always reliable
	gLastSrcPhrasePos = pSrcPhrases->Item(pApp->m_nActiveSequNum);
	*/

	Invalidate();
}

bool CAdapt_ItView::ExtendSelectionRight()
// return TRUE if the selection extended, FALSE if not (would be false only if at a boundary)
// this function works with selections on the 2nd line only; m_pAnchor is always the pile at
// which the phraseBox currently is; this function is only for the ALT plus arrow key selection
// method
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	// can't extend if we are showing only the target line
	if (gbShowTargetOnly)
		return TRUE; // don't want message about boundaries

	// remove an existing selection if it was not done using the arrow key, save
	// m_bRespectBoundaries across this operation
	bool bSaveFlag = pApp->m_bRespectBoundaries;

	if (pApp->m_selection.GetCount() > 0 && !pApp->m_bSelectByArrowKey)
	{
		RemoveSelection();
		Invalidate();
	}
	// restore flag (and button)
	if (bSaveFlag == FALSE)
	{
		OnButtonFromRespectingBdryToIgnoringBdry(dummyevent);
	}

	// need a CClientDC
	wxClientDC aDC(pApp->GetMainFrame()->canvas); 

	canvas->DoPrepareDC(aDC); //OnPrepareDC(&aDC); // adjust the origin
	canvas->pFrame->PrepareDC(aDC); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame

	CPile* pActivePile = pApp->m_pActivePile;
	wxASSERT(pActivePile != NULL);
	pApp->m_pAnchor = pActivePile->m_pCell[1];
	bool bSelExists = pApp->m_selection.GetCount() > 0;
	if (bSelExists && pApp->m_bSelectByArrowKey)
	{
		// if we are extending to the right in a selection to the left, we have to remove
		// the first pile's selection
		if (pApp->m_curDirection == left)
		{
			// find the leftmost cell of the selection
			CCellList::Node* cpos = pApp->m_selection.GetFirst();
			CCell* pLeftmost = (CCell*)cpos->GetData();

			// remove this cell's selection
			aDC.SetBackgroundMode(pApp->m_backgroundMode); // Do not use wxTRANSPARENT here!! it leaves any existing yellow background
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pLeftmost->m_pText->Draw(&aDC);
			pLeftmost->m_pText->m_bSelected = FALSE;

			// preserve record of the deselection
			CCellList::Node* pos = pApp->m_selection.GetFirst();
			if (pos != NULL)
				pApp->m_selection.DeleteNode(pos);

			// if the deselection brought us back to the anchor cell, then
			// remove the selection entirely (ie. remove anchor cell seln too)
			CCell* pNextCell = GetNextCell(pLeftmost,1);
			if (pNextCell != NULL)
			{
				CPile* pNextPile = pNextCell->m_pPile;
				if (pNextPile == pActivePile)
				{
					// remove this pile's selection too
					pNextCell->m_pText->Draw(&aDC);

					pNextCell->m_pText->m_bSelected = FALSE;



					// make all the parameter agree with no selection
					pApp->m_bSelectByArrowKey = FALSE;
					pApp->m_selectionLine = -1;
					pApp->m_pAnchor = NULL;
					pApp->m_selection.Clear();
				}
			}
			else
			{
				wxMessageBox(_(
				"Error while trying to deselect a cell. Try selecting using the mouse instead.\n"),
                _T(""), wxICON_INFORMATION);
				RemoveSelection();	// whm added 7July06 to prevent crash when invoking
								// ALT+Rightarrow at end of document (avoids m_selectionLine becoming 1
								// while m_selection is empty. The crash would happen in a OnUpdateUI
								// handler that tests the status of m_selectionLine != -1
				return FALSE;
			}
			return TRUE;
		}

		// find the rightmost cell of the selection
		CCellList::Node* ccpos = pApp->m_selection.GetLast();
		CCell* pRightmost = (CCell*)ccpos->GetData();
		CPile* pRightPile = pRightmost->m_pPile;

		if (pApp->m_bRespectBoundaries)
		{
			if (pRightPile->m_pSrcPhrase->m_bBoundary) // can't extend past a boundary
				return FALSE;
		}

		CCell* pNextCell = GetNextCell(pRightmost,1);
		
		// if vertical edit is in effect, and we are in adaptationsStep (glossesStep doesn't allow
		// this selection method because glossing mode doesn't), then check that we've not encroached
		// on the gray text to the right, if we have then beep and remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			pRightPile = pNextCell->m_pPile;
			if (pRightPile->m_pSrcPhrase->m_nSequNumber > gEditRecord.nAdaptationStep_EndingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pNextCell != NULL)
		{
			wxASSERT(pNextCell != NULL);
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			pNextCell->m_pText->Draw(&aDC);
			pNextCell->m_pText->m_bSelected = TRUE;

			// preserve record of the selection
			pApp->m_selection.Append(pNextCell); 
			pApp->m_selectionLine = 1;
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the next cell. Try selecting with the mouse instead.\n"),
            _T(""), wxICON_INFORMATION);
			RemoveSelection();	// whm added 7July06 to prevent crash when invoking
								// ALT+Rightarrow at end of document (avoids m_selectionLine becoming 1
								// while m_selection is empty. The crash would happen in a OnUpdateUI
								// handler that tests the status of m_selectionLine != -1
			return FALSE;
		}
	}
	else
	{
		// no selection yet, so select the cell in the active pile before extending right
		pApp->m_bSelectByArrowKey = TRUE;
		pApp->m_curDirection = right;
		aDC.SetBackgroundMode(pApp->m_backgroundMode);
		aDC.SetTextBackground(wxColour(255,255,0)); // yellow
		CCell* pCell = pActivePile->m_pCell[1];
		pCell->m_pText->Draw(&aDC);
		pCell->m_pText->m_bSelected = TRUE;

		// preserve record of the selection
		pApp->m_selection.Append(pCell);
		pApp->m_selectionLine = 1;

		// now try extend it one cell right
		if (pApp->m_bRespectBoundaries)
		{
			if (pActivePile->m_pSrcPhrase->m_bBoundary) // can't extend past a boundary
				return FALSE;
		}
		CCell* pNextCell = GetNextCell(pCell,1);

		// if vertical edit is in effect, and we are in adaptationsStep (glossesStep doesn't allow
		// this selection method because glossing mode doesn't), then check that we've not encroached
		// on the gray text to the right, if we have then beep and remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			CPile* pRightPile = pNextCell->m_pPile;
			if (pRightPile->m_pSrcPhrase->m_nSequNumber > gEditRecord.nAdaptationStep_EndingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pNextCell != NULL)
		{
			wxASSERT(pNextCell != NULL);
			pNextCell->m_pText->Draw(&aDC);
			pNextCell->m_pText->m_bSelected = TRUE;

			// preserve record of the selection
			pApp->m_selection.Append(pNextCell);
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the next cell. Try selecting with the mouse instead.\n"),
            _T(""), wxICON_INFORMATION);
			RemoveSelection();	// whm added 7July06 to prevent crash when invoking
								// ALT+Rightarrow at end of document (avoids m_selectionLine becoming 1
								// while m_selection is empty. The crash would happen in a OnUpdateUI
								// handler that tests the status of m_selectionLine != -1
			return FALSE;
		}
	}

	return TRUE;
}

bool CAdapt_ItView::ExtendSelectionLeft()
// return TRUE if the selection extended, FALSE if not (would be false only if at a boundary)
// this function works with selections on the 2nd line only; m_pAnchor is alway the pile at
// which the phraseBox currently is
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	// can't extend if we are showing only the target line
	if (gbShowTargetOnly)
		return TRUE; // don't want message about boundaries

	// remove an existing selection if it was not done using the arrow key, save
	// m_bRespectBoundaries across this operation
	bool bSaveFlag = pApp->m_bRespectBoundaries;
	if (pApp->m_selection.GetCount() > 0 && !pApp->m_bSelectByArrowKey)
	{
		RemoveSelection();
		Invalidate();
	}
	// restore flag (and button)
	if (bSaveFlag == FALSE)
	{
		OnButtonFromRespectingBdryToIgnoringBdry(dummyevent);
	}

	// need a CClientDC
	wxClientDC aDC(pApp->GetMainFrame()->canvas); 

	canvas->DoPrepareDC(aDC); //OnPrepareDC(&aDC); // adjust the origin
	canvas->pFrame->PrepareDC(aDC); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame

	CPile* pActivePile = pApp->m_pActivePile;
	wxASSERT(pActivePile != NULL);
	pApp->m_pAnchor = pActivePile->m_pCell[1];
	bool bSelExists = pApp->m_selection.GetCount() > 0;
	if (bSelExists && pApp->m_bSelectByArrowKey)
	{
		// if we are backing up in a selection to the right, we have to remove
		// the last pile's selection
		if (pApp->m_curDirection == right)
		{
			// find the rightmost cell of the selection
			CCellList::Node* cpos = pApp->m_selection.GetLast();
			CCell* pRightmost = (CCell*)cpos->GetData();

			// remove this cell's selection
			aDC.SetBackgroundMode(pApp->m_backgroundMode); // Do not use wxTRANSPARENT here!! it leaves any existing yellow background
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pRightmost->m_pText->Draw(&aDC);
			pRightmost->m_pText->m_bSelected = FALSE;

			// preserve record of the deselection
			CCellList::Node* pos = pApp->m_selection.GetLast();
			if (pos != NULL)
				pApp->m_selection.DeleteNode(pos);

			// if the deselection brought us back to the anchor cell, then
			// remove the selection entirely (ie. remove anchor cell seln too)
			CCell* pPrevCell = GetPrevCell(pRightmost,1);
			if (pPrevCell != NULL)
			{
				CPile* pPrevPile = pPrevCell->m_pPile;
				if (pPrevPile == pActivePile)
				{
					// remove this pile's selection too
					pPrevCell->m_pText->Draw(&aDC);
					pPrevCell->m_pText->m_bSelected = FALSE;

					// make all the parameter agree with no selection
					pApp->m_bSelectByArrowKey = FALSE;
					pApp->m_selectionLine = -1;
					pApp->m_pAnchor = NULL;
					pApp->m_selection.Clear();
				}
			}
			else
			{
				wxMessageBox(_(
				"Error while trying to deselect a cell. Try selecting using the mouse instead.\n"),
                _T(""), wxICON_INFORMATION);
				return FALSE;
			}
			return TRUE;
		}
		// find the leftmost cell of the selection
		CCellList::Node* fpos = pApp->m_selection.GetFirst();
		CCell* pLeftmost = fpos->GetData();
		CCell* pPrevCell = GetPrevCell(pLeftmost,1);

		// if vertical edit is in effect, and we are in adaptationsStep (glossesStep doesn't allow
		// this selection method because glossing mode doesn't), then check that we've not encroached
		// on the gray text to the left, if we have then beep and remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			CPile* pPrevPile = pPrevCell->m_pPile;
			if (pPrevPile->m_pSrcPhrase->m_nSequNumber < gEditRecord.nAdaptationStep_StartingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pPrevCell != NULL)
		{
			wxASSERT(pPrevCell != NULL);
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			CPile* pPrevPile = pPrevCell->m_pPile;

			if (pApp->m_bRespectBoundaries)
			{
				if (pPrevPile->m_pSrcPhrase->m_bBoundary) // can't extend left on to a boundary
					return FALSE;
			}

			pPrevCell->m_pText->Draw(&aDC);
			pPrevCell->m_pText->m_bSelected = TRUE;

			// preserve record of the selection
			pApp->m_selection.Insert(pPrevCell);
			pApp->m_selectionLine = 1;
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the previous cell. Try selecting with the mouse instead.\n"
			), _T(""), wxICON_INFORMATION);
			return FALSE;
		}
	}
	else
	{
		// no selection yet, so select the cell in the active pile before extending left
		pApp->m_bSelectByArrowKey = TRUE;
		pApp->m_curDirection = left;
		aDC.SetBackgroundMode(pApp->m_backgroundMode);
		aDC.SetTextBackground(wxColour(255,255,0)); // yellow
		CCell* pCell = pActivePile->m_pCell[1];
		pCell->m_pText->Draw(&aDC);
		pCell->m_pText->m_bSelected = TRUE;

		// preserve record of the selection
		pApp->m_selection.Insert(pCell);
		pApp->m_selectionLine = 1;

		// now try extend it one cell left
		CCell* pPrevCell = GetPrevCell(pCell,1);
		if (pPrevCell == NULL) // whm added to prevent crash when phrasebox is in first pile
		{
			// we're at the first pile in the doc and can't move left
			RemoveSelection(); //whm added; if test were at top of current else block this wouldn't be needed
			return FALSE;
		}
		wxASSERT(pPrevCell != NULL);
		CPile* pPrevPile = pPrevCell->m_pPile;
		wxASSERT(pPrevPile != NULL);
		if (pApp->m_bRespectBoundaries)
		{
			if (pPrevPile->m_pSrcPhrase->m_bBoundary) // can't extend past a boundary
			{
				// whm added below for situation when phrasebox is at last pile in doc and a
				// boundary prevents selecting previous pile.
				CCell* pNextCell = GetNextCell(pCell,1);
				if (pNextCell == NULL)
				{
					RemoveSelection();
				}
				return FALSE;
			}
		}

		// if vertical edit is in effect, and we are in adaptationsStep (glossesStep doesn't allow
		// this selection method because glossing mode doesn't), then check that we've not encroached
		// on the gray text to the left, if we have then beep and remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			if (pPrevPile->m_pSrcPhrase->m_nSequNumber < gEditRecord.nAdaptationStep_StartingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pPrevCell != NULL)
		{
			pPrevCell->m_pText->Draw(&aDC);
			pPrevCell->m_pText->m_bSelected = TRUE;

			// preserve record of the selection
			pApp->m_selection.Insert(pPrevCell);
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the previous cell. Try selecting with the mouse instead.\n"
			), _T(""), wxICON_INFORMATION);
			return FALSE;
		}
	}
	return TRUE;
}

// pass in a pile pointer which we want to know whether or not it is in the gray text
// area; the gEditStep is a global, so does not need to be passed in; return TRUE if the
// pile is in the editabe area, FALSE if in the gray area, and if a NULL pile is passed
// in, treat it as equivalent to being in the gray area (ie. return FALSE)
bool CAdapt_ItView::CheckForVerticalEditBoundsError(CPile* pPile)
{
	if (pPile == NULL)
		return FALSE;
	int nLeftBoundSN = 0; // whm initialized to avoid "potentially uninitialized local variable ... used" warning
	int nRightBoundSN = 0; // whm initialized to avoid "potentially uninitialized local variable ... used" warning
	if (gbVerticalEditInProgress && 
		(gEditStep == adaptationsStep ||
		gEditStep == glossesStep ||
		gEditStep == freeTranslationsStep
		))
	{
		switch(gEditStep)
		{
		case adaptationsStep:
			nLeftBoundSN = gEditRecord.nAdaptationStep_StartingSequNum;
			nRightBoundSN = gEditRecord.nAdaptationStep_EndingSequNum;
			break;
		case glossesStep:
			nLeftBoundSN = gEditRecord.nGlossStep_StartingSequNum;
			nRightBoundSN = gEditRecord.nGlossStep_EndingSequNum;
			break;
		case freeTranslationsStep:
			nLeftBoundSN = gEditRecord.nFreeTranslationStep_StartingSequNum;
			nRightBoundSN = gEditRecord.nFreeTranslationStep_EndingSequNum;
			break;
		}
		if ((pPile->m_pSrcPhrase->m_nSequNumber < nLeftBoundSN)
			||(pPile->m_pSrcPhrase->m_nSequNumber > nRightBoundSN))
		{
			RemoveSelection();
			::wxBell();
			return FALSE;
		}
	}
	return TRUE;
}

void CAdapt_ItView::MergeWords()
{
	wxCommandEvent dummyevent;
	OnButtonMerge(dummyevent);
}

bool CAdapt_ItView::StoreText(CKB *pKB, CSourcePhrase *pSrcPhrase, wxString &tgtPhrase,
                                    bool bSuppressEmptyAdaptDlg)
// return TRUE if all was well, FALSE if unable to store (the caller should use the FALSE value
// to block a move of the phraseBox to another pile) This function's behaviour was changed after
// version1.2.8, on May 6 2002, in order to eliminate the occurence of the "Empty Adaption Dialog"
// which would come up whenever the user deleted the contents of the phrase box and then moved on,
// or clicked elsewhere. (In the new behaviour, a FALSE value now stores nothing when the box has
// no content.)  The new default behaviour is that if the box is empty when the user causes
// it to move, then nothing is stored in the knowledge base (same as the former default behaviour
// for the empty adaption dialog) and the move is acted on immediately. If the user wants to store
// a <no adaptation> empty entry in the KB, a button "<no adaptation>" has been provided on the
// control bar. Click it before moving the phrase box to cause an empty adaptation to be stored in
// the KB for the source text at the current active location.
// version 2.0 and onward tests gbIsGlossing for storing to the appropriate KB, etc.
// For adaptation, on input the tgtPhrase parameter should have the text with punctuation removed,
// so this is typically done in the caller with a call to RemovePunctuation( ).
// In order to support the user overriding the stored punctuation for the source text, a call to
// MakeLineFourString( ) is done in the caller, and then RemovePunctuation( ) is called in the
// caller, so a second call of MakeLineFourString( ) within StoreText( ) is not required in this
// circumstance - in this case, a global boolean gbInhibitLine4StrCall is used to jump the call
// within StoreText( ).
// Ammended, July 2003, for Auto-Capitalization support
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// determine the auto caps parameters, if the functionality is turned on
	bool bNoError = TRUE;

	// do not permit storage if the source phrase has an empty key (eg. user may have ... ellipsis
	// in the source text, which generates an empty key and three periods in the punctuation)
	if (pSrcPhrase->m_key.IsEmpty())
	{
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // this is not an error, just suppression of the store
	}

	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pSrcPhrase->m_key); // for source word or phrase
	}

	// If the source word (or phrase) has not been previously encountered, then m_bHasKBEntry (or
	// the equiv flag if glossing is ON) will be false, which has to be true for the StoreText call
	// not to fail. But if we have come to an entry in the KB which we are about to add a new
	// adaptation (or gloss) to it, then the flag will be TRUE (and rightly so.) The StoreText call
	// would then fail - so we will test for this possibility and clear the appropriate flag if
	// necessary.
	// BEW 05July2006: No! The above comment confuses the KB entry with the CSourcePhrase instance
	// at the active location. The flags we are talking about declare that that PARTICULAR instance
	// in the DOCUMENT does, or does not, yet have a KB entry. When the phrase box lands there, it
	// gets its KB entry removed (or ref count decremented) before a store is done, and so the flags
	// are made false when the former happens.
	// RemoveRefString() was supposed to do that, but my logic error was there as well (I've fixed it
	// now). So before the store it done, the RemoveRefString call will now clear the relevant flag;
	// so we don't need to test and clear it in the following block.
	/*
	if (gbIsGlossing)
	{
		if (pSrcPhrase->m_bHasGlossingKBEntry)
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // ensures the save will not fail
	}
	else
	{
		if (pSrcPhrase->m_bHasKBEntry)
		pSrcPhrase->m_bHasKBEntry = FALSE; // ensures the save will not fail
	}
	*/
	GetDocument()->Modify(TRUE);

	// BEW added 20Apr06, to store <Not In KB> when gbSuppressStoreForAltBackspaceKeypress flag
	// is TRUE - as wanted by Bob Eaton; we support this only in adapting mode, not glossing mode
	if (!gbIsGlossing && gbSuppressStoreForAltBackspaceKeypress)
	{
		wxString strNot = _T("<Not In KB>");
		// rest of this block's code is a simplification of code from later in StoreText()
		int nMapIndex;
		if (gbIsGlossing)
			nMapIndex = 0; // always an index of zero when glossing
		else
			nMapIndex = pSrcPhrase->m_nSrcWords - 1; // index to the appropriate map

		// if we have too many source words, then we cannot save to the KB, so beep - this is
		// unlikely to be the case when Bob's modification is being used.
		if (!gbIsGlossing && pSrcPhrase->m_nSrcWords > MAX_WORDS)
		{
			::wxBell(); //MessageBeep(0);
			return TRUE;
		}

		// continue the storage operation
		wxString unchangedkey = pSrcPhrase->m_key;
		wxString key = AutoCapsMakeStorageString(pSrcPhrase->m_key); // key might be made lower case
		CTargetUnit* pTU;
		CRefString* pRefString;
		if (pKB->m_pMap[nMapIndex]->empty())
		{
			pTU = new CTargetUnit;
			pRefString = new CRefString(pTU); // the pTU argument sets the m_pTgtUnit member
			pRefString->m_refCount = 1; // set the count
			pRefString->m_translation = strNot;
			pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
			pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
			if (gbIsGlossing)
			{
				pSrcPhrase->m_bHasGlossingKBEntry = TRUE; // glossing KB has to treat <Not In KB> as a 'real' gloss
				(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in the map
				pKB->m_nMaxWords = 1;
			}
			else
			{
				pSrcPhrase->m_bHasKBEntry = FALSE; // it's not a 'real' entry
				pSrcPhrase->m_bNotInKB = TRUE;
				pSrcPhrase->m_bBeginRetranslation = FALSE;
				pSrcPhrase->m_bEndRetranslation = FALSE;

				(*pKB->m_pMap[nMapIndex])[key] = pTU;
				if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
					pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
			}
		}
		else // this block for when map is not empty
		{
			// there might be a pre-existing association between this key and a CTargetUnit,
			// so check it out
			bool bFound = AutoCapsLookup(pKB->m_pMap[nMapIndex], pTU, unchangedkey);

			// we won't check we have a valid pTU .. so a block of code omitted here

			// if not found on the lookup, then create a targetUnit, and add the refString, etc,
			// but if one is found, then check whether we add a new refString or increment the
			// refCount of an existing one
			if(!bFound)
			{
				pTU = new CTargetUnit;
				pRefString = new CRefString(pTU);
				pRefString->m_refCount = 1; // set the count
				pRefString->m_translation = strNot;
				pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
				pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
				if (gbIsGlossing)
				{
					pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					(*pKB->m_pMap[nMapIndex])[key] = pTU;
					pKB->m_nMaxWords = 1;
				}
				else
				{
					pSrcPhrase->m_bHasKBEntry = FALSE;
					pSrcPhrase->m_bNotInKB = TRUE;
					(*pKB->m_pMap[nMapIndex])[key] = pTU;
					if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
						pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
				}
			}
			else // we found one
			{
				// we found a pTU for this key, so check for a matching CRefString, if there is no
				// match, then add a new one (note: no need to set m_nMaxWords for this case)
				//int nTrCount = pTU->m_pTranslations->GetCount(); // unused
				bool bMatched = FALSE;
				pRefString = new CRefString(pTU);
				pRefString->m_refCount = 1; // set the count, assuming this will be stored (it may not be)
				pRefString->m_translation = strNot;

				TranslationsList::Node* pos = pTU->m_pTranslations->GetFirst();
				while (pos != NULL)
				{
					CRefString* pRefStr = (CRefString*)pos->GetData();
					pos = pos->GetNext();
					wxASSERT(pRefStr != NULL);

					// does it match?
					if (*pRefStr == *pRefString) // TRUE if pRStr->m_translation == pRefString->m_translation
					{
						// if we get a match, then increment ref count and point to this, etc
						bMatched = TRUE;
						pRefStr->m_refCount++;
						if (gbIsGlossing)
						{
							pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
						}
						else
						{
							pSrcPhrase->m_bHasKBEntry = FALSE;
							pSrcPhrase->m_bNotInKB = TRUE;
							pSrcPhrase->m_bBeginRetranslation = FALSE;
							pSrcPhrase->m_bEndRetranslation = FALSE;
						}
						delete pRefString; // don't need this one
						break;
					}
				}
				// if we get here with bMatched == FALSE, then there was no match, so this must somehow
				// be a normal entry, so we don't add anything and just return
				return TRUE;
			}
		}

		return TRUE;
	}

	gbByCopyOnly = FALSE; // restore default setting

	// First get rid of final spaces
	int len;
	int nIndexLast;
	if (tgtPhrase.IsEmpty())
		goto s; // code below would fail if string is empty, due to negative index
	len = tgtPhrase.Length();
	nIndexLast = len-1;
	do {
		if (tgtPhrase.GetChar(nIndexLast) == _T(' '))
		{
			//tgtPhrase.Delete(nIndexLast);
			// Note: wsString::Remove must have the second param as 1 here otherwise
			// it will truncate the remainder of the string!
			tgtPhrase.Remove(nIndexLast,1); // MFC Delete same as wxString::Remove
			// can't trust the Delete's returned value, it exceeds string length by one
			len = tgtPhrase.Length();
			nIndexLast = len -1;
		}
		else
		{
			break;
		}
	} while (len > 0 && nIndexLast > -1);

	// always place a copy in the source phrase's m_adaption member, unless it is <Not In KB>;
	// when glossing always place a copy in the m_gloss member.
s:	if (gbIsGlossing)
	{
		wxString s = tgtPhrase;
		if (gbAutoCaps)
		{
			bool bNoError = TRUE;
			if (gbSourceIsUpperCase && !gbMatchedKB_UCentry)
			{
				bNoError = SetCaseParameters(s,FALSE);
				if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
				{
					// change it to upper case
					s.SetChar(0,gcharNonSrcUC);
				}
			}
		}
		pSrcPhrase->m_gloss = s;
	}
	else // currently adapting
	{
		if (tgtPhrase != _T("<Not In KB>"))
		{
			pSrcPhrase->m_adaption = tgtPhrase;
			if (!gbInhibitLine4StrCall)
				MakeLineFourString(pSrcPhrase, tgtPhrase); // set m_targetStr member too
		}
	}
	pApp->m_curIndex = pSrcPhrase->m_nSequNumber;

	// if the source phrase is part of a retranslation, we allow updating of the m_adaption
	// attribute only (since this is the only place where retranslations are stored), but suppress
	// saving to the KB. For support of glossing, we must skip this block if glossing is ON because
	// glossing does not care about retranslations - the user needs to be able to gloss the source
	// words in a retranslation just like the rest of it
	if (!gbIsGlossing && pSrcPhrase->m_bRetranslation)
	{
		if (!pApp->m_bSaveToKB)
			pApp->m_bSaveToKB = TRUE; // ensure this flag is turned back on
		pApp->m_bForceAsk = FALSE; // also must be cleared prior to next save attempt
		pSrcPhrase->m_bHasKBEntry = FALSE;
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // the caller must treat this as a valid 'save' operation
	}

	// if the user doesn't want a store done (he checked the dialog bar's control for this choice)
	// then return, without saving, after setting the source phrases m_bNotInKB flag to TRUE
	// (ignore this block when glossing)
	if (!gbIsGlossing && !pApp->m_bSaveToKB)
	{
		pSrcPhrase->m_bNotInKB = TRUE;
		pApp->m_bForceAsk = FALSE; // have to turn this off too, since this is regarded as a valid
							 // 'store' op
		pSrcPhrase->m_bHasKBEntry = FALSE;
		pSrcPhrase->m_bBeginRetranslation = FALSE;
		pSrcPhrase->m_bEndRetranslation = FALSE;
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // we want the caller to think all is well
	}

	// if there is a CTargetUnit associated with the current key, then get it; if not, create one
	// and add it to the appropriate map; we start by computing which map we need to store to
	int nMapIndex;
	if (gbIsGlossing)
		nMapIndex = 0; // always an index of zero when glossing
	else
		nMapIndex = pSrcPhrase->m_nSrcWords - 1; // index to the appropriate map

	// if we have too many source words, then we cannot save to the KB, so detect this and warn the
	// user that it will not be put in the KB, then return TRUE since all is otherwise okay (this
	// will be handled as a retranslation, by default) The following comment is for when glossing...
	// Note: if the source phrase is part of a retranslation, we allow updating of the m_gloss
	// attribute, and we won't change any of the retranslation supporting flags; so it is therefore
	// possible for m_bRetranslation to be TRUE, and also for m_bHasGlossingKBEntry to be TRUE.
	if (!gbIsGlossing && pSrcPhrase->m_nSrcWords > MAX_WORDS)
	{
		pSrcPhrase->m_bNotInKB = FALSE;
		pSrcPhrase->m_bHasKBEntry = FALSE;
		//IDS_TOO_MANY_SRC_WORDS
		wxMessageBox(_("Warning: there are too many source language words in this phrase for this adaptation to be stored in the knowledge base."), _T(""),wxICON_INFORMATION);
		gbMatchedKB_UCentry = FALSE;
		return TRUE;
	}

	// continue the storage operation
	wxString unchangedkey = pSrcPhrase->m_key; // this never has case change done to it
											  // (need this for lookups)
	wxString key = AutoCapsMakeStorageString(pSrcPhrase->m_key); // key might be made lower case
	CTargetUnit* pTU;
	CRefString* pRefString;
	if (pKB->m_pMap[nMapIndex]->empty())
	{
		// if suppression is off then we just won't store anything if the target phrase has no
		// content. (When about to put up the ChooseTranslation dialog this is one context where
		// the flag would be TRUE, another is when storing during a rebuild of the document due to
		// punctuation having been changed, it is FALSE by default on all other StoreText calls)
		if (!bSuppressEmptyAdaptDlg)
		{
			// is the pApp->m_targetPhrase empty?
			if (tgtPhrase.IsEmpty())
			{
				// store nothing if there is no suppression (if this seems odd, remember
				// the app used to have a dialog which would be put up if the flag
				// was FALSE (ie no suppression)) and the bSuppressEmptyAdaptDlg has another
				// function as well, so we can't eliminate it even though its main function
				// no longer applies
				if (!gbIsGlossing)
				{
					pSrcPhrase->m_bBeginRetranslation = FALSE;
					pSrcPhrase->m_bEndRetranslation = FALSE;
				}
				pApp->m_bForceAsk = FALSE; // make sure it's turned off
				gbMatchedKB_UCentry = FALSE;
				return TRUE; // make caller think all is well
			}
		}

		pTU = new CTargetUnit;
		wxASSERT(pTU != NULL);
		pRefString = new CRefString(pTU);
		wxASSERT(pRefString != NULL);

		pRefString->m_refCount = 1; // set the count
		// add the translation string
		if (bNoError)
		{
			pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
		}
		else
		{
			// if something went wrong, just save as if gbAutoCaps was FALSE
			pRefString->m_translation = tgtPhrase;
		}
		pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
		if (pApp->m_bForceAsk)
		{
			pTU->m_bAlwaysAsk = TRUE; // turn it on if user wants to be given opportunity to
									  // add a new refString next time its matched
		}

		pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
		if (gbIsGlossing)
		{
			pSrcPhrase->m_bHasGlossingKBEntry = TRUE; // tell the src phrase it has an entry
													  // in the glossing KB
			(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in the map

			// update the maxWords limit - for glossing it is always set to 1
			pKB->m_nMaxWords = 1;
		}
		else
		{
			pSrcPhrase->m_bHasKBEntry = TRUE; // tell the src phrase it has an entry in the KB

			// it can't be a retranslation, so ensure the next two flags are cleared
			pSrcPhrase->m_bBeginRetranslation = FALSE;
			pSrcPhrase->m_bEndRetranslation = FALSE;

			(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in the map with
													// appropriate index
			// update the maxWords limit
			if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
				pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
		}
	}
	else // do block for when map is not empty
	{
		// there might be a pre-existing association between this key and a CTargetUnit,
		// so check it out
		bool bFound = AutoCapsLookup(pKB->m_pMap[nMapIndex], pTU, unchangedkey);

		// check we have a valid pTU
		if (bFound && pTU->m_pTranslations->IsEmpty())
		{
			// this is an error condition, targetUnits must NEVER have an empty m_translations list
			// IDS_BAD_TGTUNIT_ERR
			wxMessageBox(_T("Warning: the current storage operation has been skipped, and a bad storage element has been deleted."), _T(""), wxICON_EXCLAMATION);

			// fix the error
			TUList::Node* pos = pKB->m_pTargetUnits->Find(pTU); // find position of the bad targetUnit
														   // in the list
			// get the targetUnit in the list
			CTargetUnit* pTgtUnit = (CTargetUnit*)pos->GetData();
			wxASSERT(pTgtUnit != NULL && pTgtUnit->m_pTranslations->IsEmpty()); // have we found the
																			// bad one?
			pKB->m_pTargetUnits->DeleteNode(pos); // remove it from the list
			delete pTgtUnit; // delete it from the heap
			pTgtUnit = (CTargetUnit*)NULL;

			MapKeyStringToTgtUnit* pMap = pKB->m_pMap[nMapIndex];
			int bRemoved;
			if (gbAutoCaps && gbSourceIsUpperCase && !gbMatchedKB_UCentry)
				bRemoved = pMap->erase(key); // remove the changed to lc entry from the map
			else
				bRemoved = pMap->erase(unchangedkey); // remove the unchanged one from the map
			wxASSERT(bRemoved == 1);
			pApp->m_bSaveToKB = TRUE; // ensure its back on (if here from a choice not save to KB,
								// this will be cleared by OnCheckKBSave, preserving user choice
			gbMatchedKB_UCentry = FALSE;
			return FALSE;
		}

		// if not found, then create a targetUnit, and add the refString, etc, as above;
		// but if one is found, then check whether we add a new refString or increment the
		// refCount of an existing one
		if(!bFound)
		{
			// don't store if the box is empty and there is no suppression,
			// and then return; otherwise, go on
			if (tgtPhrase.IsEmpty())
			{
				// store nothing if there is no suppression (if this seems odd, remember
				// the app used to have a dialog which would be put up if the flag
				// was FALSE (ie no suppression))
				if (!bSuppressEmptyAdaptDlg)
				{
					// store nothing
					if (!gbIsGlossing)
					{
						pSrcPhrase->m_bBeginRetranslation = FALSE;
						pSrcPhrase->m_bEndRetranslation = FALSE;
					}
					pApp->m_bForceAsk = FALSE; // make sure it's turned off
					gbMatchedKB_UCentry = FALSE;
					return TRUE; // make caller think all is well
				}
			}

			pTU = new CTargetUnit;
			wxASSERT(pTU != NULL);
			pRefString = new CRefString(pTU);
			wxASSERT(pRefString != NULL);

			pRefString->m_refCount = 1; // set the count
			// add the translation or gloss string
			pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
			pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
			if (pApp->m_bForceAsk)
			{
				pTU->m_bAlwaysAsk = TRUE; // turn it on if user wants to be given opportunity to
										  // add a new refString next time its matched
			}

			pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
			if (gbIsGlossing)
			{
				pSrcPhrase->m_bHasGlossingKBEntry = TRUE;

				(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in the map with
														// appropr. index (key may have been made lc)
				// update the maxWords limit - for glossing it is always set to 1
				pKB->m_nMaxWords = 1;
			}
			else
			{
				pSrcPhrase->m_bHasKBEntry = TRUE;

				(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in the map with
													// appropr. index (key may have been made lc)
				// update the maxWords limit
				if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
					pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
			}
		}
		else // we found one
		{
			// we found a pTU for this key, so check for a matching CRefString, if there is no
			// match, then add a new one (note: no need to set m_nMaxWords for this case)
			bool bMatched = FALSE;
			pRefString = new CRefString(pTU);
			wxASSERT(pRefString != NULL);
			pRefString->m_refCount = 1; // set the count, assuming this will be stored (it may
										// not be)
			// set its gloss or adaptation string; the fancy test is required because the
			// refStr entry may have been stored in the kb when auto-caps was off, and if it
			// was upper case for the source text's first letter, then it will have been looked up
			// only on the second attempt, for which gbMatchedKB_UCentry will have been set TRUE,
			// and which means the gloss or adaptation will not have been made lower case - so we
			// must allow for this possibility
			if ((gbAutoCaps && gbMatchedKB_UCentry) || !gbAutoCaps)
				pRefString->m_translation = tgtPhrase; // use the unchanged string, could be uc
			else
				pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);

			TranslationsList::Node* pos = pTU->m_pTranslations->GetFirst();
			while (pos != NULL)
			{
				CRefString* pRefStr = pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pRefStr != NULL);

				// does it match?
				if (*pRefStr == *pRefString) // TRUE if pRStr->m_translation ==
											 // pRefString->m_translation
				{
					// if we get a match, then increment ref count and point to this, etc
					bMatched = TRUE;
					pRefStr->m_refCount++;
					if (gbIsGlossing)
					{
						pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					}
					else
					{
						pSrcPhrase->m_bHasKBEntry = TRUE;
						pSrcPhrase->m_bBeginRetranslation = FALSE;
						pSrcPhrase->m_bEndRetranslation = FALSE;
					}
					delete pRefString; // don't need this one
					pRefString = (CRefString*)NULL;
					if (pApp->m_bForceAsk)
					{
						pTU->m_bAlwaysAsk = TRUE; // nTrCount might be 1, so we must ensure it
												  // gets set if that is what the user wants
					}
					break;
				}
			}
			// if we get here with bMatched == FALSE, then there was no match, so we must add
			// the new pRefString to the targetUnit, but if it is already an <Not In KB> entry,
			// then the latter must override (to prevent <Not In KB> and <no adaptation> or a
			// nonempty adaptation or gloss being two ref strings for the one key  -- when adapting;
			// for glossing this cannot happen)
			if (!bMatched)
			{
				TranslationsList::Node* tpos = pTU->m_pTranslations->GetFirst();
				CRefString* pRefStr = (CRefString*)tpos->GetData();
				if (!gbIsGlossing && pRefStr->m_translation == _T("<Not In KB>"))
				{
					// keep it that way (the way to cancel this setting is with the toolbar
					// checkbox)  But leave m_adaption and m_targetStr (or m_gloss) having whatever
					// the user may have typed
					pSrcPhrase->m_bHasKBEntry = FALSE;
					pSrcPhrase->m_bNotInKB = TRUE;
					pSrcPhrase->m_bBeginRetranslation = FALSE;
					pSrcPhrase->m_bEndRetranslation = FALSE;
					delete pRefString; // don't leak memory
					pRefString = (CRefString*)NULL;
					pApp->m_bForceAsk = FALSE;
					gbMatchedKB_UCentry = FALSE;
					return TRUE; // all is well
				}
				else // either we are glossing, or we are adapting and it's a normal adaptation
				{
					// is the pApp->m_targetPhrase empty?
					if (tgtPhrase.IsEmpty())
					{
						// don't store if there is no suppression, and then return
						// otherwise go on
						if (!bSuppressEmptyAdaptDlg)
						{
							// don't store if there is no suppression (if this seems odd,
							// remember the app used to have a dialog which would be put up if
							// the flag was FALSE (ie no suppression)) and then return, else
							// just go on
							if (!gbIsGlossing)
							{
								pSrcPhrase->m_bBeginRetranslation = FALSE;
								pSrcPhrase->m_bEndRetranslation = FALSE;
							}
							pApp->m_bForceAsk = FALSE; // make sure it's turned off
							delete pRefString; // don't leak the memory
							pRefString = (CRefString*)NULL;
							gbMatchedKB_UCentry = FALSE;
							return TRUE; // make caller think all is well
						}
					}

					// recalculate the string to be stored, in case we looked up a
					// stored upper case entry earlier
					pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
					pTU->m_pTranslations->Append(pRefString);
					if (gbIsGlossing)
					{
						pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					}
					else
					{
						pSrcPhrase->m_bHasKBEntry = TRUE;
						pSrcPhrase->m_bBeginRetranslation = FALSE;
						pSrcPhrase->m_bEndRetranslation = FALSE;
					}
				}
			}
		}
	}
	if (!gbIsGlossing)
		pSrcPhrase->m_bNotInKB = FALSE; // ensure correct flag value, in case it was not in KB
	pApp->m_bForceAsk = FALSE; // must be turned off, as it applies to one store operation only
	gbMatchedKB_UCentry = FALSE;
	return TRUE;
}

void CAdapt_ItView::RemoveFinalSpaces(CPhraseBox* pBox, wxString* pStr)
{
	// empty strings don't need anything done
	if (pStr->IsEmpty())
		return;

	// remove any phrase final space characters
	bool bChanged = FALSE;
	int len = pStr->Length();
	int nIndexLast = len-1;
	do {
		if (pStr->GetChar(nIndexLast) == _T(' '))
		{
			//pStr->Delete(nIndexLast);
			// Note: wsString::Remove must have the second param as 1 here otherwise
			// it will truncate the remainder of the string!
			pStr->Remove(nIndexLast,1);
			// can't trust the Delete's returned value, it exceeds string length by one
			len = pStr->Length();
			nIndexLast = len -1;
			bChanged = TRUE;
		}
		else
		{
			break;
		}
	} while (len > 0 && nIndexLast > -1);

	if (bChanged) // need to do this, because for some reason rubbish is getting left in the
				  // earlier box when the ChooseTranslation dialog gets put up. That is, a simple
				  // call of SetWindowText with parameter pStr cast to (const char *) doesn't work
				  //right; but the creation & setting of str below fixes it
	{
		wxString str = *pStr;
		pBox->SetValue(str);
	}

}


// BEW added 30Apr08, an overloaded version which deletes final spaces in any CString's text, and
// if there are only spaces in the string, it reduces it to an empty string
void CAdapt_ItView::RemoveFinalSpaces(wxString& rStr)
{
	// whm Note: This could be done with a single line in wx, i.e., rStr.Trim(TRUE), but we'll
	// go with the MFC version for now.
	if (rStr.IsEmpty())
		return;
	rStr = MakeReverse(rStr);
	wxChar chFirst = rStr[0];
	while (chFirst == _T(' '))
	{
		rStr = rStr.Mid(1);
		chFirst = rStr[0];
	}
	if (rStr.IsEmpty())
		return;
	else
		rStr = MakeReverse(rStr);
}

bool CAdapt_ItView::StoreTextGoingBack(CKB *pKB, CSourcePhrase *pSrcPhrase, wxString &tgtPhrase)
// like StoreAdaption, but with different assumptions since we need to be able to move back when
// either there is nothing in the current phraseBox (in which case no store need be done), or when
// the user has finished typing the current srcPhrase's adaption (since it will be saved to the KB
// when focus moves back.) TRUE if okay to go back, FALSE otherwise. For glossing, pKB must point
// to the glossing KB, for adapting, to the normal KB.
// Ammended, July 2003, for Auto-Capitalization support
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// determine the auto caps parameters, if the functionality is turned on
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pSrcPhrase->m_key); // for source word or phrase
	}

	// If the source word (or phrase) has not been previously encountered, then m_bHasKBEntry (or
	// the equiv flag if glossing is ON) will be false, which has to be in effect for the StoreText
	// call not to fail. But if we have come to an entry in the KB which we are about to add a new
	// adaptation (or gloss) to, then the flag will be TRUE (and rightly so.) The StoreText call
	// would then fail - so we will test for this possibility and clear the appropriate flag if
	// necessary.
	// BEW 05July2006: No! The above comment confuses the KB entry with the CSourcePhrase instance
	// at the active location. The flags we are talking about declare that that PARTICULAR instance
	// in the DOCUMENT does, or does not, yet have a KB entry. When the phrase box lands there, it
	// gets its KB entry removed (or ref count decremented) before a store is done, and so the flags
	// are made false when the former happens.
	// RemoveRefString() was supposed to do that, but my logic error was there as well (I've fixed it
	// now). So before the store it done, the RemoveRefString call will now clear the relevant flag;
	// so we don't need to test and clear it in the following block.
	/*
	if (gbIsGlossing)
	{
		if (pSrcPhrase->m_bHasGlossingKBEntry)
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // ensures the save will not fail
	}
	else
	{
		if (pSrcPhrase->m_bHasKBEntry)
		pSrcPhrase->m_bHasKBEntry = FALSE; // ensures the save will not fail
	}
	*/
	GetDocument()->Modify(TRUE);

	// do not permit storage if the source phrase has an empty key (eg. user may have ...
	// ellipsis in the source text, which generates an empty key and three periods in the
	// punctuation)
	if (pSrcPhrase->m_key.IsEmpty())
	{
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // this is not an error, just suppression of the store
	}

	gbByCopyOnly = FALSE; // restore default setting

	// is the m_targetPhrase empty?
	if (tgtPhrase.IsEmpty())
	{
		// it's empty, so we can go back without saving anything in the kb
		pApp->m_bForceAsk = FALSE; // must ensure this flag is off, no forcing of Choose Translation
							 // dialog is required when moving back
		gbMatchedKB_UCentry = FALSE;
		return TRUE;
	}

	// It's not empty, so go ahead and re-store it as-is (but if auto capitalization has just
	// been turned on, it will be stored as a lower case entry if it is an upper case one in the doc)
	// first, remove any phrase final space characters
	int len;
	int nIndexLast;
	if (tgtPhrase.IsEmpty())
		goto s; // code below would fail if string is empty, due to negative index
	len = tgtPhrase.Length();
	nIndexLast = len-1;
	do {
		if (tgtPhrase.GetChar(nIndexLast) == _T(' '))
		{
			// wxString.Remove must have 1 otherwise the default is to truncate the
			// remainder of the string!
			tgtPhrase.Remove(nIndexLast,1); //tgtPhrase.Delete(nIndexLast);
			// can't trust the Delete's returned value, it exceeds string length by one
			len = tgtPhrase.Length();
			nIndexLast = len -1;
		}
		else
		{
			break;
		}
	} while (len > 0 && nIndexLast > -1);

	// always place a copy in the source phrase's m_adaption member, etc
s:	if (gbIsGlossing)
	{
		wxString s = tgtPhrase;
		if (gbAutoCaps)
		{
			bool bNoError = TRUE;
			if (gbSourceIsUpperCase && !gbMatchedKB_UCentry)
			{
				bNoError = SetCaseParameters(s,FALSE);
				if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
				{
					// change it to upper case
					s.SetChar(0,gcharNonSrcUC);
				}
			}
		}
		pSrcPhrase->m_gloss = s;
		if (gbRemovePunctuationFromGlosses)
			RemovePunctuation(GetDocument(),&pSrcPhrase->m_gloss,1);
	}
	else
	{
		if (tgtPhrase != _T("<Not In KB>"))
		{
			pSrcPhrase->m_adaption = tgtPhrase;
			if (!gbInhibitLine4StrCall)
				MakeLineFourString(pSrcPhrase, tgtPhrase); // set m_targetStr member too
		}
	}

	// if the user doesn't want a store done (he checked the dialog bar's control for this choice)
	// then return without saving after setting the source phrase's m_bNotInKB flag to TRUE
	int nMapIndex;
	if (!gbIsGlossing && !pApp->m_bSaveToKB)
	{
		pSrcPhrase->m_bNotInKB = TRUE;
		pApp->m_bForceAsk = FALSE; // its a valid 'store op' so must turn this flag back off
		pSrcPhrase->m_bHasKBEntry = FALSE;
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // we want the caller to think all is well

		//nMapIndex = 0; // TODO: check unreachable code here //always zero when glossing is ON, even if m_nSrcWords is greater than one
	}
	else // adapting or glossing
	{
		if (gbIsGlossing)
			nMapIndex = 0;
		else
			nMapIndex = pSrcPhrase->m_nSrcWords - 1; // compute the index to the map
	}
	// if there is a CTargetUnit associated with the current key, then get it; if not,
	// create one and add it to the appropriate map

	// if we have too many source words, then we cannot save to the KB, so detect this and warn the
	// user that it will not be put in the KB, then return TRUE since all is otherwise okay;
	// this check need be done only when adapting
	if (!gbIsGlossing && pSrcPhrase->m_nSrcWords > MAX_WORDS)
	{
		pSrcPhrase->m_bNotInKB = TRUE;
		pSrcPhrase->m_bHasKBEntry = FALSE;
		// IDS_TOO_MANY_SRC_WORDS
		wxMessageBox(_("Warning: there are too many source language words in this phrase for this adaptation to be stored in the knowledge base."), _T(""), wxICON_INFORMATION);
		gbMatchedKB_UCentry = FALSE;
		return TRUE;
	}

	// continue the storage operation
	wxString unchangedkey = pSrcPhrase->m_key; // this never has case change done to it
											  // (need this for lookups)
	wxString key = AutoCapsMakeStorageString(pSrcPhrase->m_key); // key might be made lower case
	CTargetUnit* pTU;
	CRefString* pRefString;
	if (pKB->m_pMap[nMapIndex]->empty()) 
	{
		pTU = new CTargetUnit;
		wxASSERT(pTU != NULL);
		pRefString = new CRefString(pTU);
		wxASSERT(pRefString != NULL);

		pRefString->m_refCount = 1; // set the count
		// add the translation string, or gloss string
		if (bNoError)
		{
			pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
		}
		else
		{
			// if something went wrong, just save as if gbAutoCaps was FALSE
			pRefString->m_translation = tgtPhrase;
		}
		pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
		if (pApp->m_bForceAsk)
			pTU->m_bAlwaysAsk = TRUE; // turn it on if user wants to be given opportunity to
									  // add a new refString next time its matched

		pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
		if (gbIsGlossing)
			pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
		else
			pSrcPhrase->m_bHasKBEntry = TRUE;

		(*pKB->m_pMap[nMapIndex])[key] = pTU;
		// update the maxWords limit
		if (gbIsGlossing)
		{
			pKB->m_nMaxWords = 1; // always 1 when glossing (ensures glossing ignores maps
								  // with indices from 1 to 9; everything is in 1st map only)
		}
		else
		{
			if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
				pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
		}
	}
	else // do next block when the map is not empty
	{
		// there might be a pre-existing association between this key and a CTargetUnit,
		// so check it out
		bool bFound = AutoCapsLookup(pKB->m_pMap[nMapIndex], pTU, unchangedkey); 

		// if not found, then create a targetUnit, and add the refString, etc, as above;
		// but if one is found, then check whether we add a new refString or increment the
		// refCount of an existing one
		if(!bFound)
		{
			pTU = new CTargetUnit;
			wxASSERT(pTU != NULL);
			pRefString = new CRefString((CTargetUnit*)pTU);
			wxASSERT(pRefString != NULL);

			pRefString->m_refCount = 1; // set the count
			pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
			pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
			if (pApp->m_bForceAsk)
				pTU->m_bAlwaysAsk = TRUE; // turn it on if user wants to be given opportunity to
										  // add a new refString next time its matched

			pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
			if (gbIsGlossing)
				pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
			else
				pSrcPhrase->m_bHasKBEntry = TRUE;

			(*pKB->m_pMap[nMapIndex])[key] = pTU;// store the CTargetUnit in the map 
			// update the maxWords limit
			if (gbIsGlossing)
			{
				pKB->m_nMaxWords = 1; // for glossing it is always 1
			}
			else
			{
				if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
					pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
			}
		}
		else // we found one
		{
			// we have a pTU for this key, so check for a matching CRefString, if there is no
			// match, then add a new one (note: no need to set m_nMaxWords for this case)
			bool bMatched = FALSE;
			pRefString = new CRefString(pTU);
			wxASSERT(pRefString != NULL);
			pRefString->m_refCount = 1; // set the count, assuming this will be stored (it may
										// not be)
			// set its gloss or adaptation string; the fancy test is required because the
			// refStr entry may have been stored in the kb when auto-caps was off, and if it
			// was upper case for the source text's first letter, then it will have been looked up
			// only on the second attempt, for which gbMatchedKB_UCentry will have been set TRUE,
			// and which means the gloss or adaptation will not have been made lower case - so we
			// must allow for this possibility
			if ((gbAutoCaps && gbMatchedKB_UCentry) || !gbAutoCaps)
				pRefString->m_translation = tgtPhrase; // use the unchanged string, could be uc
			else
				pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
			//pRefString->m_translation.FreeExtra();

			TranslationsList::Node* pos = pTU->m_pTranslations->GetFirst();
			while (pos != NULL)
			{
				CRefString* pRefStr = (CRefString*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pRefStr != NULL);

				// does it match?
				if (*pRefStr == *pRefString) // TRUE if pRStr->m_translation ==
											 //						pRefString->m_translation
				{
					// if we get a match, then increment ref count and point to this, etc
					bMatched = TRUE;
					pRefStr->m_refCount++;
					if (gbIsGlossing)
						pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					else
						pSrcPhrase->m_bHasKBEntry = TRUE;
					delete pRefString; // don't need this one
					pRefString = (CRefString*)NULL;
					if (pApp->m_bForceAsk)
						pTU->m_bAlwaysAsk = TRUE; // nTrCount might be 1, so we must ensure it
												  // gets set if that is what the user wants
					break;
				}
			}
			// if we get here with bMatched == FALSE, then there was no match, so we must add
			// the new pRefString to the targetUnit
			if (!bMatched)
			{
				TranslationsList::Node* tpos = pTU->m_pTranslations->GetFirst();
				CRefString* pRefStr = (CRefString*)tpos->GetData();
				if (!gbIsGlossing && pRefStr->m_translation == _T("<Not In KB>"))
				{
					// keep it that way (the way to cancel this setting is with the toolbar
					// checkbox)  But leave m_adaption and m_targetStr (or m_gloss) having whatever
					// the user may have typed
					pSrcPhrase->m_bHasKBEntry = FALSE;
					pSrcPhrase->m_bNotInKB = TRUE;
					pSrcPhrase->m_bBeginRetranslation = FALSE;
					pSrcPhrase->m_bEndRetranslation = FALSE;
					delete pRefString; // don't leak memory
					pRefString = (CRefString*)NULL;
					pApp->m_bForceAsk = FALSE;
					gbMatchedKB_UCentry = FALSE;
					return TRUE; // all is well
				}
				else // either we are glossing, or we are adapting and it's a normal adaptation
				{
					// is the m_targetPhrase empty?
					if (tgtPhrase.IsEmpty())
					{
						// don't store if it is empty, and then return; but if not empty
						// then go on to do the storage
						if (!gbIsGlossing)
						{
							pSrcPhrase->m_bBeginRetranslation = FALSE;
							pSrcPhrase->m_bEndRetranslation = FALSE;
						}
						pApp->m_bForceAsk = FALSE; // make sure it's turned off
						delete pRefString; // don't leak the memory
						pRefString = (CRefString*)NULL;
						gbMatchedKB_UCentry = FALSE;
						return TRUE; // make caller think all is well
					}

					// recalculate the string to be stored, in case we looked up a
					// stored upper case entry earlier
					pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
					pTU->m_pTranslations->Append(pRefString); 
					if (gbIsGlossing)
						pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					else
						pSrcPhrase->m_bHasKBEntry = TRUE;
				}
			}
		}
	}
	if (!gbIsGlossing)
		pSrcPhrase->m_bNotInKB = FALSE; // ensure correct flag value, in case it was not in KB
	pApp->m_bForceAsk = FALSE; // must be turned off, as it applies to one store operation only
	gbMatchedKB_UCentry = FALSE;
	return TRUE;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// It enables the "Change Interface Language..." item on the View menu. This menu item is always
/// enabled unless Vertical Editing is in progress.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateChangeInterfaceLanguage(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// should always be accessible
	event.Enable(TRUE);
}

void CAdapt_ItView::OnChangeInterfaceLanguage(wxCommandEvent& WXUNUSED(event))
{
	gpApp->ChangeUILanguage();
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the application is doing a vertical edit, only showing the target language, or the Document 
/// pointer is NULL, this handler disables the "Preferences..." item on the View menu and 
/// immediately returns.
/// It enables the "Preferences..." item on the View menu if a document is loaded (i.e., the count 
/// of source phrases in m_pSourcePhrases list is greater than zero), otherwise it disables the 
/// menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditPreferences(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if ((CAdapt_ItDoc*)GetDocument() == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnCheckSingleStep(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// toggle the m_bSingleStep flag
	pApp->m_bSingleStep = pApp->m_bSingleStep == TRUE ? FALSE : TRUE;

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnCheckForceAsk(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// toggle the m_bForceAsk flag
	pApp->m_bForceAsk = pApp->m_bForceAsk == TRUE ? FALSE : TRUE;

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnCopySource(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pViewCopySource = pMenuBar->FindItem(ID_COPY_SOURCE);
	wxASSERT(pViewCopySource != NULL);

	// toggle the setting
	if (pApp->m_bCopySource)
	{
		// toggle the checkmark to OFF
		pViewCopySource->Check(FALSE);
		pApp->m_bCopySource = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pViewCopySource->Check(TRUE);
		pApp->m_bCopySource = TRUE;
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the application is in Free Translation Mode, this handler disables the "Use Consistent Changes" 
/// item on the Tools menu and immediately returns.
/// If one or more cc tables are loaded (i.e., the App's m_bTablesLoaded flag is TRUE), it enables the 
/// "Use Consistent Changes" item on the Tools menu, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateUseConsistentChanges(wxUpdateUIEvent& event)
{
	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}

	// the flags we want are on the view, so get the view
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (pApp->m_bTablesLoaded)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the application is in Free Translation Mode, this handler disables the "Use SIL Converter" 
/// item on the Tools menu and immediately returns.
/// If there is an SIL Converter table name configured (i.e., the App's m_strSilEncConverterName string
/// is not empty), it enables the "Use SIL Converter" item on the Tools menu, otherwise it disables the 
/// menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateUseSilConverter(wxUpdateUIEvent& event)
{
	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}

    // enable it if there's a configured table name
	event.Enable(!gpApp->m_strSilEncConverterName.IsEmpty());
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event (unused) 
/// \remarks
/// Called from the Tools menu on selection of the "Use Consistent Changes" menu item. This handler
/// toggles the check on the menu item and the value of the m_bUseConsistentChanges variable on the App.
/// The "Use Consistent Changes" menu selection basically works as a switch to turn on or off any
/// change tables the were previously loaded using the "Load Consistent Changes..." menu item.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUseConsistentChanges(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuUseCC = pMenuBar->FindItem(ID_USE_CC);
	wxASSERT(pToolsMenuUseCC != NULL);
	wxMenuItem * pToolsMenuUseSilConverter = pMenuBar->FindItem(ID_USE_SILCONVERTER);
	wxASSERT(pToolsMenuUseSilConverter != NULL);

	// toggle the setting
	if (pApp->m_bUseConsistentChanges)
	{
		// toggle the checkmark to OFF
		pToolsMenuUseCC->Check(FALSE);
		pApp->m_bUseConsistentChanges = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pToolsMenuUseCC->Check(TRUE);
		pApp->m_bUseConsistentChanges = TRUE;

        // reset the SILConverter 'use' menu in case it was set (i.e. these two are mutually exclusive)
		pToolsMenuUseSilConverter->Check(FALSE);
		gpApp->m_bUseSilConverter = FALSE;
	}

	// if the checkbox was just turned on, then have the phrase box placed there again,
	// so as to give consistent changes a chance to work on the current source phrase
	if (pApp->m_bUseConsistentChanges)
	{
		// ensure we are not at eof with no phrase box currently in existence
		if (pApp->m_pActivePile != NULL)
		{
			CCell* pCell = pApp->m_pActivePile->m_pCell[2];
			wxASSERT(pCell != NULL);
			int selector = 1; // this value suppresses both removal from the KB and storing
							  // prior adaptation
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			PlacePhraseBox(pCell,selector);
		}
	}
	else
	{
		// we have just turned off the use of consistent changes, so we must turn off acceptance
		// of defaults too
		pApp->m_bAcceptDefaults = FALSE;

		// and update the menu command to be unchecked
		pToolsMenuUseCC->Check(FALSE);

	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

// TODO: Uncomment blocks below after COM equivalent is implemented
void CAdapt_ItView::OnUseSilConverter(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame *pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuUseSilConverter;
	pToolsMenuUseSilConverter = pMenuBar->FindItem(ID_USE_SILCONVERTER);
	wxASSERT(pToolsMenuUseSilConverter != NULL);
	wxMenuItem * pToolsMenuUseCC;
	pToolsMenuUseCC = pMenuBar->FindItem(ID_USE_CC);
	wxASSERT(pToolsMenuUseCC != NULL);
	wxMenuItem* pToolsMenuAcceptChanges;
	pToolsMenuAcceptChanges = pMenuBar->FindItem(ID_ACCEPT_CHANGES);
	wxASSERT(pToolsMenuAcceptChanges != NULL);
/*

	// toggle the setting
	if (gpApp->m_bUseSilConverter)
	{
		// toggle the checkmark to OFF
		pToolsMenuUseSilConverter->Check(FALSE); //pToolsMenu->CheckMenuItem(ID_USE_SILCONVERTER,MF_BYCOMMAND | MF_UNCHECKED);
		gpApp->m_bUseSilConverter = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pToolsMenuUseSilConverter->Check(TRUE);
		gpApp->m_bUseSilConverter = TRUE;

        // reset the Consistent Changes 'use' menu in case it was set (i.e. these two are mutually exclusive)
		pToolsMenuUseCC->Check(FALSE);
		gpApp->m_bUseConsistentChanges = FALSE;
	}

	// if the checkbox was just turned on, then have the phrase box placed there again,
	// so as to give consistent changes a chance to work on the current source phrase
	if (gpApp->m_bUseSilConverter)
	{
		// ensure we are not at eof with no phrase box currently in existence
		if (gpApp->m_pActivePile != NULL)
		{
			CCell* pCell = gpApp->m_pActivePile->m_pCell[2];
			wxASSERT(pCell != NULL);
			int selector = 1; // this value suppresses both removal from the KB and storing
							  // prior adaptation
			gpApp->m_pTargetBox->m_bAbandonable = TRUE;
			PlacePhraseBox(pCell,selector);
		}
	}
	else
	{
		// we have just turned off the use of the SILConverter, so we must turn off acceptance
		// of defaults too
		gpApp->m_bAcceptDefaults = FALSE;

		// and update the menu command to be unchecked
		pToolsMenuAcceptChanges->Check(FALSE);

	}

	// restore focus to the targetBox, if it is visible
	if (gpApp->m_pTargetBox != NULL)			//if (m_targetBox.m_hWnd != NULL)
		if (gpApp->m_pTargetBox->IsShown())	// if ((m_targetBox.GetStyle() & WS_VISIBLE) != 0)
			gpApp->m_pTargetBox->SetFocus();	// m_targetBox.SetFocus();
	*/
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If Vertical Editing is in progress, the "Accept Changes Without Stopping" item on the Tools menu
/// is disabled and this handler returns immediately.
/// If the application is not in Single Step Mode, but is set to Copy the Source text, and, either
/// m_bUseConsistentChanges is TRUE or m_bUseSilConverter is TRUE, then this handler enables the 
/// "Accept Changes Without Stopping" item on the Tools menu, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAcceptChanges(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// disable if the 3 flags (single step, cc changes, copy source) are not
	// the right values, but if they are, allow value to be changed
	if (!gpApp->m_bSingleStep && gpApp->m_bCopySource && (gpApp->m_bUseConsistentChanges || gpApp->m_bUseSilConverter) )
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAcceptChanges(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);

	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsAcceptChanges = pMenuBar->FindItem(ID_ACCEPT_CHANGES);
	wxASSERT(pToolsAcceptChanges != NULL);

	// toggle the setting
	if (pApp->m_bAcceptDefaults)
	{
		// toggle the checkmark to OFF
		pToolsAcceptChanges->Check(FALSE);
		pApp->m_bAcceptDefaults = FALSE;
		
		// restore the highlighting setting
		pApp->m_bSuppressTargetHighlighting = gbSaveHilightingSetting;
	}
	else
	{
		// toggle the checkmark to ON
		pToolsAcceptChanges->Check(TRUE);
		pApp->m_bAcceptDefaults = TRUE;
		
		// save the highlighting setting so it can be restored when the toggle
		// is later turned off, and then suppress highlighting till then
		gbSaveHilightingSetting = gpApp->m_bSuppressTargetHighlighting;
		gpApp->m_bSuppressTargetHighlighting = TRUE;
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnRadioDrafting(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar);
	wxRadioButton* pDraftingBtn = (wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_DRAFTING);
	wxRadioButton* pReviewingBtn = (wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_REVIEWING);
	pDraftingBtn->SetValue(TRUE);
	pReviewingBtn->SetValue(FALSE);
	pApp->m_bDrafting = TRUE;

	// ensure the Automatic checkbox is enabled
	wxCheckBox* pAuto = (wxCheckBox*)pControlBar->FindWindowById(IDC_CHECK_SINGLE_STEP);
	pAuto->Enable(TRUE);

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnRadioReviewing(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame);
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxRadioButton* pDraftingBtn = (wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_DRAFTING);
	wxRadioButton* pReviewingBtn = (wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_REVIEWING);
	pDraftingBtn->SetValue(FALSE);
	pReviewingBtn->SetValue(TRUE);
	pApp->m_bDrafting = FALSE;

	// ensure the Automatic checkbox is disabled
	wxCheckBox* pAuto = (wxCheckBox*)pControlBar->FindWindowById(IDC_CHECK_SINGLE_STEP);
	pAuto->Enable(FALSE);

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if ((pApp->m_pTargetBox->IsShown()))
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnClearContentsButton(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pComposeBar = pFrame->m_pComposeBar; 
	if(pComposeBar != NULL && pComposeBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			pEdit->SetValue(_T(""));
			pEdit->SetFocus();
		}
	}
}

void CAdapt_ItView::OnSelectAllButton(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pComposeBar = pFrame->m_pComposeBar;
	if(pComposeBar != NULL && pComposeBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			pEdit->SetSelection(-1,-1);
			gnStart = 0;
			gnEnd = -1;
			pEdit->SetFocus();
		}
	}
}

/*******************************************************************
RemovePunctuation
returns: nothing
pDoc -- pointer to document class
pStr -- pointer to the CString which may have punctuation, and the punctuation is to be
removed (this is done using ParseWord() so the method of stripping is consistent
with how stripping is done during parsing of source text data
nIndex -- index of the punctuation string which is to be used - 0 for source, 1 for target
New version coded on 02April05 by BEW
********************************************************************/

void CAdapt_ItView::RemovePunctuation(CAdapt_ItDoc* pDoc, wxString* pStr, int nIndex)
{
	if (pStr->IsEmpty())
		return;

	// get rid of spaces from a temp copy of the punctuation set which we want to use
	wxString spacelessPunctsStr = gpApp->m_punctuation[nIndex];
	// remove all spaces, leaving only the list of punctation characters
	int countRemoved;
	countRemoved = spacelessPunctsStr.Replace(_T(" "),_T(""));

	// test for no punctuation, if so, then we can return immediately
	if (FindOneOf(*pStr, spacelessPunctsStr) == -1) 
	{
		// there are no punctuation chars in the string (but there may be spaces),
		// so the caller can use the string immediately
		return;
	}

	// wx version note: Since we require a read-only buffer we use GetData which just returns
	// a const wxChar* to the data in the string.
	const wxChar* pChar = (*pStr).GetData();
	wxChar* ptr = (wxChar*)pChar;
	wxChar* pBufStart = ptr;
	wxChar* pEnd = pBufStart + (*pStr).Length(); // points to null
	wxASSERT(*pEnd == _T('\0')); // whm added
	wxString strFinal = _T(""); // store accumulated punctuation-less word or phrase here
	wxString precStr = _T(""); // for storage of preceding punctuation stripped in the parse
	wxString follStr = _T(""); // ditto, but for following punctuation
	int itemLen = 0;

	while (ptr < pEnd)
	{
		itemLen = pDoc->ParseWord(ptr, precStr,follStr,spacelessPunctsStr);

		wxString strPunctuatedWord(ptr,itemLen);

		// get the length of the preceding punctuation substring
		int aLength = precStr.Length();

		wxString spanned = strPunctuatedWord.Mid(aLength); // get the remainder after preceding punctuation is skipped

		ptr += aLength; // point to start of the word proper
		itemLen -= aLength; // reduce itemLen by the size of the preceding punctuation substring

		// get the length of the following punctuation substring
		aLength = follStr.Length();
		int wordLen = itemLen - aLength;
		wxASSERT(wordLen >= 0);
		wxString theWord(ptr,wordLen);

		ptr += itemLen; // update ptr to point at next part of string to be parsed

		while (*ptr == _T(' ')) { ptr++; }

		if (strFinal.IsEmpty())
		{
			strFinal = theWord;
		}
		else
		{
			strFinal += _T(" ") + theWord;
		}

		precStr.Empty();
		follStr.Empty();
	}

	*pStr = strFinal; // copy result to caller
}

void CAdapt_ItView::OnEditCopy(wxCommandEvent& WXUNUSED(event))
// the copy could be from several places, so these are prioritized. First, if the compose box
// has a selection and has the focus, it is done from there; but if not, then next in priority
// is a selection of source phrases - if such a selection is current, then the m_targetStr fields
// are accumulated as a phrase & copied to the clipboard; if not, the phrase box contents
// is taken, provided it has the focus; if none of these, then nothing is copied.
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// get the window which has the current focus
	wxWindow* pWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the frame window in OnEditCopy\n"),
			_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnEditCopy\n"),
			_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnEditCopy\n"),
			_T(""), wxICON_EXCLAMATION);
		return;
	}
	// In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle
	// from the view menu merely shows or hides the composeBar. In MFC version the
	// compose bar is recreated each time it becomes visible. Hence, I'll add the
	// condition check to insure the text control in the composeBar IsShown()
	if (pWnd == pEdit && pEdit->IsShown())
	{
		pEdit->Copy(); // copy to the clipboard using wxTextCtrl's built in function (CF_TEXT format,
					   // or CF_UNICODETEXT for the NR version)
		return;
	}

	if (pApp->m_selectionLine == 0 || pApp->m_selectionLine == 1)
	{
		// this has priority, ie. if there is / are sourcePhrase(s) selected
		DoSrcPhraseSelCopy();
	}
	else
	{
	wxTextCtrl* pEdit2 = pApp->m_pTargetBox;
	if (pEdit2 == pWnd)
		pEdit2->Copy();
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the App's m_pActivePile is NULL this handler disables the "Copy" item in the Edit menu
/// and immediately returns.
/// It enables the "Copy" item on the Edit menu if there is a valid selection in either the
/// composeBar's edit box, the targetBox, or a source phrase selection, otherwise it disables 
/// the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditCopy(wxUpdateUIEvent& event)
{
	// whm: Removed the messages which would be issued endlessly if ever the errors happened in the
	// update idler handling.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	bool bComposeSel = FALSE;
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the frame window in OnUpdateEditCopy\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar; 
	if (pBar == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnUpdateEditCopy\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		//wxMessageBox(_T(
		//	"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnUpdateEditCopy\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	long nStartChar1; long nEndChar1; 
	pEdit->GetSelection(&nStartChar1,&nEndChar1);
	bComposeSel = nStartChar1 != nEndChar1;

	bool bTargetBoxSel = FALSE;
	long nStartChar; long nEndChar;
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->GetSelection(&nStartChar,&nEndChar);
			bTargetBoxSel = nStartChar != nEndChar;
		}

	bool bSrcPhraseSel = FALSE;
	if (pApp->m_selectionLine == 0 || pApp->m_selectionLine == 1)
		bSrcPhraseSel = TRUE;

	event.Enable(bComposeSel || bTargetBoxSel || bSrcPhraseSel);
}

void CAdapt_ItView::OnEditPaste(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxWindow* pWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the frame window in OnEditPaste\n"),
			_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnEditPaste\n"),
			_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		wxMessageBox(_T(
			"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnEditPaste\n"),
			_T(""), wxICON_EXCLAMATION);
		return;
	}
	// In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle
	// from the view menu merely shows or hides the composeBar. In MFC version the
	// compose bar is recreated each time it becomes visible. Hence, I'll add the
	// condition check to insure the text control in the composeBar IsShown()
	if (pWnd == pEdit && pEdit->IsShown())
	{
		// paste from the clipboard using wxTextCtrl's built in function (CF_TEXT format
		// or CF_UNICODETEXT for NR)
		pEdit->Paste();
	}

	if (pApp->m_pTargetBox->GetHandle() != NULL)
		if (pApp->m_pTargetBox->IsShown() && (pApp->m_pTargetBox == pWnd))
		{
			DoTargetBoxPaste(pApp->m_pActivePile);
		}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the App's main frame pointer is NULL, or the composeBar is NULL, or the composeBar's edit box is
/// NULL, or both the composeBar and targetBox are not shown this handler disables the "Paste" item in the 
/// Edit menu and immediately returns.
/// It enables the "Paste" item on the Edit menu if either the composeBar's edit box is shown or the
/// targetBox is shown, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditPaste(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	bool bComposeWnd = FALSE;

	wxWindow* pFocusWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	// In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle
	// from the view menu merely shows or hides the composeBar. In MFC version the
	// compose bar is recreated each time it becomes visible. Hence, I'll add the
	// condition check to insure the text control in the composeBar IsShown()
	if (pFocusWnd == pEdit && pEdit->IsShown())
		bComposeWnd = TRUE;

	bool bTargetBox = FALSE;
	if (pApp->m_pTargetBox != NULL)
		bTargetBox = (pApp->m_pTargetBox->IsShown()) && (pApp->m_pTargetBox == pFocusWnd);

	event.Enable(bComposeWnd || bTargetBox);
}

void CAdapt_ItView::OnEditCut(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// get the window which has the current focus
	wxWindow* pWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the frame window in OnEditCut\n"),
							_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnEditCut\n"),
							_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		wxMessageBox(_T(
			"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnEditCut\n"),
			_T(""), wxICON_EXCLAMATION);
		return;
	}
	// In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle
	// from the view menu merely shows or hides the composeBar. In MFC version the
	// compose bar is recreated each time it becomes visible. Hence, I'll add the
	// condition check to insure the text control in the composeBar IsShown()
	if (pWnd == pEdit && pEdit->IsShown())// if (pWnd == pEdit)
		pEdit->Cut(); // cut to the clipboard using wxTextCtrl's built in function (CF_TEXT format)

	wxTextCtrl* pEdit2 = pApp->m_pTargetBox;
	if (pEdit2 == pWnd)
	{
		pEdit2->Cut();

		// the phrase box now has different text, but pApp->m_targetPhrase still has the uncut text, so
		// to prevent the cut text from reappearing on the pile, we must put the text remaining in
		// the phrase box's "title" into pApp->m_targetPhrase;
		wxString text;
		text = pEdit2->GetValue();
		pApp->m_targetPhrase = text; // now it agree's with the window contents for the box
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the App's main frame is NULL, or the composeBar is NULL, or the composeBar's edit box is NULL, 
/// or neither the composeBar nor targetBox have a selection, this handler disables the "Cut" item 
/// in the Edit menu, otherwise it enables the "Cut" item on the Edit menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditCut(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	bool bComposeSel = FALSE;
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the frame window in OnUpdateEditCut\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnUpdateEditCut\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		//wxMessageBox(_T(
		//	"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnUpdateEditCut\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	long nStartChar; long nEndChar;
	pEdit->GetSelection(&nStartChar,&nEndChar);
	bComposeSel = nStartChar != nEndChar;

	bool bTargetBoxSel = FALSE;
	long nStartChar1; long nEndChar1; 
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->GetSelection(&nStartChar1,&nEndChar1); 
			bTargetBoxSel = nStartChar1 != nEndChar1;
		}


	event.Enable(bComposeSel || bTargetBoxSel);
}

void CAdapt_ItView::InsertNullSrcPhraseBefore() // this one is public, and default for
// bInsertBefore is TRUE, and so it inserts before the active location, or before the selection
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// first save old sequ num for active location
	gnOldSequNum = pApp->m_nActiveSequNum;

	// find the pile preceding which to do the insertion - it will either be preceding the
	// first selected pile, if there is a selection current, or preceding the active location
	// if no selection is current
	CPile* pInsertLocPile;
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);
	int nCount = 1;
	int nSequNum = -1;
	if (pApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's first element
		CCellList* pCellList = &pApp->m_selection; 
		CCellList::Node* fpos = pCellList->GetFirst();
		pInsertLocPile = fpos->GetData()->m_pPile; 
		if (pInsertLocPile == NULL)
		{
			wxMessageBox(_T("Sorry, a zero pointer was returned, the insertion cannot be done."),
											_T(""), wxICON_EXCLAMATION);
			return;
		}
		nSequNum = pInsertLocPile->m_pSrcPhrase->m_nSequNumber;
		wxASSERT(pInsertLocPile != NULL);
		RemoveSelection(); // Invalidate will be called in InsertNullSourcePhrase()
	}
	else
	{
		// no selection, so just insert preceding wherever the phraseBox currently is located
		pInsertLocPile = pApp->m_pActivePile;
		if (pInsertLocPile == NULL)
		{
			wxMessageBox(_T("Sorry, a zero pointer was returned, the insertion cannot be done."),
											_T(""), wxICON_EXCLAMATION);
			return;
		}
		nSequNum = pInsertLocPile->m_pSrcPhrase->m_nSequNumber;
	}
	wxASSERT(nSequNum >= 0);


	// check we are not in a retranslation - we can't insert there!
	if(pInsertLocPile->m_pSrcPhrase->m_bRetranslation)
	{
		CPile* pPile = GetPrevPile(pInsertLocPile);
		if (pPile != NULL)
		{
			if (!pPile->m_pSrcPhrase->m_bRetranslation)
				goto a;
		}
		// IDS_NO_INSERT_IN_RETRANS
		wxMessageBox(_("Sorry, you cannot insert a placeholder within a retranslation. The command has been ignored."),_T(""), wxICON_EXCLAMATION);
		RemoveSelection();
		Invalidate();
		return;
	}

	// ensure the contents of the phrase box are saved to the KB
	// & make the punctuated target string
a:	if (pApp->m_pTargetBox != NULL && pApp->m_pTargetBox->IsShown())
	{
		MakeLineFourString(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase); // StoreText( ) does it

		// we are about to leave the current phrase box location, so we must try to store what
		// is now in the box, if the relevant flags allow it
		RemovePunctuation(pDoc,&pApp->m_targetPhrase,1 /*from tgt*/);
		gbInhibitLine4StrCall = TRUE;
		bool bOK;
		bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
		gbInhibitLine4StrCall = FALSE;
	}

	InsertNullSourcePhrase(pDoc,pApp,pInsertLocPile,nCount);

	// jump to it (can't use old pile pointers, the recalcLayout call will have clobbered them)
	CPile* pPile = GetPile(nSequNum);
	Jump(pApp,pPile->m_pSrcPhrase);
}

void CAdapt_ItView::InsertNullSrcPhraseAfter() // this one is public
{
	int nSequNum;
	int nCount;
	CAdapt_ItDoc* pDoc = GetDocument();
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	// CTRL key is down, so an "insert after" is wanted
	// first save old sequ num for active location
	gnOldSequNum = pApp->m_nActiveSequNum;

	// find the pile after which to do the insertion - it will either be after the
	// last selected pile if there is a selection current, or after the active location
	// if no selection is current - beware the case when active location is a doc end!
	CPile* pInsertLocPile;
	nCount = 1; // the button or shortcut can only insert one
	nSequNum = -1;
	if (pApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's last element
		CCellList* pCellList = &pApp->m_selection;
		CCellList::Node* cpos = pCellList->GetLast();
		pInsertLocPile = cpos->GetData()->m_pPile; 
		if (pInsertLocPile == NULL)
		{
			wxMessageBox(_T("Sorry, a zero pointer was returned, the insertion cannot be done."),
											_T(""), wxICON_EXCLAMATION);
			return;
		}
		nSequNum = pInsertLocPile->m_pSrcPhrase->m_nSequNumber;
		wxASSERT(pInsertLocPile != NULL);
		RemoveSelection(); // Invalidate will be called in InsertNullSourcePhrase()
	}
	else
	{
		// no selection, so just insert after wherever the phraseBox currently is located
		pInsertLocPile = pApp->m_pActivePile;
		if (pInsertLocPile == NULL)
		{
			wxMessageBox(_T("Sorry, a zero pointer was returned, the insertion cannot be done."),
											_T(""), wxICON_EXCLAMATION);
			return;
		}
		nSequNum = pInsertLocPile->m_pSrcPhrase->m_nSequNumber;
	}
	wxASSERT(nSequNum >= 0);

	// check we are not in a retranslation - we can't insert there! We can be at the end of a
	// retranslation since we are then inserting after it, but if we are not at the end, there
	// will be at least one more retranslation sourcephrase to the right, and so we must check
	// if this is the case & abort the operation if so
	if(pInsertLocPile->m_pSrcPhrase->m_bRetranslation)
	{
		CPile* pPile = GetNextPile(pInsertLocPile);
		if (pPile != NULL)
		{
			if (!pPile->m_pSrcPhrase->m_bRetranslation)
				goto b; // it's okay, pInsertLocPile is at the end of the retranslation
		}
		// IDS_NO_INSERT_IN_RETRANS
		wxMessageBox(_("Sorry, you cannot insert a placeholder within a retranslation. The command has been ignored."),_T(""), wxICON_EXCLAMATION);
		RemoveSelection();
		Invalidate();
		return;
	}

	// ensure the contents of the phrase box are saved to the KB
	// & make the punctuated target string
b:	if (pApp->m_pTargetBox != NULL && pApp->m_pTargetBox->IsShown())
	{
		MakeLineFourString(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);

		// we are about to leave the current phrase box location, so we must try to store what is now
		// in the box, if the relevant flags allow it
		RemovePunctuation(pDoc,&pApp->m_targetPhrase,1 /*from tgt*/);
		gbInhibitLine4StrCall = TRUE;
		bool bOK;
		bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
		gbInhibitLine4StrCall = FALSE;
	}

	// at this point, we need to increment the pInsertLocPile pointer to the next pile, and the
	// nSequNum to it's sequence number, since InsertNullSourcePhrase() always inserts "before"
	// the pInsertLocPile; however, if the selection end, or active location if there is no
	// selection, is at the very end of the document (ie. last sourcephrase), there is no
	// following source phrase instance to insert before. If this is the case, we have to append
	// a dummy sourcephrase at the end of the document, do the insertion, and then remove it
	// again; and we will also have to set (and later clear) the global gbDummyAddedTemporarily
	// because this is used in the function in order to force a leftwards association only (and
	// hence the user does not have to be asked whether to associate right or left, if there is
	// final punctuation)
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CSourcePhrase* pDummySrcPhrase = NULL; // whm initialized to NULL
	if (nSequNum == pApp->m_maxIndex)
	{
		// a dummy is temporarily required
		gbDummyAddedTemporarily = TRUE;

		// do the append
		pDummySrcPhrase = new CSourcePhrase;
		wxASSERT(pDummySrcPhrase != NULL);
		pDummySrcPhrase->m_srcPhrase = _T("dummy"); // something needed, so a pile width can
													// be computed
		pDummySrcPhrase->m_key = pDummySrcPhrase->m_srcPhrase;
		pApp->m_maxIndex += 1;
		pApp->m_endIndex = pApp->m_maxIndex;
		pDummySrcPhrase->m_nSequNumber = pApp->m_maxIndex;
		SPList::Node* posTail;
		posTail = pSrcPhrases->Append(pDummySrcPhrase);

		// we need a valid layout which includes the new dummy element on its own pile
		RecalcLayout(pSrcPhrases,0,pApp->m_pBundle);
		pApp->m_pActivePile = GetPile(pApp->m_maxIndex); // temporary active location, at the dummy one

		// now we can do the insertion
		pInsertLocPile = pApp->m_pActivePile;
		nSequNum = pApp->m_maxIndex;
	}
	else
	{
		// we are not out of the woods yet; the selection end, or the active location if no
		// selection, may be at the very end of the bundle, so a call to GetNextPile() would
		// return null in that case, and we would crash - so we must check for an advance, do it
		// if needed, and then get the next pile etc.
		CPile* pPile = GetNextPile(pInsertLocPile);
		if (pPile == 0)
		{
			pInsertLocPile = AdvanceBundle(nSequNum); // calls RecalcLayout(), so need to reset
													  // active pile ptr
		}
		else
		{
			pInsertLocPile = pPile;
		}
		pApp->m_pActivePile = pInsertLocPile; // ensure it is up to date
		nSequNum++;
	}

	InsertNullSourcePhrase(pDoc,pApp,pInsertLocPile,nCount,TRUE,FALSE,FALSE); // here, never for
	// Retransln if we inserted a dummy, now get rid of it and clear the global flag
	if (gbDummyAddedTemporarily)
	{
		gbDummyAddedTemporarily = FALSE;

		// now remove the dummy element, and make sure memory is not leaked!
		delete pDummySrcPhrase->m_pSavedWords;
		pDummySrcPhrase->m_pSavedWords = (SPList*)NULL;
		delete pDummySrcPhrase->m_pMedialMarkers;
		pDummySrcPhrase->m_pMedialMarkers = (wxArrayString*)NULL;
		delete pDummySrcPhrase->m_pMedialPuncts;
		pDummySrcPhrase->m_pMedialPuncts = (wxArrayString*)NULL;
		//pSrcPhrases->RemoveTail(); // don't need the returned pointer - we already know it
		// WX Note: wxList does not have RemoveTail(). We can do it in a two stage process
		// by using GetLast(), then DeleteNode() on the pLast node returned [ which is equivalent to MFC RemoveAt()].
		SPList::Node *pLast = pSrcPhrases->GetLast();
		pSrcPhrases->DeleteNode(pLast);
		delete pDummySrcPhrase;
		pDummySrcPhrase = (CSourcePhrase*)NULL;

		// get another valid layout
		pApp->m_maxIndex = pApp->m_endIndex -= 1; // we've no longer got the dummy present, so decrement
									  // the indices
		RecalcLayout(pSrcPhrases,0,pApp->m_pBundle);
		pApp->m_pActivePile = GetPile(pApp->m_maxIndex); // temporarily at the end, caller will fix
		nSequNum = pApp->m_maxIndex;
	}

	// jump to it (can't use old pile pointers, the recalcLayout call will have clobbered them)
	CPile* pPile = GetPile(nSequNum);
	Jump(pApp,pPile->m_pSrcPhrase);
}

void CAdapt_ItView::OnButtonNullSrc(wxCommandEvent& WXUNUSED(event))
{
	// Since the Add placeholder toolbar button has an accelerator table hot key (CTRL-I see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_NULL_SRC))
	{
		::wxBell();
		return;
	}

	if (gbIsGlossing)
	{
		//IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),_T(""),wxICON_INFORMATION);
		return;
	}
	int nSequNum;
	int nCount;
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = gpApp->GetDocument(); //GetDocument();

	// Bill wanted the behaviour modified, so that if the box's m_bAbandonable flag is TRUE
	// (ie. a copy of source text was done and nothing typed yet) then the current pile
	// would have the box contents abandoned, nothing put in the KB, and then the placeholder
	// inserion - the advantage of this is that if the placeholder is inserted immediately
	// before the phrasebox's location, then after the placeholder text is typed and the user
	// hits ENTER to continue looking ahead, the former box location will get the box and the
	// copy of the source redone, rather than the user usually having to edit out an unwanted
	// copy from the KB, or remember to clear the box manually. A sufficient thing to do here
	// is just to clear the box's contents.
	if (pApp->m_pTargetBox->m_bAbandonable)
	{
		pApp->m_targetPhrase.Empty();
		if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->SetValue(_T(""));
		}
	}

	//SHORT ctrlKeyState = GetKeyState(VK_CONTROL);
	if (wxGetKeyState(WXK_CONTROL))
	{
		// CTRL key is down, so an "insert after" is wanted
		// first save old sequ num for active location
		gnOldSequNum = pApp->m_nActiveSequNum;

		// find the pile after which to do the insertion - it will either be after the
		// last selected pile if there is a selection current, or after the active location
		// if no selection is current - beware the case when active location is a doc end!
		CPile* pInsertLocPile;
		nCount = 1; // the button or shortcut can only insert one
		nSequNum = -1;
		if (pApp->m_selectionLine != -1)
		{
			// we have a selection, the pile we want is that of the selection list's last element
			CCellList* pCellList = &pApp->m_selection;
			CCellList::Node* cpos = pCellList->GetLast();
			pInsertLocPile = cpos->GetData()->m_pPile;
			if (pInsertLocPile == NULL)
			{
				wxMessageBox(_T(
					"Sorry, a zero pointer was returned, the insertion cannot be done."),
					_T(""), wxICON_EXCLAMATION);
				return;
			}
			nSequNum = pInsertLocPile->m_pSrcPhrase->m_nSequNumber;
			wxASSERT(pInsertLocPile != NULL);
			RemoveSelection(); // Invalidate will be called in InsertNullSourcePhrase()
		}
		else
		{
			// no selection, so just insert after wherever the phraseBox currently is located
			pInsertLocPile = pApp->m_pActivePile;
			if (pInsertLocPile == NULL)
			{
				wxMessageBox(_T(
					"Sorry, a zero pointer was returned, the insertion cannot be done."),
					_T(""), wxICON_EXCLAMATION);
				return;
			}
			nSequNum = pInsertLocPile->m_pSrcPhrase->m_nSequNumber;
		}
		wxASSERT(nSequNum >= 0);

		// check we are not in a retranslation - we can't insert there! We can be at the end of a
		// retranslation since we are then inserting after it, but if we are not at the end, there
		// will be at least one more retranslation sourcephrase to the right, and so we must check
		// if this is the case & abort the operation if so
		if(pInsertLocPile->m_pSrcPhrase->m_bRetranslation)
		{
			CPile* pPile = GetNextPile(pInsertLocPile);
			if (pPile != NULL)
			{
				if (!pPile->m_pSrcPhrase->m_bRetranslation)
					goto b; // it's okay, pInsertLocPile is at the end of the retranslation
			}
			// IDS_NO_INSERT_IN_RETRANS
			wxMessageBox(_("Sorry, you cannot insert a placeholder within a retranslation. The command has been ignored."),_T(""), wxICON_EXCLAMATION);
			RemoveSelection();
			Invalidate();
			return;
		}

		// ensure the contents of the phrase box are saved to the KB
		// & make the punctuated target string
b:		if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
			MakeLineFourString(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);

			// we are about to leave the current phrase box location, so we must try to store
			// what is now in the box, if the relevant flags allow it
			RemovePunctuation(pDoc,&pApp->m_targetPhrase,1 /*from tgt*/);
			gbInhibitLine4StrCall = TRUE;
			bool bOK;
			bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
			gbInhibitLine4StrCall = FALSE;
		}

		// at this point, we need to increment the pInsertLocPile pointer to the next pile, and the
		// nSequNum to it's sequence number, since InsertNullSourcePhrase() always inserts "before"
		// the pInsertLocPile; however, if the selection end, or active location if there is no
		// selection, is at the very end of the document (ie. last sourcephrase), there is no
		// following source phrase instance to insert before. If this is the case, we have to
		// append a dummy sourcephrase at the end of the document, do the insertion, and then
		// remove it again; and we will also have to set (and later clear) the global
		// gbDummyAddedTemporarily because this is used in the function in order to force a
		// leftwards association only (and hence the user does not have to be asked whether to
		// associate right or left, if there is final punctuation)
		SPList* pSrcPhrases = pApp->m_pSourcePhrases;
		CSourcePhrase* pDummySrcPhrase = NULL; // whm initialized to NULL
		if (nSequNum == pApp->m_maxIndex)
		{
			// a dummy is temporarily required
			gbDummyAddedTemporarily = TRUE;

			// do the append
			pDummySrcPhrase = new CSourcePhrase;
			pDummySrcPhrase->m_srcPhrase = _T("dummy"); // something needed, so a pile width can
														// be computed
			pDummySrcPhrase->m_key = pDummySrcPhrase->m_srcPhrase;
			pApp->m_maxIndex += 1;
			pApp->m_endIndex = pApp->m_maxIndex;
			pDummySrcPhrase->m_nSequNumber = pApp->m_maxIndex;
			SPList::Node* posTail;
			posTail = pSrcPhrases->Append(pDummySrcPhrase);

			// we need a valid layout which includes the new dummy element on its own pile
			RecalcLayout(pSrcPhrases,0,pApp->m_pBundle);
			pApp->m_pActivePile = GetPile(pApp->m_maxIndex); // temporary active location, at the dummy one

			// now we can do the insertion
			pInsertLocPile = pApp->m_pActivePile;
			nSequNum = pApp->m_maxIndex;
		}
		else
		{
			// we are not out of the woods yet; the selection end, or the active location if no
			//selection, may be at the very end of the bundle, so a call to GetNextPile() would
			// return null in that case, and we would crash - so we must check for an advance, do
			// it if needed, and then get the next pile etc.
			CPile* pPile = GetNextPile(pInsertLocPile);
			if (pPile == 0)
			{
				pInsertLocPile = AdvanceBundle(nSequNum); // calls RecalcLayout(), so need to
														// reset active pile ptr
			}
			else
			{
				pInsertLocPile = pPile;
			}
			pApp->m_pActivePile = pInsertLocPile; // ensure it is up to date
			nSequNum++;
		}

		InsertNullSourcePhrase(pDoc,pApp,pInsertLocPile,nCount,TRUE,FALSE,FALSE); // here, never
																				  // for Retransln

		// if we inserted a dummy, now get rid of it and clear the global flag
		if (gbDummyAddedTemporarily)
		{
			gbDummyAddedTemporarily = FALSE;

			// now remove the dummy element, and make sure memory is not leaked!
			delete pDummySrcPhrase->m_pSavedWords;
			delete pDummySrcPhrase->m_pMedialMarkers;
			delete pDummySrcPhrase->m_pMedialPuncts;
			bool deleteOK;
			deleteOK = pSrcPhrases->DeleteNode(pSrcPhrases->GetLast());
			wxASSERT(deleteOK);
			delete pDummySrcPhrase;

			// get another valid layout
			pApp->m_maxIndex = pApp->m_endIndex -= 1; // we've no longer got the dummy present,
										  // so decrement the indices
			RecalcLayout(pSrcPhrases,0,pApp->m_pBundle);
			pApp->m_pActivePile = GetPile(pApp->m_maxIndex); // temporarily at the end, caller will fix
			nSequNum = pApp->m_maxIndex;
		}

		// jump to it (can't use old pile pointers, the recalcLayout call will have clobbered them)
		CPile* pPile = GetPile(nSequNum);
		Jump(pApp,pPile->m_pSrcPhrase);
	}
	else
	{
		// we want the default "insert before" case

		// first save old sequ num for active location
		gnOldSequNum = pApp->m_nActiveSequNum;

		// find the pile preceding which to do the insertion - it will either be preceding the
		// first selected pile, if there is a selection current, or preceding the active location
		// if no selection is current
		CPile* pInsertLocPile;
		nCount = 1; // the button or shortcut can only insert one
		nSequNum = -1;
		if (pApp->m_selectionLine != -1)
		{
			// we have a selection, the pile we want is that of the selection list's first element
			CCellList* pCellList = &pApp->m_selection;
			CCellList::Node* cpos = pCellList->GetFirst();
			pInsertLocPile = cpos->GetData()->m_pPile;
			if (pInsertLocPile == NULL)
			{
				wxMessageBox(_T(
					"Sorry, a zero pointer was returned, the insertion cannot be done."),
					_T(""), wxICON_EXCLAMATION);
				return;
			}
			nSequNum = pInsertLocPile->m_pSrcPhrase->m_nSequNumber;
			wxASSERT(pInsertLocPile != NULL);
			RemoveSelection(); // Invalidate will be called in InsertNullSourcePhrase()
		}
		else
		{
			// no selection, so just insert preceding wherever the phraseBox currently is located
			pInsertLocPile = pApp->m_pActivePile;
			if (pInsertLocPile == NULL)
			{
				wxMessageBox(_T(
					"Sorry, a zero pointer was returned, the insertion cannot be done."),
					_T(""), wxICON_EXCLAMATION);
				return;
			}
			nSequNum = pInsertLocPile->m_pSrcPhrase->m_nSequNumber;
		}
		wxASSERT(nSequNum >= 0);


		// check we are not in a retranslation - we can't insert there! (only need to check
		// previous one, if it is still a retranslation, we must abort the operation)
		if(pInsertLocPile->m_pSrcPhrase->m_bRetranslation)
		{
			CPile* pPile = GetPrevPile(pInsertLocPile);
			if (pPile != NULL)
			{
				if (!pPile->m_pSrcPhrase->m_bRetranslation)
					goto a;
			}
			// IDS_NO_INSERT_IN_RETRANS
			wxMessageBox(_("Sorry, you cannot insert a placeholder within a retranslation. The command has been ignored."),_T(""), wxICON_EXCLAMATION);
			RemoveSelection();
			Invalidate();
			return;
		}

		// ensure the contents of the phrase box are saved to the KB
		// & make the punctuated target string
	a:	if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
			MakeLineFourString(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);

			// we are about to leave the current phrase box location, so we must try to store
			// what is now in the box, if the relevant flags allow it
			RemovePunctuation(pDoc,&pApp->m_targetPhrase,1 /*from tgt*/);
			gbInhibitLine4StrCall = TRUE;
			bool bOK;
			bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
			gbInhibitLine4StrCall = FALSE;
		}

		InsertNullSourcePhrase(pDoc,pApp,pInsertLocPile,nCount);

		// BEW added 10Sep08 in support of Vertical Edit mode
		if (gbVerticalEditInProgress)
		{
			// update the relevant parts of the gEditRecord (all spans are affected equally, except
			// the source text edit section is unchanged)
			gEditRecord.nAdaptationStep_ExtrasFromUserEdits += 1;
			gEditRecord.nAdaptationStep_NewSpanCount += 1;
			gEditRecord.nAdaptationStep_EndingSequNum += 1;
		}

		// jump to it (can't use old pile pointers, the recalcLayout call will have clobbered them)
		CPile* pPile = GetPile(nSequNum);
		Jump(pApp,pPile->m_pSrcPhrase);
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Insert A Placeholder" toolbar item 
/// and returns immediately: The application is in glossing mode, the target text only is showing in
/// the main window, the m_pActivePile pointer is NULL, or the application is in Free Translation mode. 
/// It enables the toolbar button if there is a valid selection or the targetBox is showing, and the targetBox
/// is the window in focus.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonNullSrc(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	bool bCanInsert = FALSE;
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_selectionLine != -1 || (pApp->m_pTargetBox->IsShown()
			&& (pApp->m_pTargetBox == wxWindow::FindFocus())))
		bCanInsert = TRUE;
	}
	event.Enable(bCanInsert);
}

CSourcePhrase* CAdapt_ItView::GetPrevSrcPhrase(SPList::Node*& curPos,SPList::Node*& posPrev)
// returns previous source phrase's pointer, or null if there is no previous one
{
	wxASSERT(curPos != NULL);
	SPList::Node* pos = curPos; 
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData(); 
	pos = pos->GetPrevious();
	if (pos != NULL)
	{
		posPrev = pos; // this is the previous position
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetPrevious();
		wxASSERT(pSrcPhrase);
		return pSrcPhrase;
	}
	else
	{
		posPrev = (SPList::Node*)NULL;
		return (CSourcePhrase*)0;
	}
}

CSourcePhrase* CAdapt_ItView::ReDoInsertNullSrcPhrase(SPList* pList,SPList::Node*& insertPos,bool bForRetranslation)
// returns a pointer to the inserted single null source phrase which was inserted
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(insertPos != NULL);
	wxASSERT(pList);

	CSourcePhrase* pSrcPhr = (CSourcePhrase*)insertPos->GetData();
	wxASSERT(pSrcPhr);
	int nCurSequNum = pSrcPhr->m_nSequNumber; // this will be used for the UpdateSequNumbers() call

	// create a new null source phrase
	CSourcePhrase* pSrcPhrase = new CSourcePhrase; // this should never fail, it's a small object
	wxASSERT(pSrcPhrase != NULL);
	pSrcPhrase->m_bNullSourcePhrase = TRUE;
	pSrcPhrase->m_srcPhrase = _T("...");
	pSrcPhrase->m_key = _T("...");
	pSrcPhrase->m_nSequNumber = nCurSequNum; // ensures the UpdateSequNumbers() call works

	if (bForRetranslation)
	{
		// if we are calling the function as part of re-rendering a retranslation, then we will
		// want to set the appropriate flags for this situation
		pSrcPhrase->m_bRetranslation = TRUE;
		pSrcPhrase->m_bNotInKB = TRUE;
	}

	// now insert it in the list, and update the end index (the latter is probably not needed here)
	// Note: wxList::Insert places the item before the given item and the inserted item then
	// has the insertPos node position.
	pList->Insert(insertPos,pSrcPhrase); 
	pApp->m_maxIndex += 1;

	// update the sequence numbers starting from the newly inserted null source phrase
	UpdateSequNumbers(nCurSequNum);

	// do any copying to m_inform, and other source phrase members in the caller, so just return
	// a pointer to the new null source phrase
	return pSrcPhrase;
}

// BEW additions 22Jul05 for support of free translations when placeholder insertions are done
void CAdapt_ItView::InsertNullSourcePhrase(CAdapt_ItDoc* pDoc,CAdapt_ItApp* pApp,
										   CPile* pInsertLocPile,const int nCount,
										   bool bRestoreTargetBox,bool bForRetranslation,
										   bool bInsertBefore)
{
	bool bAssociatingRightwards = FALSE;
	CSourcePhrase* pSrcPhrase = NULL; // whm initialized to NULL
	CSourcePhrase* pPrevSrcPhrase = NULL; // whm initialized to NULL
	CPile* pPrevPile;
	CPile* pPile		= pInsertLocPile;
	int nStartingSequNum	= pPile->m_pSrcPhrase->m_nSequNumber;
	// whm 2Aug06 added following test to prevent insertion of placeholder in front of \id marker
	if (pPile->m_pSrcPhrase->m_markers.Find(_T("\\id")) != -1)
	{
		// user is attempting to insert placeholder before a \id marker which should not be allowed
		// rather than a message, we'll just beep and return
		::wxBell(); //MessageBeep(0);
		return;
	}
	SPList* pList		= pApp->m_pSourcePhrases;
	SPList::Node* insertPos	= pList->Item(nStartingSequNum); // the position before
															 // which we will make the insertion
	CSourcePhrase* pOldLastSrcPhrase; // the sourcephrase which lies before the first inserted ellipsis,
									  // we have to check this one for a m_bEndFreeTrans == TRUE flag
									  // and move that BOOL value to the end of the insertions
	bool bMoveEndOfFreeTrans = FALSE; // moved outside of if block below
	if (nStartingSequNum > 0) // whm added to prevent assert and unneeded test for m_bEndFreeTrans when sequ num is zero
	{
		SPList::Node* earlierPos = pList->Item(nStartingSequNum - 1);
		pOldLastSrcPhrase = (CSourcePhrase*)earlierPos->GetData();
		if (pOldLastSrcPhrase->m_bEndFreeTrans)
		{
			pOldLastSrcPhrase->m_bEndFreeTrans = FALSE;
			bMoveEndOfFreeTrans = TRUE;
		}
	}

	// get the sequ num for the insertion location (it could be quite diff from active sequ num)
	CSourcePhrase* pSrcPhraseInsLoc = pInsertLocPile->m_pSrcPhrase;
	int	nSequNumInsLoc = pSrcPhraseInsLoc->m_nSequNumber;
	wxASSERT(nSequNumInsLoc >= 0 && nSequNumInsLoc <= pApp->m_maxIndex); // check its in legal range

	wxASSERT(insertPos != NULL);
	int nActiveSequNum = pApp->m_nActiveSequNum; // save, so we can restore later on, since the
												 // call to RecalcLayout will clobber all the pointers

	// we may be inserting in the context of a footnote, either within it, or next to it - so we
	// will need to do some checks to determine whether or not we will have to set the TextType
	// as 'footnote'. A sufficient condition for being 'within' a footnote is m_bFootnote = FALSE
	// but m_curTextType == footnote; the insertion before the start of a footnote, or after the
	// end of a footnote, will be dealt with further down in the current function.
	if (!bForRetranslation)
	{
		// retranslation case is taken care of by handlers OnButtonRetranslation and
		// OnButtonEditRetranslation, so only the normal null srcphrase insertion needs to be
		// considered here
		if (pSrcPhraseInsLoc->m_curTextType == footnote && pSrcPhraseInsLoc->m_bFootnote == FALSE)
			gbInsertingWithinFootnote = TRUE;
	}

	// create the needed null source phrases and insert them in the list; preserve pointers to the
	// first and last for use below
	CSourcePhrase* pFirstOne = NULL; // whm initialized to NULL
	CSourcePhrase* pLastOne = NULL; // whm initialized to NULL
	for (int i = 0; i<nCount; i++)
	{
		CSourcePhrase* pSrcPhrasePH = new CSourcePhrase; // PH means 'PlaceHolder'
		if (i == 0)
		{
			pFirstOne = pSrcPhrasePH;
			pSrcPhrase = pSrcPhrasePH;
		}
		if (i == nCount-1)
			pLastOne = pSrcPhrasePH;
		pSrcPhrasePH->m_bNullSourcePhrase = TRUE;
		pSrcPhrasePH->m_srcPhrase = _T("...");
		pSrcPhrasePH->m_key = _T("...");
		pSrcPhrasePH->m_nSequNumber = nStartingSequNum + i; // ensures the UpdateSequNumbers() call
														  // works
		if (bForRetranslation)
		{
			// if we are calling the function as part of rendering a retranslation, then we will
			// want to set the appropriate flags for each of the null source phrases
			pSrcPhrasePH->m_bRetranslation = TRUE;
			pSrcPhrasePH->m_bNotInKB = TRUE;

			// BEW added 22Jul05 for support of free translations. We assume placeholders within
			// a free translation section in a retranslation belong to the free translation section -
			// provided that section exists at the last sourcephrase instance before the first placeholder,
			// and if the last sourcephrase before the first placeholder was the end of the free
			// translation section, then we move the end of the section to the last placeholder as well
			if (pSrcPhraseInsLoc->m_bHasFreeTrans)
				pSrcPhrasePH->m_bHasFreeTrans = TRUE; // handles the 'within' case
			if ((i == nCount - 1) && bMoveEndOfFreeTrans)
			{
				// move the end of the free translation to this last one (flag on old location is
				// already cleared above in anticipation of this)
				wxASSERT(pLastOne);
				pLastOne->m_bEndFreeTrans = TRUE;
			}
		}

		// set the footnote TextType if the flag is TRUE; the flag can be set TRUE within the
		// handlers for retranslation, edit of a retranslation, edit of source text, and in
		// the InsertNullSourcePhrase function itself. We have to get the type right, because
		// the user might output interlinear RTF with footnote suppression wanted, so we have
		// to ensure that these null source phrases have the footnote TextType set so that the
		// suppression will work properly
		if (gbInsertingWithinFootnote)
		{
			pSrcPhrasePH->m_curTextType = footnote;
			if (!pSrcPhrasePH->m_bRetranslation)
				pSrcPhrasePH->m_bSpecialText = TRUE; // want it to have special text colour
		}

		pList->Insert(insertPos,pSrcPhrasePH);
	}

	// fix up the bundle's indices, and the sequ num for the old insert location's source phrase
	gpApp->m_maxIndex += nCount;
	gpApp->m_endIndex += nCount;
	gpApp->m_upperIndex += nCount;
	nSequNumInsLoc += nCount;

	// calculate the new active sequ number - it could be anywhere, but all we need to know is
	// whether or not the insertion was done preceding the former active sequ number's location
	if (nStartingSequNum <= nActiveSequNum)
		gpApp->m_nActiveSequNum = nActiveSequNum + nCount;

	// update the sequence numbers, starting from the first one inserted
	UpdateSequNumbers(nStartingSequNum);

	// we must check if there is preceding
	// punctuation on the following source phrase, or a marker; or following punctuation on the
	// preceding source phrase. If one of these conditions (or several conditions) obtain, then
	// we must ask the user whether the null source phrase associates with the end of the previous
	// one, or with the following one; and do the appropriate transfer of punctuation and or marker
	// to the first null src phrase (if association is to the right), or the last null source
	// phrase (if the association is to the left) - but all of this only provided we are not doing
	// rendering of a retranslation.  If inserting before the first pile, we don't have to worry
	// about any preceding context.
	bool bAssociationRequired = FALSE; // it will be set true if the message box for associating to
									   // the left or right is required at punctuation
	bool bPreviousFollPunct = FALSE;
	bool bFollowingPrecPunct = FALSE;
	bool bFollowingMarkers = FALSE;
	int nPrevSequNum = nStartingSequNum - 1; // remember, this could be -ve
	if (!bForRetranslation)
	{
		if (nPrevSequNum != -1)
		{
			pPrevPile = GetPrevPile(pInsertLocPile); // old pointers are still valid
			wxASSERT(pPrevPile != NULL);
			pPrevSrcPhrase = pPrevPile->m_pSrcPhrase;
			if (!pPrevSrcPhrase->m_follPunct.IsEmpty())
				bPreviousFollPunct = TRUE;
		}
		else
		{
			// make sure these pointers are null if we are inserting at the doc beginning
			pPrevPile = NULL;
			pPrevSrcPhrase = NULL;
		}
		// now check the following source phrase for any preceding punct or a marker
		if (!pSrcPhraseInsLoc->m_precPunct.IsEmpty())
			bFollowingPrecPunct = TRUE;
		if (!pSrcPhraseInsLoc->m_markers.IsEmpty())
		{
			// BEW added 23Jul05, so that a marker which has TextType none does not
			// trigger the message box, and if the insertion is before its endmarker
			// then the endmarker gets moved to the placeholder (making the insertion
			// be 'outside' the text delimited by the marker & endmarker pair)
			wxString markersStr = pSrcPhraseInsLoc->m_markers;
			int curPos = markersStr.Find(filterMkr);
			if (curPos >= 0)
			{
				// it's a \~FILTER marker, so not one of the TextType == none ones
				bFollowingMarkers = TRUE;
			}
			else
			{
				// check out what it actually is
				curPos = markersStr.Find(gSFescapechar);
				if (curPos == -1)
				{
					// no marker present, so don't set the flag
					;
				}
				else
				{
					// wx version note: Since we require a read-only buffer we use GetData which just returns
					// a const wxChar* to the data in the string.
					const wxChar* pBuff = markersStr.GetData(); 
					wxChar* pBufStart = (wxChar*)pBuff;
					wxChar* pEnd;
					pEnd = pBufStart + markersStr.Length(); // whm added
					wxASSERT(*pEnd == _T('\0')); // whm added
					wxChar* ptr = pBufStart + curPos;
					wxASSERT(*ptr == gSFescapechar);
					wxString bareMkr = pDoc->GetBareMarkerForLookup(ptr);
					wxString wholeMkrLessBackslash = pDoc->GetMarkerWithoutBackslash(ptr);
					USFMAnalysis* pAnalysis = pDoc->LookupSFM(ptr);
					if (pAnalysis == NULL)
					{
						// its an unknown marker, so one which should trigger the message box
						bFollowingMarkers = TRUE;
					}
					else
					{
						// it's a known marker
						wxString endMkr = pAnalysis->endMarker; // could return an empty string
						if (pAnalysis->textType == none)
						{
							// it's a marker which we don't want to trigger the message box,
							// check out if its the endmarker? if so, we'll assume the marker is
							// the only marker in m_markers, and move the latter to the placeholder
							if (wholeMkrLessBackslash == endMkr)
							{
								// it's an endmarker - so do the m_markers move
								pSrcPhrase->m_markers = pSrcPhraseInsLoc->m_markers;
								pSrcPhraseInsLoc->m_markers.Empty();
							}
							bFollowingMarkers = FALSE;
						}
						else
						{
							// it needs to trigger the message box
							bFollowingMarkers = TRUE;
						}
					}
				}
			}
		}

		// if one of the flags is true, ask the user for the direction of association
		if (bFollowingMarkers || bFollowingPrecPunct || bPreviousFollPunct)
		{
			// association leftwards or rightwards will be required, so set the flag
			// for this
			bAssociationRequired = TRUE;
			
			// bleed off the case when we are inserting before a temporary dummy srcphrase,
			// since in this situation association always can only be leftwards
			if (!bInsertBefore && gbDummyAddedTemporarily)
				goto a;

			// any other situation, we need to let the user make the choice
			// IDS_PUNCT_OR_MARKERS
			if (wxMessageBox(_("Adapt It does not know whether the inserted placeholder is the end of the preceding text, or the beginning of what follows. Is it the start of what follows?"),_T(""),wxYES_NO) == wxYES)
			{
				bAssociatingRightwards = TRUE;

				// the association is to the text which follows, so transfer from there
				// to the first in the list - but not if the first sourcephrase of a
				// retranslation follows, if it does, then silently ignore user's choice
				if (bFollowingMarkers)
				{
					if (pSrcPhraseInsLoc->m_bBeginRetranslation)
						// can't right associate into a retranslation, so skip the block
						goto m;
					wxASSERT(pFirstOne != NULL); // whm added
					pFirstOne->m_markers = pSrcPhraseInsLoc->m_markers; // transfer markers
					pSrcPhraseInsLoc->m_markers.Empty();

					// right association to the beginning of a footnote makes the insertion
					// also part of the footnote, so deal with this possibility
					if (pSrcPhraseInsLoc->m_curTextType == footnote && pSrcPhraseInsLoc->m_bFootnote)
					{
						pFirstOne->m_curTextType = footnote;
						// note m_bFootnote flag is handled in next block rather than here
					}


					// have to also copy various members, such as m_inform, so navigation text
					// works right; but we don't want to copy everything - for instance, we don't
					// want to incorporate it into a retranslation; so just get the essentials
					pFirstOne->m_inform = pSrcPhraseInsLoc->m_inform;
					pFirstOne->m_chapterVerse = pSrcPhraseInsLoc->m_chapterVerse;
					pFirstOne->m_bVerse = pSrcPhraseInsLoc->m_bVerse;
					pFirstOne->m_bParagraph = pSrcPhraseInsLoc->m_bParagraph;
					pFirstOne->m_bChapter = pSrcPhraseInsLoc->m_bChapter;
					pFirstOne->m_bSpecialText = pSrcPhraseInsLoc->m_bSpecialText;
					pFirstOne->m_bFootnote = pSrcPhraseInsLoc->m_bFootnote;
					pFirstOne->m_bFirstOfType = pSrcPhraseInsLoc->m_bFirstOfType;
					pFirstOne->m_curTextType = pSrcPhraseInsLoc->m_curTextType;

					// copying the m_markers member means we must transfer the flag values for
					// the 3 booleans which could be there due to a note and/or free translation
					pFirstOne->m_bHasNote = pSrcPhraseInsLoc->m_bHasNote;
					pFirstOne->m_bHasFreeTrans = pSrcPhraseInsLoc->m_bHasFreeTrans;
					pFirstOne->m_bStartFreeTrans = pSrcPhraseInsLoc->m_bStartFreeTrans;
					// if we inserted before the end of a free translation, the m_bEndFreeTrans
					// boolean does not move
					pSrcPhraseInsLoc->m_bHasNote = FALSE;
					//pSrcPhraseInsLoc->m_bHasFreeTrans = FALSE; // BEW commented out 16Oct06, because pSrcPhraseInsLoc
																 // remains within the same free translation!
					pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;

					// clear the others which were moved
					pSrcPhraseInsLoc->m_inform.Empty();
					pSrcPhraseInsLoc->m_chapterVerse.Empty();
					pSrcPhraseInsLoc->m_bFirstOfType = FALSE;
					pSrcPhraseInsLoc->m_bVerse = FALSE;
					pSrcPhraseInsLoc->m_bParagraph = FALSE;
					pSrcPhraseInsLoc->m_bChapter = FALSE;
					pSrcPhraseInsLoc->m_bFootnote = FALSE;
					pSrcPhraseInsLoc->m_bFootnote = FALSE;
				}
				if (bFollowingPrecPunct)
				{
					pFirstOne->m_precPunct = pSrcPhraseInsLoc->m_precPunct; // transfer preceding
																			// punct
					pSrcPhraseInsLoc->m_precPunct.Empty();

					// do an adjustment of the m_targetStr member, simplest solution is to make it
					// same as the m_adaption member
					pSrcPhraseInsLoc->m_targetStr = pSrcPhraseInsLoc->m_adaption;
					pFirstOne->m_bFirstOfType = pSrcPhraseInsLoc->m_bFirstOfType;
				}
			}
			else
			{
				// the association is to the text which precedes, so transfer from there
				// to the last in the list
a:				bAssociatingRightwards = FALSE;

				if (bPreviousFollPunct)
				{
					pLastOne->m_follPunct = pPrevSrcPhrase->m_follPunct; // transfer following
																		 // punct
					pPrevSrcPhrase->m_follPunct.Empty();

					// left association when the text to the left is a footnote makes the
					// inserted text part of the footnote; so get the TextType set correctly
					if (pPrevSrcPhrase->m_curTextType == footnote)
					{
						pLastOne->m_bSpecialText = TRUE; // want it to have special text colour
						pLastOne->m_curTextType = footnote;
						// note: m_bFootnoteEnd is deal with below
					}

					// do an adjustment of the m_targetStr member, simplest solution is to make
					// it same as the m_adaption member; then transfer the other member's values
					// which are pertinent to the leftwards association
					pPrevSrcPhrase->m_targetStr = pPrevSrcPhrase->m_adaption;
					pLastOne->m_bFootnoteEnd = pPrevSrcPhrase->m_bFootnoteEnd;
					pPrevSrcPhrase->m_bFootnoteEnd = FALSE;
					pLastOne->m_bBoundary = pPrevSrcPhrase->m_bBoundary;
					pPrevSrcPhrase->m_bBoundary = FALSE;
				}
			}
		}
	}
	else
	{
		// we are inserting to pad out a retranslation, so if the last of the selected source
		// phrases has following punctuation, we need to move it to the last null source phrase
		// inserted (note, the case of moving free-translation-supporting BOOL values is done above)
		CSourcePhrase* pPrevSrcPhrase2 = NULL;	// whm initialized to NULL
		if (nPrevSequNum != -1)
		{
			CPile* pPrevPile = GetPrevPile(pInsertLocPile); // old pointers are still valid
			wxASSERT(pPrevPile != NULL);
			pPrevSrcPhrase2 = pPrevPile->m_pSrcPhrase;
			if (!pPrevSrcPhrase2->m_follPunct.IsEmpty())
				bPreviousFollPunct = TRUE;
		}

		if (bPreviousFollPunct)
		{
			// the association is to the text which precedes, so transfer from there
			// to the last in the list
			wxASSERT(pPrevSrcPhrase2 != NULL); // whm added
			pLastOne->m_follPunct = pPrevSrcPhrase2->m_follPunct; // transfer following punct
			pPrevSrcPhrase2->m_follPunct.Empty();
		}
	}

	// handle any adjustments required because the insertion was done where there is one or more
	// free translation sections defined in the viscinity of the inserted sourcephrase.
	if (!bForRetranslation)
	{
		// we've done the retranslation placeholder additions case in a block previously, so here
		// we are interested in the single placeholder inserted not in any retranslation
		if (pPrevSrcPhrase == NULL)
		{
			// the insertion was at the start of the document, so we must assume a rightwards association
			// for the inserted sourcephrase
			if (pSrcPhraseInsLoc->m_bStartFreeTrans)
			{
				pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
				pSrcPhrase->m_bStartFreeTrans = TRUE;
				pSrcPhrase->m_bHasFreeTrans = TRUE;
				// we assume punctuation has already been handled above, if necessary
			}
		}
		else
		{
			// the insertion was done not at the doc beginning, and it may have been done before a
			// temporary sourcephrase added to the doc end until the insertion has been completed, but
			// typically it is some general location in the doc - and what we do will typically depend
			// on whether there was associating left or right, or no associating at all (which means the
			// insertion was done where punctuation was absent immediately before or after) -- but these
			// potential locations are independent (not completely, but enough to complicate matters) of
			// where free translation sections begin and end, so there are a couple of dozen possibilities
			// to be considered for the three consecutive sourcephrase pointers pPrevSrcPhrase, pSrcPhrase,
			// and pSrcPhraseInsLoc - pSrcPhrase being the placeholder which was just inserted.
			if (pPrevSrcPhrase->m_bHasFreeTrans)
			{
				// the previous sourcephrase has a free translation section defined on it
				if (pPrevSrcPhrase->m_bStartFreeTrans)
				{
					// the previous sourcephrase is where a section of free translation starts
					if (pPrevSrcPhrase->m_bEndFreeTrans)
					{
						// the previous sourcephrase is both the start and end of a free translation
						// section (ie. a rare short section with one sourcephrase in it)
						if (pSrcPhraseInsLoc->m_bHasFreeTrans)
						{
							// the sourcephrase following the placeholder also has a different free translation
							// section defined on it - what happens depends on whether there was a left or right
							// association, or none
							if (pSrcPhraseInsLoc->m_bStartFreeTrans)
							{
								// its the start of a new section - which we know must be the case anyway
								if (bAssociationRequired && bAssociatingRightwards)
								{
									// we have to make the placeholder the new start of the section on the right
									// m_markers should have been moved already, so just do the flags
									pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
									pSrcPhrase->m_bStartFreeTrans = TRUE;
									pSrcPhrase->m_bHasFreeTrans = TRUE;
								}
								else if (bAssociationRequired && !bAssociatingRightwards)
								{
									// we have to make the placeholder the end of the section on the left
									pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
									pSrcPhrase->m_bEndFreeTrans = TRUE;
									pSrcPhrase->m_bHasFreeTrans = TRUE;
								}
								else if (!bAssociationRequired)
								{
									// no punctuation in the context, so the user was not asked for an
									// association choice - so we must do so now
									// IDS_ASSOC_WITH_FREE_TRANS
									if (wxMessageBox(_("Do you want the inserted placeholder to be considered as belonging to the free translation section which begins immediately following it?"),_T(""), wxYES_NO) == wxYES)
									{
										// user wants to associate it to the right - make the placeholder the
										// new start location, and move m_markers to it since it won't have
										// been done previously
										pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
										pSrcPhrase->m_bStartFreeTrans = TRUE;
										pSrcPhrase->m_bHasFreeTrans = TRUE;
										pSrcPhrase->m_markers = pSrcPhraseInsLoc->m_markers;
										pSrcPhraseInsLoc->m_markers.Empty();
									}
									else
									{
										// user wants to associate it to the left
										pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
										pSrcPhrase->m_bEndFreeTrans = TRUE;
										pSrcPhrase->m_bHasFreeTrans = TRUE;
									}
								}
							}
							else
							{
								// impossible situation (pPrevSrcPhrase is the end of an earlier free translation
								// section, so pSrcPhraseInsLoc must be the starting one of a new section if
								// it is in a free translation section - so do nothing
								;
							}
						}
					}
					else
					{
						// the previous sourcephrase starts a free translation section, and because it is
						// not also the end of the section, the section must extend past the inserted
						// placeholder - so the placeholder is within the section, so we only need set
						// one flag
						pSrcPhrase->m_bHasFreeTrans = TRUE;
					}
				}
				else if (pPrevSrcPhrase->m_bEndFreeTrans)
				{
					// the previous sourcephrase does not start a free translation section,
					// but it is the end of a section
					if (pSrcPhraseInsLoc->m_bHasFreeTrans)
					{
						// the sourcephrase following the inserted placeholder is involved in a
						// free translation section - it has to be the start of a new section, or the
						// only one in a new section
						if (pSrcPhraseInsLoc->m_bStartFreeTrans)
						{
							// the sourcephrase following the inserted placeholder is the start of
							// a new free translation section - what we do now depends on whether or
							// not there was an association to left or right due to punctuation, or
							// no association was done
							if (bAssociationRequired && bAssociatingRightwards)
							{
								// associate to the right, so move the right section's start to the
								// inserted placeholder, m_markers should already have been moved
								pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
								pSrcPhrase->m_bStartFreeTrans = TRUE;
								pSrcPhrase->m_bHasFreeTrans = TRUE;
							}
							else if (bAssociationRequired && !bAssociatingRightwards)
							{
								// associate to the left, so move the end of the previous section to
								// the inserted placeholder
								pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
								pSrcPhrase->m_bEndFreeTrans = TRUE;
								pSrcPhrase->m_bHasFreeTrans = TRUE;
							}
							else if (!bAssociationRequired)
							{
								// no association is defined, so we must ask the user for what to do
								//IDS_ASSOC_WITH_FREE_TRANS
								if (wxMessageBox(_("Do you want the inserted placeholder to be considered as belonging to the free translation section which begins immediately following it?"),_T(""),wxYES_NO) == wxYES)
								{
									// associate rightwards, which means we'll need to move m_markers too
									pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
									pSrcPhrase->m_bStartFreeTrans = TRUE;
									pSrcPhrase->m_bHasFreeTrans = TRUE;
									pSrcPhrase->m_markers = pSrcPhraseInsLoc->m_markers;
									pSrcPhraseInsLoc->m_markers.Empty();
								}
								else
								{
									// associate leftwards
									pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
									pSrcPhrase->m_bEndFreeTrans = TRUE;
									pSrcPhrase->m_bHasFreeTrans = TRUE;
								}
							}
						}
						else
						{
							// impossible situation
							; // do nothing
						}
					}
					else
					{
						// the sourcephrase following the inserted placeholder has no free translation
						// defined on it - so we need consider only leftwards associations or no association
						if (bAssociationRequired && !bAssociatingRightwards)
						{
							// leftwards association was already requested, so make the placeholder the
							// new end of the previous section of free translation
							pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
							pSrcPhrase->m_bEndFreeTrans = TRUE;
							pSrcPhrase->m_bHasFreeTrans = TRUE;
						}
						else if (bAssociationRequired && bAssociatingRightwards)
						{
							// nothing to be done, there is no free translation to the immediate right
							;
						}
						else if (!bAssociationRequired)
						{
							// no association known as yet, so ask the user
							// IDS_ASSOC_LEFT_FREE_TRANS
							if (wxMessageBox(_("Do you want the inserted placeholder to be considered as belonging to the free translation section which immediately precedes it?"),_T(""),wxYES_NO) == wxYES)
							{
								// user wants the inserted placeholder to be associated with the free translation
								// lying to the left - so make the placeholder be the new end of the section
								pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
								pSrcPhrase->m_bEndFreeTrans = TRUE;
								pSrcPhrase->m_bHasFreeTrans = TRUE;
							}
							else
							{
								// there is no association, and since no free translation lies to the
								// immediate right of the placeholder, we don't have to do anything
								;
							}
						}
					}
				}
				else
				{
					// the previous sourcephrase neither starts nor ends a free translation section,
					// so it is within a free translation section - we just need to set the one flag
					pSrcPhrase->m_bHasFreeTrans = TRUE;
				}
			}
			else
			{
				// pPrevSrcPhrase has no free translation defined on it
				if (pSrcPhraseInsLoc->m_bHasFreeTrans)
				{
					// the only possibilities are that pSrcPhraseInsLoc is the first or only free
					// translation in a section lying to the right of the placeholder. What we do will
					// depend on the associativity, which may be leftwards, rightwards, or none. (A
					// placeholder inserted before a temporary sourcephrase at the document end always
					// associates leftwards. bAssociatingRightwards == FALSE handles that case automatically.)
					if (pSrcPhraseInsLoc->m_bStartFreeTrans)
					{
						// its the start of a free translation section
						if (bAssociationRequired && !bAssociatingRightwards)
						{
							// leftwards association - so nothing is to be done
							;
						}
						else if (bAssociationRequired && bAssociatingRightwards)
						{
							// rightwards association - we must move the start to the placeholder
							pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
							pSrcPhrase->m_bStartFreeTrans = TRUE;
							pSrcPhrase->m_bHasFreeTrans = TRUE;
							// punctuation should have been handled already, and also m_markers
						}
						else if (!bAssociationRequired)
						{
							// no association in either direction (ie. insertion not at punctuation) so
							// we have no user action to guide us - so we must ask the user for guidance
							// IDS_ASSOC_WITH_FREE_TRANS
							if (wxMessageBox(_("Do you want the inserted placeholder to be considered as belonging to the free translation section which begins immediately following it?"),_T(""),wxYES_NO) == wxYES)
							{
								// rightwards association - move the start to the placeholder, but in this
								// case no m_markers movement will have been done, so we must move that
								// as well
								pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
								pSrcPhrase->m_bStartFreeTrans = TRUE;
								pSrcPhrase->m_bHasFreeTrans = TRUE;
								pSrcPhrase->m_markers = pSrcPhraseInsLoc->m_markers;
								pSrcPhraseInsLoc->m_markers.Empty();
							}
							else
							{
								// leftwards association, so do nothing
								;
							}
						}
					}
					else
					{
						// impossible situation (a free trans section starting without m_bStartFreeTrans
						// having the value TRUE)
						;
					}

				}
				else
				{
					// pSrcPhraseInsLoc has no free translation defined on it, so nothing needs to be done
					// to the default flag values (all 3 FALSE) for free translation support in pSrcPhrase
					;
				}
			}
		}
	}

	// recalculate the layout starting from the strip the starting pile is in
m:	int nStrip;
	nStrip = pPile->m_pStrip->m_nStripIndex;
	RecalcLayout(pList, 0,pPile->m_pStrip->m_pBundle);

	if (bRestoreTargetBox) // don't restore when this function is called as part of a larger
						   // inclusive procedure
	{
		// get a new (valid) active pile pointer, now that the layout is recalculated
		gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
		wxASSERT(gpApp->m_pActivePile);

		// create the phraseBox at the active pile
		gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;
		RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);

		// restore focus, and selection if any
		gpApp->m_pTargetBox->SetFocus();
		if (gpApp->m_nStartChar != gpApp->m_nEndChar)
		{
			gpApp->m_pTargetBox->SetSelection(gpApp->m_nStartChar,gpApp->m_nEndChar); 
		}
		gnStart = gpApp->m_nStartChar;
		gnEnd = gpApp->m_nEndChar;

		// scroll into view, just in case a lot were inserted
		gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);

		Invalidate();
	}
	gbInsertingWithinFootnote = FALSE; // make sure it is off (default) before exiting
}

void CAdapt_ItView::OnButtonRemoveNullSrcPhrase(wxCommandEvent& WXUNUSED(event))
{
	// Since the Remove Placeholder toolbar button has an accelerator table hot key (CTRL-D see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_REMOVE_NULL_SRCPHRASE))
	{
		::wxBell();
		return;
	}

	// If glossing is ON we don't allow removal (nor insertion) of null source phrases,
	// so warn the user and return.
	if (gbIsGlossing)
	{
		//IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),_T(""),wxICON_INFORMATION);
		return;
	}

	// find the pile containing the null src phrase to be deleted - it will either be the
	// first selected pile, if there is a selection current, or the active location
	// if no selection is current; the button removes only one at a time.
	CPile* pRemoveLocPile;
	int nCount = 1;
	if (gpApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's first element
		CCellList* pCellList = &gpApp->m_selection;
		CCellList::Node* cpos = pCellList->GetFirst();
		CCell* pCell;
		pCell = cpos->GetData();
		pRemoveLocPile = cpos->GetData()->m_pPile;
		wxASSERT(pRemoveLocPile != NULL);
		if (pRemoveLocPile->m_pSrcPhrase->m_bNullSourcePhrase != TRUE)
		{
			::wxBell();
			RemoveSelection();
			return;
		}
		if (pRemoveLocPile->m_pSrcPhrase->m_bRetranslation == TRUE)
		{
			::wxBell(); 
			RemoveSelection();
			return;
		}
		RemoveSelection(); // Invalidate() will be called in RemoveNullSourcePhrase()
	}
	else
	{
		// no selection, so just remove at wherever the phraseBox currently is located
		pRemoveLocPile = gpApp->m_pActivePile;
		wxASSERT(pRemoveLocPile != NULL);
		if (pRemoveLocPile->m_pSrcPhrase->m_bNullSourcePhrase == FALSE ||
			pRemoveLocPile->m_pSrcPhrase->m_bRetranslation == TRUE)
		{
			::wxBell();
			return;
		}
	}

	RemoveNullSourcePhrase(pRemoveLocPile,nCount);

	// we don't do the next block at a deeper level because removing a retranslation which is long 
	// uses lower level functions to do automated placeholder removals, and we don't want them
	// counted a second time; so we do it here only, in the handler for a user's manual click of
	// the command bar button to remove a placeholder
	if (gbVerticalEditInProgress)
	{
		// update the relevant parts of the adaptationsStep parameters in gEditRecord
			gEditRecord.nAdaptationStep_ExtrasFromUserEdits -= 1;
			gEditRecord.nAdaptationStep_NewSpanCount -= 1;
			gEditRecord.nAdaptationStep_EndingSequNum -= 1;
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Remove A Placeholder" toolbar item 
/// and returns immediately: The application is in glossing mode, the target text only is showing in
/// the main window, the m_pActivePile pointer is NULL, or the application is in Free Translation mode. 
/// It enables the toolbar button if there is a selection which is on a null source phrase which is not a 
/// retranslation, or if the active pile is a null source phrase which is not a retranslation. The selection, 
/// if there is one, takes priority, if its pile is different from the active pile..
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRemoveNullSrcPhrase(wxUpdateUIEvent& event)
{
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	bool bCanDelete = FALSE;
	if (gpApp->m_pTargetBox->GetHandle() != NULL)
	{
		// set the flag true either if there is a selection and which is on a null source phrase
		// which is not a retranslation, or if the active pile is a null source phrase which
		// is not a retranslation. The selection, if there is one, takes priority, if its pile is
		// different from the active pile.
		if (gpApp->m_selectionLine != -1)
		{
			CCellList::Node* cpos = gpApp->m_selection.GetFirst();
			CCell* pCell = cpos->GetData();
			if (pCell->m_pPile->m_pSrcPhrase->m_bNullSourcePhrase
				&& !pCell->m_pPile->m_pSrcPhrase->m_bRetranslation)
			{
				bCanDelete = TRUE;
			}
		}
		else
		{
			 wxWindow *focus = wxWindow::FindFocus();
			if (gpApp->m_pTargetBox == focus) // don't use GetHandle() on m_pTargetBox here !!!
			{
				if (gpApp->m_pTargetBox->IsShown()
						&& gpApp->m_pActivePile->m_pSrcPhrase->m_bNullSourcePhrase
						&& !gpApp->m_pActivePile->m_pSrcPhrase->m_bRetranslation)
					bCanDelete = TRUE;
			}
		}
	}
	event.Enable(bCanDelete);
}

void CAdapt_ItView::RemoveNullSourcePhrase(CPile* pRemoveLocPile,const int nCount)
{
	CPile* pPile			= pRemoveLocPile;
	int nStartingSequNum	= pPile->m_pSrcPhrase->m_nSequNumber;
	SPList* pList			= gpApp->m_pSourcePhrases;
	SPList::Node* removePos = pList->Item(nStartingSequNum); // the position at
															 // which we will do the removal
	SPList::Node* savePos = removePos; // we will alter removePos & need to restore it
	wxASSERT(removePos != NULL);
	int nActiveSequNum = gpApp->m_nActiveSequNum; // save, so we can restore later on, since the
										   // call to RecalcLayout will clobber all the pointers

	// get the preceding source phrase, if it exists, whether null or not - we may have to transfer
	// punctuation to it
	CSourcePhrase* pPrevSrcPhrase = NULL;
	if (nStartingSequNum > 0)
	{
		// there is a preceding one, so get it
		CPile* pPile = GetPrevPile(pRemoveLocPile);
		wxASSERT(pPile != NULL);
		pPrevSrcPhrase = pPile->m_pSrcPhrase;
		wxASSERT(pPrevSrcPhrase != NULL);
	}

	// ensure that there are nCount null source phrases which can be removed from this location
	int count = 0;
	CSourcePhrase* pFirstOne = NULL; // whm initialized to NULL
	CSourcePhrase* pLastOne = NULL; // whm initialized to NULL
	while( removePos != 0 && count < nCount)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)removePos->GetData();
		removePos = removePos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		if (count == 0)
			pFirstOne = pSrcPhrase;
		pLastOne = pSrcPhrase;
		count++;
		if (!pSrcPhrase->m_bNullSourcePhrase)
		{
			//IDS_TOO_MANY_NULL_SRCPHRASES
			wxMessageBox(_T("Error: you are trying to remove more empty source phrases than exist at that location: the command will be ignored."),_T(""),wxICON_EXCLAMATION);
			if (gpApp->m_selectionLine != -1)
				RemoveSelection();
			Invalidate();
			return;
		}
	}

	// a null source phrase can (as of version 1.3.0) be last in the list,
	// so we can no longer assume there will be a non-null one following, if we are at the end we
	// must restore the active location to an earlier sourcephrase, otherwise, to a following one
	bool bNoneFollows = FALSE;
	CSourcePhrase* pSrcPhraseFollowing = 0;
	if (nStartingSequNum + nCount > gpApp->m_maxIndex)
	{
		// we are at the very end, or wanting to remove more at the end than is possible
		bNoneFollows = TRUE; // flag this condition
	}

	if (bNoneFollows)
		pSrcPhraseFollowing = 0;
	else
	{
		pSrcPhraseFollowing = (CSourcePhrase*)removePos->GetData();
		removePos = removePos->GetNext();
		wxASSERT(pSrcPhraseFollowing != NULL);
	}

	wxASSERT(pFirstOne != NULL); // whm added; note: if pFirstOne can ever be NULL there should be more
								 // code added here to deal with it
	// if the null source phrase(s) carry any punctuation or markers, then these have to be
	// first transferred to the appropriate normal source phrase in the context, whether forwards
	// or backwards, depending on what is stored.
	if (!pFirstOne->m_markers.IsEmpty() && !bNoneFollows)
	{
		// BEW comment 25Jul05, if a TextType == none endmarker was initial in m_markers, it will have
		// been moved to the placeholder; so the next line handles other situations as well as moving
		// an endmarker back on to the following sourcephrase which formerly owned it
		pSrcPhraseFollowing->m_markers = pFirstOne->m_markers; // don't bother to clear original

		// now all the other things which depend on markers
		pSrcPhraseFollowing->m_inform = pFirstOne->m_inform;
		pSrcPhraseFollowing->m_chapterVerse = pFirstOne->m_chapterVerse;
		pSrcPhraseFollowing->m_bVerse = pFirstOne->m_bVerse;
		pSrcPhraseFollowing->m_bParagraph = pFirstOne->m_bParagraph;
		pSrcPhraseFollowing->m_bChapter = pFirstOne->m_bChapter;
		pSrcPhraseFollowing->m_bSpecialText = pFirstOne->m_bSpecialText;
		pSrcPhraseFollowing->m_bFootnote = pFirstOne->m_bFootnote;
		pSrcPhraseFollowing->m_bFirstOfType = pFirstOne->m_bFirstOfType;
		pSrcPhraseFollowing->m_curTextType = pFirstOne->m_curTextType;

		// BEW 05Jan06 if there was a moved note we must ensure that the following
		// sourcephrase gets the note flag set (it might already be TRUE anyway)
		pSrcPhraseFollowing->m_bHasNote = pFirstOne->m_bHasNote;
	}
	// block ammended by BEW 25Jul05
	if (!pFirstOne->m_precPunct.IsEmpty() && !bNoneFollows)
	{
		pSrcPhraseFollowing->m_precPunct = pFirstOne->m_precPunct;

		// fix the m_targetStr member (we are just fixing punctuation, so no store needed)
		MakeLineFourString(pSrcPhraseFollowing,pSrcPhraseFollowing->m_targetStr);

		// anything else
		pSrcPhraseFollowing->m_bFirstOfType = pFirstOne->m_bFirstOfType;
	}
	// BEW added 25Jul05
	// a m_bHasFreeTrans = TRUE value can be ignored provided m_bStartFreeTrans value is FALSE,
	// if the latter is TRUE, then we must move the value to the following sourcephrase
	if (pFirstOne->m_bStartFreeTrans && !bNoneFollows)
	{
		pSrcPhraseFollowing->m_bStartFreeTrans = TRUE;
		pSrcPhraseFollowing->m_bHasFreeTrans = TRUE;
	}
	wxASSERT(pLastOne != NULL); // whm added; note: if pLastOne can ever be NULL there should be more
								// code added here to deal with it
	if (!pLastOne->m_follPunct.IsEmpty() && nStartingSequNum > 0)
	{
		pPrevSrcPhrase->m_follPunct = pLastOne->m_follPunct;

		// now the other stuff
		pPrevSrcPhrase->m_bFootnoteEnd = pLastOne->m_bFootnoteEnd;
		pPrevSrcPhrase->m_bBoundary = pLastOne->m_bBoundary;

		// fix the m_targetStr member (we are just fixing punctuation, so no store needed)
		MakeLineFourString(pPrevSrcPhrase,pPrevSrcPhrase->m_targetStr);
	}
	// BEW added 25Jul05...
	// a m_bHasFreeTrans = TRUE value can be ignored provided m_bEndFreeTrans value is FALSE,
	// if the latter is TRUE, then we must move the value to the preceding sourcephrase
	if (pLastOne->m_bEndFreeTrans && nStartingSequNum > 0)
	{
		pPrevSrcPhrase->m_bEndFreeTrans = TRUE;
		pPrevSrcPhrase->m_bHasFreeTrans = TRUE;
	}

	// remove the null source phrases from the list, after removing their translations from the KB
	CRefString* pRefString = NULL;
	removePos = savePos;
	count = 0;
	while (removePos != NULL && count < nCount)
	{
		SPList::Node* pos2 = removePos; // save current position for RemoveAt call
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)removePos->GetData();
		removePos = removePos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key,pSrcPhrase->m_adaption);
		count++;
		if (pRefString != NULL)
			// don't need to worry about m_bHasKBEntry flag, since pSrcPhrase will be deleted next
			RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);
		delete pSrcPhrase;
		pList->DeleteNode(pos2); 
	}

	// fix up the bundle's indices
	gpApp->m_maxIndex -= nCount;
	gpApp->m_endIndex -= nCount;
	gpApp->m_upperIndex -= nCount;

	// calculate the new active sequ number - it could be anywhere, but all we need to know is
	// whether or not the last removal of the sequence was done preceding the former active
	// sequ number's location
	if (nStartingSequNum + nCount < nActiveSequNum)
		gpApp->m_nActiveSequNum = nActiveSequNum - nCount;
	else
	{
		if (bNoneFollows)
			gpApp->m_nActiveSequNum = nStartingSequNum - 1;
		else
			gpApp->m_nActiveSequNum = nStartingSequNum;
	}

	// update the sequence numbers, starting from the location of the first one removed; but if we
	// removed at the end, no update is needed
	if (!bNoneFollows)
		UpdateSequNumbers(nStartingSequNum);

	// in case the active location is going to be a retranslation, check and if so, advance past
	// it; but if at the end, then back up to a valid preceding location
	CSourcePhrase* pSP = GetSrcPhrase(gpApp->m_nActiveSequNum);
	CPile* pNewPile;
	if (pSP->m_bRetranslation)
	{
		CPile* pPile = GetPile(gpApp->m_nActiveSequNum);
		do {
				pNewPile = GetNextPile(pPile);
				if (pNewPile == NULL)
				{
					// move backwards instead, and find a suitable location
					pPile = GetPile(gpApp->m_nActiveSequNum);
					do {
						pNewPile = GetPrevPile(pPile);
						pPile = pNewPile;
					} while (pNewPile->m_pSrcPhrase->m_bRetranslation);
					goto b;
				}
				pPile = pNewPile;
		} while (pNewPile->m_pSrcPhrase->m_bRetranslation);
b:		gpApp->m_pActivePile = pNewPile;
		gpApp->m_nActiveSequNum = pNewPile->m_pSrcPhrase->m_nSequNumber;
	}

	// we need to set m_targetPhrase to what it will be at the new active location, else if
	// the old string was real long, the CalcPileWidth() call will compute enormous and wrong
	// box width at the new location
	pSP = GetSrcPhrase(gpApp->m_nActiveSequNum);
	if (!gpApp->m_bHidePunctuation && gpApp->m_bSuppressLast)
		gpApp->m_targetPhrase = pSP->m_targetStr;
	else
		gpApp->m_targetPhrase = pSP->m_adaption;

	// recalculate the layout starting from the strip the starting pile is in
	int nStrip;
	nStrip = pPile->m_pStrip->m_nStripIndex;
	RecalcLayout(pList, 0,pPile->m_pStrip->m_pBundle);

	// get a new (valid) active pile pointer, now that the layout is recalculated
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	wxASSERT(gpApp->m_pActivePile);

	// create the phraseBox at the active pile, do it using PlacePhraseBox()...
	CSourcePhrase* pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
	wxASSERT(pSrcPhrase != NULL);

	// renumber its sequ number, as its now in a new location because of the deletion (else the
	// PlacePhraseBox call below will get the wrong number when it reads its m_nSequNumber
	// attribute)
	pSrcPhrase->m_nSequNumber = gpApp->m_nActiveSequNum;
	gpApp->m_curIndex = gpApp->m_nActiveSequNum; // make this agree, else the PlacePhraseBox call could use wrong
								   // value (eg. if advanced past a retranslation, m_curIndex would
								   // still have the old value, and box would be wrongly placed

	// set m_targetPhrase to the appropriate string
	if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		if (!gpApp->m_bHidePunctuation && gpApp->m_bSuppressLast)
			gpApp->m_targetPhrase = pSrcPhrase->m_targetStr;
		else
			gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
	}
	else
	{
		gpApp->m_targetPhrase.Empty(); // empty string will have to do
	}

	// we must remove the source phrase's translation from the KB as if we had clicked here
	// (otherwise PlacePhraseBox will assert)
	pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key,pSrcPhrase->m_adaption);

	// it is okay to do the following call with pRefString == NULL, in fact, it must be done
	// whether NULL or not; since if it is NULL, RemoveRefString will clear pSrcPhrase's
	// m_bHasKBEntry to FALSE, which if not done, would result in a crash if the user clicked on
	// a source phrase which had its reference string manually removed from the KB and then
	// clicked on another source phrase. (The StoreAdaption call in the second click would trip
	// the first line's ASSERT.)
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// now place the box
	PlacePhraseBox(gpApp->m_pActivePile->m_pCell[2],2);

	// get a new (valid) active pile pointer, now that the layout is recalculated (again!)
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	wxASSERT(gpApp->m_pActivePile);

	// save old sequ number in case required for toolbar's Back button - but since it probably
	// has been lost (being the null source phrase location), to be safe we must set it to the
	// current active location
	gnOldSequNum = gpApp->m_nActiveSequNum;

	// scroll into view, just in case a lot were inserted
	gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);

	Invalidate();
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Do A Retranslation" toolbar 
/// item and returns immediately: The application is in glossing mode, the target text only is showing 
/// in the main window, the m_pActivePile pointer is NULL, or if there is a selection in which at least
/// one source phrase already is part of a retranslation. 
/// Otherwise, it enables the toolbar button if there is a selection whose source phrases are not part of
/// an existing retranslation.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRetranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
		// if there is at least one srcPhrase with m_bRetranslation == TRUE, then disable
		// the button
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData();
			CPile* pPile = pCell->m_pPile;
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;
			if (pSrcPhrase->m_bRetranslation)
			{
				event.Enable(FALSE);
				return;
			}
		}
		event.Enable(TRUE);
		return;
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::SetNotInKBFlag(SPList* pList,bool bValue)
{
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	while (pos != 0)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		pSrcPhrase->m_bNotInKB = bValue;
	}
}

void CAdapt_ItView::SetRetranslationFlag(SPList* pList,bool bValue)
{
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	while (pos != 0)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		pSrcPhrase->m_bRetranslation = bValue;
	}
}

void CAdapt_ItView::GetContext(const int nStartSequNum,const int nEndSequNum,wxString& strPre,
							   wxString& strFoll,wxString& strPreTgt, wxString& strFollTgt)
// gets the preceding & following contexts for a 'retranslation' section of source text.
// We cannot rely on the layout pointers being valid, because if there was an unmerge done,
// they will have been clobbered prior to GetContext being called rather than use GetPile().
// We accumulate 40 words of preceding context and 30 words of following context, and we
// omit any m_markers content from the accumulations - we are just interested in the text.
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// get the preceding context first
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	SPList::Node* pos = pSrcPhrases->Item(nStartSequNum);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetPrevious();
	TextType textType = pSrcPhrase->m_curTextType;
	wxString str; // temporary buffers
	str.Empty();
	wxString strTgt;
	strTgt.Empty();

	int count = 0;
	while (count < NUM_PREWORDS && pos != NULL)
	{
		TextType type;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetPrevious();
		count++;
		type = pSrcPhrase->m_curTextType;
		if (type != textType)
			break;
		str = pSrcPhrase->m_srcPhrase;
		strTgt = pSrcPhrase->m_targetStr;
		strPre = str + _T(" ") + strPre;
		strPreTgt = strTgt + _T(" ") + strPreTgt;
	}

	// now get the following context
	pos = pSrcPhrases->Item(nEndSequNum);
	pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext();
	count = 0;
	str.Empty();
	strTgt.Empty();

	while (count < NUM_FOLLWORDS && pos != NULL)
	{
		TextType type;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		count++;
		type = pSrcPhrase->m_curTextType;
		if (type != textType)
			break;
		str = pSrcPhrase->m_srcPhrase;
		strTgt = pSrcPhrase->m_targetStr;
		if (strFoll.IsEmpty())
		{
			strFoll = str;
			strFollTgt = strTgt;
		}
		else
		{
			strFoll += _T(" ") + str;
			strFollTgt += _T(" ") + strTgt;
		}
	}
}

bool CAdapt_ItView::IsConstantType(SPList* pList)
{
	SPList::Node* pos = pList->GetFirst(); 
	if (pos == NULL)
	{
		wxMessageBox(_T("Error accessing sublist in IsConstantType function\n"), _T(""), wxICON_EXCLAMATION);
		wxASSERT(FALSE);
		return FALSE;
	}
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext();
	TextType firstType = pSrcPhrase->m_curTextType;
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		TextType type = pSrcPhrase->m_curTextType;
		if (type != firstType)
			return FALSE;
	}

	// if we get here, it's all one type; so if that type is also the footnote textType
	// then set the gbInsertingWithinFootnote flag (we want to propragate a footnote type into
	// any padding with null source phrases, in case the user wants to get interlinear RTF
	// output with footnote text suppressed)
	if (pSrcPhrase->m_curTextType == footnote)
		gbInsertingWithinFootnote = TRUE;
	return TRUE;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Remove A Retranslation" toolbar 
/// item and returns immediately: The application is in glossing mode, the target text only is showing 
/// in the main window, the m_pActivePile pointer is NULL, or if the head or tail of the selection do
/// not lie within the retranslation.
/// Otherwise, it enables the toolbar button if there is a selection whose head and tail are part of
/// an existing retranslation.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateRemoveRetranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
		// we require both head and tail of the selection to lie within the retranslation
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = (CCell*)cpos->GetData();
		if (pCell != NULL)
		{
			CPile* pPile = pCell->m_pPile;
			CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;
			if (!pSrcPhrase->m_bRetranslation)
			{
				event.Enable(FALSE);
				return;
			}
			cpos = pApp->m_selection.GetLast();
			pCell = (CCell*)cpos->GetData();
			if (pCell != NULL)
			{
				pPile = pCell->m_pPile;
				pSrcPhrase = pPile->m_pSrcPhrase;
				if (!pSrcPhrase->m_bRetranslation)
				{
					event.Enable(FALSE);
					return;
				}
				else
				{
					event.Enable(TRUE);
					return;
				}
			}
			else
			{
				event.Enable(FALSE);
				return;
			}
		}
		else
		{
			event.Enable(FALSE);
			return;
		}
	}
	else
	{
		// I'll leave the following block here, but it will never be entered because
		// I changed the behaviour to prohibit the phrase box from being placed within
		// a retranslation
		if (pApp->m_pTargetBox != NULL)
		{
			if (pApp->m_pTargetBox->IsShown())
			{
				CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->m_pSrcPhrase;
				if (pSrcPhrase->m_bRetranslation)
				{
					event.Enable(TRUE);
					return;
				}
			}
		}
	}
	event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Edit A Retranslation" toolbar 
/// item and returns immediately: The application is in glossing mode, the target text only is showing 
/// in the main window, the m_pActivePile pointer is NULL, or if the head or tail of the selection do
/// not lie within the retranslation.
/// Otherwise, it enables the toolbar button if there is a selection whose head and tail are part of
/// an existing retranslation.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonEditRetranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (!gbIsGlossing && pApp->m_selectionLine != -1)
	{
		// we require both head and tail of the selection to lie within the retranslation
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = (CCell*)cpos->GetData();
		if (pCell != NULL)
		{
			CPile* pPile = pCell->m_pPile;
			CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;
			if (!pSrcPhrase->m_bRetranslation)
			{
				event.Enable(FALSE);
				return;
			}
			cpos = pApp->m_selection.GetLast();
			pCell = (CCell*)cpos->GetData();
			if (pCell != NULL)
			{
				pPile = pCell->m_pPile;
				pSrcPhrase = pPile->m_pSrcPhrase;
				if (!pSrcPhrase->m_bRetranslation)
				{
					event.Enable(FALSE);
					return;
				}
				else
				{
					event.Enable(TRUE);
					return;
				}
			}
			else
			{
				event.Enable(FALSE);
				return;
			}
		}
		else
		{
			event.Enable(FALSE);
			return;
		}
	}
	else
	{
		// I'll leave the following block here, but it will never be entered because
		// I changed the behaviour to prohibit the phrase box from being placed within
		// a retranslation
		if (pApp->m_pTargetBox != NULL)
		{
			if (pApp->m_pTargetBox->IsShown())
			{
				CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->m_pSrcPhrase;
				if (pSrcPhrase->m_bRetranslation)
				{
					event.Enable(TRUE);
					return;
				}
			}
		}
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::DoRetranslation()
{
	wxCommandEvent dummyevent;
	// IDS_TOO_MANY_SRC_WORDS
	wxMessageBox(_("Warning: there are too many source language words in this phrase for this adaptation to be stored in the knowledge base."), _T(""), wxICON_INFORMATION);

	OnButtonRetranslation(dummyevent);
}

void CAdapt_ItView::DoRetranslationByUpArrow()
{
	wxCommandEvent dummyevent;
	OnButtonRetranslation(dummyevent);
}


int CAdapt_ItView::GetSelectionWordCount()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_selectionLine == -1)
		return 0; // no selection
	int nCount = 0;
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		CCell* pCell = (CCell*)pos->GetData();
		nCount += pCell->m_pPile->m_pSrcPhrase->m_nSrcWords;
		pos = pos->GetNext();
	}
	return nCount;
}

CRefString* CAdapt_ItView::GetRefString(CKB *pKB, int nSrcWords, wxString keyStr,
																		wxString adaptation)
// looks up the knowledge base to find if there is an entry in the map with index nSrcWords-1,
// for the key keyStr and then searches the list in the CTargetUnit for the CRefString with
// m_translation member identical to adaptation, and returns a pointer to that CRefString
// instance. If it fails, it returns a null pointer. (Note: Jan 27 2001 changed so that returns
// the pRefString for a <Not In KB> entry). For version 2.0 and later, pKB will point to the
// glossing KB when gbIsGlossing is TRUE. Ammended, July 2003, to support auto capitalization
{
	MapKeyStringToTgtUnit* pMap = pKB->m_pMap[nSrcWords-1];
	wxASSERT(pMap != NULL);
	CTargetUnit* pTgtUnit;	// wx version changed 2nd param of AutoCapsLookup() below to
							// directly use CTargetUnit* pTgtUnit
	CRefString* pRefStr;
	bool bOK = AutoCapsLookup(pMap,pTgtUnit,keyStr);
	if (bOK)
	{
		return pRefStr = AutoCapsFindRefString(pTgtUnit,adaptation);
	}
	// lookup failed, so the KB state is different than data in the document suggests,
	// a Consistency Check operation should be done on the file(s)
	return (CRefString*)NULL;
}

CTargetUnit* CAdapt_ItView::GetTargetUnit(CKB *pKB, int nSrcWords, wxString keyStr)
// looks up the knowledge base to find if there is an entry in the map with index nSrcWords-1, for
// the key keyStr and returns the CTargetUnit pointer it finds. If it fails, it
// returns a null pointer.
// version 2.0 and onwards supports glossing, so pKB could point to the glossing KB or the
// adapting one, as set by the caller; and for glossing it is the caller's responsibility to ensure
// that nSrcWords has the value 1 only.
{
	MapKeyStringToTgtUnit* pMap = pKB->m_pMap[nSrcWords-1]; //CMapStringToOb* pMap = pKB->m_pMap[nSrcWords-1];
	wxASSERT(pMap != NULL);
	// MFC used pObject, in wx we use pointer to CTargetUnit directly
	CTargetUnit* pTgtUnit;
	bool bOK = AutoCapsLookup(pMap, pTgtUnit, keyStr);
	if (bOK)
	{
		wxASSERT(pTgtUnit);
		return pTgtUnit; // we found it
	}
	// lookup failed, so the KB state is different than data in the document suggests, a Verify
	// operation should be done on the file(s)
	return (CTargetUnit*)NULL;
}

CKB* CAdapt_ItView::GetKB()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	if (gbIsGlossing)
		return pApp->m_pGlossingKB;
	else
		return pApp->m_pKB;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing a copy of the m_key member (which has punctuation 
///             stripped off) of pSrcPhrase after m_key has been modified by Consistent Changes
///             (if m_bUseConsistentChanges is TRUE) or by SIL Converters (if m_bUseSilConverter
///             if TRUE)
/// \param      pSrcPhrase              -> the source phrase from which the m_key is copied
/// \param      bUseConsistentChanges   -> flag indicating if Consistent Changes is required
/// \remarks
/// Called from: The CopySourceKey() function is called from the View's PlacePhraseBox(), 
/// OnButtonToEnd(), OnButtonToStart(), OnButtonStepDown(), OnButtonStepUp(), OnButtonMerge(), 
/// OnButtonRestore(), RestoreTargetBoxText(), JumpForwardToNote_CoreCode(), and 
/// JumpBackwardToNote_CoreCode(); and CSourcePhrase's MoveToNextPile(), MoveToPrevPile() and
/// MoveToImmedNextPile().
/// CopySourceKey() is generally only called when the m_bCopySource flag is TRUE and when the
/// m_targetPhrase is empty, because there is no matching translation available from the KB or 
/// no previous target phrase has been entered. CopySourceKey() returns the source 
/// word or phrase (possibly merged) in a pre-processed form which constitutes a first guess 
/// for what might be wanted as a target text in the phrase box. This guess starts as the 
/// m_key member of the CSourcePhrase object (which is the form without any punctuation). 
/// CopySourceKey() applies any necessary modifications as the result of Consistent Changes 
/// (if m_bUseConsistentChanges is TRUE) or any modifications made by SIL Converters (if 
/// m_bUseSilConverter if TRUE) before returning the final string to the caller. 
/// Thus, CopySourceKey() is the primary place where Consistent Changes and SIL Converter 
/// changes is done within the Adapt It application.
////////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::CopySourceKey(CSourcePhrase *pSrcPhrase, bool bUseConsistentChanges)
{
	wxString str = pSrcPhrase->m_key;
	if (str.IsEmpty())
		return _T("");

	if (!gbLegacySourceTextCopy)
	{
		// the user wants smart copying done to the phrase box when the active location
		// landed on does not have any existing adaptation (in adapting mode), or, gloss
		// (in glossing mode). In the former case, it tries to copy a gloss to the box
		// if a gloss is available, otherwise source text used instead; in the latter case
		// it tries to copy an adaptation as the default gloss, if an adaptation is
		// available, otherwise source text is used instead
		if (gbIsGlossing)
		{
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				str = pSrcPhrase->m_adaption;
			}
		}
		else
		{
			if (!pSrcPhrase->m_gloss.IsEmpty())
			{
				str = pSrcPhrase->m_gloss;
			}
		}
	}

	gbByCopyOnly = TRUE;
	if (bUseConsistentChanges)
	{
		// these added spaces are automatically stripped before storage takes place, after cc
		// has had its chance to apply, so no harm is done by these additions
		str = _T(" ") + str;
		str += _T(" ");

		// apply to the merged string (ie. merged with whatever is returned here)
		wxString str2 = DoConsistentChanges(str);

		// strip the added spaces back off
		// whm comment: the following GetChar() operations assume that str2 can never be an 
		// empty string when it returns from DoConsistentChanges; for safety sake, I'm just
		// going to use the Trim() function instead.
		//if (str2.GetChar(0) == _T(' '))
		//	str2 = str2.Mid(1); // remove initial space
		//int len = str2.Length();
		//if (str2.GetChar(len-1) == _T(' '))
		//	str2 = str2.Left(len-1); // remove final space
		str2.Trim(FALSE); // trim the left end
		str2.Trim(TRUE); // trim the right end

		return str2;
	}
	else if( gpApp->m_bUseSilConverter )
	{
		return DoSilConvert(str);
	}
	else
		return str;
}

/*
wxString CAdapt_ItView::CopySourcePhrase(CSourcePhrase *pSrcPhrase, bool bUseConsistentChanges) // unused
// this does the cc table changes on the m_srcPhrase attribute, which may contain punctuation;
// - but I think I no longer use this function, and hence ignore punctuation for CC table applications
{
	wxString str = pSrcPhrase->m_srcPhrase;
	if (str.IsEmpty())
		return _T("");

	gbByCopyOnly = TRUE;
	if (bUseConsistentChanges)
	{
		// add initial and final space, so that cc tables entries can be defined for word-initial
		// application, or word final application (these spaces are automatically stripped before
		// storage takes place, after cc has had its chance to apply, so no harm is done by these
		// additions)
		str = _T(" ") + str;
		str += _T(" ");

		// apply to the merged string (ie. merged with whatever is returned here)
		wxString str2 = DoConsistentChanges(str);

		// strip the added spaces back off
		if (str2.GetChar(0) == _T(' '))
			str2 = str2.Mid(1); // remove initial space
		int len = str2.Length();
		if (str2.GetChar(len-1) == _T(' '))
			str2 = str2.Left(len-1); // remove final space

		return str2;
	}
	else
		return str;
}
*/

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing text after any Consistent Changes have been performed
///             on the text
/// \param      str    -> the incoming string on which Consistent Changes is to be performed
/// \remarks
/// Called from: the View's CopySourceKey() and DoTargetBoxPaste().
/// If str is not empty, DoConsistentChanges passes str through up to four successive Consistent
/// Changes processes, once for each of up to four loaded changes tables. DoConsistentChanges()
/// handles the initialization of an input and an output buffer for processing of changes by
/// calling of up to four m_consistentChager instances on the buffers, employing the 
/// utf8ProcessBuffer() method of CConsistentChanger. See the CConsistentChanger and CCModule 
/// classes.
////////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::DoConsistentChanges(wxString& str)
// the DLL for the consistent changes code will need to handle unicode characters for the
// Unicode version - make sure the appropriate changes are done
{
	if (str.IsEmpty())
		return _T("");

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

#ifndef _UNICODE
	// new ANSI version, uses buffers, and based on the _UNICODE code...
	// for the ANSI version, str will be a byte-oriented wxString. No conversions needed.
	// the strings stored in the buffers will be null delimited
	int nIn = 0;  // index for current input buffer
	int nOut = 1; // index for current output buffer
	char byteBuff[2][1024]; // two 1k byte buffers which will alternate as input and output iteratively
	int nInLength = 0;
	int nOutLength = 1024;
	int nTableIndex = -1;

	nInLength = str.Length(); // in bytes
	nInLength += 1; // allow for the null byte at the end (note: for 2.2.1 and previous
					// I did not realize that CC will strip off this final null byte
					// reducing the length by one, so I got final character chopped off
					// the changed string - I fixed this for 2.3.0 (the next after 2.2.1)
	const wxChar* pbuffer = str.GetData();

	// whm added pEnd and null char below
	wxChar* pEnd;
	pEnd = (wxChar*)pbuffer + nInLength -1; // -1 to compensate for += 1 increment on nInLength above
	wxASSERT(*pEnd == _T('\0')); // insure there's a null at end of buffer

	// populate the first of the buffers
	wxStrcpy(byteBuff[nIn],pbuffer);

	// apply the tables
	int iResult = 0;
	bool bPreviouslyUsedTable = FALSE; // TRUE after a table has been used
	for (int i = 0; i < 4; i++)
	{
		nTableIndex++; // keep track of which table, in case we get an error

		// do the next table, if present
		if (pApp->m_bCCTableLoaded[i])
		{
			if (bPreviouslyUsedTable)
			{
				// prepare for this next table
				nIn = nIn == 0 ? 1 : 0;
				nOut = nOut == 0 ? 1 : 0;
				nInLength = nOutLength;
				nOutLength = 1024;
				memset(byteBuff[nOut],0,1024); // clear the string in the new output buffer
											   // (CC does not retain the null bytes, but
											   // fills the unused part with -52 bytes,
											   // and input '\0' is lost)
			}
			bPreviouslyUsedTable = TRUE;

			iResult = pApp->m_pConsistentChanger[i]->utf8ProcessBuffer(byteBuff[nIn],nInLength,
																byteBuff[nOut],&nOutLength);

			// if there was an error, just return the unaltered original string & warn user
			if (iResult)
			{
				ccErrorStr = ccErrorStr.Format(
				_(" Processing a CC table failed. Got error code %d with table having index %d."),
									iResult,nTableIndex);
				wxMessageBox(ccErrorStr, _T(""), wxICON_EXCLAMATION);
				return str; // if there was a table procesing error then return the
							// original string, ie. no tables used
			}
			else
			{
				// no errors
				if (i == 3)
					break; // at the end, so go convert the output string back to UTF-16
			}
		}
		else
		{
			// that table was not loaded, so try the next one
			continue;
		}
	}

	byteBuff[nOut][nOutLength] = '\0';    // ensure it is null terminated at the correct
										  // location (it will overwrite the first (byte)-52)
	// wx version note: here we need a writable buffer
	wxChar* pStr = str.GetWriteBuf(nOutLength + 1);  // nOutLength is 1024
	wxStrcpy(pStr,byteBuff[nOut]);            // but I ran into some problems, so I've done it the safety first way
	//wxChar* pEnd;
	pEnd = pStr + nOutLength; // whm added 18Jun06
	wxASSERT(*pEnd == _T('\0')); // whm added 18Jun06
	str.UngetWriteBuf(); 
	return str;

#else // Unicode version

	// for the unicode version, str will be a UTF-16 wxString. We have to convert to UTF8, run the
	// resulting string through the CCProcessBuffer() function with a minimum of string copying
	// to maximize speed, and then convert back to UTF-16 and return it to the caller as an LPTSTR;
	// the strings stored in the buffers will be null delimited

	// BEW changed 8Apr06 to accomodate the buffer-safe new conversion macros in VS 2003, which
	// use malloc for buffer allocation of long string to be converted, etc.

	int nIn = 0;  // index for current input buffer
	int nOut = 1; // index for current output buffer
	char byteBuff[2][1024]; // two 1k byte buffers which will alternate as input and output iteratively
	int nInLength = 0;
	int nOutLength = 1024;
	int nTableIndex = -1;

	// The MFC way: convert to UTF8
	//CW2A lpszConverted((LPCTSTR)str,eUTF8); // I had to tweak ATLConv.h to have x4 multiplier, not x2
	//LPCSTR psz = lpszConverted;
	
	// pre 3.1.0 code -- reinstate this code, don't use CW2A!
	//USES_CONVERSION_U8;
	//LPCSTR psz = T2CU8((LPCTSTR)str);
	
	// wx version note:
	// The wxString::mb_str() method returns a wxCharBuffer. The wxConvUTF8 is a predefined
	// instance of the wxMBConvUTF8 class which converts between Unicode (UTF-16) and UTF-8.
	wxCharBuffer tempBuf = str.mb_str(wxConvUTF8);
	CBString psz(tempBuf);

	nInLength = strlen(psz) + 1; // + 1 for the null byte at the end
	strcpy(byteBuff[nIn],psz);

	// apply the tables
	int iResult = 0;
	bool bPreviouslyUsedTable = FALSE; // TRUE after a table has been used
	for (int i = 0; i < 4; i++)
	{
		nTableIndex++; // keep track of which table, in case we get an error

		// do the next table, if present
		if (pApp->m_bCCTableLoaded[i])
		{
			if (bPreviouslyUsedTable)
			{
				// prepare for this next table
				nIn = nIn == 0 ? 1 : 0;
				nOut = nOut == 0 ? 1 : 0;
				nInLength = nOutLength;
				nOutLength = 1024;
				memset(byteBuff[nOut],0,1024); // clear the string in the new output buffer

			}
			bPreviouslyUsedTable = TRUE;

			// whm note: the following line is where consistent changes does its work
			iResult = pApp->m_pConsistentChanger[i]->utf8ProcessBuffer(byteBuff[nIn],nInLength,byteBuff[nOut],&nOutLength);

			// if there was an error, just return the unaltered original string & warn user
			if (iResult)
			{
				ccErrorStr.Format(
				_(" Processing a CC table failed. Got error code %d with table having index %d."),
									iResult,nTableIndex);
				wxMessageBox(ccErrorStr, _T(""), wxICON_EXCLAMATION);
				return str; // if there was a table procesing error then return the original
							// string, ie. no tables used
			}
			else
			{
				// no errors
				if (i == 3)
					break; // at the end, so go convert the output string back to UTF-16
			}
		}
		else
		{
			// that table was not loaded, so try the next one
			continue;
		}
	}

	// convert back to UTF-16 and return the converted string
	byteBuff[nOut][nOutLength] = '\0';	// ensure it is null terminated at the correct
										// location
	//CA2W lpConvertedText((LPSTR)byteBuff[nOut],eUTF8);
	// the wxWidgets equivalent for the above conversion is:
	
	// pre 3.1.0 code
	//LPTSTR lpConvertedText;
	//lpConvertedText = U82T((LPSTR)byteBuff[nOut]);
	
	CBString tempBuff(byteBuff[nOut]);
	return gpApp->Convert8to16(tempBuff);

#endif // for _UNICODE
}

void CAdapt_ItView::ChooseTranslation()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	if (pApp->m_pTargetBox == NULL || !pApp->m_pTargetBox->IsShown())
	{
		// whm Note: the m_pTargetBox is never NULL in the wx version, but
		// sometimes it is not shown, so if we are getting a bell sound at
		// wrong times, this may be the cause.
		// TODO: check the logic during Find operations and any other cases
		// where the MFC version assumes that the target box might be NULL
		::wxBell();
	}
	else
	{
		if (pApp->m_pActivePile != NULL && !pApp->m_pActivePile->m_pSrcPhrase->m_bNotInKB)
			OnButtonChooseTranslation(dummyevent);
		else
			;
			::wxBell();
	}
}

void CAdapt_ItView::OnButtonChooseTranslation(wxCommandEvent& WXUNUSED(event))
// Modified for support of glossing.
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// ensure blank variables
	translation.Empty();
	curKey.Empty();
	nWordsInPhrase = 0;
	pCurTargetUnit = NULL;

	CKB* pKB;
	int nCurLongest;
	if (gbIsGlossing)
	{
		pKB = gpApp->m_pGlossingKB;
		nCurLongest = 1; // only one map in the glossing KB, so treat as "one word" case
						 // whether or not src words or phrases are put into this one map
	}
	else
	{
		pKB = gpApp->m_pKB;
		nCurLongest = pKB->m_nMaxWords; // no matches are possible for phrases
										// longer than nCurLongest
	}
	// check we are within bounds
	CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->m_pSrcPhrase;
	if (gbIsGlossing)
		nWordsInPhrase = 1;
	else
		nWordsInPhrase = pSrcPhrase->m_nSrcWords;

	if (nWordsInPhrase > nCurLongest)
	{
		// something is really wrong, this should not be possible
		wxString str =
		_T("Error: longest phrase in KB is shorter than current source phrase's number of words!\n");
		str += _T("So this command will be ignored.\n");
		wxMessageBox(str, _T(""), wxICON_EXCLAMATION);
		nWordsInPhrase = 0;
		pApp->m_pTargetBox->SetFocus();
		return;
	}

	// restore the current phrase box's text in the KB, so that potential singly referenced
	// adaptations not yet in the KB will still show in the dialog; but don't do so if the
	// phrasebox is empty (since we want <no adaptation> to show only when the button of
	// that name has been pressed)
	wxString temp;
	bool bOK = TRUE;
	bool bEmptyBox = FALSE;
	if (pApp->m_targetPhrase.IsEmpty())
	{
		bEmptyBox = TRUE;
		goto jp;
	}
	temp = pApp->m_targetPhrase;
	if (!gbIsGlossing || gbRemovePunctuationFromGlosses)
		RemovePunctuation(GetDocument(),&temp,1 /*from tgt*/);
	bOK = StoreText(pKB,pSrcPhrase,temp,TRUE); // TRUE means we want suppression here
												    // of the CEmptyAdaptDlg
	wxASSERT(bOK);

	// get a pointer to the target unit for the current key
jp:	pCurTargetUnit = GetTargetUnit(GetKB(),nWordsInPhrase,pSrcPhrase->m_key);
	if (pCurTargetUnit == NULL)
	{
		// IDS_NO_KB_ENTRY
		wxMessageBox(_("Sorry, the knowledge base does not yet have an entry matching this source text, so the Choose Translation dialog cannot be shown."), _T(""), wxICON_EXCLAMATION);
		nWordsInPhrase = 0;
		pApp->m_pTargetBox->SetFocus();
		return;
	}
	else
	{
		curKey = pSrcPhrase->m_key;
		CChooseTranslation dlg(pApp->GetMainFrame());
		dlg.Centre();
		// initialize m_chosenTranslation, other initialization is in OnInitDialog()
		dlg.m_chosenTranslation.Empty();

		// put up the dialog
		bool bCancelled = FALSE;
		gbInspectTranslations = TRUE; // use TRUE value to hide the "Cancel and Select" button
		if(dlg.ShowModal() == wxID_OK)
		{
			// set the translation static var from the member m_chosenText
			translation = dlg.m_chosenTranslation;
			if (dlg.m_bEmptyAdaptationChosen)
				gbEmptyAdaptationChosen = TRUE; // enable PlacePhraseBox to use the null string
												// chosen
		}
		else
		{
			// must have hit Cancel button
			bCancelled = TRUE;
			gbEmptyAdaptationChosen = FALSE;
		}
		gbInspectTranslations = FALSE;

		// remove the refString again, to restore the phrase box and KB to the proper state
		// for having landed there - if the user removed the refString in the dialog, pRefString
		// will be NULL and no damage will be done as RemoveRefString checks for this condition
		CRefString* pRefString;
		if (bEmptyBox)
			goto ed;
		if (gbIsGlossing)
			pRefString = GetRefString(GetKB(), 1, pSrcPhrase->m_key, pSrcPhrase->m_gloss);
		else
			pRefString = GetRefString(GetKB(),nWordsInPhrase,pSrcPhrase->m_key,
																	pSrcPhrase->m_adaption);

		if (pRefString != NULL)
		{
			// remove the translation from the KB, in case user wants to edit it before its
			// stored again (RemoveRefString also clears the m_bHasKBEntry flag on the source
			// phrase)
			if (gbIsGlossing)
			{
				RemoveRefString(pRefString,pSrcPhrase,1);
				// we must make sure the m_bHasGlossingKBEntry flag is false, otherwise a
				// subsequent StoreText() call will assert
				pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
			}
			else
			{
				RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);
				// we must make sure the m_bHasKBEntry flag is false, otherwise a
				// subsequent StoreText() call will assert
				pSrcPhrase->m_bHasKBEntry = FALSE;
			}
		}

		// if user hit the cancell button, we can return immediately
ed:		if (bCancelled)
		{
			nWordsInPhrase = 0;
			pCurTargetUnit = NULL;
			curKey.Empty();
			pApp->m_pTargetBox->SetFocus();
			return;
		}

		// use the translation global variable to set the phrase box to the chosen adaptation
		pApp->m_targetPhrase = translation;
		pApp->m_pTargetBox->SetValue(translation);
		PlacePhraseBox(pApp->m_pActivePile->m_pCell[2], 1); // selector = 1 inhibits the saving to KB
													  // since there was no click to a new location
		gbEmptyAdaptationChosen = FALSE; // ensure its safely defused!

		// get a new (valid) active pile pointer, now that the layout is recalculated (again!)
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pApp->m_pActivePile);
		int len = pApp->m_pTargetBox->GetLineLength(0);
		pApp->m_nStartChar = pApp->m_nEndChar = len; // cursor at end of text in the box
		pApp->m_pTargetBox->SetModify(TRUE);

		// scroll into view, just in case a lot were inserted
		pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

		pApp->m_pTargetBox->SetFocus();
		translation.Empty(); // clear the globals
		curKey.Empty();
		Invalidate();
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Show the Choose Translation 
/// Dialog" toolbar item and returns immediately: The application is in Free Translation mode, the
/// targetBox is NULL or is not shown, or the application is in glossing mode.
/// Otherwise, it enables the toolbar button if the active pile is valid and the source phrase at that
/// point does not have the m_bNotInKB flag set.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonChooseTranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pTargetBox == NULL || !pApp->m_pTargetBox->IsShown())
	{
		// whm 12Aug08 Note: the m_pTargetBox is never NULL in the wx version, but
		// sometimes it is not shown, so if the ChooseTranslation button is
		// not enabled when it should be, this may be the cause.
		// TODO: check the logic during Find operations and any other cases
		// where the MFC version assumes that the target box might be NULL
		event.Enable(FALSE);
		return;
	}
	else
	{
		if (!gbIsGlossing && pApp->m_pActivePile != NULL && !pApp->m_pActivePile->m_pSrcPhrase->m_bNotInKB)
			event.Enable(TRUE);
		else
		{
			if (gbIsGlossing)
				event.Enable(TRUE);
			else
				event.Enable(FALSE);
		}
	}
}

void CAdapt_ItView::StatusBarMessage(wxString &message)
{
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
 	wxStatusBar* pStatusBar = pFrame->GetStatusBar();
	if (pStatusBar != NULL)
	{
		pStatusBar->SetStatusText(message,0); // use first field 0
	}
}

void CAdapt_ItView::OnFileStartupWizard(wxCommandEvent& event) // called by DoStartupWizardOnLaunch
{
	// Since the Startup Wizard menu item has an accelerator table hot key (CTRL-W see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	// On Windows, the accelerator key doesn't appear to call the handler for a disabled menu item, but
	// I'll leave the following code here in case it works differently on other platforms.
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_FILE_STARTUP_WIZARD))
	{
		::wxBell();
		return;
	}

	pApp->m_bStartViaWizard = TRUE; // allows the OnIdle handler to force phrase box text to be selected
	bool bSuppress = pApp->m_bSuppressWelcome;

	if (pApp->m_pSourcePhrases->GetCount() > 0)
		goto a;
	if (pApp->m_pKB != NULL)
		goto a;
	if (gbJustClosedProject)
		goto a;

	if (!bSuppress)
	{
		CWelcome wdlg(pApp->GetMainFrame()); // make the view the parent
		wdlg.Centre();
		wdlg.ShowModal();
		pApp->m_bSuppressWelcome = wdlg.m_bSuppressWelcome; // update flag
	}

a:	if (pApp->m_bJustLaunched && !pApp->m_bUseStartupWizardOnLaunch)
		return; // suppress its use if user wants, but only for the program launch
	else
	{
		bool bSuccess = pApp->DoStartWorkingWizard(event);
		if (!bSuccess)
		{
			wxMessageBox(_T(
"The Startup Wizard failed. Try using Start Here... and either the New...\nor Open... items on the File... menu instead."),
				_T(""), wxICON_EXCLAMATION);
		}
	}
}

void CAdapt_ItView::DoStartupWizardOnLaunch()
{
	wxCommandEvent dummyevent;
	OnFileStartupWizard(dummyevent);
}

void CAdapt_ItView::RedrawEverything(int nActiveSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	// get everything redrawn
	RecalcLayout(pApp->m_pSourcePhrases,0,pApp->m_pBundle);

	// restore the active pile location, etc - by using the saved sequNum and finding
	// the pile which that source phrase belongs to; providing we are not at EOF
	if (pApp->m_nActiveSequNum < 0)
	{
		// we are at EOF, so we don't worry about the phrase box
		Invalidate(); // our own
		return;

	}
	pApp->m_nActiveSequNum = nActiveSequNum;
	pApp->m_pActivePile = GetPile(nActiveSequNum);
	pApp->m_curIndex = pApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;

		#ifdef _Trace_Box_Loc_Wrong
		if (m_nActiveSequNum >12500)
		{
			TRACE0("ScrollIntoView  from RedrawEverything 15866\n");
		}
		#endif

	// scroll the active location into view & force window update
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	if (pApp->m_pActivePile == NULL)
	{
		return; // added by whm 17May04 TODO: see if can remove "return" and uncomment below
//		wxMessageBox(_(
//"Failed finding the active pile in RedrawEverything(). Save & then exit the application.\n"), _T(""),
//			wxICON_EXCLAMATION);
//		wxASSERT(FALSE);
	}
	else
	{
		//int oldWidth = pApp->m_curBoxWidth; // for debugging // not used
		SetupPhraseBoxParameters(pApp->m_pActivePile); // doesn't change pApp->m_targetPhrase value
		if (pApp->m_pTargetBox != NULL)
			RemakePhraseBox(pApp->m_pActivePile,pApp->m_targetPhrase);
		else
		{
			pApp->m_ptCurBoxLocation = pApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

			// create the box at that location
			pApp->m_curBoxWidth = RecalcPhraseBoxWidth(pApp->m_targetPhrase); // recalc, since the pasted
																  // text might be shorter
			pApp->m_nCurPileMinWidth = pApp->m_curBoxWidth; // update this too, so box can be shorter
												// if necessary
			pApp->m_targetPhrase.Empty();
			pApp->m_nStartChar = 0;
			pApp->m_nEndChar = -1;
			pApp->m_curIndex = pApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;

			if (gbIsGlossing && gbGlossingUsesNavFont)
			{
				// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
				ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nNavTextHeight,pApp->m_targetPhrase,
															pApp->m_nStartChar,pApp->m_nEndChar,pApp->m_pActivePile);
				// set the color - CPhraseBox has a color variable & uses reflected notification
				pApp->m_pTargetBox->m_textColor = pApp->m_navTextColor;
			}
			else
			{
				// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
				ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nTgtHeight,pApp->m_targetPhrase,
															pApp->m_nStartChar,pApp->m_nEndChar,pApp->m_pActivePile);
				// set the color - CPhraseBox has a color variable & uses reflected notification
				if (gbIsGlossing)
					pApp->m_pTargetBox->m_textColor = pApp->m_navTextColor;
				else
					pApp->m_pTargetBox->m_textColor = pApp->m_targetColor;

			}

		}

		pApp->m_nStartChar = 0;
		int len = pApp->m_pTargetBox->GetLineLength(0);// line number zero for our phrasebox
		pApp->m_nEndChar = len;
		pApp->m_pTargetBox->SetSelection(pApp->m_nEndChar,pApp->m_nEndChar); // put cursor at end // MFC SetSel
		gnStart = pApp->m_nStartChar;
		gnEnd = pApp->m_nEndChar;

		Invalidate(); // our own
	}
}

void CAdapt_ItView::OnButtonToggleSourceLines(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// save the current sequence number
	int nSaveSequNum = pApp->m_nActiveSequNum;

	// toggle the flag value
	pApp->m_bSuppressFirst = pApp->m_bSuppressFirst == TRUE ? FALSE : TRUE;

	// can't allow a selection to be "preserved" if it was in line 1, and line 1 will not be
	// defined
	if (pApp->m_bSuppressFirst && pApp->m_selectionLine == 0)
		RemoveSelection();

	// redraw the layout etc.
	RedrawEverything(nSaveSequNum);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Toggle Showing 1 or 2
/// Source Lines" toolbar item and returns immediately: The application is showing only the target
/// language text, the active pile is NULL, or there are no source phrases in the m_pSourcePhrases list.
/// Otherwise, it enables the toolbar button if the m_curIndex represents a valid location.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonToggleSourceLines(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_curIndex <= (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_curIndex >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonToggleTargetLines(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// save the current sequence number
	int nSaveSequNum = pApp->m_nActiveSequNum;

	// toggle the flag value
	pApp->m_bSuppressLast = pApp->m_bSuppressLast == TRUE ? FALSE : TRUE;

	// redraw the layout etc.
	RedrawEverything(nSaveSequNum);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Toggle Showing 1 or 2
/// Target Lines" toolbar item and returns immediately: The application is showing only the target
/// language text, the active pile is NULL, or there are no source phrases in the m_pSourcePhrases list.
/// Otherwise, it enables the toolbar button if the m_curIndex represents a valid location.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonToggleTargetLines(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_curIndex <= (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_curIndex >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::RedoStorage(CKB* pKB, CSourcePhrase* pSrcPhrase)
// Modified for support of glossing KB as well as adapting KB. The caller must send the
// correct KB pointer in the first parameter.
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	pApp->m_bForceAsk = FALSE;
	bool bOK;
	if (gbIsGlossing)
	{
		if (!pSrcPhrase->m_bHasGlossingKBEntry)
		{
			return; // nothing to be done
		}
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // has to be false on input to StoreText()
		bOK = StoreText(pKB,pSrcPhrase,pSrcPhrase->m_gloss,TRUE);
		if (!bOK)
		{
			// I don't expect any error here, but just in case ...
			wxBell();
			wxASSERT(FALSE);
		}
	}
	else // adapting
	{
		if (!pSrcPhrase->m_bRetranslation)
		{
			if (pSrcPhrase->m_bNullSourcePhrase)
			{
				goto a;
			}
			else
			{
				if (pSrcPhrase->m_bNotInKB)
				{
					wxString str = _T("<Not In KB>");
					pSrcPhrase->m_bHasKBEntry = FALSE; // to enable storage
					bOK = StoreText(pKB,pSrcPhrase,str,TRUE);
					if (!bOK)
					{
						// I don't expect any error here, but just in case ...
						::wxBell(); 
						wxASSERT(FALSE);
					}
					return;
				}
			}
a:			if (!pSrcPhrase->m_bHasKBEntry)
			{
				return; // nothing to be done
			}
			pSrcPhrase->m_bHasKBEntry = FALSE; // has to be false on input to StoreText()
			bool bOK = StoreText(pKB,pSrcPhrase,pSrcPhrase->m_adaption,TRUE);
			if (!bOK)
			{
				// I don't expect any error here, but just in case ...
				::wxBell();
				wxASSERT(FALSE);
			}
		}
	}
}

void CAdapt_ItView::OnCheckKBSave(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing)
	{
		// if glossing is ON, keep the box checked at all times since
		// we won't allow <Not In KB> option when gbIsGlossing is TRUE
		pApp->m_bSaveToKB = TRUE;
		return;
	}
	// glossing is OFF, so box can be toggled on or off
	if (pApp->m_pActivePile == NULL)
		return;
	CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->m_pSrcPhrase;
	if (pSrcPhrase == NULL)
		return;

	// call DoNotInKB & then toggle the m_bSaveToKB flag
	if (pApp->m_bSaveToKB)
	{
		// user does not want it to be in the KB
		// we must do the call with m_bSaveToKB TRUE, otherwise the store
		// of "<Not In KB>" will not happen
		DoNotInKB(pSrcPhrase,TRUE);
		pApp->m_bSaveToKB = FALSE;
	}
	else
	{
		// user wants it in the KB
		pApp->m_bSaveToKB = TRUE;
		DoNotInKB(pSrcPhrase,FALSE);
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::DoNotInKB(CSourcePhrase* pSrcPhrase, bool bChoice)
{
	if (bChoice)
	{
		// user wants it to not be in the KB, so set it up accordingly...
		// first thing to do is to remove all existing translations from this source phrase's
		// entry in the KB
		CTargetUnit* pTgtUnit = GetTargetUnit(GetKB(),pSrcPhrase->m_nSrcWords,pSrcPhrase->m_key);
		if (pTgtUnit != NULL)
		{
			TranslationsList* pList = pTgtUnit->m_pTranslations;
			if (!pList->IsEmpty())
			{
				TranslationsList::Node* pos = pList->GetFirst();
				while (pos != NULL)
				{
					CRefString* pRefString = (CRefString*)pos->GetData();
					pos = pos->GetNext();
					if (pRefString != NULL)
					{
						delete pRefString;
						pRefString = (CRefString*)NULL;
					}
				}
				pList->Clear();

				// have to get rid of the pTgtUnit too, as its m_translation list must not be empty
				//pos = GetKB()->m_pTargetUnits->Find(pTgtUnit); // find position of the bad
				//											   // targetUnit in the list
				// NOTE: pos in the line above needs to be a node in a TUList, rather than a node
				// in a TranslationsList as defined above. We'll need to call it something else since
				// it is in the same scope as above.
				TUList::Node* tupos = GetKB()->m_pTargetUnits->Find(pTgtUnit); // find position of the bad
															   // targetUnit in the list
				// get the targetUnit in the list
				CTargetUnit* pTU = (CTargetUnit*)tupos->GetData(); 
				wxASSERT(pTU != NULL && pTU->m_pTranslations->IsEmpty()); // have we found it?
				GetKB()->m_pTargetUnits->DeleteNode(tupos); // remove it from the list
				delete pTU; // delete it from the heap
				pTU = (CTargetUnit*)NULL;

				MapKeyStringToTgtUnit* pMap = GetKB()->m_pMap[pSrcPhrase->m_nSrcWords - 1];
				// handle auto-caps tweaking, if it is on
				wxString temp = pSrcPhrase->m_key;
				if (gbAutoCaps && !gbNoSourceCaseEquivalents)
				{
					// auto caps is on and there are case equivalences defined, so check if we must
					// convert the key to lower case for the removal operation (so that it succeeds,
					// since the KB would have a lower case key stored, not upper case
					bool bNoError = SetCaseParameters(temp); // TRUE for default parameter = src text
					if (bNoError && gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
					{
						temp.SetChar(0,gcharSrcLC); // make first char lower case
					}
				}
				int bRemoved;
				bRemoved = pMap->erase(temp); // also remove it from the map 
				wxASSERT(bRemoved != 0);
			}
		}

		// we make it's KB translation be a unique "<Not In KB>" - Adapt It will use this as a flag
		pSrcPhrase->m_bNotInKB = FALSE; // temporarily set FALSE to allow the string to go into KB
		wxString str = _T("<Not In KB>");
		bool bOK;
		bOK = StoreText(GetKB(),pSrcPhrase,str);

		// make the flags the correct values & save them on the source phrase
		pSrcPhrase->m_bNotInKB = TRUE;
		pSrcPhrase->m_bHasKBEntry = FALSE;

		// user can set pSrcPhrase->m_adaption to whatever he likes via phrase box, it won't go
		// into KB, and it now will get clobbered, since "<Not In KB>" overrides anything which
		// is there, so since "<Not In KB>" has been put in the source Phrase's m_adaption member
		// in the StoreText call just above, we now must clear it -- we no longer do this,
		// see next two comment lines. Following Susanna Imrie's recommendation that this feature
		// should still allow a non-null translation to remain in the document, the following code
		// will be commented out as of version 1.4.0 Dec 18.
		/*
		pSrcPhrase->m_adaption.Empty();
		pSrcPhrase->m_targetStr.Empty();
		if (pApp->m_targetBox.m_hWnd != NULL && (pApp->m_targetBox.GetStyle() & WS_VISIBLE) != 0)
		{
			pApp->m_targetPhrase.Empty();
			pApp->m_targetBox.SetWindowText(pApp->m_targetPhrase);
			pApp->m_targetBox.UpdateWindow();
		}
		*/
	}
	else
	{
		// make translations storable from now on
		pSrcPhrase->m_bNotInKB = FALSE; // also permits finding of KB entry
		pSrcPhrase->m_bHasKBEntry = FALSE; // make sure

		wxString str = _T("<Not In KB>");
		CRefString* pRefString =
						GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,pSrcPhrase->m_key,str);
		if (pRefString == NULL)
		{
			// user must have already deleted the <Not In KB> while in the KB editor, so our
			// work is done
			return;
		}
		wxASSERT(pRefString);
		if (pRefString != NULL)
		{
			CTargetUnit* pTgtUnit = pRefString->m_pTgtUnit;
			wxASSERT(pTgtUnit);
			TranslationsList* pList = pTgtUnit->m_pTranslations;
			wxASSERT(!pList->IsEmpty() && pList->GetCount() == 1);
			TranslationsList::Node* pos = pList->GetFirst();
			delete pRefString; // deletes the CRefString having the text "<Not In KB>"
			pRefString = (CRefString*)NULL;
			pList->DeleteNode(pos);

			// we must also delete the target unit, since we are setting up a situation
			// where in effect the current matched item was never previously matched, ie. it's a
			// big error to have a target unit with no reference string in it.
			int index = pSrcPhrase->m_nSrcWords - 1;
			MapKeyStringToTgtUnit* pMap = GetKB()->m_pMap[index];
			//BOOL bRemoved = pMap->RemoveKey(pSrcPhrase->m_key); // remove it from the map
			int bRemoved;
			// handle auto-caps tweaking, if it is on
			wxString temp = pSrcPhrase->m_key;
			if (gbAutoCaps && !gbNoSourceCaseEquivalents)
			{
				// auto caps is on and there are case equivalences defined, so check if we must
				// convert the key to lower case for the removal operation (so that it succeeds,
				// since the KB would have a lower case key stored, not upper case
				bool bNoError = SetCaseParameters(temp); // TRUE for default parameter = src text
				if (bNoError && gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
				{
					temp.SetChar(0,gcharSrcLC); // make first char lower case
				}
			}
			bRemoved = pMap->erase(temp); // remove it from the map

			// now remove the CTargetUnit instance too
			//pos = GetKB()->m_pTargetUnits->Find(pTgtUnit); // find position of pRefString's
			//											   // owning targetUnit
			// pos was used as node for TranslationsList above, so we need to change it
			// to a node for a TUList here and give it a different name
			TUList::Node* tupos;
			tupos = GetKB()->m_pTargetUnits->Find(pTgtUnit); // find position of pRefString's
														   // owning targetUnit
			pTgtUnit = (CTargetUnit*)tupos->GetData(); // get the targetUnit
														  // in the list
			wxASSERT(pTgtUnit != NULL);
			GetKB()->m_pTargetUnits->DeleteNode(tupos); // remove it from the list
			delete pTgtUnit; // delete it from the heap
			pTgtUnit = (CTargetUnit*)NULL;
		}
	}
}

void CAdapt_ItView::ClobberDocument()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = (CAdapt_ItDoc*)GetDocument();
	wxASSERT(pDoc != NULL);

	// BEW added 21Apr08; clean out the global struct gEditRecord & clear its deletion lists,
	// because each document, on opening it, it must start with a truly empty EditRecord; and
	// on doc closure and app closure, it likewise must be cleaned out entirely (the deletion
	// lists in it have content which persists only for the life of the document currently open)
	InitializeEditRecord(gEditRecord); // clears all except the deletion list, so do those next
	gEditRecord.deletedAdaptationsList.Clear(); // remove any stored deleted adaptation strings
	gEditRecord.deletedGlossesList.Clear(); // remove any stored deleted gloss strings
	gEditRecord.deletedFreeTranslationsList.Clear(); // remove any stored deleted free translations

	// save settings for restoration from config file
	if (pApp->m_nActiveSequNum == -1)
		pApp->m_nActiveSequNum = 0;
	pApp->m_lastDocPath = pApp->m_curOutputPath;
	pApp->nLastActiveSequNum = pApp->m_nActiveSequNum;

	// now clobber it all the view stuff associated with the document, leaving an empty
	// document object
	pDoc->Modify(FALSE); // MFC has SetModifiedFlag(FALSE)
	pApp->m_pBundle->DestroyStrips(0); // this is enough, a file open will call DeleteContents anyway
	pDoc->DeleteSourcePhrases();
	pApp->m_pActivePile = (CPile*)NULL;
	pApp->m_curIndex = -1;
	pApp->m_pTargetBox->SetValue(_T("")); //pApp->m_targetBox.Destroy(); // MFC CWnd uses DestroyWindow()
	pApp->m_nActiveSequNum = -1;
	pApp->m_selectionLine = -1;
	Invalidate(); // our own

	gbDoingInitialSetup = TRUE; // MFC note: Needed because the phrase box will not exist after the close
							// is done, so if a <New Document> command is issued, then
							// OnButtonMerge() would otherwise fail if a LookAhead merge
							// was required on the first words of the new document. I put it here
							// because this is called for a doc close by any method
	// NOTE: we don't change he values of the four flags associated with glossing, because this
	// function will be called for processes which serially open and close each document of a
	// project, and the flags will have to maintain their values across the calls to ClobberDocument

	// hide and disable the target box until input is expected
	pApp->m_pTargetBox->Hide(); // MFC version calls DestroyWindow() // whm note: SetValue(_T("")) is called above
	pApp->m_pTargetBox->Enable(FALSE);
}

void CAdapt_ItView::CloseProject()
{
	wxCommandEvent dummyevent;
	OnFileCloseProject(dummyevent);
}

void CAdapt_ItView::MakeLineFourString(CSourcePhrase *pSrcPhrase, wxString targetStr)
// targetStr will normally be the contents of the Phrase Box; it could have initial punctuation,
// it may not have, and/or final punctuation, or even in the case of a merger it may have
// medial punctuation, and it could have text starting with lower case and needing to become upper.
// BEW added 20 Apr 2005 checking of the app's flag m_bCopySourcePunctuation - which typically is
// TRUE, but for version 3 we wish to be able to temporarily suppress punctuation copy if the
// user clicks the No Punctuation Copy button on the command bar - so this flag was added to
// support this new functionality. The flag is automatically reset TRUE once the phrase box moves
// to a different location by any method.
{
	// BEW added 19Dec07: bleed out the case when Reviewing mode is on and the box is about to
	// leave a hole which may or may not have had punctuation there; the former m_targetStr is
	// preserved in the global gStrSaveLineFourInReviewingMode, and the test for needing to
	// do this restoration is that the global flag gbSavedLineFourInReviewingMode is TRUE, and
	// we must clear the flag before returning
	if (gbSavedLineFourInReviewingMode)
	{
		// the flag will only be true when the location was a hole when the box landed there, so
		// we can rely on m_targetPhrase being empty provided the user has not decided to edit
		// the document by typing something. So we check for a still empty m_targetPhrase, and if
		// so we restore m_targetStr to what it was before and return; but if the use has typed
		// something then we abandon what we saved and we do a normal pass through the rest of
		// this function
		if (gpApp->m_targetPhrase.IsEmpty())
		{
			// it is still empty, so do the restoration etc.
			pSrcPhrase->m_targetStr = gStrSaveLineFourInReviewingMode;
			gStrSaveLineFourInReviewingMode.Empty();
			gbSavedLineFourInReviewingMode = FALSE; // restore default value
			return;
		}
		// user must have typed something, so clean up and control can fall thru to the rest
		gStrSaveLineFourInReviewingMode.Empty();
		gbSavedLineFourInReviewingMode = FALSE; // restore default value
	}

	wxString str = targetStr; // make a copy
	wxArrayString remainderList;
	wxString strCorresp;	// where we build target punctuation strings (from the punctuation 
							// correspondences pairs) before inserting them into m_targetStr
	strCorresp.Empty();

	// for auto-capitalization we will attempt to do any needed change to upper case, no matter
	// what the punctuation behaviour is. If a lookup was done earlier, and a store not yet done,
	// then the value of the gbMatchedKB_UCentry flag will also be valid here (if it is TRUE then
	// we don't want a change to upper case done because the lookup was done with upper case
	// source data - so we take the adaptation or gloss 'as is')

	// first find out what the key's case status is
	bool bNoError = TRUE;
	bool bWantChangeToUC = FALSE; // if TRUE, we want the change to upper case done if possible
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pSrcPhrase->m_key);
		if (bNoError && gbSourceIsUpperCase && !gbMatchedKB_UCentry)
		{
			bWantChangeToUC = TRUE;
		}
	}

	// if it is <Not In KB> then suppress punctuation insertion - there is nothing supposed
	// to be "there" anyway -- from version 1.4.0 and onwards, by Susanna Imrie's suggestion,
	// we will allow a non-null adaptation for a <not in kb> entry; we just won't store it in
	// the kb -- so just go on...

	// we don't worry about internal punctuation in the target if the target is empty
	// in fact, we don't want any punctuation if the target is empty
	bool bEmptyTarget = FALSE;
	if (!str.IsEmpty() && gpApp->m_bCopySourcePunctuation)
	{
		// check for any medial punctuation, if there is any, see if it is all in
		// the targetStr already; if not, ask user for whatever is missing (if he wants
		// he can then place the extra stuff, or ignore it). We assume that the
		// phrase is not so long that the same punctuation will occur medially twice, if
		// it does, our algorithm will not ensure each instance is there; so to be sure, the
		// user should type what he wants in the Phrase Box in the first place.
		if (pSrcPhrase->m_bHasInternalPunct)
		{
			wxString punct;
			bool bFoundAll = TRUE;
			wxArrayString* pList = pSrcPhrase->m_pMedialPuncts; // the CSourcePhrase might contain
															  // a phrase or a word
			int count = pList->GetCount();

			for ( int n = 0; n < count; n++ )
			{
				punct = pList->Item(n); // can be several punct characters in the
											 // stored string
				wxASSERT(!punct.IsEmpty());
				strCorresp = GetConvertedPunct(punct); // uses PUNCTPAIRS and TWOPUNCTPAIRS
													   // for converting

				// the new syntax no longer checks if some are already typed, it just assumes
				// none are
				remainderList.Add(strCorresp);//remainderList.AddTail(strCorresp);
				bFoundAll = FALSE;
			}

			if (!bFoundAll)
			{
				// put them all in interactively using a dialog (formerly, the dialog showed
				// only the ones not typed)
				gpRemainderList = &remainderList; // set the global so dialog can access it
				CPlaceInternalPunct dlg(wxGetApp().GetMainFrame());
				dlg.Centre();
				dlg.m_pSrcPhrase = pSrcPhrase; // set the dialog's local member
				dlg.ShowModal(); // display the dialog

				// get the result, and fix the source phrase accordingly
				str = dlg.m_tgtPhrase; // remember str could be a phrase, and so contain one
									   // or more spaces
				// anything left in the list can be thrown away now
				gpRemainderList->Clear();
				gpRemainderList = (wxArrayString*)NULL; // the remainderList will be destroyed when it goes out
									    // of scope
				strCorresp.Empty();
			}
		}
	}
	else
	{
		bEmptyTarget = TRUE;
	}

	// BEW addition 23March05, to allow detached punctuation to be reconstructed in the target text
	// I do it here and not for the internal punctuation case above because it would make no sense to
	// do the block of code above when the target is empty
	bool bWantPrevCopy;
	//int len; // unused
	int punctLen;
	if (bEmptyTarget) bEmptyTarget = FALSE;

	// BEW added 20 April 2005 to support the use of the new No Punctuation Copy button
	if (!gpApp->m_bCopySourcePunctuation)
		goto a; // don't restore the TRUE value for this flag at the end of this function because
				// the function can be called more than once while the phrase box is unmoved. Do
				// the flag restoration to TRUE in code which moves the phrase box elsewhere

	// preceding punctuation can be handled silently. If the user typed different punctuation,
	// then the user's must override the original punctuation. The target text string might be a
	// phrase and hence contain spaces, but space is a delimiter in m_punctSet from version 1.3.6
	// onwards, so we must be careful in the next code blocks - SpanIncluding() can still be used
	// safely, because there will be nonpunctuation and nonspace characters prior to any spaces in
	// the phrase; and similarly when reversed
	bWantPrevCopy = FALSE;
	punctLen = 0; // for auto caps support
	if (!bEmptyTarget)
	{
		if (!pSrcPhrase->m_precPunct.IsEmpty())
		{
			// span using target lang's punctuation - wxWidgets version SpanIncluding() in helpers.h
			wxString strInitialPunct = SpanIncluding(str, gpApp->m_punctuation[1]); // span using target

			if (strInitialPunct.IsEmpty())
			{
				// there was no initial punctuation typed, so silently copy original's to the
				// target later on (not here, in case it mucks up the check for following punct)
				bWantPrevCopy = TRUE;
			}
			else
			{
				// let the punctuation typed by the user stand unchanged, but for auto caps ON
				// get the case change done if it is required
				punctLen = strInitialPunct.Length();
			}

			if (bWantChangeToUC)
			{
				// check first that the change to upper case is possible
				wxString noInitialPunctStr = str.Mid(punctLen);
				bNoError = SetCaseParameters(noInitialPunctStr,FALSE);
				if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
				{
					// do the change to upper case
					str.SetChar(punctLen,gcharNonSrcUC);
				}
			}
		}
		// if the word or phrase in the source had no preceding punctuation, then
		// MakeLineFourString will do nothing, so that if the user elects to explicitly type
		// some preceding punctuation, it will be accepted unconditionally

		// ditto, for following punctuation
		if (!pSrcPhrase->m_follPunct.IsEmpty())
		{
			wxString reverse = str;
			reverse = MakeReverse(reverse); // my version of MakeReverse() in helpers.h

			wxString strFollPunct = SpanIncluding(reverse,gpApp->m_punctuation[1]); // span using
													// target lang's punctuation - see helpers.h
			if (strFollPunct.IsEmpty())
			{
				// there was no final punctuation typed, so silently copy original's to the target
				wxString tgtFollPunct;
				tgtFollPunct.Empty();
				tgtFollPunct = GetConvertedPunct(pSrcPhrase->m_follPunct);

				// references in the text like 10:27 give this algorithm problems; the first time
				// the phrasebox is accessed, :27 gets appended to 10, resulting in 10:27 as the
				// target text - correctly; but if the user backtracks to that CSourcePhrase instance
				// later on (by any means), then MakeLineFourString will be called at least two more
				// times, and the next time round the passed in text would be 10:27 to which a
				// further :27 gets added, producing 10:27:27 and then the caller would call
				// RemovePunctuation( ) which is coded in such a way that this "word" would result
				// in 1027 being saved to the KB and the final :27 retained as following punctuation,
				// and that gets added producing 1027:27 - and so it goes on, next we'd get
				// 102727:27, and so on ad infinitum. To break this sequence of errors, we need to
				// do a test for "following punctuation" strings which have already been added
				// to the word, such as "10". So we use the reversed string and also reverse
				// tgtFollPunct and check if the latter is the initial string already - if so,
				// we assume nothing more needs to be done.
				wxString reverseFollPunct = tgtFollPunct;
				reverseFollPunct = MakeReverse(reverseFollPunct);
				int nFind = reverse.Find(reverseFollPunct);
				if (nFind == 0)
				{
					// we have a situation where it looks like the 'following punctuation' has
					// already been added so we'll do nothing
					;
				}
				else
				{
					// looks like it has not been added yet, so do so
					str += tgtFollPunct;
				}
			}
			else
			{
				; // do nothing, let the punctuation typed by the user stand unchanged
			}
		}
		// if the word or phrase in the source had no following punctuation, then
		// MakeLineFourString will do nothing, so that if the user elects to explicitly type
		// some following punctuation, it will be accepted unconditionally

		// add the preceding punctuation, if any
		if (bWantPrevCopy)
		{
			wxString tgtPrecPunct;
			tgtPrecPunct.Empty();
			tgtPrecPunct = GetConvertedPunct(pSrcPhrase->m_precPunct);
			str = tgtPrecPunct + str;
		}
	}

	// now add the final form of the target string to the source phrase
a:	pSrcPhrase->m_targetStr = str;
}

wxString CAdapt_ItView::GetConvertedPunct(const wxString& rStr)
// return the target punctuation string corresponding to input rStr parameter which is a source
// punctuation string this function should work fine without modification, for ANSI or UNICODE
// (UTF-16) builds
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxString s;
	s.Empty();

	if (rStr.IsEmpty())
	{
		return s;
	}

	wxChar ch;
	wxChar doubleCh[2];
	int len = rStr.Length();
	int l;
	bool bFoundDouble;
	int k;
	int i;
	bool bFound;

	for (int j = 0; j < len; j++)
	{
		// first try two-character source punctuation, if no match, then try single-char matching
		bool bMatchedTwo = FALSE;
		k = j;
		++k;
		if (k >= len)
			goto a; // no room for a 2-char match
		doubleCh[0] = rStr.GetChar(j);
		doubleCh[1] = rStr.GetChar(k);
		bFoundDouble = FALSE;
		for (l = 0; l < MAXTWOPUNCTPAIRS; l++)
		{
			wxChar srcChar[2];
			srcChar[0] = pApp->m_twopunctPairs[l].twocharSrc[0];
			if (srcChar[0] == _T('\0'))
				goto a; // this is a null entry, so there is nothing to search for
			srcChar[1] = pApp->m_twopunctPairs[l].twocharSrc[1];
			if (srcChar[1] == _T('\0'))
			{
				if (srcChar[0] == doubleCh[0])
				{
					// we have matched, but the user only specified a single src punct
					bMatchedTwo = TRUE;
					break;
				}
			}
			else
			{
				if (srcChar[0] == doubleCh[0] && srcChar[1] == doubleCh[1])
				{
					// we have matched a 2-char punct pair
					bMatchedTwo = TRUE;
					break;
				}
			}
		}

		if (bMatchedTwo)
		{
			wxChar chMatched[2];
			chMatched[0] = pApp->m_twopunctPairs[l].twocharTgt[0];
			if (chMatched[0] == _T('\0'))
				goto b; // user must want this pair converted to nothing
			chMatched[1] = pApp->m_twopunctPairs[l].twocharTgt[1];
			if (chMatched[1] == _T('\0'))
			{
				// target punct pair is just a single char, so append it
				s += chMatched[0];
			}
			else
			{
				// target punct pair is a pair, so append them both
				s += chMatched[0];
				s += chMatched[1];
			}
			goto b;
		}

		// try match a single char source punctuation
a:		ch = rStr.GetChar(j);

		bFound = FALSE;
		for (i = 0; i < MAXPUNCTPAIRS; i++)
		{
			wxChar srcChar = pApp->m_punctPairs[i].charSrc;
			if (srcChar == ch)
			{
				// matched source char, so get its corresponding target char
				bFound = TRUE;
				break;
			}
		}

		if (!bFound)
		{
			// if not found, copy original character to the converted punct string
			s += ch;
		}
		else
		{
			wxChar chMatched = pApp->m_punctPairs[i].charTgt;
			if (chMatched != (wxChar)0)
			{
				s += chMatched;
			}
		}

b:		if (bMatchedTwo)
			j += 1;
	}

	return s; // if we get here, we got no match, which is an error
}

void CAdapt_ItView::OnEditConsistencyCheck(wxCommandEvent& WXUNUSED(event))
// whm Modified 9Feb2004, to enable consistency checking of currently
// open document or, alternatively, select multiple documents from the
// project to check for consistency. If a document is open when call is
// made to this routine, the consistency check is completed and the user
// can continue working from the same position in the open document.
{
	// the 'accepted' list holds the document filenames to be used
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	pApp->m_acceptedFilesList.Clear(); //pApp->m_acceptedFilesList.RemoveAll();
	CAdapt_ItDoc* pDoc = GetDocument();
	if (pDoc == NULL)
	{
		wxMessageBox(_T(
"GetDocument() call returned a null pointer in OnEditConsistencyCheck(), so command was aborted."),
						_T(""), wxICON_EXCLAMATION);
		return;
	}

	// BEW added 01Aug06 Support for Book Mode was absent in 3.2.1 and earlier, but it is
	// now added here & below. For Book Mode, not all Bible book folders will be scanned,
	// instead, the check is done on the current doc, or on all the docs in the single current
	// book folder. To check other book folders, the user must first change to one, and then
	// the same two options will be available there.
	wxString dirPath;
	if (gpApp->m_bBookMode && !gpApp->m_bDisableBookMode)
		dirPath = gpApp->m_bibleBooksFolderPath;
	else
		dirPath = gpApp->m_curAdaptionsPath;
	bool bOK = ::wxSetWorkingDirectory(dirPath); // ignore failures

	// BEW added 05Jan07 to enable work folder on input to be restored when done
	wxString strSaveCurrentDirectoryFullPath = dirPath;

	// Determine if a document is currently open with data to check
	if (!pApp->m_pSourcePhrases->GetCount() == 0)
	{
		// A document is open with data to check, therefore see if
		// user wants to only check the open document or to select
		// from a list of all documents in the current project to be
		// checked.
		// Save current path and doc name for use in re-opening below
		wxString pathName = pApp->m_curOutputPath;
		wxString docName = pApp->m_curOutputFilename;

		// Save the phrase box's current position in the file
		int currentPosition = pApp->m_nActiveSequNum;

		// Put up the Choose Consistency Check Type dialog
		CChooseConsistencyCheckTypeDlg ccDlg(pApp->GetMainFrame());
		if (ccDlg.ShowModal() == wxID_OK) 
		{
			// handle user's choice of consistency check type
			if (ccDlg.m_bCheckOpenDocOnly)
			{
				// user want's to check only the currently open doc...

				// Save the Doc (and DoFileSave() also automatically saves, without backup, both
				// the glossing and adapting KBs)
				bool fsOK = pDoc->DoFileSave();
				if (!fsOK)
				{
					// something's real wrong!
					wxMessageBox(_(
					"Could not save the current document. Consistency Check Command aborted."),
						_T(""), wxICON_EXCLAMATION);
					// whm note 5Dec06: Since EnumerateDocFiles has not yet been called the current working
					// directory has not changed, so no need here to reset it before return.
					return;
				}

				// BEW added 01Aug06, ensure the current document's contents are removed, otherwise we
				// will get a doubling of the doc data when OnOpenDocument() is called because the latter
				// will append to whatever is in m_pSourcePhrases, so the latter list must be cleared to
				// avoid the data doubling bug
				ClobberDocument();

				// Ensure that our current document is the only doc in the accepted files list
				pApp->m_acceptedFilesList.Clear();
				pApp->m_acceptedFilesList.Add(docName);

				// do the consistency check on the doc
				DoConsistencyCheck(pApp,pDoc);
				pApp->m_acceptedFilesList.Clear();
			}
			else
			{
				// User wants to check a selection of docs in current project.
				// This is like the multi-document type consistency check, except
				// that, in this case, there is a currenly open document.

				// BEW changed 01Aug06 Save the current doc and then clear out its contents -- see
				// block above for explanation of why this is necessary
				bool fsOK = pDoc->DoFileSave();
				if (!fsOK)
				{
					// something's real wrong!
					wxMessageBox(_(
					"Could not save the current document. Consistency Check Command aborted."),
						_T(""), wxICON_EXCLAMATION);
					// whm note 5Dec06: Since EnumerateDocFiles has not yet been called the current working
					// directory has not changed, so no need here to reset it before return.
					return;
				}
				ClobberDocument();

				// Enumerate the doc files and do the consistency check
				// whm note: EnumerateDocFiles() has the side effect of changing the current work directory
				// to the passed in dirPath.
				bOK = pApp->EnumerateDocFiles(pDoc, dirPath);
				if (bOK)
				{
					if (pApp->m_acceptedFilesList.GetCount() == 0)
					{
						// nothing to work on, so abort the operation
						// IDS_NO_DOCUMENTS_YET
						wxMessageBox(_("Sorry, there are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."),_T(""),wxICON_EXCLAMATION);
						// whm note 5Dec06: EnumerateDocFiles above changes the current work directory, so
						// to be safe I'll reset it here before the consistency check returns to what it 
						// was on entry (the line below was not added in MFC version).
						bool bOK;
						bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
						return;
					}
					DoConsistencyCheck(pApp,pDoc);
				}
				pApp->m_acceptedFilesList.Clear();
			}
		}
		else
		{
			// user cancelled
			// whm note 5Dec06: Since EnumerateDocFiles has not yet been called the current working
			// directory has not changed, so no need here to reset it before return.
			return;
		}

		// BEW added 05Jan07 to restore the former current working directory
		// to what it was on entry
		bool bOK;
		bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);

		// Re-Open the CurrentDocName to continue editing at the point where
		// the phrase box was at closure
		bool bOpenOK;
		bOpenOK = pDoc->OnOpenDocument(pathName);
		pDoc->SetFilename(pathName,TRUE);
		// Return the phrase box to the active sequence number; but if the box is not
		// in existence because the user got to the end of the document and invoked the
		// test from there, then reset to the initial position
		if (currentPosition == -1)
			currentPosition = 0;
		CPile* pPile = GetPile(currentPosition);
		Jump(pApp,pPile->m_pSrcPhrase);

	}// end of if document is open with data to check
	else
	{
		// No document open. User selected Consistency Check intending to check
		// a selection of documents in the current project
		// whm note: EnumerateDocFiles() has the side effect of changing the current work directory
		// to the passed in dirPath.
		bOK = pApp->EnumerateDocFiles(pDoc, dirPath);
		if (bOK)
		{
			if (pApp->m_acceptedFilesList.GetCount() == 0)
			{
				// nothing to work on, so abort the operation
				//IDS_NO_DOCUMENTS_YET
				wxMessageBox(_("Sorry, there are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."),_T(""),wxICON_EXCLAMATION);
				// whm note 5Dec06: EnumerateDocFiles above changes the current work directory, so
				// to be safe I'll reset it here before the consistency check returns to what it 
				// was on entry (the line below was not added in MFC version).
				bool bOK;
				bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
				return;
			}
			DoConsistencyCheck(pApp,pDoc);
		}
		pApp->m_acceptedFilesList.Clear();
		
		// BEW added 05Jan07 to restore the former current working directory
		// to what it was on entry
		bool bOK;
		bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
	}
}

void CAdapt_ItView::DoConsistencyCheck(CAdapt_ItApp* pApp, CAdapt_ItDoc* pDoc)
// this function assumes that the current directory will have already been set correctly
// before being called. Modified, July 2003, for support of Auto Capitalization
{
	gbConsistencyCheckCurrent = TRUE; // turn on Flag to inhibit placement of phrase box
									  // initially when OnOpenDocument() is called

	wxASSERT(pApp != NULL);
	wxASSERT(pDoc != NULL);
	CKB* pKB;
	wxArrayString* pList = &pApp->m_acceptedFilesList;
	if (gbIsGlossing)
		pKB = pApp->m_pGlossingKB;
	else
		pKB = pApp->m_pKB;
	wxASSERT(pKB != NULL);
	int nCount = pList->GetCount();
	if (nCount <= 0)
	{
		// something is real wrong, but this should never happen so an English message will suffice
		wxString error;
		error = error.Format(_T("Error, the file count was found to be %d, so the command was aborted."),
																						nCount);
		wxMessageBox(error,_T(""), wxICON_WARNING);
		gbConsistencyCheckCurrent = FALSE;
		return;
	}
	wxASSERT(nCount > 0);
	if (pDoc == NULL)
	{
		wxMessageBox(_T(
"GetDocument() call returned a null pointer in DoConsistencyCheck(), so command was aborted."),
						_T(""), wxICON_EXCLAMATION);
		gbConsistencyCheckCurrent = FALSE;
		return;
	}
	int nTotal = 0;
	int nCumulativeTotal = 0;

	// create a list to hold pointers to auto-fix records, if user checks the auto fix checkbox
	// in the dlg
	AFList afList;

	// create a copy of the KB, we check the copy for inconsistencies, but do updating within
	// the current KB pointed to by the app's m_pKB pointer, or m_pGlossingKB when glossing
	CKB* pKBCopy = new CKB(); // can't use a copy constructor, due to C++ bug
	pKBCopy->Copy(*pKB);  // this is a work-around for the C++ bug - see KB.h for an explanation

	// iterate over the document files
	bool bUserCancelled = FALSE; // whm note: Caution: This bUserCancelled overrides the scope of the extern global of the same name
	int i;
	for (i=0; i < nCount; i++)
	{
		wxString newName = pList->Item(i);
		wxASSERT(!newName.IsEmpty());

		// for debugging- check pile count before & after (failure to close doc before calling
		// this function resulted in the following OnOpenDocument() call appending a copy of the
		// document's contents to itself -- the fix is to ensure OnFileClose() is done in the caller
		// before DoConsistencyCheck() is called
		// int piles = gpApp->m_pSourcePhrases->GetCount();

		bool bOK;
		bOK = pDoc->OnOpenDocument(newName);
		pDoc->SetFilename(newName,TRUE);

		nTotal = gpApp->m_pSourcePhrases->GetCount();
		if (nTotal == 0)
		{
			wxString str;
			str = str.Format(_T("Bad file:  %s"),newName.c_str());
			wxMessageBox(str,_T(""),wxICON_WARNING);
			//wxExit(); //AfxAbort();
		}
		nCumulativeTotal += nTotal;
		// TRACE2("File:   %s    Num Src Phrases  %d\n", newName, nTotal);

		// put up a progress indicator

#ifdef __WXMSW__
		wxString progMsg = _("%s  - %d of %d Total words and phrases");
		wxString msgDisplayed = progMsg.Format(progMsg,newName.c_str(),1,nTotal);
		wxProgressDialog progDlg(_("Consistency Checking"),
                        msgDisplayed,
                        nTotal,    // range
                        gpApp->GetMainFrame(),   // parent
                        //wxPD_CAN_ABORT |
                        //wxPD_CAN_SKIP |
                        wxPD_APP_MODAL |
                        // wxPD_AUTO_HIDE | -- try this as well
                        wxPD_ELAPSED_TIME |
                        wxPD_ESTIMATED_TIME |
                        wxPD_REMAINING_TIME
                        | wxPD_SMOOTH // - makes indeterminate mode bar on WinXP very small
                        );
#else
	// wxProgressDialog tends to hang on wxGTK so I'll just use the simpler CWaitDlg
	// notification on wxGTK and wxMAC
	// put up a Wait dialog - otherwise nothing visible will happen until the operation is done
	CWaitDlg waitDlg(gpApp->GetMainFrame());
	// indicate we want the reading file wait message
	waitDlg.m_nWaitMsgNum = 5;	// 5 hides the static leaving only "Please wait..." in title bar
	waitDlg.Centre();
	waitDlg.Show(TRUE);
	waitDlg.Update();
	// the wait dialog is automatically destroyed when it goes out of scope below.
#endif

		SPList* pPhrases = gpApp->m_pSourcePhrases;
		SPList::Node* pos1; 
		pos1 = pPhrases->GetFirst();
		wxASSERT(pos1 != NULL);
		int counter = 0;
		while (pos1 != NULL)
		{
			CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetNext();
			counter++;

			// check the KBCopy has the required association of key with translation
			int nWords;
			if (gbIsGlossing)
				nWords = 1;
			else
				nWords = pSrcPhrase->m_nSrcWords;
			CTargetUnit* pTU = NULL;
			bool bOK = TRUE;
			bool bFoundTgtUnit = TRUE;
			bool bFoundRefString = TRUE;

			// any inconsistency with a <Not In KB> entry can be fixed automatically,
			// and this block must be ignored when glossing is ON
			if (!gbIsGlossing && !pSrcPhrase->m_bRetranslation && pSrcPhrase->m_bNotInKB &&
															!pSrcPhrase->m_bHasKBEntry)
			{
				wxString str = _T("<Not In KB>");
				// do the lookup
				bOK = AutoCapsLookup(pKBCopy->m_pMap[nWords-1], pTU, pSrcPhrase->m_key);
				if (!bOK)
				{
					// fix it silently
					gpApp->m_bSaveToKB = TRUE; // ensure it gets stored
					StoreText(pKB,pSrcPhrase,str); // don't want punctuation in KB
					pSrcPhrase->m_bHasKBEntry = FALSE;
					pSrcPhrase->m_bNotInKB = TRUE;
				}
			}

			bool bTheTest = FALSE;
			// define the test's value
			if (gbIsGlossing)
			{
				if (pSrcPhrase->m_bHasGlossingKBEntry)
				{
					bTheTest = TRUE;
				}
			}
			else // adapting
			{
				if (!pSrcPhrase->m_bRetranslation && !pSrcPhrase->m_bNotInKB &&
						pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_adaption != _T("<Not In KB>"))
				{
					bTheTest = TRUE;
				}
			}
			if (bTheTest)
			{
				// do the lookup
				bOK = AutoCapsLookup(pKBCopy->m_pMap[nWords-1], pTU, pSrcPhrase->m_key);
				if (!bOK)
				{
					// there was no target unit for this key in the map, so this is an
					// inconsistency
					bFoundTgtUnit = FALSE;
					bFoundRefString = FALSE;
				}
				else
				{
					// the target unit is in the map, so check if there is a corresponding
					// refString for the m_adaption, or m_gloss, member of the source phrase
					wxASSERT(pTU);
					bool bMatched = FALSE;
					TranslationsList* pList = pTU->m_pTranslations; 
					wxASSERT(pList != NULL);
					wxASSERT(pList->GetCount() > 0); // a target unit with no refStrings is illegal
					wxString srcPhraseStr;
					if (gbIsGlossing)
					{
						srcPhraseStr = pSrcPhrase->m_gloss;
					}
					else
					{
						srcPhraseStr = pSrcPhrase->m_adaption;
					}
					if (!((gbAutoCaps && gbSourceIsUpperCase && gbMatchedKB_UCentry) || !gbAutoCaps))
					{
						// do a change to lc only if it is needed - that is, attempt it when it is
						// not the case that gbMatchedKB_UCentry is TRUE (because then we want
						// an unmodified string to be used), otherwise attempt it when auto-caps is ON
						srcPhraseStr = AutoCapsMakeStorageString(srcPhraseStr,FALSE);
					}
					TranslationsList::Node* pos = pList->GetFirst();
					wxASSERT(pos != NULL);
					while (pos != NULL)
					{
						CRefString* pRefString = (CRefString*)pos->GetData();
						pos = pos->GetNext();
						wxASSERT(pRefString != NULL);
						if (pRefString->m_translation == srcPhraseStr)
						{
							// a matching gloss was found
							bMatched = TRUE;
							break;
						}
					}
					if (!bMatched)
					{
						// no match was made, so this is an inconsistency
						bFoundRefString = FALSE;
					}
				}
			}

			// open the dialog if we have an inconsistency
			if (!bFoundTgtUnit || !bFoundRefString)
			{
				// make the source phrase able to have a KB entry added
				if (gbIsGlossing)
					pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
				else
					pSrcPhrase->m_bHasKBEntry = FALSE;

#ifdef __WXMSW__
				// hide the progress window
				progDlg.Hide(); 
#endif

				// work out if this is an auto-fix item, if so, don't show the dialog, but use the
				// stored AutoFixRecord to fix the inconsistency without user intervention (note:
				// any items for which the "Ignore it, I will fix it later" button was pressed
				// cannot occur as auto-fix records) The next 100 lines could be improved - it was
				// "added to" in a rather ad hoc fashion, so its a bit spagetti-like... something
				// to do sometime when there is plenty of time!
				AutoFixRecord* pAFRecord = NULL;
				if (MatchAutoFixItem(&afList, pSrcPhrase, pAFRecord))
				{
					// we matched an auto-fix element, so do the fix automatically...
					// update the original kb (not pKBCopy)
					wxString tempStr = pAFRecord->finalAdaptation; // could have punctuation in it

					// if the adaptation is null, then assume user wants it that way and so store
					// an empty string
					if (tempStr.IsEmpty())
					{
						StoreText(pKB,pSrcPhrase,tempStr,TRUE); // TRUE = suppress the
																// (now relic) dialog
					}
					else
					{
						if (!gbIsGlossing)
						{
							RemovePunctuation(pDoc,&tempStr,1 /*from tgt*/); // don't want
							// punctuation in adaptation KB
							// if autocapitalization is ON, we could have an upper case source, but
							// the user may have typed lower case for fixing the gloss or adaptation,
							// but this is okay - the store will work right, so don't need anything
							// here except the call to store it
							StoreText(pKB,pSrcPhrase,tempStr);
						}
						// do the gbIsGlossing case when no punct is to be removed, in next block
					}
					// BEW removed next line, 16May08, as the changes made at this time no longer
					// cause pAFRecord->finalAdaptation to be made to have an initial upper case letter
					//wxString oldFinalOne = pAFRecord->finalAdaptation;
					if (!tempStr.IsEmpty())
					{
						// here we must be careful; pAFRecord->finalAdaptation may have a lower
						// case string when the source text has upper case, and the user is
						// expecting the application to do the fix for him; this would be easy if
						// we could be sure that the first letter of the string was at index == 0,
						// but the possible presence of preceding punctuation makes the assumption
						// dangerous - so we must find where the actual text starts and do any
						// changes there if needed.
						// tempStr has punctuation stripped out, pAFRecord->finalAdaptation doesn't
						// so start by determining if there actually is a problem to be fixed.
						if (gbAutoCaps)
						{
							bool bNoError = SetCaseParameters(pSrcPhrase->m_key);
							if (bNoError && gbSourceIsUpperCase)
							{
								bNoError = SetCaseParameters(tempStr,FALSE); // FALSE means "it's target text"
								if (bNoError && !gbNonSourceIsUpperCase &&
																(gcharNonSrcUC != _T('\0')))
								{
									// source is upper case but nonsource is lower and is a
									// character with an upper case equivalent - we have a problem:
									// we need to fix the AutoFixRecord's finalAdaptation string,
									// and the sourcephrase too. At this point we can fix the
									// m_adaption member as follows:
									pSrcPhrase->m_adaption.SetChar(0,gcharNonSrcUC);

									// to fix the m_targetStr and pAFRecord->finalAdaptation
									// strings, we have to be a bit more clever. Search these for
									// the first instance of the lowercase character, get its index
									// and use that to overwrite with the upper case one
									// BEW removed next four lines, 16May08, because their logic is
									// wrong (MakeLineFourString() below will do what we need for
									// the pSrcPhrase->m_targetStr member, and we don't want to EVER
									// change the AutoFixRecord's finalAdaptation CString's initial
									// character to upper case; we should only do that on a local
									// copy for when the document at the current location has source
									// text beginning with upper case. Also offset was omitted as the
									// return variable for the second line of code below, so the change
									// to upper case has never been done by this code anyway!
									//int offset = -1;
									//pAFRecord->finalAdaptation.Find(gcharNonSrcLC);
									//ASSERT(offset >= 0);
									//pAFRecord->finalAdaptation.SetAt(offset,gcharNonSrcUC);
								}
							}
						}
						// In the next if/else block, the non-glossing-mode call of MakeLineFourString()
						// accomplishes the setting of the pSrcPhrase's m_targetStr member, handling
						// any needed lower case to upper case conversion (even when typed initial
						// punctuation is present), and the punctuation override protocol if the passed
						// in string in the 2nd parameter has initial and/or final punctuation. The else
						if (!gbIsGlossing)
						{
							// for auto capitalization support, MakeLineFourString( ) is now
							// able to do any needed change to upper case initial letter even
							// when there is initial punctuation on pAFRecord->finalAdaptation
							MakeLineFourString(pSrcPhrase,pAFRecord->finalAdaptation);
						}
						else
						{
							// store, for the glossing ON case, the gloss text, with any punctuation
							StoreText(pKB,pSrcPhrase,pAFRecord->finalAdaptation);
							if (gbAutoCaps)
							{
								// if Auto Caps is on, gloss text can be auto capitalized too - so
								// attempt this (use code from MakeLineFourString())...

								// upper case may be wanted, we have to do it on the first character
								// past any initial punctuation; glossing mode doesn't do punctuation
								// stripping and copying, but the user may have punctuation included in
								// the inconsistency fixing string, so we have to check etc.
								wxString str = pAFRecord->finalAdaptation;
								// make a copy and remove punctuation from it
								wxString str_nopunct = str;
								RemovePunctuation(pDoc,&str_nopunct,1); // 1 means from tgt
								// use the punctuation-less string to get the initial charact and
								// its upper case equivalent if it exists
								bool bNoError = SetCaseParameters(str_nopunct,FALSE); // FALSE means "using target punct list"
								// span punctuation-having str using target lang's punctuation...
								wxString strInitialPunct = SpanIncluding(str,gpApp->m_punctuation[1]); // use our own SpanIncluding in helpers
								int punctLen = strInitialPunct.Length();

								// work out if there is a case change needed, and set the relevant case globals
								bNoError = SetCaseParameters(tempStr,FALSE); // FALSE means "it's target text"
								if (bNoError && gbSourceIsUpperCase && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
								{
									if (strInitialPunct.IsEmpty())
									{
										// there is no initial punctuation, so the change to upper case
										// can be done at the string's start
										pSrcPhrase->m_gloss.SetChar(0,gcharNonSrcUC);
									}
									else
									{
										// set it at the first character past the initial punctuation
										str.SetChar(punctLen,gcharNonSrcUC);
										pSrcPhrase->m_gloss = str;
									}
								}
							}
							else
							{
								// no auto capitalization, so just use finalAdaptation string 'as is'
								pSrcPhrase->m_gloss = pAFRecord->finalAdaptation;
							}
						}
					}
					gpApp->m_targetPhrase = pAFRecord->finalAdaptation; // any brief glimpse of box
											// should show the current adaptation, or gloss, string
#ifdef __WXMSW__
					// show the progress window again
					progDlg.Show(TRUE); 
					//prog.Update(); //prog.UpdateWindow(); // needed, otherwise window's stat text items don't show
#endif
				}
				else
				{
					// no match, so this is has to be handled with user intervention via the dialog
					CConsistencyCheckDlg dlg(gpApp->GetMainFrame());
					dlg.m_bFoundTgtUnit = bFoundTgtUnit;
					dlg.m_bDoAutoFix = FALSE;
					dlg.m_pApp = pApp;
					dlg.m_pKBCopy = pKBCopy;
					dlg.m_pTgtUnit = pTU; // could be null
					dlg.m_finalAdaptation.Empty(); // initialize final chosen adaptation or gloss
					dlg.m_pSrcPhrase = pSrcPhrase;

					// update the view to show the location where this source pile is, and put the
					// phrase box there ready to accept user input indirectly from the dialog
					int nActiveSequNum = pSrcPhrase->m_nSequNumber;
					wxASSERT(nActiveSequNum >= 0);
					gpApp->m_pActivePile = AdvanceBundle(nActiveSequNum); // also computes
																   // m_ptCurBoxLocation
					gpApp->m_pTargetBox->m_pActivePile = gpApp->m_pActivePile; // put copy on phrase box
					gpApp->GetMainFrame()->canvas->ScrollIntoView(nActiveSequNum);
					CCell* pCell = gpApp->m_pActivePile->m_pCell[2]; // the cell where the phraseBox
															  // is to be
					if (gbIsGlossing)
						gpApp->m_targetPhrase = pSrcPhrase->m_gloss;
					else
						// make it look normal, don't use m_targetStr here
						gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
					ReDoPhraseBox(pCell);
					Invalidate();

					// get the chapter and verse
					wxString chVerse = GetChapterAndVerse(pSrcPhrase);
					dlg.m_chVerse = chVerse;

					// provide hooks for the phrase box location so that the dialog can work out
					// where to display itself so it does not obscure the active location
					dlg.m_ptBoxTopLeft = gpApp->m_ptCurBoxLocation; // logical coords
					dlg.m_nTwoLineDepth = 2 * gpApp->m_nTgtHeight;
					if (gbIsGlossing)
					{
						// really its three lines, but the code works provided the height is right
						if (gbGlossingUsesNavFont)
							dlg.m_nTwoLineDepth += gpApp->m_nNavTextHeight;
						else
							dlg.m_nTwoLineDepth += gpApp->m_nTgtHeight;
					}

					// put up the dialog
					if (dlg.ShowModal() == wxID_OK)
					{
						//bool bNoError;
						wxString finalStr;
						// if the m_bDoAutoFix flag is set, add this 'fix' to a list for
						// subsequent use
						AutoFixRecord* pRec;
						if (dlg.m_bDoAutoFix)
						{
							if (gbIgnoreIt)
								// disallow record creation for a press of the "Ignore it,
								// I will fix it later" button
								goto x;
							pRec = new AutoFixRecord;
							pRec->key = pSrcPhrase->m_key; // case should be as wanted
							if (gbIsGlossing)
							{
								pRec->oldAdaptation = pSrcPhrase->m_gloss; // case as wanted
								pRec->nWords = 1;
							}
							else
							{
								pRec->oldAdaptation = pSrcPhrase->m_adaption; // case as wanted
								pRec->nWords = pSrcPhrase->m_nSrcWords;
							}

							// BEW changed 16May; we don't want to convert the m_finalAdaptation member to
							// upper case in ANY circumstances, so we will comment out the relevant lines
							// here and unilaterally use the user's final string
							finalStr = dlg.m_finalAdaptation; // can have punctuation
									// in it, or can be null; can also be lower case and user
									// expects the app to switch it to upper case if source is upper
							/* BEW removed 16May08, see above
							if (gbAutoCaps)
							{
								bNoError = SetCaseParameters(pRec->key);
								if (bNoError && gbSourceIsUpperCase)
								{
									bNoError = SetCaseParameters(finalStr,FALSE);
									if (bNoError && !gbNonSourceIsUpperCase &&
																	(gcharNonSrcUC != _T('\0')))
									{
										// need to make it start with upper case
										finalStr.SetChar(0,gcharNonSrcUC);
									}
								}
							}
							*/
							pRec->finalAdaptation = finalStr;
							afList.Append(pRec); //afList.AddTail(pRec);
						} // end of block for setting up a new AutoFixRecord

						// update the original kb (not pKBCopy)
x:						finalStr = dlg.m_finalAdaptation; // could have punctuation in it
						// if the adaptation is null, then assume user wants it that way and so store
						// an empty string; but if user wants the inconsistency ignored, then skip
						wxString tempStr = dlg.m_finalAdaptation; // remove punctuation from this one
						RemovePunctuation(pDoc,&tempStr,1); // 1 = removing from tgt text
						if (gbIgnoreIt)
						{
							// if the user hit the "Ignore it, I will fix it later" button,
							// then just put the existing adaptation or gloss back into the KB,
							// after clearing the flag
							if (gbIsGlossing)
							{
								tempStr = pSrcPhrase->m_gloss;
								StoreText(pKB,pSrcPhrase,tempStr,TRUE);
							}
							else // adapting
							{
								tempStr = pSrcPhrase->m_adaption; // no punctuation on this one
								StoreText(pKB,pSrcPhrase,tempStr,TRUE);
								MakeLineFourString(pSrcPhrase,pSrcPhrase->m_targetStr); // m_targetStr may have punct
							}
							gbIgnoreIt = FALSE;
							goto y;
						}
						else
						{
							// don't ignore, so handle the dialog's contents
							if (tempStr.IsEmpty())
							{
								StoreText(pKB,pSrcPhrase,tempStr,TRUE); // TRUE = suppress the (now relic) dialog
							}
							else
							{
								if (!gbIsGlossing)
								{
									StoreText(pKB,pSrcPhrase,tempStr);
								}
								// do the gbIsGlossing case in next block
							}
							// the next stuff is taken from code earlier than the DoModal() call, so comments
							// will not be repeated here - see above if the details are wanted
							if (gbAutoCaps)
							{
								bool bNoError = SetCaseParameters(pSrcPhrase->m_key);
								if (bNoError && gbSourceIsUpperCase)
								{
									bNoError = SetCaseParameters(tempStr,FALSE); // FALSE means "it's target text"
									if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
									{
										pSrcPhrase->m_adaption.SetChar(0,gcharNonSrcUC); // get m_adaption member done
									}
								}
							}
							if (!gbIsGlossing)
							{
								MakeLineFourString(pSrcPhrase,finalStr); // handles auto caps, punctuation, etc
							}
							else // we are in glossing mode
							{
								StoreText(pKB,pSrcPhrase,finalStr); // glossing store can have punctuation in it
								if (gbAutoCaps)
								{
									// if Auto Caps is on, gloss text can be auto capitalized too... check it out
									wxString str_nopunct = finalStr;
									RemovePunctuation(pDoc,&str_nopunct,1 /*from tgt*/);
									bool bNoError = SetCaseParameters(str_nopunct,FALSE); // FALSE means "using target punct list"
									wxString strInitialPunct = SpanIncluding(finalStr,gpApp->m_punctuation[1]);
									int punctLen = strInitialPunct.Length();
									bNoError = SetCaseParameters(str_nopunct,FALSE); // FALSE means "using target punct list"
									if (bNoError && gbSourceIsUpperCase && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
									{
										if (strInitialPunct.IsEmpty())
										{
											pSrcPhrase->m_gloss.SetChar(0,gcharNonSrcUC);
										}
										else
										{
											finalStr.SetChar(punctLen,gcharNonSrcUC);
											pSrcPhrase->m_gloss = finalStr;
										}
									}
								}
								else
								{
									pSrcPhrase->m_gloss = finalStr;
								}
							} // end of block for glossing mode
						} // end of else block for test: if (gbIgnoreIt)

/*	// BEW removed 16May08, as it was a bit simplistic; copied the earlier code from the AutoFixRecord's
	// way of doing it above, as that is smarter, tweaking it as necessary
						if (gbAutoCaps)
						{
							bNoError = SetCaseParameters(pSrcPhrase->m_key);
							if (bNoError && gbSourceIsUpperCase)
							{
								bNoError = SetCaseParameters(finalStr,FALSE);
								if (bNoError && !gbNonSourceIsUpperCase &&
																(gcharNonSrcUC != _T('\0')))
								{
									// need to make it start with upper case
									finalStr.SetChar(0,gcharNonSrcUC);
								}
							}
						}
						wxString tempStr = finalStr; // could have punctuation in it
						if (!gbIsGlossing)
							RemovePunctuation(pDoc,&tempStr,1); // don't want punctuation in adaptations KB
						if (tempStr.IsEmpty())
						{
							tempStr = _T("");
							StoreText(pKB,pSrcPhrase,tempStr,TRUE); // store null string
						}
						else
						{
							if (gbIgnoreIt)
							{
								// if the user hit the "Ignore it, I will fix it later" button,
								// then just put the existing adaptation or gloss back into the KB,
								// after clearing the flag
								if (gbIsGlossing)
								{
									tempStr = pSrcPhrase->m_gloss;
									StoreText(pKB,pSrcPhrase,tempStr,TRUE);
								}
								else // adapting
								{
									tempStr = pSrcPhrase->m_targetStr;
									StoreText(pKB,pSrcPhrase,tempStr,TRUE);
									MakeLineFourString(pSrcPhrase,tempStr);
								}
								gbIgnoreIt = FALSE;
								goto y;
							}
							// if we get here, then storage in the KB for the fix done to this
							// item is required
							StoreText(pKB,pSrcPhrase,tempStr);
						}
						if (!gbIsGlossing)
							MakeLineFourString(pSrcPhrase,finalStr);
						gpApp->m_targetPhrase = finalStr;
*/
						// show the progress window again
y:						;
#ifdef __WXMSW__
						progDlg.Show(TRUE); //prog.Show(TRUE);
						//prog.Update(); //prog.UpdateWindow(); // needed, otherwise window's stat text items
											 // don't show
#endif
					} // end of TRUE block for test of ShowModal() == wxID_OK
					else
					{
						// user cancelled
						bUserCancelled = TRUE;
#ifdef __WXMSW__
						progDlg.Show(TRUE); //prog.Show(TRUE);
						msgDisplayed = progMsg.Format(progMsg,newName.c_str(),counter,nTotal);
						progDlg.Update(counter,msgDisplayed);
#endif
						break;
					}
				} // end of else block for test of presence of an AutoFixRecord for this inconsistency
			}
#ifdef __WXMSW_
			// update the progress bar every 20th iteration
			if (counter % 1000 == 0) //if (20 * (counter / 20) == counter)
			{
				//prog.m_progress.SetValue(counter);
				//prog.TransferDataToWindow(); //prog.UpdateData(FALSE);
				msgDisplayed = progMsg.Format(progMsg,newName.c_str(),counter,nTotal);
				progDlg.Update(counter,msgDisplayed);
			}
#endif
		}// end of while (pos1 != NULL)

		// save document and KB
		gpApp->m_pTargetBox->Hide(); //MFC calls DestroyWindow(); // this prevents DoFileSave() trying to store to kb with a
									 // source phrase with m_bHasKBEntry flag TRUE, which would
									 // cause an assert to trip
		gpApp->m_pTargetBox->SetValue(_T("")); // need to set it to null str since it won't get recreated
		bool bSavedOK = pDoc->DoFileSave();
		if (!bSavedOK)
		{
			wxMessageBox(_("Warning: failure on document save operation."),_T(""), wxICON_EXCLAMATION);
		}

		ClobberDocument();

		// delete the buffer containing the filed-in source text
		if (gpApp->m_pBuffer != NULL)
		{
			delete gpApp->m_pBuffer;
			gpApp->m_pBuffer = NULL;
		}
#ifdef __WXMSW__
		// remove the progress indicator window
		progDlg.Destroy();
#endif
		if (bUserCancelled)
			break; // don't do any more saves of the KB if user cancelled
	}// end iteration of document files for (int i=0; i < nCount; i++)

	// erase the copied CKB which is no longer needed
	wxASSERT(pKBCopy != NULL);
	pDoc->EraseKB(pKBCopy); // don't want memory leaks!

	// inform user of success and some statistics
	if (!bUserCancelled)
	{
		// put up final statistics, provided user did not cancel from one of the dialogs
		wxString stats;
		// IDS_CONSCHECK_OK
		stats = stats.Format(_("The consistency check was successful. There were %d source words and phrases  in %d  files."),nCumulativeTotal,nCount);
		wxMessageBox(stats,_T(""),wxICON_INFORMATION);
	}

	// make sure the global flag is cleared
	gbConsistencyCheckCurrent = FALSE;

	// delete the contents of the pointer list, the list is local so will go out of scope
	if (!afList.IsEmpty())
	{
		AFList::Node* pos = afList.GetFirst(); //POSITION pos = afList.GetHeadPosition();
		wxASSERT(pos != 0);
		while (pos != 0)
		{
			AutoFixRecord* pRec = (AutoFixRecord*)pos->GetData();
			pos = pos->GetNext();
			delete pRec;
		}
	}
	afList.Clear();
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the application is in Free Translation mode, or Vertical Editing is in progress, or it is 
/// only showing the target language text, or the active KB is not in a ready state, this handler 
/// disables the "Consistency Check..." item in the Edit menu, otherwise it enables the 
/// "Consistency Check..." item on the Edit menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditConsistencyCheck(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItDoc* pDoc = GetDocument();
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (pDoc == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	bool bKBReady = FALSE;
	if (gbIsGlossing)
		bKBReady = pApp->m_bGlossingKBReady;
	else
		bKBReady = pApp->m_bKBReady;
	// Allow Consistency Check... while document is open
	if (bKBReady)// && (pDoc->m_pSourcePhrases->GetCount() == 0))
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::DoFileSaveKB()
{
	wxCommandEvent dummyevent;
	OnFileSaveKB(dummyevent); // protected, so make it accessible
}

void CAdapt_ItView::NewRetranslation()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	if (gbShowTargetOnly)
	{
		::wxBell();
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		::wxBell();
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
		// if there is at least one srcPhrase with m_bRetranslation == TRUE, then disable the
		// button
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData();
			CPile* pPile = pCell->m_pPile;
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;
			if (pSrcPhrase->m_bRetranslation)
			{
				::wxBell(); 
				return;
			}
		}
		OnButtonRetranslation(dummyevent);
		return;
	}
	::wxBell();
}

// *********************************************************************************************
//
// Begin section for OnButtonRetranslation()
//
// Helper functions used in OnButtonRetranslation(); these are (in the order in which they
// get called):
//
// GetSelectedSourcePhraseInstances()
// CopySourcePhraseList()
// RemoveNullSourcePhraseFromLists()
// UnmergeMergersInSublist()
// TokenizeTextString()
// BuildRetranslationSourcePhraseInstances()
// DeleteSavedSrcPhraseSublist()
// PadWithNullSourcePhrasesAtEnd()
// SetActivePilePointerSafely()
// ClearSublistKBEntries()
// InsertSublistAfter()
// RemoveUnwantedSourcePhraseInstancesInRestoredList()
// RestoreTargetBoxText()
//
// ***********************************************************************************************

void CAdapt_ItView::GetSelectedSourcePhraseInstances(SPList*& pList,
													 wxString& strSource, wxString& strAdapt)
// pList is the list of selected CSourcePhrase instances; pSrcPhrases is the full list maintained
// on the app; strSource is the accumulated source text, strAdapt is the accumulated target
// text (both with punctuation). The pList will only contain copies of the pointers to the
// CSourcePhrase instances on the heap.
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxString str; str.Empty();
	wxString str2; str2.Empty();
	CCellList::Node* pos = pApp->m_selection.GetFirst(); 
	CCell* pCell = (CCell*)pos->GetData();
	CPile* pPile = pCell->m_pPile; // get the pile first in selection
	pos = pos->GetNext(); // needed for our CCellList list
	CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;

	pList->Append(pSrcPhrase); // add first to the temporary list
// "GetSelectedSourcePhraseInstances: m_pMedialMarkers %X m_pMedialPuncts %X m_pSavedWords %X\n",
//			pSrcPhrase->m_pMedialMarkers, pSrcPhrase->m_pMedialPuncts, pSrcPhrase->m_pSavedWords); // MFC commented out

	if (pSrcPhrase->m_targetStr.IsEmpty())
	{
		if (pPile == pApp->m_pActivePile)
		{
			str = pApp->m_targetPhrase;
		}
		else
		{
			str.Empty();
		}
	}
	else
	{
		str = pSrcPhrase->m_targetStr;
	}
	strAdapt += str;

	// accumulate the source language key text, provided it is not a null source phrase
	if (!pSrcPhrase->m_bNullSourcePhrase)
		str2 = pSrcPhrase->m_srcPhrase;
	strSource += str2; // accumulate it

	// fill the list, accumulating any translation text already in the selected source phrases
	// and also the original text (with punctuation) which is to be retranslated
	while (pos != NULL)
	{
		// wx note: Caution! The following conversion is tricky so I'll break it up into parts
		//pPile = ((CCell*)m_selection.GetNext(pos))->m_pPile;
		CCell* pCell = (CCell*)pos->GetData();
		pPile = pCell->m_pPile;
		pos = pos->GetNext(); // needed for our list
		pSrcPhrase = pPile->m_pSrcPhrase;
//"GetSelectedSourcePhraseInstances: m_pMedialMarkers %X m_pMedialPuncts %X m_pSavedWords %X\n",
//			pSrcPhrase->m_pMedialMarkers, pSrcPhrase->m_pMedialPuncts, pSrcPhrase->m_pSavedWords);
		wxASSERT(pSrcPhrase);
		pList->Append(pSrcPhrase);

		// accumulate any adaptation
		if (pSrcPhrase->m_targetStr.IsEmpty())
		{
			if (pPile == pApp->m_pActivePile)
			{
				str = pApp->m_targetPhrase;
			}
			else
			{
				str.Empty();
			}
		}
		else
		{
			str = pSrcPhrase->m_targetStr;
		}

		if (strAdapt.IsEmpty())
			strAdapt += str;
		else
		{
			if (!str.IsEmpty())
				strAdapt = strAdapt + _T(" ") + str;
		}

		// accumulate the source language text, provided it is not a null source phrase
		if (!pSrcPhrase->m_bNullSourcePhrase)
			str2 = pSrcPhrase->m_srcPhrase;
		else
			str2.Empty();
		if (strSource.IsEmpty())
			strSource += str2;
		else
			strSource = strSource + _T(" ") + str2; // space before a marker will -> CR+LF
													// on Export...
	}
}

// BEW modified 16Apr08 to enable it to optionally do a deep copy
void CAdapt_ItView::CopySourcePhraseList(SPList*& pList,SPList*& pCopiedList,bool bDoDeepCopy)
// pList is the list to be copied, pCopiedList contains the copies
{
	SPList::Node* pos = pList->GetFirst(); //POSITION pos = pList->GetHeadPosition(); // original list
	while (pos != NULL)
	{
		CSourcePhrase* pElement = (CSourcePhrase*)pos->GetData(); // original source phrase
		pos = pos->GetNext();// needed for our list
		CSourcePhrase* pNewSrcPhrase = new CSourcePhrase(*pElement); // uses operator=
		wxASSERT(pNewSrcPhrase != NULL);
//		TRACE3("CopySourcePhraseList: m_pMedialMarkers %X m_pMedialPuncts %X m_pSavedWords %X\n",
//			pNewSrcPhrase->m_pMedialMarkers, pNewSrcPhrase->m_pMedialPuncts, 
//			pNewSrcPhrase->m_pSavedWords);
		if (bDoDeepCopy)
		{
			pNewSrcPhrase->DeepCopy();
		}
		pCopiedList->Append(pNewSrcPhrase); 
	}
	// Note: the default is a shallow copy; any heap instances of CSourcePhrases which are pointed at
	// by elements in the m_pSavedWords list in pList, are also pointed at by the copies of elements
	// in the m_pSavedWords list of CSourcePhrase instances in pCopiedList. This has implications when
	// destroying such a copied list. For a true deep copy of a list of CSourcePhrase instances, the 
	// bDoDeepCopy flag must be TRUE. A deep copy produces a copied list, pCopiedList, in which everything
	// is a duplicate of what was in the original list, and hence every original CSourcePhrase of a merger
	// is pointed at by a CSourcePhrase in only one of the pList and pCopiedList lists.
}

// BEW added 16Apr08; pList is a passed in list of CSourcePhrase pointers, such as m_pSourcePhrases;
// parameters two and three define which part of the passed in list is used for doing the deep copies,
// and the pCopiedSublist passes the sublist back to the caller. Normally pCopiedSublist will be empty
// when passed in, but it does not have to be. Internally AddTail() is used, and so the function can
// also be used to append deep copies to an existing sublist of deep copies (but I've no plans to do the
// latter, at least none yet).
// returns TRUE if there was no error, FALSE if there was an error
bool CAdapt_ItView::DeepCopySourcePhraseSublist(SPList* pList,int nStartingSequNum, int nEndingSequNum,
						SPList* pCopiedSublist)
{
	wxString errStr;
	// it is the caller's responsibility to ensure that nStartingSequNum and nEndingSequNum are valid
	// indexes into the pList list
	SPList::Node* pos = pList->Item(nStartingSequNum); //POSITION pos = pList->FindIndex(nStartingSequNum);
	if (pos == NULL)
	{
		// error condition exists
		// whm Note: Leave these error strings untranslated; not for localization
		errStr = _T("DeepCopySourcePhraseSublist() returned NULL for POSITION pos on .FindIndex() call. Saving document. ");
		errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
		wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	SPList::Node* endpos = pList->Item(nEndingSequNum); //POSITION endpos = pList->FindIndex(nEndingSequNum);
	if (endpos == NULL)
	{
		// error condition exists
		errStr = _T("DeepCopySourcePhraseSublist() returned NULL for POSITION endpos on .FindIndex() call. Saving document. ");
		errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
		wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	
	SPList::Node* savePos = NULL; // POSITION savePos = NULL;
	CSourcePhrase* pSrcPhrase = NULL;
	while (pos != NULL)
	{
		savePos = pos;
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		// whm TODO: Check that the CSourcePhrase(*pSrcPhrase) call below actually does use operator=
		// shallow copy in wx version. Probably wouldn't make any difference in this case since DeepCopy()
		// is called on pNewSP immediately after creation of pNewSP.
		CSourcePhrase* pNewSP = new CSourcePhrase(*pSrcPhrase); // uses operator=, does shallow copy
		pNewSP->DeepCopy(); // pNewSP is now a deep copy
		pCopiedSublist->Append(pNewSP);
		if (savePos == endpos)
		{
			// we have just added the final deep copy to pCopiedSublist, so break out
			break;
		}
	}
	return TRUE;
}

void CAdapt_ItView::RemoveNullSrcPhraseFromLists(SPList*& pList,SPList*& pSrcPhrases,
												 int& endIndex,int& upperIndex,int& maxIndex,
												 int& nCount,int& nEndSequNum,
												 bool bActiveLocAfterSelection,
												 int& nSaveActiveSequNum)
// pList is the sublist of (formerly) selected source phrase instances, pSrcPhrases is the
// document's list (the whole lot), endIndex upperIndex, maxIndex are references to member
// indices on the view, nCount is the count of elements in pList (it will be reduced as each
// null source phrase is eliminated), bActiveLocAfterSelection is a flag in the caller,
// nSaveActiveSequNum is the caller's saved value for the active sequence number
{
	// find the null source phrase in the sublist
	CRefString* pRefString = 0;
	SPList::Node* pos = pList->GetFirst();
	while (pos != NULL)
	{
		SPList::Node* savePos = pos;
		CSourcePhrase* pSrcPhraseCopy = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext(); 
		wxASSERT(pSrcPhraseCopy != NULL);
		if (pSrcPhraseCopy->m_bNullSourcePhrase)
		{
			// we've found a null source phrase in the sublist, so get rid of its KB presence, then
			// delete it from the (temporary) sublist, and its instance from the heap
			pRefString = GetRefString(GetKB(),pSrcPhraseCopy->m_nSrcWords,
												pSrcPhraseCopy->m_key,pSrcPhraseCopy->m_adaption);
			if (pRefString != NULL)
			{
				// don't care about m_bHasKBEntry flag value, since pSrcPhraseCopy will be
				// deleted next
				RemoveRefString(pRefString,pSrcPhraseCopy,pSrcPhraseCopy->m_nSrcWords);
			}
			delete pSrcPhraseCopy;
			pSrcPhraseCopy = (CSourcePhrase*)NULL;
			pList->DeleteNode(savePos); 

			// the main list on the app still stores the (now hanging) pointer, so find where it is
			// and remove it from that list too
			SPList::Node* mainPos = pSrcPhrases->GetFirst();
			wxASSERT(mainPos != 0);
			mainPos = pSrcPhrases->Find(pSrcPhraseCopy); // search from the beginning
			wxASSERT(mainPos != NULL); // it must be there somewhere
			pSrcPhrases->DeleteNode(mainPos); 

			// fix the indices for the bundle
			endIndex -= 1;
			upperIndex -= 1;
			maxIndex -= 1;
			nCount -= 1; // since there is one less source phrase in the selection now
			nEndSequNum -= 1;
			if (bActiveLocAfterSelection)
				nSaveActiveSequNum -= 1;

			// now we have to renumber the source phrases' sequence number values - since the temp
			// sublist list has pointer copies, we need only do this in the main list using a call
			// to UpdateSequNumbers, and so the value of nSaveSequNum will still be correct for the
			// first element in the sublist - even if there were deletions at the start of the
			// sublist
			UpdateSequNumbers(0); // start from the very first in the list to be safe
		}
	}
}

void CAdapt_ItView::UnmergeMergersInSublist(SPList*& pList,SPList*& pSrcPhrases,int& WXUNUSED(endIndex),
											int& WXUNUSED(upperIndex),int& WXUNUSED(maxIndex),int& nCount,
											int& nEndSequNum,bool bActiveLocAfterSelection,
											int& nSaveActiveSequNum,bool bWantRetranslationFlagSet,
											bool bAlsoUpdateSublist)
// same parameters as for RemoveNullSourcePhraseFromLists(), except the second last boolean is
// added in order to control whether m_bRetranslation gets set or not; for retranslations we want
// it set, for editing the source text we want it cleared; and the last boolean controls whether
// or not we also update the sublist passed as the first parameter - for a retranslation we don't
// update it, because the caller will make no more use of it; but for an edit of the source text,
// the caller needs it updated because it will be used later when the transfer of standard format
// markers, if any, is done.
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int nNumElements = 1;
	CRefString* pRefString = (CRefString*)NULL;
	SPList::Node* pos = pList->GetFirst();
	int nTotalExtras = 0; // accumulate the total number of extras added by unmerging,
						  // this will be used if the updating of the sublist is asked for
	int nInitialSequNum = pos->GetData()->m_nSequNumber; // preserve this
														// for sublist updating
	while (pos != NULL)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		int nStartingSequNum = pSrcPhrase->m_nSequNumber;
		nNumElements = 1;
		if (pSrcPhrase->m_nSrcWords > 1)
		{
			// have to restore to original state (RestoreOriginalMinPhrases also
			// appends any m_translation in the CRefString object to pApp->m_targetPhrase, but we don't
			// care about that here as we will abandon pApp->m_targetPhrase's contents anyway)
			nNumElements = RestoreOriginalMinPhrases(pSrcPhrase,nStartingSequNum);

			// RestoreOriginalMinPhrases accumulates any m_adaptation text into the view's
			// pApp->m_targetPhrase attribute, which is fine when doing an unmerge of a single merged
			// phrase, but it is not fine in preparing a retranslation. The reason is that if
			// there are a lot of merged phrases in the selection and if these have existing
			// translations in them, unmerging them will result in the accumulation of a very
			// long pApp->m_targetPhrase. When we then get to the RecalcLayout call below, it will
			// rebuild the strips and eventually one of the pile's will have a source phrase
			// with sequence number equalling the old active location's sequence number; but in
			// the unmerging process, the m_adaptation field is cleared for each sourcePhrase,
			// and so when CalcPileWidth is called at the point when the old active pile is
			// reached, the "else" block is used for calculating the text extent because
			// m_adaptation is empty. Unfortunately, the else block calculated the extent by
			// looking at the contents of pApp->m_targetPhrase, as set up by the unmerges being done
			// now - the result is a huge pile width, and this would lead to a crash when the
			// endIndex is reached - since no source phrases can be laid out due to the spurious
			// large pileWidth value. The solution is to clean out the contents of pApp->m_targetPhrase
			// after each call of RestoreOriginalMinPhrases above, so that the caluculated
			// pileWidth values will be correct. So we do it now, where it makes sense - though
			// it could instead be done just once before the RecalcLayout call.
			// RestoreOriginalMinPhrases does its own KB clearance of the translations for the
			// phrases being unmerged.
			pApp->m_targetPhrase.Empty();

			// update the bundle indices, and nCount etc.
			int nExtras = nNumElements - 1;
			nTotalExtras += nExtras;
			pApp->m_endIndex += nExtras;
			pApp->m_upperIndex += nExtras;
			pApp->m_maxIndex += nExtras;
			nCount += nExtras;
			nEndSequNum += nExtras;
			if (bActiveLocAfterSelection)
				nSaveActiveSequNum += nExtras;

			// set the flags on the restored original min phrases (the pointers to the piles are
			// clobbered, but the sequence in the m_pSourcePhrases list is restored, so access
			// these)
			for (int i = nStartingSequNum; i <= nStartingSequNum + nExtras; i++)
			{
				// here POSITION pos is redefined in a subscope of the one above
				SPList::Node* pos = pSrcPhrases->Item(i);
				wxASSERT(pos != NULL);
				CSourcePhrase* pSPh = (CSourcePhrase*)pos->GetData();
				pSPh->m_bHasKBEntry = FALSE;
				if (bWantRetranslationFlagSet)
				{
					pSPh->m_bRetranslation = TRUE;
					pSPh->m_bNotInKB = TRUE;
				}
				else
				{
					pSPh->m_bRetranslation = FALSE;
					pSPh->m_bNotInKB = FALSE;
				}
				pSPh->m_adaption.Empty();  // ensure its clear for later on
				pSPh->m_targetStr.Empty(); // ditto
			}
		}
		else
		{
			//  remove the refString from the KB, etc.
			pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
												pSrcPhrase->m_key,pSrcPhrase->m_adaption);
			// it is okay to do the following call with pRefString == NULL, in fact, it must be
			// done whether NULL or not; since if it is NULL, RemoveRefString will clear
			// pSrcPhrase's m_bHasKBEntry to FALSE, which if not done, would result in a crash
			// if the user clicked on a source phrase which had its reference string manually
			// removed from the KB and then clicked on another source phrase.
			// (The StoreAdaption call in the second click would trip the first line's wxASSERT.)
			RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

			// we must abandon any existing adaptation text
			pSrcPhrase->m_adaption.Empty();
			pSrcPhrase->m_bNotInKB = TRUE;
			if (bWantRetranslationFlagSet)
			{
				pSrcPhrase->m_bRetranslation = TRUE;
				pSrcPhrase->m_bNotInKB = TRUE;
			}
			else
			{
				pSrcPhrase->m_bRetranslation = FALSE;
				pSrcPhrase->m_bNotInKB = FALSE;
			}
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pSrcPhrase->m_targetStr.Empty();
		}
	}

	// do the sublist updating, if required
	if (bAlsoUpdateSublist)
	{
		int nOldCount = pList->GetCount();
		wxASSERT(nOldCount);
		pList->Clear(); // clear the old list of pointer
		// again POSITION pos is redefined in a subscope
		SPList::Node* pos = pSrcPhrases->Item(nInitialSequNum);
		int nNewCount = nOldCount + nTotalExtras;
		CSourcePhrase* pSrcPhrase = 0;
		for (int index = 0; index < nNewCount; index++)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase);
			pList->Append(pSrcPhrase);
		}
	}
}

void CAdapt_ItView::BuildRetranslationSourcePhraseInstances(SPList* pRetransList,
						int nStartSequNum,int nNewCount,int nCount,int& nFinish)
{
	CAdapt_ItDoc* pDoc = GetDocument();
	int nSequNum = nStartSequNum - 1;
	nFinish = nNewCount < nCount ? nCount : nNewCount;
	for (int j=0; j<nFinish; j++)
	{
		nSequNum++;
		CPile* pPile = GetPile(nSequNum); // needed, because the InsertNullSourcePhrase
										  // clobbered ptrs and so did a RecalcLayout()
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pPile->m_pSrcPhrase; // the one to be updated

		if (j == 0)
		{
			// mark the first one
			pSrcPhrase->m_bBeginRetranslation = TRUE;
			pSrcPhrase->m_bEndRetranslation = FALSE;
		}
		else if (j == nFinish - 1)
		{
			// mark the last one
			pSrcPhrase->m_bEndRetranslation = TRUE;
			pSrcPhrase->m_bBeginRetranslation = FALSE;
		}
		else
		{
			// play safe, ensure any others have both flags cleared
			pSrcPhrase->m_bBeginRetranslation = FALSE;
			pSrcPhrase->m_bEndRetranslation = FALSE;
		}

		if (j < nNewCount)
		{
			// there will be a retranslation word available only when j < nNewCount
			SPList::Node* pos = pRetransList->Item(j);
			CSourcePhrase* pIncompleteSrcPhrase = (CSourcePhrase*)pos->GetData();
			wxASSERT(pIncompleteSrcPhrase != NULL);

			// copy the text across (these "source phrases" actually contain target text in the
			// attributes which otherwise would hold source text, due to the use of TokenizeText
			// for parsing what the user typed)
			pSrcPhrase->m_targetStr = pIncompleteSrcPhrase->m_srcPhrase; // the text with
																		  // punctuation
			RemovePunctuation(pDoc,&pIncompleteSrcPhrase->m_key,1 /* from tgt */); // ensure there
																		// is no punctuation in it
			pSrcPhrase->m_adaption = pIncompleteSrcPhrase->m_key;
			// copy over any punctuation (but don't touch markers - if user typed any, just ignore
			// them) the punctuation is, of course, already on the m_targetStr attribute, but we
			// want the m_precPunct & m_follPunct attributes to be in sync
			////BEW commented out, 17Nov06 because source text settings should not be altered irreversibly
			//if (pIncompleteSrcPhrase->m_precPunct.IsEmpty())
			//	pSrcPhrase->m_precPunct.Empty(); // don't want a punctuation conflict
			//else
			//	pSrcPhrase->m_precPunct = pIncompleteSrcPhrase->m_precPunct;
			//if (pIncompleteSrcPhrase->m_follPunct.IsEmpty())
			//	pSrcPhrase->m_follPunct.Empty(); // ditto
			//else
			//	pSrcPhrase->m_follPunct = pIncompleteSrcPhrase->m_follPunct;
			//
			//check that all is well
			wxASSERT(pSrcPhrase->m_nSequNumber == pIncompleteSrcPhrase->m_nSequNumber);
		}

		// if nNewCount was less than nCount, we must clear any old punctuation off
		// the unused source phrases at the end of the selection (we will leave markers untouched)
		// so that the typed punctuation effectively overrides that on the source
		if (j >= nNewCount)
		{
			//// BEW commented out, 17Nov06 because source text settings should not be altered irreversibly
			//pSrcPhrase->m_precPunct.Empty();
			//pSrcPhrase->m_follPunct.Empty();
		}
	}
}

int CAdapt_ItView::TokenizeTextString(SPList* pNewList, wxString& str,  int nInitialSequNum)
// Tokenize the string str storing the CSourcePhrase instances (only m_strSource & m_nSequNumber
// are set) in pNewList. nInitialSequNum is what will be used for the sequence number of the
// first element tokenized
{
	CAdapt_ItDoc* pDoc = GetDocument();
	int	length = str.Length();
	if (!str.IsEmpty())
	{
		// BEW added next line 10Mmay08; long ago I counted the null character as part of the string's
		// length, and Bill had to remove it in TokenizeText(), so since Bill's edit still
		// stands, I have to add a +1 to the length here, so that TokenizeText()'s calculation
		// of pEndText points at the final null and doesn't otherwise cause the final character
		// of the data passed in to be chopped off.
		// whm Note: Although Bruce feels it fixed the problem in the MFC version, I'm not carrying
		// over his fix here because, I've modified things elsewhere in the wx version to 
		// account for the change.
		//length += 1;
		return pDoc->TokenizeText(nInitialSequNum,pNewList,str,length);
	}
	else
		return 0;
}

void CAdapt_ItView::DeleteSavedSrcPhraseSublist(SPList* pSaveList)
{
	if (pSaveList->GetCount() > 0)
	{
		SPList::Node* pos = pSaveList->GetFirst(); 
		wxASSERT(pos != 0);
		while (pos != 0)
		{
			CSourcePhrase* pSP = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (pSP != NULL)
			{
				// don't want memory leaks
				delete pSP->m_pMedialMarkers;
				pSP->m_pMedialMarkers = (wxArrayString*)NULL;
				delete pSP->m_pMedialPuncts;
				pSP->m_pMedialPuncts = (wxArrayString*)NULL;
				pSP->m_pSavedWords->Clear(); // remove pointers only
				delete pSP->m_pSavedWords;
				pSP->m_pSavedWords = (SPList*)NULL;
				delete pSP;
				pSP = (CSourcePhrase*)NULL;
			}
		}
		pSaveList->Clear();
	}
	delete pSaveList; // don't leak memory
	pSaveList = (SPList*)NULL;
}

void CAdapt_ItView::PadWithNullSourcePhrasesAtEnd(CAdapt_ItDoc* pDoc,CAdapt_ItApp* pApp,
												  SPList* pSrcPhrases,
											int nEndSequNum,int nNewCount,int nCount)
// The padding is done in the main list of source phrases, on the [App]. pSrcPhrases is the
// pointer to this list; nEndSequNumber is the sequence number of the last CSourcePhrase instance
// of the selected source text (and the padding is required when there are more words in the
// target text than the source piles can accomodate). nNewCount is the number of target text
// words - it could be less, more, or the same as the number piles selected (we test internally
// and act accordingly), and nCount is the number of CSourcePhrase instances after all nulls
// removed, and mergers unmerged. We have to be careful if nEndSequNumber is equal to m_maxIndex,
// because insertion of null source phrases has to take place before a sourcephrase instance which
// would not exist, so we must detect this and temporarily add an extra CSourcePhrase instance at
// the end of the main list, do the insertions preceding it, then remove it.
{
	if (nNewCount > nCount)
	{
		// null source phrases are needed for padding
		int nExtras = nNewCount - nCount;

		// check we are not at the end of the list of CSourcePhrase instances, if we are we will
		// have to add an extra one so that we can insert before it, then remove it later.
		if (nEndSequNum == pApp->m_maxIndex)
		{
			// we are at the end, so we must add a dummy sourcephrase; note, m_nActiveSequNum and
			// the caller's nSaveActiveSequNum values will almost certainly be greater than
			// m_maxIndex, and so we must not use these until we adjust them in the caller later
			// on. So we can ignore the active location, and just temporarily treat it as the
			// last pile in the document.
			CSourcePhrase* pDummySrcPhrase = new CSourcePhrase;
			pDummySrcPhrase->m_srcPhrase = _T("dummy"); // something needed, so a pile width
														// can be computed
			pDummySrcPhrase->m_key = pDummySrcPhrase->m_srcPhrase;
			pApp->m_maxIndex += 1;
			pApp->m_endIndex = pApp->m_maxIndex;
			pDummySrcPhrase->m_nSequNumber = pApp->m_maxIndex;
			SPList::Node* posTail;
			posTail = pSrcPhrases->Append(pDummySrcPhrase); 

			// we need a valid layout which includes the new dummy element on its own pile
			RecalcLayout(pSrcPhrases,0,pApp->m_pBundle);
			pApp->m_pActivePile = GetPile(pApp->m_maxIndex); // temporary active location

			// now we can do the insertions
			CPile* pPile = GetPile(nEndSequNum + 1);
			wxASSERT(pPile != NULL);
			InsertNullSourcePhrase(pDoc,pApp,pPile,nExtras,FALSE,TRUE); // FALSE for restoring
				// the phrase box, TRUE for doing it for a retranslation, and default TRUE for
				// bInsertBefore flag at end

			// now remove the dummy element, and make sure memory is not leaked!
			delete pDummySrcPhrase->m_pSavedWords;
			pDummySrcPhrase->m_pSavedWords = (SPList*)NULL;
			delete pDummySrcPhrase->m_pMedialMarkers;
			pDummySrcPhrase->m_pMedialMarkers = (wxArrayString*)NULL;
			delete pDummySrcPhrase->m_pMedialPuncts;
			pDummySrcPhrase->m_pMedialPuncts = (wxArrayString*)NULL;
			// WX Note: wxList does not have RemoveTail(). We can do it in a two stage process
			// by using GetLast(), then DeleteNode() [ which is equivalent to MFC RemoveAt()].
			SPList::Node *pLast = pSrcPhrases->GetLast();
			pSrcPhrases->DeleteNode(pLast);
			delete pDummySrcPhrase;

			// get another valid layout
			pApp->m_maxIndex = pApp->m_endIndex -= 1; // we've no longer got the dummy present,
										  // so decrement the indices
			RecalcLayout(pSrcPhrases,0,pApp->m_pBundle);
			pApp->m_pActivePile = GetPile(nEndSequNum + nExtras - 1); // temporarily at the end,
						// caller will fix  things properly before the phrase box is recreated
		}
		else
		{
			// not at the end, so we can proceed immediately; get the insertion location's pile
			// pointer
			CPile* pPile = GetPile(nEndSequNum + 1);
			wxASSERT(pPile != NULL);
			InsertNullSourcePhrase(pDoc,pApp,pPile,nExtras,FALSE,TRUE); // FALSE for restoring
										// the phrase box, TRUE for doing it for a retranslation
		}
	}
	else
		return; // no padding needed
}

bool CAdapt_ItView::SetActivePilePointerSafely(CAdapt_ItApp* pApp,
											   SPList* pSrcPhrases,int& nSaveActiveSequNum,
											   int& nActiveSequNum,int nFinish)
// nSaveActiveSequNum, on input, should be the tentative sequNum value we hope will be a valid
// location but may not be; and nActiveSequNum, on input, should be the current active location's
// sequNum; on output, nSaveActiveSequNum will be a different value if the input value landed the
// box in a retranslation...
// pSrcPhrases is the list on the app, nSaveActiveSequNum - this could be too large since
// we try place the active location after the retranslation and that might be beyond the end of
// the document, hence the need to try find a safe place somewhere (its passed by reference
// because we want the caller's variable of the same name to be automatically updated too);
// nActiveSequNum is a ref to the App's m_nActiveSequNum and we will set it from here;
// nFinish is the final number of piles in the retranslation after all adjustments have been done.
{
	if (nSaveActiveSequNum >= (int)pSrcPhrases->GetCount())
	{
		// need to put active location before the retranslation
		int sequNum = nSaveActiveSequNum - nFinish;
		CSourcePhrase* pSP;
		do
		{
			--sequNum;
			SPList::Node* pos = pSrcPhrases->Item(sequNum);
			pSP = (CSourcePhrase*)pos->GetData();
			wxASSERT(pSP != NULL);
		} while (pSP->m_bRetranslation || pSP->m_bNotInKB);
		nSaveActiveSequNum = sequNum; // new value

		// are we still in the current bundle?
		if (nSaveActiveSequNum < pApp->m_beginIndex)
		{
			// gone back preceding the bundle, so we have to fix the bundle too
			pApp->m_pActivePile = AdvanceBundle(nSaveActiveSequNum); // not an "advance" but the
															   // call works ok
		}
		else
		{
			pApp->m_pActivePile = GetPile(nSaveActiveSequNum); // in the current bundle
		}
	}
	else
	{
		pApp->m_pActivePile = GetPile(nSaveActiveSequNum);

		// this could be a pile containing a retranslation, so check it out, and if so, advance
		// until we find a safe location, and if that process reaches the end of the document
		// without finding a safe location, then go backwards instead until we find one - one of
		// these processes will definitely succeed.
		CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->m_pSrcPhrase;
		if (pSrcPhrase->m_bRetranslation)
		{
			// a retranslation is not a valid phrase box location, so hunt for a safe place nearby
			CSourcePhrase* pSaveSP = pSrcPhrase;
			pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);

			if (pSrcPhrase == NULL)
			{
				// reached end of source phrase list without finding a safe place, so look in the
				// opposite direction - this (almost certainly) MUST succeed - it could only fail
				// if the previous active location was in the selection and the selection comprised
				// all of the srcPhrases which are not already in a retranslation, and the whole
				// doc is now a series of consecutive retranslations (most unlikely!)
				pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSP);

				if (pSrcPhrase == NULL)
				{
					// nowhere is a safe location! (Is the user retranslating everything? !!!)
					// so our only option is to go to the end
					int lastSequNum = pApp->m_maxIndex;
					CPile* pPile;
					pPile = AdvanceBundle(lastSequNum);
					Invalidate();
					// we don't want a phrase box, so step past the end
					pApp->m_targetPhrase.Empty();
					nActiveSequNum = pApp->m_curIndex = -1;
					pApp->m_pTargetBox->SetValue(_T(""));
					pApp->m_pActivePile = (CPile*)NULL; // can use this as a flag for at-EOF condition too
					return FALSE;
				}
			}
		}

		// jump to whatever pile is not in a retranslation, as close to wanted loc'n as possible
		nSaveActiveSequNum = pSrcPhrase->m_nSequNumber;
		gnOldSequNum = nSaveActiveSequNum; // the only safe option, since old location may now
										   // be within the retranslation
		Jump(pApp,pSrcPhrase);
	}
	nActiveSequNum = nSaveActiveSequNum; // ensure value of pApp->m_nActiveSequNum agrees with any
										 // adjustments
	return TRUE;
}

void CAdapt_ItView::ClearSublistKBEntries(SPList* pSublist)
{
	SPList::Node* pos = pSublist->GetFirst();
	while (pos != NULL)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key,pSrcPhrase->m_adaption);
		// it is okay to do the following call with pRefString == NULL, the function will just
		// exit early, having done nothing
		RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);
		pSrcPhrase->m_bRetranslation = FALSE; // make sure its off
		pSrcPhrase->m_bHasKBEntry = FALSE;	  // ditto
	}
}

void CAdapt_ItView::InsertSublistAfter(SPList* pSrcPhrases, SPList* pSublist, int nLocationSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList::Node* pos = pSrcPhrases->Item(nLocationSequNum);
	wxASSERT(pos != 0);
	SPList::Node* pos1 = pSublist->GetLast();
	wxASSERT(pos1 != 0);
	// Get a node called posNextHigher which points to the next node beyond pos
	// in pSrcPhrases and use its position in the Insert() call (which only inserts
	// BEFORE the indicated position). The result should be that the insertions
	// will get placed in the list the same way that MFC's InsertAfter() places them.
	SPList::Node* newInsertBeforePos = pos->GetNext(); // Is this in the right place ???
	//CSourcePhrase* pSPTest = newInsertBeforePos->GetData(); //for testing
	while (pos1 != 0)
	{
		CSourcePhrase* pSPhr = (CSourcePhrase*)pos1->GetData();
		pos1 = pos1->GetPrevious();
		wxASSERT(pSPhr != NULL);
		// wxList has no equivalent to InsertAfter(). The wxList Insert() method
		// inserts the new node BEFORE the current position/node. To emulate what
		// the MFC code does, we insert before using newInsertBeforePos.
		// wx note: If newInsertBeforePos is NULL, it means the insert position is
		// at the end of the list; in this case we just append the item to the end
		// of the list.
		if (newInsertBeforePos == NULL)
			pSrcPhrases->Append(pSPhr);
		else
			pSrcPhrases->Insert(newInsertBeforePos,pSPhr); //pSrcPhrases->InsertAfter(pos,pSPhr);

		// since we must now insert before the inserted node above, we need to get a
		// previous node (which will actually be the just inserted source phrase)
		newInsertBeforePos = newInsertBeforePos->GetPrevious();
		//CSourcePhrase* pSPTest = newInsertBeforePos->GetData(); // for testing

		// If the m_bNotInKB flag is FALSE, we must re-store the translation in
		// the KB. We can get the former translation string from the m_adaption member.
		if (!pSPhr->m_bNotInKB && !pSPhr->m_adaption.IsEmpty())
		{
			bool bOK = StoreText(pApp->m_pKB,pSPhr,pSPhr->m_adaption);
			if (!bOK)
			{
				// never had a problem here, so this message can stay in English
				wxMessageBox(_T(
			"Warning: redoing the StoreText operation failed in OnButtonRetranslation\n"),
					_T(""), wxICON_EXCLAMATION);
			}
		}
	}
}

void CAdapt_ItView::RemoveUnwantedSourcePhraseInstancesInRestoredList(SPList* pSrcPhrases,
									 int nCurCount, int nStartingSequNum,SPList* pSublist)
// pSrcPhrases is the document's list; nCurCount is how many elements are now in the 'selection'
// as modified by removing all nulls and unmerging all mergers, nStartingSequNum is where the
// checking will start for doing the removals of those determined to be unwanted, and pSublist is
// the pointer to the sublist which stores the original elements we are in the process of
// restoring to the main list on the app
{
	SPList::Node* pos = pSrcPhrases->Item(nStartingSequNum); // first one's position
	int count = 0;
	while (pos != NULL && count < nCurCount)
	{
		SPList::Node* savePos = pos;
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);

		// before we can delete it, we must check it's not one of those (minimal) source phrases
		// which is in the sublist of a merged source phrase in the saved list - if we deleted it,
		// we'd be deleting something we must retain; but we would want to remove it's pointer
		// from the list (because it's to be accessed only by the m_pSavedWords sublist of
		// whichever merged source phrase was formed from it)
		bool bCanDelete = TRUE;
		SPList::Node* posSaveList = pSublist->GetFirst();
		wxASSERT(posSaveList != 0);
		while (posSaveList != 0)
		{
			CSourcePhrase* pSP = (CSourcePhrase*)posSaveList->GetData();
			posSaveList = posSaveList->GetNext();
			wxASSERT(pSP != 0);
			if (pSP->m_nSrcWords == 1)
				continue; // its a copy without a sublist, so ignore it
			else
			{
				// its a copy with a sublist, so see if any source phrase in the sublist is
				// a match for the one we wish to delete; if it is, don't delete it, just
				// remove its pointer from the m_pSourcePhrases list only
				SPList* pL = pSP->m_pSavedWords;
				wxASSERT(pL->GetCount() > 1);
				SPList::Node* pos4 = pL->GetFirst(); 
				wxASSERT(pos4 != 0);
				while (pos4 != 0)
				{
					CSourcePhrase* pSPhr = (CSourcePhrase*)pos4->GetData();
					pos4 = pos4->GetNext();
					wxASSERT(pSPhr != 0);
					if (pSPhr == pSrcPhrase)
					{
						// we have a match
						bCanDelete = FALSE;
						break;
					}
				}
			}
		}
		if (bCanDelete)
		{
			if (pSrcPhrase->m_pMedialMarkers->GetCount() > 0)
			{
				pSrcPhrase->m_pMedialMarkers->Clear(); // can clear the strings safely
			}
			delete pSrcPhrase->m_pMedialMarkers;
			pSrcPhrase->m_pMedialMarkers = (wxArrayString*)NULL;

			if (pSrcPhrase->m_pMedialPuncts->GetCount() > 0)
			{
				pSrcPhrase->m_pMedialPuncts->Clear(); // can clear the strings safely
			}
			delete pSrcPhrase->m_pMedialPuncts;
			pSrcPhrase->m_pMedialPuncts = (wxArrayString*)NULL;

			// don't delete any saved CSourcePhrase instances forming a phrase (and these
			// will never have medial puctuation nor medial markers nor will they store
			// any saved minimal phrases since they are CSourcePhrase instances for single
			// words only) - just clear the pointers
			if (pSrcPhrase->m_pSavedWords->GetCount() > 0)
			{
				pSrcPhrase->m_pSavedWords->Clear(); // just remove the pointers
			}
			delete pSrcPhrase->m_pSavedWords;		// and delete the list from the heap
			pSrcPhrase->m_pSavedWords = (SPList*)NULL;

			// finally delete the source phrase copy itself
			delete pSrcPhrase;
			pSrcPhrase = (CSourcePhrase*)NULL;

			// remove its pointer from the list
			pSrcPhrases->DeleteNode(savePos); 

			// augment the count of how many have been removed
			count++;
		}
		else
		{
			// this is one we cannot delete, but must just remove its pointer from the list
			pSrcPhrases->DeleteNode(savePos);

			// augment the count of how many have been removed
			count++;
		}
	}
}

void CAdapt_ItView::RestoreTargetBoxText(CSourcePhrase* pSrcPhrase,wxString& str)
// the pSrcPhrase supplied by the caller will be a newly created one, and therefore all its flags
// will have default values, and in particular the m_adaption and m_targetStr attributes will both
// be empty. So we must invoke a lookup of the single source word at the box location (which will
// be at the start of the new source text) in the KB to find a suitable adaptation to put in the
// target box; and this may, if there is more than one possible adaptation available, put up the
// Choose Translation dialog. (We can pinch suitable code from OnButtonRestore() and modify it a
// bit for here.) We set str in this function, and the caller then takes that and assigns it to
// pApp->m_targetPhrase. Modified, July 2003, for auto capitalization support
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	bool bGotTranslation;
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pSrcPhrase->m_key);
	}

	// although this function strictly speaking is not necessarily invoked in the context of an
	// unmerge, the gbUnmergeJustDone flag being TRUE gives us the behaviour we want; ie. we
	// certainly DON'T want OnButtonRestore() called from here!
	gbUnmergeJustDone = TRUE; // prevent second OnButtonRestore() call from within
							  // ChooseTranslation() within LookUpSrcWord() if user happens to
							  // cancel the Choose Translation dialog (see CPhraseBox code)
	bGotTranslation = pApp->m_pTargetBox->LookUpSrcWord(this,pApp->m_pActivePile);
	gbUnmergeJustDone = FALSE; // clear flag to default value, since it is a global boolean
	wxASSERT(pApp->m_pActivePile); // it was created in the caller just prior to this function
								 // being called 
	if (bGotTranslation)
	{
		// we have to check here, in case the translation it found was a "<Not In KB>"
		// - in which case, we must display m_targetStr and ensure
		// that the pile has an asterisk above it, etc
		if (translation == _T("<Not In KB>"))
		{
			str.Empty(); // phrase box must be shown empty
			pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
			pApp->m_pActivePile->m_pSrcPhrase->m_bNotInKB = TRUE;
			str = pApp->m_pActivePile->m_pSrcPhrase->m_targetStr;
		}
		else
		{
			str = translation; // set using the global var, set in LookUpSrcWord call
		}

		if (gbAutoCaps && gbSourceIsUpperCase)
		{
			bNoError = SetCaseParameters(str,FALSE);
			if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
			{
				// change first letter to upper case
				str.SetChar(0, gcharNonSrcUC);
			}
		}
	}
	else // no translation found
	{
		// do the copy of source instead, or nothing if Copy Source flag is not set
		if (pApp->m_bCopySource)
		{
			// copy source key
			str = CopySourceKey(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_bUseConsistentChanges);
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			str.Empty();
		}
	}
}

void CAdapt_ItView::OnButtonRetranslation(wxCommandEvent& event)
// Modified for support of glossing (this function cannot be used when glossing is ON)
{
	// Since the Do a Retranslation toolbar button has an accelerator table hot key (CTRL-R see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_RETRANSLATION))
	{
		::wxBell();
		return;
	}

	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."), _T(""), wxICON_INFORMATION);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	SPList* pList = new SPList; // list of the selected CSourcePhrase objects 
	wxASSERT(pList != NULL);
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;
	int nStartingStripIndex;

	// determine the active sequ number, so we can determine whether or not the active location
	// lies within the selection (if its not in the selection, we will need to recreate the
	// phrase box at the former active location when done - be careful, because if the active
	// location lies after the selection and the selection contains null src phrases or merged
	// phrases, then the value of nFormerActiveSequNum will need to be updated as we remove null
	// src phrases and / or unmerge merged phrases)
	int nSaveActiveSequNum = pApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;

	CSourcePhrase* pSrcPhrase;
	wxString strAdapt; // accumulates the existing adaptation text for the selection (now, for
					  // fourth line, we will use strAdapt to accumulate that line, rather than
					  // third line text)
	strAdapt.Empty();

	wxString str; // a temporary storage string
	str.Empty();
	wxString str2; // second temporary storage string
	str2.Empty();
	wxString strSource; // the source text which is to be retranslated (now line 1, not line 2)
	strSource.Empty();
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	int nCount = pApp->m_selection.GetCount(); // number of src phrase instances in the selection

	if (nCount == (int)pApp->m_pSourcePhrases->GetCount())
	{
		//IDS_RETRANS_NOT_ALL_OF_DOC
		wxMessageBox(_("Sorry, for a retranslation your selection must not include all the document contents - otherwise there would be no possible place for the phrase box afterwards. Shorten the selection then try again."),_T(""),wxICON_INFORMATION);
		return;
	}

	//CPile* pPile = ((CCell*)m_selection.GetNext(pos))->m_pPile; // get the pile first in
	//															// selection
	CCell* pCell = (CCell*)pos->GetData();
	CPile* pPile = pCell->m_pPile; // get the pile first in
														// selection
	pos = pos->GetNext(); // needed for our CCellList to effect MFC's GetNext()

	pStartingPile = pPile; // need this for later when we look up the strip which first pile
						   // is in prior to calling RecalcLayout
	CSourceBundle* pBundle = pStartingPile->m_pBundle; // needed for recalculating layout
	nStartingStripIndex = pStartingPile->m_pStrip->m_nStripIndex;
	pSrcPhrase = pPile->m_pSrcPhrase;

	int nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything depends
												  // on this - its the first in the sublist list

	// get a list of the selected CSourcePhrase instances (some might not be minimal ones
	// so if this is the case we must later restore them to minimal ones, and some might be
	// null, so these must be later eliminated after their text, if any, is preserved & any
	// punctuation transferred) and also accumulate the words in the source and target text
	// into string variables
	GetSelectedSourcePhraseInstances(pList, strSource, strAdapt);

	// check that the selection is text of a single type - if it isn't, then tell the user and
	// abandon the operation
	bool bConstType = IsConstantType(pList);
	if (!bConstType)
	{
		// IDS_TYPE_CHANGE_ERR
		wxMessageBox(_("Sorry, the selection contains text of more than one type. Select only one text type at a time. The operation will be ignored."), _T(""), wxICON_EXCLAMATION);
		RemoveSelection();
		delete pList;
		pList = (SPList*)NULL;
		pApp->m_pTargetBox->SetFocus();
		pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
		gnStart = pApp->m_nStartChar;
		gnEnd = pApp->m_nEndChar;
		Invalidate();
		return;
	}

	// check for a retranslation in the selection, and abort the retranslatiaon operation if
	// there is one
	if (IsRetranslationInSelection(pList))
	{
		// IDS_NO_RETRANSLATION_IN_SEL
		wxMessageBox(_("Sorry, but this operation is not permitted when the selection contains any part of a retranslation. First remove the retranslation and then try again."), _T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		pApp->m_pTargetBox->SetFocus();
		pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
		gnStart = pApp->m_nStartChar;
		gnEnd = pApp->m_nEndChar;
		Invalidate();
		return;
	}

	// need to clobber the selection here, so the selection globals will be set to -1,
	//  otherwise RecalcLayout will fail at its RestoreSelection() call; and any unmergers or other
	// layout changes done immediately below will invalidate layout pointers which RemoveSelection()
	// relies on, and produce a crash.
	RemoveSelection();

	// copy the list to a 2nd list for saving the original state, in case the user hits the
	// Cancel button in the dialog, and save the old sequ num value for the active location; we
	// don't save copies of the pointers, but instead use the copy constructor to make fresh
	// copies of the original selection's source phrases - but note that the copy constructor
	// (and also operator=) only copies pointers for any CSourcePhrases in each source phrase's
	// m_pSavedWords sublist - which has implications for below (in particular, when deleting
	// the copied list, we must not delete in the sublists, but only remove the pointers,
	// otherwise the originals will have hanging pointers)
	SPList* pSaveList = new SPList;
	wxASSERT(pSaveList != NULL);
	CopySourcePhraseList(pList,pSaveList);

	// BEW added 20Mar07: to suppress KB entry removal during a retranslation or edit of same
	gbIsRetranslationCurrent = TRUE;

	// deliberately abandon contents of box at active loc'n - we'll reconstitute it as
	// necessary later, depending on where we want to place the targetBox. But before we
	// abandon it, we must first check if the active location is outside the selection -
	// since there could be a just-edited entry in the phrase box which is not yet entered
	// in the knowledge base, and the active location's source phrase doesn't yet have its
	// m_adaption and m_targetStr members updated, so we must check for this condition and
	// if it obtains then we must first update everything at the active location before we
	// empty pApp->m_targetPhrase, etc. For versions later than 1.2.9, the code below is different.
	// We need an unconditional store, because if outside the selection, we must update as the
	// above explanation explains; but for an active location within the selection, we still
	// must update because (a) there is one refString removal already by virtue of the fact
	// that it is the active location (ie. the box is there), and (b) a further refString
	// removal will be done in the UnmergeMergersInSublist() call, and this means the
	// refString for the active location gets  removed twice unless we prevent it (it only
	// should be removed once). So by doing an unconditional store, we bump the refCount at
	// the active loc, and then the UnmergeMergersInSublist() call can decrement it again,
	// keeping the count correct. We need to do this also in OnEditSourceText().
	if (pApp->m_pActivePile != NULL)
	{
		// the active location is not within the retranslation section, so update before
		// throwing it all out
		MakeLineFourString(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
		RemovePunctuation(pDoc,&pApp->m_targetPhrase,1 /*from tgt*/);
		gbInhibitLine4StrCall = TRUE;
		bool bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
		gbInhibitLine4StrCall = FALSE;
		if (!bOK)
		{
			gbIsRetranslationCurrent = FALSE;
			return; // can't proceed until a valid adaption (which could be null) is
					// supplied for the former active pile's srcPhrase
		}
		else
		{
			int nFormerStrip = pApp->m_pActivePile->m_pStrip->m_nStripIndex;
			int nCurStripIndex = pStartingPile->m_pStrip->m_nStripIndex;
			if (nCurStripIndex != nFormerStrip)
			{
				// layout the former strip too, if it is not the current one
				LayoutStrip(pApp->m_pSourcePhrases,nFormerStrip,pApp->m_pBundle);
				Invalidate();
			}
		}
	}
	pApp->m_targetPhrase.Empty();
	if (pApp->m_pTargetBox != NULL)
	{
		pApp->m_pTargetBox->SetValue(pApp->m_targetPhrase);
	}

	// determine the value for the active sequ number on exit, so we will know where to place
	// the phrase box on return to the caller; we'll place the phrase box at the first location
	// after the retranslation - provided the active location was within the selection; but if
	// it lay outside the selection, we will need to restore it to wherever it was.
	//int nEndSequNum = ((CSourcePhrase*)pList->GetLast())->m_nSequNumber;
	// break above complex call down into parts
	SPList::Node* lastPos = pList->GetLast();
	int nEndSequNum = lastPos->GetData()->m_nSequNumber;
	bool bActiveLocWithinSelection = FALSE;
	if (nSaveActiveSequNum >= nSaveSequNum && nSaveActiveSequNum <= nEndSequNum)
		bActiveLocWithinSelection = TRUE;
	bool bActiveLocAfterSelection = FALSE;
	if (nSaveActiveSequNum > nEndSequNum)
		bActiveLocAfterSelection = TRUE;

	// check for any null source phrases in the selection, and delete any found from both the
	// temporary list (pList), and from the original source phrases list on the app (see above)
	while (IsNullSrcPhraseInSelection(pList))
	{
		RemoveNullSrcPhraseFromLists(pList,pSrcPhrases,pApp->m_endIndex,pApp->m_upperIndex,pApp->m_maxIndex,
			nCount,nEndSequNum,bActiveLocAfterSelection,nSaveActiveSequNum);
	}

	// at this point pList does not contain any null source phrases, and we have accumulated any
	// adaptations already typed into strAdapt. However, we might have merged phrases in pList
	// to be unmerged, and we have not yet removed the translation for each pSrcPhrase in pList
	// from the KB, so we must do those things next.
	UnmergeMergersInSublist(pList,pSrcPhrases,gpApp->m_endIndex,gpApp->m_upperIndex,gpApp->m_maxIndex,nCount,
			nEndSequNum,bActiveLocAfterSelection,nSaveActiveSequNum,TRUE,TRUE); // final 2 flags
				// should take default values (TRUE, and FALSE, respectively), but this leads to a crash
				// when there are unmergers to be done - so using TRUE,TRUE fixes it (ie. the pList sublist
				// needs to be updated here too)

	// now we can work out where to place the phrase box on exit from this function - it is
	// currently the nSaveActiveSequNum value, unless the active location was within the
	// selection, in which case we must make the active location the first pile after the
	// selection
	if (bActiveLocWithinSelection)
		nSaveActiveSequNum = nEndSequNum + 1;

	// the src phrases in the sublist will not be saved to the KB (because we don't save
	// retranslations) so mark them as not being in the KB; similarly, set the
	// m_bRetranslation flag to TRUE
	SetNotInKBFlag(pList,TRUE);
	SetRetranslationFlag(pList,TRUE);

	// we must have a valid layout, so we have to recalculate it before we go any further,
	// because if preceding code unmerged formerly merged phrases, or if null phrases were
	// deleted, then the layout's pointers will be clobbered, and then if we move the dialog
	// about to be put up, accesses to Draw() for the cells, piles & strips will fail.
	RecalcLayout(pSrcPhrases,0,pBundle);

	// create the CRetranslationDlg dialog
	CRetranslationDlg dlg(pApp->GetMainFrame());
	dlg.Centre();

	// initialize the edit boxes
	dlg.m_sourceText = strSource;
	dlg.m_retranslation = strAdapt;
	wxString preceding;
	preceding.Empty();
	wxString following;
	following.Empty();
	wxString precedingTgt;
	precedingTgt.Empty();
	wxString followingTgt;
	followingTgt.Empty();
	GetContext(nSaveSequNum,nEndSequNum,preceding,following,precedingTgt,followingTgt);
	dlg.m_preContextSrc = preceding;
	dlg.m_preContextTgt = precedingTgt;
	dlg.m_follContextSrc = following;
	dlg.m_follContextTgt = followingTgt;

	// BEW addition 08Sep08 for support of vertical editing
	bool bVerticalEdit_SuppressPhraseBox = FALSE;
	int nVerticalEdit_nExtras = 0;

	// wx version: The wx version was crashing as soon as this CRetranslationDlg was shown. The
	// crashes were in OnUpdateButtonRestore(), an unrelated update handler, because in the code
	// line
	//		CSourcePhrase* pSP = pApp->m_pActivePile->m_pSrcPhrase;
	// m_pActivePile was valid, but the m_pSrcPhrase was uninitialized. Perhaps the wx version
	// update handlers in wx are more robust than those of MFC, or don't get blocked while a
	// modal dialog is showing, I don't know. But to eliminate the crash, I'm temporarily turning
	// off the update handler in the line below, and activating it again after ShowModal returns
	// farther below. This should be appropriate because while the dialog is being shown, it is
	// not possible to click on a toolbar button anyway.
	// TODO: It might be appropriate to do this for other modal dialogs too. Another possibility
	// is to have a special handler that disables all controls outside a modal dialog while the
	// modal dialog is running.
	// wx later note: I've incorporated the SetMode() call in the AIModalDialog class upon which all
	// Adapt It modal dialogs are now based. It actually is wxIdleEvent::SetMode(wxIDLE_PROCESS_SPECIFIED);
	// which stops all background idle processing, including wxUpdateUIEvent event handling.
	//wxUpdateUIEvent::SetMode(wxUPDATE_UI_PROCESS_SPECIFIED); // prevent UI updating while dialog is shown
	// show the dialog
	if (dlg.ShowModal() == wxID_OK)
	{
		SPList* pRetransList = new SPList;
		wxASSERT(pRetransList);
		wxString retrans = dlg.m_retranslation;
		int nNewCount = 0; // number of CSourcePhrase instances returned from the tokenization
						   // operation

		// tokenize the retranslation into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key and m_nSequNumber are set); nSaveSequNum is the
		// absolute sequence number for first source phrase in the sublist - it is used to
		// define the starting sequence number to be stored on the first element of the sublist,
		// and higher numbers on succeeding ones
		nNewCount = TokenizeTextString(pRetransList,retrans,nSaveSequNum);

		// we must have a valid layout, so we have to recalculate it before we go any further,
		// because if preceding code unmerged formerly merged phrases, or if null phrases were
		// deleted, then the layout's pointers will be clobbered
		RecalcLayout(pSrcPhrases,0,pBundle);

		// get a new valid starting pile pointer, and pApp->m_nActiveSequNum updated, etc
		pStartingPile = GetPile(nSaveSequNum);
		wxASSERT(pStartingPile != NULL);

		// augment the active sequ num if it lay after the selection
		if (bActiveLocAfterSelection && nNewCount > nCount)
			nSaveActiveSequNum += nNewCount - nCount;
		else
		{
			// augment it also if the active location lay within the selection
			// and null source phrases were inserted
			if (bActiveLocWithinSelection && nNewCount > nCount)
				nSaveActiveSequNum += nNewCount - nCount;
		}

		pApp->m_nActiveSequNum = nSaveActiveSequNum; // to ensure any call to InsertNullSrcPhrase()
											   // will work right

		// determine if we need extra null source phrases inserted, and insert them if we do
		PadWithNullSourcePhrasesAtEnd(pDoc,pApp,pSrcPhrases,nEndSequNum,nNewCount,nCount);

		// copy the retranslation's words, one per source phrase, to the constituted sequence of
		// source phrases (including any null ones) which are to display it; but ignore any
		// markers and punctuation if they were encountered when the retranslation was parsed, so
		// that the original source text's punctuation settings in the document are preserved.
		// Export will get the possibly new punctuation settings by copying m_targetStr, so we do
		// not need to alter m_precPunct and m_follPunct on the document's CSourcePhrase instances.
		int nFinish = -1; // set in the following call
		BuildRetranslationSourcePhraseInstances(pRetransList,nSaveSequNum,nNewCount,
												nCount,nFinish);

		// delete the temporary list and delete the pointers to the CSourcePhrase instances on
		// the heap
		DeleteTempList(pRetransList);

		// remove the unused saved original source phrase copies & their list too
		// this pSaveList list will possibly have copies which contain non-empty sublists,
		// especially in m_pSavedWords, and the source phrases pointed to by that list will
		// only have had their pointers copied, so we must not delete those pointers, otherwise
		// the originals will contain hanging pointers & we'll  crash if we were to retry the
		// retranslation on the same data
		DeleteSavedSrcPhraseSublist(pSaveList);

		// set the active pile pointer - do it here (not earlier), after any null source phrases
		// have been inserted, otherwise if we are near the end of file, the pointer could be
		// invalid because no such pile exists yet. Also, since the nSaveActiveSequNum could be
		// greater than the possible max value (if we are making a retranslation at the very end
		// of the file), we must check and if necessary put the active location somewhere before
		// the retranslation
		// BEW addition 08Sep08 for support of vertical editing
		if (!gbVerticalEditInProgress)
		{
			// legacy behaviour
			gbSuppressRemovalOfRefString = TRUE; // suppress RemoveRefString() call within 
												 // PlacePhraseBox()
			bool bSetSafely = SetActivePilePointerSafely(pApp,pSrcPhrases,nSaveActiveSequNum,
															gpApp->m_nActiveSequNum,nFinish);
			gbSuppressRemovalOfRefString = FALSE; // permit RemoveRefString() in subsequent 
												  // PlacePhraseBox() calls
			gbIsRetranslationCurrent = FALSE;
			if(!bSetSafely)
			{
				// IDS_ALL_RETRANSLATIONS
				wxMessageBox(_("Warning: your document is full up with retranslations. This makes it impossible to place the phrase box anywhere in the document."), _T(""), wxICON_EXCLAMATION);
				return; // we have to return with no phrase box, since we couldn't find anywhere it
						// could be put
			}
		}
		else
		{
			// we are in adaptationsStep of vertical editing process, so we want the active pile
			// to be the one immediately following the retranslation; but if that is in the gray text
			// area beyond the end of the editable span, we set a boolean so we can later suppress
			// the reconstruction of the phrase box in the gray area, and just instead immediately
			// cause the dialog asking the user what to do for the next step to be displayed; we
			// also need to deal with the possibility the user's retranslation may make the editable
			// span longer, and update the relevant parameters in gEditRecord
			if (nNewCount > nCount)
			{
				nVerticalEdit_nExtras = nNewCount - nCount;

				// update the relevant parts of the gEditRecord (all spans are affected equally, except
				// the source text edit section is unchanged)
				gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nVerticalEdit_nExtras;
				gEditRecord.nAdaptationStep_NewSpanCount += nVerticalEdit_nExtras;
				gEditRecord.nAdaptationStep_EndingSequNum += nVerticalEdit_nExtras;
			}
			// if the test is equality or less than, then nVerticalEdit_nExtras is 0, and no
			// change to the gEditRecord is required

			// set the potential active location to the CSourcePhrase immediately following
			// the end of the retranslation
			int nPotentialActiveSequNum = nSaveSequNum + nNewCount;

			// determine if this location is within the editable span, if it is, we permit
			// the later restoration of the phrase box there; if not, we suppress the
			// restoration of the phrase box (otherwise it would be in the gray text area)
			if (!(nPotentialActiveSequNum >= gEditRecord.nAdaptationStep_StartingSequNum &&
				nPotentialActiveSequNum <= gEditRecord.nAdaptationStep_EndingSequNum))
			{
				bVerticalEdit_SuppressPhraseBox = TRUE;
			}

			nSaveActiveSequNum = nPotentialActiveSequNum; // we need a value to work with below
										// even if we suppress reconstituting of the phrase box
			gbSuppressRemovalOfRefString = TRUE; // suppress RemoveRefString() call within 
												 // PlacePhraseBox()
			bool bSetSafely;
			bSetSafely = SetActivePilePointerSafely(pApp,pSrcPhrases,nSaveActiveSequNum,
															gpApp->m_nActiveSequNum,nFinish);
			gbSuppressRemovalOfRefString = FALSE; // permit RemoveRefString() in subsequent 
												  // PlacePhraseBox() calls
			gbIsRetranslationCurrent = FALSE;
		}
	}
	else
	{
		// user cancelled, so we have to restore the original state
		gbIsRetranslationCurrent = FALSE;
		wxASSERT(pSaveList);
		int nCurCount = nEndSequNum - nSaveSequNum + 1; // what the selection now numbers,
														// after unmerge etc.
		int nOldCount = pSaveList->GetCount();
		wxASSERT(nOldCount >0);
		int nExtras = nCurCount - nOldCount; // needed for adjusting indices
		wxASSERT(nExtras >= 0); // cannot be negative

		// this list's source phrases have not had their KB refString entries removed/count
		// decremented, whichever is required, so we must do so now - otherwise, if they are
		// storing some adaptions, when we try to re-store them in the KB, the StoreAdapation
		// assert at 1st line will trip.
		ClearSublistKBEntries(pSaveList);

		// insert the original (saved) source phrases after the nEndSequNum one
		InsertSublistAfter(pSrcPhrases,pSaveList,nEndSequNum);

		// now remove the unwanted ones - be careful, some of these single-word ones will point
		// to memory that any merged source phrases in the saved list will point to in their
		// m_pSavedWords sublists, so don't delete the memory in the latter sublists,
		// just remove the pointers!
		RemoveUnwantedSourcePhraseInstancesInRestoredList(pSrcPhrases,nCurCount,nSaveSequNum,
															pSaveList);

		// now fix the indices, we can assume nExtras is either 0 or positive
		pApp->m_endIndex -= nExtras;
		pApp->m_upperIndex -= nExtras;
		pApp->m_maxIndex -= nExtras;
		if (nSaveActiveSequNum > nSaveSequNum + nOldCount - 1)
			nSaveActiveSequNum -= nExtras; // decrement only if it lay after the original
										   // selection

		// renumber the sequence numbers
		UpdateSequNumbers(0);

		// remove the pointers in the saved list, and delete the list, but leave the instances
		// undeleted since they are now pointed at by elements in the pSrcPhrases list
		if (pSaveList->GetCount() > 0)
		{
			pSaveList->Clear();
		}
		delete pSaveList; // don't leak memory
		pSaveList = (SPList*)NULL;
	}

	// delete the temporary list after removing its pointer copies (copy constructor was not
	// used on this list, so removal of pointers is sufficient)
	pList->Clear();
	delete pList;
	pList = (SPList*)NULL;

	// recalculate the layout
	RecalcLayout(pSrcPhrases,0,pBundle); // can fail if the recalculated bundle has fewer strips
										 // than nStartingStripIndex, so use 0 to be always safe
	// get a new valid active pile pointer
	pApp->m_nActiveSequNum = nSaveActiveSequNum;
	pApp->m_pActivePile = GetPile(nSaveActiveSequNum);
	pSrcPhrase = pApp->m_pActivePile->m_pSrcPhrase;
	wxASSERT(pSrcPhrase != NULL);

	// determine the text to be shown, if any, in the target box when it is recreated
	// When placing the phrasebox after doing a retranslation, or edit of a retranslation, or
	// removal of a retranslation. Introduced in version 1.4.2, because in earlier versions
	// if there was more than one translation available at the location where the phrasebox
	// gets put, the earlier code (in RestoreTargetBoxText( )) would put up the Choose
	// Translation dialog, which is a nuisance when the translation there is already correct;
	// so now we do that call only when we cannot ascertain a valid translation from the
	// source phrase at that point.
	// BEW additions 08Sep08 for support of vertical editing mode
	wxString str3;
	if (!gbVerticalEditInProgress)
	{
legacy:	if (pSrcPhrase->m_targetStr.IsEmpty() && !pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB)
		{
			gpApp->m_pTargetBox->m_bAbandonable = TRUE;
			RestoreTargetBoxText(pSrcPhrase,str3); // for getting a suitable m_targetStr contents
		}
		else
		{
			str3 = pSrcPhrase->m_targetStr; // if we have something
			gpApp->m_pTargetBox->m_bAbandonable = FALSE;
		}

		// it is okay to do the Remove call with pRefString == NULL, in fact, it must be done
		// whether NULL or not; since if it is NULL, RemoveRefString will clear pSrcPhrase's 
		// m_bHasKBEntry to FALSE, which if not done, would result in a crash if the user clicked on
		// a source phrase which had its reference string manually removed from the KB and then 
		// clicked on another source phrase. (The StoreAdaption call in the second click would trip
		// the first line's ASSERT.)
		CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key,pSrcPhrase->m_adaption);
		RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

		gpApp->m_targetPhrase = str3; // in our 4-line version, the Phrase Box can have punctuation 
							   // as well as text
		gpApp->m_pTargetBox->SetValue(str3);
		gnStart = 0;
		gnEnd = -1;

		// layout again, so that the targetBox won't encroach on the next cell's adaption text 
		// (can't just layout the strip, because if the text is long then source phrases get pushed
		// off into limbo and we get access violation & null pointer returned in the GetPile call)
		// RecalcLayout(pSrcPhrases,nStartingStripIndex,pBundle);
		// can fail if the recalculated bundle has fewer strips than nStartingStripIndex, so use 
		// 0 to be always safe
		RecalcLayout(pSrcPhrases,0,pBundle);
		
		// get a new valid active pile pointer
		gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);

		// create the phraseBox at the active pile
		gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;
		RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
		gpApp->m_pTargetBox->SetFocus();
		gpApp->m_pTargetBox->SetSelection(-1,-1); // -1,-1 selects all // SetSel(0,-1,TRUE); // no scroll
	}
	else
	{
		// vertical edit mode is in operation, and a recalc of the layout has been done, so
		// it remains just to determine whether or not to suppress the phrase box and if so
		// to transition to the next step, otherwise send control to the legacy code to have
		// the phrase box created at the active location
		if (bVerticalEdit_SuppressPhraseBox)
		{
			// the active location is in the gray text area, so don't build the phrase box
			// (in wxWidgets, instead hide the phrase box at this point); and instead transition
			// to the next step
			bool bCommandPosted;
			bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(-1, nextStep, TRUE);
		}
		else
			goto  legacy;
	}

	// remove selection and update the display
	RemoveSelection();
	Invalidate();

	// ensure respect for boundaries is turned back on
	if (!pApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(event);
	gbInsertingWithinFootnote = FALSE; // restore default value
}

// ********************************************************************************************
// End section for  OnButtonRetranslation()
// ********************************************************************************************

// ********************************************************************************************
//
// Begin section for  OnButtonEditRetranslation()
//
// Helper functions:
// IsEndInCurrentSelection()
// AccumulateText()
// ReplaceMatchedSubstring()
//
// ********************************************************************************************

bool CAdapt_ItView::IsEndInCurrentSelection()
{
	CCellList::Node* pos = gpApp->m_selection.GetLast(); 
	CCell* pCell = (CCell*)pos->GetData();
	pos = pos->GetPrevious();
	bool bCurrentSection = TRUE;
	while( pos != NULL)
	{
		pCell = (CCell*)pos->GetData();
		pos = pos->GetPrevious();
		CPile* pPile2 = pCell->m_pPile;
		if (pPile2->m_pSrcPhrase->m_bEndRetranslation)
		{
			bCurrentSection = FALSE;
			break;
		}
	}
	return bCurrentSection;
}

void CAdapt_ItView::GetRetranslationSourcePhrasesStartingAnywhere(CPile* pStartingPile,
																  CPile*& pFirstPile,
																  SPList* pList)
{
	pFirstPile = pStartingPile; // first pile in the retranslation section, initialize to
								// the one clicked or selected, in case the first was clicked
								// or selected in which case the first loop below will not be
								// entered and we'd otherwise not set pFirstPile at all

	CSourcePhrase* pSrcPhrase = pStartingPile->m_pSrcPhrase;
	// wx Note: wxList::Insert() Inserts object at front of list = CObList's AddHead()
	pList->Insert(pSrcPhrase); // add the one we've found already
	CPile* pPile = pStartingPile;
	if (pFirstPile->m_pSrcPhrase->m_bBeginRetranslation)
		goto b; // skip next block if we are at beginning of the retranslation as
				// previously constituted

	while ((pPile = GetPrevPile(pPile)) != NULL && pPile->m_pSrcPhrase->m_bRetranslation)
	{
		pList->Insert(pPile->m_pSrcPhrase);
		pFirstPile = pPile; // last time thru this loop leaves this variable with the value
							// we want

		// go back only to the source phrase with m_bBeginRetranslation set TRUE, but if none
		// such is found, then continue until the loop test gives an exit
		if (pPile->m_pSrcPhrase->m_bBeginRetranslation)
			break; // we are at the start of the retranslation section as earlier constituted
	}

b:	pPile = pStartingPile;
	if (pStartingPile->m_pSrcPhrase->m_bEndRetranslation)
		return; // skip next block if we are at the end of the retranslation as previously
				// constituted

	while ((pPile = GetNextPile(pPile)) != NULL && pPile->m_pSrcPhrase->m_bRetranslation)
	{
		pList->Append(pPile->m_pSrcPhrase); 

		// break when we come to one with m_bEndRetranslation flag set TRUE
		if (pPile->m_pSrcPhrase->m_bEndRetranslation)
			break;
	}
}

void CAdapt_ItView::AccumulateText(SPList* pList,wxString& strSource,wxString& strAdapt)
{
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	wxString str;
	wxString str2;

	while (pos != NULL)
	{
		// accumulate the old retranslation's text
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		str = pSrcPhrase->m_targetStr;
		if (strAdapt.IsEmpty())
		{
			strAdapt += str;
		}
		else
		{
			if (!str.IsEmpty())
				strAdapt += _T(" ") + str;
		}

		// also accumulate the source language text (line 1), provided it is not a null
		// source phrase
		if (!pSrcPhrase->m_bNullSourcePhrase)
		{
			str2 = pSrcPhrase->m_srcPhrase;
			if (strSource.IsEmpty())
			{
				strSource = str2;
			}
			else
			{
				strSource += _T(" ") + str2;
			}
		}
	}
}

void CAdapt_ItView::ReplaceMatchedSubstring(wxString strSearch, wxString& strReplace,
											wxString& strAdapt)
// finds the strSearch in strAdapt, and replaces it with strReplace, updating strAdapt in
// the caller
{
		int nFound = -1;
		int lenAdaptStr = 0;
		int lenTgt = 0;
		int nRight;
		wxString left;
		left.Empty();
		wxString right;
		right.Empty();
		lenTgt = strSearch.Length(); // the search string's length
		lenAdaptStr = strAdapt.Length(); // length of the string in which the search is done
		nFound = strAdapt.Find(strSearch);
		wxASSERT(nFound != -1); // must not have failed, since this was the match done in caller
		left = strAdapt.Left(nFound);
		nRight = nFound + lenTgt;
		wxASSERT(nRight <= lenAdaptStr);
		nRight = lenAdaptStr - nRight;
		right = strAdapt.Right(nRight);

		// put the final string into the strAdapt alias string in caller
		strAdapt = left + strReplace + right;
}

void CAdapt_ItView::OnButtonEditRetranslation(wxCommandEvent& event)
// Modified for support of glossing. (This function cannot be used when glossing is ON.)
{
	// Since the Edit Retranslation toolbar button has an accelerator table hot key (CTRL-E see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_EDIT_RETRANSLATION))
	{
		::wxBell();
		return;
	}

	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),_T(""), wxICON_INFORMATION);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = gpApp->GetDocument(); 
	SPList* pList = new SPList; // list of the CSourcePhrase objects in the retranslation section
	SPList* pSrcPhrases = gpApp->m_pSourcePhrases;
	CPile* pStartingPile = NULL;
	CSourcePhrase* pSrcPhrase;
	int nSaveActiveSequNum = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;

	// get the source phrases which comprise the section which is retranslated; but first check if
	// we have a selection, and if so start from the first pile in the selection; otherwise, we
	// have an error condition.
	CCell* pCell;
	CCellList::Node* cpos;
	if (gpApp->m_selectionLine != -1)
	{
		// there is a selection current
		cpos = gpApp->m_selection.GetFirst();
		pCell = (CCell*)cpos->GetData();
		if (pCell != NULL)
		{
			pStartingPile = pCell->m_pPile; // since the selection might be any single srcphrase,
											// not necessarily the first in the retranslation,
											// we must reset this later to the true first one
			pSrcPhrase = pStartingPile->m_pSrcPhrase;
			if (!pSrcPhrase->m_bRetranslation)
			{
				// an error state
				//IDS_NO_REMOVE_RETRANS
h:				wxMessageBox(_("Sorry, the whole of the selection was not within a section of retranslated text, so the command has been ignored."), _T(""), wxICON_EXCLAMATION);
				RemoveSelection();
				delete pList;
				Invalidate();
				return;
			}
		}
	}

	// also check that the end of the selection is also part of the retranslation, if not, return
	cpos = gpApp->m_selection.GetLast();
	pCell = (CCell*)cpos->GetData();
	CPile* pPile2 = pCell->m_pPile;
	if (!pPile2->m_pSrcPhrase->m_bRetranslation)
	{
		// an error state
		goto h;
	}
	else
	{
		// must also check that there is no preceding pile which has a sourcephrase with
		// its m_bEndRetranslation flag set TRUE, if so, the selection lies in a following
		// retranslation section, and so the selection is invalid for delineating one retranslation
		bool bCurrentSection = IsEndInCurrentSelection();
		if (!bCurrentSection)
			goto h;
	}

	// we are in a single retranslation section, so get the source phrases into pList
	RemoveSelection();
	CPile* pFirstPile = 0;
	GetRetranslationSourcePhrasesStartingAnywhere(pStartingPile,pFirstPile,pList);

	int nSaveSequNum = pFirstPile->m_pSrcPhrase->m_nSequNumber; // save its sequ number,
									// everything depends on this - its the first in the sublist

	// copy the list to a 2nd list for saving the original state, in case the user hits the Cancel
	// button in the dialog, and save the old sequ num value for the active location; we don't save
	// copies of the pointers, but instead use the copy constructor to make fresh copies of the
	// original selection's source phrases - but note, in the m_pSavedWords sublists, if they have
	// something, the copy constructor only copies the pointers, & doesn't make new copies, so
	// beware that some source phrases might be pointed at from more than one place - which
	// affects how we delete
	SPList* pSaveList = new SPList;
	CopySourcePhraseList(pList,pSaveList);

	// deliberately abandon contents of box at active loc'n - we'll reconstitute it as necessary
	// later, depending on where we want to place the targetBox. But before we abandon it, we
	// must first check if the active location is outside the selection - since there could be
	// a just-edited entry in the phrase box which is not yet entered in the knowledge base, and
	// the active location's source phrase doesn't yet have its m_adaption and m_targetStr
	// members updated, so we must check for this condition and if it obtains then we must first
	// update everything at the active location before we empty m_targetPhrase, etc.
	SPList::Node* pos = 0;
	if (gpApp->m_pActivePile != NULL)
	{
		CSourcePhrase* pActiveSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
		pos = pList->GetFirst();
		bool bInSelection = FALSE;
		while (pos != NULL)
		{
			CSourcePhrase* pSP = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (pSP == pActiveSrcPhrase)
			{
				bInSelection = TRUE;
				break;
			}
		}

		// BEW added 20Mar07: to suppress removing of KB entries during edit of retranslation
		gbIsRetranslationCurrent = TRUE;

		if (!bInSelection)
		{
			// the active location is not within the retranslation section, so update before
			// throwing it all out
			MakeLineFourString(gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
			RemovePunctuation(pDoc,&gpApp->m_targetPhrase,1 /*from tgt*/);
			if (!gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
			{
				gbInhibitLine4StrCall = TRUE;
				bool bOK = StoreText(pApp->m_pKB,gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
				if (!bOK)
				{
					gbIsRetranslationCurrent = FALSE;
					return; // can't proceed until a valid adaption (which could be null) 
							// is supplied for the former active pile's srcPhrase
				}
				else
				{
					int nFormerStrip = gpApp->m_pActivePile->m_pStrip->m_nStripIndex;
					int nCurStripIndex = pFirstPile->m_pStrip->m_nStripIndex;
					if (nCurStripIndex != nFormerStrip)
					{
						// layout the former strip too, if it is not the current one
						LayoutStrip(gpApp->m_pSourcePhrases,nFormerStrip,gpApp->m_pBundle);
						Invalidate();
					}
				}
			}
		}
	}
	gpApp->m_targetPhrase.Empty();
	if (gpApp->m_pTargetBox->GetHandle() != NULL && gpApp->m_pTargetBox->IsShown())
	{
		gpApp->m_pTargetBox->SetValue(gpApp->m_targetPhrase); // clear it
	}

	// we have to accumulate now the text comprising the current retranslation, since we won't
	// be able to recover it fully after we throw away any null source phrases which may be
	// present.
	wxString strAdapt; // accumulates the existing adaptation text for the selection
	strAdapt.Empty();
	wxString str; // a temporary storage string
	str.Empty();
	wxString str2; // second temporary storage
	str2.Empty();
	wxString strSource; // the source text which is to be retranslated (now line 1, not line 2)
	strSource.Empty();
	AccumulateText(pList,strSource,strAdapt);


	// if we are invoking this function because of a Find & Replace match within the retranslation,
	// then replace the portion of the strAdapt string which was matched with the replacement
	// string found in the global gReplStr
	if (gbReplaceInRetranslation)
	{
		ReplaceMatchedSubstring(gSrchStr,gReplStr,strAdapt);

		// clear the globals for next time
		gbReplaceInRetranslation = FALSE;
		gSrchStr.Empty();
		gReplStr.Empty();
	}

	// determine the value for the active sequ number on exit, so we will know where to place
	// the phrase box on return to the caller; we'll place the phrase box at the first location
	// after the retranslation - provided the active location was within the selection; but if
	// it lay outside the selection, we will need to restore it to wherever it was.
	//int nEndSequNum = ((CSourcePhrase*)pList->GetTail())->m_nSequNumber;
	// break the above down into parts
	SPList::Node* spos = pList->GetLast();
	int nEndSequNum = spos->GetData()->m_nSequNumber;
	bool bActiveLocWithinSelection = FALSE;
	if (nSaveActiveSequNum >= nSaveSequNum && nSaveActiveSequNum <= nEndSequNum)
		bActiveLocWithinSelection = TRUE;
	bool bActiveLocAfterSelection = FALSE;
	if (nSaveActiveSequNum > nEndSequNum)
		bActiveLocAfterSelection = TRUE;

	// we can now clear the m_bEndRetranslation flag on the last entry of the list
	spos = pList->GetLast();
	pSrcPhrase = (CSourcePhrase*)spos->GetData();
	wxASSERT(pSrcPhrase);
	pSrcPhrase->m_bEndRetranslation = FALSE;

	// any null source phrases have to be thrown away, and the layout recalculated after updating
	// the sequence numbers of the source phrases remaining
	pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	int nCount = pList->GetCount();

	// BEW addition 08Sep08 for support of vertical editing
	bool bVerticalEdit_SuppressPhraseBox = FALSE;
	int nVerticalEdit_nExtras = 0;
	int nOriginalCount = nCount;

	// BEW added 01Aug05, to support free translations -- removing null source phrases also removes
	// m_bHasFreeTrans == TRUE instances as well, so the only thing we need check for is whether or
	// not there is m_bEndFreeTrans == TRUE on the last null source phrase removed -- if so, we must
	// set the same bool value to TRUE on the last pSrcPhrase remaining in the list after all the
	// null ones have been deleted. We do this by setting a flag in the block below, and then using
	// the set flag value in the block which follows it
	bool bEndIsAlsoFreeTransEnd = FALSE;
	while (pos != NULL)
	{
		SPList::Node* savePos = pos; 
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_bNullSourcePhrase)
		{
			// it suffices to test each one, since the m_bEndFreeTrans value will be FALSE on
			// every one, or if not so, then only the last will have a TRUE value
			if (pSrcPhrase->m_bEndFreeTrans)
				bEndIsAlsoFreeTransEnd = TRUE;

			// null source phrases in a retranslation are never stored in the KB, so we need only
			// remove their pointers from the lists and delete them from the heap
			SPList::Node* pos1 = pSrcPhrases->Find(pSrcPhrase);
			wxASSERT(pos1 != NULL); // it has to be there
			pSrcPhrases->DeleteNode(pos1); // remove its pointer from m_pSourcePhrases list on
										 // the doc
			delete pSrcPhrase; // delete the null source phrase itself
			pList->DeleteNode(savePos); // also remove its pointer from the local sublist

			// fix the indices used for the bundle & targetBox location
			gpApp->m_endIndex -= 1;
			gpApp->m_upperIndex -= 1;
			gpApp->m_maxIndex -= 1;
			nCount -= 1; // since there is one less source phrase in the selection now
			nEndSequNum -= 1;
			if (bActiveLocAfterSelection)
				nSaveActiveSequNum -= 1;
		}
		else
		{
			// of those source phrases which remain, throw away the contents of their
			// m_adaption and m_targetStr members
			pSrcPhrase->m_adaption.Empty();
			pSrcPhrase->m_targetStr.Empty();
			pSrcPhrase->m_bBeginRetranslation = FALSE;
			pSrcPhrase->m_bEndRetranslation = FALSE;
		}
	}

	// handle transferring the indication of the end of a free translation
	if (bEndIsAlsoFreeTransEnd)
	{
		SPList::Node* tpos = pList->GetLast();
		CSourcePhrase* pSPend = (CSourcePhrase*)tpos->GetData();
		pSPend->m_bEndFreeTrans = TRUE;
	}

	// update the sequence number in the whole source phrase list on the app & update indices
	// for bounds
	UpdateSequNumbers(0);

	// now we can work out where to place the phrase box on exit from this function - it is
	// currently the nSaveActiveSequNum value, unless the active location was within the
	// selection, in which case we must make the active location the first pile after the selection
	if (bActiveLocWithinSelection)
		nSaveActiveSequNum = nEndSequNum + 1;

	// clear the selection, else RecalcLayout() call will fail at the RestoreSelection() call
	// within it
	RemoveSelection();

	// we must have a valid layout, so we have to recalculate it before we go any further,
	// because if preceding code deleted null phrases, the layout's pointers would be clobbered
	// and moving the dialog window would crash the app when Draw messages use the dud pointers
	RecalcLayout(pSrcPhrases,0 /* nStartingStripIndex unsafe if bundle contracts */,gpApp->m_pBundle);

	bool bConstType;
	bConstType = IsConstantType(pList); // need this only in case gbInsertingWithinFootnote
											 // needs to be set

	// put up the CRetranslationDlg dialog
	CRetranslationDlg dlg(gpApp->GetMainFrame());

	// initialize the edit boxes
	dlg.m_sourceText = strSource;
	dlg.m_retranslation = strAdapt;
	wxString preceding;
	preceding.Empty();
	wxString following;
	following.Empty();
	wxString precedingTgt;
	precedingTgt.Empty();
	wxString followingTgt;
	followingTgt.Empty();
	GetContext(nSaveSequNum,nEndSequNum,preceding,following,precedingTgt,followingTgt);
	dlg.m_preContextSrc = preceding;
	dlg.m_preContextTgt = precedingTgt;
	dlg.m_follContextSrc = following;
	dlg.m_follContextTgt = followingTgt;

	if (dlg.ShowModal() == wxID_OK)
	{
		SPList* pRetransList = new SPList;
		wxASSERT(pRetransList);
		wxString retrans = dlg.m_retranslation;
		int nNewCount = 0; // number of CSourcePhrase instances returned from the
						   // tokenization operation

		// tokenize the retranslation into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key and m_nSequNumber are set)
		nNewCount = TokenizeTextString(pRetransList,retrans,nSaveSequNum);

		// we must have a valid layout, so we have to recalculate it before we go any further,
		// because if preceding code deleted null phrases, then the layout's pointers will be
		// clobbered
		RecalcLayout(pSrcPhrases,0 /* nStartingStripIndex unsafe if bundle contracts */,gpApp->m_pBundle);

		// get a new valid starting pile pointer, and gpApp->m_nActiveSequNum updated, etc
		pStartingPile = GetPile(nSaveSequNum);
		wxASSERT(pStartingPile != NULL);

		// ensure any call to InsertNullSrcPhrase() will work right - that function saves the
		// gpApp->m_nActiveSequNum value, and increments it by how many null source phrases were
		// inserted; so we have to present it with the decremented value agreeing with the
		// present state of the layout (which now lacks the deleted null src phrases - if any)
		if (bActiveLocAfterSelection && nNewCount > nCount)
			nSaveActiveSequNum += nNewCount - nCount;
		else
		{
			// augment it also if the active location lay within the selection
			// and null source phrases were inserted
			if (bActiveLocWithinSelection && nNewCount > nCount)
				nSaveActiveSequNum += nNewCount - nCount;
		}

		gpApp->m_nActiveSequNum = nSaveActiveSequNum; // to ensure any call to InsertNullSrcPhrase()
											   // will work right

		// determine if we need extra null source phrases inserted, and insert them if we do
		PadWithNullSourcePhrasesAtEnd(pDoc,pApp,pSrcPhrases,nEndSequNum,nNewCount,nCount);

		// copy the retranslation's words, one per source phrase, to the constituted sequence of
		// source phrases (including any null ones) which are to display it
		int nFinish = -1; // set in the following call
		BuildRetranslationSourcePhraseInstances(pRetransList,nSaveSequNum,nNewCount,nCount,
																						nFinish);

		// delete the temporary list and delete the pointers to the CSourcePhrase instances on
		// the heap
		DeleteTempList(pRetransList);

		// remove the unused saved original source phrase copies & their list too
		// this pSaveList list will possibly have copies which contain non-empty sublists,
		// especially in m_pSavedWords, and the source phrases pointed to by that list will only
		// have had their pointers copied, so we must not delete those pointers, otherwise the
		// originals will contain hanging pointers & we'll  crash if we were to retry the
		// retranslation on the same data
		DeleteSavedSrcPhraseSublist(pSaveList);

		// set the active pile pointer - do it here (not earlier), after any null source phrases
		// have been inserted, otherwise if we are near the end of file, the pointer could be
		// invalid because no such pile exists yet
		// BEW addition 08Sep08 for support of vertical editing
		if (!gbVerticalEditInProgress)
		{
			// legacy behaviour
			bool bSetSafely = SetActivePilePointerSafely(pApp,pSrcPhrases,nSaveActiveSequNum,
															gpApp->m_nActiveSequNum,nFinish);
			gbIsRetranslationCurrent = FALSE;
			if(!bSetSafely)
			{
				// IDS_ALL_RETRANSLATIONS
				wxMessageBox(_("Warning: your document is full up with retranslations. This makes it impossible to place the phrase box anywhere in the document."), _T(""), wxICON_EXCLAMATION);
				return; // we have to return with no phrase box, since we couldn't find anywhere it
						// could be put
			}
		}
		else
		{
			// we are in adaptationsStep of vertical editing process, so we want the active pile
			// to be the one immediately following the retranslation; but if that is in the gray text
			// area beyond the end of the editable span, we set a boolean so we can later suppress
			// the reconstruction of the phrase box in the gray area, and just instead immediately
			// cause the dialog asking the user what to do for the next step to be displayed; we
			// also need to deal with the possibility the user's retranslation may make the editable
			// span longer, and update the relevant parameters in gEditRecord
			nVerticalEdit_nExtras = nNewCount - nOriginalCount; // can be -ve, 0 or +ve

			// update the relevant parts of the gEditRecord
			gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nVerticalEdit_nExtras;
			gEditRecord.nAdaptationStep_NewSpanCount += nVerticalEdit_nExtras;
			gEditRecord.nAdaptationStep_EndingSequNum += nVerticalEdit_nExtras;
			
			// set the potential active location to the CSourcePhrase immediately following
			// the end of the retranslation
			int nPotentialActiveSequNum = nSaveSequNum + nNewCount;

			// determine if this location is within the editable span, if it is, we permit
			// the later restoration of the phrase box there; if not, we suppress the
			// restoration of the phrase box (otherwise it would be in the gray text area)
			if (!(nPotentialActiveSequNum >= gEditRecord.nAdaptationStep_StartingSequNum &&
				nPotentialActiveSequNum <= gEditRecord.nAdaptationStep_EndingSequNum))
			{
				bVerticalEdit_SuppressPhraseBox = TRUE;
			}
			nSaveActiveSequNum = nPotentialActiveSequNum; // we need a value to work with below
										// even if we suppress reconstituting of the phrase box
			gbSuppressRemovalOfRefString = TRUE; // suppress RemoveRefString() call within 
												 // PlacePhraseBox()
			bool bSetSafely;
			bSetSafely = SetActivePilePointerSafely(pApp,pSrcPhrases,nSaveActiveSequNum,
															gpApp->m_nActiveSequNum,nFinish);
			gbSuppressRemovalOfRefString = FALSE; // permit RemoveRefString() in subsequent 
												  // PlacePhraseBox() calls
			gbIsRetranslationCurrent = FALSE;
		}
	}
	else
	{
		// user cancelled, so we have to restore the original retranslation
		wxASSERT(pSaveList);
		int nCurCount = nEndSequNum - nSaveSequNum + 1; // what the retranslation section
														// now numbers
		int nOldCount = pSaveList->GetCount();
		wxASSERT(nOldCount >0);
		// nOldCount >= nCurCount, because the only thing that could have happened is null source
		// phrases were removed; (and cancellation does not result in parsing what may be in the
		// dialog)
		int nExtras = nOldCount - nCurCount; // needed for adjusting indices
		wxASSERT(nExtras >= 0); // cannot be negative
		gbIsRetranslationCurrent = FALSE;

		// insert the original (saved) source phrases after the nEndSequNum one (the layout may be
		// different than at start, ie. null ones were removed) - nEndSequNum was reduced however
		// so it has the correct value at this point
		SPList::Node* pos = pSrcPhrases->Item(nEndSequNum);
		wxASSERT(pos != 0);
		SPList::Node* pos1 = pSaveList->GetLast();
		wxASSERT(pos1 != 0);

		// Get a node called newInsertBeforePos which points to the next node beyond pos
		// in pSrcPhrases and use its position in the Insert() call (which only inserts
		// BEFORE the indicated position). The result should be that the insertions
		// will get placed in the list the same way that MFC's InsertAfter() places them.
		SPList::Node* newInsertBeforePos = pos->GetNext();
		//CSourcePhrase* pSPTest = newInsertBeforePos->GetData(); //for testing
		while (pos1 != 0)
		{
			// these will be minimal ones, so no restoring in KB is required, as these are
			// effectively not 'encountered' yet
			CSourcePhrase* pSPhr = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetPrevious();
			wxASSERT(pSPhr != NULL);

			// wxList has no equivalent to InsertAfter(). The wxList Insert() method
			// inserts the new node BEFORE the current position/node. To emulate what
			// the MFC code does, we insert before using newInsertBeforePos.
			// wx note: If newInsertBeforePos is NULL, it means the insert position is
			// at the end of the list; in this case we just append the item to the end
			// of the list.
			if (newInsertBeforePos == NULL)
				pSrcPhrases->Append(pSPhr);
			else
				pSrcPhrases->Insert(newInsertBeforePos,pSPhr); //pSrcPhrases->InsertAfter(pos,pSPhr);

			// since we must now insert before the inserted node above, we need to get a
			// previous node (which will actually be the just inserted source phrase)
			newInsertBeforePos = newInsertBeforePos->GetPrevious();
			//CSourcePhrase* pSPTest = newInsertBeforePos->GetData(); // for testing
		}

		// now remove the unwanted ones - be careful, some of these single-word ones will point
		// to memory that any merged source phrases in the saved list will point to in their
		// m_pSavedWords sublists, so don't delete the memory in the latter sublists,
		// just remove the pointers!
		pos = pSrcPhrases->Item(nSaveSequNum); // first one's position
		int count = 0;
		while (pos != NULL && count < nCurCount)
		{
			SPList::Node* savePos = pos;
			CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

			// before we can delete it, we must check it's not one of those (minimal) source
			// phrases which is in the sublist of a merged source phrase in the saved list - if
			// we deleted it,we'd be deleting something we must retain; but we would want to
			// remove it's pointer from the list (because it's to be accessed only by the
			// m_pSavedWords sublist of whichever merged source phrase was formed from it)
			bool bCanDelete = TRUE;
			SPList::Node* posSaveList = pSaveList->GetFirst();
			wxASSERT(posSaveList != 0);
			while (posSaveList != 0)
			{
				CSourcePhrase* pSP = (CSourcePhrase*)posSaveList->GetData();
				posSaveList = posSaveList->GetNext();
				wxASSERT(pSP != 0);
				if (pSP->m_nSrcWords == 1)
					continue; // its a copy without a sublist, so ignore it
				else
				{
					// its a copy with a sublist, so see if any source phrase in the sublist is
					// a match for the one we wish to delete; if it is, don't delete it, just
					// remove its pointer from the m_pSourcePhrases list only
					SPList* pL = pSP->m_pSavedWords;
					wxASSERT(pL->GetCount() > 1);
					SPList::Node* pos4 = pL->GetFirst();
					wxASSERT(pos4 != 0);
					while (pos4 != 0)
					{
						CSourcePhrase* pSPhr = (CSourcePhrase*)pos4->GetData();
						pos4 = pos4->GetNext();
						wxASSERT(pSPhr != 0);
						if (pSPhr == pSrcPhrase)
						{
							// we have a match
							bCanDelete = FALSE;
							break;
						}
					}
				}
			}
			if (bCanDelete)
			{
				if (pSrcPhrase->m_pMedialMarkers->GetCount() > 0)
				{
					pSrcPhrase->m_pMedialMarkers->Clear(); // can clear the strings safely
					delete pSrcPhrase->m_pMedialMarkers;
				}

				if (pSrcPhrase->m_pMedialPuncts->GetCount() > 0)
				{
					pSrcPhrase->m_pMedialPuncts->Clear(); // can clear the strings safely
					delete pSrcPhrase->m_pMedialPuncts;
				}

				// don't delete any saved CSourcePhrase instances forming a phrase (and these
				// will never have medial puctuation nor medial markers nor will they store
				// any saved minimal phrases since they are CSourcePhrase instances for single
				// words only) - just clear the pointers
				if (pSrcPhrase->m_pSavedWords->GetCount() > 0)
				{
					pSrcPhrase->m_pSavedWords->Clear(); // just remove the pointers
					delete pSrcPhrase->m_pSavedWords;		// and delete the list from the heap
				}

				// finally delete the source phrase copy itself
				delete pSrcPhrase;

				// remove its pointer from the list
				pSrcPhrases->DeleteNode(savePos); //pSrcPhrases->RemoveAt(savePos);

				// augment the count of how many have been removed
				count++;
			}
			else
			{
				// this is one we cannot delete, but must just remove its pointer from the list
				pSrcPhrases->DeleteNode(savePos);

				// augment the count of how many have been removed
				count++;
			}
		}

		// now fix the indices, we can assume nExtras is either 0 or positive
		gpApp->m_endIndex += nExtras;
		gpApp->m_upperIndex += nExtras;
		gpApp->m_maxIndex += nExtras;

		// set the active sequ number - it must not be in the retranslation
		int nSequNumImmedAfter = nSaveSequNum + nOldCount;
		if (nSaveActiveSequNum < nSaveSequNum)
		{
			// it earlier than retranslation, so leave it unchanged
			;
		}
		else if (nSaveActiveSequNum < nSequNumImmedAfter)
		{
			// it's still within the retranslation, which is illegal, so put it immed after
			nSaveActiveSequNum = nSequNumImmedAfter;
		}
		else
		{
			// add nExtras to it, to preserve it's former value
			nSaveActiveSequNum += nExtras;
		}

		// renumber the sequence numbers
		UpdateSequNumbers(0);

		// remove the pointers in the saved list, and delete the list, but leave the instances
		// undeleted since they are now pointed at by elements in the pSrcPhrases list
		if (pSaveList->GetCount() > 0)
		{
			pSaveList->Clear();
		}
		delete pSaveList; // don't leak memory
	}

	// delete the temporary list after removing its pointer copies
	pList->Clear();
	delete pList;

	// recalculate the layout from the first strip in the selection, to force the text to change
	// color
	RecalcLayout(pSrcPhrases,0 /* nStartingStripIndex unsafe if bundle contracts */,gpApp->m_pBundle);

	// get a new valid active pile pointer
	gpApp->m_nActiveSequNum = nSaveActiveSequNum;
	gpApp->m_pActivePile = GetPile(nSaveActiveSequNum);
	pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
	wxASSERT(pSrcPhrase != NULL);

	// determine the text to be shown, if any, in the target box when it is recreated
	// BEW additions 08Sep08 for support of vertical editing mode
	wxString str3; // use this one for m_targetStr contents
	if (!gbVerticalEditInProgress)
	{
legacy:	str3.Empty();

		// we want text with punctuation, for the 4-line version
		if (!pSrcPhrase->m_targetStr.IsEmpty() && 
								(pSrcPhrase->m_bHasKBEntry || pSrcPhrase->m_bNotInKB))
		{
			str3 = pSrcPhrase->m_targetStr;
			gpApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
			// the Jump( ) call embedded in the PlacePhraseBox( ) which is in turn within
			// SetActivePilePointerSafely( ) will clear the adaptation (or reduce its ref count,)
			// if it exists at the active location; which will cause the above test to land control
			// in this block; so we don't want to do a lookup (it would not find anything if the
			// jump removed the adaptation, and then the source would be copied) because we could 
			// then lose the phrasebox contents when in fact they are still good - so if the 
			// sourcephrase at the active location has a nonempty target string, we'll use that. 
			// Otherwise, get it by a lookup.
			if (pSrcPhrase->m_targetStr.IsEmpty())
			{
				gpApp->m_pTargetBox->m_bAbandonable = TRUE;
				RestoreTargetBoxText(pSrcPhrase,str3); // for getting a suitable m_targetStr contents
			}
			else
			{
				str3 = pSrcPhrase->m_targetStr;
				gpApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
		}

		// it is okay to do the Remove call with pRefString == NULL, in fact, it must be done 
		// whether NULL or not; since if it is NULL, RemoveRefString will clear pSrcPhrase's 
		// m_bHasKBEntry to FALSE, which if not done, would result in a crash if the user clicked on
		// a source phrase which had its reference string manually removed from the KB and then
		// clicked on another source phrase. (The StoreAdaption call in the second click would trip
		// the first line's ASSERT.)
		CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key,pSrcPhrase->m_adaption);
		RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

		gpApp->m_targetPhrase = str3;
		if (gpApp->m_pTargetBox != NULL)
		{
			gpApp->m_pTargetBox->SetValue(str3);
		}

		// layout again, so that the targetBox won't encroach on the next cell's adaption text 
		// (can't just layout the strip, because if the text is long then source phrases get pushed 
		// off into limbo and we get access violation & null pointer returned in the GetPile call)
		RecalcLayout(pSrcPhrases,0 /* nStartingStripIndex unsafe if bundle contracts */,gpApp->m_pBundle);
		
		// get a new valid active pile pointer
		gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);

		// create the phraseBox at the active pile
		gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;
		RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
		gpApp->m_pTargetBox->SetSelection(-1,-1); // -1,-1 selects all
		gpApp->m_pTargetBox->SetFocus();
		gnStart = 0;
		gnEnd = -1;
	}
	else
	{
		// vertical edit mode is in operation, and a recalc of the layout has been done, so
		// it remains just to determine whether or not to suppress the phrase box and if so
		// to transition to the next step, otherwise send control to the legacy code to have
		// the phrase box created at the active location
		if (bVerticalEdit_SuppressPhraseBox)
		{
			// the active location is in the gray text area, so don't build the phrase box
			// (in wxWidgets, instead hide the phrase box at this point); and instead transition
			// to the next step
			bool bCommandPosted;
			bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(-1, nextStep, TRUE);
		}
		else
			goto  legacy;
	}

	// remove selection and update the display
	RemoveSelection();

	Invalidate();

	// ensure respect for boundaries is turned back on
	if (!gpApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(event);
	gbInsertingWithinFootnote = FALSE; // restore default value
}

void CAdapt_ItView::OnRemoveRetranslation(wxCommandEvent& event)
// Modified for support of glossing. (Invalid function when glossing is ON, so it just returns.)
{
	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),_T(""),wxICON_INFORMATION);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	SPList* pList = new SPList; // list of the CSourcePhrase objects in the retranslation section
	SPList* pSrcPhrases = gpApp->m_pSourcePhrases;
	CPile* pStartingPile = NULL;
	CSourcePhrase* pSrcPhrase;
	CCell* pCell;

	// get the source phrases which comprise the section which is retranslated; first check if
	// we have a selection, and if so start from the first pile in the selection; otherwise, the
	// location to start from must be the target box's location (ie. the active pile); if it's
	// neither of those then we have an error condition
	CCellList::Node* cpos;
	if (gpApp->m_selectionLine != -1)
	{
		// there is a selection current
		cpos = gpApp->m_selection.GetFirst();
		pCell = (CCell*)cpos->GetData();
		if (pCell != NULL)
		{
			pStartingPile = pCell->m_pPile;
			pSrcPhrase = pStartingPile->m_pSrcPhrase;
			if (!pSrcPhrase->m_bRetranslation)
			{
				// an error state
				// IDS_NO_REMOVE_RETRANS
h:				wxMessageBox(_("Sorry, the whole of the selection was not within a section of retranslated text, so the command has been ignored."), _T(""), wxICON_EXCLAMATION);
				RemoveSelection();
				delete pList;
				Invalidate();
				return;
			}
		}
	}

	// also check that the end of the selection is also part of the retranslation, if not, return
	cpos = gpApp->m_selection.GetLast();
	pCell = (CCell*)cpos->GetData();
	CPile* pPile2 = pCell->m_pPile;
	if (!pPile2->m_pSrcPhrase->m_bRetranslation)
	{
		// an error state
		goto h;
	}
	else
	{
		// must also check that there is no preceding pile which has a sourcephrase with
		// its m_bEndRetranslation flag set TRUE, if so, the selection lies in a following
		// retranslation section, and so the selection is invalid for delineating one retranslation
		bool bCurrentSection = IsEndInCurrentSelection();
		if (!bCurrentSection)
			goto h;
	}

	// we are in a retranslation section, so get the source phrases into pList
	RemoveSelection();
	CPile* pFirstPile = 0;
	GetRetranslationSourcePhrasesStartingAnywhere(pStartingPile,pFirstPile,pList);

	int nStartingSequNum = pFirstPile->m_pSrcPhrase->m_nSequNumber;

	// We must first check if the active location is outside the selection - since there could be
	// a just-edited entry in the phrase box which is not yet entered in the knowledge base, and
	// the active location's source phrase doesn't yet have its m_adaption and m_targetStr
	// members updated, so we must check for this condition and if it obtains then we must first
	// update everything at the active location before we proceed
	if (gpApp->m_pActivePile != NULL)
	{
		CSourcePhrase* pActiveSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
		SPList::Node* pos = pList->GetFirst();
		bool bInSelection = FALSE;
		while (pos != NULL)
		{
			CSourcePhrase* pSP = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (pSP == pActiveSrcPhrase)
			{
				bInSelection = TRUE;
				break;
			}
		}
		if (!bInSelection)
		{
			// the active location is not within the retranslation section, so update before
			// throwing it all out
			MakeLineFourString(gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
			RemovePunctuation(pDoc,&gpApp->m_targetPhrase,1 /*from tgt*/);
			if (gpApp->m_targetPhrase != gpApp->m_pActivePile->m_pSrcPhrase->m_adaption)
			{
				gbInhibitLine4StrCall = TRUE;
				bool bOK = StoreText(pApp->m_pKB,gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
				if (!bOK)
					return; // can't proceed until a valid adaption (which could be null)
							// is supplied for the former active pile's srcPhrase
				else
				{
					int nFormerStrip = gpApp->m_pActivePile->m_pStrip->m_nStripIndex;
					int nCurStripIndex = pStartingPile->m_pStrip->m_nStripIndex;
					if (nCurStripIndex != nFormerStrip)
					{
						// layout the former strip too, if it is not the current one
						LayoutStrip(gpApp->m_pSourcePhrases,nFormerStrip,gpApp->m_pBundle);
						Invalidate();
					}
				}
			}
		}
	}

	// accumulate the translation text of the old retranslation, so that we can put it in
	// the compose bar's CEdit, in case user wants it preserved
	wxString strAdapt; // accumulates the existing adaptation text for the retranslation
	strAdapt.Empty();
	wxString str2; // a temporary storage string
	str2.Empty();
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		// accumulate the old retranslation's text
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		str2 = pSrcPhrase->m_targetStr;
		if (strAdapt.IsEmpty())
		{
			strAdapt += str2;
		}
		else
		{
			if (!str2.IsEmpty())
				strAdapt += _T(" ") + str2;
		}
	}

	// put the text in the compose bar
	CMainFrame* pMainFrm = gpApp->GetMainFrame();
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	if(pBar != NULL)
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			pEdit->SetValue(strAdapt);
		}
	}

	// any null source phrases have to be thrown away, and the layout recalculated after updating
	// the sequence numbers of the source phrases remaining
	pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	int nCount = pList->GetCount();
	int nDeletions = 0; // number of null source phrases to be deleted (needed for adjusting
						// gpApp->m_endIndex)
	// BEW added 01Aug05, to support free translations -- removing null source phrases also removes
	// m_bHasFreeTrans == TRUE instances as well, so the only thing we need check for is whether or
	// not there is m_bEndFreeTrans == TRUE on the last null source phrase removed -- if so, we must
	// set the same bool value to TRUE on the last pSrcPhrase remaining in the list after all the
	// null ones have been deleted. We do this by setting a flag in the block below, and then using
	// the set flag value in the block which follows it
	bool bEndIsAlsoFreeTransEnd = FALSE;
	while (pos != NULL)
	{
		SPList::Node* savePos = pos;
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_bNullSourcePhrase)
		{
			// it suffices to test each one, since the m_bEndFreeTrans value will be FALSE on
			// every one, or if not so, then only the last will have a TRUE value
			if (pSrcPhrase->m_bEndFreeTrans)
				bEndIsAlsoFreeTransEnd = TRUE;

			// null source phrases in a retranslation are never stored in the KB, so we need only
			// remove their pointers from the lists and delete them from the heap
			nDeletions++; // count it
			SPList::Node* pos1 = pSrcPhrases->Find(pSrcPhrase); 
			wxASSERT(pos1 != NULL); // it has to be there
			pSrcPhrases->DeleteNode(pos1); // remove its pointer from m_pSourcePhrases list on
										 // the doc
			delete pSrcPhrase->m_pMedialPuncts;
			delete pSrcPhrase->m_pMedialMarkers;
			pSrcPhrase->m_pSavedWords->Clear();
			delete pSrcPhrase->m_pSavedWords;
			delete pSrcPhrase; // delete the null source phrase itself
			pList->DeleteNode(savePos); // also remove its pointer from the local sublist
		}
		else
		{
			// of those source phrases which remain, throw away the contents of their m_adaption
			// member, and also the m_targetStr member, and clear the flags for start and end,
			// and clear the flags which designate them as retranslations and not in the KB
			pSrcPhrase->m_adaption.Empty();
			pSrcPhrase->m_targetStr.Empty();
			pSrcPhrase->m_bRetranslation = FALSE;
			if (IsItNotInKB(pSrcPhrase))
				pSrcPhrase->m_bNotInKB = TRUE;
			else
				pSrcPhrase->m_bNotInKB = FALSE;
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pSrcPhrase->m_bBeginRetranslation = FALSE;
			pSrcPhrase->m_bEndRetranslation = FALSE;

			// we have to restore the original punctuation too
			RestoreOriginalPunctuation(pSrcPhrase);
		}
	}

	// check if we removed any, if so, we need to renumber the sequence numbers & adjust end index
	gpApp->m_endIndex -= nDeletions;
	gpApp->m_maxIndex -= nDeletions;
	gpApp->m_upperIndex -= nDeletions;
	if ((int)pList->GetCount() < nCount)
	{
		// handle transferring the indication of the end of a free translation
		if (bEndIsAlsoFreeTransEnd)
		{
			SPList::Node* spos = pList->GetLast();
			CSourcePhrase* pSPend = (CSourcePhrase*)spos->GetData();
			pSPend->m_bEndFreeTrans = TRUE;
		}

		// update the sequence numbers to be consecutive across the deletion location
		UpdateSequNumbers(nStartingSequNum);
	}

	// BEW added 09Sep08 in support of vertical editing mode
	if (gbVerticalEditInProgress && nDeletions != 0)
	{
		gEditRecord.nAdaptationStep_EndingSequNum -= nDeletions;
		gEditRecord.nAdaptationStep_ExtrasFromUserEdits -= nDeletions;
		gEditRecord.nAdaptationStep_NewSpanCount -= nDeletions;
	}

	// we must allow the user the chance to adapt the section of source text which is now no longer
	// a retranslation, so the targetBox must be placed at the first pile of the section - but
	// first we must recalculate the layout
	gpApp->m_nActiveSequNum = nStartingSequNum;

	// now do the recalculation of the layout & update the active pile pointer
	RecalcLayout(pSrcPhrases,0 /* nStartingStripIndex unsafe if bundle contracts */,gpApp->m_pBundle);
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum); // need this uptodate so that
											   // RestoreTargetBoxText( ) call will not fail
											   // in the code which is below
	// get the text to be displayed in the target box, if any
	SPList::Node* spos = pList->GetFirst();
	pSrcPhrase = (CSourcePhrase*)spos->GetData();
	wxString str3;
	if (pSrcPhrase->m_targetStr.IsEmpty() && !pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB)
	{
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
		RestoreTargetBoxText(pSrcPhrase,str3); // for getting a suitable m_targetStr contents
	}
	else
	{
		str3 = pSrcPhrase->m_targetStr; // if we have something
		gpApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	gpApp->m_targetPhrase = str3;

	// get a device context, and work out the targetBox initial size
	wxClientDC aDC(gpApp->GetMainFrame()->canvas);
	wxString str = gpApp->m_targetPhrase;
	wxFont* pFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pFont = gpApp->m_pNavTextFont;
	else
		pFont = gpApp->m_pTargetFont;
	aDC.SetFont(*pFont);
	wxSize extent;
	aDC.GetTextExtent(str,&extent.x,&extent.y);
	wxString aChar = _T('w');
	wxSize charSize;
	aDC.GetTextExtent(aChar,&charSize.x,&charSize.y);
	int width = extent.GetWidth() + gnExpandBox*charSize.GetWidth();
	gpApp->m_nCurPileMinWidth = width <= gpApp->m_nCurPileMinWidth ? gpApp->m_nCurPileMinWidth : width;
	gpApp->m_curBoxWidth = gpApp->m_nCurPileMinWidth;

	// ensure the selection is removed, else RecalcLayout() will fail
	RemoveSelection();

	// put the new text into targetBox, as RemakePhraseBox needs it to be there
	gpApp->m_pTargetBox->SetValue(gpApp->m_targetPhrase);

	// update location for phraseBox creation
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);
	gpApp->m_nStartChar = 0;
	gpApp->m_nEndChar = -1; // ensure initially all is selected
	RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);

	Invalidate();
	pList->Clear();
	delete pList;

	// ensure respect for boundaries is turned back on
	if (!gpApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(event);
}

void CAdapt_ItView::RestoreOriginalPunctuation(CSourcePhrase *pSrcPhrase)
// old code based on code in TokenizeText in doc file; new code based on code in
// RemovePunctuation() which is much smarter & handles word-building punctuation properly
{
	wxString src = pSrcPhrase->m_srcPhrase;

	// first, clear any punctuation resulting from the retranslation
	pSrcPhrase->m_precPunct.Empty();
	pSrcPhrase->m_follPunct.Empty();
	pSrcPhrase->m_pMedialPuncts->Clear();
	pSrcPhrase->m_bHasInternalPunct = FALSE;

	wxString punctSet = gpApp->m_punctuation[0]; // from version 1.3.6, contains spaces as well as
											// punct chars

	// ensure there is at least one space, so "<< <" and similar sequences get spanned properly
	if (punctSet.Find(_T(' ')) == -1)
	{
		// no space in it yet, so put one there (done on the local variable only,
		// so m_punctSet[0] unchanged)
		punctSet += _T(' ');
	}

	if (FindOneOf(src,punctSet) == -1)
		return; // there are no punctuation chars in the string (except possibly word-building
				// ones) and no spaces either

	// get the preceding punctuation
	wxString precStr;
	precStr.Empty();
	int len = 0;
	wxString tempStr;
	tempStr.Empty();
	int totalLength = src.Length();
	precStr = SpanIncluding(src,punctSet);
	len = precStr.Length();
	if (len > 0)
	{
		// has initial punctuation, so strip it off and store it
		pSrcPhrase->m_precPunct = precStr;
		tempStr = pSrcPhrase->m_srcPhrase.Mid(len); // tempStr holds the rest after the punct.
		totalLength -= len; // reduce by size of punctuation chars in set
	}
	else
	{
		// no initial punctuation, so copy the lot to tempStr
		tempStr = pSrcPhrase->m_srcPhrase;
	}

	// now handle any following punctuation
	wxString key = tempStr;
	key = MakeReverse(key);
	wxString follStr;
	follStr.Empty();
	totalLength = key.Length();
	follStr = SpanIncluding(key,punctSet);
	len = follStr.Length();
	if (len > 0)
	{
		// has following punctuation so strip it off, store it (after reversing it again)
		follStr = MakeReverse(follStr);
		pSrcPhrase->m_follPunct = follStr;
		key = key.Mid(len);
		key = MakeReverse(key);
		pSrcPhrase->m_key = key;
	}
	else
	{
		// no following punctuation
		pSrcPhrase->m_key = tempStr;
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// This handler disables the "Knowledge Base Editor..." item in the Tools menu if the appropriate KB
/// is not in a ready state, otherwise it enables the "Knowledge Base Editor..." item on the Tools menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateToolsKbEditor(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT( pApp != NULL /* && pDoc != NULL*/ );

	if ((!gbIsGlossing && pApp->m_bKBReady && pApp->m_pKB != NULL) ||
		(gbIsGlossing && pApp->m_bGlossingKBReady && pApp->m_pGlossingKB != NULL))
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::OnToolsKbEditor(wxCommandEvent& WXUNUSED(event))
// Modified for support of glossing or adapting, for version 2.0 and onwards
{
	// Since the Tools KB Edit menu item has an accelerator table hot key (CTRL-K see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	// On Windows, the accelerator key doesn't appear to call the handler for a disabled menu item, but
	// I'll leave the following code here in case it works differently on other platforms.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_TOOLS_KB_EDITOR))
	{
		::wxBell();
		return;
	}

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// want the view as the owning window

	wxNotebookPage* noteBookPage[10];
	CKBEditor editorPage(pApp->GetMainFrame());
	editorPage.Centre();

	wxNotebook* pKBEditorNotebook = (wxNotebook*)editorPage.FindWindowById(ID_KB_EDITOR_NOTEBOOK);
	wxASSERT(pKBEditorNotebook != NULL);

	CKB* pKBase = NULL;
	wxString title[10];
	if (gbIsGlossing)
	{
		// wx version note: All pages are added to the wxNotebook in wxDesigner
		// so we'll simply remove all but first one.
		int ct;
		for (ct = 0; ct < (int)pKBEditorNotebook->GetPageCount(); ct++)
		{
			noteBookPage[ct] = pKBEditorNotebook->GetPage(ct);
			if (ct > 0)
			{
				pKBEditorNotebook->RemovePage(ct);
			}
		}

		noteBookPage[0] = pKBEditorNotebook->GetPage(0);
		editorPage.m_nWords = 1;

		// fix the titles to be what we want (ANSI strings)
		title[0] = _("All Gloss Words Or Phrases"); //title[0].Format(IDS_GLOSSING_TAB);

		// get the current counts for each map into the gnMapLength array
		pKBase = pApp->m_pGlossingKB;
		gnMapLength[0] = pKBase->m_pMap[0]->size();
	}
	else
	{
		// fix the titles to be what we want (ANSI strings)
		title[0] = _(" Word"); //title[0].Format(IDS_ONE_WORD);
		title[0] = _("1") + title[0];
		title[1] = _(" Words"); //title[1].Format(IDS_PLURAL_WORDS);
		title[1] = _("2") + title[1];
		title[2] = _(" Words"); //title[2].Format(IDS_PLURAL_WORDS);
		title[2] = _("3") + title[2];
		title[3] = _(" Words"); //title[3].Format(IDS_PLURAL_WORDS);
		title[3] = _("4") + title[3];
		title[4] = _(" Words"); //title[4].Format(IDS_PLURAL_WORDS);
		title[4] = _("5") + title[4];
		title[5] = _(" Words"); //title[5].Format(IDS_PLURAL_WORDS);
		title[5] = _("6") + title[5];
		title[6] = _(" Words"); //title[6].Format(IDS_PLURAL_WORDS);
		title[6] = _("7") + title[6];
		title[7] = _(" Words"); //title[7].Format(IDS_PLURAL_WORDS);
		title[7] = _("8") + title[7];
		title[8] = _(" Words"); //title[8].Format(IDS_PLURAL_WORDS);
		title[8] = _("9") + title[8];
		title[9] = _(" Words"); //title[9].Format(IDS_PLURAL_WORDS);
		title[9] = _("10") + title[9];
		int ii;

		// get the current counts for each map into the gnMapLength array
		pKBase = pApp->m_pKB;
		for (ii=0; ii<MAX_WORDS; ii++)
		{
			gnMapLength[ii] = pKBase->m_pMap[ii]->size();
		}
	}

	// use the current source and target language fonts for the list boxes
	// and edit boxes (in case there are special characters)
	// make the fonts show user's desired point size in the dialog
	CopyFontBaseProperties(pApp->m_pSourceFont,pApp->m_pDlgSrcFont);
	pApp->m_pDlgSrcFont->SetPointSize(pApp->m_dialogFontSize);

	CopyFontBaseProperties(pApp->m_pTargetFont,pApp->m_pDlgTgtFont);
	pApp->m_pDlgTgtFont->SetPointSize(pApp->m_dialogFontSize);

	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		// in this situation press m_pDlgTgtFont into service for the display of glosses
		// since we don't have an m_pDlgNavTextFont member in the app class
		CopyFontBaseProperties(pApp->m_pNavTextFont,pApp->m_pDlgTgtFont);
		pApp->m_pDlgTgtFont->SetPointSize(pApp->m_dialogFontSize);
	}

	// New feature for version 2.2.1 requested by Gene Casad. A user selection will take the
	// first CSourcePhrase instance in the selection and open the KB editor on the appropriate
	// page and with that source key selected, but if the key is not in the KB the selection
	// will default to the first item of the list. The selection in the main window can be
	// anywhere, not necessarily at the phrasebox location.
	if (pApp->m_selectionLine > 0 && pApp->m_selection.GetCount() > 0)
	{
		// we have a selection
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = (CCell*)cpos->GetData();
		CSourcePhrase* pSrcPhrase = pCell->m_pPile->m_pSrcPhrase;
		gnWordsInPhrase = pSrcPhrase->m_nSrcWords;
		gTheSelectedKey = pSrcPhrase->m_key;

		// set the active page to be shown first; for glossing ON, this will always be the one
		// and only first page, but for adapting mode ON, this could be any of 10 pages
		if (!gbIsGlossing)
		{
			editorPage.m_nWords = gnWordsInPhrase; // whm added
		}
		RemoveSelection(); // to be safe, on return from the KB editor we want predictability
		Invalidate();
	}

	if (editorPage.ShowModal() == wxID_OK) 
	{
		// make the user's changes to the KB persistent (FALSE = no Auto backup)
		if (gbIsGlossing)
			pApp->SaveGlossingKB(FALSE);
		else
			pApp->SaveKB(FALSE);
	}

	// restore focus to the targetBox
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_pTargetBox->IsShown())
		{
			int len = pApp->m_targetPhrase.Length();
			gnStart = len;
			gnEnd = len;
			pApp->m_pTargetBox->SetSelection(len,len);
			pApp->m_pTargetBox->SetFocus();
		}
	}
}

bool CAdapt_ItView::MatchAutoFixItem(AFList* pList, CSourcePhrase *pSrcPhrase,
																AutoFixRecord*& rpRec)
// the rpRec value will be undefined if FALSE is returned, if TRUE is returned, rpRec will be the
// matched auto-fix item in the list. For version 2.0 and later which supports glossing, rpRec could
// contain glossing or adapting information, depending on the setting for the gbIsGlossing flag.
// Also, in support of auto capitalization; since these strings are coming from the sourcephrase
// instances in the documents, they will have upper or lower case as appropriate; but we will need
// to allow the user to just type lower case strings when correcting in the context of AutoCaps
// being turned ON, so be careful!
{
	wxASSERT(pList != NULL);
	wxASSERT(pSrcPhrase != NULL);
	if (pList->IsEmpty())
		return FALSE;
	AFList::Node* pos = pList->GetFirst(); 
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		AutoFixRecord* pRec = (AutoFixRecord*)pos->GetData();
		pos = pos->GetNext();
		bool bTest = FALSE;
		if (gbIsGlossing)
		{
			if (pRec->key == pSrcPhrase->m_key && pRec->oldAdaptation == pSrcPhrase->m_gloss)
				bTest = TRUE;
		}
		else
		{
			if (pRec->key == pSrcPhrase->m_key && pRec->oldAdaptation == pSrcPhrase->m_adaption)
				bTest = TRUE;
		}
		if (bTest)
		{
			// we can autofix with this one, so pass its values (including any upper case) to
			// the caller (ie. to DoConsistencyCheck( )) for processing - remember, it may have
			// an old gloss or adaptation which is upper case, and the user may have typed
			// a lower case string for the finalAdaptation member, so this will need to be tested for
			rpRec = pRec;
			return TRUE;
		}
	}
	// if we get to here, no match was made
	rpRec = NULL;
	return FALSE;
}

void CAdapt_ItView::OnGoTo(wxCommandEvent& WXUNUSED(event))
{
	// Since the Edit Go To... menu item has an accelerator table hot key (CTRL-G see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	// On Windows, the accelerator key doesn't appear to call the handler for a disabled menu item, but
	// I'll leave the following code here in case it works differently on other platforms.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_GO_TO))
	{
		::wxBell();
		return;
	}

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos;
	if (pList->IsEmpty())
	{
		::wxBell();
		return;
	}

	// BEW added 28Sep05, to fix the following bug. It the globals below are not here reset,
	// and especially to the same value, then when we've been doing autoinseting at a location
	// somewhere and we go to a very different location far away in
	// the document, any call to ScrollIntoView() will invoke its "smart" code -- that takes
	// the two globals below and if they are different, it will ask for a recalculation of the
	// pile pointers for the beginning and end of the last inserted set of adaptations -- and
	// these require GetPile() calls which, because that old location was miles away further away
	// in the document, a bundle advance and layout recalculation get done in order to get valid
	// pointers - and on return from ScrollIntoView() the layout is no longer where expected and
	// the active pointer has probably become invalid. Setting both globals to zero avoids all
	// and causes the legacy scrolling block to be used in ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	// provided the phrase box exists, unconditionally enter the old phrase box's text into
	//  the KB - we assume it is complete, if not, too bad - it can be fixed later if it's wrong.
	// Oct 2004, Wolfgang Stradner requested that nothing be put in KB when Go To...
	// is being used to move around. So we look at the srcphrase and if it's m_adaption
	// member is null and the m_bAbandonable flag on the box is TRUE, then the m_targetBox
	// contents can be assumed to be unwanted and so not stored. (The step up/down buttons
	// make this kind of check already.)
	bool bOK;
	CRefString* pRefStr;
	if (pApp->m_nActiveSequNum != -1)
	{
		gnOldSequNum = pApp->m_nActiveSequNum; // preserve old location
		if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
			// abandon storage when not wanted (test added Oct 2004 - see above comment)
			if (!pApp->m_pActivePile->m_pSrcPhrase->m_adaption.IsEmpty())
			{
				pApp->m_targetPhrase = pApp->m_pActivePile->m_pSrcPhrase->m_adaption;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				pApp->m_targetPhrase.Empty();
				goto c;
			}

			if (gbIsGlossing)
			{
				// the store will fail if the user edited the entry out of the glossing KB, the latter
				// cannot know which srcPhrases will be affected, so these will still have their
				// m_bHasGlossingKBEntry set true. We have to test for this, ie. a null pRefString
				// but the m_bHasGlossing KBEntry set TRUE is a sufficient test, and if so, set the
				// flag to FALSE
				pRefStr = GetRefString(pApp->m_pGlossingKB, 1,pApp->m_pActivePile->m_pSrcPhrase->m_key,pApp->m_targetPhrase);
				if (pRefStr == NULL && pApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry)
					pApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
				bOK = StoreText(pApp->m_pGlossingKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
			}
			else
			{
				MakeLineFourString(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
				RemovePunctuation(pDoc,&pApp->m_targetPhrase,1 /*from tgt*/);

				// the store will fail if the user edited the entry out of the KB, as the latter
				// cannot know which srcPhrases will be affected, so these will still have their
				// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString but
				// the m_bHasKBEntry set TRUE is a sufficient test, and if so, set the flag to FALSE
				pRefStr = GetRefString(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
												pApp->m_pActivePile->m_pSrcPhrase->m_key,pApp->m_targetPhrase);
				if (pRefStr == NULL && pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
					pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
				gbInhibitLine4StrCall = TRUE;
				bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
			}
		}
	}
	else
	{
		gnOldSequNum = -1; // if we were at the eof, need -1 to signal no earlier valid location
	}

	// remove any selection to be safe from unwanted selection-related side effects
c:	RemoveSelection();

	wxString str;
	int nWantedChapter = 1;
	int nWantedVerse = 1;
	CGoToDlg dlg(pApp->GetMainFrame());
	if (dlg.ShowModal() == wxID_OK)
	{
		nWantedChapter = dlg.m_nChapter;
		nWantedVerse = dlg.m_nVerse; // from Oct 2004 extended version, this can be 0
						// which means "ignore the verse number, use chapter number only"

		// find the nominated chapter and verse, if possible, using the CString for chapt:verse;
		// if it fails, assume a range & try again with integers; but if verse is 0, then go straight
		// to the range block
		if (dlg.m_nVerse == 0)
			goto v;
		if (dlg.m_nChapter == 0)
		{
			// special case, either its non-scripture, or a chapterless book like 2John
			pos = pList->GetFirst();
			wxASSERT(pos != NULL);

			// first, assume it's a chapterless book like 2 John, try find the verse
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL); 
				if (pSrcPhrase->m_chapterVerse == dlg.m_verse)
				{
					if (!gbIsGlossing)
					{
						// when adapting, we must prevent placing the phrasebox within a
						// retranslation, but when glossing this does not matter
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									//IDS_GOTO_FAILED
									wxMessageBox(_("Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"), _T(""), wxICON_EXCLAMATION);
									pApp->m_pTargetBox->SetFocus();
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}
					return;
				}
			}

			// didn't find the verse, so instead put the phrase box at the first sourcephrase
			// with TextType of 'verse'
			pos = pList->GetFirst();
			wxASSERT(pos != NULL);
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_curTextType == verse)
				{
					if (!gbIsGlossing)
					{
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									// IDS_GOTO_FAILED
									wxMessageBox(_("Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"),_T(""),wxICON_EXCLAMATION);
									pApp->m_pTargetBox->SetFocus();
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}

					return;
				}
			}
		} // end chapter number == zero block
		else
		{
			// look for chapter & verse in the form  n:m
			pos = pList->GetFirst();
			wxASSERT(pos != NULL);
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_chapterVerse == dlg.m_chapterVerse)
				{
					if (!gbIsGlossing)
					{
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									// IDS_GOTO_FAILED
									wxMessageBox(_("Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"), _T(""), wxICON_EXCLAMATION);
									pApp->m_pTargetBox->SetFocus();
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}

					return;
				}
			}

			// not found, so try again, this time assuming we may have the wanted ch & verse
			// within a range in the text, such as 3-7, or 3,4 etc; or the verse may have been
			// set to zero so that only chapter numbers are to be considered
v:			pos = pList->GetFirst();
			wxASSERT(pos != NULL);
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);

				int chapter;
				int firstVerse;
				int lastVerse;
				// BW, Oct 04, extended the signature to take the nWantedVerse as an extra parameter,
				// so that when it is zero in value we can force a return once a chapter beginning
				// has been located; this extra parameter has no other internal function in the
				// AnalyseReference function, and since this function is called in nearly a dozen
				// other places, those places just need an arbitrary non-zero number passed in
				// for the nWantedVerse number so as to retain the previous functionality unchanged
				bool bOK =
					AnalyseReference(pSrcPhrase->m_chapterVerse,chapter,firstVerse,lastVerse,nWantedVerse);

				// if we've already passed the chapter, return
				if (bOK && chapter > nWantedChapter)
					goto a;

				if (bOK && chapter == nWantedChapter && nWantedVerse == 0)
					goto f;

				if (bOK && chapter == nWantedChapter && (nWantedVerse >= firstVerse
															&& nWantedVerse <= lastVerse))
				{
f:					if (!gbIsGlossing)
					{
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									// IDS_GOTO_FAILED
									wxMessageBox(_("Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"), _T(""), wxICON_EXCLAMATION);
									pApp->m_pTargetBox->SetFocus();
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}

					return;
				}

				if (bOK && chapter == nWantedChapter &&  nWantedVerse != 0
						&& lastVerse > nWantedVerse) // if passed the wanted verse
					goto a;
			}

			// not found, so tell the user
			//IDS_NO_SUCH_CHAPTER
a:			str = str.Format(_("Sorry, but the chapter and verse combination  %s  does not exist in this document. The command will be ignored."),dlg.m_chapterVerse.c_str());
			wxMessageBox(str,_T(""), wxICON_EXCLAMATION);
			pApp->m_pTargetBox->SetFocus();
			goto b;
		}
	}
	else
	{
		// user cancelled, so do nothing except remove the ref string that we stored above
		// (and most importantly, this will clear the m_bHasKBEntry on the source phrase too)
b:		CRefString* pRefStr = NULL;
		if (gbIsGlossing)
		{
			pRefStr = GetRefString(pApp->m_pGlossingKB, 1,
										pApp->m_pActivePile->m_pSrcPhrase->m_key,pApp->m_targetPhrase);
			if (pRefStr == NULL && pApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry)
				pApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
			if (pRefStr != NULL)
			{
				// remove the translation from the glossing KB, in case user wants to edit it
				// before it is stored again
				RemoveRefString(pRefStr, pApp->m_pActivePile->m_pSrcPhrase, 1);
			}
		}
		else
		{
			pRefStr = GetRefString(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
				pApp->m_pActivePile->m_pSrcPhrase->m_key,pApp->m_targetPhrase);
			if (pRefStr == NULL && pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
				pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
			if (pRefStr != NULL)
			{
				// remove the translation from the KB, in case user wants to edit it before it is
				// stored again
				RemoveRefString(pRefStr,pApp->m_pActivePile->m_pSrcPhrase,
													pApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords);
			}
		}
	}
}

bool CAdapt_ItView::AnalyseReference(wxString& chVerse,int& chapter,int& vFirst,int& vLast,int nWantedVerse)
{
	int chap = -1;
	int firstVerse = -1;
	int lastVerse = -1;
	if (chVerse.IsEmpty())
		return FALSE; // premature exit, no chapter or verse on this srcPhrase
	wxString range;
	range.Empty();

	// first determine if there is a chapter number present
	int nFound = chVerse.Find(_T(':'));
	if (nFound < 0)
	{
		// no chapter number, so  set chapter to zero
		range = chVerse;
		chap = 0;
	}
	else
	{
		// chapter number exists, extract it and put the remainder after the colon into range
		wxString strChapter = SpanExcluding(chVerse,_T(":")); 
		chap = wxAtoi(strChapter); 

		nFound++; // index the first char after the colon
		range = chVerse.Mid(nFound);

		// if wanted verse is zero, then exit now since we have a chapter located
		if (nWantedVerse == 0)
		{
			chapter = chap;
			return TRUE;
		}
	}

	// potentially we have a range, so first see if it is a range specified by a hyphen separator
	nFound = range.Find(_T('-'));
	if (nFound >= 0)
	{
		// it is a range, find first & last verse numbers
		wxASSERT(nFound != 0); // must be an initial verse number
		wxString verseFirst = SpanExcluding(range,_T("-"));
		firstVerse = wxAtoi(verseFirst);
		nFound++;
		wxString verseLast = range.Mid(nFound);
		lastVerse = wxAtoi(verseLast);
	}
	else
	{
		// no hyphenated range, so try a comma-delimited range
		nFound = range.Find(_T(','));
		if (nFound < 0)
		{
			// its neither, so it's something unknown, so assume its just a single verse number
			firstVerse = lastVerse = wxAtoi(range); //firstVerse = lastVerse = _ttoi(range);
			// from version 2.0.5 and onwards we allow verse numbers to have unlimited maximum
			// value; so comment out the next block and the test
			/*
			if (firstVerse > 176)
			{
				firstVerse = lastVerse = 1;
				chapter = chap;
				vFirst = firstVerse;
				vLast = lastVerse;
				return FALSE;
			}
			*/
			chapter = chap;
			vFirst = firstVerse;
			vLast = lastVerse;
			return TRUE;
		}
		else
		{
			// it's a comma-delimited range, so get first and last verse numbers
			// (assume n,m structure) note: printing code will allow comma delimited ranges of form
			// n,m,o,p,q etc (see ExtractChapterAndVerse in ..view.cpp), so if the fact that
			// AnalyseReference permits only n,m ever becomes an issue for someone, the copy the extra
			// bit of code needed into the block below (actually, it may be possible to get rid of
			// the latter function and just use the Extract.... one.)
			wxASSERT(nFound != 0); // must be an initial verse number
			wxString verseFirst = SpanExcluding(range,_T(","));
			firstVerse = wxAtoi(verseFirst);
			nFound++;
			wxString verseLast = range.Mid(nFound);
			lastVerse = wxAtoi(verseLast);
		}
	}

	// return the values found
	chapter = chap;
	vFirst = firstVerse;
	vLast = lastVerse;
	return TRUE;
}

void CAdapt_ItView::Jump(CAdapt_ItApp* pApp, CSourcePhrase* pNewSrcPhrase)
// while this appears to be coded for a forward jump only, actually it works equally well for
// arbitrary distance forward or backwards jumps
{
	wxASSERT(pNewSrcPhrase);

	// jump to here
	int nNewSequNum = pNewSrcPhrase->m_nSequNumber;
	pApp->m_pActivePile = AdvanceBundle(nNewSequNum); // also computes m_ptCurBoxLocation
	pApp->m_pTargetBox->m_pActivePile = pApp->m_pActivePile; // put copy on phrase box
	pApp->GetMainFrame()->canvas->ScrollIntoView(nNewSequNum);
	CCell* pCell = pApp->m_pActivePile->m_pCell[2]; // the cell where the phraseBox is to be
	pApp->m_targetPhrase = pNewSrcPhrase->m_adaption; // make it look normal, don't use m_targetStr here
	PlacePhraseBox(pCell,2);

	// update status bar with project name
	gpApp->RefreshStatusBarInfo();
	Invalidate();
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If Vertical Editing is in progress, or the pointers to the KBs are NULL or the bundle's 
/// m_nStripCount is not greater than zero, this handler disables the "Go To..." item in the 
/// Edit menu, otherwise it enables the "Go To..." item on the Edit menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateGoTo(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pKB != NULL && pApp->m_pGlossingKB != NULL &&pApp->m_pBundle->m_nStripCount > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::MakeSelectionForFind(int nNewSequNum, int nCount, int nSelectionLine)
// nNewSequNum is the index of the first srcPhrase in the new selection, nCount is how many
// srcPhrases are to be selected, and nSelectionLine is the 0-based line index to put the
// selection it - it can be any of the four line indices in a strip (ie. 0 up to 3).
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (!gbUserWantsSelection)
	{
		// the above flag is never TRUE when this function is being called in association with
		// a Find Next operation; but since this function is also used for making a selection
		// when user hits the "Cancel And Select" button in CChooseTranslation dialog when
		// called from LookAhead(), the flag will be TRUE when that happens, and in that context
		// all the recalcs and scrolls and advances needed will have been done already in
		// OnChar(), so we need to inhibit advancing in just that circumstance
		pApp->m_pActivePile = AdvanceBundle(nNewSequNum); // also computes m_ptCurBoxLocation
		pApp->m_pTargetBox->m_pActivePile = pApp->m_pActivePile; // put copy on phrase box
		pApp->GetMainFrame()->canvas->ScrollIntoView(nNewSequNum);
	}

	CCell* pCell = pApp->m_pActivePile->m_pCell[nSelectionLine]; // which cell will show the selection

	// make the selection (remember, this code can make selections in line indices 2 or 3 as
	// well as in 1 or 2; so if we click on the view, we will have to transform it to a legal
	// selection for the view - so we would want to make it an index 0 selection in that event,
	// for max flexibility) first, get rid of any old selection
	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context
	if (pApp->m_selection.GetCount() != 0)
	{
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		CCell* pOldSel;
		while (pos != NULL)
		{
			pOldSel = (CCell*)pos->GetData();
			pos = pos->GetNext();
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pOldSel->m_pText->m_bSelected = FALSE;
			pOldSel->m_pText->Draw(&aDC);
		}
		pApp->m_selection.Clear();
		pApp->m_selectionLine = -1; // no selection
		pApp->m_pAnchor = (CCell*)NULL;
	}

	// then do the new selection
	aDC.SetBackgroundMode(pApp->m_backgroundMode);
	aDC.SetTextBackground(wxColour(255,255,0));// yellow
	pApp->m_bSelectByArrowKey = FALSE;
	pCell->m_pText->m_bSelected = TRUE;
	pCell->m_pText->Draw(&aDC);

	// preserve record of the selection
	pApp->m_selection.Append(pCell);
	pApp->m_selectionLine = nSelectionLine; // can be 2 or 3, not just 0 or 1
	pApp->m_pAnchor = pCell;

	if (nCount > 1)
	{
		// extend the selection
		ExtendSelectionForFind(pCell,nCount);
	}

	gbUserWantsSelection = FALSE; // appropriate place to turn it back off
	Invalidate();
}

void CAdapt_ItView::ExtendSelectionForFind(CCell* pAnchorCell, int nCount)
// pAchorCell is pointer to the first cell in the selection, nCount is the number cells in
// the selection (there is always one in existence, the first, when this function is entered)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context

	// local variables to use in the loops below
	CSourceBundle* pBundle;
	CPile*	pCurPile; // the one we use in the loop
	CStrip* pCurStrip; // the strip the starting pile is in
	CCell*	pCurCell; // the current cell in the current pile (used in loop)
	int nCurPileCount; // how many piles in current strip
	int nCurPile; // index of current pile (in loop)
	int nCurStrip; // index of current strip in which is the current pile
	CSourcePhrase* pCurSrcPhrase; // the current pile's source phrase pointer (in loop)

	// set the above local variables from pAnchorCell
	pBundle = pAnchorCell->m_pBundle;
	pCurPile = pAnchorCell->m_pPile;
	pCurStrip = pCurPile->m_pStrip;
	nCurPileCount = pCurStrip->m_nPileCount;
	nCurPile = pCurPile->m_nPileIndex;
	nCurStrip = pCurStrip->m_nStripIndex;

	int nAnchorSequNum = pCurPile->m_pSrcPhrase->m_nSequNumber;
	int nEndSequNum = nAnchorSequNum + nCount - 1;
	wxASSERT(nEndSequNum > 0 && nEndSequNum <= pApp->m_maxIndex);
	int sequ = nAnchorSequNum;
	while (sequ < nEndSequNum)
	{
		sequ++; // next one

		// get the next pile
		if (nCurPile < nCurPileCount-1)
		{
			// there is at least one more pile in this strip, so access it
			nCurPile++; // index of next pile
			pCurPile = pCurStrip->m_pPile[nCurPile]; // the next pile
			pCurSrcPhrase = pCurPile->m_pSrcPhrase;
			wxASSERT(pCurSrcPhrase->m_nSequNumber == sequ); // must match
			pCurCell = pCurPile->m_pCell[pApp->m_selectionLine]; // get the cell

			// if it is already selected, continue to next one, else select it
			if (!pCurCell->m_pText->m_bSelected)
			{
				aDC.SetBackgroundMode(pApp->m_backgroundMode);
				aDC.SetTextBackground(wxColour(255,255,0)); // yellow
				pCurCell->m_pText->Draw(&aDC);
				pCurCell->m_pText->m_bSelected = TRUE;

				// keep a record of it
				pApp->m_selection.Append(pCurCell);
			}
		}
		else
		{
			// we have reached the end of the strip, so go to start of next
			nCurPile = 0; // first in next strip
			nCurStrip++; // the next strip's index
			pCurStrip = pBundle->m_pStrip[nCurStrip]; // pointer to next strip
			pCurPile = pCurStrip->m_pPile[nCurPile];  // pointer to its first pile
			nCurPileCount = pCurStrip->m_nPileCount; // update this so test above
													 // remains correct for the strip
			pCurSrcPhrase = pCurPile->m_pSrcPhrase;
			wxASSERT(pCurSrcPhrase->m_nSequNumber == sequ);
			pCurCell = pCurPile->m_pCell[pApp->m_selectionLine]; // the required cell

			// if it is already selected, continue to next one, else select it
			if (!pCurCell->m_pText->m_bSelected)
			{
				aDC.SetBackgroundMode(pApp->m_backgroundMode);
				aDC.SetTextBackground(wxColour(255,255,0)); // yellow
				pCurCell->m_pText->Draw(&aDC);
				pCurCell->m_pText->m_bSelected = TRUE;

				// keep a record of it
				pApp->m_selection.Append(pCurCell); 
			}
		}
	}
}

void CAdapt_ItView::OnFind(wxCommandEvent& event)
{
	// check that a Find & Replace dialog is not currently open, if it is, delete it
	// preserving contents of the src & tgt edit boxes
	wxString saveSrc;
	saveSrc.Empty();
	wxString saveTgt;
	saveTgt.Empty();

	if (gpApp->m_pFindDlg != NULL)
	{
		if (gbFind == FALSE)
		{
			gpApp->m_pFindDlg->TransferDataFromWindow(); 
			saveSrc = gpApp->m_pFindDlg->m_srcStr;
			saveTgt = gpApp->m_pFindDlg->m_tgtStr;
			gpApp->m_pFindDlg->Destroy();
			gpApp->m_pFindDlg = NULL;
		}
	}

	gbFind = TRUE;
	gbJustReplaced = FALSE;

	// we must not be in 'show target only' mode, so if so, switch back to normal view mode
	if (gbShowTargetOnly)
	{
		OnFromShowingTargetOnlyToShowingAll(event);
	}

	// we must have lines 1 & 4 showing, for Find and for Find & Replace
	gbSaveSuppressFirst = gpApp->m_bSuppressFirst;
	gbSaveSuppressLast = gpApp->m_bSuppressLast;
	if (gpApp->m_bSuppressFirst)
		OnButtonToggleSourceLines(event);
	if (gpApp->m_bSuppressLast)
		OnButtonToggleTargetLines(event);

	if (gpApp->m_pFindDlg == NULL)
	{
		gpApp->m_pFindDlg = new CFindDlg(gpApp->GetMainFrame());

		// set default parameter values
		gpApp->m_pFindDlg->m_srcStr = saveSrc;
		gpApp->m_pFindDlg->m_tgtStr = saveTgt;
		gpApp->m_pFindDlg->m_replaceStr.Empty();
		gpApp->m_pFindDlg->m_marker = 0;
		gpApp->m_pFindDlg->m_markerStr.Empty();
		gpApp->m_pFindDlg->m_sfm.Empty();
		gpApp->m_pFindDlg->m_bFindRetranslation = FALSE;
		gpApp->m_pFindDlg->m_bFindNullSrcPhrase = FALSE;
		gpApp->m_pFindDlg->m_bFindSFM = FALSE;
		gpApp->m_pFindDlg->m_bSrcOnly = TRUE;
		gpApp->m_pFindDlg->m_bTgtOnly = FALSE;
		gpApp->m_pFindDlg->m_bSrcAndTgt = FALSE;
		gpApp->m_pFindDlg->m_bSpecialSearch = FALSE;
		gpApp->m_pFindDlg->m_bFindDlg = TRUE;
		gpApp->m_pFindDlg->m_bSpanSrcPhrases = FALSE;
		gpApp->m_pFindDlg->m_bIncludePunct = FALSE;
		gpApp->m_pFindDlg->m_bIgnoreCase = FALSE;
		gpApp->m_pFindDlg->TransferDataToWindow();

		gpApp->m_pFindDlg->Centre(); // this sets the horizontal pos, AdjustDialogPosition
										// below overrides the vertical one
		AdjustDialogPosition(gpApp->m_pFindDlg);
		gpApp->m_pFindDlg->Show(TRUE);
		gbFindOrReplaceCurrent = TRUE;
	}
	else
	{
		// set default parameter values
		gpApp->m_pFindDlg->m_srcStr = saveSrc;
		gpApp->m_pFindDlg->m_tgtStr = saveTgt;
		gpApp->m_pFindDlg->m_replaceStr.Empty();
		gpApp->m_pFindDlg->m_marker = 0;
		gpApp->m_pFindDlg->m_markerStr.Empty();
		gpApp->m_pFindDlg->m_sfm.Empty();
		gpApp->m_pFindDlg->m_bFindRetranslation = FALSE;
		gpApp->m_pFindDlg->m_bFindNullSrcPhrase = FALSE;
		gpApp->m_pFindDlg->m_bFindSFM = FALSE;
		gpApp->m_pFindDlg->m_bSrcOnly = TRUE;
		gpApp->m_pFindDlg->m_bTgtOnly = FALSE;
		gpApp->m_pFindDlg->m_bSrcAndTgt = FALSE;
		gpApp->m_pFindDlg->m_bSpecialSearch = FALSE;
		gpApp->m_pFindDlg->m_bFindDlg = TRUE;
		gpApp->m_pFindDlg->m_bSpanSrcPhrases = FALSE;
		gpApp->m_pFindDlg->m_bIncludePunct = FALSE;
		gpApp->m_pFindDlg->m_bIgnoreCase = FALSE;
		gpApp->m_pFindDlg->TransferDataToWindow();

		gpApp->m_pFindDlg->Centre(); // this sets the horizontal pos, AdjustDialogPosition
									// below overrides the vertical one
		AdjustDialogPosition(gpApp->m_pFindDlg);
		gpApp->m_pFindDlg->Show(TRUE);
		gbFindOrReplaceCurrent = TRUE;
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// This handler disables the "Find..." item in the Tools menu if Vertical Editing is in progress,
/// or if the application is in Free Translation mode, or if there are no source phrases in the 
/// App's m_pSourcePhrases list. Otherwise it enables the "Find..." item on the Tools menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFind(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::AdjustDialogPosition(wxDialog* pDlg)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// place the dialog window so as not to obscure things
	// work out where to place the dialog window
	int nTwoLineDepth = 2 * pApp->m_nTgtHeight;
	wxPoint ptBoxTopLeft = pApp->m_ptCurBoxLocation; //top left point of phrase box in logical units
	wxRect rectScreen;

	// The wxWidgets docs say, "::wxClientDisplayRect() method returns the
	// dimensions of the work area on the display. On Windows this means the
	// area not covered by the taskbar, etc. Other platforms are currently
	// defaulting to the whole display until a way is found to provide this
	// info for all window managers, etc."
	// Note: All calls that have no wxDC as a parameter deal in display device/pixels,
	// and MM_TEXT mapping mode, never in logical coordinates (or other mapping modes).
	int displayX;
	int displayY;
	int displayWidth;
	int displayHeight;
	::wxClientDisplayRect(&displayX,&displayY,&displayWidth,&displayHeight);
	rectScreen = wxRect(displayX,displayY,displayWidth,displayHeight); // in screen/device coords (pixels)

	wxClientDC dc(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(dc); //OnPrepareDC(&dc); // adjust origin
	canvas->pFrame->PrepareDC(dc); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame

	// use location where phrase box would be put
	//dc.LPtoDP(&ptBoxTopLeft); // converts ptBoxTopLeft from logical to screen/device coords
	// whm Note: The following LogicalToDeviceX and LogicalToDeviceY functions are supposed to
	// adjust the logical position of rectBox after scrolling down from the zero scroll position;
	// but, they don't always seem to do what is expected in MFC terms, so use CalcScrolledPosition below.
	//int x = dc.LogicalToDeviceX(ptBoxTopLeft.x);// get the logical X coord converted to device coord
	//int y = dc.LogicalToDeviceY(ptBoxTopLeft.y);// get the logical Y coord converted to device coord
	//ptBoxTopLeft.x = x;
	//ptBoxTopLeft.y = y;

	//int xScrollUnits, yScrollUnits, xOrigin, yOrigin;
	//pApp->GetMainFrame()->canvas->GetViewStart(&xOrigin, &yOrigin); // gets xOrigin and yOrigin in scroll units
	//pApp->GetMainFrame()->canvas->GetScrollPixelsPerUnit(&xScrollUnits, &yScrollUnits); // gets pixels per scroll unit
	//ptBoxTopLeft.x = xOrigin * xScrollUnits; // number pixels is ScrollUnits * pixelsPerScrollUnit
	//ptBoxTopLeft.y = yOrigin * yScrollUnits;

	// CalcScrolledPosition translates logical coordinates to device ones. Use this instead of those above.
	int newXPos, newYPos;
	// CalcScrolledPosition translates logical coordinates to device ones.
	pApp->GetMainFrame()->canvas->CalcScrolledPosition(ptBoxTopLeft.x,ptBoxTopLeft.y,&newXPos,&newYPos);
	ptBoxTopLeft.x = newXPos;
	ptBoxTopLeft.y = newYPos;

	// In the ClientToScreen call below the x and y coords are adjusted; in wxRect the width and height remain
	// unchanged, i.e., the rectangle retains the same size dimensions, but the x and y coords change
	// from (0,0) to a new (x,y) positioin for the rectangle in relation to screen coords.
	gpApp->GetMainFrame()->canvas->ClientToScreen(&ptBoxTopLeft.x,&ptBoxTopLeft.y); //pView->ClientToScreen(&ptBoxTopLeft); // now its screen coords

	int height = nTwoLineDepth;
	//wxRect rectDlg;
	int dlgWidth;
	int dlgHeight;
	wxASSERT(pDlg != NULL);
	// whm - for the dialog we should use GetSize, rather than GetClientSize as we want to include
	// the whole window
	pDlg->Centre(); // start with centered as default (for horizontal position especially)
	pDlg->GetSize(&dlgWidth,&dlgHeight); //pDlg->GetClientRect(&rectDlg); // dialog's window; gets the width and height in pixels
	//rectDlg = wxRect(0,0,dlgWidth,dlgHeight);	// use 0,0 for upper left origin
	//rectDlg = NormalizeRect(rectDlg); //rectDlg.NormalizeRect(); // in case we ever change from MM_TEXT mode // use our own from helpers.h
	// In wxRect we already have the height and width in dlgHeight and dlgWidth from GetClientSize above.
	//int dlgHeight = rectDlg.bottom - rectDlg.top;
	//int dlgWidth = rectDlg.right - rectDlg.left;
	wxASSERT(dlgHeight > 0);
	// wx note: displayWidth determined above (takes place of rectScreen.right - rectScreen.left) below:
	// because the actual width (before items are hidden) is much greater than the displayed width,
	// the following calculations place the dialog much left of center. We won't bother setting
	// the horizontal position.
	if (ptBoxTopLeft.y + height < rectScreen.GetBottom() - 50 - dlgHeight)
	{
		// put dlg near the bottom of screen, or 30 pixels under the box's strip
		// Roland Fumey is reporting the Choose Translation dialog being shown above the client area
		// and so invisible, so my fix for 2.4.1f did not work, so try do something here and send
		// to Roland for evaluation (BEW changed, 12Jul05)
		int topAdjusted = wxMin(ptBoxTopLeft.y + height + 30,rectScreen.GetBottom()-dlgHeight-80);
		if (topAdjusted < rectScreen.GetTop())
			topAdjusted = rectScreen.GetBottom() - dlgHeight - 80;
		//pDlg->SetWindowPos(&CWnd::wndTop,left,topAdjusted,300,200,SWP_NOSIZE);
		// WX Note: We'll use the wxWindow::SetSize() method
		pDlg->SetSize( // set size in device/screen pixels
			-1, //left,
			topAdjusted,
			300, // width, dummy value overridden by wxSIZE_USE_EXISTING below
			200, // height, ditto
			wxSIZE_USE_EXISTING);
	}
	else
	{
		// put dlg near the top of the screen, or if possible, 60 pixels above the strip (version 2.4.0 altered
		// this below from max(ptBoxTopLeft.y - dlgHeight - height - 60, rectScreen.top+40) so that now
		// we put the box 2 pixels down from the top of the screen, to minimize the need to scroll or move
		// the box because it may be obscuring some of the automatically inserted text); BEW altered 09Sep05 for
		// it to be 100 pixels down from the screen top - even if it sometimes obscures some inserted text, it is
		// better to have a reasonable chance of not obscuring the command bar buttons
		//pDlg->SetWindowPos(&CWnd::wndTop,left,rectScreen.top+100,300,200,SWP_NOSIZE);
		pDlg->SetSize(
			-1, //left,
			rectScreen.GetTop()+100,
			300, // width, dummy value overridden by wxSIZE_USE_EXISTING below
			200, // height, ditto
			wxSIZE_USE_EXISTING);
	}
	pDlg->Update();
}

void CAdapt_ItView::SetWhichBookPosition(wxDialog* pDlg)
{
	// WX NOTE: This is used only in WhichBook.cpp's InitDialog
	int xPos,yPos;
	pDlg->GetPosition(&xPos,&yPos); // whatever position the OS assigns to it by default
	pDlg->Move(xPos,200); // use the xPos but move it down 200 pixels from top

	pDlg->Update();
}

void CAdapt_ItView::AdjustDialogPositionByClick(wxDialog* pDlg,wxPoint ptClick)
{
	// place the dialog window so as not to obscure things work out where to place the dialog window;
	// the passed in ptClick value comes from the saved point value for the user's click in the client area
	// of the view, and the coords for that point will be device coords (ie. relative to top left of the
	// client area of the view)

	// first calculate the height of two target text lines
	int height = 2 * gpApp->m_nTgtHeight;

	// get the size of the screen - use screen coords
	wxRect rectScreen;
	// wx note: According to wx docs, wxGetClientDisplayRect() "returns the dimensions of the work
	// area on the display. On Windows this means the area not covered by the taskbar, etc. Other
	// platforms are currently defaulting to the whole display until a way is found to provide this
	// info for all window managers, etc."
	rectScreen = wxGetClientDisplayRect(); //CWnd* desktopWnd = GetDesktopWindow();
	//wxASSERT(desktopWnd);
	// wx note: Since wxGetClientDisplayRect accounts for taskbar etc (at least on Windows) we
	// don't need to invoke the equivalent of the GetClientRect() call below on the desktop window.
	//gpApp->GetMainFrame()->canvas->GetClientSize(&rectScreen.x,&rectScreen.y); //desktopWnd->GetClientRect(&rectScreen); // in screen coords

	// we need to know where the view's client rect is located, in screen coords
	wxRect rectView;
	//gpApp->GetMainFrame()->canvas->GetClientSize(&rectView.width,&rectView.height); //pView->GetClientRect(&rectView);
	// wx note: calling GetClientSize on the canvas produced different results in wxGTK and
	// wxMSW, so I'll use my own GetCanvasClientSize() which calculates it from the main frame's
	// client size.
	wxSize canvasSize;
	canvasSize = gpApp->GetMainFrame()->GetCanvasClientSize();
	rectView.width = canvasSize.x;
	rectView.height = canvasSize.y;
	
	// In the ClientToScreen call below the x and y coords are adjusted; in wxRect the width and height remain
	// unchanged, i.e., the rectangle retains the same size dimensions, but the x and y coords change
	// from (0,0) to a new (x,y) positioin for the rectangle in relation to screen coords.
	gpApp->GetMainFrame()->canvas->ClientToScreen(&rectView.x,&rectView.y); //pView->ClientToScreen(&rectView); // now rectView is in screen coords - is this needed ???

	// we need to know the location and size of the dialog which is to have its location adjusted
	wxRect rectDlg;
	pDlg->GetClientSize(&rectDlg.width,&rectDlg.height); // dialog's window
	rectDlg = NormalizeRect(rectDlg); // in case we ever change from MM_TEXT mode // use our own from helpers.h
	int dlgHeight = rectDlg.GetHeight();
	int dlgWidth = rectDlg.GetWidth();
	wxASSERT(dlgHeight > 0);

	// determine how far from the left of the screen we will make the left side of the dialog be
	// so it is centered
	int left = (rectScreen.GetWidth() - dlgWidth)/2;

	// put it above the click if there is enough screen real estate to fit it between the command bar and
	// a 1.5 linepair height values above the click's y coordinate; else put it near the screen bottom,
	// making sure it clears the status bar
	if (dlgHeight + ((height * 3) / 2) < ptClick.y)
	{
		pDlg->SetSize(left,rectView.GetTop() + 5,300,200,wxSIZE_USE_EXISTING); 
	}
	else
	{
		pDlg->SetSize(left,rectScreen.GetBottom() - dlgHeight - 80,300,200,wxSIZE_USE_EXISTING);
	}
	pDlg->Update();
}

void CAdapt_ItView::OnReplace(wxCommandEvent& event)
{
	// check that a Find dialog is not currently open, if it is, delete it
	// preserving contents of the src & tgt edit boxes
	wxString saveSrc;
	saveSrc.Empty();
	wxString saveTgt;
	saveTgt.Empty();

	if (gpApp->m_pReplaceDlg != NULL)
	{
		if (gbFind == TRUE)
		{
			gpApp->m_pReplaceDlg->TransferDataFromWindow();
			saveSrc = gpApp->m_pReplaceDlg->m_srcStr;
			saveTgt = gpApp->m_pReplaceDlg->m_tgtStr;
			gpApp->m_pReplaceDlg->Destroy();
			gpApp->m_pReplaceDlg = NULL;
		}
	}

	gbFind = FALSE; // make dialog appearance be for Find & Replace
	gbJustReplaced = FALSE;

	// we must not be in 'show target only' mode, so if so, switch back to normal view mode
	if (gbShowTargetOnly)
	{
		OnFromShowingTargetOnlyToShowingAll(event);
	}

	// we must have lines 1 & 4 showing, for Find and for Find & Replace
	gbSaveSuppressFirst = gpApp->m_bSuppressFirst;
	gbSaveSuppressLast = gpApp->m_bSuppressLast;
	if (gpApp->m_bSuppressFirst)
		OnButtonToggleSourceLines(event);
	if (gpApp->m_bSuppressLast)
		OnButtonToggleTargetLines(event);

	if (gpApp->m_pReplaceDlg == NULL)
	{
		gpApp->m_pReplaceDlg = new CReplaceDlg(gpApp->GetMainFrame());

		gbJustReplaced = FALSE;

		// set default parameter values
		gpApp->m_pReplaceDlg->m_srcStr = saveSrc;
		gpApp->m_pReplaceDlg->m_tgtStr = saveTgt;
		gpApp->m_pReplaceDlg->m_replaceStr.Empty();
		//gpApp->m_pReplaceDlg->m_marker = 0;
		gpApp->m_pReplaceDlg->m_markerStr.Empty();
		gpApp->m_pReplaceDlg->m_sfm.Empty();
		//gpApp->m_pReplaceDlg->m_bFindRetranslation = FALSE;
		//gpApp->m_pReplaceDlg->m_bFindNullSrcPhrase = FALSE;
		//gpApp->m_pReplaceDlg->m_bFindSFM = FALSE;
		gpApp->m_pReplaceDlg->m_bSrcOnly = FALSE;
		gpApp->m_pReplaceDlg->m_bTgtOnly = TRUE;
		gpApp->m_pReplaceDlg->m_bSrcAndTgt = FALSE;
		//gpApp->m_pReplaceDlg->m_bSpecialSearch = FALSE;
		gpApp->m_pReplaceDlg->m_bFindDlg = FALSE;
		gpApp->m_pReplaceDlg->m_bSpanSrcPhrases = FALSE;
		gpApp->m_pReplaceDlg->m_bIncludePunct = FALSE;
		gpApp->m_pReplaceDlg->m_bIgnoreCase = FALSE;
		gpApp->m_pReplaceDlg->TransferDataToWindow();

		gpApp->m_pReplaceDlg->Centre(); // this sets the horizontal pos, AdjustDialogPosition
											// below overrides the vertical one
		AdjustDialogPosition(gpApp->m_pReplaceDlg);
		gpApp->m_pReplaceDlg->Show(TRUE);
		gbFindOrReplaceCurrent = TRUE;
	}
	else
	{
		if (gpApp->m_pReplaceDlg != NULL)
		{
			AdjustDialogPosition(gpApp->m_pReplaceDlg);
			gpApp->m_pReplaceDlg->Show(TRUE);
			gbFindOrReplaceCurrent = TRUE;
		}
		else
		{
			// wx doesn't need to call Create

			gbJustReplaced = FALSE;

			// set default parameter values
			gpApp->m_pReplaceDlg->m_srcStr = saveSrc;
			gpApp->m_pReplaceDlg->m_tgtStr = saveTgt;
			gpApp->m_pReplaceDlg->m_replaceStr.Empty();
			//gpApp->m_pReplaceDlg->m_marker = 0;
			gpApp->m_pReplaceDlg->m_markerStr.Empty();
			gpApp->m_pReplaceDlg->m_sfm.Empty();
			//gpApp->m_pReplaceDlg->m_bFindRetranslation = FALSE;
			//gpApp->m_pReplaceDlg->m_bFindNullSrcPhrase = FALSE;
			//gpApp->m_pReplaceDlg->m_bFindSFM = FALSE;
			gpApp->m_pReplaceDlg->m_bSrcOnly = FALSE;
			gpApp->m_pReplaceDlg->m_bTgtOnly = TRUE;
			gpApp->m_pReplaceDlg->m_bSrcAndTgt = FALSE;
			//gpApp->m_pReplaceDlg->m_bSpecialSearch = FALSE;
			gpApp->m_pReplaceDlg->m_bFindDlg = FALSE;
			gpApp->m_pReplaceDlg->m_bSpanSrcPhrases = FALSE;
			gpApp->m_pReplaceDlg->m_bIncludePunct = FALSE;
			gpApp->m_pReplaceDlg->m_bIgnoreCase = FALSE;
			gpApp->m_pReplaceDlg->TransferDataToWindow();

			gpApp->m_pReplaceDlg->Centre(); // this sets the horizontal position, AdjustDialogPosition sets vert posn
			AdjustDialogPosition(gpApp->m_pReplaceDlg);
			gpApp->m_pReplaceDlg->Show(TRUE);
			gbFindOrReplaceCurrent = TRUE;
		}
	}
}

void CAdapt_ItView::ToggleSourceLines()
{
	wxCommandEvent event;
	OnButtonToggleSourceLines(event);
}

void CAdapt_ItView::ToggleTargetLines()
{
	wxCommandEvent event;
	OnButtonToggleTargetLines(event);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// This handler disables the "Find And Replace..." item in the Tools menu if Vertical Editing is
/// in progress, or if the application is in Free Translation mode, or if there are no source 
/// phrases in the App's m_pSourcePhrases list. Otherwise it enables the "Find And Replace..." 
/// item on the Tools menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateReplace(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::SelectFoundSrcPhrases(int nNewSequNum, int nCount,
										 bool bIncludePunct, bool bSearchedInSrc)
{
	if (gbIsGlossing)
	{
		wxASSERT(nCount == 1);;
	}

	int nSelLineIndex;
	if (bSearchedInSrc)
	{
		if (bIncludePunct)
			nSelLineIndex = 0;
		else
			nSelLineIndex = 1;
	}
	else
	{
		if (bIncludePunct)
			nSelLineIndex = 3;
		else
			nSelLineIndex = 2;
	}
	// set up bundle, recalc layout, etc, and make the appropriate selection
	MakeSelectionForFind(nNewSequNum,nCount,nSelLineIndex);

	// update the active sequ number
	gpApp->m_nActiveSequNum = nNewSequNum;
}

bool CAdapt_ItView::DoFindNext(int nCurSequNum, bool bIncludePunct, bool bSpanSrcPhrases,
							bool bSpecialSearch,bool bSrcOnly, bool bTgtOnly,
							bool bSrcAndTgt, bool bFindRetranslation, bool bFindNullSrcPhrase,
							bool bFindSFM, wxString& src, wxString& tgt, wxString& sfm,
							bool bIgnoreCase, int& nSequNum, int& nCount)
// All parameters relevant when glossing is OFF. When glossing is ON, the following applies:
// bIncludePunct and bSpanSrcPhrases will be FALSE, since the checkboxes for those flags are
// hidden; tgt parameter will hold, if relevant, text to be searched for in the m_gloss line;
// and nCount should never be anything except 1 when glossing.
{
	if (gbIsGlossing)
	{
		wxASSERT(nCount == 1);;
	}
	wxASSERT(!(nCurSequNum > gpApp->m_maxIndex));
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);

	// if the targetBox is visible, store the contents in KB since we will advance the
	// active location to the pile having the text matched in the source phrase; and even if
	// there is no match, we want to do the save to KB before any bundle advances, otherwise the
	// old active location's pointer will be garbage & we'll crash if we try to use it
	if (gpApp->m_pTargetBox != NULL)
	{
		if (gpApp->m_pTargetBox->IsShown())
		{
			if (!gbIsGlossing)
				MakeLineFourString(pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
			if (!gbIsGlossing)
				RemovePunctuation(pDoc,&pApp->m_targetPhrase,1 /*from tgt*/);

			// the store will fail if the user edited the entry out of the KB, as the latter
			// cannot know which srcPhrases will be affected, so these will still have their
			// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString but
			// the above flag TRUE is a sufficient test, and if so, set the flag to FALSE
			CRefString* pRefStr;
			bool bOK;
			if (gbIsGlossing)
			{
				pRefStr = GetRefString(pApp->m_pGlossingKB, 1,
										pApp->m_pActivePile->m_pSrcPhrase->m_key,pApp->m_targetPhrase);
				if (pRefStr == NULL || pApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry) // be safe
					pApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
				// now do the store
				bOK = StoreText(pApp->m_pGlossingKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
			}
			else
			{
				pRefStr = GetRefString(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
										pApp->m_pActivePile->m_pSrcPhrase->m_key,pApp->m_targetPhrase);
				if (pRefStr == NULL || pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry) // be safe
					pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
				// now do the store
				gbInhibitLine4StrCall = TRUE;
				bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase,pApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
			}

			// now get rid of the phrase box, until we need it again
			pApp->m_pTargetBox->Hide(); //MFC version calls DestroyWindow();
			pApp->m_pTargetBox->SetValue(_T("")); // need to set it to null str since it won't get recreated
			//gpApp->m_pTargetBox->m_hWnd = NULL;
			pApp->m_targetPhrase.Empty(); // the box will move on, so this old location is now invalid
		}
	}

	if (nCurSequNum == pApp->m_maxIndex || nCurSequNum == -1)
		return FALSE; // we are at the end, so cannot search further (we won't wrap the search)


	if (bSpecialSearch)
	{
		bool bFound;

		// a special search is wanted
		if (bFindRetranslation)
		{
			bFound = DoFindRetranslation(nCurSequNum+1,nSequNum,nCount);
		}
		else if (bFindNullSrcPhrase)
		{
			bFound = DoFindNullSrcPhrase(nCurSequNum+1,nSequNum,nCount);
		}
		else
		{
			// must want to find a standard format marker
			if (bFindSFM != TRUE)
			{
				::wxBell(); 
				wxASSERT(FALSE);
			}
			bFound = DoFindSFM(sfm,nCurSequNum+1,nSequNum,nCount);
		}
		if (!bFound)
		{
			// clear the globals
			gbMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			::wxBell(); // alert user there was no match
			Invalidate();
			return FALSE;
		}
		else
		{
			// found a matching string, in the srcPhrase with sequ num nSequNum
			SelectFoundSrcPhrases(nSequNum,nCount,TRUE,TRUE);
			return TRUE;
		}
	}
	else
	{
		bool bFound;
		bool bInSrc = TRUE;

		// if we previously matched a retranslation, we have to advance to its end before
		// we can continue searching for a new match; but if glossing is ON, retranslations
		// are irrelevant, so we would skip the block in that case
		if (!gbIsGlossing && gbMatchedRetranslation)
		{
			wxASSERT(gnRetransEndSequNum >= 0);
			nCurSequNum = gnRetransEndSequNum;
			gbMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
		}

		// a normal type of search is wanted & the following functions search in
		// m_pSourcePhrases list
		if (bSrcOnly)
		{
			// search only in m_srcPhrase field or m_key field, depending on bIncludePunct
			// flag value
			bFound = DoSrcOnlyFind(nCurSequNum+1,bIncludePunct,bSpanSrcPhrases,src,
															bIgnoreCase,nSequNum,nCount);
		}
		else if (bTgtOnly)
		{
			// search only in m_targetStr field or m_adaption field
			bFound = DoTgtOnlyFind(nCurSequNum+1,bIncludePunct,bSpanSrcPhrases,tgt,
															bIgnoreCase,nSequNum,nCount);
			bInSrc = FALSE;
		}
		else
		{
			// search both m_srcPhrase and m_targetStr fields, trying to match both
			if (bSrcAndTgt != TRUE)
			{
				::wxBell(); 
				wxASSERT(FALSE);
			}
			bFound = DoSrcAndTgtFind(nCurSequNum+1,bIncludePunct,bSpanSrcPhrases,src,tgt,
															bIgnoreCase,nSequNum,nCount);
			bInSrc = FALSE;
		}
		if (!bFound)
		{
			// clear the globals
			gbMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			::wxBell(); // alert user there was no match
			Invalidate();
			return FALSE;
		}
		else
		{
			// found a matching string, in the srcPhrase with sequ num nSequNum
			SelectFoundSrcPhrases(nSequNum,nCount,bIncludePunct,bInSrc);
			return TRUE;
		}
	}
}

bool CAdapt_ItView::DoFindRetranslation(int nStartSequNum, int& nSequNum, int& nCount)
// we allow this search whether glossing is on or not; as it might be a useful search when
// glossing is ON
{
	SPList* pList = gpApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* savePos = pos;

	// get past the current retranslation, if we are in one
	pSrcPhrase = (CSourcePhrase*)pos->GetData();
	if (pSrcPhrase->m_bBeginRetranslation)
	{
		// we are at the start of a retranslation, so must access the next srcPhrase
		// before we have a possibility of being out of it, or into the next retranslation
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
	}
	if (pSrcPhrase->m_bRetranslation)
	{
		while (pos != NULL)
		{
			savePos = pos;
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (!pSrcPhrase->m_bRetranslation || pSrcPhrase->m_bBeginRetranslation)
				break; // break if we are out, or at the beginning of a consecutive one
		}
	}

	// do the search, confining attempts within a single CSourcePhrase instance
	if (pos == NULL)
	{
		// we are at the end of the document
		nSequNum = -1; // undefined
		return FALSE;
	}

	pos = savePos;
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bRetranslation || pSrcPhrase->m_bBeginRetranslation)
		{
			// we found a retranslation
			nSequNum = pSrcPhrase->m_nSequNumber;
			nCount = 1;
			return TRUE;
		}
	}

	// if we get here, we didn't find a match
	nSequNum = -1;
	return FALSE;
}

bool CAdapt_ItView::DoFindNullSrcPhrase(int nStartSequNum, int& nSequNum, int& nCount)
// finds only those null src phases (ie. placeholders) which are not within a retranslation
// for padding purposes; the search is also allowed when glossing is ON
{
	SPList* pList = gpApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;

	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bNullSourcePhrase && !pSrcPhrase->m_bRetranslation)
		{
			// we found a null source phrase (exclude those which may be in a retranslation)
			nSequNum = sn;
			nCount = 1;
			return TRUE;
		}
		else
		{
			sn++; // index for next CSourcePhrase instance to be searched
		}
	}

	// if we get here, we didn't find a match
	return FALSE;
}

bool CAdapt_ItView::IsSameMarker(int str1Len, int nFirstChar, const wxString& str1,
								 const wxString& testStr)
{
	wxASSERT(str1.Length() > 1);
	wxString extracted = testStr.Mid(nFirstChar,str1Len);

	// if the testStr has a marker which has the str1 marker in it as a substring, we have to
	// extend the "extracted" string, otherwise we will end up returning a TRUE value
	// incorrectly
	int nNext = nFirstChar + str1Len;
	int totalLen = testStr.Length();

	wxChar c;
	// while we are not beyond the textStr bounds, and the character at the nNext offset is
	// not a space character, add the next character to the extracted marker stub, and iterate
	// until the whole marker is built
	while ( nNext < totalLen && (c = testStr.GetChar(nNext)) != _T(' '))
	{
		extracted += c;
		nNext++;
	}

	if ((int)extracted.Length() < str1Len)
		return FALSE; // can't be the same, since it's shorter
	return (extracted == str1);
}

bool CAdapt_ItView::DoFindSFM(wxString& sfm, int nStartSequNum, int& nSequNum, int& nCount)
// we allow this search when glossing or when adapting
{
	SPList* pList = gpApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int len = sfm.Length();

	int nFound = -1; // assume not found
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);

		nFound = pSrcPhrase->m_markers.Find(sfm); // nFound is index of first char of matched str
		if (nFound >= 0)
		{
			// we can assume m_markers does not have two markers one of which is a substring of
			// the other (if that was the case, and the longer was first and we were looking for
			// the shorter, we'd never find the shorter one with the following code)
			bool bSame = IsSameMarker(len,nFound,sfm,pSrcPhrase->m_markers);
			if (!bSame)
			{
				nFound = -1;
				goto b;
			}
		}
		else
		{
b:			if (pSrcPhrase->m_nSrcWords > 1)
			{
				// there could be medial markers in the phrase, so check it out
				if (!pSrcPhrase->m_pMedialMarkers->IsEmpty())
				{
					wxArrayString* pSL = pSrcPhrase->m_pMedialMarkers;
					int ct;
					for (ct = 0; ct < (int)pSL->GetCount(); ct++) 
					{
						wxString markers = pSL->Item(ct);
						nFound = markers.Find(sfm);
						if (nFound >= 0)
						{
							bool bSame = IsSameMarker(len,nFound,sfm,markers);
							if (bSame)
							{
								break;
							}
							else
							{
								nFound = -1;
							}
						}
					}
				}
			}
		}
		if (nFound >= 0)
		{
			// we found a matching standard format marker
			nSequNum = sn;
			nCount = 1;
			return TRUE;
		}
		else
		{
			sn++; // index for next CSourcePhrase instance to be searched
		}
	}

	// if we get here, we didn't find a match
	return FALSE;
}

void CAdapt_ItView::DeleteTempList(SPList* pList)
{
	SPList::Node* p;
	if (pList->IsEmpty())
		goto a;
	p = pList->GetFirst();
	while (p != 0)
	{
		CSourcePhrase* pSP = (CSourcePhrase*)p->GetData();
		p = p->GetNext();
		delete pSP->m_pMedialMarkers;
		pSP->m_pMedialMarkers = (wxArrayString*)NULL;
		delete pSP->m_pMedialPuncts;
		pSP->m_pMedialPuncts = (wxArrayString*)NULL;
		delete pSP->m_pSavedWords;
		pSP->m_pSavedWords = (SPList*)NULL;
		delete pSP;
		pSP = (CSourcePhrase*)NULL;
	}
	pList->Clear();
a:	delete pList;
	pList = (SPList*)NULL;
}

int CAdapt_ItView::IsMatchedToEnd(wxString& strSearch, wxString& strTarget)
// when IsMatchedToEnd is called, it will be the case that we are trying to match less than the
// whole of the user's typed search string, and we will be doing the test for the match only in
// the text supplied from the first source phrase of a potential multi-sourcePhrase match. In
// the first srcPhrse, we have no way of knowing how many of the user's first typed words will
// be able to match, so we have to test all possibilities - in the caller, an nIteration
// variable keeps track of which attempt we are making, each iteration tests a string one word
// shorter than the one tested earlier in the last call to IsMatchedToEnd(). However, any match
// within IsMatchedToEnd is not valid unless the last matched character is also the very last
// character of the strTarget string. The reason for this is that since there is more to be
// matched in a later sourcePhrase, we cannot allow a discontinuity between what is matched in
// the current one, and any potential match in the next one. So IsMatchedToEnd looks
// specifically for a match which is coextensive with the end of the strTarget string; returns
// the offset to the first matched character if it finds such a match, or -1 otherwise
// (mimicking CString's Find() function)
{
	int nTargetLen = strTarget.Length();
	int nSearchLen = strSearch.Length();
	int nFirstChar = -1;
	int nStart = 0;
a:	nFirstChar = FindFromPos(strTarget,strSearch,nStart);
	if (nFirstChar == -1)
	{
		// no match
		return -1;
	}
	else
	{
		// got a match, check it out
		if (nFirstChar + nSearchLen == nTargetLen)
		{
			// it matches up to the end, so we have a successful match
			return nFirstChar;
		}
		else
		{
			// not coextensive with the end, so see if we can get a match later in the string
			nStart = ++nFirstChar;
			goto a;
		}
	}
}

bool CAdapt_ItView::DoExtendedSearch(int selector, SPList::Node*& pos, CAdapt_ItDoc* pDoc,
									 SPList* pTempList, int nElements, bool bIncludePunct,
                                     bool bIgnoreCase, int& nCount)
// selector = 0 means, a src only search
// selector = 1 means, a tgt only search
// pList is a pointer to the list of CSourcePhrase instances in the document's m_pSourcePhrases
// member, pTempList holds a temporary list created in the caller, of pSrcPhrase instances which
// are the result of parsing src string using TokenizeText() function - we use these to
// construct search strings which we wish to match within the appropriate members of each
// pSrcPhrase in the pList, starting from the location pos
// If glossing is ON, this should never get called.
{
	wxASSERT(!gbIsGlossing);
	SPList::Node* pos1 = pos; // local copy to use in iterations
	SPList::Node* pos2 = NULL; // whm initialized to NULL // position within the pTempList
	bool bFirstOnly = TRUE; // true when we are dealing with the first of a possible string of srcPhrases
							// in the m_pSourcePhrases list of pDoc
	int nTotal = nElements; // number of words (ie. elements in pTempList) in search string
	//bool bFound = FALSE; // unused
	wxString strConstruct; // we construct strings in this, in which to search for a match using src
	strConstruct.Empty();
	nCount = 0; // count of how many m_pSourcePhrases elements were used in making the match,
				// garbage if no match
	int bFirstAttempt = TRUE; // used when making first attempt at a match - the first matching
							  // character does not have to be at the start of the string being
							  // searched in this instance, but subsequent matches must match
							  // exactly from the start
	wxString strSearchTarget; // we search in this string for a match
	strSearchTarget.Empty();
	CSourcePhrase* pSrcPhrase = NULL; // a source phase in doc's m_pSourcePhrases list
	CSourcePhrase* pSP = NULL; // a source phrase in the tokenized pTempList, from which we
							   // build search strings
	int nTargetLength = 0;
	int nSearchLength = 0;
	int nAddParts= 0;
	int nFound = -1;
	int nWordCount = 0;
	int count = 0;
	int nIteration = 0; // iteration number for the try in first source phrase, starting with
						// longest & decreasing by one word per iteration
	int nLimit = 0; // max number of search words which can be constructed in strConstruct for
					// matching in the strSearchTarget string built from the current pSrcPhrase
					// in the loop
	if (pos == 0)
		return FALSE;
	switch (selector)
	{
	case 0: // source only
		while (pos1 != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetNext();
			wxASSERT(pSrcPhrase != NULL);
			nWordCount = pSrcPhrase->m_nSrcWords;
			nLimit = wxMin(nTotal,nWordCount);
			nCount++; // count this source phrase (it could have more than one word in its
			// m_key or m_srcPhrase)
			if (bFirstOnly)
			{
				bFirstOnly = FALSE;
				pos = pos1; // we need to return only this one, because the caller needs to
							// know when the end of pList has been reached, so that the caller's
							// loop can be exited cleanly
			}
			else
			{
				nIteration = 0; // no iterations allowed for src phrases other than the first
			}
			if(pSrcPhrase->m_bNullSourcePhrase)
			{
				if (nCount == 1)
					return FALSE; // if first is a null source phrase, cause progression to next
				else
				{
					// not the first srcPhrase, so just skip it and continue trucking
					continue;
				}
			}

			// compute strSearchTarget
			if (bIncludePunct)
			{
				strSearchTarget = pSrcPhrase->m_srcPhrase;
			}
			else
			{
				strSearchTarget = pSrcPhrase->m_key;
			}
			if (bIgnoreCase)
				strSearchTarget.MakeLower();

			// how many iterations left to be tried, for the first phrase
a:			if (nCount == 1)
			{
				nTotal = nElements; // reset, for each iteration
				nIteration++;  // which iteration within the nCount == 1 loop are we on
				nLimit = wxMin(nTotal,nWordCount) - nIteration + 1;
			}
			else
				nLimit = wxMin(nTotal,nWordCount);

			if (nIteration > wxMin(nTotal,nWordCount))
				return FALSE; // couldn't make a match in the first source phrase, and the rest
							  // match also

			// we use nWordCount together with pTempList data in order to build a strConstruct
			// which has nWordCount words in it - either with or without punctuation depending
			// on the bIncludePunct value, (or there can be less than nWordCount words, if the
			// search string is short enough); then for each nIterations decrement, try building
			// one word less each time (provided no earlier iteration produced a match)
			if (nCount == 1)
			{
				// go back to the start of the user's typed string, for every iteration while
				// nCount == 1
				pos2 = pTempList->GetFirst(); 
			}
			count = 0; // count of words from user's typed string which are to be used for this
					   // test
			while (pos2 != NULL)
			{
				pSP = (CSourcePhrase*)pos2->GetData();
				pos2 = pos2->GetNext();
				wxASSERT(pSP != NULL);
				if (bIncludePunct)
				{
					if (count == 0)
					{
						strConstruct = pSP->m_srcPhrase;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_srcPhrase;
					}
				}
				else
				{
					if (count == 0)
					{
						strConstruct = pSP->m_key;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_key;
					}
				}
				count++; // count the word represented by this source phrase
				if (count == nLimit)
				{
					break;
				}
			}
			if (bIgnoreCase)
				strConstruct.MakeLower();

			// we exit either because nTotal is less than nLimit (in which case pos2 became
			// null before count was able to become equal to nLimit), or because count equals
			// nLimit. So now we must update the value of nTotal, so that it equals the number
			// of remaining words (ie. srcPhrases) in the pTempList list.
			nTotal -= count;
			wxASSERT(nTotal >= 0);

			// now we must check for a match. If nTotal is zero, the match can be a substring,
			// and if bFirstAttempt is TRUE, that substring can be not at the start of the search
			// string, etc. The test is different if we are on an iteration other than 1st, for
			// nCount == 1
			if (nCount == 1 && nIteration > 1)
			{
				nFound = IsMatchedToEnd(strConstruct,strSearchTarget);
			}
			else
			{
				nFound = strSearchTarget.Find(strConstruct);
			}
			if (nFound == -1)
			{
				// no match, so goto a: to try next iteration, provided nCount is still 1; if
				// nCount is greater than 1 we are not in the first SrcPhrase, and so a non-match
				// means we must return FALSE
				if (nCount == 1)
				{
					// try next iteration (with a shorter search string)
					goto a;
				}
				else
				{
					return FALSE;
				}
			}

			// we have a match, so check out whether it is exact, or a substring, etc.
			nTargetLength = strSearchTarget.Length();
			nSearchLength = strConstruct.Length();
			nAddParts = 0;
			if (nTotal > 0)
			{
				// there is more in the search string yet to be matched, so we are not at the last
				// source phrase to be tested when in this nTotal > 0 == TRUE code block
				if (bFirstAttempt)
				{
					// nFound can be non-zero, but the matching must be done up to the end of the
					// strSearchTarget string, else we have a discontinuity and so return FALSE or
					// iterate
					nAddParts = nFound + nSearchLength;
					if (nAddParts < nTargetLength)
					{
						if (nCount == 1 && nIteration < nLimit)
						{
							// no match: we can try with a shorter search string, so iterate to
							// do so
							goto a;
						}
						else
						{
							// nCount > 1, can't possibly match because of discontinuity,
							// so return FALSE
							return FALSE;
						}
					}
					wxASSERT(nAddParts == nTargetLength); // we can continue, valid matching so far
				}
				else
				{
					// there was a previous match or matches, so this matched string must be
					// coextensive with strSearchTarget itself, to avoid a discontinuity in the
					// matching, since there is yet more waiting to be tested for a match in a
					// later srcPhrase; if there is a discontinuity, check for the possibility
					// of an iteration and do so if the conditions are right, else return FALSE
					if (nSearchLength != nTargetLength)
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto a; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
					wxASSERT(nSearchLength == nTargetLength); // okay so far, so continue
				}
			}
			else
			{
				// nTotal must be zero, and so this current match is the last - but it must
				// match from the beginning of strSearchTarget, unless bFirstAttempt is also TRUE
				wxASSERT(nTotal == 0);
				if (bFirstAttempt)
				{
					// we have just made our first match, ie, we are at the start of the search
					// string, so nFind can be non-zero legitimately, so we can return TRUE,
					// since we are done
					return TRUE;
				}
				else
				{
					// we are at the end of the search string, and there were previous matches, so
					// the offset to the first matched character must be zero, if not, we do not
					// have continuity in the matching, hence not a legitimate match
					if (nFound == 0)
					{
						return TRUE;
					}
					else
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto a; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
				}
			}

			// we have finished our first attempt (ie. trying to match in first srcPhrase), so
			// make bFirstAttempt FALSE for subsequent traverses through the loop
			bFirstAttempt = FALSE;
		}
		return FALSE;
		break;

	case 1: // target only
	default:
		while (pos1 != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetNext();
			wxASSERT(pSrcPhrase != NULL); 

			// count the words in the m_adaption member, using TokenizeText, which is more
			// sophisticated than just counting white space etc.
			wxString aString = pSrcPhrase->m_adaption;
			SPList* pAList = new SPList;
			int	length = aString.Length();
			int numElements = 0;
			if (!aString.IsEmpty())
			{
				numElements = pDoc->TokenizeText(0,pAList,aString,length);
				DeleteTempList(pAList);
			}
			else
			{
				// if aString is empty, we've nothing to search in on this srcPhrase,
				// so cause progression
				delete pAList; // don't leak memory
				if (bFirstOnly)
					pos = pos1;
				return FALSE;
			}
			nWordCount = numElements;

			nLimit = wxMin(nTotal,nWordCount);
			nCount++; // count this source phrase (it could have more than one word in its
					  // m_key or m_srcPhrase)
			if (bFirstOnly)
			{
				bFirstOnly = FALSE;
				pos = pos1; // we need to return only this one, because the caller needs to
							// know when the end of pList has been reached, so that the caller's
							// loop can be exited cleanly
			}
			else
			{
				nIteration = 0; // no iterations allowed for src phrases other than the first
			}

			// compute strSearchTarget
			if (bIncludePunct)
			{
				strSearchTarget = pSrcPhrase->m_targetStr;
			}
			else
			{
				strSearchTarget = pSrcPhrase->m_adaption;
			}
			if (bIgnoreCase)
				strSearchTarget.MakeLower();

			// how many iterations left to be tried, for the first phrase
b:			if (nCount == 1)
			{
				nTotal = nElements; // reset, for each iteration
				nIteration++;  // which iteration within the nCount == 1 loop are we on
				nLimit = wxMin(nTotal,nWordCount) - nIteration + 1;
			}
			else
				nLimit = wxMin(nTotal,nWordCount);

			if (nIteration > wxMin(nTotal,nWordCount))
				return FALSE; // couldn't make a match in the first source phrase, and the rest
							  // match also

			// we use nWordCount together with pTempList data in order to build a strConstruct
			// which has nWordCount words in it - either with or without punctuation depending
			// on the bIncludePunct value, (or there can be less than nWordCount words, if the
			// search string is short enough); then for each nIterations decrement, try building
			// one word less each time (provided no earlier iteration produced a match)
			if (nCount == 1)
			{
				// go back to the start of the user's typed string, for every iteration while
				// nCount == 1
				pos2 = pTempList->GetFirst();
			}
			count = 0; // count of words from user's typed string which are to be used for this
					   // test
			while (pos2 != NULL)
			{
				pSP = (CSourcePhrase*)pos2->GetData();
				pos2 = pos2->GetNext();
				wxASSERT(pSP != NULL);
				if (bIncludePunct)
				{
					if (count == 0)
					{
						strConstruct = pSP->m_srcPhrase;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_srcPhrase;
					}
				}
				else
				{
					if (count == 0)
					{
						strConstruct = pSP->m_key;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_key;
					}
				}
				count++; // count the word represented by this source phrase
				if (count == nLimit)
				{
					break;
				}
			}
			if (bIgnoreCase)
				strConstruct.MakeLower();

			// we exit either because nTotal is less than nLimit (in which case pos2 became null
			// before count was able to become equal to nLimit), or because count equals nLimit.
			// So now we must update the value of nTotal, so that it equals the number of
			// remaining words (ie. srcPhrases) in the pTempList list.
			nTotal -= count;
			wxASSERT(nTotal >= 0);

			// now we must check for a match. If nTotal is zero, the match can be a substring,
			// and if bFirstAttempt is TRUE, that substring can be not at the start of the search
			// string, etc. The test is different if we are on an iteration other than 1st, for
			// nCount == 1
			if (nCount == 1 && nIteration > 1)
			{
				nFound = IsMatchedToEnd(strConstruct,strSearchTarget);
			}
			else
			{
				nFound = strSearchTarget.Find(strConstruct);
			}
			if (nFound == -1)
			{
				// no match, so goto a: to try next iteration, provided nCount is still 1; if
				// nCount is greater than 1 we are not in the first SrcPhrase, and so a
				// non-match means we must return FALSE
				if (nCount == 1)
				{
					// try next iteration (with a shorter search string)
					goto b;
				}
				else
				{
					return FALSE;
				}
			}

			// we have a match, so check out whether it is exact, or a substring, etc.
			nTargetLength = strSearchTarget.Length();
			nSearchLength = strConstruct.Length();
			nAddParts = 0;
			if (nTotal > 0)
			{
				// there is more in the search string yet to be matched, so we are not at the last
				// source phrase to be tested when in this nTotal > 0 == TRUE code block
				if (bFirstAttempt)
				{
					// nFound can be non-zero, but the matching must be done up to the end of the
					// strSearchTarget string, else we have a discontinuity and so return FALSE or
					// iterate
					nAddParts = nFound + nSearchLength;
					if (nAddParts < nTargetLength)
					{
						if (nCount == 1 && nIteration < nLimit)
						{
							// no match: we can try with a shorter search string, so iterate to
							// do so
							goto b;
						}
						else
						{
							// nCount > 1, can't possibly match because of discontinuity,
							// so return FALSE
							return FALSE;
						}
					}
					wxASSERT(nAddParts == nTargetLength); // we can continue, valid matching so far
				}
				else
				{
					// there was a previous match or matches, so this matched string must be
					// coextensive with strSearchTarget itself, to avoid a discontinuity in the
					// matching, since there is yet more waiting to be tested for a match in a
					// later srcPhrase; if there is a discontinuity, check for the possibility
					// of an iteration and do so if the conditions are right, else return FALSE
					if (nSearchLength != nTargetLength)
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto b; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
					wxASSERT(nSearchLength == nTargetLength); // okay so far, so continue
				}
			}
			else
			{
				// nTotal must be zero, and so this current match is the last - but it must
				// match from the beginning of strSearchTarget, unless bFirstAttempt is also TRUE
				wxASSERT(nTotal == 0);
				if (bFirstAttempt)
				{
					// we have just made our first match, ie, we are at the start of the search
					// string, so nFind can be non-zero legitimately, so we can return TRUE,
					// since we are done
					return TRUE;
				}
				else
				{
					// we are at the end of the search string, and there were previous matches, so
					// the offset to the first matched character must be zero, if not, we do not
					// have continuity in the matching, hence not a legitimate match
					if (nFound == 0)
					{
						return TRUE;
					}
					else
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto b; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
				}
			}

			// we have finished our first attempt (ie. trying to match in first srcPhrase),
			// so make bFirstAttempt FALSE for subsequent traverses through the loop
			bFirstAttempt = FALSE;
		}
		return FALSE;
		break;
	}
#ifndef __VISUALC__
	return FALSE; // unreachable according to VC7.1, but gcc says it is needed!!!
#endif
}

bool CAdapt_ItView::DoSrcOnlyFind(int nStartSequNum, bool bIncludePunct, bool bSpanSrcPhrases,
								  wxString& src,bool bIgnoreCase, int& nSequNum, int& nCount)
// searches in the list of source phrases for a match, ignores the view; if glossing is ON
// then bIncludePunct and bSpanSrcPhrases will be obligatorily FALSE; and nCount should not
// get set to anything except 1 (when glossing is ON)
// ALSO NOTE: for simplicity I had a test of gbIsGlossing set the bIncludePunct flag to FALSE,
// which strictly speaking is too strong a condition when the search is done only in the
// source text; however, since few people use the Find... command, and fewer still are likely
// to use it with glossing ON and at the same time want a punctuated search in the source text,
// I figure I can get this past muster without anyone ever discovering it! In other words, when
// glossing is ON, the search will be in source text where punctuation has been excluded.
{
	if (gbIsGlossing)
	{
		wxASSERT(!bIncludePunct && !bSpanSrcPhrases);
	}
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);
	SPList* pList = gpApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int nRetransFirst = -1;
	int nRetransLast = -1;
	bool bInRetrans = FALSE;
	int nFound;
	wxString srcCopy; // for caseless matching
	wxString searchCopy; // for caseless searching in it
	wxString srcNoPunct; // for making a copy from which we can remove punctuation

	if (bSpanSrcPhrases)
	{
		// must never enter here when glossing is ON
		bool bFound = FALSE;

		// parse a copy of the src text string, storing the results in temporary CSourcePhrase
		// instances so that the m_key members hold the punctuation-less words, and the
		// m_srcPhrase members the punctuated words
		SPList* pTempList = new SPList; // a temporary list
		wxASSERT(pTempList != NULL);

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		wxString theString = src;
		int	length = theString.Length();
		int nElements = 0;
		if (!theString.IsEmpty())
		{
			nElements = pDoc->TokenizeText(0,pTempList,theString,length);
		}
		else
		{
			// if theString is empty, we've nothing to search for, so return FALSE
			delete pTempList; // don't leak memory
			return FALSE;
		}

		// do the search, and permit matching text across discrete CSourcePhrase instances
		SPList::Node* savePos;
e:		while (pos != NULL)
		{
			wxString tgt;
			tgt.Empty();
			savePos = pos; // test for initial matched srcPhrase in a retranslation
			bFound = DoExtendedSearch(0,pos,pDoc,pTempList,nElements,
														bIncludePunct,bIgnoreCase,nCount);
			if (bFound)
			{
				nSequNum = sn;
				goto d;
			}
			else
			{
				sn++;
			}
		}
		// if we get here, pos is null, and so we have no match possible
		DeleteTempList(pTempList);
		return FALSE;

		// we found a match, check if it is in a retranslation & adjust nCount & nSequNum if it
		// is contained within the retranslation
d:		pSrcPhrase = (CSourcePhrase*)savePos->GetData();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bRetranslation)
		{
			bInRetrans = IsContainedByRetranslation(nSequNum,nCount,nRetransFirst,nRetransLast);
			if (bInRetrans)
			{
				// adjust values, so that the match is the whole retranslation
				CPile* pP = GetPile(nRetransFirst);
				wxASSERT(pP != NULL);
				CSourcePhrase* pSP = pP->m_pSrcPhrase;
				wxASSERT(pSP != NULL);
				nSequNum = pSP->m_nSequNumber;
				nCount = nRetransLast - nRetransFirst + 1;

				// set the globals
				gbMatchedRetranslation = TRUE;
				gnRetransEndSequNum = nRetransLast;
				DeleteTempList(pTempList);
				return TRUE;
			}
			else
			{
				// clear the globals
				gbMatchedRetranslation = FALSE;
				gnRetransEndSequNum = -1;
				goto e; // continue iterating, looking for a match
			}
		}
		// clear the globals
		gbMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		DeleteTempList(pTempList);
		return TRUE; // return with unchanged nSequNum and nCount values
	}
	else // could be glossing or adapting
	{
		// do the search, confining attempts to match the text within a single CSourcePhrase
		// instance
		nFound = -1; // assume not found
		srcCopy = src; // for caseless matching
		//searchCopy; // for caseless searching in it // ??? same in MFC
		srcNoPunct = src; // make a copy from which we can remove punctuation
		RemovePunctuation(pDoc,&srcNoPunct,0 /*from src*/);
		if (bIgnoreCase)
		{
			srcCopy.MakeLower();
			srcNoPunct.MakeLower();
		}
f:		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

			// do the searching either in m_srcPhrase or m_key, depending on whether punctuation
			// is to be included in the search or not
			if (bIncludePunct)
			{
				// use the m_srcPhrase attribute if adapting; don't enter this block
				// if glossing is ON
				if (pSrcPhrase->m_srcPhrase.IsEmpty() || pSrcPhrase->m_bNullSourcePhrase)
				{
					goto b;
				}
				searchCopy = pSrcPhrase->m_srcPhrase;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				nFound = searchCopy.Find(srcCopy);
b:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto c;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
			else // bIncludePunct is FALSE, so if glossing is ON it too will use this block
			{
				// use the m_key attribute
				if (pSrcPhrase->m_key.IsEmpty() || pSrcPhrase->m_bNullSourcePhrase)
				{
					goto a;
				}
				searchCopy = pSrcPhrase->m_key;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				nFound = searchCopy.Find(srcNoPunct);
a:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto c;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
		}
	}

	// if we get here, we didn't find a match
	return FALSE;

	// we found a match, check if it is in a retranslation & adjust nCount & nSequNum if it
	// is contained within the retranslation; but we don't want to test this if glossing is ON
	// because matching can be within a translation in that circumstance
c: if (gbIsGlossing)
   {
	gbMatchedRetranslation = FALSE;
	gnRetransEndSequNum = -1;
	return TRUE;
   }
   // when not glossing we have to consider the possibility that we may be in, out, or
   // partially within a retranslation
	if (pSrcPhrase->m_bRetranslation)
	{
		bInRetrans = IsContainedByRetranslation(nSequNum,nCount,nRetransFirst,nRetransLast);
		if (bInRetrans)
		{
			// adjust values, so that the match is the whole retranslation
			CPile* pP = GetPile(nRetransFirst);
			wxASSERT(pP != NULL);
			CSourcePhrase* pSP = pP->m_pSrcPhrase;
			wxASSERT(pSP != NULL);
			nSequNum = pSP->m_nSequNumber;
			nCount = nRetransLast - nRetransFirst + 1;

			// set the globals
			gbMatchedRetranslation = TRUE;
			gnRetransEndSequNum = nRetransLast;
			return TRUE;
		}
		else
		{
			// clear the globals
			gbMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			goto f; // continue iterating, looking for a match
		}
	}
	// clear the globals
	gbMatchedRetranslation = FALSE;
	gnRetransEndSequNum = -1;
	return TRUE; // return with unchanged nSequNum and nCount values
}

bool CAdapt_ItView::DoTgtOnlyFind(int nStartSequNum, bool bIncludePunct, bool bSpanSrcPhrases,
								  wxString& tgt, bool bIgnoreCase, int& nSequNum, int& nCount)
// searches in the list of source phrases for a match, ignores the view; when glossing is ON
// the 'tgt' will be the glossing line; and the 2nd and 3rd parameters will be FALSE, and
// nCount must only return 1 (when glossing is ON). Glossing text by default allows any typed
// punctuation to be stored; so bIncludePunct == FALSE does nothing to affect whether gloss text
// has punctuation, it just stops certain blocks of code being entered.
{
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL); 
	SPList* pList = gpApp->m_pSourcePhrases;
	wxASSERT(pList != NULL); 
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int nRetransFirst = -1;
	int nRetransLast = -1;
	bool bInRetrans = FALSE;
	int nFound; // -1 = assume not found
	wxString tgtCopy; // for caseless matching
	wxString searchCopy; // for caseless searching in it
	wxString tgtNoPunct; // for making a copy from which we can remove punctuation

	// if bSpanSrcPhrases is TRUE,but the tgt string is empty, then it makes no sense to
	// span source phrases, so this case reduces to a normal search within a single srcPhrase
	if (bSpanSrcPhrases && tgt.IsEmpty())
		goto c;

	if (bSpanSrcPhrases)
	{
		wxASSERT(!gbIsGlossing); // must not be glossing if we enter this block
		// do the search, and permit matching text across discrete CSourcePhrase instances
		bool bFound = FALSE;

		// parse a copy of the tgt text string, storing the results in temporary CSourcePhrase
		// instances so that the m_key members hold the punctuation-less words, and the
		// m_srcPhrase members the punctuated words
		SPList* pTempList = new SPList; // a temporary list
		wxASSERT(pTempList != NULL); 

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		wxString theString = tgt;
		int	length = theString.Length();
		int nElements = 0;
		if (!theString.IsEmpty())
		{
			nElements = pDoc->TokenizeText(0,pTempList,theString,length);
		}
		else
		{
			// if theString is empty, we've nothing to search for, so return FALSE
			delete pTempList; // don't leak memory
			return FALSE;
		}

		// do the search, and permit matching text across discrete CSourcePhrase instances
		SPList::Node* savePos; 
h:		while (pos != NULL)
		{
			wxString src;
			src.Empty();
			savePos = pos;
			bFound = DoExtendedSearch(1,pos,pDoc,pTempList,nElements,
														bIncludePunct,bIgnoreCase,nCount);
			if (bFound)
			{
				nSequNum = sn;
				goto d;
			}
			else
			{
				sn++;
			}
		}
		// if we get here, pos is null, and so we have no match possible
		DeleteTempList(pTempList);
		return FALSE;

		// we found a match, check if it is in a retranslation & adjust nCount & nSequNum if it
		// is contained within the retranslation
d:		pSrcPhrase = (CSourcePhrase*)savePos->GetData();
		wxASSERT(pSrcPhrase != NULL); 
		if (pSrcPhrase->m_bRetranslation)
		{
			bInRetrans = IsContainedByRetranslation(nSequNum,nCount,nRetransFirst,nRetransLast);
			if (bInRetrans)
			{
				// adjust values, so that the match is the whole retranslation
				CPile* pP = GetPile(nRetransFirst);
				wxASSERT(pP != NULL);
				CSourcePhrase* pSP = pP->m_pSrcPhrase;
				wxASSERT(pSP != NULL);
				nSequNum = pSP->m_nSequNumber;
				nCount = nRetransLast - nRetransFirst + 1;

				// set the globals
				gbMatchedRetranslation = TRUE;
				gnRetransEndSequNum = nRetransLast;
				DeleteTempList(pTempList);
				return TRUE;
			}
			else
			{
				// clear the globals
				gbMatchedRetranslation = FALSE;
				gnRetransEndSequNum = -1;
				goto h; // continue iterating, looking for a match
			}
		}
		// clear the globals
		gbMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		DeleteTempList(pTempList);
		return TRUE; // return with unchanged nSequNum and nCount values
	}
	else // bSpanSrcPhrases == FALSE branch; glossing ON uses this branch always
	{
		// do the search, confining attempts to match the text within
		// a single CSourcePhrase instance
c:		nFound = -1; // assume not found
		tgtCopy = tgt; // for caseless matching (tgt would contain search string for finding
					   // within glosses if glossing is ON)
		//searchCopy; // for caseless searching in it // ??? same in MFC
		tgtNoPunct = tgt; // make a copy from which we can remove punctuation
		if (!gbIsGlossing)
			RemovePunctuation(pDoc,&tgtNoPunct,1 /*from tgt*/);
		if (bIgnoreCase)
		{
			tgtCopy.MakeLower();
			tgtNoPunct.MakeLower();
		}
i:		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

			// do the searching either in m_targetStr or m_adaption, depending on whether
			// punctuation is to be included in the search or not
			if (bIncludePunct) // glossing ON forces this boolean FALSE in caller, so glossing
							   // does not use this block, but only the ELSE block
			{
				// use the m_targetStr attribute
				if (pSrcPhrase->m_targetStr.IsEmpty())
				{
					// since we allow null matches, check for this
					if (tgt.IsEmpty())
					{
						// we have a null match, so success
						nSequNum = sn;
						nCount = 1;
						goto e;
					}
					else
						goto b;
				}
				else
				{
					if (tgt.IsEmpty())
						goto b; // can't allow a Find with a null phrase, it would match anything
				}
				searchCopy = pSrcPhrase->m_targetStr;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				nFound = searchCopy.Find(tgtCopy);
b:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto e;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
			else // bIncludePunct == FALSE branch; glossing ON also uses this branch
			{
				// use the m_adaption attribute when adapting, m_gloss when glossing
				bool bTest;
				if (gbIsGlossing)
					bTest = pSrcPhrase->m_gloss.IsEmpty();
				else
					bTest = pSrcPhrase->m_adaption.IsEmpty();
				if (bTest)
				{
					// no text, since we allow null matches check for a null match
					if (tgt.IsEmpty())
					{
						// we have a null match, so success
						nSequNum = sn;
						nCount = 1;
						goto e;
					}
					else
						goto a;
				}
				else // there is some adaptation, or gloss, text
				{
					if (tgt.IsEmpty())
						goto a; // can't allow a Find with a null phrase,
								// (except for a null match) because it would match anything
				}
				if (gbIsGlossing)
					searchCopy = pSrcPhrase->m_gloss;
				else
					searchCopy = pSrcPhrase->m_adaption;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				if (gbIsGlossing)
				{
					nFound = pSrcPhrase->m_gloss.Find(tgt); // possibly a punctuation-containing search
				}
				else // not glossing
				{
					nFound = pSrcPhrase->m_adaption.Find(tgtNoPunct);
				}
a:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto e;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
		}
	}

	// if we get here, we didn't find a match
	return FALSE;

	// we found a match, check if it is in a retranslation & adjust nCount & nSequNum if it
	// is contained within the retranslation
e:	if (gbIsGlossing)
	{
		gbMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
	}
	// if not glossing, we have to check out if we landed in, or partly in, or out of
	// a retranslation - and fix things accordingly.
	if (pSrcPhrase->m_bRetranslation)
	{
		bInRetrans = IsContainedByRetranslation(nSequNum,nCount,nRetransFirst,nRetransLast);
		if (bInRetrans)
		{
			// adjust values, so that the match is the whole retranslation
			CPile* pP = GetPile(nRetransFirst);
			wxASSERT(pP != NULL);
			CSourcePhrase* pSP = pP->m_pSrcPhrase;
			wxASSERT(pSP != NULL);
			nSequNum = pSP->m_nSequNumber;
			nCount = nRetransLast - nRetransFirst + 1;

			// set the globals
			gbMatchedRetranslation = TRUE;
			gnRetransEndSequNum = nRetransLast;
			return TRUE;
		}
		else
		{

			// clear the globals
			gbMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			goto i; // continue iterating, looking for a match
		}
	}
	// clear the globals
	gbMatchedRetranslation = FALSE;
	gnRetransEndSequNum = -1;
	return TRUE; // return with unchanged nSequNum and nCount values
}

bool CAdapt_ItView::DoSrcAndTgtFind(int nStartSequNum, bool bIncludePunct, bool bSpanSrcPhrases,
									wxString& src, wxString& tgt, bool bIgnoreCase, int& nSequNum,
									int& nCount)
// see the comments at the start of the DoSrcOnlyFind( ) and DoTgtOnlyFind( ) - same stuff applies
// here; and tgt could be text to check in adaptations, or glosses, depending on gbIsGlossing value
{
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL); 
	SPList* pList = gpApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int nSaveSrcSequNum = -1;
	int nCount1 = 0;
	int nCount2 = 0;
	int nRetransFirst = -1;
	int nRetransLast = -1;
	bool bInRetrans = FALSE;
	bool bSrcMatchIsRetrans = FALSE;
	bool bFound = FALSE;
	SPList* pTempList = NULL;
	int length = 0;
	int nElements = 0;
	int nElements2 = 0;
	wxString theString;
	theString.Empty();
	SPList::Node* savePos = NULL;
	int nFound; // -1 = assume not found
	wxString srcCopy;
	wxString tgtCopy;
	wxString searchStr;
	wxString srcNoPunct; // for making a copy from which we can remove punctuation

	if (bSpanSrcPhrases)
	{
		wxASSERT(!gbIsGlossing); // cannot enter this block when glossing is ON
		// do the search, and permit matching text across discrete CSourcePhrase instances
		bFound = FALSE;

		// parse a copy of the src text string, storing the results in temporary CSourcePhrase
		// instances so that the m_key members hold the punctuation-less words, and the
		// m_srcPhrase members the punctuated words
		pTempList = new SPList; // a temporary list
		wxASSERT(pTempList != NULL);

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		theString = src;
		length = theString.Length();
		nElements = 0;
		if (!theString.IsEmpty())
		{
			nElements = pDoc->TokenizeText(0,pTempList,theString,length);
		}
		else
		{
			// if theString is empty, we've nothing to search for, so return FALSE
			delete pTempList; // don't leak memory
			return FALSE;
		}

		// do the search, and permit matching text across discrete CSourcePhrase instances
		SPList::Node* savePos = NULL; // whm initialized to NULL 
e:		while (pos != NULL)
		{
			wxString tgt;
			tgt.Empty();
			savePos = pos;
			bFound = DoExtendedSearch(0,pos,pDoc,pTempList,nElements,
														bIncludePunct,bIgnoreCase,nCount1);
			if (bFound)
			{
				nSaveSrcSequNum = sn;
				break;
			}
			else
			{
				sn++;
			}
		}
		// if we get here, pos is null, or we have a src match, if the latter,
		// do the target search
		if (pos == NULL || nSaveSrcSequNum == -1 || savePos == NULL) // whm added || savePos == NULL
		{
			// we didn't get a src match, so return
			DeleteTempList(pTempList);
			return FALSE;
		}

		// we found a match, check if it is in a retranslation & adjust nCount1 & nSequNum if it
		// is contained within the retranslation
		pSrcPhrase = (CSourcePhrase*)savePos->GetData();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bRetranslation)
		{
			bInRetrans = IsContainedByRetranslation(nSaveSrcSequNum,nCount1,
														nRetransFirst,nRetransLast);
			if (bInRetrans)
			{
				// adjust values, so that the match is the whole retranslation
				CPile* pP = GetPile(nRetransFirst);
				wxASSERT(pP != NULL);
				CSourcePhrase* pSP = pP->m_pSrcPhrase;
				wxASSERT(pSP != NULL);
				nSaveSrcSequNum = pSP->m_nSequNumber;
				nCount1 = nRetransLast - nRetransFirst + 1;
				bSrcMatchIsRetrans = TRUE;
			}
			else
			{
				// clear the globals
				bSrcMatchIsRetrans = FALSE;
				gbMatchedRetranslation = FALSE;
				gnRetransEndSequNum = -1;
				sn++;
				nSaveSrcSequNum = -1;
				goto e; // continue iterating, looking for a match
			}
		}
		else
		{
			bSrcMatchIsRetrans = FALSE;
		}

		// before doing the target search, we must check for an empty tgt string. If it is empty,
		// then the only meaningful "match" is that nCount1 source phrases matched so far must
		// each have an empty string in their m_adaption member. So if that is so, we have a
		// null match and can exit TRUE. So do the check next.
		if (tgt.IsEmpty())
		{
			SPList::Node* pos3 = pList->Item(nSaveSrcSequNum); 
			wxASSERT(pos3 != 0);
			for (int j=0; j < nCount1; j++)
			{
				CSourcePhrase* pSP = (CSourcePhrase*)pos3->GetData();
				pos3 = pos3->GetNext();
				wxASSERT(pos3 != 0);
				if (!pSP->m_adaption.IsEmpty())
				{
					bSrcMatchIsRetrans = FALSE;
					gbMatchedRetranslation = FALSE;
					gnRetransEndSequNum = -1;
					sn++;
					nSaveSrcSequNum = -1;
					goto e; // continue iterating, looking for a match
				}
			}

			// if we get here, we have a valid match, so return
			nSequNum = nSaveSrcSequNum;
			nCount = nCount1;
			DeleteTempList(pTempList);
			return TRUE;
		}

		// now try the target search - (use code copied from DoTgtFindOnly() & modified a bit)
		// (formerly g:)
		bFound = FALSE;

		// start at the sequ number just defined
		SPList::Node* pos2 = pList->Item(nSaveSrcSequNum);
		sn = nSaveSrcSequNum;

		// parse a copy of the tgt text string, storing the results in temporary CSourcePhrase
		// instances so that the m_key members hold the punctuation-less words, and the
		// m_srcPhrase members the punctuated words
		SPList* pTempList2 = new SPList; // a temporary list for the tgt ones
		wxASSERT(pTempList2 != NULL); 

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		theString = tgt;
		length = theString.Length();
		nElements2 = 0;
		if (!theString.IsEmpty())
		{
			nElements2 = pDoc->TokenizeText(0,pTempList2,theString,length);
		}
		// note, we will permit "matching" an empty string in the target text

		// if the target's nElements2 > nElements, no match is possible (the target must match
		// within the scope of the source match), though it may be possible if the source match
		// was in a retranslation
		if (nElements2 > nElements && !bSrcMatchIsRetrans)
		{
			gbMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			sn = nSaveSrcSequNum; // prepare for outer loop
			sn++;
			nSaveSrcSequNum = -1;
			goto e;
		}

		// do the search, and permit matching text across discrete CSourcePhrase instances
		while (pos2 != NULL)
		{
			wxString src;
			src.Empty();
			savePos = pos2; // DoExtendedSearch returns pos value at next location to the
							// input parameter pos2 value, so to preserve the input one,
							// we need savePos as well
			bFound = DoExtendedSearch(1,pos2,pDoc,pTempList2,nElements2,
													bIncludePunct,bIgnoreCase,nCount2);
			if (bFound)
			{
				nSequNum = sn;
				DeleteTempList(pTempList2);

				// we have a double match only if the sequence number for the first srcPhrase of
				// each match is the same and the target selection is no longer than the source
				// one; or if not the same, then both nSequNum and the end of the target
				// match lie within the source text selection, which amounts to conditions on
				// nCount1 and nCount2 values

				// we found a match, check if it is in same retranslation if the first match was
				// in one
				pSrcPhrase = (CSourcePhrase*)savePos->GetData();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_bRetranslation && bSrcMatchIsRetrans)
				{
					bInRetrans = IsContainedByRetranslation(nSequNum,nCount2,
															nRetransFirst,nRetransLast);
					if (bInRetrans)
					{
						// the match is the whole retranslation
						nSequNum = nSaveSrcSequNum;
						nCount = nCount1;

						// set the globals
						gbMatchedRetranslation = TRUE;
						gnRetransEndSequNum = nRetransLast;
						if (pTempList != NULL) DeleteTempList(pTempList); // don't leak memory
						return TRUE;
					}
					else
					{
						// continue iterating the source loop, since the src string matched the
						// retranslation but the tgt string matched at best only part of the
						// retranslation which makes it a non-match for the src/tgt string pair
						// (caller clears the globals)
						bSrcMatchIsRetrans = FALSE;
						gbMatchedRetranslation = FALSE;
						gnRetransEndSequNum = -1;
						sn = nSaveSrcSequNum; // prepare for outer loop
						sn++;
						nSaveSrcSequNum = -1;
						goto e;
					}
				}
				else
				{
					// not a retranslation match
					if (nSaveSrcSequNum == nSequNum)
					{
						if (nCount2 <= nCount1)
						{
							// we have a valid match, but not to a retranslation
							gbMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							nCount = nCount1;
							if (pTempList != NULL) DeleteTempList(pTempList); // don't leak memory
							return TRUE;
						}
						else
						{
							// match is not valid
							bSrcMatchIsRetrans = FALSE;
							gbMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							sn = nSaveSrcSequNum; // prepare for outer loop
							sn++;
							nSaveSrcSequNum = -1;
							goto e;
						}
					}
					else if (nSequNum < nSaveSrcSequNum + nCount1)
					{
						if (nSequNum + nCount2 <= nSaveSrcSequNum + nCount1)
						{
							// we have a valid match
							gbMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							nSequNum = nSaveSrcSequNum;
							nCount = nCount1;
							if (pTempList != NULL) DeleteTempList(pTempList); // don't leak memory
							return TRUE;
						}
						else
						{
							// match is not valid
							bSrcMatchIsRetrans = FALSE;
							gbMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							sn = nSaveSrcSequNum; // prepare for outer loop
							sn++;
							nSaveSrcSequNum = -1;
							goto e;
						}
					}
					else
					{
						bSrcMatchIsRetrans = FALSE;
						gbMatchedRetranslation = FALSE;
						gnRetransEndSequNum = -1;
						sn = nSaveSrcSequNum; // prepare for outer loop
						sn++;
						nSaveSrcSequNum = -1;
						goto e;
					}
				}
			}
			else // no match, so continue at next sequ number in the inner pos2 loop, until invalid
			{
				sn++;

				// discontinue tgt search & continue src search if sn gets beyond range for the
				// src match
				if (sn >= nSaveSrcSequNum + nCount1)
				{
					bSrcMatchIsRetrans = FALSE;
					gbMatchedRetranslation = FALSE;
					gnRetransEndSequNum = -1;
					sn = nSaveSrcSequNum; // prepare for outer loop
					sn++;
					nSaveSrcSequNum = -1;
					goto e;
				}
			}
		}
		// if we get here, pos2 is null, and so we have no later target match possible, so there
		// is no point to trying further source matches
		DeleteTempList(pTempList2);
		if (pTempList != NULL) DeleteTempList(pTempList); // don't leak memory
		return FALSE;
	}
	else // bSpanSrcPhrases == FALSE block; also glossing ON always uses this block
	{
		// do the search, confining attempts to match the text within a single
		// CSourcePhrase instance
		nFound = -1; // assume not found
		srcCopy = src;
		tgtCopy = tgt;
		//searchStr; // ??? same in MFC
		srcNoPunct = src; // make a copy from which we can remove punctuation
		RemovePunctuation(pDoc,&srcNoPunct,0 /*from src*/); // independent of gbIsGlossing
		wxString tgtNoPunct = tgt; // make a copy from which we can remove punctuation
		if (!gbIsGlossing)
			RemovePunctuation(pDoc,&tgtNoPunct,1 /*from tgt*/);
		if (bIgnoreCase)
		{
			srcCopy.MakeLower();
			tgtCopy.MakeLower();
			srcNoPunct.MakeLower();
			tgtNoPunct.MakeLower();
		}

		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

			// do the searching either in the pair m_srcPhrase &m_targetStr, or in the pair
			// m_key and m_adaption, depending on whether punctuation is to be included in the
			// search or not
			if (bIncludePunct) // if glossing is ON, this flag will be FALSE
			{
				// use the m_srcPhrase attribute
				if (pSrcPhrase->m_targetStr.IsEmpty())
				{
					if (pSrcPhrase->m_srcPhrase.IsEmpty())
					{
						goto b; // no match
					}
					// we allow a null match in the target, check for this, by continuing
				}
				searchStr = pSrcPhrase->m_srcPhrase;
				if (bIgnoreCase)
					searchStr.MakeLower();
				nFound = searchStr.Find(srcCopy);
			}
			else
			{
				// use the m_adaption attribute
				if (pSrcPhrase->m_adaption.IsEmpty())
				{
					if (pSrcPhrase->m_key.IsEmpty())
					{
						goto b; // no match
					}
					// we allow a null match in the target, check for this, by continuing
				}
				searchStr = pSrcPhrase->m_key;
				if (bIgnoreCase)
					searchStr.MakeLower();
				nFound = searchStr.Find(srcCopy);
			}
			if (nFound == -1)
				goto b;
			nFound = -1; // prepare for attempt to match in target text

			// we matched in the source text, check if the match was in a retranslation.
			// If it is, then we must make the whole retranslation be "matched", in which
			// case we cannot arbitrarily pick one of the target language m_targetStr or
			// m_adaption members as a corresponding since srcPhrase location in which to
			// search for the target, instead, we have to treat the target match as a
			// bSpanSrcPhrases == TRUE case, and try make the match anywhere within the
			// appropriate target text of the retranslation

			// check if the match is in a retranslation & adjust nCount & nSequNum if it
			// is contained within a retranslation; if glossing is ON we don't enter next block
			if (!gbIsGlossing && pSrcPhrase->m_bRetranslation)
			{
				bInRetrans = IsContainedByRetranslation(sn,1,nRetransFirst,nRetransLast);
				if (bInRetrans)
				{
					// adjust values, so that the match is the whole retranslation
					CPile* pP = GetPile(nRetransFirst);
					wxASSERT(pP != NULL); 
					CSourcePhrase* pSP = pP->m_pSrcPhrase;
					wxASSERT(pSP != NULL); 
					nSaveSrcSequNum = pSP->m_nSequNumber;
					nCount1 = nRetransLast - nRetransFirst + 1;

					// do a multi-element search for the target text, because retranslations
					// typically are longer than one sourcePhrase in length
					bSrcMatchIsRetrans = TRUE;

					// this block is copied code from above, & changed a bit
					bFound = FALSE;

					// start at the sequ number just defined
					SPList::Node* pos2 = pList->Item(nSaveSrcSequNum); 
					sn = nSaveSrcSequNum;

					// parse a copy of the tgt text string, storing the results in temporary
					// CSourcePhrase instances so that the m_key members hold the
					// punctuation-less words, and the m_srcPhrase members the punctuated words
					SPList* pTempList2 = new SPList; // a temporary list for the tgt ones
					wxASSERT(pTempList2 != NULL);

					// tokenize the string into a list of new CSourcePhrase instances on the heap
					// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
					theString = tgt;
					length = theString.Length();
					nElements = 0;
					if (!theString.IsEmpty())
					{
						nElements = pDoc->TokenizeText(0,pTempList2,theString,length);
					}
					// note, we will permit "matching" an empty string in the target text

					// do the search, and permit matching text across discrete CSourcePhrase
					// instances
					while (pos2 != NULL)
					{
						wxString src;
						src.Empty();
						savePos = pos2; // DoExtendedSearch returns pos value at next location
										// to the input parameter pos2 value, so to preserve the
										// input one, we need savePos as well
						bFound = DoExtendedSearch(1,pos2,pDoc,pTempList2,
												nElements,bIncludePunct,bIgnoreCase,nCount2);
						if (bFound)
						{
							nSequNum = sn;
							DeleteTempList(pTempList2);

							// we have a double match only if the sequence number for the first
							// srcPhrase of each match is the same and the target selection is
							// no longer than the source one; or if not the same, then both
							// nSequNum and the end of the target  match lie within the source
							// text selection, which amounts to conditions on nCount1 and nCount2
							// values

							// we found a match, check if it is in same retranslation if the
							// first match was in one
							pSrcPhrase = (CSourcePhrase*)savePos->GetData(); 
							wxASSERT(pSrcPhrase != NULL);
							if (pSrcPhrase->m_bRetranslation && bSrcMatchIsRetrans)
							{
								bInRetrans = IsContainedByRetranslation(nSequNum,nCount2,
																nRetransFirst,nRetransLast);
								if (bInRetrans)
								{
									// the match is the whole retranslation
									nSequNum = nSaveSrcSequNum;
									nCount = nCount1;

									// set the globals
									gbMatchedRetranslation = TRUE;
									gnRetransEndSequNum = nRetransLast;
									if (pTempList != NULL) DeleteTempList(pTempList); // don't
																					// leak memory
									return TRUE;
								}
								else
								{
									// continue iterating the source loop, since the src string
									// matched the retranslation but the tgt string matched at
									// best only part of the retranslation which makes it a
									// non-match for the src/tgt string pair (caller clears the
									// globals)
									bSrcMatchIsRetrans = FALSE;
									gbMatchedRetranslation = FALSE;
									gnRetransEndSequNum = -1;
									sn = nSaveSrcSequNum; // prepare to continue in outer loop
									goto g;
								}
							}
							else
							{
								// not a retranslation match
								if (nSaveSrcSequNum == nSequNum)
								{
									if (nCount2 <= nCount1)
									{
										// we have a valid match, but not to a retranslation
										gbMatchedRetranslation = FALSE;
										gnRetransEndSequNum = -1;
										nCount = nCount1;
										if (pTempList != NULL) DeleteTempList(pTempList); // don't
																					// leak memory
										return TRUE;
									}
									else
									{
										// match is not valid
										bSrcMatchIsRetrans = FALSE;
										sn = nSaveSrcSequNum; // prepare to continue in outer loop
										goto g;
									}
								}
								else if (nSequNum < nSaveSrcSequNum + nCount1)
								{
									if (nSequNum + nCount2 <= nSaveSrcSequNum + nCount1)
									{
										// we have a valid match
										gbMatchedRetranslation = FALSE;
										gnRetransEndSequNum = -1;
										nSequNum = nSaveSrcSequNum;
										nCount = nCount1;
										if (pTempList != NULL) DeleteTempList(pTempList); // don't
																					// leak memory
										return TRUE;
									}
									else
									{
										// match is not valid
										bSrcMatchIsRetrans = FALSE;
										sn = nSaveSrcSequNum; // prepare to continue in outer loop
										goto g;
									}
								}
								else
								{
									bSrcMatchIsRetrans = FALSE;
									sn = nSaveSrcSequNum; // prepare to continue in outer loop
									goto g; // the match in tgt was to the right of end of src
											// match
								}
							}
						}
						else // no match, so continue at next sequ number, in the pos2 loop for tgt
						{
							sn++;

							if (sn >= nSaveSrcSequNum + nCount1)
							{
								bSrcMatchIsRetrans = FALSE;
								sn = nSaveSrcSequNum;
								goto g;
							}
						}
					}
					// if we get here, pos2 is null, and so we have no later target match
					// possible, so there is no point to trying further source matches
					DeleteTempList(pTempList2);
					if (pTempList != NULL) DeleteTempList(pTempList); // don't leak memory
					return FALSE;
					// end of the copied & modified code block
				}
				else
				{
					// clear the globals
					bSrcMatchIsRetrans = FALSE;
					gbMatchedRetranslation = FALSE;
					gnRetransEndSequNum = -1;
					sn++;
					nSaveSrcSequNum = -1;
					continue; // continue iterating, looking for a match
				}
			} // end of block for testing if the srcPhrase is in a retranslation

			// we are now back in the outer pos loop:
			// continue searching in the single srcPhrase's target text for a match
			if (bIncludePunct)
				searchStr = pSrcPhrase->m_targetStr;
			else
			{
				if (gbIsGlossing)
				{
						searchStr = pSrcPhrase->m_gloss; // do it 'as is'
				}
				else
				{
					searchStr = pSrcPhrase->m_adaption;
				}
			}
			if (bIgnoreCase)
				searchStr.MakeLower();
			if (searchStr.IsEmpty())
			{
				// check for a null match
				if (tgt.IsEmpty())
				{
					// we have a null match, so success
					nSequNum = sn;
					nCount = 1;
					return TRUE;
				}
				else
				{
					// can't match, so try at a later source match if we can find one
					bSrcMatchIsRetrans = FALSE;
					sn++;
					nSaveSrcSequNum = -1;
					continue;
				}
			}
			else
			{
				if (tgt.IsEmpty())
				{
					bSrcMatchIsRetrans = FALSE;
					sn++;
					nSaveSrcSequNum = -1;
					continue; // can't allow a Find with a null string, it would match anything
							  // so try for a new source match
				}
			}
			nFound = searchStr.Find(tgtCopy);
b:			if (nFound >= 0)
			{
				// we found matching (sub)strings
				nSequNum = sn;
				nCount = 1;
				return TRUE;
			}
			else
			{
g:					sn++; // index for next CSourcePhrase instance to be searched
					nSaveSrcSequNum = -1;
			}
		}
	}

	// if we get here, we didn't find a match
	return FALSE;
}

bool CAdapt_ItView::DoReplace(int nActiveSequNum, bool bIncludePunct, wxString& tgt,
																wxString& replStr, int nCount)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);

	wxASSERT(nCount >= 1);
	wxASSERT(nActiveSequNum >= 0 && nActiveSequNum <= gpApp->m_maxIndex);
	wxASSERT(nActiveSequNum == gpApp->m_nActiveSequNum);
	// both or either of the strings can be empty (user is not too smart if they both are!)

	wxString tgtNoPunct = tgt;
	if (!gbIsGlossing)
		RemovePunctuation(pDoc,&tgtNoPunct,1 /*from tgt*/);
	wxString oldTgtNoPunct;
	oldTgtNoPunct.Empty();
	wxString oldTgt;
	oldTgt.Empty();
	wxString finalStr;
	finalStr.Empty();

	CPile* pPile = GetPile(nActiveSequNum);
	wxASSERT(pPile != NULL); 
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pPile->m_pSrcPhrase;
	wxASSERT(pSrcPhrase != NULL);

	// if it's a retranslation, the whole will be selected, so nCount will not be 1, even if
	// we didn't choose the multi-srcphrase match option, so check this case out first; if
	// glossing is ON, we ignore the fact that we matched within a retranslation
	if (!gbIsGlossing && pSrcPhrase->m_bRetranslation)
	{
		// we have matched something in a retranslation, so this has to invoke the retranslation
		// editor's dialog which will show the replacement done already when the dialog is shown,
		// user can edit it before dismissing the dialog, or just accept what was done;
		// initialize the globals that OnButtonEditRetranslation() will use
		gbReplaceInRetranslation = TRUE;
		gSrchStr = tgt;
		gReplStr = replStr;

		// allow user to edit result
		wxCommandEvent event;
		OnButtonEditRetranslation(event);

		// clear the globals
		gbMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
	}

	// we have to merge first, if nCount is greater than one
	// if glossing is ON, nCount being greater than 1 should not be possible since in
	// that circumstance we don't permit matching across piles
	if (nCount == 1)
	{
		// get the m_adaption member's contents, & m_targetStr; if glossing is ON, then
		// use m_gloss instead
		if (gbIsGlossing)
		{
			oldTgtNoPunct = pSrcPhrase->m_gloss;
			oldTgt = pSrcPhrase->m_gloss;
		}
		else
		{
			oldTgtNoPunct = pSrcPhrase->m_adaption;
			oldTgt = pSrcPhrase->m_targetStr;
		}

		// if we are at a <Not In KB> entry, clear this state because we are going to store
		// something for this entry now (and be sure its not in a retranslation - that is handled
		// differently below
		if (!gbIsGlossing &&
			!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB && !pSrcPhrase->m_bRetranslation)
		{
			wxString str = _T("<Not In KB>");
			CRefString* pRefString = GetRefString(pApp->m_pKB,
											gpApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
											gpApp->m_pActivePile->m_pSrcPhrase->m_key,str);
			if (pRefString != NULL)
			{
				// we must remove the KB entry
				CTargetUnit* pTgtUnit = pRefString->m_pTgtUnit;
				wxASSERT(pTgtUnit != NULL);
				TranslationsList* pList = pTgtUnit->m_pTranslations;
				wxASSERT(!pList->IsEmpty() && pList->GetCount() == 1);
				TranslationsList::Node* pos = pList->GetFirst();
				delete pRefString; // deletes the CRefString having the text "<Not In KB>"
				pList->DeleteNode(pos);

				// we must also delete the target unit, since we are setting up a situation
				// where in effect the current matched item was never previously matched, ie.
				// it's a big error to have a target unit with no reference string in it.
				int index = pSrcPhrase->m_nSrcWords - 1;
				MapKeyStringToTgtUnit* pMap = GetKB()->m_pMap[index];
				pMap->erase(pSrcPhrase->m_key); // remove it from the map

				// now remove the CTargetUnit instance too
				TUList::Node* tpos;
				tpos = GetKB()->m_pTargetUnits->Find(pTgtUnit); // find position of pRefString's
															   // owning targetUnit
				pTgtUnit = (CTargetUnit*)tpos->GetData(); // get the
															// targetUnit in the list
				wxASSERT(pTgtUnit != NULL);
				GetKB()->m_pTargetUnits->DeleteNode(tpos); // remove it from the list
				delete pTgtUnit; // delete it from the heap
			}

			// fix the flags that will make a save to KB possible
			pSrcPhrase->m_bNotInKB = FALSE;
			pSrcPhrase->m_bHasKBEntry = FALSE;
			gpApp->m_bSaveToKB = TRUE;

			// put the replacement string into the global translation variable, which with
			// selector value of 1 in the PlacePhraseBox call, will ensure it goes into
			// m_targetPhrase member, and ends up in the created phrase box
			translation = replStr;

			// prepare for phrase box creation
			gpApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			gpApp->m_pActivePile = pPile;
			CCell* pCell = pPile->m_pCell[2]; // we want the 3rd line, for phrase box
			gpApp->m_ptCurBoxLocation = pCell->m_ptTopLeft;

			// place the phrase box
			PlacePhraseBox(pCell,1);

			translation.Empty(); // clear it, no longer needed

			// get a new active pile pointer, the PlacePhraseBox call did a recal of the layout
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			gpApp->m_pTargetBox->m_pActivePile = gpApp->m_pActivePile; // put copy on phrase box
			wxASSERT(gpApp->m_pActivePile != NULL);
			pSrcPhrase->m_bHasKBEntry = FALSE; // ensure StoreText won't crash when
											   // later called

			// save old sequ number in case required for toolbar's Back button - after a
			// Replace, the only safe location is the now current active location
			gnOldSequNum = gpApp->m_nActiveSequNum;

			Invalidate();
			return TRUE;
		}
		else if (!gbIsGlossing &&
			pSrcPhrase->m_bNullSourcePhrase && !pSrcPhrase->m_bRetranslation)
		{
			// we are changing tgt text in a null src phrase which is not in a retranslation
			int nFound = -1;
			int lenOldTgt = 0;
			int lenTgt = 0;
			int nRight;
			wxString left;
			left.Empty();
			wxString right;
			right.Empty();
			if (bIncludePunct)
			{
				lenTgt = tgt.Length(); // the search string's length
				lenOldTgt = oldTgt.Length(); // length of the string in which the search is done
				nFound = oldTgt.Find(tgt);
				wxASSERT(nFound != -1); // must not have failed, since this was the match done
									  // in caller
				left = oldTgt.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgt.Right(nRight);
			}
			else
			{
				lenTgt = tgtNoPunct.Length(); // the search string's length
				lenOldTgt = oldTgtNoPunct.Length(); // length of the string in which the
													   // search is done
				nFound = oldTgtNoPunct.Find(tgtNoPunct);
				wxASSERT(nFound != -1); // must not have failed, since this was the match done
									  // in caller
				left = oldTgtNoPunct.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgtNoPunct.Right(nRight);
			}

			// put the final string into the global translation variable, which with selector
			// value of 1 in the PlacePhraseBox call, will ensure it goes into m_targetPhrase
			// member, and ends up in the created phrase box
			translation = left + replStr + right;

			// prepare for phrase box creation
			gpApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			gpApp->m_pActivePile = pPile;
			CCell* pCell = pPile->m_pCell[2]; // we want the 3rd line, for phrase box
			gpApp->m_ptCurBoxLocation = pCell->m_ptTopLeft;

			// update pSrcPhrase so it shows the new stuff (we can do this because no KB storage
			// is involved)
			wxString adaptionStr = translation;
			RemovePunctuation(pDoc,&adaptionStr,1 /*from tgt*/);
			pSrcPhrase->m_adaption = adaptionStr;
			gpApp->m_targetPhrase = translation;
			MakeLineFourString(pSrcPhrase,gpApp->m_targetPhrase);

			// place the phrase box
			PlacePhraseBox(pCell,1); // selector == 1 inhibits both the internal restore code blocks

			translation.Empty(); // clear it, no longer needed

			// get a new active pile pointer, the PlacePhraseBox call did a recal of the layout
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			gpApp->m_pTargetBox->m_pActivePile = gpApp->m_pActivePile; // put copy on phrase box
			wxASSERT(gpApp->m_pActivePile != NULL);
			pSrcPhrase->m_bHasKBEntry = FALSE;  // ensure its FALSE, since it's a null src phrase

			// save old sequ number in case required for toolbar's Back button - use current
			// location
			gnOldSequNum = gpApp->m_nActiveSequNum;

			Invalidate();
			return TRUE;
		}
		else // normal srcPhrase, or if glossing it could be a null one or retranslation as
			 // well as possibly being just a normal one
		{
			// it's a normal srcPhrase, so go ahead and do the replacement
			int nFound = -1;
			int lenOldTgt = 0;
			int lenTgt = 0;
			int nRight;
			wxString left;
			left.Empty();
			wxString right;
			right.Empty();
			if (bIncludePunct)
			{
				// bIncludePunct is always FALSE for glossing, so this block can never be
				// entered when glossing is ON
				wxASSERT(!gbIsGlossing);
				lenTgt = tgt.Length(); // the search string's length
				lenOldTgt = oldTgt.Length(); // length of the string in which the search is done
				nFound = oldTgt.Find(tgt);
				wxASSERT(nFound != -1); // must not have failed, since this was the match done in
									  // caller
				left = oldTgt.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgt.Right(nRight);
			}
			else
			{
				// no punctuation case; but can be punctuated string if glossing is ON since
				// glossing being ON will always cause this block to be done
				lenTgt = tgtNoPunct.Length(); // the search string's length
				lenOldTgt = oldTgtNoPunct.Length(); // length of the string in which the
													   // search is done
				nFound = oldTgtNoPunct.Find(tgtNoPunct);
				wxASSERT(nFound != -1); // must not have failed, since this was the match done
									  // in caller
				left = oldTgtNoPunct.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgtNoPunct.Right(nRight);
			}

			// put the final string into the temporary store
			finalStr = left + replStr + right;

			// prepare for phrase box creation
			gpApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			gpApp->m_pActivePile = pPile;
			CCell* pCell = pPile->m_pCell[2]; // we want the 3rd line, for phrase box
			gpApp->m_ptCurBoxLocation = pCell->m_ptTopLeft;

			// place the phrase box
			PlacePhraseBox(pCell,2); // selector == 2 means location's KB entry will be removed
									 // or ref count decremented if >1

			// now put the new content in the box
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			pCell = gpApp->m_pActivePile->m_pCell[2]; // we want the 3rd line, for phrase box
			gpApp->m_targetPhrase = finalStr;
			ReDoPhraseBox(pCell); // clobbers pointers, because does a RecalcLayout()

			// get a new active pile pointer, the PlacePhraseBox call did a recalc of the layout
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			gpApp->m_pTargetBox->m_pActivePile = gpApp->m_pActivePile; // put copy on phrase box
			wxASSERT(gpApp->m_pActivePile != NULL);

			// save old sequ number in case required for toolbar's Back button - use current
			// location
			gnOldSequNum = gpApp->m_nActiveSequNum;

			Invalidate();
			return TRUE;
		}
	}
	else // nCount > 1
	{
		// more than one srcPhrase involved, so merge first
		wxASSERT(!gbIsGlossing); // should never get here when glossing is ON
		wxCommandEvent event;
		OnButtonMerge(event);

		if (gbMergeSucceeded)
		{
			// restore the clobbered pointers
			pPile = GetPile(gpApp->m_nActiveSequNum);
			gpApp->m_pActivePile = pPile;
			gpApp->m_pTargetBox->m_pActivePile = pPile;

			// set up the strings in which searching is done, using the globals defined by
			// OnButtonMerge
			oldTgtNoPunct = gOldConcatStrNoPunct;
			oldTgt = gOldConcatStr;

			// it's now a normal single srcPhrase replacement, so go ahead and do it
			int nFound = -1;
			int lenOldTgt = 0;
			int lenTgt = 0;
			int nRight;
			wxString left;
			left.Empty();
			wxString right;
			right.Empty();
			if (bIncludePunct)
			{
				lenTgt = tgt.Length(); // the search string's length
				lenOldTgt = oldTgt.Length(); // length of the string in which the search is done
				nFound = oldTgt.Find(tgt);
				wxASSERT(nFound != -1); // must not have failed, since this was the match done
									  // in caller
				left = oldTgt.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgt.Right(nRight);
			}
			else
			{
				lenTgt = tgtNoPunct.Length(); // the search string's length
				lenOldTgt = oldTgtNoPunct.Length(); // length of the string in which the search
													   // is done
				nFound = oldTgtNoPunct.Find(tgtNoPunct);
				wxASSERT(nFound != -1); // must not have failed, since this was the match done in
									  // caller
				left = oldTgtNoPunct.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgtNoPunct.Right(nRight);
			}

			// put the final string into the temporary store
			finalStr = left + replStr + right;

			// prepare for phrase box creation
			gpApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			gpApp->m_pActivePile = pPile;
			CCell* pCell = pPile->m_pCell[2]; // we want the 3rd line, for phrase box
			gpApp->m_ptCurBoxLocation = pCell->m_ptTopLeft;

			// place the phrase box
			PlacePhraseBox(pCell,2); // selector == 2 means location's KB entry will be removed
									 // or ref count decremented if >1

			// now put the new content in the box
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			pCell = gpApp->m_pActivePile->m_pCell[2]; // we want the 3rd line, for phrase box
			gpApp->m_targetPhrase = finalStr;
			ReDoPhraseBox(pCell); // clobbers pointers, because does a RecalcLayout()

			// get a new active pile pointer, the PlacePhraseBox call did a recalc of the layout
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			gpApp->m_pTargetBox->m_pActivePile = gpApp->m_pActivePile; // put copy on phrase box
			wxASSERT(gpApp->m_pActivePile != NULL);

			// update pSrcPhrase here, rather than waiting for another Find Next button click, so
			// than in the event of the latter, the view reflects the changed m_adaption, etc.
			// members
			wxString adaptionStr = finalStr;
			RemovePunctuation(pDoc,&adaptionStr,1 /*from tgt*/);
			pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
			wxASSERT(pSrcPhrase != NULL);
			pSrcPhrase->m_adaption = adaptionStr;

			// save old sequ number in case required for toolbar's Back button - use current
			// location
			gnOldSequNum = gpApp->m_nActiveSequNum;

		}
		else
		{
			RemoveSelection();
			::wxBell();
		}

		Invalidate();

		// clear the globals
		gbMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
	}
	//return TRUE; // unreachable
}

bool CAdapt_ItView::IsContainedByRetranslation(int nFirstSequNum, int nCount, int& nSequNumFirst,
											   int& nSequNumLast)
// determines if nFirstSequNum up to nFirstSequNum + nCount - 1 all lie within a retranslation;
// if TRUE, then also returns the first and last sequence numbers for the retranslation in the
// last 2 parameters; these parameters are not defined if FALSE is returned
{
	wxASSERT(!gbIsGlossing); // when glossing this should never be called
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	CSourcePhrase* pSrcPhrase;

	SPList::Node* pos = pList->Item(nFirstSequNum);
	wxASSERT(pos != NULL);
	int count = 0;
	bool bFoundEnd = FALSE;
	while(pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL); 
		count++;
		if (pSrcPhrase->m_bEndRetranslation)
			bFoundEnd = TRUE; // next iteration will go out of retranslation, or into a
							  // following one
		if (!pSrcPhrase->m_bRetranslation || (pSrcPhrase->m_bBeginRetranslation && bFoundEnd))
		{
			return FALSE;
		}
		if (count >= nCount)
			break;
	}

	// lies within the retranslation, so get the bounds
	nSequNumFirst = nFirstSequNum;
	int nFirst = nFirstSequNum+1;
	pos = pList->Item(nFirstSequNum);
a:	pSrcPhrase = (CSourcePhrase*)pos->GetData(); 
	pos = pos->GetPrevious();
	if (pSrcPhrase->m_bRetranslation && !pSrcPhrase->m_bEndRetranslation)
	{
		nSequNumFirst = --nFirst;
		goto a;
	}
	nSequNumLast = nFirstSequNum + count - 1;
	int nLast = nFirstSequNum + count - 1;
b:	nLast += 1;
	pos = pList->Item(nLast); 
	pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext();
	if (pSrcPhrase->m_bRetranslation && !pSrcPhrase->m_bBeginRetranslation)
	{
		nSequNumLast = nLast;
		goto b;
	}

	return TRUE;
}

void CAdapt_ItView::OnRetransReport(wxCommandEvent& WXUNUSED(event))
{
	// BEW added 05Jan07 to enable work folder on input to be restored when done
	wxString strSaveCurrentDirectoryFullPath = GetDocument()->GetCurrentDirectory();

	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),_T(""),wxICON_INFORMATION);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc;
	CPhraseBox* pBox;
	CAdapt_ItView* pView;
	pApp->GetBasePointers(pDoc,pView,pBox); // this is 'safe' when no doc is open
	wxString name; // name for the document, to be used in the report

	pApp->m_acceptedFilesList.Clear();
	int answer;

	// only put up the message box if a document is open (and the update handler also
	// disables the command if glossing is on)
	if (gpApp->m_pBundle->m_nStripCount > 0)
	{
		// IDS_RETRANS_REPORT_ADVICE
		answer = wxMessageBox(_("The retranslation report will be based on this open document only.\nTo get a report based on many or all documents,\nclose the document and select this command again.\nDo you want a report only for this document?"),_T(""),wxYES_NO); //answer = AfxMessageBox(IDS_RETRANS_REPORT_ADVICE,MB_YESNO);
		if (!(answer == wxYES))
		{
			// a "Yes" answer is a choice for reporting only for the current document,
			// a "No" answer exits to allow the user to close the document and then
			// the report can be chosen again and it will do all documents
			return;
		}
	}

	// can proceed, so get output filename and put up file dialog
	// make the working directory the "<Project Name>" one
	bool bOK;
	bOK = ::wxSetWorkingDirectory(pApp->m_curProjectPath); // ignore failures
	int len;
	wxString reportFilename,defaultDir;
	if (gpApp->m_pBundle->m_nStripCount > 0)
	{
		wxASSERT(pDoc != NULL);
		reportFilename = pApp->m_curOutputFilename;

		// make a suitable default output filename for the export function
		len = reportFilename.Length();
		reportFilename.Remove(len-4,4); //reportFilename.Delete(len-4,4); // remove the .adt or .xml extension
		name = reportFilename; // use for the document name in the report
		reportFilename += _(" report.txt"); //reportFilename += " report.txt"; // make it a *.txt file type // MFC localization?
	}
	else
	{
		// construct a general default filename, and "name" will be defined in
		// DoRetranslationReport()
		reportFilename = _("retranslation report.txt"); //reportFilename = "retranslation report.txt"; // MFC localization?
		name.Empty();
	}
	// set the default folder to be shown in the dialog (::SetCurrentDirectory does not
	// do it)
	if (pApp->m_retransReportPath.IsEmpty())
	{
		defaultDir = pApp->m_curProjectPath;
	}
	else
	{
		defaultDir = pApp->m_retransReportPath;
	}

	// get a file dialog
	wxString filter;
	filter = _("Adapt It Reports (*.txt)|*txt||"); //IDS_REPORT_FILTER
	wxFileDialog fileDlg(
		(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
		_("Filename For Retranslation Report"),
		defaultDir,
		reportFilename,
		filter,
		wxSAVE | wxOVERWRITE_PROMPT); // | wxHIDE_READONLY); wxHIDE_READONLY deprecated in 2.6 - the checkbox is never shown
	fileDlg.Centre();

	if (fileDlg.ShowModal() != wxID_OK)
	{
		int length = pApp->m_targetPhrase.Length();
		gnStart = length;
		gnEnd = length;
		pApp->m_pTargetBox->SetSelection(length,length);
		pApp->m_pTargetBox->SetFocus();
		// whm added 05Jan07 to restore the former current working directory for safety sake
		// to what it was on entry, since there was a wxSetWorkingDirectory call made above
		// (MFC version did not add the line below)
		bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
		return; // user cancelled
	}

	// update m_retransReportPath
	wxString exportPath = fileDlg.GetPath();
	wxString fname = fileDlg.GetFilename(); 
	int nameLen = fname.Length();
	int pathLen = exportPath.Length();
	wxASSERT(nameLen > 0 && pathLen > 0);
	pApp->m_retransReportPath = exportPath.Left(pathLen - nameLen - 1);

	// get the user's desired path
	wxString reportPath = fileDlg.GetPath();

	wxFile f; //CStdioFile f;
	if( !f.Open( reportPath, wxFile::write)) 
	{
	   #ifdef __WXDEBUG__
		  wxLogError(_("Unable to open report file.\n")); //afxDump << _T("Unable to open report file") << _T("\n");
		  wxMessageBox(_("Unable to open report file."),_T(""), wxICON_WARNING);
	   #endif
		// whm added 05Jan07 to restore the former current working directory for safety sake
		// to what it was on entry, since there was a wxSetWorkingDirectory call made above
		// (MFC version did not add the line below)
		bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
	   return; //exit( 1 ); // whm changed to return since it is not a fatal error
	}

	// write a file heading
	wxString header1,header2;
	header1.Empty();
	header2.Empty();
	// header.Format(IDS_RETRANS_HEADER, reportPath);
	// wx note: Since we supply the cross-platform eol chars separately, break header into two parts
	header1 = _("Retranslation Report");
	header2 = header2.Format(_("File Path: %s"), reportPath.c_str());

#ifndef _UNICODE
	f.Write(header1);
	f.Write(gpApp->m_eolStr);
	f.Write(header2);
	f.Write(gpApp->m_eolStr);
	f.Write(gpApp->m_eolStr);
#else
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,header1); // use UTF-8 encoding
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,gpApp->m_eolStr); // use UTF-8 encoding
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,header2); // use UTF-8 encoding
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,gpApp->m_eolStr); // use UTF-8 encoding
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,gpApp->m_eolStr); // use UTF-8 encoding
#endif

	// save entry state (only necessary if entry state had book mode on)
	BookNamePair* pSave_BookNamePair = pApp->m_pCurrBookNamePair;
	int nSave_BookIndex = pApp->m_nBookIndex;
	wxString save_bibleBooksFolderPath = pApp->m_bibleBooksFolderPath;

	// output report data
	wxArrayString* pFileList = &pApp->m_acceptedFilesList;
	if (gpApp->m_pBundle->m_nStripCount > 0)
	{
		// a document is open, so only do the report for this current document
		wxASSERT(pFileList->IsEmpty()); // must be empty, DoRetranslationReport uses this as a flag

		DoRetranslationReport(pApp,pDoc,name,pFileList,pApp->m_pSourcePhrases,&f);
	}
	else
	{
		// no document is open, so enumerate all the doc files, and do a report
		// based on those the user chooses (remember that in our version of this SDI app, when
		// no document is open, in fact we have an open unnamed empty document, so pDoc is still
		// valid)
		// BEW modified 06Sept05 for support of Bible book folders in the Adaptations folder
		wxASSERT(pDoc != NULL);

		// determine whether or not there are book folders present
		// whm note: AreBookFoldersCreated() has the side effect of changing the current work directory
		// to the passed in gpApp->m_curAdaptionsPath.
		gbHasBookFolders = gpApp->AreBookFoldersCreated(gpApp->m_curAdaptionsPath);

		// do the Adaptations folder's files first
		// whm note: EnumerateDocFiles() has the side effect of changing the current work directory
		// to the passed in pApp->m_curAdaptionsPath.
		bool bOK = pApp->EnumerateDocFiles(pDoc, pApp->m_curAdaptionsPath);
		if (bOK)
		{
			// bale out if there are no files to process, and no book folders too
			if (pApp->m_acceptedFilesList.GetCount() == 0 && !gbHasBookFolders)
			{
				// nothing to work on, so abort the operation
				// IDS_NO_DOCUMENTS_YET
				wxMessageBox(_("Sorry, there are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."),_T(""),wxICON_EXCLAMATION);
				// whm added 05Jan07 to restore the former current working directory for safety sake
				// to what it was on entry, since the EnumerateDocFiles call made above changes the
				// current working dir to the Adaptations folder (MFC version did not add the line below)
				bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
				return;
			}
			// because of prior EnumerateDocFiles call, pFileList will have
			// document filenames in it
			DoRetranslationReport(pApp,pDoc,name,pFileList,pApp->m_pSourcePhrases,&f);
		}

		// now do the book folders, if there are any
		if (gbHasBookFolders)
		{
			// process this block only if the project's Adaptations folder contains the set of
			// Bible book folders - these could contain documents, and some or all could be empty;
			// NOTE: the code below is smart enough to ignore any user-created folders which are sisters
			// of the Bible book folders for which the Adaptations folder is the common parent folder
			int nCount;
			wxDir finder;
			bool bOK = (::wxSetWorkingDirectory(gpApp->m_curAdaptionsPath) && finder.Open(gpApp->m_curAdaptionsPath)); // wxDir must call .Open() before enumerating files!
			if (!bOK)
			{
				// highly unlikely, so English will do
				wxString s1, s2, s3;
				s1 = _T(
				"Failed to set the current directory to the Adaptations folder in OnRetransReport function, ");
				s2 = _T("processing book folders, so the book folder document files contribute nothing.");
				s3 = s3.Format(_T("%s%s"),s1.c_str(),s2.c_str());
				wxMessageBox(s3,_T(""), wxICON_EXCLAMATION);
				// whm added 05Jan07 to restore the former current working directory for safety sake
				// to what it was on entry, since the wxSetWorkingDirectory call made above changes the
				// current working dir to the Adaptations folder (MFC version did not add the line below)
				bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
				return;
			}
			else
			{
				// whm note: in GetFirst below, wxDIR_FILES | wxDIR_DIRS flag finds files or directories, but not . or .. or hidden files
				wxString str = _T("");
				bool bWorking = finder.GetFirst(&str,wxEmptyString,wxDIR_FILES | wxDIR_DIRS); //bool bWorking = finder.FindFile(_T("*.*"));
				while (bWorking)
				{
					bWorking = finder.GetNext(&str);

					// whm note: in the MFC version's "if (finder.IsDirectory())" test below, the finder continues
					// to use the directory path that was current when the inital finder.FindFile call was made
					// above, even though the EnumerateDocFiles() call below changes the current working dir for
					// each of the book folder directories it processes. In the wx version the finder.Exists(str)
					// call uses whatever the current working directory is and checks for a sub-directory "str"
					// below that - a difference we must account for here in the wx version.
					// whm Note: The Exists() method of wxDIR used below returns TRUE if the passed name IS a directory.
					if (finder.Exists(gpApp->m_curAdaptionsPath + gpApp->PathSeparator + str))
					{
						// User-defined folders can be in the Adaptations folder without making the
						// app confused as to whether or not Bible Book folders are present or not

						// we have found a folder, check if it matches one of those in
						// the array of BookNamePair structs (using the seeName member)
						if (gpApp->IsDirectoryWithin(str,gpApp->m_pBibleBooks))
						{
							// we have found a folder name which belongs to the set of
							// Bible book folders, so construct the required path to the
							// folder and enumerate is documents then call
							// DoTransformationsToGlosses() to process any documents within
							wxString folderPath = gpApp->m_curAdaptionsPath;
							folderPath += pApp->PathSeparator + str; 

							// clear the string list of directory names & then enumerate the
							// directory's file contents; the EnumerateDocFiles() call sets the
							// current directory to the one given by folderPath (ie. to a book folder)
							// so after the DoKBRestore() call, which relies on that directory being
							// current, we must call ::SetCurrentDirectory(m_curAdaptionsPath) again
							// so that this outer look which iterates over directories continues correctly
							pFileList->Clear();
							// whm note: EnumerateDocFiles() has the side effect of changing the current work directory
							// to the passed in folderPath.
							bOK = gpApp->EnumerateDocFiles(pDoc, folderPath, TRUE); // TRUE == suppress dialog
							if (!bOK)
							{
								// don't process any directory which gives an error, but continue looping --
								// this is a highly unlikely error, so an English message will do
								wxString errStr;
								errStr = errStr.Format(_T("Error returned by EnumerateDocFiles in Book Folder loop, directory %s skipped."),
									folderPath.c_str());
								wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
								continue;
							}
							nCount = pFileList->GetCount();
							if (nCount == 0)
							{
								// no documents to work on in this folder, so iterate
								continue;
							}

							// There are files to be processed. TRUE parameter suppresses the statistics dialog.
							DoRetranslationReport(pApp,pDoc,name,pFileList,pApp->m_pSourcePhrases,&f);
							bOK = ::wxSetWorkingDirectory(gpApp->m_curAdaptionsPath); // restore parent folder as current
							wxASSERT(bOK);
						}
						else
						{
							continue;
						}
					}
					else
					{
						// its a file, so ignore it
						continue;
					}
				} // end loop for FindFile() scanning all possible files in folder
			}  // end block for bOK == TRUE
		} // end block for test for gbHasBookFolders yielding TRUE

		// clean up the list before returning
		pApp->m_acceptedFilesList.Clear();
	}

	// close the file
	f.Close();

	// restore the former book mode parameters (even if book mode was not on on entry)
	pApp->m_pCurrBookNamePair = pSave_BookNamePair;
	pApp->m_nBookIndex = nSave_BookIndex;
	pApp->m_bibleBooksFolderPath = save_bibleBooksFolderPath;
	// now, if the user opens the Document tab of the Start Working wizard, and book
	// mode is on, then at least the path and index and book name are all consistent

	// make sure that book mode is off if there is no valid folder path (if there are
	// docs in book folders, they will store a T (ie. TRUE) for the book mode saved
	// value and so when opened they will turn book mode back on, but if we started
	// with book mode off, then m_bibleBooksFolderPath would be empty, and if we attempt
	// to open the Document tab of the wizard after finishing the report, then we'd
	// get a crash - book mode would be on, but the folder path undefined, -> crash
	// when OnSetActive() of the wizard is called - so the code below ensures this
	// can't happen)
	if (pApp->m_bBookMode)
	{
		if (pApp->m_bibleBooksFolderPath.IsEmpty())
		{
			// set safe defaults for when mode is off
			pApp->m_bBookMode = FALSE;
			pApp->m_nBookIndex = -1;
			pApp->m_nDefaultBookIndex = 39;
			pApp->m_nLastBookIndex = 39;
		}
	}

	int length = pApp->m_targetPhrase.Length();
	gnStart = length;
	gnEnd = length;
	if (pApp->m_pTargetBox != NULL && pApp->m_pTargetBox->IsShown())
	{
		pApp->m_pTargetBox->SetSelection(length,length);
		pApp->m_pTargetBox->SetFocus();
	}
	// BEW added 05Jan07 to restore the former current working directory
	// to what it was on entry
	bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
}

void CAdapt_ItView::DoRetranslationReport(CAdapt_ItApp* pApp, CAdapt_ItDoc* pDoc, wxString& name,
									wxArrayString* pFileList, SPList* pList, wxFile* pFile)
{
	if (pFileList->IsEmpty())
	{

		// use the open document's pList of srcPhrase pointers
		DoOneDocReport(name,pList,pFile); 
	}
	else
	{
		// no document is open, so pList will be empty, so we have to iterate over files in
		// pFileList
		wxASSERT(pList->IsEmpty());
		wxASSERT(!pFileList->IsEmpty());

		// iterate over the files (borrow code from DoConsistencyCheck)
		int nCount = pFileList->GetCount();
		if (nCount <= 0)
		{
			// something is real wrong, but this should never happen so an English message
			// will suffice
			wxString error;
			error = error.Format(_T(
				"Error, the file count was found to be %d, so the command was aborted."),nCount);
			wxMessageBox(error);
			return;
		}

		// lock view window updates till done
		pApp->GetMainFrame()->canvas->Freeze(); //LockWindowUpdate();

		// iterate over the document files
		SPList* pPhrases;
		for (int i=0; i < nCount; i++)
		{
			wxString newName = pFileList->Item(i);
			wxASSERT(!newName.IsEmpty());

			// make a suitable name for the document, for the report
			wxString indexingName = newName;
			int len = indexingName.Length();
			indexingName.Remove(len-4,4); // remove the .adt or .xml extension

			// open the document
			bool bOK;
			bOK = pDoc->OnOpenDocument(newName);
			pDoc->SetFilename(newName,TRUE);

			int nTotal = pApp->m_pSourcePhrases->GetCount();
			if (nTotal == 0)
			{
				wxString str;
				str = str.Format(_T("Bad file:  %s"),newName.c_str());
				wxMessageBox(str,_T(""),wxICON_WARNING);
				wxExit(); //AfxAbort();
			}

			// get a local pointer to the list of source phrases
			pPhrases = pApp->m_pSourcePhrases;

			// use the now open document's pList of srcPhrase pointers, build the part of
			// the report which pertains to this document
			DoOneDocReport(indexingName,pPhrases,pFile); 

			// remove the document
			if (!pPhrases->IsEmpty())
			{
				ClobberDocument();

				// delete the buffer containing the filed-in source text
				if (pApp->m_pBuffer != NULL)
				{
					delete pApp->m_pBuffer;
					pApp->m_pBuffer = NULL;
				}
			}
		}

		// allow the view to respond again to updates
		pApp->GetMainFrame()->canvas->Thaw(); //UnlockWindowUpdate();
	}
}

void CAdapt_ItView::DoOneDocReport(wxString& name,
								   //int iteration, int nCount, wxProgressDialog* pProg,
								   SPList* pList, wxFile* pFile)
{
	wxASSERT(!pList->IsEmpty());
	wxString oldText;
	oldText.Empty();
	wxString newText;
	newText.Empty();
	wxString endText = wxTextFile::GetEOL();
	wxString chAndVerse;
	chAndVerse.Empty();
	wxString indexText;
	indexText.Empty();
	wxString prevIndexText;
	prevIndexText.Empty();
	CSourcePhrase* pSrcPhrase = NULL;
	int count = 0;

	// initialize the progress indicator window
	int nTotal;
	nTotal = pList->GetCount();
	wxASSERT(nTotal > 0);

#ifdef __WXMSW__
	wxString progMsg = _("%s  - %d of %d Total words and phrases");
	wxString msgDisplayed = progMsg.Format(progMsg,name.c_str(),1,nTotal);
	wxProgressDialog progDlg(_("Retranslation Report"),
                    msgDisplayed,
                    nTotal,    // range
                    gpApp->GetMainFrame(),   // parent
                    //wxPD_CAN_ABORT |
                    //wxPD_CAN_SKIP |
                    wxPD_APP_MODAL |
                    // wxPD_AUTO_HIDE | -- try this as well
                    wxPD_ELAPSED_TIME |
                    wxPD_ESTIMATED_TIME |
                    wxPD_REMAINING_TIME
                    | wxPD_SMOOTH // - makes indeterminate mode bar on WinXP very small
                    );
#else
	// wxProgressDialog tends to hang on wxGTK so I'll just use the simpler CWaitDlg
	// notification on wxGTK and wxMAC
	// put up a Wait dialog - otherwise nothing visible will happen until the operation is done
	CWaitDlg waitDlg(gpApp->GetMainFrame());
	// indicate we want the reading file wait message
	waitDlg.m_nWaitMsgNum = 5;	// 5 hides the static leaving only "Please wait..." in title bar
	waitDlg.Centre();
	waitDlg.Show(TRUE);
	waitDlg.Update();
	// the wait dialog is automatically destroyed when it goes out of scope below.
#endif

	// compose the output data & write it out, phrase by phrase
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	bool bStartRetrans = TRUE;
	bool bJustEnded = FALSE;
	bool bStartOver = FALSE;
	int counter = 0; // for progress indicator
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != 0);
		counter++;

		if (!pSrcPhrase->m_chapterVerse.IsEmpty())
		{
			prevIndexText = indexText; // keep old ch & verse, in case a retrans is at previous
									   // verse's end
			indexText = name + _T(" ") + pSrcPhrase->m_chapterVerse + endText;
		}

b:		bStartOver = FALSE;
		if (pSrcPhrase->m_bRetranslation)
		{
			if (bStartRetrans || pSrcPhrase->m_bBeginRetranslation)
			{
				if (oldText.IsEmpty())
				{
					// we've just written out an entry, so we are ready to begin a new one
					oldText = pSrcPhrase->m_srcPhrase;
					newText = pSrcPhrase->m_targetStr;
					bStartRetrans = FALSE;
					count++;
				}
				else
				{
					// the current entry is not yet written out, (probably m_bBeginRe... is TRUE)
					// because we are at start of a consecutive retranslation
					bJustEnded = TRUE;
					bStartOver = TRUE; // so we can start a new entry without iterating the loop
					goto a;
				}
			}
			else
			{
				if (!pSrcPhrase->m_bNullSourcePhrase)
				{
					oldText += _T(" ") + pSrcPhrase->m_srcPhrase;
				}
				if (!pSrcPhrase->m_targetStr.IsEmpty())
				{
					newText += _T(" ") + pSrcPhrase->m_targetStr;
				}
			}
			bJustEnded = TRUE;

			// if we are at the end of the file, we have to force the writing of the current one
			// before we exit the loop
			if (counter == (int)pList->GetCount())
				goto a;
		}
		else
		{
			if (bJustEnded)
			{
a:				oldText += endText;
				newText += endText + endText; // we want a blank line

				// write out the entry to the file
				if (pSrcPhrase->m_chapterVerse.IsEmpty())
				{
					// within a verse, use current indexText
#ifndef _UNICODE
					pFile->Write(indexText);
#else
					gpApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,indexText); // use UTF-8
#endif
				}
				else
				{
					// retranslation goes to end of last verse, use previous indexText
#ifndef _UNICODE
					pFile->Write(prevIndexText); 
#else
					gpApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,prevIndexText); // use UTF-8
#endif
				}
#ifndef _UNICODE
				pFile->Write(oldText);

#else // _UNICODE version
				// use UTF-8 encoding
				gpApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,oldText);
#endif
			}
			oldText.Empty();
			newText.Empty();
			bJustEnded = FALSE;
			bStartRetrans = TRUE; // get ready for start of next one encountered
		}

		// whm note: Yield operations tend to hang in wxGTK, so I'm going to just use the
		// wxBusyInfo message and not worry about the message being repainted if covered
		// and uncovered by another window.
#ifdef __WXMSW__
		// update the progress bar
		if (counter % 1000 == 0) 
		{
			msgDisplayed = progMsg.Format(progMsg,name.c_str(),counter,nTotal);
			progDlg.Update(counter,msgDisplayed);
		}
#endif

		if (bStartOver)
			goto b;
	}

	if (count == 0)
	{
		oldText.Empty();
		// IDS_NO_RETRANS_IN_DOC
		oldText = oldText.Format(_("***  There were no retranslations in the %s document. ***"),name.c_str());
		oldText += endText + endText;
#ifndef _UNICODE
		pFile->Write(oldText); //pFile->WriteString(oldText);
#else
		gpApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,oldText); // use UTF-8
#endif
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// This handler disables the "Retranslation Report..." item in the Tools menu if Vertical Editing
/// is in progress, or if the application is in glossing mode, or if the regular KB is not in a ready 
/// state. Otherwise it enables the "Retranslation Report..." item on the Tools menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateRetransReport(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT( pApp != NULL);

	if (!gbIsGlossing && pApp->m_bKBReady && pApp->m_pKB != NULL)
	{
		if (gbIsGlossing)
			event.Enable(FALSE); // disable if glossing is ON
		else
			event.Enable(TRUE); // enable, whether doc open or not; glossing OFF
	}
	else
	{
		event.Enable(FALSE); // disable if not got an open project
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Layout Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// This handler always enables the "Layout Window Right To Left" (or "Layout Window Left To Right") 
/// item in the Layout menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAlignment(wxUpdateUIEvent& event)
{
	event.Enable(TRUE); // always enabled
}

void CAdapt_ItView::OnAlignment(wxCommandEvent& WXUNUSED(event))
{
	// don't permit a CTRL + 1 accidental keycombo press to flip the layout
	// if we are running the regular app
	if (sizeof(wxChar) == 1)
	{
		// we are running in the regular app, so bale out without doing anything
		return;
	}

	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pLayoutMenuAlignment = pMenuBar->FindItem(ID_ALIGNMENT);
	wxASSERT(pLayoutMenuAlignment != NULL);
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	// toggle the setting & update the display accordingly
	wxString menuItem;
	if (pApp->m_bRTL_Layout)
	{
		// we have an RTL layout and user has just chosen LTR layout
		pApp->m_bRTL_Layout = FALSE; // toggle
		gbRTL_Layout = FALSE; // do the global too

		// change text of the menu item
		//IDS_RTL_LAYOUT
		pLayoutMenuAlignment->SetText(_("Layout Window Right To Left\tCtrl-1"));
	}
	else
	{
		// we have an LTR layout and user has just chosen RTL layout
		pApp->m_bRTL_Layout = TRUE; // toggle
		gbRTL_Layout = TRUE; // do the global too

		// change text of the menu item
		//IDS_LTR_LAYOUT
		pLayoutMenuAlignment->SetText(_("Layout Window Left To Right\tCtrl-1"));
	}

	// redraw everything -- RecalcLayout uses the m_bRTL_LAYOUT flag in the CreateStrip() function
	RedrawEverything(pApp->m_nActiveSequNum);

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::AdjustAlignmentMenu(bool bRTL,bool bLTR)
// use this function when user changes, or potentially changes, the RTL checkboxes in
// either the wizard, or the preferences fonts page; if both source and target checkboxes are off
// then we silently ensure the layout is switched to LTR, and if both are on, then we silently
// ensure the layout will appear as RTL. The user can subsequently override the auto setting with
// the Layout menu if he chooses.
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxMenuItem * pLayoutMenuAlignment = pMenuBar->FindItem(ID_ALIGNMENT);
	wxASSERT(pLayoutMenuAlignment != NULL);

	// adjust the menu item to fit with the flag values
	wxString menuItem;
	if (bRTL == TRUE && bLTR == FALSE)
	{
		// we should have an RTL layout so set up accordingly
		pApp->m_bRTL_Layout = TRUE;
		gbRTL_Layout = TRUE; // do the global too

		// change text of the menu item ready for next time user accesses it
		menuItem = _("Layout Window Left To Right\tCtrl-1"); //menuItem.Format(IDS_LTR_LAYOUT);
		pLayoutMenuAlignment->SetText(menuItem);
	}
	else
	{
		if (bRTL == FALSE && bLTR == TRUE)
		{
			// we should have an LTR layout so do it
			pApp->m_bRTL_Layout = FALSE;
			gbRTL_Layout = FALSE; // do the global too

			// change text of the menu item ready for next time user accesses it
			menuItem = _("Layout Window Right To Left\tCtrl-1"); //IDS_RTL_LAYOUT
			pLayoutMenuAlignment->SetText(menuItem);
		}
		else
		{
			// do nothing if we have a mixed reading direction situation
			;
		}
	}
}

// BEW changed 08Dec06, as Bob's encoding checking code
// was unreliable, so from now on always force the
// conversion, and remove the Export....As UTF-8 command
//#ifdef _UNICODE
//
//void CAdapt_ItView::OnUpdateExportTgtTextAsUTF8(wxUpdateUIEvent& event)
//{
//	if (gpApp->m_pSourcePhrases->GetCount() > 0)
//		event.Enable(TRUE);
//	else
//		event.Enable(FALSE);
//}
//
//void CAdapt_ItView::OnExportTgtTextAsUTF8(wxCommandEvent& event)
//{
//	bool bExportTarget = TRUE;
//	bool bForceUTF8Conversion = TRUE;
//	DoExportSrcOrTgt(bExportTarget,bForceUTF8Conversion);
//}
//
//#endif

void CAdapt_ItView::OnFileExport(wxCommandEvent& WXUNUSED(event))
{
	bool bExportTarget = TRUE;
	bool bForceUTF8Conversion = TRUE; // BEW changed 08Dec06, as Bob's encoding checking code
									  // was unreliable, so from now on always force the
									  // conversion, and remove the Export....As UTF-8 command
	DoExportSrcOrTgt(bExportTarget,bForceUTF8Conversion);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If Vertical Editing is in progress, or if the application is in glossing mode this handler 
/// disables the "Export Translation Text..." item in the File menu, otherwise it enables the 
/// "Export Translation Text..." item on the File menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExport(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() > 0)
	{
		if (gbIsGlossing)
			event.Enable(FALSE); // don't allow target text export when glossing
		else
			event.Enable(TRUE); // not glossing, so allow target text export
	}
	else
		event.Enable(FALSE); // nothing to export since doc is empty
}

bool CAdapt_ItView::IsUnstructuredData(SPList* pList)
{
	// the markers below can just have terminating space, because we call the
	// function on marker strings which have been normalized (ie. newlines
	// replaced by spaces)
	wxString s1 = gSFescapechar;
	wxString verseMkr = s1 + _T("v ");
	wxString verseNumberMkr = s1 + _T("vn ");
	wxString verseTextMkr = s1 + _T("vt ");
	wxString idMkr = s1 + _T("id ");
	wxString chapterMkr = s1 + _T("c ");

	if (pList->GetCount() == 0)
		return TRUE; // certainly data is unstructured, in fact it doesn't exist!
	SPList::Node* posx = pList->GetFirst();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)posx->GetData();
	wxASSERT(pSrcPhrase);
	wxString markers = pSrcPhrase->m_markers;
	int nFound = -1;
	nFound = markers.Find(idMkr);
	if (nFound >= 0)
		return FALSE; // it's structured data because it has an \id line; that would only be
					  // there if the \v and other markers were too - at least that's what we
					  // will assume
	SPList::Node* pos = pList->GetFirst(); 
	wxASSERT(pos);
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase);
		markers = pSrcPhrase->m_markers;
		if (!markers.IsEmpty())
		{
			nFound = -1;
			nFound = markers.Find(verseMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(verseNumberMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(verseTextMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(chapterMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data

			// BEW added 10Apr06 to agree with similar changes in IsUnstructuredPlainText()
			// in the Adapt_ItDoc.cpp file (BEW 18April06, don't include \p here, since it gets
			//  temporarily inserted into a non-SFM file, so detecting it would give wrong result!)
			nFound = -1;
			nFound = markers.Find(s1 + _T("s "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("f "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q1 "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q2 "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q3 "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("x "));
			if (nFound >= 0)
				return FALSE; // it's structured data
		}
	}
	return TRUE; // it's unstructured data
}

//void CAdapt_ItView::OnSize() // implemented in CMainFrame()

void CAdapt_ItView::OnSize(wxSizeEvent& event)
{
	// wx note: event.Skip() must be called here in order to pass the size event on to be handled
	// by the CMainFrame::OnSize() method.
	event.Skip(); //CScrollView::OnSize(nType, cx, cy);

	// BEW added 05Mar06: Bill Martin reported (email 3 March) that if user is in free translation mode,
	// and uses either the Shorten of Lengthen buttons (these set gbSuppressSetup to TRUE in the beginning
	// of their handlers, to suppress resetting up of the section for the change in the layout), and then
	// he resizes the window, the app will crash (invalid pile pointer usually). The easiest solution is
	// just to allow the section to be reset - this loses the effect of the shortening or lengthening, but
	// that can easily be done again by hitting the relevant button(s) after the resized layout is redrawn.
	if (gpApp->m_bFreeTranslationMode)
	{
		gbSuppressSetup = FALSE;
	}

	// need to initiate a recalc of the layout with new m_docSize value, since strip-wrap is on
	RedrawEverything(gpApp->m_nActiveSequNum);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Stop Selection At Boundaries"
/// toolbar item and returns immediately: The application is in Free Translation mode, in glossing
/// mode, is showing only the target language text, the active pile is NULL, or there are no source 
/// phrases in the m_pSourcePhrases list.
/// Otherwise, it enables the toolbar button if the m_curIndex represents a valid location.
/// Note: The "Stop Selection At Boundaries" toolbar button is the opposite state toggle of the
/// "Ignore Boundaries" toolbar button.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRespectBdry(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_endIndex <= (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Ignore Boundaries"
/// toolbar item and returns immediately: The application is in Free Translation mode, in glossing
/// mode, is showing only the target language text, the active pile is NULL, or there are no source 
/// phrases in the m_pSourcePhrases list.
/// Otherwise, it enables the toolbar button if the m_curIndex represents a valid location.
/// Note: The "Ignore Boundaries" toolbar button is the opposite state toggle of the
/// "Stop Selection At Boundaries" toolbar button.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonIgnoreBdry(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_endIndex <= (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_BUTTON_RESPECTING_BDRY
///                         bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button associated
/// with the ID_BUTTON_RESPECTING_BDRY bitmap image (road with fence across it). 
/// Note: The Button image depicts what the current state of boundary respecting/ignoring is, but the
/// tooltip and help text describe what clicking the button will accomplish. 
/// If m_bRespectBoundaries is TRUE, this handler insures that the ID_BUTTON_IGNORING_BDRY 
/// bitmap image is displayed in the Toolbar, and changes m_bRespectBoundaries to FALSE. The
/// "Ignoring Boundaries" button (witn ID_BUTTON_IGNORING_BDRY image having a road ahead with no fence 
/// across it) is displayed on the toolBar after this handler finishes because it shows the user what 
/// state the respect/ignore boundaries functionality would be if the user were to press that toolbar 
/// button, i.e., the opposite of the current state.
/// Note: The "Respecting Boundaries" toolbar button (having a fence across the road) is the opposite 
/// state toggle of the "Ignoring Boundaries" toolbar button . 
/// See also OnButtonFromIgnoringBdryToRespectingBdry().
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromRespectingBdryToIgnoringBdry(wxCommandEvent& WXUNUSED(event))
{
	// This handler was called OnButtonRespectBdry() in the MFC version. Since it is a toggle button
	// which changes its appearance I've changed the name of the handler and its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_IGNORING_BDRY); // toolPos should be 18
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_RESPECTING_BDRY);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (pApp->m_bRespectBoundaries)
	{
		// The app is currently respecting boundaries. The user wants to switch from respecting
		// to ignoring them. This is effected by setting m_bRespectBoundaries to FALSE. 
		pApp->m_bRespectBoundaries = FALSE;
		// Now we must change the appearance of the toggle button in the toolbar so that its appearance
		// switches from the respecting image to the ignoring image. We do this by inserting the
		// ID_BUTTON_IGNORING_BDRY button into position on the toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
			// Note: In InsertTool, 1st parameter is position of button, zero based, count includes spacers
			// In AIToolBarBitmapsToggledFunc parameter is index of bitmap, zero based (no spacers in count)
			pToolBar->InsertTool(toolPos, ID_BUTTON_IGNORING_BDRY, _T(""),
				AIToolBarBitmapsToggledFunc( 0 ), wxNullBitmap,
				wxITEM_CHECK,
				_("Stop Selection At Boundaries"),
				_("Respect boundaries when selecting"));
			// whm Note: Now, the ignoring bdry button is showing on the toolbar. Remember: The tooltip
			// and help text tell what clicking on this hiding button would do, i.e., Respect Boundaries.
			// must call Realize() after adding a new button
			pToolBar->Realize();
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_BUTTON_IGNORING_BDRY
///                         bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button associated
/// with the ID_BUTTON_IGNORING_BDRY bitmap image (road with no fence across it). 
/// Note: The Button image depicts what the current state of boundary respecting/ignoring is, but the
/// tooltip and help text describe what clicking the button will accomplish. 
/// If m_bRespectBoundaries is FALSE, this handler insures that the ID_BUTTON_RESPECTING_BDRY 
/// bitmap image is displayed in the Toolbar, and changes m_bRespectBoundaries to TRUE. The
/// "Respecting Boundaries" button (witn ID_BUTTON_RESPECTING_BDRY image having a fence across the road) is 
/// displayed on the toolBar after this handler finishes because it shows the user what state the 
/// respect/ignore boundaries functionality would be if the user were to press that toolbar button, i.e., 
/// the opposite of the current state.
/// Note: The "Ignoring Boundaries" toolbar button (road ahead with no fence across it) is the opposite 
/// state toggle of the "Respecting Boundaries" toolbar button . 
/// See also OnButtonFromRespectingBdryToIgnoringBdry().
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromIgnoringBdryToRespectingBdry(wxCommandEvent& WXUNUSED(event))
{
	// This handler was called OnButtonIgnoreBdry() in the MFC version. Since it is a toggle button
	// which changes its appearance I've changed the name of the handler and its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// user or the app wants to restore respect for boundarires, fix accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_IGNORING_BDRY); // toolPos should be 18
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_RESPECTING_BDRY);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (!pApp->m_bRespectBoundaries)
	{
		// The app is currently ingoring boundaries. The user wants to switch from ignoring
		// to respecting them. This is effected by setting m_bRespectBoundaries to TRUE. 
		pApp->m_bRespectBoundaries = TRUE;
		// Now we must change the appearance of the toggle button in the toolbar so that its appearance
		// switches from the ignoring image to the respecting image. We do this by inserting the
		// ID_BUTTON_RESPECTING_BDRY button into position on the toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if(tbDeleted)
		{
			// Note: In InsertTool, 1st parameter is position of button, zero based, count includes spacers
			// In AIToolBarBitmapsUnToggledFunc parameter is index of bitmap, zero based (no spacers in count)
			pToolBar->InsertTool(toolPos, ID_BUTTON_RESPECTING_BDRY, _T(""),
				AIToolBarBitmapsUnToggledFunc( 9 ), wxNullBitmap,
				wxITEM_CHECK,
				_("Ignore Boundaries"),
				_("Ignore boundaries when making selections"));
			// whm Note: Now, the respecting bdry button is showing on the toolbar. Remember: The tooltip
			// and help text tell what clicking on this hiding button would do, i.e., Ignore Boundaries.
			// must call Realize() after adding a new button
			pToolBar->Realize();
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Show Punctuation"
/// toolbar item and returns immediately: The application is in Free Translation mode, in glossing
/// mode, the active pile is NULL, or there are no source phrases in the m_pSourcePhrases list.
/// Otherwise, it enables the toolbar button if the m_curIndex represents a valid location.
/// Note: The "Show Punctuation" toolbar button is the opposite state toggle of the
/// "Hide Punctuation" toolbar button.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonShowPunct(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
    if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_endIndex <= (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_endIndex > 0)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_BUTTON_SHOWING_PUNCT
///                         bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button associated
/// with the ID_BUTTON_SHOWING_PUNCT bitmap image. 
/// Note: The Button image depicts what the current state of punctuation showing/hiding is, but the
/// tooltip and help text describe what clicking the button will accomplish. 
/// If m_bHidePunctuation is FALSE, this handler insures that the ID_BUTTON_HIDING_PUNCT 
/// bitmap image is displayed in the Toolbar, and changes m_bHidePunctuation to TRUE. The
/// "Hiding Punctuation" button (witn ID_BUTTON_HIDING_PUNCT image having curtains closed on stage) 
/// is displayed on the toolBar after this handler finishes because it shows 
/// the user what state the show/hide punctuation functionality would be if the user were to press that 
/// toolbar button, i.e., the opposite of the current state.
/// Note: The "Showing Punctuation" toolbar button (curtains drawn back revealing an exclamation point) 
/// is the opposite state toggle of the "Hiding Punctuation" toolbar button . 
/// See also OnButtonFromHidingToShowingPunct().
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromShowingToHidingPunct(wxCommandEvent& WXUNUSED(event))
{
	// This handler was called OnButtonShowPunct() in the MFC version. Since it is a toggle button
	// which changes its appearance I've changed the name of the handler and its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_HIDING_PUNCT); // toolPos should be 19
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_SHOWING_PUNCT); // toolPos should be 19
	wxASSERT(toolPos != wxNOT_FOUND);
	if (!pApp->m_bHidePunctuation)
	{
		// The app is currently showing (not hiding) punctuation. The user wants to switch from showing
		// to hiding. This is effected by setting m_bHidePunctuation to TRUE. 
		pApp->m_bHidePunctuation = TRUE;
		// Now we must change the appearance of the toggle button in the toolbar so that its appearance
		// switches from the showing image to the hiding image. We do this by inserting the
		// ID_BUTTON_HIDING_PUNCT button into position on the toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
			// Note: In InsertTool, 1st parameter is position of button, zero based, count includes spacers
			// In AIToolBarBitmapsToggledFunc parameter is index of bitmap, zero based (no spacers in count)
			pToolBar->InsertTool(toolPos, ID_BUTTON_HIDING_PUNCT, _T(""),
				AIToolBarBitmapsToggledFunc( 1 ), wxNullBitmap,
				wxITEM_CHECK,
				_("Show Punctuation"),
				_("Show text with punctuation"));
			// whm Note: Now, the hiding punct button is showing on the toolbar. Remember: The tooltip
			// and help text tell what clicking on this hiding button would do, i.e., Show Punctuation.
			// must call Realize() after adding a new button
			pToolBar->Realize();

			if (pApp->m_nActiveSequNum != -1)
			{
				CPile* pPile = GetPile(pApp->m_nActiveSequNum);
				wxASSERT(pPile);
				CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;

				// reset the pApp->m_targetPhrase to hold the source phrase's other member
				pApp->m_targetPhrase = pSrcPhrase->m_adaption;
			}
			RedrawEverything(pApp->m_nActiveSequNum);
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Enable Punctuation Copy"
/// toolbar item (black punctuation characters on a green background) and returns immediately: The 
/// application is in Free Translation mode, in glossing mode, the active pile is NULL, or there 
/// are no source phrases in the m_pSourcePhrases list. Otherwise, it enables the toolbar button 
/// if the m_curIndex represents a valid location.
/// Note: The "Enable Punctuation Copy" toolbar button is the opposite state toggle of the
/// "No Punctuation Copy" toolbar button (black punctuation with yellow background and a red circle
/// and red diagonal bar).
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonEnablePunctCopy(wxUpdateUIEvent& event)
{
 	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
   if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_endIndex <= (int)gpApp->m_pSourcePhrases->GetCount() - 1 && gpApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_BUTTON_ENABLE_PUNCT_COPY
///                         bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button associated
/// with the ID_BUTTON_ENABLE_PUNCT_COPY bitmap image. The OnButtonEnablePunctCopy() handler is also 
/// called directly from the View's OnInitialUpdate(), OnButtonToEnd(), OnButtonToStart(), 
/// OnButtonStepDown(), OnButtonStepUp(), JumpForwardToNote_CoreCode(), JumpBackwardToNote_CoreCode(), 
/// and from CPhraseBox's MoveToNextPile(), MoveToPrevPile(), MoveToImmedNextPile().
/// If m_bCopySourcePunctuation is FALSE, this handler insures that the ID_BUTTON_NO_PUNCT_COPY 
/// bitmap image is displayed in the Toolbar, and changes m_bCopySourcePunctuation to TRUE. The
/// "No Punctuation Copy" button (witn ID_BUTTON_NO_PUNCT_COPY image having black punctuation 
/// with yellow background and a red circle and red diagonal bar) is displayed on the toolBar after
/// this handler finishes because it shows the user what state the punctuation copy functionality would
/// be if the user were to press that toolbar button, i.e., the opposite of the current state.
/// Note: The "Enable Punctuation Copy" toolbar button is the opposite state toggle of the
/// "No Punctuation Copy" toolbar button (black punctuation with yellow background and a red circle
/// and red diagonal bar). See also OnButtonNoPunctCopy().
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonEnablePunctCopy(wxCommandEvent& WXUNUSED(event)) // added in version 3
{
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	// whm Note: The MFC version starts with both toggle state images in the toolbar images and simply
	// hides one and shows the other as appropriate. The wxToolBar class does not have a HideButton()
	// method, so we Delete the unwanted image from the toolBar, and Insert the image we want into the
	// toolBar. The MFC version also used this OnButtonEnablePunctCopy() handler to set the initial
	// state of the punctuation copy function to TRUE in OnInitialUpdate() and other places, so to be
	// safe we will get the toolPos from either the ID_BUTTON_NO_PUNCT_COPY image or the
	// ID_BUTTON_ENABLE_PUNCT_COPY image, delete whatever image was there, but then unilaterally we
	// insert the ID_BUTTON_NO_PUNCT_COPY into the position of the deleted image. The image names
	// reflect the toggle state that would ensue if the button were pressed, rather than the present
	// state as indicated by the value of m_bCopySourcePunctuation as set at the end of this handler.
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_NO_PUNCT_COPY); // toolPos should be 40
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_ENABLE_PUNCT_COPY);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (!gpApp->m_bCopySourcePunctuation)
	{
		// In WX we delete the unwanted button and insert the wanted button to create the toggle effect
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
			// Note: In InsertTool, 1st parameter is position of button, zero based, count includes spacers
			// In AIToolBarBitmapsUnToggledFunc parameter is index of bitmap, zero based (no spacers in count)
			pToolBar->InsertTool(toolPos, ID_BUTTON_NO_PUNCT_COPY, _T(""),
				AIToolBarBitmapsUnToggledFunc( 27 ), wxNullBitmap,
				wxITEM_CHECK,
				_("No Punctuation Copy"),
				_("Suppress the copying of source text punctuation temporarily"));
			// must call Realize() after adding a new button
			pToolBar->Realize();
		}
		// toggle the setting
		gpApp->m_bCopySourcePunctuation = TRUE;
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "No Punctuation Copy"
/// toolbar item (black punctuation with yellow background and a red circle and red diagonal bar) 
/// and returns immediately: The application is in Free Translation mode, in glossing mode, the 
/// active pile is NULL, or there are no source phrases in the m_pSourcePhrases list. Otherwise, 
/// it enables the toolbar button if the m_curIndex represents a valid location.
/// Note: The "No Punctuation Copy" toolbar button is the opposite state toggle of the
/// "Enable Punctuation Copy" toolbar button (black punctuation characters on a green background).
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonNoPunctCopy(wxUpdateUIEvent& event)
{
 	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
   if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_endIndex <= (int)gpApp->m_pSourcePhrases->GetCount() - 1 && gpApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_BUTTON_NO_PUNCT_COPY
///                         bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button associated
/// with the ID_BUTTON_NO_PUNCT_COPY bitmap image. 
/// If m_bCopySourcePunctuation is TRUE, this handler insures that the ID_BUTTON_ENABLE_PUNCT_COPY 
/// bitmap image is displayed in the Toolbar, and changes m_bCopySourcePunctuation to FALSE. The
/// "Enable Punctuation Copy" button (witn ID_BUTTON_ENABLE_PUNCT_COPY image having black punctuation 
/// with green background) is displayed on the toolBar after this handler finishes because it shows 
/// the user what state the punctuation copy functionality would be if the user were to press that 
/// toolbar button, i.e., the opposite of the current state.
/// Note: The "No Punctuation Copy" toolbar button (black punctuation with yellow background and a 
/// red circle and red diagonal bar) is the opposite state toggle of the "Enable Punctuation Copy" 
/// toolbar button . See also OnUpdateButtonEnablePunctCopy().
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonNoPunctCopy(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame); 
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_NO_PUNCT_COPY); // toolPos should be 40
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_ENABLE_PUNCT_COPY);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (gpApp->m_bCopySourcePunctuation)
	{
		// In WX we delete the unwanted button and insert the wanted button to create the toggle effect
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
			// Note: In InsertTool, 1st parameter is position of button, zero based, count includes spacers
			// In AIToolBarBitmapsUnToggledFunc parameter is index of bitmap, zero based (no spacers in count)
			pToolBar->InsertTool(toolPos, ID_BUTTON_ENABLE_PUNCT_COPY, _T(""),
				AIToolBarBitmapsToggledFunc( 3 ), wxNullBitmap,
				wxITEM_CHECK,
				_("Enable Punctuation Copy"),
				_("Re-enable automatic copying of source text punctuation"));
			// must call Realize() after adding a new button
			pToolBar->Realize();
		}
		// toggle the setting
		gpApp->m_bCopySourcePunctuation = FALSE;
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Hide Punctuation"
/// toolbar item and returns immediately: The application is in Free Translation mode, in glossing
/// mode, the active pile is NULL, or there are no source phrases in the m_pSourcePhrases list.
/// Otherwise, it enables the toolbar button if the m_curIndex represents a valid location.
/// Note: The "Hide Punctuation" toolbar button is the opposite state toggle of the
/// "Show Punctuation" toolbar button.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonHidePunct(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
  	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
   if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_endIndex <= (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);

}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_BUTTON_HIDING_PUNCT
///                         bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button associated
/// with the ID_BUTTON_HIDING_PUNCT bitmap image (image with curtains closed). 
/// Note: The Button image depicts what the current state of punctuation showing/hiding is, but the
/// tooltip and help text describe what clicking the button will accomplish. 
/// If m_bHidePunctuation is TRUE, this handler insures that the ID_BUTTON_SHOWING_PUNCT 
/// bitmap image is displayed in the Toolbar, and changes m_bHidePunctuation to FALSE. The
/// "Showing Punctuation" button (witn ID_BUTTON_SHOWING_PUNCT image having curtains drawn back revealing an
/// exclamation point) is displayed on the toolBar after this handler finishes because it shows 
/// the user what state the show/hide punctuation functionality would be if the user were to press that 
/// toolbar button, i.e., the opposite of the current state.
/// Note: The "Hiding Punctuation" toolbar button (curtains closed on stage) is the opposite state 
/// toggle of the "Showing Punctuation" toolbar button . See also OnButtonFromShowingToHidingPunct().
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromHidingToShowingPunct(wxCommandEvent& WXUNUSED(event))
{
	// This handler was called OnButtonHidePunct() in the MFC version. Since it is a toggle button
	// which changes its appearance I've changed the name of the handler and its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_HIDING_PUNCT); // toolPos should be 19
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_SHOWING_PUNCT);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (pApp->m_bHidePunctuation)
	{
		// The app is currently hiding punctuation. The user wants to switch from hiding
		// to showing. This is effected by setting m_bHidePunctuation to FALSE. 
		pApp->m_bHidePunctuation = FALSE;
		// Now we must change the appearance of the toggle button in the toolbar so that its appearance
		// switches from the hiding image to the showing image. We do this by inserting the
		// ID_BUTTON_SHOWING_PUNCT button into position on the toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
			// Note: In InsertTool, 1st parameter is position of button, zero based, count includes spacers
			// In AIToolBarBitmapsUnToggledFunc parameter is index of bitmap, zero based (no spacers in count)
			pToolBar->InsertTool(toolPos, ID_BUTTON_SHOWING_PUNCT, _T(""),
				AIToolBarBitmapsUnToggledFunc( 10 ), wxNullBitmap,
				wxITEM_CHECK,
				_("Hide Punctuation"),
				_("Don't show punctuation with the text"));
			// whm Note: Now, the showing punct button is showing on the toolbar. Remember: The tooltip
			// and help text tell what clicking on this hiding button would do, i.e., Hide Punctuation.
			// must call Realize() after adding a new button
			pToolBar->Realize();
			if (pApp->m_nActiveSequNum != -1)
			{
				CPile* pPile = GetPile(pApp->m_nActiveSequNum);
				wxASSERT(pPile);
				CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;

				// reset the pApp->m_targetPhrase to hold the source phrase's other member
				pApp->m_targetPhrase = pSrcPhrase->m_targetStr;
			}
			RedrawEverything(pApp->m_nActiveSequNum);
		}

	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Show Target Text Only" 
/// toolbar item and returns immediately: Vertical Editing is in progress, the active pile is NULL, 
/// or there are no source phrases in the m_pSourcePhrases list. Otherwise, it enables the 
/// toolbar button if m_endIndex is within a valid range.
/// Note: The "Show Target Text Only" toolbar button is the opposite state toggle of the
/// "Show Source And Target Text" toolbar button.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateShowTgt(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_endIndex <= (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_SHOWING_ALL
///                         bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button associated
/// with the ID_SHOWING_ALL bitmap image. 
/// Note: The Button image depicts what the current state of showing-all/showing-target-only is, but the
/// tooltip and help text describe what clicking the button will accomplish. 
/// If gbShowTargetOnly is FALSE, this handler insures that the ID_SHOWING_TGT 
/// bitmap image is displayed in the Toolbar, and changes gbShowTargetOnly to TRUE. The
/// "Showing Source And Target Text" button (witn ID_SHOWING_ALL image having pairs of lines representing 
/// strips of source and target together) is displayed on the toolBar after this handler finishes 
/// because it shows the user what state the target text only functionality would be if the user 
/// were to press that toolbar button, i.e., the opposite of the current state.
/// Note: The "Show Source And Target Text" toolbar button is the opposite state toggle of the 
/// "Show Target Text Only" toolbar button. 
/// See also OnFromShowingAllToShowingTargetOnly().
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnFromShowingAllToShowingTargetOnly(wxCommandEvent& WXUNUSED(event))
{
	// This handler was called OnShowTgt() in the MFC version. Since it is a toggle button
	// which changes its appearance I've changed the name of the handler and its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_SHOWING_TGT); // toolPos should be 38
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_SHOWING_ALL);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (!gbShowTargetOnly)
	{
		// The app is currently showing all. The user wants to switch from showing all
		// to showing only TGT text. This is effected by setting gbShowTargetOnly to TRUE. 
		
		// must remove any selection first
		RemoveSelection();

		// user wants to show only the target lines, so fix accordingly
		gbShowTargetOnly = TRUE;
		// Now we must change the appearance of the toggle button in the toolbar so that its appearance
		// switches from the showing all image to the showing only target text image. We do this by 
		// inserting the ID_SHOWING_TGT button into position on the toolbar.
		gnSaveLeading = pApp->m_curLeading;
		gnSaveGap = pApp->m_curGapWidth;
		pApp->m_curLeading = pApp->m_nTgtHeight / 4;
		int newGapWidth = pApp->m_curGapWidth / 3;
		pApp->m_curGapWidth = wxMax(newGapWidth,10);
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
			// Note: In InsertTool, 1st parameter is position of button, zero based, count includes spacers
			// In AIToolBarBitmapsUnToggledFunc parameter is index of bitmap, zero based (no spacers in count)
			pToolBar->InsertTool(toolPos, ID_SHOWING_TGT, _T(""),
				AIToolBarBitmapsToggledFunc( 2 ), wxNullBitmap,
				wxITEM_CHECK,
				_("Show normal view"),
				_("Show Source And Target Text"));
			// whm Note: Now, the showing tgt only button is showing on the toolbar. Remember: The tooltip
			// and help text tell what clicking on this hiding button would do, i.e., Show Source and
			// Target Text.
			// must call Realize() after adding a new button
			pToolBar->Realize();
			RedrawEverything(pApp->m_nActiveSequNum);
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Show Source And 
/// Target Text" toolbar item (pairs of lines representing strips) and returns immediately: 
/// Vertical Editing is in progress, the active pile is NULL, or there are no source phrases 
/// in the m_pSourcePhrases list. Otherwise, it enables the toolbar button if m_endIndex is 
/// within a valid range.
/// Note: The "Show Source And Target Text" toolbar button is the opposite state toggle of the
/// "Show Target Text Only" toolbar button.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateShowAll(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_endIndex <= (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_endIndex > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_SHOWING_TGT
///                         bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button associated
/// with the ID_SHOWING_TGT bitmap image. The OnFromShowingTargetOnlyToShowingAll() handler is also 
/// called directly from the View's OnInitialUpdate(), OnFind(), and OnReplace().
/// Note: The Button image depicts what the current state of showing-all/showing-target-only is, but the
/// tooltip and help text describe what clicking the button will accomplish. 
/// If gbShowTargetOnly is TRUE, this handler insures that the ID_SHOWING_ALL 
/// bitmap image is displayed in the Toolbar, and changes gbShowTargetOnly to FALSE. The
/// "Showing ALL" button (witn ID_SHOWING_ALL image having pairs of lines representing strips of 
/// source and target together) is displayed on the toolBar after this handler finishes because 
/// it shows the user what state the showing-all/showing-target-text-only functionality would be 
/// if the user were to press that toolbar button, i.e., the opposite of the current state.
/// Note: The "Showing Target Text Only" toolbar button is the opposite state toggle of the
/// "Showing All" toolbar button. See also OnFromShowingAllToShowingTargetOnly().
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnFromShowingTargetOnlyToShowingAll(wxCommandEvent& WXUNUSED(event))
{
	// This handler was called OnShowAll() in the MFC version. Since it is a toggle button
	// which changes its appearance I've changed the name of the handler and its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar(); 
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_SHOWING_TGT); // toolPos should be 38
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_SHOWING_ALL);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (gbShowTargetOnly)
	{
		// The app is currently showing only target lines. The user wants to switch from showing
		// only the target text to showing all. This is effected by setting gbShowTargetOnly 
		// to FALSE. 
		gbShowTargetOnly = FALSE;
		// Now we must change the appearance of the toggle button in the toolbar so that its appearance
		// switches from the showing target only image to the showing all image. We do this by 
		// inserting the ID_SHOWING_ALL button into position on the toolbar.
		pApp->m_curLeading = gnSaveLeading;
		pApp->m_curGapWidth = gnSaveGap;
		gnSaveLeading = 4;
		gnSaveGap = 8;
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if(tbDeleted)
		{
			// Note: In InsertTool, 1st parameter is position of button, zero based, count includes spacers
			// In AIToolBarBitmapsUnToggledFunc parameter is index of bitmap, zero based (no spacers in count)
			pToolBar->InsertTool(toolPos, ID_SHOWING_ALL, _T(""),
				AIToolBarBitmapsUnToggledFunc( 24 ), wxNullBitmap,
				wxITEM_CHECK,
				_("Show Target Text Only"),
				_("Show target text only"));
			// whm Note: Now, the showing all button is showing on the toolbar. Remember: The tooltip
			// and help text tell what clicking on this hiding button would do, i.e., Show Target Text
			// Only.
			// must call Realize() after adding a new button
			pToolBar->Realize(); // this should not be necessary
			RedrawEverything(pApp->m_nActiveSequNum);
		}
	}
}

CSourcePhrase* CAdapt_ItView::GetSrcPhrase(int nSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList = pApp->m_pSourcePhrases; 
	wxASSERT(pList);
	int nCount;
	nCount = pList->GetCount();
	wxASSERT(nCount != 0);
	SPList::Node* pos = pList->Item(nSequNum);
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase);
	return pSrcPhrase;
}

CSourcePhrase* CAdapt_ItView::GetNextEmptySrcPhrase(int nStartingSequNum)
// this searches in the list of stored source phrases, and is independent of the size of the
// current bundle - so it will search to the very end of the doc if necessary
// For version 2.0 and onwards, test gbIsGlossing and branch accordingly.
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CSourcePhrase* pSrcPhrase;
	int sn = nStartingSequNum;
	do
	{
		++sn;
		if (sn > pApp->m_maxIndex)
			return (CSourcePhrase*)NULL; // we have gone past end of document
		pSrcPhrase = GetSrcPhrase(sn);
		wxASSERT(pSrcPhrase);
		if (gbIsGlossing)
		{
			if (!pSrcPhrase->m_bHasGlossingKBEntry)
				return pSrcPhrase;
		}
		else
		{
			if (!pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB
											&& !pSrcPhrase->m_bRetranslation)
				return pSrcPhrase;
		}
	} while (TRUE);
}

CSourcePhrase* CAdapt_ItView::GetFollSafeSrcPhrase(CSourcePhrase* pSrcPhrase)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pSrcPhrase);
	int sn = pSrcPhrase->m_nSequNumber;
	CSourcePhrase* pSP;
	do
	{
		++sn;
		if (sn > pApp->m_maxIndex)
			return (CSourcePhrase*)NULL; // we have gone past end of document
		pSP = GetSrcPhrase(sn);
		wxASSERT(pSP);
	} while (pSP->m_bRetranslation);
	return pSP; // found one where it is okay to have the phrase box put in the view
}

CSourcePhrase* CAdapt_ItView::GetPrevSafeSrcPhrase(CSourcePhrase* pSrcPhrase)
{
	wxASSERT(pSrcPhrase);
	int sn = pSrcPhrase->m_nSequNumber;
	CSourcePhrase* pSP;
	do
	{
		--sn;
		if (sn < 0)
			return (CSourcePhrase*)NULL; // we have gone back past start of document
		pSP = GetSrcPhrase(sn);
		wxASSERT(pSP);
	} while (pSP->m_bRetranslation);
	return pSP; // found one where it is okay to have the phrase box put in the view
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the KB is in a ready state the "Wrap At Standard Format Markers" item on the View menu is
/// enabled, otherwise the menu item is disabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateMarkerWrapsStrip(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT( pApp != NULL);

	// testing one kb is enough
	if (pApp->m_bKBReady && pApp->m_pKB != NULL)
	{
		event.Enable(TRUE); // enable, whether doc open or not
	}
	else
	{
		event.Enable(FALSE); // disable if not got an open project
	}
}

void CAdapt_ItView::OnMarkerWrapsStrip(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pViewMarkerWrapsStrip = pMenuBar->FindItem(ID_MARKER_WRAPS_STRIP);
	wxASSERT(pViewMarkerWrapsStrip != NULL);

	// toggle the setting & update the display accordingly
	if (pApp->m_bMarkerWrapsStrip)
	{
		// toggle the checkmark to OFF & recalc the layout with wrap caused by markers turned off
		pViewMarkerWrapsStrip->Check(FALSE);
		pApp->m_bMarkerWrapsStrip = FALSE;
	}
	else
	{
		// toggle the checkmark to ON, and recalc the layout with wrap caused by markers turned on
		pViewMarkerWrapsStrip->Check(TRUE);
		pApp->m_bMarkerWrapsStrip = TRUE;
	}

	// redraw everything -- CreateStrip() in RecalcLayout uses the m_bMarkerWrapsStrip flag to
	// do the wanted wraps
	RedrawEverything(pApp->m_nActiveSequNum);
}

void CAdapt_ItView::GetVisibleStrips(int& nFirstStrip,int&nLastStrip)
// nFirstStrip = index of first strip visible (or partly visible) in the view
// nLast Strip = index of last strip visible (or partly visible) in the view
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxClientDC dc(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(dc); //OnPrepareDC(&dc); // adjust origin
	canvas->pFrame->PrepareDC(dc); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame

	// find the index of the first strip which is visible
	wxRect rectStrip;
	int nTotalStrips = pApp->m_pBundle->m_nStripCount;
	wxRect rectClient;
	//GetClientRect(&rectClient); // gets view's client area (device coords) - upper left point is always (0,0)
	//pApp->GetMainFrame()->canvas->GetClientSize(&rectClient.width,&rectClient.height);// gets the width and height in pixels
	// wx note: calling GetClientSize on the canvas produced different results in wxGTK and
	// wxMSW, so I'll use my own GetCanvasClientSize() which calculates it from the main frame's
	// client size.
	wxSize canvasViewSize;
	canvasViewSize = pApp->GetMainFrame()->GetCanvasClientSize();

//#ifdef _DEBUG
//	// Here's sample code for alternative 1:
//	// save a copy of the initial grectViewClient values for use below (alternative 2 changes grectViewClient)
//	wxRect testRectViewClient = rectClient;
//#endif

	//int xScrollUnits, yScrollUnits, xOrigin, yOrigin;
	//pApp->GetMainFrame()->canvas->GetViewStart(&xOrigin, &yOrigin); // gets xOrigin and yOrigin in scroll units
	//pApp->GetMainFrame()->canvas->GetScrollPixelsPerUnit(&xScrollUnits, &yScrollUnits); // gets pixels per scroll unit
	//rectClient.x = xOrigin * xScrollUnits; // number pixels is ScrollUnits * pixelsPerScrollUnit
	//rectClient.y = yOrigin * yScrollUnits;

//#ifdef _DEBUG
//	//wx version uses CalcUnscrolledPosition
//	int newXPos,newYPos;
//	pApp->GetMainFrame()->canvas->CalcUnscrolledPosition(0,0,&newXPos,&newYPos);
//	wxASSERT(newXPos == rectClient.x); //rectClient.x = newXPos; // stays zero since we dont' have horizontal scrolling
//	wxASSERT(newYPos == rectClient.y); //rectClient.y = newYPos;
//#endif

//#ifdef _DEBUG
//	//dc.DPtoLP(&rectClient); // this is like the MFC method
//	int x = dc.DeviceToLogicalX(testRectViewClient.x);// get the device X (width) coord converted to logical coord
//	int y = dc.DeviceToLogicalY(testRectViewClient.y); // get the device Y (height) coord converted to logical coord
//	wxASSERT(x == rectClient.x);
//	wxASSERT(y == rectClient.y);
//#endif
	
	pApp->GetMainFrame()->canvas->CalcUnscrolledPosition(0,0,&rectClient.x,&rectClient.y);
	rectClient.width = canvasViewSize.x;
	rectClient.height = canvasViewSize.y;

	wxPoint ptStripBottomRight;
	wxPoint ptStripTopLeft;
	int i;
	for (i = 0; i < nTotalStrips; i++)
	{
		ptStripBottomRight.x = pApp->m_pBundle->m_pStrip[i]->m_rectStrip.GetRight(); // get BottomRight in 2 steps
		ptStripBottomRight.y = pApp->m_pBundle->m_pStrip[i]->m_rectStrip.GetBottom();
		if (ptStripBottomRight.y > rectClient.GetTop())
		{
			// this strip is at least partly visible
			nFirstStrip = pApp->m_pBundle->m_pStrip[i]->m_nStripIndex;
			break;
		}
	}

	int j;
	for (j = i + 1; j < nTotalStrips; j++)
	{
		ptStripTopLeft.x = pApp->m_pBundle->m_pStrip[j]->m_rectStrip.GetLeft(); // get TopLeft in 2 steps
		ptStripTopLeft.y = pApp->m_pBundle->m_pStrip[j]->m_rectStrip.GetTop();
		if (ptStripTopLeft.y >= rectClient.GetBottom())
		{
			nLastStrip = --j;
			wxASSERT(nLastStrip > nFirstStrip);
			break;
		}
	}
	if (j == nTotalStrips)
	{
		// we got to the end of the bundle
		nLastStrip = nTotalStrips - 1;
		wxASSERT(nLastStrip > nFirstStrip);
	}
}

void CAdapt_ItView::ReDoMerge(int nSequNum,SPList* pNewList,SPList::Node* posNext,
							  CSourcePhrase* pFirstSrcPhrase, int nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList::Node* pos = posNext; // since posNext comes from the caller, it is already the 'next'
							// position
	// starting from the next minimal srcPhrase, Merge each succeeding one to pFirstSrcPhrase
	for (int i = 1; i < nCount; i++)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase);
		wxASSERT(pSrcPhrase->m_nSrcWords == 1 || pSrcPhrase->m_nSrcWords == 0); // no phrases allowed
		pFirstSrcPhrase->Merge(this,pSrcPhrase);
	}

	// count how many have to be removed from the m_pSourcePhrases list on the app
	int nRemoveCount = nCount - 1; // that is, all but the first

	// remove from the list the ones which have been merged to the first
	pos = pNewList->Item(nSequNum + 1); // position of first to be removed
	SPList::Node* savePos;
	wxASSERT(pos != NULL);
	int j = 0;
	while (pos != NULL && j < nRemoveCount)
	{
		savePos = pos;
		CSourcePhrase* pSrcPhrase;
		pSrcPhrase = (CSourcePhrase*)pos->GetData(); // not really used
		pos = pos->GetNext();
		pNewList->DeleteNode(savePos); // remove pointer, but leave srcPhrase on the heap,
		j++;						 // because it is pointed at from within pFirstSrcPhrase now
	}

	// fix up the max index value (not sure I need do this here, but it won't hurt)
	pApp->m_maxIndex -= nRemoveCount;

	// update the sequence numbers which follow the first src phrase
	UpdateSequNumbers(nSequNum);

	// set up the m_inform attribute, if there are medial markers
	if (pFirstSrcPhrase->m_bHasInternalMarkers)
	{
		wxString s = _T(" Medial markers: ");
		if (!pFirstSrcPhrase->m_pMedialMarkers->IsEmpty())
		{
			// In wxArrayString the "head position" should be Item zero (0)
			// We'll iterate through the array with a for loop
			for (int i = 0; i < (int)pFirstSrcPhrase->m_pMedialMarkers->GetCount(); i++)
			{
				s += pFirstSrcPhrase->m_pMedialMarkers->Item(i);
			}
			pFirstSrcPhrase->m_inform += s;
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the appropriate KB is not in a ready state this handler disables the "Export Knowledge Base..." item 
/// in the File menu, otherwise it enables the "Export Knowledge Base..." item on the File menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExportKb(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if ((!gbIsGlossing && pApp->m_pKB != NULL) || (gbIsGlossing && pApp->m_pGlossingKB != NULL))
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnFileExportKb(wxCommandEvent& WXUNUSED(event))
// Modified for export of either the adaptation KB or the glossing KB
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc;
	CPhraseBox* pBox;
	CAdapt_ItView* pView;
	pApp->GetBasePointers(pDoc,pView,pBox); // this is 'safe' when no doc is open

	// get a pointer to either the glossing KB or the adaptation one
	CKB* pKB;
	if (gbIsGlossing)
		pKB = pApp->m_pGlossingKB;
	else
		pKB = pApp->m_pKB;
	wxASSERT(pKB != NULL);

	// get an output filename and put up file dialog
	// make the working directory the "<Project Name>" one if no previous export path
	// was defined, else make it the stored last export path for the kb
	bool bOK = TRUE;
	if (pApp->m_kbExportPath.IsEmpty())
		bOK = ::wxSetWorkingDirectory(pApp->m_curProjectPath);
	else
		bOK = ::wxSetWorkingDirectory(pApp->m_kbExportPath);

	// the above may have failed, so if so use m_curProjectPath as the folder
	// so we can proceed to the file dialog safely
	if (!bOK)
	{
		pApp->m_kbExportPath = pApp->m_curProjectPath;
		bOK = ::wxSetWorkingDirectory(pApp->m_kbExportPath); // this should work, since
														   //m_curProjectPath can hardly be wrong!
		if (!bOK)
		{
			bOK = ::wxSetWorkingDirectory(pApp->m_kbExportPath = _T("C:"));
			if (!bOK)
			{
				// we should never get a failure for the above, so just an English message will do
				wxMessageBox(_T("OnFileExportKb() failed, the export has been aborted"),_T(""),wxICON_WARNING);
				return;
			}
		}
	}

	wxString dicFilename;
	dicFilename = pApp->m_curProjectName;
	dicFilename = MakeReverse(dicFilename);
	int offset = dicFilename.Find(_T(" "));
	dicFilename = dicFilename.Mid(offset); // remove "Adaptations" or Tok Pisin equivalent
	dicFilename = MakeReverse(dicFilename);
	wxString glossStr;
	if (gbIsGlossing)
	{
		//IDS_GLOSSING
		glossStr = _("Glossing");
		glossStr += _T(" ");
		dicFilename += glossStr; // ensure the glossing KB export has its own filename
	}
	wxString str;
	// IDS_DIC_REC_TXT
	str = str.Format(_("dictionary records.txt"));
	dicFilename += str;

	wxString defaultDir;
	if (pApp->m_kbExportPath.IsEmpty())
	{
		defaultDir = pApp->m_curProjectPath;
	}
	else
	{
		defaultDir = pApp->m_kbExportPath;
	}

	// get a file dialog
	wxString filter;
	filter = _("Adapt It knowledge base export (*.txt)|*.txt|All Files (*.*)|*.*||"); //(IDS_KB_EXPORT_FILTER);
	wxFileDialog fileDlg(
		(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
		_("Filename For KB Export"),
		defaultDir,	// empty string causes it to use the current working directory (set above)
		dicFilename,	// default filename
		filter,
		wxSAVE | wxOVERWRITE_PROMPT); // | wxHIDE_READONLY); wxHIDE_READONLY deprecated in 2.6 - the checkbox is never shown
	fileDlg.Centre();

	// make the dialog visible
	if (fileDlg.ShowModal() != wxID_OK)
		return; // user cancelled

	// update m_kbExportPath
	wxString exportPath = fileDlg.GetPath();
	wxString name = fileDlg.GetFilename();
	int nameLen = name.Length();
	int pathLen = exportPath.Length();
	wxASSERT(nameLen > 0 && pathLen > 0);
	pApp->m_kbExportPath = exportPath.Left(pathLen - nameLen - 1);

	// get the user's desired path
	wxString dicPath = fileDlg.GetPath(); 

	wxFile f; //CStdioFile f;
	if( !f.Open( dicPath, wxFile::write))
	{
	   #ifdef __WXDEBUG__
		  wxLogError(_("Unable to open knowledge base export file.\n"));
		  wxMessageBox(_("Unable to open knowledge base export file."),_T(""), wxICON_WARNING);
	   #endif
	   return; //exit( 1 ); // whm changed to return since it is not a fatal error
	}

	DoKBExport(pKB,&f);

	// close the file
	f.Close();
}

void CAdapt_ItView::DoKBExport(CKB* pKB, wxFile* pFile)
// Modified for export of either the glossing KB or the adapting KB
{
	wxASSERT(pKB != NULL);
	wxASSERT(pFile != NULL);
	wxString s1 = gSFescapechar;
	wxString lexSFM = s1 + _T("lx ");
	wxString geSFM = s1 + _T("ge ");
	wxString key;
	key.Empty();
	wxString gloss;
	wxString baseKey;
	gloss.Empty(); // this name used for the "adaptation" when adapting,
				   // or the "gloss" when glossing

	// MFC's WriteString() function automatically converts any \n embedded within the buffer
	// to the \r\n pair on output. The wxWidgets wxFile::Write() function, however, does
	// not do this so we need to here create the proper EOL sequences in the buffer.
	// The wxWidgets' wxTextFile::GetEOL() static function returns the appropriate
	// end-of-line sequence for the current platform. It would be hex sequence pair 0d 0a for
	// Windows, the single hex char 0a for Unix/Linux, and the single hex char 0d for Macintosh.
	// The GetEOL function provides the correct line termination character(s).
	//wxString eolStr = wxTextFile::GetEOL(); // done in the App's OnInit()
	wxASSERT(gpApp->m_eolStr.Find(_T('\n')) != -1 || gpApp->m_eolStr.Find(_T('\r')) != -1);

	int numWords;
	MapKeyStringToTgtUnit::iterator iter;
	CTargetUnit* pTU = 0;
	CRefString* pRefStr;
	for (numWords = 1; numWords <= MAX_WORDS; numWords++)
	{
		if (gbIsGlossing && numWords > 1)
			continue; // when glossing we want to consider only the first map, the others
					  // are all empty
		if (pKB->m_pMap[numWords-1]->size() == 0) 
			continue;
		else
		{
a:			for (iter = pKB->m_pMap[numWords-1]->begin(); iter != pKB->m_pMap[numWords-1]->end(); ++iter)
			{
				key = iter->first; 
				pTU = (CTargetUnit*)iter->second; 
				wxASSERT(pTU != NULL); 
				baseKey = key;
				key = lexSFM + key; // + endText; // we put the proper eol char(s) below when writing
				bool bDelayed = TRUE;

				// get the reference strings
				TranslationsList::Node* posRef = 0; 

				// if the data somehow got corrupted by a CTargetUnit being retained in the
				// list but which has an empty list of reference strings, this illegal
				// instance would cause a crash - so test for it and if such occurs, then
				// remove it from the list and then just continue looping
				if (pTU->m_pTranslations->IsEmpty())
				{
					pKB->m_pMap[numWords-1]->erase(baseKey); // the map now lacks this invalid association
					TUList::Node* pos = pKB->m_pTargetUnits->Find(pTU); 
					wxASSERT(pos != NULL);
					pKB->m_pTargetUnits->DeleteNode(pos); // its CTargetUnit ptr is now gone from list
					delete pTU; // and its memory chunk is freed
					continue;
				}
				else
					posRef = pTU->m_pTranslations->GetFirst(); 
				wxASSERT(posRef != 0);

				while (posRef != 0)
				{
					pRefStr = (CRefString*)posRef->GetData();
					posRef = posRef->GetNext();
					wxASSERT(pRefStr != NULL); 
					gloss = pRefStr->m_translation;
					if (gloss == _T("<Not In KB>")) // this possibility forces us to delay the
													// \lx write
						goto a;
					gloss = geSFM + gloss; // + endText; // we put the proper eol char(s) below when writing
					if (bDelayed)
					{
#ifndef _UNICODE // ANSI version
						pFile->Write(key); 
						pFile->Write(gpApp->m_eolStr); // whm added for wx version
						bDelayed = FALSE;
					}
					pFile->Write(gloss); 
					pFile->Write(gpApp->m_eolStr); // whm added for wx version
				}

				// write a blank line
				pFile->Write(gpApp->m_eolStr); // use the proper cross-platform eol char(s)

#else // Unicode version
// version 2.0.3 and earlier, the encoding was intermittently getting confused and AI would
// try to convert to legacy encoding - which would fail if the user was using 1252 code page
// in some other country where, say, arabic or some other encoding should be in force; so instead
// of trying to have the possibility of a legacy conversion, just use CP_UF8 for exporting the
// KB every time, and this should give users what they want and expect (to get to a legacy
// encoding they could use a TECKit mapping after the export is done - safer way to go)
//						gpApp->ConvertAndWrite(pApp->m_srcEncoding,pFile,key); // source text
						gpApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,key); // source text
						bDelayed = FALSE;
					}

					// use the IMultiLanguage2 interface (see ATL stuff) to find out what
					// encoding it is
/* // below commented out in MFC
					MyML2Ptr pML2;
					TCHAR* pBuff = gloss.GetBuffer(0);
					int nLength = gloss.GetLength() * sizeof(TCHAR);
					if (!!pML2) // if not bad
					{
						switch(pML2.WhichEncoding((LPVOID)pBuff,(INT)nLength))
						{
						case CP_UTF8:
							// it has at least some UTF8
							gpApp->m_tgtEncoding = eUTF8;
							break;
						case CP_UTF16:
							// it has at least some UTF16
							gpApp->m_tgtEncoding = eUTF8;
							break;
						default:
							// it's neither, so probably ANSI, LATIN1, ASCII, or MBCS etc
							// (ie. a legacy encoding) since there is no safe converstion,
							// we'll use the system codepage and convert using A2T
							gpApp->m_tgtEncoding = GetACP();
						}
					}
					gpApp->ConvertAndWrite(gpApp->m_tgtEncoding,pFile,gloss);
*/
					gpApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,gloss);
				}

				// write a blank line
//				gpApp->ConvertAndWrite(gpApp->m_srcEncoding,pFile,endText);
				gpApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,gpApp->m_eolStr); //gpApp->ConvertAndWrite(eUTF8,pFile,endText);
#endif
			}
		}
	}
}

// Moved to CAdapt_ItCanvas in WX version:
//void CAdapt_ItView::OnLButtonUp(wxMouseEvent& event) //void CAdapt_ItView::OnLButtonUp(UINT nFlags, CPoint point)

// Moved to CAdapt_ItCanvas in WX version:
//void CAdapt_ItView::OnMouseMove(wxMouseEvent& event) //void CAdapt_ItView::OnMouseMove(UINT nFlags, CPoint point)

void CAdapt_ItView::SelectDragRange(CCell* pAnchor,CCell* pCurrent)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pCurrent != NULL);
	if (pAnchor == NULL)
		return;

	// are boundaries to be ignored?
	bool bIgnoreBoundaries = !pApp->m_bRespectBoundaries; // if m_bRespectBoundaries is FALSE because
					// user clicked the button, for a SHIFT select, SelectDragRange sometimes
					// gets called, and if we unilaterally start with bIgnoreBoundaries as FALSE
					// then it can result in a long selection being wrongly shortened to the
					// loc'n of the first bounding srcPhrase
	if (wxGetKeyState(WXK_CONTROL))
		bIgnoreBoundaries = TRUE;

	if (pAnchor->m_nCellIndex != pCurrent->m_nCellIndex)
	{
		// cells are on different line, so cannot make a valid selection
		SelectAnchorOnly();
		return;
	}

	// set the direction
	if (pAnchor->m_pPile->m_pSrcPhrase->m_nSequNumber <
											pCurrent->m_pPile->m_pSrcPhrase->m_nSequNumber)
		pApp->m_curDirection = right;
	else if (pAnchor->m_pPile->m_pSrcPhrase->m_nSequNumber >
											pCurrent->m_pPile->m_pSrcPhrase->m_nSequNumber)
		pApp->m_curDirection = left;
	else
		return; // since we must be at the anchor which is already selected, so nothing to
				// be done yet

	SelectAnchorOnly(); // reduce to just the anchor, before we rebuild the selection
	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context
	canvas->DoPrepareDC(aDC); //OnPrepareDC(&aDC); // get origin adjusted
	canvas->pFrame->PrepareDC(aDC); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame
	aDC.SetBackgroundMode(pApp->m_backgroundMode);
	aDC.SetTextBackground(wxColour(255,255,0)); // yellow

	int cellIndex = pAnchor->m_nCellIndex;
	CCell* pCell = pAnchor;
	bool bAtEnd = FALSE;
	bool bAtBoundary = FALSE;
	if (pApp->m_curDirection == right)
	{
a:		pCell = GetNextCell(pCell,cellIndex);

		if (IsTypeDifferent(pApp->m_pAnchor,pCell))
		{
			// IDS_DIFF_TEXT_TYPE
			wxMessageBox(_("Sorry, you are trying to select text of different types, such as a heading and verse text, or some other illegal combination. Combining verse text with poetry is acceptable, other combinations are not."), _T(""), wxICON_INFORMATION);
			RemoveSelection();
			pApp->m_mouse.x = pApp->m_mouse.y = -1;
			CMainFrame *pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame != NULL);
			pFrame->canvas->ReleaseMouse(); //ReleaseCapture(); // assume no failure
			pApp->m_pAnchor = NULL;
			Invalidate();  // UpdateWindow() doesn't work, need the delayed update
			gbHaltedAtBoundary = FALSE;
			return;
		}

		if (pCell == pCurrent)
			bAtEnd = TRUE; // use this in our break out test later
		if (!bIgnoreBoundaries && pCell->m_pPile->m_pSrcPhrase->m_bBoundary)
		{
			bAtBoundary = TRUE; // can't go further, must respect this boundary because CTRL
								// key not down
			gbHaltedAtBoundary = TRUE; // for use by OnLButtonUp()
		}
		pCell->m_pText->Draw(&aDC); // draw it selected
		pCell->m_pText->m_bSelected = TRUE; // ensure updates continue to show it selected
		pApp->m_selection.Append(pCell); // store pointer in the selection list
		if (!(bAtEnd || bAtBoundary))
			goto a;
	}
	else
	{
b:		pCell = GetPrevCell(pCell,cellIndex);

		if (IsTypeDifferent(pApp->m_pAnchor,pCell))
		{
			// IDS_DIFF_TEXT_TYPE
			wxMessageBox(_("Sorry, you are trying to select text of different types, such as a heading and verse text, or some other illegal combination. Combining verse text with poetry is acceptable, other combinations are not."),_T(""), wxICON_INFORMATION);
			RemoveSelection();
			pApp->m_mouse.x = pApp->m_mouse.y = -1;
			CMainFrame *pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame != NULL);
			pFrame->canvas->ReleaseMouse(); //ReleaseCapture(); // assume no failure
			pApp->m_pAnchor = NULL;
			Invalidate(); // UpdateWindow() doesn't work, need the delayed update
			gbHaltedAtBoundary = FALSE;
			return;
		}

		if (pCell == pCurrent)
			bAtEnd = TRUE; // use this in our break out test later
		if (!bIgnoreBoundaries && pCell->m_pPile->m_pSrcPhrase->m_bBoundary)
		{
			bAtBoundary = TRUE; // can't go further, must respect this boundary because CTRL
								// key not down
			gbHaltedAtBoundary = TRUE; // for use by OnLButtonUp()
		}
		if (!bAtBoundary)
		{
			pCell->m_pText->Draw(&aDC); // draw it selected
			pCell->m_pText->m_bSelected = TRUE; // ensure updates continue to show it selected
			pApp->m_selection.Insert(pCell); // store pointer in the selection list
		}
		if (!bAtEnd)
			goto b;
	}
	CMainFrame *pFrame = pApp->GetMainFrame();
	pFrame->canvas->Update(); 
}

void CAdapt_ItView::SelectAnchorOnly()
// shortens the selection so that it is just the anchor cell
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pApp->m_pAnchor != NULL);
	CCell* pAnchor = pApp->m_pAnchor;
	wxASSERT(pAnchor); 

	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context
	canvas->DoPrepareDC(aDC); //OnPrepareDC(&aDC); // get origin adjusted
	canvas->pFrame->PrepareDC(aDC); // wxWidgets' drawing.cpp sample also calls PrepareDC on the owning frame

	CCellList* pList = &pApp->m_selection; 
	wxASSERT(pList);
	CCellList::Node* pos = pList->GetFirst(); 
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		CCell* pCell = (CCell*)pos->GetData();
		pos = pos->GetNext();
		if (pCell == pAnchor)
			continue;
		else
		{
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pCell->m_pText->Draw(&aDC);
			pCell->m_pText->m_bSelected = FALSE;
		}
	}
	// now remove from the selection list the cells which were deselected
	pList->Clear(); //pList->RemoveAll();
	pList->Insert(pAnchor);
	wxASSERT(pList->GetCount() == 1); // should only be one left in the list
	CMainFrame *pFrame = pApp->GetMainFrame();
	pFrame->canvas->Update();
}

bool CAdapt_ItView::IsTypeDifferent(CCell* pAnchor, CCell* pCurrent)
// poetry is not treated as different than verse, but any other mismatch
// is considered to be a real mismatch
{
	TextType aType = pAnchor->m_pPile->m_pSrcPhrase->m_curTextType;
	TextType curType = pCurrent->m_pPile->m_pSrcPhrase->m_curTextType;
	if (curType == aType)
		return FALSE;
	if (aType == verse)
	{
		if (curType == poetry)
			return FALSE;
		else
			return TRUE;
	}
	else if (aType == poetry)
	{
		if (curType == verse)
			return FALSE;
		else
			return TRUE;
	}
	else
		return TRUE;
}

//void CAdapt_ItView::OnCaptureChanged(CWnd *pWnd)
//{
//	UpdateWindow();
//	CScrollView::OnCaptureChanged(pWnd);
//}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the TargetBox is in focus this handler enables the Edit Undo menu item, otherwise it disables 
/// the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditUndo(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxWindow* pWnd = wxWindow::FindFocus(); 
	if (pWnd == (wxWindow*)pApp->m_pTargetBox) 
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::OnEditUndo(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxWindow* pWnd = wxWindow::FindFocus();
	if (pWnd == (wxWindow*)pApp->m_pTargetBox)
	{
		if (pApp->m_pTargetBox->m_backspaceUndoStr.IsEmpty())
		{
			pApp->m_pTargetBox->Undo();
		}
		else
		{
			pApp->m_pTargetBox->OnEditUndo(event);
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If the KBs are in a ready state this handler enables the "Import to Knowledge Base..." item on the 
/// File menu, otherwise it disables the menu item.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateImportToKb(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

void CAdapt_ItView::OnImportToKb(wxCommandEvent& WXUNUSED(event))
// no changes needed for support of glossing, however, calls DoKBImport( ) and the latter
// has modifications for glossing versus adapting support
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxString message;
	message = _("Extend the knowledge base by importing dictionary records"); //IDS_IMPORT_DICT_RECORDS
	wxString filter;
	filter = _("Adapt It knowledge base import (*.txt)|*.txt|All Files (*.*)|*.*||"); //IDS_KB_IMPORT_FILTER
	wxString exportFilename = _T(""); // empty string
	wxString defaultDir;
	if (pApp->m_kbExportPath.IsEmpty())
	{
		defaultDir = pApp->m_curProjectPath;
	}
	else
	{
		defaultDir = pApp->m_kbExportPath;
	}

	wxFileDialog fileDlg(
		(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
		message,
		defaultDir,	// empty string causes it to use the current working directory (set above)
		exportFilename,	// default filename
		filter,
		wxOPEN); // | wxHIDE_READONLY); wxHIDE_READONLY deprecated in 2.6 - the checkbox is never shown
	fileDlg.Centre();

	// open as modal dialog
	int returnValue = fileDlg.ShowModal();
	if (returnValue == wxID_CANCEL)
	{
		return; // user Cancelled, or closed the dialog box
	}
	else // must be wxID_OK
	{
		wxString pathName;
		pathName = fileDlg.GetPath();

		// update m_kbExportPath
		wxString exportPath = fileDlg.GetPath();
		wxString name = fileDlg.GetFilename();
		int nameLen = name.Length();
		int pathLen = exportPath.Length();
		wxASSERT(nameLen > 0 && pathLen > 0);
		pApp->m_kbExportPath = exportPath.Left(pathLen - nameLen - 1);

		wxTextFile file;
		// Under wxWidgets wxTextFile actually reads the entire file into memory at the Open()
		// call. It is set up so we can treat it as a line oriented text file while in memory,
		// modifying it, then if not just reading it, we can write it back out to persistent
		// storage with a single call to Write().

		// open the config file for reading
		// wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
		// Note: Need to check if file exists, otherwise if Open fails wxWidgets' wxTextFile
		// conjures up its own error message to that fact which it issues in Idle time just
		// after it's no longer busy.
		bool bSuccessful;
		if (!::wxFileExists(pathName))
		{
			bSuccessful = FALSE;
		}
		else
		{
	#ifndef _UNICODE
			// ANSI
			bSuccessful = file.Open(pathName); // read ANSI file into memory
	#else
			// UNICODE
			bSuccessful = file.Open(pathName, wxConvUTF8); // read UNICODE file into memory
	#endif
		}
		if (!bSuccessful)
		{
			// assume there was no configuration file in existence yet, so nothing needs to be fixed
			wxMessageBox(_("Unable to open import file for reading."));
			return;
		}

		DoKBImport(pApp,&file);
	}
	return;
}

bool CAdapt_ItView::IsAlreadyInKB(int nWords,wxString key,wxString adaptation)
// Modified to work for either glossing or adapting KBs
{
	CTargetUnit* pTgtUnit = 0;

	// is there a targetunit for this key in the KB?
	bool bFound;
	if (gbIsGlossing)
		bFound = gpApp->m_pTargetBox->FindMatchInKB(GetKB(),1,key,pTgtUnit); // only check first map
	else // is adapting
		bFound = gpApp->m_pTargetBox->FindMatchInKB(GetKB(),nWords,key,pTgtUnit);
	if (!bFound)
		return FALSE;

	// check if there is a matching adaptation
	TranslationsList::Node* pos = pTgtUnit->m_pTranslations->GetFirst(); 
	while (pos != 0)
	{
		CRefString* pRefStr = (CRefString*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pRefStr);
		if (adaptation == pRefStr->m_translation)
			return TRUE; // adaptation, or gloss, matches this entry
	}
	return FALSE; // did not find a match
}

void CAdapt_ItView::DoKBImport(CAdapt_ItApp* pApp, wxTextFile* pFile)
{
	CKB* pKB;
	if (gbIsGlossing)
		pKB = pApp->m_pGlossingKB;
	else
		pKB = pApp->m_pKB;
	wxASSERT(pKB != NULL);
	CSourcePhrase* pSrcPhrase = new CSourcePhrase;
	// guarantee safe value for storage of contents to KB, or glossing KB
	if (gbIsGlossing)
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
	else
		pSrcPhrase->m_bHasKBEntry = FALSE;
	wxString key;
	key.Empty();
	wxString adaption; // use for actual adaptation, or gloss when glossing is ON
	adaption.Empty();
	wxString line;
	line.Empty();
	wxString ss1 = gSFescapechar;
	wxString keyMarker = ss1 + _T("lx");
	wxString adaptionMarker = ss1 + _T("ge");
	bool bKeyDefined = FALSE;
	int nOffset = -1;
	pApp->m_bSaveToKB = TRUE;

	// wx version: We are using wxTextFile which has already loaded its entire contents
	// into memory with the Open call in OnImportToKb() above. wxTextFile knows how
	// to handle Unicode data and the different end-of-line characters of the different
	// platforms.
	// Since the entire basic config file is now in memory we can read the information
	// by scanning its virtual lines.
	// In this routine we use the "direct access" method of retrieving the lines from
	// storage in memory, using GetLine(ct).
	int lineCount = pFile->GetLineCount();

	int ct;
	// whm 29Dec06 TODO: determine if we should call convertToLocalCharset() here below on line
	for (ct = 0; ct < lineCount; ct++)
	{
		line = pFile->GetLine(ct);
		// the data for each line is now in lineStr
		// is the line a m_key member?
		if (IsMember(line,keyMarker,nOffset) || nOffset >= 0)
		{
			// it is a valid key
			pSrcPhrase->m_key.Empty();
			if (gbIsGlossing)
			{
				pSrcPhrase->m_gloss.Empty();
				pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
				pSrcPhrase->m_nSrcWords = 1;
			}
			else
			{
				pSrcPhrase->m_adaption.Empty();
				pSrcPhrase->m_bHasKBEntry = FALSE;
				pSrcPhrase->m_nSrcWords = 1; // temp default value
			}
			bKeyDefined = TRUE;

			// extract the actual srcPhrase's m_key from the read in string, to set the key
			// variable
			int keyLen = line.Length();
			keyLen -= (4 + nOffset); // \lx followed by a space = 4 characters,
									 // nOffset takes care of any leading spaces
			if (keyLen > 0)
			{
				key = line.Right(keyLen);
				int nWordCount;
				if (gbIsGlossing)
					nWordCount = 1;
				else
					nWordCount = CountSourceWords(key);
				if (nWordCount == 0 || nWordCount > MAX_WORDS)
				{
					// error condition
					pSrcPhrase->m_nSrcWords = 1;
					key.Empty();
					bKeyDefined = FALSE;
				}
				else
				{
					// we have an acceptable key
					pSrcPhrase->m_nSrcWords = nWordCount;
					pSrcPhrase->m_key = key; // CountSourceWords will strip off leading or
											 // trailing spaces in key
				}
			}
			else
			{
				key.Empty();
				bKeyDefined = FALSE;
				pSrcPhrase->m_nSrcWords = 1;
			}
		}
		else
		{
			if (IsMember(line,adaptionMarker,nOffset) || nOffset >= 0)
			{
				// an adaptation member exists for this key, so get the KB updated with this
				// association provided a valid key was constructed
				if (bKeyDefined)
				{
					int adaptionLen = line.Length();
					adaptionLen -= (4 + nOffset); // \ge followed by a space = 4 characters,
												  // nOffset takes care of any leading spaces
					if (adaptionLen > 0)
					{
						adaption = line.Right(adaptionLen);
					}
					else
					{
						adaption.Empty();
					}

					// store the association in the KB, provided it is not already there
					if (gbIsGlossing)
					{
						if (!IsAlreadyInKB(1,key,adaption))
							// adaption parameter is assumed to be a gloss if glossing is ON
							StoreText(pKB,pSrcPhrase,adaption,TRUE);
					}
					else
					{
						if (!IsAlreadyInKB(pSrcPhrase->m_nSrcWords,key,adaption))
							StoreText(pKB,pSrcPhrase,adaption,TRUE);
					}

					// prepare for another adaptation (or gloss) for this key
					pSrcPhrase->m_adaption.Empty();
					adaption.Empty();
				}
			}
			else
			{
				// it's neither a key nor an adaption (or gloss),
				// so probably a blank line - just ignore it
				;
			}
		}
	}
	// process the last line here ???
	delete pSrcPhrase;
}

int CAdapt_ItView::CountSourceWords(wxString& rStr)
{
	int len = rStr.Length();
	if (len == 0)
		return 0;

	// remove any final spaces
	wxString reverse = rStr;
	reverse = MakeReverse(reverse);
	wxChar ch = _T(' ');
a:	int nFound = reverse.Find(ch);
	if (nFound == 0)
	{
		// found one, so remove it and iterate
		reverse = reverse.Right(len-1);
		len = reverse.Length();
		goto a;
	}
	else
	{
		// restore correct order
		reverse = MakeReverse(reverse);
	}

	// remove initial spaces, if any
	len = reverse.Length();
b:	nFound = reverse.Find(ch);
	if (nFound == 0)
	{
		// found one, so remove it and iterate
		reverse = reverse.Right(len-1);
		len = reverse.Length();
		goto b;
	}

	rStr = reverse; // updates string in the caller, so it has no trailing nor leading spaces

	if (rStr.IsEmpty())
	{
		// if it was only spaces, we have no valid string
		return 0;
	}

	// now parse words
	int count = 1;
	len = reverse.Length();
c:	nFound = reverse.Find(ch);
	if (nFound > 0)
	{
		// found a space, so must be an additional word
		count++; // count it

		// reduce reverse by one word
		reverse = reverse.Right(len-nFound-1);

		// there might be a sequence of spaces, so skip any leading spaces on the reduced string
d:		nFound = reverse.Find(ch);
		if (nFound == 0)
		{
			reverse = reverse.Right(len-1);
			len = reverse.Length();
			goto d;
		}
		len = reverse.Length();
		goto c;
	}
	else
		return count;
}

bool CAdapt_ItView::IsMember(wxString& rLine, wxString& rMarker, int& rOffset)
{
	if (rLine.IsEmpty())
	{
		rOffset = -1;
		return FALSE;
	}
	int nFound = rLine.Find(rMarker);
	rOffset = nFound;
	if (nFound == 0)
		return TRUE;
	else
		return FALSE;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If Vertical editing is in progress this handler disables the Back button and returns
/// immediately. Otherwise, if there are source phrases in the App's m_pSourcePhrases list, if the 
/// App's m_endIndex is within a valid range, and if the global gnOldSequNum does not equal -1, 
/// this handler enables the toolBar's "Jump Back" button, otherwise it disables the toolBar 
/// button.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonBack(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_endIndex < (int)gpApp->m_pSourcePhrases->GetCount() && gpApp->m_endIndex > 0)
	{
		if (gnOldSequNum == -1)
			event.Enable(FALSE);
		else
			event.Enable(TRUE);
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonBack(wxCommandEvent& WXUNUSED(event))
{
	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	if (gnOldSequNum == -1)
	{
		::wxBell();
		return;
	}

	// BEW added 28Sep05, to fix the following bug. It the globals below are not here reset,
	// and especially to the same value, then when we've been doing autoinseting at a location
	// somewhere and we click the back button to go to a very different location far away in
	// the document, any call to ScrollIntoView() will invoke its "smart" code -- that takes
	// the two globals below and if they are different, it will ask for a recalculation of the
	// pile pointers for the beginning and end of the last inserted set of adaptations -- and
	// these require GetPile() calls which, because that old location was miles away further away
	// in the document, a bundle advance and layout recalculation get done in order to get valid
	// pointers - and on return from ScrollIntoView() the layout is no longer where expected and
	// the active pointer has probably become invalid. Setting both globals to zero avoids all
	// and causes the legacy scrolling block to be used in ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	// there must be a valid earlier active location, so jump to there
	int nOldSequNum;
	if (gpApp->m_nActiveSequNum == -1)
	{
		// current location is at eof, so gnOldSequNum will need to be set to -1
		nOldSequNum = -1;
	}
	else
	{
		nOldSequNum = gpApp->m_nActiveSequNum; // location we are about to leave becomes new old one
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CPile* pPile = GetPile(gnOldSequNum);
	Jump(pApp,pPile->m_pSrcPhrase);

	// update its value from the saved one in the local variable
	gnOldSequNum = nOldSequNum;
}

/*
wxSize CAdapt_ItView::GetPaperSize(short dmPaperSize)
// see wingdi.h for source of these values; I first make all of them mm, then convert to
// thousandths of an inch, and return that rounded to nearest thousandth.
{
	wxSize size(0,0);
	float w; // width
	float l; // length
	switch(dmPaperSize)
	{
	case 0:
	case 1: // DMPAPER_LETTER  Letter 8 1/2 x 11 in  
	case 2: // DMPAPER_LETTERSMALL  Letter Small 8 1/2 x 11 in
	case 18: // DMPAPER_NOTE  Note 8 1/2 x 11 in
		w = (float)215.9;
		l = (float)279.4;
		break;
	case 3: // DMPAPER_TABLOID  Tabloid 11 x 17 in
		w = (float)279.4;
		l = (float)431.8;
		break;
	case 4: // DMPAPER_LEDGER Ledger 17 x 11 in
		w = (float)431.8;
		l = (float)279.4;
		break;
	case 5: // DMPAPER_LEGAL Legal 8 1/2 x 14 in
		w = (float)215.9;
		l = (float)355.6;
		break;
	case 6: // DMPAPER_STATEMENT  Statement 5 1/2 x 8 1/2 in
		w = (float)139.7;
		l = (float)215.9;
		break;
	case 7: // DMPAPER_EXECUTIVE Executive 7 1/4 x 10 1/2 in
		w = (float)184.2;
		l = (float)266.7;
		break;
	case 8: // DMPAPER_A3   A3 297 x 420 mm
		w = (float)297;
		l = (float)420;
		break;
	case 9: // DMPAPER_A4  A4 210 x 297 mm
	case 10: // DMPAPER_A4SMALL  A4 Small 210 x 297 mm
		w = (float)210;
		l = (float)297;
		break;
	case 11: // DMPAPER_A5  A5 148 x 210 mm
		w = (float)148;
		l = (float)210;
		break;
	case 12: // DMPAPER_B4  B4 (JIS) 250 x 354
		w = (float)250;
		l = (float)354;
		break;
	case 13: // DMPAPER_B5  B5 (JIS) 182 x 257 mm
		w = (float)182;
		l = (float)257;
		break;
	case 14: // DMPAPER_FOLIO  Folio 8 1/2 x 13 in
		w = (float)215.9;
		l = (float)330.2;
		break;
	case 15: // DMPAPER_QUARTO  Quarto 215 x 275 mm
		w = (float)215;
		l = (float)275;
		break;
	case 16: // DMPAPER_10X14     10x14 in
		w = (float)254;
		l = (float)355.6;
		break;
	case 17: // DMPAPER_11X17  11x17 in
		w = (float)279.4;
		l = (float)431.8;
		break;
	case 19: // DMPAPER_ENV_9   Envelope #9   3 7/8 x 8 7/8
		l = (float)98.4;
		w = (float)225.4;
		break;
	case 20: // DMPAPER_ENV_10  Envelope #10 4 1/8 x 9 1/2
		w = (float)241.3;
		l = (float)104.6;
		break;
	case 21: // DMPAPER_ENV_11   Envelope #11 4 1/2 x 10 3/8
		l = (float)114.3;
		w = (float)263.5;
		break;
	case 22: // DMPAPER_ENV_12  Envelope #12 4 \276 ?? x 11
		l = (float)120.6;
		w = (float)279.4;
		break;
	case 23: // DMPAPER_ENV_14  Envelope #14 5 x 11 1/2
		l = (float)127;
		w = (float)292.1;
		break;
	case 27: // DMPAPER_ENV_DL  Envelope DL 110 x 220mm
		l = (float)110;
		w = (float)220;
		break;
	case 28: // DMPAPER_ENV_C5  Envelope C5 162 x 229 mm
		l = (float)162;
		w = (float)229;
		break;
	case 29: // DMPAPER_ENV_C3  Envelope C3  324 x 458 mm
		l = (float)324;
		w = (float)458;
		break;
	case 30: // DMPAPER_ENV_C4   Envelope C4  229 x 324 mm
		l = (float)229;
		w = (float)324;
		break;
	case 31: // DMPAPER_ENV_C6   Envelope C6  114 x 162 mm
		l = (float)114;
		w = (float)162;
		break;
	case 32: // DMPAPER_ENV_C65  Envelope C65 114 x 229 mm
		l = (float)114;
		w = (float)229;
		break;
	case 33: // DMPAPER_ENV_B4   Envelope B4  250 x 353 mm
	case 42: // DMPAPER_ISO_B4  B4 (ISO) 250 x 353 mm
		l = (float)250;
		w = (float)353;
		break;
	case 34: // DMPAPER_ENV_B5   Envelope B5  176 x 250 mm
		l = (float)176;
		w = (float)250;
		break;
	case 35: // DMPAPER_ENV_B6   Envelope B6  176 x 125 mm
		l = (float)176;
		w = (float)125;
		break;
	case 36: // DMPAPER_ENV_ITALY   Envelope 110 x 230 mm
		l = (float)110;
		w = (float)230;
		break;
	case 37: // DMPAPER_ENV_MONARCH  Envelope Monarch 3.875 x 7.5 in
		l = (float)98.4;
		w = (float)190.5;
		break;
	case 38: // DMPAPER_ENV_PERSONAL  Envelope 3 5/8 x 6 1/2 in
		l = (float)92.1;
		w = (float)165.1;
		break;
	case 39: // DMPAPER_FANFOLD_US   US Std Fanfold 14 7/8 x 11 in
		w = (float)377.8;
		l = (float)279.4;
		break;
	case 40: // DMPAPER_FANFOLD_STD_GERMAN   German Std Fanfold 8 1/2 x 12 in
		w = (float)215.9;
		l = (float)304.8;
		break;
	case 41: // DMPAPER_FANFOLD_LGL_GERMAN  German Legal Fanfold 8 1/2 x 13 in
		w = (float)215.9;
		l = (float)330.2;
		break;
	case 43: // DMPAPER_JAPANESE_POSTCARD   Japanese Postcard 100 x 148 mm
		w = (float)100;
		l = (float)148;
		break;
	case 284: // CANON   101.6 X 152.4 mm - a size which comes with the BJC 2100SP printer
		w = (float)118;
		l = (float)214;
		break;
	// that's enough, the rest are most unlikely to be encountered (as are most of the above!)
	case 24: // DMPAPER_CSHEET       C size sheet -- no size given
	case 25: // DMPAPER_DSHEET       D size sheet -- no size given
	case 26: // DMPAPER_ESHEET       E size sheet -- no size given
	default: // make it A4
		w = (float)210.0;
		l = (float)297.0;
		break;
	}

	// convert to rounded thousandths of an inch
	size.x = (int)((w * 100.0) / 2.54);
	size.y = (int)((l * 100.0) / 2.54);
	return size;
}
*/

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If the active pile pointer is NULL or there are no source phrases in the App's m_pSourcePhrases
/// list, or the App's m_endIndex is not within a valid range, the toolBar's "View Translation or 
/// Glosses Elsewhere In The Document" button is disabled, otherwise it is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonEarlierTranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_curIndex <= (int)pApp->m_pSourcePhrases->GetCount() - 1 && pApp->m_curIndex >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonEarlierTranslation(wxCommandEvent& WXUNUSED(event))
{
	// check that the dialog is not currently open, if it is, delete it
	wxString saveSrc;
	saveSrc.Empty();
	wxString saveTgt; // for version 2.0 and onwards, this can double for either adaptation
					 // text or glossing text, depending on the gbIsGlossing flag
	saveTgt.Empty();
	if (gpApp->m_pEarlierTransDlg != NULL)
	{
		gpApp->m_pEarlierTransDlg->Destroy();
		gpApp->m_pEarlierTransDlg = NULL;
	}

	if (gpApp->m_pEarlierTransDlg == NULL)
	{
		gpApp->m_pEarlierTransDlg = new CEarlierTranslationDlg(gpApp->GetMainFrame());
		// don't use Create in wx dialogs

		// set default parameter values
		gpApp->m_pEarlierTransDlg->m_srcText = _T("");
		gpApp->m_pEarlierTransDlg->m_tgtText = _T("");
		gpApp->m_pEarlierTransDlg->m_strBeginChVerse = _T("");
		gpApp->m_pEarlierTransDlg->m_strEndChVerse = _T("");
		gpApp->m_pEarlierTransDlg->m_bIsVerseRange = FALSE;
		gpApp->m_pEarlierTransDlg->m_nChapter = 0;
		gpApp->m_pEarlierTransDlg->m_nVerse = 0;
		gpApp->m_pEarlierTransDlg->m_nVerseRangeEnd = 0;

		AdjustDialogPosition(gpApp->m_pEarlierTransDlg);
		gpApp->m_pEarlierTransDlg->Show(TRUE);
	}
	else
	{
		AdjustDialogPosition(gpApp->m_pEarlierTransDlg);
		gpApp->m_pEarlierTransDlg->Show(TRUE);
	}
}

void CAdapt_ItView::OnButtonNoAdapt(wxCommandEvent& event)
// Modified for version 2.0 and onwards which supports glossing
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	pApp->m_bForceAsk = FALSE; // ensure it's off
	CPile* pCurPile = pApp->m_pActivePile;

	// make sure the store will succeed, and if the pApp->m_targetPhrase has a gloss or adaptation
	// in the appropriate KB then remove it or reduce its reference count before we clear out
	// the contents of m_targetPhrase; but if a selection is current, then don't do the above, but
	// instead assume a merge is wanted first - so do the merge, and then make the <no adaptation>
	// button click apply to the merged phrase thereby produced. (Feature change requested by
	// Wolfgang Stradner, Oct 28 04)
	CRefString* pRefStr;
	if (pApp->m_selectionLine != -1 && pApp->m_selection.GetCount() > 1 && !gbIsGlossing)
	{
		// move the active location for restoration of the view to first cell of the selection, if not there already
		//int saveSequNum = ((CCell*)m_selection.GetHead())->m_pPile->m_pSrcPhrase->m_nSequNumber;
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = cpos->GetData();
		int saveSequNum = pCell->m_pPile->m_pSrcPhrase->m_nSequNumber;
		OnButtonMerge(event);
		RecalcLayout(pApp->m_pSourcePhrases,0,pApp->m_pBundle);
		pApp->m_pActivePile = GetPile(saveSequNum);
		pApp->m_pTargetBox->m_pActivePile = pApp->m_pActivePile;
		pCurPile = pApp->m_pActivePile;
	}
	else
	{
		if (gbIsGlossing)
		{
			pRefStr = GetRefString(pApp->m_pGlossingKB, 1,
									pApp->m_pActivePile->m_pSrcPhrase->m_key,pApp->m_targetPhrase);
			if (pRefStr == NULL && pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
									pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
			if (pRefStr != NULL)
				RemoveRefString(pRefStr, pApp->m_pActivePile->m_pSrcPhrase, 1);
		}
		else
		{
			pRefStr = GetRefString(pApp->m_pKB,pApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
									pApp->m_pActivePile->m_pSrcPhrase->m_key,pApp->m_targetPhrase);
			if (pRefStr == NULL && pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
									pApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
			if (pRefStr != NULL)
				RemoveRefString(pRefStr, pApp->m_pActivePile->m_pSrcPhrase,
												pApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords);
		}
	}

	pApp->m_targetPhrase.Empty(); // clear out the attribute on the view
	pApp->m_pTargetBox->SetValue(_T("")); // clear out the box too
	if (gbIsGlossing)
		pApp->m_pActivePile->m_pSrcPhrase->m_gloss.Empty(); // clear this one when glossing
	else
	{
		pApp->m_pActivePile->m_pSrcPhrase->m_adaption.Empty();  // clear these
		pApp->m_pActivePile->m_pSrcPhrase->m_targetStr.Empty(); // too
	}

	// the TRUE flag is required (ie. suppress empty adapt dlg) since it leads to the store
	// being automatically done - otherwise, no store would be done for the empty adaptation
	bool bOK;
	if (gbIsGlossing)
		bOK = StoreText(pApp->m_pGlossingKB,pCurPile->m_pSrcPhrase,pApp->m_targetPhrase,TRUE);
	else
		bOK = StoreText(pApp->m_pKB,pCurPile->m_pSrcPhrase,pApp->m_targetPhrase,TRUE);

	int nCurStripIndex = pCurPile->m_pStrip->m_nStripIndex;
	int sn = pCurPile->m_pSrcPhrase->m_nSequNumber;
	LayoutStrip(pApp->m_pSourcePhrases,nCurStripIndex,pApp->m_pBundle);
	pApp->m_pActivePile = GetPile(sn);
	wxASSERT(pApp->m_pActivePile);

	// remove any selection, but don't redraw, so need to do it without calling RemoveSelection()
	// because the layout's pointers are now not matched by those in m_selection.
	gnSelectionLine = -1;
	gnSelectionStartSequNum = -1;
	gnSelectionEndSequNum = -1;
	pApp->m_selectionLine = -1;
	pApp->m_pAnchor = NULL;
	if (pApp->m_selection.GetCount() > 0)
		pApp->m_selection.Clear();

	// recalc the box
	pApp->m_nStartChar = 0;
	pApp->m_nEndChar = 0;
	//pApp->m_targetBox.Destroy(); //m_targetBox.DestroyWindow();
	pApp->m_pTargetBox->SetValue(_T(""));
	pApp->m_curBoxWidth = RecalcPhraseBoxWidth(pApp->m_targetPhrase);
	pApp->m_nCurPileMinWidth = pApp->m_curBoxWidth;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nNavTextHeight,pApp->m_targetPhrase,
													pApp->m_nStartChar,pApp->m_nEndChar,pApp->m_pActivePile);
	else
		// wx Note: ResizeBox doesn't recreate the box; it just calls SetSize and causes it to be visible again
		ResizeBox(&pApp->m_ptCurBoxLocation,pApp->m_curBoxWidth,pApp->m_nTgtHeight,pApp->m_targetPhrase,
													pApp->m_nStartChar,pApp->m_nEndChar,pApp->m_pActivePile);
	Invalidate();
}

// whm added 14Aug06 as a temporary measure to prevent editing of source text when
// the selection contains any filtered information (BEW 15 Aug 06: it will probably be
// a permanent measure as source editing when there is filtered info would be hard to
// control since the editing could do anything and the filtered info be anything!)
bool CAdapt_ItView::IsFilteredInfoInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // let the caller have the burden of aborting the edit it the list is empty
	
	// BEW added next (two) lines 27Dec07 to only reject the attempt when filtered info is on non-first
	pSrcPhrase = (CSourcePhrase*)pos->GetData(); // allow filtered info on first in the list
	pos = pos->GetNext();

	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_markers.Find(filterMkr) != -1)
			return TRUE;
	}
	return FALSE;
}

bool CAdapt_ItView::IsFreeTranslationInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // let the caller have the burden of aborting the edit it the list is empty
	
	// BEW added next (two) lines 27Dec07 to only reject the attempt when starting of a free trans is not
	// on the first CSourcePhrase instance in the selection
	pSrcPhrase = (CSourcePhrase*)pos->GetData(); // allow filtered info on first in the list
	pos = pos->GetNext();

	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		// BEW changed 27Dec07, see above: if (pSrcPhrase->m_bHasFreeTrans)
		if (pSrcPhrase->m_bStartFreeTrans)
			return TRUE;
	}
	return FALSE;
}

/* deprecated 11Apr08
// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Edit Source Text..." item on the Edit menu is disabled if the application is in Free
/// Translation mode, or there is no source text selected, otherwise the menu item is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditSourceText(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	// enable only if some source text is selected
	if (!gbIsGlossing && (pApp->m_selectionLine > -1 && pApp->m_selectionLine < 2))
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}
*/

/* depricated 11Apr08
void CAdapt_ItView::OnEditSourceText(wxCommandEvent& event)
// This function is not available when glossing is ON.
{
	// Since the Edit Source Text menu item has an accelerator table hot key (CTRL-Q see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	// On Windows, the accelerator key doesn't appear to call the handler for a disabled menu item, but
	// I'll leave the following code here in case it works differently on other platforms.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_EDIT_SOURCE_TEXT))
	{
		::wxBell();
		return;
	}

	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),_T(""),wxICON_INFORMATION);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	SPList* pList = new SPList; // list of the selected CSourcePhrase objects
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;
	int nStartingStripIndex;
	gnOldMaxIndex = gpApp->m_maxIndex; // store the old value, UpdateSourceTextCopy() needs to use it unchanged
	pApp->m_FilterStatusMap.clear(); // BEW added 16Jun05

	// determine the active sequ number, so we can determine whether or not the active location
	// lies within the selection (if its not in the selection, we will need to recreate the phrase
	// box at the former active location when done - be careful, because if the active location
	// lies after the selection and the selection contains null src phrases or merged phrases,
	// then the value of nFormerActiveSequNum will need to be updated as we remove null src
	// phrases and / or unmerge merged phrases)
	if (gpApp->m_pActivePile == NULL)
	{
		// must be at eof with no phrase box defined; so we won't allow editing at this
		// point (for example, there is no valid active sequence number, etc.) The phrase box
		// first must be placed at one of the piles before editing can be done.
		::wxBell(); 
		RemoveSelection();
		return;
	}
	int nSaveActiveSequNum = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;

	CSourcePhrase* pSrcPhrase;
	wxString strAdapt; // accumulates the existing adaptation text for the selection
	// (now, for fourth line, we will use strAdapt to accumulate that line, rather than third
	// line text)
	strAdapt.Empty();

	wxString str; // a temporary storage string
	str.Empty();
	wxString str2; // second temporary storage string
	str2.Empty();
	wxString strSource; // the source text which is to be retranslated (now line 1, not line 2)
	strSource.Empty();
	CCellList::Node* pos = pApp->m_selection.GetFirst(); //POSITION pos = pApp->m_selection.GetHeadPosition(); //POSITION pos = m_selection.GetHeadPosition();
	int nCount = pApp->m_selection.GetCount(); // number of src phrase instances in the selection
										 // (this value will change (become less or greater)
										 // depending on how many unmerges and deletion of null
										 // sourcephrases are done below)

	CCell* pCell = pos->GetData();
	CPile* pPile = pCell->m_pPile; // get the pile first in selection
	pos = pos->GetNext();
	pStartingPile = pPile; // need this for later when we look up the strip which first pile is in
						   // prior to calling RecalcLayout
	CSourceBundle* pBundle = pStartingPile->m_pBundle; // needed for recalculating layout
	nStartingStripIndex = pStartingPile->m_pStrip->m_nStripIndex;
	pSrcPhrase = pPile->m_pSrcPhrase;
	TextType myTextType = pSrcPhrase->m_curTextType; // so we can use it on any extra inserted
													 // sourcephrases

	int nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything depends
												  // on this - its the first in the sublist list

	// get a list of the selected CSourcePhrase instances (some might not be minimal ones
	// so if this is the case we must later restore them to minimal ones, and some might be null,
	// so these must be later eliminated after their text, if any, is preserved & any punctuation
	// transferred) and also accumulate the words in the source and target text into string
	// variables
	GetSelectedSourcePhraseInstances(pList, strSource, strAdapt);

	// check that the selection is text of a single type - if it isn't, then tell the user and
	// abandon the operation
	bool bConstType = IsConstantType(pList);
	if (!bConstType)
	{
		//IDS_TYPE_CHANGE_ERR
		wxMessageBox(_("Sorry, the selection contains text of more than one type. Select only one text type at a time. The operation will be ignored."),_T(""), wxICON_EXCLAMATION);
		RemoveSelection();
		delete pList;
		gpApp->m_pTargetBox->SetFocus();
		gpApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar); //,TRUE); // no scroll
		gnStart = pApp->m_nStartChar;
		gnEnd = pApp->m_nEndChar;
		Invalidate();
		return;
	}

	// check for a retranslation in the selection, and abort the edit operation if
	// there is one
	if (IsRetranslationInSelection(pList))
	{
		//IDS_NO_RETRANSLATION_IN_SEL
		wxMessageBox(_("Sorry, but this operation is not permitted when the selection contains any part of a retranslation. First remove the retranslation and then try again."),_T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		RemoveSelection();
		gpApp->m_pTargetBox->SetFocus();
		gpApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
		gnStart = pApp->m_nStartChar;
		gnEnd = pApp->m_nEndChar;
		Invalidate();
		return;
	}

	// check for one or more free translations defined on this selection range - if there are any
	// sourcephrases in pList with the m_bHasFreeTrans flag set TRUE, then we won't allow the edit
	// to be done until all instances in the selection range have this flag cleared - which can
	// be done by entering free translation mode and there using the Remove button to remove them.
	// BEW changed 27Dec07 so that IsFreeTranslationInSelection() ignores the first CSourcePhrase
	// instance in the selection (storage on that one can be handled reliable)
	if (IsFreeTranslationInSelection(pList))
	{
		//IDS_UNWANTED_FREE_TRANS_IN_SELECTION
		wxMessageBox(_("Sorry, editing the source text is not permitted when there is a free translation anywhere within the selected text.\nFirst remove the free translations in the selection range."),_T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		RemoveSelection();
		gpApp->m_pTargetBox->SetFocus();
		gpApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar); //,TRUE); // no scroll
		gnStart = pApp->m_nStartChar;
		gnEnd = pApp->m_nEndChar;
		Invalidate();
		return;
	}

	// BEW changed 27Dec07 so that IsFilteredInfoInSelection() ignores the first CSourcePhrase
	// instance in the selection (storage on that one can be handled reliable)
	if (IsFilteredInfoInSelection(pList))
	{
		//IDS_NO_EDIT_SRC_WHEN_FILTERED_INFO
		wxMessageBox(_("Editing the source text is not permitted when there is a filtered information within the selection."),_T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		RemoveSelection();
		gpApp->m_pTargetBox->SetFocus();
		gpApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar); 
		gnStart = pApp->m_nStartChar;
		gnEnd = pApp->m_nEndChar;
		Invalidate();
		return;
	}

	// copy the list to a 2nd list for saving the original state, in case the user hits the Cancel
	// button in the dialog, and save the old sequ num value for the active location; we don't save
	// copies of the pointers, but instead use the copy constructor to make fresh copies of the
	// original selection's source phrases - but note that the copy constructor (and also operator
	// =) only copies pointers for any CSourcePhrases in each source phrase's m_pSavedWords sublist
	// - which has implications for below (in particular, when deleting the copied list, we must
	// not delete in the sublists, but only remove the pointers, otherwise the originals will have
	// hanging pointers)
	SPList* pSaveList = new SPList;
	CopySourcePhraseList(pList,pSaveList);
	int nOldSaveActiveSequNum = nSaveActiveSequNum;

	// BEW added 27Dec07: now that the old list is saved, we must check for a Note having been stored
	// on the first of the CSourcePhrase instances in the selection (notes are always filtered), because
	// the earlier code properly handles the 3 flags for dealing with free translations if the start
	// of the selection is edited (say, to add extra words at the start, etc), but the m_bHasNote flag
	// can get lost. So we check for it here, and if present we set the flag on the first instance in
	// the new sublist. (We don't have to bother about a Note later on, because we our code rejects
	// any attempt to edit the source across an embedded Note.) We set or clear a local BOOL flag, since
	// we don't have a new list until after the dialog returns. The new flag is used in ReconcileLists()
	// to which it is added as a new parameter at the end of the parameter list.
	bool bSetNoteFlagLaterOn = FALSE;
	SPList::Node* xpos = pList->GetFirst();
	CSourcePhrase* pOldFirstSrcPhrase = xpos->GetData();
	if (pOldFirstSrcPhrase->m_bHasNote)
	{
		bSetNoteFlagLaterOn = TRUE;
	}

	// update to keep the KB properly updated, provided the active location is not in the
	// selection, but if it is, then we don't update because the active location's source word
	// may no longer exist after the user finishes editing the source. The box, and
	// gpApp->m_targetPhrase, will be reconstituted later appropriately, depending on what the user does
	// in the edit. For versions later than 1.2.9, the code below is different. We need an
	// unconditional store, because if outside the selection, we must update as the above
	// explanation explains; but for an active location within the selection, we still must
	// update because (a) there is one refString removal already by virtue of the fact that it
	// is the active location (ie. the box is there), and (b) a further refString removal will
	// be done in the UnmergeMergersInSublist() call, and this means the refString for the active
	// location gets removed twice unless we prevent it (it only should be removed once). So by
	// doing an unconditional store, we bump the refCount at the active loc, and then the
	// UnmergeMergersInSublist() call can decrement it again, keeping the count correct. We need
	// to do this also in OnButtonRetranslation()
	if (gpApp->m_pActivePile != NULL)
	{
		// the active location is not within the retranslation section, so update KB for
		// this location
		MakeLineFourString(gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
		RemovePunctuation(pDoc,&gpApp->m_targetPhrase,1); // from tgt
		gbInhibitLine4StrCall = TRUE;
		bool bOK = StoreText(pApp->m_pKB,gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
		gbInhibitLine4StrCall = FALSE;
		if (!bOK)
			return; // can't proceed until a valid adaption (which could be null) is supplied
					// for the former active pile's srcPhrase
		else
		{
			int nFormerStrip = gpApp->m_pActivePile->m_pStrip->m_nStripIndex;
			int nCurStripIndex = pStartingPile->m_pStrip->m_nStripIndex;
			if (nCurStripIndex != nFormerStrip)
			{
				// layout the former strip too, if it is not the current one
				LayoutStrip(pApp->m_pSourcePhrases,nFormerStrip,pApp->m_pBundle);
				Invalidate();
			}
		}
	}
	gpApp->m_targetPhrase.Empty(); // empty gpApp->m_targetPhrase; the box will probably be built elsewhere
							// after editing
	if (gpApp->m_pTargetBox != NULL) 
	{
		gpApp->m_pTargetBox->SetValue(gpApp->m_targetPhrase);
	}

	// bActiveLocWithinSelection and bActiveLocAfterSelection were required for retranslations,
	// but we don't make use of them; however since RemoveNullSrcPhraseFromLists() is as used
	// for retranslations and these booleans are in its parameter list, we must retain them here
	//int nEndSequNum = ((CSourcePhrase*)pList->GetTail())->m_nSequNumber;
	// do above line in two parts below:
	SPList::Node* spos = pList->GetLast();
	int nEndSequNum = spos->GetData()->m_nSequNumber;
	bool bActiveLocWithinSelection = FALSE;
	if (nSaveActiveSequNum >= nSaveSequNum && nSaveActiveSequNum <= nEndSequNum)
		bActiveLocWithinSelection = TRUE;
	bool bActiveLocAfterSelection = FALSE;
	if (nSaveActiveSequNum > nEndSequNum)
		bActiveLocAfterSelection = TRUE;

	// check for any null source phrases in the selection, and delete any found from both the
	// temporary list (pList), and from the original source phrases list on the app (see above)
	while (IsNullSrcPhraseInSelection(pList))
	{
		RemoveNullSrcPhraseFromLists(pList,pSrcPhrases,gpApp->m_endIndex,gpApp->m_upperIndex,gpApp->m_maxIndex,nCount,
										nEndSequNum,bActiveLocAfterSelection,nSaveActiveSequNum);
	}

	// at this point pList does not contain any null source phrases, and we have accumulated any
	// adaptations already typed into strAdapt. However, we might have merged phrases in pList to
	// be unmerged, and we have not yet removed the translation for each pSrcPhrase in pList from
	// the KB, so we must do those things next. Here, the final FALSE value makes m_bRetranslation
	// be cleared to FALSE for each sourcephrase, and the TRUE value asks that the pList passed
	// in be updated too, not just the doc's main list
	UnmergeMergersInSublist(pList,pSrcPhrases,nCount,
						nEndSequNum,bActiveLocAfterSelection,nSaveActiveSequNum,FALSE,TRUE);

	// now we can work out where to place the phrase box on exit from this function - it is
	// currently the nSaveActiveSequNum value, unless the active location was within the
	// selection, in which case we must make the active location the first pile after the
	// selection - but if that location does not exist, then make it the last pile preceding
	// the selection
	if (bActiveLocWithinSelection)
	{
		nSaveActiveSequNum = nEndSequNum + 1;

		// make it an earlier location if this location does not exist
		if (nSaveActiveSequNum > gpApp->m_maxIndex)
			nSaveActiveSequNum = nSaveSequNum - 1; // immediately before first pile of selection
	}

	// need to clobber the selection here, so the selection globals will be set to -1, otherwise
	// RecalcLayout will fail at its RestoreSelection() call
	RemoveSelection();

	// we must have a valid layout, so we have to recalculate it before we go any further,
	// because if preceding code unmerged formerly merged phrases, or if null phrases were deleted,
	// then the layout's pointers will be clobbered, and then if we move the dialog about to be put
	// up, accesses to Draw() for the cells, piles & strips will fail.
	RecalcLayout(pSrcPhrases,0,pBundle);
	gpApp->m_pActivePile = GetPile(nSaveActiveSequNum); // to get a valid one (temporarily, while
												 // coding this function)

	// create the edit source text dialog
	CEditSourceTextDlg dlg(pApp->GetMainFrame());
	dlg.Centre();

	// initialize the edit boxes
	dlg.m_strOldSourceText = strSource;
	dlg.m_strNewSourceText = strSource;
	dlg.m_strOldTranslationText = strAdapt;
	wxString precedingSrc;
	precedingSrc.Empty();
	wxString followingSrc;
	followingSrc.Empty();
	wxString precedingTgt;
	precedingTgt.Empty();
	wxString followingTgt;
	followingTgt.Empty();
	// we don't need to use the tgt ones in the following call
	GetContext(nSaveSequNum,nEndSequNum,precedingSrc,followingSrc,precedingTgt,followingTgt);
	dlg.m_preContext = precedingSrc;
	dlg.m_follContext = followingSrc;

	// Since EditSourceTextDlg is modal, disable Update UI handling while it is being shown
	//wxUpdateUIEvent::SetMode(wxUPDATE_UI_PROCESS_SPECIFIED);
	// put up the Edit Source Text dialog's window
	if (dlg.ShowModal() == wxID_OK)
	{
		// get the checkbox value for forcing open the transfer markers dialog, set the global
		gbForceOpenMarkerTransferDialog = FALSE; // default
		if (dlg.m_bEditMarkersWanted)
			gbForceOpenMarkerTransferDialog = TRUE;

		// we need a boolean to tell us when we must delay removing CSourcePhrase instances in
		// the app's list, (removal is needed when the new source phrase text is shorter than
		// the premodified selected text) because we have to reconcile the contents of the
		// sourcephrases pointed to by pList (these are the old ones, as modified after
		// unmergers done and removal of null source phrases) and the list pNewSrcPhrases
		// which points to the new ones on the heap; we have to get things like markers off
		// the pList elements, and relocate them on the new list - but in actual fact, we will
		// do it all on the app's list, so we can't do any removals from that list until
		// all the attributes of the sourcephrases are properly built, so a flag is needed to
		// tell us to delay. This is pretty tricky stuff!
		bool bDelayRemovals = FALSE;

		SPList* pNewSrcPhrasesList = new SPList;
		wxASSERT(pNewSrcPhrasesList != NULL);
		wxString strNewSrcText = dlg.m_strNewSourceText;
		int nNewCount = 0; // number of CSourcePhrase instances to be returned from the
						   // tokenization operation

		// tokenize the edited source text into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key and m_nSequNumber are set); nSaveSequNum is the
		// absolute sequence number for first source phrase in the sublist - it is used to define
		// the starting sequence number to be stored on the first element of the sublist, and
		// higher numbers on succeeding ones
		nNewCount = TokenizeTextString(pNewSrcPhrasesList,strNewSrcText,nSaveSequNum);

		// get the text type correct for the list contents
		SPList::Node* pos = pNewSrcPhrasesList->GetFirst();
		while (pos != 0)
		{
			CSourcePhrase* pSrcPh = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			pSrcPh->m_curTextType = myTextType;
		}

		// we must have a valid layout, so we have to recalculate it before we go any further,
		// because if preceding code unmerged formerly merged phrases, or if null phrases were
		// deleted, then the layout's pointers will be clobbered
		RecalcLayout(pSrcPhrases,0,pBundle);

		// get a new valid starting pile pointer, and gpApp->m_nActiveSequNum updated, etc
		pStartingPile = GetPile(nSaveSequNum);
		wxASSERT(pStartingPile != NULL);

		// set the active location - which for an edit operation on source phrases, must be the
		// first of the new source phrase instances
		gpApp->m_nActiveSequNum = nSaveSequNum; // to ensure any call to InsertNullSrcPhrase() will work
										 // right

		// get the globals set up which the dialogs will want to access
		gpOldSrcPhraseList = pList;
		gpNewSrcPhraseList = pNewSrcPhrasesList;
		gnCount = nCount;
		gnNewCount = nNewCount;

		// determine if we need extra or fewer source phrases, get the right amount needed into
		// the list
		PadOrShortenAtEnd(pSrcPhrases,nSaveSequNum,nEndSequNum,nNewCount,nCount,
																	myTextType,bDelayRemovals);

		// reconcile the two lists, pList and pNewSrcPhrasesList, transferring any standard format
		// markers and punctuation to the appropriate attributes of each source phrase - the user
		// may need to be asked by a dialog where to locate markers in the new string; and if
		// bDelayRemovals is TRUE, then after the transferals are done, the unwanted sourcephrases
		// at the end can be removed and the document's sequence numbers updated.
		gpPrecSrcPhrase = 0; // clear the globals
		gpFollSrcPhrase = 0;
		if (nSaveSequNum > 0)
		{
			// set the global pointer to the preceding sourcephrase, for use in AnalyseMarkers()
			// call
			SPList::Node* p = pSrcPhrases->Item(nSaveSequNum - 1); // the POSITION immediately
											// preceding the first element of gpOldSrcPhrasesList
			wxASSERT(p != 0);
			gpPrecSrcPhrase = (CSourcePhrase*)p->GetData();
			wxASSERT(gpPrecSrcPhrase != NULL);
		}

		// now the one following the end of the sublist
		int nAfter = nSaveSequNum + nCount;

		// if the user's editing resulted in more sourcephrases than earlier, then the insertions
		// will have made the "after" one move down, so check and adjust the index value if
		// necessary
		if (nNewCount > nCount)
			nAfter += nNewCount - nCount;

		// set the pointer only provided there is a valid sourcephrase following, if not,
		// leave it zero
		if (nAfter <= gpApp->m_maxIndex)
		{
			SPList::Node* p = pSrcPhrases->Item(nAfter);
			wxASSERT(p != 0);
			gpFollSrcPhrase = (CSourcePhrase*)p->GetData(); 
			wxASSERT(gpFollSrcPhrase != NULL); 
		}

		// set the doc's m_curChapter string, because it is left at the highest value encountered
		// during the parse of the input text (with colon following it), and since our selection
		// might have a verse number before the chapter number, or no chapter number at all, in
		// either of those cases we would have a wrong n:m value being set
		pApp->m_curChapter = _T("0:");
		if (gpPrecSrcPhrase != 0) // we can assume the == 0 case will take care of itself
								  // (ie. \c precedes \v)
		{
			// get chapter and verse
			wxString cv = GetChapterAndVerse(gpPrecSrcPhrase);
			if (cv.GetChar(0) == _T('0'))
			{
				// there are no chapter numbers, so leave the default zero at the start to
				// flag this fact
				;
			}
			else
			{
				// remove verse numbers from n:m until only n: remains
				int offset = cv.Find(_T(':'));
				if (offset != -1)
				{
					// found it
					wxString left = cv.Left(offset + 1);
					pApp->m_curChapter = left;
				}
			}
		}

		// whm note: ReconcileLists below will call the TransferMarkersDlg
		// BEW 27Dec07: added bSetNoteFlagLaterOn parameter so that m_bHasNote flag can be transferred
		// correctly if it was set on the first CSourcePhrase instance of the selection
		bool bOK = ReconcileLists(pList,pNewSrcPhrasesList, nSaveSequNum,nCount,nNewCount,
										bDelayRemovals,bSetNoteFlagLaterOn);
		if (!bOK)
			goto a; // user cancelled the dialog for transferral of standard format markers,
					// so abort the operation

		// do the transfer of the finally completed sourcephrase instances back to the
		// document's list
		TransferCompletedSrcPhrases(pNewSrcPhrasesList,nSaveSequNum);

		// remove unneeded CSourcePhrase instances from the document's m_pSourcePhrases list, when
		// the edited source phrase text has fewer words than the formerly selected source phrase
		// text
		if (nNewCount < nCount && bDelayRemovals)
		{
			RemoveUnwantedSrcPhrasesInDocList(nSaveSequNum,nNewCount,nCount);
		}

//		// BEW removed 31Jan01 because the global's value is not always reliable
//a:		gLastSrcPhrasePos = NULL; // in case main list is different, the global POSITION's
//			// srcPhrase may have been deleted; if so, GetSrcPhrasePos() would crash; so
//			// the NULL forces the latter to search from the start of the list delete the
//			// temporary list and delete the pointers to the CSourcePhrase instances on the heap
//
a:		DeleteTempList(pNewSrcPhrasesList);
		if (!bOK)
		{
			goto b;
		}

		// remove the unused saved original source phrase copies & their list too
		// this pSaveList list will possibly have copies which contain non-empty sublists,
		// especially in m_pSavedWords, and the source phrases pointed to by that list will only
		// have had their pointers copied, so we must not delete those pointers, otherwise the
		// originals will contain hanging pointers & we'll  crash if we were to retry the
		// retranslation on the same data
		DeleteSavedSrcPhraseSublist(pSaveList);

		// do any TextType propagation that remains to be done - use the globals returned from
		// CTransferMarkersDlg
		if (gbPropagationNeeded && gpFollSrcPhrase != NULL)
		{
			int sequNum = gpFollSrcPhrase->m_nSequNumber;
			wxASSERT(gpFollSrcPhrase != 0);
			SPList::Node* pos = pSrcPhrases->Item(sequNum);
			while (pos != 0)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_bFirstOfType)
					break; // we are done
				else
				{
					pSrcPhrase->m_curTextType = gPropagationType;
					pSrcPhrase->m_bSpecialText = gbSpecialText;
				}
			}
		}
		gbPropagationNeeded = FALSE; // turn it back off, for default

		// BEW added next block 16Jun05
		// handle any filtering needed because one or more markers were edited to be markers
		// which should be filtered out
		// if any filtering is needed, we check for it and if so, get it done here
		if (pApp->m_FilterStatusMap.size() > 0)
		{
			// there is at least one entry, maybe more, which needs to be filtered
			// (code below plagiarized from app's DoUsfmFilterChanges()function)
			int activeSequNum = gpApp->m_nActiveSequNum;
			if (gpApp->m_nActiveSequNum < 0)
			{
				// must not have data yet, or we are at EOF and so no pile is currently active
				activeSequNum = -1;
			}
			else
			{
				// we are somewhere in the midst of the data, so a pile will be active
				activeSequNum = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;
				pApp->m_curIndex = activeSequNum;

				// remove any current selection, as we can't be sure of any pointers
				// depending on what user may choose to alter
				RemoveSelection();
			}

			// as in DoPunctuationChanges, we need to be sure we can recreate the phrase box safely
			// so changes will be needed here; however, this is done at a lower level within
			// RetokenizeText(), and typically the box location is preserved, so it makes sense to retain
			// its contents for redisplay when unfiltering & filtering has completed -- however, if the
			// phrase box was located within a stretch which got filtered out, then it's location will be
			// changed to somewhere close by (the app tries to put it at the first safe location following
			// where its earlier location was destroyed by the filtering) - and restoring the old contents
			// will in that case typically be wrong. We'll do it nevertheless, since the user will immediately
			// see it and can manually edit the contents to what they should be before continuing to adapt.
			wxString strSavePhraseBox = gpApp->m_targetPhrase;

			// now do the reparse

			int nNewSrcPhraseCount = pDoc->RetokenizeText(	FALSE,  // FALSE = punctuation not changed here
															TRUE,	// bFilterChangeInDoc
															FALSE); // FALSE = sfm set change not flagged here
			gpApp->m_maxIndex = nNewSrcPhraseCount - 1; // update (this is cosmetic, actually we have to have
												 // updated this index progressively as we retokenized)
			gpApp->m_targetPhrase = strSavePhraseBox; // will have the correct text, unless the phrase box was
											   // located within material just filtered out (see above)
		}
	}
	else
	{
		// *********************** user cancelled, so restore initial state *********************
b:		int nCurCount = nEndSequNum - nSaveSequNum + 1; // what the selection now numbers,
														// after unmerge etc.
		wxASSERT(pSaveList != NULL);
		int nOldCount = pSaveList->GetCount();
		wxASSERT(nOldCount >0);
		int nExtras = nCurCount - nOldCount; // needed for adjusting indices
		wxASSERT(nExtras >= 0); // cannot be negative

		// this list's source phrases have not had their KB refString entries removed/count
		// decremented, whichever is required, so we must do so now - otherwise, if they are
		// storing some adaptions, when we try to re-store them in the KB, the StoreAdapation
		// assert at 1st line will trip.
		ClearSublistKBEntries(pSaveList);

		// insert the original (saved) source phrases after the nEndSequNum one
		InsertSublistAfter(pSrcPhrases,pSaveList,nEndSequNum);

		// now remove the unwanted ones - be careful, some of these single-word ones will point
		// to memory that any merged source phrases in the saved list will point to in their
		// m_pSavedWords sublists, so don't delete the memory in the latter sublists,
		// just remove the pointers!
		RemoveUnwantedSourcePhraseInstancesInRestoredList(pSrcPhrases,nCurCount,
																nSaveSequNum,pSaveList);

		// now fix the indices, we can assume nExtras is either 0 or positive
		gpApp->m_endIndex -= nExtras;
		gpApp->m_upperIndex -= nExtras;
		gpApp->m_maxIndex -= nExtras;

		// renumber the sequence numbers
		UpdateSequNumbers(0);

		// remove the pointers in the saved list, and delete the list, but leave the instances
		// undeleted since they are now pointed at by elements in the pSrcPhrases list
		if (pSaveList->GetCount() > 0)
		{
			pSaveList->Clear();
		}
		delete pSaveList; // don't leak memory

		// for cancellation of source phrase editing, we can safely put the phrase box back
		// where it was
		gpApp->m_nActiveSequNum = nOldSaveActiveSequNum;
	}

	// delete the temporary list after removing its pointer copies (copy constructor was not
	// used on this list, so removal of pointers is sufficient)
	pList->Clear();
	delete pList;

	// recalculate the layout from the first strip in the selection, to force the text to change
	// color
	RecalcLayout(pSrcPhrases,0,pBundle); // can fail if the recalculated bundle has fewer strips
										 // than nStartingStripIndex, so use 0 to be always safe
	// get a new valid active pile pointer
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
	wxASSERT(pSrcPhrase != NULL);

	// determine the text to be shown, if any, in the target box when it is recreated
	wxString str3;
	RestoreTargetBoxText(pSrcPhrase,str3); // for m_targetStr contents, get it from the active
										   // loc's pSrcPhrase doing a Lookup etc.

	// at this point, the sourcephrase's m_bHasKBEntry flag will be the default (FALSE) value,
	// so we do not need to do any KB adjustments (such as calling GetRefString and then
	// RemoveRefString); so we just go ahead and set up the phrasebox according to what was
	// restored by the RestoreTargetBoxText call
	gpApp->m_targetPhrase = str3; // in our 4-line version, the Phrase Box can have punctuation as well
						   // as text
	gpApp->m_pTargetBox->SetValue(str3);
	gpApp->m_pTargetBox->SetSelection(-1,-1); // no scroll -1,-1 selects all
	gnStart = 0;
	gnEnd = -1;

	// layout again, so that the targetBox won't encroach on the next cell's adaption text
	// (can't just layout the strip, because if the text is long then source phrases get pushed
	// off into limbo and we get access violation & null pointer returned in the GetPile call)
	// RecalcLayout can fail if the recalculated bundle
	// has fewer strips than nStartingStripIndex, so use 0 to be always safe
	RecalcLayout(pSrcPhrases,0,pBundle);

	// get a new valid active pile pointer
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);

	// create the phraseBox at the active pile
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;
	RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);

	// remove selection and update the display
	RemoveSelection();
	Invalidate();

	// ensure respect for boundaries is turned back on
	if (!gpApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(event);
	gbInsertingWithinFootnote = FALSE; // restore default (it can be set in IsConstantType( ) )
}
*/

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Edit Source Text..." item on the Edit menu is disabled if any of the following conditions
/// is TRUE: Vertical Editing is in progress, the m_pActivePile is NULL, the application is in Free
/// Translation mode. Otherwise it is enabled only if some source text selected.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditSourceText(wxUpdateUIEvent& event) 
{
	// BEW updated, 11Apr08, to remove the "not when in free translation mode" modality
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// added test for no phrase box currently defined (this can happen when user has advanced
	// the box past the last pile within the document) -- we'll not allow editing of the source
	// when the app is in this state, as there is no valid current sequence number (formerly,
	// this test was in the edit source text command handler, but is more appropriate here)
	if (gpApp->m_pActivePile == NULL)
	{
		// The phrase box must first must be placed at one of the piles before the edit is enabled
		event.Enable(FALSE);
		return;
	}

	// currently, we won't allow it when free translation mode is turned on; but when vertical
	// editing as a multi-step process is implemented, we can remove this constraint
	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}

	// enable only if some source text is selected
	// if (!gbIsGlossing && (m_selectionLine > -1 && m_selectionLine < 2)) // the old constraint
	// the new constraint also allows source text editing when glossing mode is turned on
	if (gpApp->m_selectionLine > -1 && gpApp->m_selectionLine < 2)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);	
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there were no internal errors; FALSE if something went belly up requiring 
///             the edit to be aborted (but the app continues, the document isn't changed)
/// \param      pSrcPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		<->	(input)reference to the sequence number for the first pile 
///                                 in the user's selection; (output) the sequence number value 
///                                 for the first pile after any extension leftwards was done
/// \param      nEndingSN		<->	(input)reference to the sequence number for the last pile 
///                                 in the user's selection; (output) the sequence number value 
///                                 for the last pile after any extension rightwards was done
/// \param      bIsExtended		<-	reference to BOOL indicating whether extension was required 
///                                 and done (TRUE) or not required and not done (FALSE)
/// \remarks
/// Called from: The View's OnEditSourceText().
/// Automatically extends the user's selection of the source text to be edited where necessary to 
/// include source text material (and filtered/hidden material) that should be dealt with when 
/// editing the source text. 
/// We save processing time by not bothering to actually use the m_selection list; extension only
/// is required if we have a retranslation in or partly in the span of the user's manual selection,
/// and we can easily test for that by looking at flag values on CSourcePhrase instances. The
/// caller only needs to know what the final sequence numbers of the span for editing are.
/// "Leftwards" in this function is to be interpretted as "to lower sequence numbers", & so if we
/// are dealing with a right-to-left language data, it would be rightwards to the user.
// //////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ExtendEditSourceTextSelection(SPList* pSrcPhrases, int& nStartingSN, int& nEndingSN,
												  bool& bIsExtended)
{
	// 12Apr08, BEW added this function
	bIsExtended = FALSE;
	int nIteratorSN = 0; // use when scanning forwards or backwards
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN); //POSITION pos = pSrcPhrases->FindIndex(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		// whm Note: The following error message does not need to be available for localization
		wxMessageBox(_T("FindIndex() failed in ExtendEditSourceTextSelection(), pos value is NULL. Saving document & cancelling this editing attempt..."
		), _T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		gpApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* savePos = pos; //POSITION savePos = pos; // keep for when we later scan forwards
	pSrcPhrase = pos->GetData();
	pos = pos->GetPrevious();
	if (pSrcPhrase->m_bRetranslation)
	{
		// the user's first selected pile is within a retranslation, 
		// so possibly extension left is required
		if (!pSrcPhrase->m_bBeginRetranslation)
		{
			// the first pile of the user's selection is not the first pile in
			// the retranslation, so extension leftwards is needed
			while (TRUE)
			{
				if (pos == NULL)
				{
					// we have come to the start of the document, so extending
					// further left is not possible
					break;
				}
				// get the previous CSourcePhrase at the new POSITION
				pSrcPhrase = pos->GetData();
				pos = pos->GetPrevious();
				nStartingSN = pSrcPhrase->m_nSequNumber;
				bIsExtended = TRUE;
				if (pSrcPhrase->m_bBeginRetranslation)
				{
					// we are at the start of the retranslation, so break out
					break;
				}
			}
		}
		// We have established the nStartingSN value, now we need to work out
		// where this particular retranslation ends - it may end before, at, or
		// after the user's selection's end (in fact, there may be more than one
		// retranslation in his selection). So now we must here scan across the
		// current retranslation to its end, then work out if it contains the
		// end of the user's selection - if so, we are done, if not, we must
		// proceed to the outer block to continue scanning to higher sequence numbers
		pos = savePos; // restore starting POSITION; we must start from here because the
					   // user may have selected only a single word
		while (pos != NULL)
		{
			savePos = pos; // save the POSITION
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			nIteratorSN = pSrcPhrase->m_nSequNumber;

			// if we get to a higher sequence number than the end of the user's
			// selection, the selection is being extended and we must register
			// that fact using the next test
			if (nIteratorSN > nEndingSN)
			{
				bIsExtended = TRUE;
			}
			if (pSrcPhrase->m_bEndRetranslation)
			{
				// we are at the end of the retranslation, so break out
				break;
			}
		}
		// return if we have inclusion or are at the doc end
		if (nIteratorSN >= nEndingSN || pos == NULL)
		{
			// the end of the user's original selection is earlier than the
			// end of the retranslation, or coincides with it, or we
			// are at the end of the document; hence we are done
			nEndingSN = nIteratorSN; // update the value being returned to the caller
			return TRUE; // no errors
		}
		
	}
	// If control gets to here, then either the starting pile of the user's selection
	// was not in a retranslation (in which case no exending leftwards was needed) and
	// the POSITION value is still at the start of the user's selection; or we have just
	// iterated across a retranslation but have not yet reached the final pile of the
	// user's selection. In either case, we must continue iterating rightwards until we
	// get to the user's selection end - then, once there, if that is within a(nother)
	// retranslation, we must extend further rightwards to the end of that one, but 
	// if not, we are done
	pos = savePos; // initialize iterator
	pSrcPhrase = pos->GetData(); // get the next pos value
	pos = pos->GetNext(); 
	nIteratorSN = pSrcPhrase->m_nSequNumber; // initialize sequence number iterator
	while (pos != NULL && nIteratorSN < nEndingSN)
	{
		// iterate forwards to the end of the user's selection
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nIteratorSN = pSrcPhrase->m_nSequNumber;
	}
	if (pos == NULL)
	{
		// we reached the end of the document
		nEndingSN = nIteratorSN; // pass back the last CSourcePhrase instance's sequ num
		return TRUE; // if we return here, we've not done any rightwards extension
	}

	// If control gets to here, then we are not at the document's end, but have reached
	// the last pile of the user's selection. This may be as far as we need go, but we
	// must test for this pile being within a(nother) retranslation, and if it is, we must
	// extend rightwards to the end of that retranslation & end there; otherwise, we are done
	if (!pSrcPhrase->m_bRetranslation)
	{
		// no extending is needed, so return
		nEndingSN = nIteratorSN;
		return TRUE; // no errors
	}
	else
	{
		// extending rightwards is needed
		bIsExtended = TRUE;
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			nIteratorSN = pSrcPhrase->m_nSequNumber; // update the sequ num iterator
			if (pSrcPhrase->m_bEndRetranslation)
			{
				// we don't extend any further, the whole retranslation is in 
				// the span we've now identified
				nEndingSN = nIteratorSN;
				return TRUE; // no errors
			}
		}
	}
	// if we get here, we've reached the document end, so set nEndingSN and return
	nEndingSN = nIteratorSN;
	return TRUE; // no errors
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error, FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	index into the pSrcPhrases list at which the span to be investigated starts
/// \param      nEndingSN		->	index at which the span ends
/// \param      pbHasAdaptations <-	pointer to bool, returns TRUE if there is at least one adaptation in the 
///                                 span, FALSE if there were none
/// \remarks
/// Called from: The View's OnEditSourceText().
/// Determines if there is at least one adaptation in the span of text determined by nStartingSN and nEndingSN.
/// We check only as far as the end of the span, or till we find the first adaptation, whichever comes first.
/// Used to set or clear the bEditSpanHasAdaptations flag in the global struct gEditRecord.
// //////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsAdaptationInformationInThisSpan(SPList* pSrcPhrases, int& nStartingSN, int& nEndingSN,
												 bool* pbHasAdaptations)
{
	(*pbHasAdaptations) = FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	int nThisSN;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN); //POSITION pos = pSrcPhrases->FindIndex(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		// An English message would be ok here.
		wxMessageBox(_T("FindIndex() failed in IsAdaptationInformationInThisSpan(), pos value is NULL. Saving the document. Exiting the edit process."
		), _T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		gpApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}

	// scan over the editable span looking for any m_adaption non-empty strings in the 
	// CSourcePhrase instances; exit TRUE when the first such is found, we don't need
	// to know how many there are
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;
		if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			// there is at least one non-empty adaptation string in this span
			(*pbHasAdaptations) = TRUE;
			return TRUE;
		}
		if (nThisSN >= nEndingSN)
		{
			// we are at the end of the span which is to be tested, so break out
			break;
		}
	}
	(*pbHasAdaptations) = FALSE;
	return TRUE;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error, FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	index into the pSrcPhrases list at which the span to be investigated starts
/// \param      nEndingSN		->	index at which the span ends
/// \param      pbHasGlosses    <-	pointer to bool, returns TRUE if there is at least one gloss in the span, 
///                                 FALSE if there were none
/// \remarks
/// Called from: The View's OnEditSourceText().
/// Determines if there is at least one gloss in the span of text determined by nStartingSN and nEndingSN.
/// We check only as far as the end of the span, or till we find the first gloss, whichever comes first.
/// Used to set or clear the bEditSpanHasGlosses flag in the global struct gEditRecord.
// //////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsGlossInformationInThisSpan(SPList* pSrcPhrases, int& nStartingSN, int& nEndingSN,
												 bool* pbHasGlosses)
{
	(*pbHasGlosses) = FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	int nThisSN;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN); //POSITION pos = pSrcPhrases->FindIndex(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		wxMessageBox(_T("FindIndex() failed in IsGlossInformationInThisSpan(), pos value is NULL. Saving the document. Exiting the edit process."
		), _T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		gpApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}

	// scan over the editable span looking for any m_gloss non-empty strings in the 
	// CSourcePhrase instances; exit TRUE when the first such is found, we don't need
	// to know how many there are
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;
		if (!pSrcPhrase->m_gloss.IsEmpty())
		{
			// there is at least one non-empty gloss string in this span
			(*pbHasGlosses) = TRUE;
			return TRUE;
		}
		if (nThisSN >= nEndingSN)
		{
			// we are at the end of the span which is to be tested, so break out
			break;
		}
	}
	(*pbHasGlosses) = FALSE;
	return TRUE;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if it appears likely the free translation section was created with the "Define Sections By"
///     		radio button "Verse" turned ON, FALSE if the other radio button "Punctuation" was the one
///     		more likely to have been ON
/// \param      pSrcPhrases					->	pointer to m_pSrcPhrases defined on CAdapt_ItDoc class
/// \param      nStartingFreeTransSequNum	->	start of the free translation found at the start of the free translation
///                                             span, or if there was no free translation there, then it 
///                                             is the same as the nStartingSN value of gEditRecord
/// \param      nEndingFreeTransSequNum		->	bounding sequence number beyond which we don't scan further (it is
///                                             not necessarily the end of a free translation section, as the end of
///                                             the first free translation section, if one exists here, may occur
///                                             earlier, because this value may just be the nEndingSN value of gEditRecord
/// \param      bFreeTransPresent			->	TRUE if there is at least one free translation section within the
///                                             span defined by the first two parameters (caller determines this), FALSE
///                                             if not - and if FALSE, then control immediately exits and no scan is
///                                             done and default FALSE is returned.
/// \remarks
/// Called from: The View's OnEditSourceText().
/// When a free translation section is set up by the SetupCurrentFreeTranslationSection() call at the end
/// of the RecalcLayout() call, the user will have had one of the radio buttons "Punctuation" or "Verse" turned
/// on - the latter defines, usually, a longer section than the former. However which one it was is not recorded,
/// and so in vertical edit mode, we want to get a "best guess" for what that setting was, (it is the application
/// class's BOOL flag, m_bDefineFreeTransByPunctuation, default is TRUE), because we wish to restore that setting
/// before entering the freeTranslationsStep of the vertical edit process. (Otherwise, the user would be annoyed
/// that his earlier sectioning choice is not in effect. However, even if our algorithm gets it wrong, he can
/// just click the relevant radio button after freeTranslationsStep is entered, and before he does any updating
/// of his free translation, and the current section would then be resized)
/// Unfortunately, we cannot reliably determine what the former setting was. We know 5 piles will be traversed
/// and then the sectioning code starts looking for a terminating condition - punctuation, or significant SFM,
/// or start of a new verse. If after 5 piles we come to a following punctuation character, and the section does
/// not end there, we can be certain that m_bDefineFreeTransByPunctuation was originaly FALSE; if we come to the
/// end of the section and the next pile contains pSrcPhrase with m_bVerse set TRUE, then it is likely that
/// m_bDefineFreeTransByPunctuation was FALSE - but we can't be certain; or if there are lots of piles in the section
/// (we mean "more than 15") we'll assume the flag was FALSE. Otherwise, we'll assume it was TRUE.
/// (The value we return is the inverse of m_bDefineFreeTransByPunctuation value; i.e. if the latter was FALSE,
/// meaning a verse-length section, then we return TRUE; and vise versa)
// //////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetLikelyValueOfFreeTranslationSectioningFlag(SPList* pSrcPhrases,
				 int nStartingFreeTransSequNum, int nEndingFreeTransSequNum, bool bFreeTransPresent)
{
	// 01Oct08, BEW added this function 
	if (!bFreeTransPresent)
		return FALSE; // do nothing if we know there is no free translation in the span

	wxString spacelessTgtPunctuation = gpApp->m_punctuation[1]; // target set, with delimiting spaces
	spacelessTgtPunctuation.Replace(_T(" "),_T("")); // get rid of the spaces

	int nThreshhold = NUM_WORDS_IMPLYING_VERSE_SECTIONING; // #defined as 15 near top of file
	int nWordCount = 0;
	int nPunctuationsNotHaltedAt = 0;
	CSourcePhrase* pSrcPhrase = NULL;

	// find the first pSrcPhrase in the span which has m_bStartFreeTrans TRUE
	bool bFoundStart = FALSE;
	SPList::Node* pos = pSrcPhrases->Item(nStartingFreeTransSequNum); //POSITION pos = pSrcPhrases->FindIndex(nStartingFreeTransSequNum);
	SPList::Node* posBoundary = pSrcPhrases->Item(nEndingFreeTransSequNum);
	wxASSERT(pos != NULL);
	bool bHasWordFinalPunct = FALSE;
	while (pos != NULL)
	{
		if (pos == posBoundary)
		{
			// we have tested the last one in the span, so must exit this loop having
			// not found an instance where a free translation starts; and so we exit the 
			// whole function as there can be no free translation to be dealt with
			return FALSE;
		}
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_bStartFreeTrans)
		{
			bFoundStart = TRUE;
			break;
		}
	}
	if (bFoundStart)
	{
		// scan over this free translation, collecting information about it; but if the first pSrcPhrase
		// is the end of the free translation section, then assume "Punctuation" radio button was ON
		// and return a FALSE value accordingly
		if (pSrcPhrase->m_bEndFreeTrans)
			return FALSE;
		// otherwise, check out this pSrcPhrase more closely
		nWordCount += pSrcPhrase->m_nSrcWords; // could be a merger, so may already exceed 5, check
		if (nWordCount >= MIN_FREE_TRANS_WORDS)
		{
			// test for potential halt location (following punctuation at end of m_targetStr, or 
			// end of source text word or phrase if there is no target text here)
			bHasWordFinalPunct = HasWordFinalPunctuation(pSrcPhrase,pSrcPhrase->m_targetStr,spacelessTgtPunctuation);
			if (bHasWordFinalPunct)
			{
				// does the free translation section end here?
				if (pSrcPhrase->m_bEndFreeTrans)
				{
					// it does end here, and it's just a single pile, so without doubt this section
					// was delineated earlier with "Punctuation" radio button ON
					return FALSE; // no need to go further
				}
				else if (pSrcPhrase->m_bHasFreeTrans)
				{
					// we are still in the free translation section, but it does not end at this
					// punctuation, so count this location
					nPunctuationsNotHaltedAt++; // its starting to look like "Verse" radio button
												// was ON, but check some more
				}
				else
				{
					// the free translation is not defined here! This is unexpected, so return with
					// a default value
					return FALSE;
				}
			} // end block for test (bHasWordFinalPunct))
		} // end block for test (nWordCount >= MIN_FREE_TRANS_WORDS)

		// if control gets here, then we've not found the end of the free translation section yet,
		// but we may or may not have exceeded MIN_FREE_TRANS_WORDS, anyway, we soldier on to later
		// CSourcePhrase instances and test those
		bool bReachedBoundary = FALSE;
		while (pos != NULL)
		{
			// if we are at the boundary for scanning, record the fact but then do the tests
			// below and use the boolean to exit the loop when those test are finished
			if (pos == posBoundary)
			{
				bReachedBoundary = TRUE;
			}
			// get next CSourcePhrase, and increment the word count
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			nWordCount += pSrcPhrase->m_nSrcWords;

			// if we've not exceeded the minimum words, the only thing we need check for
			// is whether or not this is an unusualy short free translation section, if it is
			// then return FALSE immediately, otherwise, loop; but if we've exceed the minimum
			// words now, then we have to do more checks
			if (nWordCount <= MIN_FREE_TRANS_WORDS)
			{
				if (pSrcPhrase->m_bEndFreeTrans)
				{
					// the section ends here, so it must be a short section
					return FALSE;
				}
			}
			else
			{
				// word count exceeds minimum, so more extensive testing required

				// test for potential halt location (following punctuation at end of m_targetStr, or 
				// end of source text word or phrase if there is no target text here)
				bHasWordFinalPunct = HasWordFinalPunctuation(pSrcPhrase,pSrcPhrase->m_targetStr,spacelessTgtPunctuation);
				if (bHasWordFinalPunct)
				{
					// does the free translation section end here?
					if (pSrcPhrase->m_bEndFreeTrans)
					{
						// it does end here, so break out to check if next CSourcePhrase has m_bVerse == TRUE
						break;
					}
					else if (pSrcPhrase->m_bHasFreeTrans)
					{
						// we are still in the free translation section, but it does not end at this
						// punctuation, so count this location & iterate loop
						nPunctuationsNotHaltedAt++;
					}
					else
					{
						// the free translation is not defined here! This is unexpected, so decrement
						// nWordCount and break out for final check
						nWordCount -= pSrcPhrase->m_nSrcWords;
						break;
					}
				} // end of block for test (bHasWordFinalPunct)
				else
				{
					// no word final punctuation at this CSourcePhrase instance, so just check if the
					// free translation section ends here - if it does, break out to check if the
					// next CSourcePhrase has m_bVerse == TRUE
					if (pSrcPhrase->m_bEndFreeTrans)
					{
						// it ends here
						break;
					}
				} // end of else block for test (bHasWordFinalPunct)
			} // end of else block for test (nWordCount <= MIN_FREE_TRANS_WORDS)

			if (bReachedBoundary)
			{
				// if we get here, the m_bEndFreeTrans TRUE has not been encountered - this should
				// not happen because the caller sets the ending boundary to the place where that
				// flag is TRUE, unless there is no free translation defined here, in which case
				// we should have come to the section end earlier - so all we can do is the best
				// we can
				if (nWordCount > nThreshhold)
					return TRUE;
				else
					return FALSE;
			}
		} // end of loop for test (pos != NULL)

		bool bEndsAtVerse = FALSE;
		if (pos != NULL && pos != posBoundary)
		{
			// test the CSourcePhrase following the end of the free translation section, for
			// m_bVerse == TRUE, if it is, then probaby the radio button that was ON was "Verse"
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			bEndsAtVerse = pSrcPhrase->m_bVerse;
		}

		// now, make out final assessment; the most reliable ones first, less reliable ones later
		if (nPunctuationsNotHaltedAt >= 1)
			return TRUE; // "Verse" button was ON
		if (bEndsAtVerse)
			return TRUE; // "Verse" button may have been ON
		if (nWordCount > nThreshhold)
			return TRUE; // we don't really know, but "Verse" assumption will give best chance
						 // of a long section
	}
	return FALSE; // we didn't get a starting location, or we fell though from the preceding
				  // block because no test was conclusive, so return default;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error; FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	reference to the sequence number for the first pile in the span 
///                                 which is to have its source text shown to the user (this could be 
///                                 more than the user's original selection, if extension was done 
///                                 because of the presence of a retranslation or even more than one 
///                                 retranslation)
/// \param      nEndingSN		->	reference to the sequence number for the last pile in the span
///                                 referred to by the preceding parameter's comment
/// \param      nStartingFreeTransSequNum	<- ref to the start of any free translation found at the 
///                                             start of the above span, or if there were no free 
///                                             translation there, then it is the same as the 
///                                             nStartingSN value
/// \param      nEndingFreeTransSequNum		<- ref to the end of any free translation found at the 
///                                             end of the above span, or if there were no free 
///                                             translation there, then it is the same as the 
///                                             nEndingSN value
/// \param      bFreeTransPresent			<-	return TRUE if at least one free translation section 
///                                             is in or partly overlaps the passed in span; FALSE 
///                                             if none were detected (a \free .... \free* section 
///                                             with no content would be regarded as a free 
///                                             translation section and would cause TRUE to be returned)
/// \remarks
/// Called from: The View's OnEditSourceText().
/// Gets the starting and ending sequence numbers of any free translation within the span. 
/// "Leftwards" in this function is to be interpretted as "to lower sequence numbers", & so if we are dealing 
/// with a right-to-left language data, it would be rightwards to the user. Free translations are 
/// defined over document 'sections', and there is no reason why we could assume that the boundaries
/// of the user's selection for edit purposes would coincide with the start of a free translation section
/// and the end of that or another free translation section. In general, if free translations are present
/// then there is a real possibility that the one or more whole free translations defined over the user's
/// selection will start earlier than his selection, and end later; but we can't be sure of that because
/// the free translations might happen to end partway through the user's selection simply because he's not
/// yet managed to free translation past that point yet. So this function works out the span of 
/// CSourcePhrase instances which have retranslations defined over them, and makes sure the span starts
/// at the start of the free translation or the passed in nStartingSN value, whichever is lesser, and ends
/// at the end of a whole free translation section at higher sequence number than nEndingSN, or at nEndingSN
/// if there was no free translation at the end of the passed in span, whichever is the case.
// //////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetEditSourceTextFreeTranslationSpan(SPList* pSrcPhrases, int& nStartingSN, int& nEndingSN,
				 int& nStartingFreeTransSequNum, int& nEndingFreeTransSequNum, bool& bFreeTransPresent)
{
	// 22Apr08, BEW added this function 
	bFreeTransPresent = FALSE;
	//int nIteratorSN = 0; // use when scanning forwards or backwards // unused
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN); //POSITION pos = pSrcPhrases->FindIndex(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		wxMessageBox(_T("FindIndex() failed in GetEditSourceTextFreeTranslationSpan(), pos value is NULL. Saving document. Abandoning edit."
		), _T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		gpApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* savePos = pos; //POSITION savePos = pos; // we may need this if we need to verify there are no editable span
							// internal free translation sections (which don't reach either end)

	// initialize the nStartingFreeTransSequNum value to the passed in nStartingSN value
	nStartingFreeTransSequNum = nStartingSN;

	pSrcPhrase = pos->GetData();
	pos = pos->GetPrevious();
	gEditRecord.bSpecialText = pSrcPhrase->m_bSpecialText; // store the special text
													// value in the global EditRecord
	if (pSrcPhrase->m_bHasFreeTrans)
	{
		// the first pile's word or phrase which is to be shown to the user as editable, has
		// a free translation defined on it; so scan back to the start of that free translation
		// if the current pile is not the beginning of the free translation section
		bFreeTransPresent = TRUE;
		if (!pSrcPhrase->m_bStartFreeTrans)
		{
			// the current pile is not the beginning of the section, so scan to lower sequ numbers
			while (pos != NULL)
			{
				// get the previous CSourcePhrase at the new POSITION
				pSrcPhrase = pos->GetData();
				pos = pos->GetPrevious();
				nStartingFreeTransSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans)
				{
					// we are at the start of the free translation section, so break out
					break;
				}
			}
		}
	} // end of block for test pSrcPhrase->m_bHasFreeTrans == TRUE

	// We have established the nStartingSN value, now we need to work out
	// if at the CSourcePhrase instance indexed by the nEndingSN value (the last one whose
	// source text data will be made visible to the user for editing purposes) also has a
	// free translation defined on it, and if it has, then whether or not the free translation
	// ends there - if so, we are done, or if there is no free translation there we are done;
	// but if either is not the case, we must continue scanning to higher sequence numbers
	// until we find the end of that particular free translation section

	// initialize the nEndingFreeTransSequNum value to the passed in nEndingSN value
	nEndingFreeTransSequNum = nEndingSN;

	pos = pSrcPhrases->Item(nEndingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		wxMessageBox(_T("FindIndex() failed in GetEditSourceTextFreeTranslationSpan(), pos value is NULL, for index nEndingSN. Saving document. Abandoning edit."
		), _T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		gpApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	pSrcPhrase = pos->GetData();
	pos = pos->GetNext();
	if (pSrcPhrase->m_bHasFreeTrans)
	{
		// the last pile's word or phrase which is to be shown to the user as editable, has
		// a free translation defined on it; so scan forward to the end of that free translation
		// if the current pile is not the end location of that free translation section
		bFreeTransPresent = TRUE;
		if (!pSrcPhrase->m_bEndFreeTrans)
		{
			// the current pile is not the end of the section, so scan to higher sequ numbers
			while (pos != NULL)
			{
				// get the CSourcePhrase at the new POSITION
				pSrcPhrase = pos->GetData();
				pos = pos->GetNext();
				nEndingFreeTransSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bEndFreeTrans)
				{
					// we are at the end of the free translation section, so break out
					break;
				}
			}
		}
	} // end of block for test pSrcPhrase->m_bHasFreeTrans == TRUE

	if (!bFreeTransPresent)
	{
		// we found no free translation at the start or end of the editable span, but
		// that does not mean that there is no free translation defined within the span,
		// so scan across the span to verify that there really is none defined on it
		pos = savePos; // restore editable span's beginning POSITION
		int width = nEndingSN - nStartingSN + 1;
		int index;
		for (index = 0; index < width; index++)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			if (pSrcPhrase->m_bHasFreeTrans)
				bFreeTransPresent = TRUE;
		}
	}

	// set the flag in the EditRecord which later, entering freeTranslationsStep, allows us
	// to get the original value of the app class's BOOL member, m_bDefineFreeTransByPunctuation
	// set back to its earlier value (mostly that should happen), so the user most of the 
	// time will not have to manually resize the section
	gEditRecord.bVerseBasedSection = GetLikelyValueOfFreeTranslationSectioningFlag(pSrcPhrases,
							nStartingFreeTransSequNum,nEndingFreeTransSequNum,bFreeTransPresent);
	return TRUE; // there was no error
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error; FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	reference to the sequence number for the first pile in the span 
///                                 which is to have its source text shown to the user (this could be 
///                                 more than the user's original selection, if extension was done 
///                                 because of the presence of a retranslation or even more than one 
///                                 retranslation)
/// \param      nEndingSN		->	reference to the sequence number for the last pile in the span
///                                 referred to by the preceding parameter's comment
/// \param      nStartingFreeTransSequNum	-> ref to the start of any free translation found at the 
///                                             start of the above span, or if there were no free 
///                                             translation there, then it is -1
/// \param      nEndingFreeTransSequNum		-> ref to the end of any free translation found at the end 
///                                             of the above span, or if there were no free translation 
///                                             there, then it is -1
/// \param      nStartingBackTransSequNum	<- ref to the first back translation deemed to overlap or 
///                                             be within the passed in nStartingSequNum to nEndingSequNum 
///                                             span; return -1 if no back translation span was able to 
///                                             be defined for the passed in editable span
/// \param      nEndingBackTransSequNum		<- ref to the last CSourcePhrase location in the final 
///                                             (or only) back translation section deemed to overlap the 
///                                             end of the passed in editable span given by 
///                                             nStartingSequNum to nEndingSequNum; return -1 if no back
///                                             translation span was able to be defined for the passed in 
///                                             editable span
/// \param      bHasBackTranslations		<- ref to BOOL to inform caller that the span has at least 
///                                             one collected back translation defined on it (even if 
///                                             the collected \bt marker's content was empty)
/// \remarks
/// Called from: The View's OnEditSourceText(). Gets the starting and ending sequence numbers of any back 
/// translation within the span. 
/// Note: parameters 2 to 7 reference members in the struct gEditRecord, and of those 2 to 5 should have 
/// been set already, or set to -1 if inapplicable, by previous function calls).
/// "Leftwards" in this function is to be interpretted as "to lower sequence numbers", & so if we
/// are dealing with a right-to-left language data, it would be rightwards to the user. 
/// The intent of this function is to define the start and end of a span in which there is one or
/// more collected back translations overlapping any or all of the editable span defined by nStartingSN to
/// nEndingSN values. This is tricky to do, because collection does not occur from CSourcePhrase instances
/// which have certain TextTypes (footnote -- used for true footnotes and also for endnotes, crossReference,
/// and markers with TextType of none), but such material could be selected wholely or in part by the user.
/// These possibilities complicate the algorithm. Back translation markers (\bt or any marker starting with
/// \bt) have to eventually be removed, and their contents thrown away, by another function which the caller
/// calls.  Members of gEditRecord are set by being passed in directly. In the algorithm described
/// below, we speak of "halt locations" - these are the CSourcePhrase instances where the view class's
/// HaltCurrentCollection() function returns; the function returns TRUE if a SF marker has been found which is
/// of the kind deemed able to halt the collecting operation, FALSE if collecting should continue, and the
/// function also returns, via its parameter list, whether or not the marker which halted collection was a
/// \bt type of marker. Because HaltCurrentCollection() has all the smarts we need for the present function,
/// we'll use it in the algorithms described below - so that the collection halting criteria are the same
/// over all code for collecting back translations within the application. (Back translation sections don't
/// have a terminating endmarker, and so it is not a simple matter to work out what the span of any \bt marker
/// happens to be, and the CSourcePhrase instances in any such span have no flag indicating they belong to
/// a \bt section, except that the first of them stores, in m_markers the filtered back translation itself.)
/// 
/// Note 1: nStartingBackTransSequNum value is not necessarily the same as the starting value of either
/// the editable span nor any free translation span that was earlier defined. (The design also does not
/// require the back translation span subsume the free translation span or the editable span - the ends
/// of all these can be different.)
/// 
/// Note 2. gEditRecord preserves the span involved in back translation deletions, so if the
/// user elects to have recollection done, we can then use the stored locations and the new length of the 
/// edited source text to work out the span over which the collection operation has to be automatically done.
/// 
/// To understand the algorithm used in GetEditSourceTextBackTranslationSpan(), it is best to break it up
/// into 5 sequential sub-algorithms as follows:
/// 
/// 1. Determine the starting location (a sequence number) for the first \bt marker destined for removal
/// 
/// 2. Determine where to scan forward from - it will be the location found in 1. if a back translation was
/// actually found by 1.'s algorithm, but if none was found, we start scanning at the start of the editable span
/// 
/// 3. Halt locations are examined wherever the back translation collect operation would have halted during
/// the collection operation which defined the back translation spans found in the current document.
/// At these halt locations nothing is done if no \bt or \bt-derived marker has yet been found, but if one
/// has been found, then we check for presence of another \bt and remove it if we find one there and we are
/// not at that point past the end of the editable span. Also we maintain a boolean flag, bHasBackTranslations
/// which we set only if we find a \bt or \bt-derived marker at some point in all this, and its span does not
/// halt before the start of the editable span, and that marker is not stored at some location after the 
/// editable span (because if it was, its back translation would remain valid no matter what editing the user
/// did within the text shown to him for editing).
/// 
/// 4. Eventually scanning will come to the last CSourcePhrase instance in the editable span, here we must
/// test whether the bHasBackTranslations flag has been set yet, and whether or not it is a halt location,
/// and if it is a halt location, whether or not another \bt marker (or the first such marker if none was
/// found up to that point) is stored there. Depending on the results of these tests, we either declare there
/// is no collected backtranslation defined on any part of the editable span, or the span we are defining
/// ends there, or it ends at a halt location further along which has to now be found.
/// 
/// 5. Find the final halt location if within 4. it could not be determined.
/// 
/// The appropriate value of bHasBackTranslations is then returned to the caller, where it is used to set or
/// clear the gEditRecord member bEditSpanHasBackTranslations, and if the the latter is cleared, the
/// caller will also reset the struct's nStartingBackTransSequNum and nEndingBackTransSequNum values to -1.
// //////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetEditSourceTextBackTranslationSpan(SPList* pSrcPhrases, int& nStartingSN,
					int& nEndingSN, int& WXUNUSED(nStartingFreeTransSequNum), int& WXUNUSED(nEndingFreeTransSequNum),
					int& nStartingBackTransSequNum, int& nEndingBackTransSequNum, bool& bHasBackTranslations)
{
	// 23Apr08, BEW added this function 
	// use BOOL CAdapt_ItView::HaltCurrentCollection(CSourcePhrase* pSrcPhrase, BOOL& bFound_bt_mkr) as the
	// way, when scanning forward, to determine halt locations - and remember that the last CSourcePhrase
	// instance within the span thus delineated is the one which precedes the halt location (the halt location
	// is actually the kick off location for a new collection span, as it stores the marker which lead to
	// the halt, and is the place where the next filtered collected back translation would be stored)
	bHasBackTranslations = FALSE;
	bool bFound_bt_mkr = FALSE;
	bool bIsHaltLocation = FALSE;
	bool bItsHereAnyway = FALSE;
	//EditRecord* pRec = &gEditRecord; // get a local pointer to the  // unused
										// EditRecord global struct
	wxString markers;
	nStartingBackTransSequNum = -1; // initialize to 'no value set'
	nEndingBackTransSequNum = -1; // ditto

	int nIteratorSN = nStartingSN; // start from the commencement of the editable span
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nIteratorSN); //POSITION pos = pSrcPhrases->FindIndex(nIteratorSN);
	// no error is expected, but we'll check and abort the edit with an English message if a valid pos
	// was not found, but do a save to retain user's work; the document structures are still unchanged
	if (pos == NULL)
	{
		wxMessageBox(_T("FindIndex() failed in GetEditSourceTextBackTranslationSpan(), pos value is NULL. Saving document. Abandoning edit."
		), _T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		gpApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* savePos = pos; //POSITION savePos = pos; // keep for when we later scan forwards
	pSrcPhrase = pos->GetData();
	pos = pos->GetPrevious();

	// The collection operation for back translations does no collecting of filtered information which is inLine,
	// & has a TextType of footnote, or crossReference; these are for things such as footnotes, endnotes,
	// cross references, and we don't allow Adapt It notes' text to be collected. The user could do a selection
	// in things like visible footnotes, endnotes or cross references, but not AI Notes. But the AI interface
	// will not accept selection attempts across a TextType boundary (except for verse and poetry) and so we
	// can be sure than any selection made will be wholely within the one text type. Since there won't be any
	// \bt marker defined on such spans, we must make the function check for a selection within these
	// information types (checking the first CSourcePhrase instance of the user's selection suffices) and if
	// that is where the selection was done, we exit without setting up any bt span
	TextType aType = pSrcPhrase->m_curTextType;
	if (aType == footnote || aType == crossReference)
		return TRUE;

	// check if this first CSourcePhrase in the editable span is a halt location, and if it is, whether or
	// not a \bt marker is stored there; even if not a halt location, we still must check for the presence
	// of a \bt marker there because using a selection the user is able to force any CSourcePhrase instance
	// to be the start of a back translation collection span and hence the place where the back translation
	// text for that span would be stored, so use ContainsBtMarker() to check for that possibility as well
	bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
	if (bIsHaltLocation)
	{
		// its a halt location, so any bt span will either start here (if bFound_bt_mkr is TRUE) or will
		// start at a later location, or not at all; whichever is the case we don't have to scan back (to 
		// lower sequence numbers) to get the start of any potential bt span because any prior one will have
		// terminated its collection at the CSourcePhrase instance preceding this current location, and so
		// that one's back translation cannot be affected by the user's editing of the text shown to him
		if (bFound_bt_mkr)
		{
			// the \bt deletion subspan starts here
			nStartingBackTransSequNum = nIteratorSN;
			bHasBackTranslations = TRUE;
		}
	}
	else
	{
		// it's not a halt location, but nevertheless a collection could have been manually forced here
		// in some earlier session, so we must check for that; otherwise, we must scan back to the first
		// previous halt location to see if there is a \bt stored there - if so, that would be the start
		// of the bt deletion span we are trying to delimit
		bItsHereAnyway = ContainsBtMarker(pSrcPhrase);
		if (bItsHereAnyway)
		{
			// the \bt deletion subspan starts here
			nStartingBackTransSequNum = nIteratorSN;
			bHasBackTranslations = TRUE;
		}
		else
		{
			// scan back to see if there is a \bt at the previous halt location, it would start the subspan
			while (pos != NULL)
			{
				pSrcPhrase = pos->GetData();
				pos = pos->GetPrevious();
				nIteratorSN = pSrcPhrase->m_nSequNumber;
				bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
				if (bIsHaltLocation)
				{
					if (bFound_bt_mkr)
					{
						// we have found the location where the \bt deletion span starts
						nStartingBackTransSequNum = nIteratorSN;
						bHasBackTranslations = TRUE;
						break;
					}
					else
					{
						// there is no \bt marker at this halt location, so we can assume that in this
						// part of the document there is no back translation data collected here - just
						// prior to the start of the editable span
						break;
					}
				} // end of block for test:  bIsHaltLocation == TRUE
				else
				{
					// it's not a halt location, but still check for storage of \bt manually forced to be
					// here; otherwise do next iteration of the loop
					bItsHereAnyway = ContainsBtMarker(pSrcPhrase);
					if (bItsHereAnyway)
					{
						// the bt deletion span starts here
						nStartingBackTransSequNum = nIteratorSN;
						bHasBackTranslations = TRUE;
						break;
					}
				}
			} // end of while loop with pos != NULL test
		} // end of else block for test: bItsHereAnyway == TRUE
	} // end of else block for bIsHaltLocation == TRUE test

	// that finishes the first stage of the overall algorithm; when control gets here, either
	// nStartingBackTransSequNum has been set to a non-negative sequence number value for the start
	// of the back translation deletion span; or it is still -1 because no beginning for such a span
	// has been detected at or prior to the start of the editable span. Now we commence the subalgorithm
	// number 2, which is to determine the location for scanning forward
	if (bHasBackTranslations)
	{
		nIteratorSN = nStartingBackTransSequNum;
		pos = pSrcPhrases->Item(nIteratorSN);
		wxASSERT(pos != NULL); // we'll assume FindIndex() won't fail, so just ASSERT for a debug mode check
		pSrcPhrase = pos->GetData();// get the pos for next POSITION
		pos = pos->GetNext();
	}
	else
	{
		// no \bt found yet, so start scanning forward from the start of the editable span
		nIteratorSN = nStartingSN;
		pos = savePos;
		wxASSERT(pos);
	}
	// that finishes subalgorithm number 2, commence subalgorithm number 3 in which we scan forward looking
	// for halt locations and manually assigned \bt storage locations prior to coming to the end of the
	// editable span
	bool bBtMarkerFoundAtEndOfEditableSpan = FALSE;
	bool bEndOfEditableSpanIsAHaltLocation = FALSE;
	while (pos != NULL)
	{
		// get the CSourcePhrase data for the current pos
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nIteratorSN = pSrcPhrase->m_nSequNumber;
		bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
		if (bIsHaltLocation)
		{
			// it's a halt location, so check out whether \bt is there, etc
			if (bFound_bt_mkr)
			{
				// a \bt marker was found here, so either the bt deletion span starts here, or
				// this is another collection storage point for back translations which happens to
				// be located within the editable span of source text shown to the user
				bHasBackTranslations = TRUE;
				if (nIteratorSN == nEndingSN)
				{
					// this \bt marker was stored at the very end of the editable span,
					// we need to know this when the loop is exitted
					bBtMarkerFoundAtEndOfEditableSpan = TRUE;
					bEndOfEditableSpanIsAHaltLocation = TRUE;
				}
				if (nStartingBackTransSequNum == -1)
				{
					// the bt deletion span has not been commenced yet, so start it here
					nStartingBackTransSequNum = nIteratorSN;
				}
			}
			// if no \bt marker was found, we continue looping
		}
		else
		{
			// not a halt location, but there may be a \bt marker nevertheless because the
			// user at some earlier time manually forced a collection to be stored here
			bItsHereAnyway = ContainsBtMarker(pSrcPhrase);
			if (bItsHereAnyway)
			{
				// a \bt marker was found here, so either the \bt deletion span starts here, or
				// this is another collection storage point for back translations which happens to
				// be located within the editable span of source text shown to the user
				bHasBackTranslations = TRUE;
				if (nIteratorSN == nEndingSN)
				{
					// this \bt marker was stored at the very end of the editable span,
					// we need to know this when the loop is exitted
					bBtMarkerFoundAtEndOfEditableSpan = TRUE;
				}
				if (nStartingBackTransSequNum == -1)
				{
					// the bt deletion span has not been commenced yet, so start it here
					nStartingBackTransSequNum = nIteratorSN;
				}
			}
		}
		// if we are at the end of the editable span then exit this loop
		if (nIteratorSN == nEndingSN)
		{
			break;
		}
	} // end of while loop with test pos != NULL

	// We are now about to start subalgorithm 4; the loop will have been exitted either because pos is NULL
	// (we've reached the end of the document), or because we've landed at the end CSourcePhrase instance
	// in the editable span. Now we use the booleans defined preceding the last loop, and the other flags
	// and sequence numbers to work out whether we have a bt deletion span being defined, and if so then
	// where to terminate its span, but if not, we return to the caller with appropriate EditRecord
	// values indicating there were no back translations defined over any part of the editable span of text
	// which the user sees for editing purposes
	if (pos == NULL)
	{
		// iterating came to the document's end, the \bt subspan, if it exists, must end here
		if (!bHasBackTranslations || nStartingBackTransSequNum == -1)
		{
			// the span was never started, so there are no back translations defined over any part
			// of the editable text span
			nStartingBackTransSequNum = -1;
			nEndingBackTransSequNum = -1;
			bHasBackTranslations = FALSE;
			return TRUE;
		}
		else
		{
			// a span is being delineated, so it must end here
			nEndingBackTransSequNum = nIteratorSN;
			bHasBackTranslations = TRUE;
			return TRUE;
		}
	}
	else
	{
		// control is not at the end of the document on exit of the loop, so work out what has to be done
		// (this stuff is subalgorithm 5 of the description above)
		if (!bHasBackTranslations || nStartingBackTransSequNum == -1)
		{
			// the span delineation was never started, so there are no back translations defined
			// over any part of the editable text span
			nStartingBackTransSequNum = -1;
			nEndingBackTransSequNum = -1;
			bHasBackTranslations = FALSE;
			return TRUE;
		}
		else
		{
			// a span is being delineated, so work out where it ends
			if (!bBtMarkerFoundAtEndOfEditableSpan && bEndOfEditableSpanIsAHaltLocation)
			{
				// the end CSourcePhrase of the editable span is a halt location and there
				// was no \bt marker stored there, so the end of the current bt span must originally
				// have been at the penultimate instance in the editable span; and there is no
				// collection previously done starting from the end of the editable span
				nEndingBackTransSequNum = nIteratorSN - 1;
			}
			else
			{
				// either there was a \bt marker stored at the very end of the editable span (which
				// implies its collected text was drawn from CSourcePhrase instances lying beyond the
				// end of the editable span - as far as the next halt location), or the current bt collection
				// span doesn't end at the end of the editable span because the latter is not a halt location.
				// Whichever is the case, the \bt subspan will end at the CSourcePhrase instance which is
				// immediately preceding wherever the next halt location is. Find it.
				wxASSERT(pos != NULL);
				while (pos != NULL)
				{
					pSrcPhrase = pos->GetData();
					pos = pos->GetNext();
					nIteratorSN = pSrcPhrase->m_nSequNumber;
					bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
					if (bIsHaltLocation)
					{
						nEndingBackTransSequNum = nIteratorSN - 1; // the location preceding the halt location
						break;
					}
				}
			}
		}
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      editRec  <- an enum of type EditRecord
/// \remarks
/// Called from: The Doc's OnNewDocument(), OnCloseDocument(), OnOpenDocument(), the View's
/// ClobberDocument(), BailOutFromEditProcess(), OnEditSourceText(), and OnCustomEventEndVerticalEdit().
/// Initializes the gEditRecord global struct's members. The struct members must be initialized when the 
/// document is created or reopened for work, and also when closing down the document either using 
/// ClobberDocument()(which is called by the document class's OnFileClose() function) or the document 
/// class's OnCloseDocument() function; and when closing or opening or creating we also remove the 
/// constents of the three deletion lists in the caller after calling InitializeEditRecord(). 
/// Note: the deletedAdaptationsList, deletedGlossesList, and DeletedFreeTranslationsList members' 
/// contents persist for the life of the current document's RAM presence, and so those lists must 
/// empty when the doc is just created or launched and will generally be added to by the user's 
/// work, and will only lose their contents when the user or the application at exit time closes the 
/// document. 
/// Default values are FALSE for booleans, -1 for integers (meaning "unset"), verse for TextType,
/// and empty for lists (except the deletion lists, which are empty only at the point that the
/// document has just been created or reopened, and emptied again when it is closed).
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::InitializeEditRecord(EditRecord& editRec)
{
	// BEW added 17Apr08
	// first clear the global boolean which tracks whether or not
	// vertical editing is currently happening
	gbVerticalEditInProgress = FALSE;
	// and reset the entry point indicator to the non-edit value
	gEntryPoint = noEntryPoint;

	// now clear EditRecord members which should be cleared once any one
	// instance of vertical editing is completed, or cancelled, or abandoned
	CAdapt_ItDoc* pDoc = (CAdapt_ItDoc*)GetDocument();
	editRec.bGlossingModeOnEntry = FALSE; // default is adaptations mode is currently ON, even
				// even when it isn't; this is safe because the flag is only looked at when
				// vertical editing is currently in progress, and it's only then that its value
				// is taken seriously
	editRec.bSeeGlossesEnabledOnEntry = FALSE; // default is FALSE, whether on or off, same reasons
				// apply as for bGlossingModeOnEntry
	editRec.bEditSpanHasAdaptations = FALSE;
	editRec.bEditSpanHasGlosses = FALSE;
	editRec.bEditSpanHasFreeTranslations = FALSE;
	editRec.bEditSpanHasBackTranslations = FALSE;
	editRec.nSaveActiveSequNum = -1;
	editRec.nStartingTextType = verse;
	editRec.nEndingTextType = verse;
	// the following three are never re-initialized while a session is current, 
	// they get larger as the session goes on, and are cleared only when the
	// session ends. We preserve their contents across document closure and
	// reopening, because their contents may be useful in other documents
	//editRec.deletedAdaptationsList;
	//editRec.deletedGlossesList;
	//editRec.deletedFreeTranslationsList;
	editRec.storedNotesList.Clear();
	editRec.nStartingSequNum = -1;
	editRec.nEndingSequNum = -1;
	editRec.nFreeTrans_StartingSequNum = -1;
	editRec.nFreeTrans_EndingSequNum = -1;
	editRec.nBackTrans_StartingSequNum = -1;
	editRec.nBackTrans_EndingSequNum = -1;
	editRec.nCancelSpan_StartingSequNum = -1;
	editRec.nCancelSpan_EndingSequNum = -1;
	pDoc->DeleteSourcePhrases(&editRec.cancelSpan_SrcPhraseList);
	pDoc->DeleteSourcePhrases(&editRec.modificationsSpan_SrcPhraseList);
	pDoc->DeleteSourcePhrases(&editRec.propagationSpan_SrcPhraseList);
	// the editableSpan_NewSrcPhraseList's pointers are not taken over and managed by
	// a section of the document's m_pSourcePhrase list, because the replacement process
	// inserts deep copies into the document list, leaving editableSpan_NewSrcPhraseList
	// unchanged, so we must delete those too
	pDoc->DeleteSourcePhrases(&editRec.editableSpan_NewSrcPhraseList);
	editRec.nPropagationSpan_StartingSequNum = -1;
	editRec.nPropagationSpan_EndingSequNum = -1;
	editRec.arrNotesSequNumbers.Clear();
	editRec.nOldMaxIndex = gpApp->m_maxIndex;
	editRec.nOldSpanCount = -1;
	editRec.nNewSpanCount = -1;
	editRec.strInitialEndmarkers.Empty();
	editRec.strFinalEndmarkers.Empty();
	editRec.strNewFinalEndmarkers.Empty();
	editRec.bSpecialText = FALSE;
	pDoc->DeleteSourcePhrases(&editRec.follNotesMoveSpanList);
	pDoc->DeleteSourcePhrases(&editRec.precNotesMoveSpanList);
	editRec.bTransferredFilterStuffFromCarrierSrcPhrase = FALSE;
	editRec.bDocEndPreventedTransfer = FALSE;
	editRec.bExtendedForFiltering = FALSE;
	// now the ones unique to the adaptations step
	editRec.bAdaptationStepEntered = FALSE;
	pDoc->DeleteSourcePhrases(&editRec.adaptationStep_SrcPhraseList);
	editRec.nAdaptationStep_StartingSequNum = -1;
	editRec.nAdaptationStep_EndingSequNum = -1;
	editRec.nAdaptationStep_OldSpanCount = -1;
	editRec.nAdaptationStep_NewSpanCount = -1;
	editRec.nAdaptationStep_ExtrasFromUserEdits = 0;
	// now the ones unique to the glosses step
	editRec.bGlossStepEntered = FALSE;
	pDoc->DeleteSourcePhrases(&editRec.glossStep_SrcPhraseList);
	editRec.nGlossStep_StartingSequNum = -1;
	editRec.nGlossStep_EndingSequNum = -1;
	editRec.nGlossStep_SpanCount = -1;
	// now the ones unique to the freeTranslations step
	editRec.bFreeTranslationStepEntered = FALSE;
	editRec.bVerseBasedSection =  FALSE;
	pDoc->DeleteSourcePhrases(&editRec.freeTranslationStep_SrcPhraseList);
	editRec.nFreeTranslationStep_StartingSequNum = -1;
	editRec.nFreeTranslationStep_EndingSequNum = -1;
	editRec.nFreeTranslationStep_SpanCount = -1;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error, FALSE if something went wrong
/// \param      pSublist		->	pointer to a temporary ordered list of CString instances, 
///                                 added in the caller by successive .Append() calls as a 
///                                 scan is done from left to right over a span of CSourcePhrase 
///                                 instances (typically, in the m_pSourcePhrases list in the 
///                                 App class)
/// \param      whichList		->	an enum which specifies the list to store in
/// \param      pRec    		->	pointer to the global EditRecord struct, gEditRecord, which 
///                                 contains amongst its members the various wxArrayString 
///                                 instances into which the passed in string is inserted
/// \remarks
/// Called from: The View's RestoreNotesAfterSourceTextEdit(), and OnEditSourceText().
/// This is a helper function for storage of a passed in sublist (either removed adaptations, 
/// glosses, free translations, or notes) in the appropriate CStringList within gEditRecord. 
/// The sublist is inserted at the head, so that the first removal will be at the top of the 
/// final list, the second will be next, and so forth. The final list (the one in gEditRecord, 
/// a pointer to which is passed in as the last parameter) is kept to a maximum of 
/// DELETIONS_LIST_MAX_ENTRIES which is #defined to be 100 entries, adding extra ones which 
/// cause the limit to be exceeded causes the oldest extra entries to drop off the end of the 
/// list and be lost. Entries can persist, however, only for the life of the session.
// //////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::InsertSublistAtHeadOfList(wxArrayString* pSublist, ListEnum whichList, EditRecord* pRec)
{
	// 29Apr08	function created as part of refactoring the Edit Source Text functionality
	int numElements = 0;
	wxArrayString* pList = NULL;
	switch (whichList)
	{
	case adaptationsList:
		pList = &pRec->deletedAdaptationsList;
		break;
	case glossesList:
		pList = &pRec->deletedGlossesList;
		break;
	case freeTranslationsList:
		pList = &pRec->deletedFreeTranslationsList;
		break;
	case notesList:
		pList = &pRec->storedNotesList;
		break;
	default:
		return FALSE; // unknown list, must be a bad enum value passed in
	}
	//pList->AddHead(pSublist); // inserting them as a block preserves their order
	// In wx we don't have an equivalent of AddHead() where one array is being inserted at the head
	// of another array. Wx has Insert() which by default inserts a single item into the arrau at a
	// position n in the array. In this case we want to preserve the original order of the array we're
	// inserting, so we can use Insert() as long as we insert items of the sublist array in reverse
	// order, inserting them at position 0 in the base array. We do the insertions manually.
	int ct;
	for (ct = (int)pSublist->GetCount()-1; ct >= 0; ct--) //for (ct = 0; ct < (int)pSublist->GetCount(); ct++)
	{
		pList->Insert(pSublist->Item(ct),0);
	}
	numElements = pList->GetCount();
	if (numElements > (int)DELETIONS_LIST_MAX_ENTRIES)
	{
		// inserting a sublist can result in several more than the limit being present, so
		// we must find out how many overlong we are and remove the bottommost excess ones
		int extras = numElements - (int)DELETIONS_LIST_MAX_ENTRIES;
		int i;
		wxString removedStr;
		for (i = 0; i < extras; i++)
		{
			//removedStr = pList->RemoveTail();
			// WX Note: wxStringArray does not have RemoveTail(). To remove the last element
			// of the array, we call RemoveAt using an index value of count - 1.
			int nLast;
			nLast = pList->GetCount();
			pList->RemoveAt(nLast - 1);
		}
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the removals were done successfully, or if there were no removals
///             needing to be done; FALSE if a removal attempt failed, or if no edit operation
///             is currently in effect
/// \param      pSrcPhrase	->	pointer to the CSourcePhrase instance from which information 
///                             is to be removed
/// \param      nSequNum	->	the sequence number in m_pSourcePhrases list in the document 
///                             for the pSrcPhrase passed in as first parameter (but it will 
///                             not be the index of the pointer in the caller's sublist 
///                             (the modifications list); rather the value is obtained from 
///                             the pSrcPhrase->m_nSequNumber member)
/// \param      pRec		<->	pointer to the global EditRecord struct, gEditRecord, which 
///                             records spans, lists of CSourcePhrase instances, lists of 
///                             removed strings, starting and ending TextType values, and 
///                             various booleans reflecting the state of the edit process, etc
/// \param      pAdaptList	<->	list for removed adadptations
/// \param      pGlossList	<->	list for removed glosses
/// \param      pFTList		<->	list for removed free translations
/// \param      pNoteList	<->	list for removed notes
/// \param      remAd		->	BOOL indicating whether to remove or retain adaptation information
/// \param      remGl		->	BOOLindicating whether to remove or retain gloss information
/// \param      remNt		->	BOOL indicating whether to remove or retain note information
/// \param      remFT		->	BOOL indicating whether to remove or retain free translation information
/// \param      remBT		->	BOOL indicating whether to remove or retain back translation information
/// \remarks
/// Called from: the View's ScanSpanDoingRemovals().
/// Information which is potentially large and/or invalidated by the edit process (eg. source
/// text editing invalidates the adaptations, glosses, free translations and collected back
/// translations within the span of the edit, and possibly notes stored in the span as well)
/// is removed - collected back translations are abandoned (because they are easily recollected)
/// but the other information types are preserved in lists - the persistence of the data in these
/// lists depends on what is stored: notes are preserved only until, at the end of the edit,
/// they are reconstituted in the document (at possibly different locations, but unchanged content),
/// while free translations, glosses and adaptations are stored for the session, or until the document
/// is closed, or until further information of the same type inserted in the list causes them to drop
/// off the list's bottom - the max list length being given by #define DELETIONS_LIST_MAX_ENTRIES which
/// has the value 100. What information is to be removed is controlled by a set of enum values, because
/// we want to use this function eventually for all vertical editing, not just source text editing.
/// The main reason for removing large information like notes, free translations and collected 
/// backtranslations is that these would otherwise be displayed in line in the span of source text being
/// edited, and that would tend to make the source text difficult to find, and be a source of potential
/// confusion or error to a user not expecting to see all filtered information suddenly made visible.
/// 
/// Note: adaptations glosses and notes are removed only from the editable span, any free translations
/// are removed from a span which potentially is larger than the editable span, and back translations
/// are removed from a span which could be considerably larger than that for back translations. Hence
/// the gEditRecord must be checked, for each removal type, to ensure that the passed in
/// pSrcPhrase has a m_nSequNumber value which lies within the span appropriate for whatever marker type's
/// content is being removed, and if CSourcePhrase instance lies outside the appropriate range of
/// sequence numbers, the marker and content are not removed. That member's value is passed in as the
/// nSequNum parameter, and so that is the value which is tested for inclusion in the various kinds of
/// subspan. (The caller does only a single scan across the modification's list's span, so all the
/// required removals have to be done, per passed in pSrcPhrase, as necessary for each span type, in
/// that one pass through the caller's list.)
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RemoveInformationDuringEdit(CSourcePhrase* pSrcPhrase, int nSequNum, EditRecord* pRec, 
					wxArrayString* pAdaptList, wxArrayString* pGlossList, wxArrayString* pFTList,
					wxArrayString* pNoteList, bool remAd, bool remGl, bool remNt,bool remFT, bool remBT)
{
	// 27Apr08	function created as part of refactoring the Edit Source Text functionality
	// no list for removed collected back translations, we throw them away & recollect later

	wxString str; // use as a scratch variable
	wxString errStr;
	int nEditableSpanStart;
	int nEditableSpanEnd;
	int nFreeTranslationSpanStart;
	int nFreeTranslationSpanEnd;
	int nBackTranslationSpanStart;
	int nBackTranslationSpanEnd;

	// If there is no current edit operation in effect, return FALSE immediately
	if (!gbVerticalEditInProgress)
	{
		return FALSE;
	}

	// set the sequence numbers which define each span; any undefined span will have
	// both starting and ending values set to -1, but the editable span never has -1
	// for its indices; each type of removal is valid within only its own span, but the
	// spans potentially overlap significantly or perhaps are each the same span
	nEditableSpanStart = pRec->nStartingSequNum;
	nEditableSpanEnd = pRec->nEndingSequNum;
	nFreeTranslationSpanStart = pRec->nFreeTrans_StartingSequNum;
	nFreeTranslationSpanEnd = pRec->nFreeTrans_EndingSequNum;
	nBackTranslationSpanStart = pRec->nBackTrans_StartingSequNum;
	nBackTranslationSpanEnd = pRec->nBackTrans_EndingSequNum;

	// Note removal and storage is done unilaterally; in many edit situations the note is
	// restored to the same location and the user won't be aware of the temporary removal
	// and restoration; but when source text is edited, note locations can't be guaranteed
	// to remain fixed
	// handle removal of a Note stored here, preserve the note contents in the appropriate CString list,
	// but only do the removal provided the note lies in the editable span
	int nOffset = -1;
	wxString marker = _T("\\note");
	wxString endmarker = _T("\\note*");
	int nContentStartingOffset = -1; // for the function call below, needed for RemoveContentWrappers()
	int nContentStringLength = -1; // needed for the function call below, but we make no use of it
	if (nSequNum >= nEditableSpanStart && nSequNum <= nEditableSpanEnd)
	{
		if (remNt)
		{
			// do this only if removal of notes has been requested, and a note is stored on this
			// pSrcPhrase (remove even if the note's contents is itself an empty string, but don't put
			// an empty note into the wxArrayString in gEditRecord -- the user would probably not care
			// about the fact that there will later be no reconstruction of the empty note, and 
			// certainly Adapt It shouldn't care that it has disappeared)
			nOffset = pSrcPhrase->m_markers.Find(marker);
			if (nOffset != -1)
			{
				// there is a note stored here (beware, its contents may have been cleared out by
				// user action earlier, so we can't be certain there is any content for the note
				// between \note and \note*, but at least the markers are present)
				str = GetExistingMarkerContent(marker,endmarker,pSrcPhrase,nContentStartingOffset,
												nContentStringLength);
				RemoveFinalSpaces(str);
				// remove this note from the passed in CSourcePhrase instance
				RemoveContentWrappers(pSrcPhrase,marker,nContentStartingOffset); 
				// if the content is an empty string, we don't insert it in the list, but if not we
				// must insert it so the end of the source text edit process can reinsert it
				// somewhere appropriate (we can't guarantee the final location will be as meaningful
				// as the original location, but the user can later move it very easily; Adapt It will
				// therefore just do the best it can when it comes to choosing where to relocate it)
				if (!str.IsEmpty())
				{
					size_t Inspos = pNoteList->Add(str); //POSITION pos = pNoteList->AddTail(str);
					if (Inspos == -1) //if (pos == NULL)
					{
						// the .AddTail() call failed, so bail out of 
						// this edit process with a message to the user - we expect this
						// never to happen, so it can be an English hard-coded message
						errStr = _T(".Add() for note string, failed. ");
						errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
						wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
						return FALSE;
					}

					// preserve the Note's former location in the CArray in gEditRecord, 
					// to help us later on restore the Note in a similar location as far as possible
					pRec->arrNotesSequNumbers.Add(nSequNum);

				} // end block for testing for non-empty str
			} // end block for having tested for a \note marker and found one
		}
	}

	// which actions of the total edit process are to be done depend on what the entry
	// condition was, whether editing source, adaptation, gloss, etc. In the MFC app,
	// we support only the editingSourceText entry point. In the wxWidgets port,
	// the other entry points as in the switch will be supported, and vertical editing
	// supported right across the application's modalities.
	switch (gEntryPoint)
	{
		case sourceTextEntryPoint:
			goto s;
		case adaptationsEntryPoint:
			goto a;
		case glossesEntryPoint:
			goto g;
		case freeTranslationsEntryPoint:
			goto f;
		case noEntryPoint: // not expected and would imply an error occurred
		default:
		{
			errStr = _T("gEntryPoint was undefined in RemoveInformationDuringEdit() function. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			return FALSE; // indicate an error state
		}
	}

	// find the adaptation & if non-empty transfer a copy to the temporary string list
	// for later insertion in the string list wtihin pRec (done in the caller); but only
	// provided this CSourcePhrase instance passed in is within the editable span
s:	if (nSequNum >= nEditableSpanStart && nSequNum <= nEditableSpanEnd)
	{
		// (to save time we don't bother to actually remove, but just save a copy)
		if (remAd)
		{
			// do this only if removal of adaptations has been requested, and the
			// adaptation is not an empty string
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				// there is some adaptation text that can be copied, so do so, etc
				str = pSrcPhrase->m_adaption; // copy punctuation-less m_adaption member
				size_t Inspos = pAdaptList->Add(str); //POSITION pos = pAdaptList->AddTail(str);
				if (Inspos == -1) //if (pos == NULL)
				{
					// the AddTail() call failed, so bail out of 
					// this edit process with a message to the user - we expect this
					// never to happen, so it can be an English hard-coded message
					errStr = _T(".Add() for adaptation string, failed. ");
					errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
					wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
					return FALSE;
				}
			}
		}
	}
	// find the gloss, if it exists, & if non-empty transfer a copy to the temporary string
	// list for later insertion in the string list wtihin pRec (done in the caller); but only
	// provided this CSourcePhrase instance passed in is within the editable span
a:	if (nSequNum >= nEditableSpanStart && nSequNum <= nEditableSpanEnd)
	{
		// (we don't bother to remove, just do the copy)
		if (remGl)
		{
			// do this only if removal of glosses has been requested, and the gloss
			// is not an empty string, and the caller has determined there is at least
			// one gloss somewhere in the span to which this CSourcePhrase belongs
			if (pRec->bEditSpanHasGlosses)
			{
				if (!pSrcPhrase->m_gloss.IsEmpty())
				{
					// there is some gloss text that can be copied, so do so, etc
					str = pSrcPhrase->m_gloss;
					size_t Inspos = pGlossList->Add(str); //POSITION pos = pGlossList->AddTail(str);
					if (Inspos == -1) //if (pos == NULL)
					{
						// the .AddTail() call failed, so bail out of 
						// this edit process with a message to the user - we expect this
						// never to happen, so it can be an English hard-coded message
						errStr = _T(".Add() for gloss string, failed. ");
						errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
						wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
						return FALSE;
					}
				}
			}
		}
	}
	// next, do any free translation removal & transfer it to the temporary string list in the caller,
	// but only do it if the CSourcePhrase is within the free translation span; also clear the
	// three free translation-related flags
g:	nOffset = -1;
	marker = _T("\\free");
	endmarker = _T("\\free*");
	nContentStartingOffset = -1; // for the function call below, needed for RemoveContentWrappers()
	nContentStringLength = -1; // needed for the function call below, but we make no use of it
	if ((nFreeTranslationSpanStart != -1 && nSequNum >= nFreeTranslationSpanStart) && 
		(nFreeTranslationSpanEnd != -1 && nSequNum <= nFreeTranslationSpanEnd))
	{
		if (remFT)
		{
			// do this only if removal of free translations has been requested, and the
			// free translation is actually stored on this pSrcPhrase (remove even if the free 
			// translation is itself an empty string, but don't put an empty free translation
			// into the CStringList in gEditRecord)
			if (pRec->bEditSpanHasFreeTranslations)
			{
				// there may be a free translation stored here, if so remove it and insert it
				// at the head of the caller's temporary list for retaining removed free translations
				// for later insertion in the similar list in gEditRecord
				nOffset = pSrcPhrase->m_markers.Find(marker);
				if (nOffset != -1)
				{
					// there is a free translation section stored here (beware, its contents may have
					// been cleared out by user action earlier, so we can't be certain there is a storable
					// free translation between \free and \free*, but at least the markers are present)
					str = GetExistingMarkerContent(marker,endmarker,pSrcPhrase,nContentStartingOffset,
													nContentStringLength);
					RemoveFinalSpaces(str);
					// remove this free translation from the passed in CSourcePhrase instance
					RemoveContentWrappers(pSrcPhrase,marker,nContentStartingOffset); 
					// if the content is an empty string, we don't insert it in the list, but if not we
					// must insert it so the user later has a chance to reuse it and/or modify it
					if (!str.IsEmpty())
					{
						size_t Inspos = pFTList->Add(str); //POSITION pos = pFTList->AddTail(str);
						if (Inspos == -1) //if (pos == NULL)
						{
							// the .Add() call failed, so bail out of 
							// this edit process with a message to the user - we expect this
							// never to happen, so it can be an English hard-coded message
							errStr = _T(".Add() for free translation string, failed. ");
							errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
							wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
							return FALSE;
						}
					} // end block for testing for non-empty str
				} // end block for having tested for a \free marker and found one

				// clear the three flags; this ensures that if the user edits considerably - especially
				// within the adaptations step, then the free translation step's update will do the
				// required resegmenting to comply with the result of those edits
				pSrcPhrase->m_bHasFreeTrans = FALSE;
				pSrcPhrase->m_bStartFreeTrans = FALSE;
				pSrcPhrase->m_bEndFreeTrans = FALSE;

			} // end block for testing for presence of free translations in the editable span
		}
	}
	// handle removal of any collected back translation stored on this CSourcePhrase instance, provided
	// the passed in CSourcePhrase instance lies within the back translation span
f:	nOffset = -1;
	marker = _T("\\bt"); // also handles any \bt-derived marker, such as \btv, \bts, etc
	endmarker.Empty();
	nContentStartingOffset = -1; // for the function call below, needed for RemoveContentWrappers()
	nContentStringLength = -1; // needed for the function call below, but we make no use of it
	if ((nBackTranslationSpanStart != -1 && nSequNum >= nBackTranslationSpanStart) && 
		(nBackTranslationSpanEnd != -1 && nSequNum <= nBackTranslationSpanEnd))
	{
		if (remBT)
		{
			// do this only if removal of back translations has been requested, and the
			// back translation is present on this pSrcPhrase (remove even if the back 
			// translation is itself an empty string, but don't put an empty back translation
			// into the CStringList in gEditRecord)
			if (pRec->bEditSpanHasBackTranslations)
			{
				// there may be a back translation stored here, if so remove it and insert it
				// at the head of the list for retaining removed back translations in gEditRecord
				nOffset = pSrcPhrase->m_markers.Find(marker);
				if (nOffset != -1)
				{
					// there is a collected back translation section stored here (beware, its contents may
					// have been cleared out by user action earlier, so we can't be certain there is a
					// back translation between \bt and the next \~FILTER* marker, but at least the marker
					// is present)
					str = GetExistingMarkerContent(marker,endmarker,pSrcPhrase,nContentStartingOffset,
													nContentStringLength);
					// remove this back translation from the passed in CSourcePhrase instance
					// and throw it away (as we can programmatically recollect as the last step of
					// the edit process, so no need to store it)
					RemoveContentWrappers(pSrcPhrase,marker,nContentStartingOffset);
					str.Empty();
				} // end block for having tested for a \bt marker and found one, or a \bt-derived one
			} // end block for testing for presence of back translations in the editable span
		}
	}
	
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the removals were done successfully, or if there were no removals
///             needing to be done; FALSE if a removal attempt failed, or if no edit 
///             operation is currently in effect
/// \param      pSrcPhrase	->	pointer to the modifications list, a SPList, within 
///                             gEditRecord, where the modifiable deep copied 
///                             CSourcePhrase instances are stored temporarily (there are
///                             potentially many more instances in this list than belong 
///                             within the editable span, because of the possibility of 
///                             span expansion due to the presence of free and/or back 
///                             translations)
/// \param      pRec		<->	pointer to the global EditRecord struct, gEditRecord, 
///                             which records edit spans, lists of CSourcePhrase instances, 
///                             lists of removed strings, starting and ending TextType 
///                             values, and various booleans reflecting the state of
///                             the edit process
/// \param      pAdaptList	->	an empty list which is to receive any removed adaptations
/// \param      pGlossList	->	an empty list which is to receive any removed glosses
/// \param      pFTList		->	an empty list which is to receive any removed free translations
/// \param      pNoteList	->	an empty list which is to receive any removed notes
/// \remarks
/// Called from: the View's OnEditSourceText().
/// Scans a span of Source Phrases and removes adaptations, glosses, free translations and
/// notes storing them in lists for later processing and incorporation into the document after
/// the user edits the source text. 
/// Iterating forward it starts from the end of the sublist, but removals are potentially done 
/// only from the CSourcePhrase instances which fall within the appropriate span. The internal 
/// function call, RemoveInformationDuringEdit(), has all the smarts needed so that it removes 
/// each information type only in the subspan appropriate for that type. Information removed 
/// is stored in lists, within gEditRecord, except that removed back translations are abandoned 
/// because they can be re-collected automatically (once the user indicates which line of the 
/// strips to collect from) at the end of the edit process. (While we could remove adaptations 
/// and glosses that are within the editable span, there is really no need because their parent
/// CSourcePhrase instances will be recreated from the edited source text and will replace the 
/// older ones, so we will leave them in place in order to save processing time, and just put 
/// copies in the storage lists for these two types of information.)
/// 
/// Note: this function does nothing to the CSourcePhrase instances stored in the App class's
/// m_pSourcePhrases list, so if there is an error herein, the document is still intact on 
/// return.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ScanSpanDoingRemovals(SPList* pSrcPhrases, EditRecord* pRec,
							wxArrayString* pAdaptList, wxArrayString* pGlossList,
							wxArrayString* pFTList, wxArrayString* pNoteList)
{
	// 19May08	function created as part of refactoring the Edit Source Text functionality
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->GetFirst(); //POSITION pos = pSrcPhrases->GetHeadPosition();
	bool bAllWasOK = TRUE;
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		// whm: No need to localize the following error message.
		wxMessageBox(_T("GetHeadPosition() failed in ScanSpanDoingRemovals(), pos value is NULL. Saving document, abandoning edit."
		), _T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

	// scan over the modifications span
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		// do the smart information removals for this pSrcPhrase, but for adaptations and glosses,
		// place copies in the respective lists, but don't do any removals; the pRec parameter passes
		// in the knowledge of where the various subspans (editable span, free translation span, collected
		// back translations span) begin and end
		bAllWasOK = RemoveInformationDuringEdit(pSrcPhrase, pSrcPhrase->m_nSequNumber, pRec, 
					pAdaptList, pGlossList, pFTList, pNoteList, TRUE, TRUE, TRUE, TRUE, TRUE);
		if (!bAllWasOK)
		{
			// whm: No need to localize the following error message.
			wxMessageBox(_T("RemoveInformationDuringEdit() returned FALSE in loop within ScanSpanDoingRemovals(). Saving document, abandoning edit."
			), _T(""), wxICON_EXCLAMATION);
			return FALSE;
		}
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the reconstruction was done successfully, FALSE if the 
///             reconstruction attempt failed, or if no edit operation is currently 
///             in effect
/// \param      pSrcPhrase	->	pointer to the deep copied sublist of CSourcePhrase instances 
///                             found in modifications list, (but only that subspan of it 
///                             which is the editable span is actually used for the 
///                             reconstrution)
/// \param      pRec		<->	pointer to the global EditRecord struct, gEditRecord,
///                             which records edit spans, lists of CSourcePhrase instances, 
///                             lists of removed strings, starting and ending TextType 
///                             values, and various booleans reflecting the state of the 
///                             edit process, etc.
/// \param      nStartingSN	->	the sequence number value in pSrcPhrases where the editable span 
///                             commences (note: the CSourcePhrase's m_nSequNumber member has 
///                             to be examined, not the index for the list's elements, 
///                             because the list is a sublist copied from the document's list)
/// \param      nEndingSN	->	the sequence number value in pSrcPhrases where the editable 
///                             span ends, including the CSourcePhrase instance at this index 
///                             value (& likewise, the index value we check is that in the 
///                             m_nSequNumber member)
/// \param      strSource	<-	returns the accumulated editable source text, minus any 
///                             initial endmarkers and with any following context-initial 
///                             endmarkers appended
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The span used for this scan is the editable span, but the sublist traversed in the scan 
/// is potentially wider - depending on whether free translations and / or collected back 
/// translations earlier caused the original editable span to be widened when forming the 
/// modifications span, and it is the modifications span which is passed in. The editable 
/// subspan will coincide with the user's selection, except if/when the user's selection 
/// partly overlapped a retranslation - in the latter case, the span will have been 
/// extended to include all of the retranslation; the result, whichever is the case, is what
/// we are calling the "editable span", and this is the span of source text which the user 
/// will see and which is available for editing.
/// 
/// Special attention must be given to (a) an initial endmarkers, and (b) any endmarkers 
/// which commence the beginning of the following context. For (a) we must remove them from 
/// the accumulated string (because, they do not belong with the editable text) and the 
/// code can later restore them to their proper place once the edit of the source text is 
/// done, but for (b) we must append any final endmarkers to the end of the editable string 
/// which is to be shown to the user, because that is where they logically belong. Hence (a) 
/// and / or (b) when, pertinent will help make the user's experience concordant with what 
/// marker & endmarker delimitations he would expect to obtain. For instance, if he selects 
/// a footnote in order to edit the whole of it, he'd expect to see \f at its start, and 
/// \f* at its end - even though the \f* was stored outside of the editable span as far 
/// as the original selection was concerned.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ScanSpanDoingSourceTextReconstruction(SPList* pSrcPhrases, EditRecord* pRec,
				int nStartingSN, int nEndingSN, wxString& strSource)
{
	// 5May08	function created as part of refactoring the Edit Source Text functionality
	CSourcePhrase* pSrcPhrase = NULL;
	int nThisSN;
	SPList::Node* pos = pSrcPhrases->GetFirst(); // POSITION pos = pSrcPhrases->GetHeadPosition();
	//bool bAllWasOK = TRUE; // unused
	bool bLacksInitialEndmarkers = pRec->strInitialEndmarkers.IsEmpty();
	bool bLacksFinalEndmarkers = pRec->strFinalEndmarkers.IsEmpty();
	
	strSource.Empty(); // ensure strSource starts out empty

	// no error is expected, but we'll check and abort the app with an English message if a valid pos
	// was not found, but have the caller do a save to retain user's work & terminate the edit attempt
	if (pos == NULL)
	{
		// whm: no need to localize this type of error message
		wxMessageBox(_T("GetHeadPosition() failed in ScanSpanDoingSourceTextReconstruction(), pos value is NULL. Saving document and abandoning edit."
		), _T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

	// scan over the list, and test for pRscPhrase pointers within the editable span;
	// for those, we collect the source text with its punctuation (if any), and precede
	// it with the contents of any non-empty m_markers member. The firt CSourcePhrase instance
	// is given special attention because it may need initial endmarkers removed.
	bool bIsFirst = TRUE;
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;

		if (nThisSN >= nStartingSN && nThisSN <= nEndingSN)
		{
			// any sequence number meeting that condition lies within the editablel span, so
			// collect from it...

			// do the source text reconstrution; any material in m_markers must come first, and
			// we don't consider m_markers if the CSourcePhrase instance is a placeholder one
			// because inserted placeholders are not going to store marker info except posibly for
			// the information types (notes, free translations, back translations) which have
			// already been removed

			// remove any initial endmarkers which we would prefer the user not see (it is
			// conceivable that there may be initial endmarkers stored in the CSourcePhrase for
			// a placeholder, so don't limit the RemoveInitialEndmarkers() call to only a 
			// non-placeholder)
			if (bIsFirst)
			{
				wxString markers = pSrcPhrase->m_markers;
				if (!bLacksInitialEndmarkers)
				{
					// there are initial endmarker(s) to be removed, so do so
					int offset = -1;
					wxString endmkrs = pRec->strInitialEndmarkers; // includes final space(s)
					int len = endmkrs.Length();
					wxASSERT(len > 0);
					offset = markers.Find(endmkrs);
					wxASSERT(offset == 0);
					markers = markers.Mid(len);
				}
				if (!markers.IsEmpty())
				{
					// there is remaining marker information, so append it
					strSource += markers;
				}
				bIsFirst = FALSE; // make sure this block is never entered more than once
			}
			else
			{
				// the CSourcePhrase instances non-inital in the editable span are checked here
				if (!pSrcPhrase->m_markers.IsEmpty() && !pSrcPhrase->m_bNullSourcePhrase)
				{
					if (strSource.IsEmpty())
					{
						strSource = pSrcPhrase->m_markers;
					}
					else
					{
						strSource += pSrcPhrase->m_markers;
					}
				}
			}

			// always collect the m_srcPhrase member (which has any punctuation), and append a
			// following space each time; but only provided we are not at a placeholder
			if (!pSrcPhrase->m_bNullSourcePhrase)
			{
				if (strSource.IsEmpty())
				{
					strSource = pSrcPhrase->m_srcPhrase;
				}
				else
				{
					strSource = strSource + _T(" ") + pSrcPhrase->m_srcPhrase;
				}
			}
			if (nThisSN >= nEndingSN)
			{
				// we are at the end of the editable span, so break out of the loop
				break;
			}
		}
	}
	// The editable span may end where there may have been endmarkers, in which case
	// they will have been stored at the beginning of the m_markers member of the
	// CSourcePhrase instance immediately following the editable span. We've found
	// this endmarkers substring in the caller already, if it exists, so append the
	// markers now before returning
	if (!bLacksFinalEndmarkers)
	{
		// a non-empty final endmarkers substring is available, so append it
		strSource += pRec->strFinalEndmarkers;
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if one or more endmarkers were transferred, (and if they were then the 
///             carrier CSourcePhrase instance will have also been deleted from the end of 
///             the pNewSrcPhrases list). The caller will want to pass knowledge of these 
///             facts to the function which adjusts the TextType in the new section of source 
///             text, so that proper propagation of altered TextType can be done if the user 
///             has modified the markup. Or FALSE if no endmarkers were transferred.
/// \param      pNewSrcPhrases	->	pointer to the SPList pointer in the EditRecord which 
///                                 holds the list of CSourcePhrase instances resulting from 
///                                 the parse of the new source text as edited by the user
/// \param      pFollSrcPhrase	<->	pointer to the first CSourcePhrase instance in the context 
///                                 which follows the editable span of instances in 
///                                 m_pSourcePhrases list in the app; this is the instance 
///                                 whose m_markers member will receive any transferred 
///                                 endmarkers to the beginning of that member; pass in
///                                 NULL if there is no following context (because we are at 
///                                 the end of the document) - in such a circumstance no 
///                                 transfer can be done and the carrier CSourcePhrase in 
///                                 pNewSrcPhrases for the endmarkers, or now-filtered 
///                                 information, will have to be included in the document 
///                                 where it would continue to carry those markers or filtered 
///                                 info
/// \param      pRec		    <->	pointer to the global EditRecord struct, gEditRecord, which
///                                 records edit spans, lists of CSourcePhrase instances, 
///                                 lists of removed strings, starting and ending TextType 
///                                 values, and various booleans reflecting the state of 
///                                 the edit process
/// \remarks
/// Called from: the View's OnEditSourceText().
/// This function does several jobs. (1) It detects if the new source text ends with one or
/// more endmarkers, or with filtered information. Either will manifest in the new list of 
/// CSourcePhrase instances as the final one in the list, with m_key empty, m_follPunct 
/// empty, and m_markers containing just the one or more endmarkers and possibly a final 
/// space, or, the \~FILTER and \~FILTER* wrapped filtered content. When there is one or 
/// more such endmarkers, or filtered content, they have to be stored on the CSourcePhrase 
/// which is first in the following context. So that transfer is done here. (2) Moving the 
/// endmarkers leaves a CSourcePhrase instance whose only reason for existing was to carry 
/// the endmarkers; so once they have gone, this carrier instance must be deleted. Same for
/// filtered information. (3) Knowledge of what happened is passed back to the caller by 
/// the returned BOOL parameter. (Note: we check for m_precPunct non-empty, because a 
/// CSourcePhrase instance that results from a parse of endmarker followed by punctuation 
/// will manifest as m_prevPunct carrying the punctuation and m_marker having the endmarker; 
/// in such a circumstance, if we transferred the endmarker to the following CSourcePhrase 
/// then we'd effect a bogus rearrangment of the linear order of the endmarker and the 
/// punctuation. Hence we bleed that case out by testing and returning FALSE if there is 
/// preceding punctuation. Only after that do we look at the m_follPunct and m_markers
/// members.) (4) A fourth task is to store any final endmarkers, because they may be 
/// different than what was there before, or there may have been none before but now there 
/// are some present. In the case of now-filtered information, we don't need to store 
/// that, as any Cancel or bailout operation will recover that information from stored 
/// CSourcePhrase instances within the EditRecord. (5) A fifth task, but only when a 
/// typo marker has been corrected, is to clear the m_bFirstOfType flag and clear 
/// "?\mkr?" from the m_inform member, both done on the gpFollSrcPhrase which is first 
/// in the following context.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::TransportWidowedEndmarkersToFollowingContext(SPList* pNewSrcPhrases, 
			CSourcePhrase* pFollSrcPhrase, EditRecord* pRec)
{
	//7May08	function created as part of refactoring the Edit Source Text functionality
	if (pFollSrcPhrase == NULL)
	{
		// there is no following context, so no marker transfer can be done, so the carrier
		// CSourcePhrase (if there is one) must be retained as it is - so we've nothing to do
		//but tell the caller no transfer was done
		return FALSE;
	}

	// get the final CSourcePhrase in the list; but if the list is empty (ie. the user used the
	// edit source text dialog to remove all the displayed source text) then there will not be
	// any endmarkers to transfer (otherwise the list would have at least one entry), so return FALSE
	int nCount = pNewSrcPhrases->GetCount();
	if (nCount == 0)
	{
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
		pRec->strNewFinalEndmarkers.Empty();
		pRec->bDocEndPreventedTransfer = FALSE; // a TRUE value is pointless if nothing is there
		return FALSE;
	}
	SPList::Node* lastPos = pNewSrcPhrases->GetLast();
	CSourcePhrase* pLastSrcPhrase = lastPos->GetData();
	wxASSERT(pLastSrcPhrase != NULL);
	if (pLastSrcPhrase->m_markers.IsEmpty())
	{
		// no final endmarkers to transfer, and no now-filtered information to transfer
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
		pRec->strNewFinalEndmarkers.Empty();
		pRec->bDocEndPreventedTransfer = FALSE; // a TRUE value is pointless if m_markers is empty
		return FALSE; 
	}
	if (!pLastSrcPhrase->m_precPunct.IsEmpty())
	{
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
		pRec->strNewFinalEndmarkers.Empty();
		pRec->bDocEndPreventedTransfer = FALSE; // a TRUE value is misleading if the final one was
												// retained for a different reason than being at the
												// document's end
		return FALSE; // this punctuation prevents endmarker transfer, see description above for why;
					  // and the same applies for any now-filtered information
	}

	// m_markers has some content, check for endmarkers or filtered information. We can't assume USFM endmarkers
	// (these have a final asterisk *) because the SFM set could be the PNG 1998 one, where \fe and \F are
	// endmarkers. So we'll use the RemoveInitialEndmarkers() function from Helpers.cpp, which has 
	// the smarts we need here. If the function removes endmarkers, then pLastSrcPhrase is modified. In the case
	// of now-filtered information, RemoveInitialEndmarkers does not handle that, and the SFM set is irrelevant,
	// so we handle that possibility first. There can't be both now-filtered info AND endmarkers to be transferred
	// as well, only one or the other, or neither.
	bool bLacksEndmarkers = FALSE; // default, because of the logic further down
	wxString endmarkers;
	wxString filteredInfo;
	bool bFilteredInfoToBeTransferred = FALSE;
	pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // start off assuming there is none to be handled
	int aPosition = -1;
	aPosition = pLastSrcPhrase->m_markers.Find(filterMkr); // search for "\\~FILTER" literal string (a global)
	if (aPosition != -1)
	{
		// there is now-filtered information present on the last CSourcePhrase instance, so indicate it
		// has to be handled further down in the function -- but don't do it yet because it only needs
		// to be done provided pLastSrcPhrase's m_key and m_follPunct CString members are both empty
		bFilteredInfoToBeTransferred = TRUE;
		filteredInfo = pLastSrcPhrase->m_markers;
		pRec->strNewFinalEndmarkers.Empty(); // ensure this member is empty, there can't be endmarkers if
									// it is now-filtered information that possibly needs to be transferred
	}
	else
	{
		// there isn't any now-filtered info, but there might be endmarkers, so check and handle the
		// removal of those from pLastSrcPhrase
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
		// now try for endmarkers instead
		endmarkers = RemoveInitialEndmarkers(pLastSrcPhrase, gpApp->gCurrentSfmSet, bLacksEndmarkers);
		if (bLacksEndmarkers)
		{
			pRec->strNewFinalEndmarkers.Empty(); // ensure the member is empty
		}
		// we don't do an else block here in which we do the store, because we only store the endmarkers
		// in pRec provided they get transferred, and we aren't sure we need to yet - until we test for
		// empty key and m_follPunct members below
	}

	// we have some endmarkers or filtered info to transfer - do so, but only provided pLastSrcPhrase's
	// m_key and m_follPunct CString members are both empty
	if (bFilteredInfoToBeTransferred || !bLacksEndmarkers)
	{
		// only do the transfer provided there is something there to be transferred in the first place;
		// and only if the relevant members are empty (which indicates a CSourcePhrase otherwise unwanted)
		if (pLastSrcPhrase->m_key.IsEmpty() && pLastSrcPhrase->m_follPunct.IsEmpty())
		{
			// in either case, the stuff is transferred to the start of the destination m_markers member
			if (bFilteredInfoToBeTransferred)
			{
				// it's filtered information we are dealing with
				pFollSrcPhrase->m_markers = filteredInfo + pFollSrcPhrase->m_markers;

				// record, in the EditRecord, what we just did
				pRec->bTransferredFilterStuffFromCarrierSrcPhrase = TRUE;

				// because the original bogus marker was incorrect, clear the m_bFirstOfType flag to
				// permit propagation of parameters to be done by the caller after we return (we can't
				// be sure this reset is wanted when what we are transferring is endmarkers only, so
				// we don't do the same in the else block below)
				pFollSrcPhrase->m_bFirstOfType = FALSE;

				// likewise, the bogus marker should now be correct (or filtered), so at least clear
				// the "?\mkr?" string from m_inform. Even if we don't manage to make the navigation
				// text show the corrected marker name, at worse that is benign and does not affect the
				// integrity of the document (and if RetokenizeText() is later called by the caller, which
				// it should be, that should fix up the navigation text to be what it should be - I think
				// Likewise, in the case of transferring just endmarkers, we also can't be sure that this
				// adjustment is needed in the else block, so we don't do so there either.
				int anOffset = -1;
				wxString accumulateStr;
				wxString inform = pFollSrcPhrase->m_inform;
				anOffset = inform.Find(_T('?'));
				if (anOffset != -1)
				{
					// there is a bogus marker name to be removed
					accumulateStr += inform.Left(anOffset);
					anOffset++; // get past the first ? character
					inform = inform.Mid(anOffset); // use the remainder for next test
					anOffset = inform.Find(_T('?'));
					if (anOffset != -1)
					{
						// go through with the rest only provided we have found the
						// matching ? which delimits the end of the "?\mkr?" substring
						anOffset++; // get past the final ? character
						inform = inform.Mid(anOffset); // get whatever remains, possibly nothing
						accumulateStr += inform; // add it to the initial material
						// we have done this just in case there is also the name of one or more
						// non-bogus markers in the m_inform member; we want to retain those
						pFollSrcPhrase->m_inform = accumulateStr;
					}
				}
			}
			else
			{
				// its endmarkers we are dealing with
				pFollSrcPhrase->m_markers = endmarkers + pFollSrcPhrase->m_markers;

				// store the endmarkers, in case we later need to retore the original document state
				pRec->strNewFinalEndmarkers = endmarkers;
			}

			// now delete the carrier, pLastSrcPhrase, which is no longer needed & update the
			// count value stored in pRec to comply with this deletion; remove the pointer at the
			// tail of the list too
			gpApp->GetDocument()->DeleteSingleSrcPhrase(pLastSrcPhrase);
			pRec->nNewSpanCount -= 1;
			//pNewSrcPhrases->RemoveTail();
			// wxList has no RemoveTail() so we do it in two parts:
			SPList::Node* spLast = pNewSrcPhrases->GetLast();
			pNewSrcPhrases->DeleteNode(spLast);

			pRec->bDocEndPreventedTransfer = FALSE; // make sure we get value correct
			return TRUE;
		}
	}
	// if control gets to here, we've done no transfers, so inform the caller
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrases  -> the document's m_pSourcePhrases list of CSourcePhrase instances
/// \param      pRec         -> the EditRecord for the vertical edit process, which contains the indices 
///                             for the start and end of the CSourcePhrase instances in spans we want to 
///                             check
/// \remarks
/// Called from: the View's OnEditSourceText().
/// Checks the editable text span, and the preceding and following moved notes span, to make sure that the
/// m_bHasNote flag is set TRUE for every CSourcePhrase instance which contains a \note marker in its
/// m_markers member. If the flag is not set and should be, it sets it.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::CheckAndFixNoteFlagInSpans(SPList* pSrcPhrases, EditRecord* pRec)
{
	//20June08 created by BEW
	//CAdapt_ItView* pView = gpApp->GetView(); // unused

	// first check the editable span
	int nStartAt = pRec->nStartingSequNum;
	int nEndAt = nStartAt + pRec->nNewSpanCount - 1;
	wxString mkr = _T("\\note");
	CSourcePhrase* pSrcPhrase = NULL;
	int offset = -1;
	SPList::Node* pos = pSrcPhrases->Item(nStartAt); // POSITION pos = pSrcPhrases->FindIndex(nStartAt);
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		offset = pSrcPhrase->m_markers.Find(mkr);
		if (offset != -1)
		{
			// there is a note stored here
			pSrcPhrase->m_bHasNote = TRUE; // ensure the note is flagged in case
										   // in case the user edited a typo SF
										   // resulting in a Note which got filtered
		}
		// break out of the loop once we've checked the last in the span
		if (pSrcPhrase->m_nSequNumber >= nEndAt)
			break; 
	}
	// next check 5 or as many CSourcePhrase instances there are in the
	// follNotesMoveSpanList and precNotesMoveSpanList (5 because we can't
	// be sure either of those lists has content), doing these checks preceding
	// and following the editable span
	// start with the span following the editable span
	int nNextStartAt = nEndAt + 1;
	int nNextEndAt;
	int delta = 0;
	// don't do it if the following context does not exist
	if (nNextStartAt < gpApp->m_maxIndex)
	{
		delta = wxMin(5,pRec->arrNotesSequNumbers.GetCount());
		if (delta < 5) delta = 5;
		nNextEndAt = nNextStartAt + delta - 1;
		if (nNextEndAt > gpApp->m_maxIndex)
			nNextEndAt = gpApp->m_maxIndex;
		// now do the check of these
		SPList::Node* pos = pSrcPhrases->Item(nNextStartAt); // pos = pSrcPhrases->FindIndex(nNextStartAt);
		wxASSERT(pos != NULL);
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);
			offset = pSrcPhrase->m_markers.Find(mkr);
			if (offset != -1)
			{
				// there is a note stored here
				pSrcPhrase->m_bHasNote = TRUE; // ensure the note is flagged in case
											   // in case the user edited a typo SF
											   // resulting in a Note which got filtered
			}
			// break out of the loop once we've checked the last in the span
			if (pSrcPhrase->m_nSequNumber >= nNextEndAt)
				break; 
		}
	}
	// finally, do the same check and fix for the preceding context, at least 5, etc
	nNextEndAt = nStartAt - 1;
	delta = 0;
	// don't do it if the preceding context does not exist
	if (nNextEndAt < 0)
	{
		delta = wxMin(5,pRec->arrNotesSequNumbers.GetCount());
		if (delta < 5) delta = 5;
		nNextStartAt = nNextEndAt - delta + 1;
		if (nNextStartAt < 0)
			nNextStartAt = 0;
		// now do the check of these
		SPList::Node* pos = pSrcPhrases->Item(nNextStartAt); // pos = pSrcPhrases->FindIndex(nNextStartAt);
		wxASSERT(pos != NULL);
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);
			offset = pSrcPhrase->m_markers.Find(mkr);
			if (offset != -1)
			{
				// there is a note stored here
				pSrcPhrase->m_bHasNote = TRUE; // ensure the note is flagged in case
											   // in case the user edited a typo SF
											   // resulting in a Note which got filtered
			}
			// break out of the loop once we've checked the last in the span
			if (pSrcPhrase->m_nSequNumber >= nNextEndAt)
				break; 
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error
/// \param      pOriginalList        ->	 pointer to an CObList (short) list containing deep copies of 
///                                      a subspan of CSourcePhrase instances from the m_pSourcePhrases 
///                                      list in the app
/// \param      pDestinationList     <-> pointer to the list which is potentially to have CSourcePhrase 
///                                      instances (their pointers, actually) inserted in it at the start, 
///                                      and possibly at the end as well, in order to extend the 
///                                      original pDestinationList to comply with a desired wider span
/// \param      nOldList_StartingSN  ->	the sequence number index which determines the starting sequence 
///                                     number value for the instances already in pDestination list at 
///                                     the time that that list is passed in
/// \param      nOldList_EndingSN    ->	the sequence number index which determines the ending (inclusive) 
///                                     sequence number value for the instances already in pDestination 
///                                     list at the time that that list is passed in
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The algorith is as follows. The pOriginalList (which is potentially wider than pDestinationList) is
/// scanned from its beginning, and each pSrcPhrase's m_nSequNumber value is tested against the
/// nOldList_StartingSN value; if the former is less than the latter, then that particular pSrcPhrase 
/// also needs to be put in the pDestinationList - so we make a deep copy and insert it; we iterate 
/// this until the m_nSequNumber value reaches nOldList_StartingSN and break out, because that pSrcPhrase 
/// instance is already in pDestinationList. Then we skip to the nOldList_EndingSN location, and when 
/// we find it, we test to see if any pSrcPhrase instances from the end of the pOriginalList follow that 
/// location -- that is, if their m_nSequNumber values are greater than nOldList_EndingSN. Any that are 
/// deep copied and appended to the pDestinationList. (Copies are inserted or appended, and so the caller 
/// must delete the deep copies in the pOriginalList, if appropriate, on return.)
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::CopyCSourcePhrasesToExtendSpan(SPList* pOriginalList, SPList* pDestinationList,
												   int nOldList_StartingSN, int nOldList_EndingSN)
{
	// 13May08	function created as part of refactoring the Edit Source Text functionality
	SPList::Node* posOrig = pOriginalList->GetFirst(); //POSITION posOrig = pOriginalList->GetHeadPosition();
	if (posOrig == NULL)
	{
		// whm Note: no translation for localization need be done for this type of error message
		wxMessageBox(_T("FindIndex() failed in MoveCSourcePhrasesToExtendSpan(), posOrig value is NULL. Saving document. Abandoning edit."
		), _T(""), wxICON_EXCLAMATION);
		BailOutFromEditProcess(gpApp->m_pSourcePhrases, &gEditRecord); // restore original document state
		wxCommandEvent evt;
		gpApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* posInsert = pDestinationList->GetFirst(); //POSITION posInsert = pDestinationList->GetHeadPosition();
	if (posInsert == NULL)
	{
		// whm Note: no translation for localization need be done for this type of error message
		wxMessageBox(_T("FindIndex() failed in MoveCSourcePhrasesToExtendSpan(), posInsert value is NULL. Saving document. Abandoning edit."
		), _T(""), wxICON_EXCLAMATION);
		BailOutFromEditProcess(gpApp->m_pSourcePhrases, &gEditRecord); // restore original document state
		wxCommandEvent evt;
		gpApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	int nSequNum = -1;
	bool bIsFirst = TRUE;
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pNewOne = NULL;
	while (posOrig != NULL)
	{
		pSrcPhrase = posOrig->GetData();
		posOrig = posOrig->GetNext();
		wxASSERT(pSrcPhrase);
		nSequNum = pSrcPhrase->m_nSequNumber;
		if (nSequNum < nOldList_StartingSN)
		{
			// a deep copy of this CSourcePhrase instance needs to be inserted following earlier
			// insertions into the pDestinationList, or if this is the first to be inserted,
			// then at the start of that list
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			if (bIsFirst)
			{
				// whm: In wxList Insert inserts by default at the head/beginning of the list
				posInsert = pDestinationList->Insert(pNewOne);//posInsert = pDestinationList->AddHead(pNewOne);
				//ASSERT(posInsert);
				bIsFirst = FALSE;
			}
			else
			{
				//posInsert = pDestinationList->InsertAfter(posInsert,pNewOne);
				// wxList has no equivalent to InsertAfter(). The wxList Insert() method 
				// inserts the new node BEFORE the current position/node. To emulate what
				// the MFC code does, we can advance one node before calling Insert()
				// geting a node called posNextHigher which points to the next node beyond the 
				// current position, and use its position in the Insert() call (which only inserts 
				// BEFORE the indicated position). The result should be that the insertions 
				// will get placed in the list the same way that MFC's InsertAfter() places them.
				// wx additional note: If the item is to be inserted after the last item in the list 
				// posNextHigher will return NULL, in that case, just append the new item to the list.
				SPList::Node* posNextHigher = posInsert->GetNext();
				if (posNextHigher == NULL)
					posInsert = pDestinationList->Append(pNewOne);
				else
					posInsert = pDestinationList->Insert(posNextHigher,pNewOne);
				//wxASSERT(posInsert);
			}
		}
		if (nSequNum >= nOldList_StartingSN && nSequNum <= nOldList_EndingSN)
			continue;
		if (nSequNum > nOldList_EndingSN)
		{
			// Any which remain have to be appended to the destination list
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			posInsert = pDestinationList->Append(pNewOne);
		}
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrases  ->	pointer to the m_pSourcePhrases list in the app 
/// \param      pRec         ->	pointer to the EditRecord for the vertical edit process
/// \remarks
/// Called from: the View's BailOutFromEditProcess().
/// This function restores the contents of pSrcPhrases list to what it was prior to
/// the source text edit being attempted.
/// 
/// The passed in EditRecord, pRec, contains the information about the source text edit which
/// has just been completed, and in particular it includes the CSourcePhrase instances
/// in the cancel span, and the potentially overlapping (at the large sequence numbers end)
/// propagation span. It also has the starting and ending sequence number values for each
/// relevant span, and so it just requires some arithmetic, deletions and insertions in order
/// to reconstitute the original document state, now that the document's underlying native
/// structures have been modified.
/// 
/// There are four possible circumstances in which this function may be called.
/// (1) After the edit source text dialog is dismissed by an OK button click, and the
/// document has undergone modifications subsequent to that according to how the used edited
/// the source text, but somewhere along the way in doing those modifications an exception
/// was encountered.
/// 
/// (2) The user has progressed down somewhat in the vertical edit process, past the source
/// text edit step, and has decided to backtrack all the way to the original document state.
/// (This is unlikely, but must be allowed for. He's more likely though to just Cancel the
/// whole process in order to get back to the original doc state.) For this to work, any
/// changes to the number of source phrases made during the adaptations update step must be
/// removed (eg. mergers, placeholder insertions, retranslations), so that the entry point for
/// RestoreDocAfterSrcTextEditModifiedIt() is exactly as it was at the earlier end of the 
/// source text edit step. (Other restoration functions will have been called prior to this
/// function being entered, for whatever other steps were completed before the backtrack was
/// initiated.)
/// 
/// (3) As in (2) the user has progessed down somewhere in the vertical edit process, then
/// decides to cancel out of the whole process. Same caveat applies as in (2) about what the
/// initial conditions must be prior to RestoreDocAfterSrcTextEditModifiedIt() being entered,
/// and any completed lower steps having their restoration functions called first before
/// RestoreDocAfterSrcTextEditModifiedIt() is entered.
/// 
/// (4) As in (2) or (3), but an exception in one of the processing steps lower than source
/// text editing was encountered, so that the whole vertical edit must be abandoned - same
/// caveats as for (2) and (3) apply here also.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RestoreDocAfterSrcTextEditModifiedIt(SPList* pSrcPhrases, EditRecord* pRec)
{
	// 26May08	function created as part of refactoring the Edit Source Text functionality
	int nCount = 0;
	int nReplaceCount = 0;
	bool bReplacedOK = TRUE;
	wxString error;
	// since replacement of temporarily removed Notes is done last, the bailaout must
	// first replace any subspans involved in potential Note moves in the preceding or
	// following context; the array storing removed Notes' sequence numbers can be used
	// as a flag, if there were none removed, the array will be empty, and then no such
	// context restoration is required
	int nStartingAtSN;
	if (pRec->arrNotesSequNumbers.GetCount() > 0)
	{
		// do the restorations, if there are sublists to restore; first do the following context
		nCount = pRec->follNotesMoveSpanList.GetCount();
		if (nCount > 0)
		{
			// if the user deleted all the source text, start at the first CSourcePhrase
			// of the following context -- which will have become the same index as
			// nStartingSequNum; otherwise work out the first CSourcePhrase of
			// the following context using the nNewSpanCount value
			if (pRec->nNewSpanCount == 0)
			{
				nStartingAtSN = pRec->nStartingSequNum;
			}
			else
			{
				nStartingAtSN = pRec->nStartingSequNum + pRec->nNewSpanCount;
				// the above index will definitely lie within the document's list
				// because follNotesMoveSpanList is not empty
			}
			nReplaceCount = nCount;
			bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartingAtSN,
				nCount, &pRec->follNotesMoveSpanList, 0, nReplaceCount);
			if (!bReplacedOK)
			{
				// if we have an error while restoring the original document, then we can't get back
				// the document as it was, so it is best to abort the app and lose recent changes than
				// to continue and risk a malformed document or with content lacking somewhere within
				error = _T("Restoration following context potential moved notes span failed, ");
				error += _T(" so rather than save a bad document, we abort the ");
				error += _T("application now, losing the work done since the last save.");
				wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
				wxExit();
			}
		}
		// now the preceding context's subspan
		nCount = pRec->precNotesMoveSpanList.GetCount();
		if (nCount > 0)
		{
			nStartingAtSN = pRec->nStartingSequNum - 1; // the instance just prior to the edit span
			nStartingAtSN = nStartingAtSN - nCount + 1; // allow for the sublist's content
			// the above index will definitely lie within the document's list
			// because precNotesMoveSpanList is not empty
			nReplaceCount = nCount;
			bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartingAtSN,
				nCount, &pRec->precNotesMoveSpanList, 0, nReplaceCount);
			if (!bReplacedOK)
			{
				// if we have an error while restoring the original document, then we can't get back
				// the document as it was, so it is best to abort the app and lose recent changes than
				// to continue and risk a malformed document or with content lacking somewhere within
				error = _T("Restoration preceding context potential moved notes span failed, ");
				error += _T(" so rather than save a bad document, we abort the ");
				error += _T("application now, losing the work done since the last save.");
				wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
				wxExit();
			}
		}
	}

	// if the cancel span has instances to the left of the nStartingSequNum value for
	// the commencement of the former editable span, then replace the m_pSourcePhrases
	// instances in that range with the deep copies from the same subrange in the
	// cancel list; the consecutive values of the sequence numbers stored on the instances
	// are still correct after this next block is done
	if (pRec->nCancelSpan_StartingSequNum < pRec->nStartingSequNum)
	{
		nCount = pRec->nStartingSequNum - pRec->nCancelSpan_StartingSequNum;
		nReplaceCount = nCount;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, pRec->nCancelSpan_StartingSequNum,
			nCount, &pRec->cancelSpan_SrcPhraseList, 0, nReplaceCount);
		if (!bReplacedOK)
		{
			// if we have an error while restoring the original document, then we can't get back
			// the document as it was, so it is best to abort the app and lose recent changes than
			// to continue and risk a malformed document or with content lacking somewhere within
			error = _T("Restoration of the document failed in the initial replacements from the ");
			error += _T("cancel span, so rather than save a bad document, we abort the ");
			error += _T("application now, losing the work done since the last save.");
			wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
			wxExit();
		}
	}
	// now we must replace the CSourcePhrase instances which were the result of the user's edit,
	// with those which were in the original (possibly extended by a retranslation) editable span
	int nExtras = pRec->nOldSpanCount - pRec->nNewSpanCount; // could be +ve, 0, or -ve
	bReplacedOK = ReplaceCSourcePhrasesInSpan(
		pSrcPhrases,
		pRec->nStartingSequNum, // could be beyond doc end if the edit removed data from doc end
		pRec->nNewSpanCount, // could be zero, or small, or large
		&pRec->cancelSpan_SrcPhraseList, // where the replacements are to be taken from
		pRec->nStartingSequNum - pRec->nCancelSpan_StartingSequNum, // offset in cancel span
							// where the insertions are to be done from (inclusive)
		pRec->nOldSpanCount // how many old instances were in the editable span
	);
	if (!bReplacedOK)
	{
		// if we have an error while restoring the original document, then we can't get back
		// the document as it was, so it is best to abort the app and lose recent changes than
		// to continue and risk a malformed document or with content lacking somewhere within
		error = _T("Restoration of the document failed in the replacements from the ");
		error += _T("editable span within the cancel span, so rather than save a bad document, ");
		error += _T("we abort the application now, losing the work done since the last save.");
		wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
		wxExit();
	}
	else
	{
		// there could be more, same, or fewer CSourcePhrase instances in the document, so
		// make the required adjustments to doc and view parameters, if we need to
		if (nExtras != 0)
		{
			if (gpApp->m_endIndex + nExtras > gpApp->m_maxIndex)
			{
				// this one should be done first, because m_endIndex will only have been
				// changed if the bundle was positioned to include the end of the document,
				// and so the above test will be true only when that is where the bundle 
				// actually is, and only then is the adjustment required; m_upperIndex is
				// also a bundle parameter, so same logic applies to it
				gpApp->m_endIndex += nExtras;
				gpApp->m_upperIndex += nExtras;
			}
			// m_maxIndex is a document parameter, so must be unilaterally modified
			gpApp->m_maxIndex += nExtras;
		}
	}
	// update the sequence numbers, starting from the start of the cancel span
	UpdateSequNumbers(pRec->nCancelSpan_StartingSequNum);

	// now replace any CSourcePhrase instances at the end of the cancel span, provided they
	// lie beyond the end of the just replaced editable span
	if (pRec->nCancelSpan_EndingSequNum > pRec->nEndingSequNum)
	{
		// there are are some instances in the cancel span not yet replaced, so do so
		int nStartAt_InCancelSpan = pRec->nEndingSequNum - pRec->nCancelSpan_StartingSequNum + 1;
		int nHowMany_InCancelSpan = pRec->nCancelSpan_EndingSequNum - pRec->nEndingSequNum;
		int nStartAt_InDocList = pRec->nEndingSequNum + 1;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartAt_InDocList, nHowMany_InCancelSpan, 
						&pRec->cancelSpan_SrcPhraseList, nStartAt_InCancelSpan, nHowMany_InCancelSpan);
		if (!bReplacedOK)
		{
			// if we have an error while restoring the original document, then we can't get back
			// the document as it was, so it is best to abort the app and lose recent changes than
			// to continue and risk a malformed document or with content lacking somewhere within
			error = _T("Restoration of the document failed in the final replacements from the ");
			error += _T("cancel span, so rather than save a bad document, we abort the ");
			error += _T("application now, losing the work done since the last save.");
			wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
			wxExit();
		}
	}

	// The attempt to do source text editing could, if the SF markup was altered, result in a
	// new TextType having to be propagated forward into the following context. The propagation
	// would continue until a marker was encountered which changed the TextType, and so such a
	// propagation conceivably may sometimes go beyond the end of the cancel span. The text type
	// would be different on those CSourcePhrase instances, and also possibly the special text
	// boolean, and m_inform member. So the final task is to work out now if are any CSourcePhrase
	// instances in the propagation span (in the EditRecord) which lie beyond the end of the cancel
	// span; if so, we must replace that subspan of the document's list with the relevant deep 
	// copies from the propagation span list in the EditRecord.
	if (pRec->nPropagationSpan_EndingSequNum > pRec->nCancelSpan_EndingSequNum)
	{
		// there are are some instances in the propagation span not yet replaced, so do so
		int nStartAt_InPropSpan = pRec->nCancelSpan_EndingSequNum 
									- pRec->nPropagationSpan_StartingSequNum + 1;
		int nHowMany_InPropSpan = pRec->nPropagationSpan_EndingSequNum - pRec->nCancelSpan_EndingSequNum;
		int nStartAt_InDocList = pRec->nCancelSpan_EndingSequNum + 1;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartAt_InDocList, nHowMany_InPropSpan, 
						&pRec->propagationSpan_SrcPhraseList, nStartAt_InPropSpan, nHowMany_InPropSpan);
		if (!bReplacedOK)
		{
			// if we have an error while restoring the original document, then we can't get back
			// the document as it was, so it is best to abort the app and lose recent changes than
			// to continue and risk a malformed document or with content lacking somewhere within
			error = _T("Restoration of the document failed in the replacements from the ");
			error += _T("propagation span, so rather than save a bad document, we abort the ");
			error += _T("application now, losing the work done since the last save.");
			wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
			wxExit();
		}
	}
	// if we haven't aborted, then the original document state prior to the source text edit
	// has now been successfully restored
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error
/// \param      pSrcPhrases -> pointer to the document's m_pSourcePhrases list (the Note(s) 
///                             will be restored to instances of CSourcePhrase in this list)
/// \param      pRec        -> pointer to the EditRecord for the vertical edit process
/// \remarks
/// Called from: the View's OnEditSourceText().
/// Restores notes to the source text after having been removed during source text editing.
/// The passed in EditRecord contains the information about the source text edit which
/// has just been completed, and it includes an array, arrNotesSequNumbers, which stores
/// in normal order the sequence number indices for each Note that was removed from the
/// original editable span (this span will have been extended beyond the user's selection
/// to include all of any retranslation(s) it overlaps, but if there were no such overlaps
/// then it was the same as the user's selection). The array is used to assist in relocating
/// the removed notes. This is a difficult process because the user may have done a minor 
/// edit, or a major one, or removed his entire selection from the document. The best the
/// function can do is to try relocate the notes in approximately the same locations as much
/// as possible; without reordering any, and within the bounds formed by unremoved notes in
/// the preceding and following contexts, or the document's start or end. For an edit which
/// results in the same number of CSourcePhrase instances in the final edit span, or more, 
/// this is easy to do; when fewer instances result, some squeezing of note locations may
/// be required, and possibly even relocating some notes, or all, in the following context -
/// and if there is insufficient following context for that, left-shifting some or all in
/// order to create empty locations for the unreplaceable ones to be replaced. The whole of
/// this process is encapsulated in this function; unfortunately it isn't trivial to do, and
/// if there are too many Notes to be replaced near the end of the document so that not all
/// can be replaced, then the unreplaceable ones are simply lost - but the user is given a
/// message saying so.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RestoreNotesAfterSourceTextEdit(SPList* pSrcPhrases, EditRecord* pRec)
{
	// 26May08	function created as part of refactoring the Edit Source Text functionality
	wxArrayInt arrUnsqueezedLocations; //CArray<int,int> arrUnsqueezedLocations; // for those locations for which the old sequence
									// numbers are still valid, and in the edit span (in its final form)
	wxArrayInt arrSqueezedLocations; //CArray<int,int> arrSqueezedLocations; // for those locations for which the old sequence
									// numbers are not valid and therefore are squeezed leftwards

	// notes were removed, but this happens only for those in the editable span, and in
	// left to right order; so get the removals' minimum and maximum sequence numbers
	int nNumRemoved = pRec->arrNotesSequNumbers.GetCount();
	//int nRemovedFirstSN = pRec->arrNotesSequNumbers[0]; // unused
	//int nRemovedLastSN = pRec->arrNotesSequNumbers[nNumRemoved - 1]; // unused
	//int nSequNumberRemovalRange = nRemovedLastSN - nRemovedFirstSN; // unused
	//int nLastUnsqueezedSN = -1; // unused
	int nNumUnsqueezedLocations = -1;
	//int nNumSqueezedLocations = -1; // unused
	int nEditSpanStartingSN = pRec->nStartingSequNum; // this could be the start of the
		// 'following context' if the user's edit was to remove everything in the edit span
	int nEditSpanEndingSN; // for the same reason this once can also be at the start of the
						   // former following context
	if (pRec->nNewSpanCount == 0)
	{
		nEditSpanEndingSN = pRec->nStartingSequNum;
	}
	else
	{
		nEditSpanEndingSN = pRec->nStartingSequNum + pRec->nNewSpanCount - 1;
	}

	// find where there are existing unremoved notes, earlier and later than the edit span,
	// which will act as bounds for our note relocations - we can't transgress these bounds
	// without causing a reordering of at least a couple of notes, and reordering is forbidden
	int nLeftBound;
	int nRightBound;
	bool bNoError;
	if (nEditSpanStartingSN - 1 < 0)
	{
		// the edit span commenced at the start of the document, so the edit span's start
		// has to be the left bound
		nLeftBound = 0;
	}
	else
	{
		// FALSE in the last parameter of the next call means 'seach backwards'
		// (when searching backwards, the initial location is ignored; but not when
		// searching forward, so pass in the edit span's starting SN value)
		bNoError = FindNote(pSrcPhrases, nEditSpanStartingSN, nLeftBound, FALSE);
		if (!bNoError)
		{
			// an error message has been seen already, so return FALSE to the caller to make
			// the vertical edit process BailOut() function be called
			return FALSE;
		}
		if (nLeftBound == -1)
		{
			// no leftwards note was found, so the left bound is the start of the document
			// (otherwise, it is the value returned in nLeftBound)
			nLeftBound = 0;
		}
	}
	// Now nRightBound, no final BOOL parameter in the next call means 'seach forwards'
	bNoError = FindNote(pSrcPhrases, nEditSpanEndingSN, nRightBound); 
	if (!bNoError)
	{
		// an error message has been seen already, so return FALSE to the caller to make
		// the vertical edit process BailOut() function be called
		return FALSE;
	}
	if (nRightBound == -1)
	{
		// no forwards note was found, so the right bound is the end of the document
		// (otherwise, it is the value returned in nRightBound)
		nRightBound = gpApp->m_maxIndex;
	}

	// loop to handle the cases where note replacement can occur without location changes (but
	// there is no guarantee that any one note will be on the same word as formerly, nor even
	// that the notes' contents are appropriate for the new meaning at the places where they
	// will be put); these locations we will store in the unsqueezed array; we'll put the 
	// remainders in the squeezed array; but we'll put all in the squeezed array if the user's
	// edit was to delete the entire editable source text string
	int index;
	int aNoteSN;
	int nCurrentSN = nEditSpanStartingSN; // potential storage location's index
	if (pRec->nNewSpanCount == 0)
	{
		// the user deleted all the source text shown him in the dialog, so notes removed have
		// nowhere to go, so we'll just bunch them up in consecutive CSourcePhrase instances
		// in the old following context; but moving them left to create gaps if necessary
		bool bShiftingRightWorked;
		for (index = 0; index < nNumRemoved; index++)
		{
			if (!IsNoteStoredHere(pSrcPhrases, nCurrentSN))
			{
				// no note at this location, so we can restore a note at this location
				//arrSqueezedLocations.SetAtGrow(index,nCurrentSN);
				// whm Note: wxArrayInt doesn't have MFC's SetAtGrow() method, but we can 
				// accomplish the same thing. We can use the ::SetCount() method of wxArray to 
				// insure the array has at least anArrayIndex + 1 elements, then assign locIndex 
				// to element anArrayIndex. We only call SetCount() if the array is too small. 
				if (index+1 > (int)arrSqueezedLocations.GetCount())
					arrSqueezedLocations.SetCount(index+1); // any added elements to the array are assigned int(0) by default
				arrSqueezedLocations[index] = nCurrentSN;
				nCurrentSN++; // get the next potential storage location's index
			}
			else
			{
				// we've come to a bound, that is, a note already existing at this location
				// so we'll move it, and as many consecutive following ones as there are, one
				// place to the right, to create a gap for restoring the present one. If we
				// don't succeed in creating a gap this way (the only way to prevent it would
				// be to have come to the end of the document with a series of consecutive
				// notes), we'll next try left-shifting the already stored locations (remember,
				// these are locations without notes by definition, so we are just decrementing
				// stored index values) to create a gap that way - this will work so long as
				// we don't go bump into the nLeftBound value, but if that unthinkable thing
				// should happen, the only recourse is to insert the remaining Notes' text into
				// the removed free translations list, and tell the user he can get it/them from
				// there by entering Free Translation Mode and using the combobox there to
				// have any visible Note in the list sent to the Clipboard - after which he can
				// create an empty note (it can be done in Free Translation Mode) somewhere and
				// paste the old Note text into it.
				bShiftingRightWorked = 
						ShiftASeriesOfConsecutiveNotesRightwardsOnce(pSrcPhrases, nCurrentSN);
				if (bShiftingRightWorked)
				{
					// exploit the gap we created by the above call
					//arrSqueezedLocations.SetAtGrow(index,nCurrentSN);
					// whm Note: wxArrayInt doesn't have MFC's SetAtGrow() method, but we can 
					// accomplish the same thing. We can use the ::SetCount() method of wxArray to 
					// insure the array has at least anArrayIndex + 1 elements, then assign locIndex 
					// to element anArrayIndex. We only call SetCount() if the array is too small. 
					if (index+1 > (int)arrSqueezedLocations.GetCount())
						arrSqueezedLocations.SetCount(index+1); // any added elements to the array are assigned int(0) by default
					arrSqueezedLocations[index] = nCurrentSN;
					nCurrentSN++; // get the next potential storage location's index
				}
				else
				{
					// there are more to replace, but no more document space at the end on which
					// to store them, so now try leftshifting as explained above
					bool bLeftwardsOK = MoveNoteLocationsLeftwardsOnce(&arrSqueezedLocations, nLeftBound);
					if (bLeftwardsOK)
					{
						// exploit the gap we created by the above call
						nCurrentSN--; // the gap is at the end of the valid locations in the array, but
									  // we above had incremented nCurrentSN to point past that location,
									  // so we must decrement it so it indexes the gap we created
						//arrSqueezedLocations.SetAtGrow(index,nCurrentSN);
						// whm Note: wxArrayInt doesn't have MFC's SetAtGrow() method, but we can 
						// accomplish the same thing. We can use the ::SetCount() method of wxArray to 
						// insure the array has at least anArrayIndex + 1 elements, then assign locIndex 
						// to element anArrayIndex. We only call SetCount() if the array is too small. 
						if (index+1 > (int)arrSqueezedLocations.GetCount())
							arrSqueezedLocations.SetCount(index+1); // any added elements to the array are assigned int(0) by default
						arrSqueezedLocations[index] = nCurrentSN;
						nCurrentSN++; // get the next potential storage location's index
					}
					else
					{
						// left shifting indices bumped up against the left bound - we will call it quits
						// and just abandon the rest, and tell the user
						//
						// BEW changed 2Sep08, I want user's click on an item in the Removed list to send the
						// clicked string to the phrase box or free translation Compose box, directly. If I let
						// potentially huge Notes be stored in the free translations list, this could result in
						// unwieldly large strings having to be dealt with in the Compose bar's edit box. Since
						// an unreplaceable Note is, in practical terms, almost an impossibility, I'll just 
						// instead delete unreplaceable ones, but still warn the user what has happened.

						/* deprecated code
						int nRemainder = nNumRemoved - index;
						int nNewIndex;
						CStringList* pRemList = new CStringList;
						ASSERT_VALID(pRemList);
						CString aNote;
						POSITION pos2 = pRec->storedNotesList.FindIndex(index);
						ASSERT(pos2);
						for (nNewIndex = index; nNewIndex < nNumRemoved; nNewIndex++)
						{
							aNote = pRec->storedNotesList.GetNext(pos2);

							// change any carriage returns & linefeeds in the note to spaces, as we want
							// it to display on one line of the combobox list
							TCHAR crorlf[2] = {_T('\n'),_T('\r')};
							int offset = aNote.FindOneOf(crorlf);
							if (offset != -1)
							{
								// there is at least one, so change it to a space and do any others
								while (offset != -1)
								{
									aNote.SetAt(offset,_T(' '));
									offset = aNote.FindOneOf(crorlf);
								}
							}
							// add the (possibly modified) string to the list of removed free translations
							pRemList->AddTail(aNote);
							if (pos2 == NULL)
								break;
						}
						BOOL bResult = InsertSublistAtHeadOfList(pRemList, freeTranslationsList, pRec);
						if (!bResult)
						{
							// there was an error (an unknown list was requested in the switch)
							CString errStr = _T("InsertSublistAtHeadOfList(), for storing un-restorable ");
							errStr += _T("Notes in the free translations list, failed. ");
							errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
							AfxMessageBox(errStr,MB_ICONEXCLAMATION);
							pRemList->RemoveAll();
							delete pRemList;
							return FALSE;
						}
						
						delete pRemList; // the free translations list now manages these strings,
										 // so don't do any Remove() before doing this deletion
						*/

						// delete any which remain
						pRec->storedNotesList.Clear();

						// warn the user about what has happened
						int nRemainder = nNumRemoved - index;
						//TCHAR buff[34];
						//_itot(nRemainder,buff,10); // convert to a digit string
						wxString aStr; 
						// IDS_UNPLACEABLE_NOTES
						aStr = aStr.Format(_("Some temporarily removed Notes could not be restored to the document due to lack of space, so they have been discarded. Number of notes discarded: %d"),nRemainder);
						wxString message;
						//message.Format((LPCTSTR)aStr,buff);
						wxMessageBox(message, _T(""), wxICON_INFORMATION);
						break; // break out of the loop and let the rest of the function do the 
							   // replacements of those that were successfully relocated and stored
							   // in arrSqueezedLocations
					}
				}
			}
		}
	}
	else
	{
		// there is some new edited text, so the possibility of reconstituting at least some
		// of the removed notes on CSourcePhrase instances within the new edit span remains
		for (index = 0; index < nNumRemoved; index++)
		{
			aNoteSN = pRec->arrNotesSequNumbers[index]; // get the next note's location
			if (aNoteSN >= nEditSpanStartingSN && aNoteSN <= nEditSpanEndingSN)
			{
				// the note index falls within the edit span, store it unchanged in value
				// in the "unsqueezed" array
				arrUnsqueezedLocations.Add(aNoteSN);
			}
			else
			{
				// the note index falls later than the end of the edit span, so just store
				// it unchanged for the present in the "squeezed" array
				arrSqueezedLocations.Add(aNoteSN);
			}
		}
		if (arrSqueezedLocations.GetCount() == 0)
		{
			// all the removed ones were placed within the edit span, so go to en(d) to have
			// the relocated notes reconstituted in the document
			goto en;
		}
		else
		{
			// some would not fit in the edit span, so try fit the other ones within it at its
			// end, failing that, create gaps by left shifting and try fit at the end
			bool bRelocatedThemAll = BunchUpUnsqueezedLocationsLeftwardsFromEndByOnePlace(
									pRec->nStartingSequNum, pRec->nNewSpanCount,
									&arrUnsqueezedLocations, &arrSqueezedLocations, nRightBound);

			if (!bRelocatedThemAll)
			{
				// not all were successfully re-located, the remainder which are as yet
				// unrelocated are in arrSqueezedLocations; we will locate them in the following
				// context for the edit span, and move existing unremoved notes rightwards to
				// create gaps as far as possible, this will work except when there are a lot of
				// notes yet to be placed and we are at or near the document's end and there can't
				// be a sufficient number of note movements to the right in order to accomodate those
				// that remain in the locations vacated -- if that happens, the last unrelocated ones
				// will just be stored at the top of the removed free translations list, so as to be
				// accessible (though only when in free translation mode) rather than lost entirely
				int nRemainderCount = arrSqueezedLocations.GetCount();
				wxASSERT(nRemainderCount > 0);
				int nStartAt = pRec->nStartingSequNum + pRec->nNewSpanCount; // the first location 
																			 //following the edit span
				// check this is a valid index within the document's list
				if (nStartAt <= gpApp->m_maxIndex)
				{
					// the location is within the document; so we check for the presence of an existing
					// Note, and if there is none, we use the location as a location for recreating the
					// next Note, and remove the latter's old SN index from the start of the
					// arrSqueezedLocations array. If we bump against an already existing Note, we'll
					// move it (and any consecutive ones following it) a location rightwards, to create
					// the gap we need, etc.
					nNumUnsqueezedLocations = arrUnsqueezedLocations.GetCount(); // make sure it's value
																				// is current
					for (index = 0; index < nRemainderCount; index++)
					{
						// iterate over all those remaining unrelocated, relocating each...
						aNoteSN = nStartAt + index;
						bool bHasNote = IsNoteStoredHere(pSrcPhrases, aNoteSN);
						if (bHasNote)
						{
							// we've bumped against an already existing Note still in the document,
							// so we have to move it righwards (any any consecutives which follow it)
							// if we can...
							bool bMoveRightWorked = ShiftASeriesOfConsecutiveNotesRightwardsOnce(
																			pSrcPhrases, aNoteSN);
							if (bMoveRightWorked)
							{
								// we've created a gap at aNoteSN location, so set this location up
								// as one for Note relocation in the code later below
								arrSqueezedLocations.RemoveAt(0);
								// whm note: wxArrayInt's Insert method reverses the parameters! Caution: wx docs also
								// says of wxArray::Insert() "Insert the given number of copies of the item into the array
								// before the existing item n. This resulted in incorrect ordering of source phrases, so
								// we use array[] = assignment notation instead. Bruce's note indicates that it is going
								// to "insert at the array's end", so to be safe we insure that the array has at least
								// nNumInUnsqueezedArray elements by calling SetCount()
								if (nNumUnsqueezedLocations+1 > (int)arrUnsqueezedLocations.GetCount())
									arrUnsqueezedLocations.SetCount(nNumUnsqueezedLocations+1);
								arrUnsqueezedLocations[nNumUnsqueezedLocations] = aNoteSN; //arrUnsqueezedLocations.InsertAt(nNumUnsqueezedLocations,aNoteSN);
								nNumUnsqueezedLocations = arrUnsqueezedLocations.GetCount(); // update size
							}
							else
							{
								// the move rightwards by one location did not succeed (probably we got
								// to the end of the document); so the only recourse we have is to store
								// the remaining stored Note text strings at the head of the removed
								// free translations list (to make them accessible in Free Translation mode)
								int nRemainder = nRemainderCount - index;
								int nNewIndex;
								wxArrayString* pRemList = new wxArrayString;
								wxASSERT(pRemList != NULL);
								wxString aNote;
								//POSITION pos2 = pRec->storedNotesList.GetTailPosition();
								int lastIndexPos;
								lastIndexPos = pRec->storedNotesList.GetCount() -1;
								// whm note: below we need to juggle things around again, because
								// wxArrayInt doesn't have the same kind of methods that wxList has
								// (and are used by MFC on its CStringList).
								for (nNewIndex = index; nNewIndex < nRemainder; nNewIndex++)
								{
									//aNote = pRec->storedNotesList.GetPrev(pos2);
									// MFC's GetPrev() first gets the data item at pos2 then pos2 moves
									// to the previous element position. We do the same by getting the
									// data item at lastIndexPos, then decrementing lastIndexPos
									aNote = pRec->storedNotesList.Item(lastIndexPos);
									lastIndexPos--;
									// for wxArrayString we insert aNote at index 0 to do the same as
									// MFC's AddHead().
									pRemList->Insert(aNote,0); //pRemList->AddHead(aNote);
									if (lastIndexPos < 0) //if (pos2 == NULL)
										break;
								}
								bool bResult = InsertSublistAtHeadOfList(pRemList, freeTranslationsList, pRec);
								if (!bResult)
								{
									// there was an error (an unknown list was requested in the switch)
									wxString errStr = _T("InsertSublistAtHeadOfList(), for storing un-restorable ");
									errStr += _T("Notes in the free translations list (just some from tail), failed. ");
									errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
									wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
									pRemList->Clear();
									delete pRemList;
									return FALSE;
								}
								
								delete pRemList; // the free translations list now manages these strings,
												 // so don't do any Remove() before doing this deletion
								// warn the user about what has happened
								// IDS_KEEP_UNREPLACED_NOTE
								// TODO: Surely IDS_KEEP_UNREPLACED_NOTE is not supposed to be a single
								// space - not much of a message for the user!
								//wxMessageBox(_(" "), _T(""), wxICON_INFORMATION);
								break; // break out of the loop and let the rest of the function do the 
									   // replacements of those that were successfully relocated and stored
									   // in arrSqueezedLocations
							} // end of else block for test bMoveRightWorked == TRUE
						}
						else
						{
							// the aNoteSN index has no Note at this location, so we can create one there
							arrSqueezedLocations.RemoveAt(0);
							// whm note: wxArrayInt's Insert method reverses the parameters! Caution: wx docs also
							// says of wxArray::Insert() "Insert the given number of copies of the item into the array
							// before the existing item n. This resulted in incorrect ordering of source phrases, so
							// we use array[] = assignment notation instead. Bruce's note indicates that it is going
							// to "insert at the array's end", so to be safe we insure that the array has at least
							// nNumInUnsqueezedArray elements by calling SetCount()
							if (nNumUnsqueezedLocations+1 > (int)arrUnsqueezedLocations.GetCount())
								arrUnsqueezedLocations.SetCount(nNumUnsqueezedLocations+1);
							arrUnsqueezedLocations[nNumUnsqueezedLocations] = aNoteSN; //arrUnsqueezedLocations.InsertAt(nNumUnsqueezedLocations,aNoteSN);
							nNumUnsqueezedLocations = arrUnsqueezedLocations.GetCount(); // update size
						}
					} // end of for loop for relocating all those we couldn't fit in edit span at the start
					  // of the context following the edit span - rightshifting notes if necessary
				} // end of TRUE block for test nStartAt <= m_maxIndex
				else
				{
					// we are already at the end of the document, so the remainders have to be put
					// into the removed free translation list; we'll remove them in a loop from the
					// tail of the CStringList in pRec, and insert each such one at the start of a
					// new CStringList which we will then insert at the start of the removed
					// free translations list
					arrSqueezedLocations.Clear(); // clear these stored SN indices, so that the Note
													  // creations done below won't wrongly grab the
													  // locations stored in arrSqueezedLocations
					int nNewIndex;
					wxArrayString* pRemList = new wxArrayString; //CStringList* pRemList = new CStringList;
					wxASSERT(pRemList != NULL);
					wxString aNote;
					//POSITION pos2 = pRec->storedNotesList.GetTailPosition();
					//ASSERT(pos2);
					int lastIndexPos;
					lastIndexPos = pRec->storedNotesList.GetCount() -1;
					for (nNewIndex = 0; nNewIndex < nRemainderCount; nNewIndex++)
					{
						// we'll use the longer POSITION iterator way, rather than .RemoveTail() because
						// we don't want to alter the EditRecord contents until we call InitializeEditRecord()
						// on it
						//aNote = pRec->storedNotesList.GetPrev(pos2);
						// MFC's GetPrev() first gets the data item at pos2 then pos2 moves
						// to the previous element position. We do the same by getting the
						// data item at lastIndexPos, then decrementing lastIndexPos
						aNote = pRec->storedNotesList.Item(lastIndexPos);
						lastIndexPos--;
						// for wxArrayString we insert aNote at index 0 to do the same as
						// MFC's AddHead().
						pRemList->Insert(aNote,0); //pRemList->AddHead(aNote);
					}
					bool bResult = InsertSublistAtHeadOfList(pRemList, freeTranslationsList, pRec);
					if (!bResult)
					{
						// there was an error (an unknown list was requested in the switch)
						wxString errStr = _T("InsertSublistAtHeadOfList(), for storing un-restorable ");
						errStr += _T("Notes in the free translations list (all the removed ones), failed. ");
						errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
						wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
						pRemList->Clear();
						delete pRemList;
						return FALSE;
					}
					
					delete pRemList; // the free translations list now manages these strings,
									 // so don't do any Remove() before doing this deletion
					// warn the user about what has happened
					// IDS_KEEP_UNREPLACED_NOTE
					// TODO: Surely IDS_KEEP_UNREPLACED_NOTE is not supposed to be a single
					// space - not much of a message for the user!
					//wxMessageBox(_(" "), _T(""), wxICON_INFORMATION);
				}
			}
		}
	}

	// build the notes at the required locations, using the stored new sequence numbers,
	// after making the unsqueezed and squeezed arrays into one; we don't need to keep them
	// separate anymore, because any values stored in the squeezed array will be at higher
	// sequence numbers than any in the unsqueezed array
en:	;
	//arrUnsqueezedLocations.Add(arrSqueezedLocations);
	// In wx we need to add the elements of another array manually
	int arrCt;
	for (arrCt = 0; arrCt < (int)arrSqueezedLocations.GetCount(); arrCt++)
	{
		arrUnsqueezedLocations.Add(arrSqueezedLocations.Item(arrCt));
	}

	//return FALSE; // temporary, uncomment out in order to test the document restoration code

	wxString strNoteText;
	int nNumToReplace = arrUnsqueezedLocations.GetCount();
	//bool bNoNotePresent; // commented out in MFC
	//POSITION pos = pRec->storedNotesList.GetHeadPosition();
	//wxASSERT(pos != NULL);
	for (index = 0; index < nNumToReplace; index++)
	{
		// get each Note string and create its Note on the appropriate CSourcePhrase instance, there
		// should not be any Notes already present at these locations, but we'll check and if there
		// is, we've an error state which must cause the vertical edit process to be abandoned and the
		// earlier doc state rebuilt
		aNoteSN = arrUnsqueezedLocations[index]; // get the next note's location
		strNoteText = pRec->storedNotesList.Item(index); //strNoteText = pRec->storedNotesList.GetNext(pos); // get the next note's text
		if (IsNoteStoredHere(pSrcPhrases, aNoteSN))
		{
			// error, so cause bailout after showing the user a message
			wxString errStr = _T("Error in RestoreNotesAfterSourceTextEdit(), attempted to restore ");
			errStr += _T("a Note at a location where there was supposed to be no Note already stored. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			return FALSE;
		}
		else
		{
			// these is no note at this location, so create it there now
			bool bAllsWell = CreateNoteAtLocation(pSrcPhrases, aNoteSN, strNoteText);
			if (!bAllsWell)
			{
				// there was an unexpected error - either a bounds error, or a note already present
				wxString errStr = _T("Error in RestoreNotesAfterSourceTextEdit(), the CreateNoteAtLocation() ");
				errStr += _T("function returned FALSE, either because of a bounds error (past doc end) or ");
				errStr += _T("there really was a Note already stored at this location when all the many ");
				errStr += _T("previous checks said there wasn't!! ");
				errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				return FALSE;
			}
		}
	}

	// Test the error handling code by returning FALSE, comment out next line when
	// the error handling code is working right, and instead return TRUE
	//return FALSE;
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error
/// \param      pSrcPhrases -> pointer to the app's m_pSourcePhrases list, after the user's
///                             edit source text has been made to replace the original selection 
///                             and m_nSequNumber values in all CSourcePhrase instances in 
///                             pSrcPhrases have been made sequential from 0 at the list's 
///                             start
/// \param      pRec        -> pointer to the EditRecord for the vertical edit process
/// \param      context     -> a WhichContextEnum enum value which is either precedingContext (0) 
///                             or followingContext (1)
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The passed in EditRecord contains the information about the source text edit which
/// has just been completed, and it includes an array, arrNotesSequNumbers, which stores
/// in normal order the sequence number indices for each Note that was removed from the
/// original editable span (this span will have been extended beyond the user's selection
/// to include all of any retranslation(s) it overlaps, but if there were no such overlaps
/// then it was the same as the user's selection). The array is used to assist in relocating
/// the removed notes.
/// GetMovedNotesSpan is called after the edited source text has been incorporated into the
/// document list, but immediately prior to the attempt to recreate any temporarily removed
/// Notes from the editable span (possibly extended, see previous paragraph). The Note
/// restoration process, if there are many notes, or the user removed source text where Notes
/// were stored, may need to move unremoved notes in the preceding context leftwards, or in the
/// following context rightwards, in order to make gaps for placing the temporarily removed Notes.
/// Any such Note movements would invalidate the Note placements in the cancel span, so that if
/// the user asks for a Cancel, or there is an error requiring the original state of the document
/// to be rebuilt, the Notes could end up duplicated in nearby locations, or worse.
/// The solution to this connundrum is to work out the maximum number of possible moves that the
/// algorithms for Note replacement might request in order to form gaps, at both preceding and
/// following context (with respect to the edit span) and make deep copies of that many CSourcePhrase
/// instances in one or the other context (depending on the passed in context value) prior to the
/// Note restoration being initiated. If a Cancel or bail it is later requested, then the first
/// thing to be done is to restore these preceding and following small contextual sublists, so that
/// the pre-Note-moves state of the pSrcPhrases list is restored, and then the cancel span will be
/// able to be used without error in the rest of the document restoration process. The EditRecord
/// stores these two sublists in its follNotesMoveSpanList and precNotesMoveSpanList members.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetMovedNotesSpan(SPList* pSrcPhrases, EditRecord* pRec, WhichContextEnum context)
{
	// 26May08	function created as part of refactoring the Edit Source Text functionality
	wxString errStr;
	//int nNumRemoved = pRec->arrNotesSequNumbers.GetCount(); // unused
	int nEditSpanStartingSN = pRec->nStartingSequNum; // this could be the start of the
	int nEditSpanEndingSN;
	if (pRec->nNewSpanCount == 0)
	{
		nEditSpanEndingSN = pRec->nStartingSequNum;
	}
	else
	{
		nEditSpanEndingSN = pRec->nStartingSequNum + pRec->nNewSpanCount - 1;
	}
	int nMaxMoves = pRec->arrNotesSequNumbers.GetCount();
	// if the array has no members, the span does not need to be created
	if (nMaxMoves == 0)
		return TRUE;
	// there is at least one temporarily removed Note, so there is the possibility that a
	// non-removed Note may need to be moved at the Note restoration step; so we need to go
	// ahead and work collect the CSourcePhrase instances which would potentially be involved
	// in any such moves and copy those and store in pRec
	int nGapCount = 0;	// count how many CSourcePhrase instances without a Note stored there are
						// traversed as we scan across them, leftwards in top block, rightwards in
						// the else block; when nGapCount == nMaxMoves, we've collected enough
						// instances; don't count any CSourcePhrase which has a stored Note in it
	int nStartAt;
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = NULL; //POSITION pos = NULL;
	CSourcePhrase* pNewOne = NULL; // for creation of deep copies on the heap
	if (context == precedingContext)
	{
		// at this invocation, collect from the context preceding the edit span
		nStartAt = nEditSpanStartingSN - 1;
		if (nStartAt < 0)
		{
			// there is no preceding context, so return
			return TRUE;
		}
		pos = pSrcPhrases->Item(nStartAt); // pos = pSrcPhrases->FindIndex(nStartAt); // initialize pos
		if (pos == NULL)
		{	
			errStr = _T("FindIndex() failed in GetMovedNotesSpan(), preceding context, pos value is NULL.");
			errStr += _T(" Abandoning the edit process. Will attempt to restore original document state.");
			wxMessageBox( errStr, _T(""), wxICON_EXCLAMATION);
			return FALSE;
		}
		while (pos != NULL)
		{
			// count this CSourcePhrase instance if it has no Note stored in it
			pSrcPhrase = pos->GetData();
			pos = pos->GetPrevious();
			if (!pSrcPhrase->m_bHasNote)
				nGapCount++;
			// make a deep copy, and store it in the EditRecord
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			// In wxList Insert() always adds to the head of the list
			SPList::Node* posInsert = pRec->precNotesMoveSpanList.Insert(pNewOne); //POSITION posInsert = pRec->precNotesMoveSpanList.AddHead(pNewOne);
			posInsert = posInsert; // to avoid warning in release build
			wxASSERT(posInsert != NULL);
			// check if the break out criterion has been met
			if (nGapCount == nMaxMoves)
			{
				// we have obtained sufficient preceding context for a safe restoration of the
				// sublist section which might have one or more moved Notes done within it
				break;
			}
		}
		// NOTE, the sublist in pRec will contain more than nGapCount CSourcePhrase instances
		// if the above while loop scanned across instances which contain a Note already; these
		// are not counted, but must be included in the sublist
	}
	else
	{
		// at this invocation, collect from the context following the edit span
		if (pRec->nNewSpanCount == 0)
			nStartAt = nEditSpanEndingSN;
		else
			nStartAt = nEditSpanEndingSN + 1;
		if (nStartAt > gpApp->m_maxIndex)
		{
			// there is no following context, so return
			return TRUE;
		}
		pos = pSrcPhrases->Item(nStartAt); // pos = pSrcPhrases->FindIndex(nStartAt); // initialize pos
		if (pos == NULL)
		{	
			errStr = _T("FindIndex() failed in GetMovedNotesSpan(), following context, pos value is NULL.");
			errStr += _T(" Abandoning the edit process. Will attempt to restore original document state.");
			wxMessageBox( errStr, _T(""), wxICON_EXCLAMATION);
			return FALSE;
		}
		while (pos != NULL)
		{
			// count this CSourcePhrase instance if it has no Note stored in it
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			if (!pSrcPhrase->m_bHasNote)
				nGapCount++;
			// make a deep copy, and store it in the EditRecord
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			SPList::Node* posInsert = pRec->follNotesMoveSpanList.Append(pNewOne); //POSITION posInsert = pRec->follNotesMoveSpanList.AddTail(pNewOne);
			posInsert = posInsert; // to avoid warning in release build
			wxASSERT(posInsert != NULL);
			// check if the break out criterion has been met
			if (nGapCount == nMaxMoves)
			{
				// we have obtained sufficient following context for a safe restoration of the
				// sublist section which might have one or more moved Notes done within it
				break;
			}
		}
		// NOTE, the sublist in pRec will contain more than nGapCount CSourcePhrase instances
		// if the above while loop scanned across instances which contain a Note already; these
		// are not counted, but must be included in the sublist
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there was no error, FALSE if some kind of exception or bad value happened
/// \param      pRec           -> pointer to the EditRecord which has the info about bounds and spans etc
/// \param      pSrcPhrases    -> pointer to the document's m_pSourcePhrases member
/// \param      strNewSource   -> reference to the current (post-edit) new source text which we potentially
///                                 will be appending additional words to from the following context to the
///                                 current editable span (and also, in parallel, extending the width of 
///                                 the editable span, etc)
/// \param      pMap           <- pointer to the document's map called m_FilterStatusMap, which contains
///                                 the "to-be-filtered" entries (probably never more than one) which 
///                                 specify the particular SFM we need to search for in order to determine 
///                                 where its filterable content commences
/// \param      bWasExtended   <- returns TRUE to the caller if the function actually extended the editable
///                                 span -- the caller may not need to know this, but just in case we give 
///                                 it the knowledge of whether or not pRec had its contents altered; 
///                                 returns FALSE if the editable span was not extended (and therefore no 
///                                 changes made to pRec's contents) 
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The prototypical situation we have designed this function for is the following. \yy would be an
/// "unknown" marker, because it is not a marker in any known SFM set, not the USFM set, not the 1998
/// PNG set. The document may contain ?\yy? in the navigation text where there is word1 word2 word3 word4
/// etc, and the user decides to edit \yy to, say, \r (a reference marker which is filterable by default). He
/// then just selects word1 and does Edit / Edit Source Text, and in the dialog changes \yy to \r and clicks
/// OK. The \r marker's content is, because it is a to-be-filtered marker, all supposed to be filtered out,
/// but his word selection for the editable span was only word1, rather than word1 word2 ... down to whatever
/// word is last before the next SFM location (other than a 'none' TextType one which we want to ignore).
/// Adapt It then just filters the \r and word1 as its content, and word2 word3 etc are left in the document
/// as if they were sacred text to be adapted. What the user should have done was to include all the word1 word2
/// word3 ... down to the end of the filterable content, in his original selection - then Adapt It would filter
/// the whole word string out properly. The ExtendEditableSpanForFiltering() function, therefore, permits the
/// user to do the obvious thing (ie. select just word1 where the bad marker is stored under the hood) and
/// nevertheless get the whole of the bad marker's text contents filtered out, as if he'd really selected all
/// of the words of that material.
/// The way the function works is to scan rightwards from the end of the passed in editable span (pRec has
/// that information) until the end of the marker's filterable contents is found, where it will halt. We use 
/// the HaltCurrentCollection() function to find the halt location, because it has the smarts about the SFM
/// set currently in operation, and it ignores the markers which have their associated TextType with the value
/// none. Each CSourcePhrase traversed without causing a halt yields a source text word or phrase to be appended
/// to strNewSource, a deep copy of the CSourcePhrase is made and inserted in the appropriate spans - a very
/// tricky process because we throw away any Notes, free translations and/or collected back translations
/// which the user may have erroneously defined on that filterable material (though we'd expect he wouldn't
/// have ever put such things there, and usually the bad marker would be edited long before he'd add such things
/// to his document). Because of the complexity of what is to be done in this function, we'll just make the
/// insertions of deep copied CSourcePhrase instances in the lists, and increment the "Ending" sequence numbers
/// for the various spans to comply with the extension of the editable span. This should suffice, but if bailout
/// of the vertical edit process happens then any notes, free translations or collected back translations defined
/// on this extra material won't be recreated. The chances of that being a problem, however, are miniscule.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ExtendEditableSpanForFiltering(EditRecord* pRec, SPList* pSrcPhrases, 
							wxString& strNewSource, MapWholeMkrToFilterStatus* WXUNUSED(pMap), bool& bWasExtended)
{
	// Created 5July08 by BEW, for support of refactored Source Text Edit functionality
	bWasExtended = FALSE; // default starting value
	bool bFound_bt_mkr = FALSE;
	bool bIsHaltLocation = FALSE;
	//CString markers;
	int nIteratorSN = pRec->nEndingSequNum + 1;
	if (nIteratorSN > gpApp->m_maxIndex)
		return TRUE; // do nothing if the editable span ended at the document end
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nIteratorSN); //POSITION pos = pSrcPhrases->FindIndex(nIteratorSN);
	if (pos == NULL)
	{
		wxMessageBox(_T("FindIndex() failed in ExtendEditableSpanForFiltering(), pos value is NULL. Saving and restoring document. Abandoning edit."
		), _T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		gpApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	int nCancelSpanEnd = pRec->nCancelSpan_EndingSequNum; // it's also where the modificationsSpan ends
	wxString aSpace = _T(' ');
	
	// scan forwards, until at a halt location (the very first CSourcePhrase might be a halt
	// location, so the scan might exit without any extension to the editable span)
	while (pos != NULL)
	{
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nIteratorSN = pSrcPhrase->m_nSequNumber;
		bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
		if (bIsHaltLocation)
		{
			// no further extension is needed, so exit the loop
			break;
		}
		else
		{
			// we need to add to the new source text, and increment the index for the end of the editable
			// span, and we also must check if we've gone past the end of the cancel span - if the latter is true,
			// then we must extend both the cancel and modifications spans and increment their ending index (they
			// always have the same extent) and append a deep copy to each list
			bWasExtended = TRUE; // tell the caller an extension was done (caller will put the value into pRec)
			strNewSource += aSpace + pSrcPhrase->m_srcPhrase;
			pRec->nEndingSequNum = nIteratorSN; // set the new end to the editable span
			pRec->nOldSpanCount += 1; // we are widening the old editable span
			pRec->nNewSpanCount += 1; // and also widening the new source text span
			pRec->nEndingTextType = pSrcPhrase->m_curTextType; // update, in case it is different
			if (nIteratorSN > nCancelSpanEnd)
			{
				pRec->nCancelSpan_EndingSequNum = nIteratorSN;
				CSourcePhrase* 	pNewOne = new CSourcePhrase(*pSrcPhrase);
				pNewOne->DeepCopy();
				pRec->cancelSpan_SrcPhraseList.Append(pNewOne); // add a copy to the cancelSpan's list
				CSourcePhrase* 	pNewTwo = new CSourcePhrase(*pSrcPhrase);
				pNewTwo->DeepCopy();
				pRec->modificationsSpan_SrcPhraseList.Append(pNewTwo); // add a new copy to the modificationsSpan's list
				nCancelSpanEnd = nIteratorSN; // update; not nessessary, but harmless
			}
		}
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrases -> pointer to the app's m_pSourcePhrases list
/// \param      pRec        -> pointer to the EditRecord for the vertical edit process
/// \remarks
/// Called from: the View's CopyCSourcePhrasesToExtendSpan(), and OnEditSourceText().
/// Cancels out from the source text editing process. It clears the clearable parts of the
/// EditRecord, rolls back through the lists of CSourcePhrases using the user's chosen order
/// and ...
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::BailOutFromEditProcess(SPList* pSrcPhrases, EditRecord* pRec)
{
	// this must clear the clearable parts of the EditRecord, roll back through the lists of CSourcePhrases
	// using the user's chosen order .. anything else??

	// TODO -- the above



	if (gEditStep == sourceTextStep && gEntryPoint == sourceTextEntryPoint)
	{
		// What has to be done depends on whether the document's native structures have as
		// yet been modified. If they are as yet unchanged, we only need reinitialize the
		// edit record. If they have been changed, we have to use the cancel span and propagation
		// span and other parameters to get the document restored to what it originally was prior
		// to the commencement of the vertical edit at the source text edit step
		if (!gbEditingSourceAndDocNotYetChanged)
		{
			// doc is modified, so undo what has been done, and then proceed to the reinitialization
			RestoreDocAfterSrcTextEditModifiedIt(pSrcPhrases, pRec);
		}
	}
	InitializeEditRecord(gEditRecord);

	// do the resetting of the globals, so that we are ready for a new vertical edit process
	gbVerticalEditInProgress = FALSE;	
	gEntryPoint = noEntryPoint;
	gEditStep = noEditStep;
	gbEditingSourceAndDocNotYetChanged = TRUE;
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      bOnlyWithinSpan       -> default TRUE; explicitly set to FALSE to cause a unilateral 
///                                     storage attempt regardless of whether or not the active 
///                                     location is within the span of the adaptationsStep or 
///                                     glossesStep
/// \param      bRestoreBoxOnFailure  -> default FALSE; set TRUE to have the application attempt to 
///                                     restore the phrase box when/if the vertical edit process 
///                                     fails
/// \remarks
/// Called from: the View's OnEditSourceText() and OnCustomEventEndVerticalEdit().
/// StoreText() always attempts the store. DoConditionalStore() wraps the StoreText() call in
/// a lot of tests, so that the store is only done when really wanted (eg, when the phrase
/// box contents were not copied). Store is not wanted if contents were copied, & the user has not
/// yet typed something nor clicked in the box, and the CPhraseBox class member m_bAbandonable is
/// still TRUE, and the box text is non-empty). When those things don't obtain, we can be pretty
/// certain the user has done some editing in the box and so we'd expect to save that work if the
/// box contents are about to be cleared.
/// The flags we need to look at are all globals (or, for the wxWidgets versions, they'd all be
/// members of the app class), and so we don't need to pass anything in; nor return anything. The
/// distinction between glossing and adapting modes is also handled internally too. And we make sure
/// that if the user had earlier removed the relevant entry from the KB or glossing KB, whichever
/// applies, then the store won't fail by having flags set on the document at that point which are
/// incompatible with the KB contents after said removal.
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::DoConditionalStore(bool bOnlyWithinSpan, bool bRestoreBoxOnFailure)
{
	// Created 1Aug08 by BEW, for support of refactored Source Text Edit functionality, but could
	// be used elsewhere if we ever refactor other code - the code here is cloned from part of 
	// PlacePhraseBox() and tweaked a bit
	CAdapt_ItDoc* pDoc = GetDocument();
	EditRecord* pRec = &gEditRecord;
	wxString strBoxText;
	strBoxText = gpApp->m_pTargetBox->GetValue(); // save, in case later failure requires 
												// the box contents be reconstructed

	// what we do depends on where the active pile is when this function is called. If the user has
	// clicked the End Now button while the phrase box is still in an active editing step of Vertical Edit,
	// then it is appropriate to save the box contents to the KB before restoring the phrase box to
	// the original position or suitable placee nearby. On the other had, if the box has been advanced in
	// the lookup loop and has reached the end of the current span and the dialog asking the user to either
	// click Next Step, Previous Step, End Now or Cancel All Steps is showing and he elects to End Now, then
	// the phrase box will be disengaged from the active pile: the box will be showing at the last pile in
	// the current span, but the active location will have moved forward to the first hole beyond the end
	// of the editing span currently active (it could be adaptationsStep, glossesStep, or freeTranslationsStep)
	// and so doing a store would store garbage in such a situation. So we have to test for which end state
	// we have, and either do a store or restore the active location back to where the phrase box is and
	// not do a store (since it would have been done already at the start of the lookahead loop); and then
	// set up the phrase box at the appropriate place in the document for when vertical editig mode is off.
	// We use the current m_pActivePile to determine where the active location is, and act accordingly.
	CPile* pPile = gpApp->m_pActivePile;
	if (pPile == NULL)
	{
		// no active location is defined, so we can't store an adaptation or gloss, so exit
		return;
	}
	wxASSERT(pPile != NULL);
	bool bWithinSpan = FALSE;
	bool bFreeTransStepIsCurrent = FALSE; // storing to KB or glossingKB is needed when FALSE, not when TRUE
	bool bUnknownStep = FALSE;
	int nCurSequNum = pPile->m_pSrcPhrase->m_nSequNumber;
	switch (gEditStep) {
		case adaptationsStep:
			if (nCurSequNum >= pRec->nAdaptationStep_StartingSequNum &&
				nCurSequNum <= pRec->nAdaptationStep_EndingSequNum)
			{
				bWithinSpan = TRUE;
			}
			break;
		case glossesStep:
			if (nCurSequNum >= pRec->nGlossStep_StartingSequNum &&
				nCurSequNum <= pRec->nGlossStep_EndingSequNum)
			{
				bWithinSpan = TRUE;
			}
			break;
		case freeTranslationsStep:
			bFreeTransStepIsCurrent = FALSE;
			if (nCurSequNum >= pRec->nFreeTranslationStep_StartingSequNum &&
				nCurSequNum <= pRec->nFreeTranslationStep_EndingSequNum)
			{
				bWithinSpan = TRUE;
			}
			break;
		default:
			bUnknownStep = TRUE;
	}

	if (!bOnlyWithinSpan)
	{
		// cause unilateral store attempt, provided other conditions are met
		bWithinSpan =  TRUE;
	}
	if (!bUnknownStep && bWithinSpan && !bFreeTransStepIsCurrent)
	{
		// any one of the following 3 tests is sufficient cause for attempting to store
		if (gpApp->m_bUserTypedSomething || !gpApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
		{
			// make sure m_targetPhrase doesn't have any final spaces
			RemoveFinalSpaces(gpApp->m_pTargetBox,&gpApp->m_targetPhrase);

			// any existing phraseBox text must be saved to the KB or glossingKB, unless its empty
			if (!gpApp->m_targetPhrase.IsEmpty())
			{
				if (gpApp->m_pTargetBox->IsModified()) //MFC uses GetModify()
				{
					// only save if something (eg a click or typing) has set the box's dirty flag
					if (gpApp->m_pTargetBox->m_bAbandonable)
					{
						// if abandonable, we want to throw away the text in the box, so clearing
						// it will do the trick -- it makes the store operation do no store
						gpApp->m_targetPhrase.Empty();
						gpApp->m_pTargetBox->SetValue(_T(""));
					}
				}

				// it has to be saved to the relevant KB now
				if (!gpApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
				{
					if (gbIsGlossing)
					{
						// the store attempt would fail if the user earlier edited the entry out of
						// the glossingKB, as the latter cannot know which srcPhrases will be affected
						// by such a change, so these in the document would still have their 
						// m_bHasGlossingKBEntry set true. We have to test for this, ie. a
						// null pRefString, but that flag being TRUE is a sufficient test, and if so,
						// set the flag to FALSE
						CRefString* pRefStr = GetRefString(gpApp->m_pGlossingKB, 1,
							gpApp->m_pActivePile->m_pSrcPhrase->m_key, gpApp->m_targetPhrase);
						if (pRefStr == NULL && gpApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry)
							gpApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
						bool bOK;
						bOK = StoreText(gpApp->m_pGlossingKB,gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
					}
					else
					{
						MakeLineFourString(gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
						RemovePunctuation(pDoc,&gpApp->m_targetPhrase,1 /*from tgt*/);

						// the store attempt would fail if the user earlier edited the entry out of
						// the adaptation KB, as the latter cannot know which srcPhrases will be affected
						// by such a change, so these in the document would still have their 
						// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString,
						// but that flag being TRUE is a sufficient test, and if so, set the flag to FALSE
						CRefString* pRefStr = GetRefString(gpApp->m_pKB,
							gpApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
							gpApp->m_pActivePile->m_pSrcPhrase->m_key,gpApp->m_targetPhrase);
						if (pRefStr == NULL && gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
							gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
						gbInhibitLine4StrCall = TRUE;
						bool bOK;
						bOK = StoreText(gpApp->m_pKB,gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
						gbInhibitLine4StrCall = FALSE;
					}
				}
			} // end block for non-empty box contents
			else
			{
				// m_targetPhrase is empty, so let StoreText handle what needs to happen.
				bool bOK = FALSE;
				if (gbIsGlossing)
				{
					gpApp->m_pActivePile->m_pSrcPhrase->m_gloss = gpApp->m_targetPhrase;

					// see above for why we do this
					CRefString* pRefStr = GetRefString(gpApp->m_pGlossingKB, 1,
						gpApp->m_pActivePile->m_pSrcPhrase->m_key,gpApp->m_targetPhrase);
					if (pRefStr == NULL && gpApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry)
						gpApp->m_pActivePile->m_pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
					bOK = StoreText(gpApp->m_pGlossingKB,gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
				}
				else // is adapting
				{
					gpApp->m_pActivePile->m_pSrcPhrase->m_adaption = gpApp->m_targetPhrase;
					MakeLineFourString(gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase); // punctuation is 
																					// re-expressed
					RemovePunctuation(pDoc,&gpApp->m_targetPhrase, 1 /*from tgt*/);

					// see above for why we do this
					CRefString* pRefStr = GetRefString(gpApp->m_pKB,gpApp->m_pActivePile->m_pSrcPhrase->m_nSrcWords,
						gpApp->m_pActivePile->m_pSrcPhrase->m_key,gpApp->m_targetPhrase);
					if (pRefStr == NULL && gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry)
						gpApp->m_pActivePile->m_pSrcPhrase->m_bHasKBEntry = FALSE;
					gbInhibitLine4StrCall = TRUE;
					bOK = StoreText(gpApp->m_pKB,gpApp->m_pActivePile->m_pSrcPhrase,gpApp->m_targetPhrase);
					gbInhibitLine4StrCall = TRUE;
				}

				// check for a failure, abandon the function if the store failed, and because this
				// function could be used in other places, check the bRestoreBoxOnFailure flag to
				// see whether or not a failure warrants restoring the phrase box contents and focus
				if (!bOK)
				{
					if (bRestoreBoxOnFailure)
					{
						// we must restore the box's selection to what it was earlier before returning
						gpApp->m_pTargetBox->SetValue(strBoxText);
						gpApp->m_targetPhrase = strBoxText;
						gpApp->m_pTargetBox->SetFocus();
						gpApp->m_pTargetBox->SetSelection(gpApp->m_nStartChar,gpApp->m_nEndChar); //,TRUE); // no scroll
						gnStart = gpApp->m_nStartChar;
						gnEnd = gpApp->m_nEndChar;
						gSaveTargetPhrase = gpApp->m_targetPhrase;
						return;
					}
				}
			}
		} // end block for m_bUserTypedSomething == TRUE
	}
}

void CAdapt_ItView::RestoreBoxOnFinishVerticalMode()
{
	EditRecord* pRec = &gEditRecord;

	// when this function is called, the original pre-Vertical Edit Process mode
	// (either glossing or adapting) will have been restored, but the gEditRecord
	// has not yet been initialized so as to clear it; so use its contents to
	// work out where the active location should be put
	int nSequNum = pRec->nSaveActiveSequNum; // original location
	bool bOriginalLocationWithinSpan = FALSE;
	if (!gbIsGlossing)
	{
		// we are in adapting mode
		if (pRec->nAdaptationStep_NewSpanCount != 0) 
		{
			if (nSequNum >= pRec->nAdaptationStep_StartingSequNum &&
				nSequNum <= pRec->nAdaptationStep_EndingSequNum)
			{
				bOriginalLocationWithinSpan = TRUE;
			}
		}
	}
	else
	{
		// we are in glossing mode
		if (pRec->nAdaptationStep_NewSpanCount != 0) 
		{
			if (nSequNum >= pRec->nGlossStep_StartingSequNum &&
				nSequNum <= pRec->nGlossStep_EndingSequNum)
			{
				bOriginalLocationWithinSpan = TRUE;
			}
		}
	}

	// now we attempt to find a safe final active location; and it can be within a retranslation if
	// we are restoring glossing mode, but not if we are restoring adapting mode; 
	// vertical  edit in MFC legacy app is only available from a Source Text Edit, and it is not
	// possible to do that from free translations mode, so we know we are not restoring to the
	// latter mode (**** NOT TRUE for wxWidgets *** where eventually vert edit will be available
	// in any mode except when collecting back  translations -- in that case extend this function
	// to handle those extra options)
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pOldSrcPhrase = NULL;
	if (!gbIsGlossing)
	{
		// adapting mode was on when the user first entered the edit process & is now back on
		if (bOriginalLocationWithinSpan || pRec->nAdaptationStep_NewSpanCount == 0)
		{
			// the original location was either within the (non-empty) span, or the span is now
			// empty because the user deleted all of its CSourcePhrase instances - in which case
			// the old sequence number at entry would now be somewhere in the context or even
			// possibly beyond the end of the document, so we have to look carefully for a suitable
			// place to rebuild the box -- it could be within a retranslation, so find a safe place
			// to put the box
			if (nSequNum > gpApp->m_maxIndex)
			{
				// the old location is beyond the end of the document, so initialize to the
				// last CSourcePhrase instance in the document, and then check it is safe
				nSequNum =  gpApp->m_maxIndex;
			}
			pSrcPhrase = GetSrcPhrase(nSequNum); // won't return NULL because the CSourcePhrase at nSequNum we know exists
			pOldSrcPhrase = pSrcPhrase; // in case we want to try again from same initial one
			wxASSERT(pSrcPhrase != NULL);
			if (pSrcPhrase->m_bRetranslation)
			{
				// this location is within a retranslation, and because of the possibility the edit span
				// may be at the end of the document, we'll look for a safe location preceding the retranslation
				//rather than following it
				pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);
				if (pSrcPhrase == NULL)
				{
					// we expect this never to happen, but if we can't find such a location, try following the
					// the retranslation
					pSrcPhrase = pOldSrcPhrase;
					pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);
					if (pSrcPhrase == NULL)
					{
						// unthinkable, but if it happens, violate rule about retranslations and put the box within it!
						pSrcPhrase = pOldSrcPhrase;
					}
				}
			}
			// get the safe sequence number index
			nSequNum = pSrcPhrase->m_nSequNumber;
		}
		else
		{
			// the original location, being outside the span, must already be a safe location, so
			// do the restoration at nSequNum's location
			;
		}
	}

	// we now have the nSequNum at which we want to restore the box, so do it
	translation.Empty();
	gpApp->m_targetPhrase.Empty();

	// now set up the phrase box
	gpApp->m_nActiveSequNum = nSequNum; // needed, as a test for m_nActiveSequNum < 0 done internally
								 // will have box placement skipped if we get here and it is -1
	gpApp->m_pActivePile = GetPile(nSequNum);
	bool bFoundSomething = FALSE;
	if (!pRec->bGlossingModeOnEntry)
	{
		if (gpApp->m_pActivePile->m_pSrcPhrase->m_adaption.IsEmpty())
			bFoundSomething = gpApp->m_pTargetBox->LookUpSrcWord(this, gpApp->m_pActivePile);
		if (bFoundSomething)
		{
			gpApp->m_targetPhrase = translation;
		}
		else
		{
			translation = gpApp->m_pActivePile->m_pSrcPhrase->m_adaption;
			gpApp->m_targetPhrase = translation;
		}
	}
	else
	{
		if (gpApp->m_pActivePile->m_pSrcPhrase->m_gloss.IsEmpty())
			bFoundSomething = gpApp->m_pTargetBox->LookUpSrcWord(this, gpApp->m_pActivePile);
		if (bFoundSomething)
		{
			gpApp->m_targetPhrase = translation;
		}
		else
		{
			translation = gpApp->m_pActivePile->m_pSrcPhrase->m_gloss;
			gpApp->m_targetPhrase = translation;
		}
	}
	RedrawEverything(nSequNum);
}

// BEW updated, 11Apr08++ to remove modalities, show filtered info with selected text, extend
// selection if necessary to accomodate editing within or overlapping a retranslation, handle
// endmarkers of the USFM standard adequately, and remove the child dialog for marker transfer
// This refactored version is part of a staged process which uses inserts data in and uses data
// from, a global struct, gEditRecord, defined at the top of this file.
void CAdapt_ItView::OnEditSourceText(wxCommandEvent& WXUNUSED(event))
{
	// we cannot have any synchronized scrolling messages be received, throwing the active location
	// to any old place during vertical edit mode, we have to keep total control of the active
	// location; so if it is currently on, save the setting, turn it off, and use the saved setting
	// to restore it back to its on state when we are done
	if (gbIgnoreScriptureReference_Receive == FALSE)
	{
		// it is currently ON, so save it and turn off
		gbVerticalEdit_SynchronizedScrollReceiveBooleanWasON = TRUE;
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedReceiveSynchronizedScrollingMessages(uevent); // toggle receiving to OFF
	}

	EditRecord* pRec = &gEditRecord; // local pointer to the global EditRecord
	pRec->bGlossingModeOnEntry = gbIsGlossing; // save, for when original mode is to be set up again
	pRec->bSeeGlossesEnabledOnEntry = gbEnableGlossing; // ditto

	gbEditingSourceAndDocNotYetChanged = TRUE;
	bool bUserCancelled = FALSE;

	CAdapt_ItDoc* pDoc = GetDocument();
	//CAdapt_ItApp* pApp = pDoc->GetApp();
	//SPList* pList = new SPList; // list of the selected CSourcePhrase objects; the selection will get // unused
								  // programmatically extended (in either or both direction) if the
								  // user's selection overlaps or is within a retranslation
	int nFirstFollContextCSrcPhraseSN;
	int nFinalPrecContextCSrcPhraseSN;
	SPList* pSrcPhrases = gpApp->m_pSourcePhrases;
	CPile* pStartingPile;	// will change if the selection is programmatically extended leftwards (see above)
	CPile* pEndingPile;		// will change if the selection is programmatically extended rightwards
	int nStartingStripIndex; // may decrease if the selection is programmatically extended leftwards
	// int nStartingSequNum, and int nEndingSequNum are in the EditRecord struct; these to track the
	// sequence number for the start of the (possibly extended programmatically) selection (we don't actually
	// extend the selection but just work out the new starting and ending sequence number values)
	gnOldMaxIndex = gpApp->m_maxIndex; // store the old value -- this global may not be needed here, as we'll have
								// a member in the EditRecord for storing this too
	pRec->nOldMaxIndex = gpApp->m_maxIndex;
	pRec->nNewSpanCount = -1; // -1 means "this value is undefined thus far"
	wxString str; // a temporary storage string
	str.Empty();
	wxString str2; // second temporary storage string
	str2.Empty();
	wxString strSource; // the source text which is to be retranslated (from m_srcPhrase values)
	strSource.Empty();
	gpApp->m_FilterStatusMap.clear(); // BEW added 16Jun05, entries will be \mrkr=0 or \mkr=1 for \mkr as
										 // key, with =0 meaning 'now to be unfiltered' and =1 meaning
										 // 'now to be filtered'
	// save the active sequ number, so we can later determine whether or not the active location
	// lies within the selection (if it's not in the selection, we will need to recreate the phrase
	// box at the former active location when done - BE CAREFUL, because if the active location 
	// lies after the selection and the selection contains null src phrases or merged phrases,
	// then the value of nFormerActiveSequNum will need to be updated as we remove null src
	// phrases and / or unmerge merged phrases); and (for 11Apr08 code changes) the active location
	// may start out outside the selection but for acceptance of the user's edit, we put it always
	// at the start of the new source text (ready for updating adaptations in next step of the vertical
	// edit process), or if there is no new text, at the start of the following context (or a safe location
	// if that is a retranslation) -- so our refactored code probably won't make use of the saved value much
	pRec->nSaveActiveSequNum = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;

	// preserve the active location's phrase box text, in case the phrase box is recreated there when done
	pRec->oldPhraseBoxText = gpApp->m_targetPhrase;

	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pEndingSrcPhrase = NULL;
	wxString strAdapt; // accumulates the existing adaptation text for the selection
		// using the m_targetStr member of each CSourcePhrase instance (ie. includes punctuation)
		// but in the refactored code we don't make any use of this nor let the user see it
	strAdapt.Empty();

	// NOTE: for the wxWidgets version, we need to add a CStringList to store the m_key members (not
	// m_srcPhrase members, because punctuation location may get changed in the edit) which will assist
	// us to work out what the former mergers were so we can reconstitute them whenever their source
	// text was unchanged (other than punctuation changes) in the edit; we won't build that functionality
	// for the legacy MFC versions however --- ( may or may not happen, I may do it differently if I decide
	// to do it)

	CPile* pPile; // to be used as a scratch value
	CCellList::Node* pos = gpApp->m_selection.GetFirst(); //POSITION pos = m_selection.GetHeadPosition();
	//int nCount = gpApp->m_selection.GetCount(); // number of src phrase instances in the user selection // unused
										 // (this value will change (become less or greater) 
										 // depending on how many unmerges and deletion of null 
										 // sourcephrases are done below, and whether we extend or not)

	//pPile = ((CCell*)m_selection.GetNext(pos))->m_pPile; // get the pile first in selection
	// whm note: the above needs to be unpacked a bit for wx
	CCell* pCell = pos->GetData();
	pos = pos->GetNext();
	pPile = pCell->m_pPile;
	pStartingPile = pPile; // need this for later when we look up the strip which first pile is in
						   // prior to calling RecalcLayout
	pRec->nStartingSequNum = pStartingPile->m_pSrcPhrase->m_nSequNumber; // store start location

	// The next two lines are for calculting nStartingStripIndex. We don't currently make any
	// use of this, but in the first versions of Adapt It, we used it at the end of the function
	// to speed up the recalculation of the layout using RecalcLayout(pSrcPhrases,nStartingStripIndex,pBundle);
	// But if the edit made that strip index invalid, the app would crash, so instead
	// RecalcLayout(pSrcPhrases,0,pBundle); is used, to recalculate from the start of the document.
	// Since we don't use the variable, it's line is commented out, but retained in case we
	// later change our mind about using RecalcLayout(pSrcPhrases,nStartingStripIndex,pBundle);
	CSourceBundle* pBundle = pStartingPile->m_pBundle; // needed in case bundle changes unexpectedly
	//nStartingStripIndex = pStartingPile->m_pStrip->m_nStripIndex;

	// Get the pointer to the CSourcePhrase at the start of the user's selection
	pSrcPhrase = pStartingPile->m_pSrcPhrase;
	pRec->nStartingTextType = pSrcPhrase->m_curTextType; // so we can use it on any extra inserted 
													 // sourcephrases
	pos = gpApp->m_selection.GetLast();
	pCell = pos->GetData();
	pPile = pCell->m_pPile; // pile at end of unextended selection
	pEndingPile = pPile;
	pEndingSrcPhrase = pEndingPile->m_pSrcPhrase;
	wxASSERT(pEndingSrcPhrase != NULL);
	pRec->nEndingSequNum = pEndingSrcPhrase->m_nSequNumber;
	pRec->nEndingTextType = pEndingSrcPhrase->m_curTextType;
	// (if the selection is extended at either or both ends because of a retranslation being present
	// and no co-terminous with both ends of the selection, then the values of the sequence number and
	// TextType stored in pRec will be changed as a result of code which follows below)

	gbVerticalEditInProgress = TRUE; // as soon as we change the EditRecord, we set this boolean -
								// even though the user may Cancel the edit later on
	gEntryPoint = sourceTextEntryPoint; // set the global enum variable to the starting type for this vertical edit
	gEditStep = sourceTextStep; // indicate that editing of source text is the current step within the
								// vertical edit process

	int nSaveSequNum = pSrcPhrase->m_nSequNumber; // save the sequ number of the start of user's selection
		// -- though we must update this value to a smaller value if automatic selection extension to earlier
		// sequence numbers happens below (for example, if user selectted some source text words in the
		// middle of a retranslation)...
		// nSaveSequNum is from the legacy code, in this refactored 2008 code it is retained as an alias for
		// nStartingSequNum

	// initialize the cancel span from the user's selection span (the modifications span does not need separate
	// indices, as it is always co-extensive with the cancel span, so the same indices apply to both spans)
	pRec->nCancelSpan_StartingSequNum = pRec->nStartingSequNum;
	pRec->nCancelSpan_EndingSequNum = pRec->nEndingSequNum;

	// do any required selection 'extension' (actually only possibly new sequence numbers are returned),
	// returning TRUE if there was no error, FALSE there was an error. The bWasExtended BOOL parameter
	// returns TRUE if extension and either or both ends was done, FALSE if no extension was required
	bool bWasExtended;
	bool bNoErrors = ExtendEditSourceTextSelection(pSrcPhrases, pRec->nStartingSequNum, pRec->nEndingSequNum,
													bWasExtended);
	if (!bNoErrors)
	{
		// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level, so we can do so here;
exit:		BailOutFromEditProcess(pSrcPhrases, pRec); // clears the gbVerticalEditInProgress flag when done
			wxCommandEvent evt;
			gpApp->GetDocument()->OnFileSave(evt);
		}
		return;
	}
	if (bWasExtended)
	{
		// extension to left or right or in both directions was done, so we have to reset the
		// relevant parameters above to new values (check later, I'm doing it differently so
		// we may not need all these parameters)
		//pos = pSrcPhrases->FindIndex(pRec->nStartingSequNum);
		//ASSERT(pos != NULL);
		pStartingPile = GetPile(pRec->nStartingSequNum); // returns NULL if it couldn't get it
		wxASSERT(pStartingPile != NULL);
		nStartingStripIndex = pStartingPile->m_pStrip->m_nStripIndex;
		pBundle = pStartingPile->m_pBundle; // the bundle could have changed within a GetPile() call
		pSrcPhrase = pStartingPile->m_pSrcPhrase;
		pRec->nStartingTextType = pSrcPhrase->m_curTextType; // the TextType value at the start of the new span
		pRec->bSpecialText = pSrcPhrase->m_bSpecialText; // update the initial special text BOOL value

		nSaveSequNum = pSrcPhrase->m_nSequNumber; // update the alias

		pEndingPile = GetPile(pRec->nEndingSequNum); // returns NULL if it couldn't get it
		wxASSERT(pEndingPile != NULL);
		pEndingSrcPhrase = pEndingPile->m_pSrcPhrase;
		pRec->nEndingTextType = pEndingSrcPhrase->m_curTextType;

		// update the cancel span indices to comply with the extension just done
		pRec->nCancelSpan_StartingSequNum = pRec->nStartingSequNum;
		pRec->nCancelSpan_EndingSequNum = pRec->nEndingSequNum;
	}
	// set the EditRecord's value for the nOldSpanCount member
	pRec->nOldSpanCount = pRec->nCancelSpan_EndingSequNum - pRec->nCancelSpan_StartingSequNum + 1;

	// make the required deep copy and store in the CObList for this in the EditRecord
	// as the cancel span's list
	bool bAllWasOK;
	bAllWasOK = DeepCopySourcePhraseSublist(pSrcPhrases, pRec->nCancelSpan_StartingSequNum, 
							pRec->nCancelSpan_EndingSequNum, &pRec->cancelSpan_SrcPhraseList);
	if (!bAllWasOK)
	{
		// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level, so we can do so here;
			goto exit;
		}
	}
	// the cancelSpan_SrcPhraseList is always co-extensive with the modifications span, so deep copy the
	// one just delineated; we don't ever expect this to fail, so internally just use try and catch blocks
	// to check for any memory exceptions
	DeepCopySublist2Sublist(&pRec->cancelSpan_SrcPhraseList, &pRec->modificationsSpan_SrcPhraseList);

	// now that we have the editable span delineated, (this is the material the user will see), we need to
	// determine if there are any glosses in this span and set the gEditRecord's flag accordingly; and
	// likewise for adaptations
	bool bHasGlosses = FALSE;
	bool bHasAdaptations = FALSE;
	bAllWasOK = IsGlossInformationInThisSpan(pSrcPhrases,pRec->nStartingSequNum, 
													pRec->nEndingSequNum,&bHasGlosses);
	if (!bAllWasOK)
	{
		// something went belly up, so restore original document state and bail out of the process
		goto exit;
	}
	pRec->bEditSpanHasGlosses = bHasGlosses;
	bAllWasOK = IsAdaptationInformationInThisSpan(pSrcPhrases,pRec->nStartingSequNum, 
													pRec->nEndingSequNum,&bHasAdaptations);
	if (!bAllWasOK)
	{
		// something went belly up, so restore original document state and bail out of the process
		goto exit;
	}
	pRec->bEditSpanHasAdaptations = bHasAdaptations;

	// The next sections of code determine if we need to widen the cancel span, and modifications span, to
	// include free translation whole sections; and then again, do the same for collected back translations.
	// If one or neither of these information types is not present, clear the relevant flag(s) in the
	// EditRecord struct. The way we do this processing is to scan the present cancel span and
	// determine what the starting and ending sequence number bounds are, eg. for free translations overlapping
	// the editable subspan, then make a temporary list of deep copies of the CSourcePhrase instances in the
	// potentially wider span, then test the bounds to see if extension before or after is needed, and if so,
	// copy the relevant CSourcePhrase deep copies to the cancel span's list and the modifications span's list
	// (as both these must contain the same instances). Doing these things, the original m_pSourcePhrases list
	// contents in the document class remains unchanged in any way, so that if any of these processing steps
	// fails, the document remains valid.
	SPList* pTempList = new SPList;

	// First: do any required extra scanning to left and right if the beginning of a free translation section
	// and/or the end of a free translation section, if present, are not coterminous with the start and end
	// of the span (possibly extended earlier) derived from the user's original selection, returning TRUE
	// in the bFreeTransPresent parameter if there was some free translation data defined over the span, 
	// FALSE if not; and the function returns TRUE if there was no error, FALSE if there was an error 
	bool bFreeTransPresent;
	bAllWasOK = GetEditSourceTextFreeTranslationSpan(pSrcPhrases, pRec->nStartingSequNum, pRec->nEndingSequNum,
						pRec->nFreeTrans_StartingSequNum, pRec->nFreeTrans_EndingSequNum, bFreeTransPresent);
	if (!bAllWasOK)
	{
		// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level, so we can do so here;
			goto exit;
		}
		else
			wxExit();
	}
	if (bFreeTransPresent)
	{
		// extension to left or right or in both directions was done if needed, but we don't show any of the
		// extra stuff to the user; we just use the wider span to ensure we remove whole free translation
		// sections because otherwise we'd corrupt the document; so all we need do is do the relevant
		// deep copy for the wider span, and set the EditRecord flag
		pRec->bEditSpanHasFreeTranslations = TRUE;
		bAllWasOK = DeepCopySourcePhraseSublist(pSrcPhrases, pRec->nFreeTrans_StartingSequNum, 
													pRec->nFreeTrans_EndingSequNum, pTempList);
		if (!bAllWasOK)
		{
			// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

		// work out if the subspan for free translations starts earlier, or ends later, than the current
		// bounds for the cancel span; if so, work out the new bounds for the cancel span's indices
		pRec->nCancelSpan_StartingSequNum = wxMin(pRec->nCancelSpan_StartingSequNum,
												pRec->nFreeTrans_StartingSequNum);
		pRec->nCancelSpan_EndingSequNum = wxMax(pRec->nCancelSpan_EndingSequNum,
												pRec->nFreeTrans_EndingSequNum);

		// Do any required extension of the "cancel span" list (extension is not assumed, the function
		// internally works out if it is needed and where, and does whatever extending is required)
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList, &pRec->cancelSpan_SrcPhraseList, 
										pRec->nStartingSequNum, pRec->nEndingSequNum);
		if (!bAllWasOK)
		{
			// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

		// Also do any required extension of the "modifications span" list (an alternative way to do
		// this would be to just do a deep copy of the cancel list using CopyCSourcePhrasesToExtendSpan())
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList, &pRec->modificationsSpan_SrcPhraseList, 
										pRec->nStartingSequNum, pRec->nEndingSequNum);
		if (!bAllWasOK)
		{
			// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

		// clear out the contents of the temporary list
		pDoc->DeleteSourcePhrases(pTempList);
	} // end block for test (bFreeTransPresent == TRUE)
	else
	{
		// clear the flag, and don't do a deep copy as we've no free translations to remove later on;
		// & set the stored sequence number values back to -1 since this span is undefined
		pRec->bEditSpanHasFreeTranslations = FALSE;
		pRec->nFreeTrans_StartingSequNum = -1;
		pRec->nFreeTrans_EndingSequNum = -1;
	}

	// do a third subspan, if it exists, for the collected back translations; the start of such a span (if
	// it exists) will usually be somewhere preceding the pRec->nStartingSequNum value, and may even be
	// preceding the pRec->nFreeTrans_StartingSequNum value (if free translations are defined on this
	// editing context); but we don't require that the end of any back translation collection span(s)
	// be made to coincide with the end of the free translations span nor with the end of the editable
	// span - though  typically if will end somewhere shortly after the pRec->nEndingSequNum value.
	bool bBackTransPresent;
	bAllWasOK = GetEditSourceTextBackTranslationSpan(pSrcPhrases, pRec->nStartingSequNum, 
						pRec->nEndingSequNum, pRec->nFreeTrans_StartingSequNum, 
						pRec->nFreeTrans_EndingSequNum, pRec->nBackTrans_StartingSequNum,
						pRec->nBackTrans_EndingSequNum, bBackTransPresent);
	if (!bAllWasOK)
	{
		// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level, so we can do so here;
			goto exit;
		}
		else
			wxExit();
	}

	if (bBackTransPresent)
	{
		// set the EditRecord's flag, and get the deep copy done of all the CSourcePhrases in the
		// back translation span (the back translations in this span will be later removed so the user
		// won't have to bother dealing with them while editing the source text; the are abandoned rather
		// than stored, because they can be recollected later easily once this span is delineated
		pRec->bEditSpanHasBackTranslations = TRUE;
		bAllWasOK = DeepCopySourcePhraseSublist(pSrcPhrases,pRec->nBackTrans_StartingSequNum, 
								pRec->nBackTrans_EndingSequNum, pTempList);
		if (!bAllWasOK)
		{
			// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

		// work out if the subspan for back translations starts earlier, or ends later, than the current
		// bounds for the cancel span; if so, work out the new bounds for the cancel span's indices
		pRec->nCancelSpan_StartingSequNum = wxMin(pRec->nCancelSpan_StartingSequNum,
												pRec->nBackTrans_StartingSequNum);
		pRec->nCancelSpan_EndingSequNum = wxMax(pRec->nCancelSpan_EndingSequNum,
												pRec->nBackTrans_EndingSequNum);

		// Do any required extension of the "cancel span" list; take care, only the instances prior to
		// the minimum index for the start of the editable span and the free translation span (if the
		// latter exists) need be inserted, and only the instances after than the maximim index for the
		// end of the editable span and the free translation span (if the latter exists) need to be appended
		int nEarliestAlreadyPresent = pRec->nStartingSequNum;
		int nLatestAlreadyPresent = pRec->nEndingSequNum;
		if (pRec->bEditSpanHasFreeTranslations)
		{
			nEarliestAlreadyPresent = wxMin(pRec->nStartingSequNum,pRec->nFreeTrans_StartingSequNum);
			nLatestAlreadyPresent = wxMax(pRec->nEndingSequNum,pRec->nFreeTrans_EndingSequNum);
		}
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList, &pRec->cancelSpan_SrcPhraseList, 
										nEarliestAlreadyPresent, nLatestAlreadyPresent);
		if (!bAllWasOK)
		{
			// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

		// Do any required extension of the "modifications span" list; take care, only the instances prior to
		// the minimum index for the start of the editable span and the free translation span (if the
		// latter exists) need be inserted, and only the instances after than the maximum index for the
		// end of the editable span and the free translation span (if the latter exists) need to be appended
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList, &pRec->modificationsSpan_SrcPhraseList, 
										nEarliestAlreadyPresent, nLatestAlreadyPresent);
		if (!bAllWasOK)
		{
			// something went wrong, bail out (m_pSourcePhrases list contents have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

		// clear out the contents of the temporary list
		pDoc->DeleteSourcePhrases(pTempList);
	} // end of block for test (bBackTransPresent == TRUE)
	else
	{
		// no back translations were defined on this editable span, so do no deep copy and make sure
		// the edit record has the appropriate values (redundant, but helps understanding if we do it)
		pRec->bEditSpanHasBackTranslations = FALSE;
		pRec->nBackTrans_StartingSequNum = -1;
		pRec->nBackTrans_EndingSequNum = -1;
	}
	/*
	// check we got correct spans
	TRACE2("\n Editable   Span = %d , %d\n",pRec->nStartingSequNum,pRec->nEndingSequNum);
	TRACE2(" Free Trans Span = %d , %d\n",pRec->nFreeTrans_StartingSequNum,pRec->nFreeTrans_EndingSequNum);
	TRACE2(" Back Trans Span = %d , %d\n",pRec->nBackTrans_StartingSequNum,pRec->nBackTrans_EndingSequNum);
	TRACE2(" Cancel Span = %d , %d\n",pRec->nCancelSpan_StartingSequNum,pRec->nCancelSpan_EndingSequNum);
	int ii = 1; // a do-nothing statement for a break point for the TRACE macros	
	*/
	// Up to now, the CAdapt_ItDoc class's m_pSourcePhrases list which defines the document contents has not
	// been altered in any way. We are now about to do modifications of the information in the CSourcePhrase
	// instances in the (deep copied) modifications list, the modifications being to remove potentially large
	// slabs of information which the user would find distracting to see while trying to edit the source text
	// - such info is notes, collected back translations, free translations; also since the source will change,
	// old adaptations and glosses (we'll preserve copies of these for access in the combobox later, but not
	// remove them from the editable span because the editable span will be abandoned and replaced by newly
	// parsed material, so there is no point in removing anything from what is going to be thrown away anyway).
	// The removed information types are preserved in lists which are made accessible in a combobox at each
	// stage of the overall process - except that back translations are unilaterally abandoned, and notes are
	// automatically restored (albeit, probably at different locations, depending on how the user edits
	// the source text). In keeping with out design being not to alter any of the original document until after
	// the user commits to his changes in the dialog by hitting the OK key, the modifications will be done
	// on the deep copies in the modifications list; the cancel list will remain untouched, as it must persist
	// through the total vertical edit process in case the use elects to Cancel out of the whole edit process,
	// in which case the cancel list is needed in order to help restore the original document state.
	//
	// The next major function call will scan across the modification list's  CSourcePhrase instances,
	// (smartly, using knowledge stored in gEditRecord) the required information removals and
	// sequestering in lists within gEditRecord. When it completes, various CSourcePhrase instances
	// will be simplified in their m_markers member(we don't bother to unmerger any mergers, as there is
	// no need to do so), and then afterwards we accumulate the source text string from the simplified
	// instances in order to show it to the user for editing. We must also handle movement of initial
	// endmarkers at either end of the editable span; see notes further below for details.

	// To keep removals done left to right in the order top to bottom in lists, we must add the removed
	// information types to temporary lists, using AddTail(), and then insert the sublists at the head
	// of the final storage lists. The strings saved are copies, so later deletion of the old CSourcePhrase
	// edited instances will leave the string copies in the wxArrayString instances intact.
	wxArrayString* pAdaptList = new wxArrayString; // MFC uses CStringList
	wxArrayString* pGlossList = new wxArrayString;
	wxArrayString* pFTList = new wxArrayString;
	wxArrayString* pNoteList = new wxArrayString;

	// a couple of local variables for the start and end of the editable span are convenient here
	int nStartAt = pRec->nStartingSequNum; // can't be -1
	int nEndAt = pRec->nEndingSequNum; // can't be -1

	// We have to handle any preceding information's endmarkers stored at the start of the editable span
	// (we find out what they are and store them, including their final delimiting white space(s)), and
	// any following information's storage of endmarkers belonging to the end of the editable span also
	// has to be determined, stored in pRec for later appending to the end of the editable string which
	// the user eventually will see -- but nothing is appended if there are no endmarkers at that location
	// in the first place.
	wxString strInitialEndmarkers; // pRec also has a member of this name
	wxString strFinalEndmarkers; // ditto
	strInitialEndmarkers.Empty(); strFinalEndmarkers.Empty();
	
	// The editable span may end where there may have been endmarkers, in which case
	// they will have been stored at the beginning of the m_markers member of the
	// CSourcePhrase instance immediately following the editable span. Check for this,
	// and if found, store a copy of them in a CString in pRec
	nFirstFollContextCSrcPhraseSN = nEndAt + 1;
	if (nFirstFollContextCSrcPhraseSN <= gpApp->m_maxIndex)
	{
		// there is a CSourcePhrase instance following the last one in the editable
		// span, so check for a non-empty m_markers member in it, and if there is such
		// then check for any initial endmarkers in it - any of these must be copied, along with
		// delimiting following space(s), and stored in pRec (note, we do this check on the document's
		// m_pSourcePhrases list, rather than a copied sublist, to be sure that we can access the first
		// CSourcePhrase instance following the editable context where the check is to be done
		CSourcePhrase* pSrcPhrase2 = NULL;
		SPList::Node* pos2 = pSrcPhrases->Item(nFirstFollContextCSrcPhraseSN);//POSITION pos2 = pSrcPhrases->FindIndex(nFirstFollContextCSrcPhraseSN);
		wxASSERT(pos2); // the above is unlikely to fail
		if (pos2 != NULL)
		{
			bool bLacksFinalEndmarkers = TRUE;
			pSrcPhrase2 = pos2->GetData(); // MFC uses GetAt()
			wxASSERT(pSrcPhrase2 != NULL);
			strFinalEndmarkers = RemoveInitialEndmarkers(pSrcPhrase2, gpApp->gCurrentSfmSet,
										bLacksFinalEndmarkers,TRUE); // TRUE means "copy only, don't remove"
			if (!bLacksFinalEndmarkers && !strFinalEndmarkers.IsEmpty())
			{
				// we've got a copy of one or more consecutive endmarkers, so store it for later on
				pRec->strFinalEndmarkers = strFinalEndmarkers;
			}
		}
		else
		{
			wxMessageBox(_T("FindIndex() failed in OnEditSourceText(), pos value is NULL when finding following endmarkers. Saving document, abandoning edit."
				), _T(""), wxICON_EXCLAMATION);
			goto exit;
		}
	}
	// do the same, for any endmarkers stored at the start of the editable span - these later must
	// be removed from the start of the editable string which the user will see, before he sees it
	nFinalPrecContextCSrcPhraseSN = nStartAt;
	CSourcePhrase* pSrcPhrase2 = NULL;
	SPList::Node* pos2 = pSrcPhrases->Item(nFinalPrecContextCSrcPhraseSN); //POSITION pos2 = pSrcPhrases->FindIndex(nFinalPrecContextCSrcPhraseSN);
	wxASSERT(pos2); // the above is unlikely to fail
	if (pos2 != NULL)
	{
		bool bLacksInitialEndmarkers = TRUE;
		pSrcPhrase2 = pos2->GetData();
		wxASSERT(pSrcPhrase2 != NULL);
		strInitialEndmarkers = RemoveInitialEndmarkers(pSrcPhrase2, gpApp->gCurrentSfmSet,
										bLacksInitialEndmarkers,TRUE); // TRUE means "copy only, don't remove"
		if (!bLacksInitialEndmarkers && !strInitialEndmarkers.IsEmpty())
		{
			// we've got a copy of one or more consecutive endmarkers, so store it for later on
			pRec->strInitialEndmarkers = strInitialEndmarkers;
		}
	}
	else
	{
		wxMessageBox(_T("FindIndex() failed in OnEditSourceText(), pos value is NULL when finding preceding endmarkers. Saving document, abandoning edit."
			), _T(""), wxICON_EXCLAMATION);
		goto exit;
	}
	
	// Do the scan for removing and sequestering removed information; the CSourcePhrase instances scanned
	// are those in the modifications list - these are deep copies of those on the document, and so we
	// still will not have changed any of the document as yet, only fiddled with copies so far
	bool bAllsWell = ScanSpanDoingRemovals(&pRec->modificationsSpan_SrcPhraseList, pRec,
											pAdaptList, pGlossList, pFTList, pNoteList);
	if (!bAllsWell)
	{
		// something fouled up, the bailout function has not already been called from a lower level, so we
		// can do so here; but first remove the temp string lists and their data, to avoid memory leaks
bailout:	pAdaptList->Clear();
		pGlossList->Clear();
		pFTList->Clear();
		pNoteList->Clear();
		delete pAdaptList;
		delete pGlossList;
		delete pFTList;
		delete pNoteList;
		goto exit;
	}

	// Get the insertions done for the removed information, putting the information into gEditRecord,
	// and then deleting the temporary CStringList instances (but leave their contents unremoved because the 
	// gEditRecord will manage those strings instead)
	bool bResult = TRUE;
	wxString errStr;
	if (pAdaptList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pAdaptList, adaptationsList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T("InsertSublistAtHeadOfList() for adaptations sublist, failed. Unknown list requested. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			goto bailout;
		}
		delete pAdaptList;
	}
	if (pGlossList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pGlossList, glossesList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T("InsertSublistAtHeadOfList() for glosses sublist, failed. Unknown list requested. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			goto bailout;
		}
		delete pGlossList;
	}
	if (pFTList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pFTList, freeTranslationsList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T("InsertSublistAtHeadOfList() for free translations sublist, failed. Unknown list requested. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			goto bailout;
		}
		delete pFTList;
	}
	if (pNoteList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pNoteList, notesList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T("InsertSublistAtHeadOfList() for notes sublist, failed. Unknown list requested. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			goto bailout;
		}
		delete pNoteList;
	}

	// We are now ready to accumulate the editable text from the editable span, and append any endmarkers
	// stored in the document at the first CSourcePhrase instance of the context following the editable
	// span (such endmarkers logically belong with the editable text, at its end). These endmarkers, if
	// present at that location, are stored already in gEditRecord in its strFinalEndmarkers
	// member. Likewise, endmarkers stored in m_markers of the first CSourcePhrase of the editable span
	// do not belong logically with the source text to be edited, but rather with the source text which
	// ends at the end of the context material before the editable span; hence these have to be removed
	// from the accumulated string before it is shown to the user -- and those endmarkers, if present
	// at that location, are stored already in gEditRecord in its strInitialEndmarkers
	// member. The accumulation, however, is not done from the unmodified CSourcePhrase instances in the
	// m_pSourcePhrases list in the document, but from the modified deep copies in the modifications list.
	bAllsWell = ScanSpanDoingSourceTextReconstruction(&pRec->modificationsSpan_SrcPhraseList, 
					pRec, pRec->nStartingSequNum, pRec->nEndingSequNum, strSource);
	if (!bAllsWell)
	{
		// there was an error (could not obtain a valid pos value within the function, an error message
		// has already been shown, so try safely preserve the document and then abort)
		goto bailout;
	}

	// There could be other filtered information in the reconstructed source text, which is not a
	// note, free translation or back translation, and it does not get removed. It will therefore
	// have \~FILTER and \~FILTER* marker and endmarker pairs wrapping each such filtered marker and
	// its content, eg. cross reference material. We must now remove these filter wrapping markers
	// because the parse of the edited source text will refilter such material, and if we don't
	// remove the \~FILTER and \~FILTER* pairs, we'd end up with extra ones wrapping the ones already
	// present. The global C strings filterMkr and filterMkrEnd store these markers. Search for them
	// and the following space for each, and remove them.
	RemoveFilterWrappersButLeaveContent(strSource);

	// BEW changed 7May08: update to keep the KB properly updated, provided the active location 
	// is not in the selection, but if it is, then we don't update because the active location's
	// source word may no longer exist after the user finishes editing the source. The box, and 
	// m_targetPhrase, will be reconstituted later appropriately, depending on what the user does
	// in the edit -- if there was some text remaining after his edit, the box will be placed at
	// the CSourcePhrase instance which stores the edited source's first word.
	int nOldSaveActiveSequNum = pRec->nSaveActiveSequNum;
	bool bActiveLocationWithinEditableSpan = (nOldSaveActiveSequNum >= pRec->nStartingSequNum) &&
		(nOldSaveActiveSequNum <= pRec->nEndingSequNum) ? TRUE :  FALSE;
	if (!bActiveLocationWithinEditableSpan  && gpApp->m_pActivePile != NULL)
	{
		// the active location is not within the retranslation section, and the layout is still
		// valid, so update KB for this location's phrase box contents (if the user has not finished
		// making it a valid string when he invoked the source text edit, then too bad - it will go
		// 'as is' into the KB, unless internal tests require the store be skipped)
		DoConditionalStore(FALSE); // FALSE is bOnlyWithinSpan, it forces unilateral store if 
								   // other conditions are met
	}
	gpApp->m_targetPhrase.Empty(); // empty m_targetPhrase; because the box may be built elsewhere 
							// after editing
	if (gpApp->m_pTargetBox != NULL)
	{
		gpApp->m_pTargetBox->SetValue(gpApp->m_targetPhrase);
	}

	// need to clobber the selection now, so the selection globals will be set to -1, etc,
	// otherwise RecalcLayout will fail at its RestoreSelection() call
	RemoveSelection();

	// The document's native structures are as yet still unchanged.

	// create the edit source text dialog; then prepare the preceding and following context
	// strings (we decline to display the SFM markup in the context strings, because we want
	// to make it easy for the user to just follow what the source text meaning actually is
	CEditSourceTextDlg dlg(gpApp->GetMainFrame());

	// initialize the edit boxes
	dlg.m_strOldSourceText = strSource;
	dlg.m_strNewSourceText = strSource;
	wxString precedingSrc;
	precedingSrc.Empty();
	wxString followingSrc;
	followingSrc.Empty();
	wxString precedingTgt;
	precedingTgt.Empty();
	wxString followingTgt;
	followingTgt.Empty();
	// the following call needs the target text's CString variables passed in, but the 
	// Edit Source Text functionality does not use the values returned in them; these
	// context strings are built up from the meanings in the document's m_pSourcePhrases
	// list, because getting sufficient context may require looking at CSourcePhrase 
	// instances preceding and/or following those in any of the sublists thus far populated
	GetContext(pRec->nStartingSequNum,pRec->nEndingSequNum, precedingSrc, followingSrc,
				precedingTgt, followingTgt); 
	dlg.m_preContext = precedingSrc;
	dlg.m_follContext = followingSrc;

	// put up the Edit Source Text dialog's window
	bool bMarkerSetsAreDifferent = FALSE;
	if (dlg.ShowModal() == wxID_OK)
	{
		// the user has committed to the edit changes he has made, so in this block we
		// can now actually modify the document's contents
		wxString strNewSrcText = dlg.m_strNewSourceText;
		int nNewCount = 0; // number of CSourcePhrase instances to be returned from the 
						   // tokenization operation
		bool bFirstIsFirstOfType = FALSE; // BEW added 6Aug08 to help control text type and colour
										  // if the user deletes the whole of the editable span
		CPile* pFirst = GetPile(pRec->nStartingSequNum);
		bFirstIsFirstOfType = pFirst->m_pSrcPhrase->m_bFirstOfType; // use this later below

		// Before we do anything to the CSourcePhrase instances, we have to set up a correct
		// value for the chapter number used in the Document's member m_curChapter, which is to
		// have a value of the form "n:" where n is the chapter number. We have a legacy function
		// for detecting what chapter we are in given a passed in pointer to a CSourcePhrase, so
		// we use that, passing in the instance which is at the start of the editable span. We
		// need to do this here before TokenizeTextString() is called, because the latter calls
		// TokenizeText(), which in turn uses m_curChapter. Remember, we can't assume there will
		// have been a \c marker within the user's selection, but there may well be a \v, and on
		// that CSourcePhrase instance we need to set a valid m_chapterVerse, of the form "n:m",
		// and TokenizeText() uses the m_curChapter value to set the "n:" part, so now we must
		// make sure the value it is going to use is correct
		// now get the preceding CSourcePhrase's pointer (ie. preceding the editable span),
		// it could be NULL
		CSourcePhrase* pInitialSrcPhrase = NULL;
		int aSequNum = pRec->nStartingSequNum; // location of start of edit span (possibly extended)
		SPList::Node* aPos = pSrcPhrases->Item(aSequNum);//POSITION aPos = pSrcPhrases->FindIndex(aSequNum); // returns NULL if out of bounds
		if (aPos != NULL)
		{
			// we are not at the start of the document, so there is preceding context
			pInitialSrcPhrase = aPos->GetData();

			// set the doc's m_curChapter string, because it could have any arbitrary value left in
			// it from some earlier parse (with colon following it), and since our editable span 
			// might have a verse number before the chapter number, or no chapter number at all, in 
			// either of those cases we would have a wrong n:m value being set
			gpApp->m_curChapter = _T("0:"); // default to use if there are no chapter markers
			if (pInitialSrcPhrase != 0)
			{
				// get chapter and verse
				wxString cv = GetChapterAndVerse(pInitialSrcPhrase);
				if (cv.GetChar(0) == _T('0'))
				{
					// there are no chapter numbers, so leave the default zero at the start to 
					// flag this fact
					;
				}
				else
				{
					// remove verse numbers from n:m until only n: remains
					int offset = cv.Find(_T(':'));
					if (offset != -1)
					{
						// found it
						wxString left = cv.Left(offset + 1);
						gpApp->m_curChapter = left;
					}
				}
			}
		}

		// Detect whether or not the user has edited the SF markers - specifically, if there is
		// at least one SF marker in the edited text which is not in the original text, or vise
		// versa. If either is the case, we later want to call DoMarkerHousekeeping() over the whole
		// document to ensure that any typo markers get appropriately handled as far as nav text, text colour
		// and TextType are concerned. The TokenizeTextString() call will do any needed unfiltering or filtering.
		// The AreMarkerSetsDifferent() function below (see Helpers.cpp) also does tests, if the return value is
		// TRUE, to determine if unfiltering, and/or filtering will get done. We need to know about any filtering
		// due to a respelled marker in order to make sure all the filterable content is included in the editable
		// span - so if the user has not done that, we'll do it further below programmatically. The algorithm
		// checking marker status is not foolproof, but it should take care of all or most situations that
		// are reasonably expected to be handleable. We really only need it to handle a filtered marker
		// which the user edits so as to be a marker which should be unfiltered (that original marker may
		// or may not be an unknown one, it doesn't matter either way, and the destination marker can
		// likewise be, or not be, an unknown one); or, an unfiltered marker which the user edits to be
		// a marker which should be filtered (and similarly, either being known or unknown doesn't matter).
		// Marker edits which require no filtering change, whether unfiltered and remain so, or filtered and
		// remain so, don't need any attention here. The application class's string gCurrentFilterMarkers is
		// used internally to determine filterable status
		bool bFilteringRequired = FALSE; // these two are set or cleared by the following call, but it
		bool bUnfilteringRequired = FALSE; // is the first having a TRUE value that we are interested in
		bMarkerSetsAreDifferent = AreMarkerSetsDifferent(strSource, strNewSrcText,bUnfilteringRequired,
															bFilteringRequired);

		// Any unfiltering & filtering will be handled by the TokenizeTextString(), but it doesn't necessarily
		// handle required filtering completely because only the user's selected words will get into the
		// filtered content of a now-to-be-filtered marker which has had its spelling changed in the edit
		// source text dialog, and the user may have intended to only edit the marker and so may have just
		// selected the first word (which carries the marker) rather than it and all subsequent words which
		// are to be filtered - in which case unless we do an edit span expansion here, only the single
		// selected word would be filtered and the rest of the filterable content will stay unfiltered
		// in the document. So, we check that filtering of an edited marker has been called for, and if so,
		// we check that the whole of the marker's content (as far as preceding, but not including the first
		// CSourcePhrase instance which stores a marker for which the associated TextType is not 'none' - the 
		// latter are things like keyword markup, italic markup, bold markup, etc, and we just want Adapt It to
		// completely ignore SFMs associated with such things) is included in the editable span, and if not, we
		// now extend the editable span rightwards, altering the ending sequence numbers etc, and adding copies
		// of the CSourcePhrase instances thereby added at the end to the spans in the EditRecord, etc, and
		// adding the m_srcPhrase words, space delimited, to the end of the strNewSrcText string, so that
		// these extra words will be included in the TokenizeTextString() call below.
		// Doing these modifications right now gets them done before the editableSpan_NewSrcPhrase List and
		// propagationSpan_SrcPhraseList are populated, and their spans' starting and ending indices evaluated,
		// and similarly for other EditRecord members having to do with the location and properties of the
		// "following context". We are doing here what we'd prefer to have done before the dialog was opened
		// but couldn't, because we had to wait for the user to actually effect the respelling of a marker.
		bool bWasExtended = FALSE;
		if (bFilteringRequired)
		{
			bool bIsOK;
			bIsOK = ExtendEditableSpanForFiltering(pRec, pSrcPhrases, strNewSrcText, 
								&gpApp->m_FilterStatusMap, bWasExtended);
			if (!bIsOK)
			{
				// something went wrong and so we have to bail out; the document's m_pSourcePhrases list's
				// contents has not been altered by what happens within ExtendEditableSpanForFiltering(),
				// and so bailout is simple
				errStr = _T("Failure when extending the editable span to handle filterable content. ");
				errStr += _T("Vertical edit process abandoned. "); 
				errStr += _T("Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto z;
			}
			if (bWasExtended)
				pRec->bExtendedForFiltering = TRUE; // record the fact
		}

		// Tokenize the edited source text into a list of new CSourcePhrase instances on the heap,
		// pRec->nStartingSequNum is the absolute sequence number for first source phrase in the sublist
		// - it is used to define the starting sequence number to be stored on the first element of
		// the sublist, and higher numbers on succeeding ones. Note: if marker status was changed in the
		// edit, then any filtering or unfiltering will be done here and all we need later do is call
		// DoMarkerHousekeeping() over the whole document to clean up the navigation text, text types,
		// colours, etc
		wxString chvStr = gpApp->m_curChapter;

		nNewCount = TokenizeTextString(&pRec->editableSpan_NewSrcPhraseList, strNewSrcText,
										pRec->nStartingSequNum);
		pRec->nNewSpanCount = nNewCount; // this value may decrease by one if a CSourcePhrase carrier
										 // of final endmarkers, but with no source text, is found to
										 // be present and therefore gets removed in the code below

		// do a while loop for looking at the pSrcPhrase instances in debug mode
		/*
		POSITION posTemp = pRec->editableSpan_NewSrcPhraseList.GetHeadPosition();
		while (posTemp != NULL) {
			CSourcePhrase* pSP = (CSourcePhrase*)pRec->editableSpan_NewSrcPhraseList.GetNext(posTemp);
			CString itsSrcPhrase = pSP->m_srcPhrase;
			CString itsMarkers = pSP->m_markers;
		}
		*/

		// from this point on, the document itself will be changed, so we indicate this is
		// the case by setting the following global boolean to FALSE; the BailOut() function
		// uses this value to work out what needs to be done if there was a cancel, or a failure
		// after the document has been modified
		gbEditingSourceAndDocNotYetChanged = FALSE;

		// Before going further, we must replace the CSourcePhrase instances in the cancel span with
		// the modified ones in the modifications list. This is to ensure that the changed CSourcePhrase
		// instances resulting from the removed information which was removed prior to displaying the
		// dialog, actually find their way into the document -- the instances we are particularly
		// concerned with are those (if any) preceding the start of the editable span, and those (if any)
		// which follow the end of the editable span, because those are not changed when the editable
		// span's content is replaced by the CSourcePhrase instances resulting from the parse of the
		// user's edited source text; so if we didn't do this substitution now, we'd run the risk of
		// the old free translations, & collected back translations, remaining present (filtered) in
		// those preceding and following contexts, when in actual fact we want them removed so that the
		// vertical edit process can help the user to reconstitute them with appropriate changes.

		/*
		// check the spans
		TRACE2("\n Editable   Span = %d , %d\n",pRec->nStartingSequNum,pRec->nEndingSequNum);
		TRACE2(" Free Trans Span = %d , %d\n",pRec->nFreeTrans_StartingSequNum,pRec->nFreeTrans_EndingSequNum);
		TRACE2(" Back Trans Span = %d , %d\n",pRec->nBackTrans_StartingSequNum,pRec->nBackTrans_EndingSequNum);
		TRACE2(" Cancel Span = %d , %d\n",pRec->nCancelSpan_StartingSequNum,pRec->nCancelSpan_EndingSequNum);
		int ii = 1; // a do-nothing statement for a break point for the TRACE macros	
		*/
		// do a while loop for looking at the pSrcPhrase instances of the modifications span in debug mode
		/*
		SPList::Node* posTemp = pRec->modificationsSpan_SrcPhraseList.GetFirst();
		int modsCountFromCancelSpanBounds = pRec->nCancelSpan_EndingSequNum - pRec->nCancelSpan_StartingSequNum + 1;
		int modsCountFromSublist = (int)pRec->modificationsSpan_SrcPhraseList.GetCount();
		while (posTemp != NULL) {
			CSourcePhrase* pSP = posTemp->GetData();
			posTemp = posTemp->GetNext();
			int itsSequNum = pSP->m_nSequNumber;
			wxString itsSrcPhrase = pSP->m_srcPhrase;
			//wxString itsMarkers = pSP->m_markers;
			bool bItsFreeTransFlag = pSP->m_bHasFreeTrans;
			bool bItsStartFTflag = pSP->m_bStartFreeTrans;
			bool bItsEndFTflag = pSP->m_bEndFreeTrans;
		}
		*/

		int nHowMany = pRec->nCancelSpan_EndingSequNum - pRec->nCancelSpan_StartingSequNum + 1;
		int nReplacementCount = nHowMany;

		// populate the editSpan_NewSrcPhraseList list with deep copies of the CSourcePhrase instances
		// created from the TokenizeTextString() call.
		bool bReplacedOK;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, pRec->nCancelSpan_StartingSequNum,
			nHowMany, &pRec->modificationsSpan_SrcPhraseList, 0, nReplacementCount);
		if (!bReplacedOK)
		{
			// if we had an error while replacing the modifications, so we have to bail out of the
			// whole edit process, try to save the document too
			errStr = _T("Replacing with modified CSourcePhrases after dialog dismissal failed. ");
			errStr += _T("Vertical edit process abandoned. "); 
			errStr += _T("Will try now to restore the document to its pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			BailOutFromEditProcess(pSrcPhrases,pRec);
			goto z;
		}

		/*
		// check the spans
		TRACE2("\n Editable   Span = %d , %d\n",pRec->nStartingSequNum,pRec->nEndingSequNum);
		TRACE2(" Free Trans Span = %d , %d\n",pRec->nFreeTrans_StartingSequNum,pRec->nFreeTrans_EndingSequNum);
		TRACE2(" Back Trans Span = %d , %d\n",pRec->nBackTrans_StartingSequNum,pRec->nBackTrans_EndingSequNum);
		TRACE2(" Cancel Span = %d , %d\n",pRec->nCancelSpan_StartingSequNum,pRec->nCancelSpan_EndingSequNum);
		int iii = 1; // a do-nothing statement for a break point for the TRACE macros	
		*/
		// do a while loop for looking at the pSrcPhrase instances after the replacements, in debug mode
		/*
		int sn = pRec->nCancelSpan_StartingSequNum;  // start from beginning of cancel span
		POSITION pos2 = pSrcPhrases->FindIndex(sn);
		int modsCount = 0;
		while (pos2 != NULL) {
			CSourcePhrase* pSP = (CSourcePhrase*)pSrcPhrases->GetNext(pos2);
			modsCount++;
			int itsSequNum = pSP->m_nSequNumber;
			CString itsSrcPhrase = pSP->m_srcPhrase;
			//CString itsMarkers = pSP->m_markers;
			BOOL bItsFreeTransFlag = pSP->m_bHasFreeTrans;
			BOOL bItsStartFTflag = pSP->m_bStartFreeTrans;
			BOOL bItsEndFTflag = pSP->m_bEndFreeTrans;
			if (modsCount >= nHowMany)
				break;
		}
		*/

		// Because the user can edit the markup as readily as the source text, we cannot assume that
		// the old source text without any final endmarkers will remain that way, nor the old source
		// text with final endmarkers will remain that way, or even that markers (and therefore
		// TextType) won't change from what was in effect before. The user may also have respelled a
		// mispelled marker, resulting in content being filtered. So we must assume nothing and check
		// to see what is there, and do processing appropriate for what we find. The first task is
		// to check the list of new CSourcePhrase instances to see if the end one is an insertion
		// just to carry widowed endmarkers or filtered info that was at the end of the edited source
		// text string. If either is the case, we need to do: (1) for unfiltered endmarkers, move those
		// endmarkers to the start of the first CSourcePhrase instance in the following context -
		// specifically, to the start of its m_markers member; and then remove that carrier CSourcePhrase
		// instance - we can determine it is a carrier by checking that the m_follPunct and m_key members
		// are both empty strings. For (2), a carrier with now-filtered information, that information will
		// have been put into the m_markers member of the carrier, and the same tests as in (1) apply. In
		// either case we can't remove the carrier if there is no following context (ie. the user's edit
		// was done at the very end of the document). We set up members of the EditRecord to store the
		// pre-edit information (in case the user Cancels, or an exception forces bail out back to the
		// pre-edit document state).
		gpFollSrcPhrase = NULL; // a global CSourcePhrase*
		int nFollowingSequNum = pRec->nEndingSequNum + 1;
		SPList::Node* posFoll = pSrcPhrases->Item(nFollowingSequNum); //POSITION posFoll = pSrcPhrases->FindIndex(nFollowingSequNum); // returns NULL if out of bounds
		if (posFoll != NULL)
		{
			// we are not at the end of the document, so there is following context
			gpFollSrcPhrase = posFoll->GetData();

			// there may be propagation, and we must make a deep copy of the gpFollSrcPhrase as the
			// first in the following context, storing it in pRec's propagationSpan_SrcPhraseList
			// member as the first of any propagation modifications (in case it is modified by
			// having new endmarkers restored there, or filtered info transferred there, and in case
			// propagation of parameters to suceeding instances happens in code further below. pOldFollSrcPhrase
			// has the original endmarkers, if any are relevant at the end of the editable span, stored on it
			// - it therefore makes it simple to restore the original following context in the event that there
			// is a failure later which requires the original document be reconstituted
			CSourcePhrase* pOldFollSrcPhrase = new CSourcePhrase(*gpFollSrcPhrase);
			pOldFollSrcPhrase->DeepCopy(); // fills out any in it's m_pSavedWords member with copies
			// wx Note: wxList::Insert() Inserts object at front of list = CObList's AddHead()
			pRec->propagationSpan_SrcPhraseList.Insert(pOldFollSrcPhrase); // save the deep copy
			pRec->nPropagationSpan_StartingSequNum = pOldFollSrcPhrase->m_nSequNumber; // initialize value
			pRec->nPropagationSpan_EndingSequNum = pOldFollSrcPhrase->m_nSequNumber; // initialize value
			// NOTE: additional deep copies may be added below to this list, and the
			// pRec->nPropagationSpan_EndingSequNum value incremented, if propagation across some
			// of the following context takes place after the DoMarkerHousekeeping() call below.

			// record the fact that any now-filtered information is transferrable to the following context
			pRec->bDocEndPreventedTransfer = FALSE;
		}
		else
		{
			// record the fact that there is no following context available for any transfer of information
			// to m_markers in a following CSourcePhrase instance
			pRec->bDocEndPreventedTransfer = TRUE;
		}
		// note, we must set gpFollSrcPhrase because our later DoMarkerHousekeeping() call
		// uses it internally

		// now get the preceding CSourcePhrase's pointer (ie. preceding the editable span),
		// it could be NULL
		// 
		// whm Debug TODO: At this point the contents of pSrcPhrases has been corrupted so that
		// pSrcPhrases->Item(nPrecedingSequNum) below gets the node for nPrecedingSequNum (10) and then
		// the following gpPrecSrcPhrase = posPrec->GetData() call returns the "John" source phrase
		// instead of the "Yupela" source phrase retrieved by the MFC version. To debug this I'll put a
		// wxLogDebug() statement back up in the most likely place where the corrputed ordering is
		// happening, namely the ReplaceCSourcePhrasesInSpan() call above.
		// 
		gpPrecSrcPhrase = NULL; // a global CSourcePhrase*
		int nPrecedingSequNum = pRec->nStartingSequNum - 1;
		SPList::Node* posPrec = pSrcPhrases->Item(nPrecedingSequNum); //POSITION posPrec = pSrcPhrases->FindIndex(nPrecedingSequNum); // returns NULL if out of bounds
		if (posPrec != NULL)
		{
			// we are not at the start of the document, so there is preceding context
			gpPrecSrcPhrase = posPrec->GetData();
		}
		// note, we must set gpPrecSrcPhrase because our later DoMarkerHousekeeping() call
		// uses it internally


		// the first document modification is to remove any final endmarkers from the first
		// CSourcePhrase instance, if any are actually there, of the following context -- to make
		// the context following the editable span internally consistent -- because the user's edit
		// may involve removal of information which ended with final endmarkers appended to the
		// editable text in the dialog, and if those endmarkers were thus removed, they must 
		// remain removed from the first CSourcePhrase instance in the following context; but
		// if the edit did not remove them, then the code further below will move whatever
		// final endmarkers are present in the new list of CSourcePhrase instances to the first
		// instance of the following context - so for that to work right, the following context
		// must have had them removed beforehand; so either way, they've gotta go and now is a 
		// good time to do it.
		wxString strRemoved;
		if (gpFollSrcPhrase != NULL && !pRec->strFinalEndmarkers.IsEmpty())
		{
			// since we just want any removed, we won't make any use of strRemoved, as it should be
			// identical to what was earlier stored in pRec as strFinalEndmarkers anyway
			bool bLacksAny = FALSE;
			strRemoved = RemoveInitialEndmarkers(gpFollSrcPhrase, gpApp->gCurrentSfmSet, bLacksAny);
		}

		// In the following call, gpFollSrcPhrase will be NULL if there is no following context; a
		// return value of TRUE means there was endmarker transfer from the new list AND deletion of
		// the last CSourcePhrase instance, to a non-NULL instance which formerly carried the markers;
		// OR, if the edit resulted in material being filtered at the end of the new sublist of 
		// CSourcePhrase instances, the transfer of the filter-marker wrapped filtered content will have
		// been done and the carrier CSourcePhrase removed.
		// (The call below also sets the pRec member strNewFinalEndmarkers to whatever endmarkers are
		// now at the end of the user's edited string, or empty if there are none at that location or
		// the endmarkers 'disappear' because they were filtered out with filterable content which has
		// now become filtered.)
		// In the special case where filtered info is transferred, the former unknown marker will have
		// caused the first CSourcePhrase of the following context to have its m_bFirstOfType flag set
		// TRUE, and the m_inform member will have something like "?\mkr?" where mkr is whatever was
		// the bare (misspelled) marker. The m_bFirstOfType value being TRUE halts propagation of correct
		// parameter values in the block further down, if we left it TRUE; and the fix to the marker should
		// at the very least cause the ?\mkr? navigation text to disappear - so the function will also
		// remedy those things before returning.
		bool bEndmarkersOrFilteredInfoTransferred = TransportWidowedEndmarkersToFollowingContext(
										&pRec->editableSpan_NewSrcPhraseList, gpFollSrcPhrase, pRec);
		if (bEndmarkersOrFilteredInfoTransferred)
		{
			// the list is shorter, so adjust the local count value which we set earlier (note: the
			// list could actually have been made empty -- see below for a discussion of where that
			// matters, before the DoMarkerHousekeeping() call)
			nNewCount = pRec->nNewSpanCount;
		}

		// We now come to the point where we have to possibly possibly propagate the new list's final
		// TextType and m_bSpecialText values forward past the end of the editable span - depending on what
		// the user has done in his editing of markers and / or source text. DoMarkerHousekeeping() fixes
		// this up, and it returns a boolean and TextType value to the caller which we can use to propagate
		// as necessary past the end. There are 3 globals for preserving the values needed for such
		// propagation; we'll set them to some good guesses here, based on what is currently known;
		// DoMarkerHousekeeping() will adjust them as, needed later, or if the sublist is empty, we'll set
		// best-possible-values directly ('verse' and m_bSpecialText = FALSE)and not call DoMarkerHousekeeping()
		gbPropagationNeeded = FALSE; // the most likely scenario 
		gPropagationType = pRec->nStartingTextType; // the TextType at the start of the editable span, 
				// (DoMarkerHousekeeping(), if called, will provide the value stored in the last CSourcePhrase
				// of the passed in new list, but usually these two are the same; but if the passed in
				// list is empty, we can't use DoMarkerHousekeeping's default as it uses gpFollSrcPhrase which
				// could be quite wrong if the user is editing the source to correct a misspelled marker
		gbSpecialText = pRec->bSpecialText;  // the special text boolean which may be propagated, however
				// (DoMarkerHousekeeping() , if called, will provide the value stored in the last CSourcePhrase
				// of the passed in new list, but usually these two are the same; but if the passed in
				// list is empty, we can't use DoMarkerHousekeeping's default as it uses gpFollSrcPhrase which
				// could be quite wrong if the user is editing the source to correct a misspelled marker

		// get the text type, etc, correct for the list contents. Care is needed here, depending on what 
		// happened within the above TransportWidowedEndmarkersToFollowingContext() call. Passing the
		// editable span's new CSourcePhrase list into DoMarkerHousekeeping will cause the latter to fail
		// and crash the app if there was only a single CSourcePhrase in the new list, and it was a carrier
		// either for endmarkers, or for now-filtered information (because the user edited a SF marker and
		// the reparse then filtered out the material shown to the user in the dialog); in either case, if
		// information was tranferred to the following context, the last CSourcePhrase in the new substring
		// will have been deleted by code in TransportWidowedEndmarkersToFollowingContext(), and if that was
		// the only instance, then the sublist is empty. The potential for user's marker correction resulting
		// in all the content being filtered is very real, and if the filtered info is tranferred to the first
		// CSourcePhrase in the following context, then that one will probably need to have a new TextType which
		// must be propagated forward, and other things will need fixing eg. an unknown marker will be in the
		// navigation area shown as ?mkr?, and that needs to be removed, the m_inform member needs resetting,
		// and some flags changing. DoMarkerHousekeeping() does those jobs, but although we can call it on an
		// empty list, it isn't helpful to do so for the following reason:
		// It defaults to TextType of verse (that's okay) but it takes the m_bSpecialText value from the value
		// on the gpFollSrcPhrase (the first in the context following) which is decidely wrong if the user
		// has just edited a wrongly spelled marker (which would have earlier given the text there a type of
		// noType) and it's almost certain that we'd not want to be propagating a noType value into the
		// following context.
		// The solution is to check pRec for the editableSpan_NewSrcPhraseList having become an empty
		// list, and if so, check that bEndmarkersOrFilteredInfoTransferred flag was set TRUE (meaning, in part,
		// that the carrier CSourcePhrase was deleted from new edit span's list of CSourcePhrases, and it was
		// the only one in that list) and in that case set the propagation parameters to default values without
		// making any DoMarkerHousekeeping call, and assume propagation is needed.
		// BEW changed 6Aug08: because Roland Fumey found that if he deleted some words (but the whoe of his
		// selection) within a \s section, which is special text, the the colouring and  text type is only
		// correct for the preceding word, and rest of the \s material gets wrongly formatted as verse TextType
		// and the specialText flag is FALSE - so I have to do cleverer code in the TRUE block just below.
		if (pRec->editableSpan_NewSrcPhraseList.IsEmpty())
		{
			// probably a typo marker was edited, and it and its contents were filtered, so assume the type
			// should now revert to verse; on the other hand, we might be editing within special text, etc, so
			// care is needed
			if (bFirstIsFirstOfType)
			{
				// use the type of the last CSourcePhrase in the preceding context
				if (gpPrecSrcPhrase != NULL)
				{
					gPropagationType = gpPrecSrcPhrase->m_curTextType;
					gbSpecialText = gpPrecSrcPhrase->m_bSpecialText;
				}
				else
				{
					// everything removed from start of document - we can assume it's not \id information,
					// so probably just a plain text file without SF markup, so assume the type is verse
					gPropagationType = verse;
					gbSpecialText = FALSE;
				}
			}
			else
			{
				// use the type stored in pRec's nStartingTextType member
				if (pRec->nStartingTextType == verse)
				{
					gPropagationType = verse;
					gbSpecialText = FALSE;
				}
				else if(pRec->nStartingTextType == poetry)
				{
					gPropagationType = poetry;
					gbSpecialText = FALSE;
				}
				else
				{
					// defaut to special text
					gPropagationType = noType;
					gbSpecialText = TRUE;
				}
			}
			gbPropagationNeeded = TRUE;
			
		}
		else
		{
			// a non-empty list means the type and special text values can be obtained from the list contents
			GetDocument()->DoMarkerHousekeeping(&pRec->editableSpan_NewSrcPhraseList, pRec->nNewSpanCount, 
									gPropagationType, gbPropagationNeeded); // sets gbSpecialText internally
		}
		if (gbPropagationNeeded)
			pRec->bSpecialText = gbSpecialText; // update the EditRecord, to keep everything straight

		// do any forward propagation, halting at the first CSourcePhrase in the following context which
		// has the member flag m_bFirstOfType set TRUE (Note; so far, nothing has been done to the contents
		// of pSrcPhrases list to invalidate any pointer in it (except possibly to add endmarkers at the
		// start of the first CSourcePhrase's m_markers CString in the following context, and that does not
		// affect the CSourcePhrase pointer itself), so we don't need any layout update yet)
		if (gbPropagationNeeded && gpFollSrcPhrase != NULL)
		{
			SPList::Node* pos = pSrcPhrases->Item(nFollowingSequNum); //POSITION pos = pSrcPhrases->FindIndex(nFollowingSequNum); // won't fail, as we computed this above
			CSourcePhrase* pSP = NULL;
			bool bIsFirst = TRUE;
			while (pos != NULL)
			{
				pSP = pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSP != NULL);
				if (pSP->m_bFirstOfType)
				{
					break; // propagation ends, don't change this one
				}
				else
				{
					// the first CSourcePhrase of the following context already has a deep copy stored
					// at the start of pRec's propagationSpan_SrcPhraseList, so we only need to store
					// the deep copies of the additional ones (making the deep copy before it is changed),
					// and then we can do the propagation on the one in the m_pSourcePhrases list of the
					// document class
					if (bIsFirst)
					{
						// skip, we've got this one
						bIsFirst = FALSE;
					}
					else
					{
						// we've not got this one in the propagation list, so do the pRec changes so as
						// to preserve the old one's contents in case we bail out later
						CSourcePhrase* pADeepCopiedSrcPhrase = new CSourcePhrase(*pSP);
						pADeepCopiedSrcPhrase->DeepCopy();
						pRec->propagationSpan_SrcPhraseList.Append(pADeepCopiedSrcPhrase);
						pRec->nPropagationSpan_EndingSequNum = pADeepCopiedSrcPhrase->m_nSequNumber;
						// NOTE: we fill this list, and get the starting and ending sequence numbers,
						// unilaterally -- without consideration of whether or not the free translation
						// span, and the back translation span, have made the cancel span already
						// encompass the CSourcePhrase instances in the propagation span. When we need
						// to know whether or not that is the case (ie. if we are required to do a bail
						// out so as to restore the original document state), we can compare indices for
						// these spans, and whenever the propagation span is subsumed by the cancel span,
						// we can just retore the cancel span and ignore the propagation span; but in the
						// event that the propagation span extends further than the end of the cancel span,
						// we use the former's contents to restore those CSourcePhrase instances which
						// lie beyond the end of the cancel span -- this saves us having to fiddle with
						// code for checking whether endmarkers were moved or replaced etc.
					}

					// now we can propagate the special text value, and the TextType
					pSP->m_bSpecialText = pRec->bSpecialText;
					pSP->m_curTextType = gPropagationType;
				}
			}
		}
		gbPropagationNeeded = FALSE; // turn it off, restoring the default value

		// now that TextType and special text value are correct, we need to put back any removed initial
		// endmarkers, putting them at the start of the m_markers member of the firstCSourcePhrase in
		// the new list
		if (!pRec->strInitialEndmarkers.IsEmpty())
		{
			// there are markers to be restored
			CSourcePhrase* pSP = NULL;
			if (pRec->editableSpan_NewSrcPhraseList.GetCount() == 0)
			{
				// the user deleted everything, so add the endmarkers to the following context's
				// first CSourcePhrase instance's m_markers member, at its start -- but we can do so
				// only provided the gpFollSrcPhrase is not NULL (it would be null only at doc end)
				if (gpFollSrcPhrase != NULL)
				{
					gpFollSrcPhrase->m_markers = pRec->strInitialEndmarkers + gpFollSrcPhrase->m_markers;
				}
			}
			else
			{
				// the newSrcPhraseList has one or more members, so add to the first in it
				//pSP = (CSourcePhrase*)pRec->editableSpan_NewSrcPhraseList.GetHead();
				SPList::Node* posSp = pRec->editableSpan_NewSrcPhraseList.GetFirst();
				pSP = posSp->GetData();
				if (pSP != NULL)
				{
					pSP->m_markers = pRec->strInitialEndmarkers + pSP->m_markers;
				}
			}
		}

		// the new CSourcePhrase instances are now ready to be put into the document's m_pSourcePhrases
		// list at the editable span location, replacing the ones in the editable span. Beware, the new
		// list might be empty, or shorter, or the same length, or longer than the former editable span.
		// The TransferCompletedSrcPhrases() function also adjusts the m_maxIndex value and other document
		// and bundle defining parameters as necessary (in particular, m_endIndex and m_upperIndex)
		int nBeginAt = pRec->nStartingSequNum;
		int nFinishAt = pRec->nEndingSequNum;
		TransferCompletedSrcPhrases(pRec,&pRec->editableSpan_NewSrcPhraseList,pSrcPhrases,nBeginAt,nFinishAt);

		/* // check the chapter:verse nav text string is correct at pile 2378 for the test document (R Fumey's)
		CPile* aPilePtr = GetPile(2378);
		CSourcePhrase* pSP_test = aPilePtr->m_pSrcPhrase;
		CString aStrTest = pSP_test->m_chapterVerse;
		TRACE1("AfterTferCompletedSPh   chapterVerse = %s\n",aStrTest);
		*/

		// get a new valid starting pile pointer for the inserted new source text -- because for a
		// source text edit, this is where the active location needs to be put
		nSaveSequNum = pRec->nStartingSequNum; // the start of the new material, if there was some new material
		if (pRec->nNewSpanCount == 0)
		{
			// there was no new material, so put the location as the previous CSourcePhrase instance
			nSaveSequNum -= 1;
			// check we didn't go negative, if so, then make the document start be the location
			if (nSaveSequNum < 0)
				nSaveSequNum = 0;
		}
		gpApp->m_nActiveSequNum = nSaveSequNum; // this ensures any later call to InsertNullSrcPhrase() won't crash

		// we must have a valid layout, because the last function call will have clobbered some of
		// the original layout's pointers
		RecalcLayout(pSrcPhrases,0,pBundle);
		pStartingPile = GetPile(nSaveSequNum);
		wxASSERT(pStartingPile != NULL);
		gpApp->m_pActivePile = pStartingPile;

		// restore removed Notes, provided there are some to be restored
		//int nNewSrcPhraseCount = -1;
		bool bNotesRestorationWorkedOK = TRUE;
		if (pRec->arrNotesSequNumbers.GetCount() > 0)
		{
			// we must first get preceding and following contexts which may get Notes moved, so
			// that a user Cancel operation will be able to be done successfully
			bool bGotSpanSuccessfully = GetMovedNotesSpan(pSrcPhrases, pRec, precedingContext);
			if (!bGotSpanSuccessfully)
			{
				// remove the contents of the arrNotesSequNumbers array first, before bailout
				// is attempted, and also the follNotesMoveSpanList and prec NotesMoveSpanList
				// need to be cleared, as one or the other may have not yet been cleared; and
				// since Note restoration has not yet been attempted, no Notes in either preceing
				// or final context can possibly have been moved as yet, so Bailout doesn't need
				// these lists if done from before the RestorNotesAfterSourceTextEdit() function
				// is called
				pRec->arrNotesSequNumbers.Clear();
				pDoc->DeleteSourcePhrases(&pRec->follNotesMoveSpanList);
				pDoc->DeleteSourcePhrases(&pRec->precNotesMoveSpanList);
				// create the user message
				errStr = _T("Notes restoration unexpectedly failed when ");
				errStr += _T("getting the potential moved notes (preceding context) span. ");
				errStr += _T("Vertical edit process abandoned. "); 
				errStr += _T("Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto z;
			}

			bGotSpanSuccessfully = GetMovedNotesSpan(pSrcPhrases, pRec, followingContext);
			if (!bGotSpanSuccessfully)
			{
				// remove the contents of the arrNotesSequNumbers array first, before bailout
				// is attempted, and also the follNotesMoveSpanList and prec NotesMoveSpanList
				// need to be cleared, as one or the other may have not yet been cleared; and
				// since Note restoration has not yet been attempted, no Notes in either preceing
				// or final context can possibly have been moved as yet, so Bailout doesn't need
				// these lists if done from before the RestorNotesAfterSourceTextEdit() function
				// is called
				pRec->arrNotesSequNumbers.Clear();
				pDoc->DeleteSourcePhrases(&pRec->follNotesMoveSpanList);
				pDoc->DeleteSourcePhrases(&pRec->precNotesMoveSpanList);
				// create the user message
				errStr = _T("Notes restoration unexpectedly failed when ");
				errStr += _T("getting the potential moved notes (following context) span. ");
				errStr += _T("Vertical edit process abandoned. "); 
				errStr += _T("Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto z;
			}

			// do the restoration of the removed Notes
			bNotesRestorationWorkedOK = RestoreNotesAfterSourceTextEdit(pSrcPhrases,pRec);
			// if there was an error, we can't continue with the vertical edit process
			// so call the BailOutFromEditProcess() function, as it knows how to bail out
			// when the document has been modified already  - it relies on some globals
			// to give it the smarts it needs
			if (!bNotesRestorationWorkedOK)
			{
				// we don't expect note restoration would ever fail, so a hard coded English
				// message for the developer's benefit will suffice here, then do the bail out
				errStr = _T("Notes restoration unexpectedly failed. ");
				errStr += _T("Vertical edit process abandoned. "); 
				errStr += _T("Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto z;
			}
		}

		// the restoration of markers did not attend to making sure every Note recreated has
		// its parent CSourcePhrase's m_bHasNote boolean set TRUE. We do that check now and fix
		// any in which the flag is still clear. (Do this in the editable span and 5 CSourcePhrase
		// instances or so either side - that should be enough to catch all which neeed this fix.)
		CheckAndFixNoteFlagInSpans(pSrcPhrases, pRec);

		/* uncomment these 6 lines to check document restoration from this point in process
		// test bailout at this point, when editing a typo marker produced automatic filtering
		errStr = _T("Testing only. ");
		errStr += _T("Vertical edit process abandoned. "); 
		errStr += _T("Will try now to restore the document to its pre-edit state.");
		AfxMessageBox(errStr,MB_ICONEXCLAMATION);
		BailOutFromEditProcess(pSrcPhrases,pRec);
		goto z;
		*/
		// BEW added next block 16Jun05
		// handle any filtering needed because one or more markers were edited to be markers
		// which should be filtered out...
		// if any filtering is needed, we check for it and if so, get it done by the
		// RetokenizeText() call below
		if (bMarkerSetsAreDifferent)
		{
			// There is at least one place (could be more if changed endmarker(s) are involved) where
			// the document's screen appearance would probably now be incorrect - because the user
			// has edited one or more SF markers. The following comment from the code for the document
			// class's RetokenizeText() function explains... "Typically, ..., there will be errors
			// remaining in the document - these are old pSrcPhrase->m_inform strings which are now out
			// of date, TextType values which are set or changed at the wrong places and now
			// inappropriately propagated in the light of the edited SFM change(s) now in effect, and
			// likewise m_bSpecialText will in many places be wrong, or changed when it shouldn't be,
			// shouldn't be. To fix all this stuff we will scan across the whole document with the
			// DoMarkerHousekeeping() function, which duplicates some of TokenizeText()'s code, to get
			// the TextType, m_bSpecialText, and m_inform members of pSrcPhrase correct at each location
			// (doing it over the whole doc is, of course, overkill, but it will catch anything wrong
			// from other operations and fix them too, so worth doing & it is quick/unnoticed)
			int activeSequNum = gpApp->m_nActiveSequNum;
			if (gpApp->m_nActiveSequNum < 0)
			{
				// must not have data yet, or we are at EOF and so no pile is currently active
				activeSequNum = -1;
			}
			else
			{
				// we are somewhere in the midst of the data, so a pile will be active
				activeSequNum = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;
				gpApp->m_curIndex = activeSequNum;

				// remove any current selection, as we can't be sure of any pointers
				// depending on what user may choose to alter
				RemoveSelection();
			}
			TextType aDontCare_PropagationType = verse; // we won't use the returned value
			bool bDontCare_PropagationNeeded = FALSE; // we won't use the returned value
			int docSrcPhraseCount = pSrcPhrases->GetCount(); // current doc size
			GetDocument()->DoMarkerHousekeeping(pSrcPhrases,docSrcPhraseCount,
									aDontCare_PropagationType, bDontCare_PropagationNeeded);

			
			gpApp->m_targetPhrase.Empty(); // when editing src text, the box will be at the start of the new material
									// hopefully, so we don't expect any adaptation to be known

			// recalculate the layout from the first strip in the selection, to force the text to change
			// color  (do we really need these next four lines of code here???)
			pBundle = gpApp->m_pBundle;
			RecalcLayout(pSrcPhrases,0,pBundle); // can fail if the recalculated bundle has fewer strips
												 // than nStartingStripIndex, so use 0 to be always safe	
			// get a new valid active pile pointer
			gpApp->m_pActivePile = GetPile(activeSequNum);
			gpApp->m_curIndex = activeSequNum;
			pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
			wxASSERT(pSrcPhrase != NULL);
		}

		// prepare for next step, eg, combobox etc
	
		// post the custom event for adaptations step of the vertical edit, or for the
		// glossing step, depending on the user's preference (I want return immediately, so 
		// I don't use SendMessage())
		if (gbAdaptBeforeGloss)
		{
			// whm note: MFC docs say of PostMessage, "Places a message in the window's message 
			// queue and then returns without waiting for the corresponding window to process 
			// the message." For SendMessage, they say, "Sends a message to the window and does 
			// not return until the window procedure has processed the message."
			// MFC code:
			//this->PostMessage(CUSTOM_EVENT_ADAPTATIONS_EDIT,0,0);
			
			// wx example code for sending custom event:
			// user code sending the event
			//void MyWindow::SendEvent()
			//{
			//    wxCommandEvent event( wxEVT_MY_EVENT, GetId() );
			//    event.SetEventObject( this );
			//    // Give it some contents
			//    event.SetText( wxT("Hallo") );
			//    // Send it
			//    GetEventHandler()->ProcessEvent( event );
			//}
			// wx code:
			wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
			wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame

		}
		else
		{
			// MFC code:
			//this->PostMessage(CUSTOM_EVENT_GLOSSES_EDIT,0,0);
			// wx code:
			wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
			wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
		}
		/* un-comment out when an interim version with no additional steps is wanted, and comment out PostMessage call
		InitializeEditRecord(*pRec); // clears gbVerticalEditInProgress as well
		gEntryPoint = noEntryPoint;
		gEditStep = noEditStep;
		gbEditingSourceAndDocNotYetChanged = TRUE;
		*/
	}
	else
	{
		bUserCancelled = TRUE;
	}

	// determine the text to be shown, if any, in the target box when it is recreated
z:	;
	wxString str3;
	if (!bActiveLocationWithinEditableSpan && pRec->nSaveActiveSequNum == gpApp->m_nActiveSequNum)
	{
		str3 = pRec->oldPhraseBoxText;
	}
	else
	{
		gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
		pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
		RestoreTargetBoxText(pSrcPhrase,str3); // for m_targetStr contents, get it from the active 
											   // loc's pSrcPhrase doing a Lookup etc.
	}
	// at this point, the sourcephrase's m_bHasKBEntry flag will be the default (FALSE) value, 
	// so we do not need to do any KB adjustments (such as calling GetRefString and then 
	// RemoveRefString); so we just go ahead and set up the phrasebox according to what was 
	// restored by the RestoreTargetBoxText call
	gpApp->m_targetPhrase = str3; // in our 4-line version, the Phrase Box can have punctuation as well
						   // as text
	gpApp->m_pTargetBox->SetValue(str3);
	//m_targetBox.SetSel(0,-1,TRUE); // no scroll
	gnStart = 0;
	gnEnd = -1;

	// layout again, so that the targetBox won't encroach on the next cell's adaption text 
	// (can't just layout the strip, because if the text is long then source phrases get pushed
	// off into limbo and we get access violation & null pointer returned in the GetPile call)
	//RecalcLayout(pSrcPhrases,nStartingStripIndex,pBundle); // can fail if the recalculated bundle 
						// has fewer strips than nStartingStripIndex, so use 0 to be always safe
	RecalcLayout(pSrcPhrases,0,pBundle);

	// get a new valid active pile pointer
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);

	// create the phraseBox at the active pile
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;
	RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
	gpApp->m_pTargetBox->SetFocus();
	gpApp->m_pTargetBox->SetSelection(-1,-1); //(0,-1,TRUE); // no scroll

	// remove selection and update the display
	RemoveSelection();
	Invalidate();

	// ensure respect for boundaries is turned back on
	if (!gpApp->m_bRespectBoundaries)
	{
		wxCommandEvent ev;
		OnButtonFromIgnoringBdryToRespectingBdry(ev);
	}
	gbInsertingWithinFootnote = FALSE; // restore default (it can be set in IsConstantType( ) )

	// if near the start or end of a bundle, detect this and retreat or advance the bundle
	// so that the edited material is all visible; use the cancel span's indices, so that
	// enough context will be present for later vertical edit operations without needing
	// another bundle change
	if (pRec->nCancelSpan_EndingSequNum > gpApp->m_upperIndex)
	{
		// do a bundle advance
		gpApp->m_pActivePile = AdvanceBundle(gpApp->m_nActiveSequNum);
		wxASSERT(gpApp->m_pActivePile != NULL);
		goto up;
	}
	else if (pRec->nCancelSpan_StartingSequNum < gpApp->m_lowerIndex)
	{
		// do a bundle retreat
		gpApp->m_pActivePile = RetreatBundle(gpApp->m_nActiveSequNum);
		wxASSERT(gpApp->m_pActivePile != NULL);
up:		gpApp->m_curIndex = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;
		gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);

		// recreate the phraseBox again (required, since we may have just done a
		// PlacePhraseBox() call, so the calculated position will now have been
		// invalidated by the advance of the bundle.)
		RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
		Invalidate();
	}
	// delay cancel cleanup to here, as the restoration of the view needed to use the pRec
	// values which are to be initialized here
	if (bUserCancelled)
	{
		// user cancelled, so restore initial state...
		// The document is not modified until after the dialog is dismissed, so a Cancel 
		// button press only requires that that the edit record will have its stored
		// information cleared
		InitializeEditRecord(*pRec); // clears gbVerticalEditInProgress as well
		gEntryPoint = noEntryPoint;
		gEditStep = noEditStep;
		gbEditingSourceAndDocNotYetChanged = TRUE;
	}

	//BOOL bFTPRES = pRec->bEditSpanHasFreeTranslations; // for debugging, to do a QuickWatch on pRec when done
}

/*******************************************************************************************************
*
*	RestoreMode
*
*	Returns: nothing
*
*	Parameters:
*	bSeeGlossesEnabled	->	TRUE of glosses are visible currently in the main window (caller passes in
*							the global BOOL gbEnableGlossing flag), FALSE if not
*	bIsGlossing			->	TRUE if glossing mode is currently ON, FALSE if adapting mode is currently ON
*							(caller passes in the global BOOL gbIsGlossing flag)
*	pRec				->	pointer to the EditRecord struct which, among other things, stores the value of
*							the passed in global BOOLs at the time when the vertical edit process was entered
*	Comments:
*	Used to restore the mode to whatever it was when the vertical edit process was initiated, including
*	making glosses visible or hidden if the original mode was adaptations mode and they were visible or
*	hidden, respectively. There are handlers for menu commands for these mode changes, so we just need to
*	provide a set of tests to determine how, if at all, the original state differs from the current state
*	and make the appropriate handler calls to get the state back to what it should be.
*	
*	History: created BEW 1Aug08 for support of vertical editing in the refactored Edit Source Text handler
*
********************************************************************************************************/
void CAdapt_ItView::RestoreMode(bool WXUNUSED(bSeeGlossesEnabled), bool WXUNUSED(bIsGlossing), EditRecord* pRec)
{
	// Protocol: start from the 3 possible current states (1. glossing, 2. adapting & seeing glosses, 3. adapting 
	// & hidden glosses), and for each of these three starting points, use pRec to determine what the original 
	// state was, and then set up the calls needed to restore to any particular starting state (again, the same
	// 3 possibilities obtain)
	if (gbIsGlossing)
	{
		// glossing mode is currently ON, so gbEnableGlosses must be TRUE as well
		if (pRec->bGlossingModeOnEntry)
		{
			// glossing mode was ON at entry also, so pRec->bSeeGlossesEnabledOnEntry must be TRUE as well
			// so the current flag values are correct - hence nothing to do
			;
		}
		else
		{
			// adapting mode was ON at entry, but gbEnableGlossing could have been ON (ie. glosses visible) or OFF
			//  (ie. glosses hidden) on entry, so find out which was the case
			if (pRec->bSeeGlossesEnabledOnEntry)
			{
				// the "See Glosses" menu item was ticked when the vertical edit was entered, glosses were visible
				// in adapting mode
				//OnCheckIsGlossing(); // toggles checkbox off and clears gbIsGlossing to FALSE
				ToggleGlossingMode();
			}
			else
			{
				// the "See Glosses" menu item was unticked on entry, glosses were hidden, we had a standard 2-line 
				// strip on entry
				ToggleSeeGlossesMode();
				//OnAdvancedEnableglossing(); // clears both gbEnableGlossing and gbIsGlossing to FALSE and removes checkbox
			}
		} // end of tests for original state
	}
	else
	{
		// adapting mode is currently ON, but gbEnableGlosses could be ON (ie. glosses visible) or OFF (ie. glosses
		// hidden
		if (gbEnableGlossing)
		{
			// the "See Glosses" menu item is ticked, glosses are visible in adapting mode
			if (pRec->bGlossingModeOnEntry)
			{
				// glossing mode was ON at entry, so pRec->bSeeGlossesEnabledOnEntry must be TRUE as well
				//OnCheckIsGlossing(); // toggles checkbox to ON and sets gbIsGlossing to TRUE
				ToggleGlossingMode();
			}
			else
			{
				// adapting mode was ON at entry, but gbEnableGlossing could have been ON (ie. glosses visible) 
				// or OFF (ie. glosses hidden) on entry, so find out which was the case
				if (pRec->bSeeGlossesEnabledOnEntry)
				{
					// the "See Glosses" menu item was ticked when the vertical edit was entered, glosses were
					// visible in adapting mode so the current flag values are correct - hence nothing to do
					;
				}
				else
				{
					// the "See Glosses" menu item was unticked on entry, glosses were hidden, we had a standard
					// 2-line strip on entry
					ToggleSeeGlossesMode();
					//OnAdvancedEnableglossing(); // clears both gbEnableGlossing and gbIsGlossing to FALSE and removes checkbox
				}
			} // end of tests for original state
		}
		else
		{
			// the "See Glosses" menu item is unticked, glosses are hidden, we have a standard 2-line strip currenty
			if (pRec->bGlossingModeOnEntry)
			{
				// glossing mode was ON at entry, so pRec->bSeeGlossesEnabledOnEntry must be TRUE as well
				ToggleSeeGlossesMode();
				//OnAdvancedEnableglossing(); // sets gbEnableGlossing to TRUE, leaves gbIsGlossing as FALSE and unhides checkbox
				//OnCheckIsGlossing(); // toggles checkbox to ON and sets gbIsGlossing to TRUE
				ToggleGlossingMode();

			}
			else
			{
				// adapting mode was ON at entry, but gbEnableGlossing could have been ON (ie. glosses visible) or OFF
				// (ie. glosses hidden) on entry, so find out which was the case
				if (pRec->bSeeGlossesEnabledOnEntry)
				{
					// the "See Glosses" menu item was ticked when the vertical edit was entered, glosses were visible
					// in adapting mode
					ToggleSeeGlossesMode();
					//OnAdvancedEnableglossing(); // sets gbEnableGlossing to TRUE, leaves gbIsGlossing as FALSE and unhides checkbox
				}
				else
				{
					// the "See Glosses" menu item was unticked on entry, glosses were hidden, we had a standard
					// 2-line strip on entry so the current flag values are correct - hence nothing to do
					;
				}
			} // end of tests for original state
		}
	}
}

// return a pointer to a specific vertical edit bar of the frame window, or NULL if
// there is an error when trying to get the pointer
wxPanel* CAdapt_ItView::GetBar(enum VertEditBarType vertEditBarType)
{
	// whm modified to use enum VertEditBarType defined in Adapt_It.h
	wxPanel* pBar = (wxPanel*)NULL;
	// In the wx version all the vertical edit bars reside as members of CMainFrame
	// and they all are created at the startup of the application, but are hidden
	// until needed by the vertical editing process.
	CMainFrame *pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);

	switch (vertEditBarType)
	{
	case Vert_Edit_RemovalsBar:
		pBar = pFrame->m_pRemovalsBar;
		break;
	case Vert_Edit_Bar:
		pBar = pFrame->m_pVertEditBar;
		break;
	//case Vert_Edit_Step_Trans_Bar:
	//	pBar = pFrame->m_pVertEditStepTransBar;
	//	break;
	default:
		pBar = (wxPanel*)NULL;
	}
	return pBar;
}

// return a pointer to the CComboBox in the m_wndRemovalsBar of the frame window, or NULL if
// there is an error when trying to get the pointer
wxComboBox* CAdapt_ItView::GetRemovalsComboBox()
{
	wxComboBox* pCombo = NULL;
	wxPanel* pBar = GetBar(Vert_Edit_RemovalsBar);
	if (pBar == NULL)
		return NULL;
	pCombo = (wxComboBox*)pBar->FindWindowById(IDC_COMBO_REMOVALS);
	wxASSERT(pCombo != NULL);
	if (pCombo == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the ComboBox control in GetRemovalsComboBox()"), 
			_T(""), wxICON_EXCLAMATION);
	}
	return pCombo;
}

// Get a pointer to the CComboBox control in the m_wndRemovalsBar CDialogBar member of the
// frame window (see MainFrm.cpp and .h), and then check which step is passed in, and populate
// the combo box with the removed data strings in gEditRecord's appropriate CStringList; there
// may be no entries to put in the list, in which case a single entry which is space is retained
// so that the comboxbox stays visible, and this is not an error. Return TRUE when there was no
// error, and FALSE if there was an error leading to the list not being populated.
// Note, this function can be called when vertical editing is not currently on, to repopulate
// the combobox list with whatever desired data we want, whether adaptations, glosses, or free
// translations - by passing in the appropriate enum value, rather than the current value in the
// global gEditStep
bool CAdapt_ItView::PopulateRemovalsComboBox(enum EditStep step, EditRecord* pRec)
{
	wxComboBox* pCombo = GetRemovalsComboBox();
	if (pCombo == NULL)
		return FALSE; // could not get the required pointer (an error warning will have been seen already)
	wxASSERT(pRec);
	wxArrayString* pStrList = NULL;

	//int elementCount = -1; // unused
	wxString aString;
	//int aLength = -1; // unused
	//int aValue; // unused
	int index;
	//int nHowMany = 0; // unused
	bool bIsEmpty = FALSE;
	//POSITION pos = NULL;

	// determine which list we are dealing with for this vertical editing step...
	// Note: this function can be called when no vertical editing is in progress, in
	// which case the caller does not pass in gEditStep's current value (which would be
	// noEditStep) but rather the particular enum value which results in the population
	// being done with the appropriate data (whether adaptations, glosses, of free
	// translations)
	switch (step)
	{
		case glossesStep:
		{
			pStrList = &pRec->deletedGlossesList;
			break;
		}
		case freeTranslationsStep:
		{
			pStrList = &pRec->deletedFreeTranslationsList;
			break;
		}
		default:
		case adaptationsStep:
		{
			pStrList = &pRec->deletedAdaptationsList;
			break;
		}
	}

	// populate the combo's list, etc...

	// don't do anything if pRec's CStringList has no entries in it, except
	// remove whatever is already in the combo's list -- because anything already
	// in it is quite likely data from a different step, and so inappropriate now
	bIsEmpty = pStrList->IsEmpty();
	if (bIsEmpty)
	{
		// no populating to be done, but this is no error; but make sure there is
		// a space there at least, to keep the combobox visible
		pCombo->Clear(); // remove old content, it could be glosses or free translations
		index = pCombo->Append(_T(" "));
		return TRUE;
	}
	// the pRec list has content to be put in the combo box... first remove old content
	pCombo->Clear(); //pCombo->ResetContent();
	// and now loop over the stored list, adding its strings to the combo's list
	//pos = pStrList->GetHeadPosition();
	//if (pos == NULL)
	//{
	//	// should not happen, so return FALSE
	//	index = pCombo->AddString(_T(" ")); // ensure combobox remains visible (but apparently empty)
	//	return FALSE;
	//}
	// the pRec lists are maintained eternally with a maximum of 100 entries, so we can safely
	// loop over all there are (#define DELETIONS_LIST_MAX_ENTRIES 100 at top of Adapt_ItView.cpp)
	int ct;
	for (ct = 0; ct < (int)pStrList->GetCount(); ct++) //while (pos != NULL)
	{
		aString = pStrList->Item(ct); //aString = pStrList->GetNext(pos);
		// we don't bother having empty strings in the list, the user can make those himself easily
		if (!aString.IsEmpty())
		{
			index = pCombo->Append(aString); //index = pCombo->AddString(aString);
		}
	}

	// set up the list's visual dimensions and the combo width, visually it must fit within
	// the frame window's vertical extent of the client rectangle
	//SizeTheRemovalsComboBoxList();
	// whm Note: wxComboBox derives from wxControlWithItems which has a SetSelection() method with a
	// single parameter - this method sets the item in the list. The wxComboBox class itself has
	// another methos called SetSelection() which takes two parameters - this method is used to set
	// the selection highlight of the line showing in the text field of the combo box!
	// 
	pCombo->SetSelection(0); //int nItemShown = pCombo->SetCurSel(0); // show the first in the list in top position
	pCombo->SetSelection(0,0); //aValue = pCombo->SetEditSel(-1,0); // show that top item unselected
	return TRUE;
}

// SizeTheRemovalsComboBoxList() is a utility which sizes the Removed: combobox's list to conform
// to more data added and any resizing of the frame window's width or height; similar code is in the
// MainFrm.cpp OnSize() handler. SizeTheRemovalsComboBoxList() is also called from within 
// PopulateRemovalsComboBox() to do the necessary sizing
// whm Note: The removals combo box in the wx version is under the control of a sizer which is set 
// to expand the combo box to fill the available length of the removalsBar.
//void CAdapt_ItView::SizeTheRemovalsComboBoxList()
//{
//	CFrameWnd* pFWnd = GetParentFrame();
//	wxComboBox* pCombo = GetRemovalsComboBox();
//	wxRect clientRect;
//	pFWnd->GetClientRect(&clientRect);
//	int clientHeight = clientRect.bottom - clientRect.top;
//	int clientWidth = clientRect.right - clientRect.left;
//	int labelSpacePlusSlop = 40 + 25; // pixels, combo begins 40 pixels from bar's left, allow 25 to
//									   // prevent encroachment on the right side of the frame rectangle
//	int count = pCombo->GetCount();
//	CRect r2;
//	pCombo->GetDroppedControlRect(&r2);
//	int width = r2.right - r2.left;
//	int height = pCombo->GetItemHeight(-1) + 3; // get combo box height & add 3
//	UINT nFlags = SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOMOVE;
//	int nShowThisMany = clientHeight / height; // max we can show
//	nShowThisMany = min (nShowThisMany, count + 1);
//	if (nShowThisMany == 0)
//		nShowThisMany = 1;
//	int nNewWidth = clientWidth - labelSpacePlusSlop;
//	BOOL b = pCombo->SetWindowPos(&CWnd::wndTop,0,0,nNewWidth,height * nShowThisMany,nFlags);
//}

void CAdapt_ItView::SetVerticalEditModeMessage(wxString messageText)
{
	wxPanel* pBar;
	pBar = GetBar(Vert_Edit_Bar);
	wxASSERT(pBar != NULL);
	//if (pBar == NULL)
	//{
	//	AfxMessageBox(_T("Failure to obtain pointer to the vertical edit bar in SetVerticalEditModeMessage()"),
	//		MB_ICONEXCLAMATION);
	//	return;
	//}
	wxTextCtrl* pMsgBox = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_MSG_TEXT);
	wxASSERT(pMsgBox != NULL);
	//if (pMsgBox == NULL)
	//{
	//	AfxMessageBox(_T("Failure to obtain pointer to the message box in the vertical edit\
	//					 bar in SetVerticalEditModeMessage()"),MB_ICONEXCLAMATION);
	//	return;
	//}
	pMsgBox->SetValue(messageText);
}

// use the following when placing the phrase box in vertical editing moode's steps
//void CAdapt_ItView::PutPhraseBoxAtSequNumAndLayout(EditRecord* pRec, int nSequNum, int selector)
void CAdapt_ItView::PutPhraseBoxAtSequNumAndLayout(EditRecord* WXUNUSED(pRec), int nSequNum)
{
	// first make sure any pile's CSourcePhrase instance's source text or translation or gloss is
	// not carried forward or back to a different step
	translation.Empty();
	gpApp->m_targetPhrase.Empty();

	// now set up the phrase box
	gpApp->m_nActiveSequNum = nSequNum; // needed, as a test for m_nActiveSequNum < 0 done internally
								 // will have box placement skipped if we get here and it is -1
	gpApp->m_pActivePile = GetPile(nSequNum);
	if (gbIsGlossing)
		translation = gpApp->m_pActivePile->m_pSrcPhrase->m_gloss;
	else
		translation = gpApp->m_pActivePile->m_pSrcPhrase->m_adaption;
	if (translation.IsEmpty())
	{
		bool bFoundSomething;
		bFoundSomething = gpApp->m_pTargetBox->LookUpSrcWord(this, gpApp->m_pActivePile);
	}
	gpApp->m_targetPhrase = translation; // global CString  translation is set by whatever is adaptation
		// or gloss if user switched modes, and if there is no such string yet, then do LookUpSrcWord()
								  // and if there is an entry in the KB, use that, else leave empty
	RedrawEverything(nSequNum);
}

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the end of the vertical edit step has been reached, so that an event for 
///             transitioning to the next vertical edit step has been posted (in other words, a 
///             PostMessage() has been done); FALSE if the step end has not yet been reached
/// \param      nSequNum          -> the sequence number for the landing location that the 
///                                  phrase box would want to stop at
/// \param      select            -> no matter where it is invoked from it will be one of the enum 
///                                  values nextStep, previousStep, endNow, or cancelAllSteps
/// \param      bForceTransition  -> default is FALSE; when FALSE the normal tests for landing the 
///                                  box in the gray area are done, to see if transition to the 
///                                  next step is required; when TRUE, the transition is done 
///                                  unilaterally
/// \remarks
/// Called from: the View's OnButtonRetranslation(), OnButtonEditRetranslation(), OnAdvanceButton(),
/// OnNextButton(), OnButtonNextStep(), OnButtonPrevStep(), CPhraseBox::JumpForward(), 
/// CPhraseBox::MoveToNextPile().
/// While vertical editing is in progress, this function checks for a landing location (using the 
/// passed in nSequNum value) to see if it lies beyond the end bound for the editable span for the 
/// current step; it so, then the appropriate custom event is posted to cause transition to the next 
/// step.
/// As the user advances through the edit span, doing updates in either adaptationsStep, glossesStep
/// or freeTranslationsStep, control will eventually get to the end of the span and the action for
/// advancing to the next CSourcePhrase appropriate for that step will take the phrase box into the
/// gray text area. When that happens, we want to suppress landing the phrase box in that context,
/// and instead transition vertical edit mode to whatever editing step is logically next. This function
/// therefore checks for a landing location (using the passed in nSequNum value) to see if it lies
/// beyond the end bound for the editable span for the current step; it so, then the appropriate
/// custom event is posted to cause transition to the next step.
/// In some circumstandes it may be necessary or expedient to force the transition, so that can
/// be done by passing in TRUE for the final parameter. Typical scenarios for that would be 1. that
/// the end of the document was reached without finding a landing location; or 2. the function is
/// invoked from the Vertical Edit control bar buttons - which force transition without checking
/// if the active location is beyond the edit span or not; 3. bundle end has been reached in the
/// search for a "hole" to jump to, in which case this really means we've moved into the gray
/// area, so TRUE would be appropriate.
////////////////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::VerticalEdit_CheckForEndRequiringTransition(int nSequNum, ActionSelector select,
												bool bForceTransition)
{
	EditRecord* pRec = &gEditRecord;
	if (bForceTransition)
	{
		switch (gEditStep)
		{
		case adaptationsStep:
			{
				switch (select)
				{
				case nextStep:
					if (gbAdaptBeforeGloss)
					{
						//this->PostMessage(CUSTOM_EVENT_GLOSSES_EDIT,0,0);
						wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
						wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					}
					else
					{
						//this->PostMessage(CUSTOM_EVENT_FREE_TRANSLATIONS_EDIT,0,0);
						wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
						wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					}
					return TRUE;
				case previousStep:
					if (gbAdaptBeforeGloss)
						::wxBell(); // cannot roll back to the edit source text dialog, cancel is better
					else
					{
						//this->PostMessage(CUSTOM_EVENT_GLOSSES_EDIT,0,0); // rollback to glossesStep
						wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
						wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					}
					return TRUE;
				case endNow:
					{
					//this->PostMessage(CUSTOM_EVENT_END_VERTICAL_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					return TRUE;
					}
				case cancelAllSteps:
					//this->PostMessage(CUSTOM_EVENT_CANCEL_VERTICAL_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					return TRUE;
				}
				break;
			}
		case glossesStep:
			{
				switch (select)
				{
				case nextStep:
					if (gbAdaptBeforeGloss)
					{
						//this->PostMessage(CUSTOM_EVENT_FREE_TRANSLATIONS_EDIT,0,0);
						wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
						wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					}
					else
					{
						//this->PostMessage(CUSTOM_EVENT_ADAPTATIONS_EDIT,0,0);
						wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
						wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					}
					return TRUE;
				case previousStep:
					if (gbAdaptBeforeGloss)
					{
						//this->PostMessage(CUSTOM_EVENT_ADAPTATIONS_EDIT,0,0); // rollback to adaptationsStep
						wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
						wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					}
					else
						::wxBell(); // cannot roll back to the edit source text dialog, cancel is better
					return TRUE;
				case endNow:
					{
					//this->PostMessage(CUSTOM_EVENT_END_VERTICAL_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					return TRUE;
					}
				case cancelAllSteps:
					{
					//this->PostMessage(CUSTOM_EVENT_CANCEL_VERTICAL_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					return TRUE;
					}
				}
				break;
			}
		case freeTranslationsStep:
			{
				switch (select)
				{
				case nextStep:
					{
					StoreFreeTranslationOnLeaving();
					//this->PostMessage(CUSTOM_EVENT_BACK_TRANSLATIONS_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_Back_Translations_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					return TRUE;
					}
				case previousStep:
					if (gbAdaptBeforeGloss)
					{
						//this->PostMessage(CUSTOM_EVENT_GLOSSES_EDIT,0,0); // rollback to glossesStep
						wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
						wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					}
					else
					{
						//this->PostMessage(CUSTOM_EVENT_ADAPTATIONS_EDIT,0,0); // rollback to adaptationsStep
						wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
						wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					}
					return TRUE;
				case endNow:
					{
					StoreFreeTranslationOnLeaving();
					//this->PostMessage(CUSTOM_EVENT_END_VERTICAL_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					return TRUE;
					}
				case cancelAllSteps:
					{
					//this->PostMessage(CUSTOM_EVENT_CANCEL_VERTICAL_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
					return TRUE;
					}
				}
				break;
			}
		default:
			{
			// control should never come here, but if it does, make vertical edit mode end immediately
			//this->PostMessage(CUSTOM_EVENT_END_VERTICAL_EDIT,0,0);
			wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
			wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
			}
		}
		return TRUE;
	} // end block for test (bForceTransition == TRUE)

	// for the unforced case, make the tests for the landing location being in the gray area;
	// pleaseIgnore is not a valid option if control gets this far
	switch (gEditStep)
	{
	case adaptationsStep:
		if (nSequNum > pRec->nAdaptationStep_EndingSequNum)
		{
			switch (select)
			{
			case nextStep:
				if (gbAdaptBeforeGloss)
				{
					//this->PostMessage(CUSTOM_EVENT_GLOSSES_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				}
				else
				{
					//this->PostMessage(CUSTOM_EVENT_FREE_TRANSLATIONS_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				}
				return TRUE;
			case previousStep:
				if (gbAdaptBeforeGloss)
					::wxBell(); // cannot roll back to the edit source text dialog, cancel is better
				else
				{
					//this->PostMessage(CUSTOM_EVENT_GLOSSES_EDIT,0,0); // rollback to glossesStep
					wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				}
				return TRUE;
			case endNow:
				{
				//this->PostMessage(CUSTOM_EVENT_END_VERTICAL_EDIT,0,0);
				wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
				wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				return TRUE;
				}
			case cancelAllSteps:
				{
				//this->PostMessage(CUSTOM_EVENT_CANCEL_VERTICAL_EDIT,0,0);
				wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
				wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				return TRUE;
				}
			}
		}
		break;
	case glossesStep:
		if (nSequNum > pRec->nGlossStep_EndingSequNum)
		{
			switch (select)
			{
			case nextStep:
				if (gbAdaptBeforeGloss)
				{
					//this->PostMessage(CUSTOM_EVENT_FREE_TRANSLATIONS_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				}
				else
				{
					//this->PostMessage(CUSTOM_EVENT_ADAPTATIONS_EDIT,0,0);
					wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				}
				return TRUE;
			case previousStep:
				if (gbAdaptBeforeGloss)
				{
					//this->PostMessage(CUSTOM_EVENT_ADAPTATIONS_EDIT,0,0); // rollback to adaptationsStep
					wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				}
				else
					::wxBell(); // cannot roll back to the edit source text dialog, cancel is better
				return TRUE;
			case endNow:
				{
				//this->PostMessage(CUSTOM_EVENT_END_VERTICAL_EDIT,0,0);
				wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
				wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				return TRUE;
				}
			case cancelAllSteps:
				{
				//this->PostMessage(CUSTOM_EVENT_CANCEL_VERTICAL_EDIT,0,0);
				wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
				wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				return TRUE;
				}
			}
		}
		break;
	case freeTranslationsStep:
		if (nSequNum > pRec->nFreeTranslationStep_EndingSequNum)
		{
			switch (select)
			{
			case nextStep:
				{
				StoreFreeTranslationOnLeaving(); // may result in re-storing an already stored f.t. but its safety first
				//this->PostMessage(CUSTOM_EVENT_BACK_TRANSLATIONS_EDIT,0,0);
				wxCommandEvent eventCustom(wxEVT_Back_Translations_Edit);
				wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				return TRUE;
				}
			case previousStep:
				if (gbAdaptBeforeGloss)
				{
					//this->PostMessage(CUSTOM_EVENT_GLOSSES_EDIT,0,0); // rollback to glossesStep
					wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				}
				else
				{
					//this->PostMessage(CUSTOM_EVENT_ADAPTATIONS_EDIT,0,0); // rollback to adaptationsStep
					wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
					wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				}
				return TRUE;
			case endNow:
				{
				StoreFreeTranslationOnLeaving();  // may result in re-storing an already stored f.t. but its safety first
				//this->PostMessage(CUSTOM_EVENT_END_VERTICAL_EDIT,0,0);
				wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
				wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				return TRUE;
				}
			case cancelAllSteps:
				{
				//this->PostMessage(CUSTOM_EVENT_CANCEL_VERTICAL_EDIT,0,0);
				wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
				wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
				return TRUE;
				}
			}
		}
		break;
	default:
		{
		// control should never come here, but if it does, make vertical edit mode end immediately
		//this->PostMessage(CUSTOM_EVENT_END_VERTICAL_EDIT,0,0);
		wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
		wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
		}
	}
	return FALSE; // no PostMessage() has been done, so caller can just continue processing

	// we don't need a case for backTranslationsStep, because that is always the last step and
	// if it is entered, it unilaterally ends the vertical edit process when it finishes and
	// the user is never given a chance to do otherwise
}

/*
void CAdapt_ItView::InsertSourcePhrases(CPile* pInsertLocPile,const int nCount,TextType myTextType)
// use this function to create new source phrases on the heap and insert them preceding the
// source phrase instance stored on the pile pInsertLocPile (this function is used when editing
// source phrase text)
{
	CPile* pPile		= pInsertLocPile;
	int nStartingSequNum	= pPile->m_pSrcPhrase->m_nSequNumber;
	SPList* pList		= gpApp->m_pSourcePhrases;
	SPList::Node* insertPos = pList->Item(nStartingSequNum); //POSITION insertPos = pList->FindIndex(nStartingSequNum); // the position before
															 // which we will make the insertion
	wxASSERT(nStartingSequNum >= 0 && nStartingSequNum <= gpApp->m_maxIndex); // check its in legal range
	wxASSERT(insertPos != NULL);

	// create the needed source phrases and insert them in the list; preserve pointers to the
	// first and last for use below
	CSourcePhrase* pFirstOne;
	CSourcePhrase* pLastOne;
	for (int i = 0; i<nCount; i++)
	{
		CSourcePhrase* pSrcPhrase = new CSourcePhrase;
		if (i == 0)
			pFirstOne = pSrcPhrase;
		if (i == nCount-1)
			pLastOne = pSrcPhrase;
		pSrcPhrase->m_nSequNumber = nStartingSequNum + i; // ensures the UpdateSequNumbers()
														  // call works
		pSrcPhrase->m_curTextType = myTextType;
		// wx Note: Insert inserts before the given position
		pList->Insert(insertPos,pSrcPhrase); //pList->InsertBefore(insertPos,pSrcPhrase);
	}

	// fix up the bundle's indices, and the sequ num for the old insert location's source phrase
	gpApp->m_maxIndex += nCount;
	gpApp->m_endIndex += nCount;
	gpApp->m_upperIndex += nCount;

	// update the sequence numbers, starting from the first one inserted
	UpdateSequNumbers(nStartingSequNum);
}
*/
/*
void CAdapt_ItView::PadOrShortenAtEnd(SPList* pSrcPhrases,
						  int nStartSequNum,int nEndSequNum,int nNewCount,int nCount,
						  TextType myTextType,bool& bDelayRemovals)
// The padding is done in the main list of source phrases, on the app. pSrcPhrases is the
// pointer to this list; nEndSequNumber is the sequence number of the last CSourcePhrase instance
// of the selected source text (and the padding is required when there are more words in the
// target text than the source piles can accomodate). nNewCount is the number of target text
// words - it could be less, more, or the same as the number piles selected (we test internally
// and act accordingly), and nCount is the number of CSourcePhrase instances after all nulls
// removed, and mergers unmerged. We have to be careful if nEndSequNumber is equal to gpApp->m_maxIndex,
// because insertion of null source phrases has to take place before a sourcephrase instance which
// would not exist, so we must detect this and temporarily add an extra CSourcePhrase instance at
// the end of the main list, do the insertions preceding it, then remove it.
{
	if (nNewCount > nCount)
	{
		// source phrases are needed for padding
		int nExtras = nNewCount - nCount;
		bDelayRemovals = FALSE;

		// check we are not at the end of the list of CSourcePhrase instances, if we are we will
		// have to add an extra one so that we can insert before it, then remove it later.
		if (nEndSequNum == gpApp->m_maxIndex)
		{
			// we are at the end, so we must add a dummy sourcephrase; note, m_nActiveSequNum and
			// the caller's nSaveActiveSequNum values will almost certainly be greater than
			// gpApp->m_maxIndex, and so we must not use these until we adjust them in the caller later
			// on. So we can ignore the active location, and just temporarily treat it as the last
			// pile in the document.
			CSourcePhrase* pDummySrcPhrase = new CSourcePhrase;
			pDummySrcPhrase->m_srcPhrase = _T("dummy"); // something needed, so a pile width can
														// be computed
			pDummySrcPhrase->m_key = pDummySrcPhrase->m_srcPhrase;
			gpApp->m_maxIndex += 1;
			gpApp->m_endIndex = gpApp->m_maxIndex;
			pDummySrcPhrase->m_nSequNumber = gpApp->m_maxIndex;

			// we need a valid layout which includes the new dummy element on its own pile
			RecalcLayout(pSrcPhrases,0,gpApp->m_pBundle);
			gpApp->m_pActivePile = GetPile(gpApp->m_maxIndex); // temporary active location

			// now we can do the insertions
			CPile* pPile = GetPile(nEndSequNum + 1);
			wxASSERT(pPile != NULL);
			InsertSourcePhrases(pPile,nExtras,myTextType);

			// now remove the dummy element, and make sure memory is not leaked!
			delete pDummySrcPhrase->m_pSavedWords;
			delete pDummySrcPhrase->m_pMedialMarkers;
			delete pDummySrcPhrase->m_pMedialPuncts;
			// wxList doesn't have RemoveTail equivalent, so we get the last node and delete it
			SPList::Node* lastSPpos = pSrcPhrases->GetLast();
			pSrcPhrases->DeleteNode(lastSPpos);
			delete pDummySrcPhrase;

			// get another valid layout
			gpApp->m_maxIndex = gpApp->m_endIndex -= 1; // we've no longer got the dummy present,
										  // so decrement the indices
			RecalcLayout(pSrcPhrases,0,gpApp->m_pBundle);
			gpApp->m_pActivePile = GetPile(nStartSequNum); // at the start is where we will want it to be
		}
		else
		{
			// not at the end, so we can proceed immediately; get the insertion location's pile
			// pointer
			CPile* pPile = GetPile(nEndSequNum + 1);
			wxASSERT(pPile != NULL);
			InsertSourcePhrases(pPile,nExtras,myTextType);
		}
		return;
	}
	else if (nNewCount < nCount)
	{
		// we have to remove some source phrases
		bDelayRemovals = TRUE; // we can't do it now, because we would lose any standard format
							   // marker information that occurs on those sourcephrases; we first
							   // must transfer such info and then we can delete the sourcephrase
							   // instances we no longer need

		// we have to fix the end and max indices, otherwise we'll later try access a
		// nonexistent srcphrase
		int diff = nCount-nNewCount;
		gpApp->m_maxIndex -= diff;
		gpApp->m_endIndex -= diff;
		return;
	}
	else
		return; // no padding or removal needed
}
*/

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pRec				-> pointer to the global EditRecode struct, gEditRecord
/// \param      pNewSrcPhrasesList	-> a list of pointers to CSourcePhrase instances from parsing the
///								        user's edited source text
/// \param      pSrcPhrases			-> pointer to the document' m_pSourcePhrases list being edited
/// \param      nBeginAtSN			-> sequence number in m_pSourcePhrases list at which transfer begins (inclusive)
/// \param      nFinishAtSN			-> sequence number in m_pSourcePhrases list at which transfer finishes (inclusive)
/// \remarks
/// Called from: 
/// Remove the now unwanted original edited span of CSourcePhrase instances. Insert their replacements,
/// (possibly zero), and tidy up various document parameters so that a recalculation of the layout can
/// be done in the caller on return. An important step, done last, is to call the document function
/// UpdateSequNumbers(0) to get all these numbers into consecutive order. (If the user has deleted the
/// whole editable span, then nBeginAtSN and nFinishAtSN are the same and index the first CSourcePhrase
/// instance of the context following the editable span.)
////////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::TransferCompletedSrcPhrases(EditRecord* pRec, SPList* pNewSrcPhrasesList,
												SPList* pSrcPhrases, int nBeginAtSN, int nFinishAtSN)
{
	// 8May08 BEW added to support refactored Edit Source Text functionality
	wxASSERT(pNewSrcPhrasesList);
	SPList::Node* posMain;
	SPList::Node* posNew; //POSITION posMain, posNew;
	SPList* pMainList = pSrcPhrases;
	wxASSERT(pMainList != NULL);
	int nHowManyToDelete = nFinishAtSN - nBeginAtSN + 1;
	int nHowManyToInsert = pNewSrcPhrasesList->GetCount();
	int nExtras = nHowManyToInsert - nHowManyToDelete; // can be +ve, 0, or -ve

	int nBeginAt = nBeginAtSN; // this is the first one to be deleted and pointer removed from list

	// first delete the old instances from the m_pSourcePhrases list in the document
	SPList::Node* posSaved = NULL;
	int index;
	CSourcePhrase* pSP = NULL;
	posMain = pMainList->Item(nBeginAt); // MFC used FindIndex
	wxASSERT(posMain != 0);
	for (index = 0; index < nHowManyToDelete; index++)
	{
		posSaved = posMain;
		wxASSERT(posSaved);
		pSP = posMain->GetData();
		posMain = posMain->GetNext();
		GetDocument()->DeleteSingleSrcPhrase(pSP);
		pMainList->DeleteNode(posSaved);
		// NOTE: this does **NOT** remove the deep copies which are in the pRec->originalSrcPhraseList
		// because that list must persist until the end of the whole edit process, in case the user
		// wants to Cancel out of the edit -- then that list would be used to restore the original
		// document state.
	}

	// user could have deleted the whole editable span, so allow for this possibility - check here
	if (nHowManyToInsert == 0)
	{
		// update the maximum index value, and any others that are relevant, then return
		gpApp->m_maxIndex += nExtras;
		if (gpApp->m_upperIndex > gpApp->m_maxIndex)
			gpApp->m_upperIndex += nExtras;
		if (gpApp->m_endIndex > gpApp->m_maxIndex)
			gpApp->m_endIndex += nExtras;
		if (pRec->nSaveActiveSequNum >= pRec->nStartingSequNum + nHowManyToInsert)
		{
			if (gpApp->m_nActiveSequNum > gpApp->m_maxIndex)
			{
				gpApp->m_nActiveSequNum += nExtras;
				pRec->nSaveActiveSequNum = gpApp->m_nActiveSequNum;
			}
		}
		GetDocument()->UpdateSequNumbers(0); // update from the beginning of m_pSourcePhrases
		return;
	}

	// if we get here, there is at least one sourcephrase in the new list
	// now insert the new ones - distinguish doing so at the start of the doc versus somewhere within it
	posNew = pNewSrcPhrasesList->GetLast(); // insert in reverse order, to preserve order
	wxASSERT(posNew != 0);
	SPList::Node* posAt = NULL; 
	if (nBeginAt == 0)
	{
		// insert at the document start
		posAt = pMainList->Item(0); // always the start // MFC uses FindIndex
		for (index = 0; index < nHowManyToInsert; index++)
		{
			if (posNew == NULL)
				break;
			pSP = posNew->GetData();
			posNew = posNew->GetPrevious();
			wxASSERT(pSP != NULL);
			posAt = pMainList->Insert(posAt, pSP);
		}
	}
	else
	{
		// insert within the document (nBeginAt - 1 will not be negative)
		posAt = pMainList->Item(nBeginAt - 1); // always the start // MFC uses FindIndex
		wxASSERT(posAt != NULL);
		for (index = 0; index < nHowManyToInsert; index++)
		{
			if (posNew == NULL)
				break;
			pSP = posNew->GetData();
			posNew = posNew->GetPrevious();
			wxASSERT(pSP != NULL);
			//SPList::Node* posMoved = pMainList->InsertAfter(posAt, pSP);
			// wxList has no equivalent to InsertAfter(). The wxList Insert() method
			// inserts the new node BEFORE the current position/node. To emulate what
			// the MFC code does, we insert before using newInsertBeforePos.
			// wx note: If newInsertBeforePos is NULL, it means the insert position is
			// at the end of the list; in this case we just append the item to the end
			// of the list.
			SPList::Node* newInsertBeforePos = posAt->GetNext();
			if (newInsertBeforePos == NULL)
				pMainList->Append(pSP);
			else
				pMainList->Insert(newInsertBeforePos,pSP);

			// TEST
			/*
			POSITION pos1 = pMainList->FindIndex(nBeginAt - 1);
			POSITION pos2 = pMainList->FindIndex(nBeginAt );
			POSITION pos3 = pMainList->FindIndex(nBeginAt+1);
			POSITION pos4 = pMainList->FindIndex(nBeginAt+2);
			POSITION pos5 = pMainList->FindIndex(nBeginAt+3);
			POSITION pos6 = pMainList->FindIndex(nBeginAt+4);
			CSourcePhrase* pSP[6];
			pSP[0] = (CSourcePhrase*)pMainList->GetAt(pos1);
			pSP[1] = (CSourcePhrase*)pMainList->GetAt(pos2);
			pSP[2] = (CSourcePhrase*)pMainList->GetAt(pos3);
			pSP[3] = (CSourcePhrase*)pMainList->GetAt(pos4);
			pSP[4] = (CSourcePhrase*)pMainList->GetAt(pos5);
			pSP[5] = (CSourcePhrase*)pMainList->GetAt(pos6);
			TRACE3("\n1-3: %s , %s, %s\n",pSP[0]->m_key,pSP[1]->m_key,pSP[2]->m_key);
			TRACE3("\n4-6: %s , %s, %s\n",pSP[3]->m_key,pSP[4]->m_key,pSP[5]->m_key);
			int ii = 1; // place to put a breakpoint
			*/
		}
	}
	// the main list is managing these pointers now, so RemoveAll on the list in pRec
	pNewSrcPhrasesList->Clear();

	// update the maximum index value, and any others that are relevant
	gpApp->m_maxIndex += nExtras;
	if (gpApp->m_upperIndex > gpApp->m_maxIndex)
		gpApp->m_upperIndex += nExtras;
	if (gpApp->m_endIndex > gpApp->m_maxIndex)
		gpApp->m_endIndex += nExtras;
	if (pRec->nSaveActiveSequNum >= pRec->nStartingSequNum + nHowManyToInsert)
	{
		if (gpApp->m_nActiveSequNum > gpApp->m_maxIndex)
		{
			gpApp->m_nActiveSequNum += nExtras;
			pRec->nSaveActiveSequNum = gpApp->m_nActiveSequNum;
		}
	}
	GetDocument()->UpdateSequNumbers(0); // update from the beginning of m_pSourcePhrases
}

/* remove the old version of this function below, after the refactoring is done, other functions never use it 
void CAdapt_ItView::TransferCompletedSrcPhrases(SPList* pNewSrcPhrasesList,int nSaveSequNum)
// transfer the finished off CSourcePhrase instances in pNewSrcPhrasesList, to the main list on
// the document starting at the nSaveSequNum (the first of the former selection) element in the
// latter list. nNewCount is the number of elements in pNewSrcPhrasesList. (Any padding, if
// necessary, will have been done previously, and we do the transfer using the overloaded = on
// CSourcePhrase. The latter only copies pointers for srcPhrase sublists such as m_pSavedWords,
// etc, but these lists will be empty, always, in the context where this function is called, so
// no problems.)
{
	wxASSERT(pNewSrcPhrasesList != NULL);
	SPList::Node* posMain;
	SPList::Node* posNew; //POSITION posMain, posNew;
	SPList* pMainList = gpApp->m_pSourcePhrases;
	wxASSERT(pMainList);
	posMain = pMainList->Item(nSaveSequNum);
	wxASSERT(posMain != 0);

	// user could delete the whole selection, so allow for this possibility - check here
	if (pNewSrcPhrasesList->GetCount() == 0)
		return;

	// if we get here, there is at least one sourcephrase in the new list
	posNew = pNewSrcPhrasesList->GetFirst();
	wxASSERT(posNew != 0);
	while (posNew != 0 && posMain != 0)
	{
		CSourcePhrase* pNewSPh = (CSourcePhrase*)posNew->GetData();
		posNew = posNew->GetNext();
		wxASSERT(pNewSPh != NULL);
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)posMain->GetData();
		posMain = posMain->GetNext();
		wxASSERT(pSrcPhrase);

		// copy the completed one to the old one in the main list
		*pSrcPhrase = *pNewSPh;
	}
}
*/

/* deprecated 10Sep08
void CAdapt_ItView::RemoveUnwantedSrcPhrasesInDocList(int nSaveSequNum,int nNewCount,int nCount)
// remove unwanted CSourcePhrase instances in the document's list, starting from the one at at
// nSaveSequNum + nNewCount, and ending at nSaveSequNum + nCount - 1. The caller is responsible
// for calling this function only when nNewCount < nCount.
{
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);
	SPList* pMainList = gpApp->m_pSourcePhrases;
	wxASSERT(pMainList != NULL);
	SPList::Node* posMain;
	wxASSERT(nNewCount < nCount);
	wxASSERT(nSaveSequNum + nNewCount - 1 <= gpApp->m_maxIndex);
	posMain = pMainList->Item(nSaveSequNum + nNewCount);
	CSourcePhrase* pSrcPhrase = 0;
	for (int nItem = nSaveSequNum + nNewCount; nItem < nSaveSequNum + nCount; nItem++)
	{
		wxASSERT(posMain != 0);
		SPList::Node* savePos = posMain; // where the element is that we will remove from the list
		pSrcPhrase = (CSourcePhrase*)posMain->GetData();
		posMain = posMain->GetNext();
		wxASSERT(pSrcPhrase != NULL); 

		// get rid of the CSourcePhrase instance on the heap
		if (pSrcPhrase != NULL)
		{
			// don't want memory leaks
			delete pSrcPhrase->m_pMedialMarkers;
			delete pSrcPhrase->m_pMedialPuncts;
			pSrcPhrase->m_pSavedWords->Clear(); // remove pointers only (its an empty
													// list anyway)
			delete pSrcPhrase->m_pSavedWords;
			delete pSrcPhrase;
		}

		// now remove the list's unwanted pointer
		pMainList->DeleteNode(savePos); 
	}

	// make sure the sequence numbers are all correct
	pDoc->UpdateSequNumbers(0);
}
*/
/* deprecated 10Sept08
bool CAdapt_ItView::ReconcileLists(SPList* pList,SPList* pNewSrcPhrasesList,int WXUNUSED(nSaveSequNum),
								   int WXUNUSED(nCount),int WXUNUSED(nNewCount),bool WXUNUSED(bDelayRemovals),bool bSetNoteFlagLaterOn)
// pList has a list of pointer copies to the srcphrases on the heap (as unmerged, and any null
// ones removed) and the count for this list is nCount; pNewSrcPhrasesList has the pointers to
// the tokenized new list of srcphrases on the heap as defined by the user's typed new source
// text for the former selection, and this list's count is nNewCount; bDelayRemovals if TRUE is
// used to remove unwanted sourcphrase instances when the reconciliation process is complete
// (only, of course, if nNewCount < nCount). When this function is entered, and provided
// nNewCount > nCount, then the necessary extra sourcephrase instances (empty ones) will have
// already been inserted in the app's main list at the end of the former selection. So now
// we have to handle all the markers, etc, and we will do this by building the required
// fully-specified CSourcePhrase instances in the pNewSrcPhrasesList, and then copy their
// attributes to the main list on the app using the overloaded = operator defined on
// CSourcePhrase; then we can throw away both pList and pNewSrcPhrasesList. The reconciliation
// may require an auxiliary dialog (CTransferMarkersDlg) be invoked to enable the user to specify
// where markers are to be placed, removed, added. If the user has set the m_bEditMarkersWanted flag
// in the dialog for editing the source text (by clicking the checkbox) then the auxiliary dialog
// is obligatorily invoked.
// Return FALSE if something went wrong and we have to abandon the attempt to edit the source text.
// BEW 27Dec07: added bSetNoteFlagLaterOn parameter so that m_bHasNote flag can be transferred
// correctly if it was set on the first CSourcePhrase instance of the selection
{
	CAdapt_ItDoc* pDoc = GetDocument();

	CTransferMarkersDlg dlg(gpApp->GetMainFrame());
	dlg.Centre();

	// are there any standard format markers attached to the sourcephrase instances in pList?
	bool bHasInitialMarker;
	bool bHasNoninitialMarker;
	CheckForMarkers(pList,bHasInitialMarker,bHasNoninitialMarker);

	if (gbForceOpenMarkerTransferDialog || bHasNoninitialMarker)
	{
		if (dlg.ShowModal() == wxID_OK) //if (dlg.DoModal() == IDOK)
		{
			// user clicked ok button (the OnOK() function calls DoMarkerHousekeeping())

			// set the m_bHasNote flag on the first CSourcePhrase instance of the new
			// list, if the passed in bSetNoteFlagLaterOn flag is TRUE
			if (bSetNoteFlagLaterOn)
			{
				SPList::Node* posc = pNewSrcPhrasesList->GetFirst();
				CSourcePhrase* pSP = posc->GetData();
				wxASSERT(pSP != NULL);
				pSP->m_bHasNote = TRUE;
			}
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	if (bHasInitialMarker) // bHasNoninitialMarker will be FALSE if we get to here
	{
		// do the transfer automatically...
		SPList::Node* fpos = pList->GetFirst();
		CSourcePhrase* pFromSrcPhrase = fpos->GetData(); // won't be an empty list

		// BEW added 01Oct06; because if the user selected a, say, verse-initial word and
		// in the dialog removed it, the pNewSrcPhrasesList will then be empty, and any
		// call to GetHead() on an empty list causes a crash. So I have to check for the
		// empty list, and when detected, instead set pToSrcPhrase to be the gpFollSrcPhrase
		// which has already been set in the caller - and then the parameters that need to
		// be transferred here can be safely transferred.
		CSourcePhrase* pToSrcPhrase;
		bool bNewListIsEmpty = FALSE;
		if (pNewSrcPhrasesList->IsEmpty())
		{
			// the ClearForTransfer() call below chucks any m_markers content from this pToSrcPhrase,
			// so we could potentially lose data here; however, but we'll try prevent this - it is
			// only a real danger if we are removing source text immediately before a CSourcePhrase
			// instance with a non-empty m_markers member; so when that is the case the best
			// strategy is simply to not do any transfer, and no propagations (gbPropagationNeeded cleared
			// to FALSE) so that caller's next function calls don't try to propagate any settings.
			pToSrcPhrase = gpFollSrcPhrase;
			bNewListIsEmpty = TRUE;
		}
		else
		{
			SPList::Node* npos = pNewSrcPhrasesList->GetFirst();
			pToSrcPhrase = npos->GetData(); 
		}
		 // when false, we can copy things to pToSrcPhrase, but not when it is TRUE because we'd end up
		// clobbering information we need to keep, such as verse or chapter markers, etc; we also must
		// check in the empty new list situation for m_follPunct non-empty on the last source phrase
		// of the deletion, and transfer it (by appending) to the gpPrecSrcPhrase's m_follPunct member
		if (pToSrcPhrase->m_markers.IsEmpty())
		{
			// do following punctuation rescue in the event of deleting everything that was selected
			if (bNewListIsEmpty)
			{
				fpos = pList->GetLast();
				CSourcePhrase* pTailSrcPhrase = fpos->GetData();
				if (!pTailSrcPhrase->m_follPunct.IsEmpty())
				{
					wxString follpunctstr = pTailSrcPhrase->m_follPunct;
					if (gpPrecSrcPhrase != NULL)
					{
						// we'll not try to rescue any preceding punctuation, but just the
						// following punctuation, as is would be unlikely there would be both
						gpPrecSrcPhrase->m_follPunct += follpunctstr;
						gpPrecSrcPhrase->m_srcPhrase += follpunctstr;
						gpPrecSrcPhrase->m_targetStr += follpunctstr;
					}
				}
			}

			// this is the safe case; ClearForTransfer() will unilaterally empty m_markers, so we only
			// want that to happen if there was nothing in it in the first place!!
			dlg.ClearForTransfer(pToSrcPhrase);
			dlg.SimpleCopyTransfer(pFromSrcPhrase,pToSrcPhrase);
			pDoc->DoMarkerHousekeeping(gpNewSrcPhraseList,gnNewCount,gPropagationType,gbPropagationNeeded);
		}
		else
		{
			// this is the dodgey situation; as m_markers is not empty, there might be a change of TextType
			// at pToSrcPhrase, so we don't want to propagate the deleted sourcephrase's TextType to it;
			gbPropagationNeeded = FALSE;

			// do following punctuation rescue in the event of deleting everything that was selected
			if (bNewListIsEmpty)
			{
				fpos = pList->GetLast();
				CSourcePhrase* pTailSrcPhrase = fpos->GetData();
				if (!pTailSrcPhrase->m_follPunct.IsEmpty())
				{
					wxString follpunctstr = pTailSrcPhrase->m_follPunct;
					if (gpPrecSrcPhrase != NULL)
					{
						// we'll not try to rescue any preceding punctuation, but just the
						// following punctuation, as is would be unlikely there would be both
						gpPrecSrcPhrase->m_follPunct += follpunctstr;
						gpPrecSrcPhrase->m_srcPhrase += follpunctstr;
						gpPrecSrcPhrase->m_targetStr += follpunctstr;
					}
				}
			}
		}

		// set the m_bHasNote flag on the first CSourcePhrase instance of the new
		// list, if the passed in bSetNoteFlagLaterOn flag is TRUE
		if (bSetNoteFlagLaterOn)
		{
			pToSrcPhrase->m_bHasNote = TRUE;
		}
	}
	else
	{
		// no markers on any of the sourcephrases, so we can just preserve the original
		// m_bSpecialText value
		gbSpecialText = FALSE;
		if (gpPrecSrcPhrase != 0)
		{
			// set the globals
			gbSpecialText = gpPrecSrcPhrase->m_bSpecialText;
			gPropagationType = gpPrecSrcPhrase->m_curTextType;
		}

		// BEW added 01Oct06; to give smarter behaviour in the event that the user deletes the selected source
		// text words; we'll try prevent propagation and have following punctuation on the last selected word
		// rescued and put on the gpPrevSrcPhrase
		bool bNewListIsEmpty = FALSE;
		SPList::Node* pos = pNewSrcPhrasesList->GetFirst(); // whm added initialization here to prevent warning
		if (pNewSrcPhrasesList->IsEmpty())
		{
			bNewListIsEmpty = TRUE;
		}
		else
		{
			pos = pNewSrcPhrasesList->GetFirst(); // will be NULL if pNewSrcPhrasesList is empty,
												// but that causes the loop to be safely skipped
		}
		if (!bNewListIsEmpty)
		{
			while (pos != 0)
			{
				// also use the globals here within the list, and later at end of the calling function
				CSourcePhrase* pSP = pos->GetData();
				pos = pos->GetNext();
				pSP->m_bSpecialText = gbSpecialText;
				pSP->m_curTextType = gPropagationType;
			}
			gbPropagationNeeded = TRUE; // turn it on
		}
		else
		{
			// do following punctuation rescue in the event of deleting everything that was selected
			SPList::Node* fpos = pList->GetLast();
			CSourcePhrase* pTailSrcPhrase = fpos->GetData();
			if (!pTailSrcPhrase->m_follPunct.IsEmpty())
			{
				wxString follpunctstr = pTailSrcPhrase->m_follPunct;
				if (gpPrecSrcPhrase != NULL)
				{
					// we'll not try to rescue any preceding punctuation, but just the
					// following punctuation, as is would be unlikely there would be both
					gpPrecSrcPhrase->m_follPunct += follpunctstr;
					gpPrecSrcPhrase->m_srcPhrase += follpunctstr;
					gpPrecSrcPhrase->m_targetStr += follpunctstr;
				}
			}
			gbPropagationNeeded = FALSE; // turn it off
		}
	}
	return TRUE; // nothing needs to be done for transfer of markers, etc
}
*/

void CAdapt_ItView::CheckForMarkers(SPList* pList,bool& bHasInitialMarker,
									bool& bHasNoninitialMarker)
// checks the list of unmerged sourcephrase instances corresponding to the former selection, as
// required for editing some source text, to see if there are any standard format markers stored on
// any of the sourcephase instances. In particular, we want to know if there are markers on the
// first one in the list, and if there are any on any of the non-first ones in the list. If TRUE
// for the former and FALSE for the latter, transfer can be done without needing to put up a dialog
// for user control of the transfers. If both flags are FALSE, then no markers and associated
// marker information need be done at all.
{
	wxASSERT(pList->GetCount() > 0); // there must have been something selected for editing by
								   // the user!
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = 0;
	pos = pList->GetFirst();
	bool bIsFirst = TRUE;
	bHasInitialMarker = FALSE;
	bHasNoninitialMarker = FALSE;
	while (pos != 0)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (!pSrcPhrase->m_markers.IsEmpty())
		{
			if (bIsFirst)
			{
				bIsFirst = FALSE;
				bHasInitialMarker = TRUE;
			}
			else
			{
				bHasNoninitialMarker = TRUE;
			}
		}
		else
		{
			bIsFirst = FALSE;
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If there are no source phrases in the App's m_pSourcePhrases list this handler disables the 
/// "Export Source Text..." item on the File menu, otherwise it enables the "Export Source Text..." 
/// item on the File menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExportSource(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// whm revised Revised 1Aug03; bw revised 15 April 2004 to derive the source data
// from the CSourcePhrase instances
void CAdapt_ItView::OnFileExportSource(wxCommandEvent& WXUNUSED(event))
{
	bool bExportTarget = FALSE;
	bool bForceUTF8Conversion = TRUE; // BEW changed 08Dec06, to avoid unreliable encoding check
	DoExportSrcOrTgt(bExportTarget,bForceUTF8Conversion);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "See Glossing" item on the Advanced menu is enabled if the KBs are in a ready state, otherwise 
/// the menu item is disabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedEnableglossing(wxUpdateUIEvent& event)
{
	// we'll allow it to be toggled on or off provided a project is open; the two
	// kb flags being TRUE will be a sufficient test.
	if (gpApp->m_bKBReady && gpApp->m_bGlossingKBReady)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// BEW added 19Sep08 in support of mode changing within the vertical edit process
void CAdapt_ItView::ToggleSeeGlossesMode()
{
	if (gbVerticalEditInProgress)
	{
		CMainFrame* pFrame;
		pFrame = gpApp->GetMainFrame(); //(CMainFrame*)GetParentFrame();
		wxASSERT(pFrame != NULL);
		//CMenu* pTopLevelMenu = pFrame->GetMenu();
		//CMenu* pAdvancedMenu = pTopLevelMenu->GetSubMenu(4);
		wxMenuBar* pMenuBar = gpApp->GetMainFrame()->GetMenuBar();
		wxASSERT(pMenuBar != NULL);
		wxMenuItem * pAdvancedFreeTranslation;
		pAdvancedFreeTranslation = pMenuBar->FindItem(ID_ADVANCED_FREE_TRANSLATION_MODE);
		wxASSERT(pAdvancedFreeTranslation != NULL);

		// get the checkbox pointer from the "Glossing" checkbox on the controlBar
		//CMainFrame* pMainFrame = (CMainFrame*)GetTopLevelFrame();
		wxASSERT(pFrame->m_pControlBar != NULL);
		//CDialogBar* pBar = &pMainFrame->m_wndDlgBar1;
		//ASSERT_VALID(pBar);
		wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)pFrame->m_pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
		wxASSERT(pCheckboxIsGlossing != NULL);

		// toggle the setting: note; whether going to or from glossing we will not change the
		// current values of gbGlossingUsesNavFont because the user might go back and forwards
		// from having glossing allowed or actually on (in the one session,) and it would be a nuisance
		// to have to manually restore this flag to its former setting each time the user enables glossing
		// again in the one session. (Leaving the flag ON is benign when adapting.)
		wxMenuItem * pAdvancedSeeGlosses = pMenuBar->FindItem(ID_ADVANCED_ENABLEGLOSSING);
		if (gbEnableGlossing)
		{
			// toggle the checkmark to OFF
			pAdvancedSeeGlosses->Check(FALSE);
			gbEnableGlossing = FALSE;
			gbIsGlossing = FALSE; // must be off whenever the other flag is off

			// hide the mode bar checkbox when glossing is not allowed to be visible
			// and when not visible it obligatorily must be adapting
			pCheckboxIsGlossing->SetValue(FALSE); // not glossing, ie. is adapting
			pCheckboxIsGlossing->Hide();
		}
		else
		{
			// toggle the checkmark to ON
			pAdvancedSeeGlosses->Check(TRUE);
			gbEnableGlossing = TRUE;

			// show the mode bar checkbox when glossing is allowed to be visible - user can then
			// choose either to do glossing, or to do adapting
			pCheckboxIsGlossing->Show(TRUE);
		}
	}
}

void CAdapt_ItView::OnAdvancedEnableglossing(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CRefString* pRefStr;
	CSourcePhrase* pSrcPhrase;
	bool bOK;
	CSourcePhrase* pSaveSrcPhrase;
	CPile* pPile;
	int nSequNum;

	// save the current sequence number
	int nSaveSequNum = pApp->m_nActiveSequNum;

	// won't allow a selection to be preserved, this is too major a modality change
	if (pApp->m_selectionLine >= 0)
		RemoveSelection();

	// before we redraw the layout and phrasebox, we have to save what is in the box
	// (provided it's contents are not abandonable or null text) in the appropriate KB, then
	// ready the pApp->m_targetPhrase member to have the correct text before RedrawEverything is called
	pApp->m_bSaveToKB = TRUE;

	if (pApp->m_pActivePile == NULL)
		goto a; // the phrase box does not exist (we must be at the document's end)
	pSrcPhrase = pApp->m_pActivePile->m_pSrcPhrase;
	if (gbIsGlossing) // flag has not been toggled yet
	{
		// we are changing from glossing to adapting, so we must store to the glossing KB
		// and then ready the pApp->m_targetPhrase member with the sourcephrase's m_adaption contents
		// and remove its refString from the adapting KB
		if (!(pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
		{
			// we can assume no errors for StoreTest call
			bOK = StoreText(gpApp->m_pGlossingKB,pSrcPhrase,pApp->m_targetPhrase);
		}

		// if the active location is within a retranslation, we can't leave the box there
		// when we are in adapting mode, so if that is the case then find a safe location
		if (pSrcPhrase->m_bRetranslation)
		{
			pSaveSrcPhrase = pSrcPhrase;
			pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase); // try first for a location
														   // after retranslation section
			if (pSrcPhrase == NULL)
			{
				pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSrcPhrase);
			}
			// we assume (we won't test) one of the above Get... calls will succeed
			nSequNum = pSrcPhrase->m_nSequNumber;
			pPile = AdvanceBundle(nSequNum); // ensure box is within valid indices
			Invalidate(); // cause redraw of strips
			pApp->m_nActiveSequNum = nSaveSequNum = pApp->m_curIndex = nSequNum;
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		}

		// now the adaptation stuff
		pApp->m_targetPhrase = pSrcPhrase->m_adaption; // get the adaptation text
		pRefStr = GetRefString(gpApp->m_pKB, pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key, pApp->m_targetPhrase);
		gbIsGlossing = FALSE; // so RemoveRefString will get the adaptation KB
								// but it also gives us the toggle we need too
		RemoveRefString(pRefStr, pSrcPhrase, pSrcPhrase->m_nSrcWords);
		gbIsGlossing = TRUE; // restore it
	}

	// get the Enable Glossing menu pointer
a:	// uncomment when get routine to the point where label is needed
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedMenu = pMenuBar->FindItem(ID_ADVANCED_ENABLEGLOSSING);
	wxASSERT(pAdvancedMenu != NULL);

	// get the checkbox pointer
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
	wxASSERT(pCheckboxIsGlossing != NULL);

	// toggle the setting: note; whether going to or from glossing we will not change the
	// current values of gbGlossingUsesNavFont because the user might go back and forwards
	// from having glossing allowed or actually on (in the one session,) and it would be a nuisance
	// to have to manually restore this flag to its former setting each time the user enables glossing
	// again in the one session. (Leaving the flag ON is benign when adapting.)
	if (gbEnableGlossing)
	{
		// toggle the checkmark to OFF
		pAdvancedMenu->Check(FALSE);
		gbEnableGlossing = FALSE;
		gbIsGlossing = FALSE; // must be off whenever the other flag is off

		// hide the mode bar checkbox when glossing is not allowed to be visible
		// and when not visible it obligatorily must be adapting
		pCheckboxIsGlossing->SetValue(FALSE); // not glossing, ie. is adapting
		pCheckboxIsGlossing->Show(FALSE);
	}
	else
	{
		// toggle the checkmark to ON
		pAdvancedMenu->Check(TRUE);
		gbEnableGlossing = TRUE;

		// show the mode bar checkbox when glossing is allowed to be visible - user can then
		// choose either to do glossing, or to do adapting
		pCheckboxIsGlossing->Show(TRUE);
	}


	// redraw the layout etc.
	RedrawEverything(nSaveSequNum);
	pApp->m_pTargetBox->m_bAbandonable = FALSE; // we assume the new contents are wanted

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown()) 
			pApp->m_pTargetBox->SetFocus();

}

// BEW added 19Sep08, for support of mode transitions within vertical edit mode
void CAdapt_ItView::ToggleGlossingMode() 
{
	if (gbVerticalEditInProgress)
	{
		if (gbIsGlossing) // flag has not been toggled yet
		{
			// we are changing from glossing to adapting

			// get any removed adaptations in gEditRecord into the GUI list; but if the
			// mode current on is free translations mode, don't do so
			bool bAllsWell;
			if (!gpApp->m_bFreeTranslationMode)
				bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);
		}
		else
		{
			// we are changing from adapting to glossing

			// get any removed glosses in gEditRecord into the GUI list; but if the
			// mode current on is free translations mode, don't do so
			bool bAllsWell;
			if (!gpApp->m_bFreeTranslationMode)
				bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
		}

		// set the tick or clear the tick on the menu command
		CMainFrame* pFrame;
		pFrame = gpApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pControlBar != NULL);
		wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)pFrame->m_pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
		if (gbIsGlossing)
		{
			pCheckboxIsGlossing->SetValue(FALSE);
			gbIsGlossing = FALSE;
		}
		else
		{
			pCheckboxIsGlossing->SetValue(TRUE);
			gbIsGlossing = TRUE;
		}
	}
}

void CAdapt_ItView::OnCheckIsGlossing(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CRefString* pRefStr;
	CSourcePhrase* pSrcPhrase;
	bool bOK;
	CSourcePhrase* pSaveSrcPhrase;
	CPile* pPile;
	int nSequNum;
	wxString str;

	// save the current sequence number
	int nSaveSequNum = pApp->m_nActiveSequNum;

	// won't allow a selection to be preserved, this is too major a modality change
	if (pApp->m_selectionLine >= 0)
		RemoveSelection();

	// before we redraw the layout and phrasebox, we have to save what is in the box
	// (provided it's contents are not abandonable or null text) in the appropriate KB, then
	// ready the pApp->m_targetPhrase member to have the correct text before RedrawEverything is called
	pApp->m_bSaveToKB = TRUE;

	if (pApp->m_pActivePile == NULL)
	{
		// the phrase box is not in existence - because we must be at the end of the document
		// do nothing to be done with the phrasebox here, so just switch the environment
		gbIsGlossing = gbIsGlossing == TRUE ? FALSE : TRUE;
		goto a;
	}
	pSrcPhrase = pApp->m_pActivePile->m_pSrcPhrase;

	if (gbIsGlossing) // flag has not been toggled yet
	{
		// we are changing from glossing to adapting, so we must store to the glossing KB
		// and then ready the pApp->m_targetPhrase member with the sourcephrase's m_adaption contents
		// and remove its refString from the adapting KB; and if the box is within a retranslation
		// then we need to find a safe location for it as close as possible
		if (!(pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
		{
			if (gbRemovePunctuationFromGlosses)
				RemovePunctuation(GetDocument(),&pApp->m_targetPhrase,1 ); //use tgt punct set
			// assume no errors
			bOK = StoreText(gpApp->m_pGlossingKB,pSrcPhrase,pApp->m_targetPhrase);
		}

		// now the adaptation stuff
		gbIsGlossing = FALSE; // so RemoveRefString will get the adaptation KB
								// but it also gives us the toggle we need too

		// if the active location is within a retranslation, we can't leave the box there
		// when we are in adapting mode, so if that is the case then find a safe location
		if (pSrcPhrase->m_bRetranslation)
		{
			pSaveSrcPhrase = pSrcPhrase;
			pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase); // try first for a location after retrans
			if (pSrcPhrase == NULL)
			{
				pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSrcPhrase);
			}
			// we assume (we won't test) one of the above Get... calls will succeed
			nSequNum = pSrcPhrase->m_nSequNumber;
			pPile = AdvanceBundle(nSequNum); // ensure box is within valid indices
			Invalidate(); // cause redraw of strips
			pApp->m_nActiveSequNum = nSaveSequNum = pApp->m_curIndex = nSequNum;
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		}

		pApp->m_targetPhrase = pSrcPhrase->m_adaption; // get the adaptation text
		if (pSrcPhrase->m_bNotInKB)
		{
			pApp->m_bSaveToKB = FALSE;
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pApp->m_bForceAsk = FALSE;
		}
		else // it's a normal type of entry, so can be in the KB
		{
			pRefStr = GetRefString(gpApp->m_pKB, pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key, pApp->m_targetPhrase);
			RemoveRefString(pRefStr,pSrcPhrase,pSrcPhrase->m_nSrcWords);
		}

		// get any removed adaptations in gEditRecord into the GUI list; but if the
		// mode current on is free translations mode, don't do so
		bool bAllsWell;
		if (!gpApp->m_bFreeTranslationMode)
			bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);
	}
	else
	{
		// we are changing from adapting to glossing, so we must store to the adaptation KB
		// and then ready the pApp->m_targetPhrase member with the sourcephrase's m_gloss contents
		// and remove its refString from the glossing KB; but if it is a "not in kb" entry,
		// then don't store, but just set up pApp->m_targetPhrase
		if (pSrcPhrase->m_bNotInKB)
		{
			str = pApp->m_targetPhrase;
			RemovePunctuation(GetDocument(),&str,1 ); //from tgt
			pSrcPhrase->m_adaption = str;
			MakeLineFourString(pSrcPhrase,pApp->m_targetPhrase);
			pApp->m_bSaveToKB = FALSE;
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pApp->m_bForceAsk = FALSE;
		}
		else
		{
			if (!( pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
			{
				str = pApp->m_targetPhrase;
				RemovePunctuation(GetDocument(),&str,1 ); //from tgt
				pSrcPhrase->m_adaption = str;
				MakeLineFourString(pSrcPhrase,pApp->m_targetPhrase);
				bOK = StoreText(gpApp->m_pKB,pSrcPhrase,str);
			}
		}
		// now the glossing stuff
		pApp->m_targetPhrase = pSrcPhrase->m_gloss; // get the gloss text
		pRefStr = GetRefString(gpApp->m_pGlossingKB,1,pSrcPhrase->m_key,pApp->m_targetPhrase);

		gbIsGlossing = TRUE; // so GetRefString( ) will get the glossing KB
								// but it also gives us the needed toggle too
		RemoveRefString(pRefStr, pSrcPhrase, 1);

		// get any removed glosses in gEditRecord into the GUI list; but if the
		// mode current on is free translations mode, don't do so
		bool bAllsWell;
		if (!gpApp->m_bFreeTranslationMode)
			bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
	}

	// set the tick or clear the tick on the menu command
a:	// uncomment when get routine to the point where label is needed
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
	wxASSERT(pCheckboxIsGlossing != NULL);

	if (gbIsGlossing)
		pCheckboxIsGlossing->SetValue(TRUE);
	else
		pCheckboxIsGlossing->SetValue(FALSE);

	// redraw the layout etc. (Must do it after the flag is toggled, otherwise RecalcLayout( )
	// will think that the untoggled setting is still in effect and lay the pile out wrong)
	RedrawEverything(nSaveSequNum);
	pApp->m_pTargetBox->m_bAbandonable = FALSE; // we assume the new contents are wanted

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnAdvancedGlossingUsesNavFont(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedGlossingUsesNavFont = pMenuBar->FindItem(ID_ADVANCED_GLOSSING_USES_NAV_FONT);
	wxASSERT(pAdvancedGlossingUsesNavFont != NULL);

	// toggle the setting & update the display accordingly
	if (gbGlossingUsesNavFont)
	{
		// toggle the checkmark to OFF & recalc the layout with glossing using target font
		pAdvancedGlossingUsesNavFont->Check(FALSE);
		gbGlossingUsesNavFont = FALSE;
	}
	else
	{
		// toggle the checkmark to ON, and recalc the layout with strip-wrap on
		pAdvancedGlossingUsesNavFont->Check(TRUE);
		gbGlossingUsesNavFont = TRUE;
	}

	// redraw everything with the other Font and directionality setting
	RedrawEverything(pApp->m_nActiveSequNum);

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Glossing Uses Navigation Text's Font" item on the Advanced menu is enabled if the
/// gbEnableGlossing global is TRUE, otherwise the menu item is disabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedGlossingUsesNavFont(wxUpdateUIEvent& event)
{
	if (gbEnableGlossing)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

bool CAdapt_ItView::TransformSourcePhraseAdaptationsToGlosses(SPList::Node* curPos, SPList::Node* nextPos, 
															  CSourcePhrase* pSrcPhrase)
// called by the application class's DoTransformationsToGlosses( ) function. pSrcPhrase points
// to a source phrase on the heap, and the source phrase belows to the list of sourcephrases
// in the document (from another project) currently being transformed. When all such belonging
// to the current document are transformed, the document is resaved but as a document belonging
// to the current project. The latter fact allows us to simply transform each sourcephrase
// instance that is on the heap, rather than doing the changes on copies.
// The transformations ALWAYS take the m_adaption member and transform it, never the m_srcPhrase
// member since the latter may contain unwanted punctuation.
// If the sourcephrase needs to be removed by the caller, return TRUE; null
// sourcephrases are an example of such. The current and next POSITIONs are passed in, in case
// the function needs to access the previous, current or next sourcephrase entry in the list;
// the pointer to the list of the document's sourcephrase instances is pPhrases
// BEW ammended 30Aug05 to bring it into line with version 3; note, m_markers content is untouched
// and so the transformation process preserves filtering, notes, free translations, and the like,
// BEW addition 05Jan06 except when m_markers containing a note was moved leftwards by right association
// to a placeholder (pSrcPhrase) in which case we must move it back to the sourcephrase which follows
// the placeholder
{
	// <Not In KB> instances are changed to normal instances, and if there is an adaptation
	// then make it the gloss, but if not then it is assumed to be not in the glossing KB

	// start with checking for any <Not In KB> entries; since retranslations have the same
	// flag set, we are interested here only in those sourcephrases which are not retranslations
	if (pSrcPhrase->m_bNotInKB && !pSrcPhrase->m_bRetranslation)
	{
		pSrcPhrase->m_bNotInKB = FALSE;
		pSrcPhrase->m_bNullSourcePhrase = FALSE;
		pSrcPhrase->m_bRetranslation = FALSE;
		pSrcPhrase->m_bHasKBEntry = FALSE;
		if (pSrcPhrase->m_adaption.IsEmpty())
		{
			pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
		}
		else
		{
			pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
			pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
			pSrcPhrase->m_adaption.Empty( );
		}
		pSrcPhrase->m_targetStr.Empty(); // play safe
		return FALSE; // we are done with this one, but don't remove it
	}

	// any null sourcephrase instances have to be removed, whether in a retranslation or not,
	// but first we need to check if punctuation was moved from a neighbouring sourcephrase
	// instance, and it so, move it back there
	if (pSrcPhrase->m_bNullSourcePhrase)
	{
		// content can differ depending on whether the null source phrase is part of a
		// retranslation or not. If it is, then no transfers of punctuation will have been
		// done, and we can just throw the null source phrase away; but if it is not then
		// it may be the case that punctuation was moved on to it, so we have to do more tests
		// and move the punctuation back if it was moved, then indicate that the caller must
		// remove the null source phrase
		if (pSrcPhrase->m_bRetranslation)
		{
			// it is part of a retranslation, so we can abandon it (note: boundary flag settings
			// are not moved when a retranslation is padded with nulls, so we don't have to worry
			// about restoring a boundary when we delete the null source phrase in a retranslation)
			// retranslations, when they accept null sourcephrase padding, only fiddle with the
			// m_bRetranslation and m_bNotInKB flag values, nothing else is affected.
			// BEW changed 30Aug05 -- but in version 3 we have to consider the possibility that
			// the last placeholder may be a free translation end (which was moved to the last
			// inserted placeholder) and move it back to where it was originally
			//
			// BEW note 05Jan06: we also assume that the user would not place a note on a placeholder
			// within a retranslation; but if he did then this assumption would result in it being
			// lost in the transform process ******* to fix this, add code to what is below
			if (pSrcPhrase->m_bEndFreeTrans)
			{
				// move it back to the last non-placeholder sourcephrase
				SPList::Node* prevPos = curPos;
				CSourcePhrase* pPrevSrcPhrase = (CSourcePhrase*)prevPos->GetData();
				prevPos = prevPos->GetPrevious();
				wxASSERT(pPrevSrcPhrase != NULL);
				pPrevSrcPhrase->m_bEndFreeTrans = TRUE;
			}
			return TRUE; //  remove now
		}
		else
		{
			// it is not part of a retranslation, so do the extra checks related to punctuation...
			// first, get the the previous source phrase, if it exists, in case we need it
			SPList::Node* prevPos = curPos; 
			CSourcePhrase* pPrevSrcPhrase = (CSourcePhrase*)prevPos->GetData();
			prevPos = prevPos->GetPrevious();
			bool bSomethingWasMoved = FALSE;
			if (prevPos != NULL)
			{
				// previous POSITION value is valid, so get its pointer
				pPrevSrcPhrase = (CSourcePhrase*)prevPos->GetData();

				// BEW additions 30Aug05 for version 3
				if (pSrcPhrase->m_bEndFreeTrans)
				{
					// the placeholder was previously left-associated to the end of a free
					// translation section, so move the flag back where it was
					pPrevSrcPhrase->m_bEndFreeTrans = TRUE;
					bSomethingWasMoved = TRUE;
				}
				// end of 30Aug05 additions
				if (!pSrcPhrase->m_follPunct.IsEmpty())
				{
					// punctuation was moved to this source phrase, so move it back
					pPrevSrcPhrase->m_follPunct = pSrcPhrase->m_follPunct;
					bSomethingWasMoved = TRUE;
				}
				if (pSrcPhrase->m_bFootnoteEnd)
				{
					// at a footnote end, so move the end marker to previous srcphrase
					pPrevSrcPhrase->m_bFootnoteEnd = TRUE;
					bSomethingWasMoved = TRUE;
				}
				if (pPrevSrcPhrase->m_bBoundary)
				{
					// boundary was moved, so move it back
					pPrevSrcPhrase->m_bBoundary = TRUE;
					bSomethingWasMoved = TRUE;
				}
				if (bSomethingWasMoved)
					return TRUE; // remove this null src phrase now
			}
			else
			{
				// no previous srcPhrase exists, so nothing could have been moved from it
				// so check out the rightwards association possibilites to see if any
				// previous punctuation was moved leftwards to this null source phrase
				;
			}

			// check for leftwards move of punctuation
			if (nextPos == NULL)
			{
				// at the end of the document, so no possibility of a rightwards association
				// so get rid of this null source phrase now
				return TRUE;
			}
			else
			{
				CSourcePhrase* pNextSrcPhrase = (CSourcePhrase*)nextPos->GetData();
				wxASSERT(pNextSrcPhrase);
				// BEW addition 05Jan06 to handle any note moved to the placeholder by a previous
				// right association - the note (and any other m_markers content) must be moved back
				// the following sourcephrase instance
				if (pSrcPhrase->m_bHasNote)
				{
					pNextSrcPhrase->m_bHasNote = TRUE;
					// we can concatenate without bothering to add an intervening space because
					// m_markers always should end in a space
					pNextSrcPhrase->m_markers += pSrcPhrase->m_markers;
					// the above order change is deliberate; after the earlier left transfer of
					// m_markers to the placeholder, the user may have put a note or back translation
					// or free translation on the sourcephrase instance following the placeholder;
					// the above order will move any such additions to the front of m_markers, which
					// is a benign order change as Adapt It won't care;
					// but if the earlier m_markers before being moved to the left had unfiltered
					// markers, these will be at its end and they define the subsequent TextType and
					// so need to remain at the end, so changing the order as above will ensure that
					// any such remain at the end of the m_markers string
				}
				if (!pSrcPhrase->m_precPunct.IsEmpty())
				{
					// punctuation was moved here, so move it back
					pNextSrcPhrase->m_precPunct = pSrcPhrase->m_precPunct;
				}
				if (!pSrcPhrase->m_markers.IsEmpty())
				{
					// markers were moved, so move them back
					pNextSrcPhrase->m_markers = pSrcPhrase->m_markers;
				}
				if (pSrcPhrase->m_bFootnote)
				{
					// we are at the start of a footnote, so the src phrase to the right must
					// be where the footnote marker was copied from and the flag moved from
					// (markers will be fixed by previous block, just do the flag now)
					pNextSrcPhrase->m_bFootnote = TRUE;
				}
				if (pSrcPhrase->m_bFirstOfType)
				{
					pNextSrcPhrase->m_bFirstOfType = TRUE;
				}
				// BEW additions 30Aug05 for version 3
				if (pSrcPhrase->m_bStartFreeTrans)
				{
					pNextSrcPhrase->m_bStartFreeTrans = TRUE;
				}
				if (!pSrcPhrase->m_inform.IsEmpty())
				{
					pNextSrcPhrase->m_inform = pSrcPhrase->m_inform;
				}
				if (!pSrcPhrase->m_chapterVerse.IsEmpty())
				{
					pNextSrcPhrase->m_chapterVerse = pSrcPhrase->m_chapterVerse;
				}
				if (pSrcPhrase->m_bVerse)
				{
					pNextSrcPhrase->m_bVerse = pSrcPhrase->m_bVerse;
				}
				if (pSrcPhrase->m_bChapter)
				{
					pNextSrcPhrase->m_bChapter = pSrcPhrase->m_bChapter;
				}
				if (pSrcPhrase->m_bVerse)
				{
					pNextSrcPhrase->m_bVerse = pSrcPhrase->m_bVerse;
				}
				if (pSrcPhrase->m_bParagraph)
				{
					pNextSrcPhrase->m_bParagraph = pSrcPhrase->m_bParagraph;
				}
				if (pSrcPhrase->m_bSpecialText)
				{
					pNextSrcPhrase->m_bSpecialText = pSrcPhrase->m_bSpecialText;
				}
				// end 30Aug05 additions
			}
			return TRUE; // needs to be removed
		} // end block for null source phrase not a part of a retranslation
	} // end block for null source phrases

	// now we have to check for retranslation sourcephrases which are not placeholders
	// - these have no KB presence, so all we can do is leave the m_gloss member empty
	// under the transform operation
	if (pSrcPhrase->m_bRetranslation)
	{
		pSrcPhrase->m_gloss.Empty();
		pSrcPhrase->m_adaption.Empty();
		pSrcPhrase->m_targetStr.Empty();
		pSrcPhrase->m_bHasKBEntry = FALSE;
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
		pSrcPhrase->m_bNotInKB = FALSE;
		pSrcPhrase->m_bRetranslation = FALSE;
		pSrcPhrase->m_bBeginRetranslation = FALSE;
		pSrcPhrase->m_bEndRetranslation = FALSE;
		return FALSE; // don't remove this one
	}

	// anything else is normal srcphrase and just do the transformations required
	pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
	pSrcPhrase->m_adaption.Empty();
	pSrcPhrase->m_targetStr.Empty();
	pSrcPhrase->m_bHasKBEntry = FALSE;
	pSrcPhrase->m_bHasGlossingKBEntry = TRUE;

	return FALSE; // don't delete this one
}

// added by Bill Martin 1June2003
void CAdapt_ItView::OnFileExportToRtf(wxCommandEvent& WXUNUSED(event))
{

	DoExportInterlinearRTF(); // now located in ExportFunctions.cpp and .h
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// If there are no source phrases in the App's m_pSourcePhrases list this handler disables the 
/// "Export Interlinear Text..." item on the File menu, otherwise it enables the "Export Interlinear 
/// Text..." item on the File menu.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExportToRtf(wxUpdateUIEvent& event)
{
	// added by Bill Martin 1June2003
	// make sure there are some SourcePhrases to work with
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// ********************************************
//
// functions for support of Auto-Capitalization
//
// ********************************************

inline wxChar CAdapt_ItView::GetFirstChar(wxString& strText)
{
	return strText.GetChar(0);
}

bool CAdapt_ItView::IsInCaseCharSet(wxChar chTest, wxString& theCharSet, int& index)
// takes the input character chTest, and attempts to Find() it in the CString theCharSet,
// returning TRUE if it finds it, and setting index to the character index for its
// position in the string buffer; if not found, then index will be set to -1.
{
	index = theCharSet.Find(chTest);
	if (index > -1)
	{
		// it is in the list
		return TRUE;
	}
	else
	{
		// it is not in the list
		return FALSE;
	}
}

wxChar CAdapt_ItView::GetOtherCaseChar(wxString& charSet, int nOffset)
// returns the TCHAR at the passed in offset
{
	wxASSERT(nOffset < (int)charSet.Length());
	return charSet.GetChar(nOffset);
}

bool CAdapt_ItView::SetCaseParameters(wxString& strText, bool bIsSrcText)
//return TRUE if all was well, FALSE if there was an error; strText is the language word
// or phrase the first character of which this function tests to determine its case, and
// from that to set up storage for the lower or upper case equivalent character, and the
// relevant flags. strText can be source text, target text, or gloss text; for the latter
// two possibilities bIsSrcText needs to be explicitly set to FALSE, otherwise it is TRUE
// by default. This is a diagnostic function used for Auto-Capitalization support.
{
	if (strText.IsEmpty())
	{
		return FALSE;
	}
	int nOffset = -1;
	wxChar chFirst = GetFirstChar(strText);

	bool bIsLower;
	bool bIsUpper;
	if (bIsSrcText)
	{
		// exit prematurely if the user has not defined any source case equivalents
		if (gbNoSourceCaseEquivalents)
		{
			gbSourceIsUpperCase = FALSE; // ensures an old style lookup or store
			return FALSE;
		}

		// determine if it is a lower case source character which has an upper case equivalent
		bIsLower = IsInCaseCharSet(chFirst,gpApp->m_srcLowerCaseChars,nOffset);
		if (bIsLower)
		{
			// it's a lower case belonging to the source set, so we don't have to capitalize it
			gbSourceIsUpperCase = FALSE;
			gcharSrcLC = chFirst;
			wxASSERT(nOffset >= 0);
			gcharSrcUC = GetOtherCaseChar(gpApp->m_srcUpperCaseChars,nOffset);
		}
		else
		{
			// chFirst is not a lower case source character which has an upper case equivalent, so it
			// might be an upper case source character (having a lower case equivalent), or it is
			// of indeterminate case - in which case we treat it as lower case
			bIsUpper = IsInCaseCharSet(chFirst,gpApp->m_srcUpperCaseChars,nOffset);
			if (bIsUpper)
			{
				// it is an upper case source char for which there is a lower case equivalent
				gbSourceIsUpperCase = TRUE;
				gcharSrcUC = chFirst;
				wxASSERT(nOffset >= 0);
				gcharSrcLC = GetOtherCaseChar(gpApp->m_srcLowerCaseChars,nOffset);
			}
			else
			{
				// it has indeterminate case, so treat as lower case with zero as its upper case equiv
				gbSourceIsUpperCase = FALSE;
				gcharSrcLC = chFirst;
				wxASSERT(nOffset == -1);
				gcharSrcUC = _T('\0');
			}
		}
	}
	else
	{
		// it is either gloss or adaptation data: use gbIsGlossing to determine which...
		// determine if it is a lower case character which has an upper case equivalent
		if (gbIsGlossing)
		{
			// it's gloss data
			// exit prematurely if the user has not specified any gloss case equivalents
			if (gbNoGlossCaseEquivalents)
			{
				gbNonSourceIsUpperCase = FALSE; // ensures an old style lookup or store
				gcharNonSrcUC = _T('\0'); // use the value as a test indicating failure here
				return FALSE;
			}
			bIsLower = IsInCaseCharSet(chFirst,gpApp->m_glossLowerCaseChars,nOffset);
		}
		else
		{
			// it's adaptation data
			// exit prematurely if the user has not specified any target case equivalents
			if (gbNoTargetCaseEquivalents)
			{
				gbNonSourceIsUpperCase = FALSE; // ensures an old style lookup or store
				gcharNonSrcUC = _T('\0'); // use the value as a test indicating failure here
				return FALSE;
			}
			bIsLower = IsInCaseCharSet(chFirst,gpApp->m_tgtLowerCaseChars,nOffset);
		}
		if (bIsLower)
		{
			// it's a lower case belonging to the gloss or adaptation set,
			// so we don't have to capitalize it
			gbNonSourceIsUpperCase = FALSE;
			gcharNonSrcLC = chFirst;
			wxASSERT(nOffset >= 0);
			if (gbIsGlossing)
			{
				gcharNonSrcUC = GetOtherCaseChar(gpApp->m_glossUpperCaseChars,nOffset);
			}
			else
			{
				gcharNonSrcUC = GetOtherCaseChar(gpApp->m_tgtUpperCaseChars,nOffset);
			}
		}
		else // it's not lower case...
		{
			// chFirst is not a lower case adaptation or gloss character which has an upper
			// case equivalent, so it might be an upper case adaptation or gloss character
			// (having a lower case equivalent), or it is of indeterminate case - in which case
			// we treat it as lower case
			if (gbIsGlossing)
			{
				bIsUpper = IsInCaseCharSet(chFirst,gpApp->m_glossUpperCaseChars,nOffset);
			}
			else
			{
				bIsUpper = IsInCaseCharSet(chFirst,gpApp->m_tgtUpperCaseChars,nOffset);
			}
			if (bIsUpper)
			{
				// it is an upper case gloss or adaptation char for which there is a lower
				// case equivalent
				gbNonSourceIsUpperCase = TRUE;
				gcharNonSrcUC = chFirst;
				wxASSERT(nOffset >= 0);
				if (gbIsGlossing)
				{
					gcharNonSrcLC = GetOtherCaseChar(gpApp->m_glossLowerCaseChars,nOffset);
				}
				else
				{
					gcharNonSrcLC = GetOtherCaseChar(gpApp->m_tgtLowerCaseChars,nOffset);
				}
			}
			else
			{
				// it has indeterminate case, so treat as lower case with zero as its upper case equiv
				gbNonSourceIsUpperCase = FALSE;
				gcharNonSrcLC = chFirst;
				wxASSERT(nOffset == -1);
				gcharNonSrcUC = _T('\0');
			}
		}
	}
	return TRUE;
}

bool CAdapt_ItView::AutoCapsLookup(MapKeyStringToTgtUnit* pMap, CTargetUnit*& pTU,wxString keyStr)
// in this function, the keyStr parameter will always be a source string; the caller must
// determine which particular map is to be looked up and provide it's pointer as the first
// parameter; and if the lookup succeeds, pTU is the associated CTargetUnit instance's poiner.
// This function, as the name suggests, has the smarts for AutoCapitalization being On or Off.
// WX Note: Changed second parameter to CTargetUnit*& pTU.
{
	bool bOK;
	bOK = FALSE; // unused
	wxString saveKey;
	gbMatchedKB_UCentry = FALSE; // ensure it has default value before every first lookup

	MapKeyStringToTgtUnit::iterator iter;

	// the test of gbCallerIsRemoveButton is to prevent a wrong change to lower case if
	// autocapitalization is on and the user clicked in the KB editor, or in Choose Translation dlg,
	// the Remove button; otherwise the wrong entry could get deleted and the data made invalid
	if (gbAutoCaps && !gbCallerIsRemoveButton)
	{
		if (gbNoSourceCaseEquivalents)
			// this is equivalent to gbAutoCaps being off, so just do a normal lookup
			goto a;

		// auto capitalization is ON, so determine the relevant parameters etc.
		bool bNoError = SetCaseParameters(keyStr); // extra param is TRUE since it is source text
		if (!bNoError)
			goto a; // keyStr must have been empty (impossible) or the user did not define any
					// source language case correspondences
		if (gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
		{
			// we will have to change the case for the first lookup attempt
			saveKey = keyStr; // save for an upper case lookup if the first lookup fails
			// make the first character of keyStr be the appropriate lower case one
			keyStr.SetChar(0,gcharSrcLC); // gcharSrcLC is set within the SetCaseParameters call
			// do the lower case lookup
			iter = pMap->find(keyStr);
			if (iter != pMap->end())
			{
				pTU = iter->second; // we have a match, pTU now points to a CTargetUnit instance
				wxASSERT(pTU != NULL);
				return TRUE;
			}
			// if we get here, then the match failed, so just in case there is an upper case
			// entry in the knowledge base (from when autocapitalization was OFF), look it up;
			// if there, then set the gbMatchedKB_UCentry to TRUE so the caller will know that
			// no restoration of upper case will be required for the gloss or adaptation that
			// it returns
			iter = pMap->find(saveKey);
			if (iter != pMap->end())
			{
				pTU = iter->second; // we have a match, pTU now points to a CTargetUnit instance
				wxASSERT(pTU != NULL);
				// found a match, so we can assume its refStrings contain upper case initial
				// strings already
				gbMatchedKB_UCentry = TRUE;
				return TRUE;
			}
			else
			{
				pTU = (CTargetUnit*)NULL;
				return FALSE;
			}
		}
		else
		{
			// first letter of source word or phrase is lower case, so do a normal lookup
			goto a;
		}
	}
	else
	{
		// auto capitalization is OFF, so just do a lookup with the keyStr as supplied
//a:	bOK = pMap->find(keyStr) != pMap->end();
		// Originally this find() and the two above just had the line above which only
		// indicates if the element was found. The MFC Lookup(keyStr,pObject)
		// actually assigns pObject to point to the actual object when the lookup is
		// successful. Our wx pMap->find(keyStr) doesn't do that so we need to also
		// assign pTU to point to the found object with the following code:
a:		iter = pMap->find(keyStr);
		if (iter != pMap->end())
		{
			pTU = iter->second;
			wxASSERT(pTU != NULL);
			return TRUE;
		}
		else
		{
			pTU = (CTargetUnit*)NULL; //pTU = (wxObject*)NULL;
			return FALSE;
		}
	}
#ifndef __VISUALC__
	return bOK; // unreachable according to VC7.1, but gcc says it is needed!!!
#endif
}

CRefString* CAdapt_ItView::AutoCapsFindRefString(CTargetUnit* pTgtUnit,wxString adaptation)
// the "adaptation" parameter will contain an adaptation if gbIsGlossing is FALSE, or if
// TRUE if will contain a gloss; and also depending on the same flag, the pTgtUnit will have
// come from either the adaptation KB or the glossing KB.
{
	CRefString* pRefStr = (CRefString*)NULL;
	TranslationsList* pList = pTgtUnit->m_pTranslations;
	wxASSERT(pList);
	bool bNoError;
	if (gbAutoCaps && gbSourceIsUpperCase && !gbMatchedKB_UCentry && !adaptation.IsEmpty())
	{
		// possibly we may need to change the case of first character of 'adaptation'
		bNoError = SetCaseParameters(adaptation, FALSE); // FALSE means it is an
														 // adaptation or a gloss
		if (bNoError && gbNonSourceIsUpperCase && (gcharNonSrcLC != _T('\0')))
		{
			// a change to lower case is called for; otherwise leave 'adaptation' unchanged
			adaptation.SetChar(0,gcharNonSrcLC);
		}
	}
	else
	{
		// either autocapitalization is OFF, or the source text starts with a lower case
		// letter, or the first lookup for the key failed but an upper case lookup succeeded
		// (in which case we assume its a old style entry in the KB) or the adaptation string
		// is empty - any of these conditions require that no change of case be done
		;
	}

	TranslationsList::Node *pos = pList->GetFirst();
	while(pos != NULL)
	{
		pRefStr = (CRefString*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pRefStr != NULL);
		if (pRefStr->m_translation == adaptation)
			return pRefStr; // we found it
		else
		{
			if (adaptation.IsEmpty())
			{
				// it might be a <Not In KB> source phrase, check it out
				if (pRefStr->m_translation == _T("<Not In KB>"))
					return pRefStr; // we return the pointer to this too
			}
		}
	}
	// finding it failed so return NULL
	return (CRefString*)NULL;
}

wxString CAdapt_ItView::AutoCapsMakeStorageString(wxString str, bool bIsSrc)
// pass in a source string, to be converted to initial lower case;
// or a gloss or adaptation string which is to be saved to a KB, and internally
// have all the smarts for determining if a change of case for first character is needed,
// and return the string, the same or suitably ammended, back to the caller.
// bIsSrc parameter is TRUE by default.
{
	bool bNoError = TRUE;
	if (str.IsEmpty())
		return str;

	// gbMatchedKB_UCentry is never relevant to storing when gbAutoCaps is on,
	// even if the former is TRUE, we'll still want to convert the source string
	// to have initial lower case when storing
	if (bIsSrc)
	{
		// SetCaseParameters( ) will already have been called, so convert if required to
		if (gbAutoCaps && gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
		{
			str.SetChar(0,gcharSrcLC);
		}
	}
	else
	{
		// must be a gloss or adaptation string
		if (gbAutoCaps && gbSourceIsUpperCase)
		{
			bNoError = SetCaseParameters(str,FALSE);
			if (!bNoError)
				goto a;
			if (gbNonSourceIsUpperCase && (gcharNonSrcLC != _T('\0')))
			{
				// we need to make it start with lower case for storage in the KB
				str.SetChar(0,gcharNonSrcLC);
			}
		}
	}
a:	return str;
}

void CAdapt_ItView::OnAdvancedDelay(wxCommandEvent& WXUNUSED(event))
{
	/*
	// test SyncScrollReceive() code here
	wxString strValue = _T("1JN 2:19");
	wxString strThreeLetterBook;
	wxString strChapVerse;
	int nChapter;
	int nVerse;
	ExtractScriptureReferenceParticulars(strValue,strThreeLetterBook,strChapVerse,nChapter,nVerse);
	bool bSuccess;
	bSuccess = SyncScrollReceive(strThreeLetterBook, nChapter, nVerse, strChapVerse);
	// end of code test
	*/
	CSetDelay dlg(gpApp->GetMainFrame());

	dlg.m_nDelay = gpApp->m_nCurDelay;

	if (dlg.ShowModal() == wxID_OK)
	{
		gpApp->m_nCurDelay = dlg.m_nDelay;

		// update the copy shown on mode bar (it's read only there)
		CMainFrame* pMainFrame = gpApp->GetMainFrame();
		wxASSERT(pMainFrame);
		wxPanel* pControlBar = pMainFrame->m_pControlBar;
		wxASSERT(pControlBar); 
		wxTextCtrl* pDelayBox = (wxTextCtrl*)pControlBar->FindWindowById(IDC_EDIT_DELAY);
		wxASSERT(pDelayBox);
		wxString s;
		s.Empty();
		s << dlg.m_nDelay; //s = buf;
		pDelayBox->SetValue(s);
		pControlBar->Refresh();
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Delay..." item on the Advanced menu is disabled if the application is in Free Translation
/// mode, but enabled if the KB is in a ready state.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedDelay(wxUpdateUIEvent& event)
{
	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_bKBReady)
	{
		event.Enable(TRUE); // always enabled if a project is active
	}
}

// ********************** FREE TRANSLATION MODE SUPPORT **********************************
//
// BEW addition 21Jun05, handlers for free translation supporting buttons in Compose Bar
//
// ***************************************************************************************

void CAdapt_ItView::OnAdvancedFreeTranslationMode(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedMenuFTMode = pMenuBar->FindItem(ID_ADVANCED_FREE_TRANSLATION_MODE);
	wxASSERT(pAdvancedMenuFTMode != NULL);
	gbSuppressSetup = FALSE; // setdefault value

	// determine if the document is unstructured or not -- we'll need this set or cleared
	// as appropriate because in free translation mode the user may elect to end sections
	// at verse breaks - and we can't do that for unstructured data (in the latter case, we'll
	// just end when there is following punctuation on a word or phrase)
	//CAdapt_ItDoc* pDoc = GetDocument();
	SPList* pSrcPhrases = gpApp->m_pSourcePhrases;
	gbIsUnstructuredData = IsUnstructuredData(pSrcPhrases);

	// toggle the setting
	if (gpApp->m_bFreeTranslationMode)
	{
		// toggle the checkmark to OFF
		pAdvancedMenuFTMode->Check(FALSE);
		gpApp->m_bFreeTranslationMode = FALSE;

		// free translation mode is being turned off, so "fix" the current free translation before
		// the gpCurFreeTransSectionPileArray contents are invalidated by the RecalcLayout() call
		// within ComposeBarGuts() below
		StoreFreeTranslationOnLeaving();
	}
	else
	{
		// toggle the checkmark to ON
		pAdvancedMenuFTMode->Check(TRUE);
		gpApp->m_bFreeTranslationMode = TRUE;
	}
	if (gpApp->m_bFreeTranslationMode)
	{
		// put the target punctuation character set into gSpacelessTgtPunctuation to be used
		// in the HasWordFinalPunctuation() function to work out when to end a span of free
		// translation (can't put this after the ComposeBarGuts() call because the latter calls
		// SetupCurrentFreeTransSection(), and it needs gSpacelessTgtPunctuation set up beforehand)
		gSpacelessTgtPunctuation = gpApp->m_punctuation[1]; // target set, with delimiting spaces
		gSpacelessTgtPunctuation.Remove(gSpacelessTgtPunctuation.Find(_T(' ')),1); // get rid of the spaces
	}

	// restore focus to the targetBox, if free translation mode was just turned off,
	// else to the CEdit in the Compose Bar because it has just been turned on -- providing the
	// box or bar is visible and its handle exists
	pFrame->ComposeBarGuts(); // open or close the Compose Bar (it does a RecalcLayout() call, so
							  // if turning off free translation mode, the gpCurFreeTransSectionPileArray
							  // array will store hanging pointers, so don't use it below

	if (gpApp->m_bFreeTranslationMode)
	{
		// free translation mode was just turned on. The phrase box might happen to be located within
		// a previously composed section of free translation, but not at that section's anchor point, so
		// we must check for this and if so, iterate back over the piles until we get to the anchor point -
		// but we may come to the start of the bundle before we get there, so we have to do a bundle
		// retreat in that event - all this is handled in the block below (comments will be minimal because
		// this code is taken from the fully commented code for doing the same, in OnLButtonDown())
		CPile* pPile = gpApp->m_pActivePile; // current box location
		CSourcePhrase* pSP = pPile->m_pSrcPhrase;
		CKB* pKB;
		if (gbIsGlossing)
			pKB = gpApp->m_pGlossingKB;
		else
			pKB = gpApp->m_pKB;
		if (pSP->m_bHasFreeTrans && !pSP->m_bStartFreeTrans)
		{
			// save the phrase box text to the KB
			bool bOK;
			bOK = StoreTextGoingBack(pKB,pSP,gpApp->m_targetPhrase); // store, so we can forget this location
		}
		while (pSP->m_bHasFreeTrans && !pSP->m_bStartFreeTrans)
		{
			// iterate backwards to the anchor pile
			CPile* pPrevPile = GetPrevPile(pPile);
			if (pPrevPile == NULL)
			{
				// a bundle retreat is needed
				int sn = pSP->m_nSequNumber;
				pPrevPile = RetreatBundle(sn);
				wxASSERT(pPrevPile);
				gpApp->m_targetPhrase.Empty();
				pPile = pPrevPile;
				gpApp->GetMainFrame()->canvas->ScrollIntoView(sn); //gpApp->GetMainFrame()->canvas->ScrollToNearTop(sn);
			}
			else
			{
				pPile = pPrevPile;
			}
			pSP = pPile->m_pSrcPhrase;
		}
		// we are at the anchor location
		gpApp->m_pActivePile = pPile;
		gpApp->m_nActiveSequNum = pPile->m_pSrcPhrase->m_nSequNumber;
		gpApp->m_curIndex = gpApp->m_nActiveSequNum;

		// BEW changed 15Oct05; since if we have an adaptation there different than the source text
		// we want to preserve it, rather than unilaterally just use m_key; and if the member is
		// empty, then leave the box empty rather than have the source copied in free translation mode
		if (gbIsGlossing)
		{
			if (pSP->m_gloss.IsEmpty())
			{
				gpApp->m_targetPhrase.Empty();
			}
			else
			{
				gpApp->m_targetPhrase = pSP->m_gloss;
			}
		}
		else
		{
			if (pSP->m_adaption.IsEmpty())
			{
				gpApp->m_targetPhrase.Empty();
			}
			else
			{
				gpApp->m_targetPhrase = pSP->m_adaption;
			}
		}
		translation = gpApp->m_targetPhrase; // in case we just unmerged, since a PlacePhraseBox() call with
									  // selector == 1 or 3 will set m_targetPhrase to whatever is
									  // currently in the global string translation when it jumps the
									  // block of code for removing the new location's entry from the KB
		CCell* pCell = pPile->m_pCell[2]; // need this for the PlacePhraseBox() call
		PlacePhraseBox(pCell,1); // 1 = inhibit saving at old location, as we did it above instead, and
								 // also don't remove the new location's KB entry (as the phrase box is disabled)
		gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

		// now put the focus in the Compose Bar's edit box, and disable the phrase box for clicks & editing,
		// and make it able to right justify and render RTL if we are in the Unicode app
		if (pFrame->m_pComposeBar->GetHandle() != NULL)
			if (pFrame->m_pComposeBar->IsShown())
			{
				#ifdef _RTL_FLAGS
					// enable complex rendering
					if (gpApp->m_bTgtRTL)
					{
						pFrame->m_pComposeBarEditBox->SetLayoutDirection(wxLayout_RightToLeft);
					}
					else
					{
						pFrame->m_pComposeBarEditBox->SetLayoutDirection(wxLayout_LeftToRight);
					}
				#endif
				pFrame->m_pComposeBarEditBox->SetFocus();
			}

		// prevent clicks and editing being done in phrase box (do also in ResizeBox())
		if (gpApp->m_pTargetBox->IsShown() && gpApp->m_pTargetBox->GetHandle() != NULL)
			gpApp->m_pTargetBox->SetEditable(FALSE);
		gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber);

		// get any removed free translations in gEditRecord into the GUI list
		bool bAllsWell;
		bAllsWell = PopulateRemovalsComboBox(freeTranslationsStep, &gEditRecord);
	}
	else
	{
		// if the user exits the mode while the phrase box is within a retranslation, we
		// don't want the box left there (though the app would handle it just fine, no crash
		// or other problem), so check for this and if so, move the active location to
		// a safe place nearby
		int numSrcPhrases;
		int nCountForwards = 0;
		int nCountBackwards = 0;
		int nSaveActiveSequNum;
		if (gpApp->m_pActivePile->m_pSrcPhrase->m_bRetranslation)
		{
			// we have to move the box
			CSourcePhrase* pSrcPhr = gpApp->m_pActivePile->m_pSrcPhrase;
			SPList::Node* pos = pSrcPhrases->Find(pSrcPhr);
			wxASSERT(pos);
			SPList::Node* savePos = pos;
			if (pSrcPhr->m_bBeginRetranslation)
			{
				// we are at the start of the section
				nCountForwards = 1;
				pSrcPhr = (CSourcePhrase*)pos->GetData(); // counted this one
				pos = pos->GetNext();
				while (pos != NULL)
				{
					pSrcPhr = (CSourcePhrase*)pos->GetData();
					pos = pos->GetNext();
					nCountForwards++;
					if (pSrcPhr->m_bEndRetranslation)
						break;
				}
				nSaveActiveSequNum = pSrcPhr->m_nSequNumber + 1;
				numSrcPhrases = nCountForwards;
			}
			else if (pSrcPhr->m_bEndRetranslation)
			{
				nSaveActiveSequNum = pSrcPhr->m_nSequNumber + 1;
				nCountBackwards = 1;
				pSrcPhr = (CSourcePhrase*)pos->GetData(); // counted this one
				pos = pos->GetPrevious();
				while (pos != NULL)
				{
					pSrcPhr = (CSourcePhrase*)pos->GetData();
					pos = pos->GetPrevious();
					nCountBackwards++;
					if (pSrcPhr->m_bBeginRetranslation)
						break;
				}
				numSrcPhrases = nCountBackwards;
			}
			else
			{
				// somewhere in the middle of the retranslation span
				nCountForwards = 1;
				pSrcPhr = (CSourcePhrase*)pos->GetData(); // counted this one
				pos = pos->GetNext();
				while (pos != NULL)
				{
					pSrcPhr = (CSourcePhrase*)pos->GetData();
					pos = pos->GetNext();
					nCountForwards++;
					if (pSrcPhr->m_bEndRetranslation)
						break;
				}
				nSaveActiveSequNum = pSrcPhr->m_nSequNumber + 1;
				pos = savePos; // restore original position
				nCountBackwards = 0;
				pSrcPhr = (CSourcePhrase*)pos->GetData(); // already counted
				pos = pos->GetPrevious();
				while (pos != NULL)
				{
					pSrcPhr = (CSourcePhrase*)pos->GetData();
					pos = pos->GetPrevious();
					nCountBackwards++;
					if (pSrcPhr->m_bBeginRetranslation)
						break;
				}
				numSrcPhrases = nCountForwards + nCountBackwards;
			}
			bool bOK;
			bOK = SetActivePilePointerSafely(gpApp,pSrcPhrases,nSaveActiveSequNum,gpApp->m_nActiveSequNum,
											numSrcPhrases);
		}

		translation.Empty(); // don't preserve anything from a former adaptation state
		if (gpApp->m_pTargetBox->GetHandle() != NULL)
			if (gpApp->m_pTargetBox->IsShown())
				gpApp->m_pTargetBox->SetFocus();

		// allow clicks and editing to be done in phrase box (do also in ResizeBox())
		if (gpApp->m_pTargetBox->IsShown() && gpApp->m_pTargetBox->GetHandle() != NULL)
			gpApp->m_pTargetBox->SetEditable(TRUE);

		// get any removed adaptations in gEditRecord into the GUI list, if the restored state
		// is adapting mode; if glossing mode, get the removed glosses into the GUI list
		bool bAllsWell;
		if (gbIsGlossing)
			bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
		else
			bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);
	}
}

void CAdapt_ItView::ToggleFreeTranslationMode()
{
	if (gbVerticalEditInProgress)
	{

		CMainFrame* pFrame = gpApp->GetMainFrame(); //(CMainFrame*)GetParentFrame();
		wxASSERT(pFrame != NULL);
		//CMenu* pTopLevelMenu = pFrame->GetMenu();
		//CMenu* pAdvancedMenu = pTopLevelMenu->GetSubMenu(4);
		wxMenuBar* pMenuBar = gpApp->GetMainFrame()->GetMenuBar();
		wxASSERT(pMenuBar != NULL);
		wxMenuItem * pAdvancedFreeTranslation = pMenuBar->FindItem(ID_ADVANCED_FREE_TRANSLATION_MODE);
		wxASSERT(pAdvancedFreeTranslation != NULL);
		gbSuppressSetup = FALSE; // setdefault value

		// determine if the document is unstructured or not -- we'll need this set or cleared
		// as appropriate because in free translation mode the user may elect to end sections
		// at verse breaks - and we can't do that for unstructured data (in the latter case, we'll
		// just end when there is following punctuation on a word or phrase)
		//CAdapt_ItDoc* pDoc = GetDocument();
		SPList* pSrcPhrases = gpApp->m_pSourcePhrases;
		gbIsUnstructuredData = IsUnstructuredData(pSrcPhrases);

		// toggle the setting
		if (gpApp->m_bFreeTranslationMode)
		{
			// toggle the checkmark to OFF
			pAdvancedFreeTranslation->Check(FALSE);
			gpApp->m_bFreeTranslationMode = FALSE;
		}
		else
		{
			// toggle the checkmark to ON
			pAdvancedFreeTranslation->Check(TRUE);
			gpApp->m_bFreeTranslationMode = TRUE;
		}
		if (gpApp->m_bFreeTranslationMode)
		{
			// put the target punctuation character set into gSpacelessTgtPunctuation to be used
			// in the HasWordFinalPunctuation() function to work out when to end a span of free
			// translation (can't put this after the ComposeBarGuts() call because the latter calls
			// SetupCurrentFreeTransSection(), and it needs gSpacelessTgtPunctuation set up beforehand)
			gSpacelessTgtPunctuation = gpApp->m_punctuation[1]; // target set, with delimiting spaces
			gSpacelessTgtPunctuation.Replace(_T(" "),_T("")); // get rid of the spaces
		}	

		// restore focus to the targetBox, if free translation mode was just turned off, 
		// else to the CEdit in the Compose Bar because it has just been turned on -- providing the
		// box or bar is visible and its handle exists
		pFrame->ComposeBarGuts(); // open or close the Compose Bar

		if (gpApp->m_bFreeTranslationMode)
		{
			// free translation mode was just turned on.

			// put the focus in the Compose Bar's edit box, and disable the phrase box for clicks & editing,
			// and make it able to right justify and render RTL if we are in the Unicode app
			if (pFrame->m_pComposeBar != NULL)
				if (pFrame->m_pComposeBar->IsShown())
				{
					#ifdef _RTL_FLAGS
						// enable complex rendering
						if (gpApp->m_bTgtRTL)
						{
							pFrame->m_pComposeBar->SetLayoutDirection(wxLayout_RightToLeft);
							//lAlign ^= WS_EX_RIGHT;
							//lAlign ^= WS_EX_RTLREADING;
						}
						else
						{
							pFrame->m_pComposeBar->SetLayoutDirection(wxLayout_LeftToRight);
							//lAlign &= ~(WS_EX_RIGHT | WS_EX_RTLREADING);
						}
					#endif
					pFrame->m_pComposeBar->SetFocus();
				}

			// prevent clicks and editing being done in phrase box (do also in CreateBox())
			if (gpApp->m_pTargetBox->IsShown())
				gpApp->m_pTargetBox->Enable(FALSE);
			gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber); //ScrollToNearTop(m_pActivePile->m_pSrcPhrase->m_nSequNumber);

			// get any removed free translations in gEditRecord into the GUI list
			bool bAllsWell;
			bAllsWell = PopulateRemovalsComboBox(freeTranslationsStep, &gEditRecord);
		}
		else
		{
			// free translation mode was just turned off

			translation.Empty(); // don't preserve anything from a former adaptation state
			if (gpApp->m_pTargetBox->IsShown())
			{
				// MFC version had SetFocus first then Enable, but I think in wx it should be reverse
				gpApp->m_pTargetBox->Enable(TRUE);
				gpApp->m_pTargetBox->SetFocus();
			}

			// get any removed adaptations in gEditRecord into the GUI list, if the restored state
			// is adapting mode; if glossing mode, get the removed glosses into the GUI list
			bool bAllsWell;
			if (gbIsGlossing)
				bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
			else
				bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);
		}
	}
}


// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Free Translation Mode" item on the Advanced menu is disabled if the active pile pointer is NULL,
/// or the application is only showing the target text, or there are no source phrases in the App's
/// m_pSourcePhrases list. But, if m_curIndex is within a valid range and the composeBar was not
/// already opened for another purpose (called from the View), the menu item is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedFreeTranslationMode(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	// the !gpApp->m_bComposeBarWasAskedForFromViewMenu test makes sure we don't try to
	// invoke free translation mode while the user already has the Compose Bar open for
	// another purpose
	if (gpApp->m_curIndex <= (int)gpApp->m_pSourcePhrases->GetCount() - 1 && gpApp->m_curIndex >= 0
		&& !gpApp->m_bComposeBarWasAskedForFromViewMenu)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAdvancedTargetTextIsDefault(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem* pAdvancedMenuTTextDft = pMenuBar->FindItem(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT);
	wxMenuItem* pAdvancedMenuGTextDft = pMenuBar->FindItem(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT);
	wxASSERT(pAdvancedMenuTTextDft != NULL);
	wxASSERT(pAdvancedMenuGTextDft != NULL);

	// toggle the setting
	if (gpApp->m_bTargetIsDefaultFreeTrans)
	{
		// toggle the checkmark to OFF
		pAdvancedMenuTTextDft->Check(FALSE);
		gpApp->m_bTargetIsDefaultFreeTrans = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pAdvancedMenuTTextDft->Check(TRUE);
		gpApp->m_bTargetIsDefaultFreeTrans = TRUE;

		// and ensure the glossing text command is off, and its flag cleared
		pAdvancedMenuGTextDft->Check(FALSE);
		gpApp->m_bGlossIsDefaultFreeTrans = FALSE;
	}

	// restore focus to the Compose Bar
	if (pFrame->m_pComposeBar->GetHandle() != NULL)
		if (pFrame->m_pComposeBar->IsShown())
			pFrame->m_pComposeBarEditBox->SetFocus();
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Use Target Text As Default Free Translation" item on the Advanced menu is disabled if the
/// application is not in Free Translation mode, or if the active pile pointer is NULL, or if there 
/// are no source phrases in the App's m_pSourcePhrases list. But, if m_curIndex is within a valid range 
/// and the composeBar was not already opened for another purpose (called from the View), the menu item 
/// is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedTargetTextIsDefault(wxUpdateUIEvent& event)
{
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (!gpApp->m_bFreeTranslationMode) // whm added 23Jan07 to wx version
	{
		// The Advanced menu item "Use Target Text As Default Free Translation" should be
		// disabled when the app is not in Free Translation Mode.
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_curIndex <= (int)gpApp->m_pSourcePhrases->GetCount() - 1 && gpApp->m_curIndex >= 0
		&& !gpApp->m_bComposeBarWasAskedForFromViewMenu)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAdvancedGlossTextIsDefault(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem* pAdvancedMenuTTextDft = pMenuBar->FindItem(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT);
	wxMenuItem* pAdvancedMenuGTextDft = pMenuBar->FindItem(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT);
	wxASSERT(pAdvancedMenuTTextDft != NULL);
	wxASSERT(pAdvancedMenuGTextDft != NULL);

	// toggle the setting
	if (gpApp->m_bGlossIsDefaultFreeTrans)
	{
		// toggle the checkmark to OFF
		pAdvancedMenuGTextDft->Check(FALSE);
		gpApp->m_bGlossIsDefaultFreeTrans = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pAdvancedMenuGTextDft->Check(TRUE);
		gpApp->m_bGlossIsDefaultFreeTrans = TRUE;

		// ensure the target text command is toggled off (if it was on), and its flag
		pAdvancedMenuTTextDft->Check(FALSE);
		gpApp->m_bTargetIsDefaultFreeTrans = FALSE;

	}

	// restore focus to the Compose Bar
	if (pFrame->m_pComposeBar->GetHandle() != NULL)
		if (pFrame->m_pComposeBar->IsShown())
			pFrame->m_pComposeBarEditBox->SetFocus();
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Use Gloss Text As Default Free Translation" item on the Advanced menu is disabled if the
/// application is not in Free Translation mode, or if the active pile pointer is NULL, or if there 
/// are no source phrases in the App's m_pSourcePhrases list. But, if m_curIndex is within a valid range 
/// and the composeBar was not already opened for another purpose (called from the View), the menu item 
/// is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedGlossTextIsDefault(wxUpdateUIEvent& event)
{
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (!gpApp->m_bFreeTranslationMode) // whm added 23Jan07 to wx version
	{
		// The Advanced menu item "Use Gloss Text As Default Free Translation" should be
		// disabled when the app is not in Free Translation Mode.
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_curIndex <= (int)gpApp->m_pSourcePhrases->GetCount() - 1 && gpApp->m_curIndex >= 0
		&& !gpApp->m_bComposeBarWasAskedForFromViewMenu)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnRadioDefineByPunctuation(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pBar = pFrame->m_pComposeBar;
	wxASSERT(pBar != NULL);
	if(pBar != NULL && pBar->IsShown())
	{
		// FindWindow() finds a child of the current window
		wxRadioButton* pRPSButton = (wxRadioButton*)pBar->FindWindow(IDC_RADIO_PUNCT_SECTION);
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pRPSButton != 0)
		{
			// set the radio button's BOOL to be TRUE
			gpApp->m_bDefineFreeTransByPunctuation = TRUE;
			
			// whm: previous wx code:
			//pRPSButton->SetValue(TRUE);
			//wxRadioButton* pRVSButton = (wxRadioButton*)pBar->FindWindow(IDC_RADIO_VERSE_SECTION);
			//wxASSERT(pRVSButton != NULL);
			//pRVSButton->SetValue(FALSE);
			
			// BEW added 1Oct08: to have the butten click remove the current section and
			// reconstitute it as a Verse-based section
			gbSuppressSetup = FALSE;
			wxCommandEvent evt;
			OnRemoveFreeTranslationButton(evt); // remove current section and any Compose bar edit box test
			// the OnRemoveFreeTranslationButton() call calls Invalidate()
			
			// To get SetupCurrenetFreeTranslationSection() called, we must call RecalcLayout()
			// with gbSuppressSetup == FALSE, then the section will be resized smaller
			RecalcLayout(gpApp->m_pSourcePhrases,0,gpApp->m_pBundle);
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;
			RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);

			// restore focus to the edit box
			pEdit->SetFocus();
		}
	}
}

void CAdapt_ItView::OnRadioDefineByVerse(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame* pMainFrm = gpApp->GetMainFrame();
	wxASSERT(pMainFrm != NULL);
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	wxASSERT(pBar != NULL);
	if(pBar != NULL && pBar->IsShown())
	{
		wxRadioButton* pRVSButton = (wxRadioButton*)pBar->FindWindow(IDC_RADIO_VERSE_SECTION);
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pRVSButton != 0)
		{
			// set the radio button's BOOL to be TRUE
			gpApp->m_bDefineFreeTransByPunctuation = FALSE;
			
			// whm: previous wx code:
			//pRVSButton->SetValue(TRUE);
			//wxRadioButton* pRPSButton = (wxRadioButton*)pBar->FindWindow(IDC_RADIO_PUNCT_SECTION);
			//wxASSERT(pRPSButton != NULL);
			//pRPSButton->SetValue(FALSE);
			// BEW added 1Oct08: to have the butten click remove the current section and
			// reconstitute it as a Verse-based section
			gbSuppressSetup = FALSE;
			wxCommandEvent evt;
			OnRemoveFreeTranslationButton(evt); // remove current section and any Compose bar edit box test
			// the OnRemoveFreeTranslationButton() call calls Invalidate()

			// To get SetupCurrenetFreeTranslationSection() called, we must call RecalcLayout()
			// with gbSuppressSetup == FALSE, then the section will be resized larger
			RecalcLayout(gpApp->m_pSourcePhrases,0,gpApp->m_pBundle);
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;
			RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);

			// restore focus to the edit box
			pEdit->SetFocus();
		}
	}
}

/**********************************************************************
*  StoreFreeTranslation
*
* Returns: nothing
*
* Parameters:
*	pPileArray		->	pointer to the array of piles which comprise the current section which
*						is to have its free translation stored as a filtered \free ... \free*
*						marker section within the m_markers member of the pSrcPhrase at the
*						anchor location (ie. at pFirstPile's sourcephrase)
*	pFirstPile		<-	pointer to the first pile in this free translation section
*	pLastPile		<-	pointer to the last pile in this free translation section
*	whm 23Aug06 added the following parameters:
*	editBoxContents ->	enum value can be remove_editbox_contents or retain_editbox_contents.
*						When remove_editbox_contents the source phrase's flags are adjusted
*						and pPileArray is emptied; otherwise (during mere editing stores) the
*						flags and pPileArray are not changed.
*	storeStr		->	const ref string containing the free trans string to store in m_markers
* Remarks:
*	Gets the free translation text from the Compose Bar's edit box via the global CString
*	gFreeTranslationStr, constructs the bracketed filtered string and inserts it in the
*	m_markers member of the CSourcePhrase instance at the anchor pile, and returns pointers
*	to the first and last piles in the section so that the buttons <Prev, Next> or Advance can
*	obtain the jumping off place for the movement back or forwards.
*	whm clarification: In the MFC version, StoreFreeTranslation got the free translation text
*	directly from the composebar's edit box, and not via the global CString gFreeTranslationStr.
*	The MFC version originally set the value of gFreeTranslationStr here from what it found in
*	the edit box, but with my revision StoreFreeTranslation always gets the string to be stored
*	from the input parameter storeStr.
*
***********************************************************************/
void CAdapt_ItView::StoreFreeTranslation(wxArrayPtrVoid* pPileArray,CPile*& pFirstPile,CPile*& pLastPile,
					enum EditBoxContents editBoxContents, const wxString& storeStr)
{
	CMainFrame* pMainFrm = gpApp->GetMainFrame();
	wxASSERT(pMainFrm);
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	wxASSERT(pBar);
	if (pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			// get the box's current contents & remove spaces at end or start (one will be added
			// by the InsertFilteredMaterial() call, at the end of the string, automatically, if there
			// is not already one at the end of the string)
			
			// whm changed 23Aug06. We now get the string to be stored as parameter to StoreFreeTranslation
			// we can probably get rid of the gFreeTranslationStr, gnOffsetInMarkersStr, and
			// gnLengthInMarkersStr globals, but I'll leave the gFreeTranslationStr assignment here
			// until that happens.
			wxString mkr = _T("\\free");
			wxString endMkr = _T("\\free*");
			pFirstPile = (CPile*)pPileArray->Item(0);
			// call GetExistingMarkerContent to get offset and length
			wxString tempStr = GetExistingMarkerContent(mkr,endMkr,pFirstPile->m_pSrcPhrase,
				gnOffsetInMarkersStr,gnLengthInMarkersStr);
			tempStr.Trim(FALSE); // trim left end 
			tempStr.Trim(TRUE); // trim right end

			// remove the earlier free translation text from m_markers, if there was any
			CPile* pPile;
			pPile = pFirstPile; // pointer retrieved above pPile = (CPile*)(*pPileArray)[0];
			wxString markers = pPile->m_pSrcPhrase->m_markers;
			if (!markers.IsEmpty())
			{
				// delete only the text, leave the markers there
				if (gnLengthInMarkersStr > 0)
				{
					markers.Remove(gnOffsetInMarkersStr,gnLengthInMarkersStr); 
					gnLengthInMarkersStr = 0;
					gnOffsetInMarkersStr = 0;
				}
			}

			// find the insertion point (this works, regardless of what may have happened above) and
			// update with the new content for the free translation
			int nFreeTransInsertionOffset = FindFilteredInsertionLocation(markers, mkr); 
			pPile->m_pSrcPhrase->m_markers = markers; // update with the prepared string
			wxASSERT(nFreeTransInsertionOffset >= 0); 
			bool bContainsFreeTrans = ContainsFreeTranslation(pPile); // TRUE if m_markers contains \free already
			// whm revision: InsertFilteredMaterial now always uses storeStr instead of gFreeTranslationStr.
			// It also uses a local nFreeTransInsertionOffset rather than the otherwise unused
			// gnFreeTransInsertionOffset.
			InsertFilteredMaterial(mkr, endMkr, storeStr /*gFreeTranslationStr*/, pPile->m_pSrcPhrase,
											nFreeTransInsertionOffset /*gnFreeTransInsertionOffset*/, bContainsFreeTrans);

			// whm added 22Aug06 the test below to remove or retain the contents of the
			// composebar's edit box and the items in pPileArray. The contents of the edit box
			// is cleared if the enum is remove_editbox_contents. The test evaluates to true
			// when StoreFreeTranslation is called from OnNextButton(), OnPrevButton() or
			// OnAdvanceButton(). It is false when called from the ComposeBarEditBox's
			// OnEditBoxChanged() handler where StoreFreeTranslation is merely storing real-time
			// edits of the string.
			if (editBoxContents == remove_editbox_contents)
			{
				// mark this sourcephrase appropriately
				// whm note: The source phrase's flags only need updating when
				// StoreFreeTranslation is called from the view's free translation
				// navigation button handlers.
				pPile->m_pSrcPhrase->m_bHasFreeTrans = TRUE;
				pPile->m_pSrcPhrase->m_bStartFreeTrans = TRUE;
				pPile->m_pSrcPhrase->m_bEndFreeTrans = FALSE;

				// clear the compose bar's edit box too, otherwise default text at the next location can't
				// be composed even if wanted
				wxString tempStr;
				tempStr.Empty(); //FreeTranslationStr.Empty();
				// whm changed 24Aug06 - update edit box with updated string
				pEdit->SetValue(tempStr);

				pPileArray->RemoveAt(0); // first is dealt with

				// do a reality check on m_markers - I noticed that the test document had sometimes an
				// m_markers string ending with a SF marker, and no trailing space. The space should be
				// present - so if we detect this, we can do an automatic silent correction now (I also do
				// this when saving a note in OK button's handler)
				int markersLen = pPile->m_pSrcPhrase->m_markers.Length();
				if (markersLen >= 2)
				{
					// at least a backslash and a single character should be present, otherwise don't bother
					if (pPile->m_pSrcPhrase->m_markers.GetChar(markersLen - 1) != _T(' '))
					{
						pPile->m_pSrcPhrase->m_markers += _T(' ');
					}
				}

				// if we are at the end of the document, our Adavance will not be fruitful, so we'll just want
				// to be able to automatically replace the phrase box here - and beep to alert the user that
				// the Advance failed.
				pFirstPile = gpApp->m_pActivePile; // this should remain valid if we are at doc end already

				// now handle the rest in the array
				int lastIndex = 0;
				pLastPile = pPile; // default
				int nSize = pPileArray->GetCount(); 

				// if nSize is now 0, then there was only the one pSrcPhrase in the section, and so that one
				// has to be given m_bEndFreeTrans = TRUE value too
				if (nSize == 0)
				{
					pPile->m_pSrcPhrase->m_bEndFreeTrans = TRUE;
					return;
				}
				// if there is more than one pile pointer in the array, then there is at least another one
				// needing to be dealt with
				if (nSize > 0)
				{
					lastIndex = nSize - 1;
					pPile = (CPile*)(*pPileArray)[lastIndex];
					pLastPile = pPile; // we can step ahead from here, the last one, in the caller
					pPile->m_pSrcPhrase->m_bEndFreeTrans = TRUE;
					pPile->m_pSrcPhrase->m_bHasFreeTrans = TRUE;
					pPile->m_pSrcPhrase->m_bStartFreeTrans = FALSE;
					pPileArray->RemoveAt(lastIndex); // dealt with the last one
					nSize--;
				}
				// finally, any other pile pointers which are neither the first or last - set the flags
				// appropriately
				if (nSize > 0)
				{
					int index;
					CPile* ptrPile;
					for (index = 0; index < nSize; index++)
					{
						ptrPile = (CPile*)(*pPileArray)[index];
						ptrPile->m_pSrcPhrase->m_bEndFreeTrans = FALSE;
						ptrPile->m_pSrcPhrase->m_bStartFreeTrans = FALSE;
						ptrPile->m_pSrcPhrase->m_bHasFreeTrans = TRUE;
					}
					pPileArray->Clear();
				}
			} // end of if (editBoxContents == remove_editbox_contents)
		}
	}
}

// the following is based on StoreFreeTranslation() and OnPrevButton() but tweaked for use at the point
// in the vertical edit process where control is about to leave the freeTranslationsStep and so the
// current free translation needs to be made to 'stick'
void CAdapt_ItView::StoreFreeTranslationOnLeaving()
{
	CMainFrame *pFrame = gpApp->GetMainFrame(); //CFrameWnd* pMainFrm = GetParentFrame();
	wxASSERT(pFrame != NULL);
	//CWnd* pBar;
	// whm: In wx the composeBar is created when the app runs and is always there but may
	// be hidden.
	//if((pBar = pMainFrm->GetDlgItem(IDD_COMPOSE_BAR)) != NULL)
	if (pFrame->m_pComposeBar != NULL)
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			CPile* pOldActivePile = gpApp->m_pActivePile;

			// do this store unilaterally, as we can make the free translation 'stick' by calling
			// this function also in the OnAdvancedFreeTranslationMode() hander, when leaving
			// free translation mode & not in vertical edit process, as well as when we are

			// do the save & pointer calculation in the StoreFreeTranslation() call
			if (gpCurFreeTransSectionPileArray->GetCount() > 0)
			{
				CPile* saveLastPilePtr = 
					(CPile*)gpCurFreeTransSectionPileArray->Item(gpCurFreeTransSectionPileArray->GetCount()-1);
				wxString editedText;
				editedText = pEdit->GetValue();

				StoreFreeTranslation(gpCurFreeTransSectionPileArray,pOldActivePile,saveLastPilePtr,
					remove_editbox_contents, editedText);
			}

			// make sure the kb entry flag is set correctly
			CSourcePhrase* pSrcPhr = pOldActivePile->m_pSrcPhrase;
			FixKBEntryFlag(pSrcPhr);
		}
	}
}

// handler for the IDC_APPLY_BUTTON, renamed Advance after first being called Apply
void CAdapt_ItView::OnAdvanceButton(wxCommandEvent& event)
{
	// BEW added 19Oct06; if the ENTER key is pressed when not in Free Translation mode and focus is in
	// the compose bar then it would invoke the OnAdvanceButton() handler even though the button is hidden,
	// so we  prevent this by detecting when it happens and exiting without doing anything.
	if (gpApp->m_bComposeBarWasAskedForFromViewMenu)
	{
		// compose bar is open, but not in Free Translation mode, so we must ignore an ENTER keypress,
		// and also return the focus to the compose bar's edit box
		CMainFrame *pFrame;
		pFrame = gpApp->GetMainFrame();
		wxTextCtrl* pEdit;
		wxASSERT(pFrame != NULL); 
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE); 
		wxASSERT(pEdit != NULL);
		wxString str;
		str = pEdit->GetValue();
		int len = str.Length();
		pEdit->SetFocus();
		pEdit->SetSelection(len,len); 
		return;
	}

	// In FT mode and if also in Review mode, the Advance button should not move the user a long way ahead
	// to an empty section, instead it should act like the phrase box does in this mode, hence it instead
	// invokes the handler for the Next> button, which makes the immediate next section the current one
	if (!gpApp->m_bDrafting)
	{
		OnNextButton(event);
		return;
	}

	// only do the following code when in Drafting mode
	gbSuppressSetup = FALSE; // restore default value, in case Shorten or Lengthen buttons were used

	CMainFrame* pMainFrm = gpApp->GetMainFrame();
	wxPanel* pBar = pMainFrm->m_pComposeBar; 
	if(pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			CPile* pOldActivePile = gpApp->m_pActivePile;
			CPile* saveLastPilePtr = gpApp->m_pActivePile; // a safe default

			// BEW added 29Apr06; to suppress the store immediately after the user has removed the
			// filtered free translation from the current location using the button for that purpose
			// in the View Filtered Material dialog
			//if (gbFreeTranslationJustRemovedInVFMdialog)
			//{
			//	// calculate the pointers here instead, and don't do the save & pointer calculation
			//	// in the StoreFreeTranslation() call
			//	pOldActivePile = m_pActivePile;
			//	saveThisPilePtr = 
			//		(CPile*)gpCurFreeTransSectionPileArray->GetAt(gpCurFreeTransSectionPileArray->GetSize()-1);
			//}
			//else
			//{
			//	// whm added 24Aug06 passing of current edits to StoreFreeTranslation() via parameter
			//	// along with enum remove_editbox_contents to maintain legacy behavior when called from
			//	// this handler
			//	CString editedText;
			//	pEdit->GetWindowText(editedText);
			//	StoreFreeTranslation(gpCurFreeTransSectionPileArray,pOldActivePile,saveThisPilePtr,
			//		remove_editbox_contents, editedText);
			//}
			// The current free translation was not just removed so do the StoreFreeTranslation() call
			if (gpCurFreeTransSectionPileArray->GetCount() > 0)
			{
				// whm added 24Aug06 passing of current edits to StoreFreeTranslation() via 
				// the editedText parameter along with enum remove_editbox_contents to maintain 
				// legacy behavior when called from this handler
				saveLastPilePtr =
					(CPile*)gpCurFreeTransSectionPileArray->Item(gpCurFreeTransSectionPileArray->GetCount()-1);
				if (!gbFreeTranslationJustRemovedInVFMdialog)
				{
					wxString editedText;
					editedText = pEdit->GetValue();
					StoreFreeTranslation(gpCurFreeTransSectionPileArray,pOldActivePile,saveLastPilePtr,
						remove_editbox_contents, editedText);
				}
			}

			// make sure the active location we are about to leave has the correct value for
			// m_bHasKBEntry (or m_bHasGlossingKBEntry if we are in glossing mode) set
			CSourcePhrase* pSrcPhr = pOldActivePile->m_pSrcPhrase;
			FixKBEntryFlag(pSrcPhr);

			// get the next pile which does not have any free translation yet
			CPile* pPile = GetNextPile(saveLastPilePtr);

			if (pPile == NULL)
			{
				// we are probably at the end of the bundle, but maybe at the end of the document
				// so if the former then advance the bundle etc.
				if (saveLastPilePtr->m_pSrcPhrase->m_nSequNumber == gpApp->m_maxIndex)
				{
					// we are already at the end of the doc, so cannot Advance. So leave this section
					// current, and beep to tell the user
b:					::wxBell(); //MessageBeep(0);

					if (gbVerticalEditInProgress)
					{
						// force transition to next step
						bool bCommandPosted;
						bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(-1, nextStep, TRUE);
						// TRUE is bForceTransition
						return;
					}
					// make it 'stick' before returning
					StoreFreeTranslationOnLeaving();
					return;
				}
				else
				{
					// not at the end of the doc, just at the end of the bundle - so advance it...

					// however, if in vertical edit mode, then the free translation span lies within
					// the bundle by definition, so we must force a transition to next step, and
					// make sure the current section 'sticks'
					if (gbVerticalEditInProgress)
					{
						bool bCommandPosted;
						bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(-1, nextStep, TRUE);
						// TRUE is bForceTransition
						return;
					}

					// BEW modified 07Oct05: beware, advances call RecalcLayout() and since we are in
					// free translation mode there will be a call at the end of the latter to the
					// SetupCurrentFreeTranslationSection() which we don't want (and it too does a
					// RecalcLayout() & if the active sequ number isn't advanced too, which would undo the
					// earlier advance!) but we can suppress this call by setting gbSuppressSetup to
					// TRUE - but we must, once we've done the advance, turn it back off so that if
					// the empty location we are searching for is found, we can then do the setup there
					int sn = saveLastPilePtr->m_pSrcPhrase->m_nSequNumber;
d:					gbSuppressSetup = TRUE;
					CPile* pLastPile = AdvanceBundle(sn);
					gpApp->m_nActiveSequNum = sn;
					gpApp->m_pActivePile = pLastPile;
					wxASSERT(pLastPile != NULL);

					// now we've advanced the bundle, permit setup again
					gbSuppressSetup = FALSE;
					pPile = GetNextPile(pLastPile);

					// keep looping until we come to a sourcephrase which is not yet free translated
					// or we come to the end of the document
c:					if (pPile->m_pSrcPhrase->m_bHasFreeTrans)
					{
						pLastPile = pPile;
						pPile = GetNextPile(pPile);
						if (pPile == NULL)
						{
							if (pLastPile->m_pSrcPhrase->m_nSequNumber == gpApp->m_maxIndex)
							{
								// end of doc
								goto b;
							}
							else
							{
								// step down, and keep trying
								sn = pLastPile->m_pSrcPhrase->m_nSequNumber;
								goto d;
							}
						}
						else
						{
							goto c;
						}
					}
				}
			}
			else
			{
				// not a null pile pointer, so loop until we come to a section which is not
				// free translated
e:				if (pPile->m_pSrcPhrase->m_bHasFreeTrans)
				{
					CPile* pLastPile = pPile;
					pPile = GetNextPile(pPile);
					if (gbVerticalEditInProgress && pPile != NULL)
					{
						int sn = pPile->m_pSrcPhrase->m_nSequNumber;
						bool bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(sn, nextStep);
						// FALSE is bForceTransition
						if (bCommandPosted)
							return;
					}
					if (pPile == NULL)
					{
						// either we are at the end of the doc, or the end of the bundle
f:						if (pLastPile->m_pSrcPhrase->m_nSequNumber == gpApp->m_maxIndex)
						{
							// at end of doc
							goto b;
						}
						else
						{
							// need to step down
							int sn = pLastPile->m_pSrcPhrase->m_nSequNumber;

							gbSuppressSetup = TRUE; // prevent SetupCurrentFreeTransSection() being called
							pLastPile = AdvanceBundle(sn);
							gpApp->m_nActiveSequNum = sn;
							gpApp->m_pActivePile = pLastPile;
							wxASSERT(pLastPile);

							// permit setup again
							gbSuppressSetup = FALSE;
							pPile = GetNextPile(pLastPile);

							// pPile could be NULL, so test and if so check for being at the end
							// of the doc, and if not, step down again
							if (pPile == NULL)
								goto f;
							else
							goto e;
						}
					}
					else
					{
						// the pile is good, so test it
						goto e;
					}
				}
			}
			if (gbVerticalEditInProgress && pPile != NULL)
			{
				int sn = pPile->m_pSrcPhrase->m_nSequNumber;
				bool bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(sn, nextStep);
				// FALSE is bForceTransition
				if (bCommandPosted)
					return;
			}
			gpApp->m_pActivePile = pPile;
			gpApp->m_nActiveSequNum = pPile->m_pSrcPhrase->m_nSequNumber;
			gbSuppressSetup = FALSE; // make sure it is off

			// make m_bIsCurrentFreeTransSection FALSE on every pile
			MakeAllPilesNonCurrent(gpApp->m_pBundle);

			// place the phrase box at the next anchor location
			CCell* pCell = pPile->m_pCell[2]; // whatever is the phrase box's line in the strip
			if (gbIsGlossing)
			{
				translation = pCell->m_pPile->m_pSrcPhrase->m_gloss;
			}
			else
			{
				translation = pCell->m_pPile->m_pSrcPhrase->m_adaption;
			}
			int selector = 1; // this selector inhibits both intial and final code blocks (ie. no save to KB
							  // and no removal from KB at the new location)
			PlacePhraseBox(pCell,selector);

			// make sure we can see the phrase box
			gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);
			Invalidate();
			pEdit->SetFocus();
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update Idle mechanism
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the Free Translation navigation buttons are visible.
/// The "Next >" button used for navigation in free translation mode is disabled if the
/// application is not in Free Translation mode, or if the active pile pointer is NULL, or if the 
/// active sequence number is negative (-1), otherwise the button is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateNextButton(wxUpdateUIEvent& event)
{
	if (!gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_nActiveSequNum < 0 || gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

void CAdapt_ItView::OnNextButton(wxCommandEvent& WXUNUSED(event))
{
	gbSuppressSetup = FALSE; // restore default value, in case Shorten or Lengthen buttons were used

	// for debugging
	//int ftStartSN = gEditRecord.nFreeTranslationStep_StartingSequNum;
	//int ftEndSN = gEditRecord.nFreeTranslationStep_EndingSequNum;

	CMainFrame* pMainFrm = gpApp->GetMainFrame(); 
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	if(pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			CPile* pOldActivePile = gpApp->m_pActivePile;
			CPile* saveLastPilePtr = gpApp->m_pActivePile; // a safe default initialization

			// The current free translation was not just removed so do the StoreFreeTranslation() call
			if (gpCurFreeTransSectionPileArray->GetCount() > 0)
			{
				// whm added 24Aug06 passing of current edits to StoreFreeTranslation() via 
				// the editedText parameter along with enum remove_editbox_contents to maintain 
				// legacy behavior when called from this handler
				saveLastPilePtr =
					(CPile*)gpCurFreeTransSectionPileArray->Item(gpCurFreeTransSectionPileArray->GetCount()-1);
				if (!gbFreeTranslationJustRemovedInVFMdialog)
				{
					wxString editedText;
					editedText = pEdit->GetValue();
					StoreFreeTranslation(gpCurFreeTransSectionPileArray,pOldActivePile,saveLastPilePtr,
						remove_editbox_contents, editedText);
				}
			}


			// make sure the kb entry flag is set correctly
			CSourcePhrase* pSrcPhr = pOldActivePile->m_pSrcPhrase;
			FixKBEntryFlag(pSrcPhr);

			// get the next pile
			CPile* pPile = GetNextPile(saveLastPilePtr);

			// check out pPile == NULL, we could be at the bundle end or the doc end - fix things
			// according to whichever is the case; if not null, then the next pile is within the
			// current bundle and we can set it up as the active location & new anchor point - or it
			// will be the start of a predefined free translation section in which case it is already
			// the anchor point for the next free translation section
			if (pPile == NULL)
			{
				// The scroll position at the end of the bundle, or maybe at the end of the document
				// so if the former then advance the bundle etc.
				if (saveLastPilePtr->m_pSrcPhrase->m_nSequNumber == gpApp->m_maxIndex)
				{
					// we are already at the end of the doc, so cannot Advance. So leave this section
					// current, and beep to tell the user
					// BEW added 11Sep08 for support of vertical editing
					if (gbVerticalEditInProgress)
					{
						bool bCommandPosted;
						bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(-1, nextStep, TRUE);
						// TRUE is bForceTransition
						return;
					}
					else
					{
						::wxBell();
					}
					CCell* pCell = pOldActivePile->m_pCell[2];
					int selector = 1;
					PlacePhraseBox(pCell,selector);
					Invalidate();
					pEdit->SetFocus();
					return;
				}
				else
				{
					// not at the end of the doc, just at the end of the bundle - so advance it
					int sn = saveLastPilePtr->m_pSrcPhrase->m_nSequNumber;
					gbSuppressSetup = TRUE; // inhibit SetupCurrentFreeTransSection() call in RecalcLayout()
					// BEW added 11Sep08 for support of vertical editing
					if (gbVerticalEditInProgress)
					{
						int sn = pPile->m_pSrcPhrase->m_nSequNumber;
						bool bCommandPosted;
						bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(sn, nextStep);
						// FALSE is bForceTransition
						return;
					}
					CPile* pLastPile = AdvanceBundle(sn);
					wxASSERT(pLastPile != NULL);
					gpApp->m_pActivePile = pLastPile;
					gpApp->m_nActiveSequNum = pLastPile->m_pSrcPhrase->m_nSequNumber;
					gbSuppressSetup = FALSE; // repermit the call
					pPile = GetNextPile(pLastPile);
				}
			}
			if (gbVerticalEditInProgress)
			{
				int sn = pPile->m_pSrcPhrase->m_nSequNumber;
				bool bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(sn, nextStep);
				// FALSE is bForceTransition
				if (bCommandPosted)
					return; // we've reached gray text, so step transition is wanted
			}

			// make m_bIsCurrentFreeTransSection FALSE on every pile
			gpApp->m_pActivePile = pPile;
			MakeAllPilesNonCurrent(gpApp->m_pBundle);

			// place the phrase box at the next anchor location
			CCell* pCell = pPile->m_pCell[2]; // whatever is the phrase box's line in the strip
			if (gbIsGlossing)
			{
				translation = pCell->m_pPile->m_pSrcPhrase->m_gloss;
			}
			else
			{
				translation = pCell->m_pPile->m_pSrcPhrase->m_adaption;
			}
			int selector = 1; // this selector inhibits both intial and final code blocks (ie. no save to KB
							  // and no removal from KB at the new location)
			PlacePhraseBox(pCell,selector); // forces a bundle recalculation, which gets
											// SetupCurrentFreeTransSection() called

			// make sure we can see the phrase box
			gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum); // MFC commented out
			Invalidate(); // gets the view redrawn
			pEdit->SetFocus();

			// if there is text in the pEdit box, put the cursor after it
			wxString editedText;
			editedText = pEdit->GetValue();
			int len = editedText.Length(); 
			if (len > 0)
				pEdit->SetSelection(len,len); 
			else
				pEdit->SetSelection(-1,-1); // -1,-1 selects all in wx
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update Idle mechanism
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the Free Translation navigation buttons are visible.
/// The "< Prev" button used for navigation in free translation mode is disabled if the
/// application is not in Free Translation mode, or if the active pile pointer is NULL, or if the 
/// active sequence number is negative (-1), or if the pile previous to the active pile is NULL, 
/// otherwise the button is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdatePrevButton(wxUpdateUIEvent& event)
{
	if (!gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_nActiveSequNum < 0 || gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	CPile* pPile = GetPrevPile(gpApp->m_pActivePile);
	if (pPile == NULL)
	{
		// probably we are at the start of the document
		event.Enable(FALSE);
	}
	else
		event.Enable(TRUE);
	// whm 6Sep06 commented out in order to allow the Prev button to move the active location
	// to the previous potential free trans segment.
	//else
	//{
	//	// a step up should have been done externally beforehand, so except when the active
	//	// location is at sequence number 0, a previous pile should be available for testing
	//	if (pPile->m_pSrcPhrase->m_bHasFreeTrans)
	//	{
	//		// the previous piles contain a pre-defined free translation section, so enable the
	//		// button so the app can make it the current section
	//		event.Enable(TRUE);
	//	}
	//	else
	//	{
	//		// no pre-existing free translation is there, so we don't allow the button to do anything
	//		// (to get the button enabled, manually click the phrase box into a free translated section
	//		// of the document, and then the <Prev button will be enabled)
	//		event.Enable(FALSE);
	//	}
	//}
}

// whm revised 24Aug06 to allow Prev button to move back to the previous actual or potential
// free translation segment in the text
void CAdapt_ItView::OnPrevButton(wxCommandEvent& WXUNUSED(event))
{
	gbSuppressSetup = FALSE; // restore default value, in case Shorten or Lengthen buttons were used

	CMainFrame* pMainFrm = gpApp->GetMainFrame();
	wxPanel* pBar = pMainFrm->m_pComposeBar; 
	if(pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			CPile* pOldActivePile = gpApp->m_pActivePile;

			// do not do StoreFreeTranslation() call if the current free translation was just
			// deleted by operator pressing on the Delete button (either in View Filtered Material
			// dialog or using the composebar button for that purpose
			if (!gbFreeTranslationJustRemovedInVFMdialog)
			{
				// do the save & pointer calculation in the StoreFreeTranslation() call
				if (gpCurFreeTransSectionPileArray->GetCount() > 0)
				{
					// whm added 24Aug06 passing of current edits to StoreFreeTranslation() via 
					// the editedText parameter along with enum remove_editbox_contents to maintain 
					// legacy behavior when called from this handler
					CPile* saveLastPilePtr;
					saveLastPilePtr =
						(CPile*)gpCurFreeTransSectionPileArray->Item(gpCurFreeTransSectionPileArray->GetCount()-1);
					wxString editedText;
					editedText = pEdit->GetValue();
					StoreFreeTranslation(gpCurFreeTransSectionPileArray,pOldActivePile,saveLastPilePtr,
						remove_editbox_contents, editedText);
				}
			}

			// make sure the kb entry flag is set correctly
			CSourcePhrase* pSrcPhr = pOldActivePile->m_pSrcPhrase;
			FixKBEntryFlag(pSrcPhr);

			CPile* pPile = pOldActivePile;
			// The Prev button should not be activated if the active pile is already at the
			// beginning of the document. However, for safety sake, I'll check to prevent 
			// this handler doing anything if we get called from the beginning of the document.
			if (pPile->m_pSrcPhrase->m_nSequNumber == 0)
			{
				// we are at the beginning of the doc and cannot go to any previous free trans
				// segment, so beep and return;
				::wxBell();
				return;
			}
			// At this point there should be at least one pile before pPile to compose a free
			// translation segment. We call GetPrevPile once to start examining the pile immediately
			// before the current one (i.e., which potentially is the last pile of a free translation
			// segment before the current segment we're leaving). The current pile is always assigned
			// to pPile.
			// Then, as we scan through piles toward the beginning of the document, we examine 
			// the attributes of pPile and the attributes of its previous pile pPrevPile looking
			// for a halting point for the beginning of a free translation segment.
			CPile* pPrevPile = NULL;
			pPrevPile = GetPrevPile(pPile);
			wxASSERT(pPrevPile != NULL);
			if (gbVerticalEditInProgress)
			{
				int sn = pPrevPile->m_pSrcPhrase->m_nSequNumber;
				if (sn < gEditRecord.nFreeTranslationStep_StartingSequNum ||
					sn > gEditRecord.nFreeTranslationStep_EndingSequNum)
				{
					// IDS_CLICK_IN_GRAY_ILLEGAL
					wxMessageBox(_("Attempting to put the active location within the gray text area while updating information in Vertical Edit mode is illegal. The attempt has been ignored."), _T(""), wxICON_WARNING);
					return;
				}
			}


			// If the last pile before the current free trans segment (i.e., now pPrevPile) is the
			// last pile of a previously adjoining free translation segment, we want to scan back
			// to the first pile of that existing segment (regardless of any potential intervening
			// halting points)
			if (pPrevPile->m_pSrcPhrase->m_bEndFreeTrans)
			{
				// the previous pile is already within an existing free translation segment. In this
				// situation we need to scan back to find the beginning pile of that existing segment.
				while (pPrevPile != NULL)
				{
					pPile = GetPrevPile(pPrevPile);
					// Check out if this pPile == NULL, we could be at the bundle start or the doc start.
					// Handle things according to whichever is the case. 
					if (pPile == NULL)
					{
						// We are either at the start of the bundle or at the start of the document
						// so if the former then retreat the bundle.
						if (pPrevPile->m_pSrcPhrase->m_nSequNumber == 0)
						{
							// we are at the start of the doc, so cannot retreat. So leave this section
							// current (with phrasebox at pPrevPile) and return. The Prev button gets
							// disabled once we get here, so this block will only get entered when the
							// Prev button first gets us back to the beginning of the document. No bell
							// sound is needed here.
							CCell* pCell = pPrevPile->m_pCell[2];
							int selector = 1;
							PlacePhraseBox(pCell,selector);
							gpApp->m_ptCurBoxLocation = pCell->m_ptTopLeft;
							// make sure we can see the phrasebox at the beginning of the doc
							gpApp->GetMainFrame()->canvas->ScrollIntoView(pPrevPile->m_pSrcPhrase->m_nSequNumber);
							Invalidate();
							pEdit->SetFocus();
							return;
						}
						else
						{
							// not at the start of the doc, just at the start of the bundle - so retreat one step
							int sn = pPrevPile->m_pSrcPhrase->m_nSequNumber; // pOldActivePile
							gbSuppressSetup = TRUE; // inhibit SetupCurrentFreeTransSection() call in RecalcLayout()
							// Note: While in free trans mode, RetreatBundle's CalcIndicesForRetreat 
							// puts the current pile in about the middle of the bundle
							pPrevPile = RetreatBundle(sn);
							wxASSERT(pPrevPile != NULL);
							gpApp->m_pActivePile = pPrevPile;
							gpApp->m_nActiveSequNum = pPrevPile->m_pSrcPhrase->m_nSequNumber;
							gbSuppressSetup = FALSE; // repermit the call
							pPile = GetPrevPile(pPrevPile);
							// Halt scanning at pPile if pPile == NULL (an error condition after bundle retreat)
							if (pPile == NULL)
							{
								wxASSERT(FALSE); // this would be an error right after a bundle retreat
								return;
							}
						}
					}
					// Criteria for halting scanning and establishing the anchor for a free translation segment:
					// If the source pharase at pPile is already the start of a free translation (m_bStartFreeTrans).
					// We can ignore checking for other halting conditions here.
					if (pPrevPile->m_pSrcPhrase->m_bStartFreeTrans)
					{
						break;
					}
					pPrevPile = pPile;
				}
			}
			else
			{
				// the previous pile is not already within an existing free translation segment
				// (i.e., it is part of a hole). This is a situation in which we need to examine
				// halting criteria to determine the halting point.
				bool bDidBundleRetreat = FALSE;
				while (pPrevPile != NULL)
				{
					pPile = GetPrevPile(pPrevPile);
					// Check out if this pPile == NULL, we could be at the bundle start or the doc start.
					// Handle things according to whichever is the case. 
					if (pPile == NULL)
					{
						// We are either at the start of the bundle or at the start of the document
						// so if the former then retreat the bundle.
						if (pPrevPile->m_pSrcPhrase->m_nSequNumber == 0)
						{
							// we are at the start of the doc, so cannot retreat. So leave this section
							// current (with phrasebox at pPrevPile) and return. The Prev button gets
							// disabled once we get here, so this block will only get entered when the
							// Prev button first gets us back to the beginning of the document. No bell
							// sound is needed here.
							CCell* pCell = pPrevPile->m_pCell[2];
							int selector = 1;
							PlacePhraseBox(pCell,selector);
							gpApp->m_ptCurBoxLocation = pCell->m_ptTopLeft;
							// make sure we can see the phrasebox at the beginning of the doc
							gpApp->GetMainFrame()->canvas->ScrollIntoView(pPrevPile->m_pSrcPhrase->m_nSequNumber);
							Invalidate();
							pEdit->SetFocus();
							return;
						}
						else
						{
							// not at the start of the doc, just at the start of the bundle - so retreat one step
							int sn = pPrevPile->m_pSrcPhrase->m_nSequNumber; // pOldActivePile
							gbSuppressSetup = TRUE; // inhibit SetupCurrentFreeTransSection() call in RecalcLayout()
							// Note: While in free trans mode, RetreatBundle's CalcIndicesForRetreat 
							// puts the current pile in about the middle of the bundle
							pPrevPile = RetreatBundle(sn);
							wxASSERT(pPrevPile != NULL);
							gpApp->m_pActivePile = pPrevPile;
							gpApp->m_nActiveSequNum = pPrevPile->m_pSrcPhrase->m_nSequNumber;
							gbSuppressSetup = FALSE; // repermit the call
							pPile = GetPrevPile(pPrevPile);
							bDidBundleRetreat = TRUE;
							// Halt scanning at pPile if pPile == NULL (an error condition after bundle retreat)
							if (pPile == NULL)
							{
								wxASSERT(FALSE); // this would be an error right after a bundle retreat
								return;
							}
						}
					}
					// Criteria for halting scanning and establishing the anchor for a free translation segment:
					// (Note: These are the same criteria used by SetupCurrentFreeTransSection())
					// Unconditionally halt scanning, if we encounter:
					//   1. An SF marker significant enough for us to consider that a logical break in 
					//      content starts at pPrevPile (IsFreeTranslationEndDueToMarker also returns 
					//      TRUE if a filtered section starts there);
					//   2. If the source pharase at pPile is already the start of a free translation (m_bStartFreeTrans).
					// The additional conditions for halting scanning depend if we encounter the following
					// halting criteria within a pile already marked for free translation or not already
					// marked for free translation.
					// If we have unstructured data or if m_bDefineFreeTransByPunctuation, halt scanning back
					//      if HasWordFinalPunctuation() returns TRUE, unless the pile is within an existing
					//      free translation segment, and that pile is not the first pile of the existing
					//      free translation (in which case we want to continue scanning back until we reach
					//      the first pile of the existing segment).
					// If m_bDefineFreeTransByPunctuation is FALSE, we halt scanning if the source phrase at 
					//     pPrevPile marks the beginning of a new verse (m_bVerse), unless the pile is within
					//     an existing free translation segment, and that pile is not the first pile of the
					//     existing free translation (here also we want to continue scanning back until we
					//     reach the first pile of the existing segment - this might not happen often but
					//     some verses begin in strange places!). 
					// or, if the source phrase at pPrevPile marks a change of text type (m_bFirstOfType),
					//     unless, like the other criteria above, an existing free translation somehow
					//     managed to span a text type boundary, in which case we would continue scanning
					//     back until we found the first pile of that existing free translation.
					
					if (IsFreeTranslationEndDueToMarker(pPrevPile))
					{
						break;
					}
					if (pPrevPile->m_pSrcPhrase->m_bStartFreeTrans)
					{
						break;
					}
					// Check if pPile is the (potential) last pile of a previous free 
					// trans section according to user's choice of verse or punctuation criteria.
					CSourcePhrase* pPrevSrcPhrase = pPile->m_pSrcPhrase;
					wxASSERT(pPrevSrcPhrase != NULL);
					if (gbIsUnstructuredData || gpApp->m_bDefineFreeTransByPunctuation)
					{
						// the verse option is not available if the data has no SF markers
						//if (!pSrcPhrase->m_follPunct.IsEmpty()) <-- no good for placeholders
						if (HasWordFinalPunctuation(pPrevSrcPhrase,pPrevSrcPhrase->m_targetStr,gSpacelessTgtPunctuation))
						{
							// there is word-final punctuation on the previous pile's source phrase, so the 
							// current pile is a suitable place to begin this section
							break;
						}
					}
					else if (pPrevPile->m_pSrcPhrase->m_bVerse || pPrevPile->m_pSrcPhrase->m_bFirstOfType)
					{
						break;
					}
					// If we get here, we've not found an actual or potential anchor point based on
					// inspecting the current pile nor the last pile (pOldActivePile), so save the 
					// current pile in pPrevPile, and get another preceding pile and examine 
					// it to see if it has criteria for establishing the beginning of a free translation 
					// segment.
					pPrevPile = pPile;
				}
			
				if (bDidBundleRetreat)
					gpApp->GetMainFrame()->canvas->ScrollIntoView(pPrevPile->m_pSrcPhrase->m_nSequNumber);
			}

			wxASSERT(pPrevPile != NULL);
//a:		m_pActivePile = pPile;
			gpApp->m_pActivePile = pPrevPile;

			// make m_bIsCurrentFreeTransSection FALSE on every pile
			MakeAllPilesNonCurrent(gpApp->m_pBundle);

			// place the phrase box at the next anchor location
			CCell* pCell = pPrevPile->m_pCell[2]; // whatever is the phrase box's line in the strip
			if (gbIsGlossing)
			{
				translation = pCell->m_pPile->m_pSrcPhrase->m_gloss;
			}
			else 
			{
				translation = pCell->m_pPile->m_pSrcPhrase->m_adaption;
			}
			int selector = 1; // this selector inhibits both intial and final code blocks (ie. no save to KB
							  // and no removal from KB at the new location)
			PlacePhraseBox(pCell,selector); // forces a bundle recalculation, which gets 
											// SetupCurrentFreeTransSection() called

			#ifdef _Trace_Box_Loc_Wrong
			pCell = gpApp->m_pActivePile->m_pCell[2];
			gpApp->m_ptCurBoxLocation = pCell->m_ptTopLeft;
			TRACE2("OnPrevButton   m_ptCurBoxLocation { %d , %d }  AFTER PlacePhraseBox()\n", 
						gpApp->m_ptCurBoxLocation.x, gpApp->m_ptCurBoxLocation.y);
			#endif

			// make sure we can see the phrase box
			gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);

			#ifdef _Trace_Box_Loc_Wrong
			TRACE2("OnPrevButton   m_ptCurBoxLocation { %d , %d }  AFTER ScrollToNearTop()\n", 
						m_ptCurBoxLocation.x, m_ptCurBoxLocation.y);
			#endif

			Invalidate(); // gets the view redrawn
			pEdit->SetFocus();

			// if there is text in the pEdit box, put the cursor after it
			wxString editStr;
			editStr = pEdit->GetValue();
			int len = editStr.Length();
			if (len > 0)
				pEdit->SetSelection(len,len);
			else
				pEdit->SetSelection(-1,-1); // -1,-1 selection entire text;
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update Idle mechanism
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the Free Translation navigation buttons are visible.
/// The "Remove" button used in free translation mode is disabled if the application is not in Free 
/// Translation mode, or if the active pile pointer is NULL, or if the active sequence number is 
/// negative (-1), or if the active pile does not own the free translation, otherwise the button is 
/// enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateRemoveFreeTranslationButton(wxUpdateUIEvent& event)
{
	bool bOwnsFreeTranslation;
	if (!gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_nActiveSequNum < 0 || gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	bOwnsFreeTranslation = IsFreeTranslationSrcPhrase(gpApp->m_pActivePile);
	if (!bOwnsFreeTranslation)
	{
		event.Enable(FALSE);
	}
	else
	{
		event.Enable(TRUE); // it's a defined section, so we can remove it
	}
}

void CAdapt_ItView::OnRemoveFreeTranslationButton(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame* pMainFrm = gpApp->GetMainFrame(); 
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	if (pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			// BEW added 29Apr06, to inform a subsequent <Prev, Next> or Advance button click
			// that the free translation at the current section has been removed, so that those
			// buttons will not insert a filtered pair of \free \free* markers with no content
			// at the current location when the one of those three buttons' handler is invoked
			gbFreeTranslationJustRemovedInVFMdialog = TRUE;

			// get the anchor pSrcPhrase
			CSourcePhrase* pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;

			// make sure the kb entry flag is set correctly
			FixKBEntryFlag(pSrcPhrase);

			// the next part of the code aims to remove the
			// "\~FILTER \free <free trans text> \free* \~FILTER* " string from m_markers
			wxString theMkr = _T("\\free");
			wxString theEndMkr = _T("\\free*");
			// whm 24Aug06 modified below
			wxString tempStr = GetExistingMarkerContent(theMkr, theEndMkr, pSrcPhrase,
											gnOffsetInMarkersStr, gnLengthInMarkersStr);
			// BEW added 1Oct08; for supporting the use of this function to clear the current free translation
			// section when the user changes the section extent by clicking Punctuation or Verse radio button
			// (typically there may not yet by any filtered free translation in pSrcPhrase yet, so we check
			// for that and skip the stuff below which assumes a free translation is present
			if (!(gnOffsetInMarkersStr == 0 && gnLengthInMarkersStr == 0 && tempStr.IsEmpty()))
			{
				// the above call gives us gnOffsetInMarkersStr (start of the free trans text) and
				// gnLengthInMarkersStr (its length, including the trailing space), so we have to
				// get pointers, starting from these locations, to the preceding and following
				// filter bracket markers
				wxString markersStr = pSrcPhrase->m_markers;
				int totalLen = markersStr.Length();
				// start by looking for the preceding \~FILTER marker, we'll iterate a pointer backwards
				// until we find \~FILTER
				wxString fltrMkr = filterMkr;
				int fmkrLen = fltrMkr.Length();
				// wx version note: Since we require a read-only buffer we use GetData which just returns
				// a const wxChar* to the data in the string.
				const wxChar* pBuff = markersStr.GetData(); //GetWriteBuf(totalLen + 1);
				wxChar* pBufStart = (wxChar*)pBuff;
				wxChar* pEnd;
				pEnd = pBufStart + totalLen;
				wxASSERT(*pEnd == _T('\0')); // whm added
				wxChar* ptr = pBufStart + gnOffsetInMarkersStr; // point to start of the free translation text itself
				--ptr;
				while ((wxStrncmp(ptr,filterMkr,fmkrLen) != 0) && ptr > pBufStart)
				{
					--ptr;
				}
				int nStartingOffset = (int)(ptr - pBufStart);
				wxASSERT(nStartingOffset >= 0);
				wxASSERT( gnOffsetInMarkersStr + gnLengthInMarkersStr < totalLen);
				int nFound = FindFromPos(markersStr,filterMkrEnd,gnOffsetInMarkersStr + gnLengthInMarkersStr);
				// it must be present further along, after the \free* endmarker of length 6 & trailing space
				wxASSERT(nFound > gnOffsetInMarkersStr + gnLengthInMarkersStr + 6);
				// the final offset is nFound plus the length of \~FILTER* plus 1 for its trailing space
				nFound += fmkrLen + 2; // 2 because we are counting the * and then the following space

				// delete this text material from the m_markers string
				markersStr.Remove(nStartingOffset,nFound - nStartingOffset); 
				pSrcPhrase->m_markers = markersStr;
			}
			// update the navigation text
			pSrcPhrase->m_inform = GetDocument()->RedoNavigationText(pSrcPhrase);

			// clear the Compose Bar's edit box
			// whm 24Aug06 modified below
			tempStr.Empty();
			pEdit->SetValue(tempStr);

			// clear the bool members on the source phrases in the array, but leave the array elements
			// themselves since they correctly define this section's extent at the time the button
			// was pressed
			int nSize = (int)gpCurFreeTransSectionPileArray->GetCount();
			CPile* pPile;
			int index;
			for (index = 0; index < nSize; index++)
			{
				pPile = (CPile*)gpCurFreeTransSectionPileArray->Item(index);
				wxASSERT(pPile);
				pPile->m_pSrcPhrase->m_bStartFreeTrans = FALSE;
				pPile->m_pSrcPhrase->m_bHasFreeTrans = FALSE;
				pPile->m_pSrcPhrase->m_bEndFreeTrans = FALSE;
			}
			Invalidate(); // cause redraw, and hence a call to SetupCurrentFreeTransSection()
			pEdit->SetFocus();
			pEdit->SetSelection(-1,-1); // -1,-1 selects all in wx
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update Idle mechanism
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the free translation navigation buttons are visible.
/// The "Lengthen" button used in free translation mode is disabled if the application is not in Free 
/// Translation mode, or if the active pile pointer is NULL, or if the active sequence number is 
/// negative (-1). But the button is enabled if it won't extend the next free translation segment past 
/// the end of a bundle or the doc, and if it won't extend beyond some significant marker, or encroach 
/// on an already defined free translation.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateLengthenButton(wxUpdateUIEvent& event)
{
	//bool bOwnsFreeTranslation;
	if (!gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_nActiveSequNum < 0 || gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	// We only get here if we're in free trans mode and have a valid anchor location.
	// whm changed behavior 20Sep06: If the Shorten button has been used, for a given
	// free trans segment, it leaves a "hole", and we want to be able to Click Lengthen
	// to re-include some of the pile(s) in that hole in the current segment.
	// This change allows the Lengthen button to be activated when there is a hole
	// following the current segment. This can be implemented by removing the
	// restriction of whether or not the current anchor location "owns" a free trans
	// segment or not, i.e., we allow lengthening to occur as long as we don't
	// lengthen past a bundle boundary, a significant marker, or an existing free
	// translation segment.
	//bOwnsFreeTranslation = IsFreeTranslationSrcPhrase(gpApp->m_pActivePile);
	//if (bOwnsFreeTranslation)
	//{
	//	event.Enable(FALSE);
	//	return;
	//}
	//else
	//{
		// BEW addition 11Sep08; in vertical editing mode, this is called when freeTranslationStep
		// is initialized at a former free translation section which has been cleared, and so
		// the pile array is empty; GetAt() calls then fail and crash the app, so we won't allow
		// lengthening if there is no array defined yet
		if (gpCurFreeTransSectionPileArray->IsEmpty()) // && !IsFreeTranslationSrcPhrase(m_pActivePile))
		{
			event.Enable(FALSE);
			return;
		}
		int end = (int)gpCurFreeTransSectionPileArray->GetCount() - 1;
		CPile* pPile = (CPile*)gpCurFreeTransSectionPileArray->Item(end);
		wxASSERT(pPile);
		pPile = GetNextPile(pPile); // get the pile immediately after the current end
		if (pPile == NULL)
		{
			// if at the end of bundle or doc, disable the button
			event.Enable(FALSE);
			return;
		}
		else
		{
			// whm observation: Here we only restrict the lengthening of the free trans segment
			// if the next pile contains a significant sfm; but, if it contains punctuation that
			// initially established the length of the segment, we allow the user to lengthen
			// beyond that punctuation, but we never allow lengthening past the start of an 
			// existing free translation.
			if (IsFreeTranslationEndDueToMarker(pPile))
			{
				// markers or filtered stuff must end the section (for example, we can't allow the
				// possibility of unfiltering producing new content within a free translation section)
				event.Enable(FALSE);
				return;
			}
			// also, we can't lengthen if there is a defined section following
			if (pPile->m_pSrcPhrase->m_bStartFreeTrans)
				event.Enable(FALSE);
			else
				event.Enable(TRUE); // but we can lengthen provided it is extending the section
									  // into an undefined free translation area and none of the
									  // above end-conditions applies
		}
	//}
}

void CAdapt_ItView::OnLengthenButton(wxCommandEvent& WXUNUSED(event))
{
	gbSuppressSetup = TRUE; // prevent SetupCurrentFreeTransSection() from wiping out the action done below
							// at the time that the view is updated (which otherwise would call that function)
	bool bEditBoxHasText = FALSE; // default
	// whm 24Aug06 reordered and modified below
	CMainFrame* pMainFrm = gpApp->GetMainFrame(); 
	wxPanel* pBar = pMainFrm->m_pComposeBar; 
	wxASSERT(pBar != NULL);
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
	wxASSERT(pEdit != NULL);
	wxString tempStr;
	tempStr = pEdit->GetValue();

	if (!tempStr.IsEmpty()) 
		bEditBoxHasText = TRUE;
	// & we can rely on m_nActiveSequNum having being set correctly, and also gpApp->m_pActivePile;

	if(pBar != NULL && pBar->IsShown())
	{
		if (pEdit != 0)
		{
			CPile* pPile;
			int end = (int)gpCurFreeTransSectionPileArray->GetCount() - 1;
			pPile = (CPile*)gpCurFreeTransSectionPileArray->Item(end); // pile at end of current section
			// the OnUpdateLengthenButton() handler will have already disabled the button if there
			// is no next pile in the bundle, so we can procede with confidence
			pPile = GetNextPile(pPile);
			wxASSERT(pPile != NULL);
			pPile->m_bIsCurrentFreeTransSection = TRUE; // this will make it's background go light pink
			gpCurFreeTransSectionPileArray->Add(pPile); // add it to the array

			// if there is text in the Compose Bar's edit box (ie. gFreeTranslationStr is not empty) then
			// we'll lengthen without making any change to it; but if there is no text, then will either leave
			// the box empty or put in default text contructed from the new current (shorter) section, according
			// to whatever the relevant flag setting currently is
			if (!bEditBoxHasText)
			{
				if (gpApp->m_bTargetIsDefaultFreeTrans || gpApp->m_bGlossIsDefaultFreeTrans)
				{
					// do the composition from the section's target text
					//gFreeTranslationStr = ComposeDefaultFreeTranslation(gpCurFreeTransSectionPileArray);
					tempStr = ComposeDefaultFreeTranslation(gpCurFreeTransSectionPileArray);
					pEdit->SetValue(tempStr); // show it in the ComposeBar's edit box
				}
			}

			// colour the current section & select the text
			MarkFreeTranslationPilesForColoring(gpCurFreeTransSectionPileArray);
			pEdit->SetFocus();
			pEdit->SetSelection(-1,-1); //-1,-1 selects all in wx

			// get the window updated
			Invalidate();
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update Idle mechanism
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the free translation navigation buttons are visible.
/// The "Shorten" button used in free translation mode is disabled if the application is not in Free 
/// Translation mode, or if the active pile pointer is NULL, or if the active sequence number is 
/// negative (-1). But the button is enabled as long as there is at least one pile left.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateShortenButton(wxUpdateUIEvent& event)
{
	if (!gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_nActiveSequNum < 0 || gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	// BEW changed 06Mar06, so user can shorten to a single pile
	int nSize = (int)gpCurFreeTransSectionPileArray->GetCount();
	// BEW changed 15Oct05, because we want to allow the user to shorten to less than 5 piles
	// when he really wants too - such as when there are 4 piles, each a merger, and so the
	// automatic sectioning gets lots of extra piles too - in such a circumstance the user
	// may want to shorten to just get the first four piles.
	//if (nSize <= MIN_FREE_TRANS_PILES)
	if (nSize <= 1)
		event.Enable(FALSE);
	else
		event.Enable(TRUE);
}

void CAdapt_ItView::OnShortenButton(wxCommandEvent& WXUNUSED(event))
{
	gbSuppressSetup = TRUE; // prevent SetupCurrentFreeTransSection() from wiping out the action done below
							// at the time that the view is updated (which otherwise would call that function)
	bool bEditBoxHasText = FALSE; // default
	// whm 24Aug06 reordered and modified below
	CMainFrame* pMainFrm = gpApp->GetMainFrame();
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	wxASSERT(pBar != NULL);
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
	wxASSERT(pEdit != NULL);
	wxString tempStr;
	tempStr = pEdit->GetValue();

	if (!tempStr.IsEmpty())
		bEditBoxHasText = TRUE;
	// & we can rely on m_nActiveSequNum having being set correctly, and also gpApp->m_pActivePile;
	// and the button will only be enabled if this is a section not previously defined ( we want to
	// make it hard for the user to open up an un-free tranlated section gap in the sequence of
	// free translations)

	if (pBar != NULL && pBar->IsShown())
	{
		if (pEdit != 0)
		{
			int end = (int)gpCurFreeTransSectionPileArray->GetCount() - 1;
			if (end >= 1) // BEW changed 06Mar06 to allow user to shorten to one pile only
			{
				// remove the last pile from the array
				// after making sure it is no longer regarded as within the current section
				CPile* pPile = (CPile*)gpCurFreeTransSectionPileArray->Item(end);
				pPile->m_bIsCurrentFreeTransSection = FALSE; // this will mean the cell background will go white
				
				// whm corrected by addition 20Sep06: When shortening an existing free trans segment, 
				// the cell did not go white, but stayed green, because the source phrase associated 
				// with the end pile had not yet had its m_bHasFreeTrans reset to FALSE; so, the following
				// lines update the flags to correct the situation.
				pPile->m_pSrcPhrase->m_bHasFreeTrans = FALSE;
				pPile->m_pSrcPhrase->m_bEndFreeTrans = FALSE;
				// the pile previous to pPile becomes the new end pile of the active segment
				CPile* pPrevPile = GetPrevPile(pPile);
				if (pPrevPile != NULL)
					pPrevPile->m_pSrcPhrase->m_bEndFreeTrans = TRUE;

				gpCurFreeTransSectionPileArray->RemoveAt(end);
			}
			else
			{
				// can't remove index 0
				return;
			}

			// if there is text in the Compose Bar's edit box (ie. gFreeTranslationStr is not empty) then
			// we'll shorten without making any change; but if there is no text, then will either leave the
			// box empty or put in default text contructed from the new current (shorter) section, according to
			// whatever the relevant flag setting currently is
			if (!bEditBoxHasText)
			{
				if (gpApp->m_bTargetIsDefaultFreeTrans || gpApp->m_bGlossIsDefaultFreeTrans)
				{
					// do the composition from the section's target text or glossing text
					//gFreeTranslationStr = ComposeDefaultFreeTranslation(gpCurFreeTransSectionPileArray);
					tempStr = ComposeDefaultFreeTranslation(gpCurFreeTransSectionPileArray);
					pEdit->SetValue(tempStr); // show it in the ComposeBar's edit box
				}
			}

			// colour the current section & select the text
			MarkFreeTranslationPilesForColoring(gpCurFreeTransSectionPileArray);
			pEdit->SetFocus();
			pEdit->SetSelection(-1,-1); // -1,-1 selects all in wx

			// get the window updated
			Invalidate();
		}
	}
}

wxString CAdapt_ItView::ComposeDefaultFreeTranslation(wxArrayPtrVoid* arr)
{
	wxString str;
	str.Empty();
	int nCount = arr->GetCount();
	if (nCount == 0)
		return str;
	int index;
	wxString theText;
	theText.Empty();
	for (index = 0; index < nCount; index++)
	{
		if (gpApp->m_bTargetIsDefaultFreeTrans)
		{
			// get the text from the adaptation line's contents
			theText = ((CPile*)arr->Item(index))->m_pSrcPhrase->m_adaption; // ignore punctuation
		}
		else if (gpApp->m_bGlossIsDefaultFreeTrans)
		{
			// get the text from the glossing line's contents
			theText = ((CPile*)arr->Item(index))->m_pSrcPhrase->m_gloss; 
		}
		str += theText;
		str += _T(" "); // delimit with a single space
	}
	str = MakeReverse(str);
	str = str.Mid(1); // remove trailing space
	str = MakeReverse(str);
	return str; // if neither flag was on, an empty string is returned
}

/**********************************************************************
*  MarkFreeTranslationPilesForColoring
*
* Returns: nothing
*
* Parameters:
*	pileArray	->	pointer to the array of piles which are to have their
*	m_bIsCurrentFreeTransSection BOOL member set to TRUE
* Remarks:
*	this will turn on light pastel pink colouring of the phrase box line's
*	rectangles which lie within the current free translation section, when
*	Draw() is called on the CCell instances) -- use after making a call to
*	MakeAllPilesNonCurrent() when the current section moves to a new location
*	or is changed in size
*
***********************************************************************/
void CAdapt_ItView::MarkFreeTranslationPilesForColoring(wxArrayPtrVoid* pileArray)
{
	int nCount = pileArray->GetCount(); 
	int index;
	CPile* pile;
	for (index = 0; index < nCount; index++)
	{
		pile = (CPile*)pileArray->Item(index); 
		wxASSERT(pile); 
		pile->m_bIsCurrentFreeTransSection = TRUE;
	}
	// we never have to bother with clearing this BOOL member because each
	// RecalcLayout() call builds CPile instances from scratch and the
	// default value is set to FALSE for each
}

/**********************************************************************
*  MakeAllPilesNonCurrent
*
* Returns: nothing
*
* Parameters:
*	pBundle	->	pointer to the current bundle
*
* Remarks:
*	Resets the m_bIsCurrentFreeTransSection member of CPile instances
*	through the whole bundle to FALSE. Use this prior, followed by
*	MarkFreeTranslationPilesForColoring(), when the current section changes
*	to a new location, so that colouring gets done correctly at the right places
*
***********************************************************************/
void CAdapt_ItView::MakeAllPilesNonCurrent(CSourceBundle* pBundle)
{
	int nCount = pBundle->m_nStripCount;
	int indexStrip;
	int indexPile;
	CStrip* pStrip;
	CPile* pile;
	for (indexStrip = 0; indexStrip < nCount; indexStrip++)
	{
		pStrip = pBundle->m_pStrip[indexStrip];
		wxASSERT(pStrip); 
		int nPileCount = pStrip->m_nPileCount;
		for (indexPile = 0; indexPile < nPileCount; indexPile++)
		{
			pile = pStrip->m_pPile[indexPile];
			pile->m_bIsCurrentFreeTransSection = FALSE;
		}
	}
	// makes them ALL false
}

/**********************************************************************
*  IsFreeTranslationSrcPhrase
*
* Returns: TRUE if the sourcephrase's m_bStartFreeTrans BOOL is TRUE, FALSE otherwise
*
* Parameters:
*	pPile	->	pointer to the pile which stores the pSrcPhrase pointer being examined
*
***********************************************************************/
bool CAdapt_ItView::IsFreeTranslationSrcPhrase(CPile* pPile)
{

	return pPile->m_pSrcPhrase->m_bStartFreeTrans == TRUE;
}

/**********************************************************************
*  ContainsFreeTranslation
*
* Returns: TRUE if the sourcephrase's m_markers member contains a \free marker
*			FALSE otherwise
*
* Parameters:
*	pPile	->	pointer to the pile which stores the pSrcPhrase pointer being examined
*
***********************************************************************/
bool CAdapt_ItView::ContainsFreeTranslation(CPile* pPile)
{
	wxString markers = pPile->m_pSrcPhrase->m_markers;
	if (markers.IsEmpty())
		return FALSE;
	int curPos = markers.Find(_T("\\free"));
	return curPos > 0;
}

/**********************************************************************
*  SetupCurrentFreeTransSection
*
* Returns: nothing
*
* Parameters:
*	activeSequNum	->	the sequence number value at the phrase box location
*
* Remarks:
*	Called at the end of the RecalcLayout() function, provided the app flag
*	m_bFreeTranslationMode is TRUE. The function is responsible for determining
*	how many of the piles, starting at the active location, are to be deemed as
*	constituting the 'current' free translation section - the piles will be
*	shown with light pink background, and the user, after the function exits,
*	will be able to use buttons in the compose bar to alter the section - either
*	lengthening or shortening it, or recomposing it elsewhere, but these operations
*	are not handled by this function.
*
***********************************************************************/
void CAdapt_ItView::SetupCurrentFreeTransSection(int activeSequNum)
{
	gbFreeTranslationJustRemovedInVFMdialog = FALSE; // restore to default value, in case a removed was
													 // just done in the View Filtered Material dialog

	if (activeSequNum < 0)
		// phrase box is not defined, no active location is valid, so return
		return;

	gpApp->m_pActivePile = GetPile(activeSequNum); // has to be set here, because at
											// end of RecalcLayout's legacy code
											// it is still undefined
	bool bEditBoxHasText = FALSE; // to help with initializing the ComposeBar's contents,
								  // because we may be returning from normal mode after an
								  // editing operation and want the box text to still be there
	CMainFrame* pFrame;
	pFrame = gpApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxASSERT(pFrame->m_pComposeBar != NULL);
	wxTextCtrl* pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE); 
	// whm 24Aug06 removed gFreeTranslationStr global here and below
	wxString tempStr;
	tempStr = pEdit->GetValue(); // update the global with whatever is in the box

	gpCurFreeTransSectionPileArray->Clear(); // start with an empty array

	bool bOwnsFreeTranslation = IsFreeTranslationSrcPhrase(gpApp->m_pActivePile);
	CPile* pile;
	if (bOwnsFreeTranslation)
	{
		// it already has a free translation stored in the sourcephrase
		pile = gpApp->m_pActivePile;

		// before moving on from this pile, get the free translation text, and set the globals
		// for its offset and length so we can later easily update the filtered free translation
		// with any user edits done on it in the edit box of the Compose Bar
		wxString theMkr = _T("\\free");
		wxString theEndMkr = _T("\\free*");
		tempStr = GetExistingMarkerContent(theMkr, theEndMkr, gpApp->m_pActivePile->m_pSrcPhrase,
										gnOffsetInMarkersStr, gnLengthInMarkersStr);
		pEdit->SetValue(tempStr);	// show it in the ComposeBar's edit box, but don't
									// have it selected - too easy for user to mistakenly
									// lose it

		// now collect the array of piles in this section - since it's a predefined section, we can
		// use the bool values on each pSrcPhrase to determine the section's extent
		CPile* pNextPile;
		while (pile != NULL)
		{
			// store this pile in the global array
			gpCurFreeTransSectionPileArray->Add(pile);

			// there might be only one pile in the section, if so, this one would also have the
			// m_bEndFreeTrans flag set TRUE, so check for this and if so, break out here
			if (pile->m_pSrcPhrase->m_bEndFreeTrans)
				break;

			// get the next pile - beware, it may be in the next bundle
			pNextPile = GetNextPile(pile);
			if (pNextPile == NULL)
			{
				// we are at the doc end, or more likely at the bundle end and we need to
				// advance the bundle
				if (pile->m_pSrcPhrase->m_nSequNumber == gpApp->m_maxIndex)
				{
					// we are at the end of the doc
					break;
				}
				else
				{
					// we are at the end of the bundle (this block below taken from
					// OnLButtonDown())
					bool bNeeded = NeedBundleAdvance(gpApp->m_nActiveSequNum);
					if (bNeeded)
					{
						// do the advance, return a new (valid) pointer to the active pile
						gpApp->m_pActivePile = AdvanceBundle(gpApp->m_nActiveSequNum);
						wxASSERT(gpApp->m_pActivePile != NULL); 
						gpApp->m_curIndex = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;
						gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);

						// recreate the phraseBox again
						RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
					}
					// the above AdvanceBundle() call will call RecalcLayout() which again
					// calls SetupCurrentFreeTransSection() recursively, so when that returns
					// we must do no more, so just return
					return;
				}
			}
			else
			{
				// pNextPile is not null, so check out if this pile is the end of the section
				wxASSERT(pNextPile != NULL);
				pile = pNextPile;
				wxASSERT(pile->m_pSrcPhrase->m_bHasFreeTrans); // must be TRUE for a defined section
				if (pile->m_pSrcPhrase->m_bEndFreeTrans)
				{
					// we've found the ending pile
					gpCurFreeTransSectionPileArray->Add(pile); // store this one too
					break; // exit the loop
				}
			}
		} // end of loop
	}
	else
	{
		// it does not yet have a free translation stored in this sourcephrase, so
		// work out the first guess for what the current section is to be
		pile = GetPile(activeSequNum);
		if (pile == NULL)
			return; // something's very wrong - how can the phrase box be at a null pile?

		if (!tempStr.IsEmpty())
			bEditBoxHasText = TRUE;

		// at the current section we collect the layout information in globals, so that
		// we can delay committal to the section's extent until the user has made whatever
		// manual adjustments (with Compose Bar butons or clicking the phrase box elsewhere
		// or selecting or combinations of any of those) and the clicks Advance or Next>
		// of <Prev -- since it is at that point that the globals in the affected pSrcPhrase
		// instances will get set - (free translations not at the current location will use
		// those globals to set up for writing the free translation text to the main window)
		int wordcount = 0;
		CPile* pNextPile;
		while (pile != NULL)
		{
			CSourcePhrase* pSrcPhrase;
			// store this pile in the global array
			gpCurFreeTransSectionPileArray->Add(pile);

			// count the pile's words (BEW changed 28Apr06)
			wordcount += pile->m_pSrcPhrase->m_nSrcWords;

			// test first for a following free translation section - if there is one
			// it must halt scanning immediately
			pNextPile = GetNextPile(pile);
			if (pNextPile == NULL)
			{
				// we are at the doc end, or more likely at the bundle end and we need to
				// advance the bundle
				goto a;
			}
			else
			{
				if (pNextPile->m_pSrcPhrase->m_bStartFreeTrans)
					break; // halt scanning, we've bumped into a pre-existing free trans section
				// else, continue the battery of tests
			}

			if (IsFreeTranslationEndDueToMarker(pNextPile))
				break; // halt scanning, we've bumped into a SF marker which is significant enough
					   // for us to consider that something quite different follows, or a filtered
					   // section starts at pNextPile - and that too indicates potential major change
					   // in the text at the next pile

			// determine if we can start testing for the end of the section
			// MIN_FREE_TRANS_PILES is defined in AdaptitConstants.h (currently set to 5)
			// BEW 28Apr06, we are now counting words, so change to MIN_FREE_TRANS_WORDS, but still = 5
			if (wordcount >= MIN_FREE_TRANS_WORDS)
			{
				// test for final pile in this section
				pSrcPhrase = pile->m_pSrcPhrase;
				wxASSERT(pSrcPhrase != NULL);
				if (gbIsUnstructuredData || gpApp->m_bDefineFreeTransByPunctuation)
				{
					// the verse option is not available if the data has no SF markers
					//if (!pSrcPhrase->m_follPunct.IsEmpty()) <-- no good for placeholders
					if (HasWordFinalPunctuation(pSrcPhrase,pSrcPhrase->m_targetStr,gSpacelessTgtPunctuation))
					{
						// there is word-final punctuation, so this is a suitable place
						// to close off this section
						break;
					}
				}
				else
				{
					// we can assume the user wants the criterion to be the start of a
					// following verse (or end of document) or a text type change
					if (pNextPile == NULL)
					{
						// we are at the end of the document, or the end of the bundle - if
						// the latter, we need to advance the bundle, recalc the layout (done
						// by the advance bundle's code) and recompute this section (also done
						// by the advance bundle's RecalcLayout call)
a:						if (pile->m_pSrcPhrase->m_nSequNumber == gpApp->m_maxIndex)
						{
							// we are at the end of the doc
							break;
						}
						else
						{
							// we are at the end of the bundle (this block below taken from
							// OnLButtonDown())
							bool bNeeded = NeedBundleAdvance(gpApp->m_nActiveSequNum);
							if (bNeeded)
							{
								// do the advance, return a new (valid) pointer to the active pile
								gpApp->m_pActivePile = AdvanceBundle(gpApp->m_nActiveSequNum);
								wxASSERT(gpApp->m_pActivePile != NULL);
								gpApp->m_curIndex = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;
								gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);

								// recreate the phraseBox again
								RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
							}
							// the above AdvanceBundle() call will call RecalcLayout() which again
							// calls SetupCurrentFreeTransSection() recursively, so when that returns
							// we must do no more, so just return
							pEdit->SetFocus();
							pEdit->SetSelection(-1,-1);
							// Note: In wx both parameters need to be -1 to select all the text in the control
							return;
						}
					}
					else if (pNextPile->m_pSrcPhrase->m_bVerse || pNextPile->m_pSrcPhrase->m_bFirstOfType)
					{
						// this "next pile" is the start of a new verse, so we must break out here
						break;
					}
					// otherwise, continue iterating across successive piles
				}
			}

			// not enough piles to permit section to end, or end criteria not yet
			// satisfied, so keep iterating
			pile = GetNextPile(pile);
		}

		// Other calculations re strip and rects and composing default ft text -- all based on the
		// array as filled out by the above loop - these calculations should be done as function
		// calls with the array as parameter, since these calcs will be needed in other places too

		// compose default free translation text, if appropriate...
		// this is a new location, so use the box contents if there is already something there,
		// otherwise check the app's flags m_bTargetIsDefaultFreeTrans and m_bGlossIsDefaultFreeTrans
		// and if one is true (both can't be true at the same time) then compose a default free
		// translation string from the target text, or glossing text, in the section as currently defined
		if (bEditBoxHasText)
		{
			// Compose Bar's edit box has text, so leave that as the default
			;
		}
		else
		{
			// no text there, so check the app flag
			if (gpApp->m_bTargetIsDefaultFreeTrans || gpApp->m_bGlossIsDefaultFreeTrans)
			{
				// do the composition from the section's target text, or glossing text
				tempStr = ComposeDefaultFreeTranslation(gpCurFreeTransSectionPileArray);
				pEdit->SetValue(tempStr); // show it in the ComposeBar's edit box
			}
		}
	}
	// colour the current section
	MarkFreeTranslationPilesForColoring(gpCurFreeTransSectionPileArray);
	pEdit->SetFocus();
	pEdit->SetSelection(-1,-1); // -1,-1 selects all
}

/**********************************************************************
*  GetExistingFreeTranslation
*
* Returns: the text of the filtered free translation which is in the m_markers member
*
* Parameters:
*	pSrcPhrase	->	pointer to the CSourcePhrase instance whose m_markers member
*					contains a "\~FILTER \free <text of free translation> \free* \~FILTER* "
*					substring
*	offset		<-	character offset to the first word of the free translation, relative to
*					the start of m_markers
*	length		<-	character length of the free translation string, including any final space
*
* Remarks:
*	Used to extract the <text of free translation> part of the above substring, and to
*	return the offset to the character location at which this text starts, and its length
*	including the final space before the \free* marker, if any (it should be present always)
*
***********************************************************************/
/* //obsolete -- GetExistingMarkerContent replaces it
CString CAdapt_ItView::GetExistingFreeTranslation(CSourcePhrase* pSrcPhrase, int& offset, int & length)
{
	CString markers = pSrcPhrase->m_markers;
	if (markers.IsEmpty())
	{
a:		offset = 0;
		length = 0;
		return CString(_T(""));
	}
	int nFound = markers.Find(_T("\\free"));
	if (nFound == -1)
		goto a; // shouldn't happen, but play safe
	offset = nFound + 6; // 5 for the \free marker length, plus 1 for the following space
	nFound = markers.Find(_T("\\free*"));
	ASSERT(nFound >= 0);
	length = nFound - offset;
	CString freetrans = markers.Mid(offset,length);
	return freetrans;
}
*/

/**********************************************************************
*  GetExistingMarkerContent
*
* Returns: the text of the filtered content (such as a free translation) which is in the m_markers member
*
* Parameters:
*	mkr			->	reference to the SF marker string (including backslash) defining the content we are after
*	endMkr		->	reference to the matching endmarker string, including backslash (could be empty)
*	pSrcPhrase	->	pointer to the CSourcePhrase instance whose m_markers member
*					contains a substring such as:
*					"\~FILTER \free <text of free translation> \free* \~FILTER* " for free translation, or
*					"\~FILTER \note <text of note> \note* \~FILTER* " for a note, or
*					"\~FILTER \bt <text of backtranslation> \~FILTER* " or ...\btv ... or other \bt-derived marker
*	offset		<-	character offset to the first word of the content string, relative to
*					the start of m_markers
*	length		<-	character length of the content string, including any final space
*
* Remarks:
*	Used to extract the <text of free translation> part of the above substring, or <text of note>,
*	or <text of backtranslation> as the case may be; and to return the offset to the character location
*	at which this text starts, and its length including the final space before the end marker, if any
*	-- it should be present always for a free translation or a note, and never present for a backtranslation
*	marker. In the latter case, the endMkr parameter will be empty (backtranslation markers do not have
*	endmarkers), and so the protocol we follow for determining the end of the content string is the following
*	1. ends at the next backslash (typically, at a \~FILTER* marker, but may not be), otherwise
*	2. ends at the end of m_markers string.
*	This function is a generalization of an earlier GetExistingFreeTranslation() function, so that we can
*	get not just free translation content, but notes or backtranslations. We can also use it for other
*	filtered (or even non-filtered) SF marker content we wish to extract, by just passing in the relevant
*	SF marker in the mkr parameter.
*
***********************************************************************/
wxString CAdapt_ItView::GetExistingMarkerContent(wxString& mkr, wxString& endMkr,
							CSourcePhrase* pSrcPhrase, int& offset, int & length)
{
	int len = mkr.Length();
	wxString contentStr;
	wxString markers = pSrcPhrase->m_markers;
	if (markers.IsEmpty())
	{
a:		offset = 0;
		length = 0;
		return wxString(_T(""));
	}
	int nFound = markers.Find(mkr);
	if (nFound == -1)
		goto a; // shouldn't happen, but play safe
	offset = nFound + len + 1; // plus 1 for the following space
	if (endMkr.IsEmpty())
	{
		// it's content which does not have an endmarker, so implement the
		// protocol described above
		len = markers.Length();
		nFound = FindFromPos(markers,_T("\\"),offset);
		if (nFound == -1)
		{
			// no subsequent SF marker, so length is the remainder of the string
			length = len - offset;
		}
		else
		{
			// found a marker, so up to the start of it defines the content string
			length = nFound - offset;
		}
	}
	else
	{
		// there should be an endmarker, so it's location determines where the content ends
		nFound = markers.Find(endMkr);
		wxASSERT(nFound >= 0);
		length = nFound - offset;
	}
	contentStr = markers.Mid(offset,length);
	return contentStr;
}

/**********************************************************************
*  FindFilteredInsertionLocation
*
* Returns: the offset from the beginning of m_markers where the filtered string is
*			to be inserted (it could be a free translation, or note, or backtranslation)
* Parameters:
*	rStr		->	reference to the CString (typically m_markers) which is to have the insertion
*					done on it at the returned offset's character location
*	mkr			->	reference to the actual marker which is being filtered (see Remarks below)
*
* Remarks:
*	This function can be used for inserting a filtered free translation string, or a filtered
*	note string, or a filtered backtranslation string (or a derivative of the latter, such as \btv etc)
*	into m_markers. The passed in marker is used to select which particular code block is used, (and if
*	there are derivative \bt markers in the doc, just pass in whichever it is, such as \btv),
*	because we wish to ensure that in m_markers where all three kinds of marker are present, the
*	relative order will be guaranteed to be \note then \bt then \free. Nothing at all hangs on this
*	being the chosen order, and all our application's functionalities should work fine if there was
*	some other order, but we try to keep a fixed relative order for the sake of orderliness and
*	thereby we may help keep the whole more robust. Determining the insertion offset implements the
*	following protocol: - assuming we are dealing with a free translation...
*	1. if m_markers is empty, insert at location 0
*	2. else if m_markers lacks \~FILTER, then check for m_markers commencing with an endmarker,
*		or endmarker sequence, if it does then the insertion location is after the last such endmarker,
*		of if one or more spaces follow it, then after those, otherwise it is at 0
*	3. else if m_markers contains filtered material already (the rules below are ORDERED rules):
*		3.1 if \free already occurs (caller should have removed its content already) the location is
*			immediately after the \free marker and its following space, (and the caller should use
*			InsertFilteredMaterial() with the bContentOnly flag set TRUE),  else
*		3.2 if \bt or a derivative marker occurs, the free translation, after bracketing with filterMrk
*			and filterMkrEnd) goes after its closing \~FILTER* plus space, else
*		3.3 if \note occurs, the free translation goes after its closing \~FILTER* plus space, else
*		3.4 if neither, then insert directly after the last \~FILTER* plus space.
*	For a note or a backtranslation, just vary the above protocol accordingly. For example, at 3. for a
*	note, we would have 3.1 if \note already occurs, insert after \note plus space, else 3.2 if \bt or
*	derivative occurs, insert before its opening \~FILTER marker, else if \free occurs, then insert before
*	its opening \~FILTER marker, if neither, then insert directly after the last \~FILTER* plus space. Etc.
*	With these protocols, then the note and/or backtranslation and/or free translation filtered stuff will
*	be tucked towards the right end of m_markers before any unfiltered stuff like \c or \v etc, and because
*	of that whenever we have user-filterable stuff, or obligatorily filtered stuff added to m_markers, such
*	stuff is going to occur to the left of the note or backtrans or free trans material - which is nice,
*	though not essential. One benefit is that we don't have to test for the case where an endmarker is
*	followed by filtered material in m_markers; if we allowed the above three kinds of marker to just be
*	placed willynilly, we'd have to test for that as well, as it's a legal configuration.
*
***********************************************************************/
int CAdapt_ItView::FindFilteredInsertionLocation(wxString& rStr, wxString& mkr)
{
	CAdapt_ItDoc* pDoc = GetDocument();
	int loc = 0;
	if (rStr.IsEmpty())
		return loc;
	int nFound = rStr.Find(filterMkr); // look for \~FILTER
	const wxChar* pBuff;
	int bufLen = rStr.Length();
	wxChar* pEnd;
	wxChar* pBufStart;
	wxChar* pStart; // BEW added 26May06 to get start location when there may be an
				   // initial sequence of endmarkers that must be traversed
	if (nFound == -1)
	{
		// there is no \~FILTER marker in rStr
		pBuff = rStr.GetData(); //GetWriteBuf(bufLen + 1);
		pBufStart = (wxChar*)pBuff;
		pEnd = pBufStart + bufLen;
		wxASSERT(*pEnd == _T('\0')); // whm added
s:		pStart = pBufStart + loc;
		if (*pStart == gSFescapechar)
		{
			// rStr starts with a marker, or another marker is after the first
			int itemLen = pDoc->ParseMarker(pStart);
			wxString initialMkr(pStart, itemLen);

			// find out if it an endmarker
			initialMkr = MakeReverse(initialMkr);
			if (initialMkr[0] == _T('*'))
			{
				// yes, it's an endmarker
				initialMkr = MakeReverse(initialMkr);
				loc += itemLen;

				// if another marker follows hard on its heals, repeat the test for that one
				if (*(pBuff + loc) == gSFescapechar)
						goto s;

				// when instead there are one or more spaces after the marker just scanned over,
				// traverse the spaces until either we are at the end, or we reach the start of
				// other marker and jump back to s in order to check that one out too
				while (*(pBuff + loc) == _T(' ') && (pBuff + loc < pEnd))
				{
					loc++; // want the location to be after the trailing space(s), if there were any

					// if we come upon another marker, jump out and start out from this current
					// location - it may be the case that we have nested markers, so we could
					// be scanning over a pair of endmarkers, such as \fq*\f*
					if (*(pBuff + loc) == gSFescapechar)
						goto s;
				}
				return loc;
			}

			// it's some other marker, eg \c or \v or \p which isn't filtered
			// so the correct location is before it
			//rStr.UngetWriteBuf(); //rStr.ReleaseBuffer();
			return loc; // loc is still zero here
		}
		// we should not have rStr starting with anything other than a marker
		// of some description, but to make fail-safe code, we allow for the
		// possibility
		return loc; // loc may still be zero here
	}

	// the above implements 1. and 2. for all passed in markers - whether \free, \note, or \bt
	// or derivative of \bt. Now what we do will depend on which of the above was passed in.
	wxString freeStr = _T("\\free");
	wxString btStr = _T("\\bt"); // we need different tests for this one, to handle \btv, \bts, etc
	wxString noteStr = _T("\\note");

	int curPos;
	if (mkr == freeStr)
	{
		// we want to know where to insert a \free and its free translation text
		if ((curPos = rStr.Find(freeStr)) > 0)
		{
			// the \free marker is present (and it must be preceded by \~FILTER plus space) so
			// the insertion location will be after the space following \free
			loc = curPos + freeStr.Length() + 1;
			return loc; // 3.1 is implemented
		}
		else
		{
			// there is no filtered free translation substring in rStr yet, so implement protocols
			// 3.2 to 3.4
			if ((curPos = rStr.Find(btStr)) > 0)
			{
				// note, rStr might have \bt marker, or some derivative marker such as \btv, \bts1, etc
				int pos2 = FindFromPos(rStr,filterMkrEnd,curPos); 
				wxASSERT(pos2 > 0); // there must be an ending filter marker for a backtranslation section
				int filtLen = wxStrlen_(filterMkrEnd); // length of \~FILTER*
				loc = pos2 + filtLen + 1;
				return loc; // implements 3.2
			}
			else
			{
				// there is no \bt marker, or other marker starting with \bt in rStr
				if ((curPos = rStr.Find(noteStr)) > 0)
				{
					// rStr contains a filtered \note marker and its content
					int pos2 = FindFromPos(rStr,filterMkrEnd,curPos);
					wxASSERT(pos2 > 0); // there must be an ending filter marker for a note section
					int filtLen = wxStrlen_(filterMkrEnd); // length of \~FILTER*
					loc = pos2 + filtLen + 1;
					return loc; // implements 3.3
				}
				else
				{
					// no backtrans, note, or free translation section, so insert after the lastmost
					// \~FILTER* marker
					goto a;
				}
			}
		}
	}
	else if (mkr == noteStr)
	{
		// we want to know where to insert a \note and its note text
		if ((curPos = rStr.Find(noteStr)) > 0)
		{
			// the \note marker is present (and it must be preceded by \~FILTER plus space so curPos == 0
			// is not a possibility) & the insertion location will be after the space following \note
			loc = curPos + noteStr.Length() + 1;
			return loc; // 3.1 is implemented
		}
		else
		{
			// there is no filtered \note plus note substring in rStr yet, so implement protocols
			// 3.2 to 3.4; it there is a backtranslation, the note will be inserted preceding its opening
			// \~FILTER marker
			if ((curPos = rStr.Find(btStr)) > 0)
			{
				// note, rStr might have \bt marker, or instead some derivative such as \btv, \bts1, etc
				pBuff = rStr.GetData();
				pBufStart = (wxChar*)pBuff;
				pEnd = pBufStart + bufLen; // whm added
				wxASSERT(*pEnd == _T('\0')); // whm added
				wxChar* ptr = pBufStart + curPos;
				--ptr;
				while (*ptr != gSFescapechar)
				{
					--ptr;
				}
				// we should exit the above while loop with ptr pointing at \~FILTER
				wxASSERT(wxStrncmp(ptr,filterMkr,8) == 0); // assert that the comment above is true
				loc = (int)(ptr - pBufStart); // insertion location immediately before the \~FILTER marker
				return loc; // implements 3.2
			}
			else
			{
				// there is no \bt marker, or other marker starting with \bt in rStr, so check out
				// the possibility of a filtered free translation stored there
				if ((curPos = rStr.Find(freeStr)) > 0)
				{
					// a filtered free translation is present, so the insertion location must be immediately
					// preceding its opening \~FILTER marker
					pBuff = rStr.GetData(); 
					pBufStart = (wxChar*)pBuff;
					pEnd = pBufStart + bufLen; // whm added
					wxASSERT(*pEnd == _T('\0')); //// whm added
					wxChar* ptr = pBufStart + curPos;
					--ptr;
					while (*ptr != gSFescapechar)
					{
						--ptr;
					}
					// we should exit the above while loop with ptr pointing at \~FILTER
					wxASSERT(wxStrncmp(ptr,filterMkr,8) == 0); // assert that the comment above is true
					loc = (int)(ptr - pBufStart); // insertion location immediately before the \~FILTER marker
					return loc; // implements 3.3
				}
				else
				{
					// no backtrans, note, or free translation section, so insert after the lastmost
					// \~FILTER* marker
					goto a;
				}
			}
		}
	}
	else if ((nFound = mkr.Find(btStr)) == 0)
	{
		// mkr is either \bt, or something which begins with \bt; so we want to know
		// where to insert whatever kind of backtranslation is here being considered
		if ((curPos = rStr.Find(btStr)) > 0) // we could be finding \bt, or the first 3 chars of \btv, \bts1, etc
		{
			// a \bt or derivative marker is present (and it must be preceded by \~FILTER plus space so curPos
			// == 0 is not a possibility) & the insertion location will be after the space following \bt or
			// whatever other marker happens to occur in this filtered section of backtranslation
			int nEnd = FindFromPos(rStr,filterMkrEnd,curPos); // get offset to terminating \~FILTER* marker for this section
			int mkrLen = 3;
			pBuff = rStr.GetData();
			pBufStart = (wxChar*)pBuff;
			wxChar* pActualEnd = pBufStart + bufLen; // whm added
			*pActualEnd = (wxChar)0; // whm added - shouldn't matter but just to be safe
			pEnd = pBufStart + nEnd;
			wxChar* ptr = pBufStart + curPos; // point to the \bt or whatever marker it is
			ptr += 3; // point to the first character following \bt
			wxASSERT (pEnd > ptr && (pEnd < pBufStart + bufLen)); // the section end lies within the buffer, ptr precedes it
			while (*ptr != _T(' '))
			{
				// span and count the extra marker characters until we come to a space or the end
				ptr++;
				mkrLen++;
				if (ptr == pEnd)
					break;
			}
			loc = curPos + mkrLen + 1;
			return loc; // 3.1 is implemented
		}
		else
		{
			// there is no filtered \bt or derivative of \bt in rStr yet, so implement protocols
			// 3.2 to 3.4; if there is a free translation filtered, then the insertion point will be
			// to the immediately left of its opening \~FILTER marker
			if ((curPos = rStr.Find(freeStr)) > 0)
			{
				// there is a \free marker present, in a filtered section
				pBuff = rStr.GetData();
				pBufStart = (wxChar*)pBuff;
				pEnd = pBufStart + bufLen; // whm added
				wxASSERT(*pEnd == _T('\0')); // whm added
				wxChar* ptr = pBufStart + curPos;
				--ptr;
				while (*ptr != gSFescapechar)
				{
					--ptr;
				}
				// we should exit the above while loop with ptr pointing at the \~FILTER preceding \free
				wxASSERT(wxStrncmp(ptr,filterMkr,8) == 0); // assert that the comment above is true
				loc = (int)(ptr - pBufStart); // insertion location immediately before the \~FILTER marker
				return loc; // implements 3.2
			}
			else
			{
				// there is no \free marker in rStr, so check out the possibility of there being a
				// filtered \note section - if so, the insertion location is immediately following the space
				// which follows its closing \~FILTER* marker
				if ((curPos = rStr.Find(noteStr)) > 0)
				{
					// a filtered note is present, so the insertion location must be immediately
					// after its closing \~FILTER* plus space
					int pos2 = FindFromPos(rStr,filterMkrEnd,curPos);
					wxASSERT(pos2 > 0); // there must be an ending filter marker for a note section
					int filtLen = wxStrlen_(filterMkrEnd); // length of \~FILTER*
					loc = pos2 + filtLen + 1;
					return loc; // implements 3.3
				}
				else
				{
					// no backtrans, note, or free translation section, so insert after the lastmost
					// \~FILTER* marker
a:					wxString filtEnd = filterMkrEnd;
					filtEnd = MakeReverse(filtEnd);
					wxString markers = rStr;
					markers = MakeReverse(markers);
					curPos = markers.Find(filtEnd);
					wxASSERT(curPos >= 0); // there must be a \~FILTER ... \~FILTER* section in rStr
					loc = bufLen - curPos + 1;
					return loc; // implements 3.4
				}
			}
		}
	}
	return loc = 0; // if none of the above, then return the 0th character position because
					// in our Adapt It design we are not considering creation from nothing of any
					// other filtered material other than notes, backtranslations or free translations
}

/**********************************************************************
*  InsertFilteredMaterial
*
* Parameters:
*	rMkr			->	reference to the marker (either \free, or \note, or \bt or a bt-prefixed marker)
*	rEndMkr			->	reference to the matching endmarker (either \free* or \note*), empty string if none
*	contentStr		->	the string content (it should end in a space) which is to be inserted, if there is
*						no content for insertion, contentStr should be empty. (ContentStr must be a
*						free translation, backtranslation, or a note, depending on what rMkr happens to be.)
*						Any earlier content must have been cleared out by the caller first.
*	pSrcPhrase		->	pointer to the CSourcePhrase instance whose m_markers member is to have the
*						insertion done at offsetForInsert
*	offsetForInsert ->	character offset where insertion is to take place - what actually gets put there
*						depends on the next parameter
*	bContentOnly	->	TRUE if only contentStr is to be inserted
*
* Remarks:
*	Used to insert either free translation, or backtranslation, or a note, into m_markers - and these markers
*	are always filtered, so we have to be clever. If bContentOnly is TRUE, only the content for a marker gets
*	inserted, because the marker, any endmarker, and bracketing filter markers will already be present and so
*	not need to be inserted again. If bContentOnly is FALSE, none of the required stuff is already present, and
*	so filter markers, marker, endmarker (if needed) and content, with a space between each, will need to be
*	inserted at offsetForInsert, and a final space added too.
*	Note: if the marker is already present, then its content should have been removed before calling
*	InsertFilteredMaterial() -- a good way to do this is to use the function GetExistingMarkerContent() which
*	also returns offsets to the beginning and end of the content string, and then CString's Delete() function
*	can be used to get rid of the content.
*
***********************************************************************/
void CAdapt_ItView::InsertFilteredMaterial(wxString& rMkr, wxString& rEndMkr, wxString contentStr,
									 CSourcePhrase* pSrcPhrase, int offsetForInsert, bool bContentOnly)
{
	int len = contentStr.Length();
	if (bContentOnly)
	{
		// everything is already present, we only need the content updated
		if (contentStr.IsEmpty())
			return;
		if (contentStr[len - 1] != _T(' '))
			contentStr += _T(' '); // add a space if contentStr does not already end with one
		//pSrcPhrase->m_markers.Insert(offsetForInsert,contentStr); // ignore returned length
		// wxString doesn't have an Insert method, so we'll do it
		// with a helper function
		pSrcPhrase->m_markers = InsertInString(pSrcPhrase->m_markers,offsetForInsert,contentStr);
	}
	else
	{
		// none of what is needed is present, so insert it all, including the new content
		wxString accumStr;
		accumStr.Empty();
		accumStr += filterMkr; // add \~FILTER
		accumStr += _T(' '); // add a space
		accumStr += rMkr; // add whatever marker rMkr is, either \free, or \note, or \bt (or a derivative thereof)
		accumStr += _T(' '); // add a space
		if (contentStr.IsEmpty())
		{
			; // add nothing
		}
		else
		{
			if (contentStr[len - 1] != _T(' '))
				contentStr += _T(' '); // add a space if contentStr does not already end with one
		}
		accumStr += contentStr;
		if (!rEndMkr.IsEmpty())
		{
			accumStr += rEndMkr;
			accumStr += _T(' '); // add a space
		}
		accumStr += filterMkrEnd;
		accumStr += _T(' '); // add a space
		pSrcPhrase->m_markers = InsertInString(pSrcPhrase->m_markers,offsetForInsert,accumStr); // ignore returned length
	}
}

/**********************************************************************
*  IsFreeTranslationEndDueToMarker
*
* Returns: TRUE if the 'next' sourcephrase pointed at by the passed in pile pointer contains in its m_markers
*			member a SF marker which should halt forward scanning for determining the end of the current
*			section to be free translated; FALSE otherwise
*
* Parameters:
*	pNextPile		->	pointer to the pile which is one position further along in the list than where
*						control happens to be in the caller (so if TRUE is returned, that passed in pile
*						will be excluded from the current free translation section being delimited, and
*						scanning will stop)
* Remarks:
*	We don't want a situation, such as in introductory material at the start of a book where there are
*	no verses defined, and perhaps limited or no punctuation as well, for scanning to find an endpoint
*	for the current section to fail to find some criterion for termination of the section - which would
*	easily happen if we ignored SF markers - and we'd get overrun of the section into quite different
*	kinds of information. So we'll halt scanning when there is a marker, but not when the marker is an
*	endmarker for a marker with TextType none, nor when it is a beginning marker which has a TextType of
*	none - the latter we want Adapt It to treat	as if they are 'not there' for most purposes. And we'll
*	not halt at embedded markers within a footnote (\f) or cross reference (\x) section either, but
*	certainly halt when there is \f* or (PNG set's \fe or \F) or \x* on the 'next' sourcephrase passed in.
*	BEW changed 22Dec07: a filtered Note can be anywhere, and we don't want these to needlessly halt
*	section delineation, so we'll ignore \note and \note* as well.
*
***********************************************************************/
bool CAdapt_ItView::IsFreeTranslationEndDueToMarker(CPile* pNextPile)
{
	wxString noteMkr = _T("\\note"); // BEW added 22Dec07
	USFMAnalysis* pAnalysis = NULL;
	wxString bareMkr;
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markers = pNextPile->m_pSrcPhrase->m_markers;
	if (markers.IsEmpty())
		return FALSE;

	// anything filtered must halt scanning, (BEW added:) exept for \note & its content
	wxString fltr = filterMkr; // \~FILTER
	int fltrPos = FindFromPos(markers,fltr,0);
	if (fltrPos != -1)
	{
		// since \~FILTER has been found, it could be for a Note; but it might be something
		// else which is filtered, or there might be a Note present plus other filtered
		// information (in which case the presence of the other filtered stuff must halt
		// the section delineation). So only when there is a single bit of filtered info
		// and it is a Note do we let processing continue, otherwise halt. It is sufficient
		// to test for \note, then branch according to whether or not there are least 3 
		// instances of \~FILTER, in markers.
		if (FindFromPos(markers,noteMkr,0) != -1)
		{
			// there is a note filtered here; check for other filtered information too, there
			// needs to be more than two instances of \~FILTER (first is the beginning marker,
			// the second is its endmarker \~FILTER*) for that to be TRUE
			fltrPos = FindFromPos(markers,fltr,++fltrPos);
			if (fltrPos == -1)
			{
				// could happen, eg. a filtered \bt has no matching endmarker, & it halts progress
				return TRUE;
			}
			else
			{
				// matched two instances of \~FILTER, try for a third
				fltrPos = FindFromPos(markers,fltr,++fltrPos);
				if (fltrPos != -1)
				{
					return TRUE; // there is other filtered info present
				}
				else
				{
					// there were only two, so they were the beginning marker and its endmarker
					return FALSE;
				}
			}
		}
		else
			// no \note marker is in markers, so the filtered material is something else
			// and so we must halt here
			return TRUE;
	}

	const wxChar* pBuff;
	int bufLen = markers.Length();
	wxChar* pBufStart;
	wxChar* ptr;
	int itemLen;
	int curPos = -1;
	wxString ftnoteMkr = _T("\\f");
	wxString xrefMkr = _T("\\x");
	wxString endnoteMkr = _T("\\fe"); // BEW added 16Jan06
	int mkrLen = 0;

	// get rid of any initial spaces
	while (markers.GetChar(0) == _T(' '))
	{
		markers.Remove(0,1);
	}

	// handle any initial endmarker - it causes a halt unless it has TextType
	// of none, or is an endmarker for embedded markers in a footnote or cross
	// reference section, (BEW added:) or is \note*
	if (markers.GetChar(0) == gSFescapechar)
	{
		pBuff = markers.GetData(); //GetWriteBuf(bufLen + 1);
		pBufStart = (wxChar*)pBuff;
		wxChar* pEnd;
		pEnd = pBufStart + bufLen; // whm added
		wxASSERT(*pEnd == _T('\0')); //// whm added
		itemLen = pDoc->ParseMarker(pBufStart);
		wxString mkr(pBufStart,itemLen);
		mkr = MakeReverse(mkr);
		bool bIsEndMkr = FALSE;
		if (mkr.GetChar(0) == _T('*'))
		{
			// markers begins with an endmarker, determine whether it is one
			// which halts scanning or not
			itemLen++; // increment to encompass the following space
			bIsEndMkr = TRUE;
		}
		mkr = MakeReverse(mkr);
		if (bIsEndMkr)
		{
			// is it \f* or \x* ? (or if PngOnly is current, \F or \fe ?)
			if (mkr == ftnoteMkr + _T('*'))
				return TRUE; // halt scanning
			if (mkr == xrefMkr + _T('*'))
				return TRUE;
			if (gpApp->gCurrentSfmSet == UsfmOnly && (mkr == endnoteMkr + _T('*'))) // BEW added 16Jan06
				return TRUE;
			if (gpApp->gCurrentSfmSet == PngOnly && (mkr == _T("\\fe") || mkr == _T("\\F")))
				return TRUE;

			// find out if it is an embedded marker with TextType of none - we don't
			// halt for these; (BEW added:) nor for \note*
			if (mkr == noteMkr + _T('*'))
				return FALSE; // don't halt scanning for this
			mkrLen = mkr.Length();
			bareMkr = mkr;
			bareMkr = bareMkr.Left(mkrLen - 1);
			bareMkr = bareMkr.Mid(1);
			pAnalysis = pDoc->LookupSFM(bareMkr);
			if (pAnalysis == NULL)
				return TRUE; // halt for an unknown endmarker (never should be such a thing anyway)
			if (pAnalysis->textType == none)
				return FALSE; // don't halt scanning for these

			// we don't halt for embedded endmarkers in footnotes or cross references (USFM set only) either
			int nFound = mkr.Find(ftnoteMkr); // if true, \f is contained within mkr
			if (nFound >= 0 && mkrLen > 2)
				return FALSE; // must be \fr*, \fk*, etc - so don't halt
			nFound = mkr.Find(xrefMkr); // if true, \x is contained within mkr
			if (nFound >= 0 && mkrLen > 2)
				return FALSE; // must be \xr*, \xt*, \xo*, etc - so don't halt

			// halt for any other endmarker
			return TRUE;
//			markers.Delete(0,itemLen);
		}
	}
//	if (markers.IsEmpty())
//		return FALSE; // don't halt if all there was in m_markers was an endmarker

	// something else is present, so check it out
	curPos = markers.Find(gSFescapechar);
	if (curPos == -1)
		// there are no SF markes left in the string
		return FALSE; // don't halt scanning

	// we've a marker to deal with, and its not a filtered one - so we'll halt now unless
	// the marker is one like \k , or \it ,  or \sc , or \bd etc - these have TextType none
	bufLen = markers.Length();
	pBuff = markers.GetData(); //GetWriteBuf(bufLen + 1);
	pBufStart = (wxChar*)pBuff;
	wxChar* pEnd;
	pEnd = pBufStart + bufLen; // whm added
	wxASSERT(*pEnd == _T('\0')); // whm added
	ptr = pBufStart + curPos;
	bareMkr = pDoc->GetBareMarkerForLookup(ptr);
	//markers.ReleaseBuffer();
	pAnalysis = pDoc->LookupSFM(bareMkr);
	if (pAnalysis == NULL)
		// an unknown marker should halt scanning
		return TRUE;
	if (pAnalysis->textType == none)
		return FALSE; // don't halt scanning for these

	// if it's an embedded marker in a footnote or cross reference section, then these don't
	// halt scanning
	wxString mkr = _T("\\") + bareMkr; // this is genuine backslash not PathSeparator
	mkrLen = mkr.Length();
	int nFound = mkr.Find(ftnoteMkr); // if true, \f is contained within mkr
	if (nFound >= 0 && mkrLen > 2)
		return FALSE; // must be \fr, \fk, etc - so don't halt
	nFound = mkr.Find(xrefMkr); // if true, \x is contained within mkr
	if (nFound >= 0 && mkrLen > 2)
		return FALSE; // must be \xr*, \xt*, \xo*, etc - so don't halt

	return TRUE; // anything else should halt scanning
}

/**********************************************************************
*  DestroyElements
*
* Returns: nothing
*
* Parameters:
*	pArr	->	pointer to the global gpFreeTransArray which contains FreeTrElement structs - each of which
*				contains the information relevant to writing a subpart of the free translation in a single
*				rectangle under a single strip
* Remarks:
*	The global structures and variables are used over and over while writing out the free translation
*	text in the client area, and so we need this function to clear out the array each time we come to
*	the next section of the free translation. Used by DrawFreeTranslations().
*
***********************************************************************/
void CAdapt_ItView::DestroyElements(wxArrayPtrVoid* pArr)
{
	int size = pArr->GetCount();
	if (size == 0)
		return;
	FreeTrElement* pElem;
	int i;
	for (i = 0; i < size; i++)
	{
		pElem = (FreeTrElement*)pArr->Item(i);
		delete pElem;
	}
	pArr->Clear();
}

/**********************************************************************
*  HasWordFinalPunctuation
*
* Returns: TRUE if the passed in word or phrase has word-final punctuation at its end, else FALSE
*
* Parameters:
*	pSP		->	pointer to the CSourcePhrase instance which stores the phrase parameter as a member
*	phrase	->	the word or phrase being considered (actually, pSP->m_targetStr)
*	punctSet->	reference to a string of target language punctuation characters containing no spaces
* Remarks:
*	We can't simply search for a non-empty m_follPunct member of pSrcPhrase in order to end a free
*	translation section, because if we have a lot of typing in a retranslation, then there will be
*	several final placeholders in the source text line, and these will have their m_follPunct members
*	empty; so we must check for final punctuation in the target text line instead, and the only way
*	to do this is to look for final punctuation in the m_targetStr member of pSrcPhrase - this will
*	have content, even throughout a retranslation
*	BEW modified 25Nov05; the above algorithm breaks down in document sections which have not yet
*	been adapted, because then there is no target text to examine! So when the m_targetStr member
*	is empty, we will indeed instead check for a non-empty m_follPunct member!
*
***********************************************************************/
bool CAdapt_ItView::HasWordFinalPunctuation(CSourcePhrase* pSP, wxString phrase, wxString& punctSet)
{
	// beware, phrase can sometimes have a final space following punctuation - so first
	// remove trailing spaces
	phrase = MakeReverse(phrase);
	while (phrase.GetChar(0) == _T(' ')) // remove (now initial) spaces, if any
		phrase.Remove(0,1); // need second param of 1 otherwise will truncate
	wxString endingPuncts;
	if (phrase.IsEmpty())
	{
		if (!pSP->m_follPunct.IsEmpty())
			return TRUE;
		else
			return FALSE;
	}
	else
	{
		endingPuncts = SpanIncluding(phrase, punctSet); 
		return !endingPuncts.IsEmpty();
	}
}

/**********************************************************************
*  TruncateToFit
*
* Returns: a CString which is the truncated text with an ellipsis (...) at the end
*
* Parameters:
*	pDC				->	pointer to the device context used for drawing the view
*	str				->	the string which is to be elided to fit the available drawing rectangle
*	ellipsis		->	the ellipsis text (three dots)
*	totalHExtent	->	the total horizontal extent (pixels) available in the drawing rectangle
*						to be used for drawing the elided text. It is the caller's responsibility
*						to work out when this function needs to be called.
* Remarks:
*	Called in DrawFreeTranslations() when there is a need to shorten a text substring to fit
*	within the available drawing space in the layout
*
***********************************************************************/
wxString CAdapt_ItView::TruncateToFit(wxDC* pDC,wxString& str,wxString& ellipsis,int totalHExtent)
{
	wxSize extent;
	wxString text = str;
	wxString textPlus;
a:	text.Remove(text.Length() - 1,1); 
	textPlus = text + ellipsis;
	pDC->GetTextExtent(textPlus,&extent.x,&extent.y); 
	if (extent.x <= totalHExtent) 
		return textPlus; // return truncated text with ellipsis at the end, as soon as it fits
	else
	{
		if (text.Length() > 0)
			goto a;
		else
		{
			text.Empty();
			return text;
		}
	}
}

/**********************************************************************
*  SegmentToFit
*
* Returns: a CString which is the segmented input text (integral number of whole words) that will
			fit within the passed in extent
*
* Parameters:
*	pDC				->	pointer to the device context used for drawing the view
*	str				->	the string which is to be segmented to fit the available drawing rectangle
*	ellipsis		->	the ellipsis text (three dots)
*	horizRectExtent	->	the horizontal extent (pixels) available in the drawing rectangle to be
*						used for drawing the segmented text
*	fScale			->	scaling factor to be used if the text is smaller than the available total
*						space (ie. all rectangles), we use fScale if bUseScale is TRUE, and with it
*						we scale the horizontal extent (horizExtent) to be a lesser number of whole
*						pixels when the text is comparatively short, so that we get a better distribution
*						of words between the available drawing rectangles. (bUseScale is passed in as
*						FALSE if we know in the caller that the total text is too long for the sum of
*						the available drawing rectangles for it all to fit)
*	offset			<-	pass back to the caller the offset of the first character in str which is not
*						included in the returned CString - the caller will use this offset to do a
*						.Mid(offset) call on the passed in string, to shorten it  for the next iteration's
*						call of SegmentToFit()
*	nIteration		->	the iteration count for this particular rectangle
*	nIterBound		->	the highest value that nIteration can take (equal to the total number of drawing
*						rectangles for this free translation section, less one)
*	bTryAgain		<->	passing in FALSE allows fScale to be used, passing in TRUE prevents it being used
*	bUseScale		->	whether or not to do scaling of the rectangle extents to give a better
*						segmentation results - ie. distributing words more evenly than would be the case
*						if unscaled rectangle extents were used for the calculations
* Remarks:
*	Called in DrawFreeTranslations() when there is a need to work out what the suitable substring should
*	be for the drawing rectangle with the passed in horizExtent value. Note: bUseScale will be ignored
*	on the last iteration (ie.for the last drawing rectangle) because the function must try to get all
*	of the remaining string text drawn within this last rectangle if possible, so for the last rectangle
*	we try fit what remains and if it won't go, then we truncate the text. The bTryAgain parameter enables
*	a TRUE value to be sent back to the caller (SegmentFreeTranslation()) so that the caller can request
*	a complete recalculation without any rectangle scaling by fScale being done - we want to do this when
*	scaling has cut a free translation string too early and the last rectangle's text got truncated - so
*	we want a second run with no scaling so that we minimize the possibility of truncation being needed
*
***********************************************************************/
wxString CAdapt_ItView::SegmentToFit(wxDC* pDC,wxString& str,wxString& ellipsis,int horizRectExtent,float fScale,
								int& offset,int nIteration,int nIterBound,bool& bTryAgain,bool bUseScale)
{
	wxString subStr;
	wxSize extent;
	pDC->GetTextExtent(str,&extent.x,&extent.y); 
	int nStrExtent = extent.x; // the passed in substring str's text extent (horiz)
	int len = str.Length();
	int nHExtent = horizRectExtent;
	int ncount;
	int nShortenBy;
	if (bUseScale && !bTryAgain)
	{
		// don't use the scaling factor if bTryAgain is TRUE, but if FALSE it can be used provided
		// bUseScale is TRUE (and the latter will be the case if the caller knows the text is shorter than
		// the total rectangle horizontal extents)
		nHExtent = (int)(horizRectExtent * fScale); // this is a lesser number of pixels than horizRectExtent
		// the scaling effectively gives us shorter rectangles for our segmenting calculations
	}

	// work out how much will fit - start at 5 characters, since we can be sure that much is fittable
	if (nIteration < nIterBound)
	{
		ncount = 5;
		subStr = str.Left(ncount);
		pDC->GetTextExtent(subStr,&extent.x,&extent.y); 
		while (extent.x < nHExtent && ncount < len) 
		{
			ncount++;
			subStr = str.Left(ncount);
			pDC->GetTextExtent(subStr,&extent.x,&extent.y); 
		}

		// did we get to the end of the str and it all fits?
		if (extent.x < nHExtent)
		{
			offset = len;
			return subStr;
		}

		// we didn't get to the str's end, so work backwards until we come to a space
		subStr = MakeReverse(subStr);
		int nFind = (int)subStr.Find(_T(' '));
		if (nFind == -1)
		{
			// there was no space character found, so this rectangle can't have anything drawn in it
			// - that is, we can't make a whole word fit within it
			subStr.Empty();
			offset = 0;
		}
		else
		{
			nShortenBy = nFind;
			wxASSERT( nShortenBy >= 0);
			ncount -= nShortenBy;
			subStr = str.Left(ncount); // this includes a trailing space, even if nShortenBy was 0
			offset = ncount; // return the offset value that ensures the caller's .Mid() call will remove
							// the trailing space as well (beware, the resulting shortened string may
							// still begin with a space, because the user may have typed more than one
							// space between words, so the caller must do a Trim() anyway
			// remove the final space, so we are sure it will fit
			subStr.Trim(FALSE); // trim left end
			subStr.Trim(TRUE); // trim right end
		}
		return subStr;
	}
	else
	{
		// we are at the last rectangle, so do the best we can and ignore scaling
		offset = len;
		subStr = str;
		subStr.Trim(FALSE); // trim left end
		subStr.Trim(TRUE); // trim right end
		// recalculate, in case lopping off a trailing space has now made it able to fit
		pDC->GetTextExtent(subStr,&extent.x,&extent.y);
		nStrExtent = extent.x; 
		if (nStrExtent < horizRectExtent)
		{
			// it's all gunna fit, so just return it
			;
		}
		else
		{
			// it ain't gunna fit, so truncate
			subStr = TruncateToFit(pDC,str,ellipsis,horizRectExtent);

			// here is where we can set bTryAgain to force a recalculation without the scaling factor
			if (!bTryAgain && bUseScale)
			{
				bTryAgain = TRUE; // tell the caller to initiate a recalculation
			}
			/* we don't need this block because on the second attempt we return to a different block
				in the caller, and so bTryAgain's value is not again tested, so we can't keep looping
			else if (bTryAgain && bUseScale)
			{
				bTryAgain = FALSE; // after the second try, clear the boolean to prevent an
								   //  infinite loop of recalculation attempts
			}
			*/
		}
		return subStr;
	}
}

/**********************************************************************
*  DrawFreeTranslations
*
* Returns: nothing
*
* Parameters:
*	pDC		->	pointer to the device context used for drawing the view
*	pBundle	->	pointer to the bundle, which has just been (possibly recalculted and) drawn - all the
*				strips, piles, cells and backgrounding has been done before DrawFreeTranslation() is
*				called; so this function's task is just to work out what bits of free translation text
*				need to be drawn where - and do it
* whm added parameters below 24Aug06 and 31May07
*	drawFTCaller -> enum value either call_from_ondraw, or call_from_edit - when call_from_ondraw all free
*					translations within the view are drawn; when call_from_edit, only the free translation
*					being edited is redrawn as editing is being done
* Remarks:
*	Called in the view's OnDraw() function, which gets invoked whenever a paint message has been received,
*	but DrawFreeTranslations is only done when free translation mode is turned on, otherwise it is skipped.
*	Internally, it intersects each rectangle, and the whole of each free translation section (which may
*	span several strips), with the client rectangle for the view - and when the intersection is null, it
*	skips further calculations at that point and draws nothing; furthermore, then the function determines
*	that all further drawing will be done below the bottom of the client rect, it exits. The data structures
*	and variables the function requires are, for the most part, globals defined at the start of the view
*	class's file Adapt_ItView.cpp.
*
*   whm: With its six jump labels, and thirteen gotos, the logic of this function is very convoluted and 
*   difficult to follow - BEWARE!
*   TODO: Rewrite with simpler logic!
*
***********************************************************************/
void CAdapt_ItView::DrawFreeTranslations(wxDC* pDC, CSourceBundle* pBundle, enum DrawFTCaller drawFTCaller)
{
	CAdapt_ItView* pView = gpApp->GetView();
	wxASSERT(pView != NULL);
	DestroyElements(gpFreeTransArray);
	CPile*  pPile; // a scratch pile pointer
	CStrip* pStrip; // a scratch strip pointer
	wxRect rect; // a scratch rectangle variable
	int curStripIndex;
	int curPileIndex;
	int curPileCount;
	int nTotalHorizExtent; // the sum of the horizonal extents of the subrectangles which make up
						   // the laid out possible writable areas for the current free trans section
	wxPoint topLeft;
	wxPoint botRight;
	CSourcePhrase* pSrcPhrase;
	FreeTrElement* pElement;
	wxSize extent;
	bool bSectionIntersects = FALSE;
	pPile = pBundle->m_pStrip[0]->m_pPile[0]; // first pile in bundle
	pSrcPhrase = pPile->m_pSrcPhrase; // its pointed at sourcephrase
	wxString ellipsis = _T("...");
	wxString ftStr;
	wxArrayString subStrings;
	wxRect testRect = grectViewClient; // need a local, because an intersect test
									  // changes the calling rectangle
	wxString theMkr = _T("\\free");
	wxString theEndMkr = _T("\\free*");

	// ready the drawing context - we must handle ANSI & Unicode, and for the former we use TextOut()
	// and for the latter we use DrawText() and the Unicode app can be LTR or RTL script (we use
	// same text rending directionality as the target text line) - code from CCell.cpp and CText.cpp
	// can be reused here
	// wx version note: wx version always uses DrawText

	wxRect rectBounding;
	bool bRTLLayout = FALSE;
	#ifdef _RTL_FLAGS
	//wxUint32 nFormat; // for specifying directionality
	//nFormat = gnFormat; // this global has the basic value (LTR assumed), DT_LEFT is default
	// wx note: wx's DrawText() does not have an nFormat parameter to indicate directionality
	// and alignment, so I'll use a separate bool bRTLLayout to signal when we must do RTL
	// and right alignment.
	if (gpApp->m_bTgtRTL)
	{
		ellipsis = _T('\u2026'); // use a unicode ellipsis for RTL
		// free translation has to be RTL & aligned RIGHT
		bRTLLayout = TRUE; //nFormat = gnRTLFormat;
	}
	else
	{
		// free translation has to be LTR & aligned LEFT
		bRTLLayout = FALSE; //nFormat = gnLTRFormat;
	}
	#endif

	// set up a new colour - make it a purple, hard coded in app as m_freetransTextColor
	wxFont pSaveFont;
	wxFont* pFreeTransFont = gpApp->m_pTargetFont;
	pSaveFont = pDC->GetFont();
	pDC->SetFont(*pFreeTransFont);
	wxColour color(gpApp->m_freeTransTextColor);
	if (!color.IsOk())
	{
		::wxBell(); 
		wxASSERT(FALSE);
	}
	pDC->SetTextForeground(color); 

	// for wx testing we make the background yellow in order to verify the extent of each DrawText
	// and clearing of remaining free translation's rect segment
	//pDC->SetBackgroundMode(gpApp->m_backgroundMode);
	//pDC->SetTextBackground(wxColour(255,255,0));
	// wx testing above

	/* THE LOOP FOR ITERATING OVER ALL FREE TRANSLATION SECTIONS IN THE BUNDLE BEGINS HERE */

	#ifdef _Trace_DrawFreeTrans
	TRACE0("\n\n BEGIN - Loop About To Start in DrawFreeTranslations()\n\n");
	#endif

	// whm: I moved the following declarations and initializations here from way below 
	// to avoid compiler warnings:
	bool bTextIsTooLong = FALSE;
	int totalRects = 0;
	int offset = 0;
	int length = 0;

	// whm added 25Aug06 if we are being called from the OnEnChangeEditBox handler we can assume that
	// the screen display has been drawn with the any existing free translations, including the one
	// we may be editing. Since we are editing a single free translation, we can just update the free 
	// translation associated with the first pile in gpCurFreeTrasnSectionPileArray. So, we can go 
	// directly there without having to worry about drawing any other free translations.
	if (drawFTCaller == call_from_edit)
	{
		// if we are not presently at the pile where the phrase box currently is, keep scanning
		// piles until we are (or encounter the end of the doc - an error)
		while (pPile != NULL && !pPile->m_bIsCurrentFreeTransSection)
		{
			pPile = GetNextPile(pPile);
		}
		// when DrawFreeTranslations is called from the composebar's editbox, there should certainly
		// be a valid pPile to be found
		wxASSERT(pPile != NULL && pPile->m_bIsCurrentFreeTransSection);
		// if this is a new free translation which has not been entered at this location before,
		// and the user just typed the first character, the free trans flags on the source phrases
		// will not have been set, but they must be set for the code below to properly define this
		// free translation element
		CPile* pCurrentPile;
		int j;
		for (j = 0; j < (int)gpCurFreeTransSectionPileArray->GetCount(); j++)
		{
			// set the common flags
			pCurrentPile = (CPile*)gpCurFreeTransSectionPileArray->Item(j);
			pCurrentPile->m_pSrcPhrase->m_bHasFreeTrans = TRUE;
			pCurrentPile->m_pSrcPhrase->m_bEndFreeTrans = FALSE;
			pCurrentPile->m_pSrcPhrase->m_bStartFreeTrans = FALSE;
		}
		// set the beginning one
		pCurrentPile = (CPile*)gpCurFreeTransSectionPileArray->Item(0);
		pCurrentPile->m_pSrcPhrase->m_bStartFreeTrans = TRUE;
		// set the ending one
		pCurrentPile = (CPile*)gpCurFreeTransSectionPileArray->Item(gpCurFreeTransSectionPileArray->GetCount()-1);
		pCurrentPile->m_pSrcPhrase->m_bEndFreeTrans = TRUE;
		goto ed;
	}

	// The a: labeled while loop below is skipped whenever drawFTCaller == call_from_edit
	// find the next free translation section
a:	while ((pPile != NULL) && (!pPile->m_pSrcPhrase->m_bStartFreeTrans))
	{
		pPile = GetNextPile(pPile);

		#ifdef _Trace_DrawFreeTrans
		#ifdef __WXDEBUG__
		if (pPile)
		{
			TRACE2("while     sn = %d  ,  word =  %s\n", pPile->m_pSrcPhrase->m_nSequNumber,
						pPile->m_pSrcPhrase->m_srcPhrase.c_str());
			TRACE2("  Has?   %d   ,   Start?   %d\n",pPile->m_pSrcPhrase->m_bHasFreeTrans,
				pPile->m_pSrcPhrase->m_bStartFreeTrans);
		}
		#endif
		#endif
	}

	// did we find a free translation section?
ed:	if (pPile == NULL)
	{
		#ifdef _Trace_DrawFreeTrans
		TRACE0("** exiting due to null pile while scanning ahead **\n");
		#endif

		// there are as yet no free translations in this bundle, or we've come to its end
		DestroyElements(gpFreeTransArray); // don't leak memory
		return;
	}
	pSrcPhrase = pPile->m_pSrcPhrase;

	// was the one we found the current one (that is, where the phrase box currently is)? If so, we choose to
	// skip it because we can't be certain of a valid free translation being there yet

	// BEW commented out the next line 11Sep08 because it appears to not be needed and when in vertical
	// edit mode, entering the free translation section which was just removed the next line tries to
	// do a GetAt() call on an empty list - which is illegal
	//CPile* pCurrentPile = (CPile*)gpCurFreeTransSectionPileArray->GetAt(0); // the anchor pile

	// whm commented out the block below in order to be able to see the current free translation
	// updated real-time within the main window.
	//if (pPile == pCurrentPile)
	//{
	//	// skip this section
	//	int sectCount = gpCurFreeTransSectionPileArray->GetCount();
		//pCurrentPile = (CPile*)gpCurFreeTransSectionPileArray->Item(sectCount - 1); // last pile in the array
	//	wxASSERT(pCurrentPile);
	//	pCurrentPile = GetNextPile(pCurrentPile);
	//	if (pCurrentPile == NULL)
	//	{
	//		#ifdef _Trace_DrawFreeTrans
	//		TRACE0("** exiting in skip current section block **\n");
	//		#endif

	//		DestroyElements(gpFreeTransArray); // don't leak memory
	//		return; // we are at the end of the bundle, and nothing more to be written
	//	}
	//	pPile = pCurrentPile; // this is the first one past the current section (it may or may not be an anchor)
	//	goto a; // move forward, if necessary, to find the next anchor pile for a section to be written out
	//}

	// if we get here, we've found the next one's start - save the pile for later on (we won't
	// use it until we are sure it's free translation data is to be written within the client rectangle
	// of the view)
	gpFirstPile = pPile;

	// create the elements (each a struct containing int horizExtent and wxRect subRect)
	// which define the places where the free translation substrings are to be written out,
	// and initialize the strip and pile parameters for the loop
	pStrip = pPile->m_pStrip;
	curStripIndex = pStrip->m_nStripIndex;
	curPileIndex = pPile->m_nPileIndex;
	curPileCount = pStrip->m_nPileCount;
	pElement = new FreeTrElement; // this struct is defined in CAdapt_ItView.h
	rect = pStrip->m_rectFreeTrans; // start with the full rectangle, and reduce as required below
	bSectionIntersects = FALSE; // TRUE when the section being laid out intersects the window's client area
	nTotalHorizExtent = 0;

	#ifdef _Trace_DrawFreeTrans
	TRACE3("curPileIndex  %d  , curStripIndex  %d   , curPileCount %d  \n",
				curPileIndex,curStripIndex,curPileCount);
	#endif

	if (gbRTL_Layout)
	{
		// source is to be laid out right-to-left, so free translation rectangles will be altered in location
		// from what would be the case for a LTR layout
		rect.SetRight(pPile->m_rectPile.GetRight());	// this fixes where the writable area starts
		// is this pile the ending pile for the free translation section?
e:		if (pSrcPhrase->m_bEndFreeTrans)
		{
			// whether we make the left boundary of rect be the left of the pile's rectangle, or let it be
			// the leftmost remainder of the strip's free translation rectangle, depends on whether or not
			//  this pile is the last in the strip - found out, and set the .left parameter accordingly
			if (curPileIndex == curPileCount - 1)
			{
				// last pile in the strip, so use the full width (so no change to rect is needed)
				;
			}
			else
			{
				// more piles to the left, so terminate the rectangle at the pile's left boundary
				// REMEMBER!! When an upper left coordinate of an existing wxRect is set to a 
				// different value (with intent to change the rect's size as well as its position),
				// we must also explicitly change the width/height by the same amount. Here the correct 
				// width of rect is critical because in RTL we want to use the upper right coord of rect, 
				// and transform its value to the mirrored coordinates of the underlying canvas.
				rect.SetLeft(pPile->m_rectPile.GetLeft()); // this only moves the rect
				rect.SetWidth(abs(pStrip->m_rectFreeTrans.GetRight() - pPile->m_rectPile.GetLeft())); // use abs to make sure
			}
			// store in the pElement's subRect member (don't compute the substring yet, to save
			// time since the rect may not be visible), add the element to the pointer array
			pElement->subRect = rect;
			pElement->horizExtent = rect.GetWidth(); 
			nTotalHorizExtent += pElement->horizExtent;
			gpFreeTransArray->Add(pElement);

			// determine whether or not this free translation section is going to have to be written
			// out in whole or part
			testRect = grectViewClient; // need a scratch testRect, since its values are changed in the
										// following test for intersection, so can't use grectViewClient
			//bool bIntersects = testRect.IntersectRect(&grectViewClient,&rect);
			// The intersection is the largest rectangle contained in both existing
			// rectangles. Hence, when IntersectRect(&r,&rectTest) returns TRUE, it
			// indicates that there is some client area to draw on.
			if (testRect.Intersects(rect)) //if (bIntersects)
				bSectionIntersects = TRUE; // we'll have to write out at least this much of this section
			goto b; // exit the loop for constructing the drawing rectangles
		}
		else
		{
			// the current pile is not the ending one, so check the next - also check out when a strip
			// changes, and restart there with a new rectangle calculation after saving the earlier element
			if (curPileIndex == curPileCount - 1)
			{
				// we are at the end of the strip, so we have to close off the current rectangle and store it
				pElement->subRect = rect;
				pElement->horizExtent = rect.GetWidth(); 
				nTotalHorizExtent += pElement->horizExtent;
				gpFreeTransArray->Add(pElement);

				// will we have to draw this rectangle's content?
				testRect = grectViewClient;
				if (testRect.Intersects(rect)) 
					bSectionIntersects = TRUE;

				// are there more strips? (we may have come to the end of the bundle) (for a partial section
				// at a bundle boundary, we just show as much of it as we possibly can without changing the bundle)
				if (curStripIndex == pBundle->m_nStripCount - 1)
				{
					// there are no more strips, so this free translation section will be truncated to whatever
					// rectangles we've set up so far
					goto b;
				}
				else
				{
					// we are not yet at the end of the strips, so we can be sure there is a next pile
					// so get it, and its sourcephrase pointer
					wxASSERT(curStripIndex < pBundle->m_nStripCount - 1);
					pPile = GetNextPile(pPile);
					wxASSERT(pPile);
					pSrcPhrase = pPile->m_pSrcPhrase;

					// initialize rect to the new strip's free translation rectangle, and
					// reinitialize the strip and pile parameters for this new strip
					pStrip = pPile->m_pStrip;
					curStripIndex = pStrip->m_nStripIndex;
					curPileCount = pStrip->m_nPileCount;
					curPileIndex = pPile->m_nPileIndex;

					// get a new element
					pElement = new FreeTrElement;
					rect = pStrip->m_rectFreeTrans; // rect.right is already correct, since this is pile[0]

					// this new pile might be the one for the end of the free translation section, so
					// check it out
					goto e;
				}
			}
			else
			{
				// there is at least one more pile in this strip, so check it out
				pPile = GetNextPile(pPile);
				wxASSERT(pPile);
				pSrcPhrase = pPile->m_pSrcPhrase;
				curPileIndex = pPile->m_nPileIndex;
				goto e;
			}
		}
	}
	else
	{
		// LTR layout, and this is the only option for the non-unicode application
		// REMEMBER!! When an upper left coordinate of an existing wxRect is set to a 
		// different value (with intent to change the rect's size as well as its position,
		// we must also explicitly change the width/height by the same amount. The ending width 
		// of the rect here has no apparent affect on the resulting text being displayed 
		// because only the upper left coordinates in LTR are significant in DrawText operations 
		// below
		rect.SetLeft(pPile->m_rectPile.GetLeft()); // this fixes where the writable area starts
		rect.SetWidth(abs(pStrip->m_rectFreeTrans.GetRight() - pPile->m_rectPile.GetLeft())); // use abs to make sure

		// is this pile the ending pile for the free translation section?
d:		if (pSrcPhrase->m_bEndFreeTrans)
		{
			// whether we make the right boundary of rect be the end of the pile's rectangle, or let it be
			// the remainder of the strip's free translation rectangle, depends on whether or not this pile
			// is the last in the strip - found out, and set the .right parameter accordingly
			if (curPileIndex == curPileCount - 1)
			{
				// last pile in the strip, so use the full width (so no change to rect is needed)
				;
			}
			else
			{
				// more piles to the right, so terminate the rectangle at the pile's right boundary
				rect.SetRight(pPile->m_rectPile.GetRight());
			}
			// store in the pElement's subRect member (don't compute the substring yet, to save
			// time since the rect may not be visible), add the element to the pointer array
			pElement->subRect = rect;
			pElement->horizExtent = rect.GetWidth(); 
			nTotalHorizExtent += pElement->horizExtent;
			gpFreeTransArray->Add(pElement);

			// determine whether or not this free translation section is going to have to be written
			// out in whole or part
			testRect = grectViewClient;
			if (testRect.Intersects(rect))
				bSectionIntersects = TRUE; // we'll have to write out at least this much of this section
			goto b; // exit the loop for constructing the drawing rectangles
		}
		else
		{
			// the current pile is not the ending one, so check the next - also check out when a strip
			// changes, and restart there with a new rectangle calculation after saving the earlier element
			if (curPileIndex == curPileCount - 1)
			{
				// we are at the end of the strip, so we have to close off the current rectangle and store it
				pElement->subRect = rect;
				pElement->horizExtent = rect.GetWidth();
				nTotalHorizExtent += pElement->horizExtent;
				gpFreeTransArray->Add(pElement);

				// will we have to draw this rectangle's content?
				testRect = grectViewClient;
				if (testRect.Intersects(rect))
					bSectionIntersects = TRUE;

				// are there more strips? (we may have come to the end of the bundle) (for a partial section
				// at a bundle boundary, we just show as much of it as we possibly can without changing the bundle)
				if (curStripIndex == pBundle->m_nStripCount - 1)
				{
					// there are no more strips, so this free translation section will be truncated to whatever
					// rectangles we've set up so far
					goto b;
				}
				else
				{
					// we are not yet at the end of the strips, so we can be sure there is a next pile
					// so get it, and its sourcephrase pointer
					wxASSERT(curStripIndex < pBundle->m_nStripCount - 1);
					pPile = GetNextPile(pPile);
					wxASSERT(pPile != NULL); 
					pSrcPhrase = pPile->m_pSrcPhrase;

					// initialize rect to the new strip's free translation rectangle, and
					// reinitialize the strip and pile parameters for this new strip
					pStrip = pPile->m_pStrip;
					curStripIndex = pStrip->m_nStripIndex;
					curPileCount = pStrip->m_nPileCount;
					curPileIndex = pPile->m_nPileIndex;

					// get a new element
					pElement = new FreeTrElement;
					rect = pStrip->m_rectFreeTrans; // rect.left is already correct, since this is pile[0]

					// this new pile might be the one for the end of the free translation section, so
					// check it out
					goto d;
				}
			}
			else
			{
				// there is at least one more pile in this strip, so check it out
				pPile = GetNextPile(pPile);
				wxASSERT(pPile != NULL); 
				pSrcPhrase = pPile->m_pSrcPhrase;
				curPileIndex = pPile->m_nPileIndex;
				goto d;
			}
		}
	}

	// rectangle calculations are finished, and stored in FreeTrElement structs in gpFreeTransArray
b:	if (!bSectionIntersects)
	{
		// nothing in this current section of free translation is visible in the view's client rectangle
		// so if we are not below the bottom of the latter, iterate to handle the next section, but if
		// we are below it, then we don't need to bother with futher calculations & can return immediately
		pElement = (FreeTrElement*)gpFreeTransArray->Item(0);
		if (pElement->subRect.GetTop() > grectViewClient.GetBottom()) // view only, MM_TEXT mode, y-axis positive downwards
		{
			#ifdef _Trace_DrawFreeTrans
			TRACE0("No intersection, *** and below bottom of client rect, so return ***\n");
			#endif
			DestroyElements(gpFreeTransArray); // don't leak memory
			return; // we are done
		}
		else
		{
			#ifdef _Trace_DrawFreeTrans
			TRACE0("No intersection, so iterating loop...\n");
			#endif
			DestroyElements(gpFreeTransArray); // don't leak memory
			goto c;
		}
	}

	// the whole or part of this section must be drawn, so do the calculations now; first, get
	// the free translation text
	pSrcPhrase = gpFirstPile->m_pSrcPhrase;
	offset = 0;
	length = 0;
	ftStr = GetExistingMarkerContent(theMkr, theEndMkr, pSrcPhrase, offset, length);
	// whm note: length is the length of the free trans string within the m_markers member.
	// Since Bruce has globals tracking these, and since under certain circumstances
	// (i.e., when an editing change is made by typing over and replacing a selection
	// in which case it is two successive edit operations - first delete of the selection
	// and second addition of the replacement) there can be two calls to our OnEditBoxChanged
	// for a single editing action, we need to keep the globals in sync here
	// The length needs to be the length BEFORE padding with spaces (done below)
	gnLengthInMarkersStr = length;
	// offset is the position of the free trans string within the m_markers member
	gnOffsetInMarkersStr = offset;

	#ifdef _Trace_DrawFreeTrans
	TRACE2("Sequ Num  %d  ,  Free Trans:  %s \n", pSrcPhrase->m_nSequNumber, ftStr.c_str());
	#endif

	// whm changed 24Aug06 when called from OnEnChangedEditBox, we need to be able to allow
	// user to delete the contents of the edit box, and draw nothing, so we'll not jump out 
	// early here because the new length is zero.
	if (drawFTCaller == call_from_ondraw)
	{
		if (length == 0)
		{
			// there is no text to be written to the screen, so continue with the next free 
			// translation section
			goto c;
		}

		// trim off any leading or trailing spaces
		ftStr.Trim(FALSE); // trim left end
		ftStr.Trim(TRUE); // trim right end
		if (ftStr.IsEmpty())
		{
			// nothing to write, so move on
			goto c;
		}
	}
	// get text's extent (a wxSize object) and compare to the total horizontal extent of the rectangles.
	// also determine the number of rectangles we are to write this section into, and initialize
	// other needed data
	pDC->GetTextExtent(ftStr,&extent.x,&extent.y);
	bTextIsTooLong = extent.x > nTotalHorizExtent ? TRUE : FALSE;
	totalRects = gpFreeTransArray->GetCount();

	if (totalRects == 1)
	{
		// the easiest case, the whole free translation section is contained within a single strip
		pElement = (FreeTrElement*)gpFreeTransArray->Item(0);
		if (bTextIsTooLong)
		{
			ftStr = TruncateToFit(pDC,ftStr,ellipsis,nTotalHorizExtent);
		}

		// wx version always uses DrawText
		// ////////// Draw Single Strip Free Translation Text  /////////////////
		
		// clear only the subRect; this effectively allows for the erasing from the display
		// of any deleted text from the free translation string; even though this clearing of
		// the subRect is only technically needed before deletion edits, it doesn't hurt to
		// do it before every edit/keystroke. It works for either RTL or LTR text displays.
		pDC->DestroyClippingRegion();
		pDC->SetClippingRegion(pElement->subRect);
		pDC->Clear();
		pDC->DestroyClippingRegion();
		if (bRTLLayout)
		{
			// Here are some other DrawText() variations I tried:
			//pDC->DrawText(ftStr,pElement->subRect.GetRight(),pElement->subRect.GetTop());
			//pDC->DrawText(ftStr,pStrip->m_rectFreeTrans.GetWidth()+RH_SLOP - pElement->subRect.GetRight(),pElement->subRect.GetTop());
			
//#ifdef _DEBUG
//			wxSize trueSz;
//			pDC->GetTextExtent(ftStr,&trueSz.x,&trueSz.y);
//			wxLogDebug(_T("RTL DrawText sub.l=%d + sub.w=%d - ftStrExt.x=%d, x=%d, y=%d of %s"),
//				pElement->subRect.GetLeft(),pElement->subRect.GetWidth(),trueSz.x,
//				pElement->subRect.GetLeft()+pElement->subRect.GetWidth()-trueSz.x,
//				pElement->subRect.GetTop(),ftStr.c_str());
//#endif
			pView->DrawTextRTL(pDC,ftStr,pElement->subRect);
		}
		else
		{
			pDC->DrawText(ftStr,pElement->subRect.GetLeft(),pElement->subRect.GetTop());
		}
	}
	else
	{
		// the free translation is spread over at least 2 strips - so we've more work to do - call
		// SegmentFreeTranslation() to get a string array returned which has the passed in frStr cut up
		// into appropriately sized segments (whole words in each segment), truncating the last segment if
		// not all the ftStr data can be fitted into the available drawing rectangles
		SegmentFreeTranslation(pDC,ftStr,ellipsis,extent.GetWidth(),nTotalHorizExtent,gpFreeTransArray,&subStrings,totalRects);

		// draw the substrings in their respective rectangles
		int index;
		for (index = 0; index < totalRects; index++)
		{
			// get the next element
			pElement = (FreeTrElement*)gpFreeTransArray->Item(index);
			// get the string to be drawn in its rectangle
			wxString s = subStrings.Item(index);

			// draw this substring
			// ////////// Draw Multiple Strip Free Translation Text  /////////////////
			
			// clear only the subRect; this effectively allows for the erasing from the display
			// of any deleted text from the free translation string; even though this clearing of
			// the subRect is only technically needed before deletion edits, it doesn't hurt to
			// do it before every edit/keystroke. It works for either RTL or LTR text displays.
			pDC->DestroyClippingRegion();
			pDC->SetClippingRegion(pElement->subRect);
			pDC->Clear();
			pDC->DestroyClippingRegion();
			if (bRTLLayout)
			{
				// Here are some other DrawText() variations I tried:
				//pDC->DrawText(s,pElement->subRect.GetRight(),pElement->subRect.GetTop());
 				//pDC->DrawText(s,pStrip->m_rectFreeTrans.GetWidth()+RH_SLOP - pElement->subRect.GetRight(),pElement->subRect.GetTop());
 			
//#ifdef _DEBUG
//				wxSize trueSz;
//				pDC->GetTextExtent(s,&trueSz.x,&trueSz.y);
//				wxLogDebug(_T("RTL DrawText sub.l=%d + sub.w=%d - sExt.x=%d, x=%d, y=%d of %s"),
//					pElement->subRect.GetLeft(),pElement->subRect.GetWidth(),trueSz.x,
//					pElement->subRect.GetLeft()+pElement->subRect.GetWidth()-trueSz.x,
//					pElement->subRect.GetTop(),s.c_str());
//#endif
				pView->DrawTextRTL(pDC,s,pElement->subRect);
			}
			else
			{
				pDC->DrawText(s,pElement->subRect.GetLeft(),pElement->subRect.GetTop());
			}
		}

		subStrings.Clear(); // clear the array ready for the next iteration
	}

	if (drawFTCaller == call_from_edit)
	{
		// drawing of the one free translation being edited is done so return
		DestroyElements(gpFreeTransArray); // don't leak memory
		return;
	}

	// the section has been dealt with, get the next pile and iterate
c:	pPile = GetNextPile(pPile);
	if (pPile != NULL)
		pSrcPhrase = pPile->m_pSrcPhrase;
	DestroyElements(gpFreeTransArray);
	goto a;
}

/**********************************************************************
*  SegmentFreeTranslation
*
* Returns: nothing
*
* Parameters:
*	pDC				->	pointer to the device context used for drawing the view
*	str				->	the string which is to be segmented to fit the available drawing rectangles
*	ellipsis		->	the ellipsis text (three dots)
*	textHExtent		->	horizontal extent of the section's free translation text (unsegmented)
*	totalHExtent	->	the total horizontal extent (pixels) available - calculated by summing the
*						horizontal extents of all the drawing rectangles to be used for drawing the
*						subtext strings.
*	pElementsArray	->	array of FreeTrElement structs, one per drawing rectangle for this section
*	pSubstrings		<-	array of substrings formed by segmenting str into substrings which will fit,
*						one per rectangle, in the rectangles stored in pElementsArray (the caller
*						will do the drawing of these substrings in the appropriate rectangles)
*	totalRects		->	the total number of drawing rectangles available for this section (equals
*						pElementsArray->GetSize() - which is how it was calculated in the caller)
* Remarks:
*	Called in DrawFreeTranslations() when there is a need distribute the typed free translation string
*	passed in in the str parameter over a number of drawing rectangles in two or more consecutive strips -
*	hence the size of the pSubstrings array must be the same as or less than totalRects.
*
***********************************************************************/
void CAdapt_ItView::SegmentFreeTranslation(wxDC* pDC,wxString& str, wxString& ellipsis, int textHExtent,
					int totalHExtent, wxArrayPtrVoid* pElementsArray, wxArrayString* pSubstrings, int totalRects)
{
	float fScale = (float)(textHExtent / totalHExtent); // calculate the scale factor

	// adjustments are needed -- if the text is much shorter than the allowed space (considering the two
	// or more rectangles it has to be distributed over) then it isn't any good to split short text across
	// wide rectangles - instead it looks better to bunch it to the left, if necessary drawing it all in
	// the one rectangle. So for smaller and smaller values of fScale, we need to bump up fScale by bigger
	// and bigger increments; the particular values below have been determined by experimentation and appear
	// to give optimal results in terms of appearance and synchonizing meaning chunks with the layout parts
	// to which they pertain
	if (fScale > (float)0.95)
		; // make no change
	else if (fScale > (float)0.9)
		fScale = (float)0.95;
	else if (fScale > (float)0.8)
		fScale = (float)0.9;
	else if (fScale > (float)0.7)
		fScale = (float)0.87;
	else if (fScale > (float)0.6)
		fScale = (float)0.83;
	else
		fScale = (float)0.8;


	wxString remainderStr = str; // we shorten this for each iteration
	wxString subStr; // what we work out as the first part of remainderStr which will fit the current rect
	wxASSERT(pSubstrings->GetCount() == 0);
	FreeTrElement* pElement;
	int offset;
	int nIteration;
	int nIterBound = totalRects - 1;
	bool bTryAgain = FALSE; // if we use the scaling factor and we get truncation in the last rectangle
							// then we'll use a TRUE value for this flag to force a second segmentation
							// which does not use the scaling factor

a:	if (bTryAgain || textHExtent > totalHExtent)
	{
		// the text is longer than the available space for drawing it, so there is no point to doing any
		// scaling -- instead, get as much as will fit into each each rectange, and the last rectangle
		// will have to have its text elided using TruncateToFit()
		for (nIteration = 0; nIteration <= nIterBound; nIteration++)
		{
			pElement = (FreeTrElement*)pElementsArray->Item(nIteration);

			// do the calculation, ignoring fScale (hence, last parameter is FALSE)
			subStr = SegmentToFit(pDC,remainderStr,ellipsis,pElement->horizExtent,fScale,offset,
									nIteration,nIterBound,bTryAgain,FALSE);
			pSubstrings->Add(subStr);
			remainderStr = remainderStr.Mid(offset); // shorten, for next segmentation
		}
	}
	else
	{
		// we should be able to make the text fit (though this can't be guaranteed because some space is
		// wasted in each rectangle if we print whole words (which we do)) - and we'll need to do scaling
		// to ensure the best segmentation results
		for (nIteration = 0; nIteration <= nIterBound; nIteration++)
		{
			pElement = (FreeTrElement*)pElementsArray->Item(nIteration);

			// do the calculation, using fScale (hence, last parameter is TRUE)
			subStr = SegmentToFit(pDC,remainderStr,ellipsis,pElement->horizExtent,fScale,offset,
									nIteration,nIterBound,bTryAgain,TRUE);
			pSubstrings->Add(subStr);
			remainderStr = remainderStr.Mid(offset); // shorten, for next segmentation
		}

		if (bTryAgain)
		{
			pSubstrings->Clear();
			remainderStr = str;
			goto a;
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Remove Filtered Back Translations" item on the Advanced menu is disabled if there 
/// are no source phrases in the App's m_pSourcePhrases list, or the active KB pointer is NULL,
/// otherwise the menu item is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedRemoveFilteredBacktranslations(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pKB != NULL && (int)gpApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAdvancedRemoveFilteredFreeTranslations(wxCommandEvent& WXUNUSED(event))
{
	// whm added 23Jan07 check below to determine if the doc has any free translations. If not
	// an information message is displayed saying there are no free translations; then returns.
	// Note: This check could be made in the OnIdle handler which could then disable the menu
	// item rather than issuing the info message. However, if the user clicked the menu item,
	// it may be because he/she though there might be one or more free translations in the 
	// document. The message below confirms to the user the actual state of affairs concerning
	// any free translations in the current document.
	CAdapt_ItDoc* pDoc = GetDocument();
	bool bFTfound = FALSE;
	if (pDoc)
	{
		SPList* pList = gpApp->m_pSourcePhrases;
		if (pList->GetCount() > 0)
		{
			SPList::Node* pos = pList->GetFirst();
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				if (pSrcPhrase->m_bHasFreeTrans)
				{
					// set the flag on the app
					bFTfound = TRUE; 
					break; // don't need to check further
				}
			}
		}
	}
	if (!bFTfound)
	{
		// there are no free translations in the document, so tell the user and return
		wxMessageBox(_("The document does not contain any free translations."), _T(""),wxICON_INFORMATION);
		return;
	}

	// IDS_DELETE_ALL_FT_ASK
	int nResult = wxMessageBox(_("You are about to delete all the free translations in the document. Is this what you want to do?"), _T(""), wxYES_NO);
	if (nResult == wxNO)
	{
		// user clicked the command by mistake, so exit the handler
		return;
	}

	// initialize variables needed for the scan over the document's sourcephrase instances
	SPList* pList = gpApp->m_pSourcePhrases;
	SPList::Node* pos = pList->GetFirst();
	CSourcePhrase* pSrcPhrase;

	wxString mkr = _T("\\free"); // enough for standard or derived backtranslation markers



	// do the loop, removing the free translations, their filter marker wrappers also, and
	// clearing the document's free translation flags on the CSourcePhrase instances
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();

		// clear the flags
		pSrcPhrase->m_bHasFreeTrans = FALSE;
		pSrcPhrase->m_bStartFreeTrans = FALSE;
		pSrcPhrase->m_bEndFreeTrans = FALSE;

		// handle removal from m_markers member
		if (pSrcPhrase->m_markers.IsEmpty())
		{
			continue;
		}
		else
		{
			int nFound = pSrcPhrase->m_markers.Find(mkr);
			if (nFound > 0)
			{
				// there is a filtered free translation section to be deleted
				RemoveContentWrappers(pSrcPhrase,mkr,nFound + 5); // + 5 to ensure pointing past \free
			}
		} // end block for non-empty m_markers
	} // end while loop
	Invalidate();

	// mark the doc as dirty, so that Save command becomes enabled
	pDoc->Modify(TRUE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Remove Filtered Free Translations" item on the Advanced menu is disabled if there 
/// are no source phrases in the App's m_pSourcePhrases list, or the active KB pointer is NULL,
/// otherwise the menu item is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedRemoveFilteredFreeTranslations(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pKB != NULL && (int)gpApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// Moved ScrollToNearTop to CAdapt_ItCanvas in WX version
//void CAdapt_ItView::ScrollToNearTop(int nSequNum)

// when the phrase box lands at the anchor location, it may clear the m_bHasKBEntry flag, or
// the m_bHasGlossingKBEntry flag when glossing mode is on, and if there is an adaptation (or gloss)
// there when the phrase box is subsequently moved, we must make sure the flag has the appropriate
// value
void CAdapt_ItView::FixKBEntryFlag(CSourcePhrase* pSrcPhr)
{
	if (gbIsGlossing)
	{
		if (pSrcPhr->m_bHasGlossingKBEntry == FALSE)
		{
			// might be wrong value, so check and set it if necessary
			if (!pSrcPhr->m_gloss.IsEmpty())
			{
				// we need to reset it
				pSrcPhr->m_bHasGlossingKBEntry = TRUE;
			}
		}
	}
	else // we are in adapting mode
	{
		if (pSrcPhr->m_bHasKBEntry == FALSE)
		{
			// might be wrong value, so check and set it if necessary
			if (!pSrcPhr->m_targetStr.IsEmpty() && !pSrcPhr->m_bNotInKB)
			{
				// we need to reset it
				pSrcPhr->m_bHasKBEntry = TRUE;
			}
		}
	}
}

/*******************************************************************************************
*
*		Functions for Notes support
*
********************************************************************************************/

void CAdapt_ItView::OnButtonCreateNote(wxCommandEvent& WXUNUSED(event))
{
	CPile* pPile = NULL;
	CSourcePhrase* pSrcPhrase = NULL;
	gnOldSequNum = gpApp->m_nActiveSequNum; // save it, to be safe

	// create the note attached to the first sourcephrase of a selection if there is one,
	// else do it at the active location
	int nSequNum = -1;
	CCellList* pCellList;
	if (gpApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's first element
		pCellList = &gpApp->m_selection;
		CCellList::Node* fpos = pCellList->GetFirst();
		pPile = fpos->GetData()->m_pPile;
		if (pPile == NULL)
		{
			// unlikely, so an English message will do
			wxMessageBox(_T("A zero pile pointer was returned, the note dialog cannot be put up."),_T(""),
				wxICON_EXCLAMATION);
			return;
		}
		wxASSERT(pPile != NULL);
		RemoveSelection(); // need Invalidate() to be called later on
	}
	else
	{
		// no selection, so just attach the note to whatever pile the caller sets up, usually wherever
		// the phraseBox currently is located; but in the case of free translation mode being current, or
		// a note in a retranslation, the caller may calculate a different pile than the active one
		pPile = gpApp->m_pActivePile;
		if (pPile == NULL)
		{
			// unlikely, so an English message will do
			wxMessageBox(_T("A zero pile pointer was returned, the note dialog cannot be put up."),_T(""),
				wxICON_EXCLAMATION);
			return;
		}
	}
	pSrcPhrase = pPile->m_pSrcPhrase; // get the sourcephrase
	nSequNum = pSrcPhrase->m_nSequNumber; // get its sequence number
	wxASSERT(nSequNum >= 0);

	// set m_nSequNumBeingViewed, as the note dialog also uses it, not just the
	// View Filtered Material dialog (both dialogs cannot be open at the one time and so
	// we can safely use the one variable for the same purpose in the two functionalities)
	gpApp->m_nSequNumBeingViewed = nSequNum;
	Invalidate();

	// open the dialog so the user can type in a note
	wxASSERT(gpApp->m_pNoteDlg == NULL);
	gpApp->m_pNoteDlg = new CNoteDlg(gpApp->GetMainFrame()); 
	// wx version: we don't need the Create() call for modeless notes dialog
	//gpApp->m_pNoteDlg->Create(gpApp->GetMainFrame(),-1,_("Note"));
	// whm using the ...ByClick form here doesn't make sense to me unless the user purposely
	// clicks near the phrase box location of the note and avoids scrolling afterwards positioning
	// the phrasebox. AdjustDialogPositionByClick doesn't appear to avoid the phrasebox location
	// very well which I think is more important, so I'm changing  the call below to use
	// AdjustDialogPosition() which better avoids the phrasebox even with scrolling.
	AdjustDialogPositionByClick(gpApp->m_pNoteDlg,gptLastClick); // avoid click location
	gpApp->m_pNoteDlg->Show(TRUE);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE this handler disables the "Open A Note dialog" 
/// toolBar button: The application is only showing the target text, the active pile pointer is
/// NULL, a Note dialog is already open (the m_pNoteDlg is not NULL), if there already is a note
/// on the first source phrase of any selection, or if the targetBox is not shown. Otherwise the
/// toolbar button is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonCreateNote(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pNoteDlg != NULL)
	{
		// there already is a note dialog open, so we can't open another until it is closed
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_selectionLine != -1)
	{
		// if the first sourcephrase in the selection does not have a note, enable the button,
		// but if it does then disable the button
		CCellList::Node* pos = gpApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CPile* pPile = pos->GetData()->m_pPile;
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;
			if (pSrcPhrase->m_bHasNote)
			{
				// has a note already, so clicking this button is not the way to open it -
				//  do it with the note icon in the layout instead
				event.Enable(FALSE);
				return;
			}
			else
			{
				// it's enabled only if the sourcephrase does not already have a note
				event.Enable(TRUE);
				return;
			}
		}
		event.Enable(TRUE);
		return;
	}
	if (gpApp->m_pTargetBox->GetHandle() != NULL && gpApp->m_pTargetBox->IsShown())
	{
		// if the phrase box is visible, then enable
		event.Enable(TRUE);
		return;
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonPrevNote(wxCommandEvent& WXUNUSED(event))
{

	// is the note dialog open, if so - close it (and invoke the OK button's handler)
	// it's location defines the starting sequence number from which we look forward
	// for the next one -- but if the dialog is not open, then the phrase box's location
	// is where we start looking from
	int nJumpOffSequNum = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;
	if (gpApp->m_pNoteDlg != NULL)
	{
		// the note dialog is still open, so save the note and close the dialog
		// and reset the jump off value to the pSrcPhase where the note was attached
		nJumpOffSequNum = gpApp->m_nSequNumBeingViewed;
		wxCommandEvent oevent(wxID_OK);
		gpApp->m_pNoteDlg->OnOK(oevent);
		gpApp->m_pNoteDlg = NULL;
	}

	// find the previous note
	if (nJumpOffSequNum == 0)
		return; // can't go back if already at the start of the doc
	nJumpOffSequNum--; // jump origin
	JumpBackwardToNote_CoreCode(nJumpOffSequNum);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE this handler disables the "Jump To The Previous 
/// Note" toolBar button: The App's m_bNotesExist flag is FALSE (there are no Notes to jump to), 
/// The application is only showing the target text, the application is in free translation mode, 
/// there is a selection current, or the targetBox is not being shown. Otherwise the
/// toolbar button is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonPrevNote(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (!gpApp->m_bNotesExist)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_selectionLine != -1)
	{
		// if there is a selection, then disable the button (doing the jump and ignoring a
		// selection might be confusing to some users)
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pNoteDlg != NULL)
	{
		// there is a note dialog open, but the button handler will close it before jumping
		event.Enable(TRUE);
	}
	if (gpApp->m_pTargetBox != NULL && gpApp->m_pTargetBox->IsShown()
		&& gpApp->m_bNotesExist)
	{
		// if the phrase box is visible and there are notes in the document, then enable
		event.Enable(TRUE);
		return;
	}
	// otherwise disable
	event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonNextNote(wxCommandEvent& WXUNUSED(event))
{
	// is the note dialog open, if so - close it (and invoke the OK button's handler)
	// it's location defines the starting sequence number from which we look forward
	// for the next one -- but if the dialog is not open, then the phrase box's location
	// is where we start looking from
	int nJumpOffSequNum = gpApp->m_pActivePile->m_pSrcPhrase->m_nSequNumber;
	if (gpApp->m_pNoteDlg != NULL)
	{
		// the note dialog is still open, so save the note and close the dialog
		// and reset the jump off value to the pSrcPhase where the note was attached
		nJumpOffSequNum = gpApp->m_nSequNumBeingViewed;
		wxCommandEvent oevent(wxID_OK);
		gpApp->m_pNoteDlg->OnOK(oevent);
		gpApp->m_pNoteDlg = NULL;
	}

	// find the next note
	nJumpOffSequNum++;
	JumpForwardToNote_CoreCode(nJumpOffSequNum);
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE this handler disables the "Jump To The Next 
/// Note" toolBar button: The App's m_bNotesExist flag is FALSE (there are no Notes to jump to), 
/// The application is only showing the target text, the application is in free translation mode, 
/// there is a selection current, or the targetBox is not being shown. Otherwise the
/// toolbar button is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonNextNote(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (!gpApp->m_bNotesExist)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_selectionLine != -1)
	{
		// if there is a selection, then disable the button (doing the jump and ignoring a
		// selection might be confusing to some users)
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pNoteDlg != NULL)
	{
		// there is a note dialog open, but the button handler will close it before jumping
		event.Enable(TRUE);
	}
	if (gpApp->m_pTargetBox != NULL && gpApp->m_pTargetBox->IsShown()
		&& gpApp->m_bNotesExist)
	{
		// if the phrase box is visible and there are notes in the document, then enable
		event.Enable(TRUE);
		return;
	}
	// otherwise disable
	event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonDeleteAllNotes(wxCommandEvent& WXUNUSED(event))
{
	// IDS_ABOUT_TO_DELETE_NOTES
	if(wxMessageBox(_("You are about to cause all the notes in this document to be irreversibly deleted. Are you sure you want to do this?"),_T(""),wxYES_NO | wxICON_EXCLAMATION) == wxID_YES )
	{
		RemoveSelection();

		// close any open note
		if (gpApp->m_pNoteDlg)
		{
			wxCommandEvent cevent(wxID_CANCEL);
			gpApp->m_pNoteDlg->OnCancel(cevent);
			gpApp->m_pNoteDlg = NULL;
		}

		// delete them all
		DeleteAllNotes(); // calls Invalidate() internally
		GetDocument()->Modify(TRUE);
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE this handler disables the "Delete All Notes" 
/// toolBar button: The App's m_bNotesExist flag is FALSE (there are no Notes to jump to), 
/// The application is only showing the target text, the active pile pointer is NULL. 
/// Otherwise, if the targetBox is showing the toolbar button is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonDeleteAllNotes(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (!gpApp->m_bNotesExist)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pTargetBox->GetHandle() != NULL && gpApp->m_pTargetBox->IsShown()
		&& gpApp->m_bNotesExist)
	{
		// if the phrase box is visible and there are notes in the document, then enable
		event.Enable(TRUE);
		return;
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::MoveToAndOpenFirstNote()
{
	// is a note dialog open, if so - close it (and invoke the OK button's handler)
	// it's location defines the starting sequence number from which we look forward
	// for the next one -- but if the dialog is not open, then the phrase box's location
	// is where we start looking from
	int nJumpOffSequNum = 0;
	if (gpApp->m_pNoteDlg != NULL)
	{
		// the note dialog is still open, so save the note and close the dialog
		wxCommandEvent oevent(wxID_OK);
		gpApp->m_pNoteDlg->OnOK(oevent);
		gpApp->m_pNoteDlg = NULL;
	}
	JumpForwardToNote_CoreCode(nJumpOffSequNum);

}



/**********************************************************************
*  FindNoteSubstring
*
* Returns:	the sequence number of the pSrcPhase which has a note containing the whole string
*			(though white space between words may be different in the matching up of the search
*			string with the matched string), or -1 if there was no matching string found
*
* Parameters:
*	nCurrentlyOpenNote_SequNum	->	sequ num of the note dialog from which the search was initiated
*	searchStr					->	reference to the string the user typed in to be searched for
*
* Remarks:
*	If it finds a matching string in a subsequent note, that location's sequence number is returned
*	to the caller
*
***********************************************************************/
int CAdapt_ItView::FindNoteSubstring(int nCurrentlyOpenNote_SequNum, WordList*& pSearchList,
									 int numWords, int& nStartOffset, int& nEndOffset)
{
	int sn = nCurrentlyOpenNote_SequNum;
	sn++; // start looking from the next pSrcPhrase in the list

	SPList* pList = gpApp->m_pSourcePhrases;
	SPList::Node* pos;
	CSourcePhrase* pSrcPhrase;
	wxString noteContentStr;
	wxString noteMkr = _T("\\note");
	wxString noteEndMkr = noteMkr + _T('*');
	int curPos = -1;
	int curEndPos = -1;
	int nFoundSequNum = -1;

	// get the starting POSITION from which to commence the scan
	pos = pList->Item(sn); 
	wxASSERT(pos != NULL);

	// loop forward over the pSrcPhrase instances till once containing a note is found
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		sn = pSrcPhrase->m_nSequNumber; // update sn
		if ( (curPos = pSrcPhrase->m_markers.Find(noteMkr)) == -1)
		{
			// this sourcephrase instance contains no filtered note
			continue;
		}
		else
		{
			// this source phrase contains a note, so get the \note* endmarker
			// and remove the intervening content into noteContentStr
			curPos += 6; // point the offset to the first character after the space after \note
			curEndPos = curPos;
			if ( (curEndPos = FindFromPos(pSrcPhrase->m_markers,noteEndMkr,curEndPos)) == -1)
			{
				// no matching endmarker, so an ill-formed note - so ignore it
				continue;
			}
			else
			{
				// curEndPos is the offset pointing to \note*, which defines the end of the
				// content string and its trailing space - so we can now extract the content
				noteContentStr = pSrcPhrase->m_markers.Mid(curPos, curEndPos - curPos);
				if (noteContentStr.IsEmpty())
				{
					// no content, so continue
					continue;
				}
				else
				{
					// Check out whether the search string is contained in the content string
					wxString aWord;
					WordList::Node* fpos = pSearchList->GetFirst();
					aWord = *fpos->GetData(); // get the first word in the passed in search word list

					// How we proceed depends on the number of words to be searched for.
					// When searching just for a single word, a match anywhere in noteContentStr
					// constitutes a successful Find(); but when searching for two or more words,
					// the first word must match all the way up to the end of a content string's
					// word, and then subsequent non-final search words must match whole words
					// exactly, and the final search word must match the next content word from its
					// beginning (but does not necessarily have to match all the character in the word)
					// -- since the multi-word match is complex, we will do it in a function which will
					// return the offsets to the matched substring as well when the match succeeded
					int nFound;
					if (numWords == 1)
					{
						// do a simple Find() for the word
						nFound = noteContentStr.Find(aWord);
						if (nFound == -1)
						{
							// no match, so continue iterating the pSrcPhrase loop
							continue;
						}
						else
						{
							// it matched, so set the offsets to start and end locations
							int len = aWord.Length();
							nStartOffset = nFound;
							nEndOffset = nStartOffset + len;

							// get the sequ number for this pSrcPhrase which we need to return to the caller
							nFoundSequNum = sn;
							break;
						}
					}
					else
					{
						// we have a multiword match requested...
						// find matches for the first of the search word - (there could be more than one
						// matching location)
						nFound = 0;
						//while ( (nFound = noteContentStr.Find(aWord,nFound)) != -1)
						while ( (nFound = FindFromPos(noteContentStr,aWord,nFound)) != -1)
						{
							// we found a match for the first word
							nStartOffset = nFound;

							// find out if the rest of the search string matches at this location
							bool bItMatches = DoesTheRestMatch(pSearchList,aWord,noteContentStr,
																nStartOffset,nEndOffset);
							if (!bItMatches)
							{
								// keep iterating when the whole search string was not matched
								nFound++; // start from next character after start of last match
								nStartOffset = -1;
								nEndOffset = -1;
								continue; // iterate within this inner loop, to find another matching location
										// for the first word of the search string
							}
							else
							{
								// the whole lot matches, so we can break out after determining the
								// sequence number for this location
								nFoundSequNum = sn;
								goto a;
							}
						}

						// there was no match for the whole search string
						nFoundSequNum = -1;
						continue; // iterate the outer loop which scans pSrcPhrase instances
					} // end block for testing for a multi-word match
				} // end block for processing a non-empty noteContentStr
			} // end block for having found a matching \note* endmarker
		} // end block for pSrcPhrase contains a note
	} // end loop for scanning over the pSrcPhrase instances in m_pSourcePhrases
a:	return nFoundSequNum;
}

/**********************************************************************
*  DoesTheRestMatch
*
* Returns: TRUE if the user's typed string matches, FALSE if not
*
* Parameters:
*	pSearchList		->	pointer to the list of words in the user's typed string, as returned
*						by repeated calls to Tokenize(), using whitespace characters for delimiters
*	firstWord		->	the first word in pSearchList - the caller will already have matched this one
*	noteStr			->	the full content of the note, as stored on the pSrcPhrase currently being examined
*						and typically this string will end in a space (if the filtering was done right)
*	nStartOffset	<->	starting offset in noteStr for the already matched part (ie. firstWord)
*	nEndOffset		<-	ending offset (ie. the character immediately after the matched search string)
*						for the match -- used  in conjunction with nStartOffset to enable the CNoteDlg
*						code to later determine how much of noteStr to hightlight
* Remarks:
*	Uses some of the document's text parsing code. For multiword matches, only the first and last of
*	the passed in search words can be other than full-word matchups, the first must at least match
*	suffixally, and the last must at least match prefixally. We don't care if the user has typed
*	white space characters such as newline, carriage return or tabs in noteStr, and only spaces in
*	the search string - such white space differences are ignored (which we expect is what the user
*	would always want). The returned offsets are used by the caller (ie. CNoteDlg) for highlighting
*	purposes when there was a successful match.
*
***********************************************************************/
bool CAdapt_ItView::DoesTheRestMatch(WordList* pSearchList, wxString& firstWord, wxString& noteStr,
										int& nStartOffset, int& nEndOffset)
{
	// get a str variable containing the rest, beginning at the start of the matched first word
	wxString str = noteStr.Mid(nStartOffset);
	int len = firstWord.Length();

	// if the first word match was just a prefix in a larger word, then we won't be able to match
	// any of the other search words, in which case return FALSE to the caller
	if ( (str[len] != _T(' ')) && (str[len] != _T('\n')) && (str[len] != _T('\r')) && (str[len] != _T('\t')) )
	{
		// there is an alphabetic or numeric character at the next location, so we've just matched a
		// subpart of the word and that subpart does not extend to the word's end, so we cannot match any
		// of the other search words; this constitutes a failure to match the whole search string
		return FALSE;
	}

	// we are okay so far, so now try to match the rest
	int buflen = noteStr.Length();
	const wxChar* pBuff = str.GetData();
	wxChar* pBufStart = (wxChar*)pBuff;
	wxChar* ptr = pBufStart + len; // start from where we've matched to so far (it will be pointing at whitespace)
	wxChar* pEnd = pBufStart + buflen; // get the bound past which we must not go
	wxASSERT(*pEnd == _T('\0')); // whm added
	CAdapt_ItDoc* pDoc = GetDocument(); // we'll use the doc's functions IsWhiteSpace() and ParseWhiteSpace()
	WordList::Node* pos = pSearchList->GetFirst(); 
	wxString nextWord = *pos->GetData(); // we've already matched this one, so the loop handles the rest
	pos = pos->GetNext();
	int nHowManyChars;
	int nWordNum = 1;
	int nLastWord = pSearchList->GetCount();
	int nTotalChars = len; // count the total characters spanned in getting the match
	while (pos != NULL)
	{
		// get the next search word, and its length
		nextWord = *pos->GetData();
		pos = pos->GetNext();
		len = nextWord.Length();
		nWordNum++; // count it

		// jump over any whitespace
		if (pDoc->IsWhiteSpace(ptr))
		{
			nHowManyChars = pDoc->ParseWhiteSpace(ptr);
			ptr += nHowManyChars;
			nTotalChars += nHowManyChars;
		}

		// are we at the end? If so, since we've not yet matched the search word, then
		// we would have failed to get a match and must return, otherwise, continue processing
		if (ptr == pEnd)
		{
			// MFC released noteStr which was error
			return FALSE;
		}

		// do we have a match for the contents of nextWord, starting at the ptr location?
		if (wxStrncmp(nextWord,ptr,len) == 0)
		{
			// the strings matched...
			// count what we just matched
			nTotalChars += len;
			ptr += len; // point to the character which immediately follows the matched word

			// if we are not dealing with the last word in the search list, then the match
			// must be a whole word match -- and if it isn't, we have failed & must return FALSE,
			// but if we *are* dealing with the last word, then a prefixal match is sufficient
			// for success
			if (nWordNum < nLastWord)
			{
				// this is not the last word needing to be matched, so check out it is a
				// whole-word match
				if (ptr == pEnd)
				{
					// we've an unmatched word or more to go, so this constitutes a failure
					// MFC released noteStr which was error
					return FALSE;
				}
				else if (!pDoc->IsWhiteSpace(ptr))
				{
					// there is more of a word at the ptr location, so we only matched an
					// initial substring, and so no further match is possible - we've failed
					// MFC released noteStr which was error
					return FALSE;
				}
				else
				{
					// we had a whole-word match, hence so far so good, & we iterate the loop
					continue;
				}
			}
			else
			{
				// we are dealing with the last word, so we don't require a whole-word match
				// -- in fact, we are done & we have matched the whole search string typed
				// by the user (except there could be differences in whitespaces)
				break;
			}
		}
		else
		{
			// no match, so the total matchup has failed
			// MFC released noteStr which was error
			return FALSE;
		}
	} // end of word-matching loop

	// if we get here, then the whole search string has been matched
	nEndOffset = nStartOffset + nTotalChars; // set nEndOffset which is to be returned to the caller
	// MFC released noteStr which was error
	return TRUE;
}

void CAdapt_ItView::MoveToAndOpenLastNote()
{
	// is a note dialog open, if so - close it (and invoke the OK button's handler)
	// it's location defines the starting sequence number from which we look backward
	// for the last one -- but if the dialog is not open, then the phrase box's location
	// is where we start looking from
	int nJumpOffSequNum = gpApp->m_maxIndex;
	if (gpApp->m_pNoteDlg != NULL)
	{
		// the note dialog is still open, so save the note and close the dialog
		wxCommandEvent event(wxID_OK);
		gpApp->m_pNoteDlg->OnOK(event);
		gpApp->m_pNoteDlg = NULL;
	}
	JumpBackwardToNote_CoreCode(nJumpOffSequNum);
}

void CAdapt_ItView::JumpForwardToNote_CoreCode(int nJumpOffSequNum)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit;

	// find the first note
	SPList::Node* pos; 
	SPList* pList = gpApp->m_pSourcePhrases;
	pos = pList->Item(nJumpOffSequNum); 
	CSourcePhrase* pSrcPhrase = NULL;
	int nNoteSequNum = nJumpOffSequNum; // for iterating forward from the jump origin
	int nBoxSequNum;

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	// jump only if there is a possibility of a note being ahead
	if (nNoteSequNum <= gpApp->m_maxIndex)
	{
		// loop until the next note's pSrcPhrase is found
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (pSrcPhrase->m_bHasNote)
				break;
			// return if at doc end without finding a note
			if (pos == NULL)
				return;
		}

		// store the adaptation in the KB before moving the phrase box
		wxASSERT(gpApp->m_pActivePile); // the old value is still valid, and it's pile has the old sourcephrase
		bool bOK;
		bOK = StoreBeforeProceeding(gpApp->m_pActivePile->m_pSrcPhrase);

		// Otherwise, we have found one, so it can be opened. However, we have to
		// exercise care with the phrase box - if the note is in a retranslation while
		// adaptation mode is turned on, then we can't place the phrase box at the note
		// location - the best we can do is place it at a safe location outside the
		// retranslation. We implement these protocols below.

		// get the new value of nNoteSequNum from the located sourcephrase
		nNoteSequNum = pSrcPhrase->m_nSequNumber;
		nBoxSequNum = nNoteSequNum; // default, at least until we know it is not safe and adjust it

		if (gpApp->m_bFreeTranslationMode)
		{
			// free translation mode is on, which limits the phrase box locations so disallow the
			// jump
			pFrame = gpApp->GetMainFrame();
			wxASSERT(pFrame);
			wxASSERT(&pFrame->m_pComposeBar);
			pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);

			// NOTE: the Update handler will prevent OnButtonNextNote() being entered when
			// in Free Translation mode, so control should never get here. But in case
			// someone changes things, moving to the next (or previous) note when in Fr. Trans
			// mode is bad news - because in that mode the phrase box location is limited to
			// the start of existing free trans sections, and in the part of the doc which
			// does not have free trans sections yet, to jump to a note location would result
			// in a free trans section being defined there - which is unlikely to be what
			// is wanted because notes can be anywhere and are unlikely to just be at locations
			// where we'd want a free translation to start.
			// BEW comment 18Oct06; actually control WILL get to here when the Find Next button
			// is used when in Free Trans mode, so here we trap it and prevent any mess from happening

			// since we are in free translation mode, we want the focus to be in the
			// Compose Bar's edit box
			if (gpApp->m_bFreeTranslationMode)
			{
				pEdit->SetFocus();
			}
			return; // do nothing else
		}
		else if (pSrcPhrase->m_bRetranslation && !gbIsGlossing)
		{
			// we are in adapting mode and the sourcephrase with the note lies within a retranslation
			// so the box location will end up different than the note location, so set the note
			// location (ie. its sequence number) since we already know it
			gpApp->m_nSequNumBeingViewed = nBoxSequNum; // the note dialog needs this value be correct

			// now work out where the active location (ie. phrase box location) should be---
			// first check the bundle - we may have advanced beyond the current bundle's bounds,
			// and so an advance of the bundle may be needed to get a valid layout
			if (nNoteSequNum > gpApp->m_upperIndex)
			{
				// a bundle recalculation is required
				gpApp->m_nActiveSequNum = nNoteSequNum;
				CalcIndicesForAdvance(gpApp->m_nActiveSequNum);
				gpApp->m_pActivePile = AdvanceBundle(gpApp->m_nActiveSequNum);
			}
			gpApp->m_nActiveSequNum = nNoteSequNum;
			gpApp->m_pActivePile = GetPile(nNoteSequNum);
			wxASSERT(gpApp->m_pActivePile);

			// this 'active' location is invalid, because the phrase box can't be put in a
			// retranslation, so we'll try put the box before the retranslation, if not, then after it
			CSourcePhrase* pSafeSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);
			if (pSafeSrcPhrase == NULL)
			{
				// not a safe place, so try after the retranslation
				pSafeSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);
				if (pSafeSrcPhrase == NULL)
				{
					// horrors! nowhere is safe - if so, just open it within the retranslation
					goto a;
				}
			}
			pSrcPhrase = pSafeSrcPhrase;
			gpApp->m_nActiveSequNum = pSafeSrcPhrase->m_nSequNumber;
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			wxASSERT(gpApp->m_pActivePile);

			// now do the stuff common to all three of these possibilities
			goto a;
		}
		else
		{
			// there should be no restraint against us placing the box at the same location
			// as the note; but check the bundle - we may have advanced beyond the current
			// bundle's bounds, and so an advance may be needed first
			if (nNoteSequNum > gpApp->m_upperIndex)
			{
				// a bundle recalculation is required
				gpApp->m_nActiveSequNum = nNoteSequNum;
				CalcIndicesForAdvance(gpApp->m_nActiveSequNum);
				gpApp->m_pActivePile = AdvanceBundle(gpApp->m_nActiveSequNum);
			}
			gpApp->m_nActiveSequNum = nNoteSequNum;
			gpApp->m_pActivePile = GetPile(nNoteSequNum);
			wxASSERT(gpApp->m_pActivePile);
			gpApp->m_nSequNumBeingViewed = gpApp->m_nActiveSequNum; // the note dialog needs this value be correct

			// now do the stuff common to each of these above three possibilities

		} // end of block for not in a retranslation and not in free translation mode
	} // end of block for testing that a jump is possible

	// get the phrase box contents appropriate for the new location
	// & handle the possibility that the new active location might be a "<Not In KB>" one
a:	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
		// this ensures user has to explicitly type into the box and explicitly check the
		// checkbox if he wants to override the "not in kb" earlier setting at this location
		gpApp->m_bSaveToKB = FALSE;
		gpApp->m_targetPhrase.Empty();
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
	}
	else
	{
		if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
			gpApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
			gpApp->m_pTargetBox->m_bAbandonable = TRUE;
			if (gpApp->m_bCopySource)
			{
				gpApp->m_targetPhrase = CopySourceKey(pSrcPhrase,gpApp->m_bUseConsistentChanges);
			}
			else
			{
				gpApp->m_targetPhrase.Empty();
			}
		}
	}

	// remove the text from the KB, if refString is not null
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
								pSrcPhrase->m_key,pSrcPhrase->m_adaption);
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// get a device context, and work out the targetBox initial size, since there is
	// a stored adaption it could be long, so we'll need to recalc the layout again
	wxClientDC aDC(gpApp->GetMainFrame()->canvas);
	wxString str = gpApp->m_targetPhrase;
	wxFont* pFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pFont = gpApp->m_pNavTextFont;
	else
		pFont = gpApp->m_pTargetFont;
	aDC.SetFont(*pFont); 
	wxSize extent;
	aDC.GetTextExtent(str,&extent.x,&extent.y);
	wxString aChar = _T('w');
	wxSize charSize;
	aDC.GetTextExtent(aChar,&charSize.y,&charSize.y);
	int width = extent.GetWidth() + gnExpandBox*charSize.GetWidth();
	gpApp->m_nCurPileMinWidth = width <= gpApp->m_nCurPileMinWidth ? gpApp->m_nCurPileMinWidth : width;
	gpApp->m_curBoxWidth = gpApp->m_nCurPileMinWidth;

	// recalculate the layout from the beginning
	RecalcLayout(gpApp->m_pSourcePhrases,0,gpApp->m_pBundle);

	// recalculate the active pile & update location for phraseBox creation
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);
	gpApp->m_nStartChar = 0;
	gpApp->m_nEndChar = -1; // ensure initially all is selected
	RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
	// restore default button image, and m_bCopySourcePunctuation to TRUE
	wxCommandEvent event;
	OnButtonEnablePunctCopy(event);
	Invalidate();

	// now put up the note dialog at the m_nSequNumBeingViewed location
	wxASSERT(gpApp->m_pNoteDlg == NULL);
	gpApp->m_pNoteDlg = new CNoteDlg(gpApp->GetMainFrame());
	// wx version: we don't need the Create() call for modeless notes dialog
	AdjustDialogPosition(gpApp->m_pNoteDlg); // show it lower, not at top left
	gpApp->m_pNoteDlg->Show(TRUE);
}

void CAdapt_ItView::JumpBackwardToNote_CoreCode(int nJumpOffSequNum)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit;

	SPList::Node* pos;
	SPList* pList = gpApp->m_pSourcePhrases;
	pos = pList->Item(nJumpOffSequNum);
	CSourcePhrase* pSrcPhrase = NULL;
	int nNoteSequNum = nJumpOffSequNum; // for iterating back from the jump origin
	int nBoxSequNum;

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	// jump only if there is a possibility of a note being earlier
	if (nNoteSequNum > 0)
	{
		// loop until the previous note's pSrcPhrase is found
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetPrevious();
			if (pSrcPhrase->m_bHasNote)
				break;
			// if pos is NULL, no earlier one was found
			if (pos == NULL)
				return;
		}

		// store the adaptation in the KB before moving the phrase box
		wxASSERT(gpApp->m_pActivePile); // the old value is still valid, and it's pile has the old sourcephrase
		bool bOK;
		bOK = StoreBeforeProceeding(gpApp->m_pActivePile->m_pSrcPhrase);

		// Otherwise, we have found one, so it can be opened. However, we have to
		// exercise care with the phrase box - if the note is in a retranslation while
		// adaptation mode is turned on, then we can't place the phrase box at the note
		// location - the best we can do is place it at a safe location outside the
		// retranslation. We implement these protocols below.

		// get the new value of nNoteSequNum from the located sourcephrase
		nNoteSequNum = pSrcPhrase->m_nSequNumber;
		nBoxSequNum = nNoteSequNum; // default, at least until we know it is not safe and adjust it

		if (gpApp->m_bFreeTranslationMode)
		{
			// free translation mode is on, which limits the phrase box locations so disallow the
			// jump
			pFrame = gpApp->GetMainFrame();
			wxASSERT(pFrame);
			wxASSERT(&pFrame->m_pComposeBar);
			pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);

			// NOTE: the Update handler will prevent OnButtonNextNote() being entered when
			// in Free Translation mode, so control should never get here. But in case
			// someone changes things, moving to the next (or previous) note when in Fr. Trans
			// mode is bad news - because in that mode the phrase box location is limited to
			// the start of existing free trans sections, and in the part of the doc which
			// does not have free trans sections yet, to jump to a note location would result
			// in a free trans section being defined there - which is unlikely to be what
			// is wanted because notes can be anywhere and are unlikely to just be at locations
			// where we'd want a free translation to start.

			// since we are in free translation mode, we want the focus to be in the
			// Compose Bar's edit box
			if (gpApp->m_bFreeTranslationMode)
			{
				pEdit->SetFocus();
			}
			return; // do nothing else
		}
		else if (pSrcPhrase->m_bRetranslation && !gbIsGlossing)
		{
			// we are in adapting mode and the sourcephrase with the note lies within a retranslation
			// so the box location will end up different than the note location, so set the note
			// location (ie. its sequence number) since we already know it
			gpApp->m_nSequNumBeingViewed = nBoxSequNum; // the note dialog needs this value be correct

			// now work out where the active location (ie. phrase box location) should be---
			// first check the bundle - we may have retreated beyond the current bundle's bounds,
			// and so a retreat of the bundle may be needed to get a valid layout
			if (nNoteSequNum < gpApp->m_lowerIndex)
			{
				// a bundle recalculation is required
				gpApp->m_nActiveSequNum = nNoteSequNum;
				CalcIndicesForRetreat(gpApp->m_nActiveSequNum);
				gpApp->m_pActivePile = RetreatBundle(gpApp->m_nActiveSequNum);
			}
			gpApp->m_nActiveSequNum = nNoteSequNum;
			gpApp->m_pActivePile = GetPile(nNoteSequNum);
			wxASSERT(gpApp->m_pActivePile);

			// this 'active' location is invalid, because the phrase box can't be put in a
			// retranslation, so we'll try put the box after the retranslation, if not, then before it
			CSourcePhrase* pSafeSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);
			if (pSafeSrcPhrase == NULL)
			{
				// not a safe place, so try earlier than the retranslation
				pSafeSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);
				if (pSafeSrcPhrase == NULL)
				{
					// horrors! nowhere is safe - if so, just open it within the retranslation
					goto a;
				}
			}
			pSrcPhrase = pSafeSrcPhrase;
			gpApp->m_nActiveSequNum = pSafeSrcPhrase->m_nSequNumber;
			gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
			wxASSERT(gpApp->m_pActivePile);

			// now do the stuff common to all three of these possibilities
			goto a;
		}
		else
		{
			// there should be no restraint against us placing the box at the same location
			// as the note; but check the bundle - we may have retreated beyond the current
			// bundle's bounds, and so a retreat may be needed first
			if (nNoteSequNum < gpApp->m_lowerIndex)
			{
				// a bundle recalculation is required
				gpApp->m_nActiveSequNum = nNoteSequNum;
				CalcIndicesForRetreat(gpApp->m_nActiveSequNum);
				gpApp->m_pActivePile = AdvanceBundle(gpApp->m_nActiveSequNum);
			}
			gpApp->m_nActiveSequNum = nNoteSequNum;
			gpApp->m_pActivePile = GetPile(nNoteSequNum);
			wxASSERT(gpApp->m_pActivePile);
			gpApp->m_nSequNumBeingViewed = gpApp->m_nActiveSequNum; // the note dialog needs this value be correct

			// now do the stuff common to each of these above three possibilities

		} // end of block for not in a retranslation and not in free translation mode
	} // end of block for testing that a jump is possible

	// get the phrase box contents appropriate for the new location
	// & handle the possibility that the new active location might be a "<Not In KB>" one
a:	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
		// this ensures user has to explicitly type into the box and explicitly check the
		// checkbox if he wants to override the "not in kb" earlier setting at this location
		gpApp->m_bSaveToKB = FALSE;
		gpApp->m_targetPhrase.Empty();
		gpApp->m_pTargetBox->m_bAbandonable = TRUE;
	}
	else
	{
		if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			gpApp->m_targetPhrase = pSrcPhrase->m_adaption;
			gpApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
			gpApp->m_pTargetBox->m_bAbandonable = TRUE;
			if (gpApp->m_bCopySource)
			{
				gpApp->m_targetPhrase = CopySourceKey(pSrcPhrase,gpApp->m_bUseConsistentChanges);
			}
			else
			{
				gpApp->m_targetPhrase.Empty();
			}
		}
	}

	// remove the text from the KB, if refString is not null
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
								pSrcPhrase->m_key,pSrcPhrase->m_adaption);
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// get a device context, and work out the targetBox initial size, since there is
	// a stored adaption it could be long, so we'll need to recalc the layout again
	wxClientDC aDC(gpApp->GetMainFrame()->canvas);
	wxString str = gpApp->m_targetPhrase;
	wxFont* pFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pFont = gpApp->m_pNavTextFont;
	else
		pFont = gpApp->m_pTargetFont;
	aDC.SetFont(*pFont);
	wxSize extent;
	aDC.GetTextExtent(str,&extent.x,&extent.y);
	wxString aChar = _T('w');
	wxSize charSize;
	aDC.GetTextExtent(aChar,&charSize.x,&charSize.y);
	int width = extent.GetWidth() + gnExpandBox*charSize.GetWidth();
	gpApp->m_nCurPileMinWidth = width <= gpApp->m_nCurPileMinWidth ? gpApp->m_nCurPileMinWidth : width;
	gpApp->m_curBoxWidth = gpApp->m_nCurPileMinWidth;

	// recalculate the layout from the beginning
	RecalcLayout(gpApp->m_pSourcePhrases,0,gpApp->m_pBundle);

	// recalculate the active pile & update location for phraseBox creation
	gpApp->m_pActivePile = GetPile(gpApp->m_nActiveSequNum);
	gpApp->m_ptCurBoxLocation = gpApp->m_pActivePile->m_pCell[2]->m_ptTopLeft;

	gpApp->GetMainFrame()->canvas->ScrollIntoView(gpApp->m_nActiveSequNum);
	gpApp->m_nStartChar = 0;
	gpApp->m_nEndChar = -1; // ensure initially all is selected
	RemakePhraseBox(gpApp->m_pActivePile,gpApp->m_targetPhrase);
	// restore default button image, and m_bCopySourcePunctuation to TRUE
	wxCommandEvent event;
	OnButtonEnablePunctCopy(event);
	Invalidate();

	// now put up the note dialog at the m_nSequNumBeingViewed location
	wxASSERT(gpApp->m_pNoteDlg == NULL);
	gpApp->m_pNoteDlg = new CNoteDlg(gpApp->GetMainFrame());
	// wx version: we don't need the Create() call for modeless notes dialog
	AdjustDialogPosition(gpApp->m_pNoteDlg); // show it lower, not at top left
	gpApp->m_pNoteDlg->Show(TRUE);
}

/**********************************************************************
*  RemoveContentWrappers
*
* Returns: nothing
*
* Parameters:
*	pSrcPhrase		->	ref to pointer to the sourcephrase containing the filtered content
*	mkr				->	SF marker for the filtered material remnants to be removed
*	offset			->	offset, in the m_markers member string of the passed in pSrcPhrase,
*						to any character following the backslash of mkr, and preceding the
*						backslash of any matching endmarker, or if there is no endmarker, then
*						preceding the backslash of the closing \~FILTER* marker
* Remarks:
*	Removes mkr, and matching endmarker, and their wrapping \~FILTER and \~FILTER* markers, and any
*	intervening content for this particular SF marker - which might be nothing
*	Used for removing \note remnants so far, but no doubt could be used elsewhere -- yes, now
*	used for removing free translations and / or back translations too, and / or notes.
*
***********************************************************************/
void CAdapt_ItView::RemoveContentWrappers(CSourcePhrase*& pSrcPhrase, wxString mkr, int offset)
{
	// remove the marker remnants altogether, ie. markers and filter markers (the content may,
	// or may not, have already been removed
	wxString markers = pSrcPhrase->m_markers;

	// return if we have an invalid or bad offset to start from
	if (offset <= 0)
		return;

	int nStart = offset; // move back from this location to get to the start
	int nEnd = offset; // move forward from this location to get to the end
	int nFound;
	wxASSERT(nStart > 11);
	nStart--; // point at whatever precedes the mkr marker
	while (markers.GetChar(nStart) != _T('\\'))
	{
		nStart--;
	}
	// exits with nStart pointing at \ of the mkr
	nStart--; // point at whatever precedes it
	while (markers.GetChar(nStart) != _T('\\'))
	{
		nStart--;
	}
	// exits with nStart pointing at the preceding \~FILTER marker (which may be at buffer start)

	// now scan in the opposite direction, to get the end of what is to be removed
	nFound = FindFromPos(markers,_T('\\'),nEnd); // get the first backslash following the passed in offset location
	wxASSERT(nFound >= 0); // there must be one
	nEnd = nFound; // put the nEnd offset there
	nEnd++; // point past the backslash of the marker - it could be an end marker, or if there is no endmarker
			// it could be a \~FILTER* endmarker - so test for the latter
	if (markers.GetChar(nEnd) == _T('~'))
	{
		// there was no endmarker, we instead found \~FILTER*, so just scan over the end filter marker
		--nEnd; // put the offset back to precede the backslash

	}
	else
	{
		// there is an endmarker, so scan over it and the subsequent end filter marker
		while (markers.GetChar(nEnd) != _T('\\'))
		{
			nEnd++;
		}
		// exits with nEnd pointing at the following \~FILTER* marker
	}
	// now handle the \~FILTER* marker and trailing space
	wxString fltrEnd = filterMkrEnd;
	int lenFilterEnd = fltrEnd.Length();
	nEnd += lenFilterEnd + 1; // add one to count the trailing space after \~FILTER* (it's always there)

	// remove the remnants and update m_markers
	markers.Remove(nStart, nEnd - nStart); //markers.Delete(nStart, nEnd - nStart);
	pSrcPhrase->m_markers = markers;

	// if pSrcPhrase has a flag for the marker being present, the caller should clear it
}

void CAdapt_ItView::DeleteAllNotes()
{
	SPList* pList = gpApp->m_pSourcePhrases;
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase;
	wxString noteMkr = _T("\\note");
	wxString noteEndMkr = noteMkr + _T('*');
	int curPos = -1;

	// do the deleting
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if ( (curPos = pSrcPhrase->m_markers.Find(noteEndMkr)) == -1)
		{
			// this sourcephrase instance contains no filtered note
			pSrcPhrase->m_bHasNote = FALSE; // ensure the flag agrees
			continue;
		}
		else
		{
			// this source phrase contains a note, or the wrappers for a note
			// if the content happens to have been removed; RemoveContentWrappers also
			// removes the content if it has not already been removed, as well as removing
			// the content's wrapping markers and filter markers
			RemoveContentWrappers(pSrcPhrase, noteMkr, curPos);
			pSrcPhrase->m_bHasNote = FALSE; // ensure the flag agrees
		}
	}
	Invalidate(); // get the view redrawn, so the note icons disappear too
}

void CAdapt_ItView::OnEditMoveNoteForward(wxCommandEvent& WXUNUSED(event))
{
	// Since the Move Note Forward menu item has an accelerator table hot key (CTRL-3 see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	// On Windows, the accelerator key doesn't appear to call the handler for a disabled menu item, but
	// I'll leave the following code here in case it works differently on other platforms.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_EDIT_MOVE_NOTE_FORWARD))
	{
		::wxBell();
		return;
	}

	CPile* pPile = NULL;
	SPList* pList = gpApp->m_pSourcePhrases;
	CSourcePhrase* pSrcPhrase = NULL;

	// determine which pSrcPhrase has the note - if unable, return, doing nothing
	int nSequNum = -1;
	CCellList* pCellList;
	CCellList::Node* cpos;
	CCell* pCell;
	if (gpApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's first element
		pCellList = &gpApp->m_selection;
		cpos = pCellList->GetFirst();
		pCell = cpos->GetData();
		pPile = pCell->m_pPile;
		if (pPile == NULL)
		{
			// unlikely, so an English message will do
a:			wxMessageBox(_T("A zero pile pointer was returned, the sourcephrase with the note is indeterminate."),
				_T(""), wxICON_EXCLAMATION);
			return;
		}
		wxASSERT(pPile != NULL);
		RemoveSelection(); // need Invalidate() to be called later on
	}
	else
	{
		// no selection, so just assume the note is on the sourcephrase where the phrase box is
		pPile = gpApp->m_pActivePile;
		if (pPile == NULL)
		{
			goto a;
		}
	}
	pSrcPhrase = pPile->m_pSrcPhrase; // get the sourcephrase
	nSequNum = pSrcPhrase->m_nSequNumber; // get its sequence number
	wxASSERT(nSequNum >= 0);

	// the update handler will enable the menu item only if there was an unopen note stored on
	// the first of any selected sourcephrases, or if no selection, then at the active location, so
	// we can here assume pSrcPhrase has a note - so next we need to remove it (after storing its
	// content), determine what the target sourcephrase is, then re-establish the note there. We do
	// this using a function call, because there may be other situations where we'd want to reestablish
	// the note at some other location other than the immediate next sourcephrase, doing so under
	// program control (eg. moving the note several sourcephrases forward or back, so that a merger could
	// be done at what would otherwise have been a place where filtered material would be merger-internal
	// which is illegal).
	SPList::Node* tgtPos = pList->Item(nSequNum);
	wxASSERT(tgtPos != NULL);
	CSourcePhrase* pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
	tgtPos = tgtPos->GetNext();
	if (tgtPos == NULL)
	{
		// the update handler should disable the button to prevent this possibility, but just in
		// case we'll check for it and return silently if we can't move it forward
		return;
	}
	else
	{
		// the next sourcephrase exists, so put the note there - provided there is not already a note
		// there -- and if there is, then return without doing anything as the update handler will
		// have disabled the command anyway so we shouldn't ever get into this handler in that case
		pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData();
		tgtPos = tgtPos->GetNext();
		wxASSERT(pTgtSrcPhrase != NULL); 
		if (!pTgtSrcPhrase->m_bHasNote)
		{
			// there is no note there yet
			MoveNote(pSrcPhrase,pTgtSrcPhrase);
			Invalidate();

			// BEW added 19Dec07: establish a selection at the new location in case the user wishes
			// to use accelerator key combination in order to move the note further forward
			if (!gbShowTargetOnly)
			{
				// can do it only if showing source text and nav text whiteboard, (but update handler blocks
				// otherwise, but having this test documents things better so we'll use it, though unnecessary)
				wxASSERT(gpApp->m_selection.IsEmpty());
				int nNewSequNum = nSequNum + 1;
				CPile* pNewPile = GetPile(nNewSequNum);
				if (pNewPile == NULL)
				{
					// this should not happen, but just in case, we will exit and not bother with
					// trying to make a selection, as presumably the move has succeeded, so we'll let
					// the user try again manually
					return;
				}
				else
				{
					// the pile pointer is known, we can assume it is valid; we'll create the selection in
					// the cell with index = 1 as this is always shown for either value of m_bSuppressFirst
					// boolean
					gpApp->m_selectionLine = gnSelectionLine = 1;
					CCell* pCell = pNewPile->m_pCell[1];
					gpApp->m_selection.Insert(pCell);
					gpApp->m_pAnchor = pCell;
					gpApp->m_curDirection = right;
					gpApp->m_bSelectByArrowKey = FALSE;

					// draw the background yellow for the CCell we want shown selected
					wxClientDC aDC(gpApp->GetMainFrame()->canvas); // get a temporary client device context for this view window
					aDC.SetBackgroundMode(gpApp->m_backgroundMode);
					aDC.SetTextBackground(wxColour(255,255,0)); // yellow
					pCell->m_pText->Draw(&aDC);
					pCell->m_pText->m_bSelected = TRUE;
				}
			}
		}
		else
		{
			// shouldn't happen because update handler should disable the command if there is
			// already a note on pSrcPhrase
			;
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Move Note Forward" item on the Edit menu is disabled if any of the following conditions
/// is TRUE: the application is showing only the target text, the active pile pointer is NULL,
/// a Note dialog is currently open (must be closed first), the first source phrase of any selection
/// already has a Note. Otherwise, if there is a Note at the active location and there is an eligible 
/// source phrase ahead to move to, the menu item is enabled, otherwise the menu item is disabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditMoveNoteForward(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	SPList* pList = gpApp->m_pSourcePhrases;
	SPList::Node* tgtPos; 
	CSourcePhrase* pTgtSrcPhrase;
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pNoteDlg != NULL)
	{
		// there already is a note dialog open, so we can't move one until it is closed
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_selectionLine != -1)
	{
		// if the first sourcephrase in the selection does not have a note, enable the button,
		// but if it does then disable the button
		CCellList::Node* pos = gpApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CPile* pPile = ((CCell*)pos->GetData())->m_pPile;
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;
			if (pSrcPhrase->m_bHasNote)
			{
				// has a note, so it can be moved forward, provided there is something forward
				// to receive it and it does not already contain a note
				if (pSrcPhrase->m_nSequNumber < gpApp->m_maxIndex)
				{
					tgtPos = pList->Item(pSrcPhrase->m_nSequNumber); 
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
					tgtPos = tgtPos->GetNext();
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // this is the next
					tgtPos = tgtPos->GetNext();
					if (pTgtSrcPhrase->m_bHasNote)
					{
						// the next one already has a note, so disable the button
						event.Enable(FALSE);
					}
					else
					{
						// there is no note on the next one, so it can be a target instance
						event.Enable(TRUE); // more of the doc is ahead
					}
				}
				else
					event.Enable(FALSE); // at the end of the doc, so nothing is ahead
				return;
			}
			else
			{
				// doesn't have a note, so no move is possible here
				event.Enable(FALSE);
				return;
			}
		}
	}
	else
	{
		// check out if there is a note at the active location

		if (gpApp->m_pTargetBox != NULL && gpApp->m_pTargetBox->IsShown())
		{
			// enable the button only if there is a note at the active location and
			// there is at least one sourcephrase ahead to form the target one for the move
			CSourcePhrase* pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
			if (pSrcPhrase->m_bHasNote)
			{
				if (pSrcPhrase->m_nSequNumber < gpApp->m_maxIndex)
				{
					// there is an instance ahead
					tgtPos = pList->Item(pSrcPhrase->m_nSequNumber); 
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
					tgtPos = tgtPos->GetNext();
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // this is the next
					tgtPos = tgtPos->GetNext();
					if (pTgtSrcPhrase->m_bHasNote)
					{
						// the next one already has a note, so disable the button
						event.Enable(FALSE);
					}
					else
					{
						// there is no note on the next one, so it can be a target instance
						event.Enable(TRUE); // more of the doc is ahead
					}
				}
				else
					event.Enable(FALSE); // at the end of the doc, so nothing is ahead
				return;
			}
			else
			{
				event.Enable(FALSE);
				return;
			}
		}
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::OnEditMoveNoteBackward(wxCommandEvent& WXUNUSED(event))
{
	// Since the Move Note Backward menu item has an accelerator table hot key (CTRL-2 see CMainFrame)
	// and wxWidgets accelerator keys call menu and toolbar handlers even when they are disabled,
	// we must check for a disabled button and return if disabled.
	// On Windows, the accelerator key doesn't appear to call the handler for a disabled menu item, but
	// I'll leave the following code here in case it works differently on other platforms.
	CMainFrame* pFrame = gpApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_EDIT_MOVE_NOTE_BACKWARD))
	{
		::wxBell();
		return;
	}

	CPile* pPile = NULL;
	SPList* pList = gpApp->m_pSourcePhrases;
	CSourcePhrase* pSrcPhrase = NULL;

	// determine which pSrcPhrase has the note - if unable, return, doing nothing
	int nSequNum = -1;
	CCellList* pCellList;
	CCellList::Node* cpos;
	if (gpApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's first element
		pCellList = &gpApp->m_selection;
		cpos = pCellList->GetFirst();
		pPile = ((CCell*)cpos->GetData())->m_pPile;
		if (pPile == NULL)
		{
			// unlikely, so an English message will do
a:			wxMessageBox(_T("A zero pile pointer was returned, the sourcephrase with the note is indeterminate."),
				_T(""), wxICON_EXCLAMATION);
			return;
		}
		wxASSERT(pPile != NULL);
		RemoveSelection(); // need Invalidate() to be called later on
	}
	else
	{
		// no selection, so just assume the note is on the sourcephrase where the phrase box is
		pPile = gpApp->m_pActivePile;
		if (pPile == NULL)
		{
			goto a;
		}
	}
	pSrcPhrase = pPile->m_pSrcPhrase; // get the sourcephrase
	nSequNum = pSrcPhrase->m_nSequNumber; // get its sequence number
	wxASSERT(nSequNum >= 0);

	// the update handler will enable the menu item only if there was an unopen note stored on
	// the first of any selected sourcephrases, or if no selection, then at the active location, so
	// we can here assume pSrcPhrase has a note - so next we need to remove it (after storing its
	// content), determine what the target sourcephrase is, then re-establish the note there. We do
	// this using a function call, because there may be other situations where we'd want to reestablish
	// the note at some other location other than the immediate previous sourcephrase, doing so under
	// program control (eg. moving the note several sourcephrases back, so that a merger could be done
	// at what would otherwise have been a place where filtered material would be merger-internal
	// which is illegal).
	SPList::Node* tgtPos = pList->Item(nSequNum); 
	wxASSERT(tgtPos != NULL);
	CSourcePhrase* pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
	tgtPos = tgtPos->GetPrevious();
	if (tgtPos == NULL)
	{
		// the update handler should disable the button to prevent this possibility, but just in
		// case we'll check for it and return silently if we can't move it backward
		return;
	}
	else
	{
		// the next sourcephrase exists, so put the note there - provided there is not already a note
		// there -- and if there is, then tell the user to first move that note & return without doing
		// anything
		pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData();
		tgtPos = tgtPos->GetPrevious();
		wxASSERT(pTgtSrcPhrase);
		if (!pTgtSrcPhrase->m_bHasNote)
		{
			// there is no note there yet
			MoveNote(pSrcPhrase,pTgtSrcPhrase);
			Invalidate();

			// BEW added 19Dec07: establish a selection at the new location in case the user wishes
			// to use accelerator key combination in order to move the note further backward
			if (!gbShowTargetOnly)
			{
				// can do it only if showing source text and nav text whiteboard, (but update handler blocks
				// otherwise, but having this test documents things better so we'll use it, though unnecessary)
				wxASSERT(gpApp->m_selection.IsEmpty());
				int nNewSequNum = nSequNum - 1;
				CPile* pNewPile = GetPile(nNewSequNum);
				if (pNewPile == NULL)
				{
					// this should not happen, but just in case, we will exit and not bother with
					// trying to make a selection, as presumably the move has succeeded, so we'll let
					// the user try again manually
					return;
				}
				else
				{
					// the pile pointer is known, we can assume it is valid; we'll create the selection in
					// the cell with index = 1 as this is always shown for either value of m_bSuppressFirst
					// boolean
					gpApp->m_selectionLine = gnSelectionLine = 1;
					CCell* pCell = pNewPile->m_pCell[1];
					gpApp->m_selection.Insert(pCell);
					gpApp->m_pAnchor = pCell;
					gpApp->m_curDirection = left;
					gpApp->m_bSelectByArrowKey = FALSE;

					// draw the background yellow for the CCell we want shown selected
					wxClientDC aDC(gpApp->GetMainFrame()->canvas); // get a temporary client device context for this view window
					aDC.SetBackgroundMode(gpApp->m_backgroundMode);
					aDC.SetTextBackground(wxColour(255,255,0)); // yellow
					pCell->m_pText->Draw(&aDC);
					pCell->m_pText->m_bSelected = TRUE;
				}
			}
		}
		else
		{
			// shouldn't happen because update handler should disable the command if there is
			// already a note on pSrcPhrase
			;
		}
	}
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Move Note Backward" item on the Edit menu is disabled if any of the following conditions
/// is TRUE: the application is showing only the target text, the active pile pointer is NULL,
/// a Note dialog is currently open (must be closed first), the first source phrase of any selection
/// already has a Note. Otherwise, if there is a Note at the active location and there is an eligible 
/// source phrase previous to the current location to move to, the menu item is enabled, otherwise 
/// the menu item is disabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditMoveNoteBackward(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	SPList* pList = gpApp->m_pSourcePhrases;
	SPList::Node* tgtPos;
	CSourcePhrase* pTgtSrcPhrase;
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pNoteDlg != NULL)
	{
		// there already is a note dialog open, so we can't move one until it is closed
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_selectionLine != -1)
	{
		// if the first sourcephrase in the selection does not have a note, enable the button,
		// but if it does then disable the button
		CCellList::Node* pos = gpApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CPile* pPile = ((CCell*)pos->GetData())->m_pPile;
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->m_pSrcPhrase;
			if (pSrcPhrase->m_bHasNote)
			{
				// has a note, so it can be moved backwards, provided there is a sourcephrase
				// earlier to receive it and it does not already contain a note
				if (pSrcPhrase->m_nSequNumber > 0)
				{
					tgtPos = pList->Item(pSrcPhrase->m_nSequNumber); 
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
					tgtPos = tgtPos->GetPrevious();
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // this is the previous
					tgtPos = tgtPos->GetPrevious();
					if (pTgtSrcPhrase->m_bHasNote)
					{
						// the previous one already has a note, so disable the button
						event.Enable(FALSE);
					}
					else
					{
						// there is no note on the previous one, so it can be a target instance
						event.Enable(TRUE); // some of the doc is earlier
					}
				}
				else
					event.Enable(FALSE); // at the start of the doc, so nothing is earlier
				return;
			}
			else
			{
				// doesn't have a note, so no move is possible here
				event.Enable(FALSE);
				return;
			}
		}
	}
	else
	{
		// check out if there is a note at the active location

		if (gpApp->m_pTargetBox->GetHandle() != NULL && gpApp->m_pTargetBox->IsShown())
		{
			// enable the button only if there is a note at the active location and
			// there is at least one sourcephrase earlier to form the target one for the move
			CSourcePhrase* pSrcPhrase = gpApp->m_pActivePile->m_pSrcPhrase;
			if (pSrcPhrase->m_bHasNote)
			{
				if (pSrcPhrase->m_nSequNumber > 0)
				{
					// there is an instance backwards
					tgtPos = pList->Item(pSrcPhrase->m_nSequNumber);
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
					tgtPos = tgtPos->GetPrevious();
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // this is the earlier
					tgtPos = tgtPos->GetPrevious();
					if (pTgtSrcPhrase->m_bHasNote)
					{
						// the previous one already has a note, so disable the button
						event.Enable(FALSE);
					}
					else
					{
						// there is no note on the previous one, so it can be a target instance
						event.Enable(TRUE); // some of the doc is earlier
					}
				}
				else
					event.Enable(FALSE); // at the start of the doc, so nothing is earlier
				return;
			}
			else
			{
				event.Enable(FALSE);
				return;
			}
		}
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::MoveNote(CSourcePhrase* pFromSrcPhrase,CSourcePhrase* pToSrcPhrase)
// it is the caller's responsibility to determine which sourcephrase is to receive the note, and it must
// exist, and the sourcephrase passed in as pFromSrcPhrase must have a note (caller must bleed out any
// situations where this is not the case)
{
	wxString noteMkr = _T("\\note");
	wxString noteEndMkr = noteMkr + _T('*');
	wxString noteStr;
	int noteOffset = 0;
	int noteLen = 0;
	int curPos = -1;
	if ( (curPos = pFromSrcPhrase->m_markers.Find(noteEndMkr)) == -1)
	{
		// this sourcephrase instance contains no filtered note, so just return
		return;
	}
	else
	{
		// this source phrase contains a note, or the wrappers for a note...
		// first determine that the target sourcephrase has no note, since it is invalid to move note
		// to such a one
		int nFound = pToSrcPhrase->m_markers.Find(_T("\\note*"));
		if (nFound > 0)
		{
			// it has a note, so do nothing (no message here, the GUI button's handler has a test
			// for this and disables the command if necessary, but for programatic use of MoveNote,
			// we want a silent return)
			return;
		}

		// get the note's content
		noteStr = GetExistingMarkerContent(noteMkr,noteEndMkr,pFromSrcPhrase,noteOffset,noteLen);

		// remove it and its wrappers
		RemoveContentWrappers(pFromSrcPhrase,noteMkr,curPos - 1); // -1 is not needed, just ensures safety
		pFromSrcPhrase->m_bHasNote = FALSE; // ensure the flag is cleared on the old location

		// now create the note on the pToSrcPhrase instance
		int nInsertionOffset = FindFilteredInsertionLocation(pToSrcPhrase->m_markers,noteMkr);
		bool bInsertContentOnly = FALSE; // need the whole lot done, including wrapping filter markers
		InsertFilteredMaterial(noteMkr,noteEndMkr,noteStr,pToSrcPhrase,nInsertionOffset,bInsertContentOnly);
		pToSrcPhrase->m_bHasNote = TRUE;
	}
}

/********************************************************************************************
*
*	Backtranslation Support
*
*********************************************************************************************/

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Collect Back Translations..." item on the Edit menu is enabled if the applicable KB is not 
/// NULL and there are source phrases in the App's m_pSourcePhrases list, otherwise the menu item 
/// is disabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedCollectBacktranslations(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gpApp->m_pKB != NULL && (int)gpApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAdvancedCollectBacktranslations(wxCommandEvent& WXUNUSED(event))
{
	CCollectBacktranslations dlg(gpApp->GetMainFrame());
	dlg.Centre();
	if (dlg.ShowModal() == wxID_OK)
	{
		// user clicked the OK button
		DoCollectBacktranslations(dlg.m_bUseAdaptations);

		// mark the doc as dirty, so that Save command becomes enabled
		CAdapt_ItDoc* pDoc = GetDocument();
		pDoc->Modify(TRUE);
	}
	else
	{
		// user clicked the Cancel button, so do nothing
		;
	}
	Invalidate(); // get the view updated (so new icons (green wedges) get drawn)
}

/**********************************************************************
*  GetPrevMarker
*
* Returns: TRUE if ptr scanned back to the backslash of an SF marker, FALSE otherwise
*
* Parameters:
*	pBuff		->	pointer to the start of the pSrcPhrase->m_markers buffer
*	ptr			<->	iterator, a reference to a pointer to TCHAR at which scanning is to commence
*	mkrLen		<-	the length, in characters and including the backslash, of the marker scanned
*					(this parameter has no meaning if FALSE is returned)
* Remarks:
*	When looking for a marker which is to halt collection of adaptations or glosses as backtranslations,
*	the markers we are interested in lie at or near the end of pSrcPhrase->m_markers, except for endmarkers
*	which (provided they are not filtered) lie at the beginning of the string. So we want to start
*	processing at the end of m_markers, and iterate backwards to find the last marker; but in some
*	circumstances we may need to find the penultimate marker (eg. if the string ends with, say, \f \fr  or
*	maybe \x \xr ). So this function may need to be called more than once on the one m_markers string.
*	We also return a count of consecutive non-space characters traversed, so the caller can construct
*	the marker just traversed over. The marker may or may not be an endmarker, it's the caller's job
*	to distinguish such differences. The way GetPrevMarker is coded means that any numbers are ignored,
*	because when it exits TRUE, ptr will be pointing at the backslash of a marker, and mkrLen will have
*	its length (a space will follow).
*
***********************************************************************/
bool CAdapt_ItView::GetPrevMarker(wxChar* pBuff,wxChar*& ptr,int& mkrLen)
{
	int nCount = 0;
	if (ptr > pBuff)
		ptr--;
	else
	{
		mkrLen = 0;
		return FALSE;
	}
	while (*ptr != _T('\\'))
	{
		if (*ptr == _T(' '))
			nCount = 0; // initialize the count when pointing at a space
		else
			nCount++; // count any non-space characters

		// is there room in the buffer to go back further?
		if (ptr > pBuff)
			ptr--;
		else
		{
			// we are at the start of the buffer, but we didn't find a marker
			// so return FALSE
			mkrLen = 0;
			return FALSE;
		}
	}

	// if we get here, we have not counted the backslash yet, so do so
	nCount++;
	mkrLen = nCount;
	return TRUE;
}

// a utility to return TRUE if pSrcPhrase contains a \bt or \bt-prefixed marker
bool CAdapt_ItView::ContainsBtMarker(CSourcePhrase* pSrcPhrase)
{
	wxString btMkr = _T("\\bt");
	int nFound = pSrcPhrase->m_markers.Find(btMkr);
	if (nFound >= 0)
	{
		// there is a marker which commences with the 3 characters \bt, so return TRUE
		return TRUE;
	}
	return FALSE;
}

/**********************************************************************
*  HaltCurrentCollection
*
* Returns: TRUE if the passed in pSrcPhrase->m_markers string contains an unfiltered marker
*			which should halt collecting of the backtranslation text at the current pSrcPhrase;
*			FALSE if collecting should continue
*			BEW modified 21Nov05 to support collecting within the range of a selection by
*			explicitly checking for \bt and immediately returning TRUE if it is in m_markers
*
* Parameters:
*	markers			->	the m_markers member of the current pSrcPhrase being examined
*	bFound_bt_mkr	<-	TRUE if the reason we halt is because \bt or derivative was encountered
*
* Remarks:
*	Where the halt happens is also where the collection starts for the next subsection,
*	and the caller maintains a pointer to an earlier sourcephrase (pLastSrcPhrase) which
*	is where the just-finished collected backtranslation text is to be stored filtered in
*	its m_markers member.
*
*	We do the scanning for a marker to test by scanning backwards in m_markers. It is done
*	backwards because (a) filtered material, if present, will be earlier in m_markers than
*	at the end (and filtered material doesn't itself halt collecting - except for a \bt or derived
*	\bt marker, which must halt collection because a new section commences at this CSourcePhrase
*	instance), and (b) unfiltered markers define the text type which is visible in the main window
*	and the marker which does that will typically be the last (unfiltered) one in m_markers.
*
*	Also, since from 02Nov06 we ignore footnotes, endnotes and cross references of any kind,
*	we can ignore any unfiltered endmarker in m_markers (that is, such markers don't halt
*	the collection process) - these markers would normally occur first in initial position in
*	m_markers, and could be such things as \f*, \fe (for PNG SF set), \F (ditto), \x* --
*	all of which we want to ignore; but also endmarkers for which the TextType is 'none' such
*	as \k* etc (see AI_USFM.xml for others)
*
***********************************************************************/
bool CAdapt_ItView::HaltCurrentCollection(CSourcePhrase* pSrcPhrase, bool& bFound_bt_mkr)
{
	// initialize
	bFound_bt_mkr = FALSE;
	int mkrLen = 0;
	wxString markers = pSrcPhrase->m_markers;
	int bufLen = markers.Length();

	// coming to an already existing \bt or derived \bt marker must immediately
	// halt collection, so that we don't encroach on the next collected section
	if (ContainsBtMarker(pSrcPhrase))
	{
		bFound_bt_mkr = TRUE;
		return TRUE;
	}

	CAdapt_ItDoc* pDoc = GetDocument();
	const wxChar* pBuff = markers.GetData();
	wxChar* pBufStart = (wxChar*)pBuff;
	wxChar* pEnd;
	pEnd = pBufStart + bufLen; // whm added
	wxASSERT(*pEnd == _T('\0')); // whm added
	wxChar* ptr = pBufStart;
	ptr += bufLen; // ptr starts at the end and scans backwards

	/* BEW removed 02Jan06 // bleed off the footnote and cross reference cases
	BOOL bMustHalt = HaltAtFootnoteOrCrossRef(pBuff,ptr);
	if (bMustHalt)
	{
		markers.ReleaseBuffer();
		return TRUE;
	}
	*/

	ptr = pBufStart + bufLen; // ptr starts at the end and scans backwards
	bool bGotMarkerOK = GetPrevMarker(pBufStart,ptr,mkrLen);
	if (!bGotMarkerOK)
	{
		return FALSE; // keep collecting
	}
	wxString mkr(ptr,mkrLen);
	wxASSERT(!mkr.IsEmpty());

	// return FALSE if it's an endmarker
	if ( mkr.Find(_T('*')) >= 0)
	{
		return FALSE; // keep collecting
	}

	// if it is an unknown marker, then it must halt collecting
	wxString mkrPlusEqual = mkr + _T('=');
	if (gpApp->m_currentUnknownMarkersStr.Find(mkrPlusEqual) >= 0)
	{
		return TRUE; // halt
	}

	wxString bareMkr = pDoc->GetBareMarkerForLookup(ptr);
	wxASSERT(!bareMkr.IsEmpty());
	USFMAnalysis* pAnalysis = pDoc->LookupSFM(bareMkr);
	if (pAnalysis)
	{
		if (pAnalysis->textType == none || pAnalysis->inLine)
		{
			return FALSE; // keep collecting
		}
		else
		{
			// all other markers, whether filtered or not, should halt collecting
			return TRUE; // it halts collecting
		}
	}

	// we get here only if pAnalysis was not valid, so assume it should halt
	// -- this is the safest default for an unrecognized marker which is also
	// not listed as an unknown marker
	return TRUE;

}



/**********************************************************************
*  InsertCollectedBacktranslation
*
* Returns: nothing
*
* Parameters:
*	pSrcPhrase	->	pointer to the sourcephrase instance which is to receive the collected
*					backtranslation string (filtered)
*	btStr		->	the just-collected backtranslation content which is to be stored filtered in
*					the m_markers member of the passed in pSrcPhrase; if there is no backtranslation
*					there already, it is wrapped with the appropriate markers first and then
*					inserted, otherwise it replaces the content already there from an earlier
*					collection operation
* Remarks:
*	The comments above should suffice.
*
***********************************************************************/
void CAdapt_ItView::InsertCollectedBacktranslation(CSourcePhrase*& pSrcPhrase, wxString& btStr)
{
	wxString markers = pSrcPhrase->m_markers;
	wxString mkr = _T("\\bt");
	wxString endMkr = _T(""); // there are no backtranslation endmarkers
	wxString derivMkr; // to store derivative \bt markers, like \btv, etc, when checking which
					  // kind of backtranslation marker is actually present on pSrcPhase

	// we first must find out whether there is an existing backtranslation in markers, and if
	// there is, is it just a \bt one (ie. standard), or is it a derived \bt marker such as
	// \btv or \bts1 etc. (Adapt It does not automatically insert derived ones, but if they are
	// already present due to (a) manual editing of the XML document, or (b) imported from adaptation
	// exported from another project, then Adapt It will try to preserve them unchanged. Whenever
	// it cannot be done, \bt will be used.
	int nFound = markers.Find(mkr);
	bool bInsertContentOnly;
	int nInsertionOffset;
	if (nFound == -1)
	{
		// there is no \bt marker, nor a derived one, in the markers string as yet - so we will
		// be inserting standard \bt marker plus its content and filter marker wrappers

		// we may have other content in m_markers, so we have to first find the proper insertion location
		nInsertionOffset = FindFilteredInsertionLocation(markers,mkr);

		// now build the total string and insert it all (final BOOL being FALSE accomplishes the
		// build of \~FILTER \bt <contents of btStr> \~FILTER* followed by a single space,
		// which is done internally (and it ensures that btStr ends in a space too)
		bInsertContentOnly = FALSE;
		InsertFilteredMaterial(mkr,endMkr,btStr,pSrcPhrase,nInsertionOffset,bInsertContentOnly);
	}
	else
	{
		// there is either a standard \bt marker, or a derivative, present -- find out which it is
		derivMkr = WhichMarker(markers, nFound);

		// remove the existing content - it could be already empty though
		wxString oldBTStr;
		int nContentLen;
		oldBTStr = GetExistingMarkerContent(derivMkr,endMkr,pSrcPhrase,nInsertionOffset,nContentLen);
		pSrcPhrase->m_markers.Remove(nInsertionOffset,nContentLen);

		// now put in the new content at nInsertionOffset -- and note that the function internally
		// ensures that btStr ends in a space before it is inserted
		bInsertContentOnly = TRUE;
		InsertFilteredMaterial(derivMkr,endMkr,btStr,pSrcPhrase,nInsertionOffset,bInsertContentOnly);
	}
}

/**********************************************************************
*  DoCollectBacktranslations
*
* Returns: nothing
*
* Parameters:
*	bUseAdaptationsLine	->	TRUE if m_targetStr is used for the collection, FALSE if m_gloss is used
*
* Remarks:
*	This function changes nothing in the GUI, so a message is put up to ask the user to
*	wait for the function to finish. It then scans all the pSrcPhrase instances in the document's
*	m_pSourcePhrases list, collecting the adaptation or gloss string from each, until it comes to
*	a halt location. Halt locations are determined by calling HaltCurrentCollection() which looks
*	at the passed in m_markers string to see if the string ends in a marker which should halt
*	collection, or begin with an endmarker which should halt collection (such as \f* or \x*).
*
*	On 02Jan06 BEW changed the handling of footnotes and cross references to ignore their CSourcePhrase
*	instances in the collection process (by checking for footnote or crossReference TextType); because
*	these embedded information types should not be part of any backtranslation collection.
*
*	At each halt location, the collected backtranslation string is wrapped with a \bt marker and
*	filter markers if there is no collected backtranslation already there, and inserted; but if
*	there is a prexisting filtered backtranslation there, then its content is removed and just the
*	newly collected backtranslation is inserted in its place.
*	On 21Nov05 this algorithm was enhanced to optionally work with a selection. The collection operation
*	is confined to the selection range - and works as follows.
*	1.	If the first sourcephrase instance already has a filtered \bt (or derivative) marker, the
*		collection erases the content of this already-collected section, and the collection
*		replaces that section with the new content - which goes up to either the end of the
*		selection, or until a sourcephrase with a new \bt marker (or derivative) is encountered.
*		(Note, if the selection is not long enough, the collection may then not include all that
*		should be there - but that is the user's responsibility to fix. He can check in the
*		View Filtered Material dialog, and manually add the extra words if he wishes.)
*		(Also note, if the selection is long enough, more than one back translation section may
*		be defined before either the selection end is encountered, or another \bt marker is reached.)
*	2.	If the first sourcephrase does not have a filtered \bt (or derivative) marker, then
*		a new back translation section is commenced at that location - and ends according to the
*		same criteria as in 1. above.
*		(Note, if the first source phrase follows shortly after one on which a back translation
*		is stored but occurs before the former one's extent ends, it is quite possible for the one
*		currently being collected to have overlapping content with the former one. Again, this
*		is the user's responsibility to check for and rectify if he wishes, and the View Filtered
*		material dialog is again the way to do it.)
*
***********************************************************************/
void CAdapt_ItView::DoCollectBacktranslations(bool bUseAdaptationsLine)
{
	// whm note: The process of collecting back translations is done so quickly that there is probably no
	// need for a wait or progress dialog. The user gets feedback by the appearance of wedges appearing
	// on the screen.

	bool bSelectionExists = FALSE;
	SPList aList;	// list of selected CSourcePhrase objects, if any; else an alias for
					// the document's m_pSourcePhrases list
	SPList* pList = &aList;

	SPList* pDocPhrases = gpApp->m_pSourcePhrases; // the document's list

	// determine if there is a selection, and get a list of the sourcephrase instances
	// in it if it exists
	if (gpApp->m_selection.GetCount() > 0)
	{
		// collection only within a selection is wanted (and it doesn't matter if the selection
		// has text of different types, because the collection mechanism handles that automatically)
		wxString unwantedSrcText; // need this because the following call returns strings we are
								 // not interested in
		wxString unwantedOtherText; // need this because the following call returns strings we are
								   // not interested in
		GetSelectedSourcePhraseInstances(pList, unwantedSrcText, unwantedOtherText);
		// pList is now populated with pointers to the selected sourcephrase instances

		bSelectionExists = TRUE;
	}
	else
	{
		// collection over the whole document is wanted, so set pList to the whole list
		pList = pDocPhrases;
	}

	// initialize variables needed for the scan over the document's sourcephrase instances
	wxString strCollect;
	wxString abit; // BEW added 26Nov05 because from gloss lines we can collect copied ellipses, so exclude these
	SPList::Node* iteratorPos = pList->GetFirst(); 
	CSourcePhrase* pSrcPhrase;
	SPList::Node* savePos = iteratorPos; 
	bool bHalt;
	CSourcePhrase* pLastSrcPhrase = (CSourcePhrase*)iteratorPos->GetData();

	bool bHalted_at_bt_mkr = FALSE;
	// BEW addition 02Jan06: collecting ignores footnotes, endnotes & cross references of any kind, so we must
	// check if pLastSrcPhrase (which is where the collection is to be stored) actually has either kind of
	// TextType value. If so, we must advance pLastSrcPhrase until it points to the first CSourcePhrase instance
	// beyond the footnote, endnote or cross reference. In the case of a selection, this potentially might not
	// be possible (if the user selects only footnote text for instance), so we must allow for such a possibility.
	// (Note, the footnote endmarker, or cross reference endmarker, will be in m_markers on a CSourcePhrase instance
	// which is not a footnote or endmarker, but that won't be a problem because our halt conditions will not
	// cause a halt at any endmarker)
	if (pLastSrcPhrase->m_curTextType == footnote || pLastSrcPhrase->m_curTextType == crossReference)
	{
		// we need to skip this material
		while (iteratorPos != NULL)
		{
			savePos = iteratorPos; // needed for next loop after this one
			pLastSrcPhrase = (CSourcePhrase*)iteratorPos->GetData();
			iteratorPos = iteratorPos->GetNext();
			if (pLastSrcPhrase->m_curTextType == footnote || pLastSrcPhrase->m_curTextType == crossReference)
			{
				pLastSrcPhrase = NULL;
				continue; // skip it, try next one
			}
			else
			{
				// we have found one which we don't need to skip over
				break;
			}
		}
		if (pLastSrcPhrase == NULL)
		{
			// we got to the end of the list without finding one which was not a footnote, endnote or
			// free translation, so don't do any collection, just remove the selection (if there is one)
			// and return
			goto b;
		}
	}

	// do the loop, halting each collection at appropriate (unfiltered) SF markers (such as the start
	// of the next verse if no other marker was encountered beforehand) and store the resulting collection
	// at the starting place for this particular part of the collection (ie. at pLastSrcPhrase instance).
	// BEW changed 02Jan06 to have the code ignore instances with TextType of footnote or crossReference
	bHalted_at_bt_mkr = FALSE;
	iteratorPos = savePos; // restore POSITION for the pLastSrcPhrase instance, which is to start the loop
	while (iteratorPos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)iteratorPos->GetData();
		iteratorPos = iteratorPos->GetNext();

		// skip any footnote or cross reference instances
		if (pSrcPhrase->m_curTextType == footnote || pSrcPhrase->m_curTextType == crossReference)
			continue;

		if (pSrcPhrase == pLastSrcPhrase)
		{
			// we are just starting the next section, so don't try to halt, just start collecting
			abit = bUseAdaptationsLine ? pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
			if (abit == _T("..."))
				abit.Empty();
			strCollect = abit;
		}
		else
		{
			// pSrcPhrase has advanced past pLastSrcPhrase, so we must check for halt condition
			// as we do the collecting
			if (pSrcPhrase->m_markers.IsEmpty())
			{
				// an empty m_markers means no halt is possible at this pSrcPhrase, so
				// do the collection and then iterate
				if (strCollect.IsEmpty())
				{
					abit = bUseAdaptationsLine ? pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
					if (abit == _T("..."))
						abit.Empty();
					strCollect = abit;
				}
				else
				{
					abit = bUseAdaptationsLine ? pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
					if (abit == _T("..."))
					{
						abit.Empty();
					}
					else
					{
						strCollect += _T(' ');
						strCollect += abit;
					}
				}
			}
			else
			{
				bHalt = HaltCurrentCollection(pSrcPhrase,bHalted_at_bt_mkr);
				if (bHalt)
				{
					// do the insertion
					InsertCollectedBacktranslation(pLastSrcPhrase, strCollect);

					// prepare for collection in the next document section
					pLastSrcPhrase = pSrcPhrase;
					strCollect.Empty(); // unnecessary, but it clarifies what happens next

					// collect this one's content before iterating, because iteratorPos is already
					// pointing at the next POSITION
					strCollect = bUseAdaptationsLine ? pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;

					if (bSelectionExists && bHalted_at_bt_mkr)
					{
						// we don't collect any further within the selection, even if not at its end
						goto b;
					}
				}
				else
				{
					// collect here
					if (strCollect.IsEmpty())
					{
						abit = bUseAdaptationsLine ? pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
						if (abit == _T("..."))
							abit.Empty();
						strCollect = abit;
					}
					else
					{
						abit = bUseAdaptationsLine ? pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
						if (abit == _T("..."))
						{
							abit.Empty();
						}
						else
						{
							strCollect += _T(' ');
							strCollect += abit;
						}
					}
				}
			} // end block for non-empty m_markers
		} // end block for pSrcPhrase advanced past pLastSrcPhrase
	} // end while loop

	// do the final insertion
	wxASSERT(pLastSrcPhrase);
	InsertCollectedBacktranslation(pLastSrcPhrase, strCollect);

	// remove the selection, if there is one
b:	if (bSelectionExists)
		RemoveSelection();
}

/**********************************************************************
*  WhichMarker
*
* Returns: the full marker (including backslash) which is at the passed in location
*
* Parameters:
*	markers		->	the pSrcPhrase->m_markers string being checked for which kind of backtranslation
*					marker was found by the caller
*	nAtPos		->	character offset to the backslash at the beginning of the marker, the marker might
*					be a standard \bt one, or a derived one like \btv etc; but the function will return
*					whatever marker is there - so it is not limited to backtranslation support
*
* Remarks:
*	Comments above say it all. The function assumes and relies on there being a space following
*	whatever marker it is
*
***********************************************************************/
wxString CAdapt_ItView::WhichMarker(wxString& markers, int nAtPos)
{
	wxString mkr;
	int curPos = nAtPos;
	wxChar ch;
	ch = markers.GetChar(curPos);
	wxASSERT(ch == _T('\\'));
	mkr += ch;
	curPos++;
	while ((ch = markers.GetChar(curPos)) != _T(' '))
	{
		mkr += ch;
		curPos++;
	}
	return mkr;
}

void CAdapt_ItView::OnAdvancedRemoveFilteredBacktranslations(wxCommandEvent& WXUNUSED(event))
{
	// whm added 23Jan07 check below to determine if the doc has any back translations. If not
	// an information message is displayed saying there are no back translations; then returns.
	// Note: This check could be made in the OnIdle handler which could then disable the menu
	// item rather than issuing the info message. However, if the user clicked the menu item,
	// it may be because he/she though there might be one or more back translations in the 
	// document. The message below confirms to the user the actual state of affairs concerning
	// any back translations in the current document.
	CAdapt_ItDoc* pDoc = GetDocument();
	bool bBTfound = FALSE;
	if (pDoc)
	{
		SPList* pList = gpApp->m_pSourcePhrases;
		if (pList->GetCount() > 0)
		{
			SPList::Node* pos = pList->GetFirst();
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				if (!pSrcPhrase->m_markers.IsEmpty())
				{
					if (pSrcPhrase->m_markers.Find(_T("\\bt")) != -1)
					bBTfound = TRUE; 
					break; // don't need to check further
				}
			}
		}
	}
	if (!bBTfound)
	{
		// there are no free translations in the document, so tell the user and return
		wxMessageBox(_("The document does not contain any back translations."), _T(""),wxICON_INFORMATION);
		return;
	}

	// IDS_DELETE_ALL_BT_ASK
	if( wxMessageBox(_("You are about to delete all the back translations in the document. Is this what you want to do?"), _T(""), wxYES_NO|wxICON_INFORMATION) == wxNO)
	{
		// user clicked the command by mistake, so exit the handler
		return;
	}

	// initialize variables needed for the scan over the document's sourcephrase instances
	SPList* pList = gpApp->m_pSourcePhrases;
	SPList::Node* pos = pList->GetFirst(); 
	CSourcePhrase* pSrcPhrase;
	wxString mkr = _T("\\bt"); // enough for standard or derived backtranslation markers

	// do the loop, halting to store each collection at appropriate (unfiltered) SF markers
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_markers.IsEmpty())
		{
			continue;
		}
		else
		{
			int nFound = pSrcPhrase->m_markers.Find(mkr);
			if (nFound > 0)
			{
				// there is a filtered backtranslation section to be deleted
				RemoveContentWrappers(pSrcPhrase,mkr,nFound + 3); // + 3 to ensure pointing past \bt
			}
		} // end block for non-empty m_markers
	} // end while loop
	Invalidate();

	// mark the doc as dirty, so that Save command becomes enabled
	pDoc->Modify(TRUE);
}

/**********************************************************************
*  IsFreeTranslationContentEmpty
*
* Returns: TRUE if there is a \free marker in m_markers of pSrcPhrase, but with no content
*			else returns FALSE (and it also returns FALSE if there is no \free marker present)
*
* Parameters:
*	pSrcPhrase	->	pointer to the CSourcePhrase instance whose m_markers member
*					may or may not contain a free translation (filtered)
*
* Remarks:
*	Used by the CCell.cpp Draw() function to control the colouring of the "green" wedge; if
*	a free translation field is empty, the wedge will display khaki, if a backtranslation field
*	is empty it will display a pastel blue, if both are empty it will display red
*	-- the alternate colouring idea was suggested by John Nystrom in order to give the user
*	visual feedback about when a \free or \bt field has no content, so he can enter it manually
*	or by other means; a companion function to this present one is IsBackTranslationContentEmpty(),
*	which works similarly but for a \bt or \bt derived marker's field.
*
***********************************************************************/
bool CAdapt_ItView::IsFreeTranslationContentEmpty(CSourcePhrase* pSrcPhrase)
{
	int offset;
	int length;
	wxString mkr = _T("\\free");
	wxString endMkr = _T("\\free*");

	// determine there is a free translation there first - exit FALSE if there is none
	int curPos = pSrcPhrase->m_markers.Find(mkr);
	if (curPos == -1)
		return FALSE; // no \free is present, so we cannot claim it is empty of content

	// there is a \free marker present, so determine its content
	wxString contentStr = GetExistingMarkerContent(mkr,endMkr,pSrcPhrase,offset,length);

	// trim any spaces - since these are included in what the GetExistingMarkerContent returns
	contentStr.Trim(FALSE); // trim left end
	contentStr.Trim(TRUE); // trim right end

	// if there were only spaces, then the field is contentless & so return TRUE, else FALSE
	return contentStr.IsEmpty();
}

/**********************************************************************
*  IsBackTranslationContentEmpty
*
* Returns: TRUE if there is a \bt or \bt derivative marker in m_markers of pSrcPhrase, but with no
*			content, else returns FALSE (and it also returns FALSE if there is no \bt or
*			\bt derivative marker present)
*
* Parameters:
*	pSrcPhrase	->	pointer to the CSourcePhrase instance whose m_markers member
*					may or may not contain a back translation (filtered)
*
* Remarks:
*	Used by the CCell.cpp Draw() function to control the colouring of the "green" wedge; if
*	a free translation field is empty, the wedge will display khaki, if a backtranslation field
*	is empty it will display a pastel blue, if both are empty it will display red
*	-- the alternate colouring idea was suggested by John Nystrom in order to give the user
*	visual feedback about when a \free or \bt field has no content, so he can enter it manually
*	or by other means; a companion function to this present one is IsFreeTranslationContentEmpty(),
*	which works similarly but for a \free field.
*
***********************************************************************/
bool CAdapt_ItView::IsBackTranslationContentEmpty(CSourcePhrase* pSrcPhrase)
{
	int offset;
	int length;
	wxString mkr = _T("\\bt");
	wxString endMkr = _T(""); // back translations do not have endmarkers

	// determine there is a free translation there first - exit FALSE if there is none
	int curPos = pSrcPhrase->m_markers.Find(mkr);
	if (curPos == -1)
		return FALSE; // no \bt or \bt derived marker is present, so we cannot claim it is empty of content

	// there is a \bt or a marker which is a derivative of \bt present, so determine its content
	wxString contentStr = GetExistingMarkerContent(mkr,endMkr,pSrcPhrase,offset,length);

	// trim any spaces - since these are included in what the GetExistingMarkerContent returns
	contentStr.Trim(FALSE); // trim left end
	contentStr.Trim(TRUE); // trim right end

	// if there were only spaces, then the field is contentless & so return TRUE, else FALSE
	return contentStr.IsEmpty();
}

// ******************************  End backtranslation support **************************************

bool CAdapt_ItView::PrecedingWhitespaceHadNewLine(wxChar* pChar, wxChar* pBuffStart)
{
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	wxASSERT(pDoc != NULL);
	wxChar* ptr = pChar;
	ptr--; // back up one char in buffer
	while (ptr >= pBuffStart && pDoc->IsWhiteSpace(ptr))
	{
		if (*ptr == _T('\n'))
		{
			return TRUE;
		}
		ptr--;
	}
	return FALSE;
}

void CAdapt_ItView::GetMarkerInventoryFromCurrentDoc()
{
	// Scans all the doc's source phrase m_markers members and inventories
	// all the markers used in the current document, storing all unique
	// markers in m_exportBareMarkers, the full markers and their descriptions
	// in the CStringArray called m_exportMarkerAndDescriptions, and their
	// corresponding include/exclude states (boolean flags) in the
	// CUIntArray called m_exportFilterFlagsBeforeEdit. A given marker may occur
	// more than once in a given document, but is only stored once in these
	// inventory arrays.
	// All the boolean flags in the m_exportFilterFlagsBeforeEdit array
	// are initially set to FALSE indicating that no markers are to be
	// filtered out of the export by default. If the user accesses and/or
	// changes the export options via the "Export/Filter Options" dialog
	// and thereby filters one or markers from export, then their
	// corresponding flags in the CUIntArray called m_exportFilterFlags
	// will be set to TRUE.

	// Any sfms that are currently filtered are listed with [FILTERED] prefixed
	// to the description. Unknown markers are listed with [UNKNOWN MARKER] as
	// their description. We list all markers that are used in the document, and
	// if the user excludes things illogically, then the output will reflect
	// that.

	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	SPList* pList = gpApp->m_pSourcePhrases;
	wxArrayString MarkerList;	// gets filled with all the currently used markers including
							// filtered ones
	wxArrayString* pMarkerList = &MarkerList;
	SPList::Node* posn;
	USFMAnalysis* pSfm;
	wxString key;
	wxString lbStr;

	MapSfmToUSFMAnalysisStruct* pSfmMap;
	pSfmMap = gpApp->GetCurSfmMap(gpApp->gCurrentSfmSet);

	// Gather markers from all source phrase m_markers strings
	posn = pList->GetFirst();
	wxASSERT(posn != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)posn->GetData();
	//posn = posn->GetNext();
	// whm 27Nov07 modification: The above GetNext() line causes the
	// function to skip the first pSrcPhrase - there is the possibility 
	// that a \note, \bt and \free markers could reside in the first 
	// source phrase position, so I've commented out the extra GetNext
	// line from GetMarkerInventoryFromCurrentDoc() so that it now
	// includes the first source phrase in the inventory.
	wxASSERT(pSrcPhrase);
	while (posn != 0)
	{
		pSrcPhrase = (CSourcePhrase*)posn->GetData();
		posn = posn->GetNext();
		wxASSERT(pSrcPhrase);
		// retrieve sfms used from pSrcPhrase->m_markers
		if (!pSrcPhrase->m_markers.IsEmpty())
		{
			// GetMarkersAndTextFromString() retrieves each marker and its associated string
			// and places them in the CStringList. Any Filtered markers are stored as a list
			// item bracketed by \~FILTER ... \~FILTER* markers.
			// To avoid a large CStringList developing we'll process the markers in each
			// m_markers string individually, so empty the list.
			pMarkerList->Clear();
			pDoc->GetMarkersAndTextFromString(pMarkerList, pSrcPhrase->m_markers);

			wxString resultStr;
			resultStr.Empty();
			wxString displayStr;
			wxString bareMarker;
			wxString temp;
			int ct;
			for (ct = 0; ct < (int)pMarkerList->GetCount(); ct++)
			{
				resultStr = pMarkerList->Item(ct);
				bool markerIsFiltered;
				if (resultStr.Find(filterMkr) != -1)
				{
					resultStr = pDoc->RemoveAnyFilterBracketsFromString(resultStr);
					markerIsFiltered = TRUE;
				}
				else
				{
					markerIsFiltered = FALSE;
				}
				resultStr.Trim(FALSE); // trim left end
				resultStr.Trim(TRUE); // trim right end
				wxASSERT(resultStr.Find(gSFescapechar) == 0);
				int strLen = resultStr.Length();
				int posm = 1; // skip initial backslash
				bareMarker.Empty();
				displayStr.Empty();
				while (posm < strLen && resultStr[posm] != _T(' ') && resultStr[posm] != gSFescapechar)
				{
					bareMarker += resultStr[posm];
					posm++;
				}
				bareMarker.Trim(FALSE); // trim left end
				bareMarker.Trim(TRUE); // trim right end

				// do not include end markers in this inventory
				int aPos = bareMarker.Find(_T('*'));
				if (aPos == (int)bareMarker.Length() -1)
					bareMarker.Remove(aPos,1);
				wxASSERT(bareMarker.Length() > 0);
				// lookup the marker in the active USFMAnalysis struct map
				// whm ammended 11Jul05 Here we want to use the LookupSFM() routine which treats all
				// \bt... initial back-translation markers as known markers all under the \bt marker
				// with its description "Back-translation"
				// whm revised again 14Nov05. For output filtering purposes, we need to treat
				// all \bt... initial forms the same as simple \bt, in order to give the user
				// the placement options (boxed paragraphs or footnote format for sfm RTF output;
				// new table row or footnote format for interlinear RTF output). Handling all
				// backtranslation the same for the sake of these placement options I think is
				// preferable to not having the placement options and being able to filter from
				// output the possible different kinds of backtranslation \bt... markers.
				// Therefore here we will make all \bt... be just simple \bt and hence only have
				// \bt in the export options list box. I've also renamed the \bt marker's
				// description in AI_USFM.xml file to read: "Back Translation (and all
				// \bt... initial forms)".
				if (bareMarker.Find(_T("bt")) == 0)
				{
					bareMarker = _T("bt"); // make any \bt... initial forms be just \bt in the listbox
				}
				pSfm = pDoc->LookupSFM(bareMarker); // use LookupSFM which properly handles \bt... forms as \bt
				bool bFound = pSfm != NULL;
				lbStr = _T(' '); // prefix one initial space - looks better in a CCheckListBox
				lbStr += gSFescapechar; // add backslash
				// Since LookupSFM will find any back-translation marker of the form bt...
				// we'll use the actual bareMarker to build the list box string
				lbStr += bareMarker;
				// We don't worry about adjusting for text extent here - that is done below in
				// FormatMarkerAndDescriptionsStringArray(). Here we will just add a single
				// space as delimiter between the whole marker and its description
				lbStr += _T(' ');
				if (!bFound)
				{
					// unknown marker so make the description [UNKNOWN MARKER]
					// IDS_UNKNOWN_MARKER
					temp = _("[UNKNOWN MARKER]"); //.Format(); // prefix description with "[UNKNOWN MARKER]"
					lbStr = lbStr + temp;
				}
				else
				{
					if (markerIsFiltered)
					{
						// IDS_FILTERED
						temp = _("[FILTERED]"); // prefix description with "[FILTERED] ..."
						lbStr += temp;
						lbStr += _T(' ');
						lbStr += pSfm->description;
					}
					else
					{
						lbStr += pSfm->description;
					}
				}
				// Have we already stored this marker?
				bool mkrAlreadyExists = FALSE;
				for (int ct = 0; ct < (int)m_exportMarkerAndDescriptions.GetCount(); ct++)
				{
					if (lbStr == m_exportMarkerAndDescriptions[ct])
					{
						mkrAlreadyExists = TRUE;
						break;
					}
				}
				if (!mkrAlreadyExists)
				{
					m_exportBareMarkers.Add(bareMarker);
					m_exportMarkerAndDescriptions.Add(lbStr);
					m_exportFilterFlags.Add(FALSE); // export defaults to nothing filtered out
					m_exportFilterFlagsBeforeEdit.Add(FALSE); // export defaults to nothing filtered out
				}
			}
		}
	}
	wxClientDC dC(gpApp->GetMainFrame()->canvas);
	gpApp->FormatMarkerAndDescriptionsStringArray(&dC,&m_exportMarkerAndDescriptions, 2);// MFC used CDC
	// last parameter in call above is 2 spaces min between whole marker and its description
}

wxString CAdapt_ItView::GetWholeMarkerFromString(wxString mkrStr, int nBeginPos)
{
	// expects mkrStr to have a backslash prefixed marker at nBeginPos in the string
	wxString tempStr = mkrStr;
	int pos = FindFromPos(tempStr,_T(' '),nBeginPos);
	tempStr = tempStr.Mid(nBeginPos,pos - nBeginPos);
	return tempStr;
}

wxString CAdapt_ItView::GetAssocTextWithoutMarkers(wxString mkrStr)
{
	// expects mkrStr to have a backslash prefixed marker at the beginning of the string
	// and possibly a corresponding end marker
	wxString tempStr = mkrStr;
	// remove whitespace at beginning or end
	wxString wholeMkr = GetWholeMarkerFromString(tempStr,0);
	wxString endMarker = wholeMkr + _T('*');
	// remove initial marker
	tempStr = tempStr.Mid(wholeMkr.Length()); // get the part after initial marker and space
#ifndef _USE_OLD_CALLS
	tempStr.Trim();
#else
	tempStr = gpApp->Trim(tempStr);
#endif
	// remove any end marker
	int endPos = tempStr.Find(endMarker);
	if (endPos != -1)
	{
		// mkrStr has a corresponding end marker
		tempStr = tempStr.Left(endPos);
	}
	return tempStr;
}

bool CAdapt_ItView::MarkerTakesAnEndMarker(wxString bareMarkerForLookup, wxString& wantedEndMkr)
{
	CAdapt_ItDoc* pDoc = gpApp->GetDocument();
	USFMAnalysis* pSfm;
	MapSfmToUSFMAnalysisStruct* pSfmMap;
	pSfmMap = gpApp->GetCurSfmMap(gpApp->gCurrentSfmSet);
	pSfm = pDoc->LookupSFM(bareMarkerForLookup); // use LookupSFM which properly handles \bt... forms as \bt
	wantedEndMkr.Empty();
	if (pSfm != NULL && !pSfm->endMarker.IsEmpty())
	{
		wantedEndMkr = pSfm->endMarker;
		return TRUE;
	}
	return FALSE;
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "SIL Converters..." item on the Edit menu is enabled on a Windows port if the registry key
/// "SOFTWARE\\SIL\\SilEncConverters22" exists in the m_pConfig object, otherwise the menu item 
/// is disabled. For testing the existence of this key we've created an alternate wxConfig object
/// called m_pConfigSIL which was created with it root set at "SOFTWARE\\SIL". Therefore we need only
/// test for the existence of the "SilEncConverters22" entry at that node in the registry.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateSelectSilConverters(wxUpdateUIEvent& event)
{
	// only enable the SILConverters menu item if it is currently installed (as indicated by a registry key)
	// and the repository dll exists. TECHNICALLY, this requires SilConverters 2.2 and newer, but I can't figure
	// out how to determine that... (if not, it gracefully errors anyways)
	// whm note: This OnUpdateSelectSilConverters() handler(s) modified 31May07 as per Bruce's email of 29May07
	// to be included in MFC version 3.4.1
	// MFC code next two lines:
    //CRegKey keyRegSC;
    //event.Enable( keyRegSC.Open(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\SIL\\SilEncConverters22")) == ERROR_SUCCESS );
	// whm 17May08 Note: our m_pConfig object was created with its root being Adapt_It. In order to be able to
	// query a different branch off of the Software/SIL, I've created another wxConfig object called
	// m_pConfigSIL whose root was configured to be "SIL". With that root we can simply test to see if the
	// "SilEncConverters22 entry exists within the "SIL" group.
	// save current config path
	wxString oldPath = gpApp->m_pConfigSIL->GetPath(); // is always absolute path "/Recent_File_List"
	if (gpApp->m_pConfigSIL->Exists(_T("SilEncConverters22")))
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
	// restore the oldPath back to ""
	gpApp->m_pConfigSIL->SetPath(oldPath);
}


/* 3.4.0 and earlier -- two tests, but Bob says now only the one is needed
void CAdapt_ItView::OnUpdateSelectSilConverters(wxUpdateUIEvent& event)
{
	// whm Note: Windows registry access and Unix/Linux config file access is done in wxWidgets via
	// the wxConfig class, which attempts to make dealing with the disparate OS's registry/config files
	// look similar. The App has a pointer called m_pConfig which was initialized as a new wxConfig
	// instance there. Unix systems forbid program code from writing directly to their equivalent of
	// the HKEY_LOCAL_MACHINE except when done under Administrator priviledges/access (usually when
	// the admin in installing software with admin's level access). I think we can use wxConfig to read
	// values from HKEY_LOCAL_MACHINE keys, however, so this should work.

	// TODO: test to see if following read of HKEY_LOCAL_MACHINE was successful

    //CRegKey keyRegSC;
    //if( keyRegSC.Open(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\SIL\\SilEncConverters22")) == ERROR_SUCCESS )
	if (gpApp->m_pConfig->Exists(_T("SOFTWARE\\SIL\\SilEncConverters22")))
    {
        // just in case the registry key was stranded, make sure the dll is also still there!
        //ULONG nBufLen = _MAX_PATH;
        //wxChar szRootDir[_MAX_PATH]; szRootDir[0] = 0;
		wxString rootDir;
        //if( keyRegSC.QueryStringValue(_T("RootDir"), szRootDir, &nBufLen) == ERROR_SUCCESS )
		if (gpApp->m_pConfig->Read(_T("RootDir"), &rootDir))
        {
            // key is there... how about the dll?
            wxString strFilename = rootDir; //szRootDir;
            strFilename += _T("SilEncConverters22.tlb");
            //CFileStatus fstat;
            //event.Enable( CFile::GetStatus(strFilename, fstat) );
			if (wxFileExists(strFilename))
				event.Enable(TRUE);
			else
				event.Enable(FALSE);
            return;
        }
    }

    event.Enable(FALSE);
}
*/

void CAdapt_ItView::OnSelectSilConverters(wxCommandEvent& event)
{
#ifndef USE_SIL_CONVERTERS
	// TODO: remove following message once the COM equivalent is implemented
	wxMessageBox(_("Sorry - the SIL Converters feature is not available in the wxWidgets version at this time."),_T(""), wxICON_INFORMATION);
	return;
#endif

    // bring up the SilConverter select dialog to allow the user to pick a converter
    CSilConverterSelectDlg dlg
    (
    gpApp->m_strSilEncConverterName,
    gpApp->m_bSilConverterDirForward,
#ifdef USE_SIL_CONVERTERS
    gpApp->m_eSilConverterNormalizeOutput,
    gpApp->m_aEC,
#endif
    gpApp->GetMainFrame()
    );

    if( dlg.ShowModal() == wxID_OK )
    {
        // save these values in the app, so they get written to the project settings file
        // (i.e. to be retentive across program launches)
        gpApp->m_strSilEncConverterName = dlg.ConverterName;
        gpApp->m_bSilConverterDirForward = dlg.DirectionForward;
#ifdef USE_SIL_CONVERTERS
        gpApp->m_eSilConverterNormalizeOutput = dlg.NormalizeOutput;
#endif

        // if no converter configured, then turn off the 'use' if it was on
        // (NOTE: this is the equivalent of "Unload")
        if( dlg.ConverterName.IsEmpty() )
        {
	        CMainFrame *pFrame = gpApp->GetMainFrame(); //CFrameWnd* pFrame = GetParentFrame();
			wxASSERT(pFrame != NULL);
	        //CMenu* pTopLevelMenu = pFrame->GetMenu();
			wxMenuBar* pMenuBar = pFrame->GetMenuBar();
			wxASSERT(pMenuBar != NULL);
	        //CMenu* pToolsMenu = pTopLevelMenu->GetSubMenu(3);
	        //ASSERT(pToolsMenu != NULL);
			wxMenuItem * pToolsMenuUseSilConverter = pMenuBar->FindItem(ID_USE_SILCONVERTER);
			wxASSERT(pToolsMenuUseSilConverter != NULL);

		    // toggle the checkmark to OFF
		    pToolsMenuUseSilConverter->Check(FALSE);
		    gpApp->m_bUseSilConverter = FALSE;
            return;
        }
        else if( gpApp->m_bUseSilConverter )
        {
            // otherwise, if it *was* being used before, then reset it now (to trigger the not-in-use check below
            //  (which in turn triggers the reevaluation of the source word))
            OnUseSilConverter(event);
        }

        // if it isn't on, then make it on. This causes the current word to be re-run thru the converter
        if( !gpApp->m_bUseSilConverter )
        {
            OnUseSilConverter(event);
        }
    }
}

#ifdef USE_SIL_CONVERTERS
////////////////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      aEC                <- reference to an SIL Converter
/// \param      strFriendlyName    <- a wxString representing the name of the SIL Converter, used 
///                                     in the get_Item() call to get a reference to the specific 
///                                     converter to initialize (pointed to by aEC)
/// \param      bDirectionForward  -> a bool representing a flag for the put_DirectionForward() call
///                                     further initializing the converter (pointed to by aEC)
/// \param      eNormalizeFlag     -> an enum value for the put_NormalizeOutput() call that further
///                                     initializes the converter (pointed to by aEC)
/// \remarks
/// Called from: the View's DoSilConvert().
/// Initializes a connection to an SIL Converter.
/// The aEC reference (passed in as m_aEC from DoSilConvert) will be NULL on entry to 
/// InitializeEC() since InitializeEC() is only called from DoSilConvert() when m_aEC is NULL 
/// and needs to be initialized. The strFriendlyName should have the name of the SIL Converter that is
/// to be initialized. If strFriendlyName is a null string it indicates that the user
/// has not yet selected an SIL Converter and an error message is issued and the initialization 
/// aborts. The pointer to the COM IEncConverters Interface (pECs being a type of IECs) is used to 
/// call CoCreateInstance() on the "SilEncConverters22.EncConverters" ProgID string, which creates 
/// an instance of the SIL Converters object in a type-safe manner. pECs is then used to call
/// get_Item() in which the first parameter is the strFriendlyName property to retrieve made into a 
/// VARIANT, and the second parameter aEC receives the pointer/reference to the retrieved property
/// (i.e., the Converter to be used). This aEC pointer is then used to initialize two other run-time
/// parameters needed before the Convert() call can be called (in the ProcessHResult part of
/// DoSilConvert) on the retrieved Converter. The two initializations are accomplished by calling the
/// following two methods on aEC; put_DirectionForward(), and put_NormalizeOutput() utilizing
/// InitializeEC's "bDirectionForward" and "eNormalizeFlag" input parameters passed to these two 
/// methods.
/// If either the CoCreateInstance() or get_Item() call fails, appropriate error messages are issued 
/// to the user.
////////////////////////////////////////////////////////////////////////////////////////////
void InitializeEC(IEC& aEC, const wxString& strFriendlyName, bool bDirectionForward, NormalizeFlags eNormalizeFlag)
{
	// helper function to initialize the converter
    //wxASSERT(!aEC);
    gpApp->m_bECConnected = FALSE;
    if( strFriendlyName.IsEmpty() )
    {
		// IDS_NO_SIL_CONVERTER_CONFIGURED
        wxMessageBox(_("No SILConverter configured! Click 'Tools', 'SIL Converters...' to re-configure a new converter"),_T(""),wxICON_INFORMATION);
    }
    else
    {
        //wxCursor cursor(wxCURSOR_WAIT); //CWaitCursor x; // TODO: see if setting wait cursor is necessary
        
		// whm Observarions based on looking at automtn.h library source in (C:\wxWidgets-2.8.7\include\wx\msw\ole)
		// and automtn.cpp (in C:\wxWidgets-2.8.7\src\msw\ole):
		// 
		// 1. wxAutomationObject::GetInstance()
		// Signature: GetInstance(const wxString& classId) const
		// GetInstance() retrieves the current object associated with a class id, and attaches the
		// IDispatch pointer to this object. Returns TRUE if a pointer was successfully retrieved,
		// FALSE otherwise. It does the following:
		//    a. Returns FALSE immediately if m_dispatchPtr is already defined (non-NULL).
		//    b. Calls CLSIDFromProgID() to look up in the registry the CLSID corresponding to our progID 
		//    (Unicode) string passed into GetInstance(). If CLSIDFromProgID() fails GetInstance()
		//    immediately returns FALSE.
		//    c. Using a valid CLSID from b above, GetActiveObject() is called using an IUnknown* pUnk
		//    reference parameter to get back a pointer pUnk to a "running" object that has been
		//    registered with OLE (using the class identifier CLSID). If GetActiveObject() fails, GetInstance() 
		//    immediately returns FALSE.
		//    d. Using the pUnk pointer to the found active object, pUnk->QueryInterface() is
		//    called using IID_IDispatch to retrieve the raw interface pointer for the COM object which 
		//    is stored in wxAutomationObject's m_dispatchPtr member. Note: the inline GetDispatchPtr()
		//    method of wxAutomationObject simply returns this raw m_dispatchPtr.
		//  
		// 2. wxAutomationObject::CreateInstance()  
		// Signature: CreateInstance(const wxString& classId) const
		// CreateInstance() creates a new object based on the clas id, returning TRUE if the object was
		// successfully created, FALSE otherwise. It does the following:
		//    a. Returns FALSE immediately if m_dispatchPtr is already defined (non-NULL).
		//    b. Calls CLSIDFromProgID() to look up in the registry the CLSID corresponding to our progID 
		//    (Unicode) string passed into CreateInstance(). If CLSIDFromProgID() fails CreateInstance()
		//    immediately returns FALSE.
		//    c. Using a valid CLSID from b above, CoCreateInstance() is called using the parameters
		//    CLSCTX_LOCAL_SERVER and IID_IDispatch, and on success stores the raw dispatch pointer
		//    in m_dispatchPtr. 
		//  
		// 3. wxAutomationObject::GetObject()
		// Signature: GetObject(wxAutomationObject &obj const wxString& property, int noArgs = 0, wxVariant args[] = NULL) const
		// GetObject() retrieves one object from another object. It works by retrieving a property from this object, 
		// assumed to be a dispatch pointer, and initializes obj with it. It avoids having to deal with IDispatch 
		// pointers directly. It does the following:
		//    a. Invokes the wxAutomationObject's internal GetDispatchProperty() function which returns
		//    an IDispatch pointer to the object represented by property, and assigns this IDispatch
		//    pointer to the obj reference parameter of GetObject() using SetDispatchPtr().
		//    a.[more detail] The GetDispatchProperty() mentioned above calls the wxAutomationObject's 
		//    internal Invoke() function which in turn calls the IDispatch's own Invoke() function to 
		//    get the desired sub-object's own dispatch pointer.
        
        IECs    pECs;
        //pECs.CoCreateInstance(L"SilEncConverters22.EncConverters");
		//if (!pECs.GetInstance(_T("SilEncConverters22.EncConverters")))
		//{
			if (pECs.CreateObject(_T("SilEncConverters22.EncConverters"))) //if (pECs.CreateInstance(_T("SilEncConverters22.EncConverters"))) // if ( !!pECs )
			{
				
				//wxVariant varName(strFriendlyName); //COleVariant varName(strFriendlyName);
				//pECs->get_Item(varName, &aEC);
				//if( !!aEC )
				if (pECs.InvokeMethod(_T("get_Item"),strFriendlyName, &aEC)) //if (m_aEC.CreateObject(ConverterName))
				//if (pECs.GetObject(aEC, strFriendlyName)) 
				{
					// initialize the other run-time parameters needed for the Convert call
					bool bPutOK1, bPutOK2;
					bPutOK1 = aEC.SetProperty(_T("put_DirectionForward"),wxVariant(bDirectionForward)); //aEC->put_DirectionForward((bDirectionForward) ? VARIANT_TRUE : VARIANT_FALSE);
					bPutOK2 = aEC.SetProperty(_T("put_NormalizeOutput"),wxVariant(eNormalizeFlag)); //aEC->put_NormalizeOutput(eNormalizeFlag);
					if (bPutOK1 && bPutOK2)
						gpApp->m_bECConnected = TRUE;
					else
					{
						wxString strError,strError1,strError2;
						strError1 = _T("put_DirectionForward()");
						strError2 = _T("put_NormalizeOutput()");
						strError = strError.Format(_T("The followoing command(s) failed for the SILConverter named %s! \n\n %s\n%s \n\n Click 'Tools', 'SIL Converters...' to re-configure a new converter"),strFriendlyName.c_str(),strError1.c_str(), strError2.c_str());
						wxMessageBox(strError,_T(""),wxICON_WARNING);
					}

				}
				else
				{
					// must no longer be in the repository!
					wxString strError;
					//AfxFormatString1(strError, IDS_SILCONVERTER_NO_LONGER_IN_REPOSITORY, strFriendlyName);
					strError = strError.Format(_("The SILConverter named \n\n\t'%s'\n\nis no longer in the system repository! Click 'Tools', 'SIL Converters...' to re-configure a new converter"),strFriendlyName.c_str());
					wxMessageBox(strError,_T(""),wxICON_WARNING);
				}
			}
			else
			{
				// something more serious is wrong... probably requires a reboot or reinstall
				//AfxMessageBox(IDS_SILCONVERTERS_NO_AVAILABLE);
				wxMessageBox(_("Unable to launch the SIL Converters Selection Dialog! Are you using SIL Converters version v 2.2 or greater? Otherwise, you need to re-install or reboot"),_T(""),wxICON_WARNING);
			}
		//}
		//else
		//{
		//	// the call to pECs.GetInstance() above succeeded. According to the wxAutomationObject
		//	// docs, GetInstance() retrieves the current ojbect associated with the classId, and
		//	// attaches the IDispatch pointer to this object. 
		//	// We should now be able to access that IDispatch pointer and call:
		//	//IDispatch* pIDispPtr = pECs.GetDispatchPtr();
		//	// but the wxAutomationObject class is designed to avoid direct use of dispatch pointers,
		//	// so we'll call GetObject() to get the inner object and then call PutProperty() on that
		//	// inner object (as within the block above)
		//	//wxVariant varName(strFriendlyName); //COleVariant varName(strFriendlyName);
		//	//pECs->get_Item(varName, &aEC);
		//	//if( !!aEC )
		//	if (pECs.GetObject(aEC, strFriendlyName))
		//	{
		//		// initialize the other run-time parameters needed for the Convert call
		//		bool bPutOK1, bPutOK2;
		//		bPutOK1 = aEC.PutProperty("put_DirectionForward",wxVariant(bDirectionForward)); //aEC->put_DirectionForward((bDirectionForward) ? VARIANT_TRUE : VARIANT_FALSE);
		//		bPutOK2 = aEC.PutProperty("put_NormalizeOutput",wxVariant(eNormalizeFlag)); //aEC->put_NormalizeOutput(eNormalizeFlag);
		//		if (bPutOK1 && bPutOK2)
		//			gpApp->m_bECConnected = TRUE;
		//		else
		//		{
		//			wxString strError,strError1,strError2;
		//			strError1 = _T("put_DirectionForward()");
		//			strError2 = _T("put_NormalizeOutput()");
		//			strError = strError.Format(_T("The followoing command(s) failed for the SILConverter named %s! \n\n %s\n%s \n\n Click 'Tools', 'SIL Converters...' to re-configure a new converter"),strFriendlyName.c_str(),strError1.c_str(), strError2.c_str());
		//			wxMessageBox(strError,_T(""),wxICON_WARNING);
		//		}
		//	}
		//	else
		//	{
		//		// must no longer be in the repository!
		//		wxString strError;
		//		//IDS_SILCONVERTER_NO_LONGER_IN_REPOSITORY
		//		strError = strError.Format(_("The SILConverter named \n\n\t'%s'\n\nis no longer in the system repository! Click 'Tools', 'SIL Converters...' to re-configure a new converter"),strFriendlyName.c_str());
		//		wxMessageBox(strError,_T(""),wxICON_WARNING);
		//	}
		//}
    }
}
#endif

////////////////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the input str after it is modified by the action of the 
///                 SIL Converter; or a null/empty str if str was initially empty or if the SIL
///                 Converter could not be found
/// \param      str     -> the wxString to be processed by an SIL Converter
/// \remarks
/// Called from: the View's CopySourceKey() and DoTargetBoxPaste() functions.
/// Calls the configured SilConverter to pre-process the data and return the result to the caller.
/// First, DoSilConvert() creates a connection with the EncConverter, if the connection hasn't been 
/// created previously. A NULL pointer in m_aEC indicates that no connection to a converter is 
/// current and needs to be made. If the connection needs to be made (m_aEC is NULL), it is 
/// established by calling the InitializeEC() function which passes the m_aEC pointer, the 
/// App's m_strSilEncConverterName, m_bSilConverterDirForward, and m_eSilConverterNormalizeOutput 
/// values. Then, if m_aEC is not NULL by that point (InitializeEC succeeded) and if the string 
/// str originally passed to DoSilConvert() is not empty, ProcessHResult() is called 
/// which is a wrapper to trap errors and which internally (within its parameter list) calls 
/// m_aEC->Convert(CComBSTR(str), and returns the processed output string in its strOutput reference
/// parameter, which is then finally used as the return value from DoSilConvert(). 
/// The ProcessHResult() function also has a parameter which calls __uuidof(IEncConverter) as it
/// passes into the function. If the m_aEC reference did not get associated with a COM object earlier, 
/// or if the str input string was originally a null string, DoSilConvert() simply returns a null 
/// string.
////////////////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::DoSilConvert(const wxString& str)
{

#ifndef USE_SIL_CONVERTERS
	int dummyLen;
	dummyLen = (int)str.Length(); // avoids "unreferenced formal parameter" warning when USE_SIL_CONVERTERS is not defined
#endif

#ifdef USE_SIL_CONVERTERS
    // if the connection to the EncConverter hasn't been created yet, create it now
    if (!gpApp->m_bECConnected) //if( !gpApp->m_aEC )
        InitializeEC(gpApp->m_aEC, gpApp->m_strSilEncConverterName, gpApp->m_bSilConverterDirForward, gpApp->m_eSilConverterNormalizeOutput);

    // if it's connected (now) AND if the string isn't empty...
    if (gpApp->m_bECConnected && !str.IsEmpty()) //if( !!gpApp->m_aEC && !str.IsEmpty() )
    {
        // then we're all set: call Convert
        //CComBSTR strOutput;
        //if( ProcessHResult(gpApp->m_aEC->Convert(CComBSTR(str), &strOutput), gpApp->m_aEC, __uuidof(IEncConverter)) )
        wxString strOutput;
        if (gpApp->m_aEC.InvokeMethod(_T("Convert"), str, &strOutput)) //if (gpApp->m_aEC.CallMethod(_T("Convert"), 2, wxVariant(str), wxVariant(strOutput)))
            return wxString(strOutput);
    }
#endif
    return _T("");
}

void CAdapt_ItView::OnAdvancedUseTransliterationMode(wxCommandEvent& WXUNUSED(event))
{
	// toggle the mode on or off
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);

	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuUseUseTransLMode = pMenuBar->FindItem(ID_ADVANCED_USETRANSLITERATIONMODE);
	wxASSERT(pToolsMenuUseUseTransLMode != NULL);

	if (pApp->m_bTransliterationMode)
	{
		// toggle the checkmark to OFF
		pToolsMenuUseUseTransLMode->Check(FALSE);
		pApp->m_bTransliterationMode  = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pToolsMenuUseUseTransLMode->Check(TRUE);
		pApp->m_bTransliterationMode = TRUE;
	}

	// update status bar information
	pApp->RefreshStatusBarInfo();

	// restore focus to the phrase box (free translations cannot be on for this mode)
	if (pApp->m_pTargetBox != NULL)	
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

// //////////////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// The "Use Transliteration Mode" item on the Advanced menu is disabled if any of the following
/// conditions are TRUE: the KB is not ready, there are no source phrases in the App's m_pSourcePhrases
/// list, the application is in free translation mode or glossing mode. Otherwise, if the
/// m_strSilEncConverterName string has a name loaded the menu item is enabled.
// //////////////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedUseTransliterationMode(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// toggle the mode on or off
	//CAdapt_ItApp* pApp = (CAdapt_ItApp*)AfxGetApp();
	//ASSERT(pApp != NULL);
	//CAdapt_ItDoc* pDoc = pApp->GetDocument();
	// whm 15Aug06 added && !pApp->m_strSilEncConverterName.IsEmpty() condition to disable
	// the menu item unless a SIL converter is loaded
	if (gpApp->m_bKBReady && gpApp->m_pSourcePhrases->GetCount() > 0 && !gpApp->m_bFreeTranslationMode
		&& !gbIsGlossing && !gpApp->m_strSilEncConverterName.IsEmpty()) // whm 15Aug06 added !gpApp->m_strSilEncConverterName.IsEmpty() condition
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnUpdateButtonNextStep(wxUpdateUIEvent& event) 
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(TRUE);
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonNextStep(wxCommandEvent& WXUNUSED(event)) 
{
	int sequNum = -1; // value not needed
	bool bCustomMessageSent;
	bCustomMessageSent = VerticalEdit_CheckForEndRequiringTransition(sequNum,nextStep,TRUE);
	// no need to use returned BOOL value; TRUE means "force transition"
}

void CAdapt_ItView::OnUpdateButtonPrevStep(wxUpdateUIEvent& event) 
{
	if (gbVerticalEditInProgress)
	{
		if (gEditStep == adaptationsStep && gbAdaptBeforeGloss)
		{
			event.Enable(FALSE); // don't permit rollback to the edit source text dialog,
								   // instead the user should cancel the whole process and
								   // reselect & do Edit Source Text command again
			return;
		}
		else if (gEditStep == glossesStep && !gbAdaptBeforeGloss)
		{
			event.Enable(FALSE); // don't permit rollback to the edit source text dialog,
								   // instead the user should cancel the whole process and
								   // reselect & do Edit Source Text command again
			return;
		}
		else if (gEditRecord.nNewSpanCount == 0)
		{
			event.Enable(FALSE); // don't permit rollback at all if the user deleted
								   // all the CSourcePhrase instances he selected for
								   // editing using the Edit Source Text dialog
			return;
		}
		else
		{
			event.Enable(TRUE);
			return;
		}
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonPrevStep(wxCommandEvent& WXUNUSED(event)) 
{
	int sequNum = -1; // value not needed
	bool bCustomMessageSent;
	bCustomMessageSent = VerticalEdit_CheckForEndRequiringTransition(sequNum,previousStep,TRUE);
	// no need to use returned BOOL value; TRUE means "force transition"
}

void CAdapt_ItView::OnUpdateButtonEndNow(wxUpdateUIEvent& event) 
{
	if (gbVerticalEditInProgress)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonEndNow(wxCommandEvent& WXUNUSED(event)) 
{
	// instead of calling VerticalEdit_CheckForEndRequiringTransition(), just post the
	// required message immediately
	//this->PostMessage(CUSTOM_EVENT_END_VERTICAL_EDIT,0,0);
	wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
	wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
}

void CAdapt_ItView::OnUpdateButtonCancelAllSteps(wxUpdateUIEvent& event) 
{
	if (gbVerticalEditInProgress)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonCancelAllSteps(wxCommandEvent& WXUNUSED(event)) 
{
	// instead of calling VerticalEdit_CheckForEndRequiringTransition(), just post the
	// required message immediately
	//this->PostMessage(CUSTOM_EVENT_CANCEL_VERTICAL_EDIT,0,0);
	wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
	wxPostEvent(gpApp->GetMainFrame(), eventCustom); // the event handlers are in CMainFrame
}

void CAdapt_ItView::OnUpdateButtonUndoLastCopy(wxUpdateUIEvent& event) 
{
	if (gbVerticalEditInProgress)
	{
		if (gEditStep == adaptationsStep ||
			gEditStep == glossesStep ||
			gEditStep == freeTranslationsStep)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonUndoLastCopy(wxCommandEvent& WXUNUSED(event)) 
{
	//CFrameWnd* pFWnd = GetParentFrame();
	wxPanel* pBar;
	pBar = GetBar(Vert_Edit_RemovalsBar); //CDialogBar* pBar = GetBar(IDD_REMOVALS_BAR);
	wxASSERT(pBar != NULL);
	wxComboBox* pList;
	pList = (wxComboBox*)pBar->FindWindowById(IDC_COMBO_REMOVALS);
	wxASSERT(pList != NULL);

	// TODO:


	
}


// ******************************************************************************************
// Some material used by wxWidgets version below
// ******************************************************************************************

// Clean up windows used for displaying the view. - from docview sample
bool CAdapt_ItView::OnClose(bool deleteWindow)
{
	deleteWindow = deleteWindow; // avoids "unreferenced formal parameter" warning

	// Clear the canvas in  case we're in single-window mode,
	// and the canvas stays.
	canvas->ClearBackground();

	canvas->pView = (CAdapt_ItView *) NULL;
	canvas = (CAdapt_ItCanvas *) NULL;

	wxString s(wxTheApp->GetAppName());
	if (pCanvasFrame)
		pCanvasFrame->SetTitle(s);

	SetFrame((wxFrame*)NULL);
	Activate(FALSE);

	return TRUE;
}

// wx Note: wxScrollEvent only appears to intercept scroll events for scroll bars manually
// placed in wxWindow based windows. In order to handle scroll events for windows like
// wxScrolledWindow (that have built-in scrollbars), we must use wxScrollWinEvent in the
// functions and the EVT_SCROLLWIN macro in the event table.
// wx: OnScroll is never called in the View (it is called in CAdapt_ItCanvas)
//void CAdapt_ItView::OnScroll(wxScrollWinEvent& event)
//{
//	int junk = 1; // why does this handler not activate on scroll events???
//	//gpApp->GetMainFrame()->SendSizeEvent();
//
//	event.Skip();	// this is necessary for the built-in scrolling behavior of wxScrolledWindow
//					// to be processed
//}

void CAdapt_ItView::Invalidate() // for MFC compatibility
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// wxWidgets' wxView class does not itself have an Invalidate() method like MFC
	// The wxWindow class has Refresh(), so we'll get the window associated with
	// the current View and refresh it.

	pApp->GetMainFrame()->canvas->Refresh();
}

void CAdapt_ItView::InvalidateRect(wxRect& rect) // for MFC compatibility
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// wxWidgets' wxView class does not itself have an Invalidate() method like MFC
	// The wxWindow class has Refresh(), so we'll get the window associated with
	// the current View and refresh it.

	pApp->GetMainFrame()->canvas->RefreshRect(rect);
}

// Routines below are now incorporated into Edit|Preferences
//void CAdapt_ItView::DoEditPunctCorresp()
//void CAdapt_ItView::OnEditPunctCorresp()
//void CAdapt_ItView::OnUpdateEditPunctCorresp(wxUpdateUIEvent& event)

// whm added 12Jun07
void CAdapt_ItView::DrawTextRTL(wxDC* pDC, wxString& str, wxRect& rect)
{
	// This function attempts to alieviate the limitations of wxDC::DrawText() which
	// does not have an nFormat parameter as does the MFC function CDC::DrawText()
	// and which currently (as of wxWidgets 2.8.4) has different behaviors on wxMSW,
	// wxGTK and wxMAC.
	// The challenge here is due in part to the fact that the wxDC::SetLayoutDirection() 
	// method applies to the whole DC and, on wxMSW (but not the other ports) 
	// SetLayoutDirection() effectively mirrors the underlying coordinate system (requiring
	// coordinate values input to DrawText and other drawing methods be reversed on the
	// x-axis while SetLayoutDirection() is set to RTL. Hence, for wxMSW, we must transform the 
	// coordinates in such a way that, while mirroring is in effect, the logical 0,0 
	// coordinate for drawing text is located at the upper right corner of the of the 
	// logical document and x coordinate values increase toward the left rather than toward 
	// the right. The wxGTK and wxMac ports do not require the use of SetLayoutDirection()
	// to render punctuation correctly for RTL text, but drawing RTL text in those cases 
	// requires that we must adjust the drawing coordinates of RTL text to start drawing 
	// at the left end of the resulting RTL text, rather than at the right end (as MFC does).
	// I've also used a wxRect as parameter rather than wxCoord x and wxCoord y coordinate
	// parameters to make the upper right corner of the wxRect more readily available to
	// the function.
	//
	// TODO: Since the wxWidgets RTL rendering behaviors are obviously still somewhat in an 
	// immature state of development (and may change in future library releases to become 
	// more uniform across platforms) this issue needs to be visited again upon any anticipated
	// upgrade to newer versions of wxWidgets beyond version 2.8.4.
	//
	// For wxMSW we must transform the coordinates of rect's upper right corner to 
	// account for the mirroring of the underlying coordinate system on Windows 
	// (the wxGTK and wxMac do not seem to do the mirroring of the underlying 
	// coordinates).
	// first get the upper right coords of the drawing rect
	wxPoint urPt(rect.GetRight(),rect.GetTop());
	// transform this point to have mirrored x-axis coordinates. grectViewClient should
	// indicate the current client view's total width, so if we subtract the urPt.x value
	// from grectViewClient.GetWidth(), we should have the "mirrored" x-axis coordinate
	// value for RTL layout.
#ifdef __WXMSW__
	// wxMSW needs SetLayoutDirection(wxLayout_RightToLeft) to be set; in addition we
	// need to transform the urPt so it is mirrored from the right edge of 
	// grectViewClient.
	wxASSERT(grectViewClient.GetWidth() >= urPt.x);
	pDC->SetLayoutDirection(wxLayout_RightToLeft);
	pDC->DrawText(str,grectViewClient.GetWidth() - urPt.x - 16,urPt.y); // 16 pixels for scrollbar width
#else
	// wxGTK and wxMac need to start drawing text at the point urPt less the width/extent
	// of the text to be drawn
	wxSize sizeOfPhrase = pDC->GetTextExtent(str);
	pDC->DrawText(str,urPt.x - sizeOfPhrase.x,urPt.y);
#endif

#ifdef __WXMSW__
	// turning off RTL layout of the DC after calling DrawText() would seem to be necessary 
	// to best emulate what MFC's DrawText() does with its nFormat parameter
	pDC->SetLayoutDirection(wxLayout_LeftToRight); // need this???
#endif
}

