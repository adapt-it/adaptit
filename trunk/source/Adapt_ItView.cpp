/////////////////////////////////////////////////////////////////////////////////
/// \project		adaptit
/// \file			Adapt_ItView.cpp
/// \author			Bill Martin
/// \date_created	05 January 2004
/// \date_revised	30 December 2008
/// \copyright		2008 Bruce Waters, Bill Martin, SIL International
/// \license		The Common Public License or The GNU Lesser General Public
///                 License (see license directory)
/// \description	This is the implementation file for the CAdapt_ItView class. 
/// The CAdapt_ItView class is the most
/// complex class in the application. It controls every aspect of how the
/// data is presented to the user, and most aspects of the user interface.
/// The data for the view is held entirely in memory and is kept logically
/// separate from and independent of the document class's persistent data
/// structures. This schema is an implementation of the document/view
/// framework.
/// \derivation		The CAdapt_ItView class is derived from wxView.
/////////////////////////////////////////////////////////////////////////////////
// Pending Implementation Items in MainFrm (in order of importance): (search for "TODO")
// 
/////////////////////////////////////////////////////////////////////////////////

//#define DrawFT_Bug

#if defined(__GNUG__) && !defined(__APPLE__)
    #pragma implementation "Adapt_ItView.h"
#endif

// For compilers that support precompilation, includes "wx.h".
#include <wx/wxprec.h>

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
// Include your minimal set of headers here, or wx.h
#include <wx/wx.h>
#endif

#if defined(__VISUALC__) && __VISUALC__ >= 1400
#pragma warning(disable:4428)	// VC 8.0 wrongly issues warning C4428: universal-character-name 
								// encountered in source for a statement like 
								// ellipsis = _T('\u2026');
								// which contains a unicode character \u2026 in a string literal.
								// The MSDN docs for warning C4428 are also misleading!
#endif

#include <wx/docview.h>	// includes wxWidgets doc/view framework
#include <wx/file.h>
#include <wx/clipbrd.h>
#include <wx/filesys.h> // for wxFileName
#include <wx/window.h> // for CaptureMouse()
#include <wx/event.h> // for GetCapturedWindow()
#include <wx/config.h> // for wxConfig
#include <wx/tokenzr.h>
#include <wx/textfile.h> // to get EOL info
#include "Adapt_ItCanvas.h"
#include "Adapt_It_Resources.h"
#include <wx/dir.h> // for wxDir
#include <wx/propdlg.h>
#include <wx/progdlg.h> // for wxProgressDialog
#include <wx/busyinfo.h>
#include <wx/print.h>
#include <wx/dynlib.h> // for wxDynamicLibrary

#ifdef __WXGTK__
#include <wx/dcps.h> // for wxPostScriptDC
#else
#include <wx/dcprint.h> // for wxPrinterDC
#endif

// includes below uncomment as implemented
#include "Adapt_It.h"
#include "ReadOnlyProtection.h"
#include "Adapt_ItDoc.h"
#include "helpers.h"
#include "EditPreferencesDlg.h" 
#include "KB.h"
#include "SourcePhrase.h"
#include "Strip.h"
#include "Pile.h"
#include "Cell.h"
#include "Layout.h"
#include "PhraseBox.h"
#include "Adapt_ItView.h"
#include "AdaptitConstants.h"
#include "RefString.h"
#include "TargetUnit.h"
#include "RetranslationDlg.h"
#include "ChooseTranslation.h"
#include "MainFrm.h"
#include "Welcome.h"
#include "PlaceInternalPunct.h"
#include "KBEditor.h"
#include "ConsistencyCheckDlg.h"
//#include "ProgressDlg.h" // removed in svn revision #562
#include "GoToDlg.h"
#include "WaitDlg.h" 
#include "UnitsDlg.h"
#include "EarlierTranslationDlg.h"
#include "EditSourceTextDlg.h"
#include "ChooseConsistencyCheckTypeDlg.h" //whm added 9Feb04
#include "SetDelay.h" // added for version 2.0.2
#include "CollectBacktranslations.h" // BEW added 14Sept05
#include "NoteDlg.h"
#include "AIPrintout.h"
#include "ExportFunctions.h"
#include "PrintOptionsDlg.h"
#include "ConsistentChanger.h"
#include "SilConverterSelectDlg.h"
#ifdef USE_SIL_CONVERTERS
#include "ECDriver.h"
#endif

// rde added the following but, if it is actually needed we'll use wxMax()
//#ifndef max
//#define max(a,b)            (((a) > (b)) ? (a) : (b))
//#endif

/// This global is defined in Adapt_ItView.cpp.
bool gbLegacySourceTextCopy = FALSE; // BEW added 16July08 at Roland Fumey's 
									 // request (see CViewPage.h & .cpp)
//#define IDW_TARGET_EDITBOX 1001

// Globals

// next global is for passing to SetupCursorGlobals()'s third parameter, for box_cursor
// enum value of cursor_at_offset
int gnBoxCursorOffset = 0;

extern wxDynamicLibrary ecDriverDynamicLibrary;
extern const wxChar *FUNC_NAME_EC_INITIALIZE_CONVERTER_AW;
extern const wxChar *FUNC_NAME_EC_IS_INSTALLED;
extern const wxChar *FUNC_NAME_EC_CONVERT_STRING_AW;

extern bool gbSavedLineFourInReviewingMode;			// these two are defined in PhraseBox.cpp and are for support
extern wxString gStrSaveLineFourInReviewingMode;	// of preserving a hole when phrase box lands and leaves while
													// Reviewing mode is turned on (added 19Dec07)
/// This global is defined in SplitDialog.cpp.
extern bool gbIsDocumentSplittingDialogActive; // see SplitDialog.cpp

/// This global is defined in PhraseBox.cpp.
extern bool gbSuppressStoreForAltBackspaceKeypress;
extern bool gbNoAdaptationRemovalRequested;

/// This global is defined in MainFrm.cpp.
extern bool gbIgnoreScriptureReference_Receive;

/// This global is defined in MainFrm.cpp.
extern bool gbIgnoreScriptureReference_Send;

// for support of scripture synchronizing messages (the sending side of it) -- the
// following string must differ from the one obtained in the
// SendScriptureReferenceFocusMessage() function before a new scripture reference focus
// message is sent (for example, when first entering a new verse, one is sent; but we don't
// want to send one every time the phrase box lands on another word in the same verse) The
// view's member function SendScriptureReferenceFocusMessage() accesses this global string.
wxString gOldChapVerseStr = _T(""); // the "chapter:verse" string used in the last broadcast message
	
/// This global is defined in Adapt_ItView.cpp.
extern bool gbLegacySourceTextCopy;	// default is legacy behaviour, to copy the source text (unless
									// the project config file establishes the FALSE value instead)

/// This global is defined in Adapt_It.cpp.
extern bool gbFreeTranslationJustRemovedInVFMdialog;

extern bool gbRetainBoxContents; // from version 1.4.2, see CPhraseBox for comments on its use whm added bool
extern wxString ccErrorStr;	// used in CConsistentChanger

/// This global is defined in Adapt_It.cpp.
extern wxChar gSFescapechar; // the escape char used for start of a standard format marker

/// This global is defined in Adapt_It.cpp.
extern bool gbHasBookFolders; // TRUE when Adaptations folder is found to have Bible book

// Used for inhibiting multiple accesses to MakeLineFourString when only one is needed.
bool gbInhibitLine4StrCall = FALSE;

// for suppressing MakeLineFourString in ReDoPhraseBox( ) when moving to the
// previous pile (which might have internal punct & we don't want to see Place dialog)
extern bool gbMovingToPreviousPile;

// extern declarations for free translation support (whm moved these to the app)

/// This global is defined in Adapt_It.cpp.
extern int			gnOffsetInMarkersStr; // offset to current free translation string in pSrcPhrase->m_markers

/// This global is defined in Adapt_It.cpp.
extern int			gnLengthInMarkersStr; // free translation length, including final space if any, in pSrcPhrase->m_markers

/// This global is defined in Adapt_It.cpp.
extern wxArrayPtrVoid*	gpCurFreeTransSectionPileArray; // new creates on heap in InitInstance, and disposes in ExitInstance

/// This global is defined in Adapt_It.cpp.
extern wxArrayPtrVoid*	gpFreeTransArray; // new creates on heap in InitInstance, and disposes in ExitInstance

/// This global is defined in Adapt_It.cpp.
extern CPile*		gpFirstPile; // pointer to first pile in a free translation section

/// This global is defined in Adapt_It.cpp.
extern CPile*		gpLastPile; // pointer to last pile in the same section

/// This global is defined in Adapt_It.cpp.
extern wxString	gSpacelessTgtPunctuation; // contents of app's m_punctuation[1] string with spaces removed

/// This global is defined in Adapt_It.cpp.
extern bool		gbSuppressSetup;

/// This global is defined in Adapt_It.cpp.
extern bool		gbSaveHilightingSetting;

// for support of auto-capitalization

/// This global is defined in Adapt_It.cpp.
extern bool	gbAutoCaps;

/// This global is defined in Adapt_It.cpp.
extern bool	gbSourceIsUpperCase;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNonSourceIsUpperCase;

/// This global is defined in Adapt_It.cpp.
extern bool	gbMatchedKB_UCentry;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNoSourceCaseEquivalents;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNoTargetCaseEquivalents;

/// This global is defined in Adapt_It.cpp.
extern bool	gbNoGlossCaseEquivalents;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharNonSrcLC;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharNonSrcUC;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharSrcLC;

/// This global is defined in Adapt_It.cpp.
extern wxChar gcharSrcUC;

bool	gbCallerIsRemoveButton = FALSE;

// for getting source text updated after an edit
int	gnOldMaxIndex = 0;

// next four are for version 2.0 which includes the option of a 3rd line for glossing

/// When TRUE it indicates that the application is in the "See Glosses" mode. In the 
/// "See Glosses" mode any existing glosses are visible in a separate glossing line in 
/// the main window, but words and phrases entered into the phrasebox are not entered 
/// into the glossing KB unless gbEnableGlossing is also TRUE.
bool	gbIsGlossing = FALSE; // when TRUE, the phrase box and its line have glossing text

/// When TRUE the application is in true glossing mode. The phrasebox appears in the 
/// main window's glossing line and contains glosses rather than normal adaptations. 
/// The glosses entered or displayed in the phrasebox are stored in and retrieved from 
/// the glossing KB.
bool	gbEnableGlossing = FALSE; // TRUE makes Adapt It revert to Shoebox functionality only

/// When TRUE the font used in glossing is the Navigation language font. Glossing uses 
/// the Target font & settings by default, but if TRUE then it uses the Navigation language
/// font & direction settings.
bool	gbGlossingUsesNavFont = FALSE; 

/// Defaults to FALSE to allow things like 3:sg:Subj or 1.incl to be put into the glossing 
/// KB 'as is'. When TRUE punctuation is stripped out before saving the gloss in the glossing
/// KB; or, the stripping is done after the gloss has been saved
bool	gbRemovePunctuationFromGlosses = FALSE; 

/// This flag is used to indicate that the text being processed is unstructured, i.e.,
/// not containing the standard format markers (such as verse and chapter) that would 
/// otherwise make the document be structured. This global is used to restore paragraphing 
/// in unstructured data, on export of source or target text.
bool	gbIsUnstructuredData = FALSE; 

/// When no highlighting is wanted for insertions the value is -1, otherwise this global
/// holds the sequence number of the first pile where highlighted background of
/// automatically inserted target text is to be drawn (current active pile + 1).
int	gnBeginInsertionsSequNum = -1;	

/// When no highlighting is wanted for insertions the value is -1, otherwise this global
/// holds the sequence number of the last pile where highlighted background of
/// automatically inserted target text is to be drawn. The ending sequence number is the
/// value for the pile of the phrasebox when it has halted (such as when a KB item can't be
/// found for a match, or when the user uses the Cancel or Cancel and Select buttons in the
/// Choose Translation dialog. Highlight on the cell with the ending value is not apparent
/// as long at the phrase box is located there, but becomes visible if the phrase box is
/// moved away. This also helps the user see where the stopping place was after moving
/// away.)
int	gnEndInsertionsSequNum = -1;	

/// This global is defined in Adapt_It.cpp.
extern bool gbDoingInitialSetup;

// whm added 6Apr05 for support of export filtering of sfms and RTF output of the same in
// the appropriate functions in the View. These globals are defined in ExportSaveAsDlg.cpp
extern wxArrayString m_exportBareMarkers;
extern wxArrayString m_exportMarkerAndDescriptions;
extern wxArrayInt m_exportFilterFlags;
extern wxArrayInt m_exportFilterFlagsBeforeEdit; // to detect any changes to list of markers for export

// Note: for the following, when TRUE the item is placed into the body of the output text (as boxed
// paragraphs for non-interlinear RTF output; as separate table row for interlinear RTF output). When
// FALSE the item is placed as a footnote (at bottom of page).
extern bool bPlaceFreeTransInRTFText;	// default is TRUE
extern bool bPlaceBackTransInRTFText;	// default is FALSE
extern bool bPlaceAINotesInRTFText;		// default is FALSE

extern const wxChar* filterMkr; // defined in the Doc, used here in OnLButtonDown() & free translation code, etc
extern const wxChar* filterMkrEnd; // defined in the Doc, used in free translation code, etc

// The following string is a list of markers that affect character formatting and the text
// to which they apply should not be filtered when the marker is filtered, only the markers
// themselves should be filtered out. This string of markers are used in RTF output
// routines
wxString charFormatMkrs = _T("\\qac \\qs \\qt \\nd \\tl \\dc \\bk \\pn \\wj \\k \\no \\bd \\it \\bdit \\em \\sc ");
// and the end marker forms
wxString charFormatEndMkrs = _T("\\qac* \\qs* \\qt* \\nd* \\tl* \\dc* \\bk* \\pn* \\wj* \\k* \\no* \\bd* \\it* \\bdit* \\em* \\sc* ");
// The following string is a list of markers that are embedded content 
// markers for footnotes, endnotes and crossrefs
wxString embeddedWholeMkrs = _T("\\fr \\fk \\fq \\fqa \\ft \\fdc \\fv \\fm \\xo \\xt \\xk \\xq \\xdc ");
// and the end marker forms
wxString embeddedWholeEndMkrs = _T("\\fr* \\fk* \\fq* \\fqa* \\ft* \\fdc* \\fv* \\fm* \\xo* \\xt* \\xk* \\xq* \\xdc* ");

// The following string is a list of sfms which are significant enough to become a halting
// point for the immediate placement of pending back translation material.
// NOTE: Before checking if a given Marker is included in these strings any numerical level
// part of the Marker to be checked should be removed, i.e., \th1 should be changed to \th,
// \mt1 should be changed to \mt etc. This is done in IsBTMaterialHaltingPoint().
// The following markers should NOT trigger a halt point:
//   end markers of all kinds
//   running header markers \h \h1 \h2 \h3 (these are removed early from buffer)
//	 \note
//   character formatting markers
wxString commonHaltingMarkers = _T("\\v \\c \\p \\m \\q \\qc \\qm \\qr \\qa \\pi \\mi \\pc \\pt \\ps \\pgi \\cl \\vn \\f \\fe \\x \\gd \\tr \\th \thr \\tc \tcr \\mt \\st \\mte \\div \\ms \\s \\sr \\sp \\d \\di \\hl \\r \\dvrf \\mr \\br \\rr \\pp \\pq \\pm \\pmc \\pmr \\cls \\imt \\imte \\is \\ip \\ipi \\ipq \\ipr \\iq \\im \\imi \\imq \\io \\iot \\iex \\ie \\li \\qh \\gm \\gs \\gd \\gp \\tis \\tpi \\tps \\tir \\pb \\hr ");
wxString btHaltingMarkers = commonHaltingMarkers;

// The following string is a list of sfms which are significant enough to become a halting
// point for the immediate placement of pending free translation material.
// NOTE: Before checking if a given Marker is included in these strings any numerical level
// part of the Marker to be checked should be removed, i.e., \th1 should be changed to \th,
// \mt1 should be changed to \mt etc. This is done in IsFreeMaterialHaltingPoint().
wxString freeHaltingMarkers = commonHaltingMarkers;

// The following string arrays are used to construct the cell elements of Interlinear RTF
// output They are populated by BuildInterlinearTextStrArrays(), which is patterned after
// the BuildTargetText() function, but populates the elements of the string into the four
// string arrays below rather than as a single wxString.
wxArrayString SrcStrArray;
wxArrayString TgtStrArray;
wxArrayString GlsStrArray;
wxArrayString NavStrArray;

extern bool gbRTLLayout; // defined in FontPage.cpp
extern bool gbLTRLayout;

/// This global is defined in Adapt_It.cpp.
extern bool	gbRTL_Layout;	// ANSI version is always left to right reading; this flag can only
							// be changed in the Unicode version, using the extra Layout menu

/// This global is defined in Adapt_It.cpp.
extern int	gnVerticalBoxBloat; // see CAdapt_ItApp (bloats vertical dim'n of phrasebox for unicode version)

// basic format integer for use in the DrawText() function (see CDC), since unicode will need
// DrawText()
// MFC has the following bitwise flag set as the default nFormat flag in DrawText:
//UINT gnFormat = DT_SINGLELINE | DT_EXTERNALLEADING | DT_NOCLIP | DT_NOPREFIX | DT_TOP;	// DT_LEFT
																							// is default
// The MFC version ORs other DT flags with the gnFormat flag to produce the globals 
// gnRTLFormat and gnLTRFormat; this is done in the View's OnInitialUpdate() as follows:
// gnRTLFormat = gnFormat | DT_RIGHT | DT_RTLREADING;
// gnLTRFormat = gnFormat | DT_LEFT;
// Then, later the appropriate gn...Format is assigned to a local nFormat value which is fed to
// the MFC DrawText(str,rect,nFormat) function to effect both right alignment and right-to-left 
// reading of the text being drawn.
// whm note: MFC docs say of DT_LEFT, DT_RIGHT and DT_RTLREADING:
//    "DT_LEFT - Aligns text to the left."
//    "DT_RIGHT - Aligns text to the right."
//    "DT_RTLREADING - Layout in right-to-left reading order for bi-directional text when the 
//                    font selected into the hdc is a Hebrew or Arabic font. The default 
//                    reading order for all text is left-to-right."

// whm NOTE: wxDC::DrawText(const wxString& text, wxCoord x, wxCoord y) does not have an
// equivalent to the MFC DrawText's nFormat parameter, but instead wxDC has a
// SetLayoutDirection(wxLayoutDirection dir) method to change the logical direction or
// mirroring of the display context. In wxDC the display context is mirrored right-to-left
// when wxLayout_RightToLeft is passed as the parameter; Certain controls that contain text
// strings such as wxTextCtrl and wxListBox, etc., also have an undocumented method called
// SetLayoutDirection(wxLayoutDirection dir), where dir is wxLayout_LeftToRight or
// wxLayout_RightToLeft.
// Setting the layout to wxLayout_RightToLeft on these controls also involves some
// mirroring affecting the control itself, so that any scrollbar that gets displayed, for
// example, displays on the left side of the control rather than on the right, etc.
// In the wx version we have to be careful about the automatic mirroring features involved
// in the SetLayoutDirection() function. Since Adapt It MFC was designed to micromanage the
// layout direction itself as well as alignment in the coding of text, cells, piles,
// strips, etc., we no doubt encounter problems in layout and must avoid inadvertently
// "reversing" parts of the RTL layout because of the micromanaged layout done in the
// coding of the MFC version.

bool gbDummyAddedTemporarily = FALSE; // TRUE if an null sourcephrase is to be inserted 
        // after the sel'n or after the active location, when the either of those are at
        // the GetMaxIndex() location (we use InsertNullSrcPhrase() which always inserts
        // before a location, so we have to add a dummy at the end until the insert is
        // done, and then remove it.

//////////////////////////////////////////////////////////////////////////////////////
// BEW 7May08: the next globals are for source text editing; the refactored functionality
// may not need all these... and including those for the refactored code (after the old
// ones)

int gnCount; // count of old srcphrases (user selected these) after unmerges, etc
int gnNewCount; // count of the new srcphrases (after user finished editing the source text)

/// A pointer to a sourcephrase immediately preceding the first one in a sublist of old
/// source phrase instances.
CSourcePhrase* gpPrecSrcPhrase; 

/// A pointer to a sourcephrase immediately following the ones in a sublist of source 
/// phrase instances in which their m_srcPhrase attributes have new (edited) values, 
/// or 0 if none; we need access to the following sourcephrase in case the user changes 
/// markers and then the m_bFirstOfType flag on gpFollSrcPhrase would often need to be
/// reset TRUE.
CSourcePhrase* gpFollSrcPhrase; 

// This global was defined in TransferMarkersDlg.cpp in the legacy MFC app.
/// This global is TRUE if the TextType needs to be propagated to sourcephrase instances 
/// following the new sublist, after all housekeeping is done & propagation is done in 
/// OnEditSourceText().
bool gbPropagationNeeded; 

// This global was defined in TransferMarkersDlg.cpp (now removed) in the legacy MFC app.
/// Indicates the TextType to be propagated when the gbPropagationNeeded global is TRUE
TextType gPropagationType; // the TextType to be propagated

/// This global is defined in Adapt_ItDoc.cpp.
extern bool		gbSpecialText;  // the special text boolean which will need to be propagated,
								// if propagation is required


// BEW additional globals and defines, 14Apr08, for support of the vertical editing process

// The next two globals track the vertical edit update process; when
// gbVerticalEditInProgress is turned on (TRUE), the gEntryPoint value specifies what the
// entry point was; this enables the code for any of the vertical edit processing steps to
// be able to determine what kind of edit initiated the vertical update process (eg. a
// source text edit, or an adaptation edit, etc), which in turn enables that code to know
// what members of the gEditRecord struct can be expected to have data in them which can be
// used by the current processing step of the vertical sequence. Each step also has its own
// enum value in the global gEditStep, so that if backtracking through the steps is
// required, the code can know where it must start from in the total process. Also, if the
// user edited a misspelled SF marker, and the marker which results is one nominated for
// filtering or unfiltering, the filtering or unfiltering will take place - changing the
// number of CSourcePhrase instances in the document. The bail out process must be smart
// enough to restore the original doc state when necessary given such a filtering or
// unfiltering has taken place; and we want exceptions to cause restoration of the pre-edit
// document state, rather than application death
/// Tracks whether or not vertical editing is currently in effect, and it has to be TRUE
/// for the drawing of gray text in preceding and following context of the span which is
/// being updated during the vertical edit process
bool gbVerticalEditInProgress = FALSE; // TRUE while any stage of a vertical edit process is active

/// During editing of the source text, up to a certain stage the native document structures
/// are not modified, making it possible to abandon the source text edit without restoring
/// anything in the document while this boolean remains TRUE; once it is FALSE the native
/// structures have begun to be modified and a different source editing abandonment
/// strategy is required (and implemented)
bool gbEditingSourceAndDocNotYetChanged = TRUE; // programmatically cleared to FALSE when doc is changed

/// This global enum tracks the entry point to the vertical editing process - there are
/// five possible values noEntryPoint (0), sourceTextEntryPoint (1), adaptationsEntryPoint
/// (2), glossesEntryPoint (3), freeTranslationsEntryPoint (4). Definition is in
/// Adapt_ItView.h
EntryPoint	gEntryPoint = noEntryPoint;  // from an enum, the value can be one of 
			// noEntryPoint (0), sourceTextEntryPoint (1), adaptationsEntryPoint (2),
			// glossesEntryPoint (3), or freeTranslationsEntryPoint (4) (see Adapt_ItView.h)
					
/// This global enum tracks which step in the vertical editing process is currently in
/// effect. These "steps" are names for various Adapt It modes which otherwise the user
/// would need to manually turn on by menu commands, such as editing the source text,
/// adapting mode, glossing mode, free translation mode, and collecting data from the
/// adaptation or gloss line in order to store it as a filtered back translation; the
/// default value is noEditStep which is the value in effect when vertical editing is not
/// in progress
EditStep gEditStep = noEditStep; // see Adapt_ItView.h

/// Determines the relative order of the adaptationsStep and glossesStep during the
/// vertical process, the default order is to do the adaptations step prior to the glossing
/// step (the TRUE value); the value determines the program counter's path through the code
/// both when stepping forwards through the vertical edit process and also when rolling
/// back changes made at an earlier stage of the process
bool gbAdaptBeforeGloss = TRUE; // TRUE (default) if adaptationsStep is to be done 
        // before glossesStep, FALSE for the opposite order (value of this global stored in
        // project configuration file)

/// The EditRecord is a struct, one instance of which persists as long as the session is
/// alive. It stores information about the vertical edit process which enables rollback and
/// cancellation to be supported. Its members are returned to default values, and most
/// lists emptied, when any one invocation of the vertical edit process is completed.
/// 
/// EditRecord is defined in Adapt_It.h file, here the comments are removed
/// to make reading the members easier
/// typedef struct
/// {
/// 	bool			bGlossingModeOnEntry;
/// 	bool			bSeeGlossesEnabledOnEntry;
/// 	bool			bEditSpanHasAdaptations;
/// 	bool			bEditSpanHasGlosses;
/// 	bool			bEditSpanHasFreeTranslations;
/// 	bool			bEditSpanHasBackTranslations;
/// 	BOOL			bCollectedFromTargetText;
/// 
/// 	int				nSaveActiveSequNum;
/// 	wxString		oldPhraseBoxText;
/// 	TextType		nStartingTextType;
/// 	TextType		nEndingTextType;
/// 	wxArrayString		deletedAdaptationsList;
/// 	wxArrayString		deletedGlossesList;
/// 	wxArrayString		deletedFreeTranslationsList;
/// 	wxArrayString		storedNotesList;
/// 	int				nStartingSequNum;
/// 	int				nEndingSequNum;
/// 	int				nFreeTrans_StartingSequNum;
/// 	int				nFreeTrans_EndingSequNum;
/// 	int				nBackTrans_StartingSequNum;
/// 	int				nBackTrans_EndingSequNum;
/// 	int				nCancelSpan_StartingSequNum;
/// 	int				nCancelSpan_EndingSequNum;
/// 	SPList			cancelSpan_SrcPhraseList;
/// 	SPList			modificationsSpan_SrcPhraseList;
/// 	SPList			editableSpan_NewSrcPhraseList;
/// 	SPList			propagationSpan_SrcPhraseList;
/// 	int				nPropagationSpan_StartingSequNum;
/// 	int				nPropagationSpan_EndingSequNum;
/// 	wxArrayInt		arrNotesSequNumbers;
/// 	CArray<int,int> arrNotesSequNumbers;
/// 	int				nOldSpanCount;
/// 	int				nNewSpanCount;
/// 	wxString		strInitialEndmarkers; 
/// 	wxString		strFinalEndmarkers;
/// 	wxString		strNewFinalEndmarkers;
/// 	bool			bSpecialText;
/// 	SPList			follNotesMoveSpanList;
/// 	SPList			precNotesMoveSpanList;
/// 	bool			bTransferredFilterStuffFromCarrierSrcPhrase;
/// 	bool			bDocEndPreventedTransfer;
/// 	bool			bExtendedForFiltering;
/// 	
/// 	bool			bAdaptationStepEntered;
/// 	SPList			adaptationStep_SrcPhraseList;
/// 	int				nAdaptationStep_StartingSequNum;
/// 	int				nAdaptationStep_EndingSequNum;
/// 	int				nAdaptationStep_OldSpanCount;
/// 	int				nAdaptationStep_NewSpanCount;
/// 	int				nAdaptationStep_ExtrasFromUserEdits;
/// 
/// 	bool			bGlossStepEntered;
/// 	SPList			glossStep_SrcPhraseList;
/// 	int				nGlossStep_StartingSequNum;
/// 	int				nGlossStep_EndingSequNum;
/// 	int				nGlossStep_SpanCount;
/// 
/// 	bool			bFreeTranslationStepEntered;
/// 	bool			bVerseBasedSection;
/// 	SPList			freeTranslationStep_SrcPhraseList;
/// 	int				nFreeTranslationStep_StartingSequNum;
/// 	int				nFreeTranslationStep_EndingSequNum;
/// 	int 			nFreeTranslationStep_SpanCount;
/// } EditRecord;


// The vertical editing process helps the user to edit/update dependent information, when
// editing information at a higher line of a strip invalidates information already entered
// in lower lines which depend on the higher line. The design of the topmost possible level
// of the process, the Edit Source Text functionality, requires a refactored dialog, minus
// the old and complex child dialog where SF markup was separately accessible; the
// refactored design eliminates the latter and shows SF markup and source text together,
// both accessible for editing. To keep the information non-confusing, notes, free
// translations, and any collected back translations defined in any part of the editable
// span, are removed - and retained in lists made accessible to the user later in the
// process (except removed back translations are chucked). The design involves careful
// delineation of four spans where certain types of information are removed from sublists
// -- see the comments for the definition of EditRecord in Adapt_ItView.h for extra
// details. To keep error recovery and cancelling as simple as possible when restoring the
// document to its earlier state, the m_pSourcePhrases list which defines the document is
// not changed until the very last moment when the user's edit is accepted (by the OK
// button press). This means that modifications needed to be done to CSourcePhrase
// instances prior to that, are done on deep copied instances in sublists stored in the
// EditRecord.
// The four spans (implemented as CObList and two int variables per span for the starting
// and ending offsets within the m_pSourcePhrases list on the document) are 1. the editable
// span (the user's selection, but extended to embrace any retranslation/s which the
// selection may overlap), 2. the cancel span - as wide as is necessary to hold deep copies
// of CSourcePhrase instances modified in the edit process (except it perhaps might not
// include all of the propagation span), 3. the modifications span - coextensive with the
// cancel span, but in which needed data modifications (primarily removal of distracting
// information types) are done prior to the Edit Source Text dialog being displayed, and 4.
// the propagation span - a span, possibly empty, or possibly containing numerous deep
// copies of the original CSourcePhrases following the editable span and where propagation
// of a new TextType after the source text edit was done resulted in CSourcePhrase changes.
// Span 1 always lies within spans 2 and 3; span 4 begins, if at all, immediately after
// span 1 and it may overlap completely or partially with instances in the end of spans 2
// and 3.

/// This define specifies the maximum number of etnries in the list of removed data types
/// (whether adaptations, glosses, or free translations) removed programmatically because
/// they have become invalid due to higher level changes during the vertical edit process.
/// Once this limit is reached in any of the three lists, adding more removes drops a
/// corresponding number of entries permanently off the bottom of that particular list
#define DELETIONS_LIST_MAX_ENTRIES 100

/// The vertical edit process tries to determine whether free translation sections, when
/// the user entered the free translations, were defined by punctuation locations, or verse
/// boundaries (for either setting, SF markers also influence the outcome), so that the
/// vertical edit process can use the same setting when the freeTranslationsStep is
/// entered. An algorithm does this but it cannot do it 100% reliably, and if all the
/// strong indicators are absent then it assumes that the 'verse boundaries" setting was in
/// effect if it can count off at least this number of free translation words within the
/// current section being algorithmically checked
#define NUM_WORDS_IMPLYING_VERSE_SECTIONING 15

/// This global provides a persistent location during the current session for storage of 
/// vertical edit information
EditRecord gEditRecord; // store info pertinent to generalized editing with entry 
		// point for an Edit Source Text request, in this global structure
								   
/// This global string variable stores the previous contents of the edit box (either the
/// phrase box or the compose bar's edit box) when the user has just made a choice from the
/// removals combobox's list which replaces the box's text. It enables the Undo Last Copy
/// button to restore the box's previous contents provided further ducks line line up - see
/// the next four global variables for details
wxString gOldEditBoxTextStr; // a place to store the text replaced by the last copy from one of 
							// the Removed combobox list's entries
							
/// This stores the sequence number at which the phrase box was located when the edit box's
/// contents were replaced. The Undo Last Changes button will not undo the last change
/// unless the phrase box has been placed back at this location by the user (the button is
/// disabled until that happens)
int gnWasSequNum;

/// This stores the the m_nSrcWords value when the edit box's contents were replaced. (Just
/// the sequence number value being the same is not sufficient, because the user may
/// subsequently have merged or unmerged at that location - so the merger state (in terms
/// of number of source words) must be the same as a condition for the Undo Last Copy
/// button to be enabled.)
int gnWasNumWordsInSourcePhrase;

/// A further condition for enabling the Undo Last Copy button is that the mode must be the
/// same as it was at the time the replacement was made; this global stores the earlier
/// mode - the values of relevance are whether it was adapting or glossing mode, and so a
/// boolean is suffient for those
bool gbWasGlossingMode; // the mode at last insert, either glossing mode (TRUE) or adapting mode (FALSE)

/// A final condition for enabling the Undo Last Copy button is that whether or not free
/// translation mode was turned on at the time the replacement was made; this mode can be
/// on or off concurrently with either of adapting or glossing modes, and so a further
/// boolean is needed to store the earlier state's value
bool gbWasFreeTranslationMode; // TRUE if free translation mode was in effect at last 
    // insert, in which case gbWasGlossingMode value is ignored, the latter is used if
    // gbWasFreeTranslationMode is FALSE

// end of additional gobals and defines for support of the modeless editing process

// BEW added 15July08; definitions for custom events used in the vertical edit process,
// which typically starts with a source text edit, but in the wxWidgets based apps it could
// also be an adaptation edit, gloss edit, or free translation edit that starts it off;
// these events are UINT
// These custom events are implemented in the CMainFrame class in wx version; I'm leaving
// them commented out here in order to document that they exist - but elsewhere
//UINT CUSTOM_EVENT_ADAPTATIONS_EDIT = RegisterWindowMessage(_T("CustomEventAdaptationsEdit"));
//UINT CUSTOM_EVENT_FREE_TRANSLATIONS_EDIT = RegisterWindowMessage(_T("CustomEventFreeTranslationsEdit"));
//UINT CUSTOM_EVENT_BACK_TRANSLATIONS_EDIT = RegisterWindowMessage(_T("CustomEventBackTranslationsEdit"));
//UINT CUSTOM_EVENT_COLLECTED_BACK_TRANSLATIONS_EDIT 
//							= RegisterWindowMessage(_T("CustomEventVCollectedBackTranslationsEdit"));
//UINT CUSTOM_EVENT_END_VERTICAL_EDIT = RegisterWindowMessage(_T("CustomEventEndVerticalEdit"));
//UINT CUSTOM_EVENT_CANCEL_VERTICAL_EDIT = RegisterWindowMessage(_T("CustomEventCancelVerticalEdit"));
//UINT CUSTOM_EVENT_GLOSSES_EDIT = RegisterWindowMessage(_T("CustomEventGlossesEdit"));

bool gbVerticalEdit_SynchronizedScrollReceiveBooleanWasON = FALSE;

// BEW 7May08: end of vertical editing's globals, including those 
// for the refactored code for src text editing
/////////////////////////////////////////////////////////////////////////////////////

bool			gbInsertingWithinFootnote = FALSE; // TRUE if inserting a null sourcephrase
								// within a footnote; eg. if a retranslation is within a
								// footnote and gets padded with null sourcephrases.
								// We need to know this so that we can propagate the
								// footnote TextType to the padding, or for any other insertion
								// within a footnote.
bool			gbSuppressRemovalOfRefString = FALSE; // set TRUE in SetActivePilePointerSafely,
						// otherwise nested PlacePhraseBox call will result in a RemoveRefString
						// spurious call before the phrasebox is rebuilt, which could remove a
						// source to target translation association wrongly.
extern bool		gbByCopyOnly;		  // see CPhraseBox for explanation of its function
extern int		gnLastEarlierChapter; // preserve chapter and verse number used in last call of
extern int		gnLastEarlierVerse;	  // View Earlier Translation dialog

/// Multiply width of 'w' character this many times to get the slop at right-hand-side
/// (RHS) of initial phrase box width, or the amount to expand the box by.
short			gnExpandBox = 8; 

/// Use this multiplier to calculate when text gets too near the RHS of the phrase box, so
/// that expansion becomes necessary - see the FixBox() function in CPhraseBox class.
short			gnNearEndFactor = 3; 

wxRect			grectViewClient;

/// When TRUE the main window only displays the target text lines.
bool			gbShowTargetOnly = FALSE;

/// Used to store the App's m_curLeading value when switching between views that only
/// display the target language and those that display normal target lines.
int				gnSaveLeading = 4;

/// Used to store the App's m_curGapWidth value when switching between views that only
/// display the target language and those that display normal target lines.
int				gnSaveGap = 8;

bool			gbIgnoreIt = FALSE; // used when "Ignore it, I will fix it later" button was hit
									// in consistency check dlg

extern bool		gbUnmergeJustDone;		 // see CPhraseBox for explanation
extern bool		gbCompletedMergeAndMove; // see CPhraseBox for explanation
extern bool		gbEnterTyped;			 // see CPhraseBox for explanation

extern  wxString	gSaveTargetPhrase; // for use by the SHIFT+END shortcut for unmerging a phrase

extern	bool	gbExpanding; // see use in CalcPileWidth // defined in CPhraseBox // changed int to bool

/// This global is defined in Adapt_It.cpp.
extern  int		nSequNumForLastAutoSave;

/// This global is defined in Adapt_ItDoc.cpp.
extern	bool	bUserCancelled;

extern  bool	gbJustCancelled; // set TRUE when Find or Find & Replace dialog 
        // window has just been cancelled and needed for view's OnButtonMerge() function,
        // the look ahead code block
bool bSuppressDefaultAdaptation = FALSE;	// normally FALSE, but set TRUE whenever 
        // user is wanting a MergeWords done by typing into the phrase box (which also
        // ensures cons.changes won't be done on the typing) - actually more complex than
        // this, see CPhraseBox OnChar()
bool   gbInspectTranslations = FALSE;	// TRUE when user manually opens CChooseTranslation
										// to inspect adaptions
extern bool		gbUserWantsSelection; // carries value from CPhraseBox to caller of LookAhead()
									  // - see there
extern bool		gbUserCancelledChooseTranslationDlg;
extern bool		gbSuppressLookup; // see CPhraseBox globals for explanation

// global to make source phrase accessible to dialogs
CSourcePhrase* gpSrcPhrase;

SPList gSrcPhrases; // for list of CSourcePhrase instances in the retranslation

// global pointer to the punctuation remainder list, for use by CPlaceInternalPunct
wxArrayString* gpRemainderList = (wxArrayString*)NULL; // MFC uses CStringList*

/// TRUE if a consistency check is in progress. Used to supress the placement of the 
/// phrase box when documents are opened while performing a consistency check.
bool	gbConsistencyCheckCurrent = FALSE;

// some globals for use in merging
wxString gOldConcatStr = _T("");			// may have punctuation
wxString gOldConcatStrNoPunct = _T("");  // has any punctuation removed
bool	gbMergeSucceeded = FALSE;

// miscellaneous
bool	gbJustClosedProject = FALSE; // use to suppress Welcome to Adapt It window after doc opened

// global, for choosing whether Find... or Find and Replace... comes up
bool	gbFind = TRUE;
bool	gbFindIsCurrent = FALSE;
bool	gbJustReplaced = FALSE;
bool	gbFindOrReplaceCurrent = FALSE; // for use by CMainFrame's OnActive() function

// BEW added 20March07: for suppressing removal of KB entries when a retranslation or edit
// of a retranslation is currently being done
bool	gbIsRetranslationCurrent = FALSE;

// globals for inserting a replacement target text into a retranslation, when the latter is
// wholly or partly matched (invokes OnButtonEditRetranslation() which uses these globals)
wxString gSrchStr = _T("");
wxString gReplStr = _T("");
bool	 gbReplaceInRetranslation = FALSE;

// globals for handling advancement over a found retranslation
//bool gbMatchedRetranslation = FALSE; BEW 3Aug09 changed it to be the app member 
//m_bMatchedRetranslation
int  gnRetransEndSequNum; // sequ num of last srcPhrase in a matched retranslation

/// A global for saving a source phrase's old sequence number in case it is required 
/// for the toolbar's Back button; or for saving the active location in a variety of
/// command handlers. When there is no earlier location, it is set to -1, but you should
/// never rely on it having the value -1 unless you know you've set -1 earlier
int gnOldSequNum = -1;

// globals defined in CPhraseBox
extern int			nWordsInPhrase;

/// This global is defined in PhraseBox.cpp.
extern wxString		translation; // translation, for a matched source phrase key

extern CTargetUnit*	pCurTargetUnit; // when valid, it is the matched CTargetUnit instance
extern wxString		curKey; // when non empty, it is the current key string which was matched

// global set by ChooseTranslation, when user selects <no adaptation>, then PhraseBox will not
// use CopySource() but instead use an empty string for the adaptation
bool	gbEmptyAdaptationChosen = FALSE;

// global for alerting OnLButtonUp() that selection has been halted at a boundary
// (set in OnMouseMove())
bool	gbHaltedAtBoundary = FALSE;

/// This global is defined in Adapt_It.cpp.
extern wxPoint gptLastClick;

// globals relevant to the printing process
bool	gbPrintingSelection = FALSE;
bool	gbIsPrinting = FALSE; // TRUE when OnPreparePrinting is called, cleared only in
							  // the AIPrintout destructor.
bool	gbPrintingRange = FALSE; // TRUE when the user wants to print a chapter/verse range
int		gnCurPage = 0; // to make number of current page being printed accessible to CStrip's Draw()

/// For preserving selection across a RecalcLayout() or LayoutStrip().
int		gnSelectionStartSequNum; 

/// For preserving selection across a RecalcLayout() or LayoutStrip().
int		gnSelectionEndSequNum;

/// Preserved value of m_selectionLine
int		gnSelectionLine;

bool	gbIsBeingPreviewed = FALSE; // true while a print preview is being done
int		gnPrintingLength; // ditto for the printing length of the page
int		gnFromChapter = 1;
int		gnFromVerse = 1;
int		gnToChapter = 1;
int		gnToVerse = 1;
int		gnRangeStartSequNum;
int		gnRangeEndSequNum;

/// If TRUE print the footer, otherwise skip printing of footer
bool	gbPrintFooter = TRUE;

int		gnTopGap = 100; // units of thousandths of an inch for this and next two
int		gnFooterTextHeight = 150; // for the text of the footer, units of thousandths of an inch
int		gnBottomGap = 0; // assume we can print right to the rtMinMargin.bottom limit on the page
bool	gbSuppressPrecedingHeadingInRange = FALSE;
bool	gbIncludeFollowingHeadingInRange = FALSE;

// struct for storing auto-fix inconsistencies when doing "Consistency Check..." menu item;
// for glossing we can use the same structure with the understanding that the oldAdaptation
// and finalAdaptation will in reality contain the old gloss and the final gloss,
// respectively; and nWords for glossing will always be 1.
struct	AutoFixRecord
{
	wxString	key;
	wxString	oldAdaptation;
	wxString finalAdaptation;
	int		nWords;
};

// Define type safe pointer lists
#include "wx/listimpl.cpp"

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called AFList.
WX_DEFINE_LIST(AFList);

/// This macro together with the macro list declaration in the .h file
/// complete the definition of a new safe pointer list class called WordList.
WX_DEFINE_LIST(WordList);

IMPLEMENT_DYNAMIC_CLASS(CAdapt_ItView, wxView)

BEGIN_EVENT_TABLE(CAdapt_ItView, wxView)
	// Event table data copied from Win AI with ON_COMMAND macro
	// changed to EVT_MENU, and ON_UPDATE_COMMAND_UI changed to
	// EVT_UPDATE_UI for wxWidgets
    EVT_SIZE(CAdapt_ItView::OnSize)

	// File Menu 
	EVT_UPDATE_UI(wxID_NEW, CAdapt_ItView::OnUpdateFileNew)
	EVT_UPDATE_UI(wxID_OPEN, CAdapt_ItView::OnUpdateFileOpen)

	// Standard printing commands
	EVT_MENU(wxID_PRINT, CAdapt_ItView::OnPrint)
	EVT_UPDATE_UI(wxID_PRINT, CAdapt_ItView::OnUpdateFilePrint)
	EVT_MENU(wxID_PREVIEW, CAdapt_ItView::OnPrintPreview)
	EVT_UPDATE_UI(wxID_PREVIEW, CAdapt_ItView::OnUpdateFilePrintPreview)
	EVT_MENU(ID_FILE_STARTUP_WIZARD, CAdapt_ItView::OnFileStartupWizard)
	EVT_MENU(ID_FILE_CLOSEKB, CAdapt_ItView::OnFileCloseProject)
	EVT_UPDATE_UI(ID_FILE_CLOSEKB, CAdapt_ItView::OnUpdateFileCloseKB)
	EVT_MENU(ID_FILE_SAVEKB, CAdapt_ItView::OnFileSaveKB)
	EVT_UPDATE_UI(ID_FILE_SAVEKB, CAdapt_ItView::OnUpdateFileSaveKB)
	// End of File Menu

	// Edit Menu
	EVT_MENU(wxID_UNDO, CAdapt_ItView::OnEditUndo)
	EVT_UPDATE_UI(wxID_UNDO, CAdapt_ItView::OnUpdateEditUndo)
	EVT_MENU(ID_EDIT_CUT, CAdapt_ItView::OnEditCut)
	EVT_UPDATE_UI(ID_EDIT_CUT, CAdapt_ItView::OnUpdateEditCut)
	EVT_MENU(ID_EDIT_COPY, CAdapt_ItView::OnEditCopy)
	EVT_UPDATE_UI(ID_EDIT_COPY, CAdapt_ItView::OnUpdateEditCopy)
	EVT_MENU(ID_EDIT_PASTE, CAdapt_ItView::OnEditPaste)
	EVT_UPDATE_UI(ID_EDIT_PASTE, CAdapt_ItView::OnUpdateEditPaste)
	EVT_MENU(ID_GO_TO, CAdapt_ItView::OnGoTo)
	EVT_UPDATE_UI(ID_GO_TO, CAdapt_ItView::OnUpdateGoTo)
	EVT_MENU(ID_EDIT_SOURCE_TEXT, CAdapt_ItView::OnEditSourceText)
	EVT_UPDATE_UI(ID_EDIT_SOURCE_TEXT, CAdapt_ItView::OnUpdateEditSourceText)
	EVT_MENU(ID_EDIT_CONSISTENCY_CHECK, CAdapt_ItView::OnEditConsistencyCheck)
	EVT_UPDATE_UI(ID_EDIT_CONSISTENCY_CHECK, CAdapt_ItView::OnUpdateEditConsistencyCheck)
	EVT_MENU(ID_EDIT_MOVE_NOTE_FORWARD, CAdapt_ItView::OnEditMoveNoteForward)
	EVT_UPDATE_UI(ID_EDIT_MOVE_NOTE_FORWARD, CAdapt_ItView::OnUpdateEditMoveNoteForward)
	EVT_MENU(ID_EDIT_MOVE_NOTE_BACKWARD, CAdapt_ItView::OnEditMoveNoteBackward)
	EVT_UPDATE_UI(ID_EDIT_MOVE_NOTE_BACKWARD, CAdapt_ItView::OnUpdateEditMoveNoteBackward)
	EVT_MENU(wxID_PREFERENCES, CAdapt_ItView::OnEditPreferences)
	EVT_UPDATE_UI(wxID_PREFERENCES, CAdapt_ItView::OnUpdateEditPreferences)
	// End of Edit Menu

	// View Menu 
	EVT_MENU(ID_COPY_SOURCE, CAdapt_ItView::OnCopySource)
	EVT_UPDATE_UI(ID_COPY_SOURCE, CAdapt_ItView::OnUpdateCopySource)
	EVT_MENU(ID_MARKER_WRAPS_STRIP, CAdapt_ItView::OnMarkerWrapsStrip)
	EVT_UPDATE_UI(ID_MARKER_WRAPS_STRIP, CAdapt_ItView::OnUpdateMarkerWrapsStrip)
	EVT_MENU(ID_UNITS, CAdapt_ItView::OnUnits)
	EVT_UPDATE_UI(ID_UNITS, CAdapt_ItView::OnUpdateUnits)
	// whm added the following two 16Apr07
	EVT_UPDATE_UI(ID_CHANGE_INTERFACE_LANGUAGE, CAdapt_ItView::OnUpdateChangeInterfaceLanguage)
	EVT_MENU(ID_CHANGE_INTERFACE_LANGUAGE, CAdapt_ItView::OnChangeInterfaceLanguage)
	// End of View Menu

	// Tools Menu
	EVT_MENU(wxID_FIND, CAdapt_ItView::OnFind)
	EVT_UPDATE_UI(wxID_FIND, CAdapt_ItView::OnUpdateFind)
	EVT_MENU(wxID_REPLACE, CAdapt_ItView::OnReplace)
	EVT_UPDATE_UI(wxID_REPLACE, CAdapt_ItView::OnUpdateReplace)
	EVT_MENU(ID_USE_CC, CAdapt_ItView::OnUseConsistentChanges)
	EVT_UPDATE_UI(ID_USE_CC, CAdapt_ItView::OnUpdateUseConsistentChanges)

	EVT_MENU(ID_USE_SILCONVERTER, CAdapt_ItView::OnUseSilConverter)
	EVT_UPDATE_UI(ID_USE_SILCONVERTER, CAdapt_ItView::OnUpdateUseSilConverter)
	EVT_MENU(ID_TOOLS_DEFINE_SILCONVERTER, CAdapt_ItView::OnSelectSilConverters)
	EVT_UPDATE_UI(ID_TOOLS_DEFINE_SILCONVERTER, CAdapt_ItView::OnUpdateSelectSilConverters)

	EVT_MENU(ID_ACCEPT_CHANGES, CAdapt_ItView::OnAcceptChanges)
	EVT_UPDATE_UI(ID_ACCEPT_CHANGES, CAdapt_ItView::OnUpdateAcceptChanges)
	EVT_MENU(ID_TOOLS_KB_EDITOR, CAdapt_ItView::OnToolsKbEditor)
	EVT_UPDATE_UI(ID_TOOLS_KB_EDITOR, CAdapt_ItView::OnUpdateToolsKbEditor)
	EVT_MENU(ID_RETRANS_REPORT, CAdapt_ItView::OnRetransReport) // uncomment to activate
	EVT_UPDATE_UI(ID_RETRANS_REPORT, CAdapt_ItView::OnUpdateRetransReport)
	// End of Tools Menu

	// Export-Import Menu
	EVT_MENU(ID_FILE_EXPORT_SOURCE, CAdapt_ItView::OnFileExportSource)
	EVT_UPDATE_UI(ID_FILE_EXPORT_SOURCE, CAdapt_ItView::OnUpdateFileExportSource)
	EVT_MENU(ID_FILE_EXPORT, CAdapt_ItView::OnFileExport)
	EVT_UPDATE_UI(ID_FILE_EXPORT, CAdapt_ItView::OnUpdateFileExport)
	EVT_MENU(ID_FILE_EXPORT_TO_RTF, CAdapt_ItView::OnFileExportToRtf)
	EVT_UPDATE_UI(ID_FILE_EXPORT_TO_RTF, CAdapt_ItView::OnUpdateFileExportToRtf)
	EVT_MENU(ID_EXPORT_GLOSSES, CAdapt_ItView::OnExportGlossesAsText)
	EVT_UPDATE_UI(ID_EXPORT_GLOSSES, CAdapt_ItView::OnUpdateExportGlossesAsText)
	EVT_MENU(ID_EXPORT_FREE_TRANS, CAdapt_ItView::OnExportFreeTranslations)
	EVT_UPDATE_UI(ID_EXPORT_FREE_TRANS, CAdapt_ItView::OnUpdateExportFreeTranslations)
	EVT_MENU(ID_FILE_EXPORT_KB, CAdapt_ItView::OnFileExportKb)
	EVT_UPDATE_UI(ID_FILE_EXPORT_KB, CAdapt_ItView::OnUpdateFileExportKb)
	EVT_MENU(ID_IMPORT_TO_KB, CAdapt_ItView::OnImportToKb)
	EVT_UPDATE_UI(ID_IMPORT_TO_KB, CAdapt_ItView::OnUpdateImportToKb)
	// End of Export-Import Menu

	// Advanced Menu
	// Event for Enable/Disable Glossing menu item
	EVT_MENU(ID_ADVANCED_ENABLEGLOSSING, CAdapt_ItView::OnAdvancedEnableglossing)
	EVT_UPDATE_UI(ID_ADVANCED_ENABLEGLOSSING, CAdapt_ItView::OnUpdateAdvancedEnableglossing)
	// Event for Glossing Uses Nav Font menu item
	EVT_MENU(ID_ADVANCED_GLOSSING_USES_NAV_FONT, CAdapt_ItView::OnAdvancedGlossingUsesNavFont)
	EVT_UPDATE_UI(ID_ADVANCED_GLOSSING_USES_NAV_FONT, CAdapt_ItView::OnUpdateAdvancedGlossingUsesNavFont)
	EVT_MENU(ID_ADVANCED_DELAY, CAdapt_ItView::OnAdvancedDelay)
	EVT_UPDATE_UI(ID_ADVANCED_DELAY, CAdapt_ItView::OnUpdateAdvancedDelay)
	EVT_MENU(ID_ADVANCED_FREE_TRANSLATION_MODE, CAdapt_ItView::OnAdvancedFreeTranslationMode)
	EVT_UPDATE_UI(ID_ADVANCED_FREE_TRANSLATION_MODE, CAdapt_ItView::OnUpdateAdvancedFreeTranslationMode)
	EVT_MENU(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT, CAdapt_ItView::OnAdvancedTargetTextIsDefault)
	EVT_UPDATE_UI(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT, CAdapt_ItView::OnUpdateAdvancedTargetTextIsDefault)
	EVT_MENU(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT, CAdapt_ItView::OnAdvancedGlossTextIsDefault)
	EVT_UPDATE_UI(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT, CAdapt_ItView::OnUpdateAdvancedGlossTextIsDefault)
	EVT_UPDATE_UI(ID_ADVANCED_COLLECT_BACKTRANSLATIONS, CAdapt_ItView::OnUpdateAdvancedCollectBacktranslations)
	EVT_MENU(ID_ADVANCED_COLLECT_BACKTRANSLATIONS, CAdapt_ItView::OnAdvancedCollectBacktranslations)
	EVT_MENU(ID_ADVANCED_REMOVE_FILTERED_BACKTRANSLATIONS, CAdapt_ItView::OnAdvancedRemoveFilteredBacktranslations)
	EVT_UPDATE_UI(ID_ADVANCED_REMOVE_FILTERED_BACKTRANSLATIONS, CAdapt_ItView::OnUpdateAdvancedRemoveFilteredBacktranslations)
	EVT_MENU(ID_ADVANCED_REMOVE_FILTERED_FREE_TRANSLATIONS, CAdapt_ItView::OnAdvancedRemoveFilteredFreeTranslations)
	EVT_UPDATE_UI(ID_ADVANCED_REMOVE_FILTERED_FREE_TRANSLATIONS, CAdapt_ItView::OnUpdateAdvancedRemoveFilteredFreeTranslations)

	EVT_MENU(ID_ADVANCED_USETRANSLITERATIONMODE, CAdapt_ItView::OnAdvancedUseTransliterationMode)
	EVT_UPDATE_UI(ID_ADVANCED_USETRANSLITERATIONMODE, CAdapt_ItView::OnUpdateAdvancedUseTransliterationMode)
	// End of Advanced Menu

//#ifdef _UNICODE
	// Layout Menu
	EVT_MENU(ID_ALIGNMENT, CAdapt_ItView::OnAlignment)
	EVT_UPDATE_UI(ID_ALIGNMENT, CAdapt_ItView::OnUpdateAlignment)
//#endif

	// Help menu
	//OnAppAbout is in CMainFrame in wxWidgets version

	// ControlBar event handlers
	EVT_CHECKBOX(IDC_CHECK_ISGLOSSING, CAdapt_ItView::OnCheckIsGlossing)
	EVT_RADIOBUTTON(IDC_RADIO_DRAFTING, CAdapt_ItView::OnRadioDrafting)
	EVT_RADIOBUTTON(IDC_RADIO_REVIEWING, CAdapt_ItView::OnRadioReviewing)
	EVT_CHECKBOX(IDC_CHECK_SINGLE_STEP, CAdapt_ItView::OnCheckSingleStep)
	EVT_CHECKBOX(IDC_CHECK_KB_SAVE, CAdapt_ItView::OnCheckKBSave)
	EVT_CHECKBOX(IDC_CHECK_FORCE_ASK, CAdapt_ItView::OnCheckForceAsk)
	EVT_BUTTON(IDC_BUTTON_NO_ADAPT, CAdapt_ItView::OnButtonNoAdapt)

	// ToolBar event handlers
	// Event for Enable/Disable Punct copy
	EVT_TOOL(ID_BUTTON_ENABLE_PUNCT_COPY, CAdapt_ItView::OnButtonEnablePunctCopy)
	EVT_UPDATE_UI(ID_BUTTON_ENABLE_PUNCT_COPY, CAdapt_ItView::OnUpdateButtonEnablePunctCopy)
	EVT_TOOL(ID_BUTTON_NO_PUNCT_COPY, CAdapt_ItView::OnButtonNoPunctCopy)
	EVT_UPDATE_UI(ID_BUTTON_NO_PUNCT_COPY, CAdapt_ItView::OnUpdateButtonNoPunctCopy)
	// Event for Respect/Ignore boundary controlBar button
    EVT_TOOL(ID_BUTTON_RESPECTING_BDRY, CAdapt_ItView::OnButtonFromRespectingBdryToIgnoringBdry)
    EVT_UPDATE_UI(ID_BUTTON_RESPECTING_BDRY, CAdapt_ItView::OnUpdateButtonRespectBdry)
    EVT_TOOL(ID_BUTTON_IGNORING_BDRY, CAdapt_ItView::OnButtonFromIgnoringBdryToRespectingBdry)
    EVT_UPDATE_UI(ID_BUTTON_IGNORING_BDRY, CAdapt_ItView::OnUpdateButtonIgnoreBdry)
	// Event for Show/Hide Punctuation controlBar button
	EVT_TOOL(ID_BUTTON_SHOWING_PUNCT, CAdapt_ItView::OnButtonFromShowingToHidingPunct)
	EVT_UPDATE_UI(ID_BUTTON_SHOWING_PUNCT, CAdapt_ItView::OnUpdateButtonShowPunct)
    EVT_TOOL(ID_BUTTON_HIDING_PUNCT, CAdapt_ItView::OnButtonFromHidingToShowingPunct)
	EVT_UPDATE_UI(ID_BUTTON_HIDING_PUNCT, CAdapt_ItView::OnUpdateButtonHidePunct)
	// Event for Show Target/Show All controlBar button
	EVT_TOOL(ID_SHOWING_ALL, CAdapt_ItView::OnFromShowingAllToShowingTargetOnly)
	EVT_UPDATE_UI(ID_SHOWING_ALL, CAdapt_ItView::OnUpdateShowTgt)
	EVT_TOOL(ID_SHOWING_TGT, CAdapt_ItView::OnFromShowingTargetOnlyToShowingAll)
	EVT_UPDATE_UI(ID_SHOWING_TGT, CAdapt_ItView::OnUpdateShowAll)
	EVT_TOOL(ID_BUTTON_CREATE_NOTE, CAdapt_ItView::OnButtonCreateNote)
	EVT_UPDATE_UI(ID_BUTTON_CREATE_NOTE, CAdapt_ItView::OnUpdateButtonCreateNote)
	EVT_TOOL(ID_BUTTON_PREV_NOTE, CAdapt_ItView::OnButtonPrevNote)
	EVT_UPDATE_UI(ID_BUTTON_PREV_NOTE, CAdapt_ItView::OnUpdateButtonPrevNote)
	EVT_TOOL(ID_BUTTON_NEXT_NOTE, CAdapt_ItView::OnButtonNextNote)
	EVT_UPDATE_UI(ID_BUTTON_NEXT_NOTE, CAdapt_ItView::OnUpdateButtonNextNote)
	EVT_TOOL(ID_BUTTON_DELETE_ALL_NOTES, CAdapt_ItView::OnButtonDeleteAllNotes)
	EVT_UPDATE_UI(ID_BUTTON_DELETE_ALL_NOTES, CAdapt_ItView::OnUpdateButtonDeleteAllNotes)
	EVT_TOOL(ID_BUTTON_TO_END, CAdapt_ItView::OnButtonToEnd)
	EVT_UPDATE_UI(ID_BUTTON_TO_END, CAdapt_ItView::OnUpdateButtonToEnd)
	EVT_TOOL(ID_BUTTON_TO_START, CAdapt_ItView::OnButtonToStart)
	EVT_UPDATE_UI(ID_BUTTON_TO_START, CAdapt_ItView::OnUpdateButtonToStart)
	EVT_TOOL(ID_BUTTON_STEP_DOWN, CAdapt_ItView::OnButtonStepDown)
	EVT_UPDATE_UI(ID_BUTTON_STEP_DOWN, CAdapt_ItView::OnUpdateButtonStepDown)
	EVT_TOOL(ID_BUTTON_STEP_UP, CAdapt_ItView::OnButtonStepUp)
	EVT_UPDATE_UI(ID_BUTTON_STEP_UP, CAdapt_ItView::OnUpdateButtonStepUp)
	EVT_TOOL(ID_BUTTON_BACK, CAdapt_ItView::OnButtonBack)
	EVT_UPDATE_UI(ID_BUTTON_BACK, CAdapt_ItView::OnUpdateButtonBack)
	EVT_TOOL(ID_BUTTON_MERGE, CAdapt_ItView::OnButtonMerge)
	EVT_UPDATE_UI(ID_BUTTON_MERGE, CAdapt_ItView::OnUpdateButtonMerge)
	EVT_TOOL(ID_BUTTON_RESTORE, CAdapt_ItView::OnButtonRestore)
	EVT_UPDATE_UI(ID_BUTTON_RESTORE, CAdapt_ItView::OnUpdateButtonRestore)
	EVT_TOOL(ID_BUTTON_RETRANSLATION, CAdapt_ItView::OnButtonRetranslation)
	EVT_UPDATE_UI(ID_BUTTON_RETRANSLATION, CAdapt_ItView::OnUpdateButtonRetranslation)
	EVT_TOOL(ID_BUTTON_EDIT_RETRANSLATION, CAdapt_ItView::OnButtonEditRetranslation)
	EVT_UPDATE_UI(ID_BUTTON_EDIT_RETRANSLATION, CAdapt_ItView::OnUpdateButtonEditRetranslation)
	EVT_TOOL(ID_REMOVE_RETRANSLATION, CAdapt_ItView::OnRemoveRetranslation)
	EVT_UPDATE_UI(ID_REMOVE_RETRANSLATION, CAdapt_ItView::OnUpdateRemoveRetranslation)
	EVT_TOOL(ID_BUTTON_NULL_SRC, CAdapt_ItView::OnButtonNullSrc)
    EVT_UPDATE_UI(ID_BUTTON_NULL_SRC, CAdapt_ItView::OnUpdateButtonNullSrc)
	EVT_TOOL(ID_BUTTON_REMOVE_NULL_SRCPHRASE, CAdapt_ItView::OnButtonRemoveNullSrcPhrase)
	EVT_UPDATE_UI(ID_BUTTON_REMOVE_NULL_SRCPHRASE, CAdapt_ItView::OnUpdateButtonRemoveNullSrcPhrase)
	EVT_TOOL(ID_BUTTON_CHOOSE_TRANSLATION, CAdapt_ItView::OnButtonChooseTranslation)
	EVT_UPDATE_UI(ID_BUTTON_CHOOSE_TRANSLATION, CAdapt_ItView::OnUpdateButtonChooseTranslation)
	EVT_TOOL(ID_BUTTON_EARLIER_TRANSLATION, CAdapt_ItView::OnButtonEarlierTranslation)
	EVT_UPDATE_UI(ID_BUTTON_EARLIER_TRANSLATION, CAdapt_ItView::OnUpdateButtonEarlierTranslation)
	// End of ToolBar event handlers

	// ComposeBar handlers
	EVT_BUTTON(IDC_BUTTON_CLEAR, CAdapt_ItView::OnClearContentsButton)
	EVT_BUTTON(IDC_BUTTON_SELECT_ALL, CAdapt_ItView::OnSelectAllButton)

	// Free Translation - Composebar Buttons
	EVT_BUTTON(IDC_BUTTON_APPLY, CAdapt_ItView::OnAdvanceButton)
	EVT_UPDATE_UI(IDC_BUTTON_NEXT, CAdapt_ItView::OnUpdateNextButton)
	EVT_BUTTON(IDC_BUTTON_NEXT, CAdapt_ItView::OnNextButton)
	EVT_UPDATE_UI(IDC_BUTTON_PREV, CAdapt_ItView::OnUpdatePrevButton)
	EVT_BUTTON(IDC_BUTTON_PREV, CAdapt_ItView::OnPrevButton)
	EVT_UPDATE_UI(IDC_BUTTON_REMOVE, CAdapt_ItView::OnUpdateRemoveFreeTranslationButton)
	EVT_BUTTON(IDC_BUTTON_REMOVE, CAdapt_ItView::OnRemoveFreeTranslationButton)
	EVT_UPDATE_UI(IDC_BUTTON_LENGTHEN, CAdapt_ItView::OnUpdateLengthenButton)
	EVT_BUTTON(IDC_BUTTON_LENGTHEN, CAdapt_ItView::OnLengthenButton)
	EVT_UPDATE_UI(IDC_BUTTON_SHORTEN, CAdapt_ItView::OnUpdateShortenButton)
	EVT_BUTTON(IDC_BUTTON_SHORTEN, CAdapt_ItView::OnShortenButton)
	EVT_RADIOBUTTON(IDC_RADIO_PUNCT_SECTION, CAdapt_ItView::OnRadioDefineByPunctuation)
	EVT_RADIOBUTTON(IDC_RADIO_VERSE_SECTION, CAdapt_ItView::OnRadioDefineByVerse)

	// The following added for Vertical Editing, implemented by BEW
	EVT_UPDATE_UI(IDC_BUTTON_UNDO_LAST_COPY, CAdapt_ItView::OnUpdateButtonUndoLastCopy)
	EVT_BUTTON(IDC_BUTTON_UNDO_LAST_COPY, CAdapt_ItView::OnButtonUndoLastCopy)
	EVT_UPDATE_UI(IDC_BUTTON_PREV_STEP, CAdapt_ItView::OnUpdateButtonPrevStep)
	EVT_BUTTON(IDC_BUTTON_PREV_STEP, CAdapt_ItView::OnButtonPrevStep)
	EVT_UPDATE_UI(IDC_BUTTON_NEXT_STEP, CAdapt_ItView::OnUpdateButtonNextStep)
	EVT_BUTTON(IDC_BUTTON_NEXT_STEP, CAdapt_ItView::OnButtonNextStep)
	EVT_UPDATE_UI(ID_BUTTON_END_NOW, CAdapt_ItView::OnUpdateButtonEndNow)
	EVT_BUTTON(ID_BUTTON_END_NOW, CAdapt_ItView::OnButtonEndNow)
	EVT_UPDATE_UI(ID_BUTTON_CANCEL_ALL_STEPS, CAdapt_ItView::OnUpdateButtonCancelAllSteps)
	EVT_BUTTON(ID_BUTTON_CANCEL_ALL_STEPS, CAdapt_ItView::OnButtonCancelAllSteps)

	// Mouse events  --  moved to CAdapt_ItCanvas
END_EVENT_TABLE()

CAdapt_ItView::CAdapt_ItView()
{
	// whm All MFC's View variable initializations moved to the App

	// below unique to wxWidgets version
	canvas = (CAdapt_ItCanvas*) NULL;
	pCanvasFrame = (wxFrame*) NULL;
}

CAdapt_ItView::~CAdapt_ItView() // whm added
{
	// All cleanup is to be done in App's OnExit() function
}

CLayout* CAdapt_ItView::GetLayout()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	return pApp->m_pLayout;
}

// Can be used for default print/preview
// as well as drawing on the screen
void CAdapt_ItView::OnDraw(wxDC *pDC)
{
    // the mechanism Bill has is that the canvas class handles the paint event, and the
    // handler (OnPaint()) ignores the contents of the passed in event but creates a
    // wxPaintDC with the call wxPaintDC paintDC(this); and then he explicitly calls
    // DoPrepareDC(paintDC) to get the origin scrolled to agree with the scrollbar and then
    // excutes the CAdapt_ItView's OnDraw(wxDC* pDC) by calling the canvas member
    // pView->OnDraw(&paintDC); - so the original wxDC passed to view's OnDraw() is ignored
    // and replaced with the scrolled one from the canvas before any drawing is done - I
    // don't see any problem with this mechanism (BEW note, 20Mar09)
	
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	if (GetLayout() == NULL)
		return; // application not fully initialized yet
	if (GetLayout()->GetPileList()->GetCount() == 0)
		return; // still nothing to draw yet, so can't make any strips
	wxSize canvasViewSize;
	canvasViewSize = pApp->GetMainFrame()->GetCanvasClientSize(); // gets the width and height of canvas in pixels

	pDC->DestroyClippingRegion(); // ensure whole client area is drawable
	
	// draw the layout
	GetLayout()->Draw(pDC);

    // BEW added 7Jul05 for drawing the free translation text substrings in the spaces
    // created under each of the strips (drawing is not done outside the client area for
    // the view)- but only when we are not currently printing
	if (pApp->m_bFreeTranslationMode && !gbIsPrinting)
	{
		DrawFreeTranslations(pDC, GetLayout(), call_from_ondraw);
	}
}

// return the CPile* at the passed in index, or NULL if the index is out of bounds;
// the pile list is at CLayout::m_pileList
CPile* CAdapt_ItView::GetPile(const int nSequNum)
{
	// refactored 10Mar09, for new view layout design
	CLayout* pLayout = GetLayout();
	wxASSERT(pLayout != NULL);
	PileList* pPiles = pLayout->GetPileList();
	int nCount = pPiles->GetCount();
	if (nSequNum < 0 || nSequNum >= nCount)
	{
		// bounds error, so return NULL
		return (CPile*)NULL;
	}
	PileList::Node* pos = pPiles->Item(nSequNum); // relies on parallelism of m_pSourcePhrases 
												  // and m_pileList lists
	wxASSERT(pos != NULL);
	return pos->GetData();
}

CCell* CAdapt_ItView::GetNextCell(CCell *pCell, const int cellIndex)
{
    // returns the next cell at the level specified by cellIndex (note: switching levels is
    // allowed because we only care about the level of the cell in the next pile), or
    // returns NULL if there is no next pile (and hence no next cell)
	// refactored 17Mar09
	CPile* pPile = pCell->GetPile();
	PileList* pPiles = GetLayout()->GetPileList();
	int index = pPiles->IndexOf(pPile);
	index++; // index of next CPile instance
	if (index >= (int)pPiles->GetCount())
	{
		return NULL; // bounds error - passed end of document
	}
	else
	{
		// not past end of document
		PileList::Node* pos = pPiles->Item(index);
		pPile = pos->GetData();
		wxASSERT(pPile != NULL);
	}
	return pPile->GetCell(cellIndex);
}


// returns a pointer to the next pile, or NULL if there is none
CPile* CAdapt_ItView::GetNextPile(CPile *pPile)
{
	// refactored 17Mar09; BEW modified 25Oct09 as pPile can be NULL
	// passed in, in Review mode, so must test for it early!
	if (pPile == NULL)
		return (CPile*)NULL;
	CPile* pNextPile = NULL;
	PileList* pPiles = GetLayout()->GetPileList();
	int index = pPiles->IndexOf(pPile);
	index++; // index of next CPile instance
	if (index >= (int)pPiles->GetCount())
	{
		return (CPile*)NULL; // bounds error - passed end of document
	}
	else
	{
		// not past end of document
		PileList::Node* pos = pPiles->Item(index);
		pNextPile = pos->GetData();
		wxASSERT(pPile != NULL);
	}
	return pNextPile;
}

CPile* CAdapt_ItView::GetPrevPile(CPile *pPile)
// returns a pointer to the previous pile, or NULL if there is none
{
	// refactored 30Mar09
	CPile* pPrevPile = NULL;
	PileList* pPiles = GetLayout()->GetPileList();
	int index = pPiles->IndexOf(pPile);
	index--; // index of previous CPile instance
	if (index < 0)
	{
		return (CPile*)NULL; // bounds error - passed beginning of document
	}
	else
	{
		// not past beginning of document
		PileList::Node* pos = pPiles->Item(index);
		pPrevPile = pos->GetData();
		wxASSERT(pPile != NULL);
	}
	return pPrevPile;
}

// MFC docs say that OnInitialUpdate() is "Called by the framework after the view
// is first attached to the document, but before the view is initially displayed. The
// default implementation of this function calls the OnUpdate member function with no
// hint information (that is, using the default values of 0 for the IHint parameter
// and NULL for the pHint parameter)."
// Design Note: Test of all MFC routines that could potentially call OnInitialUpdate()
// in the App show that OnInitialUpdate() is actually only called at the following
// times in the MFC code:
// 1. At end of OnInit() when app is initially run before the main frame appears (OnInit
//    explicitly calls pView->OnInitialUpdate().
// 2. When File | New menu selection is made (
// 3. When Loading a file from the MRU list.
// 4. When the main window is split (observed Jan07)
// OnInitialUpdate() should be called for only two main scenarios
// (1) for File | New, and (2) when loading a file from the MRU list. It
// doesn't really need to be called in OnInit() because the CreateDocument()
// call there triggers a File | New scenario which includes the OnInitialUpdate()
// call. See notes in App's OnInit().
// TODO: Splitting of the main window in the wxWidgets version is not yet implemented, but
// if/when it is implemented it should be tested to see if OnInitialUpdate should be
// called for that situation too.
void CAdapt_ItView::OnInitialUpdate()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxCommandEvent dummyevent; // for use in EVT governed function calls

    // get the checkbox pointer for glossing, and hide it when app is first launched (a
    // command on the Advanced menu can be used for showing it later on); but since we can
    // get here from closing a doc and then creating or opening another, the gbIsGlossing
    // flag might be TRUE - in which case we will leave it unchanged and not hide the
    // checkbox, because presumably once the user is doing glossing, if he works on another
    // document he will most likely be glossing that too (or so we will assume)
	//
	// NOTE: wxWidgets version - this is taken care of in the App's OnInit()
	//
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);

	// update the copy shown on mode bar (it's read only there)
	wxTextCtrl* pDelayBox = (wxTextCtrl*)pControlBar->FindWindowById(IDC_EDIT_DELAY);
	wxASSERT(pDelayBox != NULL);
	wxString s;
	s.Empty();
	s << pApp->m_nCurDelay; //s = buf;
	pDelayBox->ChangeValue(s);
	pControlBar->Refresh();

	// add the extra menu if it is the Unicode version
#ifdef _RTL_FLAGS
	// Note: The wx version starts with the Layout menu and removes it in the App's OnInit()
	
	// call AdjustAlignmentMenu to insure that the Layout menu items text is set correctly
	AdjustAlignmentMenu(gbRTLLayout, gbLTRLayout);
#endif // for _RTL_FLAGS

	pApp->m_selection.Clear();
	pApp->m_pAnchor = (CCell*)NULL;
	pApp->m_selectionLine = -1;

	// need to ensure the initial targetPhrase box's text is not lost across 
	// the next calls
	wxString saveText = pApp->m_targetPhrase;

    // WX Note: The App's color member are now set directly without short forms
    // specialTextColor etc.
    
	if (!gbShowTargetOnly)
	{
		gnSaveLeading = pApp->m_curLeading;
		gnSaveGap = pApp->m_curGapWidth;
		gbShowTargetOnly = TRUE;
		OnFromShowingTargetOnlyToShowingAll(dummyevent); // normal view, showing source & target lines
	}

    // BEW removed 8Aug09, there is no good reason to store a "punctuation hidden"
    // value because it we do that, the user could get confused if next time his
    // document doesn't show and punctuation and he didn't realize he shut down
    // with this setting toggled from the default, so now we'll ignore the config
    // file value, and always launch the app with this m_bHidePunctuation flag set
    // FALSE -- OnInit() initializes it to FALSE, config file is now ignored
	//if (!pApp->m_bHidePunctuation)
	//{
	//	pApp->m_bHidePunctuation = TRUE; // the function call will reset it to FALSE
	//	OnButtonFromHidingToShowingPunct(dummyevent); // make punctuation visible in lines 1 & 2
	//}
	if (pApp->m_bCopySourcePunctuation)
	{
		pApp->m_bCopySourcePunctuation = FALSE; // the function call will reset it to TRUE
		OnButtonEnablePunctCopy(dummyevent); // enable automatic copying of source text punctuation
	}

	if (pApp->m_bMarkerWrapsStrip)
	{
		// make sure the menu item is shown with checkmark
		pApp->m_bMarkerWrapsStrip = FALSE; // the function call will set it to TRUE
		OnMarkerWrapsStrip(dummyevent);
	}
	if (pApp->m_bCopySource)
	{
		// make sure the Copy Source menu item is shown with checkmark
		pApp->m_bCopySource = FALSE;
		OnCopySource(dummyevent); // toggle it ON, and set the checkmark
	}

    // wx version: the Save As XML menu item is always shown with checkmark and cannot be
    // changed

	if (pApp->m_bTransliterationMode)
	{
		// make sure the Use Transliteration Mode menu item is shown with checkmark
		pApp->m_bTransliterationMode = FALSE;
		OnAdvancedUseTransliterationMode(dummyevent); // toggle it ON, and set the checkmark
	}
	else
	{
		// make sure the Use Transliteration Mode menu item is shown without checkmark
		pApp->m_bTransliterationMode = TRUE;
		OnAdvancedUseTransliterationMode(dummyevent); // toggle it OFF, and clear the checkmark
	}

	if (gbIgnoreScriptureReference_Receive)
	{
		// scripture reference receiving starts out turned off, so get
		// the command unticked (meaning 'it is disabled', that is, turned off)
		gbIgnoreScriptureReference_Receive = FALSE;
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedReceiveSynchronizedScrollingMessages(uevent); //toggle flag to TRUE ie. OFF
	}
	if (gbIgnoreScriptureReference_Send)
	{
		// scripture reference sending starts out turned off, so get
		// the command unticked (meaning 'it is disabled', that is, turned off)
		gbIgnoreScriptureReference_Send = FALSE;
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedSendSynchronizedScrollingMessages(uevent); //toggle flag to TRUE ie. OFF
	}

	// turn the Drafting radio button ON, on the toolbar
	//
	// BEW modified 25Oct09, so that if m_bForce_Review_Mode is TRUE, then a call to 
	// OnNewDocument() (which calls OnInitialUpdate()) does not change m_bDrafting
	// back to a TRUE setting, thereby ruining the intended effect of the former flag
	// - (m_bForce_Review_Mode, once set TRUE in OnInit() should remain TRUE, and 
	// m_bDrafting should remain FALSE, for the life of that session)
	if (!pApp->m_bForce_Review_Mode)
	{
		OnRadioDrafting(dummyevent);
	}

	// set the pointer to the save list
	pApp->m_pSaveList = &pApp->m_saveList;
	
    // At this point the MFC version copies printing variables from those it had on the App
    // to those it maintined here in the View. Since the wx version maintains its printing
    // variable on the App, and they get updated when the config files are read from the
    // App's OnInit(), it is not necessary to

	pApp->SetPageOrientation(pApp->m_bIsPortraitOrientation);

	wxASSERT(pFrame);
	pFrame->SetSize(pApp->m_ptViewTopLeft.x, pApp->m_ptViewTopLeft.y, pApp->m_szView.x,
					pApp->m_szView.y, wxSIZE_AUTO);

	// Our wxWidgets' wxScrolledWindow is handled by the CAdapt_ItCanvas class.
	// From wxScrolledWindow documentation and samples for info on setting
	// up a sizer to help manage scrolling. Methods of wxScrolledWindow particular
	// interest include:
	// void GetViewStart(int* x, int* y) const. Gets the position at which the
	//		visible portion of the window starts. x receives the first visible x
	//		position in scroll units, y receives the first visible y position in
	//		scroll units. If either of the scrollbars is not at the home position
	//		x and/or y will be greater than zero. Combined with wxWindow::GetClientSize
	//		the application can use this function to efficiently redraw only the
	//		visible portion of the window. The positions are in logical scroll units
	//		not pixels, so to convert to pixels you multiply by the number of
	//		pixels per scroll increment.
	// void GetVirtualSize(int* x, int* y) const. Gets the size in device units of
	//		the scrollable window area (as opposed to the client size, which is the
	//		area of the window currently visible). Parameter x receives the length
	//		of the scrollable window, in pixels. Parameter y receives the height of
	//		the scrollable window, in pixels. Use wxDC::DeviceToLogicalX and
	//		wxDC::DeviceToLogicalY to translate these units to logical units.
	// void Scroll(int x, int y). Scrolls a window so the view start is at the
	//		given point. Parameter x is the x position to scroll to, in scroll units.
	//		Parameter y is the y position to scroll to, in scroll units. The
	//		positions are in scroll units, not pixels, so to convert to pixels
	//		you have to multiply by the number of pixels per scroll increment.
	//		If either parameter is -1, that position will be ignored (no change
	//		in that direction).
	// void SetScrollbars(int pixelsPerUnitX, int pixelsPerUnitY, int noUnitsX,
	//		int noUnitsY, int xPos = 0, int yPos = 0, bool noRefresh = FALSE)
	//		Sets up vertical and/or horizontal scrollbars. Parameters are:
	//		pixelsPerUnitX - pixels per scroll unit in the horizontal direction.
	//		pixelsPerUnitY - pixels per scroll unit in the vertical direction.
	//		noUnitsX - number of units in the horizontal direction.
	//		noUnitsY - number of units in the vertical direction.
	//		xPos - position to initialize the scrollbars in the horizontal
	//			direction, in scroll units.
	//		yPos - Position to initialize the scrollbars in the vertical
	//			direction, in scroll units.
	//		noRefresh - will not refresh window if TRUE.
	//		Remarks: The first pair of parameters give the number of pixels
	//		per 'scroll step', i.e. amount moved when the up or down scroll
	//		arrows are pressed. The second pair gives the length of scrollbar
	//		in scroll steps, which sets the size of the virtual window.
	//		xPos and yPos optionally specify a position to scroll to immediately.
	//		For example, the following gives a window horizontal and vertical
	//		scrollbars with 20 pixels per scroll step, and a size of 50 steps
	//		(1000 pixels) in each direction: window->SetScrollbars(20, 20, 50, 50);
	//		wxScrolledWindow manages the page size itself, using the current
	//		client window size as the page size. Note that for more sophisticated
	//		scrolling applications, for example where scroll steps may be variable
	//		according to the position in the document, it will be necessary to
	//		derive a new class from wxWindow, overriding OnSize and adjusting
	//		the scrollbars appropriately. See also wxWindow::SetVirtualSize
	// void SetScrollRate(int xstep, int ystep).
	//		Set the horizontal and vertical scrolling increment only. See the
	//		pixelsPerUnit parameter in SetScrollbars.
	// wxWindow also has void SetVirtualSize(const wxSize& size), which sets the
	//		virtual size of the window in pixels (i.e., wxMM_TEXT).
	//      SetVirtualSize() is used within the wx app in the following functions:
	//      OnOpenDocument(), OnInitialUpdate() and RecalcLayout().

	//
	// wxWidgets' mapping modes can be one of the following:
	// wxMM_TWIPS		Each lodical unit is 1/20 of a point, or 1/1440 of an inch (same as MFC's)
	// wxMM_POINTS		Each lodical unit is a point, or 1/72 of an inch (= MM_TWIPS*20)
	// wxMM_METRIC		Each lodical unit is 1 mm (= 10*MFC's MM_LOMETRIC below)
	// wxMM_LOMETRIC	Each lodical unit is 1/10 of a mm (same as MFC's MM_LOMETRIC below)
	// wxMM_TEXT		Each lodical unit is 1 pixel (same as MFC's)

	// MFC Docs say of SetScrollSizes: "Call SetScrollSizes when the view is about
	// to be updated. First parameter is the mapping mode to set for this view,
	// where: First paramater can be:
	//		MM_TEXT, one Logical Unit = 1 pizel and positive y-axis extends downward.
	//		MM_HIMETRIC, one Logical Unit = 0.01mm, y-axis extends upward
	//		MM_TWIPS, one Logical Unit = 1/1440 inch, y-axis extends upward
	//		MM_HIENGLISH, one Logical Unit = 0.001 inch, y-axis extends upward
	//		MM_LOWMETRIC, one Logical Unit = 0.1 mm, y-axis extends upward
	//		MM_LOENGLISH, one Logical Unit = 0.01 inch, y-axis extends upward
	// Second parameter is the total size of the scroll view. The cx member contains
	// the horizontal extent. The cy member contains the vertical extent, and sizes
	// are in logical units. Both cx and cy must be >= 0. Call it in your override
	// of the OnUpdate member function to adjust scrolling characteristics when,
	// for example, the document is initially displayed or when it changes size.
	// You will typically obtain size information from the view's associated
	// document by calling a document member function, perhaps called GetMyDocSize,
	// that you supply with your derived document class.

	pApp->GetMainFrame()->canvas->SetVirtualSize(pApp->m_docSize);

	// refactored version:
	CLayout* pLayout = pApp->m_pLayout;
	pLayout->InitializeCLayout(); // sets the app, doc, view, canvas & frame pointers, 
								  // and clears m_stripArray
	pLayout->SetLayoutParameters(); // calls InitializeCLayout() and UpdateTextHeights()
									// and other setters
	pApp->m_targetPhrase = saveText;
	pApp->m_nStartChar = -1;
	pApp->m_nEndChar = -1;
	if (pApp->m_pTargetBox != NULL)
	{
		pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar); // select it all
	}
}

bool CAdapt_ItView::OnCreate(wxDocument* doc, long flags) // a virtual method of wxView
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	doc = doc; // avoid "unreferenced formal parameter" warning
	flags = flags; // avoid "unreferenced formal parameter" warning
	pCanvasFrame = pApp->GetMainFrame();
	canvas = pApp->GetMainFrame()->canvas;
	canvas->pView = this;	// make the view pointer owned by MainFrame's canvas
							// point to the current view
    pCanvasFrame->SetTitle(_T("CAdapt_ItView"));
	SetFrame(pCanvasFrame);

#ifdef __X__
    // X seems to require a forced resize
    int x, y;
    pCanvasFrame->GetSize(&x, &y);
    pCanvasFrame->SetSize(-1, -1, x, y);
#endif

	// Create the target box using custom constructor
	// WX Note: Our TargetBox is now a child of the view's canvas (which
	// itself is derived from wxScrolledWindow. As a child of the canvas
	// window, m_pTargetBox will be automatically destroyed when pView->canvas
	// is destroyed during doc/view's normal cleanup. That is, when our View is
	// destroyed, all child windows (including our target box) are automatically
	// destroyed too. Therefore, the target box must not be deleted again in
	// the App's OnExit() method, when the App terminates.
	pApp->m_pTargetBox = new CPhraseBox(pApp->GetMainFrame()->canvas, -1,_T(""),
			wxDefaultPosition,wxDefaultSize,
			wxSIMPLE_BORDER | wxWANTS_CHARS);
	// whm Notes on the wxTextCtrl style flags:
	// wxSIMPLE_BORDER - Displays a thin border around the window.
	// wxWANTS_CHARS - According to the wx docs Use this to indicate that 
	// the window wants to get all char/key events for all keys - even for keys like 
	// TAB or ENTER which are usually used for dialog navigation and which wouldn't 
	// be generated without this style. If you need to use this style in order to 
	// get the arrows or etc., but would still like to have normal keyboard navigation 
	// take place, you should create and send a wxNavigationKeyEvent in response to 
	// the key events for Tab and Shift-Tab.
	// wxTAB_TRAVERSAL - Use this to enable tab traversal for non-dialog windows 
	// (not needed for phrasebox).
	pApp->m_pTargetBox->ChangeValue(_T(""));
	// hide and disable the target box until input is expected
	pApp->m_pTargetBox->Hide();
	pApp->m_pTargetBox->Enable(FALSE);

	// Old note: Since wxView's OnUpdate() doesn't seem to be automatically
	// called at the point that the View is created we'll try calling
	// it here in the View's OnCreate() method just before the View's
	// pCanvasFrame is shown.
	// New note: wxView does have a virtual OnUpdate() method. So rather
	// than calling our own OnInitialUpdate() here, I tired to override
	// wxView's OnUpdate() to call OnInitialUpdate only once when our view
	// is first created, but that had problems.
	OnUpdate(NULL,NULL);
    Activate(TRUE);

	// see docview sample view.cpp for code on how to set up the edit menu
	// Undo and Redo items using doc->GetCommandProcessor() here

	if (pApp->bUserSelectedFileNew)
	{
		// Note: Because of doc/view framework differences between MFC and WX,
		// a user File | New selection in WX calls CreateDocument, which
		// after calling OnSaveModified, calls OnCloseDocument which in
		// turn calls EraseKB on the adapting and glossing KBs. Hence, we
		// need to reinitialize our KBs here, since immediately after this
		// OnCreate() method finishes, OnNewDocument() will be called and
		// the KB structures need to be reinitialized before OnNewDocument
		// can succeed. 

        // we have the desired directory structures. Now we need to get a KB 
        // initialized and stored in the languages-specific folder. Ditto for the glossing
        // KB (version 2)
         
		// BEW changed 1Aug09, because the code was using the old binary filenames *.KB
		// etc, and so creating a new adaptation document using the File / New command was
		// not finding the KB on disk, creating a new empty one and saving it, thereby
		// clobbering the disk's good KB file. So I removed the wrong code and instead
		// called SetupKBPaths() which, for the wx version, sets up the correct normal and
		// alternate path names, file names, and backup paths and filenames.
		pApp->SetupKBPathsEtc();

		if (::wxFileExists(pApp->m_curKBPath)) //if (cFile.GetStatus(m_curKBPath,status))
		{
			// there is an existing .KB file, so we need to create a CKB instance in
			// memory, open the .KB file on disk, and fill the memory instance's members
			wxASSERT(pApp->m_pKB == NULL);
			pApp->m_pKB = new CKB;
			wxASSERT(pApp->m_pKB != NULL);
			bool bOK = pApp->LoadKB();
			if (bOK)
			{
				pApp->m_bKBReady = TRUE;

				// now do it for the glossing KB
				wxASSERT(pApp->m_pGlossingKB == NULL);
				pApp->m_pGlossingKB = new CKB;
				wxASSERT(pApp->m_pGlossingKB != NULL);
				bOK = pApp->LoadGlossingKB();
				if (bOK)
				{
					pApp->m_bGlossingKBReady = TRUE;
				}
				else
				{
					// IDS_LOAD_GLOSSINGKB_FAILURE
					wxMessageBox(_(
"Error: loading the glossing knowledge base failed. The application will now close."),_T(""),
					wxICON_ERROR);
					wxASSERT(FALSE);
					wxExit();
				}
			}
			else
			{
				// IDS_LOAD_KB_FAILURE
				wxMessageBox(_(
			"Error: loading a knowledge base failed. The application will now close."),
				_T(""), wxICON_ERROR);
				wxASSERT(FALSE);
				wxExit();
			}
		}
		else
		{
            // the KB file does not exist, so make sure there is an initialized CKB
            // instance on the application ready to receive data, and save it to disk. for
            // version 2, do the same for the glossing KB
			wxASSERT(pApp->m_pKB == NULL);
			pApp->m_pKB = new CKB;
			wxASSERT(pApp->m_pKB != NULL);

			// store the language names in it
			pApp->m_pKB->m_sourceLanguageName = pApp->m_sourceName;
			pApp->m_pKB->m_targetLanguageName = pApp->m_targetName;

			bool bOK = pApp->StoreKB(FALSE); // first time, so we can't make a backup
			if (bOK)
			{
				pApp->m_bKBReady = TRUE;

				// now do the same for the glossing KB
				wxASSERT(pApp->m_pGlossingKB == NULL);
				pApp->m_pGlossingKB = new CKB;
				wxASSERT(pApp->m_pGlossingKB != NULL);

				bOK = pApp->StoreGlossingKB(FALSE); // first time, so we can't make a backup
				if (bOK)
				{
					pApp->m_bGlossingKBReady = TRUE;
				}
				else
				{
					// IDS_STORE_GLOSSINGKB_FAILURE
					wxMessageBox(_(
"Error: storing the glossing knowledge base to disk for the first time failed. The application will now close."),
					_T(""), wxICON_ERROR); // something went wrong
					wxASSERT(FALSE);
					wxExit();
				}
			}
			else
			{
				// IDS_STORE_KB_FAILURE
				wxMessageBox(_(
"Error: saving the knowledge base failed. The application will now close."),
				_T(""), wxICON_ERROR); // something went wrong
				wxASSERT(FALSE);
				wxExit();
			}

			// BEW added 13Nov09: give the local user ownership for writing, or deny it if
			// somehow someone else has gotten ownership of the project folder already
			pApp->m_bReadOnlyAccess = pApp->m_pROP->SetReadOnlyProtection(pApp->m_curProjectPath);
		}
	}
    return TRUE;
}

int CAdapt_ItView::RecalcPhraseBoxWidth(wxString& phrase)
{
    // a sudden change in the m_targetPhrase's length (eg. due to a paste into the phrase
    // box) and a subsequent RecalcLayout() call, would not allow the box to be smaller
    // than its previous value; so RecalcPhraseBoxWidth() can be called wherever the
    // potential for a resizing of the box is called for
	CAdapt_ItApp* pApp = &wxGetApp();
	wxClientDC dc(pApp->GetMainFrame()->canvas);
	wxClientDC* pDC = &dc;
	int pileWidth;
	int dummyHeight;
	wxFont SaveFont;
	wxFont* pTheFont;
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pTheFont = pApp->m_pNavTextFont;
	else
		pTheFont = pApp->m_pTargetFont;
	SaveFont = dc.GetFont();
	pDC->SetFont(*pTheFont);
	pDC->GetTextExtent(phrase,&pileWidth, &dummyHeight);
	wxString aChar = _T('w');
	int charWidth;
	int charDummyHeight;
	pDC->GetTextExtent(aChar,&charWidth,&charDummyHeight);
	pileWidth += gnExpandBox*charWidth; // allow same slop factor as for 
										// RemakePhraseBox & OnChar
	dc.SetFont(SaveFont); // restore original font, don't need wxClientDC any more
	return pileWidth;
}

void CAdapt_ItView::DoTargetBoxPaste(CPile* pPile)
{
	// Modified to handle glossing or adapting
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	gbByCopyOnly = FALSE; // set this flag FALSE, so text put in the box won't
            // be thrown away if user subsequently clicks to place box elsewhere
            // without doing anything in the phrase box first
	wxString pasteStr;

	// In wx we'll use the clipboard GetData function directly
	if (wxTheClipboard->Open())
	{
		if (wxTheClipboard->IsSupported( wxDF_TEXT ))
		{
			wxTextDataObject data;
			wxTheClipboard->GetData( data );
			pasteStr = data.GetText();
		}
		wxTheClipboard->Close();
	}

    // if consistent changes is turned on, the user must be given the option of having the
    // changes applied or not applied, since we cannot assume that the text to be pasted
    // was not copied from source text (if it was, the changes should be applied)
	wxString insertionText = pasteStr;
	wxASSERT( !(pApp->m_bUseConsistentChanges && pApp->m_bUseSilConverter) ); // not both TRUE
	if (pApp->m_bUseConsistentChanges)
    {
		//IDS_ASK_USE_CC
        if( wxMessageBox(_(
"Do you wish consistent changes to be applied to the text to be pasted?"),
		_T(""), wxYES_NO) == wxYES )
		{
			insertionText = DoConsistentChanges(pasteStr);
		}
    }
    else if( pApp->m_bUseSilConverter )
    {
		// IDS_ASK_USE_SILCONVERTER
        if( wxMessageBox(_(
"Do you wish the configured SILConverter to be applied to the text to be pasted?"),
		_T(""), wxYES_NO) == wxYES )
	    {
		    insertionText = DoSilConvert(pasteStr);
	    }
    }

    // if there is a text selection in the current targetBox, erase the selected chars,
    // then get its text and the caret offset - this is where pasteStr must be inserted wx
    // Note: MFC's CEdit::Clear() deletes (clears) the current selection (if any) in the
    // edit control. wxTextCtrl::Clear() "clears the text in the control, and generates a
    // wxEVT_COMMAND_TEXT_UPDATED event." I'll first check for any existing selection by
    // calling GetStringSelection. If GetStringSelection isn't empty we know there is a
    // selection. If so, then use wxTextCtrl's Remove() method to only remove the
    // selection.
	long nS, nE;
	if (!pApp->m_pTargetBox->GetStringSelection().IsEmpty()) // whm added to 
												// only Remove any selected text
	{
		pApp->m_pTargetBox->GetSelection(&nS,&nE);
		pApp->m_pTargetBox->Remove(nS,nE); //m_targetBox.Clear();
	}
	long nStart; long nEnd;
	pApp->m_pTargetBox->GetSelection(&nStart,&nEnd);
	wxString targetPhrase;
	targetPhrase = pApp->m_pTargetBox->GetValue();
	wxString saveStr = targetPhrase; // make a copy in case we later have to abort 
									 // the operation

	// BEW added 18July08, to support leaving cursor at paste location 
	// (see Roland Fumey request below)
	int pasteStrLength = insertionText.Length();

    // insert the insertionText into the targetStr at the desired location wxString doesn't
    // have an Insert method, so we'll do it with our own InsertInString (see helpers.h)
	targetPhrase = InsertInString(targetPhrase,(int)nStart,insertionText);

    // We have to recreate the box after measuring the text, because the existing box is
    // almost certainly too small and it will reject any characters it cannot fit in. Note,
    // this code would fail if we try to paste too much text, so we accept the text for
    // pasting only if its extent fits within a strip's width - if not, clear the text &
    // give a warning message, but allow any merge.

	// use the targetPhrase text only if the resulting phrase box can fit within a single strip
	int width = RecalcPhraseBoxWidth(targetPhrase);
	CStrip* pStrip = pPile->GetStrip();
	int stripWidth = pStrip->Width(); 
	wxASSERT(stripWidth > 0);
	if (width >= stripWidth)
	{
		// it won't fit within a strip, so try to get out of this fix gracefully
		pApp->m_targetPhrase = saveStr; // restore original text back into m_targetPhrase
		// IDS_PASTE_TEXT_TOO_LONG
		wxMessageBox(_(
"Sorry, the paste operation resulted in text which exceeded the maximum width of a strip, so the operation was aborted."),
		_T(""),wxICON_EXCLAMATION); // warn user
	}
	else
	{
		pApp->m_targetPhrase = targetPhrase; // put the composite text into m_targetPhrase
	}

    // if there was a selection in line 1, we will honour the assumed intent to merge
    // first, and then the pasted stuff will be assumed to be its adaptation; however, if
    // the selection is too long, we will just remove it (not do Retranslation instead as
    // in OnChar) Do the next block only if glossing is OFF, if it is on, we don't allow a
    // merge and so proceed to the 'else' block
	int nSaveActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber;
	if (!gbIsGlossing && pApp->m_selection.GetCount() > 1 && 
		pApp->m_selection.GetCount() <= MAX_WORDS &&
		pApp->m_pActivePile == pApp->m_pAnchor->GetPile())
	{
        // if we selected backwards, we have to be careful - we want nSaveActiveSequNum to
        // be first pile of the selection, so check it out now & if necessary adjust
        // nSaveActiveSequNum
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = (CCell*)cpos->GetData();
		wxASSERT(pCell != NULL);
		CPile* pFirstPile = pCell->GetPile();
		int nFirstSequNum = pFirstPile->GetSrcPhrase()->m_nSequNumber;
		if (nFirstSequNum < nSaveActiveSequNum)
			nSaveActiveSequNum = nFirstSequNum;

		// do the merge
		bSuppressDefaultAdaptation = TRUE; // the global BOOLEAN for temporary 
										   // suppression only
		MergeWords();
		bSuppressDefaultAdaptation = FALSE;

		// restore the active pile pointers
		pPile = GetPile(nSaveActiveSequNum);
		pApp->m_pActivePile = pPile;
	}

	// remove any existing selection, it would be a confusion if left there
	RemoveSelection();

	// setup the phrase box at the same location, but with new size (probably)
	CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
	wxASSERT(pSrcPhrase != NULL);
	pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
	wxASSERT(pApp->m_nActiveSequNum >= 0);

	gnBoxCursorOffset = nStart + pasteStrLength;

	// make the layout adjustments get done and then the draw and showing of the 
	// relocated phrase box
	Invalidate();
	GetLayout()->PlaceBox();
}

CSourcePhrase* CAdapt_ItView::GetSrcPhrase(int nSequNum)
{
	// refactored, no change needed (18Mar09)
	// does the same job as Jonathan's GetSourcePhraseByIndex(int index) 
	// defined in CAdapt_ItApp
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList = pApp->m_pSourcePhrases; 
	wxASSERT(pList);
	int nCount;
	nCount = pList->GetCount();
	wxASSERT(nCount != 0);
	SPList::Node* pos = pList->Item(nSequNum);
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase);
	return pSrcPhrase;
}

// return the first CSourcePhrase instance after the nStartingSequNum in m_pSourcePhrases
// list, which has an empty m_adaption member, or NULL if no such instance can be found;
// this searches in the list of stored source phrases, so it will search to the very end of
// the doc if necessary For version 2.0 and onwards, test gbIsGlossing and branch
// accordingly.
CSourcePhrase* CAdapt_ItView::GetNextEmptySrcPhrase(int nStartingSequNum)
{
	// refactored 18Mar09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pApp->m_pSourcePhrases->Item(nStartingSequNum);
	do
	{
		pos = pos->GetNext();
		if (pos == NULL)
			return (CSourcePhrase*)NULL; // we have gone past end of document
		pSrcPhrase = pos->GetData();
		wxASSERT(pSrcPhrase);
		if (gbIsGlossing)
		{
			if (!pSrcPhrase->m_bHasGlossingKBEntry)
				return pSrcPhrase;
		}
		else
		{
			if (!pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB && 
				!pSrcPhrase->m_bRetranslation)
				return pSrcPhrase;
		}
	} while (TRUE);
}

CSourcePhrase* CAdapt_ItView::GetFollSafeSrcPhrase(CSourcePhrase* pSrcPhrase)
{
	// refactored 19Mar09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pSrcPhrase);
	int sn = pSrcPhrase->m_nSequNumber;
	CSourcePhrase* pSP;
	SPList::Node* pos = pApp->m_pSourcePhrases->Item(sn);
	do
	{
		pos = pos->GetNext();
		if (pos == NULL)
			return (CSourcePhrase*)NULL; // we have gone past end of document
		pSP = pos->GetData();
		wxASSERT(pSP);
	} while (pSP->m_bRetranslation);
	return pSP; // found one where it is okay to have the phrase box put in the view
}

CSourcePhrase* CAdapt_ItView::GetPrevSafeSrcPhrase(CSourcePhrase* pSrcPhrase)
{
	// refactored 19Mar09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pSrcPhrase);
	int sn = pSrcPhrase->m_nSequNumber;
	CSourcePhrase* pSP;
	SPList::Node* pos = pApp->m_pSourcePhrases->Item(sn);
	do
	{
		pos = pos->GetPrevious();
		if (pos == NULL)
			return (CSourcePhrase*)NULL; // we have gone back past start of document
		pSP = pos->GetData();
		wxASSERT(pSP);
	} while (pSP->m_bRetranslation);
	return pSP; // found one where it is okay to have the phrase box put in the view
}

// nSaveActiveSequNum, on input, should be the tentative sequNum value we hope will be a
// valid location but may not be; and nActiveSequNum, on input, should be the current
// active location's sequNum; on output, nSaveActiveSequNum will be a different value if
// the input value landed the box in a retranslation... pSrcPhrases is the list on the app,
// nSaveActiveSequNum - this could be too large since we try place the active location
// after the retranslation and that might be beyond the end of the document, hence the need
// to try find a safe place somewhere (its passed by reference because we want the caller's
// variable of the same name to be automatically updated too); nActiveSequNum is a ref to
// the App's m_nActiveSequNum and we will set it from here; nFinish is the final number of
// piles in the retranslation after all adjustments have been done.
bool CAdapt_ItView::SetActivePilePointerSafely(CAdapt_ItApp* pApp,
		SPList* pSrcPhrases,int& nSaveActiveSequNum,int& nActiveSequNum,int nFinish)
{
	// refactored 19Mar09
	if (nSaveActiveSequNum >= (int)pSrcPhrases->GetCount())
	{
		// need to put active location before the retranslation
		int sequNum = nSaveActiveSequNum - nFinish;
		bool bAtStart = FALSE; // if we get to doc start, put it there no matter what
		CSourcePhrase* pSP;
		do
		{
			--sequNum;
			if (sequNum == 0)
			{
				bAtStart = TRUE;
				break;
			}
			SPList::Node* pos = pSrcPhrases->Item(sequNum);
			pSP = (CSourcePhrase*)pos->GetData();
			wxASSERT(pSP != NULL);
		} while (pSP->m_bRetranslation || pSP->m_bNotInKB);
		if (bAtStart)
			nSaveActiveSequNum = 0;
		else
			nSaveActiveSequNum = sequNum; // new value
		pApp->m_pActivePile = GetPile(nSaveActiveSequNum);
	}
	else
	{
		pApp->m_pActivePile = GetPile(nSaveActiveSequNum);

        // this could be a pile containing a retranslation, so check it out, and if so,
        // advance until we find a safe location, and if that process reaches the end of
        // the document without finding a safe location, then go backwards instead until we
        // find one - one of these processes will definitely succeed.
		CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		if (pSrcPhrase->m_bRetranslation)
		{
			// a retranslation is not a valid phrase box location, 
			// so hunt for a safe place nearby
			CSourcePhrase* pSaveSP = pSrcPhrase;
			pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);

			if (pSrcPhrase == NULL)
			{
                // reached end of source phrase list without finding a safe place, so look
                // in the opposite direction - this (almost certainly) MUST succeed - it
                // could only fail if the previous active location was in the selection and
                // the selection comprised all of the srcPhrases which are not already in a
                // retranslation, and the whole doc is now a series of consecutive
                // retranslations (most unlikely!)
				pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSP);

				if (pSrcPhrase == NULL)
				{
					// nowhere is a safe location! (Is the user retranslating everything? !!!)
					// so our only option is to go to the end & put it there no matter what
					int lastSequNum = (int)pSrcPhrases->GetCount()- 1;
					CPile* pPile = GetPile(lastSequNum);
					pApp->m_targetPhrase.Empty();
					nActiveSequNum = lastSequNum;
					pApp->m_pTargetBox->ChangeValue(_T(""));
					pApp->m_targetPhrase = pPile->GetSrcPhrase()->m_adaption;
					pApp->m_pActivePile = pPile;
					return FALSE; // Note: of 9 calls in the app, only 2 actually use this returned
					// FALSE VALUE - once in OnButtonRetranslation() and the other in 
					// OnButtonEditRetranslation - where they, in the legacy version, caused a
					// warning message to show and the function exited early; in the refactored
					// version the return call after the message is commented out, so the function
					// proceeds normally and the message still shows and the phrase box is put at
					// the document end, visible.
				}
			}
		}

		// jump to whatever pile is not in a retranslation, as close to wanted loc'n as possible
		nSaveActiveSequNum = pSrcPhrase->m_nSequNumber;
		gnOldSequNum = nSaveActiveSequNum; // the only safe option, since old location may now
										   // be within the retranslation
		Jump(pApp,pSrcPhrase);
	}
	nActiveSequNum = nSaveActiveSequNum; // ensure value of pApp->m_nActiveSequNum agrees with any
										 // adjustments
	return TRUE;
}

// returns a pointer to the next pile having no target language (adapted) string, or NULL
// if there is no such empty pile later in the document
// for version 2.0 and on, the check is done on m_glossing instead, when glossing is ON
CPile* CAdapt_ItView::GetNextEmptyPile(CPile *pPile)
{
	// refactored 23Mar09
	if (gbIsGlossing)
	{
		do
		{
			pPile = GetNextPile(pPile);
			if (pPile == NULL)
				break;
		} while (pPile->GetSrcPhrase()->m_bHasGlossingKBEntry);
	}
	else // currently adapting
	{
		do
		{
			pPile = GetNextPile(pPile);
			if (pPile == NULL)
				break;
		} while (pPile->GetSrcPhrase()->m_bHasKBEntry || 
					pPile->GetSrcPhrase()->m_bNotInKB);
	}
	return pPile;
}

void CAdapt_ItView::GetVisibleStrips(int& nFirstStrip,int&nLastStrip)
// nFirstStrip = index of first strip visible (or partly visible) in the view
// nLast Strip = index of last strip visible (or partly visible) in the view
{
	// refactored 1Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CLayout* pLayout = GetLayout();
	wxClientDC dc(pLayout->m_pCanvas);
	canvas->DoPrepareDC(dc); // adjust origin

	// find the index of the first strip which is visible
	wxRect rectStrip;
	int nTotalStrips = pLayout->GetStripArray()->GetCount();
	wxRect rectClient;
    // wx note: calling GetClientSize on the canvas produced different results in wxGTK and
    // wxMSW, so I'll use my own GetCanvasClientSize() which calculates it from the main
    // frame's client size.
	wxSize canvasViewSize;
	canvasViewSize = pApp->GetMainFrame()->GetCanvasClientSize();

//#ifdef _DEBUG
//	// Here's sample code for alternative 1:
//	// save a copy of the initial grectViewClient values for use below (alternative 2 changes grectViewClient)
//	wxRect testRectViewClient = rectClient;
//#endif

	//int xScrollUnits, yScrollUnits, xOrigin, yOrigin;
	//pApp->GetMainFrame()->canvas->GetViewStart(&xOrigin, &yOrigin); // gets xOrigin and yOrigin in scroll units
	//pApp->GetMainFrame()->canvas->GetScrollPixelsPerUnit(&xScrollUnits, &yScrollUnits); // gets pixels per scroll unit
	//rectClient.x = xOrigin * xScrollUnits; // number pixels is ScrollUnits * pixelsPerScrollUnit
	//rectClient.y = yOrigin * yScrollUnits;

//#ifdef _DEBUG
//	//wx version uses CalcUnscrolledPosition
//	int newXPos,newYPos;
//	pApp->GetMainFrame()->canvas->CalcUnscrolledPosition(0,0,&newXPos,&newYPos);
//	wxASSERT(newXPos == rectClient.x); //rectClient.x = newXPos; // stays zero since we dont' have horizontal scrolling
//	wxASSERT(newYPos == rectClient.y); //rectClient.y = newYPos;
//#endif

//#ifdef _DEBUG
//	//dc.DPtoLP(&rectClient); // this is like the MFC method
//	int x = dc.DeviceToLogicalX(testRectViewClient.x);// get the device X (width) coord converted to logical coord
//	int y = dc.DeviceToLogicalY(testRectViewClient.y); // get the device Y (height) coord converted to logical coord
//	wxASSERT(x == rectClient.x);
//	wxASSERT(y == rectClient.y);
//#endif

	wxArrayPtrVoid* pStripArray = pLayout->GetStripArray();
	CStrip* pStrip = NULL;
	pLayout->m_pCanvas->CalcUnscrolledPosition(0,0,&rectClient.x,&rectClient.y);
	rectClient.width = canvasViewSize.x;
	rectClient.height = canvasViewSize.y;
	wxPoint ptStripBottomRight;
	wxPoint ptStripTopLeft;
	int i;
	for (i = 0; i < nTotalStrips; i++)
	{
		pStrip = (CStrip*)(*pStripArray)[i];
		pStrip->GetStripRect_CellsOnly(rectStrip); 
		ptStripBottomRight.x = rectStrip.GetRight();
		ptStripBottomRight.y = rectStrip.GetBottom();

		if (ptStripBottomRight.y > rectClient.GetTop())
		{
			// this strip is at least partly visible
			nFirstStrip = pStrip->GetStripIndex(); // Hmmm, Bill could have just said
											// nFirstStrip = i; here for the same result
			break;
		}
	}

	int j;
	for (j = i + 1; j < nTotalStrips; j++)
	{
		pStrip = (CStrip*)(*pStripArray)[j];
		pStrip->GetStripRect_CellsOnly(rectStrip);

		ptStripTopLeft.x = rectStrip.GetLeft(); // get TopLeft in 2 steps
		ptStripTopLeft.y = rectStrip.GetTop();
		if (ptStripTopLeft.y >= rectClient.GetBottom())
		{
			nLastStrip = --j;
			wxASSERT(nLastStrip > nFirstStrip);
			break;
		}
	}
	if (j == nTotalStrips)
	{
		// we got to the end of the document
		nLastStrip = nTotalStrips - 1;
		wxASSERT(nLastStrip > nFirstStrip);
	}
}

// DoStore_ForPlacePhraseBox added 3Apr09; it factors out some of the incidental
// complexity in the PlacePhraseBox() function, making the latter's design more
// transparent and the function shorter
bool CAdapt_ItView::DoStore_ForPlacePhraseBox(CAdapt_ItApp* pApp, wxString& targetPhrase)
{
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	bool bOK = TRUE;
	if (gbIsGlossing)
	{
		if (targetPhrase.IsEmpty())
			pApp->m_pActivePile->GetSrcPhrase()->m_gloss = targetPhrase;

		// store will fail if the user edited the entry out of the glossing KB, since it
		// cannot know which srcPhrases will be affected, so these will still have their
		// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString but
		// the above flag TRUE is a sufficient test, and if so, set the flag to FALSE
		CRefString* pRefStr = GetRefString(pApp->m_pGlossingKB, 1,
			pApp->m_pActivePile->GetSrcPhrase()->m_key, targetPhrase);
		if (pRefStr == NULL && pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
			pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
		bOK = StoreText(pApp->m_pGlossingKB, pApp->m_pActivePile->GetSrcPhrase(), targetPhrase);
	}
	else // is adapting
	{
		if (targetPhrase.IsEmpty())
			pApp->m_pActivePile->GetSrcPhrase()->m_adaption = targetPhrase;
		// re-express the punctuation
		MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(), targetPhrase);
		RemovePunctuation(pDoc, &targetPhrase, from_target_text);

		// the store will fail if the user edited the entry out of the KB, as the latter
		// cannot know which srcPhrases will be affected, so these will still have their
		// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString but
		// the above flag TRUE is a sufficient test, and if so, set the flag to FALSE
		CRefString* pRefStr = GetRefString(pApp->m_pKB, 
			pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
			pApp->m_pActivePile->GetSrcPhrase()->m_key, targetPhrase);
		if (pRefStr == NULL && pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
			pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
		gbInhibitLine4StrCall = TRUE;
		bOK = StoreText(pApp->m_pKB, pApp->m_pActivePile->GetSrcPhrase(), targetPhrase);
		gbInhibitLine4StrCall = FALSE;
	}
	return bOK;
}

// DoGetSuitableText_ForPlacePhraseBox() factors out a whole lot of special cases for
// getting suitable text to put in the phrase box when the box is reconstituted at the new
// location at which the user clicked to relocate the box there - it simplifies the flow of
// code in PlacePhraseBox() for the sake of the human trying to follow what is going on
// here
void CAdapt_ItView::DoGetSuitableText_ForPlacePhraseBox(CAdapt_ItApp* pApp, 
		CSourcePhrase* pSrcPhrase, int selector, CPile* pActivePile, wxString& str,
		bool bHasNothing, bool bNoValidText, bool bSomethingIsCopied)
{
	wxASSERT(pApp);
	bool bGotOne = FALSE;

	if (bHasNothing)
	{
		// there is as yet no translation for this source phrase & no copy from source
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
		gbByCopyOnly = FALSE;
	}
	else
	{
		// this block is for lookup, merger, failure to find a KB entry, and landing on
		// a "hole" when in free translation mode and Advance or Next> was pressed
		gbByCopyOnly = FALSE;
		if (bNoValidText)
		{
            // BEW added 20Dec07 to prevent lookup when in Reviewing mode (some further
            // comments & supporting code changes are in the blocks below)
			if (pApp->m_bDrafting)
			{
                // BEW added 16Jul09; return an empty string if we are in free translation
                // mode and the phrase box at the next section has been put at a "hole"
				if (pApp->m_bFreeTranslationMode)
				{
					str.Empty();
					return;
				}
				// it's not free translation mode, so try find something
				bGotOne = pApp->m_pTargetBox->LookAhead(this, pApp->m_pActivePile);
			}
			else // we are in reviewing mode for the code in next block
			{
				// Reviewing mode, we still need to ensure that if the user cancelled a 
				// Choose Translation merge, then pSrcPhrase will be valid before we proceed
				pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

				// ensure clicks to a location which is a hole don't, on leaving, result in
				// punctuation being copied from the source text if present there
				if (pSrcPhrase->m_targetStr.IsEmpty() || pSrcPhrase->m_adaption.IsEmpty())
				{
					// no text or punctuation, or no text and punctuation not yet placed,
					// or no text and punctuation was earlier placed -- whichever is the case
					// we need to preserve that state
					gbSavedLineFourInReviewingMode = TRUE;  // it gets cleared again at
															// end of MakeLineFourString()
					gStrSaveLineFourInReviewingMode = pSrcPhrase->m_targetStr; // cleared
															// at end of MakeLineFourString()
				}

				pApp->m_pTargetBox->m_bAbandonable = FALSE;	// don't throw away unedited
                //phrase box contents when the phrase box leaves a location by a user's
                //click and then make sure we retain the contents in the m_targetStr member
                //of pSrcPhrase, since user is reviewing; but use m_gloss if Glossing mode
                //is on
				if (gbIsGlossing)
					str = pSrcPhrase->m_gloss;
				else
					str = pSrcPhrase->m_targetStr;
			} // end block for reviewing mode

			// in Reviewing mode, bGotOne will always be FALSE when control reaches here and so
			// the next block would not be entered - which is fine because in Reviewing mode
			// there is no need to perform a merge when landing on a new pile
			if (bGotOne)
			{
				if (!gbIsGlossing)// do nix here if glossing is on, since glossing disallows merges
				{
					if (!gbCompletedMergeAndMove) // (true means phrase box moved before Choose
					{							  // Translation dialog can be shown, see LookAhead( )
						// do this only if the flag was not set
						pApp->m_pTargetBox->m_bAbandonable = FALSE;
						if (nWordsInPhrase > 1) // nWordsInPhrase is a global
						{
							// do the needed merge, etc.
							pApp->bLookAheadMerge = TRUE; // set static flag to ON
							MergeWords(); // the Choose Translation dialog might be shown in this call
							pApp->bLookAheadMerge = FALSE; // restore static flag to OFF
						}
					}
				}
                // if user cancelled a Choose Translation merge, then pSrcPhrase will be
                // invalid, so we have to make sure the pointer is valid before we proceed
				pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

                // assign the translation text - but check it's not "<Not In KB>", if it
                // is, we leave the phrase box empty, turn OFF the m_bSaveToKB flag, DON'T
                // halt auto-inserting if it is on, (formerly, I made it halt) from v 1.4.0
                // and onwards, we have to just put default null adaptation there, since a
                // successful lookup of 'not in kb' can't possibly assign any adaptation
                // except null text - unless there already is something on the source
                // phrase - in which case use that
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
                // if we are glossing, then the global variable wxString translation, will
                // have the gloss because a successful lookup was done
				if (!gbIsGlossing)
				{
                    // if adapting, check for a not in kb entry and if it is, then adjust
                    // translation; strictly speaking we only want to clear the string when
                    // in Drafting mode, but in Reviewing mode we want to let whatever was
                    // formerly there continue unchanged, so a test would be appropriate
                    // here if it was not for the fact that above we wrap the LookAhead
                    // call in a test of the m_bDrafting flag, and so in Reviewing mode
                    // bGodOne remains FALSE and so this current block would not be entered
					if (translation == _T("<Not In KB>"))
					{
						pApp->m_bSaveToKB = FALSE;
						pSrcPhrase->m_bHasKBEntry = FALSE; // ensures * shows above this srcPhrase
						pSrcPhrase->m_bNotInKB = TRUE;
						if (pSrcPhrase->m_targetStr.IsEmpty())
						{
							translation.Empty(); // clear the global
							pApp->m_targetPhrase.Empty();
						}
						else
						{
							translation = pSrcPhrase->m_targetStr;
						}
					}
				}
				str = translation; // adapting or glossing, put the final translation into str
			}
		}
		else // there is valid text -- this is typically the case when in Reviewing mode
		{
            // when in Reviewing mode and the user clicks on existing adaptation or gloss
            // text, no lookup is done because bNoValidText is FALSE, and so control will
            // have jumped to the present block. At this point, str is still empty, and so
            // we need here to ensure that what is at the clicked location is retained, so
            // we set str etc.
			if (!pApp->m_bDrafting) // ensure we really *are* in Reviewing mode for this stuff
			{
				// Reviewing mode, we still need to ensure that if the user cancelled a 
				// Choose Translation merge, then pSrcPhrase will be valid before we proceed
				pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

				// ensure clicks to a location which is a hole don't, on leaving, result in
				// punctuation being copied from the source text if present there
				if (pSrcPhrase->m_targetStr.IsEmpty() || pSrcPhrase->m_adaption.IsEmpty())
				{
					// no text or punctuation, or no text and punctuation not yet placed,
					// or no text and punctuation was earlier placed -- whichever is the case
					// we need to preserve that state
					gbSavedLineFourInReviewingMode = TRUE;	// it gets cleared again at end 
															// of MakeLineFourString()
					gStrSaveLineFourInReviewingMode = pSrcPhrase->m_targetStr; // cleared at
																// end of MakeLineFourString()
				}
				pApp->m_pTargetBox->m_bAbandonable = FALSE; // don't throw away unedited
                    // phrase box contents when the phrase box leaves a location by a click
                    // and then make sure we retain the contents in the m_targetStr member
                    // of pSrcPhrase, since user is reviewing; but use m_gloss if Glossing
                    // mode is on
				if (gbIsGlossing)
					str = pSrcPhrase->m_gloss;
				else
					str = pSrcPhrase->m_targetStr;
			} // end block for check that we really are in reviewing mode
		}

        // BEW added to the test 02Nov05, so that when the SplitDialog is active, any use
        // of a button in that dialog which results in a PlacePhraseBox being done (eg. by
        // Jump()) will not copy the source text into the phrasebox if the box lands at a
        // hitherto unadapted (or unglossed) location -- so if the document split is then
        // made at that location, it won't save into the KB a spurious copy of the source
        // text as the 'adaptation' at whatever location the box happened to land at. The
        // app setter function SetCurrentSourcePhrase sets and clears the global flag
        // gbIsDocumentSplittingDialogActive to effect this.
		if (!bGotOne && !gbIsDocumentSplittingDialogActive)
		{
            // if user cancelled a Choose Translation merge, then pSrcPhrase will be
            // invalid, so we have to make sure the pointer is valid before we proceed
			pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

            // BEW added test 20Dec07: Reviewing mode must not copy down source text into
            // holes (ie. we assume the holes are there by choice, and we don't want
            // spurious text to fill them, although the user is free to manually type at
            // such locations if he wishes)
			if (pApp->m_bDrafting)
			{
                // lookup did not find a suitable adaptation, or gloss if in glossing mode,
                // so we want a copy from the sourcePhrase done instead - but not when in
                // Reviewing mode
				wxString theText;
				if (gbIsGlossing)
					theText = pSrcPhrase->m_gloss;
				else
					theText = pSrcPhrase->m_adaption;
				if (!theText.IsEmpty()) // we want a punctuation-less test here
				{
					if (gbIsGlossing)
					{
						str = theText;
					}
					else // adapting
					{
						str = pSrcPhrase->m_adaption; // no punctuation to be shown
						// BEW changed 28Apr05, this is a better choice for the box contents
						// than to show punctuation if the m_bHidePunctuation flag is FALSE;
						// always using m_adaption means MakeLineFourString() can then be
						// allowed to do its work when the phrase box moves on, that's best
					}
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else
				{
					if (bSomethingIsCopied)
					{
						str = CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
													// and it sets gbByCopyOnly to TRUE
					}
					else // nothing copied, or its a null source phrase, or a null string
					{
                        // we didn't do a copy, so we will want whatever eventually results
                        // to still be stored later on
						gbByCopyOnly = FALSE;
					}
					// if its a null source phrase, or the copy source flag is turned off,
					// or the user stored a null string as the adaption, we don't show anything
					// - but either way it's abandonable
					pApp->m_pTargetBox->m_bAbandonable = TRUE;
				}
			} // end of block for m_bDrafting == TRUE, for Reviewing mode we 
			  // don't want a copy done
		} // end block for tests: bGotOne == FALSE and "is split dialog is 
		  // active currently?" == FALSE

        // don't do the following selection when PlacePhraseBox() is called from deep in
        // some other function before the phrasebox is finally rebuilt (such as in the
        // SetActivePilePointerSafely() call in the OnButtonRetranslation() call; since it
        // would then either decrement a refCount, or remove a translation association,
        // wrongly) - in such instances, we must suppress the removal
		if (!gbSuppressRemovalOfRefString)
		{
			// remove the CRefString from the KB if it is referenced only once, otherwise
			// decrement its reference count by one, so that if user edits the string the KB
			// (or if glossing, then the glossing KB) will be kept up to date
			if (selector != 1) // see comments under the function header for explanation
			{
				// do this for selector values 0 or 2
				CRefString* pRefString;
				if (gbIsGlossing)
					pRefString = GetRefString(GetKB(), 1, pSrcPhrase->m_key,
												pSrcPhrase->m_gloss);
				else
					pRefString = GetRefString(GetKB(), pSrcPhrase->m_nSrcWords,
												pSrcPhrase->m_key, pSrcPhrase->m_adaption);

                // it is okay to do the following call with pRefString == NULL, in fact, it
                // must be done whether NULL or not; since if it is NULL, RemoveRefString
                // will clear pSrcPhrase's m_bHasKBEntry to FALSE, which if not done, would
                // result in a crash if the user clicked on a source phrase which had its
                // reference string manually removed from the KB and then clicked on
                // another source phrase. (The StoreAdaption call in the second click would
                // trip the first line's ASSERT.)
				if (gbIsGlossing)
					RemoveRefString(pRefString, pSrcPhrase,from_target_text); // pRefString 
																	// is from glossing KB
				else
					RemoveRefString(pRefString, pSrcPhrase, pSrcPhrase->m_nSrcWords); 
														// pRefString is from adaption KB
			}
		}
		// this next call relies for it's success on pActivePile being the CPile* at the
		// new active location, and that the partner CSourcePhrase instance has its
		// m_nSequNumber value set to the same value as the app's member m_nActiveSequNum
		// - these conditions are guaranteed by code above in this function (360 lines up)
		pActivePile->SetPhraseBoxGapWidth(); // also sets CLayout::m_curBoxWidth to 
                    // same value that it sets in the active pile's m_nWidth member
	} // end of block for lookup, merger, and failure to find a KB entry
}

// Returns nothing. 
// This function is called when a match has been made for a Find button click, also when
// no match is possible or user cancels out of the Find operation. The idea is to place
// the phrase box at the start of the match (the user may have stipulated that the match
// be for more than one word and across piles), and the source text selected there, and
// the PlacePhraseBox() call made, followed by ScrollIntoView() in order to give the user
// all options for what to do next. If several words were selected at the take off
// location, then the match should be for the same number of words at the landing location
// and the selection is set up accordingly as possible. A complication is when the matched
// text is within a retranslation - in this circumstance we select the matched text as
// before, but the active location is moved to be "safe" which in this circumstance means
// immediately before the retranslation. In the case of matching source text, the
// selection is normal yellow background. In the case of matching target text, we'll do
// similarly and no try to be smart, and just select all of the phrase box contents - even
// if only part of the text was matched.
void CAdapt_ItView::FindNextHasLanded(int nLandingLocSequNum, bool bSuppressSelectionExtension)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CPile* pPile = NULL;
	if (nLandingLocSequNum == -1)
	{
		// should never be called with a value of -1 passed in, but if so, just do nothing
		return; 
	}
	pPile = GetPile(nLandingLocSequNum);

	// preserve enough information to be able to recreate the appropriate selection
	// since placing the phrase box will clobber the earlier selection at last landing
	CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
	int nCount = 0;
	if (!pApp->m_selection.IsEmpty())
	{
		nCount = pApp->m_selection.GetCount();
		wxASSERT(nCount > 0);
	}
	int nSaveSelSequNum = pSrcPhrase->m_nSequNumber; // if in a retrans, 
								// selection will not be where phrase box ends up

    // pPile is what we will use for the active pile, so set everything up there,
    // provided it is not in a retranslation - if it is, place the box preceding
    // it, if possible; but if glossing is ON, we can have the box within a
    // retranslation in which case ignore the block of code
	CPile* pSavePile = pPile;
	if (!gbIsGlossing)
	{
		while (pSrcPhrase->m_bRetranslation)
		{
			pPile = GetPrevPile(pPile);
			if (pPile == NULL)
			{
				// if we get to the start, try again, going the other way
				pPile = pSavePile;
				while (pSrcPhrase->m_bRetranslation)
				{
					pPile = GetNextPile(pPile);
					wxASSERT(pPile != NULL); // we'll assume this will never fail
					pSrcPhrase = pPile->GetSrcPhrase();
				}
				break;
			}
			pSrcPhrase = pPile->GetSrcPhrase();
		}
	}
	pSrcPhrase = pPile->GetSrcPhrase();
	pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber; // what we finally will use
	pApp->m_pActivePile = pPile;
	CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

	// place the phrase box
	PlacePhraseBox(pCell,2);

	// get a new active pile pointer, the PlacePhraseBox call did a recal 
	// of the layout
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);

	// scroll into view, just in case (but shouldn't be needed) BEW 16Jun09
	// moved this to be after the recalc of the layout, pointless to do it before
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

    // get a new pointer to the pile at the start of the selection, since the
	// recalc also clobbered the old one -- this selection could possibly be removed from
	// the active location if the original landing place was in a retranslation, if it
	// wasn't in a retranslation, it should be starting from the active location
	CPile* pSelPile = GetPile(nSaveSelSequNum);
	wxASSERT(pSelPile != NULL);

	Invalidate(); // get the view window redrawn, and the phrase box
	GetLayout()->PlaceBox();

	// restore focus to the targetBox
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->SetSelection(-1,-1); // -1,-1 selects all
			pApp->m_pTargetBox->SetFocus();
		}
	}

	// recreate the selection to be in top line; we suppress this in places where another
	// external function called after this one returns will do this job for us
	if (!bSuppressSelectionExtension)
	{
		CCell* pAnchorCell = pSelPile->GetCell(0);
		if (nCount > 0 && pAnchorCell != NULL)
		{
			pApp->m_pAnchor = pAnchorCell;
			CCellList* pSelection = &pApp->m_selection;
			wxASSERT(pSelection->IsEmpty());
			pApp->m_selectionLine = 0;
			wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context

			// then do the new selection, start with the anchor cell

			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			pAnchorCell->DrawCell(&aDC, pApp->m_pLayout->GetSrcColor());
			pApp->m_bSelectByArrowKey = FALSE;
			pAnchorCell->SetSelected(TRUE);

			// preserve record of the selection
			pSelection->Append(pAnchorCell);

			// extend the selection to the right, if more than one pile is involved
			if (nCount > 1)
			{
				// extend the selection (shouldn't be called when glossing is ON
				// because we inhibit matching across piles in that circumstance)
				ExtendSelectionForFind(pAnchorCell,nCount);
			}
		}
	}
}

// PlacePhraseBox() selector values: used for inhibiting one or both of two blocks of code.
// The first block should be done only when the user has clicked elsewhere after being in a
// former location, since the first block saves the adaptation text left in the former
// phrase box's location. The second block removes the adaptation text from the KB when the
// focus has moved to the new location clicked. It is not appropriate to do this code when
// returning from being in a dialog such as Choose Translation, since the adaptation text
// will already have been removed before the dialog was entered, so selector = 1 inhibits
// this block. The other two possible situations, a normal click (selector = 0), or the
// target box was previously not at any location - as when the user has just opened a saved
// document file, it is essential to remove the adaption text from the phrase box's
// location, so that when the user hits RETURN to move on, the store will be re-done and
// the ASSERT in start of StoreText function will not trip; so a selector value of 2 is
// used for this case. That is, 
// selector = 0 enables both blocks to be done, 
// selector = 1 disables both blocks, and 
// selector = 2 disables the first block but enables the second block.
// BEW added 27Jun05, For version 3, free translation support requires we can enable
// the first block and disable the second block, so for this combination we will use a
// selector value of 3. For version 2.0, which supports glossing, the function will test
// the gbIsGlossing flag in a number of places; these changes will increase the complexity
// of an already complex function, but it is better than having a separate glossing version
// which would bloat the app's size 
// Ammended, July 2003, for auto-capitalization support
void CAdapt_ItView::PlacePhraseBox(CCell *pCell, int selector)
{
	// refactored 2Apr09
	CLayout* pLayout = GetLayout();
	if (pCell == NULL)
	{
		pLayout->m_docEditOperationType = relocate_box_op;
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	CPile* pClickedPile = pCell->GetPile();
	wxASSERT(pClickedPile);
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),1,pApp->m_nActiveSequNum);
//#endif
	
	// if there is no active pile defined, construct one at the clicked location,
	// or at whatever cell pointer was passed in - eg. when having just opened a document,
	// the active sequence number can be -1
	if (pApp->m_pActivePile == NULL)
	{
		int sequNum = pCell->GetPile()->GetSrcPhrase()->m_nSequNumber;
		pApp->m_pActivePile = GetPile(sequNum);
	}
	
	CSourcePhrase* pOldActiveSrcPhrase = NULL;
	CPile* pOldActivePile = GetPile(pApp->m_nActiveSequNum); 
						// returns NULL if passed in value is -1
	if (pOldActivePile != NULL)
	{
		pOldActiveSrcPhrase = pOldActivePile->GetSrcPhrase();
		wxASSERT(pOldActiveSrcPhrase);
	}
	gbEnterTyped = FALSE; // ensure its false, only hitting ENTER key 
						  // should set it TRUE
	wxASSERT(pCell);
	if (pCell->GetCellIndex() != 1) // index == 1 is the line of cells 
									// which has the phrase box
	{
		gSaveTargetPhrase = pApp->m_targetPhrase; // an adaptation, or a gloss, depending on mode
		pLayout->m_docEditOperationType = relocate_box_op;
		return;
	}
	CAdapt_ItDoc* pDoc = GetDocument();
	pDoc->Modify(TRUE);

	// if auto capitalization is on, determine the source text's case propertiess
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		if (pApp->m_pActivePile == NULL)
		{
			// active location is undefined because we are at the end of the document
			bNoError = FALSE;
		}
		else
		{
			bNoError = SetCaseParameters(pApp->m_pActivePile->GetSrcPhrase()->m_key);
		}
	}
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),2,pApp->m_nActiveSequNum);
//#endif

    // Also inhibit if it is a "<Not In KB>" location where there is something in the
    // phrase box but the m_bSaveToKB flag is still off (FALSE) - but only provided we are
    // in adapting mode
	if (!(pApp->m_nActiveSequNum == -1)) // can't do the following block if there is no
										 // active pile currently in existence
	{
        // if it's an <Not In KB> entry, from version 1.4.0 and onwards, by Susanna Imrie's
        // suggestion, we allow the document to have a non null adaptation even when <Not
        // In KB> has been chosen; so we don't clear, but we do the check to fix a wrongly
        // edited adaption KB. This check is required only for gbIsGlossing == FALSE, since
        // the glossing KB knows nothing of <Not In KB> behaviour
        // BEW added to test 23Jul05, since m_bNotInKB is also true for retranslations and
        // when in free translation mode if we don't exclude retranslations then <Prev,
        // Next> or Advance buttons, if they land the box in a retranslation, the phrase
        // box text that get's set up is the old location's adaptation, not to mention a
        // spurious save of <Not In KB> to the KB as well.
		if (!gbIsGlossing && pApp->m_pActivePile && 
			!pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry &&
			pApp->m_pActivePile->GetSrcPhrase()->m_bNotInKB && 
			!pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
		{
            // in case the user edited out the <Not In KB> entry from the KB editor, we
            // need to put it back so that the setting is preserved (the "right" way to
            // change the setting is to use the toolbar checkbox)
			
            // if the user edited out the <Not In KB> entry from the KB editor, we need to
            // put it back so that the setting is preserved (the "right" way to change the
            // setting is to use the toolbar checkbox - this applies when adapting, not
            // glossing)
			pApp->m_pTargetBox->Fix_NotInKB_WronglyEditedOut(pApp, pLayout->m_pDoc, this, 
																pApp->m_pActivePile);
		}
		else // a normal situation, such as a click on a new active location
		{
            // inhibit the save, if we are here not from a click to a new location, eg. as
            // when having exited from the Choose Translation dialog having forced it to
            // show - because when the latter happens, this would be the second time this
            // function is entered for this phrase box location, and so we don't need to do
            // a save. Selector values are used to support these inhibitions on doing the
            // code below.
            // BEW changed 27Jun05, for free translation support - added test for selector
            // == 3 selector values 0 and 3 are the only ones which permit saving the old
            // location's text to the KB
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),3,pApp->m_nActiveSequNum);
//#endif
			if (selector == 0 || selector == 3)
			{
                // mark invalid the strip preceding the active strip, so as to allow
                // migration upwards of a small pile at start of active strip if the active
                // location moves further away and so the old active location's pile
                // becomes less wide and able to fit at the end of the previous strip - the
                // only way to get it there is to make that strip m_bValid = FALSE (if
                // there was no active location and we created one at the destination
                // click's pile in the code above, doing this creates no problem)
				if (pApp->m_nActiveSequNum != -1)
				{
					CPile* pile = GetPile(pApp->m_nActiveSequNum);
					wxASSERT(pile != NULL);
					int stripIndex = pile->GetStripIndex();
					if (stripIndex > 0)
					{
						stripIndex--;
						pLayout->GetInvalidStripArray()->Add(stripIndex);
					}
				}
				// user has not typed anything at the new location yet
				pApp->m_bUserTypedSomething = FALSE;

				// make sure pApp->m_targetPhrase doesn't have any final spaces
				RemoveFinalSpaces(pApp->m_pTargetBox, &pApp->m_targetPhrase);

				// any existing phraseBox text must be saved to the KB, unless its empty
				bool bOK = TRUE;
				if (!pApp->m_targetPhrase.IsEmpty())
				{
					if (pApp->m_pTargetBox->IsModified()) // MFC GetModify()
					{
						if (pApp->m_pTargetBox->m_bAbandonable)
						{
                            // if abandonable, then we want a placement click to throw away
                            // the text in the box; which will make the store operation do
                            // no store
							pApp->m_targetPhrase.Empty();
							pApp->m_pTargetBox->ChangeValue(_T("")); // this doesn't generate 
							// a wxEVT_COMMAND_TEXT_UPDATED event, we don't need
							// an OnChar() call for the location we are leaving
						}
						else
						{
                            // its not empty, not abandonable (text), and has been
                            // modified, so do nothing - the storage operation below will
                            // then store the text
							; // formerly, relic code to display the empty adapt dialog was here
						}
					}

					// it has to be saved to the relevant KB now
					if (!pApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
					{
						bOK = DoStore_ForPlacePhraseBox(pApp, pApp->m_targetPhrase);
					}
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),4,pApp->m_nActiveSequNum);
//#endif
				} // end block for test !pApp->m_targetPhrase.IsEmpty() == TRUE
				else
				{
					// pApp->m_targetPhrase is empty, so let StoreText handle 
					// what needs to happen.
					bOK = DoStore_ForPlacePhraseBox(pApp, pApp->m_targetPhrase);
					
					// check for a failure, abandon the function if the store failed
					if (!bOK)
					{
						// we must restore the box's selection to what it was 
						// earlier before returning
						pApp->m_pTargetBox->SetFocus();
						pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar);
						gSaveTargetPhrase = pApp->m_targetPhrase;
						::wxBell(); // ring the bell to say that something wasn't right
						pLayout->m_docEditOperationType = relocate_box_op;
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),5,pApp->m_nActiveSequNum);
//#endif
						return;
					}
				} // end else block for test:  !pApp->m_targetPhrase.IsEmpty() 
				  // i.e. block for empty m_targetPhrase
			} // end block for selector equals 0 or 3
		} // end normal block where saving of the text in the KB, for the
		  // old active loc'n, would be done
	}

	// before we deal with the clicked location, we want to recalculate the width of the
	// pile at the old active location, but suppress the fact that it is still the active
	// location when we do that calculation, and get the index of the changed strip put in
    // CLayout:m_invalidStripArray and mark the strip invalid as well (by setting m_bValid
    // to FALSE)
	if (pOldActiveSrcPhrase != NULL)
	{
		// bNoActiveLocationCalculation is TRUE to suppress the wide gap calculation
		pDoc->ResetPartnerPileWidth(pOldActiveSrcPhrase,TRUE);
	}
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),6,pApp->m_nActiveSequNum);
//#endif

	// honour the click
	CPile* pActivePile = pClickedPile;	// the clicked pile now has to become the 
										// new active location
	wxASSERT(pActivePile);

	// remove any existing selection
	RemoveSelection();
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),7,pApp->m_nActiveSequNum);
//#endif

    // setup the layout and phrase box at the new location; in the refactored design this
    // boils down to working out what the new active location's sequence number is, and
    // then setting the active pile to be the correct one, getting an appropriate gap
    // calculated for the "hole" the box is to occupy, tweaking the layout to conform to
    // these changes (either by a RecalcLayout() call, or AdjustForUserEdits() call -
    // either of which will make a new pile pointer, appropriately sized, for that
    // location), updating the m_pActivePile pointer on the app class, and then calling the
    // view class's Invalidate() function to get the tweaked layout drawn and the box made
    // visible, appropriately sized, at the new active location
	pApp->m_pActivePile = pActivePile;
	CSourcePhrase* pSrcPhrase = pActivePile->GetSrcPhrase();
	wxASSERT(pSrcPhrase);
	pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
	wxASSERT(pApp->m_nActiveSequNum >= 0);

	//  uncomment out, for a handy way to check the TextType values at various 
	//  locations in the doc
	//	wxString sss;
	//	sss = sss.Format(_T("TextType value: %d\n"),pSrcPhrase->m_curTextType);
	//	wxMessageBox(sss);

	wxString str; // to hold whatever text we find at the new location
	str.Empty();

	// the following three booleans are local flags which we set in code further below,
	// they will help in making decisions about which algorithm to follow in setting up
	// the new location correctly
	bool bHasNothing = FALSE;
	bool bNoValidText = FALSE;
	bool bSomethingIsCopied = FALSE;

    // if we have just chosen an empty adaptation or gloss string in the Choose Translation
    // dialog, then ensure that's what appears in the box; gbEmptyAdaptationChosen will be
    // TRUE if that is how we got here with an empty str
	if (gbEmptyAdaptationChosen)
	{
		// str is already empty, so nothing much to do
		gbEmptyAdaptationChosen = FALSE;
		
        // this next call relies for it's success on pActivePile being the CPile* at the
        // new active location, and that the partner CSourcePhrase instance has its
        // m_nSequNumber value set to the same value as the app's member m_nActiveSequNum -
        // these conditions are guaranteed by code above in this function
		pActivePile->SetPhraseBoxGapWidth(); // also sets CLayout::m_curBoxWidth to same 
                                // value that it sets in the active pile's m_nWidth member
		goto a;
	}
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),8,pApp->m_nActiveSequNum);
//#endif

    // if we are attempting to place the box on a location where the entry is "<Not In
    // KB>", then we do so but adjust the flags to fit this situation; if not locating at a
    // "<Not In KB>" location, we must ensure that m_bSaveToKB is restored to TRUE from
    // version 1.4.0 onwards - but only provided we are not glossing. If there is existing
    // adaptation text at the new location, we leave it there (as per Susanna Imrie's
    // suggestion) even when it's a "not in kb" translation
    // BEW added to test 23Jul05 since m_bNotInKB is also true for retranslations and when
    // in free translation mode if we don't exclude retranslations then <Prev, Next> or
    // Advance buttons, if they land the box in a retranslation, the phrase box text that
    // get's set up is the old location's adaptation, not to mention a spurious save of
    // <Not In KB> to the KB as well.
	if (!gbIsGlossing && ((!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB) ||
							IsItNotInKB(pSrcPhrase)) && !pSrcPhrase->m_bRetranslation)
	{
        // this ensures user has to explicitly type into the box and explicitly check the
        // checkbox if he wants to override the "not in kb" earlier setting at this
        // location
		pApp->m_bSaveToKB = FALSE;

        // this ensures the flags are appropriately set, so that an asterisk will show when
        // the placement is complete, if we arrived here due to IsItNotInKB() returning
        // TRUE & the other test FALSE
		pSrcPhrase->m_bHasKBEntry = FALSE;
		pSrcPhrase->m_bNotInKB = TRUE;
		str = pSrcPhrase->m_adaption;

		// this next call relies for it's success on pActivePile being the CPile* at the
		// new active location, and that the partner CSourcePhrase instance has its
		// m_nSequNumber value set to the same value as the app's member m_nActiveSequNum
		// - these conditions are guaranteed by code above in this function (360 lines up)
		pActivePile->SetPhraseBoxGapWidth(); // also sets CLayout::m_curBoxWidth to same
							// value that it sets in the active pile's m_nWidth member
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),9,pApp->m_nActiveSequNum);
//#endif
		goto a;
	}
	else
	{
        // when glossing, permit the save to be done to the glossing KB; but don't change
        // the source phrase's m_bNotInKB value since that only applies when adapting
		pApp->m_bSaveToKB = TRUE;
	}

	// BEW added to test, 27Jun05, for free translation support (added selector == 3 test)
	if ((selector == 1 || selector == 3) && !translation.IsEmpty())
	{
		// bypass the removal from KB, since if translation is non-empty, it will have
		// been done within code higher up in the current call tree (that's what
		// selector == 1 possibly means in this context)
		// The selector == 3 case is when the last PlacePhraseBox() call was just to the
		// start of the bundle's sourcephrase as a temporary placement to force bundle
		// adjustment so a second call can be made after the iterating backwards finishes
		// -- but later changes mean we need selector == 3 case anyway, even though we no
		// longer have bundles
		str = translation;

		// this next call relies for it's success on pActivePile being the CPile* at the
		// new active location, and that the partner CSourcePhrase instance has its
		// m_nSequNumber value set to the same value as the app's member m_nActiveSequNum
		// - these conditions are guaranteed by code above in this function (360 lines up)
		pActivePile->SetPhraseBoxGapWidth(); // also sets CLayout::m_curBoxWidth to same 
							// value that it sets in the active pile's m_nWidth member
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),10,pApp->m_nActiveSequNum);
//#endif
		goto a;
	}

	// this block added in support of adaption KB versus glossing KB, to get booleans
	// to control branching in the code lower down
	if (gbIsGlossing)
	{
		if (!pSrcPhrase->m_bHasGlossingKBEntry && !pApp->m_bCopySource)
			bHasNothing = TRUE;
		if (!pSrcPhrase->m_bHasGlossingKBEntry)
			bNoValidText = TRUE;
		if ((!pSrcPhrase->m_bNullSourcePhrase && pApp->m_bCopySource) && 
			!pSrcPhrase->m_bHasGlossingKBEntry)
			bSomethingIsCopied = TRUE;
	}
	else // adapting
	{
		if (!pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB && !pApp->m_bCopySource)
			bHasNothing = TRUE;
		if (!pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB)
			bNoValidText = TRUE;
		if ((!pSrcPhrase->m_bNullSourcePhrase && pApp->m_bCopySource) && 
			!pSrcPhrase->m_bHasKBEntry)
			bSomethingIsCopied = TRUE;
	}

	// get the auto capitalization parameters for the sourcephrase's key
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pSrcPhrase->m_key);
	}

    // the next call factors out various blocks of code which all have one objective, to
    // find suitable text (adaptation in adapting mode, gloss in glossing mode) to put in
    // the passed in str parameter, which will then on return be used for the phrase box
    // contents which are to be shown in the box when it becomes visible at the new
    // location
	DoGetSuitableText_ForPlacePhraseBox(pApp, pSrcPhrase, selector, pActivePile, str, 
										bHasNothing, bNoValidText, bSomethingIsCopied);
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),11,pApp->m_nActiveSequNum);
//#endif

a:	pApp->m_targetPhrase = str; // it will lack punctuation, because of BEW change on 
				// 28April05 to the code now in the DoGetSuitableText_ForPlacePhraseBox()
	pApp->m_nStartChar = -1;
	pApp->m_nEndChar = -1; // make sure the text is shown selected
	if (gbAutoCaps)
	{
		if (gbSourceIsUpperCase && !gbMatchedKB_UCentry)
		{
			bNoError = SetCaseParameters(pApp->m_targetPhrase, FALSE);
			if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
			{
				// change to upper case initial letter
				pApp->m_targetPhrase.SetChar(0,gcharNonSrcUC);
			}
		}
	}
	gSaveTargetPhrase = pApp->m_targetPhrase;

	// mark invalid the strip following the new active strip, so as to allow
	// migration upwards of pile in a strip which sometimes may not be full; but do this
	// only if there is less than 3/4 of the strip's width occupied by piles currently
	if (pApp->m_nActiveSequNum != -1)
	{
		CPile* pile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pile != NULL);
		int stripIndex = pile->GetStripIndex();
		if (stripIndex < (int)pLayout->GetStripArray()->GetCount() - 1)
		{
			stripIndex++;
			CStrip* pStrip = pLayout->GetStripByIndex(stripIndex);
			int stripWidth = pStrip->Width();
			int free = pStrip->GetFree();
			if (free > stripWidth / 4)
			{
				pLayout->GetInvalidStripArray()->Add(stripIndex);
			}
		}
	}

    // recalculate the layout; before the actual strips are rebuilt, doc class member
    // ResetPartnerPileWidth(), with bool param, bNoActiveLocationCalculation, default
    // FALSE is called, to get a fresh active pile pointer in m_pileList, and a new gap
    // calculated for the phrase box's new width, before Draw() has it made visible when
    // the view's Invalidate() call is made below (Note: later, we can replace this
    // RecalcLayout() call with a call to the faster AdjustForUserEdits(), which also
    // likewise calls ResetPartnerPileWidth() - for the same reason as given above)
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),12,pApp->m_nActiveSequNum);
//#endif
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif

    // update the active pile pointer to point at the refreshed pile pointer which the
    // RecalcLayout() call created
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile);
	pLayout->m_docEditOperationType = relocate_box_op;

	CSourcePhrase* pSPhr = pApp->m_pActivePile->GetSrcPhrase();
	if (pSPhr != NULL)
	{
		pDoc->ResetPartnerPileWidth(pSPhr); 										
	}
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),13,pApp->m_nActiveSequNum);
//#endif

    // we had to delay the call of DoCancelAndSelect() until now because earlier
    // RecalcLayout() calls will clobber any selection we try to make beforehand, so do the
    // selecting now; do it also before recalculating the phrase box, since if anything
    // moves, we want the phrase box location to be correct
    // *** TODO *** test new design to see if this block is still needed and works right
	if (gbUserWantsSelection)
	{
		pApp->m_pTargetBox->DoCancelAndSelect(this, pApp->m_pActivePile);
		gbUserWantsSelection = FALSE; // must be turned off before we do anything else!
		pApp->m_bSelectByArrowKey = TRUE; // so it is ready for extending
	}	
	gbCompletedMergeAndMove = FALSE;
//#ifdef __WXDEBUG__
//	wxLogDebug(_T("PlacePhraseBox at %d ,  Active Sequ Num  %d"),14,pApp->m_nActiveSequNum);
//#endif
	Invalidate();
	pLayout->PlaceBox();
}

// OnPrepareDC() was moved to CAdapt_ItCanvas in the wx version

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   -> unused
/// \remarks
/// Called from: The File -> Print menu selection. Note: This handler is not called when
/// the "Print" button in the print preview dialog is pressed. This handler creates a
/// printer object from the wxPrinter class, associates it with our wxPrintDialogData
/// object (pPrintData), sets the print dialog title and invokes the print dialog by
/// calling printer.Print().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnPrint(wxCommandEvent& WXUNUSED(event)) 
{
	// whm note: The code below is adapted from wxWidgets printing sample
	// See file:.\AIPrintout.cpp#print_flow for the order of calling of OnPrint().

	gbIsBeingPreviewed = FALSE; // from MFC's OnPreparePrinting

	CAdapt_ItApp* pApp = &wxGetApp();
   
	wxPrintDialogData printDialogData(*pApp->pPrintData);

	gbIsPrinting = TRUE; // new printing support code needs it set before poDlg InitDialog() is called
	pApp->m_nSaveActiveSequNum = pApp->m_nActiveSequNum; // needed! So Cancel from PrintOptionsDlg
														 // can restore document correctly


    // In the wx version we implement a chapter and verse selection dialog to supplement the print
    // dialog, since it is not likely we will be able to use custom print dialogs for all platforms. 
    // The print options dialog items are:
    // 1. Radio buttons for: "All", "Selection", "Pages", and "Chapter/Verse Range.
    // 2. "from:" and "to:" edit boxes associated with the "Pages" radio button.
	// 3. "from: chapter" and "verse" edit boxes; and "to: chapter" and "verse" edit boxes for range 
	//    number(s) entry associated with the "Chapter/Verse Range" radio button.
    // 4. A check box "[ ] Suppress a preceding section heading". 
    // 5. A check box "[ ] Include a following section heading". 
    // 6. A check box "[ ] Suppress printing of the footer".
	CPrintOptionsDlg poDlg(pApp->GetMainFrame()); //,&printout);
	poDlg.Centre();
	// The CPrintOptionsDlg does all of its own initialization
	if (poDlg.ShowModal() == wxID_OK)
	{
		// Update printDialogData to reflect:
        // 1. Whether the user entered a "from" and a "to" page range so that this carries
        // over to the print dialog below.
		// 2. Whether the user clicked on the "Selection" radio button (if enabled)
		
		// get user settings for Pages 
		if (poDlg.pRadioPages->GetValue() == TRUE)
		{
			wxString strFrom,strTo;
			int nFrom,nTo;
			strFrom = poDlg.pEditPagesFrom->GetValue();
			nFrom = wxAtoi(strFrom);
			strTo = poDlg.pEditPagesTo->GetValue();
			nTo = wxAtoi(strTo);
			printDialogData.SetFromPage(nFrom);
			printDialogData.SetToPage(nTo);
		}
		else if (poDlg.pRadioSelection->GetValue() == TRUE)
		{
			printDialogData.SetSelection(TRUE);
		}
	}
	else
	{
        // User cancelled the print options, so we assume we should also cancel the print
        // dialog which happens if we simply return here. The MFC version did a lot of work
        // to get the document back into its original state, but the wx version doesn't
        // change the doc's state at this early stage.
		//BEW added 20July(), because we no longer do "simulated" recalc of the layout
		//etc, but a real one and real pagination in order to prepare parameters for the
		//PrintOptionsDlg, and so we need to undo all that to get the original document
		//state back.
		pApp->m_nAIPrintout_Destructor_ReentrancyCount = 1;
		pApp->DoPrintCleanup();
		pApp->m_nAIPrintout_Destructor_ReentrancyCount = 0;
		gbIsPrinting = FALSE;
		return;
	}
	
	wxPrinter printer(& printDialogData);
	
	wxString printTitle;
	printTitle = printTitle.Format(_T("Printing %s"),pApp->m_curOutputFilename.c_str());
	AIPrintout printout(printTitle); // this calls Freeze() on the canvas
	// #printer_Print
    if (!printer.Print(pApp->GetMainFrame(), &printout, true)) // true means 'prompt'
    {
		// whm: Other error messages are issued, so we don't need yet another one here
		;
    }
    else
    {
        (*pApp->pPrintData) = printer.GetPrintDialogData().GetPrintData();
    }
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event   -> unused
/// \remarks
/// Called from: The File -> Print Preview menu selection. This handler creates a preview
// object from the / wxPrintPreview class, creates a frame object from the wxPreviewFrame
// class, positions, sizes and / initializes the frame, and finally shows the print preview
// frame in modal fashion.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnPrintPreview(wxCommandEvent& WXUNUSED(event))
{
	// whm note: The code below is adapted from wxWidgets printing sample
	// See file:.\AIPrintout.cpp#print_flow for the order of calling of OnPrint().
    // Pass two printout objects: for preview, and possible printing.
	CAdapt_ItApp* pApp = &wxGetApp();
    wxString previewTitle,printTitle;
	previewTitle = previewTitle.Format(_T("Print Preview of %s"),
										pApp->m_curOutputFilename.c_str());
	printTitle = printTitle.Format(_T("Printing %s"),pApp->m_curOutputFilename.c_str());
    wxPrintDialogData printDialogData(*pApp->pPrintData);
    wxPrintPreview *preview = new wxPrintPreview(new AIPrintout(previewTitle), 
									new AIPrintout(printTitle), & printDialogData);
    if (!preview->Ok())
    {
        delete preview;
        wxMessageBox(_T(
"There was a problem previewing.\nPerhaps your current printer is not set correctly?"),
		_T("Previewing"), wxOK);
        return;
    }

	gbIsBeingPreviewed = TRUE; // from MFC's OnPreparePrinting()

    // Note: If we ever want to use it, an AIPreviewFrame object can be created using the
    // currently commented out class AIPreviewFrame, which is derived from wxPreviewFrame
    // (see AIPrintout.h). It could be used so we can get access to wxPreviewFrame's
    // OnCloseWindow method.
    //wxPreviewFrame *frame = new AIPreviewFrame(preview, pApp->GetMainFrame(),
    //                _T("Adapt It Print Preview"), wxPoint(100, 100), wxSize(600, 650));
    
    // Since we freeze the canvas against screen updates, we may as well size the preview
    // frame to fully cover the canvas in the main window.
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxSize frameClientSize = pFrame->GetClientSize();
	// The controlbar is always visible on the main frame
	wxSize controlbarSize = pFrame->m_pControlBar->GetSize();
	wxPoint framePosition = pFrame->GetPosition();
	wxPoint canvasPosition = pFrame->canvas->GetPosition();
	wxPoint previewPosition = framePosition + canvasPosition;
	previewPosition.x += wxSystemSettings::GetMetric(wxSYS_FRAMESIZE_X); // move to the 
														// right by thickness of frame
	previewPosition.y += controlbarSize.y; // move the preview down just below the toolbar
    wxPreviewFrame *frame = new wxPreviewFrame(preview, pApp->GetMainFrame(), 
								previewTitle, previewPosition, frameClientSize);
    // We positioned the preview frame explicitly, so don't call Centre() here
    frame->Initialize();
    frame->Show();
	// whm note: The preview window is closed automatically 
	// when the user exits/closes the preview window.
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if the document is empty, otherwise TRUE
/// \param      nTotalStripCount        -> total number of strips
/// \param      nPagePrintingLength     -> the length of a printed page between top and 
//                                          bottom margins expressed in logical units
/// \remarks
/// Called from: AIPrintout::OnPreparePrinting(), and the View's SetupRangePrintOp().
/// Determines the number of strips that will fit on a page (using the current width
/// between left and right margins), and stores the offsets and strip counts for each page
/// in a list of pOffsets it stores in the App's list of PageOffsets.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::PaginateDoc(const int nTotalStripCount, const int nPagePrintingLength)
{
	//wxLogDebug(_T("PaginateDoc() START"));	
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();

    // whm Observations: PaginateDoc() basically uses the existing indices for the App's
    // strip count as the max number of strips to be paginated into pages, and determines
    // how many pages it will take to print the document. whm Notes: The MFC version
    // paginates the document and lays it out for print preview and printing to fit the
    // page, regardless of the size of the main window of the application. The MFC version
    // also assumes negative offsets. The wx version also paginates the document and lays
    // it out for print preview and printing to fit the printed page, but it keeps the map
    // mode as wxMM_TEXT, scales the output to fit the print/print preview display context,
    // and uses positive offsets instead of negative offsets.
	// 
	POList* pList = &pApp->m_pagesList;
	ClearPagesList(); // start with an empty list
	PageOffsets* pOffsets = NULL;
	// Note: RecalcLayout was previously called with the appropriate dc width
	int nMaxStrips = nTotalStripCount; 
	if(nMaxStrips <= 0)
	{
		wxMessageBox(_T("Error: Cannot paginate an empty document."),_T(""), 
			wxICON_EXCLAMATION);
		return FALSE;
	}
	int pageCount = 0;
	// strip "height" here includes the vertical space preceding it for navText display
	int nStripHeightWithLeading = pLayout->GetCurLeading() + pLayout->GetStripHeight();
    // The nPagePrintingLength passed in represents the height of the printed page between
    // the top and bottom margins (in logical units).
	int nMaxHeightPerPage = nPagePrintingLength; // the page height between top and 
												 // bottom margins in logical units    

	int nAccumStripHeightThisPage = 0;
	int nStripCountRunningTotal = 0;
	int nFirstStripOnPage = 0;
    // loop to process pages until we've processed all the strips that need processing
	// BEW 11Jul09, added boolean because if a PageOffset was just closed off when one
	// strip remains to be processed, the loop exits with nAccumStripHeightThisPage reset
	// to 0, and then the block following the loop is not entered, so extra help is needed
	// in that block's test to ensure it gets entered in this circumstance
	bool bJustClosedOff = FALSE;
	while (nStripCountRunningTotal < nMaxStrips)
	{
		if (nAccumStripHeightThisPage + nStripHeightWithLeading > nMaxHeightPerPage)
		{
			// can't fit the next strip on this page so create a PageOffset page and save
            // its starting and ending strip offsets
			pOffsets = new PageOffsets;

			pOffsets->nTop = ((CStrip*)
				(*pLayout->GetStripArray())[nFirstStripOnPage])->Top();
			pOffsets->nBottom = ((CStrip*)
				(*pLayout->GetStripArray())[nStripCountRunningTotal - 1])->Top() 
				+ ((CStrip*)(*pLayout->GetStripArray())[nStripCountRunningTotal - 1])->Height();

			pOffsets->nFirstStrip = nFirstStripOnPage;
			pOffsets->nLastStrip = nStripCountRunningTotal - 1; // store index
			pageCount++;
			pList->Append(pOffsets); // store the page information

			// prepare for the next iteration of the loop
			nFirstStripOnPage = nStripCountRunningTotal; // index for first strip 
														 // of next PageOffsets instance
			nAccumStripHeightThisPage = 0;
			bJustClosedOff = TRUE;
		}
		else
		{
            // The next strip fits on this page so continue adding strips. 
			nAccumStripHeightThisPage += nStripHeightWithLeading;
			bJustClosedOff = FALSE;
 			nStripCountRunningTotal++;

			//CStrip* pStrip = (CStrip*)(*pLayout->GetStripArray())[nStripCountRunningTotal - 1];
			//wxLogDebug(_T("CORRECT: Strip[ %d ]     Pile count:  %d"), pStrip->GetStripIndex(), pStrip->GetPilesArray()->GetCount());
		}
	}

	// BEW added to this test on 11July09, for the reason see comments above the loop above
	if (nAccumStripHeightThisPage > 0 || (bJustClosedOff && 
		((CStrip*)pLayout->GetStripArray()->Last())->GetStripIndex() == nFirstStripOnPage))
	{
		// there is material for one final (partial) page
		pOffsets = new PageOffsets;

		pOffsets->nTop = ((CStrip*)
			(*pLayout->GetStripArray())[nFirstStripOnPage])->Top();
		pOffsets->nBottom = ((CStrip*)
			(*pLayout->GetStripArray())[nStripCountRunningTotal - 1])->Top() 	
			+ ((CStrip*)(*pLayout->GetStripArray())[nStripCountRunningTotal - 1])->Height();

		pOffsets->nFirstStrip = nFirstStripOnPage;
		pOffsets->nLastStrip = nStripCountRunningTotal - 1;
		pageCount++;
		pList->Append(pOffsets); // store the page information
	}
	wxASSERT(pageCount == (int)pList->GetCount());
	//wxLogDebug(_T("PaginateDoc() END"));	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \remarks
/// Called from: The View's PaginateDoc() and AIPrintout's OnPreparePrinting() and its
/// destructor. ClearPagesList() is a helper function which simply deletes the list of page
/// offset structs from the POList called m_pagesList on the App.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::ClearPagesList()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	POList* pList = &pApp->m_pagesList;
	if (pList->GetCount() == 0)
	{
		return;
	}
	else
	{
		POList::Node* pos = pList->GetFirst();
		while(pos != NULL)
		{
			// whm note: PageParams and PageOffsets are similar structs
			// (PageParams has an extra member at the end of the struct called nPageNumber.
			// MFC version of code below casts the pList pointers to (PageParams*) but
			// the pList was originally filled with (PageOffsets*) pointers.
			// In MFC it doesn't complain, but in a wxList the pointers it
			// contains are strongly typed, so I'm casting them instead to
			// (PageOffsets*) which is really what was stored in this POList by the
			// PaginateDoc() function above.
			PageOffsets* pOffsets = (PageOffsets*)pos->GetData();
			pos = pos->GetNext();
			if (pOffsets != NULL)
			{
				delete pOffsets;
			}
		}
		pList->Clear();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE in the wx version (FALSE in the MFC version only if a memory 
//               error occurrs)
/// \param      pSaveList       <- a SPList to store all items originally in pOriginalList
/// \param      pOriginalList   <- list of Source phrase items of which only a sublist remain
///                                 at the end of the GetSubList operation
/// \param      nBeginSequNum   -> the first list item composing the intended sub list
/// \param      nEndSequNum     -> the last item composing the intended sub list
/// \remarks
/// Called from: the View's SetupRangePrintOp() function and
/// AIPrintout::OnPreparePrinting(). GetSublist() first removes any existing list items
/// from pSaveList, then it copies all list items from pOriginalList into pSaveList; then
/// removes all items from pOriginalList; and adds back to pOriginalList only those source
/// phrases from pSaveList that are within the range nBeginSequNum to nEndSequNum. Finally
/// GetSublist() updates the indices related to printing of sublists.
/// 
/// Refactored BEW 16Jul09 to support the refactored view where CPile instances are owned
/// not by their strips which contain them, but by an m_pileList member in CLayout.
/// Accesses to partner piles will not work right when dealing with a shallow copy sublist
/// of CSourcePhrase instances unless the subrange of partner piles is moved also to a
/// sublist and the partner CSourcePhrase instances are renumbered in the sublist using
/// UpdateSequNumbers() -- which itself has been modified to accept the sublist pointer as
/// a second parameter.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetSublist(SPList* pSaveList, SPList* pOriginalList, int nBeginSequNum,
							   int nEndSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();
	bool bOK = TRUE;
	wxASSERT(pOriginalList->GetCount() > 0); // ensure the list is not empty
	wxASSERT(nBeginSequNum >= 0 && nEndSequNum >= nBeginSequNum); // ensure valid start and end values
	wxASSERT(nEndSequNum < (int)pOriginalList->GetCount()); // make sure both sequence numbers are in range
	if (pSaveList->GetCount() > 0)
	{
		pSaveList->Clear();
	}

	// prepare a parallel save list for the original piles in CLayout (it's
	// m_pSavePileList member), and get a copy of m_pSavePileList for use here
	PileList* pSavePileList = pLayout->GetSavePileList();
	wxASSERT(pSavePileList);
	PileList* pOriginalPileList = pLayout->GetPileList(); // this is where all
						// the CPile instances in CLayout currently are stored

	// copy the original list to the saveList
	// wxList doesn't support appending one list onto another so do it manually.
	SPList::Node* node = NULL;
	for (node = pOriginalList->GetFirst(); node; node = node->GetNext())
	{
		CSourcePhrase *pData = node->GetData();
		pSaveList->Append(pData); // copy the pointers across
		// above two lines could be shortened to the single line: pSaveList->Append(node->GetData());
	}
	pOriginalList->Clear();
	// do the same for the list of piles
	PileList::Node* pileNode = NULL;
	for (pileNode = pOriginalPileList->GetFirst(); pileNode; pileNode = pileNode->GetNext())
	{
		CPile *pData = pileNode->GetData();
		pSavePileList->Append(pData); // copy the pointers across
	}
	pOriginalPileList->Clear(); // pSavePileList is now managing the document's inventory of piles

    // copy across to pOriginalList the pointers to the source phrases which are wanted for
    // the sublist; then do the same for the same range of partner piles, into
    // pOriginalPileList
	SPList::Node* pos = pSaveList->Item(nBeginSequNum);
	PileList::Node* pilePos = pSavePileList->Item(nBeginSequNum);
	int sn = nBeginSequNum;
	while (sn <= nEndSequNum)
	{
		CSourcePhrase* pSrcPhrase = pos->GetData();
		CPile* pPile = pilePos->GetData();
		pos = pos->GetNext();
		pilePos = pilePos->GetNext();
		sn++;
		wxASSERT(pSrcPhrase != NULL);
		wxASSERT(pPile != NULL);
		pOriginalList->Append(pSrcPhrase);
		pOriginalPileList->Append(pPile);
	}

	// inhibit printing the phrase box when printing a sublist, and store the active
	// sequence number for later one when RestoreOriginalList() is called in order to set
	// up the m_pSourcePhrases and m_pileList lists again, after range printing or
	// seletion printing is finished (the destructor ~AIPrintout()does this call)
	pApp->m_nSaveActiveSequNum = pApp->m_nActiveSequNum;
	pApp->m_nActiveSequNum = -1;

    // to make our refactored view code work correctly, the sequence numbers in the
    // CSourcePhrase instances now in m_pSourcePhrases have to be renumbered from zero, to
    // maintain the partnering of each CSourcePhrase with the CPile which points to it (the
    // second parameter for UpdateSequNumbers() is strictly speaking not needed, because
    // the only time we use it it points to m_pSourcePhrases anyway, but it's probably a
    // good idea to retain it to make the code a bit better at self-documenting what is
    // happening)
	pApp->GetDocument()->UpdateSequNumbers(0,pOriginalList);

	// inform RecalcLayout() that it won't need to work out a gap for the phrase box
	pLayout->SetBoxInvisibleWhenLayoutIsDrawn(TRUE);

	return bOK;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     always TRUE
/// \param      pSaveList      -> the (full) list of source phrase items to be moved to
///                                pOriginalList
/// \param      pOriginalList  <- the existing sublist which is to be abandoned and 
///                                replaced by the contents of pSaveList
/// \remarks
/// Called from: the AIPrintout's destructor. RestoreOriginalList() is called to restore
/// the original contents of the document's m_pSourcePhrases, after printing the document.
/// During the print operation, the original list from m_pSourcePhrases was stored/saved in
/// pSaveList. RestoreOriginalList() also restores the original active sequence number value
/// 
/// BEW changed 16Jul09, to support the refactored view code's design. CPile instances are
/// owned by CLayout, not by CStrip, and so for a range print or a selection print, we
/// needed to have separately stored in CLayout::m_pSavePileList the original list of
/// piles, so that CLayout::m_pileList can store just shallow copies of the range of
/// partner piles we need to deal with. After renumbering the m_nSequNumber member of the
/// subsete of CSourcePhrase instances, RecalcLayout() will work correctly with what
/// appears to it to be a suddenly shorter, but valid, document. Then RestoreOriginalList
/// has to restore the original document state, putting back both the full set of
/// CSourcePhrase instances, and their partner piles. A call to UpdateSequNumbers() to
/// renumber them from the first CSourcePhrase instance is mandatory, because the shallow
/// copies will have had their m_nSequNumber values reset so that the first in the
/// subrange is 0, and that means a subrange of the original ones will have their sequence
/// number values reset to wrong values. So call UpdateSequNumbers(0) to get everything
/// back as it should be.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RestoreOriginalList(SPList* pSaveList,SPList* pOriginalList)
// when called, pSaveList has the original (full) list, and pOriginalList has the sublist
// which we wish to abandon in the process of restoring the normal state
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();
	// get the CLayout::m_pSavePileList pointer which holds the original set of piles
	PileList* pOriginalPileList = pLayout->GetPileList();
	PileList* pSavePileList = pLayout->GetSavePileList();

	// BEW changed 21Jul09: it can happen that this function is entered before the culling
	// of a range print's CSourcePhrases to just those needed for printing the range (and
	// the originals saved in m_pSaveList). One scenario I found for this was to do a
	// normal print, specify a range, and turn on and then off a checkbox such as the one
	// for suppressing a preceding header, then click Print to have the print go ahead,
	// but then when the physical print's Print Settings dialog shows, Cancel at that
	// point. The wxWidgets framework correctly calls ~AIPrintout() which is one of the
	// places where the DoPrintCleanup() function is called, and then because
	// gbPrintingRange is TRUE, RestoreOriginalList() is entered - but pOriginalPileList
	// still has the full list of the document's piles, and pSavePileList is empty. So we
	// have to test for this scenario and when we have such a situation, detect it and
	// just return TRUE immediately because there is no restoration required
	if (!pOriginalPileList->IsEmpty() && pSavePileList->IsEmpty())
		return TRUE;
	wxASSERT(pSavePileList->GetCount() > 0);
	wxASSERT(pSaveList->GetCount() > 0); // ensure the list is not empty
    // If the list is empty, which may happen if there is a range error, we don't want to
	// copy an empty pSaveList back over a populated pOriginalList, nor an empty
	// pSavePileList over a populated pOriginalPileList, so just return
	if (wxPrinter::GetLastError() == wxPRINTER_ERROR)
		return FALSE;

	// abandon the now unwanted sublist of CSourcePhrase instances (these are shallow copies)
	if (pOriginalList->GetCount() > 0)
	{
		pOriginalList->Clear();
	}
	// likewise, the shallow copied sublist of CPile instances
	if (pOriginalPileList->GetCount() > 0)
	{
		pOriginalPileList->Clear();
	}

	// copy the saved list back to the originalList; likewise for the saved pile list
	// wxList doesn't support appending one list directly onto another so do it manually.
	SPList::Node *node = NULL;
	PileList::Node *pileNode = NULL;
	for (node = pSaveList->GetFirst(); node; node = node->GetNext())
	{
		CSourcePhrase *pData = node->GetData();
		pOriginalList->Append(pData); // copy the pointers across
	}
	pSaveList->Clear();
	for (pileNode = pSavePileList->GetFirst(); pileNode; pileNode = pileNode->GetNext())
	{
		CPile *pData = pileNode->GetData();
		pOriginalPileList->Append(pData); // copy the pointers across
	}
	pLayout->ClearSavePileList();  // also destroys m_pSavePileList and sets the pointer
								   // to NULL

	// restore the former active sequ number; CSourcePhrase m_nSequNumber values are
	// already correct
	pApp->m_nActiveSequNum = pApp->m_nSaveActiveSequNum;

	// renumber, to get m_nSequNumber members into the correct sequence again (the second
	// parameter for UpdateSequNumbers() is strictly speaking not needed, because the only
	// time we use it it points to m_pSourcePhrases anyway, but it's probably a good idea
	// to retain it to make the code a bit better at self-documenting what is happening)
	pApp->GetDocument()->UpdateSequNumbers(0,pOriginalList);

	// restore assumption that a gap will need to be calculated at the active pile when
	// RecalcLayout() is next called
	pLayout->SetBoxInvisibleWhenLayoutIsDrawn(FALSE);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     the m_chapterVerse member of pSrcPhrase
/// \param pSrcPhrase -> the source phrase whose m_chapterVerse member is to be retrieved
/// \remarks
/// Called from: the App's RefreshStatusBarInfo(), the Doc's
/// ReconstituteAfterFilteringChange(), ReconstituteAfterPunctuationChange(), the View's
/// DoConsistencyCheck() and OnEditSourceText().
/// Gets and returns the m_chapterVerse member of pSrcPhrase.
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::GetChapterAndVerse(CSourcePhrase *pSrcPhrase)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxString str; str.Empty();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList);
	int nActiveSequNum = pSrcPhrase->m_nSequNumber;
	SPList::Node* pos = pList->Item(nActiveSequNum); // get the position where this srcphrase is
	wxASSERT(pos != NULL);

	// loop backwards until come to start of a verse or chapter
	str = _T("0:0"); // a nonsense value which, if it gets displayed, tells us we've fouled up
	while (pos != NULL)
	{
		CSourcePhrase* pSP = (CSourcePhrase*)pos->GetData();
		pos = pos->GetPrevious(); // needed for our list
		if (pSP->m_bChapter || pSP->m_bVerse)
		{
			if (!pSP->m_chapterVerse.IsEmpty())
				str = pSP->m_chapterVerse;
			wxASSERT(!str.IsEmpty());
			break;
		}
	}
	return str;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if a valid c:v scripture reference substring has been constructed 
///             in strChapVerse, else FALSE
/// \param      pList               -> a list of CSourcePhrase pointer instances (either 
///                                    the current document, or a list constructed from
///                                    parsing in an XML document and storing in a
///                                    temporary SPList)
/// \param      pStartingSrcPhrase  -> pointer to the CSourcePhrase instance which defines 
///                                    the current location relative to which we wish to
///                                    return the best possible (and nearest) ch:verse
///                                    substring
/// \param      strChapVerse        <- a scripture reference (minus the book code and 
///                                    following space) in the form "Chapter:Verse" for
///                                    example "13:25"; or an empty string if the function
///                                    fails
/// \remarks
/// Called from: the View's SendScriptureReferenceFocusMessage(). Gets the current verse's
/// ch:v substring, or at least tries to do the best possible job of it that it can. The
/// pSrcPhrase defines a location (ie. a given sequence number) in the passed in pList of
/// CSourcePhrase instances (if looking in an active document, pList will be
/// pDoc->m_pSourcePhrases; but if scanning through a set of adaptation documents stored on
/// disk, pList will be a temporary SPList created for holding the list returned by parsing
/// in the XML (or *.adt) document file cryptically). First the function checks pSrcPhrase
/// for a non-empty m_chapterVerse member, if it finds it it puts it into strChapVerse and
/// we are done. If not, then the active location may be within a verse - so the function
/// scans back in pList to find the nearst previous pSrcPhrase instance with a non-empty
/// m_chapterVerse - returning that if it finds one; but if pSrcPhrase is near the start of
/// the document, there might be no previous such instance, so it then scans forward from
/// the passed in pSrcPhrase's location to get the nearest following non-empty
/// m_chapterVerse, and returns that. This algorithm means that we get a valid scripture
/// reference substring even if the active location is in something such as a subheading
/// part of the adaptation document (ie. information marked by \s). But if scanning both
/// backwards and forwards yields no non-empty m_chapterVerse member, we assume the
/// document was not created from a (U)SFM marked plain text source text file, and return
/// FALSE so that the caller will block sending an invalid scripture reference focus
/// message, or responding to one by looking in the document being tested for the location
/// to scroll to.
/// Note: CSourcePhrase instances can store, in their m_chapterVerse member, a chapter
/// followed by colon followed by a verse range - something in the form "13:12-15", or even
/// "13:12,15". When a substring like this has been found. We do not return it 'as is', but
/// rather extract the chapter number, colon, and first verse of the range - the rest is
/// not used in a scripture reference focus broadcast message, so we never send it in one.
/// The work of setting a valid "ch:verse" substring is done by the
/// MakeChapVerseStrForSynchronizedScroll() function defined in MainFrame.cpp.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetChapterAndVerse(SPList* pList, CSourcePhrase* pStartingSrcPhrase, 
									   wxString& strChapVerse)
{
	CSourcePhrase* pSrcPhrase = NULL;
	wxString chvStr = _T("");
	if (!pStartingSrcPhrase->m_chapterVerse.IsEmpty())
	{
        // this CSourcePhrase instance has a ch:verse or ch:verse_range string, so produce
        // the scripture reference ch:verse substring
		chvStr = MakeChapVerseStrForSynchronizedScroll(pStartingSrcPhrase->m_chapterVerse);
		strChapVerse = chvStr;
		return TRUE;
	}
    // there was no chapter:verse information in the passed in CSourcePhrase instance, so
    // search for it in the neighbourhood - preferably in the preceding neighbourhood, but
    // if not there, then in the following neighbourhood
	SPList::Node* pos = pList->Item(pStartingSrcPhrase->m_nSequNumber);
	SPList::Node* savePos = pos;
	if (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData(); // ignore this one, it is 
													 // same as pStartingSrcPhrase
		pos = pos->GetPrevious();
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetPrevious();
			if (!pSrcPhrase->m_chapterVerse.IsEmpty())
			{
                // this CSourcePhrase instance has a ch:verse or ch:verse_range string, so
                // produce the scripture reference ch:verse substring
				chvStr = MakeChapVerseStrForSynchronizedScroll(pSrcPhrase->m_chapterVerse);
				strChapVerse = chvStr;
				return TRUE;
			}
		}
		// didn't find it in the previous neighbourhood, so try again looking ahead instead
		pos = savePos;
		pSrcPhrase = (CSourcePhrase*)pos->GetData(); // ignore this one, it is 
													 // same as pStartingSrcPhrase
		pos = pos->GetNext();
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (!pSrcPhrase->m_chapterVerse.IsEmpty())
			{
                // this CSourcePhrase instance has a ch:verse or ch:verse_range string, so
                // produce the scripture reference ch:verse substring
				chvStr = MakeChapVerseStrForSynchronizedScroll(pSrcPhrase->m_chapterVerse);
				strChapVerse = chvStr;
				return TRUE;
			}
		}
		// if control reaches here, then there was no c:v information to be had, 
		// so return FALSE
		strChapVerse = chvStr;
		return FALSE; // could not find pSrcPhrase's location in the pList list
	}
	else
	{
		strChapVerse = chvStr;
		return FALSE; // could not find pSrcPhrase's location in the pList list
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pList		->	a list of CSourcePhrase pointer instances (either the current
///                             document, or a list constructed from parsing in an XML document 
///                             and storing in a temporary SPList)
/// \param      pSrcPhrase	->	pointer to the CSourcePhrase instance which defines the current 
///                             location
/// \remarks
/// Called from: the CPhraseBox::MoveToNextPile() function.
/// This is the function which does the work of determining if a scripture reference focus
/// message needs to be sent, for the current location as defined by where pSrcPhrase
/// happens to be in the document's pList (the list could be pDoc->m_pSourcePhrases, or a
/// tempory SPList pointer used for checking a document not currently open). Internally,
/// the function checks the global CStrings: gOldChapVerseStr and gCurChapVerseStr, and if
/// these are not different then a message is not sent; but if they are, then the message
/// will be sent provided the global bool gbIgnoreScriptureReference_Send is FALSE (the
/// function call needs to be wrapped by an if (!gbIgnoreScriptureReference_Send) test --
/// because the GUI command sets or clears this boolean). Also, internally the overloaded
/// version of the GetChapterAndVerse() function, which returns TRUE if successful and
/// FALSE otherwise, is called - and if FALSE is returned then no message is sent. If the
/// current document has no (U)SFM markup, or no 3-letter book code at the start of the
/// pList entries, then the latter function will return FALSE and so no message will ever
/// be sent for a document file which is not built from a properly constituted and marked
/// up scripture text file.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::SendScriptureReferenceFocusMessage(SPList* pList, CSourcePhrase* pSrcPhrase)
{
	wxASSERT(pList != NULL);
	wxASSERT(pSrcPhrase != NULL);
	wxString strChVerse = _T("");
	bool bAllIsOK = GetChapterAndVerse(pList, pSrcPhrase, strChVerse);
	if (!bAllIsOK)
	{
		return; // don't send any message
	}
	if (gOldChapVerseStr == strChVerse)
	{
        // the currently found scripture reference substring does not differ from that in
        // the last sent message, so don't resend it
		return;
	}
    // so are all is well, next, try to get the 3-letter code for the scripture book - the
    // function for doing this returns FALSE if the code does not exist, or is invalid. The
    // code returned is upper case always (the function forces this internally)
	wxString strBookCode = _T("");
	bool bValidCode = Get3LetterCode(pList,strBookCode);
	if (!bValidCode)
	{
		// the code is either invalid or is not in the document, so we cannot send a valid
		// sync message
		return;
	}
    // we have a valid substring, and the reference is different than for the last one, so
    // send it (but this function won't be called if the global
    // gbIgnoreScriptureReference_Send is TRUE, so if control has got to here, then the
    // global is FALSE and sending is wanted by the user)
	SyncScrollSend(strBookCode, strChVerse);

	// finally, update the global wxString which remembers what the this chap:verse 
	// reference was
	gOldChapVerseStr = strChVerse;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if we have chapter:verse form, FALSE if the document has no chapters
/// \param      s               <- a wxString representing the source phrase's m_chapterVerse member
/// \param      nChapter        <- an int representing the chapter number
/// \param      nVerse          <- an int representing the verse number (or 1st verse in a range); 0 if
///                                no verses are indicated
/// \param      bHasChapters    <- a bool TRUE if chapter numbers are present FALSE otherwise
/// \param      bIsVerseRange   <- a bool TRUE if there is a range of verses indicated, FALSE otherwise
/// \param      nFinalVerse     <- an int representing the final verse in a range
/// \remarks
/// Called from: the View's SetupRangePrintOp().
/// The usual form for s's contents is n:m where n is a chapter number, and m a verse
/// number, and bIsVerseRange will be set to FALSE; - s is a reference to the source
/// phrase's m_chapterVerse member. However, the contents could be just a verse number (eg.
/// Book without chapters, such as 2John etc), or n:p-q (for a range of verses), or n:p,q
/// (an alternative style for a range) so for the standard situation we set nChapter to n,
/// nVerse to m, and return TRUE; but for a book with no chapters we return FALSE, and
/// nVerse will have the verse number, or 0 if there are no verses; for the range
/// possibilities nVerse will have p the first verse in the range, nFinalVerse will have q
/// (the end verse in the range), and bIsVerseRange will be set to TRUE.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ExtractChapterAndVerse(wxString& s,int& nChapter,int& nVerse,
							bool& bHasChapters,bool& bIsVerseRange,int& nFinalVerse)
{
	bHasChapters = FALSE;
	bIsVerseRange = FALSE;
	nFinalVerse = 0;
	nChapter = 0;
	nVerse = 0;
	wxString chStr;
	wxString vStr;
	chStr.Empty();
	vStr.Empty();
	wxChar colon = _T(':');
	bool bIsOK = TRUE;
	int nHasChapters = s.Find(colon);
	if (nHasChapters > -1)
	{
		bHasChapters = TRUE;
		chStr = s.Left(nHasChapters);
		wxASSERT(!chStr.IsEmpty());
	}
	if (bHasChapters)
	{
		nChapter = wxAtoi(chStr);
		vStr = s.Mid(nHasChapters + 1);
	}
	else
	{
		// has no chapters, so string must only be a verse number, or number range
		vStr = s;
	}
	wxASSERT(!vStr.IsEmpty());
	if (vStr.IsEmpty())
		return FALSE; // error, so ignore this chap/verse string
	wxString tempStr = vStr;

	// now determine the verse, or verse range
	wxChar hyphen = _T('-');
	wxChar comma = _T(',');
	wxString leftStr;
	wxString rightStr;
	leftStr.Empty();
	rightStr.Empty();
	int	  nHyphenOffset = -1;
	int   nCommaOffset =  vStr.Find(comma);
	if (nCommaOffset == -1)
	{
		// has no comma in the string, so test now for a hyphen
		nHyphenOffset =  vStr.Find(hyphen);
		if (nHyphenOffset == -1)
		{
			// doesn't have a hyphen in the string, so it should only be a verse number
			nVerse = wxAtoi(vStr); // reads digits only until first non-digit, so safe
			//ASSERT(nVerse > 0 && nVerse <= 176); // bible verses are between 1 and about 176
												 // as in (Psalm 119)
            //for version 2.0.5 and onward, we'll allow any value for max verse number,
            //since document may not be scripture, but nevertheless be versified for use by
            //Adapt It eg. film script
			return bIsOK;
		}
		else
		{
			// does have a hyphen, so there must be a range
			bIsVerseRange = TRUE;
			leftStr = vStr.Left(nHyphenOffset);
			wxASSERT(leftStr.Length() > 0);
			nVerse = wxAtoi(leftStr);
			rightStr = vStr.Mid(nHyphenOffset + 1);
			wxASSERT(rightStr.Length() > 0);
			nFinalVerse = wxAtoi(rightStr);
			return bIsOK;
		}
	}
	else
	{
		// has a comma, so there must be a range
		bIsVerseRange = TRUE;
		leftStr = vStr.Left(nCommaOffset);
		wxASSERT(leftStr.Length() > 0);
		nVerse = wxAtoi(leftStr);
a:		rightStr = tempStr.Mid(nCommaOffset + 1);
		wxASSERT(rightStr.Length() > 0);
		// there might be more - continue till we find the final substring in p,q,r,s etc
		nCommaOffset = rightStr.Find(comma);
		if (nCommaOffset > -1)
		{
			// we are not at the rightmost one yet, so iterate
			tempStr = tempStr.Mid(nCommaOffset + 1);
			wxASSERT(tempStr.Length() > 0);
			goto a;
		}
		nFinalVerse = wxAtoi(rightStr);
		return bIsOK;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     the source phrase's m_nSequNumber which has the start of a section heading
/// \param      nStartingSequNum    -> an int representing the starting sequence number
/// \param      startingPos         <- an SPList node representing the starting position in pList
/// \param      pList               <- the source phrase list (not referenced directly, only via 
///                                    the startingPos node)
/// \remarks
/// Called from: the View's SetupRangePrintOp().
/// Scans backwards from the starting position looking for a source phrase with a section
/// head marker indicating that it is the start of a preceding section heading.
/////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItView::IncludeAPrecedingSectionHeading(int nStartingSequNum, SPList::Node* startingPos,
												   SPList* WXUNUSED(pList))
{
	// whm revised 15Feb05 to include all markers of sectionHead textType
	CAdapt_ItApp* pApp = &wxGetApp();
	int nOldSN = nStartingSequNum;
	SPList::Node* pos = startingPos;
    // whm Note: since startingPos is a node already pointing into pList, pList doesn't
    // here need to be explicitly referenced, just call pos->GetData() to return the
    // pSrcPhrase at pos in pList.
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetPrevious();
	wxASSERT(pSrcPhrase);
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markerStr; 
	wxString nonFilteredMkrs;

	while (pos != NULL)
	{
		pSrcPhrase = pos->GetData();
		pos = pos->GetPrevious();
		wxASSERT(pSrcPhrase);

		if (!pSrcPhrase->m_chapterVerse.IsEmpty())
		{
            // we have come to the start of a preceding verse without encountering any
            // section heading
			break;
		}

        // it is not possible for a section heading to be within a merged source phrase, so
        // we do not need to check for medial markers; so just check contents of the
        // m_markers attribute
		if (!pSrcPhrase->m_markers.IsEmpty())
		{
			// whm added 14Feb05 in support of USFM and SFM Filtering
			markerStr = pSrcPhrase->m_markers;
			nonFilteredMkrs = pDoc->GetUnFilteredMarkers(markerStr);
			// NormalizeToSpaces leaves the markers in m_markers delimited by spaces, at
			// lease medially. We'll use the wxStringTokenizer method here.
			wxString sfm;
			wxStringTokenizer tkz(markerStr,_T(" "));
			
			while (tkz.HasMoreTokens())
			{
				sfm = tkz.GetNextToken();
				if (sfm[0] == gSFescapechar)	// Only check actual sfms. Some 
                    // tokens will be only numbers (those after \c and \v) which we ignore
				{
					sfm.Trim(TRUE); // trim right end
					sfm.Trim(FALSE); // trim left end
						sfm += _T(' '); // insure the sfm is followed by a space 
                                        // for unique find in our wrap strings.
					// If only one of the sfms within m_markers is a wrap 
					// marker, we should return TRUE.
					switch (pApp->gCurrentSfmSet)
					{
						case UsfmOnly: 
						{
							if (pApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
								// there is a section marker, so we have found the 
								// start of a section heading
								return pSrcPhrase->m_nSequNumber;
							break;
						}
						case PngOnly:
						{
							if (pApp->PngSectionHeadMarkersStr.Find(sfm) != -1)
								// there is a section marker, so we have found the
								// start of a section heading
								return pSrcPhrase->m_nSequNumber;
							break;
						}
						case UsfmAndPng:
						{
							if (pApp->UsfmAndPngSectionHeadMarkersStr.Find(sfm) != -1)
								// there is a section marker, so we have found the 
								// start of a section heading
								return pSrcPhrase->m_nSequNumber;
							break;
						}
						default: 
						{
							// if we got here it would be a program error
							if (pApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
								return pSrcPhrase->m_nSequNumber;
						}
					}
				}
			}
		}
	}
	// if we get here, we couldn't find a preceding section heading
	return nOldSN;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     FALSE if the range could not be determined or found, otherwise TRUE
/// \param      nFromCh     -> an int representing the chapter at the beginning of the range
/// \param      nFromV      -> an int representing the verse at the beginning of the range
/// \param      nToCh       -> an int representing the chapter at the end of the range
/// \param      nToV        -> an int representing the verse at the end of the range
/// \param      pPrintData  -> (unused)
/// \param      bSuppressPrecedingHeadingInRange  -> (unused)
/// \param      bIncludeFollowingHeadingInRange   -> (unused)
/// \remarks
/// Called from: the View's OnPrint() high level handler after the standard print dialog's
/// OK button has been pressed. Determines the sequence numbers for the indicated chapter
/// and verse range and gets the appropriate sublist of source phrases making up that
/// range. From this data it calls RecalcLayout to format the printout for the correct
/// width, and PaginateDoc().
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::SetupRangePrintOp(const int nFromCh, const int nFromV, const int nToCh, 
									  const int nToV, wxPrintData* WXUNUSED(pPrintData), 
									  bool WXUNUSED(bSuppressPrecedingHeadingInRange), 
									  bool WXUNUSED(bIncludeFollowingHeadingInRange))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();

	// whm revised 8Mar08 to correct logic of tests for range inclusion
	if (pApp->m_selectionLine != -1)
		RemoveSelection();
	SPList* pList = pApp->m_pSourcePhrases;
	SPList* pSaveList = pApp->m_pSaveList;
	wxASSERT(nFromCh >= 0);
	wxASSERT(nToCh >= 0);
	wxASSERT(nFromV >= 1);
	wxASSERT(nToV >= 1);
	wxASSERT(nToCh >= nFromCh);

	// check we have a legal range
	if (nFromCh < 0 || nToCh < 0 || nToCh < nFromCh || nToV < 1 || nFromV < 1)
	{
		// IDS_ILLEGAL_RANGE
		wxMessageBox(_("Sorry, the range you specified is illegal. Try again."),
		_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	else if (nFromCh == nToCh && nToV < nFromV)
	{
		// IDS_ILLEGAL_RANGE
		wxMessageBox(_("Sorry, the range you specified is illegal. Try again."),
		_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

	int nCh = 0;
	int nV = 0;
	bool bIsVRange = FALSE;
	bool bHasChapters = FALSE;
	int nFinalV = 0;
	SPList::Node* posEnd = NULL;
	SPList::Node* savePos = NULL;

	// find the beginning and ending sequence numbers for the range
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)NULL;
	SPList::Node* pos = pList->GetFirst();
	while (pos != NULL)
	{
		savePos = pos;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		wxString chv = pSrcPhrase->m_chapterVerse;
		if (chv.IsEmpty())
			continue;
		else
		{
			// we are at the start of a verse - see if it is where we want to start
			bool bOK = ExtractChapterAndVerse(chv,nCh,nV,bHasChapters,bIsVRange,nFinalV);

            // if something went wrong, just ignore the chapter and verse - and hope it
            // wasn't the range start!
			if (!bOK)
				continue;
			else
			{
				// test what we found
				if (bHasChapters)
				{
					if (nCh != nFromCh)
						continue;
					else
					{
						// we are in the wanted chapter, so test the verse values
						if (bIsVRange)
						{
							// for a verse range, start printing here if the verse falls within 
							// the verse range
							if (nFromV >= nV && nFromV <= nFinalV)
							{
								// we have found the start of the printing range, so check for a 
								// preceding section heading, and include it if the suppression 
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos; // the position of the current source 
														   // phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
														nCurSequNumber, oldPos, pList);
								}
								
								// set the global for the sequence number of the start of the range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nFromV == nV)
							{
								// we have found the start of the printing range, so check for a 
								// preceding section heading, and include it if the suppression 
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos;	// the position of the current source 
																// phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
																nCurSequNumber, oldPos, pList);
								}
								
								// set the global for the sequence number of the start of the 
								// printing range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
					}
				}
				else
				{
                    // does not have chapters, so all we can test for is verses (ignore
                    // chapter number if the user typed one in the dialog, provided it is 0
                    // or 1)
					if (nFromCh > 1)
					{
						// IDS_NO_CHAPTERS
						wxMessageBox(_(
"Error: a chapter number was specified, but this document does not appear to contain chapter specifications. The print operation has been aborted."),
						_T(""), wxICON_STOP);
						return FALSE; // error condition, non-zero chapter number, 
									  // but doc has no chapters
					}
					else
					{
						// try test the verse now, since chapter number is either 0 or 1 & is 
						// being ignored
						if (bIsVRange)
						{
							// for a verse range, start printing here if the verse falls within 
							// the verse range
							if (nFromV >= nV && nFromV <= nFinalV)
							{
								// we have found the start of the printing range, so check for a 
								// preceding section heading, and include it if the suppression 
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos; // the position of the current source
														   // phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
															nCurSequNumber, oldPos, pList);
								}
								
								// set the global for the sequence number of the start of the range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nFromV == nV)
							{
								// we have found the start of the printing range, so check for a 
								// preceding section heading, and include it if the suppression 
								// flag is not TRUE
								int nCurSequNumber = pSrcPhrase->m_nSequNumber;
								SPList::Node* oldPos = savePos; // the position of the current source 
														   // phrase
								if (!gbSuppressPrecedingHeadingInRange)
								{
									nCurSequNumber = IncludeAPrecedingSectionHeading(
															nCurSequNumber, oldPos, pList);
								}
								
								// set the global for the sequence number of the start of the range
								gnRangeStartSequNum = nCurSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
					}
				}
			}
		}
	}

	// if we get here, we didn't find the start of the range - this is an error condition, 
	// so abort the print
	//IDS_RANGE_START_FAILURE
	wxMessageBox(_(
"Error: the specified chapter and verse for the start of the printing range could not be found. The print operation has been aborted."),
	_T(""), wxICON_STOP);
	return FALSE;

	// now continue searching for the end of the printing range
	// first check in case the end chapter and end verse is the same as the start ones
b:	if (bHasChapters)
	{
		if (nCh != nToCh)
			goto d; // end chapter is different from starting one, so keep looking
		else
		{
			// we are in the wanted chapter, so test the verse values
			if (bIsVRange)
			{
				// for a verse range, end printing here if the verse falls within the verse range
				if (nToV >= nV && nToV <= nFinalV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != NULL);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
			else
			{
				// it's not a range, so see if the verse number matches this one
				if (nToV == nV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != NULL);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
		}
	}
	else
	{
        // does not have chapters, so all we can test for is verses (ignore chapter number
        // if the user typed one in the dialog, provided it is 0 or 1)
		if (nToCh > 1)
		{
			// IDS_NO_CHAPTERS
			wxMessageBox(_(
"Error: a chapter number was specified, but this document does not appear to contain chapter specifications. The print operation has been aborted."),
			_T(""), wxICON_STOP);
			return FALSE; // error condition, non-zero or non-1 chapter number, 
						  // but doc has no chapters
		}
		else
		{
			// try test the verse now, since chapter number is either 0 or 1 & is being ignored
			if (bIsVRange)
			{
				// for a verse range, end printing here if the verse falls within the verse range
				if (nToV >= nV && nToV <= nFinalV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != NULL);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
			else
			{
				// it's not a range, so see if the verse number matches this one
				if (nToV == nV)
				{
					// we have found the end of the printing range, so set the global
					GetVerseEnd(pos,savePos,pList,posEnd);
					wxASSERT(posEnd != 0);
					pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
					gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
					goto e;
				}
				else
					goto d; // keep looking
			}
		}
	}

d:	;

	while (pos != 0)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		wxString chv = pSrcPhrase->m_chapterVerse;
		if (chv.IsEmpty())
			continue;
		else
		{
			// we are at the start of a verse - see if it is where we want to end the printing
			bool bOK = ExtractChapterAndVerse(chv,nCh,nV,bHasChapters,bIsVRange,nFinalV);

			// if something went wrong, just ignore the chapter and verse - and hope it wasn't 
			// the range end!
			if (!bOK)
				continue;
			else
			{
				// test what we found
				if (bHasChapters)
				{
					if (nCh != nToCh)
						continue;
					else
					{
						// we are in the wanted chapter, so test the verse values
						if (bIsVRange)
						{
							// for a verse range, end printing here if the verse falls within 
							// the verse range
							if (nToV >= nV && nToV <= nFinalV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != 0);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto e;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nToV == nV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != 0);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto b;
							}
							else
								continue; // iterate
						}
					}
				}
				else
				{
                    // does not have chapters, so all we can test for is verses (ignore
                    // chapter number if the user typed one in the dialog, provided it is 0
                    // or 1)
					if (nToCh > 1)
					{
						// IDS_NO_CHAPTERS
						wxMessageBox(_(
"Error: a chapter number was specified, but this document does not appear to contain chapter specifications. The print operation has been aborted."),
						_T(""), wxICON_STOP);
						return FALSE; // error condition, non-zero chapter number, 
									  // but doc has no chapters
					}
					else
					{
						// try test the verse now, since chapter number is either 0 or 1 & is 
						// being ignored
						if (bIsVRange)
						{
							// for a verse range, end printing here if the verse falls within 
							// the verse range
							if (nToV >= nV && nToV <= nFinalV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != NULL);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto e;
							}
							else
								continue; // iterate
						}
						else
						{
							// it's not a range, so see if the verse number matches this one
							if (nToV == nV)
							{
								// we have found the end of the printing range, so set the global
								GetVerseEnd(pos,savePos,pList,posEnd);
								wxASSERT(posEnd != NULL);
								pSrcPhrase = (CSourcePhrase*)posEnd->GetData();
								gnRangeEndSequNum = pSrcPhrase->m_nSequNumber;
								goto e;
							}
							else
								continue; // iterate
						}
					}
				}
			}
		}
	}

    // if we get here, we didn't find the end of the range - this is an error condition, so
    // abort the print
	// IDS_RANGE_END_FAILURE
	wxMessageBox(_(
"Error: the specified chapter and verse for the end of the printing range could not be found. The print operation has been aborted."),
	_T(""), wxICON_STOP);
	return FALSE;

	// we have the required range of sequence numbers, so we can reuse the selection code here
e:	bool bIsOK = GetSublist(pSaveList, pList, gnRangeStartSequNum, gnRangeEndSequNum);

	// recalc the layout with the new width
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pList, create_strips_keep_piles);
#else
	pLayout->RecalcLayout(pList, create_strips_keep_piles);
#endif

	// hide the box, and set safe values for a non-active location (leave m_targetPhrase
	// untouched)
	pApp->m_pActivePile = NULL;
	pApp->m_nActiveSequNum = -1;
	// wm: I don't think the phrase box needs to be hidden here

	// The stuff below could go into a separate function - 
	// see also CPrintOptionsDlg::InitDialog
	// Determine the length of the printed page in logical units.
	int pageWidthBetweenMarginsMM, pageHeightBetweenMarginsMM;
	wxSize paperSize_mm;
	paperSize_mm = pApp->pPgSetupDlgData->GetPaperSize();
	wxASSERT(paperSize_mm.x != 0);
	wxASSERT(paperSize_mm.y != 0);
     // We should also have valid (non-zero) margins stored in our pPgSetupDlgData object.
	wxPoint topLeft_mm, bottomRight_mm; // MFC uses CRect for margins, wx uses wxPoint
	topLeft_mm = pApp->pPgSetupDlgData->GetMarginTopLeft(); // returns  top (y)
								// and left (x) margins as wxPoint in milimeters
	bottomRight_mm = pApp->pPgSetupDlgData->GetMarginBottomRight(); // returns bottom (y)
								// and right (x) margins as wxPoint in milimeters
	wxASSERT(topLeft_mm.x != 0);
	wxASSERT(topLeft_mm.y != 0);
	wxASSERT(bottomRight_mm.x != 0);
	wxASSERT(bottomRight_mm.y != 0);
    // The size data returned by GetPageSizeMM is not the actual paper size edge to edge,
    // nor the size within the margins, but it is the usual printable area of a paper,
    // i.e., the limit of where most printers are physically able to print; it is the area
    // in between the actual paper size and the usual margins. We therefore start with the
    // raw paperSize and determine the intended print area between the margins.
	pageWidthBetweenMarginsMM = paperSize_mm.x - topLeft_mm.x - bottomRight_mm.x;
	pageHeightBetweenMarginsMM = paperSize_mm.y - topLeft_mm.y - bottomRight_mm.y;
	
    // Now, convert the pageHeightBetweenMarginsMM to logical units for use in calling
    // PaginateDoc.
    // 
	// Get the logical pixels per inch of screen and printer.
    // whm NOTE: We can't yet use the wxPrintout::GetPPIScreen() and GetPPIPrinter()
    // methods because the wxPrintout object is not created yet at the time this print
    // options dialog is displayed. But, we can do the same calculations by using the
    // wxDC::GetPPI() method call on both a wxPrinterDC and a wxClientDC of our canvas.
	//
    // Set up printer and screen DCs and determine the scaling factors between printer and screen.
	wxASSERT(pApp->pPrintData->IsOk());

#ifdef __WXGTK__
	// Linux requires we use wxPostScriptDC rather than wxPrinterDC
	// Note: If the Print Preview display is drawn with text displaced up and off the display on wxGTK,
	// the wxWidgets libraries probably were not configured properly. They should have included a
	// --with-gnomeprint parameter in the configure call.
	wxPostScriptDC printerDC(*pApp->pPrintData); // MUST use * here otherwise printerDC will not be initialized properly
#else
	wxPrinterDC printerDC(*pApp->pPrintData); // MUST use * here otherwise printerDC will not be initialized properly
#endif
	
	wxASSERT(printerDC.IsOk());
	wxSize printerSizePPI = printerDC.GetPPI(); // gets the resolution of the printer in pixels per inch (dpi)
	wxClientDC canvasDC(pApp->GetMainFrame()->canvas);
	wxSize canvasSizePPI = canvasDC.GetPPI(); // gets the resolution of the screen/canvas in pixels per inch (dpi)
	float scale = (float)printerSizePPI.GetHeight() / (float)canvasSizePPI.GetHeight();

    // Calculate the conversion factor for converting millimetres into logical units. There
    // are approx. 25.4 mm to the inch. There are ppi device units to the inch. Therefore 1
    // mm corresponds to ppi/25.4 device units. We also divide by the screen-to-printer
    // scaling factor, because we need to unscale to pass logical units to PaginateDoc.
	float logicalUnitsFactor = (float)(printerSizePPI.GetHeight()/(scale*25.4)); 
									// use the more precise conversion factor
	int nPagePrintingWidthLU, nPagePrintingLengthLU;
	nPagePrintingWidthLU = (int)(pageWidthBetweenMarginsMM * logicalUnitsFactor);
	nPagePrintingLengthLU = (int)(pageHeightBetweenMarginsMM * logicalUnitsFactor);
	// The stuff above could go into a separate function - see also CPrintOptionsDlg::InitDialog

	gnPrintingLength = nPagePrintingLengthLU; //nPrintingLength;

	// Footer adjustments and printing are done in the View's PrintFooter() function

	// do pagination
	//
    // whm: In the following call to PaginateDoc, we use the current m_nStripCount stored
    // on pBundle, because the PaginateDoc() call here is done within SetupRangePrintOp()
    // which is called after the print dialog has been dismissed with OK, and thus we are
    // paginating the actual doc to print and not merely simulating it for purposes of
    // getting the pages edit box values for the print options dialog.
	bIsOK = PaginateDoc(pLayout->GetStripArray()->GetCount(), nPagePrintingLengthLU);
													// doesn't call RecalcLayout()
	if (!bIsOK)
	{
		wxMessageBox(_T("Pagination failed."),_T(""), wxICON_STOP);
		return FALSE;
	}

	wxPrintDialogData printDialogData(*pApp->pPrintData); 
	// pagination succeeded, so set the initial values
	int nTotalPages = pApp->m_pagesList.GetCount();
	printDialogData.SetMaxPage(nTotalPages);
	printDialogData.SetMinPage(1);
	printDialogData.SetFromPage(1);
	printDialogData.SetToPage(nTotalPages);

	return TRUE;
}

// whm revised 15Feb05 to include all markers of sectionHead textType
void CAdapt_ItView::GetVerseEnd(SPList::Node*& curPos,SPList::Node*& precedingPos,
								SPList* WXUNUSED(pList),SPList::Node*& preLastPos)
{ 
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList::Node* pos = curPos;
	wxASSERT(curPos != 0);
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* lastPos;
	preLastPos = precedingPos;
	int count = 0;
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markerStr; 
	wxString nonFilteredMkrs;
	while (pos != 0)
	{
		lastPos = pos;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase == 0)
			break; // break out if we are at the end of the document
		count++;

		// if a following section heading is not wanted, check for it here & break early
		// if one is found
		if (!gbIncludeFollowingHeadingInRange)
		{
			// it is not possible for a section heading to be within a merged source phrase, so
			// we do not need to check for medial markers; so just check contents of the 
			// m_markers attribute
			if (!pSrcPhrase->m_markers.IsEmpty())
			{
				// whm added 14Feb05 in support of USFM and SFM Filtering
				markerStr = pSrcPhrase->m_markers;
				nonFilteredMkrs = pDoc->GetUnFilteredMarkers(markerStr);
				// NormalizeToSpaces leaves the markers in m_markers delimited by spaces, at
				// lease medially. We'll use the Tokenize CString method here.
				wxString sfm;
				wxStringTokenizer tkz(markerStr,_T(" "));
				
				while (tkz.HasMoreTokens())
				{
					sfm = tkz.GetNextToken();
					if (sfm[0] == gSFescapechar)	// Only check actual sfms. Some tokens will be only		 
													// numbers (those after \c and \v) which we ignore
					{
						sfm.Trim(TRUE); // trim right end
						sfm.Trim(FALSE); // trim left end
							sfm += _T(' '); // insure the sfm is followed by a space for unique find in
											// our wrap strings.
						// If only one of the sfms within m_markers is a wrap marker, we should return TRUE.
						switch (pApp->gCurrentSfmSet)
						{
							case UsfmOnly: 
							{
								if (pApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
									// there is a section marker, so we have found the place to end the printing range
									return; // preLastPos value is the value the caller wants
								break;
							}
							case PngOnly:
							{
								if (pApp->PngSectionHeadMarkersStr.Find(sfm) != -1)
                                    // there is a section marker, so we have found the
                                    // place to end the printing range
									return; // preLastPos value is the value the caller wants
								break;
							}
							case UsfmAndPng:
							{
								if (pApp->UsfmAndPngSectionHeadMarkersStr.Find(sfm) != -1)
									// there is a section marker, so we have found the 
									// place to end the printing range
									return; // preLastPos value is the value the caller wants
								break;
							}
							default: 
							{
								// if we got here it would be a program error
								if (pApp->UsfmSectionHeadMarkersStr.Find(sfm) != -1)
									return; // preLastPos value is the value the caller wants
							}
						}
					}
				}
			}
		}

        // for safety, in a text with no verse numbering, we'll break from the loop after
        // 300 iterations
		if (pSrcPhrase->m_chapterVerse.IsEmpty() && count < 300)
		{
			preLastPos = lastPos;
			continue;
		}
		else
			break;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected, and before
/// the menu is displayed.
/// Enables the "Units of Measurement..." item on the View menu. This menu item is always enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateUnits(wxUpdateUIEvent& event)
{
	event.Enable(TRUE);
}

void CAdapt_ItView::OnUnits(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CUnitsDlg dlg(pApp->GetMainFrame());
	dlg.Centre();
	if (dlg.ShowModal() == wxID_OK)
	{
		pApp->m_bIsInches = dlg.m_bIsInches;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pDC     -> the display context (either print preview, or actual physical printer
/// \param      fitRect -> the rectangle representing the area of the page enclosed by the page margins
/// \param      logicalUnitsFactor -> represents the factor that must be multipled by any linear 
///             measurement such as the half inch (12.7mm) that a footer is displaced below fitRect's 
///             bottom margin, in order to convert that linear measurement into logical units for 
///             correct positioning in the different display contexts 
/// \param      page -> the page currently being rendered
/// \remarks
/// Called from: AIPrintout::OnPrintPage(). Composes the text of the footer and draws it at the footer
/// position of the rendered page.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::PrintFooter(wxDC* pDC, wxRect fitRect, float logicalUnitsFactor, int page)
{
    // whm Note: This function's signature has been revised for the wx version. The fitRect
    // parameter is the rectangle that comprises the printing area within the page's
    // margins; its dimensions are in logical units which will differ depending on whether
    // the footer is being drawn on the print preview display context, or on an actual
    // higher resolution printer dc. The logicalUnitsFactor parameter represents the factor
    // that must be multipled by any linear measurement such as the half inch (12.7mm) that
    // a footer is displaced below fitRect's bottom margin, in order to convert that linear
    // measurement into logical units for correct positioning in the different display
    // contexts.
	
	// get document and app pointers
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString strPageNum;
	strPageNum = strPageNum.Format(_T("%d"),page);
	wxString tgtName = pApp->m_pKB->m_targetLanguageName;
	wxString srcName = pApp->m_pKB->m_sourceLanguageName;

    // get the filename for the document (include the range if we are printing a
    // chapter/verse range)
	wxString strDocName = pDoc->GetFilename();	// get the name of the document (actually filename, 
												// with extension. GetFilename() returns the whole
												// absolute path, so just get the name + ext)
	wxFileName fn(strDocName);
	strDocName = fn.GetFullName();
	wxString strLeft;
	wxString strLeftPlusPageNum;
	if (gbPrintingRange)
	{
		strLeft = strLeft.Format(_T("%s/%s  %s   %d:%d to %d:%d"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str(),
			gnFromChapter,gnFromVerse,gnToChapter,gnToVerse);
		strLeftPlusPageNum = strLeftPlusPageNum.Format(_T("  %s/%s  %s   %d:%d to %d:%d   %d"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str(),
			gnFromChapter,gnFromVerse,gnToChapter,gnToVerse,page);
	}
	else
	{
		strLeft = strLeft.Format(_T("%s/%s  %s"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str());
		strLeftPlusPageNum = strLeftPlusPageNum.Format(_T("  %s/%s  %s   %d"),
			srcName.c_str(),tgtName.c_str(),strDocName.c_str(),page);
	}

	// create a 12 point size copy of the system font, colour black
	wxFont* pFont;
	pFont = new wxFont(*wxNORMAL_FONT);
	pFont->SetPointSize(10);
	pFont->SetWeight(wxBOLD);
	pDC->SetTextForeground(*wxBLACK);
	pDC->SetFont(*pFont);

	// Get the date & time file was last modified on the RHS, if not created yet, use the 
	// current system time instead.

    // whm 21Oct07 updated local time calculations below to account for change in Visual
    // Studio from 2003 to 2005. In the process I discovered that CTime::Format already
    // formats the time as local rather than UTC, so no specific call to GetLocalTm is now
    // necessary with its changed parameter behavior between VS 2003 and 2005. whm wx
    // version comment: theTime doesn't need to be initialized, but it doesn't hurt.
    // It is set to the file's modification date/time below.
	wxDateTime theTime = wxDateTime::Now(); //initialize to the current time
	wxString path = pApp->m_curAdaptionsPath + pApp->PathSeparator + strDocName;
	bool bExists;
	bExists = ::wxFileExists(path) && !::wxDirExists(path);
	if (bExists)
	{
		wxFileName fn(path);
		theTime = fn.GetModificationTime(); // use the file's last modified date & time
	}
	wxString timeStr;
	timeStr = theTime.Format(_T("%a, %b %d, %H:%M, %Y")).c_str();

	/*
	// The following code captures the logic for doing a centered header if we decide 
	// to print one.
	wxString headerStr = _T("This is a test header");
    // scaling has been done and upper left margin intersection is now 0,0, so we can set
    // coordinates for DrawText based on that reference point in terms of screen
    // coordinates. See AIPrintout::OnPrintPage() for how logicalUnitsFactor is calculated.
	int headerXExt,headerYExt;
	pDC->GetTextExtent(headerStr,&headerXExt,&headerYExt);
    // Position the header 12.7mm (a half inch) above the top margin (the top of fitRect).
    // Since the logical origin is at 0,0, we need to add the fitRect.x position
    // (fitRect.GetLeft()) to xPosHdr. We also calculate in the vertical text extent of the
    // header so that there is 12.7mm of space between the bottom of the header text and
    // the printing margin below it.
	float xPosHdr = (float)(fitRect.GetLeft())+(fitRect.GetWidth()/2.0 - (float)headerXExt/2.0);
	float yPosHdr = (float)(fitRect.GetTop()-12.8*logicalUnitsFactor-headerYExt);
    // Draw header a half inch above top margin. This will be a negative y-axis component
    // because we called SetLogicalOrigin() above on the AIPrintout's DC so that its origin
    // is at the intersection of the top and left page margins. Above this origin is
    // negative y-axis coordinates.
	pDC->DrawText(headerStr, (long)xPosHdr, (long)yPosHdr); // draw header a half inch 
															// above top margin
	*/

    // Calculate the position for the footer. The incoming parameter fitRect represents the
    // rectangular printing area within the margins in logical units. The bottom of fitRect
    // is the effective bottom margin, so we'll place the footer 12.7mm (a half inch) in
    // logical units below the bottom of fitRect. Since the logical origin is at 0,0 of the
    // page, we need to add the fitRect.x position (fitRect.GetLeft()) to xPosFtr. In
    // calculating the position of yPosFtr, however, fitRect.GetBottom() returns
    // coordinates in reference to 0,0. See AIPrintout::OnPrintPage() for how
    // logicalUnitsFactor is calculated.
	// BEW added 21Jul09 because '2' is not two spaces of width, but 2 pixels, so need
	// something bigger - otherwise for a range, end of range is too close to page number
	int wXExt; int wYExt; 
	pDC->GetTextExtent(_T("W"),&wXExt,&wYExt);
	// Bill's legacy code
	int footerXExt,footerYExt;
	pDC->GetTextExtent(strLeft,&footerXExt,&footerYExt);
	float yPosFtr = (float)(fitRect.GetBottom() + 12.7*logicalUnitsFactor); // y pos is same 
														// for all segments of the footer
	float xPosFtrLeft = (float)fitRect.GetLeft();
	int timeXExt,timeYExt;
	pDC->GetTextExtent(timeStr,&timeXExt,&timeYExt);
	if (footerXExt+2*wXExt >= fitRect.GetWidth()/2)
	{
		pDC->GetTextExtent(strLeftPlusPageNum,&footerXExt,&footerYExt);
        // The strLeft (language names and file name) extends past the middle point of the
        // footer, so we will not try to draw the page number centered in the footer, but
        // will just add a couple spaces and the page number to the end of strLeft.
        // The timeStr should fit in the right-hand side of the footer, unless the language
        // names and/or file name are extremently long. Check to see if the time string
        // will fit.
		if (footerXExt + timeXExt + 2*wXExt > fitRect.GetWidth()) // allow 2 W widths 
														// between footerXExt and timeXExt
		{
            // There is not enough space for the timeStr to fit on the footer between
            // margins, so we'll position the left part a little higher and draw the time
            // part one line height lower than the left part.
			pDC->DrawText(strLeftPlusPageNum, (long)xPosFtrLeft, (long)yPosFtr - timeYExt/2);
			int xPosTimeStr = fitRect.GetRight() - timeXExt;
			pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr + timeYExt/2);
		}
		else
		{
			// There is enough space for the timeStr to fit
			pDC->DrawText(strLeftPlusPageNum, (long)xPosFtrLeft, (long)yPosFtr);
			int xPosTimeStr = fitRect.GetRight() - timeXExt;
			pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr);
		}
	}
	else
	{
		// There is enough room to draw the page number in the middle of the footer
		pDC->DrawText(strLeft, (long)xPosFtrLeft, (long)yPosFtr);
		int xPosPageNum = fitRect.GetLeft() + fitRect.GetWidth()/2; // don't worry 
							// about adjusting for x extent of the page number
		pDC->DrawText(strPageNum, (long)xPosPageNum, (long)yPosFtr);
		int xPosTimeStr = fitRect.GetRight() - timeXExt;
		pDC->DrawText(timeStr, (long)xPosTimeStr, (long)yPosFtr);
	}

	// delete pFont for no memory leaks
	delete pFont;
}

// wxWidgets Note: This function in the MFC version was called CreateBox, but I've combined
// its functionality and that of ResizeBox into a single function now called ResizeBox in
// the wx version. This was possible because the function now calls SetSize() on the
// already existing target box. The target box is created once in the App and lives while
// the app lives. When the target box should not be shown, it is now simply hidden, rather
// than destroyed and reshown.
void CAdapt_ItView::ResizeBox(const wxPoint *pLoc, const int nWidth, const int nHeight,
				wxString &text, int nStartingChar, int nEndingChar, CPile* pActivePile)
{
	//refactored 7Apr09
	#ifdef _Trace_Box_Loc_Wrong
	if (pApp->m_nActiveSequNum >20)
	{
	wxLogDebug(_T("\nCreateBox   pLoc {y= %d ,x= %d } sequ num = %d\n"), 
		pLoc->y, pLoc->x,pActivePile->GetSourcePhrase()->m_nSequNumber);
	}
	#endif

    // 7Apr09, in the refactored version, the pActivePile parameter is no longer needed, so
    // I've repurposed it to provide a check of the gap width (active pile's m_nWidth
    // value) against the nWidth value passed in - so that if nWidth exceeds the space left
    // at the active pile's gap, the gap width is used instead
	int nGapWidth = pActivePile->GetPhraseBoxGapWidth();
	int aWidth = nWidth;
	if ( nGapWidth >= 10)
	{
		aWidth = aWidth > nGapWidth ? nGapWidth : aWidth;
	}

	gbEnterTyped = FALSE; // ensure it is FALSE, only ENTER key typed should set it TRUE
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp);
	wxRect rectBox(wxPoint((*pLoc).x, (*pLoc).y), wxPoint((*pLoc).x + aWidth,
					(*pLoc).y + nHeight+4)); // logical coords

	#ifdef _Trace_Box_Loc_Wrong
	if (pApp->m_nActiveSequNum >20)
	{
	wxLogDebug(_T("ResizeBox  rectBox topLeft { %d , %d } BEFORE OnPrepareDC & LPtoDP\n"),
			rectBox.top, rectBox.left);
	}
	#endif

	/*
	{
	#ifdef __WXDEBUG__
		wxLogTrace(_T("\nTrace 0 - Within ResizeBox - before OnPrepareDC call"));
		wxString str;
		str = str.Format("rectBox -- Logical coords: T= %d, L= %d, B= %d, R= %d\n",
			rectBox.GetTop(), rectBox.GetLeft(), rectBox.GetBottom(), rectBox.GetRight());
		wxLogTrace(str);
	#endif
	}
	*/

	// convert to device coords
	wxClientDC aDC(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(aDC); // adjust origin

	wxPoint ptrLoc = *pLoc;

    // CalcScrolledPosition is the complement of CalcUnscrolledPosition;
    // CalcScrolledPosition translates logical coordinates to device ones.
	int newXPos,newYPos;
	pApp->GetMainFrame()->canvas->CalcScrolledPosition(
								rectBox.x,rectBox.y,&newXPos,&newYPos);
	rectBox.x = newXPos;
	rectBox.y = newYPos;
	// we leave the width and height the same
	
	// Below are alternates for calculating scrolled position
//#ifdef _DEBUG
//	// The device coords can be found by subtracting the logical coords of the upper left corner as
//	// reported by GetViewStart, from rectBox's upper left corner coords. This doesn't change the
//	// width and height of a wxRect; the width and height were established in the wxRect rectBox()
//	// construction statement above.
//	int xScrollUnits, yScrollUnits, xOrigin, yOrigin;
//	pApp->GetMainFrame()->canvas->GetViewStart(&xOrigin, &yOrigin); // gets xOrigin and yOrigin in scroll units
//	pApp->GetMainFrame()->canvas->GetScrollPixelsPerUnit(&xScrollUnits, &yScrollUnits); // gets pixels per scroll unit
//	rectBox.x -= xOrigin * xScrollUnits; // number pixels is ScrollUnits * pixelsPerScrollUnit
//	rectBox.y -= yOrigin * yScrollUnits;
//#endif

	
//#ifdef _DEBUG
//	//aDC.LPtoDP(&rectBox);
//	// whm Note: The following LogicalToDeviceXRel and LogicalToDeviceYRel and their non-Rel functions
//	// adjust the logical position of rectBox after scrolling down from the zero scroll position
//	int x = aDC.LogicalToDeviceXRel(rectBox.x);// get the logical X coord converted to device coord
//	int y = aDC.LogicalToDeviceYRel(rectBox.y);// get the logical Y coord converted to device coord
//	// the above should be equivalent to the non-Rel forms below when using saveRect
//	int xx = aDC.LogicalToDeviceX(saveRect.x);// get the logical X coord converted to device coord
//	int yy = aDC.LogicalToDeviceY(saveRect.y);// get the logical Y coord converted to device coord
//	wxASSERT(x == rectBox.x); //rectBox.x = x;
//	wxASSERT(y == rectBox.y); //rectBox.y = y;
//	wxASSERT(x == xx);
//	wxASSERT(y == yy);
//#endif

	#ifdef _Trace_Box_Loc_Wrong
	if (pApp->m_nActiveSequNum >20)
	{
		wxLogDebug(_T("ResizeBox  rectBox topLeft { %d , %d } AFTER OnPrepareDC & LPtoDP\n"), 
				rectBox.top, rectBox.left);
	}
	#endif

	// WX version resizes rather than recreating the target box
	pApp->m_pTargetBox->SetSize(rectBox.GetLeft(),rectBox.GetTop(),
								rectBox.GetWidth(),rectBox.GetHeight());

    // whm note: Shouldn't the following adjustment come before the SetSize call above???
    // BEW answer: no, SetSize() would then wipe out the effect.
#ifdef _RTL_FLAGS
	// adjust, otherwise box is a bit too small vertically
	rectBox.SetHeight(rectBox.GetHeight() + 5); // allow for the window borders
	if (gnVerticalBoxBloat > 0)
		rectBox.SetHeight(rectBox.GetHeight() + gnVerticalBoxBloat); // allow for the leadings on the font
	// enable complex rendering
    // whm note for wx version: Right-to-left reading is handled automatically in Uniscribe
    // and Pango, but they differ in how they handle Unicode text chars that are from the
    // first 128 point positions. In wxMSW SetLayoutDirection() aligns these to the right
    // in the phrasebox but in wxGTK (under Pango) SetLahoutDirection() aligns these to the
    // left within the phrasebox.
	if (pApp->m_bTgtRTL)
	{
		pApp->m_pTargetBox->SetLayoutDirection(wxLayout_RightToLeft);
//      whm Note: Pango overrides the following SetStyle() command
//#ifndef __WXMSW__
//		pApp->m_pTargetBox->SetStyle(-1,-1,wxTextAttr(wxTEXT_ALIGNMENT_RIGHT));
//#endif
	}
	else
	{
		pApp->m_pTargetBox->SetLayoutDirection(wxLayout_LeftToRight);
//      whm Note: Pango overrides the following SetStyle() command
//#ifndef __WXMSW__
//		pApp->m_pTargetBox->SetStyle(-1,-1,wxTextAttr(wxTEXT_ALIGNMENT_LEFT));
//#endif
	}
#endif // for _RTL_FLAGS

	pApp->m_pTargetBox->ChangeValue(text);
	if (gbIsGlossing && gbGlossingUsesNavFont)
		pApp->m_pTargetBox->SetFont(*pApp->m_pNavTextFont);

	else
		pApp->m_pTargetBox->SetFont(*pApp->m_pTargetFont);

	// whm added following to show and enable the target box
	pApp->m_pTargetBox->Show();
	pApp->m_pTargetBox->Enable(TRUE);
	pApp->m_pTargetBox->SetEditable(TRUE);
	
	// restore focus and cursor position or selection
	pApp->m_pTargetBox->SetFocus();
	pApp->m_pTargetBox->SetSelection(nStartingChar,nEndingChar);
	pApp->m_nStartChar = (int)nStartingChar;
	pApp->m_nEndChar = (int)nEndingChar;

	if (pApp->m_bFreeTranslationMode)
	{
		// prevent clicks and editing from being done in the phrase box
		// (do also in OnAdvancedFreeTranslationMode())
        // wx version: by setting the targetbox with SetEditable(FALSE) instead of
        // Enable(FALSE) we get to control the background color, keeping it pink in free
        // trans mode
		pApp->m_pTargetBox->SetEditable(FALSE);
		pApp->m_pTargetBox->SetBackgroundColour(pApp->m_freeTransCurrentSectionBackgroundColor);
	}
	else
	{
		// enable clicks and editing to be done in the phrase box
		// (do also in OnAdvancedFreeTranslationMode())
		pApp->m_pTargetBox->SetEditable(TRUE);
		pApp->m_pTargetBox->SetBackgroundColour(wxColour(255,255,255)); // white
	}
}

void CAdapt_ItView::OnEditPreferences(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp);

	CEditPreferencesDlg editPrefsDlg(
		pApp->GetMainFrame(),
		-1,
		_("Edit Preferences"),
		wxDefaultPosition,
		wxDefaultSize,
		wxCAPTION|wxRESIZE_BORDER|wxSYSTEM_MENU|wxCLOSE_BOX);  // removed |wxDIALOG_MODAL 
					// GDLC wxDIALOG_MODAL is obsolete - ShowModal() does what it used to
	editPrefsDlg.Centre();

	pApp->m_nMaxToDisplay = pApp->GetMaxIndex() + 1;

	// preserve the current active pile location, by preserving the srcPhrases's sequNum
	// (because RecalcLayout will recreate everything any any saved pointers will no longer
	// be valid)
	int activeSequNum;
	if (pApp->m_nActiveSequNum < 0)
	{
		// must not have data yet, or we are at EOF, so no pile is currently active
		activeSequNum = -1;
	}
	else
	{
		// we are somewhere in the midst of the data, so a pile will be active
		activeSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;

		// remove any current selection, as we can't be sure of any pointers
		// depending on what user may choose to alter
		RemoveSelection();
	}
	pApp->m_nActiveSequNum = activeSequNum;
	wxString strSavePhraseBox = pApp->m_targetPhrase;

    // whm Design Modification NOTE:
    // !!! DO NOT INITIALIZE DATA IN INDIVIDUAL PREFERENCES PAGES HERE !!!
    // Each of the InitDialog() methods of the individual Preferences pages takes care of
    // the initialization of all of their local members directly from the corresponding
    // members in the App (many of which get initialized previously by config file values).
    // This modification attempts to keep initialization encapsulated more in the classes
    // that know how to handle the data. Because of this modification, we don't need to
    // initialize them from here before the CEditPreferencesDlg's ShowModal() call is made
    // - as does the MFC version.

	// Put up the "Edit Preferences" dialog
    // wx note: Since CEditPreferencesDlg is based on wxPropertySheetDialog rather than on
    // wxDialog, it does not get its idle event processing turned off while it is in modal
    // state, therefore we turn off idle processing here manually just before the ShowModal
    // call; and turn it back on afterwards (below).
	wxIdleEvent::SetMode(wxIDLE_PROCESS_SPECIFIED); // turn idle processing off
	if(editPrefsDlg.ShowModal() == wxID_OK)
	{
		// whm Design Modification NOTE:
		// !!! DO NOT UPDATE DATA FROM INDIVIDUAL PREFERENCES PAGES HERE !!!
        // Each of the OnOK() methods of the individual Preferences pages takes care of the
        // updating the App's data members directly from their local temp... members. This
        // modification attempts to keep settings value changes encapsulated more in the
        // classes that know how to handle the data. Because of this modification, we don't
        // need to update them from here after the CEditPreferencesDlg's ShowModal() call
        // is made - as does the MFC version.
	}
	else
	{
		// user cancelled
		if (pApp->m_bShowAdministratorMenu)
		{
			// don't show it if the user cancelled prefs
			pApp->m_bShowAdministratorMenu = FALSE;
		}
	}

	// show the Administrator menu if the admin person requested it and password was valid
	// if flag is FALSE, check if the menu is visible and if so, hide it
	if (pApp->m_bShowAdministratorMenu)
	{
		wxMenuBar* pMenuBar = pApp->GetMainFrame()->GetMenuBar();
		wxASSERT(pMenuBar != NULL);

		// is the Admin menu hidden? If so, install it and show it, otherwise leave it
		// showing 
		if (pApp->m_bAdminMenuRemoved)
		{
			bool bAppendedOK = pMenuBar->Append(pApp->m_pRemovedAdminMenu,pApp->m_adminMenuTitle);
			wxASSERT(bAppendedOK);
			pApp->m_pRemovedAdminMenu = NULL;
			pApp->m_bAdminMenuRemoved = FALSE;
			bAppendedOK = bAppendedOK; // to remove compiler warning
		}
		pMenuBar->Refresh();
	}
	else
	{
		wxMenuBar* pMenuBar = pApp->GetMainFrame()->GetMenuBar();
		wxASSERT(pMenuBar != NULL);

		// is the Admin menu showing? If so, remove it
		if (!pApp->m_bAdminMenuRemoved)
		{
			// it's showing, so get rid of it
			int menuCount = pMenuBar->GetMenuCount();
			//wxMenu* pAdminMenu = pMenuBar->GetMenu(menuCount - 1);
			//wxASSERT(pAdminMenu != NULL);
			pApp->m_adminMenuTitle = pMenuBar->GetLabelTop(menuCount - 1);
			pApp->m_pRemovedAdminMenu = pMenuBar->Remove(menuCount - 1);
			pApp->m_bAdminMenuRemoved = TRUE;
		}
		pMenuBar->Refresh();
	}

	// We want to be smarter here so that we don't create piles and strips again
    // unnecessarily - eg. if user changes the colour of text only, no recalculation of the
    // layout would be needed
	// BEW 5Jun09, removed the RecalcLayout() call here, in favour of using the
	// DoRecalcLayoutAfterPreferencesDlg() function, which makes a more intelligent
	// decision about which particular kind of RecalcLayout() call to make
	CLayout* pLayout = GetLayout();
	pLayout->DoRecalcLayoutAfterPreferencesDlg(); // inside are smarts for making the
												  // best possible RecalcLayout() call
	if (pApp->m_nActiveSequNum == -1)
	{
		pApp->m_pActivePile = NULL; // that ought to be safe in update handlers
	}
	else
	{
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	}
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);

	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}

    // BEW 22May09 moved idle processing down to here so that idle events won't come before
    // the m_pActivePile has a chance to be reset to the valid active pile resulting from
    // the shenanigans that go on in RecalcLayout()! Failure to do so can result in system
    // housekekeping calling command update handlers before m_pActivePile points at a real
    // pile, and that gives a flame & burn crash
	wxIdleEvent::SetMode(wxIDLE_PROCESS_ALL); // turn idle processing back on

	int len;
	// BEW modified 3Apr08, restore focus to the phrase box, except when in free translation
	// mode in which case it needs to be restored to the compose bar's editbox
	if (pApp->m_bFreeTranslationMode)
	{
		CMainFrame* pFrame = pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		if (pFrame->m_pComposeBar != NULL)
			if (pFrame->m_pComposeBar->IsShown())
			{
				wxTextCtrl* pComposeBox = (wxTextCtrl*)
							pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
				wxString text;
				text = pComposeBox->GetValue(); 
				len = text.Length();
				pComposeBox->SetSelection(len,len);
				pComposeBox->SetFocus();
			}
	}
	else
	{

		if (pApp->m_pTargetBox->IsShown())
		{
			len = pApp->m_targetPhrase.Length();
			pApp->m_nStartChar = len;
			pApp->m_nEndChar = len;
			pApp->m_pTargetBox->SetSelection(len,len);
			pApp->m_pTargetBox->SetFocus();
		}
	}

    // it's not necessary to clear these flags here, as they get cleared automatically in
    // the CEditPreferences::InitDialog() function, which is called when the Preferences
    // dialog is first opened. However, it is good defensive practice not to leave them set
    // until then
	pLayout->m_bViewParamsChanged = FALSE;
	pLayout->m_bUSFMChanged = FALSE;
	pLayout->m_bFilteringChanged = FALSE;
	pLayout->m_bPunctuationChanged = FALSE;
	pLayout->m_bCaseEquivalencesChanged = FALSE;
	pLayout->m_bFontInfoChanged = FALSE;

	// BEW 30Jun09, added Invalidate() and PlaceBox() here, not sure but I think they
	// are needed
	Invalidate();
	pLayout->PlaceBox();
}

void CAdapt_ItView::OnFileSaveKB(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp);
	bool bOK = FALSE;
	wxString mess;
	mess.Empty();
	if (gbIsGlossing)
	{
		bOK = pApp->SaveGlossingKB(FALSE); // don't want backup produced of the glossing KB
		if (!bOK)
		{
			mess = _("Failure when trying to save the glossing knowledge base. ");
		}
	}
	else
	{
		bOK = pApp->SaveKB(FALSE); // don't want backup produced
		if (!bOK)
		{
			mess = _("Failure when trying to save the knowledge base. ");
		}
	}
	if (!bOK)
	{
		pApp->m_bAutoBackupKB = FALSE;	// turn it off, so if user reopens the app later, the
										// bad glossing KB will not overwrite the backed up one
		mess += _(" You should immediately save the document, then try again.");
		mess += _(" If you have repeated failures, then exit the application ");
		mess += _("and try one of the recovery strategies (either use the backup one ");
		mess += _("or the Restore Knowledge Base command). DO NOT use ");
		mess += _("the Backup Knowledge Base command now!");
		wxMessageBox(mess, _T(""), wxICON_EXCLAMATION);
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Enables the "Save Knowledge Base" item on the File menu if the appropriate KB is in a
/// ready state, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileSaveKB(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbIsGlossing)
		event.Enable(pApp->m_bGlossingKBReady);
	else
		event.Enable(pApp->m_bKBReady);
}

void CAdapt_ItView::OnFileCloseProject(wxCommandEvent& event)
{
    // Since the Close Project menu item has an accelerator table hot key (CTRL-J see
    // CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even when
    // they are disabled, we must check for a disabled button and return if disabled.
    // On Windows, the accelerator key doesn't appear to call the handler for a disabled
    // menu item, but I'll leave the following code here in case it works differently on
    // other platforms.
	//CMainFrame* pFrame = pApp->GetMainFrame();
	//wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	//wxASSERT(pMenuBar != NULL);
	//if (!pMenuBar->IsEnabled(ID_FILE_CLOSEKB))
	//{
	//	::wxBell();
	//	return;
	//}

	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp);
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	// BEW added 6Nov09 because, if recovering within the OnInit() call just after
	// launch because a custom work folder location is not accessible (eg. it may be
	// on a thumb drive not currently plugged in), the GetCustomWorkFolderLocation()
	// call, part of the recovery attempt, will call GetView()->CloseProject(), but
	// that calls OnFileCloseProject() which then tries to set up a pointer to the
	// document class's instance, which at that time does not yet exist. The pointer
	// is returned as NULL, and so the pDoc->OnFileClose() call a little further below
	// would fail unless we here detect a pDoc being NULL and exit immediately
	if (pDoc == NULL)
		return; // do nothin because no doc instance exists yet, so prevent crash

	if (gbEnableGlossing)
	{
		// glossing is on, so we must ensure the menu toggle is turned off and the
		// glossing checkbox removed, so this can all be done with the following call
		OnAdvancedEnableglossing(event);
	}

	if (pApp->m_bFreeTranslationMode)
	{
		// free translation mode is on, so we must first turn it off
		wxCommandEvent event;
		OnAdvancedFreeTranslationMode(event);
	}

	if (!gbIgnoreScriptureReference_Receive)
	{
		// scripture reference receiving is turned on, and it must be
		// off when there is no project current
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedReceiveSynchronizedScrollingMessages(uevent); //toggle it to TRUE
	}

	if (!gbIgnoreScriptureReference_Send)
	{
		// scripture reference sending is turned on, and it must be
		// off when there is no project current
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedSendSynchronizedScrollingMessages(uevent); //toggle it to TRUE
	}

	// ask for saving of doc & both kbs (normal one and glossing one)
	pDoc->OnFileClose(event);

	if (bUserCancelled)
	{
		bUserCancelled = FALSE; // clear the flag to default situation
		return;
	}

	// then delete each KB and make the app unable to use either further
	gbJustClosedProject = TRUE;
	pDoc->EraseKB(pApp->m_pKB);
	pApp->m_bKBReady = FALSE;
	pApp->m_pKB = (CKB*)NULL; // done in EraseKB too
	// now the glossing KB and flags
	pDoc->EraseKB(pApp->m_pGlossingKB);
	pApp->m_bGlossingKBReady = FALSE;
	pApp->m_pGlossingKB = (CKB*)NULL; // done in EraseKB too

	// update status bar with project name
	wxString message;
	// IDS_NO_PROJECT
	message = message.Format(_("No project is currently active"));
	if (pApp->m_bBookMode && !pApp->m_bDisableBookMode)
	{
		wxString mssg;
		wxString undef;
		undef = _(" Undefined");
		// IDS_CURFOLDER
		mssg = mssg.Format(_("  Current Folder: %s"),undef.c_str());
		message += mssg;
	}
	StatusBarMessage(message); // don't want a glossing/adapting prefix, since we are closing

    // restore the glossing support flags to their default values, so an open of another
    // project will have the default 2-rows per strip interface in effect
	gbIsGlossing = FALSE;
	gbEnableGlossing = FALSE;
	gbGlossingUsesNavFont = FALSE;

    // book folder mode may have been on; we can't be sure the next project opened will
    // have that mode on, or even that it may have been on in the project at an earlier
    // time, so the safe thing to do is to turn it off
	pApp->m_bBookMode = FALSE;
	if (pApp->m_pBibleBooks != NULL)
		pApp->m_bDisableBookMode = FALSE;
	else
		pApp->m_bDisableBookMode = TRUE;
	pApp->m_nBookIndex = -1;
	pApp->m_nDefaultBookIndex = 39; // default is Matthew
	pApp->m_nLastBookIndex = -1;
	pApp->m_pCurrBookNamePair = NULL;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "Close Project" item on the File menu if Vertical Editing is in progress.
/// Enables the item if the KBs are in a ready state, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileCloseKB(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// the kbs are closed or opened together
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "New" item on the File menu if Vertical Editing is in progress. Enables
/// the item if the KB pointers are not NULL, and if the strip count is zero, otherwise it
/// disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileNew(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	// we can't use m_pSourcePhrases->GetCount() equal to zero because after a File...Close
	// only the view (ie. strips) is clobbered, the source phrases don't get clobbered until
	// DeleteContents() is called, which does not happen until either the user chooses New...
	// or Open... or the Wizard equivalents, or closes the app. So a zero strip count is
	// a sufficient condition.
	if (pApp->m_pKB != NULL && pApp->m_pGlossingKB != NULL && 
		pApp->m_pLayout->GetStripArray()->GetCount() == 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "Open..." item on the File menu if Vertical Editing is in progress.
/// Enables the item if the KB pointers are not NULL, and if the app's strip count is
/// zero, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileOpen(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
    // we can't use m_pSourcePhrases->GetCount() equal to zero because after a File...Close
    // only the view (ie. strips) is clobbered, the source phrases don't get clobbered
    // until DeleteContents() is called, which does not happen until either the user
    // chooses New... or Open... or the Wizard equivalents, or closes the app. So a zero
    // strip count is a sufficient condition.
    // I've changed this now, the source phrases now get clobbered, but using the strip
    // count is still perfectly acceptable, so I'll leave it unchanged.
	if (pApp->m_pKB != NULL && pApp->m_pGlossingKB != NULL && 
		pApp->m_pLayout->GetStripArray()->GetCount() == 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "Print..." item on the File menu if Vertical Editing is in progress.
/// Enables the item if the KBs are in a ready state, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFilePrint(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// Disables the "Print Preview" item on the File menu if Vertical Editing is in progress. 
/// Enables the item if the KBs are in a ready state, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFilePrintPreview(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

// Modified by whm 14Feb05 to support USFM and SFM Filtering.
bool CAdapt_ItView::IsWrapMarker(CSourcePhrase* pSrcPhrase)
{
	// refactored 19Mar09 -- no changes needed
	// Version 3 implementation: We first extract each marker from
	// the pSrcPhrase->m_markers member, and use Find to check if it is
	// in the appropriate wrap string UsfmWrapMarkersStr, PngWrapMarkersStr,
	// or UsfmAndPngWrapMarkersStr, depending on which map set is active.

	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markerStr = pSrcPhrase->m_markers;
	wxString nonFilteredMkrs = pDoc->GetUnFilteredMarkers(markerStr);
	// NormalizeToSpaces leaves the markers in m_markers delimited by spaces, at
	// lease medially. We'll use the Tokenize CString method here.
	wxString sfm;
	bool bValue = FALSE;

	wxStringTokenizer tkz(markerStr,_T(" "));

	while (tkz.HasMoreTokens())
	{
		sfm = tkz.GetNextToken();
		if (sfm[0] == gSFescapechar)	// Only check actual sfms. Some tokens will be only
										// numbers (those after \c and \v) which we ignore
		{
			// there shouldn't be any end marking asterisk * on a wrap marker, but
			// remove any that might exist for a clean search below.
			int endMkrPos = sfm.Find(_T('*'),TRUE); // TRUE finds from right end
			if (endMkrPos != -1)
				sfm = sfm.Left(endMkrPos);
			sfm.Trim(FALSE); // trim left end
			sfm.Trim(TRUE); // trim right end
			sfm += _T(' '); // insure the sfm is followed by a space for unique find in
							// our wrap strings.
			// If only one of the sfms within m_markers is a wrap marker, we should return TRUE.
			switch (pApp->gCurrentSfmSet)
			{
				case UsfmOnly:
				{
					if (pApp->UsfmWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // it's in the wrap markers list, so start a new strip
					break;
				}
				case PngOnly:
				{
					if (pApp->PngWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // it's in the wrap markers list, so start a new strip
					break;
				}
				case UsfmAndPng:
				{
					if (pApp->UsfmAndPngWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // it's in the wrap markers list, so start a new strip
					break;
				}
				default:
				{
					// if we got here it would be a program error
					if (pApp->UsfmWrapMarkersStr.Find(sfm) != -1)
						return TRUE; // found the sfm, so start a new strip
				}
			}
		}
	}

	// any other marker, we will just let it be ignored & go on setting up piles
	return bValue;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     the pointer to the CCell instance the user clicked
/// \param      pPoint  -> pointer to the wxPoint (logical coords) where the 
///                        user clicked 
/// \remarks
/// 
/// Interrogates the m_stripArray to termine which strip, pile and cell was clicked in;
/// returning the cell's pointer; it is the caller's responsibility to convert the client
/// coords for the click as returned from the event record, into a logical point, before
/// passing the result to GetClickedCell()
/////////////////////////////////////////////////////////////////////////////////
CCell* CAdapt_ItView::GetClickedCell(const wxPoint *pPoint)
{
	// refactored 6Apr09
	CLayout* pLayout = GetLayout();
	wxASSERT(pLayout != NULL);
	wxPoint point = *pPoint;
	CStrip* pStrip = NULL; // whm initialized to NULL
	CPile* pPile = NULL; // whm initialized to NULL 
	CCell* pCell = NULL; // whm initialized to NULL
	wxRect rect;
	int	pileCountInStrip;
	int	pileIndexInStrip;
	int cellIndex;
	int stripIndex;
	wxArrayPtrVoid* pStripArray = pLayout->GetStripArray();
	int nStripCount = pStripArray->GetCount();

	// find the strip the click was in (we don't count a click on free translation text
	// as a valid click on the strip, neither is a click in the navText whiteboard area)
	for (stripIndex = 0; stripIndex < nStripCount; stripIndex++)
	{
		pStrip = (CStrip*)pStripArray->Item(stripIndex);
		wxASSERT(pStrip != NULL);
		pStrip->GetStripRect_CellsOnly(rect);
		rect = NormalizeRect(rect); // use our own from helpers.h
		if (rect.Contains(point))
			break;
	}
	if (stripIndex == nStripCount || pStrip == NULL)
		return NULL; // did not click within a strip
	else
	{
		// find which pile of the strip the click was in
#ifdef _ALT_LAYOUT_
		pileCountInStrip = pStrip->GetPileIndicesCount();
		for (pileIndexInStrip = 0; pileIndexInStrip < pileCountInStrip; pileIndexInStrip++)
		{
			pPile = pStrip->GetPileByIndexInStrip(pileIndexInStrip);
			pPile->GetPileRect(rect);
			rect = NormalizeRect(rect); // use our own from helpers.h
			if (rect.Contains(point))
				break;
		}
#else
		wxArrayPtrVoid*	pPilesArray = pStrip->GetPilesArray(); // gets ptr to m_arrPiles
		pileCountInStrip = pPilesArray->GetCount();
		for (pileIndexInStrip = 0; pileIndexInStrip < pileCountInStrip; pileIndexInStrip++)
		{
			pPile = (CPile*)pPilesArray->Item(pileIndexInStrip);
			pPile->GetPileRect(rect);
			rect = NormalizeRect(rect); // use our own from helpers.h
			if (rect.Contains(point))
				break;
		}
#endif
		if (pileIndexInStrip == pileCountInStrip || pPile == NULL)
			return NULL; // did not click within a pile - clicked in a gap, or at end, or in margin
		else
		{
			// find which cell the click was in
			for (cellIndex = 0; cellIndex < MAX_CELLS; cellIndex++)
			{
				pCell = pPile->GetCellArray()[cellIndex];
				if (pCell == NULL)
					continue;
				pCell->GetCellRect(rect);
				rect = NormalizeRect(rect); // use our own from helpers.h
				if (rect.Contains(point))
					break;
			}
			if (cellIndex == MAX_CELLS)
				return NULL; // click was not in a cell
		}
	}
	return pCell;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     return NULL if the click was not in a strip or its leading area - it should
///             be impossible to return NULL though; otherwise return the CStrip pointer
/// \param      pPoint  -> pointer to the wxPoint (logical coords) where the user clicked 
/// \remarks
/// 
/// Interrogates the m_stripArray to termine which strip, or the leading just above it, the
/// user clicked in - returning the strip's pointer; it is the caller's responsibility to
/// convert the client coords for the click as returned from the event record, into a
/// logical point, before passing the result to GetNearestStrip()
/// The pStrip pointer passed back is the pointer to a CStrip instance, but we determine
/// that the strip was clicked on if either it or the leading area was clicked on - since
/// the note or wedge icons will be in the leading area.
/////////////////////////////////////////////////////////////////////////////////
CStrip* CAdapt_ItView::GetNearestStrip(const wxPoint *pPoint)
{
	// refactored 6Apr09
	CLayout* pLayout = GetLayout();
	wxASSERT(pLayout != NULL);
	wxArrayPtrVoid* pStripArray = pLayout->GetStripArray();
	int nStripCount = pStripArray->GetCount();

	wxPoint point = *pPoint;
	CStrip* pStrip = NULL;
	wxRect rect;
	int leading = pLayout->GetCurLeading(); // defines the vertical extent of the nav 
											// text area above the strip
	int stripIndex;
	for (stripIndex = 0; stripIndex < nStripCount; stripIndex++)
	{
		pStrip = (CStrip*)(*pStripArray)[stripIndex];
		pStrip->GetStripRect_CellsOnly(rect);
		rect = NormalizeRect(rect); // use our own from helpers.h
        // subtract the leading from the top, because it's within there that we expect
        // clicks on the wedge to happen
        rect.SetTop(rect.GetTop()- leading); // In wx's wxRect, this only moves the x,y 
                // coordinate and consequently the whole box, leaving the height the same,
                // therefore, we also need to reset the height to include the leading value
		rect.SetHeight(rect.GetHeight() + leading); // whm added
        // BEW changed 02Aug05 to handle RTL layout better - for these the click could be
        // outside the strip rectangle for a wedge offset to the right and at the right
        // edge of the strip; so instead just check that the vertical offset for the click
        // falls on or within the top and bottom coords of the rect
		if (point.y >= rect.GetTop() && point.y <= rect.GetBottom())
			break;
	}
	if (stripIndex == nStripCount)
		return NULL; // did not click within a strip or its leading area above it
	else
		return pStrip;
}

void CAdapt_ItView::RemovePrecedingAnchor(wxClientDC* pDC, CCell *pAnchor)
{
	// refactored 6Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCellList::Node* pos = pApp->m_selection.Find(pAnchor);
	wxASSERT(pos != NULL); // the anchor MUST be in the list!
	CCell* pCell;
	pCell = (CCell*)pos->GetData(); // the earliest of desired seln
	pos = pos->GetPrevious();
	if (pos != NULL)
	{
		// there is selected CCell previous to the anchor cell,
		// so get rid of it & any earlier ones
		CCell* pPrevCell;
		while (pos != NULL)
		{
			CCellList::Node* savePos = pos;
			pPrevCell = (CCell*)pos->GetData();
			pos = pos->GetPrevious();
			pDC->SetBackgroundMode(pApp->m_backgroundMode);
			pDC->SetTextBackground(wxColour(255,255,255)); // white
			pPrevCell->DrawCell(pDC, GetLayout()->GetSrcColor());
			pPrevCell->SetSelected(FALSE);
			pApp->m_selection.DeleteNode(savePos);
		}
	}
}

void CAdapt_ItView::RemoveFollowingAnchor(wxClientDC *pDC, CCell *pAnchor)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCellList::Node* pos = pApp->m_selection.Find(pAnchor);
	wxASSERT(pos != NULL); // the anchor MUST be in the list!
	CCell* pCell;
	pCell = (CCell*)pos->GetData(); // the last cell of desired seln
	pos = pos->GetNext();
	if (pos != NULL)
	{
		// there is selected CCell after the anchor cell,
		// so get rid of it & any later ones
		//CText* pText;
		CCell* pFollCell;
		while (pos != NULL)
		{
			CCellList::Node* savePos = pos;
			pFollCell = (CCell*)pos->GetData();
			pos = pos->GetNext();
			pDC->SetBackgroundMode(pApp->m_backgroundMode);
			pDC->SetTextBackground(wxColour(255,255,255)); // white
			pFollCell->DrawCell(pDC, GetLayout()->GetSrcColor());
			pFollCell->SetSelected(FALSE);
			pApp->m_selection.DeleteNode(savePos);
		}
	}
}

void CAdapt_ItView::RemoveEarlierSelForShortening(wxClientDC *pDC, CCell *pEndCell)
{
    // the "end cell" will be towards the left of the selection list (or at its start) when
    // the layout direction is either LTR or RTL, because we store in logical order. (Lower
    // sequence numbers are to the left.)

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCell* pCell;
	CCellList::Node* pos = pApp->m_selection.Find(pEndCell);
	if (pos != NULL)
	{
		pCell = (CCell*)pos->GetData(); // the earliest of desired seln, for LTR
		pos = pos->GetPrevious();
		if (pos != NULL)
		{
			// there is previous selected CCell, so user must have shortened sel'n
			// so get rid of it & any earlier ones
			CCell* pPrevCell;
			while (pos != NULL)
			{
				CCellList::Node* savePos = pos;
				pPrevCell = (CCell*)pos->GetData();
				pos = pos->GetPrevious();
				pDC->SetBackgroundMode(pApp->m_backgroundMode);
				pDC->SetTextBackground(wxColour(255,255,255)); // white
				pPrevCell->DrawCell(pDC, GetLayout()->GetSrcColor());
				pPrevCell->SetSelected(FALSE);
				pApp->m_selection.DeleteNode(savePos);
			}
		}
	}
}

void CAdapt_ItView::RemoveLaterSelForShortening(wxClientDC *pDC, CCell *pEndCell)
{
    // the "end cell" will be towards the right of the selection list (or at its end) when
    // the layout direction is either LTR or RTL, because we store in logical order not
    // visible order (ie. larger sequence numbers are to the right in the list)
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCell* pCell;
	CCellList::Node* pos = pApp->m_selection.Find(pEndCell);
	if (pos != NULL)
	{
		pCell = (CCell*)pos->GetData(); // the last of desired seln
		pos = pos->GetNext();
		if (pos != NULL)
		{
			// there is another selected CCell, so user must have shortened sel'n
			// so get rid of it & any subsequent ones
			CCell* pLaterCell;
			while (pos != NULL)
			{
				CCellList::Node* savePos = pos;
				pLaterCell = (CCell*)pos->GetData();
				pos = pos->GetNext();
				pDC->SetBackgroundMode(pApp->m_backgroundMode);
				pDC->SetTextBackground(wxColour(255,255,255)); // white
				pLaterCell->DrawCell(pDC, GetLayout()->GetSrcColor());
				pLaterCell->SetSelected(FALSE);
				pApp->m_selection.DeleteNode(savePos);
			}
		}
	}
}

bool CAdapt_ItView::IsBoundaryCell(CCell *pCell)
{
	return pCell->GetPile()->GetSrcPhrase()->m_bBoundary;
}

// returns the cell immediately preceding the pCell one, regardless of where boundaries
// are; returns null if no previous cell
CCell* CAdapt_ItView::GetPrevCell(CCell *pCell, int cellIndex)
{
	// refactored 7Apr09
	CPile* pPile = pCell->GetPile();
	PileList* pPiles = GetLayout()->GetPileList();
	int index = pPiles->IndexOf(pPile);
	index--; // index of previous CPile instance, could exceed bound
	if (index < 0)
	{
		return NULL; // bounds error - passed beginning of document
	}
	else
	{
		// not past beginning of document
		PileList::Node* pos = pPiles->Item(index);
		pPile = pos->GetData();
		wxASSERT(pPile != NULL);
	}
	return pPile->GetCell(cellIndex);
}

void CAdapt_ItView::RemoveSelection()
{
	// refactored 7May09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	pApp->m_bSelectByArrowKey = FALSE;
	if (pApp->m_selection.IsEmpty())
	{
		// if no selection is current, just ensure sel'n parameters are zeroed
		pApp->m_selectionLine = -1;
		pApp->m_pAnchor = (CCell*)NULL;

		// and the globals also
		gnSelectionLine = -1;
		gnSelectionStartSequNum = -1;
		gnSelectionEndSequNum = -1;
		return;
	}
	wxClientDC aDC(pApp->GetMainFrame()->canvas);
	CCell* pCell;

	// there is a current selection, so clobber it
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	while (pos != NULL)
	{
		pCell = (CCell*)pos->GetData();
		pos = pos->GetNext();
		aDC.SetBackgroundMode(pApp->m_backgroundMode); // Do not use wxTRANSPARENT!! 
												// because background is not updated
		aDC.SetTextBackground(wxColour(255,255,255)); // white
		pCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
		pCell->SetSelected(FALSE);
	}
	pApp->m_selection.Clear();
	pApp->m_selectionLine = -1;
	pApp->m_pAnchor = (CCell*)NULL;

	// and the globals also need to be set to a "no selection" state
	gnSelectionLine = -1;
	gnSelectionStartSequNum = -1;
	gnSelectionEndSequNum = -1;

	// toggle Respect Boundaries button back on, so m_bRespectBoundaries is reset TRUE
	if (!pApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(dummyevent);
}

// DeepCopySublist2Sublist was in Helpers.cpp in the legacy version.
// Copies CSourcePhrase instances to an empty pCopiedSublist, as deep copies, and
// preserves m_nSequNumber values in the copies
// Called only once, in OnEditSourceText()
void CAdapt_ItView::DeepCopySublist2Sublist(SPList* pOriginalList, SPList* pCopiedSublist)
{
	if (pOriginalList->GetCount() == 0)
		return;
	SPList::Node* pos = pOriginalList->Item(0);
	wxASSERT(pos);
	SPList::Node* savePos = NULL;
	CSourcePhrase* pSrcPhrase = NULL;
	while (pos != NULL)
	{
		// deep copy each until all are copied
		savePos = pos;
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		CSourcePhrase* pNewSP = new CSourcePhrase(*pSrcPhrase); // uses operator=,
															    // does shallow copy
		pNewSP->DeepCopy(); // pNewSP is now a deep copy
		pCopiedSublist->Append(pNewSP);
	}
}

// RemoveFilterWrappersButLeaveContent was in Helpers.cpp in the legacy version.
// removes "\~FILTER" and "\~FILTER*" from str, but leaves the SFM, its content, and any
// following endmarker followed by any whitespace etc.
void CAdapt_ItView::RemoveFilterWrappersButLeaveContent(wxString& str)
{
	// uses global strings, filterMkr and filterMkrEnd
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	wxString strRemoveThis = filterMkrEnd;
	int len = strRemoveThis.Length();
	wxString strBegin;
	wxString strEnd;
	wxChar ch;
	bool bIsWhitespace = FALSE;
	int offset = -1;
	do {
		offset = str.Find(strRemoveThis);
		if (offset != -1)
		{
			// there is one to be removed
			strBegin = str.Left(offset);
			strEnd = str.Mid(offset);
			strEnd = strEnd.Mid(len); // this removes the "\\~FILTER*" which we found
			// now remove any following whitespace, which now is at the start of strEnd
			ch = strEnd[0];
			bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			while (bIsWhitespace)
			{
				strEnd = strEnd.Mid(1); // remove initial white space character
				ch = strEnd[0];
				bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			}
			// now rejoin the begin and end parts
			str = strBegin + strEnd;
		}
	} while (offset != -1);
	// now do the loop to remove any instances of "\\~FILTER" followed by whitespace
	strRemoveThis = filterMkr;
	len = strRemoveThis.Length();
	offset = -1;
	do {
		offset = str.Find(strRemoveThis);
		if (offset != -1)
		{
			// there is one to be removed
			strBegin = str.Left(offset);
			strEnd = str.Mid(offset);
			strEnd = strEnd.Mid(len); // this removes the "\\~FILTER*" which we found
			// now remove any following whitespace, which now is at the start of strEnd
			bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			while (bIsWhitespace)
			{
				strEnd = strEnd.Mid(1); // remove initial white space character
				bIsWhitespace = pDoc->IsWhiteSpace(&ch);
			}
			// now rejoin the begin and end parts
			str = strBegin + strEnd;
		}
	} while (offset != -1);
}

// ReplaceCSourcePhrasesInSpan was in Helpers.cpp in the legacy version.
/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error. (Also, if either 
///             list is empty, nothing is done and the function returns FALSE.)
/// \param      pMasterList        -> pointer to the list of CSourcePhrase pointers where the 
///                                   replacements are to be done (typically, the app's 
///                                   m_pSourcePhrases list)
/// \param      nStartAt           -> the 0-based index into the pMasterList which is the first 
///                                   CSourcePhrase instance to be replaced (the originals 
///                                   are deleted, the replacments are inserted in the gap 
///                                   where they were located)
/// \param      nHowMany           -> the 1-based count of how many consecutive CSourcePhrase 
///                                   pointers are to be removed from pMasterList to make way 
///                                   for the replacements; this value must not be zero
/// \param      pReplacementsList  -> pointer to the list from which all or a subrange of 
///                                   replacement CSourcePhrase instances are to be inserted 
///                                   where the originals were removed from in pMasterList
/// \param      nReplaceStartAt    -> 0-based index into pReplacementsList which locates the 
///                                   first CSourcePhrase instance which is to be inserted 
///                                   into pMasterList
/// \param      nReplaceCount      -> 1-based count of how many consecutive CSourcePhrase 
///                                   pointers are to be inserted into pMasterList. 
///                                   (nReplaceCount can be less, equal, or greater than 
///                                   nHowMany.) Note: this value can be zero, in which
///                                   case no insertions are done, but the deletions are done
/// \remarks
/// Called from: the View's RestoreDocAfterSrcTextEditModifiedIt(), OnEditSourceText(),
/// OnCustomEventAdaptationsEdit(), OnCustomEventGlossesEdit(),
/// This is a utility function for clearing out a span of CSourcePhrase instances from a
/// list and replacing them with a different span taken from some part (or the whole) of
/// some other list.
/// The ones cleared out are deleted (their contents are lost), the ones inserted are then
/// managed by the pMasterList, and usually that list is persistent, and the
/// pReplacementsList is temporary, but neither assumption is necessary or assumed. The
/// contents of pReplacementsList are not altered; so what actually are inserted are deep
/// copies of the instances in pReplacementsList. The nHowMany and nReplaceCount parameters
/// must not both be zero, if that is the case, it is an error.
/// 
/// The nReplaceCount value can be zero, if it is, the function is just being used to
/// delete a range of CSourcePhrase instances within a list.
/// The nHowMany value can be zero, if it is, the function is just being used to insert a
/// range of CSourcePhrase instances within a list, preceding the nStartAt instance's
/// location. BEW added to, 19Jun09. If some replacements are to be done at the doc end
/// (eg. after an edit which removed some words, and it goes belly up and the code tries to
/// restore original doc, calling this function) then nStartAt will be just beyond the
/// current end of the document. The older code did not test for this and then the
/// Item(nStartAt) produced a crash. The fix is to test for this bounds error, and send
/// control to a block of code which merely appends the replacements, rather than trying to
/// do insertions.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ReplaceCSourcePhrasesInSpan(SPList* pMasterList, int nStartAt, int nHowMany,
					SPList* pReplacementsList, int nReplaceStartAt, int nReplaceCount)
{
	// 26May08	function created as part of refactoring the Edit Source Text functionality
	// whm note: Bruce has this function in helpers.h and .cpp, but it is only used in the
	// View so I moved it to the View.
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	SPList::Node* posMaster = NULL; //POSITION posMaster = NULL;
	SPList::Node* posReplace = NULL; //POSITION posReplace = NULL;
	wxString error;
    // do nothing if either list has no elements, or if nothing; treat it as an error state
	if (pMasterList->GetCount() == 0)
		return FALSE;
	if (pReplacementsList->GetCount() == 0)
		return FALSE;
	if (nHowMany == 0 && nReplaceCount == 0)
		return FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pReplaceSrcPhrase = NULL;
	CSourcePhrase* pDeepCopiedSrcPhrase = NULL;

	int maxIndex = pApp->GetMaxIndex();
	if (nStartAt > maxIndex)
	{
		// just append the replacements
		posReplace = pReplacementsList->Item(nReplaceStartAt);
		int anIndex;
		SPList::Node* pos2 = NULL;
		int endAt = nReplaceStartAt + nReplaceCount -1;
		for (anIndex = nReplaceStartAt; anIndex <= endAt; anIndex++)
		{
			pReplaceSrcPhrase = posReplace->GetData();
			posReplace = posReplace->GetNext();
			pDeepCopiedSrcPhrase = new CSourcePhrase(*pReplaceSrcPhrase);
			pDeepCopiedSrcPhrase->DeepCopy(); // make the deep copy
			wxASSERT(pDeepCopiedSrcPhrase != NULL);
			// add each deep copy to the end of the master list
			pos2 = pMasterList->Append(pDeepCopiedSrcPhrase); 
			pDoc->CreatePartnerPile(pDeepCopiedSrcPhrase);
		}
		return TRUE;
	}
	else
	{
		posMaster = pMasterList->Item(nStartAt);
		if (posMaster == NULL)
		{
			// whm note: I don't think this error needs to be translated for localization
			// an unexpected exception, so inform the caller & advise the user of the error
			error = _T(
"FindIndex() failed in helper function ReplaceCSourcePhrasesInSpan(), posMaster value is NULL. ");
			error += _T("Abandoning current operation.");
			error += _T(" (If restoring document's original state, it is not properly restored.");
			wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
			return FALSE;
		}
	}
	posReplace = pReplacementsList->Item(nReplaceStartAt);
	if (posMaster == NULL)
	{
		// whm note: I don't think this error need to be translated for localization
		// an unexpected exception, so inform the caller & advise the user of the error
		error = _T(
"FindIndex() failed in helper function ReplaceCSourcePhrasesInSpan(), posReplace value is NULL. ");
		error += _T("Abandoning current operation.");
		error += _T(" (If restoring document's original state, it is not properly restored.");
		wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

	// First delete the old (ie. unwanted) instances from the main list
	SPList::Node* posSaved = NULL;
	SPList::Node* pos2 = NULL;
	int index;

	// special case 1: only insertions are wanted, no deletions
	if (nHowMany == 0)
	{
		// insertion is wanted, preceding posMaster location
ins:	;
#ifdef _DEBUG
		//SPList::Node* posDebug = pMasterList->GetFirst();
		//for (index = 0; index < (int)pMasterList->GetCount(); index++)
		//{
		//	CSourcePhrase* pSrcPh;
		//	pSrcPh = posDebug->GetData();
		//	posDebug = posDebug->GetNext();
		//	wxLogDebug(_T("pMasterList BEFORE Insert: pSrcPh->m_srcPhrase = %s"),
		//	pSrcPh->m_srcPhrase.c_str());
		//}
#endif

		for (index = 0; index < nReplaceCount; index++)
		{
			// insert them in normal order, each preceding the posMaster POSITION
			pReplaceSrcPhrase = posReplace->GetData();
			posReplace = posReplace->GetNext();
			pDeepCopiedSrcPhrase = new CSourcePhrase(*pReplaceSrcPhrase);
			pDeepCopiedSrcPhrase->DeepCopy(); // make the deep copy
			wxASSERT(pDeepCopiedSrcPhrase != NULL);
			// insert each deep copy before the posMaster location each time
			pos2 = pMasterList->Insert(posMaster, pDeepCopiedSrcPhrase); 

			// BEW added 13Mar09 for refactored layout
			pDoc->CreatePartnerPile(pDeepCopiedSrcPhrase); // also marks its or a
														// nearby strip as invalid

			// break out of loop if we have come to the end of the replacements list
			if (pReplaceSrcPhrase == NULL)
				break;
		}
#ifdef _DEBUG
		//posDebug = pMasterList->GetFirst();
		//for (index = 0; index < (int)pMasterList->GetCount(); index++)
		//{
		//	CSourcePhrase* pSrcPh;
		//	pSrcPh = posDebug->GetData();
		//	posDebug = posDebug->GetNext();
		//	wxLogDebug(_T("pMasterList AFTER Insert: pSrcPh->m_srcPhrase = %s"),
		//	pSrcPh->m_srcPhrase.c_str());
		//}
#endif
		return TRUE;
	}
	else
	{
		// nHowMany is not zero, so deletions are wanted
		if (nReplaceCount == 0)
		{
			// no insertions are wanted, so only the deletions - which have already
			// been done, so return TRUE
			return TRUE;
		}
		else
		{
			// delete the non-empty range of originals from pMasterList
			for (index = 0; index < nHowMany; index++)
			{
				posSaved = posMaster;
				wxASSERT(posSaved);
				pSrcPhrase = posMaster->GetData(); // assume success
				posMaster = posMaster->GetNext();
				pApp->GetDocument()->DeleteSingleSrcPhrase(pSrcPhrase); // delete pSrcPhrase
					// and its elements from memory locations; also calls DeletePartnerPile()
				pMasterList->DeleteNode(posSaved);	// delete the list's pSrcPhrase element
				// break out of the loop if we have come to the end of the pMasterList
				if (posMaster == NULL)
					break;
			}

			// now insert the non-empty range of replacements at the same location
			if (nStartAt == (int)pMasterList->GetCount())
			{
                // there is no CSourcePhrase instance now at the nStartAt value, because we
                // deleted right to the end of the master list inclusively, so we only need
                // append each to the tail of the pMasterList
				for (index = 0; index < nReplaceCount; index++)
				{
					// get a deep copy
					pReplaceSrcPhrase = posReplace->GetData();
					posReplace = posReplace->GetNext();
					pDeepCopiedSrcPhrase = new CSourcePhrase(*pReplaceSrcPhrase);
					pDeepCopiedSrcPhrase->DeepCopy(); // make the deep copy
					wxASSERT(pDeepCopiedSrcPhrase != NULL);
					// append each deep copy to the master list
					pos2 = pMasterList->Append(pDeepCopiedSrcPhrase);

					// BEW added 13Mar09 for refactored layout
					pDoc->CreatePartnerPile(pDeepCopiedSrcPhrase); // also marks the owning
													// strip, or a nearby one, as invalid

					// break out of loop if we have come to the end of the replacements list
					if (pReplaceSrcPhrase == NULL)
						break;
				}
			}
			else
			{
                // there is a CSourcePhrase instance at the nStartAt location, it has moved
                // down to occupy the location from which the earlier deletions were
                // started, so we must now insert before it
				posMaster = pMasterList->Item(nStartAt);
				if (posMaster == NULL)
				{
					// an unexpected exception, so inform the caller & advise the user of 
					// the error
					error = _T(
			"FindIndex() failed in helper function ReplaceCSourcePhrasesInSpan(), ");
					error += _T(
			"posMaster value is NULL when finding the POSITION of first CSourcePhrase ");
					error += _T("following the gap. Abandoning current operation.");
					error += _T(
			" (If restoring document's original state, it is not properly restored.");
					wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
					return FALSE;
				}
				goto ins;
			}
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     Return TRUE if there was no error, FALSE for an error (such 
///             as a bounds error) 
/// \param      pList          -> pointer to a list of source phrases
/// \param      nStartLoc      -> starting
/// \param      nFoundAt       <- receives the index value of the next note found, 
///                               or -1 if none found
/// \param      bFindForwards  -> the direction in which to search for notes
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// This function is used in the vertical edit process, when restoring removed notes after
/// a source text edit. It finds the index value in pList at which the next Note is found,
/// either forwards (or at the current location), or backwards, and return it in nFoundAt,
/// or return -1 in nFoundAt if no note was found in the nominated direction.
/// Note: while typically used with pList set to the app's m_pSourcePhrases list, in which
/// the list indices always match the stored m_nSequNumber value in each POSITION's
/// CSourcePhrase instance, the function can be used for arbitrary sublists of
/// CSourcePhrase instances because it returns the stored m_nSequNumber value for the found
/// note in the CSourcePhrase which stores it, not the index value in pList at which that
/// CSourcePhrase was located.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::FindNote(SPList* pList, int nStartLoc, int& nFoundAt, bool bFindForwards)
{
	// BEW created 29May08
	wxString errStr;
	// BEW changed 19Jun09, because of the possibility of editing resulting in the loss of
	// data from the end of the document, we need to be smarter than just check for bounds
	// errors using pre-edit index values, instead, we will test and adjust to get the
	// closest valid location and search from there
	int count = (int)pList->GetCount();
	if (nStartLoc < 0)
		nStartLoc = 0;
	if (nStartLoc >= count)
	{
		nStartLoc = count - 1;
	}
	CSourcePhrase* pSrcPhrase = NULL;
	wxString strSFM = _T("\\note");
	SPList::Node* pos = pList->Item(nStartLoc);
	int offset = -1;
	if (pos == NULL)
	{
		// unexpected error, the location should be findable
		errStr = _T(
		"Error in helper function FindNote(); the POSITION value returned from ");
		errStr += _T(
		"FindIndex() was null. The current operation will be abandoned.");
		wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	if (bFindForwards)
	{
		// examine the starting location first
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		offset = pSrcPhrase->m_markers.Find(strSFM);
		if (offset >= 0)
		{
			// there is one at the current location
			nFoundAt = pSrcPhrase->m_nSequNumber;
			return TRUE;
		}
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			offset = pSrcPhrase->m_markers.Find(strSFM);
			if (offset >= 0)
			{
				// there is one at the current POSITION
				nFoundAt = pSrcPhrase->m_nSequNumber;
				return TRUE;
			}
		}
	}
	else
	{
		// ignore the starting location
		pSrcPhrase = pos->GetData();
		pos = pos->GetPrevious();
		// search from the preceding location, backwards
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetPrevious();
			offset = pSrcPhrase->m_markers.Find(strSFM);
			if (offset >= 0)
			{
				// there is one at the current POSITION
				nFoundAt = pSrcPhrase->m_nSequNumber;
				return TRUE;
			}
		}
	}
	// none was found, so return -1
	nFoundAt = -1;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if successful, FALSE if the move could not be done
/// \param      pLocationsList  -> an array of consecutive sequence numbers where 
///                                (squeezed) Notes will be reconstituted (because they
///                                would not fit in the new edit span)
/// \param      nLeftBoundSN    -> enables us to detect when leftwards movement is 
///                                no longer possible, and FALSE is returned
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// Moves a note to the left one place.
/// pLocationsList is an array of consecutive sequence numbers where (squeezed) Notes will
/// be reconstituted (because they would not fit in the new edit span), and the caller has
/// determined that the next consecutive location in the document would be a right bound
/// (that is, a non-removed note already is there) and so the location about to be added to
/// the squeezed array can't be used. In this circumstances, we need to call this function
/// to move all the locations in the pLocationsList one place leftwards (ie. decrease the
/// stored indices by one) in order to open a gap between the last stored index and the
/// right bound location so that the next note location can be added as the gap location.
/// This works, as often as necessary, unless the stored index values come to the left
/// bound (which is either the start of the document, or an unremoved note's location lying
/// to the left of the edit span). The nLeftBoundSN enables us to detect when leftwards
/// movement is no longer possible, and FALSE is returned. A successful leftwards movement
/// returns TRUE.
/// (If all the locations between left and right bounds are used up and still there are
/// notes to be placed, the caller will attempt to move the note which is the right bound
/// to the right to create the needed gaps.)
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::MoveNoteLocationsLeftwardsOnce(wxArrayInt* pLocationsList, 
												   int nLeftBoundSN)
{
	// BEW added 30May08 in support of the source text editing step of the 
	// vertical editing process
	int aSequNum;
	// get the first sequence number index from the list
	aSequNum = (*pLocationsList)[0];
	// if there is a gap between it and the left bound, then shift all the values one
	// place to the left and return TRUE, otherwise do not shift and return FALSE
	if (nLeftBoundSN + 1 < aSequNum)
	{
		// a gap exists, so leftshift
		int count = pLocationsList->GetCount();
		int i;
		int value;
		for (i=0;i<count;i++)
		{
			value = (*pLocationsList)[i];
			(*pLocationsList)[i] = value - 1;
		}
		return TRUE;
	}
	// the attempt was unsuccessful
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if successful, FALSE if the move could not be done
/// \param      pSrcPhrases  -> the app's m_pSourcePhrases list
/// \param      nNoteSN      -> the sequence number index for the CSourcePhrase 
///                             which stores the Note which we want to move 
///                             rightwards to the next CSourcePhrase
/// \remarks
/// Called from: the View's ShiftASeriesOfConsecutiveNotesRightwardsOnce().
/// Moves a note to the right one place.
/// The move can be done only if not at the end of the document, and provided the next 
/// CSourcePhrase does not already store a different Note.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ShiftANoteRightwardsOnce(SPList* pSrcPhrases, int nNoteSN)
{
	// BEW added 30May08 in support of the source text editing step of the 
	// vertical editing process
	SPList::Node* pos = pSrcPhrases->Item(nNoteSN);
	wxString strSFM = _T("\\note");
	CSourcePhrase* pOriginalSrcPhrase = pos->GetData();
	pos = pos->GetNext();
	// check the original src phrase actually has a note
	bool bOriginalHasANote = IsNoteStoredHere(pSrcPhrases, nNoteSN);
	if (!bOriginalHasANote)
	{
		// no note at the passed in location
		return FALSE;
	}
	// check there is a following CSourcePhrase instance 
	if (pos == NULL)
	{
		// we are at the end of the document, so no destination CSourcePhrase exists
		return FALSE;
	}
	// check there is no note on the following CSourcePhrase instance, 
	// if there is, we can't shift the note to this instance
	CSourcePhrase* pDestSrcPhrase = pos->GetData(); // MFC used GetAt(pos);
	wxASSERT(pDestSrcPhrase != NULL);
	int offset = -1;
	offset = pDestSrcPhrase->m_markers.Find(strSFM);
	if (offset != -1)
	{
		// it contains a note already, so we can't move another to here
		return FALSE;
	}
	// the shift is possible, so do it
	MoveNote(pOriginalSrcPhrase,pDestSrcPhrase);
	// mark the one or both owning strips invalid
	GetDocument()->ResetPartnerPileWidth(pOriginalSrcPhrase); // mark its strip invalid
	GetDocument()->ResetPartnerPileWidth(pDestSrcPhrase); // mark its strip invalid
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if a note exists there, FALSE if not
/// \param      pSrcPhrases  -> the app's m_pSourcePhrases list
/// \param      nNoteSN      -> the sequence number index for the CSourcePhrase 
///                             which we want to know whether or not it stores a Note
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// Determines is a Note is stored at nNoteSN location in the pSrcPhrases list.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsNoteStoredHere(SPList* pSrcPhrases, int nNoteSN)
{
    // BEW added 30May08 in support of the source text editing step of the 
    // vertical editing process
    // BEW changed 19Jun09, because editing may have removed some of doc's end, including
    // one or more notes, and we can't just take the note's old sequence number and assume
    // that still corresponds to a position within the edited document; so I think the
    // thing to do is to test for nNoteSN beyond doc end, and just return FALSE - the
    // caller should not call IsNoteStoredHere if nNoteSN is beyond the doc end, but we
    // better allow for it and code defensively
	int maxIndex = pSrcPhrases->GetCount() -1;
	if (nNoteSN > maxIndex)
		return FALSE; // beyond document's end, so certainly can't store a note there!!
	SPList::Node* pos = pSrcPhrases->Item(nNoteSN);
	wxString strSFM = _T("\\note");
	CSourcePhrase* pSrcPhrase = pos->GetData();
	pos = pos->GetNext();
	// check if the src phrase has a note, return FALSE if it hasn't got one, 
	// TRUE if it has
	int offset = -1;
	offset = pSrcPhrase->m_markers.Find(strSFM);
	if (offset == -1)
	{
		// no Note stored here
		return FALSE;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if successful, FALSE if the moves could not be done
/// \param      pSrcPhrases  -> the app's m_pSourcePhrases list
/// \param      nFirstNoteSN -> the sequence number index for the CSourcePhrase which stores 
///                             the first Note of the consecutive series which we want to 
///                             move rightwards one location
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// Moves a series of consecutive notes to the right during source text editing.
/// The move can be done only if not at the end of the document, and provided there is a 
/// CSourcePhrase without a Note after the consecutive series ends. The function can be 
/// used even when the location passed in is the only one which has a stored Note.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ShiftASeriesOfConsecutiveNotesRightwardsOnce(SPList* pSrcPhrases, 
																 int nFirstNoteSN)
{
	// refactored 7Apr09 - only needed GetMaxIndex() call
    // BEW added 30May08 in support of the source text editing step of the vertical editing
    // process first compile an array of consecutive note locations which need to be
    // shifted right and return FALSE if we come to the end of the document without finding
    // a CSourcePhrase instance which lacks a note (and which could otherwise have accepted
    // a moved Note)
	CAdapt_ItApp* pApp = &wxGetApp();
	wxArrayInt locationsArr;
	int locIndex = nFirstNoteSN;
	bool bHasNote = FALSE;
	int anArrayIndex = -1;
	while (TRUE)
	{
		anArrayIndex++;
		if (locIndex > pApp->GetMaxIndex())
		{
			// we've passed the end of the document without finding a location
			// that does not have a note, so we cannot succeed
			return FALSE;
		}
		bHasNote = IsNoteStoredHere(pSrcPhrases,locIndex);
		if (bHasNote)
		{
			// insert into the array of noted locations and iterate
			//
			//locationsArr.SetAtGrow(anArrayIndex,locIndex);
            // whm Note: wxArrayInt doesn't have MFC's SetAtGrow() method, but we can
            // accomplish the same thing. We can use the ::SetCount() method of wxArray to
            // insure the array has at least anArrayIndex + 1 elements, then assign
            // locIndex to element anArrayIndex. We only call SetCount() if the array is
            // too small. The MFC docs for CAtlArray::SetAtGrow say SetAtGrow does the same
            // thing, "If iElement is larger than the current size of the array, the array
            // is automatically increased using a call to CAtrArray::SetCount."
			if (anArrayIndex+1 > (int)locationsArr.GetCount())
				locationsArr.SetCount(anArrayIndex+1); // any added elements to the array 
													   // are assigned int(0) by default
			locationsArr[anArrayIndex] = locIndex;
			locIndex++;
		}
		else
		{
			// the CSourcePhrase at this locIndex value does not have a Note
			// so we have found an instance that will permit right-shifting all
			// the consecutive noted locations in the array
			break;
		}
	}
	// now iterate backwards across the array of stored locations, moving the
	// note on each one rightwards once
	int nHowMany = locationsArr.GetCount();
	int aSequNum;
	bool bShiftedOK;
	for (anArrayIndex = nHowMany - 1; anArrayIndex >= 0; anArrayIndex--)
	{
		aSequNum = locationsArr[anArrayIndex];
		bShiftedOK = ShiftANoteRightwardsOnce(pSrcPhrases, aSequNum);
		wxASSERT(bShiftedOK); // this should not have failed
	}
	// success, the passed in nFirstNoteSN location is not a 'gap' as far
	// as stored Notes are concerned
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the Note was successfully created and stored as filtered info, 
///             FALSE if there was failure
/// \param      pSrcPhrases  -> the app's m_pSourcePhrases list
/// \param      nLocationSN  -> the location where the note is to be created
/// \param      strNote      -> the text of the note
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// Creates a filtered note on the CSourcePhrase instance in pSrcPhrases which has location
/// nLocationSN for the sequence number. It is the caller's responsibility to ensure there
/// is no note already present there.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::CreateNoteAtLocation(SPList* pSrcPhrases, int nLocationSN, 
										 wxString& strNote)
{
	// refactored 7Apr09 - only needed GetMaxIndex() call
    // pSrcPhrases has to be the m_pSourcePhrases list, or a list of CSourcePhrase
    // instances where the list index stays in synch with the stored m_nSequNumber value in
    // each CSourcePhrase instance of the list, for this function to work right
    // BEW changed 19Jun09, the caller should refrain from calling this if nLocationSN is
    // beyond the end of the document (ie. the user's editing resulted in the end of the
    // document being removed, and a note or so, and so we must assume those are not
    // wanted), but because this might get called in such a circumstance, we should code
    // defensively and return FALSE so that bailout can be done instead
	CAdapt_ItApp* pApp = &wxGetApp();
	wxString noteMkr = _T("\\note");
	wxString noteEndMkr = noteMkr + _T('*');
	if (nLocationSN > pApp->GetMaxIndex())
		return FALSE;
	bool bHasNote = IsNoteStoredHere(pSrcPhrases, nLocationSN);
	if (bHasNote)
	{
		// this location has a Note already, (the caller should have checked for
		// this and not made the call)
		wxString errStr = _T(
		"There is already a Note at the passed in index, in CreateNoteAtLocation.");
		wxMessageBox(errStr, _T(""), wxICON_WARNING);
		return FALSE;
	}
	else
	{
		// there is no Note at that location, so go ahead and create it there
		CSourcePhrase* pToSrcPhrase = NULL;
		SPList::Node* pos = pSrcPhrases->Item(nLocationSN);
		wxASSERT(pos != NULL);
		pToSrcPhrase = pos->GetData(); // MFC has GetAt(pos)
		int nInsertionOffset = FindFilteredInsertionLocation(pToSrcPhrase->m_markers,noteMkr);
		bool bInsertContentOnly = FALSE; // need the whole lot done, 
										 // including wrapping filter markers
		InsertFilteredMaterial(noteMkr,noteEndMkr,strNote,pToSrcPhrase,
								nInsertionOffset,bInsertContentOnly);
		pToSrcPhrase->m_bHasNote = TRUE;
		// mark its owning strip as invalid
		GetDocument()->ResetPartnerPileWidth(pToSrcPhrase);
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if all Notes were relocated, FALSE if not
/// \param      nStartOfEditSpan -> 
/// \param      nEditSpanCount   -> 
/// \param      pUnsqueezedArr   <- 
/// \param      pSqueezedArr     <- 
/// \param      nRightBound      -> is used to make sure that when locating notes
///                                 consecutively, we don't transgress the bound and so
///                                 cause a note reordering
/// \remarks
/// Called from: the View's RestoreNotesAfterSourceTextEdit().
/// This is sort of like a leftwards version of
/// ShiftASeriesOfConsecutiveNotesRightwardsOnce() but with some important differences. 
/// 1. It doesn't relocate notes, it just decrements note locations stored in the passed in
/// pLocationsList.
/// 2. The locations it operates on are not necessarily consecutive, because this function
/// is intended to work with the "unsqueezed" array (ie. as many note locations as possible
/// kept the same as they were before the edit of source text was commenced), and the idea
/// is to start with locations at the end of the array and try to create a gap by moving
/// the last leftwards one location, creating a gap. This iterative decrementing of the
/// final location index may eventually bump up against a previous note's location also
/// stored in the array, and if that is the case, then both those locations get moved left
/// one location, creating a gap. Ultimately, if there are enough removed Notes to be
/// replaced, all the stored locations might have been closed up leftwards to be
/// consecutive after the first one - if that happens, and more gaps are needed, then the
/// whole lot are decremented by one, -- that process can happen only so long as the first
/// index in the list is greater in value than the passed in nStartOfEditSpan index value.
/// We won't move the locations to precede the final edit span, but if we get to the point
/// where we still need gaps, we'll try relocating the remainder in the following context,
/// and if necessary, they can be created by moving real notes in the following context
/// rightwards. If not all could be relocated, we will return FALSE to the caller and with
/// the pSqueezedArr still containing unlocated stored indices for the Notes unable to be
/// relocated by this function. The caller can then try moving unremoved Notes rightwards
/// to make more gaps, and if that can't get enough, the remainder of the Notes text's will
/// be stored in the top of the removed free translations list. So, return TRUE if all were
/// relocated, FALSE if not. A second scenario is that there are no entries in the
/// "unsqueezed" array, so that all the entries are in the squeezed array, with unchanged
/// values, put there by the caller. When this is the case, the function will relocate them
/// consecutively from the start of the following context to the start of the edit span;
/// because we want removals (which are all done from within the old edit span) to be
/// reconstituted within the new bounds of the edit span after the user's edit is done. The
/// nRightBound parameter is the location of the first unremoved note in the following
/// context, or if there are none, then the location of the last CSourcePhrase
/// in the document. The nRightBound value is used to make sure that when locating notes
/// consecutively, we don't transgress the bound and so cause a note reordering. If we come
/// to this bound, we'll return to the caller to let the above algorithm for placing the
/// remainder do its job.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::BunchUpUnsqueezedLocationsLeftwardsFromEndByOnePlace(int nStartOfEditSpan, 
									int nEditSpanCount, wxArrayInt* pUnsqueezedArr, 
									wxArrayInt* pSqueezedArr, int WXUNUSED(nRightBound))
{
	// BEW added 30May08 in support of the source text editing step of the 
	// vertical editing process
    // **** Note: in this function, the capital letter pair SN used in variable naming is
    //     an acronym for 'sequence number', that is, the variable for which it is a part
    //     of its name is an index value into the document's list, m_pSourcePhrases, which
    //     stores CSourcePhrase instances ****

	wxASSERT(nEditSpanCount > 0); // == 0 case should have been dealt with in the caller
	int nNumInSqueezedArray = pSqueezedArr->GetCount();
	wxASSERT(nNumInSqueezedArray != 0); // the function should never be called if there is
									    // nothing needing to be relocated by it
	int aNoteSN = 0; // whm: I've initialized it here to prevent warning, 
					 // but see its use below
	int index;
	int nEditSpanEndLoc = nStartOfEditSpan + nEditSpanCount - 1;
	int nLastLocInUnsqueezedArr;
	int nNumInUnsqueezedArray = pUnsqueezedArr->GetCount();
	if (nNumInUnsqueezedArray == 0)
	{
        // nothing was relocated within the edit span, so the location indices are in the
        // "squeezed" array and unlocated as yet ('unlocated' means they have their old,
        // invalid, sequence numbers unchanged as yet, but are at least in the squeezed
        // array); and the new edit span has at least one CSourcePhrase instance in it.
        // We'll just locate them consecutively within the edit span, rightwards so that
        // the last to be relocated is at the end of the edit span - if if necessary
        // starting the sequence from the start of the edit span, but no earlier; so if any
        // are still are unrelocated at that stage, we return FALSE to the caller so that
        // the caller can handle those that remain (which didn't fit within the span)
		if (nNumInSqueezedArray > nEditSpanCount)
		{
			// not all will fit, so relocate starting from nStartOfEditSpan index value,
			//as many as will fit
			for (index = 0; index < nEditSpanCount; index++)
			{
				pSqueezedArr->RemoveAt(0);
				// create an alternative location for that location just removed
				aNoteSN = nStartOfEditSpan + index;
                // whm note: wxArrayInt's Insert method reverses the parameters! Caution:
                // wx docs also says of wxArray::Insert() "Insert the given number of
                // copies of the item into the array before the existing item n. This
                // resulted in incorrect ordering of source phrases, so we use array[] =
                // assignment notation instead. Bruce's note indicates that it is going to
                // "insert at the array's end", so to be safe we insure that the array has
                // at least nNumInUnsqueezedArray elements by calling SetCount()
				if (nNumInUnsqueezedArray+1 > (int)pUnsqueezedArr->GetCount())
					pUnsqueezedArr->SetCount(nNumInUnsqueezedArray+1);
				(*pUnsqueezedArr)[nNumInUnsqueezedArray] = aNoteSN; // insert at the array's end
				nNumInUnsqueezedArray = pUnsqueezedArr->GetCount(); // update its value
				nNumInSqueezedArray = pSqueezedArr->GetCount(); // update its value
			}
		}
		else
		{
            // all will fit, so relocate starting from wherever in the span will result in
            // them all being bunched up at the end of the span
			int nBeginAt = nEditSpanEndLoc - nNumInSqueezedArray + 1;
			int nHowManyToDo = nNumInSqueezedArray;
			for (index = 0; index < nHowManyToDo; index++)
			{
				pSqueezedArr->RemoveAt(0);
				// create an alternative location for that location just removed
				aNoteSN = nBeginAt + index;
				// whm: See note in block above
				if (nNumInUnsqueezedArray+1 > (int)pUnsqueezedArr->GetCount())
					pUnsqueezedArr->SetCount(nNumInUnsqueezedArray+1);
				(*pUnsqueezedArr)[nNumInUnsqueezedArray] = aNoteSN; // insert at the array's end
				nNumInUnsqueezedArray = pUnsqueezedArr->GetCount(); // update its value
				nNumInSqueezedArray = pSqueezedArr->GetCount(); // update its value
				if (nNumInSqueezedArray == 0)
				{
					return TRUE; // success, all are relocated now within the final edit span
				}
			}
		}
        // if control gets here, then there is still at least one unrelocated index
        // remaining in pSqueezedArr, in which case we'll return FALSE and let the caller
        // deal with what remains
		return FALSE;
	}
	else
	{
        // there is at least one replacement location within the edit span; this suggests
        // that the edit span may be large enough for the ones which didn't fit within the
        // span resulting from the user's edit to be squeezed in there at its end, so now
        // we attempt to do that, leftshifting as necessary.
		nLastLocInUnsqueezedArr = (*pUnsqueezedArr)[nNumInUnsqueezedArray - 1];

        // find the number of locations in the gap betwen the last in the unsqueezed array,
        // and the end of the edit span - if we can place all of the ones in the squeezed
        // array there using successive locations, then do so; otherwise, we'll need to
        // uses a left-shifting strategy to open up gaps; anything we successfully relocate
        // will be added at the tail of the unsqueezed array and removed from the squeezed
        // array, so that the final content of the squeezed array is what remains to be
        // relocated somewhere
		int nNumberPossibleAtEnd = nEditSpanEndLoc - nLastLocInUnsqueezedArr; // size of 
																		// the gap there
		// if an end gap exists try to fill it to whatever extent is possible
		if (nNumberPossibleAtEnd > 0 )
		{
            // do as many as possible by filling the gap, and then exit the loop to use a
            // left-shifting strategy for as many of the remainders as possible - unless
            // there are no remainders in which case we are done
			for (index = 0; index < nNumberPossibleAtEnd; index++)
			{
				// remove the first of those remaining in the squeezed list
				pSqueezedArr->RemoveAt(0);
				// create an alternative location for that location just removed
				aNoteSN = nLastLocInUnsqueezedArr + 1 + index;
                // store it at the end of the unsqueezed array - (forming one or more
                // consecutive locations there, depending on how many iterations this loop
                // can do before it exits)
                // whm note: wxArrayInt's Insert method reverses the parameters! Caution:
                // wx docs also says of wxArray::Insert() "Insert the given number of
                // copies of the item into the array before the existing item n. This
                // resulted in incorrect ordering of source phrases, so we use array[] =
                // assignment notation instead. Bruce's note indicates that it is going to
                // "insert at the array's end", so to be safe we insure that the array has
                // at least nNumInUnsqueezedArray elements by calling SetCount()
				if (nNumInUnsqueezedArray+1 > (int)pUnsqueezedArr->GetCount())
					pUnsqueezedArr->SetCount(nNumInUnsqueezedArray+1);
				(*pUnsqueezedArr)[nNumInUnsqueezedArray] = aNoteSN;
				nNumInUnsqueezedArray = pUnsqueezedArr->GetCount(); // update its value
				nNumInSqueezedArray = pSqueezedArr->GetCount(); // update its value
				if (nNumInSqueezedArray == 0)
				{
					return TRUE; // success, all are relocated now within the final edit span
				}
			}
		}
        // If control gets here, we've more to locate, so use left-shifts to do it, at
        // least until the leftshifts bring the replacement locations to the start of the
        // final edit span - and if that happens we won't let leftshifting go any further,
        // but rather we exit and let the caller relocate those remaining in the squeezed
        // array by a filling strategy for the immediate context of CSourcePhrase instances
        // which follow the end of the final edit span
		wxASSERT(nNumInSqueezedArray > 0);
		int nNumberToRelocate = nNumInSqueezedArray;
		int nPotentialGapSN;
		int nBackIndex;
		int anUnsqueezedArrIndex;
		while(nNumberToRelocate > 0) // loop for how many times we have to try
		{
            // inner loop iterates backwards over the relocation SN values stored in the
            // unsqueezed array now, looking for gaps and leftshifting rightmost stored
            // values as necessary to create gaps
			for (anUnsqueezedArrIndex = 0; anUnsqueezedArrIndex < nNumInUnsqueezedArray; 
				anUnsqueezedArrIndex++)
			{
				nBackIndex = nNumInUnsqueezedArray - 1 - anUnsqueezedArrIndex; // indexing 
															// from the end of the array
				// find next gap
				nPotentialGapSN = (*pUnsqueezedArr)[nBackIndex] - 1; // subtract 1 from 
																	 // the stored value
				if (nPotentialGapSN < nStartOfEditSpan)
				{
					// we can't go back that far in SN values, so break out of loop, 
					// the caller must finish it
					return FALSE;
				}
                // we have not gone past the bounding nStartOfEditSpan sequ number value,
                // so the nPotentialGapSN value is still a potential gap; it won't be a gap
                // if the previously stored SN value in the pUnsqeezedArr has the same
                // value as nPotentialGapSN, in which case we keep iterating back over
                // stored values in the unsqueezed array; but if there is no previous
                // entry, we have come to the gap region (it could be empty) from the
                // nStartOfEditSpan value (inclusive) to the SN value immediately preceding
                // the first stored SN value in the pUnsqueezedArr array - where we can
                // shift left as often as we like provided no shifted stored SN value
                // becomes less than the nStartOfEditSpan. So we have to test for these
                // conditions etc.
  				if (nBackIndex == 0)
				{
                    // there isn't any earlier stored SN entry, so we've come to the region
                    // we potentially multiple leftshifts can be done, to create multiple
                    // gaps at the end of the list of leftshifted stored SN values; either
                    // we can do enough leftshifts in this code block to relocate those
                    // that remain in pSqueezedArr and return TRUE, or we do as many as
                    // possible here and return FALSE, so that the caller can handle the
                    // remainder -- either we control will return to the caller at the end
                    // of this code block
					int nVacantLocations = (*pUnsqueezedArr)[nBackIndex] - nStartOfEditSpan;
					if (nVacantLocations > 0 )
					{
                        // do as many as possible by leftshifting, and fill the gaps
                        // created at the end and then return TRUE or FALSE depending on
                        // whether or not all were handled
						int index3;
						int nDecrementBy;
						nNumInSqueezedArray = pSqueezedArr->GetCount(); // make sure the 
																		// value is uptodate
						if (nNumInSqueezedArray <= nVacantLocations)
						{
							// we can handle all of those that remain
							nDecrementBy = nNumInSqueezedArray;
							pSqueezedArr->Clear(); // abandon these, as we'll calculate new 
                                // loc'n values decrement the pUnsqueezedArr stored values
                                // so as to leftshift into the gap
							for (index3 = 0; index3 < nNumInUnsqueezedArray; index3++)
							{
								// decrement the unsqueezed array stored SN values, 
								// creating a gap at the end
								aNoteSN = (*pUnsqueezedArr)[index3]; // get next
								aNoteSN -= nDecrementBy; // decrement its stored value 
														 // by nDecrementBy
								(*pUnsqueezedArr)[index3] = aNoteSN; // restore the new value
																	 // at same index
							}
                            // the aNoteSN value on exit of the preceding loop is the last
                            // stored SN value, in pUnsqueezedArr, and so there are
                            // nDecrementBy locations available for creating the new
                            // consecutive entries required for handling the rest of the
                            // needed replacement locations not yet assigned
							int nNewSN;
							int nItsLocation;
							for (index3 = 0; index3 < nDecrementBy; index3++)
							{
                                // store the new ones at the end of the unsqueezed array
                                // whm Note: aNoteSN here is "potentially uninitialized
                                // local variable" I've initialized it at the top of this
                                // function to 0, but the logic should be checked. TODO:
								nNewSN = aNoteSN + 1 + index3; // the SN value to be stored
								nItsLocation = nNumInUnsqueezedArray + index3;
								// whm: See notes above on MFC's InsertAt vs wx Insert
								if (nItsLocation+1 > (int)pUnsqueezedArr->GetCount())
									pUnsqueezedArr->SetCount(nItsLocation+1);
								(*pUnsqueezedArr)[nItsLocation] = nNewSN;
							}
							return TRUE;
						}
						else
						{
							// we can handle only some of those that remain
							nDecrementBy = nVacantLocations;
                            // whm Note: the STL erase doesn't have a second parameter for
                            // number of removals, so we'll do it in a for loop
							int ct;
							for (ct = 0; ct < nDecrementBy; ct++)
								pSqueezedArr->RemoveAt(0);
                            // this many new loc'n values by decrementing all the
                            // pUnsqueezedArr stored values so as to leftshift into the
                            // this gap, and the remainder will be the caller's job
							for (index3 = 0; index3 < nNumInUnsqueezedArray; index3++)
							{
								// decrement the unsqueezed array stored SN values, 
								// creating a gap at the end
								aNoteSN = (*pUnsqueezedArr)[index3]; // get next
								aNoteSN -= nDecrementBy; // decrement its stored value 
														 // by nDecrementBy
								(*pUnsqueezedArr)[index3] = aNoteSN; // restore the 
														// new value at same index
							}
							// create and store the required new SN indices at the end 
							// of the edit span
							int nNewSN;
							int nItsLocation;
							for (index3 = 0; index3 < nDecrementBy; index3++)
							{
								// store the new ones at the end of the unsqueezed array
								nNewSN = aNoteSN + 1 + index3; // the SN value to be stored
								nItsLocation = nNumInUnsqueezedArray + index3;
								// whm: See notes above on MFC's InsertAt vs wx Insert
								if (nItsLocation+1 > (int)pUnsqueezedArr->GetCount())
									pUnsqueezedArr->SetCount(nItsLocation+1);
								(*pUnsqueezedArr)[nItsLocation] = nNewSN;
							}						
						}
						return FALSE;
					}
					else
					{
                        // the stored SN value at nBackIndex == 0 is already the value
                        // nStartOfEditSpan and so we can't relocate any more, so hand it
                        // back to the caller to do
						return FALSE;
					}
				} // end of block for loop end condition being satisfied, that is,
				  // nBackIndex having reached 0 with at least one more not yet relocated
				else
				{
                    // there is at least one earlier stored SN entry, so get it's value so
                    // we can compare it with the nPotentialGapSN value (reuse the aNoteSN
                    // variable for this purpose)
					aNoteSN = (*pUnsqueezedArr)[nBackIndex - 1];
					if (aNoteSN < nPotentialGapSN)
					{
                        // nPotentialGapSN is a genuine gap, so we can leftshift entry
                        // values by one to fill this gap, and then we can fill the opened
                        // gap at the nEditSpanEndLoc SN value by removing the next first
                        // element from the pSqueezedArr array, and storing a
                        // nEditSpanEndLoc as the new relation value for it in the tail of
                        // the pUnsqueezedArr array; then adjust the appropriate values to
                        // comply, and then iterate the outer loop
						int index2;
						for (index2 = nNumInUnsqueezedArray - 1; index2 >= nBackIndex; index2--)
						{
                            // decrement by 1 the stored values at the end of the
                            // unsqueezed array (aNoteSN can be reused here for this too
							aNoteSN = (*pUnsqueezedArr)[index2];
							aNoteSN--; // decrement it, leftshifting thereby by 1
							(*pUnsqueezedArr)[index2] = aNoteSN; // overwrite with the 
																 // decremented SN value
						}
                        // now we have a 'gap' at the sequence number nEditSpanEndLoc which
                        // we can use for the next so-far-unrelocated Note index, so do the
                        // relocation etc
						pSqueezedArr->RemoveAt(0); // chuck this one
                        // whm note: wxArrayInt's Insert method reverses the parameters!
                        // Caution: wx docs also says of wxArray::Insert() "Insert the
                        // given number of copies of the item into the array before the
                        // existing item n. This resulted in incorrect ordering of source
                        // phrases, so we use array[] = assignment notation instead.
                        // Bruce's note indicates that it is going to "insert at the
                        // array's end", so to be safe we insure that the array has at
                        // least nNumInUnsqueezedArray elements by calling SetCount()
						if (nNumInUnsqueezedArray+1 > (int)pUnsqueezedArr->GetCount())
							pUnsqueezedArr->SetCount(nNumInUnsqueezedArray+1);
						(*pUnsqueezedArr)[nNumInUnsqueezedArray] = nEditSpanEndLoc; // store 
																// the relocation sequ number
						nNumInUnsqueezedArray = pUnsqueezedArr->GetCount(); // update size
						nNumInSqueezedArray = pSqueezedArr->GetCount(); // update size
						nNumberToRelocate--; // decrement the count of how many remain to be
											 // handled by the outer loop
						break; // iterate in the outer loop
					}
					else
					{
                        // aNoteSN must equal nPotentialGapSN, so these entries are
                        // consecutive, so keep iterating the inner loop to look for a gap
                        // into which we can leftshift
						continue;
					}
				} // end of the test for whether or not there is an earlier stored 
				  // SN value preceding the currently accessed one
			} // end of inner loop
		} // end of outer loop
	}
	return FALSE; // we didn't manage to relocate them all, caller can do the rest
}

/////////////////////////////////////////////////////////////////////////////////
///	GetMarkerArrayFromString	
///
///	Returns:	a CString containing one or more whole markers (ie. including 
///                backslash) and each with a delimiting single space following it,
///                including the last
///	Parameters:
///		pStrArr	<-	populated with CStrings, each being a whole marker 
///		            (no delimiting space)
///		str		->	ref to the string containing a mix of markers and text (e.g.
///                 SFM marked up source text) from which the whole markers are
///                 to be found and inserted into the aray returned to the caller
///	Comments:
///    Extracts an array of whole markers, in order of occurrence (not sorted). There might
///    not be might not be any SF markers in the passed in str, in which case an empty
///    array is returned. The array's initial size (0) and growby value (1) are set first
///    here before it is populated. We are not interested in preventing multiple identical
///    entries because the function that will use the returned array is interested only in
///    the unique markers, and works whether there are repeats or not. (Used by the
///    AreMarkerArraysDifferent() helper function, which is used in the Edit Source Text
///    refactored code (see OnEditSourceText()) to detect when the user has modified a
///    marker when doing his edit - such as when correcting a misspelled marker to be what
///    it should be.)
///	History:
///	Created 17June08 by BEW, for support of refactored Source Text Edit functionality
///
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::GetMarkerArrayFromString(wxArrayString* pStrArr, const wxString& str)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	pStrArr->Clear();
	wxString aMarker;
	wxString s(str); // we'll modify only this local copy
	int offset = 0;
	wxChar backslash = _T('\\');
	offset = FindFromPos(s,backslash,offset);
	if (offset == -1)
		return;
	int index = 0;
	while (offset != -1)
	{
		s = s.Mid(offset); // point at the backslash of the marker
		aMarker = pDoc->GetWholeMarker(s);
		// insert in the array
		// whm Note: wxArrayInt doesn't have MFC's SetAtGrow() method, but we can 
		// accomplish the same thing. We can use the ::SetCount() method of wxArray to 
		// insure the array has at least anArrayIndex + 1 elements, then assign locIndex 
		// to element anArrayIndex. We only call SetCount() if the array is too small. 
		if (index+1 > (int)pStrArr->GetCount())
			pStrArr->SetCount(index+1); // any added elements to the array are assigned 
										// int(0) by default
		(*pStrArr)[index] = aMarker;
		// point past the backslash & get the offset to the next marker
		offset++;
		offset = FindFromPos(s,backslash,offset);
		index++;
	}
}

/////////////////////////////////////////////////////////////////////////////////
///
///	IsMarkerInArray	
///
///	Returns:	TRUE if the array contains at least one instance of the whole marker 
///	            being tested, FALSE if the marker is absent from the array, or the 
///	            array is empty
///	
///	\param	pStrArr	->	populated with CStrings, each being a whole marker (no 
///                     delimiting space), derived from a string containing a mix of
///                     markers and their text content
///	\param	marker	->	a SF marker, including initial backslash, and with no  
///		                delimiting space at the end
///	\remarks
///    Iterates through the whole array, testing for identity with the passed in marker. As
///    soon as a match is made, it returns. (Used by the AreMarkerArraysDifferent() helper
///    function). If the array contains no elements, the return result is FALSE.
///	
///	History:
///	Created 17June08 by BEW, for support of refactored Source Text Edit functionality
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsMarkerInArray(wxArrayString* pStrArr, const wxString& marker)
{
	int index;
	wxString aMarker;
	int nSize = pStrArr->GetCount();
	if (nSize == 0)
		return FALSE;
	for (index = 0; index < nSize; index++)
	{
		aMarker = (*pStrArr)[index];
		wxASSERT(!aMarker.IsEmpty());
		if (aMarker == marker)
			return TRUE;
	}
	return FALSE; // no match was made
}

/////////////////////////////////////////////////////////////////////////////////
///	\return    TRUE if the arrays are different (meaning that one or the other has 
///            at least one SF marker which is not in the other, repeated markers will
///            have more than one entry in the passed in array(s), but that is not
///            relevant to the result)
///	\param     str1	                   ->	a string containing marked up (SFM or USFM)
///	                                        text, such as source text
///	\param	   str2	                   ->	a string containing marked up (SFM or USFM) 
///	                                        text, such as edited source text
///	\param     bUnfilteringRequired	   <-	TRUE if a "to-be-unfiltered" entry is added
///	                                        to m_FilterStatusMap, FALSE if not
///	\param     bFilteringRequired	   <-	TRUE if a "to-be-filtered" entry is added to
///	                                        m_FilterStatusMap, FALSE if not
///\remarks
///    Compares the unique markers in the strings, looking for evidence that there is at
///    least one marker which is not in the other string. It is done in both directions, in
///    case one of the strings has a subset of markers which are in the other - as testing
///    the contents of just one string agains the contents of the other (with perhaps an
///    extra unique marker) could produce a FALSE result, when doing it the other way round
///    would produce a TRUE result. So we do it both ways to make sure the result is
///    correct. An string without markers tested against one with one or more in it will
///    also generate a TRUE result; both strings lacking SF markers generates a FALSE
///    result.
///
///    IMPORTANT note regarding usage: str1 must be the original editable source text
///    string, str2 must be the new source text string, because the code added on 4July08
///    tests each marker in str2 to see if it is included in str1, and each which fails
///    that test will cause an entry to be added to m_FilterStatusMap which is a document
///    class member which controls the operation of RetokenizeText() when filter changes
///    are relevant to the document rebuild. BEW changed, to exclude dependence on
///    m_FilterStatusMap
///	
///	History:
///	Created 17June08 by BEW, for support of refactored Source Text Edit functionality
///    4July08, BEW added code for adding entries to m_FilterStatusMap; the code should
///    handle most situations but is not foolproof, and it relies on the caller supplying
///    the original editable text as str1, and the new editable text as str2.
///    6July08, BEW removed the need to use m_FilterStatusMap entries in the
///    OnEditSourceText() refactored code by using DoMarkerHousekeeping() over the whole
///    document, rather than rebuilding the whole document using the RetokenizeText() call
///    as the legacy function used to do; consequently the calls to
///    AddEntryToFilterStatusMap() below are commented out, and two functions are thereby
///    removed from the code because they are no longer needed (the other is
///    CopyStringToStringMap())
///
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::AreMarkerSetsDifferent(const wxString& str1, const wxString& str2, 
								bool& bUnfilteringRequired,bool& bFilteringRequired)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	int index;
	wxString aMarker; // use for a whole marker, with no trailing space 
					  // (ie. backslash plus bare marker)
	wxString aMkrWithSpace; // construct a string comprised of marker plus trailing 
							// space, here
	bool bShouldBeFiltered;
	bool bReturnValue = FALSE; // start with a safe default (ie. marker sets 
							   // are the same)
	bool bMatched = TRUE;
	wxArrayString* pStrArr1 = new wxArrayString;
	wxArrayString* pStrArr2 = new wxArrayString;

	// get their marker inventories in the form of wxArrayString arrays
	GetMarkerArrayFromString(pStrArr1, str1);
	GetMarkerArrayFromString(pStrArr2, str2);

	// initialize the flag values to be returned to the caller
	bUnfilteringRequired = FALSE;
	bFilteringRequired = FALSE;

	// get the sizes of these two arrays
	int nSize1 = pStrArr1->GetCount();
	int nSize2 = pStrArr2->GetCount();

	// bleed out the easy cases
	if (nSize1 == 0 && nSize2 == 0)
	{
		delete pStrArr1;
		delete pStrArr2;
		return FALSE; // both empty, they can't be different
	}
	// check for new source text with no markers
	if (nSize2 == 0)
	{
		// new source text has no markers, the other must have at
		// least one, so they are different; and no filtering or
		// unfiltering is involved because there is no marker which
		// could be a candidate (sso m_FilterStatusMap remains empty)
		pStrArr1->Clear();
		delete pStrArr1;
		delete pStrArr2;
		return TRUE;
	}
	// check for pre-edit source text with no markers
	// NOTE: see the long comment below for a discussion of the (small) weakness of
	// this simple algorithm for determining what entries to add to m_FilterStatusMap
	if (nSize1 == 0)
	{
		// no markers in the pre-edit source text, the new source text therefore
		// must have at least one, so the sets are different. Moreover, every marker
		// in the new source text as a result of the first set being empty, must be
		// given an entry in m_FilterStatusMap
		for (index = 0; index < nSize2; index++)
		{
			aMarker = (*pStrArr2)[index];
			wxASSERT(!aMarker.IsEmpty());
            // this aMarker SF marker is known not to be in the pre-edit source text, so
            // the arrays are different; and so this marker has to generate an entry for
            // the map m_FilterStatusMap
			bReturnValue = TRUE;

			// determine if this is filterable or not, and set up the entry accordingly
			aMkrWithSpace = aMarker + _T(' ');
			bShouldBeFiltered = IsMarkerWithSpaceInFilterMarkersString(aMkrWithSpace,
														pApp->gCurrentFilterMarkers);
			if (bShouldBeFiltered)
				bFilteringRequired = TRUE;
			else
				bUnfilteringRequired = TRUE;
		}
		delete pStrArr1;
		pStrArr2->Clear();
		delete pStrArr2;
		goto b;
	}

    // when both arrays have content, we must test each marker against all those in the
    // other array, doing this in both directions - because we must be sure to get a
    // correct BOOL result in the situation where one marker set may be a subset of the
    // other

    // iterate across the markers in the first array, testing for a non-match in the second
    // (all we are interested in for this loop is to find any pre-edit markers which are
    // not in the post-edit source text string
	for (index = 0; index < nSize1; index++)
	{
		aMarker = (*pStrArr1)[index];
		wxASSERT(!aMarker.IsEmpty());
		bMatched = IsMarkerInArray(pStrArr2, aMarker);
		if (!bMatched)
		{
			// this aMarker SF marker is not in array 2, so the arrays are different
			bReturnValue = TRUE;
		}
	}
	// iterate across the markers in the second array, (the new source text),
	// testing for a non-match in the first (the original text before editing happened)
	// -- this loop is where we possibly may add entries to m_FilterStatusMap
	//
    // This algorithm has an obvious weakness: if the original pre-edit source text has
    // \mkr1 (a misspelled marker which the user will edit to be \mkr2 which is filterable)
    // and also has an instance of \mkr2 as well, then changing \mkr1 to \mkr2 in the edit
    // dialog results in the new source text having \mkr2; and when we test \mkr2 to see if
    // it is in the pre-edit text string, we would find that it is, and so no entry would
    // get added to m_FilterStatusMap, when in actual fact it really should have, because a
    // misspelled marker has been fixed so as to be a to-be-filtered one, but the caller
    // will subsequently not call RetokenizeText() to do the filtering because the map has
    // had no entry put in it. The user can reduce the likelihood of such a situation by
    // just selecting the one word where the typo marker is stored, and do the change to
    // the correct marker in the dialog; however, if the typo marker is changed to be one
    // which comes with a matching endmarker, then the user's selection needs to be all the
    // words up to where the endmarker is stored (but not necessarily selecting the
    // CSourcePhrase instance because the TextType may change and prevent it being selected
    // anyway, but our code will still pick up the bad endmarker and show it to the user in
    // the edit source text dialog).
	//
    // So, the rule when making a good selection to correct a typo marker is: if it is
    // supposed to have an endmarker, select all the words which are to be enclosed by the
    // marker - endmarker pair, but if the typo marker is to be changed to one which has no
    // endmarker, just select the word which has the typo marker stored in its
    // CSourcePhrase instance. Doing that makes the algorithm 100% reliable.
	//
    // The likelihood of a selection with a bad marker also having an instance of the
    // filterable marker which the user will change the bad marker to be when he edits, is
    // very very small; so our simplistic algorithm should actually do the job quite well,
    // probably for everyone and every time; and it is guaranteed to work if the user
    // adhere's to the above rules for the selection
	for (index = 0; index < nSize2; index++)
	{
		aMarker = (*pStrArr2)[index];
		wxASSERT(!aMarker.IsEmpty());
		bMatched = IsMarkerInArray(pStrArr1, aMarker);
		if (!bMatched)
		{
			// this aMarker SF marker is not in array 1, so the arrays are different
			// and so this marker has to generate an entry for the map m_FilterStatusMap
			bReturnValue = TRUE;

			// determine if this is filterable or not, and set up the entry accordingly
			aMkrWithSpace = aMarker + _T(' ');
			bShouldBeFiltered = IsMarkerWithSpaceInFilterMarkersString(aMkrWithSpace,
														pApp->gCurrentFilterMarkers);
			if (bShouldBeFiltered)
				bFilteringRequired = TRUE;
			else
				bUnfilteringRequired = TRUE;
		}
	}
	// clean up
	pStrArr1->Clear();
	delete pStrArr1;
	pStrArr2->Clear();
	delete pStrArr2;
b:	return bReturnValue;
}

bool CAdapt_ItView::IsMarkerWithSpaceInFilterMarkersString(wxString& mkrWithSpace, 
														   wxString& strFilterMarkers)
{
	int offset = strFilterMarkers.Find(mkrWithSpace); // the trailing space 
												// prevents spurious matches
	if (offset == -1)
		return FALSE;
	else
		return TRUE;
}

void CAdapt_ItView::DoSrcPhraseSelCopy()
{
	// refactored 7Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CCellList* pCellList = &pApp->m_selection; // get a local pointer
	wxString str; // accumulate the words / phrases here
	str.Empty();
	CCellList::Node* pos = pCellList->GetFirst();
	if (pos == NULL)
		return;
	if (pApp->m_selectionLine == 0)
	{
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData();
			pos = pos->GetNext();
			if (pCell == NULL)
				return;
			CSourcePhrase* pSrcPhrase = pCell->GetPile()->GetSrcPhrase();
			wxASSERT(pSrcPhrase != NULL);

			if (pCell->GetPile() == pApp->m_pActivePile)
			{
				if (!pApp->m_targetPhrase.IsEmpty())
				{
					if (!pApp->m_targetPhrase.IsEmpty())
					{
						if (str.IsEmpty())
							str = pApp->m_targetPhrase;
						else
							str += _T(" ") + pApp->m_targetPhrase;
					}
				}
			}
			else
			{
				if (str.IsEmpty())
				{
					if (gbIsGlossing)
					{
						if (!pSrcPhrase->m_gloss.IsEmpty())
							str = pSrcPhrase->m_gloss;
					}
					else
					{
						if (!pSrcPhrase->m_targetStr.IsEmpty())
							str = pSrcPhrase->m_targetStr;
					}
				}
				else
				{
					if (gbIsGlossing)
					{
						if (!pSrcPhrase->m_gloss.IsEmpty())
							str += _T(" ") + pSrcPhrase->m_gloss;
					}
					else
					{
						if (!pSrcPhrase->m_targetStr.IsEmpty())
							str += _T(" ") + pSrcPhrase->m_targetStr;
					}
				}
			}
		}
	}
	else
		return;

	if (wxTheClipboard->Open())
	{
		// This data objects are held by the clipboard,
		// so do not delete them in the app.
		// SetData clears all previous contents in the clipboard
		// so there is no need to call Clear
		wxTheClipboard->SetData( new wxTextDataObject(str) );
		wxTheClipboard->Close();
	}
	else
	{
		wxMessageBox( _("Cannot open the Clipboard"), _T(""), wxICON_EXCLAMATION);
		return;
	}
}

bool CAdapt_ItView::IsItNotInKB(CSourcePhrase* pSrcPhrase)
{
	// determine if it is an <Not In KB> entry in the KB
	// modified, July 2003, for Auto-Capitalization support (ie. use AutoCapsLookup function)
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp);
	CKB* pKB = pApp->m_pKB;
	int nMapIndex = pSrcPhrase->m_nSrcWords - 1; // compute the index to the map

	// if we have too many source words, then it is not in the KB, 
	// but not a "<Not In KB>" entry
	if (pSrcPhrase->m_nSrcWords > MAX_WORDS)
	{
		return FALSE;
	}

	wxString key = pSrcPhrase->m_key;
	CTargetUnit* pTU;
	if (pKB->m_pMap[nMapIndex]->empty())
	{
		return FALSE;
	}
	else
	{
		bool bFound = AutoCapsLookup(pKB->m_pMap[nMapIndex], pTU, key);
		if(!bFound)
		{
			// not found
			return FALSE;
		}
		else
		{
			// pTU exists, so check its first refString to see if it stores <Not In KB>
			TranslationsList::Node* tpos = pTU->m_pTranslations->GetFirst();
			CRefString* pRefStr = (CRefString*)tpos->GetData();
			if (pRefStr->m_translation == _T("<Not In KB>"))
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pRefString      ->  pointer to the CRefString object to be deleted
/// \param      pSrcPhrase      ->  pointer to the CSourcePhrase instance whose m_key
///                                 member supplies the key for locating the CTargetUnit
///                                 in the relevant knowledge base map
/// \param      nWordsInPhrase  ->  used in order to define which map to look up
/// \remarks
/// Removes the wxString and reference count associated with it, (embodied as a CRefString
/// object)from a CTargetUnit instance in the knowledge base.
/// If pRefString is referenced only once, remove it from KB (since the phraseBox will hold
/// a copy of its string if it is still wanted), or if it is referenced more than once,
/// then just decrement the reference count by one, and set the srcPhrase's m_bHasKBEntry
/// flag to FALSE; also make sure m_bAlwaysAsk is set or cleared as the case may be. For
/// version 2.0 and onwards we must test gbIsGlossing in order to set the KB pointer to
/// either the adaption KB or the glossing KB; and the caller must supply the appropriate
/// first and last parameters (ie. a pRefString from the glossing KB and nWordsInPhrase set
/// to 1 when gbIsGlossing is TRUE)
/// Ammended, July 2003, to support auto capitalization
/// BEW changed 05July2006 to fix a long-standing error where the m_bHasKBEntry flag, or
/// the m_bHasGlossingKBEntry flag, was not cleared when the phrase box lands at a location
/// which earlier contributed an entry to the KB. The reason it wasn't cleared was because
/// I put the code for that in an "if (pRefString == NULL)" test's true block, so it
/// wouldn't get called except at locations which did not as yet have any KB entry! So I
/// commented out the test. (In StoreText() and StoreTextGoingBack() I unilaterally cleared
/// the flags at its start so that the store would not fail; I've now removed that bit of
/// code & tested - seems fine now.)
/// BEW 20Mar07: code added to suppress the decrement or kb entry removal if retranslating
/// is currenty going on, or editing of a retranslation (we don't want to dumb down the KB)
/// needlessly
void CAdapt_ItView::RemoveRefString(CRefString *pRefString, CSourcePhrase* pSrcPhrase,
									int nWordsInPhrase)
{
	if (gbIsGlossing)
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
	else
		pSrcPhrase->m_bHasKBEntry = FALSE;
	if (!gbIsGlossing && pSrcPhrase->m_bNotInKB)
	{
		// version 2 can do this block only when the adaption KB is in use
		pSrcPhrase->m_bHasKBEntry = FALSE;
		return; // return because nothing was put in KB for this source phrase anyway
	}

    // BEW added 06Sept06: the above tests handle what must be done to the document's
    // pSrcPhrase instance passed in, but it could be the case that the preceding
    // GetRefString() call did not find a KB entry with the given reference string
    // instance, in which case it would have returned NULL. In that case there is nothing
    // to remove, and no more to be done here, so test for this possibility and return
    // immediately if so.
	if (pRefString == NULL)
		return;

    // for autocapitalization support, we have to be careful that the translation (or
    // gloss) which we delete in the case when the ref count drops to zero is the actual
    // one in the KB - we can't always take it from pSrcPhrase->m_key because if auto caps
    // is ON it might be the case that the entry was put in when auto caps is OFF and then
    // we'd wrongly change to lower case and not succeed in removing the entry from the
    // map, so we have to be a bit more clever. So we'll set s to the key as on the
    // sourcephrase, and a second string s1 will have the other case equivalent, and if the
    // first does not get removed, we try the second (which should work); we still need to
    // form the second only when gbAutoCaps is TRUE, since when it is OFF, a failed
    // GetRefString( ) call will not result in an attempt to remove a lower case entry
    // stored when gbAutoCaps was ON
	wxString s = pSrcPhrase->m_key;
	wxString s1 = s;
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(s1);
		if (bNoError && gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
		{
			// make it start with lower case letter
			s1.SetChar(0,gcharSrcLC);
		}
	}
	int nRefCount = pRefString->m_refCount;
	wxASSERT(nRefCount > 0);
	if (nRefCount > 1)
	{
        // more than one reference to it, so just decrement & remove the srcPhrase's
        // knowledge of it, this does not affect the count of how many translations there
        // are, so m_bAlwaysAsk is unaffected. Version 2 has to test gbIsGlossing and set
        // the relevant flag to FALSE.
		if (!gbIsRetranslationCurrent)
		{
			// BEW 20Mar07: don't decrement if retranslation, or editing of same, 
			// is currently happening
			pRefString->m_refCount = --nRefCount;
		}
		if (gbIsGlossing)
		{
			pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
		}
		else
		{
			pSrcPhrase->m_bHasKBEntry = FALSE;
		}
	}
	else
	{
        // from version 1.2.9 onwards, since <no adaptation> has to be caused manually, we
        // no longer want to automatically remove an empty adaptation whenever we land on
        // one - well, not quite true, we can remove automatically provided the ref count
        // is greater than one, but we have to block automatic decrements which would
        // result in a count of zero - else we'd lose the value from the KB altogether and
        // user would not know. We need this protection because an ENTER will not cause
        // automatic re-storing of it. So now, we will just not remove the last one. This
        // will possibly skew the ref counts a bit for empty adaptations, if the user hits
        // the <no adaptation> button more than once for an entry (making them too large)
        // or landing on an empty one several times (makes count to small), would not
        // matter anyway. To manually remove empty adaptations from the KB the user still
        // has the option of doing it in the KB Editor, or in the ChooseTranslation dialog.

        //BEW changed behaviour 20Jun06 because unilaterally returning here whenever the
        //m_translation string was empty meant that if the user wanted to remove his
        //earlier "<no adaptation>" choice, there was no way to effect it from the
        //interface. So now we have a global flag gbNoAdaptationRemovalRequested which is
        //TRUE whenever the user hits backspace or Del key in an empty phrasebox, provided
        //that locatation's CSourcePhrase has m_bHasKBEntry (when in adapting mode) set
        //TRUE, or m_bHasGlossingKBEntry (when in glossing mode) set TRUE. Hence if neither
        //BS or DEL key is pressed, we'll get the legacy (no deletion & retaining of the
        //flag value) behaviour as before.
		if (pRefString->m_translation.IsEmpty())
		{
			if (!gbNoAdaptationRemovalRequested)
				return; // never automatically reduce count to zero; if user wants to be 
                        //rid of it, he must do so manually -- no, there was no 'manual'
                        //way to do it for the document CSourcePhrase instance, so 20Jun06
                        //change introduces a backspace or DEL key press to effect the
                        //removal
		}
		gbNoAdaptationRemovalRequested = FALSE; // ensure cleared to default value, & 
                        // permit removal after the flag may have been used in previous
                        // block

		if (gbIsRetranslationCurrent)
		{
            // BEW 20Mar07: don't remove if retranslation, or editing of same, is currently
            // happening because we don't want retranslations to effect the 'dumbing down'
            // of the KB by removal of perfectly valid KB entries belonging to the
            // retranslation span formerly
			return;
		}

        // this reference string is only referenced once, so remove it entirely from KB or
        // from the glossing KB, depending on gbIsGlossing flag's value
		CTargetUnit* pTU = pRefString->m_pTgtUnit; // point to the owning targetUnit
		wxASSERT(pTU != NULL);
		int nTranslations = pTU->m_pTranslations->GetCount();
		wxASSERT(nTranslations > 0); // must be at least one
		if (nTranslations == 1)
		{
			// we are removing the only CRefString in the owning targetUnit, so the latter must
			// go as well
			CTargetUnit* pTgtUnit;
			CAdapt_ItApp* pApp = GetDocument()->GetApp();
			CKB* pKB;
			if (gbIsGlossing)
				pKB = pApp->m_pGlossingKB; // point to the glossing KB when glossing is on
			else
				pKB = pApp->m_pKB; // point to the adaptation knowledge base when adapting

			delete pRefString;
			pRefString = (CRefString*)NULL;
			// since we delete pRefString, TranslationsList::Clear() should do the job below
			pTU->m_pTranslations->Clear();

			TUList::Node* pos;

			pos = pKB->m_pTargetUnits->Find(pTU); // find position of pRefString's
												  // owning targetUnit

            // Note: A check for NULL should probably be done here anyway even if when
            // working properly a NULL return value on Find shouldn't happen.
			pTgtUnit = (CTargetUnit*)pos->GetData(); // get the targetUnit in
																	// the list
			wxASSERT(pTgtUnit != NULL);
			pKB->m_pTargetUnits->DeleteNode(pos); // remove its pointer from the list
			delete pTgtUnit; // delete its instance from the heap
			pTgtUnit = (CTargetUnit*)NULL;

			MapKeyStringToTgtUnit* pMap = pKB->m_pMap[nWordsInPhrase - 1];
			int bRemoved = 0;
			if (gbAutoCaps)
			{
                // try removing the lower case one first, this is the most likely one that
                // was found by GetRefString( ) in the caller
				bRemoved = pMap->erase(s1); // also remove it from the map
			}
			if (bRemoved == 0)
			{
				// have a second shot using the unmodified string s
				bRemoved = pMap->erase(s); // also remove it from the map
			}
			wxASSERT(bRemoved == 1);
            // the above algorith will handle all possibilites except one; if earlier auto
            // caps is ON, and the user stores an entry with source text starting with
            // upper case, (which will be changed to lower case for the storage), and then
            // later on s/he turns auto caps OFF, then the entry would not be found by the
            // above line:
            // bRemoved = pMap->erase(s); and then the wxASSERT would trip; however, we
            // are saved from this happening because the pRefString passed in is provided
            // by a prior GetRefString( ) call in the caller, and that would not find the
            // pRefString, and as a consequence it would return NULL, and so the in this
            // block of RemoveRefString( ) the removal would not be asked for; so the
            // wxASSERT would not trip.
		}
		else
		{
			// there are other CRefString instances, so don't remove its owning targetUnit
			TranslationsList::Node* pos = pTU->m_pTranslations->Find(pRefString);
			wxASSERT(pos != NULL); // it must be in the list somewhere
			pTU->m_pTranslations->DeleteNode(pos); // remove that refString from the list
												   // in the targetUnit
			delete pRefString; // delete it from the heap
			pRefString = (CRefString*)NULL;
		}

		// inform the srcPhrase that it no longer has a KB entry (or a glossing KB entry)
		if (gbIsGlossing)
			pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
		else
			pSrcPhrase->m_bHasKBEntry = FALSE;
	}
}

// Return value: TRUE if all was well (whether or not an actual store to KB took place -
// because certain flags inhibit saves, or an empty targetBox does not get anything saved
// to a KB if the <no adaptation> button was not pressed), and FALSE if the store could not
// be done (eg. if the embedded call to StoreText returned FALSE) ammended, July 2003, for
// auto-capitalization support
bool CAdapt_ItView::StoreBeforeProceeding(CSourcePhrase* pSrcPhrase)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	RemoveSelection(); // ensure we don't have any selection current
	bool bOK = FALSE;

    // OnIdle( ) probably will have done any needed case changing, but just in case we will
    // check and if it has not been done, then do it here instead
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pApp->m_pActivePile->GetSrcPhrase()->m_key);
		if (bNoError && gbSourceIsUpperCase)
		{
			bNoError = SetCaseParameters(pApp->m_targetPhrase,FALSE);
			if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
			{
				pApp->m_targetPhrase.SetChar(0,gcharNonSrcUC);
			}
		}
	}

	if (gbIsGlossing)
	{
		if (!pSrcPhrase->m_bHasGlossingKBEntry)
		{
			if (!pApp->m_targetPhrase.IsEmpty())
			{
				// it has to be saved to the glossing KB if not empty
				bOK = StoreText(pApp->m_pGlossingKB,pSrcPhrase,pApp->m_targetPhrase);
			}
			else
				bOK = TRUE; // no store, but not an error so return TRUE
		}
		return bOK;
	}
	else
	{
		if (pApp->m_bSaveToKB && !pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB)
		{
			if (!pApp->m_targetPhrase.IsEmpty())
			{
				// it has to be saved to the KB if not empty
				MakeLineFourString(pSrcPhrase,pApp->m_targetPhrase);
				RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);
				gbInhibitLine4StrCall = TRUE;
				bOK = StoreText(pApp->m_pKB,pSrcPhrase,pApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
			}
			else
				bOK = TRUE; // no store, but not an error so return TRUE
		}
		pApp->m_bSaveToKB = TRUE; // make sure it's turned on
		return bOK;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle 
///                        handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// Disables the "Advance To End" toolbar item if Vertical Editing is in progress. If the
/// m_pActivePile pointer is NULL or there are no source phrase in the m_pSourcePhrases
/// list, this handler disables the "Advance To End" toolbar item and returns immediately.
/// It enables the toolbar item if the App's m_endIndex is greater than zero but less than
/// the count in m_pSourcephrases -1, otherwise it disables the toolbar item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonToEnd(wxUpdateUIEvent& event)
{
	// refactored 7Apr09
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum < pApp->GetMaxIndex())
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonToEnd(wxCommandEvent& event)
{
    // refactored 9Apr09 **** TODO **** can be restructured to have only one RecalcLayout()
    // call -- see OnButtonStepDown() for how to do it (relies on fact that the internal
    // code can make all decisions about whether to move or not without having to recalc
    // the layout, and then only do the one recalc call at the end)
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (pApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL); 
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->ChangeValue(tempStr);
	}
	gnOldSequNum = pApp->m_nActiveSequNum; // save old location

    // BEW added 28Sep05, to fix the following bug. It the globals below are not here
    // reset, and especially to the same value, then when we are in a bundle at the start
    // of the doc we'll not get trouble, but when we've been doing autoinseting at a
    // location way down in the document, and we stop the process (eg. Cancel a Choose
    // Translation dialog choice) and click the ToStart button, the button's handler
    // eventually recreates the layout at the start of the document (where we hope to end
    // up), but in the handler ScrollIntoView() gets called, and it has "smart" code in it
    // that takes the two globals below and if they are different, it will ask for a
    // recalculation of the pile pointers for the beginning and end of the last inserted
    // set of adaptations -- and these require GetPile() calls which, because that old
    // location was miles away further down in the document, a bundle advance and layout
    // recalculation get done in order to get valid pointers - and on return from
    // ScrollIntoView() the layout is no longer at the start and the active pointer has be
    // put back where we had been when we clicked ToStart to get back to the doc start.
    // Then, not only does the window not scroll and the phrase box get written over the
    // old window contents, but the bad active pile pointer causes any Update handler which
    // requires that value to crash (eg. OnUpdateButtonRestore()). Setting both globals to
    // zero avoids all and causes the legacy scrolling block to be used in
    // ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	SPList* pList = pApp->m_pSourcePhrases;

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	wxASSERT(pApp->m_pActivePile != NULL);
	bool bOK;
	bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());
    // BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
    // StoreBeforeProceeding() returns FALSE without doing any store, and in that case we
    // don't want to return from OnButtonToEnd immediately because then we have no way to
    // navigate to the end of the document by this button; instead, just ignore the bOK
    // value
	if (!bOK)
	{
		//return;
		; // just do nothing (avoids compiler warning baout bOK not being accessed)
	}

	int nSequNum = pApp->GetMaxIndex(); // make active element be the last one in the list
	pApp->m_nActiveSequNum = nSequNum;

	SPList::Node* spos = pList->GetLast();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)spos->GetData();

    // if free translation mode is on, we would not want the box to be at the very end if
    // there was already a free translation ending there - so make the adjustment if
    // required so that box goes instead to the last anchor position
	if (pApp->m_bFreeTranslationMode)
	{
		if (pSrcPhrase->m_bHasFreeTrans && !pSrcPhrase->m_bStartFreeTrans)
		{
			// move back to the sequ num for the anchor position
			SPList::Node* pos = pList->GetLast();
			int count = 0;
			while (TRUE)
			{
				count++;
				pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetPrevious();
				wxASSERT(pSrcPhrase != NULL); 
				nSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans || 
					(pSrcPhrase->m_nSequNumber == 0) ||
					pSrcPhrase->m_bChapter ||
					pSrcPhrase->m_bVerse)
				{
                    // don't go back more further than start of a free translation section,
                    // of to start of chapter, or start of verse, or start of document, if
                    // any of those conditions are encountered first
					nSequNum = pSrcPhrase->m_nSequNumber;
					pApp->m_nActiveSequNum = nSequNum;
					break;
				}
			}
		}
	}

	// handle the possibility that the new active location might be a "<Not In KB>" one
	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
        // this ensures user has to explicitly type into the box and explicitly check the
        // checkbox if he wants to override the "not in kb" earlier setting at this
        // location
		pApp->m_bSaveToKB = FALSE;
		pApp->m_targetPhrase.Empty();
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
	}
	else if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		pApp->m_targetPhrase = pSrcPhrase->m_adaption;
		pApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	else // the location is a "hole" (ie. empty)
	{
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
		pApp->m_targetPhrase.Empty();// added 31Jul03
        // the above is better, since then the user can use the To End button and not get
        // spurious copied source text entered into the KB if he does not remember to
        // delete the copied text before stepping elsewhere
	}

	// update the layout and get a fresh active pile pointer
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

    // the active pile must not contain a retranslation, since we want to put the phrase
    // box there, so check and if so, back up until we find a src phrase which is not a
    // retranslation
	if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
	{
        // it's a retranslation location, so move active location to earlier sequence
        // numbers until we find a sourcePhrase which is not in the retranslation
		CPile* pPile = pApp->m_pActivePile;
		do
		{
			pPile = GetPrevPile(pPile);
			if (pPile == NULL)
			{
                // we've backed up to the start of the document, so the last active pile
                // location (ie. the first pile in the document) is where we'll remain
				pApp->m_nActiveSequNum = 0;
				pPile = GetPile(0);
				pApp->m_targetPhrase = pPile->GetSrcPhrase()->m_adaption;
#ifdef _NEW_LAYOUT
				GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
				GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
				pApp->m_pActivePile = GetPile(0);
				return;
			}
			pApp->m_pActivePile = pPile;
		} while (pPile->GetSrcPhrase()->m_bRetranslation);

		pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
            // this ensures user has to explicitly type into the box and explicitly check
            // the checkbox if he wants to override the "not in kb" earlier setting at this
            // location
			pApp->m_bSaveToKB = FALSE;
			pApp->m_targetPhrase.Empty();
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			if (!gbIsGlossing && !pSrcPhrase->m_adaption.IsEmpty())
			{
				// there is an adaptation
				pApp->m_targetPhrase = pSrcPhrase->m_adaption;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else if (gbIsGlossing && !pSrcPhrase->m_gloss.IsEmpty())
			{
				// there is a gloss
				pApp->m_targetPhrase = pSrcPhrase->m_gloss;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (pApp->m_bCopySource)
				{
					pApp->m_targetPhrase = CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
				}
				else
				{
					pApp->m_targetPhrase.Empty();
				}
			}
		}
	}

	// remove from the KB, if there is a refString for this source phrase in the KB
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key, pSrcPhrase->m_adaption);

    // it is okay to do the following call with pRefString == NULL, in fact, it must be
    // done whether NULL or not; since if it is NULL, RemoveRefString will clear
    // pSrcPhrase's m_bHasKBEntry to FALSE, which if not done, would result in a crash if
    // the user clicked on a source phrase which had its reference string manually removed
    // from the KB and then clicked on another source phrase. (The StoreAdaption call in
    // the second click would trip the first line's ASSERT.)
	RemoveRefString(pRefString, pSrcPhrase, pSrcPhrase->m_nSrcWords);

    // BEW removed call of ResetPartnerPileWidth() 27Apr09, because a call to
    // ResetPartnerPileWidth() is always done in RecalcLayout() for the active pile, just
    // before rebuilding the strips, so we can rely on that one here

	// recalculate the layout
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif

	// recalculate the active pile
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	// scroll the active location into view, if necessary
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	GetLayout()->m_docEditOperationType = default_op; 
	
	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);

	Invalidate(); // get the layout redrawn and the phrase box too
	GetLayout()->PlaceBox();

    // if we are in free translation mode, we want the focus to be in the Compose Bar's
    // edit box after the move has been done
	if (pApp->m_bFreeTranslationMode && pEdit != NULL) // whm added && pEdit != NULL)
	{
		pEdit->SetFocus();
	}
}

/// removes both the entry from the adapting KB and the glossing KB, for the one m_key (the
/// function for removal exits if either does not yet exist in the KB, so the call is
/// always safe) - we need this function for document rebuilding, where both KBs have to be
/// updated in the one operation
void CAdapt_ItView::RemoveKBEntryForRebuild(CSourcePhrase* pSrcPhrase)
{
	// save current glossing state, so we can restore afterwards
	bool bSaveEnableFlag = gbEnableGlossing;
	bool bSaveGlossingFlag = gbIsGlossing;

	// remove from the adapting KB, if there is a refString for this source phrase in the KB
	// (GetRefString may return NULL)
	gbEnableGlossing = FALSE;
	gbIsGlossing = FALSE;
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key,pSrcPhrase->m_adaption);
	// it is okay to do the following call with pRefString == NULL
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// now the glossing KB
	gbEnableGlossing = TRUE;
	gbIsGlossing = TRUE;
	pRefString = GetRefString(GetKB(),1,pSrcPhrase->m_key,pSrcPhrase->m_gloss);
	RemoveRefString(pRefString,pSrcPhrase,from_target_text);

	// restore current mode
	gbEnableGlossing = bSaveEnableFlag;
	gbIsGlossing = bSaveGlossingFlag;
}

/// stores both adaptation for the adapting KB and gloss for the glossing KB, for the one
/// m_key (the function for storage exits if either does not yet exist in the KB, so the
/// call is always safe) - we need this function for document rebuilding, where both KBs
/// have to be updated in the one operation
void CAdapt_ItView::StoreKBEntryForRebuild(CSourcePhrase* pSrcPhrase, 
										wxString& adaptationStr, wxString& glossStr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// save current glossing state, so we can restore afterwards
	bool bSaveEnableFlag = gbEnableGlossing;
	bool bSaveGlossingFlag = gbIsGlossing;

	// store to the adapting KB
	gbEnableGlossing = FALSE;
	gbIsGlossing = FALSE;

	// inhibit the call to MakeLineFourString() within the StoreText() function
	// otherwise it will add punctuation to the m_targetStr field on the document's
	// pSrcPhrase which is currently active, and that member already has the required
	// punctuation because we have copied the old string prior to the rebuild
	gbInhibitLine4StrCall = TRUE;
	bool bOK = StoreText(pApp->m_pKB,pSrcPhrase,adaptationStr);

	// now the glossing KB
	gbEnableGlossing = TRUE;
	gbIsGlossing = TRUE;
	bOK = StoreText(pApp->m_pGlossingKB,pSrcPhrase,glossStr);

	// restore current mode
	gbEnableGlossing = bSaveEnableFlag;
	gbIsGlossing = bSaveGlossingFlag;
	gbInhibitLine4StrCall = FALSE; // restore the default setting
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Back To Start"
/// toolbar item and returns immediately: Vertical Editing is in progress, the Document
/// pointer is NULL, the m_pActivePile pointer is NULL, or the count of source phrases in
/// m_pSourcePhrases is zero. It enables the toolbar item if the App's m_beginIndex and
/// m_endIndex are both greater than zero, otherwise it disables the toolbar item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonToStart(wxUpdateUIEvent& event)
{
	// refactored 9Apr09
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if ((CAdapt_ItDoc*)GetDocument() == NULL)
	{
		event.Enable(FALSE);
		return;
	}

	if (pApp->m_nActiveSequNum == -1 && pApp->m_pSourcePhrases->GetCount() > 0)
	{
		// we are past the end, so allow the button to be used to go back to start
		event.Enable(TRUE);
		return;
	}

	// any other time when active pile pointer is null, don't let button be used
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->GetMaxIndex() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonToStart(wxCommandEvent& event)
{
    // refactored 9Apr09 **** TODO **** can be restructured to have only one RecalcLayout()
    // call -- see OnButtonStepDown() for how to do it (relies on fact that the internal
    // code can make all decisions about whether to move or not without having to recalc
    // the layout, and then only do the one recalc call at the end)
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (pApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->ChangeValue(tempStr);
	}

    // BEW added 28Sep05, to fix the following bug. It the globals below are not here
    // reset, and especially to the same value, then when we are in a bundle at the start
    // of the doc we'll not get trouble, but when we've been doing autoinseting at a
    // location way down in the document, and we stop the process (eg. Cancel a Choose
    // Translation dialog choice) and click the ToStart button, the button's handler
    // eventually recreates the layout at the start of the document (where we hope to end
    // up), but in the handler ScrollIntoView() gets called, and it has "smart" code in it
    // that takes the two globals below and if they are different, it will ask for a
    // recalculation of the pile pointers for the beginning and end of the last inserted
    // set of adaptations -- and these require GetPile() calls which, because that old
    // location was miles away further down in the document, a bundle advance and layout
    // recalculation get done in order to get valid pointers - and on return from
    // ScrollIntoView() the layout is no longer at the start and the active pointer has be
    // put back where we had been when we clicked ToStart to get back to the doc start.
    // Then, not only does the window not scroll and the phrase box get written over the
    // old window contents, but the bad active pile pointer causes any Update handler which
    // requires that value to crash (eg. OnUpdateButtonRestore()). Setting both globals to
    // zero avoids all and causes the legacy scrolling block to be used in
    // ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	gnOldSequNum = pApp->m_nActiveSequNum; // save old location

	SPList* pList = pApp->m_pSourcePhrases;

	bool bOK;
	if (pApp->m_nActiveSequNum == -1)
	{
		// we are past the end, so skip storage
		bOK = TRUE;

		// and remove any selection, since if it exists then RecalcLayout() would fail when
		// StoreSelection() gets called
		RemoveSelection();
	}
	else
	{
		wxASSERT(pApp->m_pActivePile != NULL);
		bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());
	}
    // BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
    // StoreBeforeProceeding() returns FALSE without doing any store, and in that case we
    // don't want to return from OnButtonToStart immediately because then we have no way to
    // navigate back to the start of the document; instead, just ignore the bOK value
	if (!bOK)
	{
		; // just do nothing (avoids compiler warning baout bOK not being accessed)
	}

	int nSequNum = 0; // active element is first one in the list
	pApp->m_nActiveSequNum = nSequNum;

	SPList::Node* spos = pList->GetFirst();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)spos->GetData();

	// handle the possibility that the new active location might be a "<Not In KB>" one
	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
		// this ensures user has to explicitly type into the box and explicitly check the
		// checkbox if he wants to override the "not in kb" earlier setting at this location
		pApp->m_bSaveToKB = FALSE;
		pApp->m_targetPhrase.Empty();
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
	}
	else if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		pApp->m_targetPhrase = pSrcPhrase->m_adaption;
		pApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	else
	{
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
		pApp->m_targetPhrase.Empty(); // added 31Jul03
        // the above is better, since then the user can use the To Start button and not get
        // spurious copied source text entered into the KB if he does not remember to
        // delete the copied text before stepping elsewhere
	}

	// update the layout and get a fresh active pile pointer
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

    // the active pile must not contain a retranslation, since we want to put the phrase
    // box there, so check and if so, move forward until we find a src phrase which is not
    // a retranslation
	if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
	{
        // its a retranslation location, so move active location to later sequence numbers
        // until we find a sourcePhrase which is not in the retranslation
		CPile* pPile = pApp->m_pActivePile;
		do
		{
			pPile = GetNextPile(pPile);
			if (pPile == NULL)
			{
                // we've moved forward past the end of the document, so the last potential
                // active location is where we'll remain
				pApp->m_nActiveSequNum = pApp->GetMaxIndex();
				pPile = GetPile(pApp->m_nActiveSequNum);
				pApp->m_targetPhrase = pPile->GetSrcPhrase()->m_adaption;
#ifdef _NEW_LAYOUT
				GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
				GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
				pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
				return;
			}
			pApp->m_pActivePile = pPile;
		} while (pPile->GetSrcPhrase()->m_bRetranslation);

		pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
            // this ensures user has to explicitly type into the box and explicitly check
            // the checkbox if he wants to override the "not in kb" earlier setting at this
            // location
			pApp->m_bSaveToKB = FALSE;
			pApp->m_targetPhrase.Empty();
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			if (!gbIsGlossing && !pSrcPhrase->m_adaption.IsEmpty())
			{
				// there is an adaptation
				pApp->m_targetPhrase = pSrcPhrase->m_adaption;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else if (gbIsGlossing && !pSrcPhrase->m_gloss.IsEmpty())
			{
				// there is a gloss
				pApp->m_targetPhrase = pSrcPhrase->m_gloss;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (pApp->m_bCopySource)
				{
					pApp->m_targetPhrase = CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
				}
				else
				{
					pApp->m_targetPhrase.Empty();
				}
			}
		}
	}

	// remove the text from the KB, if refString is not null
	CRefString* pRefString = GetRefString(GetKB(), pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key, pSrcPhrase->m_adaption);

    // it is okay to do the following call with pRefString == NULL, in fact, it must be
    // done whether NULL or not; since if it is NULL, RemoveRefString will clear
    // pSrcPhrase's m_bHasKBEntry to FALSE, which if not done, would result in a crash if
    // the user clicked on a source phrase which had its reference string manually removed
    // from the KB and then clicked on another source phrase. (The StoreAdaption call in
    // the second click would trip the first line's wxASSERT.)
	RemoveRefString(pRefString, pSrcPhrase, pSrcPhrase->m_nSrcWords);

	// recalculate the layout
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	
	// recalculate the active pile
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	// scroll the active location into view, if necessary
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	GetLayout()->m_docEditOperationType = default_op;

	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);

	Invalidate();
	GetLayout()->PlaceBox();

    // if we are in free translation mode, we want the focus to be in the Compose Bar's
    // edit box after the move has been done
	if (pApp->m_bFreeTranslationMode && pEdit != NULL)
	{
		pEdit->SetFocus();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Move Down One
/// Step" toolbar item and returns immediately: Vertical Editing is in progress, the
/// m_pActivePile pointer is NULL, or the count of source phrases in m_pSourcePhrases is
/// zero.
/// It enables the toolbar item if the App's m_endIndex is greater than zero and less than
/// the count of source phrases in m_pSourcePhrases -1, otherwise it disables the toolbar
/// item. otherwise it disables the toolbar item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonStepDown(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum < (int)pApp->GetMaxIndex() && pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonStepDown(wxCommandEvent& event)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	SPList* pList = pApp->m_pSourcePhrases;
	int nSaveOldSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;
	wxString saveTargetPhrase = pApp->m_targetPhrase;

    // BEW added 28Sep05, to fix the following bug. It the globals below are not here
    // reset, and especially to the same value, then when we are in a bundle at the start
    // of the doc we'll not get trouble, but when we've been doing autoinseting at a
    // location way down in the document, and we stop the process (eg. Cancel a Choose
    // Translation dialog choice) and click the ToStart button, the button's handler
    // eventually recreates the layout at the start of the document (where we hope to end
    // up), but in the handler ScrollIntoView() gets called, and it has "smart" code in it
    // that takes the two globals below and if they are different, it will ask for a
    // recalculation of the pile pointers for the beginning and end of the last inserted
    // set of adaptations -- and these require GetPile() calls which, because that old
    // location was miles away further down in the document, a bundle advance and layout
    // recalculation get done in order to get valid pointers - and on return from
    // ScrollIntoView() the layout is no longer at the start and the active pointer has be
    // put back where we had been when we clicked ToStart to get back to the doc start.
    // Then, not only does the window not scroll and the phrase box get written over the
    // old window contents, but the bad active pile pointer causes any Update handler which
    // requires that value to crash (eg. OnUpdateButtonRestore()). Setting both globals to
    // zero avoids all and causes the legacy scrolling block to be used in
    // ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	gnOldSequNum = pApp->m_nActiveSequNum; // save old location

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();
	wxASSERT(pApp->m_pActivePile != NULL);

	// find the next CSourcePhrase instance which has m_bChapter set TRUE, make it the new
	// active location; but if none is found ahead of the current active location, then
	// just beep and stay at the current active location
	bool bFoundChapterBeginning = FALSE;
	int nSequNum = nSaveOldSequNum + 1;
	CPile* pPile = GetPile(nSequNum); // might return NULL (if at doc end)
	if (nSequNum <= pApp->GetMaxIndex()) 
	{
		while (pPile != NULL)
		{
			CSourcePhrase* pSrcPhr = pPile->GetSrcPhrase();
			if (pSrcPhr->m_bChapter)
			{
				bFoundChapterBeginning = TRUE;
				break;
			}
			else
			{
				nSequNum++;
				pPile = GetPile(nSequNum);
			}
		}
	}

	// if no chapter beginning was found, then exit with a beep
	if (!bFoundChapterBeginning)
	{
		::wxBell();
		return;
	}

	// continuing, because a chapter beginning was found...
	GetLayout()->m_pDoc->ResetPartnerPileWidth(GetSrcPhrase(nSaveOldSequNum)); // update old loc'n
	
	// if it is free translation mode, get a pointer to the compose bar's wxTextCtrl
	if (pApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->ChangeValue(tempStr);
	}

	bool bOK;
	bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());
    // BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
    // StoreBeforeProceeding() returns FALSE without doing any store, and in that case we
    // don't want to return from OnButtonStepDown immediately because then we have no way
    // to navigate ahead in the document using this button; instead, just ignore the bOK
    // value
	if (!bOK)
	{
		; // do nothing, need to use bOK to avoid compile warning
	}

	wxASSERT(pPile);
	pApp->m_pActivePile = pPile;
	pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber; // the new location, at chapter
	SPList::Node* pos = pList->Item(pApp->m_nActiveSequNum); 
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase != NULL);

	// if free translation mode is on, we would not want the box to be anywhere but at the
	// start of a free translation section, so if the found location is not the start of
	// such a section, make the adjustment if required so that box goes instead to the previous
	// anchor position
	if (pApp->m_bFreeTranslationMode)
	{
		if (pSrcPhrase->m_bHasFreeTrans && !pSrcPhrase->m_bStartFreeTrans)
		{
			// move back to the sequ num for the anchor position
			while (TRUE)
			{
				pos = pos->GetPrevious();
				pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetPrevious();
				wxASSERT(pSrcPhrase != NULL); 
				nSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans || 
					(pSrcPhrase->m_nSequNumber == 0) ||
					pSrcPhrase->m_bChapter ||
					pSrcPhrase->m_bVerse)
				{
                    // don't go back more further than start of a free translation section,
                    // of to start of chapter, or start of verse, or start of document, if
                    // any of those conditions are encountered first
					nSequNum = pSrcPhrase->m_nSequNumber;
					pApp->m_nActiveSequNum = nSequNum;
					break;
				}
			}
		}
	}
	else // not free translation mode
	{
		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
            // this ensures user has to explicitly type into the box and explicitly check
            // the checkbox if he wants to override the "not in kb" earlier setting at this
            // location
			pApp->m_bSaveToKB = FALSE;
			pApp->m_targetPhrase.Empty();
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			pApp->m_targetPhrase = pSrcPhrase->m_adaption;
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			pApp->m_targetPhrase.Empty();// added 31Jul03
            // the above is better, since then the user can use the Step Up button
            // repeatedly and not get spurious copied source text entered into the KB each
            // time if he does not remember to delete the copied text first
		}

        // the active pile must not contain a retranslation, since we want to put the
        // phrase box there, so check and if so, move along until we find a src phrase
        // which is not a retranslation
		if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
		{
			// its a retranslation location, so move active location to later sequence numbers
			// until we find a sourcePhrase which is not in the retranslation
			CPile* pPile = pApp->m_pActivePile;
			do
			{
				pPile = GetNextPile(pPile);
				if (pPile == NULL)
				{
                    // we've gone forward past the end of the document, so we won't make
                    // any change of location; because the end of the doc has only
                    // retranslations, so restore the old state & tell user
					//IDS_CANNOT_STEP_DOWN //  BEW changed message 10Apr09
					wxMessageBox(_(
"Adapt It cannot step down to the beginning of the next chapter because it cannot find a legal place to put the phrase box, retranslations at the end of the document prevent it."),
					_T(""),wxICON_INFORMATION);
					// restore old location's values (no RecalcLayout() was done, so
					// layout is valid still)
					pApp->m_targetPhrase = saveTargetPhrase;
					pApp->m_nActiveSequNum = nSaveOldSequNum;
					pApp->m_pActivePile = GetPile(nSaveOldSequNum);
					return;
				}
			} while (pPile->GetSrcPhrase()->m_bRetranslation);

			wxASSERT(pPile);
			pApp->m_pActivePile = pPile; // this one is not in the retranslation
			pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

			// handle the possibility that the new active location might be a "<Not In KB>" one
			if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
			{
				// this ensures user has to explicitly type into the box and explicitly check the
				// checkbox if he wants to override the "not in kb" earlier setting at this location
				pApp->m_bSaveToKB = FALSE;
				pApp->m_targetPhrase.Empty();
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
			}
			else // it's not a <Not In KB> location
			{
				if (!gbIsGlossing && !pSrcPhrase->m_adaption.IsEmpty())
				{
					// there is an adaptation
					pApp->m_targetPhrase = pSrcPhrase->m_adaption;
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else if (gbIsGlossing && !pSrcPhrase->m_gloss.IsEmpty())
				{
					// there is a gloss
					pApp->m_targetPhrase = pSrcPhrase->m_gloss;
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else
				{
					pApp->m_pTargetBox->m_bAbandonable = TRUE;
					if (pApp->m_bCopySource)
					{
						pApp->m_targetPhrase = CopySourceKey(
										pSrcPhrase,pApp->m_bUseConsistentChanges);
					}
					else
					{
						pApp->m_targetPhrase.Empty();
					}
				}
			}
		}

		// remove the text from the KB, if refString is not null
		CRefString* pRefString = GetRefString(GetKB(), pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key, pSrcPhrase->m_adaption);
		RemoveRefString(pRefString, pSrcPhrase, pSrcPhrase->m_nSrcWords);

	} // end block for "not free translation mode"

	// update the layout and get a fresh active pile pointer
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);
	GetLayout()->m_docEditOperationType = default_op;
	
	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);

	Invalidate();
	GetLayout()->PlaceBox();

    // if we are in free translation mode, we want the focus to be in the Compose Bar's
    // edit box after the move has been done
	if (pApp->m_bFreeTranslationMode && pEdit != NULL)
	{
		pEdit->SetFocus();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Move Up One
/// Step" toolbar item and returns immediately: Vertical Editing is in progress, the
/// Document pointer is NULL, the m_pActivePile pointer is NULL, or the count of source
/// phrases in m_pSourcePhrases is zero.
/// It generally enables the toolbar button if the App's m_beginIndex and m_endIndex are
/// both greater than zero, otherwise it disables the toolbar item. It also enables the
/// toolbar item in the special circumstance when the phrasebox is past the end of the
/// document (m_pActiveSequNum is -1 and the count of source phrases in m_pSourcePhrases is
/// greater than zero).
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonStepUp(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if ((CAdapt_ItDoc*)GetDocument() == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum == -1 && pApp->m_pSourcePhrases->GetCount() > 0)
	{
		// we are past the end, so allow the button to be used to go back to start
		event.Enable(TRUE);
		return;
	}
	// any other time when active pile pointer is null, don't let button be used
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->GetMaxIndex() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonStepUp(wxCommandEvent& event)
{
	CMainFrame* pFrame;
	wxTextCtrl* pEdit = NULL; // whm initialized to NULL
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	SPList* pList = pApp->m_pSourcePhrases;

	// Beware, the update handler has the button enabled if the active sequ num is -1 and
	// there is data in the document; so we can't try to call GetSrcPhrase() for an active
	// pile pointer which is NULL. The thing to do would be to temporarily place the box
	// at the last CSourcePhrase in the document and let it then search back.
	int nSaveOldSequNum;
	if (pApp->m_nActiveSequNum == -1 || pApp->m_pActivePile == NULL)
	{
		// passed the end of the document
		pApp->m_nActiveSequNum = pApp->GetMaxIndex();
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		pApp->m_targetPhrase = _T("");
	}
	nSaveOldSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;
	wxString saveTargetPhrase = pApp->m_targetPhrase;

	// return if we are at the start of the document
	if (nSaveOldSequNum == 0)
	{
		::wxBell();
		return;
	}

    // BEW added 28Sep05, to fix the following bug. It the globals below are not here
    // reset, and especially to the same value, then when we are in a bundle at the start
    // of the doc we'll not get trouble, but when we've been doing autoinseting at a
    // location way down in the document, and we stop the process (eg. Cancel a Choose
    // Translation dialog choice) and click the ToStart button, the button's handler
    // eventually recreates the layout at the start of the document (where we hope to end
    // up), but in the handler ScrollIntoView() gets called, and it has "smart" code in it
    // that takes the two globals below and if they are different, it will ask for a
    // recalculation of the pile pointers for the beginning and end of the last inserted
    // set of adaptations -- and these require GetPile() calls which, because that old
    // location was miles away further down in the document, a bundle advance and layout
    // recalculation get done in order to get valid pointers - and on return from
    // ScrollIntoView() the layout is no longer at the start and the active pointer has be
    // put back where we had been when we clicked ToStart to get back to the doc start.
    // Then, not only does the window not scroll and the phrase box get written over the
    // old window contents, but the bad active pile pointer causes any Update handler which
    // requires that value to crash (eg. OnUpdateButtonRestore()). Setting both globals to
    // zero avoids all and causes the legacy scrolling block to be used in
    // ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = 0;
	gnEndInsertionsSequNum = 0; // clear, and make both be same value

	gnOldSequNum = pApp->m_nActiveSequNum; // save old location

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();
	wxASSERT(pApp->m_pActivePile != NULL);

    // find the previous CSourcePhrase instance which has m_bChapter set TRUE, make it the
    // new active location; but if none is found before the current active location, then
    // just beep and stay at the current active location
	bool bFoundChapterBeginning = FALSE;
	int nSequNum = nSaveOldSequNum - 1; // first preceding location's sequence number
	CPile* pPile = GetPile(nSequNum);
	if (nSequNum >= 0) 
	{
		while (pPile != NULL)
		{
			CSourcePhrase* pSrcPhr = pPile->GetSrcPhrase();
			if (pSrcPhr->m_bChapter)
			{
				bFoundChapterBeginning = TRUE;
				break;
			}
			else
			{
				nSequNum--;
				pPile = GetPile(nSequNum);
			}
		}
	}

	// if no chapter beginning was found, then exit with a beep
	if (!bFoundChapterBeginning)
	{
		::wxBell();
		return;
	}

	// continuing, because a chapter beginning was found...
	GetLayout()->m_pDoc->ResetPartnerPileWidth(GetSrcPhrase(nSaveOldSequNum)); // update old loc'n
	
	// if it is free translation mode, get a pointer to the compose bar's wxTextCtrl
	if (pApp->m_bFreeTranslationMode)
	{
		pFrame = (CMainFrame*)pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		wxASSERT(pEdit != NULL);
		// whm 24Aug06 modified below to eliminate gFreeTranslationStr global
		wxString tempStr;
		tempStr.Empty();
		pEdit->ChangeValue(tempStr);
	}

	bool bOK;
	bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());
    // BEW changed 06May05 because if m_pSrcPhrase contains m_bHasKBEntry == TRUE, then
    // StoreBeforeProceeding() returns FALSE without doing any store, and in that case we
    // don't want to return from OnButtonStepDown immediately because then we have no way
    // to navigate ahead in the document using this button; instead, just ignore the bOK
    // value
	if (!bOK)
	{
		; // do nothing, need to use bOK to avoid compile warning
	}

	wxASSERT(pPile);
	pApp->m_pActivePile = pPile; // the new active location's pile pointer
	pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber; // the new location, at chapter
	SPList::Node* pos = pList->Item(pApp->m_nActiveSequNum); 
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	wxASSERT(pSrcPhrase != NULL);

    // if free translation mode is on, we would not want the box to be anywhere but at the
    // start of a free translation section, so if the found location is not the start of
    // such a section, make the adjustment if required so that box goes instead to the
    // previous anchor position
	if (pApp->m_bFreeTranslationMode)
	{
		if (pSrcPhrase->m_bHasFreeTrans && !pSrcPhrase->m_bStartFreeTrans)
		{
			// move back to the sequ num for the anchor position
			while (TRUE)
			{
				pos = pos->GetPrevious();
				pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetPrevious();
				wxASSERT(pSrcPhrase != NULL); 
				nSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans || 
					(pSrcPhrase->m_nSequNumber == 0) ||
					pSrcPhrase->m_bChapter ||
					pSrcPhrase->m_bVerse)
				{
					// don't go back more further than start of a free translation section,
					// of to start of chapter, or start of verse, or start of document, if
					// any of those conditions are encountered first
					nSequNum = pSrcPhrase->m_nSequNumber;
					pApp->m_nActiveSequNum = nSequNum;
					break;
				}
			}
		}
	}
	else // not free translation mode
	{
		// handle the possibility that the new active location might be a "<Not In KB>" one
		if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
		{
            // this ensures user has to explicitly type into the box and explicitly check
            // the checkbox if he wants to override the "not in kb" earlier setting at this
            // location
			pApp->m_bSaveToKB = FALSE;
			pApp->m_targetPhrase.Empty();
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			pApp->m_targetPhrase = pSrcPhrase->m_adaption;
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			pApp->m_targetPhrase.Empty();// added 31Jul03
            // the above is better, since then the user can use the Step Up button
            // repeatedly and not get spurious copied source text entered into the KB each
            // time if he does not remember to delete the copied text first
		}

        // the active pile must not contain a retranslation, since we want to put the
        // phrase box there, so check and if so, move along until we find a src phrase
        // which is not a retranslation
		if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
		{
            // its a retranslation location, so move active location to earlier sequence
            // numbers until we find a sourcePhrase which is not in the retranslation
			CPile* pPile = pApp->m_pActivePile;
			do
			{
				pPile = GetPrevPile(pPile);
				if (pPile == NULL)
				{
                    // we've gone back past the start of the document, so we won't make any
                    // change of location; because the start of the doc has only
                    // retranslations, so restore the old state & tell user
					//IDS_CANNOT_STEP_UP //  BEW changed message 11Apr09
					wxMessageBox(_(
"Adapt It cannot step up to the beginning of chapter, or to the beginning of the previous chapter because it cannot find a legal place to put the phrase box, retranslations at the beginning of the document prevent it."),
					_T(""),wxICON_INFORMATION);
					// restore old location's values (no RecalcLayout() was done, so
					// layout is valid still)
					pApp->m_targetPhrase = saveTargetPhrase;
					pApp->m_nActiveSequNum = nSaveOldSequNum;
					pApp->m_pActivePile = GetPile(nSaveOldSequNum);
					return;
				}
			} while (pPile->GetSrcPhrase()->m_bRetranslation);

			wxASSERT(pPile);
			pApp->m_pActivePile = pPile; // this one is not in the retranslation
			pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;

			// handle the possibility that the new active location might be a 
			// "<Not In KB>" one
			if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
			{
                // this ensures user has to explicitly type into the box and explicitly
                // check the checkbox if he wants to override the "not in kb" earlier
                // setting at this location
				pApp->m_bSaveToKB = FALSE;
				pApp->m_targetPhrase.Empty();
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
			}
			else // it's not a <Not In KB> location
			{
				if (!gbIsGlossing && !pSrcPhrase->m_adaption.IsEmpty())
				{
					// there is an adaptation
					pApp->m_targetPhrase = pSrcPhrase->m_adaption;
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else if (gbIsGlossing && !pSrcPhrase->m_gloss.IsEmpty())
				{
					// there is a gloss
					pApp->m_targetPhrase = pSrcPhrase->m_gloss;
					pApp->m_pTargetBox->m_bAbandonable = FALSE;
				}
				else
				{
					pApp->m_pTargetBox->m_bAbandonable = TRUE;
					if (pApp->m_bCopySource)
					{
						pApp->m_targetPhrase = CopySourceKey(pSrcPhrase,pApp->m_bUseConsistentChanges);
					}
					else
					{
						pApp->m_targetPhrase.Empty();
					}
				}
			}
		}

		// remove the text from the KB, if refString is not null
		CRefString* pRefString = GetRefString(GetKB(), pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key, pSrcPhrase->m_adaption);
		RemoveRefString(pRefString, pSrcPhrase, pSrcPhrase->m_nSrcWords);

	} // end block for "not free translation mode"

	// update the layout and get a fresh active pile pointer
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);
	GetLayout()->m_docEditOperationType = default_op;
	
	// restore default button image, and m_bCopySourcePunctuation to TRUE
	OnButtonEnablePunctCopy(event);

	Invalidate();
	GetLayout()->PlaceBox();

    // if we are in free translation mode, we want the focus to be in the Compose Bar's
    // edit box after the move has been done
	if (pApp->m_bFreeTranslationMode && pEdit != NULL)
	{
		pEdit->SetFocus();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If the application is in glossing mode, or it is showing only the target text, or the m_pActivePile 
/// pointer is NULL, this handler disables the "Make A Phrase" toolbar item 
/// and returns immediately. If there is an active selection (the App's m_selection list has more than 
/// one item in its list), it enables the toolbar button, otherwise it disables the toolbar button. 
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonMerge(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selection.GetCount() > 1)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,   
/// and before the menu is displayed.
/// If the App's m_pActivePile is NULL this handler disables the "Copy Source" item in the
/// View menu and immediately returns.
/// It enables the "Copy Source" item on the View menu if the number of source phrases in
/// the m_pSourcePhrases list is greater than zero, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateCopySource(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

bool CAdapt_ItView::IsNullSrcPhraseInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // there isn't any selection
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_bNullSourcePhrase)
			return TRUE;
	}
	return FALSE;
}

bool CAdapt_ItView::IsRetranslationInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst(); 
	if (pos == NULL)
		return FALSE; // there isn't any selection
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext(); 
		if (pSrcPhrase->m_bRetranslation)
			return TRUE;
	}
	return FALSE;
}

// IsFilteredMaterialNonInitial() -- BEW added 08June05, to be used in OnButtonMerge() in
// order to abort the merge operation if the user is trying to merge CSourcePhrase
// instances and one of those which is not the initial one contains filtered material in
// its m_markers member
bool CAdapt_ItView::IsFilteredMaterialNonInitial(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // there isn't any content in the list
	bool bIsFirst = TRUE;
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (!bIsFirst && (pSrcPhrase->m_markers.Find(filterMkr) != -1))
			return TRUE;
		bIsFirst = FALSE;
	}
	return FALSE;
}

// IsSelectionAcrossFreeTranslationEnd() -- BEW added 22Jul05, to be used in
// OnButtonMerge() in order to abort the merge operation if the user is trying to merge
// CSourcePhrase instances the selection begins before a sourcephrase which is the end of a
// free translation section and extends further into a part of the document in which no
// free translation is defined (the case where what follows is another free translation
// section is already blocked by the requirement that no merge can be done across filtered
// material)
bool CAdapt_ItView::IsSelectionAcrossFreeTranslationEnd(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // there isn't any content in the list
	bool bFoundFreeTranslationEnd = FALSE;
	bool bExtendsBeyondFreeTranslation = FALSE;
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (bFoundFreeTranslationEnd)
		{
			bExtendsBeyondFreeTranslation = TRUE;
			continue;
		}
		if (pSrcPhrase->m_bEndFreeTrans)
		{
			bFoundFreeTranslationEnd = TRUE;
			continue;
		}
	}
	return bExtendsBeyondFreeTranslation;
}

void CAdapt_ItView::OnButtonMerge(wxCommandEvent& WXUNUSED(event))
{
	// 25Mar09 added partner pile updating
	CLayout* pLayout = GetLayout();
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

    // In glossing mode (ie. actually glossing) I think I've managed to silently prevent
    // any merge from happening before OnButtonMerge( ) can get invoked. However, it the
    // user were to explicitly click the button, there is no recourse except to tell him
    // that the merge is not available when doing glossing
	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_(
		"This particular operation is not available when you are glossing."),
		_T(""), wxICON_INFORMATION);
		return;
	}

	// not glossing, so continue to process the merge request
	SPList* pList = new SPList; // list of the selected CSourcePhrase objects
	wxASSERT(pList != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;
	CSourcePhrase* pSrcPhrase = NULL;
	int nCount;
	CPile* pPile;
	int nSaveSequNum;
	CCellList::Node* pos = NULL;

    // use strOldAdaptation to accumulate any existing adaptations, which will do so
    // regardless of whether some or all of the srcPhrases are already merged; the strAdapt
    // accumulation variable used later only accumulates after any unmerges are done, so we
    // don't use that unless strOldAdaptation is empty
	wxString strOldAdaptation;
	strOldAdaptation.Empty();
	gOldConcatStr.Empty();
	gOldConcatStrNoPunct.Empty();
	bool bSuppressCopyingExtraSourceWords = FALSE;
	bool bNoninitialSelectionsHaveTranslation = FALSE;	// TRUE if a non-active-location 
												// selected pile has a translation in it
	if (gbRetainBoxContents)
	{
        // whenever this is set, the user will have just deselected the default text in the
        // phrase box and selected some source words- and so we get to this present code
        // block when merging. In this circumstance we don't want the deselected phrase box
        // contents to be thrown away (it was, in earlier versions) since the deselection
        // operation was clearly intended in order to retain that text; so when that
        // happens we take the box contents 'as is' as the initial string of text in
        // strOldAdaptation
		wxString s;
		s = pApp->m_pTargetBox->GetValue();
		strOldAdaptation = s;
		pApp->m_targetPhrase = s;
	}

    // if we are merging because of a match when LookAhead was called, set things up using
    // the nWordsInPhrase (global) value in the PhraseBox file; otherwise, use the
    // selection (bLookAheadMerge is a static class boolean defined in the CAdapt_ItApp
    // class & set by the LookAhead function in CPhraseBox class)
	if (pApp->bLookAheadMerge)
	{
		if (gbDoingInitialSetup && pApp->m_pTargetBox->GetHandle() == NULL)
		{
			gbJustCancelled = FALSE;
		}
		else if (pApp->m_pTargetBox->GetHandle() == NULL || pApp->m_pTargetBox->IsShown())
		{
			if (gbJustCancelled)
			{
				gbJustCancelled = FALSE;
			}
			else
			{
				// try skipping to the rest of the process, rather than aborting
				;
			}
		}
		nCount = nWordsInPhrase; // RHS is a global variable defined in PhraseBox.cpp
		pPile = pApp->m_pActivePile;
		wxASSERT(pPile != NULL);
		pStartingPile = pPile; // need this later - see next block for explanation
		pSrcPhrase = pPile->GetSrcPhrase();
		strOldAdaptation = pSrcPhrase->m_adaption; // don't use punctuated string
		pList->Append(pSrcPhrase); // add ptr of first to the temporary list
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything depends
		int i;									  // on this
		for (i = 1; i < nCount; i++)
		{
			pPile = GetNextPile(pPile); // next one in the sequence
			wxASSERT(pPile != NULL);
			pSrcPhrase = pPile->GetSrcPhrase();
			if (strOldAdaptation.IsEmpty())
				strOldAdaptation = pSrcPhrase->m_adaption;
			else
				strOldAdaptation += _T(" ") + pSrcPhrase->m_adaption; // always concat in natural order
			pList->Append(pSrcPhrase);  // add the pointer to the list
		}

        // for a look ahead merge, treat it as if user typed it, so that if there is a
        // user-generated extension done, the inserted translation will not be removed and
        // copied source text used instead
		pApp->m_bUserTypedSomething = TRUE;
	} // end block for bLookAhead merge == TRUE
	else // pApp->bLookAheadMerge is FALSE
	{
        // whm 10Sep08 added: The MFC code assumes that we won't get here if the Make a
        // Phrase button is disabled, however, in wx a CTRL-M and other accelerator keys
        // are propagated as key events even when the control they are associated with is
        // disabled, so we must bail out if there is no selection at this point, otherwise
        // we'll get a crash on pos->GetData() below.
		if (pApp->m_selection.GetCount() == 0)
		{
			pList->Clear();
			delete pList;
			pList = (SPList*)NULL;
			RemoveSelection(); // whm this not really needed as there is no selection 
							   // (but doesn't hurt)
			// WX Note: There is no ::IsWindow() equivalent in wxWidgets
			if (pApp->m_pTargetBox->GetHandle() != NULL)
			{
				pApp->m_pTargetBox->SetFocus();
				pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar);
			}
			gbMergeSucceeded = FALSE;
			Invalidate(); // get a redraw done, and the phrase box reshown
			GetLayout()->PlaceBox();
			return;
		}
		
        // get a list of the selected CSourcePhrase instances (some might not be minimal
        // ones so if this is the case we must restore them to minimal ones)
		pos = pApp->m_selection.GetFirst();	//MFC pos = m_selection.GetHeadPosition();
		nCount = pApp->m_selection.GetCount();
		pPile = ((CCell*)pos->GetData())->GetPile();	// get the pile first in selection
		pos = pos->GetNext();  // need this to effect MFC's GetNext()
		pStartingPile = pPile; // need this for later when we look up the strip which
							   // first pile is in prior to calling RecalcLayout()
		pSrcPhrase = pPile->GetSrcPhrase();

		// at the active location, use pApp->m_targetPhrase if it's different from 
		// the stored adaptation;
		if (pStartingPile == pApp->m_pActivePile)
		{
			strOldAdaptation = pApp->m_targetPhrase;

            // version 2.3.0, we don't want to have empty piles in the selection ahead of
            // the active location to have their source text copied to the existing
            // translation, because very seldom will that be useful - mostly the user has
            // to delete such additions, so from now on we will suppress the copy operation
            // using a local flag set here.
			bSuppressCopyingExtraSourceWords = TRUE;
		}
		else
		{
            // if the box is not within the selection, we will want to save the box
            // contents first, otherwise the contents will be lost when the merge takes
            // place
            // BEW 05Oct06; commented out next line, because CopySourceKey() sets
            // gbByCopyOnly to TRUE and if a copy has just been done before this merge, it
            // makes no sense to make the flag FALSE here so as to force a copy; so we want
            // the copy skipped if the flag is still TRUE
			//gbByCopyOnly = FALSE;
			if (!pApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
			{
				MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);
				RemovePunctuation(pDoc, &pApp->m_targetPhrase, from_target_text);

                // the store will fail if the user edited the entry out of the KB, as the
                // latter cannot know which srcPhrases will be affected, so these will
                // still have their m_bHasKBEntry set true. We have to test for this, ie. a
                // null pRefString but the above flag TRUE is a sufficient test, and if so,
                // set the flag to FALSE
				CRefString* pRefStr = GetRefString(pApp->m_pKB, 
								pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
							pApp->m_pActivePile->GetSrcPhrase()->m_key, pApp->m_targetPhrase);
				if (pRefStr == NULL && pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
								pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
				gbInhibitLine4StrCall = TRUE;
				bool bOK;
				bOK = StoreText(pApp->m_pKB, pApp->m_pActivePile->GetSrcPhrase(), 
								pApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
			}

			// get the first translation string, or something possibly useful, into the list
			if (pSrcPhrase->m_targetStr.IsEmpty())
			{
				if (pApp->m_bCopySource)
					strOldAdaptation = CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
			}
			else
			{
				if (!pSrcPhrase->m_bNotInKB)
					strOldAdaptation = pSrcPhrase->m_adaption;
			}
		}
		pList->Append(pSrcPhrase); // add first to the temporary list
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, all depends on it

        // while we fill the list, also accumulate the translations; remembering that the
        // pSrcPhrase at the active location will not have its m_adaption or m_targetStr
        // members set yet, but the appropriate value will be in the view's
        // pApp->m_targetPhrase member for RTL support we don't reverse the order of words
        // as we accumulate, (Uniscribe will render the string RTL correctly after it is
        // merged in natural order); and for version 2.3.0 we suppress the copying of
        // selected source words as target text to append to the existing target text since
        // this is usually not helpful
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData(); 
			pos = pos->GetNext(); 
			pPile = pCell->GetPile();
			pSrcPhrase = pPile->GetSrcPhrase();
			wxASSERT(pSrcPhrase != NULL);

            // at the active location, use pApp->m_targetPhrase if it is different from the
            // stored adaptation; works right even if user typed punct explicitly

            // BEW changed 05Oct06: this loop begins at the second pSrcPhrase in the list,
            // so when we've selected leftwards, this could be the active location with
            // copied src text and we'd not really want to use copied src text I think (but
            // at non-active locations we'd allow the copy to be done, as in the else block
            // below for the pPile == m_pActivePile test); so the change I'm making here is
            // just in the TRUE block for the pPile == m_pActivePile test:
            // to suppress copied text then for a backwards selection -- we can test for
            // these by m_curDirection's value, and phrase box's m_bAbandonable being still
            // FALSE; however strOldAdaptation is not our primary source for merged
            // adaptation text, it is only a fall back, so further changes are to be done
            // further down
			if (pPile == pApp->m_pActivePile)
			{
				if (!pApp->m_targetPhrase.IsEmpty())
				{
					// skip if selecting left and src text was copied
					if (!(pApp->m_curDirection == left && pApp->m_pTargetBox->m_bAbandonable))
					{
						strOldAdaptation += _T(" ") + pApp->m_targetPhrase;
					}
				}
			}
			else
			{
				// this pile is not at the active location
				if (strOldAdaptation.IsEmpty()) // strOldAdaptation is empty
				{
					if (pSrcPhrase->m_adaption.IsEmpty())
					{
						if (pApp->m_bCopySource && !bSuppressCopyingExtraSourceWords)
							strOldAdaptation = 
							CopySourceKey(pSrcPhrase,pApp->m_bUseConsistentChanges);
					}
					else
					{
						strOldAdaptation = pSrcPhrase->m_adaption;
						bNoninitialSelectionsHaveTranslation = TRUE;
					}
				}
				else // strOldAdaptation is not empty
				{
					if (pSrcPhrase->m_adaption.IsEmpty())
					{
						if (pApp->m_bCopySource && !bSuppressCopyingExtraSourceWords)
						if (pApp->m_bCopySource)
							strOldAdaptation += _T(" ") + 
							CopySourceKey(pSrcPhrase, pApp->m_bUseConsistentChanges);
					}
					else
					{
						strOldAdaptation += _T(" ") + pSrcPhrase->m_adaption;
						bNoninitialSelectionsHaveTranslation = TRUE;
					}
				}
			}
			pList->Append(pSrcPhrase);
		}
	}

	// set the global strings, in case they are wanted (eg. in a Find & Replace they may be used)
	gOldConcatStr = strOldAdaptation;
	gOldConcatStrNoPunct = strOldAdaptation;
	RemovePunctuation(pDoc, &gOldConcatStrNoPunct, from_target_text);

	// check for a retranslation in the selection, and abort the merge operation if there is one
	if (IsRetranslationInSelection(pList))
	{
		// IDS_NO_RETRANSLATION_IN_SEL
		wxMessageBox(_(
"This operation is not permitted when the selection contains any part of a retranslation. First remove the retranslation and then try again."),
		_T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		// WX Note: There is no ::IsWindow() equivalent in wxWidgets
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar); 
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

    // check for a null source phrase in the selection, and abort the merge operation if
    // there is one
	if (IsNullSrcPhraseInSelection(pList))
	{
		// IDS_NO_NULL_SRCPHRASE_IN_SEL
		wxMessageBox(_(
"Merging a selection which contains a placeholder (represented by ... dots) is not permitted."),
		_T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		// WX Note: There is no ::IsWindow() equivalent in wxWidgets
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

	// check for filtered material in a non-initial sourcephrase instance,
	// and abort the merge operation if there is some (we could handle it, but
	// we just don't want to - for instance, nav text might be too long to
	// view properly, and the green wedge would disappear and editability of
	// the filtered stuff would be lost)
	if (IsFilteredMaterialNonInitial(pList))
	{
		//IDS_NO_MERGE_FILTERED
		wxMessageBox(_(
		"Merging words across filtered material is not allowed."),
		_T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

    // check user is not trying to do a merger across the end of a free translation - it
    // can legally be done up to the end, but not across it (BEW added 22Jul05)
	if (IsSelectionAcrossFreeTranslationEnd(pList))
	{
		//IDS_NO_MERGE_ACROSS_FT_END
		wxMessageBox(_(
"Merging across the end of a free translation is not permitted. (You can merge up to the end of the free translation, but not beyond that point in the same merger.)"),
		_T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_pTargetBox->SetFocus();
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar); 
		}
		gbMergeSucceeded = FALSE;
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

    // there might be some <Not In KB> source phrases in the list, so ensure the srcPhrases
    // have the flag cleared (added 1-Feb-2001)
    // Up to this point pos has been assigned as CCellList::Node* and SPList has not had a
    // node assigned to it, so we'll do that now. We can't use pos here because it is
    // already a node associated with a CCellList. BE CAREFULL not to mix pos and
    // nodeSPTemp below as the condition for while loops, etc!!!
	SPList::Node* nodeSPTemp = pList->GetFirst(); 

	while (nodeSPTemp != NULL)
	{

		CSourcePhrase* pSP = (CSourcePhrase*)nodeSPTemp->GetData();
		nodeSPTemp = nodeSPTemp->GetNext();
		wxASSERT(pSP != 0);
		pSP->m_bNotInKB = FALSE;
	}

	// if there are too many words in the selection, do a retranslation instead of a merge
	if (GetSelectionWordCount() > MAX_WORDS)
	{
		DoRetranslation();
		gbMergeSucceeded = FALSE;
		return;
	}

	// make pApp->m_targetPhrase cleared, as it must accumulate any existing translations
	// removed from the KB because of the merge
	pApp->m_targetPhrase.Empty();

	// determine if there are any non-minimal phrases selected. If there are, we must
	// restore the original list of minimal phrases (ie. words), and clear the
	// translations from the KB, before proceeding.
	int nNumElements = 1;
	nodeSPTemp = pList->GetFirst();
	while (nodeSPTemp != NULL)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();
		nodeSPTemp = nodeSPTemp->GetNext(); 
		int nStartingSequNum = pSrcPhrase->m_nSequNumber;
		nNumElements = 1;
		if (pSrcPhrase->m_nSrcWords > 1)
		{
			// have to restore to original state (RestoreOriginalMinPhrases also
			// appends any adaptation(s) to pApp->m_targetPhrase)
			nNumElements = RestoreOriginalMinPhrases(pSrcPhrase, nStartingSequNum);

			// update nCount
			int nExtras = nNumElements - 1;
			nCount += nExtras;

			// BEW added 30Sep08 in support of vertical editing
			if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
			{
				gEditRecord.nAdaptationStep_EndingSequNum += nExtras;
				gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nExtras;
				gEditRecord.nAdaptationStep_NewSpanCount += nExtras;
			}

		}
		else // block for pSrcPhrase->m_nSrcWords == 1
		{
            // append its m_translation in the CRefString to pApp->m_targetPhrase, then
            // remove the refString from the KB, etc.
			CRefString* pRefString = GetRefString(GetKB(), pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key, pSrcPhrase->m_adaption);
			if (pRefString != NULL)
			{
				if (pRefString->m_translation != _T("<Not In KB>"))
				{
					if (pApp->m_targetPhrase.IsEmpty())
						pApp->m_targetPhrase = pRefString->m_translation;
					else
					{
						if (!pRefString->m_translation.IsEmpty())
						{
							pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") +
															pRefString->m_translation;
						}
					}
                    // the following call needs to be within this block, not after it,
                    // because we don't want to also remove any <Not In KB> entries from
                    // the KB (altered 1-Feb-2001)
					RemoveRefString(pRefString, pSrcPhrase, pSrcPhrase->m_nSrcWords);
				}
			}
			else // pRefString == NULL
			{
                // if all else fails to find some text for this box (provided it is the
                // active location), then pull out whatever is stored in the CEdit itself -
                // since if we got here by a click, then the KB will have been modified
				if (pSrcPhrase == pApp->m_pActivePile->GetSrcPhrase())
				{
					// WX Note: There is no ::IsWindow() equivalent in wxWidgets
					if (pApp->m_pTargetBox->GetHandle() != NULL)
					{
						if (pApp->m_targetPhrase.IsEmpty())
							pApp->m_targetPhrase = pApp->m_pTargetBox->GetValue();
						else
						{
							wxString str;
							str = pApp->m_pTargetBox->GetValue();
							pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + str;
						}
					}
				}
			}
		}
	}

    // delete the temporary list, and then do the merge using the restored minimal phrases
    // for the original selection
	pList->Clear();
	delete pList;
	pList = (SPList*)NULL;

    // at this point, pApp->m_targetPhrase may not have anything in it, because no
    // accumulation was possible, so check if it is empty and if so then restore it from
    // the window's title text.
	if (pApp->m_targetPhrase.IsEmpty())
	{
		// WX Note: There is no ::IsWindow() equivalent in wxWidgets
		if (pApp->m_pTargetBox->GetHandle() != NULL)
		{
			pApp->m_targetPhrase = pApp->m_pTargetBox->GetValue();
		}
	}

	/*
	// a block for debugging, to check adaptation span boundaries before the merge
	if (gbVerticalEditInProgress)
	{
		int nStartSN = gEditRecord.nAdaptationStep_StartingSequNum;
		int nEndSN = gEditRecord.nAdaptationStep_EndingSequNum;
		int nExtrasFromEdits = gEditRecord.nAdaptationStep_ExtrasFromUserEdits;
		int nNewSpanCnt = gEditRecord.nAdaptationStep_NewSpanCount;
	}
	*/
	// determine the first srcPhrase in the merge operation
	nodeSPTemp = pSrcPhrases->Item(nSaveSequNum);
	wxASSERT(nodeSPTemp != NULL);
	CSourcePhrase* pFirstSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();
	nodeSPTemp = nodeSPTemp->GetNext();// needed for SPList
	wxASSERT(pFirstSrcPhrase != NULL);
	wxASSERT(pFirstSrcPhrase->m_nSrcWords == 1 || 
							pFirstSrcPhrase->m_nSrcWords == 0); // no phrases allowed
	wxASSERT(nodeSPTemp != NULL); 

	// we will try accumulating a default "adaptation" string, if strOldAdaptation is empty,
	// otherwise use the latter
	wxString strAdapt;
	strAdapt.Empty();
	if (strOldAdaptation.IsEmpty())
	{
		if (pFirstSrcPhrase->m_targetStr.IsEmpty())
		{
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			if (pApp->m_bCopySource)
				strAdapt = CopySourceKey(pFirstSrcPhrase, pApp->m_bUseConsistentChanges);
			else
				; // leave it empty
		}
		else
		{
			strAdapt = pFirstSrcPhrase->m_targetStr;
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
	}

	// ensure a correct active sequ num when done
	pApp->m_nActiveSequNum = nSaveSequNum;

    // starting from the next minimal srcPhrase, Merge each succeeding one to
    // pFirstSrcPhrase (whether LTR or RTL layout, we always merge in logical order (ie.
    // order of ascending sequence numbers), and unmerge likewise, it is only the relative
    // order of the words in the text strings which are compiled which reverses for RTL)
    // 
	// BEW added 22May09. The new RecalcLayout() code for the keep_piles_keep_strips
	// option relies, in the AdjustForUserEdits() function, on m_pActivePile pointing at a
	// valid CPile instance; for a forwards selection, mergers are done to the active
	// pile, and so m_pActivePile remains in existence; but for a leftwards selection, the
	// mergers are done to an earlier pile than the one which was the active one, and then
	// the merged CSourcePhrase instances are deleted - thereby making m_pActivePile point
	// at freed memory. In the old way of doing the layout, this didn't matter because the
	// piles were all recreated and m_pActivePile reset; but now that we retain piles and
	// just tweak certain of the strips in the changed area of the document, we have to
	// restore m_pActivePile before we call RecalcLayout() later below. It would be
	// sufficient to set it to any valid pile near the active one, but we can do better
	// than this hear, and set it to pFirstSrcPhrase after the merging loop below has
	// finished, and then all will be well as that will be the new active pile anyway
	int i;
	for (i = 1; i < nCount; i++)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();
		nodeSPTemp = nodeSPTemp->GetNext(); // needed for SPList
		wxASSERT(pSrcPhrase != NULL);
		wxASSERT(pSrcPhrase->m_nSrcWords == 1 || 
								pSrcPhrase->m_nSrcWords == 0); // no phrases allowed

		pFirstSrcPhrase->Merge(this, pSrcPhrase);

		// compose a default adaptation string, as best we can
		if (strOldAdaptation.IsEmpty())
		{
			if (pSrcPhrase->m_adaption.IsEmpty())
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				if (pApp->m_bCopySource)
				{
					// don't add these ones which are additional to the first if 
					// the flag wants suppression
					if (!bSuppressCopyingExtraSourceWords)
						strAdapt += _T(" ") + CopySourceKey(pSrcPhrase, 
													pApp->m_bUseConsistentChanges);
				}
				else
					; // leave it empty
			}
			else
			{
				strAdapt += _T(" ") + pSrcPhrase->m_adaption;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
				bNoninitialSelectionsHaveTranslation = TRUE;
			}
		}
	} // end of for loop which merges all the non-first to the first in the selection

	// BEW added 22May09 -- see comment above the merge loop just above; here we must
	// re-establish the m_pActivePile pointer, in case we did a leftwards merge
	SPList::Node* aPosition = pSrcPhrases->Item(nSaveSequNum);
	CSourcePhrase* aSrcPhrasePtr = aPosition->GetData();
	wxASSERT(aSrcPhrasePtr);
	int itsSequNumber = aSrcPhrasePtr->m_nSequNumber;
	pApp->m_pActivePile = GetPile(itsSequNumber);
	wxASSERT(pApp->m_pActivePile);

	// Because later below we call DeletePartnerPile() on each of the non-first
	// CSourcePhrase instances of the selection which have now been merged, and
	// DeletePartnerPile() calls CLayout::DestroyPile() - freeing the memory for those
	// ones, we can't call RemoveSelection() after that, because the latter assumes the
	// cell pointers are still valid and they aren't. So here we just set the source text
	// line's first CCell of the selection to have m_bSelected set to FALSE, and Clear()
	// the m_selection list, and appropriately set the other selection parameters to
	// indicate there is no longer any selection. Then the StoreSelection() call in
	// RecalcLayout() will not crash, and we don't need to call RemoveSelection() here
	{
		int nFirstSequNum = pFirstSrcPhrase->m_nSequNumber;
		CPile* pFirstPile = GetPile(nFirstSequNum);
		CCell* pFirstSrcCell = pFirstPile->GetCell(0);
		pFirstSrcCell->SetSelected(FALSE);
		if (!pApp->m_selection.IsEmpty())
		{
			pApp->m_selection.Clear();
		}
		pApp->m_selectionLine = -1;
		pApp->m_pAnchor = (CCell*)NULL;
		// and globals too
		gnSelectionLine = -1;
		gnSelectionStartSequNum = -1;
		gnSelectionEndSequNum = -1;
	}

    // put our default string into pApp->m_targetPhrase to be shown in the phrase box,
    // provided we have not temporarily suppressed the default adaptation using the global
    // flag...

    // BEW added 05Oct06; here we supply a code block to implement a protocol for deriving
    // text for the phrase box when the selection has been made leftwards, so the active
    // location is at the end of the selection; and we have two scenarios- the box contents
    // are all selected (we'll assume that is due to a copy of source text and therefore
    // use m_bAbandonable == TRUE to detect it; if the selection has been made manually
    // then too bad, the user will have to do a little editing to removed the unwanted word
    // which will have been accepted when it was intended to have been removed by what the
    // user typed); or the active location will not have a selection (use m_bAbandonable ==
    // FALSE) and so we assume that the box's text is to be retained and accumulated with
    // the rest which was accumulated earlier
	if (pApp->m_curDirection == left)
	{
		// implementing a protocol for leftwards selections...

		// get the number of characters in the phrasebox's text, and determine how far from
		// the end is the cursor
		wxString strBox = _T("");
		strBox = pApp->m_pTargetBox->GetValue();
		int strBoxLen = strBox.Length();
		long nStart;
		long nEnd;
		pApp->m_pTargetBox->GetSelection(&nStart, &nEnd);

		if (pApp->m_pTargetBox->m_bAbandonable)
		{
			// user won't have typed anything, so the box text should have been selected when
			// the merge was initiated
			if (nStart == 1 && nEnd == 1 && strBoxLen == 1)
			{
				// the contents were selected and what the user typed replaced them
				pApp->m_targetPhrase = strBox;
				// make RemakePhraseBox() position the cursor after the character which
				// the user typed to replace the selection
				pApp->m_nStartChar = 1;
				pApp->m_nEndChar = 1; 							   
			}
			else
			{
                // anything else, we'll retain the box contents and accumulate it at the
                // end of strOldAdaptation, and try get the cursor where the user left it
				pApp->m_targetPhrase = strOldAdaptation;
				pApp->m_targetPhrase.Trim(FALSE); // trim left end
				pApp->m_targetPhrase.Trim(TRUE); // trim right end
				int itsLen = pApp->m_targetPhrase.Length();
				int nFromEnd = strBoxLen - nEnd;
				pApp->m_nStartChar = itsLen - nFromEnd;
				pApp->m_nEndChar = itsLen - nFromEnd;
			}
		}
		else
		{
			// retain the box contents and accumulate it at the end of
			// strOldAdaptation, and try get the cursor where the user left it
			pApp->m_targetPhrase = strOldAdaptation;
			pApp->m_targetPhrase.Trim(FALSE); // trim left end
			pApp->m_targetPhrase.Trim(TRUE); // trim right end
			int itsLen = pApp->m_targetPhrase.Length();
			int nFromEnd = strBoxLen - nEnd;
			pApp->m_nStartChar = itsLen - nFromEnd;
			pApp->m_nEndChar = itsLen - nFromEnd;
		}
	}
	else
	{
		// legacy behaviour, that is, typically forward selection. Nothing changed here.
		if (!bSuppressDefaultAdaptation)
		{
			if (strOldAdaptation.IsEmpty())
				pApp->m_targetPhrase = strAdapt;
			else
				pApp->m_targetPhrase = strOldAdaptation;
		}
	}

	// count how many have to be removed from the m_pSourcePhrases list on the app
	int nRemoveCount = nCount - 1; // that is, all but the first

	// BEW added 09Sep08 in support of vertical editing
	if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
	{
		gEditRecord.nAdaptationStep_EndingSequNum -= nRemoveCount;
		gEditRecord.nAdaptationStep_ExtrasFromUserEdits -= nRemoveCount; // LHS can become -ve legally
		gEditRecord.nAdaptationStep_NewSpanCount -= nRemoveCount;
	}

	/*
	// a block for debugging, to check adaptation span boundaries after the merge
	if (gbVerticalEditInProgress)
	{
		int nStartSN = gEditRecord.nAdaptationStep_StartingSequNum;
		int nEndSN = gEditRecord.nAdaptationStep_EndingSequNum;
		int nExtrasFromEdits = gEditRecord.nAdaptationStep_ExtrasFromUserEdits;
		int nNewSpanCnt = gEditRecord.nAdaptationStep_NewSpanCount;
	}
	*/
	// check all is well (Debug version only)
	wxASSERT(pApp->m_nActiveSequNum == pFirstSrcPhrase->m_nSequNumber);

	// next line added for refactored layout support 25Mar09...
	// puts the affected strip's index in CLayout::m_invalidStripArray and sets the
	// strip's m_bValid boolean to FALSE
	pDoc->ResetPartnerPileWidth(pFirstSrcPhrase);  											  
	
	// remove from the list the ones which have been merged to the first
	nodeSPTemp = pSrcPhrases->Item(pApp->m_nActiveSequNum + 1); // position of first
																// to be removed
	SPList::Node* savePos; // used below
	wxASSERT(nodeSPTemp != NULL);
	int j = 0;
	while (nodeSPTemp != NULL && j < nRemoveCount)
	{
		savePos = nodeSPTemp;
		CSourcePhrase* pSrcPhrase;
		pSrcPhrase = (CSourcePhrase*)nodeSPTemp->GetData();

		// next line added for refactored layout support 25Mar09
		pDoc->DeletePartnerPile(pSrcPhrase);

		nodeSPTemp = nodeSPTemp->GetNext(); 
		pSrcPhrases->DeleteNode(savePos); // remove pointer, but leave srcPhrase
		j++;							  // on the heap, because it is pointed at
	}									  // from within pFirstSrcPhrase now

	// update the sequence numbers which follow the active sequ num
	// BEW 22May09 moved this call to precede the recalculation of the layout, because it
	// is safer to have all the m_nSequNumber members of the elements in m_pSourcePhrases
	// list set correctly sequential before code in any other part of the app is called,
	// particularly the view layout code
	UpdateSequNumbers(pApp->m_nActiveSequNum);

	// recalculate the layout
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	pLayout->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif

	// get a new (valid) active pile pointer, now that the layout is recalculated
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);

    // we don't want the code after the MergeWords( ) call (which calls OnButtonMerge()) to
    // remove the phrase box's translation if the contents of the box hold more than just
    // the last single character which the user typed, provided that the selections beyond
    // the active location don't have any translation - if they do then we would instead
    // interpret the single keypress as an attempt to replace the earlier stuff. We get
    // what we want by setting gbRetainBoxContents since OnChar( ) will test the value on
    // return from MergeWords( ). Two local flags are needed to get this to happen at just
	// the right times. (TODO. Review if these flags work here as they used to, and if
	// they need to be retained in the refactored version. Currently, we just assume so.)
	int newLen = pApp->m_targetPhrase.Length();
	if (newLen > 1 && !bNoninitialSelectionsHaveTranslation)
		gbRetainBoxContents = TRUE;

	// set up the m_inform attribute, if there are medial markers
	if (pFirstSrcPhrase->m_bHasInternalMarkers)
	{
		wxString s = _T(" Medial markers: "); // English for this string might be a problem?
		if (!pFirstSrcPhrase->m_pMedialMarkers->IsEmpty())
		{
			// m_pMedialMarkers is a wxArrayString so let iterate 
			// through it with a for loop
			for (int i = 0; i < (int)pFirstSrcPhrase->m_pMedialMarkers->GetCount(); i++)
			{
				s += pFirstSrcPhrase->m_pMedialMarkers->Item(i);
			}
			pFirstSrcPhrase->m_inform += s;
		}
	}
	Invalidate();
	GetLayout()->PlaceBox();
	gbMergeSucceeded = TRUE;
}

void CAdapt_ItView::UpdateSequNumbers(int nFirstSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList = pApp->m_pSourcePhrases;

	// get the first
	SPList::Node* pos = NULL;
	if (nFirstSequNum == 0)
	{
		// don't do a Find to get the first one, in case numbers are not
		// currently up to date at the beginning
		pos = pList->GetFirst();
	}
	else
	{
		// for non-zero values, trust a Find will succeed - this is a potential
		// source of error, but since we almost always pass in zero, and we
		// try to keep numbers correct anyway, the risk is pretty small
		pos = pList->Item(nFirstSequNum);
	}
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext(); // needed for SPList
	wxASSERT(pSrcPhrase != NULL);
	pSrcPhrase->m_nSequNumber = nFirstSequNum;
	int index = nFirstSequNum;

	while (pos != 0)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		index++; // next sequence number
		pSrcPhrase->m_nSequNumber = index;
	}
}

int CAdapt_ItView::RestoreOriginalMinPhrases(CSourcePhrase *pSrcPhrase, int nStartingSequNum)
{
	// The following note is copied from Layout.cpp... it is very important
	// NOTE: in the event of an Unmerge operation, the active pile was the one that
	// got unmerged (and hence destroyed and its memory freed) - which; the
	// RestoreOriginalMinPhrases() function inserts the old CSourcePhrase instances
	// back into the app's m_pSourcePhrases list, and creates partner piles for these
	// with CAdapt_ItDoc::CreatePartnerPile() calls. The latter does not know about
	// what strip it will end up in, nor what position in that strip, because when
	// these creations are done the old strips are current (we could have a guess and
	// probably set the strip pointer correctly if the old strips exist, but not reliably
    // set the index within the strip's m_arrPiles array, and sometimes pile creation
    // is done when all strips are destroyed for a full layout rebuild, so there is not
    // much point in trying) - so we only go as far as having RestoreOriginalMinPhrases()
    // point the CAdapt_It::m_pActivePile at the partner pile for the first of the
	// created original minimum CSourcePhrase instances we've replaced in the list -
	// knowing full well that its m_pOwningStrip value will be NULL, and its m_nPile
	// value will be -1. That means that until the strips are updated, those members
	// will have those values, which means any function which depends on them before
	// RecalcLayout() has finished must know what to do if such a pile is the active
	// one - for instance, calling CPile::GetStripIndex() will return the invalid
	// index -1, and any attempt to Draw() such a pile would fail because m_nPile is
	// accessed in order to find its location in a strip in order to work out its
	// drawing rectangle, and garbage would be being accessed.	 

	// According to the above note, we must (in the refactored layout code) ensure that
	// deleting the pBigOne (merged) pile, which will also be the active pile, does not
	// result in the function exiting with m_pActivePile set to freed memory, so we add
	// code to reset the active pile to the first of the partner CPile pointers created
	// below; this is done at the end, and the passed in nStartingSequNum is the active
	// sequence number we use for resetting m_pActivePile
	
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int nCount = pSrcPhrase->m_nSrcWords;
	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* pos = pList->Item(nStartingSequNum);
	wxASSERT(pos != NULL);
	SPList::Node* savePos = pos; // used later below
	CSourcePhrase* pBigOne = (CSourcePhrase*)pos->GetData();
	wxASSERT(pBigOne != NULL);

    // BEW added 01Aug05 for free translation support; the merged source phrase may be part
    // of a free translation, but it's original saved sourcephrase pointers may not have
    // any free translation defined on them (because the user did the free translating
    // after the merge was done); or alternatively, there may have been a free translation
    // defined on the original sourcephrase instances in the merger (because the user
    // merged after doing the free translating -- and if the latter is the case then the
    // first of the original sourcephrases may, or may not contain a non-empty m_markers
    // member which stores the filtered free translation -- but we can be sure that no
    // medial sourcephrase instance stores a free translation because the app will not
    // allow merging across filtered material, the filtered material can only be on the
    // first sourcephrase of the merge, or there must be no filtered material on any
    // sourcephrase in the merge -- this protocol simplifies what we must test for). If the
    // merged source phrase starts a free translation, we will make all the restored
    // original sourcephrases be within that free translation, and if it also ends the free
    // translation, then the last of the restored ones will also end the retranslation
	bool bHasNonEmptyM_Markers = !pBigOne->m_markers.IsEmpty() ? TRUE : FALSE;
	bool bHasFreeTrans = pBigOne->m_bHasFreeTrans ? TRUE : FALSE;
	bool bStartsAFreeTranslation = pBigOne->m_bStartFreeTrans ? TRUE : FALSE;
	bool bEndsAFreeTranslation = pBigOne->m_bEndFreeTrans ? TRUE : FALSE;

    // BEW added 27Dec07: to handle preservation of any Note's m_bHasNote == TRUE value
    // across the unmerge; since we now allow a merge if filtered info is on the first word
    // or phrase in the selection
	bool bHasNote = pBigOne->m_bHasNote ? TRUE : FALSE; // the value is used below

	// set the first in the saved original srcPhrase objects to have sequ number as passed in
	SPList::Node* pos1;
	SPList* pSaved = pBigOne->m_pSavedWords;
	pos1 = pSaved->GetFirst();
	wxASSERT(pos1 != NULL);
	CSourcePhrase* pSP = (CSourcePhrase*)pos1->GetData();
	wxASSERT(pSP != NULL);
	pSP->m_nSequNumber = nStartingSequNum; // this ensures we renumber correctly using
										   // UpdateSequNum()
	pSP->m_bHasKBEntry = FALSE;
	pSP->m_bRetranslation = FALSE; // otherwise, after a wrong retranslation & cancel, it is
								   // possible to have this flag wrongly still set TRUE, & text
								   // of wrong colour shows

	// handle any initial filtered material, including any free translation which is filtered
	// and any Note's flag
	if (bHasNote)
	{
		pSP->m_bHasNote = pBigOne->m_bHasNote; // transfer the Note flag's value when TRUE
	}
	if (bHasNonEmptyM_Markers)
	{
		pSP->m_markers = pBigOne->m_markers; // transfer the material in m_markers to the first one
	}
	// handle the flag for commencement of a free translation section
	if (bStartsAFreeTranslation)
	{
		pSP->m_bStartFreeTrans = TRUE;
	}
	else
	{
		pSP->m_bStartFreeTrans = FALSE;
	}

	// insert, starting from tail, after the pBigOne, 
	// thereby preserving original element order
	pos1 = pSaved->GetLast(); 
	// now pos1 points at the last item of pBigOne's pSaved list
	wxASSERT(pos1 != NULL);
	bool bIsLast = TRUE;

    // wx Note: Get a node called newInsertBeforePos which points to the next node beyond
    // savePos in pList and use its position in the Insert() call (which only inserts
    // BEFORE the indicated position). The result should be that the insertions will get
    // placed in the list the same way that MFC's InsertAfter() places them.
	// BEW added 25Oct09: the above logic gives a crash if unmerging a merger at the
	// document's end. Therefore we need to test for this condition and when it occurs
	// we must insert a dummy CSourcePhrase pointer at the doc end so as to use it for
	// the initial "insert before" operation
	bool bDummyAdded = FALSE;
	SPList::Node* newInsertBeforePos = savePos->GetNext();
	if (newInsertBeforePos == NULL)
	{
		bDummyAdded = TRUE;
		CSourcePhrase* pDummySrcPhrase = new CSourcePhrase();
		newInsertBeforePos = pList->Append(pDummySrcPhrase);
		wxASSERT(newInsertBeforePos != NULL);
	}
	while (pos1 != NULL)
	{
		CSourcePhrase* pSP = (CSourcePhrase*)pos1->GetData();
		pos1 = pos1->GetPrevious();
		pSP->m_bHasKBEntry = FALSE;

		// wxList has no equivalent to InsertAfter(). The wxList Insert() method
		// inserts the new node BEFORE the current position/node. To emulate what
		// the MFC code does, we insert before using newInsertBeforePos.
		// wx note: If newInsertBeforePos is NULL, it means the insert position is
		// at the end of the list; in this case we just append the item to the end
		// of the list.
		if (newInsertBeforePos == NULL)
			pList->Append(pSP);
		else
			pList->Insert(newInsertBeforePos,pSP);

		// BEW added 13Mar09 for refactored layout
		GetDocument()->CreatePartnerPile(pSP);

		// since we must now insert before the inserted node above, we need to get a
		// previous node (which will actually be the just inserted source phrase)
		newInsertBeforePos = newInsertBeforePos->GetPrevious();

        // handle any free translation booleans needing to be set; a free translation is
        // either to be defined on all the original instances, or it is defined for none -
        // and if the merger was also the end of a free translation, then the end of the
        // originals must have the m_bEndFreeTrans flag set too
		if (bHasFreeTrans)
			pSP->m_bHasFreeTrans = TRUE;
		else
			pSP->m_bHasFreeTrans = FALSE;
		if (bIsLast)
		{
			if (bEndsAFreeTranslation)
				pSP->m_bEndFreeTrans = TRUE;
			else
				pSP->m_bEndFreeTrans = FALSE;
			bIsLast = FALSE; // prevent subsequent access to this block
		}

        // prior to version 2.0, unmerging cleared the m_adaption and m_targetStr members
        // on the restored original minimal sourcephrases. This is too severe a behaviour,
        // there is no good reason why any original adaptations can't remain in place and
        // their entries restored to the KB (if non-null), so this is what I will do here
        // now.
		if (!pSP->m_adaption.IsEmpty())
		{
			// restore its KB entry
			bool bOK;
			bOK = StoreText(pApp->m_pKB,pSP,pSP->m_adaption);
		}

		if (IsItNotInKB(pSP))
			pSP->m_bNotInKB = TRUE;
		else
			pSP->m_bNotInKB = FALSE;
		pSP->m_bRetranslation = FALSE; // otherwise, after a wrong retranslation & cancel, it is
									   // possible to have this flag wrongly still set TRUE, &
									   // text of wrong colour shows
	}
	// BEW added 25Oct09, remove the dummy CSOurcePhrase appended at the list end for 
	// supporting insertions, if we appended one above
	if (bDummyAdded)
	{
		SPList::Node* extraPos = pList->GetLast();
		wxASSERT(extraPos != NULL);
		CSourcePhrase* pDummySrcPhrase = extraPos->GetData();
		delete pDummySrcPhrase;
		pList->Erase(extraPos);
	}

    // pBigOne will not be needed any longer, and its KB stuff must be removed or reference
    // decremented; append any refString's m_translation to the pApp->m_targetPhrase, so
    // user can edit or delete the resulting composite string when the phraseBox is
    // eventually put up (note, next call, pRefString may point to <Not In KB>)
	CRefString* pRefString = GetRefString(GetKB(),pBigOne->m_nSrcWords,
											pBigOne->m_key,pBigOne->m_adaption);
	pList->DeleteNode(savePos);
	if (pBigOne->m_bHasKBEntry)
	{
		RemoveRefString(pRefString,pBigOne,pBigOne->m_nSrcWords);
		pBigOne->m_bHasKBEntry = FALSE;

		// set up pApp->m_targetPhrase using pBigOne's m_targetStr attribute
		if (pApp->m_targetPhrase.IsEmpty())
			pApp->m_targetPhrase = pBigOne->m_targetStr;
		else
			pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + pBigOne->m_targetStr;
	}
	else
	{
        // might have had save to KB suppression turned on, so check this case out too - if
        // the flag is set, we don't need to remove anything from the KB, but we do need to
        // set pApp->m_targetPhrase using the m_targetStr string's value
		if (pBigOne->m_bNotInKB)
		{
			if (pApp->m_targetPhrase.IsEmpty())
				pApp->m_targetPhrase = pBigOne->m_targetStr;
			else
			{
				if (!pBigOne->m_targetStr.IsEmpty())
					pApp->m_targetPhrase = pApp->m_targetPhrase + _T(" ") + pBigOne->m_targetStr;
			}
		}
	}

	if (pBigOne->m_pMedialMarkers->GetCount() > 0)
	{
		pBigOne->m_pMedialMarkers->Clear();
	}
	delete pBigOne->m_pMedialMarkers;
	pBigOne->m_pMedialMarkers = (wxArrayString*)NULL;
	if (pBigOne->m_pMedialPuncts->GetCount() > 0)
	{
		pBigOne->m_pMedialPuncts->Clear();
	}
	delete pBigOne->m_pMedialPuncts;
	pBigOne->m_pMedialPuncts = (wxArrayString*)NULL;
	if (pBigOne->m_pSavedWords->GetCount() > 0)
	{
		// only remove pointers, never delete the memory they point to, because
		// any copies of this source phrase will only have copied pointers in the sublist
		pBigOne->m_pSavedWords->Clear();
	}
	delete pBigOne->m_pSavedWords;
	pBigOne->m_pSavedWords = (SPList*)NULL;

	// BEW added 13Mar09 for refactor of layout; delete its partner pile too 
	GetDocument()->DeletePartnerPile(pBigOne);

	delete pBigOne;
	pBigOne = (CSourcePhrase*)NULL;

	// update the sequence numbers for elements subsequent to the first
	UpdateSequNumbers(nStartingSequNum);

    // BEW added 20May09, in the refactored layout, restoring original CSourcePhrase
    // instances requires CPile partners be created and inserted into equivalent positions
    // in the m_pileList list as for their CSourcePhrase partners in m_pSourcePhrases list,
    // but the newly created piles won't have their m_pOwningStrip member set (it will be
    // NULL) nor their m_nPile member set to a valid index, but to -1. Deleting the passed
    // in original CSourcePhrase (it was at the active location) results in m_pActivePile
    // which formerly pointed at its partner pile, and which also got freed, not pointing
    // at a valid CPile pointer in memory; so m_pActivePile has to be re-established here
    // before returning (in the legacy layout, m_pActivePile got reset after the layout was
    // rebuilt, but in our refactored approach, piles are persistent and so we have to
    // reestablish the active pile pointer before RecalcLayout() is called, because code in
    // the latter uses it)
	pApp->m_pActivePile = GetPile(nStartingSequNum);

	return nCount;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If the application is in glossing mode, or it is showing only the target text, or the
/// m_pActivePile pointer is NULL, or the active pile's m_pSrcPhrase is NULL, this handler
/// disables the "Unmake A Phrase" toolbar item and returns immediately.
/// If the App's m_selectionLine is not -1, and the App's m_selection list has exactly one
/// item in its list associated with a previous merger, or alternatively, if the App's
/// m_selectioniLine is -1, and the first item in in the active pile's m_selection is
/// associated with a previous merger, it enables the toolbar button, otherwise it disables
/// the toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRestore(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL || pApp->m_pActivePile->GetSrcPhrase() == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1 && pApp->m_selection.GetCount() == 1)
	{
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = cpos->GetData();
		CSourcePhrase* pSP = pCell->GetPile()->GetSrcPhrase();
		if (pSP->m_nSrcWords > 1)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
	else if (pApp->m_selectionLine == -1 && pApp->m_pTargetBox != NULL
										&& pApp->m_pTargetBox->IsShown())
	{
		CSourcePhrase* pSP = pApp->m_pActivePile->GetSrcPhrase();
		if (pSP->m_nSrcWords > 1)
			event.Enable(TRUE);
		else
			event.Enable(FALSE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::UnmergePhrase()
{
	wxCommandEvent dummyevent;
	OnButtonRestore(dummyevent); // since is protected, & 
			// we want to call it from OnChar() in CPhraseBox class
}

// removes a merged phrase by restoring it to a sequence of the original CSourcePhrase
// instances which were stored on the merged phrase at the time of merger
// BEW changed 27Dec07: unmerging when there was a note stored on the merger did not retain
// the m_bHasNote flag value by setting it on the first CSourcePhrase instance in the
// unmerged sequence, so I fixed it so it would do so
void CAdapt_ItView::OnButtonRestore(wxCommandEvent& WXUNUSED(event))
{
    // Since the Restore (Unmerge) toolbar button has an accelerator table hot key (CTRL-U
    // see CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even
    // when they are disabled, we must check for a disabled button and return if disabled.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_RESTORE))
	{
		::wxBell();
		return;
	}
    // In glossing mode (ie. actually glossing) I think I've managed to silently prevent
    // any unmerge from happening before OnButtonRestore( ) can get invoked. However, it
    // the user were to explicitly click the button, there is no recourse except to tell
    // him that the removing a merger is not available when doing glossing
	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_(
		"This particular operation is not available when you are glossing."),
		_T(""),wxICON_INFORMATION);
		return;
	}

	// must be adapting mode, so continue with the request
	CAdapt_ItDoc* pDoc = GetDocument();
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;
	CPile* pActivePile;
	CPile* pPile;
	CCellList::Node* pos;
	CSourcePhrase* pSrcPhrase;
	int nCount;
	int nSaveSequNum;

    // get the single selected CSourcePhrase instance, or the location of phrasebox if no
    // selection
	if (pApp->m_selectionLine != -1)
	{
		pos = pApp->m_selection.GetFirst();
		nCount = pApp->m_selection.GetCount();
		// BEW added 25Jun09 to make it safe if the user selects more than one word
		if (nCount > 1)
		{
			// it shouldn't be possible for control to come here, because the update
			// handlers would detect a multipile selection and disable the Restore button,
			// but just in case, ensure no harm is done if somehow this function is called
			RemoveSelection();
			wxMessageBox(_(
			"To undo a merger using a selection, select only one pile."),
			_T(""),wxICON_INFORMATION);
			return;
		}
		wxASSERT(nCount == 1); // must only be one

		CCell* pCell = (CCell*)pos->GetData();
		pos = pos->GetNext();
		pPile = pCell->GetPile(); // get the pile for this selection
		pStartingPile = pPile; // need this for later when we look up the strip which
							   // first pile is in prior to calling RecalcLayout()
		pSrcPhrase = pPile->GetSrcPhrase();
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything
												  // depends on it
		// the active location may be remote from where the unmerge is done, so make sure
		// the active strip is marked invalid too
		pDoc->ResetPartnerPileWidth(pSrcPhrase); // FALSE for param 
												 // bNoActiveLocationCalculation

        // there could be an edited phrase waiting for a RETURN key press, and the
        // selection may be on a different pile, in which case unless we update the active
        // pile's srcPhrase before doing the restore, the latter would be wrongly cleared
        // of its adaptation text, so we check for such a condition here & do the necessary
        // fixes before proceeding
		pActivePile = pApp->m_pActivePile;
		if (pActivePile != pStartingPile)
		{
            // the selected pile is not the active one, so update the active one then make
            // the selected one the active one; so store the translation in the knowledge
            // base
			MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);
			RemovePunctuation(pDoc, &pApp->m_targetPhrase, from_target_text);
			bool bOK = StoreText(pApp->m_pKB, pActivePile->GetSrcPhrase(), 
									pApp->m_targetPhrase);
			if (!bOK)
				return; // can't proceed until a valid adaption (which could be null) 
                        // is supplied for the former active pile's srcPhrase
			else
			{
				// make the pile at start of former strip have a new pointer - new layout
				// code will then tweak the layout from that point on; if there is no
				// former strip, use the current one instead
				int nFormerStrip = pActivePile->GetStripIndex();
				pDoc->ResetPartnerPileWidth(pActivePile->GetSrcPhrase()); // mark the
																// active strip invalid
				pApp->m_pTargetBox->ChangeValue(_T("")); // we don't want the former active 
										// pile's text to be carried to the selected pile
				int nCurStripIndex = pStartingPile->GetStripIndex();
				if (nCurStripIndex != nFormerStrip)
				{
					CStrip* pFormerStrip = (CStrip*)
										GetLayout()->GetStripArray()->Item(nFormerStrip);
#ifdef _ALT_LAYOUT_
					CPile* pItsFirstPile = pFormerStrip->GetPileByIndexInStrip(0);
#else
					CPile* pItsFirstPile = (CPile*)pFormerStrip->GetPilesArray()->Item(0);
#endif
					CSourcePhrase* pItsFirstSrcPhrase = pItsFirstPile->GetSrcPhrase();
					// also mark the former strip invalid (ensures we include all piles
					// that might require updating)
					pDoc->ResetPartnerPileWidth(pItsFirstSrcPhrase, TRUE); // TRUE is 
														// bNoActiveLocationCalculation
				}
			}
		}
		RemoveSelection();
	}
	else // there is no current selection
	{
        // no selection, so just remove the merger at wherever the phraseBox currently is
        // located 
		pPile = pApp->m_pActivePile;
		pStartingPile = pPile;
		pSrcPhrase = pPile->GetSrcPhrase();
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, 
												  // everything depends on it		
		pDoc->ResetPartnerPileWidth(pSrcPhrase); // FALSE for 
												 // bNoActiveLocationCalculation
	}

	// make m_targetPhrase cleared, as it must accumulate any existing translations
	// removed from the KB because of the earlier merge
	pApp->m_targetPhrase.Empty();

	// determine that it is a genuine non-minimal phrase. If it is, we must
	// restore the original list of minimal phrases (ie. words), and clear the
	// translations from the KB.
	wxASSERT(pSrcPhrase->m_nSrcWords > 1);
	int nNumElements = 1;
    // RestoreOriginalMinPhrases also appends any adaptation to m_targetPhrase; it also
    // updates sequ numbers after the restore is done; it calls CreatePartnerPile() for
    // each CSourcePhrase ptr it restores to the doc list, and calls DeletePartnerPile()
    // for before deleting the merged one
	nNumElements = RestoreOriginalMinPhrases(pSrcPhrase,nSaveSequNum);

    // at this point, m_targetPhrase will have the target text in it if the selection was
    // done by clicking with the mouse on the source line; but if the click was on the
    // target cell then the KB will have had the adaption text cleared (or refCount
    // reduced) and the target text will have been preserved only in the phraseBox itself;
    // so we must check for the latter case and restore the text before proceeding
	if (pApp->m_targetPhrase.IsEmpty())
		pApp->m_targetPhrase = pApp->m_pTargetBox->GetValue();

	// update the bundle indices
	int nExtras = nNumElements - 1;

	// BEW added 09Sep08 in support of vertical editing
	if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
	{
		gEditRecord.nAdaptationStep_EndingSequNum += nExtras;
		gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nExtras; // LHS can become -ve legally
		gEditRecord.nAdaptationStep_NewSpanCount += nExtras;
	}

	// pos is defined as CCellList node above, so we must use a different identifier here
	// since we want a SPList node
	SPList::Node* posSP;
	posSP = pSrcPhrases->Item(nSaveSequNum);
	wxASSERT(posSP != NULL);
	CSourcePhrase* pFirstSrcPhrase;
	pFirstSrcPhrase = (CSourcePhrase*)posSP->GetData();
	posSP = posSP->GetNext();
	wxASSERT(pFirstSrcPhrase != NULL);
	wxASSERT(pFirstSrcPhrase->m_nSrcWords == 1 || 
		pFirstSrcPhrase->m_nSrcWords == 0); // no phrases allowed
	wxASSERT(posSP != NULL);

	// ensure a correct active sequ num when done
	pApp->m_nActiveSequNum = nSaveSequNum;

	// recalculate the layout
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif

	// get a new (valid) active pile pointer, now that the layout is recalculated
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile != NULL);

    // look up the single src word in the KB; if we can get a translation for it, use that,
    // if not then just retain the old merged phrase's translation
	bool bWantSelect = FALSE;
	bool bGotTranslation;
	if (!gbSuppressLookup)
	{
		gbUnmergeJustDone = TRUE; // prevent second OnButtonRestore() call from within
								  // ChooseTranslation() within LookUpSrcWord() if user happens
								  // to cancel the Choose Translation dialog (see CPhraseBox code)
		bGotTranslation = pApp->m_pTargetBox->LookUpSrcWord(this, pApp->m_pActivePile);
		gbUnmergeJustDone = FALSE; // clear flag, ready for next time
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum); // restore pointer, since 
											// LookUpSrcWord() now calls RecalcLayout()
		if (bGotTranslation)
		{
			// we have to check here, in case the translation it found was a "<Not In KB>"
			// - in which case, we must display an empty box and ensure that the pile has an
			// asterisk above it, etc
			if (translation == _T("<Not In KB>"))
			{
				pApp->m_targetPhrase.Empty(); // phrase box must be shown empty
				pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
				pApp->m_pActivePile->GetSrcPhrase()->m_bNotInKB = TRUE;
				pApp->m_pActivePile->GetSrcPhrase()->m_adaption.Empty();
				pApp->m_pActivePile->GetSrcPhrase()->m_targetStr.Empty();
				bWantSelect = FALSE;
			}
			else
			{
				pApp->m_targetPhrase = translation; // set using the global var, 
													// set in LookUpSrcWord()
				bWantSelect = TRUE;
			}
		}
		else // no translation found
		{
			// do the copy of source instead, or nothing if Copy Source flag is not set
			if (pApp->m_bCopySource)
			{
                // copy source key only provided this is not a null source phrase, don't
                // want "..." copied!
				pApp->m_targetPhrase =
						CopySourceKey(pApp->m_pActivePile->GetSrcPhrase(), 
										pApp->m_bUseConsistentChanges);
				bWantSelect = TRUE;
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
			}
			else
			{
				pApp->m_targetPhrase.Empty();
				bWantSelect = FALSE;
			}
		}

		// need to recalc layout again
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pApp->m_pActivePile != NULL);
	}
	else // was suppressed, so clear the flag now
	{
		gbSuppressLookup = FALSE;
	}

	if (bWantSelect)
	{
		pApp->m_nStartChar = 0;
		pApp->m_nEndChar = -1;
	}
	else
	{
		int len = pApp->m_targetPhrase.Length();
		pApp->m_nStartChar = len;
		pApp->m_nEndChar = len;
	}
	Invalidate();
	GetLayout()->PlaceBox();
}

// return TRUE if the selection extended, FALSE if not (would be false only if at a
// boundary) m_pAnchor is always the pile at which the phraseBox currently is; this
// function is only for the ALT plus arrow key selection method
bool CAdapt_ItView::ExtendSelectionRight()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	// can't extend if we are showing only the target line
	if (gbShowTargetOnly)
		return TRUE; // don't want message about boundaries

	// remove an existing selection if it was not done using the arrow key, save
	// m_bRespectBoundaries across this operation
	bool bSaveFlag = pApp->m_bRespectBoundaries;

	if (pApp->m_selection.GetCount() > 0 && !pApp->m_bSelectByArrowKey)
	{
		RemoveSelection();
		Invalidate();
		GetLayout()->PlaceBox();
	}
	// restore flag (and button)
	if (bSaveFlag == FALSE)
	{
		OnButtonFromRespectingBdryToIgnoringBdry(dummyevent);
	}

	// need a CClientDC
	wxClientDC aDC(pApp->GetMainFrame()->canvas); 

	canvas->DoPrepareDC(aDC); //OnPrepareDC(&aDC); // adjust the origin

	CPile* pActivePile = pApp->m_pActivePile;
	wxASSERT(pActivePile != NULL);
	//pApp->m_pAnchor = pActivePile->m_pCell[1];
	pApp->m_pAnchor = pActivePile->GetCell(0);
	bool bSelExists = pApp->m_selection.GetCount() > 0;
	if (bSelExists && pApp->m_bSelectByArrowKey)
	{
        // if we are extending to the right in a selection to the left, we have to remove
        // the first pile's selection
		if (pApp->m_curDirection == left)
		{
			// find the leftmost cell of the selection
			CCellList::Node* cpos = pApp->m_selection.GetFirst();
			CCell* pLeftmost = (CCell*)cpos->GetData();

			// remove this cell's selection...
			// (next line, Do not use wxTRANSPARENT here!! 
			// it leaves any existing yellow background)
			aDC.SetBackgroundMode(pApp->m_backgroundMode); 
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pLeftmost->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pLeftmost->SetSelected(FALSE);

			// preserve record of the deselection
			CCellList::Node* pos = pApp->m_selection.GetFirst();
			if (pos != NULL)
				pApp->m_selection.DeleteNode(pos);

			// if the deselection brought us back to the anchor cell, then
			// remove the selection entirely (ie. remove anchor cell seln too)
			CCell* pNextCell = GetNextCell(pLeftmost,0);
			if (pNextCell != NULL)
			{
				CPile* pNextPile = pNextCell->GetPile();
				if (pNextPile == pActivePile)
				{
					// remove this pile's selection too
					pNextCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
					pNextCell->SetSelected(FALSE);

					// make all the parameter agree with no selection
					pApp->m_bSelectByArrowKey = FALSE;
					pApp->m_selectionLine = -1;
					pApp->m_pAnchor = NULL;
					pApp->m_selection.Clear();
					// TODO 30Jun09 Check if below is still needed
					gnSelectionLine = -1; // whm added 21Feb09 to get global 
										  // back in sync with reality
					gnSelectionStartSequNum = -1; // whm added 21Feb09 to get global
												  // back in sync with reality
					gnSelectionEndSequNum = -1; // whm added 21Feb09 to get global 
												// back in sync with reality
				}
			}
			else
			{
				wxMessageBox(_(
				"Error while trying to deselect a cell. Try selecting using the mouse instead.\n"),
                _T(""), wxICON_INFORMATION);
				RemoveSelection();	// whm added 7July06 to prevent crash when invoking
						// ALT+Rightarrow at end of document (avoids m_selectionLine becoming 1
						// while m_selection is empty. The crash would happen in a OnUpdateUI
						// handler that tests the status of m_selectionLine != -1
				return FALSE;
			}
#ifdef __WXMAC__
			pApp->GetMainFrame()->SendSizeEvent(); // this is needed for wxMAC to paint 
												   // the highlighted source correctly
#endif
			return TRUE;
		}

		// find the rightmost cell of the selection
		CCellList::Node* ccpos = pApp->m_selection.GetLast();
		CCell* pRightmost = (CCell*)ccpos->GetData();
		CPile* pRightPile = pRightmost->GetPile();

		if (pApp->m_bRespectBoundaries)
		{
			if (pRightPile->GetSrcPhrase()->m_bBoundary) // can't extend past a boundary
				return FALSE;
		}

		CCell* pNextCell = GetNextCell(pRightmost,0);
		
        // if vertical edit is in effect, and we are in adaptationsStep (glossesStep
        // doesn't allow this selection method because glossing mode doesn't), then check
        // that we've not encroached on the gray text to the right, if we have then beep
        // and remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			pRightPile = pNextCell->GetPile();
			if (pRightPile->GetSrcPhrase()->m_nSequNumber > 
					gEditRecord.nAdaptationStep_EndingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pNextCell != NULL)
		{
			wxASSERT(pNextCell != NULL);
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			pNextCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pNextCell->SetSelected(TRUE); // set m_bSelected to TRUE

			// preserve record of the selection
			pApp->m_selection.Append(pNextCell); 
			pApp->m_selectionLine = 0;
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the next cell. Try selecting with the mouse instead.\n"),
            _T(""), wxICON_INFORMATION);
			RemoveSelection();	// whm added 7July06 to prevent crash when invoking
					// ALT+Rightarrow at end of document (avoids m_selectionLine becoming 1
					// while m_selection is empty. The crash would happen in a OnUpdateUI
					// handler that tests the status of m_selectionLine != -1
			return FALSE;
		}
	}
	else
	{
		// no selection yet, so select the cell in the active pile before extending right
		pApp->m_bSelectByArrowKey = TRUE;
		pApp->m_curDirection = right;
		aDC.SetBackgroundMode(pApp->m_backgroundMode);
		aDC.SetTextBackground(wxColour(255,255,0)); // yellow
		CCell* pCell = pActivePile->GetCell(0);
		pCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
		pCell->SetSelected(TRUE);

		// preserve record of the selection
		pApp->m_selection.Append(pCell);
		pApp->m_selectionLine = 0;

		// now try extend it one cell right
		if (pApp->m_bRespectBoundaries)
		{
			if (pActivePile->GetSrcPhrase()->m_bBoundary) // can't extend past a boundary
				return FALSE;
		}
		CCell* pNextCell = GetNextCell(pCell,0);

        // if vertical edit is in effect, and we are in adaptationsStep (glossesStep
        // doesn't allow this selection method because glossing mode doesn't), then check
        // that we've not encroached on the gray text to the right, if we have then beep
        // and remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			CPile* pRightPile = pNextCell->GetPile();
			if (pRightPile->GetSrcPhrase()->m_nSequNumber > 
					gEditRecord.nAdaptationStep_EndingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pNextCell != NULL)
		{
			wxASSERT(pNextCell != NULL);
			pNextCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pNextCell->SetSelected(TRUE);

			// preserve record of the selection
			pApp->m_selection.Append(pNextCell);
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the next cell. Try selecting with the mouse instead.\n"),
            _T(""), wxICON_INFORMATION);
			RemoveSelection();	// whm added 7July06 to prevent crash when invoking
					// ALT+Rightarrow at end of document (avoids m_selectionLine becoming 1
					// while m_selection is empty. The crash would happen in a OnUpdateUI
					// handler that tests the status of m_selectionLine != -1
			return FALSE;
		}
	}
#ifdef __WXMAC__
	pApp->GetMainFrame()->SendSizeEvent(); // this is needed for wxMAC to paint 
										   // the highlighted source correctly
#endif
	return TRUE;
}

// return TRUE if the selection extended, FALSE if not (would be false only if at a
// boundary) this function works with selections on the 2nd line only; m_pAnchor is alway
// the pile at which the phraseBox currently is
bool CAdapt_ItView::ExtendSelectionLeft()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	// can't extend if we are showing only the target line
	if (gbShowTargetOnly)
		return TRUE; // don't want message about boundaries

	// remove an existing selection if it was not done using the arrow key, save
	// m_bRespectBoundaries across this operation
	bool bSaveFlag = pApp->m_bRespectBoundaries;
	if (pApp->m_selection.GetCount() > 0 && !pApp->m_bSelectByArrowKey)
	{
		RemoveSelection();
		Invalidate();
		GetLayout()->PlaceBox();
	}
	// restore flag (and button)
	if (bSaveFlag == FALSE)
	{
		OnButtonFromRespectingBdryToIgnoringBdry(dummyevent);
	}

	// need a CClientDC
	wxClientDC aDC(pApp->GetMainFrame()->canvas); 

	canvas->DoPrepareDC(aDC); //OnPrepareDC(&aDC); // adjust the origin

	CPile* pActivePile = pApp->m_pActivePile;
	wxASSERT(pActivePile != NULL);
	pApp->m_pAnchor = pActivePile->GetCell(0);
	bool bSelExists = pApp->m_selection.GetCount() > 0;
	if (bSelExists && pApp->m_bSelectByArrowKey)
	{
		// if we are backing up in a selection to the right, we have to remove
		// the last pile's selection
		if (pApp->m_curDirection == right)
		{
			// find the rightmost cell of the selection
			CCellList::Node* cpos = pApp->m_selection.GetLast();
			CCell* pRightmost = (CCell*)cpos->GetData();

			// remove this cell's selection...
			// For next line, do not use wxTRANSPARENT here!! 
			// it leaves any existing yellow background
			aDC.SetBackgroundMode(pApp->m_backgroundMode); 
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pRightmost->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pRightmost->SetSelected(FALSE); // set CCell::m_bSelected to FALSE

			// preserve record of the deselection
			CCellList::Node* pos = pApp->m_selection.GetLast();
			if (pos != NULL)
				pApp->m_selection.DeleteNode(pos);

			// if the deselection brought us back to the anchor cell, then
			// remove the selection entirely (ie. remove anchor cell selection too)
			CCell* pPrevCell = GetPrevCell(pRightmost,0);
			if (pPrevCell != NULL)
			{
				CPile* pPrevPile = pPrevCell->GetPile();
				if (pPrevPile == pActivePile)
				{
					// remove this pile's selection too
					pPrevCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
					pPrevCell->SetSelected(FALSE);

					// make all the parameter agree with no selection
					pApp->m_bSelectByArrowKey = FALSE;
					pApp->m_selectionLine = -1;
					pApp->m_pAnchor = NULL;
					pApp->m_selection.Clear();
					// TODO 30Jun09 Check if below is still needed
					gnSelectionLine = -1; // whm added 21Feb09 to get global 
										  // back in sync with reality
					gnSelectionStartSequNum = -1; // whm added 21Feb09 to get global 
												  // back in sync with reality
					gnSelectionEndSequNum = -1; // whm added 21Feb09 to get global 
												// back in sync with reality
				}
			}
			else // pPrevCell is NULL
			{
				wxMessageBox(_(
				"Error while trying to deselect a cell. Try selecting using the mouse instead.\n"),
                _T(""), wxICON_INFORMATION);
				return FALSE;
			}
#ifdef __WXMAC__
			pApp->GetMainFrame()->SendSizeEvent(); // this is needed for wxMAC to paint 
												   // the highlighted source correctly
#endif
			return TRUE;
		}
		// find the leftmost cell of the selection
		CCellList::Node* fpos = pApp->m_selection.GetFirst();
		CCell* pLeftmost = fpos->GetData();
		//CCell* pPrevCell = GetPrevCell(pLeftmost,1);
		CCell* pPrevCell = GetPrevCell(pLeftmost,0);

        // if vertical edit is in effect, and we are in adaptationsStep (glossesStep
        // doesn't allow this selection method because glossing mode doesn't), then check
        // that we've not encroached on the gray text to the left, if we have then beep and
        // remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			CPile* pPrevPile = pPrevCell->GetPile();
			if (pPrevPile->GetSrcPhrase()->m_nSequNumber < 
					gEditRecord.nAdaptationStep_StartingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pPrevCell != NULL)
		{
			wxASSERT(pPrevCell != NULL);
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			CPile* pPrevPile = pPrevCell->GetPile();

			if (pApp->m_bRespectBoundaries)
			{
				if (pPrevPile->GetSrcPhrase()->m_bBoundary) // can't extend left on to a boundary
					return FALSE;
			}

			pPrevCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pPrevCell->SetSelected(TRUE);

			// preserve record of the selection
			pApp->m_selection.Insert(pPrevCell);
			pApp->m_selectionLine = 0;
		}
		else // pPrevCell is NULL
		{
			wxMessageBox(_(
			"Could not get a pointer to the previous cell. Try selecting with the mouse instead.\n"
			), _T(""), wxICON_INFORMATION);
			return FALSE;
		}
	}
	else
	{
		// no selection yet, so select the cell in the active pile before extending left
		pApp->m_bSelectByArrowKey = TRUE;
		pApp->m_curDirection = left;
		aDC.SetBackgroundMode(pApp->m_backgroundMode);
		aDC.SetTextBackground(wxColour(255,255,0)); // yellow
		CCell* pCell = pActivePile->GetCell(0);
		pCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
		pCell->SetSelected(TRUE);

		// preserve record of the selection
		pApp->m_selection.Insert(pCell);
		pApp->m_selectionLine = 0;

		// now try extend it one cell left
		CCell* pPrevCell = GetPrevCell(pCell,0);
		if (pPrevCell == NULL) // whm added to prevent crash when phrasebox is in first pile
		{
			// we're at the first pile in the doc and can't move left
			RemoveSelection(); // whm added; if test were at top of current 
							   // else block this wouldn't be needed
			return FALSE;
		}
		wxASSERT(pPrevCell != NULL);
		CPile* pPrevPile = pPrevCell->GetPile();
		wxASSERT(pPrevPile != NULL);
		if (pApp->m_bRespectBoundaries)
		{
			if (pPrevPile->GetSrcPhrase()->m_bBoundary) // can't extend past a boundary
			{
				// whm added below for situation when phrasebox is at last pile in doc and a
				// boundary prevents selecting previous pile.
				CCell* pNextCell = GetNextCell(pCell,0);
				if (pNextCell == NULL)
				{
					RemoveSelection();
				}
				return FALSE;
			}
		}

        // if vertical edit is in effect, and we are in adaptationsStep (glossesStep
        // doesn't allow this selection method because glossing mode doesn't), then check
        // that we've not encroached on the gray text to the left, if we have then beep and
        // remove the selection
		if (gbVerticalEditInProgress && gEditStep == adaptationsStep)
		{
			if (pPrevPile->GetSrcPhrase()->m_nSequNumber < 
					gEditRecord.nAdaptationStep_StartingSequNum)
			{
				RemoveSelection();
				return FALSE;
			}
		}
		if (pPrevCell != NULL)
		{
			pPrevCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			pPrevCell->SetSelected(TRUE);

			// preserve record of the selection
			pApp->m_selection.Insert(pPrevCell);
		}
		else
		{
			wxMessageBox(_(
			"Could not get a pointer to the previous cell. Try selecting with the mouse instead.\n"
			), _T(""), wxICON_INFORMATION);
			return FALSE;
		}
	}
#ifdef __WXMAC__
	pApp->GetMainFrame()->SendSizeEvent(); // this is needed for wxMAC to paint 
										   // the highlighted source correctly
#endif
	return TRUE;
}

// pass in a pile pointer which we want to know whether or not it is in the gray text area;
// the gEditStep is a global, so does not need to be passed in; return TRUE if the pile is
// in the editabe area, FALSE if in the gray area, and if a NULL pile is passed in, treat
// it as equivalent to being in the gray area (ie. return FALSE)
bool CAdapt_ItView::CheckForVerticalEditBoundsError(CPile* pPile)
{
	//bool bBadSwitchValue = FALSE;
	if (pPile == NULL)
		return FALSE;
	int nLeftBoundSN = 0; // whm initialized to avoid "potentially uninitialized local 
						  // variable ... used" warning
	int nRightBoundSN = 0; // whm initialized to avoid "potentially uninitialized local 
						   // variable ... used" warning
	if (gbVerticalEditInProgress && 
		(gEditStep == adaptationsStep ||
		gEditStep == glossesStep ||
		gEditStep == freeTranslationsStep
		))
	{
		switch(gEditStep)
		{
		case adaptationsStep:
			nLeftBoundSN = gEditRecord.nAdaptationStep_StartingSequNum;
			nRightBoundSN = gEditRecord.nAdaptationStep_EndingSequNum;
			break;
		case glossesStep:
			nLeftBoundSN = gEditRecord.nGlossStep_StartingSequNum;
			nRightBoundSN = gEditRecord.nGlossStep_EndingSequNum;
			break;
		case freeTranslationsStep:
			nLeftBoundSN = gEditRecord.nFreeTranslationStep_StartingSequNum;
			nRightBoundSN = gEditRecord.nFreeTranslationStep_EndingSequNum;
			break;
		case noEditStep:
			break;
		case sourceTextStep:
			break;
		case backTranslationsStep:
			break;
		}
		if ((pPile->GetSrcPhrase()->m_nSequNumber < nLeftBoundSN)
			||(pPile->GetSrcPhrase()->m_nSequNumber > nRightBoundSN))
		{
			RemoveSelection();
			::wxBell();
			return FALSE;
		}
	}
	return TRUE;
}

void CAdapt_ItView::MergeWords()
{
	wxCommandEvent dummyevent;
	OnButtonMerge(dummyevent);
}

// return TRUE if all was well, FALSE if unable to store (the caller should use the FALSE
// value to block a move of the phraseBox to another pile) This function's behaviour was
// changed after version1.2.8, on May 6 2002, in order to eliminate the occurence of the
// "Empty Adaption Dialog" which would come up whenever the user deleted the contents of
// the phrase box and then moved on, or clicked elsewhere. The new default behaviour is
// that if the box is empty when the user causes it to move, then nothing is stored in the
// knowledge base and the move is acted on immediately. If the user wants to store a <no
// adaptation> empty entry in the KB, a button "<no adaptation>" has been provided on the
// control bar. Click it before moving the phrase box to cause an empty adaptation to be
// stored in the KB for the source text at the current active location. version 2.0 and
// onward tests gbIsGlossing for storing to the appropriate KB, etc. For adaptation, on
// input the tgtPhrase parameter should have the text with punctuation removed, so this is
// typically done in the caller with a call to RemovePunctuation( ). For versions prior to
// 4.1.0, in order to support the user overriding the stored punctuation for the source
// text, a call to MakeLineFourString( ) is done in the caller, and then RemovePunctuation(
// ) is called in the caller, so a second call of MakeLineFourString( ) within StoreText( )
// is not required in this circumstance - in this case, a global boolean
// gbInhibitLine4StrCall is used to jump the call within StoreText( ). For 4.1.0 and later,
// MakeLineFourString() is not now called. See below.
// 
// Ammended, July 2003, for Auto-Capitalization support
bool CAdapt_ItView::StoreText(CKB *pKB, CSourcePhrase *pSrcPhrase, wxString &tgtPhrase, 
										bool bSupportNoAdaptationButton)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// determine the auto caps parameters, if the functionality is turned on
	bool bNoError = TRUE;

    // do not permit storage if the source phrase has an empty key (eg. user may have ...
    // ellipsis in the source text, which generates an empty key and three periods in the
    // punctuation)
	if (pSrcPhrase->m_key.IsEmpty())
	{
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // this is not an error, just suppression of the store
	}

	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pSrcPhrase->m_key); // for source word or phrase
	}

    // If the source word (or phrase) has not been previously encountered, then
    // m_bHasKBEntry (or the equiv flag if glossing is ON) will be false, which has to be
    // true for the StoreText call not to fail. But if we have come to an entry in the KB
    // which we are about to add a new adaptation (or gloss) to it, then the flag will be
    // TRUE (and rightly so.) The StoreText call would then fail - so we will test for this
    // possibility and clear the appropriate flag if necessary.
    // BEW 05July2006: No! The above comment confuses the KB entry with the CSourcePhrase
    // instance at the active location. The flags we are talking about declare that that
    // PARTICULAR instance in the DOCUMENT does, or does not, yet have a KB entry. When the
    // phrase box lands there, it gets its KB entry removed (or ref count decremented)
    // before a store is done, and so the flags are made false when the former happens.
    // RemoveRefString() was supposed to do that, but my logic error was there as well
    // (I've fixed it now). So before the store it done, the RemoveRefString call will now
    // clear the relevant flag; so we don't need to test and clear it in the following
    // block. (block below removed, but the comments are retained in case useful)
	GetDocument()->Modify(TRUE);

    // BEW added 20Apr06, to store <Not In KB> when gbSuppressStoreForAltBackspaceKeypress
    // flag is TRUE - as wanted by Bob Eaton; we support this only in adapting mode, not
    // glossing mode
	if (!gbIsGlossing && gbSuppressStoreForAltBackspaceKeypress)
	{
		wxString strNot = _T("<Not In KB>");
		// rest of this block's code is a simplification of code from later in StoreText()
		int nMapIndex;
		if (gbIsGlossing)
			nMapIndex = 0; // always an index of zero when glossing
		else
			nMapIndex = pSrcPhrase->m_nSrcWords - 1; // index to the appropriate map

        // if we have too many source words, then we cannot save to the KB, so beep - this
        // is unlikely to be the case when Bob's modification is being used.
		if (!gbIsGlossing && pSrcPhrase->m_nSrcWords > MAX_WORDS)
		{
			::wxBell(); //MessageBeep(0);
			return TRUE;
		}

		// continue the storage operation
		wxString unchangedkey = pSrcPhrase->m_key;
		wxString key = AutoCapsMakeStorageString(pSrcPhrase->m_key); // key might be made lower case
		CTargetUnit* pTU;
		CRefString* pRefString;
		if (pKB->m_pMap[nMapIndex]->empty())
		{
			pTU = new CTargetUnit;
			pRefString = new CRefString(pTU); // the pTU argument sets the m_pTgtUnit member
			pRefString->m_refCount = 1; // set the count
			pRefString->m_translation = strNot;
			pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
			pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
			if (gbIsGlossing)
			{
				pSrcPhrase->m_bHasGlossingKBEntry = TRUE; // glossing KB has to treat 
														  // <Not In KB> as a 'real' gloss
				(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in the map
				pKB->m_nMaxWords = 1;
			}
			else
			{
				pSrcPhrase->m_bHasKBEntry = FALSE; // it's not a 'real' entry
				pSrcPhrase->m_bNotInKB = TRUE;
				pSrcPhrase->m_bBeginRetranslation = FALSE;
				pSrcPhrase->m_bEndRetranslation = FALSE;

				(*pKB->m_pMap[nMapIndex])[key] = pTU;
				if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
					pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
			}
		}
		else // this block for when map is not empty
		{
			// there might be a pre-existing association between this key and a CTargetUnit,
			// so check it out
			bool bFound = AutoCapsLookup(pKB->m_pMap[nMapIndex], pTU, unchangedkey);

			// we won't check we have a valid pTU .. so a block of code omitted here

            // if not found on the lookup, then create a targetUnit, and add the refString,
            // etc, but if one is found, then check whether we add a new refString or
            // increment the refCount of an existing one
			if(!bFound)
			{
				pTU = new CTargetUnit;
				pRefString = new CRefString(pTU);
				pRefString->m_refCount = 1; // set the count
				pRefString->m_translation = strNot;
				pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
				pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
				if (gbIsGlossing)
				{
					pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					(*pKB->m_pMap[nMapIndex])[key] = pTU;
					pKB->m_nMaxWords = 1;
				}
				else
				{
					pSrcPhrase->m_bHasKBEntry = FALSE;
					pSrcPhrase->m_bNotInKB = TRUE;
					(*pKB->m_pMap[nMapIndex])[key] = pTU;
					if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
						pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
				}
			}
			else // we found one
			{
                // we found a pTU for this key, so check for a matching CRefString, if
                // there is no match, then add a new one (note: no need to set m_nMaxWords
                // for this case)
				bool bMatched = FALSE;
				pRefString = new CRefString(pTU);
				pRefString->m_refCount = 1; // set the count, assuming this will
											// be stored (it may not be)
				pRefString->m_translation = strNot;

				TranslationsList::Node* pos = pTU->m_pTranslations->GetFirst();
				while (pos != NULL)
				{
					CRefString* pRefStr = (CRefString*)pos->GetData();
					pos = pos->GetNext();
					wxASSERT(pRefStr != NULL);

					// does it match?
					if (*pRefStr == *pRefString) // TRUE if pRStr->m_translation == 
												 //         pRefString->m_translation
					{
						// if we get a match, then increment ref count and point to this,
						// etc 
						bMatched = TRUE;
						pRefStr->m_refCount++;
						if (gbIsGlossing)
						{
							pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
						}
						else
						{
							pSrcPhrase->m_bHasKBEntry = FALSE;
							pSrcPhrase->m_bNotInKB = TRUE;
							pSrcPhrase->m_bBeginRetranslation = FALSE;
							pSrcPhrase->m_bEndRetranslation = FALSE;
						}
						delete pRefString; // don't need this one
						break;
					}
				}
                // if we get here with bMatched == FALSE, then there was no match, so this
                // must somehow be a normal entry, so we don't add anything and just return
				return TRUE;
			}
		}
		return TRUE;
	}
	gbByCopyOnly = FALSE; // restore default setting

	// First get rid of final spaces, if tgtPhrase has content
	int len;
	int nIndexLast;
	if (!tgtPhrase.IsEmpty())
	{
		len = tgtPhrase.Length();
		nIndexLast = len-1;
		do {
			if (tgtPhrase.GetChar(nIndexLast) == _T(' '))
			{
				// Note: wsString::Remove must have the second param as 1 here otherwise
				// it will truncate the remainder of the string!
				tgtPhrase.Remove(nIndexLast,1);
				len = tgtPhrase.Length();
				nIndexLast = len -1;
			}
			else
			{
				break;
			}
		} while (len > 0 && nIndexLast > -1);
	}

    // always place a copy in the source phrase's m_adaption member, unless it is <Not In
    // KB>; when glossing always place a copy in the m_gloss member.
	if (gbIsGlossing)
	{
		wxString s = tgtPhrase;
		if (gbAutoCaps)
		{
			bool bNoError = TRUE;
			if (gbSourceIsUpperCase && !gbMatchedKB_UCentry)
			{
				bNoError = SetCaseParameters(s,FALSE);
				if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
				{
					// change it to upper case
					s.SetChar(0,gcharNonSrcUC);
				}
			}
		}
		pSrcPhrase->m_gloss = s;
	}
	else // currently adapting
	{
		if (tgtPhrase != _T("<Not In KB>"))
		{
			pSrcPhrase->m_adaption = tgtPhrase;
			if (!gbInhibitLine4StrCall)
				MakeLineFourString(pSrcPhrase, tgtPhrase); // set m_targetStr member too
		}
	} 
    // if the source phrase is part of a retranslation, we allow updating of the m_adaption
    // attribute only (since this is the only place where retranslations are stored), but
    // suppress saving to the KB. For support of glossing, we must skip this block if
    // glossing is ON because glossing does not care about retranslations - the user needs
    // to be able to gloss the source words in a retranslation just like the rest of it
	if (!gbIsGlossing && pSrcPhrase->m_bRetranslation)
	{
		if (!pApp->m_bSaveToKB)
			pApp->m_bSaveToKB = TRUE; // ensure this flag is turned back on
		pApp->m_bForceAsk = FALSE; // also must be cleared prior to next save attempt
		pSrcPhrase->m_bHasKBEntry = FALSE;
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // the caller must treat this as a valid 'save' operation
	}

    // if the user doesn't want a store done (he checked the dialog bar's control for this
    // choice) then return, without saving, after setting the source phrases m_bNotInKB
    // flag to TRUE (ignore this block when glossing)
	if (!gbIsGlossing && !pApp->m_bSaveToKB)
	{
		pSrcPhrase->m_bNotInKB = TRUE;
		pApp->m_bForceAsk = FALSE; // have to turn this off too, since 
								   // this is regarded as a valid 'store' op
		pSrcPhrase->m_bHasKBEntry = FALSE;
		pSrcPhrase->m_bBeginRetranslation = FALSE;
		pSrcPhrase->m_bEndRetranslation = FALSE;
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // we want the caller to think all is well
	}

    // if there is a CTargetUnit associated with the current key, then get it; if not,
    // create one and add it to the appropriate map; we start by computing which map we
    // need to store to
	int nMapIndex;
	if (gbIsGlossing)
		nMapIndex = 0; // always an index of zero when glossing
	else
		nMapIndex = pSrcPhrase->m_nSrcWords - 1; // index to the appropriate map

    // if we have too many source words, then we cannot save to the KB, so detect this and
    // warn the user that it will not be put in the KB, then return TRUE since all is
    // otherwise okay (this will be handled as a retranslation, by default) The following
    // comment is for when glossing... Note: if the source phrase is part of a
    // retranslation, we allow updating of the m_gloss attribute, and we won't change any
    // of the retranslation supporting flags; so it is therefore possible for
    // m_bRetranslation to be TRUE, and also for m_bHasGlossingKBEntry to be TRUE.
	if (!gbIsGlossing && pSrcPhrase->m_nSrcWords > MAX_WORDS)
	{
		pSrcPhrase->m_bNotInKB = FALSE;
		pSrcPhrase->m_bHasKBEntry = FALSE;
		//IDS_TOO_MANY_SRC_WORDS
		wxMessageBox(_(
"Warning: there are too many source language words in this phrase for this adaptation to be stored in the knowledge base."),
		_T(""),wxICON_INFORMATION);
		gbMatchedKB_UCentry = FALSE;
		return TRUE;
	}

	// continue the storage operation
	wxString unchangedkey = pSrcPhrase->m_key; // this never has case change done
											  // to it (need this for lookups)
	wxString key = AutoCapsMakeStorageString(pSrcPhrase->m_key); // key might be 
															// made lower case
	CTargetUnit* pTU;
	CRefString* pRefString;
	if (pKB->m_pMap[nMapIndex]->empty())
	{
		// we just won't store anything if the target phrase has no content, when
		// bSupportNoAdaptationButton has it's default value of FALSE, but if TRUE
		// then we skip this block so that we can store an empty string as a valid
		// KB "adaptation" or "gloss" - depending on which KB is active here
		if (tgtPhrase.IsEmpty())
		{
			if(!bSupportNoAdaptationButton)
			{
				if (!gbIsGlossing)
				{
					pSrcPhrase->m_bBeginRetranslation = FALSE;
					pSrcPhrase->m_bEndRetranslation = FALSE;
				}
				pApp->m_bForceAsk = FALSE; // make sure it's turned off
				gbMatchedKB_UCentry = FALSE;
				return TRUE; // make caller think all is well
			}
		}
		
		// we didn't return, so continue on to creaete a new CTargetUnit for storing to
		pTU = new CTargetUnit;
		wxASSERT(pTU != NULL);
		pRefString = new CRefString(pTU);
		wxASSERT(pRefString != NULL);

		pRefString->m_refCount = 1; // set the count
		// add the translation string
		if (bNoError)
		{
			pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
		}
		else
		{
			// if something went wrong, just save as if gbAutoCaps was FALSE
			pRefString->m_translation = tgtPhrase;
		}
		pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
		if (pApp->m_bForceAsk)
		{
			pTU->m_bAlwaysAsk = TRUE; // turn it on if user wants to be given
					// opportunity to add a new refString next time its matched
		}

		pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
		if (gbIsGlossing)
		{
			pSrcPhrase->m_bHasGlossingKBEntry = TRUE; // tell the src phrase it has
													 // an entry in the glossing KB
			(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in the map

			// update the maxWords limit - for glossing it is always set to 1
			pKB->m_nMaxWords = 1;
		}
		else
		{
			pSrcPhrase->m_bHasKBEntry = TRUE; // tell the src phrase it has 
											  // an entry in the KB

			// it can't be a retranslation, so ensure the next two flags are cleared
			pSrcPhrase->m_bBeginRetranslation = FALSE;
			pSrcPhrase->m_bEndRetranslation = FALSE;

			(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in the 
												  // map with appropriate index
			// update the maxWords limit
			if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
				pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
		}
	}
	else // the block below is for when the map is not empty
	{
		// there might be a pre-existing association between this key and a CTargetUnit,
		// so check it out
		bool bFound = AutoCapsLookup(pKB->m_pMap[nMapIndex], pTU, unchangedkey);

		// check we have a valid pTU
		if (bFound && pTU->m_pTranslations->IsEmpty())
		{
			// this is an error condition, targetUnits must NEVER have an 
			// empty m_translations list
			// IDS_BAD_TGTUNIT_ERR
			wxMessageBox(_T(
"Warning: the current storage operation has been skipped, and a bad storage element has been deleted."),
			_T(""), wxICON_EXCLAMATION);

			// fix the error
			TUList::Node* pos = pKB->m_pTargetUnits->Find(pTU); // find position of the
														   // bad targetUnit in the list
			// get the targetUnit in the list
			CTargetUnit* pTgtUnit = (CTargetUnit*)pos->GetData();
			wxASSERT(pTgtUnit != NULL && pTgtUnit->m_pTranslations->IsEmpty()); // have we
																	// found the bad one?
			pKB->m_pTargetUnits->DeleteNode(pos); // remove it from the list
			delete pTgtUnit; // delete it from the heap
			pTgtUnit = (CTargetUnit*)NULL;

			MapKeyStringToTgtUnit* pMap = pKB->m_pMap[nMapIndex];
			int bRemoved;
			if (gbAutoCaps && gbSourceIsUpperCase && !gbMatchedKB_UCentry)
				bRemoved = pMap->erase(key); // remove the changed to lc entry from the map
			else
				bRemoved = pMap->erase(unchangedkey); // remove the unchanged one from the map
			wxASSERT(bRemoved == 1);
			pApp->m_bSaveToKB = TRUE; // ensure its back on (if here from a choice not 
				// save to KB, this will be cleared by OnCheckKBSave, preserving user choice)
			gbMatchedKB_UCentry = FALSE;
			return FALSE;
		}

		// if not found, then create a targetUnit, and add the refString, etc, as above;
		// but if one is found, then check whether we add a new refString or increment the
		// refCount of an existing one
		if(!bFound)
		{
			// we just won't store anything if the target phrase has no content, when
			// bSupportNoAdaptationButton has it's default value of FALSE, but if TRUE
			// then we skip this block so that we can store an empty string as a valid
			// KB "adaptation" or "gloss" - depending on which KB is active here
			if (tgtPhrase.IsEmpty())
			{
				if(!bSupportNoAdaptationButton)
				{
					if (!gbIsGlossing)
					{
						pSrcPhrase->m_bBeginRetranslation = FALSE;
						pSrcPhrase->m_bEndRetranslation = FALSE;
					}
					pApp->m_bForceAsk = FALSE; // make sure it's turned off
					gbMatchedKB_UCentry = FALSE;
					return TRUE; // make caller think all is well
				}
			}

			pTU = new CTargetUnit;
			wxASSERT(pTU != NULL);
			pRefString = new CRefString(pTU);
			wxASSERT(pRefString != NULL);

			pRefString->m_refCount = 1; // set the count
			// add the translation or gloss string
			pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
			pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
			if (pApp->m_bForceAsk)
			{
				pTU->m_bAlwaysAsk = TRUE; // turn it on if user wants to be given
					// opportunity to add a new refString next time its matched
			}

			pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
			if (gbIsGlossing)
			{
				pSrcPhrase->m_bHasGlossingKBEntry = TRUE;

				(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in 
						// the map with appropr. index (key may have been made lc)
				// update the maxWords limit - for glossing it is always set to 1
				pKB->m_nMaxWords = 1;
			}
			else
			{
				pSrcPhrase->m_bHasKBEntry = TRUE;

				(*pKB->m_pMap[nMapIndex])[key] = pTU; // store the CTargetUnit in
						// the map with appropr. index (key may have been made lc)
				// update the maxWords limit
				if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
					pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
			}
		}
		else // we found one
		{
            // we found a pTU for this key, so check for a matching CRefString, if there is
            // no match, then add a new one (note: no need to set m_nMaxWords for this
            // case)
			bool bMatched = FALSE;
			pRefString = new CRefString(pTU);
			wxASSERT(pRefString != NULL);
			pRefString->m_refCount = 1; // set the count, assuming this will be stored
										// (it may not be)
            // set its gloss or adaptation string; the fancy test is required because the
            // refStr entry may have been stored in the kb when auto-caps was off, and if
            // it was upper case for the source text's first letter, then it will have been
            // looked up only on the second attempt, for which gbMatchedKB_UCentry will
            // have been set TRUE, and which means the gloss or adaptation will not have
            // been made lower case - so we must allow for this possibility
			if ((gbAutoCaps && gbMatchedKB_UCentry) || !gbAutoCaps)
				pRefString->m_translation = tgtPhrase; // use the unchanged string, 
													   // could be uc
			else
				pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);

			TranslationsList::Node* pos = pTU->m_pTranslations->GetFirst();
			while (pos != NULL)
			{
				CRefString* pRefStr = pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pRefStr != NULL);

				// does it match?
				if (*pRefStr == *pRefString) // TRUE if pRStr->m_translation ==
											 //         pRefString->m_translation
				{
					// if we get a match, then increment ref count and point to this, etc
					bMatched = TRUE;
					pRefStr->m_refCount++;
					if (gbIsGlossing)
					{
						pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					}
					else
					{
						pSrcPhrase->m_bHasKBEntry = TRUE;
						pSrcPhrase->m_bBeginRetranslation = FALSE;
						pSrcPhrase->m_bEndRetranslation = FALSE;
					}
					delete pRefString; // don't need this one
					pRefString = (CRefString*)NULL;
					if (pApp->m_bForceAsk)
					{
						pTU->m_bAlwaysAsk = TRUE; // nTrCount might be 1, so we must
								// ensure it gets set if that is what the user wants
					}
					break;
				}
			}
            // if we get here with bMatched == FALSE, then there was no match, so we must
            // add the new pRefString to the targetUnit, but if it is already an <Not In
            // KB> entry, then the latter must override (to prevent <Not In KB> and <no
            // adaptation> or a nonempty adaptation or gloss being two ref strings for the
            // one key -- when adapting; for glossing this cannot happen)
			if (!bMatched)
			{
				TranslationsList::Node* tpos = pTU->m_pTranslations->GetFirst();
				CRefString* pRefStr = (CRefString*)tpos->GetData();
				if (!gbIsGlossing && pRefStr->m_translation == _T("<Not In KB>"))
				{
                    // keep it that way (the way to cancel this setting is with the toolbar
                    // checkbox) But leave m_adaption and m_targetStr (or m_gloss) having
                    // whatever the user may have typed
					pSrcPhrase->m_bHasKBEntry = FALSE;
					pSrcPhrase->m_bNotInKB = TRUE;
					pSrcPhrase->m_bBeginRetranslation = FALSE;
					pSrcPhrase->m_bEndRetranslation = FALSE;
					delete pRefString; // don't leak memory
					pRefString = (CRefString*)NULL;
					pApp->m_bForceAsk = FALSE;
					gbMatchedKB_UCentry = FALSE;
					return TRUE; // all is well
				}
				else // either we are glossing, or we are adapting 
					  // and it's a normal adaptation
				{
					// is the pApp->m_targetPhrase empty?
					if (tgtPhrase.IsEmpty())
					{
                        // we just won't store anything if the target phrase has no
                        // content, when bSupportNoAdaptationButton has it's default value
                        // of FALSE, but if TRUE then we skip this block so that we can
                        // store an empty string as a valid KB "adaptation" or "gloss" -
                        // depending on which KB is active here
						if(!bSupportNoAdaptationButton)
						{
							if (!gbIsGlossing)
							{
								pSrcPhrase->m_bBeginRetranslation = FALSE;
								pSrcPhrase->m_bEndRetranslation = FALSE;
							}
							pApp->m_bForceAsk = FALSE; // make sure it's turned off
							delete pRefString; // don't leak the memory
							pRefString = (CRefString*)NULL;
							gbMatchedKB_UCentry = FALSE;
							return TRUE; // make caller think all is well
						}
					}

					// recalculate the string to be stored, in case we looked up a
					// stored upper case entry earlier
					pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
					pTU->m_pTranslations->Append(pRefString);
					if (gbIsGlossing)
					{
						pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					}
					else
					{
						pSrcPhrase->m_bHasKBEntry = TRUE;
						pSrcPhrase->m_bBeginRetranslation = FALSE;
						pSrcPhrase->m_bEndRetranslation = FALSE;
					}
				}
			}
		}
	}
	if (!gbIsGlossing)
		pSrcPhrase->m_bNotInKB = FALSE; // ensure correct flag value, 
										// in case it was not in the KB
	pApp->m_bForceAsk = FALSE; // must be turned off, as it applies
							   // to the current store operation only
	gbMatchedKB_UCentry = FALSE;
	return TRUE;
}

void CAdapt_ItView::RemoveFinalSpaces(CPhraseBox* pBox, wxString* pStr)
{
	// empty strings don't need anything done
	if (pStr->IsEmpty())
		return;

	// remove any phrase final space characters
	bool bChanged = FALSE;
	int len = pStr->Length();
	int nIndexLast = len-1;
	do {
		if (pStr->GetChar(nIndexLast) == _T(' '))
		{
			// Note: wsString::Remove must have the second param as 1 here otherwise
			// it will truncate the remainder of the string!
			pStr->Remove(nIndexLast,1);
			// can't trust the Delete's returned value, it exceeds string length by one
			len = pStr->Length();
			nIndexLast = len -1;
			bChanged = TRUE;
		}
		else
		{
			break;
		}
	} while (len > 0 && nIndexLast > -1);

	if (bChanged) // need to do this, because for some reason rubbish is getting 
            // left in the earlier box when the ChooseTranslation dialog gets put up. That
            // is, a simple call of SetWindowText with parameter pStr cast to (const char
            // *) doesn't work right; but the creation & setting of str below fixes it
	{
		wxString str = *pStr;
		pBox->ChangeValue(str);
	}

}


// BEW added 30Apr08, an overloaded version which deletes final spaces in any CString's
// text, and if there are only spaces in the string, it reduces it to an empty string
void CAdapt_ItView::RemoveFinalSpaces(wxString& rStr)
{
    // whm Note: This could be done with a single line in wx, i.e., rStr.Trim(TRUE), but
    // we'll go with the MFC version for now.
	if (rStr.IsEmpty())
		return;
	rStr = MakeReverse(rStr);
	wxChar chFirst = rStr[0];
	while (chFirst == _T(' '))
	{
		rStr = rStr.Mid(1);
		chFirst = rStr[0];
	}
	if (rStr.IsEmpty())
		return;
	else
		rStr = MakeReverse(rStr);
}

// like StoreAdaption, but with different assumptions since we need to be able to move back
// when either there is nothing in the current phraseBox (in which case no store need be
// done), or when the user has finished typing the current srcPhrase's adaption (since it
// will be saved to the KB when focus moves back.) TRUE if okay to go back, FALSE
// otherwise. For glossing, pKB must point to the glossing KB, for adapting, to the normal
// KB.
bool CAdapt_ItView::StoreTextGoingBack(CKB *pKB, CSourcePhrase *pSrcPhrase, 
									   wxString &tgtPhrase)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// determine the auto caps parameters, if the functionality is turned on
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pSrcPhrase->m_key); // for source word or phrase
	}

	GetDocument()->Modify(TRUE);

    // do not permit storage if the source phrase has an empty key (eg. user may have ...
    // ellipsis in the source text, which generates an empty key and three periods in the
    // punctuation)
	if (pSrcPhrase->m_key.IsEmpty())
	{
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // this is not an error, just suppression of the store
	}

	gbByCopyOnly = FALSE; // restore default setting

	// is the m_targetPhrase empty?
	if (tgtPhrase.IsEmpty())
	{
		// it's empty, so we can go back without saving anything in the kb
		pApp->m_bForceAsk = FALSE; // must ensure this flag is off, no forcing of 
						// Choose Translation dialog is required when moving back
		gbMatchedKB_UCentry = FALSE;
		return TRUE;
	}

    // It's not empty, so go ahead and re-store it as-is (but if auto capitalization has
    // just been turned on, it will be stored as a lower case entry if it is an upper case
    // one in the doc) first, remove any phrase final space characters
	int len;
	int nIndexLast;
	if (!tgtPhrase.IsEmpty())
	{
		len = tgtPhrase.Length();
		nIndexLast = len-1;
		do {
			if (tgtPhrase.GetChar(nIndexLast) == _T(' '))
			{
                // wxString.Remove must have 1 otherwise the default is to truncate the
                // remainder of the string!
				tgtPhrase.Remove(nIndexLast,1); //tgtPhrase.Delete(nIndexLast);
				// can't trust the Delete's returned value, it exceeds string length by one
				len = tgtPhrase.Length();
				nIndexLast = len -1;
			}
			else
			{
				break;
			}
		} while (len > 0 && nIndexLast > -1);
	}

	// always place a copy in the source phrase's m_adaption member, etc
	if (gbIsGlossing)
	{
		wxString s = tgtPhrase;
		if (gbAutoCaps)
		{
			bool bNoError = TRUE;
			if (gbSourceIsUpperCase && !gbMatchedKB_UCentry)
			{
				bNoError = SetCaseParameters(s,FALSE);
				if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
				{
					// change it to upper case
					s.SetChar(0,gcharNonSrcUC);
				}
			}
		}
		pSrcPhrase->m_gloss = s;
		if (gbRemovePunctuationFromGlosses)
			RemovePunctuation(GetDocument(),&pSrcPhrase->m_gloss,from_target_text);
	}
	else
	{
		if (tgtPhrase != _T("<Not In KB>"))
		{
			pSrcPhrase->m_adaption = tgtPhrase;
			if (!gbInhibitLine4StrCall)
				MakeLineFourString(pSrcPhrase, tgtPhrase); // set m_targetStr member too
		}
	}
	
    // if the user doesn't want a store done (he checked the dialog bar's control for this
    // choice) then return without saving after setting the source phrase's m_bNotInKB flag
    // to TRUE
	int nMapIndex;
	if (!gbIsGlossing && !pApp->m_bSaveToKB)
	{
		pSrcPhrase->m_bNotInKB = TRUE;
		pApp->m_bForceAsk = FALSE; // its a valid 'store op' so must turn this flag back off
		pSrcPhrase->m_bHasKBEntry = FALSE;
		gbMatchedKB_UCentry = FALSE;
		return TRUE; // we want the caller to think all is well
	}
	else // adapting or glossing
	{
		if (gbIsGlossing)
			nMapIndex = 0;
		else
			nMapIndex = pSrcPhrase->m_nSrcWords - 1; // compute the index to the map
	}
	// if there is a CTargetUnit associated with the current key, then get it; if not,
	// create one and add it to the appropriate map

    // if we have too many source words, then we cannot save to the KB, so detect this and
    // warn the user that it will not be put in the KB, then return TRUE since all is
    // otherwise okay; this check need be done only when adapting
	if (!gbIsGlossing && pSrcPhrase->m_nSrcWords > MAX_WORDS)
	{
		pSrcPhrase->m_bNotInKB = TRUE;
		pSrcPhrase->m_bHasKBEntry = FALSE;
		// IDS_TOO_MANY_SRC_WORDS
		wxMessageBox(_(
"Warning: there are too many source language words in this phrase for this adaptation to be stored in the knowledge base.")
		, _T(""), wxICON_INFORMATION);
		gbMatchedKB_UCentry = FALSE;
		return TRUE;
	}

	// continue the storage operation
	wxString unchangedkey = pSrcPhrase->m_key; // this never has case change done to it
											  // (need this for lookups)
	wxString key = AutoCapsMakeStorageString(pSrcPhrase->m_key); // key might be made lower case
	CTargetUnit* pTU;
	CRefString* pRefString;
	if (pKB->m_pMap[nMapIndex]->empty()) 
	{
		pTU = new CTargetUnit;
		wxASSERT(pTU != NULL);
		pRefString = new CRefString(pTU);
		wxASSERT(pRefString != NULL);

		pRefString->m_refCount = 1; // set the count
		// add the translation string, or gloss string
		if (bNoError)
		{
			pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
		}
		else
		{
			// if something went wrong, just save as if gbAutoCaps was FALSE
			pRefString->m_translation = tgtPhrase;
		}
		pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
		if (pApp->m_bForceAsk)
			pTU->m_bAlwaysAsk = TRUE; // turn it on if user wants to be given 
				// opportunity to add a new refString next time its matched

		pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
		if (gbIsGlossing)
			pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
		else
			pSrcPhrase->m_bHasKBEntry = TRUE;

		(*pKB->m_pMap[nMapIndex])[key] = pTU;
		// update the maxWords limit
		if (gbIsGlossing)
		{
			pKB->m_nMaxWords = 1; // always 1 when glossing (ensures glossing 
				// ignores maps with indices from 1 to 9; all is in 1st map only)
		}
		else
		{
			if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
				pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
		}
	}
	else // do next block when the map is not empty
	{
        // there might be a pre-existing association between this key and a CTargetUnit, 
        // so check it out
		bool bFound = AutoCapsLookup(pKB->m_pMap[nMapIndex], pTU, unchangedkey); 

        // if not found, then create a targetUnit, and add the refString, etc, as above;
        // but if one is found, then check whether we add a new refString or increment the
        // refCount of an existing one
		if(!bFound)
		{
			pTU = new CTargetUnit;
			wxASSERT(pTU != NULL);
			pRefString = new CRefString((CTargetUnit*)pTU);
			wxASSERT(pRefString != NULL);

			pRefString->m_refCount = 1; // set the count
			pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
			pTU->m_pTranslations->Append(pRefString); // store in the CTargetUnit
			if (pApp->m_bForceAsk)
				pTU->m_bAlwaysAsk = TRUE; // turn it on if user wants to be given 
						// opportunity to add a new refString next time its matched

			pKB->m_pTargetUnits->Append(pTU); // add the targetUnit to the KB
			if (gbIsGlossing)
				pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
			else
				pSrcPhrase->m_bHasKBEntry = TRUE;

			(*pKB->m_pMap[nMapIndex])[key] = pTU;// store the CTargetUnit in the map 
			// update the maxWords limit
			if (gbIsGlossing)
			{
				pKB->m_nMaxWords = 1; // for glossing it is always 1
			}
			else
			{
				if (pSrcPhrase->m_nSrcWords > pKB->m_nMaxWords)
					pKB->m_nMaxWords = pSrcPhrase->m_nSrcWords;
			}
		}
		else // we found one
		{
            // we have a pTU for this key, so check for a matching CRefString, if there is
            // no match, then add a new one (note: no need to set m_nMaxWords for this
            // case)
			bool bMatched = FALSE;
			pRefString = new CRefString(pTU);
			wxASSERT(pRefString != NULL);
			pRefString->m_refCount = 1; // set the count, assuming this will be stored 
										// (it may not be)
            // set its gloss or adaptation string; the fancy test is required because the
            // refStr entry may have been stored in the kb when auto-caps was off, and if
            // it was upper case for the source text's first letter, then it will have been
            // looked up only on the second attempt, for which gbMatchedKB_UCentry will
            // have been set TRUE, and which means the gloss or adaptation will not have
            // been made lower case - so we must allow for this possibility
			if ((gbAutoCaps && gbMatchedKB_UCentry) || !gbAutoCaps)
				pRefString->m_translation = tgtPhrase; // use unchanged string, could be uc
			else
				pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);

			TranslationsList::Node* pos = pTU->m_pTranslations->GetFirst();
			while (pos != NULL)
			{
				CRefString* pRefStr = (CRefString*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pRefStr != NULL);

				// does it match?
				if (*pRefStr == *pRefString) // TRUE if pRStr->m_translation ==
											 //				pRefString->m_translation
				{
					// if we get a match, then increment ref count and point to this, etc
					bMatched = TRUE;
					pRefStr->m_refCount++;
					if (gbIsGlossing)
						pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					else
						pSrcPhrase->m_bHasKBEntry = TRUE;
					delete pRefString; // don't need this one
					pRefString = (CRefString*)NULL;
					if (pApp->m_bForceAsk)
						pTU->m_bAlwaysAsk = TRUE; // nTrCount might be 1, so we must 
								// ensure it gets set if that is what the user wants
					break;
				}
			}
            // if we get here with bMatched == FALSE, then there was no match, so we must
            // add the new pRefString to the targetUnit
			if (!bMatched)
			{
				TranslationsList::Node* tpos = pTU->m_pTranslations->GetFirst();
				CRefString* pRefStr = (CRefString*)tpos->GetData();
				if (!gbIsGlossing && pRefStr->m_translation == _T("<Not In KB>"))
				{
                    // keep it that way (the way to cancel this setting is with the toolbar
                    // checkbox) But leave m_adaption and m_targetStr (or m_gloss) having
                    // whatever the user may have typed
					pSrcPhrase->m_bHasKBEntry = FALSE;
					pSrcPhrase->m_bNotInKB = TRUE;
					pSrcPhrase->m_bBeginRetranslation = FALSE;
					pSrcPhrase->m_bEndRetranslation = FALSE;
					delete pRefString; // don't leak memory
					pRefString = (CRefString*)NULL;
					pApp->m_bForceAsk = FALSE;
					gbMatchedKB_UCentry = FALSE;
					return TRUE; // all is well
				}
				else // either we are glossing, or we are adapting and it's a normal adaptation
				{
					// is the m_targetPhrase empty?
					if (tgtPhrase.IsEmpty())
					{
						// don't store if it is empty, and then return; but if not empty
						// then go on to do the storage
						if (!gbIsGlossing)
						{
							pSrcPhrase->m_bBeginRetranslation = FALSE;
							pSrcPhrase->m_bEndRetranslation = FALSE;
						}
						pApp->m_bForceAsk = FALSE; // make sure it's turned off
						delete pRefString; // don't leak the memory
						pRefString = (CRefString*)NULL;
						gbMatchedKB_UCentry = FALSE;
						return TRUE; // make caller think all is well
					}

					// recalculate the string to be stored, in case we looked up a
					// stored upper case entry earlier
					pRefString->m_translation = AutoCapsMakeStorageString(tgtPhrase,FALSE);
					pTU->m_pTranslations->Append(pRefString); 
					if (gbIsGlossing)
						pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
					else
						pSrcPhrase->m_bHasKBEntry = TRUE;
				}
			}
		}
	}
	if (!gbIsGlossing)
		pSrcPhrase->m_bNotInKB = FALSE; // ensure correct flag value, 
										// in case it was not in KB
	pApp->m_bForceAsk = FALSE; // must be turned off, as it applies 
							   // to one store operation only
	gbMatchedKB_UCentry = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// It enables the "Change Interface Language..." item on the View menu. This menu item is
/// always enabled unless Vertical Editing is in progress.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateChangeInterfaceLanguage(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// should always be accessible
	event.Enable(TRUE);
}

void CAdapt_ItView::OnChangeInterfaceLanguage(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	pApp->ChangeUILanguage();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is doing a vertical edit, only showing the target language, or the
/// Document pointer is NULL, this handler disables the "Preferences..." item on the View
/// menu and immediately returns.
/// It enables the "Preferences..." item on the View menu if a document is loaded (i.e.,
/// the count of source phrases in m_pSourcePhrases list is greater than zero), otherwise
/// it disables the menu item.
/// BEW note 6Nov09, the requirement that a doc be open is unnecessarily stringent,
/// there are times when you'd want access when no doc is loaded - such as getting
/// access to the Administrator menu should only require you be in an open project (and
/// even that is maybe a bit too stringent). However our code won't support this currently
/// because the USFM and Filtering pages do a lot of setup for USFM and filtering and for 
/// that it looks into the doc- which therefore has to be open.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditPreferences(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if ((CAdapt_ItDoc*)GetDocument() == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnCheckSingleStep(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// toggle the m_bSingleStep flag
	pApp->m_bSingleStep = pApp->m_bSingleStep == TRUE ? FALSE : TRUE;

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnCheckForceAsk(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// toggle the m_bForceAsk flag
	pApp->m_bForceAsk = pApp->m_bForceAsk == TRUE ? FALSE : TRUE;

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnCopySource(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pViewCopySource = pMenuBar->FindItem(ID_COPY_SOURCE);
	wxASSERT(pViewCopySource != NULL);

	// toggle the setting
	if (pApp->m_bCopySource)
	{
		// toggle the checkmark to OFF
		pViewCopySource->Check(FALSE);
		pApp->m_bCopySource = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pViewCopySource->Check(TRUE);
		pApp->m_bCopySource = TRUE;
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is in Free Translation Mode, this handler disables the "Use
/// Consistent Changes" item on the Tools menu and immediately returns.
/// If one or more cc tables are loaded (i.e., the App's m_bTablesLoaded flag is TRUE), it
/// enables the "Use Consistent Changes" item on the Tools menu, otherwise it disables the
/// menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateUseConsistentChanges(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}

	// the flags we want are on the view, so get the view
	if (pApp->m_bTablesLoaded)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the application is in Free Translation Mode, this handler disables the "Use SIL
/// Converter" item on the Tools menu and immediately returns.
/// If there is an SIL Converter table name configured (i.e., the App's
/// m_strSilEncConverterName string is not empty), it enables the "Use SIL Converter" item
/// on the Tools menu, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateUseSilConverter(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_bFreeTranslationMode || !pApp->bECDriverDLLLoaded)
	{
		event.Enable(FALSE);
		return;
	}

#ifdef USE_SIL_CONVERTERS
	// whm added 12Jan09 for SIL Converters support
	typedef int (wxSTDCALL *wxECIsInstalledType)();
	wxECIsInstalledType pfnECisInstalled = (wxECIsInstalledType)NULL;
    // whm Note: The IsEcInstalled() function in ECDriver.dll does not have A and W forms
    // so we must call GetSymbol() instead of GetSymbolAorW() here.
	pfnECisInstalled = 
		(wxECIsInstalledType)ecDriverDynamicLibrary.GetSymbol(FUNC_NAME_EC_IS_INSTALLED);
    // enable it if ECisInstalled and there's a configured table name
	event.Enable(pfnECisInstalled != NULL && pfnECisInstalled() == TRUE && 
					!pApp->m_strSilEncConverterName.IsEmpty());
#else
	event.Enable(FALSE); // don't enable the menu item if we're not using SIL Converters
#endif
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event (unused) 
/// \remarks
/// Called from the Tools menu on selection of the "Use Consistent Changes" menu item. This
/// handler toggles the check on the menu item and the value of the m_bUseConsistentChanges
/// variable on the App. The "Use Consistent Changes" menu selection basically works as a
/// switch to turn on or off any change tables the were previously loaded using the "Load
/// Consistent Changes..." menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUseConsistentChanges(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuUseCC = pMenuBar->FindItem(ID_USE_CC);
	wxASSERT(pToolsMenuUseCC != NULL);
	wxMenuItem * pToolsMenuUseSilConverter = pMenuBar->FindItem(ID_USE_SILCONVERTER);
	wxASSERT(pToolsMenuUseSilConverter != NULL);

	// toggle the setting
	if (pApp->m_bUseConsistentChanges)
	{
		// toggle the checkmark to OFF
		pToolsMenuUseCC->Check(FALSE);
		pApp->m_bUseConsistentChanges = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pToolsMenuUseCC->Check(TRUE);
		pApp->m_bUseConsistentChanges = TRUE;

        // reset the SILConverter 'use' menu in case it was set 
        // (i.e. these two are mutually exclusive)
		pToolsMenuUseSilConverter->Check(FALSE);
		pApp->m_bUseSilConverter = FALSE;
	}

    // if the checkbox was just turned on, then have the phrase box placed there again, so
    // as to give consistent changes a chance to work on the current source phrase
	if (pApp->m_bUseConsistentChanges)
	{
		// ensure we are not at eof with no phrase box currently in existence
		if (pApp->m_pActivePile != NULL)
		{
			CCell* pCell = pApp->m_pActivePile->GetCell(1);
			wxASSERT(pCell != NULL);
			int selector = 1; // this value suppresses both removal from the KB and storing
							  // prior adaptation
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			PlacePhraseBox(pCell,selector);
		}
	}
	else
	{
        // we have just turned off the use of consistent changes, so we must turn off
        // acceptance of defaults too
		pApp->m_bAcceptDefaults = FALSE;

		// and update the menu command to be unchecked
		pToolsMenuUseCC->Check(FALSE);
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnUseSilConverter(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuUseSilConverter;
	pToolsMenuUseSilConverter = pMenuBar->FindItem(ID_USE_SILCONVERTER);
	wxASSERT(pToolsMenuUseSilConverter != NULL);
	wxMenuItem * pToolsMenuUseCC;
	pToolsMenuUseCC = pMenuBar->FindItem(ID_USE_CC);
	wxASSERT(pToolsMenuUseCC != NULL);
	wxMenuItem* pToolsMenuAcceptChanges;
	pToolsMenuAcceptChanges = pMenuBar->FindItem(ID_ACCEPT_CHANGES);
	wxASSERT(pToolsMenuAcceptChanges != NULL);

	// toggle the setting
	if (pApp->m_bUseSilConverter)
	{
		// toggle the checkmark to OFF
		pToolsMenuUseSilConverter->Check(FALSE);
		pApp->m_bUseSilConverter = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pToolsMenuUseSilConverter->Check(TRUE);
		pApp->m_bUseSilConverter = TRUE;

        // reset the Consistent Changes 'use' menu in case it was set 
        // (i.e. these two are mutually exclusive)
		pToolsMenuUseCC->Check(FALSE);
		pApp->m_bUseConsistentChanges = FALSE;
	}

    // if the checkbox was just turned on, then have the phrase box placed there again, so
    // as to give consistent changes a chance to work on the current source phrase
	if (pApp->m_bUseSilConverter)
	{
		// ensure we are not at eof with no phrase box currently in existence
		if (pApp->m_pActivePile != NULL)
		{
			CCell* pCell = pApp->m_pActivePile->GetCell(1);
			wxASSERT(pCell != NULL);
			int selector = 1; // this value suppresses both removal from the KB and storing
							  // prior adaptation
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			PlacePhraseBox(pCell,selector);
		}
	}
	else
	{
        // we have just turned off the use of the SILConverter, so we must turn off
        // acceptance of defaults too
		pApp->m_bAcceptDefaults = FALSE;

		// and update the menu command to be unchecked
		pToolsMenuAcceptChanges->Check(FALSE);
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress, the "Accept Changes Without Stopping" item on the
/// Tools menu is disabled and this handler returns immediately.
/// If the application is not in Single Step Mode, but is set to Copy the Source text, and,
/// either m_bUseConsistentChanges is TRUE or m_bUseSilConverter is TRUE, then this handler
/// enables the "Accept Changes Without Stopping" item on the Tools menu, otherwise it
/// disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAcceptChanges(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// disable if the 3 flags (single step, cc changes, copy source) are not
	// the right values, but if they are, allow value to be changed
	if (!pApp->m_bSingleStep && pApp->m_bCopySource && 
		(pApp->m_bUseConsistentChanges || pApp->m_bUseSilConverter) )
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAcceptChanges(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);

	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsAcceptChanges = pMenuBar->FindItem(ID_ACCEPT_CHANGES);
	wxASSERT(pToolsAcceptChanges != NULL);

	// toggle the setting
	if (pApp->m_bAcceptDefaults)
	{
		// toggle the checkmark to OFF
		pToolsAcceptChanges->Check(FALSE);
		pApp->m_bAcceptDefaults = FALSE;
		
		// restore the highlighting setting
		pApp->m_bSuppressTargetHighlighting = gbSaveHilightingSetting;
	}
	else
	{
		// toggle the checkmark to ON
		pToolsAcceptChanges->Check(TRUE);
		pApp->m_bAcceptDefaults = TRUE;
		
		// save the highlighting setting so it can be restored when the toggle
		// is later turned off, and then suppress highlighting till then
		gbSaveHilightingSetting = pApp->m_bSuppressTargetHighlighting;
		pApp->m_bSuppressTargetHighlighting = TRUE;
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

void CAdapt_ItView::OnRadioDrafting(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar);
	wxRadioButton* pDraftingBtn = 
		(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_DRAFTING);
	wxRadioButton* pReviewingBtn = 
		(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_REVIEWING);
	pDraftingBtn->SetValue(TRUE);
	pReviewingBtn->SetValue(FALSE);
	pApp->m_bDrafting = TRUE;

	// ensure the Automatic checkbox is enabled
	wxCheckBox* pAuto = (wxCheckBox*)
		pControlBar->FindWindowById(IDC_CHECK_SINGLE_STEP);
	pAuto->Enable(TRUE);

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
	pApp->RefreshStatusBarInfo();
}

void CAdapt_ItView::OnRadioReviewing(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame);
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxRadioButton* pDraftingBtn = 
		(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_DRAFTING);
	wxRadioButton* pReviewingBtn = 
		(wxRadioButton*)pControlBar->FindWindowById(IDC_RADIO_REVIEWING);
	pDraftingBtn->SetValue(FALSE);
	pReviewingBtn->SetValue(TRUE);
	pApp->m_bDrafting = FALSE;

	// ensure the Automatic checkbox is disabled
	wxCheckBox* pAuto = (wxCheckBox*)
		pControlBar->FindWindowById(IDC_CHECK_SINGLE_STEP);
	pAuto->Enable(FALSE);

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if ((pApp->m_pTargetBox->IsShown()))
			pApp->m_pTargetBox->SetFocus();
	pApp->RefreshStatusBarInfo();
}

void CAdapt_ItView::OnClearContentsButton(wxCommandEvent& WXUNUSED(event))
{
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pComposeBar = pFrame->m_pComposeBar; 
	if(pComposeBar != NULL && pComposeBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)
			pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			pEdit->ChangeValue(_T(""));
			pEdit->SetFocus();
		}
	}
}

void CAdapt_ItView::OnSelectAllButton(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pComposeBar = pFrame->m_pComposeBar;
	if(pComposeBar != NULL && pComposeBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)
			pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			pEdit->SetSelection(-1,-1);
			pApp->m_nStartChar = -1;
			pApp->m_nEndChar = -1;
			pEdit->SetFocus();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param  pDoc    ->  pointer to document class
/// \param  pStr    ->  pointer to the CString which may have punctuation, and the 
///                     punctuation is to be removed (this is done using ParseWord() so the
///                     method of stripping is consistent with how stripping is done during
///                     parsing of source text data
/// \param  nIndex  ->  selector for the punctuation string which is to be used - 0 for 
///                     source, 1 for target
/// \remarks
/// Removes punctuation from the beginning and end of the passed in string, doing it in a
/// way consistent with the (U)SFM parser; does not try to store the stripped off
/// punctuation but just returns the punctuation-less string to the call via the pointer
/// passed in
/// New version coded on 02April05 by BEW
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RemovePunctuation(CAdapt_ItDoc* pDoc, wxString* pStr, int nIndex)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pStr->IsEmpty())
		return;

	// get rid of spaces from a temp copy of the punctuation set which we want to use
	wxString spacelessPunctsStr = pApp->m_punctuation[nIndex];
	// remove all spaces, leaving only the list of punctation characters
	int countRemoved;
	countRemoved = spacelessPunctsStr.Replace(_T(" "),_T(""));

	// test for no punctuation, if so, then we can return immediately
	if (FindOneOf(*pStr, spacelessPunctsStr) == -1) 
	{
		// there are no punctuation chars in the string (but there may be spaces),
		// so the caller can use the string immediately
		return;
	}

    // wx version note: Since we require a read-only buffer we use GetData which just
    // returns a const wxChar* to the data in the string.
	const wxChar* pChar = (*pStr).GetData();
	wxChar* ptr = (wxChar*)pChar;
	wxChar* pBufStart = ptr;
	wxChar* pEnd = pBufStart + (*pStr).Length(); // points to null
	wxASSERT(*pEnd == _T('\0')); // whm added
	wxString strFinal = _T("");  // store accumulated punctuation-less word or phrase
	wxString precStr = _T("");   // preceding punctuation stripped in the parse
	wxString follStr = _T("");   // ditto, but for following punctuation
	int itemLen = 0;

	while (ptr < pEnd)
	{
		itemLen = pDoc->ParseWord(ptr, precStr,follStr,spacelessPunctsStr);

		wxString strPunctuatedWord(ptr,itemLen);

		// get the length of the preceding punctuation substring
		int aLength = precStr.Length();
		// get the remainder after preceding punctuation is skipped
		wxString spanned = strPunctuatedWord.Mid(aLength); 
		ptr += aLength; // point to start of the word proper
		// reduce itemLen by the size of the preceding punctuation substring
		itemLen -= aLength; 

		// get the length of the following punctuation substring
		aLength = follStr.Length();
		int wordLen = itemLen - aLength;
		wxASSERT(wordLen >= 0);
		wxString theWord(ptr,wordLen);

		// update ptr to point at next part of string to be parsed
		ptr += itemLen; 

		while (*ptr == _T(' ')) { ptr++; }

		if (strFinal.IsEmpty())
		{
			strFinal = theWord;
		}
		else
		{
			strFinal += _T(" ") + theWord;
		}

		precStr.Empty();
		follStr.Empty();
	}

	*pStr = strFinal; // copy result to caller
}

// the copy could be from several places, so these are prioritized. First, if the compose
// box has a selection and has the focus, it is done from there; but if not, then next in
// priority is a selection of source phrases - if such a selection is current, then the
// m_targetStr fields are accumulated as a phrase & copied to the clipboard; if not, the
// phrase box contents is taken, provided it has the focus; if none of these, then nothing
// is copied.
void CAdapt_ItView::OnEditCopy(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// get the window which has the current focus
	wxWindow* pWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the frame window in OnEditCopy\n"),
		_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnEditCopy\n"),
		_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnEditCopy\n"),
		_T(""), wxICON_EXCLAMATION);
		return;
	}
	// In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle
	// from the view menu merely shows or hides the composeBar. In MFC version the
	// compose bar is recreated each time it becomes visible. Hence, I'll add the
	// condition check to insure the text control in the composeBar IsShown()
	if (pWnd == pEdit && pEdit->IsShown())
	{
		pEdit->Copy(); // copy to the clipboard using wxTextCtrl's built in function
                       // (CF_TEXT format, or CF_UNICODETEXT for the Unicode version)
		return;
	}

	if (pApp->m_selectionLine == 0)
	{
		// this has priority, ie. if there is or are sourcePhrase(s) selected
		DoSrcPhraseSelCopy();
	}
	else
	{
	wxTextCtrl* pEdit2 = pApp->m_pTargetBox;
	if (pEdit2 == pWnd)
		pEdit2->Copy();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the App's m_pActivePile is NULL this handler disables the "Copy" item in the Edit
/// menu and immediately returns.
/// It enables the "Copy" item on the Edit menu if there is a valid selection in either the
/// composeBar's edit box, the targetBox, or a source phrase selection, otherwise it
/// disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditCopy(wxUpdateUIEvent& event)
{
    // whm: Removed the messages which would be issued endlessly if ever the errors
    // happened in the update idler handling.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	bool bComposeSel = FALSE;
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the frame window in OnUpdateEditCopy\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar; 
	if (pBar == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnUpdateEditCopy\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		//wxMessageBox(_T(
		//	"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnUpdateEditCopy\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	long nStartChar1; long nEndChar1; 
	pEdit->GetSelection(&nStartChar1,&nEndChar1);
	bComposeSel = nStartChar1 != nEndChar1;

	bool bTargetBoxSel = FALSE;
	long nStartChar; long nEndChar;
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->GetSelection(&nStartChar,&nEndChar);
			bTargetBoxSel = nStartChar != nEndChar;
		}

	bool bSrcPhraseSel = FALSE;
	if (pApp->m_selectionLine == 0)
		bSrcPhraseSel = TRUE;

	event.Enable(bComposeSel || bTargetBoxSel || bSrcPhraseSel);
}

void CAdapt_ItView::OnEditPaste(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxWindow* pWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the frame window in OnEditPaste\n"),
		_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar in OnEditPaste\n"),
		_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnEditPaste\n"),
		_T(""), wxICON_EXCLAMATION);
		return;
	}
    // In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle from
    // the view menu merely shows or hides the composeBar. In MFC version the compose bar
    // is recreated each time it becomes visible. Hence, I'll add the condition check to
    // insure the text control in the composeBar IsShown()
	if (pWnd == pEdit && pEdit->IsShown())
	{
		// paste from the clipboard using wxTextCtrl's built in function (CF_TEXT format
		// or CF_UNICODETEXT for Unicode version)
		pEdit->Paste();
	}

	if (pApp->m_pTargetBox->GetHandle() != NULL)
		if (pApp->m_pTargetBox->IsShown() && (pApp->m_pTargetBox == pWnd))
		{
			DoTargetBoxPaste(pApp->m_pActivePile);
		}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the App's main frame pointer is NULL, or the composeBar is NULL, or the composeBar's
/// edit box is NULL, or both the composeBar and targetBox are not shown this handler
/// disables the "Paste" item in the Edit menu and immediately returns.
/// It enables the "Paste" item on the Edit menu if either the composeBar's edit box is
/// shown or the targetBox is shown, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditPaste(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	bool bComposeWnd = FALSE;

	wxWindow* pFocusWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	// In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle
	// from the view menu merely shows or hides the composeBar. In MFC version the
	// compose bar is recreated each time it becomes visible. Hence, I'll add the
	// condition check to insure the text control in the composeBar IsShown()
	if (pFocusWnd == pEdit && pEdit->IsShown())
		bComposeWnd = TRUE;

	bool bTargetBox = FALSE;
	if (pApp->m_pTargetBox != NULL)
		bTargetBox = (pApp->m_pTargetBox->IsShown()) && 
			(pApp->m_pTargetBox == pFocusWnd);

	event.Enable(bComposeWnd || bTargetBox);
}

void CAdapt_ItView::OnEditCut(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// get the window which has the current focus
	wxWindow* pWnd = wxWindow::FindFocus(); // gets a CTempWnd
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the frame window in OnEditCut\n"),
		_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar in OnEditCut\n"),
		_T(""), wxICON_EXCLAMATION);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnEditCut\n"),
		_T(""), wxICON_EXCLAMATION);
		return;
	}
    // In the wxWidgets version the m_pcomposeBar pointer always exists. The toggle from
    // the view menu merely shows or hides the composeBar. In MFC version the compose bar
    // is recreated each time it becomes visible. Hence, I'll add the condition check to
    // insure the text control in the composeBar IsShown()
	if (pWnd == pEdit && pEdit->IsShown())
		pEdit->Cut(); // cut to the clipboard using wxTextCtrl's built in function
					  // (CF_TEXT format)

	wxTextCtrl* pEdit2 = pApp->m_pTargetBox;
	if (pEdit2 == pWnd)
	{
		pEdit2->Cut();

        // the phrase box now has different text, but pApp->m_targetPhrase still has the
        // uncut text, so to prevent the cut text from reappearing on the pile, we must put
        // the text remaining in the phrase box's "title" into pApp->m_targetPhrase;
		wxString text;
		text = pEdit2->GetValue();
		pApp->m_targetPhrase = text; // now it agree's with the window contents for the box
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If the App's main frame is NULL, or the composeBar is NULL, or the composeBar's edit
/// box is NULL, or neither the composeBar nor targetBox have a selection, this handler
/// disables the "Cut" item in the Edit menu, otherwise it enables the "Cut" item on the
/// Edit menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditCut(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	bool bComposeSel = FALSE;
	CMainFrame *pFWnd = wxGetApp().GetMainFrame();
	if (pFWnd == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the frame window in OnUpdateEditCut\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	wxPanel* pBar = pFWnd->m_pComposeBar;
	if (pBar == NULL)
	{
		//wxMessageBox(_T("Failure to obtain pointer to the Compose Bar in OnUpdateEditCut\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	if (pEdit == NULL)
	{
		//wxMessageBox(_T(
		//	"Failure to obtain pointer to the Compose Bar's wxTextCtrl control in OnUpdateEditCut\n"),
		//	_T(""), wxICON_EXCLAMATION);
		event.Enable(FALSE);
		return;
	}
	long nStartChar; long nEndChar;
	pEdit->GetSelection(&nStartChar,&nEndChar);
	bComposeSel = nStartChar != nEndChar;

	bool bTargetBoxSel = FALSE;
	long nStartChar1; long nEndChar1; 
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->GetSelection(&nStartChar1,&nEndChar1); 
			bTargetBoxSel = nStartChar1 != nEndChar1;
		}


	event.Enable(bComposeSel || bTargetBoxSel);
}

// this function is public, and it inserts before the active location, or before the
// selection (called in PhraseBox.cpp)
void CAdapt_ItView::InsertNullSrcPhraseBefore() 
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// first save old sequ num for active location
	gnOldSequNum = pApp->m_nActiveSequNum;

    // find the pile preceding which to do the insertion - it will either be preceding the
    // first selected pile, if there is a selection current, or preceding the active
    // location if no selection is current
	CPile* pInsertLocPile;
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);
	int nCount = 1;
	int nSequNum = -1;
	if (pApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's 
		// first element
		CCellList* pCellList = &pApp->m_selection; 
		CCellList::Node* fpos = pCellList->GetFirst();
		pInsertLocPile = fpos->GetData()->GetPile(); 
		if (pInsertLocPile == NULL)
		{
			wxMessageBox(_T(
			"Sorry, a zero pointer was returned, the insertion cannot be done."),
			_T(""), wxICON_EXCLAMATION);
			return;
		}
		nSequNum = pInsertLocPile->GetSrcPhrase()->m_nSequNumber;
		wxASSERT(pInsertLocPile != NULL);
		RemoveSelection(); // Invalidate will be called in InsertNullSourcePhrase()
	}
	else
	{
		// no selection, so just insert preceding wherever the phraseBox 
		// currently is located
		pInsertLocPile = pApp->m_pActivePile;
		if (pInsertLocPile == NULL)
		{
			wxMessageBox(_T(
			"Sorry, a zero pointer was returned, the insertion cannot be done."),
			_T(""), wxICON_EXCLAMATION);
			return;
		}
		nSequNum = pInsertLocPile->GetSrcPhrase()->m_nSequNumber;
	}
	wxASSERT(nSequNum >= 0);

	// check we are not in a retranslation - we can't insert there!
	if(pInsertLocPile->GetSrcPhrase()->m_bRetranslation)
	{
		CPile* pPile = GetPrevPile(pInsertLocPile);
		if (pPile == NULL || pPile->GetSrcPhrase()->m_bRetranslation)
		{
			// IDS_NO_INSERT_IN_RETRANS
			wxMessageBox(_(
"Sorry, you cannot insert a placeholder within a retranslation. The command has been ignored."),
			_T(""), wxICON_EXCLAMATION);
			RemoveSelection();
			Invalidate();
			GetLayout()->PlaceBox();
			return;
		}
	}

	// ensure the contents of the phrase box are saved to the KB
	// & make the punctuated target string
	if (pApp->m_pTargetBox != NULL && pApp->m_pTargetBox->IsShown())
	{
		MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);

        // we are about to leave the current phrase box location, so we must try to store
        // what is now in the box, if the relevant flags allow it
		RemovePunctuation(pDoc, &pApp->m_targetPhrase, from_target_text);
		gbInhibitLine4StrCall = TRUE;
		bool bOK;
		bOK = StoreText(pApp->m_pKB, pApp->m_pActivePile->GetSrcPhrase(), 
							pApp->m_targetPhrase);
		gbInhibitLine4StrCall = FALSE;
	}

	InsertNullSourcePhrase(pDoc, pApp, pInsertLocPile, nCount);

	// jump to it (can't use old pile pointers, the recalcLayout call will have 
	// clobbered them)
	CPile* pPile = GetPile(nSequNum);
	Jump(pApp, pPile->GetSrcPhrase());
}

// this function is public
// (called in PhraseBox.cpp)
void CAdapt_ItView::InsertNullSrcPhraseAfter() 
{
	int nSequNum;
	int nCount;
	CAdapt_ItDoc* pDoc = GetDocument();
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	// CTRL key is down, so an "insert after" is wanted
	// first save old sequ num for active location
	gnOldSequNum = pApp->m_nActiveSequNum;

	// find the pile after which to do the insertion - it will either be after the
	// last selected pile if there is a selection current, or after the active location
	// if no selection is current - beware the case when active location is a doc end!
	CPile* pInsertLocPile;
	nCount = 1; // the button or shortcut can only insert one
	nSequNum = -1;
	if (pApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's last element
		CCellList* pCellList = &pApp->m_selection;
		CCellList::Node* cpos = pCellList->GetLast();
		pInsertLocPile = cpos->GetData()->GetPile(); 
		if (pInsertLocPile == NULL)
		{
			wxMessageBox(_T(
			"Sorry, a zero pointer was returned, the insertion cannot be done."),
			_T(""), wxICON_EXCLAMATION);
			return;
		}
		nSequNum = pInsertLocPile->GetSrcPhrase()->m_nSequNumber;
		wxASSERT(pInsertLocPile != NULL);
		RemoveSelection(); // Invalidate will be called in InsertNullSourcePhrase()
	}
	else
	{
		// no selection, so just insert after wherever the phraseBox currently is located
		pInsertLocPile = pApp->m_pActivePile;
		if (pInsertLocPile == NULL)
		{
			wxMessageBox(_T(
			"Sorry, a zero pointer was returned, the insertion cannot be done."),
			_T(""), wxICON_EXCLAMATION);
			return;
		}
		nSequNum = pInsertLocPile->GetSrcPhrase()->m_nSequNumber;
	}
	wxASSERT(nSequNum >= 0);

    // check we are not in a retranslation - we can't insert there! We can be at the end of
    // a retranslation since we are then inserting after it, but if we are not at the end,
    // there will be at least one more retranslation sourcephrase to the right, and so we
    // must check if this is the case & abort the operation if so
	if(pInsertLocPile->GetSrcPhrase()->m_bRetranslation)
	{
		CPile* pPile = GetNextPile(pInsertLocPile);
		if (pPile == NULL || pPile->GetSrcPhrase()->m_bRetranslation)
		{
			// IDS_NO_INSERT_IN_RETRANS
			wxMessageBox(_(
"Sorry, you cannot insert a placeholder within a retranslation. The command has been ignored."),
			_T(""), wxICON_EXCLAMATION);
			RemoveSelection();
			Invalidate();
			GetLayout()->PlaceBox();
			return;
		}
	}

	// ensure the contents of the phrase box are saved to the KB
	// & make the punctuated target string
	if (pApp->m_pTargetBox != NULL && pApp->m_pTargetBox->IsShown())
	{
		MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);

        // we are about to leave the current phrase box location, so we must try to store
        // what is now in the box, if the relevant flags allow it
		RemovePunctuation(pDoc, &pApp->m_targetPhrase, from_target_text);
		gbInhibitLine4StrCall = TRUE;
		bool bOK;
		bOK = StoreText(pApp->m_pKB, pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);
		gbInhibitLine4StrCall = FALSE;
	}

    // at this point, we need to increment the pInsertLocPile pointer to the next pile, and
    // the nSequNum to it's sequence number, since InsertNullSourcePhrase() always inserts
    // "before" the pInsertLocPile; however, if the selection end, or active location if
    // there is no selection, is at the very end of the document (ie. last sourcephrase),
    // there is no following source phrase instance to insert before. If this is the case,
    // we have to append a dummy sourcephrase at the end of the document, do the insertion,
    // and then remove it again; and we will also have to set (and later clear) the global
    // gbDummyAddedTemporarily because this is used in the function in order to force a
    // leftwards association only (and hence the user does not have to be asked whether to
    // associate right or left, if there is final punctuation)
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CSourcePhrase* pDummySrcPhrase = NULL; // whm initialized to NULL
	if (nSequNum == pApp->GetMaxIndex())
	{
		// a dummy is temporarily required
		gbDummyAddedTemporarily = TRUE;

		// do the append
		pDummySrcPhrase = new CSourcePhrase;
		wxASSERT(pDummySrcPhrase != NULL);
		pDummySrcPhrase->m_srcPhrase = _T("dummy"); // something needed, so a pile width can
													// be computed
		pDummySrcPhrase->m_key = pDummySrcPhrase->m_srcPhrase;
		pDummySrcPhrase->m_nSequNumber = pApp->GetMaxIndex() + 1;
		SPList::Node* posTail;
		posTail = pSrcPhrases->Append(pDummySrcPhrase);

		// create a partner pile for this dummy CSourcePhrase instance
		pDoc->CreatePartnerPile(pDummySrcPhrase);

		// we need a valid layout which includes the new dummy element on its own pile
		pApp->m_nActiveSequNum = pApp->GetMaxIndex();
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->GetMaxIndex()); // temporary active 
													// location, at the dummy one
		// now we can do the insertion
		pInsertLocPile = pApp->m_pActivePile;
		nSequNum = pApp->GetMaxIndex();
	}
	else
	{
		// the 'next' pile is not beyond the document's end, so make it the insert
		// location
		CPile* pPile = GetNextPile(pInsertLocPile);
		wxASSERT(pPile != NULL);
		pInsertLocPile = pPile;
		pApp->m_pActivePile = pInsertLocPile; // ensure it is up to date
		nSequNum++; // make the sequence number agree
	}

	InsertNullSourcePhrase(pDoc,pApp,pInsertLocPile,nCount,TRUE,FALSE,FALSE); // here, never for
	// Retransln if we inserted a dummy, now get rid of it and clear the global flag
	if (gbDummyAddedTemporarily)
	{
		gbDummyAddedTemporarily = FALSE;

		// now remove the dummy element, and make sure memory is not leaked!
		// for refactored code, first remove the partner pile for the dummy, then the dummy
		pDoc->DeletePartnerPile(pDummySrcPhrase);
		// now the dummy CSourcePhrase instance
		delete pDummySrcPhrase->m_pSavedWords;
		pDummySrcPhrase->m_pSavedWords = (SPList*)NULL;
		delete pDummySrcPhrase->m_pMedialMarkers;
		pDummySrcPhrase->m_pMedialMarkers = (wxArrayString*)NULL;
		delete pDummySrcPhrase->m_pMedialPuncts;
		pDummySrcPhrase->m_pMedialPuncts = (wxArrayString*)NULL;
		SPList::Node *pLast = pSrcPhrases->GetLast();
		pSrcPhrases->DeleteNode(pLast);
		delete pDummySrcPhrase;
		pDummySrcPhrase = (CSourcePhrase*)NULL;

		// get another valid layout
		pApp->m_nActiveSequNum = pApp->GetMaxIndex();
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->GetMaxIndex()); // temporarily at the end, 
															// caller will fix
		nSequNum = pApp->GetMaxIndex();
	}

	// jump to it (can't use old pile pointers, the recalcLayout call 
	// will have clobbered them)
	CPile* pPile = GetPile(nSequNum);
	Jump(pApp, pPile->GetSrcPhrase());
}

void CAdapt_ItView::OnButtonNullSrc(wxCommandEvent& WXUNUSED(event))
{
    // Since the Add placeholder toolbar button has an accelerator table hot key (CTRL-I
    // see CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even
    // when they are disabled, we must check for a disabled button and return if disabled.
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument(); //GetDocument();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_NULL_SRC))
	{
		::wxBell();
		return;
	}

	if (gbIsGlossing)
	{
		//IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_(
		"This particular operation is not available when you are glossing."),
		_T(""),wxICON_INFORMATION);
		return;
	}
	int nSequNum;
	int nCount;

	// Bill wanted the behaviour modified, so that if the box's m_bAbandonable flag is TRUE
	// (ie. a copy of source text was done and nothing typed yet) then the current pile
	// would have the box contents abandoned, nothing put in the KB, and then the placeholder
	// inserion - the advantage of this is that if the placeholder is inserted immediately
	// before the phrasebox's location, then after the placeholder text is typed and the user
	// hits ENTER to continue looking ahead, the former box location will get the box and the
	// copy of the source redone, rather than the user usually having to edit out an unwanted
	// copy from the KB, or remember to clear the box manually. A sufficient thing to do here
	// is just to clear the box's contents.
	if (pApp->m_pTargetBox->m_bAbandonable)
	{
		pApp->m_targetPhrase.Empty();
		if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
			pApp->m_pTargetBox->ChangeValue(_T(""));
		}
	}

	if (wxGetKeyState(WXK_CONTROL))
	{
		// CTRL key is down, so an "insert after" is wanted
		// first save old sequ num for active location
		gnOldSequNum = pApp->m_nActiveSequNum;

		// find the pile after which to do the insertion - it will either be after the
		// last selected pile if there is a selection current, or after the active location
		// if no selection is current - beware the case when active location is a doc end!
		CPile* pInsertLocPile;
		nCount = 1; // the button or shortcut can only insert one
		nSequNum = -1;
		if (pApp->m_selectionLine != -1)
		{
			// we have a selection, the pile we want is that of the selection 
			// list's last element
			CCellList* pCellList = &pApp->m_selection;
			CCellList::Node* cpos = pCellList->GetLast();
			pInsertLocPile = cpos->GetData()->GetPile();
			if (pInsertLocPile == NULL)
			{
				wxMessageBox(_T(
				"A zero pointer was returned, the insertion cannot be done."),
				_T(""), wxICON_EXCLAMATION);
				return;
			}
			nSequNum = pInsertLocPile->GetSrcPhrase()->m_nSequNumber;
			wxASSERT(pInsertLocPile != NULL);
			RemoveSelection(); // Invalidate will be called in InsertNullSourcePhrase()
		}
		else
		{
			// no selection, so just insert after wherever the phraseBox currently is located
			pInsertLocPile = pApp->m_pActivePile;
			if (pInsertLocPile == NULL)
			{
				wxMessageBox(_T(
				"A zero pointer was returned, the insertion cannot be done."),
				_T(""), wxICON_EXCLAMATION);
				return;
			}
			nSequNum = pInsertLocPile->GetSrcPhrase()->m_nSequNumber;
		}
		wxASSERT(nSequNum >= 0);

        // check we are not in a retranslation - we can't insert there! We can be at the
        // end of a retranslation since we are then inserting after it, but if we are not
        // at the end, there will be at least one more retranslation sourcephrase to the
        // right, and so we must check if this is the case & abort the operation if so
		if(pInsertLocPile->GetSrcPhrase()->m_bRetranslation)
		{
			CPile* pPile = GetNextPile(pInsertLocPile);
			if (pPile == NULL || pPile->GetSrcPhrase()->m_bRetranslation)
			{
				// IDS_NO_INSERT_IN_RETRANS
				wxMessageBox(_(
"You cannot insert a placeholder within a retranslation. The command has been ignored.")
				,_T(""), wxICON_EXCLAMATION);
				RemoveSelection();
				Invalidate();
				GetLayout()->PlaceBox();
				return;
			}
		}

		// ensure the contents of the phrase box are saved to the KB
		// & make the punctuated target string
		if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
			MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);

            // we are about to leave the current phrase box location, so we must try to
            // store what is now in the box, if the relevant flags allow it
			RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);
			gbInhibitLine4StrCall = TRUE;
			bool bOK;
			bOK = StoreText(pApp->m_pKB, pApp->m_pActivePile->GetSrcPhrase(), 
								pApp->m_targetPhrase);
			gbInhibitLine4StrCall = FALSE;
		}

        // at this point, we need to increment the pInsertLocPile pointer to the next pile,
        // and the nSequNum to it's sequence number, since InsertNullSourcePhrase() always
        // inserts "before" the pInsertLocPile; however, if the selection end, or active
        // location if there is no selection, is at the very end of the document (ie. last
        // sourcephrase), there is no following source phrase instance to insert before. If
        // this is the case, we have to append a dummy sourcephrase at the end of the
        // document, do the insertion, and then remove it again; and we will also have to
        // set (and later clear) the global gbDummyAddedTemporarily because this is used in
        // the function in order to force a leftwards association only (and hence the user
        // does not have to be asked whether to associate right or left, if there is final
        // punctuation)
		SPList* pSrcPhrases = pApp->m_pSourcePhrases;
		CSourcePhrase* pDummySrcPhrase = NULL; // whm initialized to NULL
		if (nSequNum == pApp->GetMaxIndex())
		{
			// a dummy is temporarily required
			gbDummyAddedTemporarily = TRUE;

			// do the append
			pDummySrcPhrase = new CSourcePhrase;
			pDummySrcPhrase->m_srcPhrase = _T("dummy"); // something needed, so a 
														// pile width can be computed
			pDummySrcPhrase->m_key = pDummySrcPhrase->m_srcPhrase;
			pDummySrcPhrase->m_nSequNumber = pApp->GetMaxIndex() + 1;
			SPList::Node* posTail;
			posTail = pSrcPhrases->Append(pDummySrcPhrase);

			// now we need to add a partner pile for it in CLayout::m_pileList
			pDoc->CreatePartnerPile(pDummySrcPhrase);

			// we need a valid layout which includes the new dummy element on 
			// its own pile
			pApp->m_nActiveSequNum = pApp->GetMaxIndex();
#ifdef _NEW_LAYOUT
			GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
			GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->GetMaxIndex()); // temporary 
											// active location, at the dummy one
			// now we can do the insertion
			pInsertLocPile = pApp->m_pActivePile;
			nSequNum = pApp->GetMaxIndex();
		}
		else
		{
			// the 'next' pile is not beyond the document's end, so make it the insert
			// location
			CPile* pPile = GetNextPile(pInsertLocPile);
			wxASSERT(pPile != NULL);
			pInsertLocPile = pPile;
			pApp->m_pActivePile = pInsertLocPile; // ensure it is up to date
			nSequNum++; // make the sequence number agree
		}
		
		InsertNullSourcePhrase(pDoc,pApp,pInsertLocPile,nCount,TRUE,FALSE,FALSE); // here, never
																				  // for Retransln
		// if we inserted a dummy, now get rid of it and clear the global flag
		if (gbDummyAddedTemporarily)
		{
			gbDummyAddedTemporarily = FALSE;

			// first, remove the temporary partner pile
			pDoc->DeletePartnerPile(pDummySrcPhrase);

			// now remove the dummy element, and make sure memory is not leaked!
			delete pDummySrcPhrase->m_pSavedWords;
			delete pDummySrcPhrase->m_pMedialMarkers;
			delete pDummySrcPhrase->m_pMedialPuncts;
			bool deleteOK;
			deleteOK = pSrcPhrases->DeleteNode(pSrcPhrases->GetLast());
			wxASSERT(deleteOK);
			delete pDummySrcPhrase;

			// get another valid layout
			pApp->m_nActiveSequNum = pApp->GetMaxIndex();
#ifdef _NEW_LAYOUT
			GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
			GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->GetMaxIndex()); // temporarily at the end, 
																// caller will fix
			nSequNum = pApp->GetMaxIndex();
		}

		// BEW added 10Sep08 in support of Vertical Edit mode
		if (gbVerticalEditInProgress)
		{
            // update the relevant parts of the gEditRecord (all spans are affected
            // equally, except the source text edit section is unchanged)
			gEditRecord.nAdaptationStep_ExtrasFromUserEdits += 1;
			gEditRecord.nAdaptationStep_NewSpanCount += 1;
			gEditRecord.nAdaptationStep_EndingSequNum += 1;
		}

		// jump to it (can't use old pile pointers, the recalcLayout call 
		// will have clobbered them)
		CPile* pPile = GetPile(nSequNum);
		Jump(pApp,pPile->GetSrcPhrase());
	}
	else // not inserting after the selection's end or active location, but before
	{
		// first save old sequ num for active location
		gnOldSequNum = pApp->m_nActiveSequNum;

        // find the pile preceding which to do the insertion - it will either be preceding
        // the first selected pile, if there is a selection current, or preceding the
        // active location if no selection is current
		CPile* pInsertLocPile;
		nCount = 1; // the button or shortcut can only insert one
		nSequNum = -1;
		if (pApp->m_selectionLine != -1)
		{
			// we have a selection, the pile we want is that of the selection 
			// list's first element
			CCellList* pCellList = &pApp->m_selection;
			CCellList::Node* cpos = pCellList->GetFirst();
			pInsertLocPile = cpos->GetData()->GetPile();
			if (pInsertLocPile == NULL)
			{
				wxMessageBox(_T(
				"A zero pointer was returned, the insertion cannot be done."),
				_T(""), wxICON_EXCLAMATION);
				return;
			}
			nSequNum = pInsertLocPile->GetSrcPhrase()->m_nSequNumber;
			wxASSERT(pInsertLocPile != NULL);
			RemoveSelection(); // Invalidate will be called in InsertNullSourcePhrase()
		}
		else
		{
			// no selection, so just insert preceding wherever the phraseBox 
			// currently is located
			pInsertLocPile = pApp->m_pActivePile;
			if (pInsertLocPile == NULL)
			{
				wxMessageBox(_T(
				"A zero pointer was returned, the insertion cannot be done."),
				_T(""), wxICON_EXCLAMATION);
				return;
			}
			nSequNum = pInsertLocPile->GetSrcPhrase()->m_nSequNumber;
		}
		wxASSERT(nSequNum >= 0);


		// check we are not in a retranslation - we can't insert there! (only need to check
		// previous one, if it is still a retranslation, we must abort the operation)
		if(pInsertLocPile->GetSrcPhrase()->m_bRetranslation)
		{
			CPile* pPile = GetPrevPile(pInsertLocPile);
			if (pPile == NULL || pPile->GetSrcPhrase()->m_bRetranslation)
			{
				// IDS_NO_INSERT_IN_RETRANS
				wxMessageBox(_(
"Sorry, you cannot insert a placeholder within a retranslation. The command has been ignored."),
				_T(""), wxICON_EXCLAMATION);
				RemoveSelection();
				Invalidate();
				GetLayout()->PlaceBox();
				return;
			}
		}

		// ensure the contents of the phrase box are saved to the KB
		// & make the punctuated target string
		if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
			MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(), pApp->m_targetPhrase);

            // we are about to leave the current phrase box location, so we must try to
            // store what is now in the box, if the relevant flags allow it
			RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);
			gbInhibitLine4StrCall = TRUE;
			bool bOK;
			bOK = StoreText(pApp->m_pKB, pApp->m_pActivePile->GetSrcPhrase(), 
								pApp->m_targetPhrase);
			gbInhibitLine4StrCall = FALSE;
		}

		InsertNullSourcePhrase(pDoc, pApp, pInsertLocPile, nCount);

		// BEW added 10Sep08 in support of Vertical Edit mode
		if (gbVerticalEditInProgress)
		{
            // update the relevant parts of the gEditRecord (all spans are affected
            // equally, except the source text edit section is unchanged)
			gEditRecord.nAdaptationStep_ExtrasFromUserEdits += 1;
			gEditRecord.nAdaptationStep_NewSpanCount += 1;
			gEditRecord.nAdaptationStep_EndingSequNum += 1;
		}

		// jump to it (can't use old pile pointers, the recalcLayout call 
		// will have clobbered them)
		CPile* pPile = GetPile(nSequNum);
		Jump(pApp, pPile->GetSrcPhrase());
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Insert A Placeholder"
/// toolbar item and returns immediately: The application is in glossing mode, the target
/// text only is showing in the main window, the m_pActivePile pointer is NULL, or the
/// application is in Free Translation mode. It enables the toolbar button if there is a
/// valid selection or the targetBox is showing, and the targetBox is the window in focus.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonNullSrc(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	bool bCanInsert = FALSE;
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_selectionLine != -1 || (pApp->m_pTargetBox->IsShown()
			&& (pApp->m_pTargetBox == wxWindow::FindFocus())))
		bCanInsert = TRUE;
	}
	event.Enable(bCanInsert);
}

// returns previous source phrase's pointer, or null if there is no previous one
CSourcePhrase* CAdapt_ItView::GetPrevSrcPhrase(SPList::Node*& curPos,SPList::Node*& posPrev)
{
	wxASSERT(curPos != NULL);
	SPList::Node* pos = curPos; 
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData(); 
	pos = pos->GetPrevious();
	if (pos != NULL)
	{
		posPrev = pos; // this is the previous position
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetPrevious();
		wxASSERT(pSrcPhrase);
		return pSrcPhrase;
	}
	else
	{
		posPrev = (SPList::Node*)NULL;
		return (CSourcePhrase*)0;
	}
}

// returns a pointer to the inserted single null source phrase which was inserted
CSourcePhrase* CAdapt_ItView::ReDoInsertNullSrcPhrase(SPList* pList,SPList::Node*& insertPos,
													  bool bForRetranslation)
{
	wxASSERT(insertPos != NULL);
	wxASSERT(pList);

	CSourcePhrase* pSrcPhr = (CSourcePhrase*)insertPos->GetData();
	wxASSERT(pSrcPhr);
	int nCurSequNum = pSrcPhr->m_nSequNumber; // this will be used for 
											  // the UpdateSequNumbers() call
	// create a new null source phrase
	CSourcePhrase* pSrcPhrase = new CSourcePhrase; // this should never fail, it's small
	wxASSERT(pSrcPhrase != NULL);
	pSrcPhrase->m_bNullSourcePhrase = TRUE;
	pSrcPhrase->m_srcPhrase = _T("...");
	pSrcPhrase->m_key = _T("...");
	pSrcPhrase->m_nSequNumber = nCurSequNum; // ensures the UpdateSequNumbers() call works

	if (bForRetranslation)
	{
        // if we are calling the function as part of re-rendering a retranslation, then we
        // will want to set the appropriate flags for this situation
		pSrcPhrase->m_bRetranslation = TRUE;
		pSrcPhrase->m_bNotInKB = TRUE;
	}

    // now insert it in the list, and update the end index (the latter is probably not
    // needed here) Note: wxList::Insert places the item before the given item and the
    // inserted item then has the insertPos node position.
	pList->Insert(insertPos,pSrcPhrase); 

	// update the sequence numbers starting from the newly inserted null source phrase
	UpdateSequNumbers(nCurSequNum);

    // do any copying to m_inform, and other source phrase members in the caller, so just
    // return a pointer to the new null source phrase
	return pSrcPhrase;
}

// BEW additions 22Jul05 for support of free translations when placeholder insertions are done
void CAdapt_ItView::InsertNullSourcePhrase(CAdapt_ItDoc* pDoc,CAdapt_ItApp* pApp,
										   CPile* pInsertLocPile,const int nCount,
										   bool bRestoreTargetBox,bool bForRetranslation,
										   bool bInsertBefore)
{
	bool bAssociatingRightwards = FALSE;
	CSourcePhrase* pSrcPhrase = NULL; // whm initialized to NULL
	CSourcePhrase* pPrevSrcPhrase = NULL; // whm initialized to NULL
	CPile* pPrevPile;
	CPile* pPile = pInsertLocPile;
	int nStartingSequNum = pPile->GetSrcPhrase()->m_nSequNumber;
	// whm 2Aug06 added following test to prevent insertion of placeholder 
	// in front of \id marker
	// BEW added !bForRetranslation on 6Aug09, because Bob Buss found the test succeeded
	// when here was the following information at the source text file start:
	// \id MAT English-US: New Living Translation 1996 
	// \ide 65001 - UNICODE(UTF-8)
	// \rem For any ... holder
	// \h MAT
	// \mt Matthew
	// \c 1
	// \s The Record of Jesus' Ancestors
	// where the first non-filtered info was "Matthew" after the stuff in the \id line,
	// and he had selected from English-US as far as the "1996" to make his retranslation
	// and his retranslation was longer than the 5 words he selected. What happened was
	// that the following test (without my addition) succeeds because the CSourcePhrase
	// storing "Matthew" contains the m_markers member with marker \ide in it. The test
	// for finding "\id" then succeeds, and so the bell rings and the needed null source
	// phrases are not inserted - but in the caller the extra words are inserted into the
	// list assuming the null source phrases had been put into the list beforehand,
	// resulting in an error state - that is, a malformed document, but the app doesn't
	// crash  - the extra words in the retranslation wipe out adaptations from Matthew
	// onwards until all the extra words are consumed.
	// Since this test only applies to an attempt by the user to insert a placeholder
	// preceding the very first CSourcePhrase, and that can't happen when doing a
	// retranslation because there have to be selectable CSourcePhrase instances before
	// that, and that can't happen before the one bearing an \id marker, all we need do
	// here is add the additional condition !bForRetranslation and this bug is history
	if (pPile->GetSrcPhrase()->m_markers.Find(_T("\\id")) != -1 && !bForRetranslation)
	{
        // user is attempting to insert placeholder before a \id marker which should not be
        // allowed rather than a message, we'll just beep and return
		::wxBell();
		return;
	}
	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* insertPos	= pList->Item(nStartingSequNum); // the position before
												// which we will make the insertion
	CSourcePhrase* pOldLastSrcPhrase; // the sourcephrase which lies before the first 
        // inserted ellipsis, we have to check this one for a m_bEndFreeTrans == TRUE flag
        // and move that BOOL value to the end of the insertions
	bool bMoveEndOfFreeTrans = FALSE; // moved outside of if block below
	if (nStartingSequNum > 0) // whm added to prevent assert and unneeded test for 
							  // m_bEndFreeTrans when sequ num is zero
	{
		SPList::Node* earlierPos = pList->Item(nStartingSequNum - 1);
		pOldLastSrcPhrase = (CSourcePhrase*)earlierPos->GetData();
		if (pOldLastSrcPhrase->m_bEndFreeTrans)
		{
			pOldLastSrcPhrase->m_bEndFreeTrans = FALSE;
			bMoveEndOfFreeTrans = TRUE;
		}
	}

	// get the sequ num for the insertion location 
	// (it could be quite diff from active sequ num)
	CSourcePhrase* pSrcPhraseInsLoc = pInsertLocPile->GetSrcPhrase();
	int	nSequNumInsLoc = pSrcPhraseInsLoc->m_nSequNumber;
	wxASSERT(nSequNumInsLoc >= 0 && nSequNumInsLoc <= pApp->GetMaxIndex());

	wxASSERT(insertPos != NULL);
	int nActiveSequNum = pApp->m_nActiveSequNum; // save, so we can restore later on, 
					// since the call to RecalcLayout() will clobber pointers

    // we may be inserting in the context of a footnote, either within it, or next to it -
    // so we will need to do some checks to determine whether or not we will have to set
    // the TextType as 'footnote'. A sufficient condition for being 'within' a footnote is
    // m_bFootnote = FALSE but m_curTextType == footnote; the insertion before the start of
    // a footnote, or after the end of a footnote, will be dealt with further down in the
    // current function.
	if (!bForRetranslation)
	{
        // retranslation case is taken care of by handlers OnButtonRetranslation and
        // OnButtonEditRetranslation, so only the normal null srcphrase insertion needs to
        // be considered here
		if (pSrcPhraseInsLoc->m_curTextType == footnote && 
			pSrcPhraseInsLoc->m_bFootnote == FALSE)
			gbInsertingWithinFootnote = TRUE;
	}

    // create the needed null source phrases and insert them in the list; preserve pointers
    // to the first and last for use below
	CSourcePhrase* pFirstOne = NULL; // whm initialized to NULL
	CSourcePhrase* pLastOne = NULL; // whm initialized to NULL
	for (int i = 0; i<nCount; i++)
	{
		CSourcePhrase* pSrcPhrasePH = new CSourcePhrase; // PH means 'PlaceHolder'
		if (i == 0)
		{
			pFirstOne = pSrcPhrasePH;
			pSrcPhrase = pSrcPhrasePH;
		}
		if (i == nCount-1)
			pLastOne = pSrcPhrasePH;
		pSrcPhrasePH->m_bNullSourcePhrase = TRUE;
		pSrcPhrasePH->m_srcPhrase = _T("...");
		pSrcPhrasePH->m_key = _T("...");
		pSrcPhrasePH->m_nSequNumber = nStartingSequNum + i; // ensures the
													// UpdateSequNumbers() call works
		if (bForRetranslation)
		{
            // if we are calling the function as part of rendering a retranslation, then we
            // will want to set the appropriate flags for each of the null source phrases
			pSrcPhrasePH->m_bRetranslation = TRUE;
			pSrcPhrasePH->m_bNotInKB = TRUE;

            // BEW added 22Jul05 for support of free translations. We assume placeholders
            // within a free translation section in a retranslation belong to the free
            // translation section - provided that section exists at the last sourcephrase
            // instance before the first placeholder, and if the last sourcephrase before
            // the first placeholder was the end of the free translation section, then we
            // move the end of the section to the last placeholder as well
			if (pSrcPhraseInsLoc->m_bHasFreeTrans)
				pSrcPhrasePH->m_bHasFreeTrans = TRUE; // handles the 'within' case
			if ((i == nCount - 1) && bMoveEndOfFreeTrans)
			{
                // move the end of the free translation to this last one (flag on old
                // location is already cleared above in anticipation of this)
				wxASSERT(pLastOne);
				pLastOne->m_bEndFreeTrans = TRUE;
			}
		}

        // set the footnote TextType if the flag is TRUE; the flag can be set TRUE within
        // the handlers for retranslation, edit of a retranslation, edit of source text,
        // and in the InsertNullSourcePhrase function itself. We have to get the type
        // right, because the user might output interlinear RTF with footnote suppression
        // wanted, so we have to ensure that these null source phrases have the footnote
        // TextType set so that the suppression will work properly
		if (gbInsertingWithinFootnote)
		{
			pSrcPhrasePH->m_curTextType = footnote;
			if (!pSrcPhrasePH->m_bRetranslation)
				pSrcPhrasePH->m_bSpecialText = TRUE; // want it to have special text colour
		}

		pList->Insert(insertPos,pSrcPhrasePH);

		// BEW added 13Mar09 for refactored layout
		pDoc->CreatePartnerPile(pSrcPhrasePH);
	}

	// fix the sequ num for the old insert location's source phrase
	nSequNumInsLoc += nCount;

    // calculate the new active sequ number - it could be anywhere, but all we need to know
    // is whether or not the insertion was done preceding the former active sequ number's
    // location
	if (nStartingSequNum <= nActiveSequNum)
		pApp->m_nActiveSequNum = nActiveSequNum + nCount;

	// update the sequence numbers, starting from the first one inserted
	UpdateSequNumbers(nStartingSequNum);

    // we must check if there is preceding punctuation on the following source phrase, or a
    // marker; or following punctuation on the preceding source phrase. If one of these
    // conditions (or several conditions) obtain, then we must ask the user whether the
    // null source phrase associates with the end of the previous one, or with the
    // following one; and do the appropriate transfer of punctuation and or marker to the
    // first null src phrase (if association is to the right), or the last null source
    // phrase (if the association is to the left) - but all of this only provided we are
    // not doing rendering of a retranslation. If inserting before the first pile, we don't
    // have to worry about any preceding context.
	bool bAssociationRequired = FALSE; // it will be set true if the message box for 
				// associating to the left or right is required at punctuation
	bool bPreviousFollPunct = FALSE;
	bool bFollowingPrecPunct = FALSE;
	bool bFollowingMarkers = FALSE;
	int nPrevSequNum = nStartingSequNum - 1; // remember, this could be -ve
	if (!bForRetranslation)
	{
		if (nPrevSequNum != -1)
		{
			pPrevPile = GetPrevPile(pInsertLocPile); // old pointers are still valid
			wxASSERT(pPrevPile != NULL);
			pPrevSrcPhrase = pPrevPile->GetSrcPhrase();
			if (!pPrevSrcPhrase->m_follPunct.IsEmpty())
				bPreviousFollPunct = TRUE;
		}
		else
		{
			// make sure these pointers are null if we are inserting at the doc beginning
			pPrevPile = NULL;
			pPrevSrcPhrase = NULL;
		}
		// now check the following source phrase for any preceding punct or a marker
		if (!pSrcPhraseInsLoc->m_precPunct.IsEmpty())
			bFollowingPrecPunct = TRUE;
		if (!pSrcPhraseInsLoc->m_markers.IsEmpty())
		{
            // BEW added 23Jul05, so that a marker which has TextType none does not trigger
            // the message box, and if the insertion is before its endmarker then the
            // endmarker gets moved to the placeholder (making the insertion be 'outside'
            // the text delimited by the marker & endmarker pair)
			wxString markersStr = pSrcPhraseInsLoc->m_markers;
			int curPos = markersStr.Find(filterMkr);
			if (curPos >= 0)
			{
				// it's a \~FILTER marker, so not one of the TextType == none ones
				bFollowingMarkers = TRUE;
			}
			else
			{
				// check out what it actually is
				curPos = markersStr.Find(gSFescapechar);
				if (curPos == -1)
				{
					// no marker present, so don't set the flag
					;
				}
				else
				{
                    // wx version note: Since we require a read-only buffer we use GetData()
                    // which just returns a const wxChar* to the data in the string.
					const wxChar* pBuff = markersStr.GetData(); 
					wxChar* pBufStart = (wxChar*)pBuff;
					wxChar* pEnd;
					pEnd = pBufStart + markersStr.Length(); // whm added
					wxASSERT(*pEnd == _T('\0')); // whm added
					wxChar* ptr = pBufStart + curPos;
					wxASSERT(*ptr == gSFescapechar);
					wxString bareMkr = pDoc->GetBareMarkerForLookup(ptr);
					wxString wholeMkrLessBackslash = pDoc->GetMarkerWithoutBackslash(ptr);
					USFMAnalysis* pAnalysis = pDoc->LookupSFM(ptr);
					if (pAnalysis == NULL)
					{
						// its an unknown marker, so one which should trigger the message box
						bFollowingMarkers = TRUE;
					}
					else
					{
						// it's a known marker
						wxString endMkr = pAnalysis->endMarker; // could return an empty string
						if (pAnalysis->textType == none)
						{
                            // it's a marker which we don't want to trigger the message
                            // box, check out if its the endmarker? if so, we'll assume the
                            // marker is the only marker in m_markers, and move the latter
                            // to the placeholder
							if (wholeMkrLessBackslash == endMkr)
							{
								// it's an endmarker - so do the m_markers move
								pSrcPhrase->m_markers = pSrcPhraseInsLoc->m_markers;
								pSrcPhraseInsLoc->m_markers.Empty();
							}
							bFollowingMarkers = FALSE;
						}
						else
						{
							// it needs to trigger the message box
							bFollowingMarkers = TRUE;
						}
					}
				}
			}
		}

		// if one of the flags is true, ask the user for the direction of association
		if (bFollowingMarkers || bFollowingPrecPunct || bPreviousFollPunct)
		{
			// association leftwards or rightwards will be required, so set the flag
			// for this
			bAssociationRequired = TRUE;
			
			// bleed off the case when we are inserting before a temporary dummy srcphrase,
			// since in this situation association always can only be leftwards
			if (!bInsertBefore && gbDummyAddedTemporarily)
				goto a;

			// any other situation, we need to let the user make the choice
			// IDS_PUNCT_OR_MARKERS
			if (wxMessageBox(_(
"Adapt It does not know whether the inserted placeholder is the end of the preceding text, or the beginning of what follows. Is it the start of what follows?"),
				_T(""),wxYES_NO) == wxYES)
			{
				bAssociatingRightwards = TRUE;

				// the association is to the text which follows, so transfer from there
				// to the first in the list - but not if the first sourcephrase of a
				// retranslation follows, if it does, then silently ignore user's choice
				if (bFollowingMarkers)
				{
					if (pSrcPhraseInsLoc->m_bBeginRetranslation)
						// can't right associate into a retranslation, so skip the block
						goto m;
					wxASSERT(pFirstOne != NULL); // whm added
					pFirstOne->m_markers = pSrcPhraseInsLoc->m_markers; // transfer markers
					pSrcPhraseInsLoc->m_markers.Empty();

					// right association to the beginning of a footnote makes the insertion
					// also part of the footnote, so deal with this possibility
					if (pSrcPhraseInsLoc->m_curTextType == 
											footnote && pSrcPhraseInsLoc->m_bFootnote)
					{
						pFirstOne->m_curTextType = footnote;
						// note m_bFootnote flag is handled in next block rather than here
					}


                    // have to also copy various members, such as m_inform, so navigation
                    // text works right; but we don't want to copy everything - for
                    // instance, we don't want to incorporate it into a retranslation; so
                    // just get the essentials
					pFirstOne->m_inform = pSrcPhraseInsLoc->m_inform;
					pFirstOne->m_chapterVerse = pSrcPhraseInsLoc->m_chapterVerse;
					pFirstOne->m_bVerse = pSrcPhraseInsLoc->m_bVerse;
					pFirstOne->m_bParagraph = pSrcPhraseInsLoc->m_bParagraph;
					pFirstOne->m_bChapter = pSrcPhraseInsLoc->m_bChapter;
					pFirstOne->m_bSpecialText = pSrcPhraseInsLoc->m_bSpecialText;
					pFirstOne->m_bFootnote = pSrcPhraseInsLoc->m_bFootnote;
					pFirstOne->m_bFirstOfType = pSrcPhraseInsLoc->m_bFirstOfType;
					pFirstOne->m_curTextType = pSrcPhraseInsLoc->m_curTextType;

                    // copying the m_markers member means we must transfer the flag values
                    // for the 3 booleans which could be there due to a note and/or free
                    // translation
					pFirstOne->m_bHasNote = pSrcPhraseInsLoc->m_bHasNote;
					pFirstOne->m_bHasFreeTrans = pSrcPhraseInsLoc->m_bHasFreeTrans;
					pFirstOne->m_bStartFreeTrans = pSrcPhraseInsLoc->m_bStartFreeTrans;
                    // if we inserted before the end of a free translation, the
                    // m_bEndFreeTrans boolean does not move
					pSrcPhraseInsLoc->m_bHasNote = FALSE;
					pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;

					// clear the others which were moved
					pSrcPhraseInsLoc->m_inform.Empty();
					pSrcPhraseInsLoc->m_chapterVerse.Empty();
					pSrcPhraseInsLoc->m_bFirstOfType = FALSE;
					pSrcPhraseInsLoc->m_bVerse = FALSE;
					pSrcPhraseInsLoc->m_bParagraph = FALSE;
					pSrcPhraseInsLoc->m_bChapter = FALSE;
					pSrcPhraseInsLoc->m_bFootnote = FALSE;
					pSrcPhraseInsLoc->m_bFootnote = FALSE;
				}
				if (bFollowingPrecPunct)
				{
					pFirstOne->m_precPunct = pSrcPhraseInsLoc->m_precPunct; // transfer 
														// the preceding punctuation
					pSrcPhraseInsLoc->m_precPunct.Empty();

                    // do an adjustment of the m_targetStr member, simplest solution is to
                    // make it same as the m_adaption member
					pSrcPhraseInsLoc->m_targetStr = pSrcPhraseInsLoc->m_adaption;
					pFirstOne->m_bFirstOfType = pSrcPhraseInsLoc->m_bFirstOfType;
				}
			}
			else
			{
				// the association is to the text which precedes, so transfer from there
				// to the last in the list
a:				bAssociatingRightwards = FALSE;

				if (bPreviousFollPunct)
				{
					pLastOne->m_follPunct = pPrevSrcPhrase->m_follPunct; // transfer 
													// the following punctuation
					pPrevSrcPhrase->m_follPunct.Empty();

                    // left association when the text to the left is a footnote makes the
                    // inserted text part of the footnote; so get the TextType set
                    // correctly
					if (pPrevSrcPhrase->m_curTextType == footnote)
					{
						pLastOne->m_bSpecialText = TRUE; // want it to have special text colour
						pLastOne->m_curTextType = footnote;
						// note: m_bFootnoteEnd is dealt with below
					}

                    // do an adjustment of the m_targetStr member, simplest solution is to
                    // make it same as the m_adaption member; then transfer the other
                    // member's values which are pertinent to the leftwards association
					pPrevSrcPhrase->m_targetStr = pPrevSrcPhrase->m_adaption;
					pLastOne->m_bFootnoteEnd = pPrevSrcPhrase->m_bFootnoteEnd;
					pPrevSrcPhrase->m_bFootnoteEnd = FALSE;
					pLastOne->m_bBoundary = pPrevSrcPhrase->m_bBoundary;
					pPrevSrcPhrase->m_bBoundary = FALSE;
				}
			}
		}
	}
	else
	{
        // we are inserting to pad out a retranslation, so if the last of the selected
        // source phrases has following punctuation, we need to move it to the last null
        // source phrase inserted (note, the case of moving free-translation-supporting
        // BOOL values is done above)
		CSourcePhrase* pPrevSrcPhrase2 = NULL;	// whm initialized to NULL
		if (nPrevSequNum != -1)
		{
			CPile* pPrevPile = GetPrevPile(pInsertLocPile); // old pointers are still valid
			wxASSERT(pPrevPile != NULL);
			pPrevSrcPhrase2 = pPrevPile->GetSrcPhrase();
			if (!pPrevSrcPhrase2->m_follPunct.IsEmpty())
				bPreviousFollPunct = TRUE;
		}

		if (bPreviousFollPunct)
		{
			// the association is to the text which precedes, so transfer from there
			// to the last in the list
			wxASSERT(pPrevSrcPhrase2 != NULL); // whm added
			pLastOne->m_follPunct = pPrevSrcPhrase2->m_follPunct; // transfer following punct
			pPrevSrcPhrase2->m_follPunct.Empty();
		}
	}

    // handle any adjustments required because the insertion was done where there is one or
    // more free translation sections defined in the viscinity of the inserted
    // sourcephrase.
	if (!bForRetranslation)
	{
        // we've done the retranslation placeholder additions case in a block previously,
        // so here we are interested in the single placeholder inserted not in any
        // retranslation
		if (pPrevSrcPhrase == NULL)
		{
            // the insertion was at the start of the document, so we must assume a
            // rightwards association for the inserted sourcephrase
			if (pSrcPhraseInsLoc->m_bStartFreeTrans)
			{
				pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
				pSrcPhrase->m_bStartFreeTrans = TRUE;
				pSrcPhrase->m_bHasFreeTrans = TRUE;
				// we assume punctuation has already been handled above, if necessary
			}
		}
		else
		{
            // the insertion was done not at the doc beginning, and it may have been done
            // before a temporary sourcephrase added to the doc end until the insertion has
            // been completed, but typically it is some general location in the doc - and
            // what we do will typically depend on whether there was associating left or
            // right, or no associating at all (which means the insertion was done where
            // punctuation was absent immediately before or after) -- but these potential
            // locations are independent (not completely, but enough to complicate matters)
            // of where free translation sections begin and end, so there are a couple of
            // dozen possibilities to be considered for the three consecutive sourcephrase
            // pointers pPrevSrcPhrase, pSrcPhrase, and pSrcPhraseInsLoc - pSrcPhrase being
            // the placeholder which was just inserted.
			if (pPrevSrcPhrase->m_bHasFreeTrans)
			{
				// the previous sourcephrase has a free translation section defined on it
				if (pPrevSrcPhrase->m_bStartFreeTrans)
				{
					// the previous sourcephrase is where a section of free translation starts
					if (pPrevSrcPhrase->m_bEndFreeTrans)
					{
                        // the previous sourcephrase is both the start and end of a free
                        // translation section (ie. a rare short section with one
                        // sourcephrase in it)
						if (pSrcPhraseInsLoc->m_bHasFreeTrans)
						{
                            // the sourcephrase following the placeholder also has a
                            // different free translation section defined on it - what
                            // happens depends on whether there was a left or right
                            // association, or none
							if (pSrcPhraseInsLoc->m_bStartFreeTrans)
							{
                                // its the start of a new section - which we know must be
                                // the case anyway 
                                if (bAssociationRequired && bAssociatingRightwards)
								{
                                    // we have to make the placeholder the new start of the
                                    // section on the right m_markers should have been
                                    // moved already, so just do the flags
									pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
									pSrcPhrase->m_bStartFreeTrans = TRUE;
									pSrcPhrase->m_bHasFreeTrans = TRUE;
								}
								else if (bAssociationRequired && !bAssociatingRightwards)
								{
									// we have to make the placeholder the end of the section
									// on the left
									pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
									pSrcPhrase->m_bEndFreeTrans = TRUE;
									pSrcPhrase->m_bHasFreeTrans = TRUE;
								}
								else if (!bAssociationRequired)
								{
                                    // no punctuation in the context, so the user was not
                                    // asked for an association choice - so we must do so
                                    // now 
                                    // IDS_ASSOC_WITH_FREE_TRANS
									if (wxMessageBox(_(
"Do you want the inserted placeholder to be considered as belonging to the free translation section which begins immediately following it?")
									,_T(""), wxYES_NO) == wxYES)
									{
                                        // user wants to associate it to the right - make
                                        // the placeholder the new start location, and move
                                        // m_markers to it since it won't have been done
                                        // previously
										pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
										pSrcPhrase->m_bStartFreeTrans = TRUE;
										pSrcPhrase->m_bHasFreeTrans = TRUE;
										pSrcPhrase->m_markers = pSrcPhraseInsLoc->m_markers;
										pSrcPhraseInsLoc->m_markers.Empty();
									}
									else
									{
										// user wants to associate it to the left
										pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
										pSrcPhrase->m_bEndFreeTrans = TRUE;
										pSrcPhrase->m_bHasFreeTrans = TRUE;
									}
								}
							}
							else
							{
                                // impossible situation (pPrevSrcPhrase is the end of an
                                // earlier free translation section, so pSrcPhraseInsLoc
                                // must be the starting one of a new section if it is in a
                                // free translation section - so do nothing
								;
							}
						}
					}
					else
					{
                        // the previous sourcephrase starts a free translation section, and
                        // because it is not also the end of the section, the section must
                        // extend past the inserted placeholder - so the placeholder is
                        // within the section, so we only need set one flag
						pSrcPhrase->m_bHasFreeTrans = TRUE;
					}
				}
				else if (pPrevSrcPhrase->m_bEndFreeTrans)
				{
                    // the previous sourcephrase does not start a free translation section,
                    // but it is the end of a section
					if (pSrcPhraseInsLoc->m_bHasFreeTrans)
					{
                        // the sourcephrase following the inserted placeholder is involved
                        // in a free translation section - it has to be the start of a new
                        // section, or the only one in a new section
						if (pSrcPhraseInsLoc->m_bStartFreeTrans)
						{
                            // the sourcephrase following the inserted placeholder is the
                            // start of a new free translation section - what we do now
                            // depends on whether or not there was an association to left
                            // or right due to punctuation, or no association was done
							if (bAssociationRequired && bAssociatingRightwards)
							{
                                // associate to the right, so move the right section's
                                // start to the inserted placeholder, m_markers should
                                // already have been moved
								pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
								pSrcPhrase->m_bStartFreeTrans = TRUE;
								pSrcPhrase->m_bHasFreeTrans = TRUE;
							}
							else if (bAssociationRequired && !bAssociatingRightwards)
							{
                                // associate to the left, so move the end of the previous
                                // section to the inserted placeholder
								pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
								pSrcPhrase->m_bEndFreeTrans = TRUE;
								pSrcPhrase->m_bHasFreeTrans = TRUE;
							}
							else if (!bAssociationRequired)
							{
                                // no association is defined, so we must ask the user for
                                // what to do 
                                // IDS_ASSOC_WITH_FREE_TRANS
								if (wxMessageBox(_(
"Do you want the inserted placeholder to be considered as belonging to the free translation section which begins immediately following it?"),
								_T(""),wxYES_NO) == wxYES)
								{
									// associate rightwards, which means we'll need to move
									// m_markers too
									pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
									pSrcPhrase->m_bStartFreeTrans = TRUE;
									pSrcPhrase->m_bHasFreeTrans = TRUE;
									pSrcPhrase->m_markers = pSrcPhraseInsLoc->m_markers;
									pSrcPhraseInsLoc->m_markers.Empty();
								}
								else
								{
									// associate leftwards
									pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
									pSrcPhrase->m_bEndFreeTrans = TRUE;
									pSrcPhrase->m_bHasFreeTrans = TRUE;
								}
							}
						}
						else
						{
							// impossible situation
							; // do nothing
						}
					}
					else
					{
                        // the sourcephrase following the inserted placeholder has no free
                        // translation defined on it - so we need consider only leftwards
                        // associations or no association
						if (bAssociationRequired && !bAssociatingRightwards)
						{
                            // leftwards association was already requested, so make the
                            // placeholder the new end of the previous section of free
                            // translation
							pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
							pSrcPhrase->m_bEndFreeTrans = TRUE;
							pSrcPhrase->m_bHasFreeTrans = TRUE;
						}
						else if (bAssociationRequired && bAssociatingRightwards)
						{
							// nothing to be done, there is no free translation to the
							// immediate right
							;
						}
						else if (!bAssociationRequired)
						{
							// no association known as yet, so ask the user
							// IDS_ASSOC_LEFT_FREE_TRANS
							if (wxMessageBox(_(
"Do you want the inserted placeholder to be considered as belonging to the free translation section which immediately precedes it?"),
							_T(""),wxYES_NO) == wxYES)
							{
                                // user wants the inserted placeholder to be associated
                                // with the free translation lying to the left - so make
                                // the placeholder be the new end of the section
								pPrevSrcPhrase->m_bEndFreeTrans = FALSE;
								pSrcPhrase->m_bEndFreeTrans = TRUE;
								pSrcPhrase->m_bHasFreeTrans = TRUE;
							}
							else
							{
                                // there is no association, and since no free translation
                                // lies to the immediate right of the placeholder, we don't
                                // have to do anything
								;
							}
						}
					}
				}
				else
				{
                    // the previous sourcephrase neither starts nor ends a free translation
                    // section, so it is within a free translation section - we just need
                    // to set the one flag
					pSrcPhrase->m_bHasFreeTrans = TRUE;
				}
			}
			else
			{
				// pPrevSrcPhrase has no free translation defined on it
				if (pSrcPhraseInsLoc->m_bHasFreeTrans)
				{
                    // the only possibilities are that pSrcPhraseInsLoc is the first or
                    // only free translation in a section lying to the right of the
                    // placeholder. What we do will depend on the associativity, which may
                    // be leftwards, rightwards, or none. (A placeholder inserted before a
                    // temporary sourcephrase at the document end always associates
                    // leftwards. bAssociatingRightwards == FALSE handles that case
                    // automatically.)
					if (pSrcPhraseInsLoc->m_bStartFreeTrans)
					{
						// its the start of a free translation section
						if (bAssociationRequired && !bAssociatingRightwards)
						{
							// leftwards association - so nothing is to be done
							;
						}
						else if (bAssociationRequired && bAssociatingRightwards)
						{
							// rightwards association - we must move the start to the 
							// placeholder
							pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
							pSrcPhrase->m_bStartFreeTrans = TRUE;
							pSrcPhrase->m_bHasFreeTrans = TRUE;
							// punctuation should have been handled already, and 
							// also m_markers
						}
						else if (!bAssociationRequired)
						{
                            // no association in either direction (ie. insertion not at
                            // punctuation) so we have no user action to guide us - so we
                            // must ask the user for guidance
							// IDS_ASSOC_WITH_FREE_TRANS
							if (wxMessageBox(_(
"Do you want the inserted placeholder to be considered as belonging to the free translation section which begins immediately following it?"),
							_T(""),wxYES_NO) == wxYES)
							{
                                // rightwards association - move the start to the
                                // placeholder, but in this case no m_markers movement will
                                // have been done, so we must move that as well
								pSrcPhraseInsLoc->m_bStartFreeTrans = FALSE;
								pSrcPhrase->m_bStartFreeTrans = TRUE;
								pSrcPhrase->m_bHasFreeTrans = TRUE;
								pSrcPhrase->m_markers = pSrcPhraseInsLoc->m_markers;
								pSrcPhraseInsLoc->m_markers.Empty();
							}
							else
							{
								// leftwards association, so do nothing
								;
							}
						}
					}
					else
					{
                        // impossible situation (a free trans section starting without
                        // m_bStartFreeTrans having the value TRUE)
						;
					}

				}
				else
				{
                    // pSrcPhraseInsLoc has no free translation defined on it, so nothing
                    // needs to be done to the default flag values (all 3 FALSE) for free
                    // translation support in pSrcPhrase
					;
				}
			}
		}
	}

	// recalculate the layout
#ifdef _NEW_LAYOUT
m:	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
m:	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile);

	// don't draw the layout and the phrase box when this function is called
	// as part of a larger inclusive procedure
	if (bRestoreTargetBox)
	{
		// restore focus, and selection if any
		pApp->m_pTargetBox->SetFocus();
		if (pApp->m_nStartChar != pApp->m_nEndChar)
		{
			pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar, pApp->m_nEndChar); 
		}

		// scroll into view, just in case a lot were inserted
		pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

		Invalidate();
		GetLayout()->PlaceBox();
	}
	gbInsertingWithinFootnote = FALSE; // make sure it is off (default) before exiting
}

void CAdapt_ItView::OnButtonRemoveNullSrcPhrase(wxCommandEvent& WXUNUSED(event))
{
    // Since the Remove Placeholder toolbar button has an accelerator table hot key (CTRL-D
    // see CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even
    // when they are disabled, we must check for a disabled button and return if disabled.
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_REMOVE_NULL_SRCPHRASE))
	{
		::wxBell();
		return;
	}

	// If glossing is ON we don't allow removal (nor insertion) of null source phrases,
	// so warn the user and return.
	if (gbIsGlossing)
	{
		//IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),
		_T(""),wxICON_INFORMATION);
		return;
	}

    // find the pile containing the null src phrase to be deleted - it will either be the
    // first selected pile, if there is a selection current, or the active location if no
    // selection is current; the button removes only one at a time.
	CPile* pRemoveLocPile;
	int nCount = 1;
	if (pApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's first element
		CCellList* pCellList = &pApp->m_selection;
		CCellList::Node* cpos = pCellList->GetFirst();
		CCell* pCell;
		pCell = cpos->GetData();
		pRemoveLocPile = cpos->GetData()->GetPile();
		wxASSERT(pRemoveLocPile != NULL);
		if (pRemoveLocPile->GetSrcPhrase()->m_bNullSourcePhrase != TRUE)
		{
			::wxBell();
			RemoveSelection();
			return;
		}
		if (pRemoveLocPile->GetSrcPhrase()->m_bRetranslation == TRUE)
		{
			::wxBell(); 
			RemoveSelection();
			return;
		}
		RemoveSelection(); // Invalidate() will be called in RemoveNullSourcePhrase()
	}
	else
	{
		// no selection, so just remove at wherever the phraseBox currently is located
		pRemoveLocPile = pApp->m_pActivePile;
		wxASSERT(pRemoveLocPile != NULL);
		if (pRemoveLocPile->GetSrcPhrase()->m_bNullSourcePhrase == FALSE ||
			pRemoveLocPile->GetSrcPhrase()->m_bRetranslation == TRUE)
		{
			::wxBell();
			return;
		}
	}
    // remove the placeholder - note, this will clobber the m_pActivePile pointer, and a
    // new partner pile will not be created, so we have to provide a temporary valid
    // m_pActivePile after this next call returns, so that our RecalcLayout() code which
    // needs to find the active strip will find a pile in a strip at or about the right
    // place in the document (so the layout gets set up right) -- what we need to ensure is
    // that any access to CPile::m_pOwningStrip using the GetStrip() call, will not have an
    // m_pOwningStrip value set to NULL (or to a non-NULL value in the debugger which then
    // points at arbitrary memory)
	RemoveNullSourcePhrase(pRemoveLocPile, nCount);

    // we don't do the next block at a deeper level because removing a retranslation which
    // is long uses lower level functions to do automated placeholder removals, and we
    // don't want them counted a second time; so we do it here only, in the handler for a
    // user's manual click of the command bar button to remove a placeholder
	if (gbVerticalEditInProgress)
	{
		// update the relevant parts of the adaptationsStep parameters in gEditRecord
			gEditRecord.nAdaptationStep_ExtrasFromUserEdits -= 1;
			gEditRecord.nAdaptationStep_NewSpanCount -= 1;
			gEditRecord.nAdaptationStep_EndingSequNum -= 1;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Remove A Placeholder"
/// toolbar item and returns immediately: The application is in glossing mode, the target
/// text only is showing in the main window, the m_pActivePile pointer is NULL, or the
/// application is in Free Translation mode. It enables the toolbar button if there is a
/// selection which is on a null source phrase which is not a retranslation, or if the
/// active pile is a null source phrase which is not a retranslation. The selection, if
/// there is one, takes priority, if its pile is different from the active pile..
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRemoveNullSrcPhrase(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	bool bCanDelete = FALSE;
	if (pApp->m_pTargetBox->GetHandle() != NULL)
	{
        // set the flag true either if there is a selection and which is on a null source
        // phrase which is not a retranslation, or if the active pile is a null source
        // phrase which is not a retranslation. The selection, if there is one, takes
        // priority, if its pile is different from the active pile.
		if (pApp->m_selectionLine != -1)
		{
			CCellList::Node* cpos = pApp->m_selection.GetFirst();
			CCell* pCell = cpos->GetData();
			if (pCell->GetPile()->GetSrcPhrase()->m_bNullSourcePhrase
				&& !pCell->GetPile()->GetSrcPhrase()->m_bRetranslation)
			{
				bCanDelete = TRUE;
			}
		}
		else
		{
			 wxWindow *focus = wxWindow::FindFocus();
			if (pApp->m_pTargetBox == focus) // don't use GetHandle() on m_pTargetBox here !!!
			{
				if (pApp->m_pTargetBox->IsShown()
						&& pApp->m_pActivePile->GetSrcPhrase()->m_bNullSourcePhrase
						&& !pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
					bCanDelete = TRUE;
			}
		}
	}
	event.Enable(bCanDelete);
}

void CAdapt_ItView::RemoveNullSourcePhrase(CPile* pRemoveLocPile,const int nCount)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CPile* pPile			= pRemoveLocPile;
	int nStartingSequNum	= pPile->GetSrcPhrase()->m_nSequNumber;
	SPList* pList			= pApp->m_pSourcePhrases;
	SPList::Node* removePos = pList->Item(nStartingSequNum); // the position at
													// which we will do the removal
	SPList::Node* savePos = removePos; // we will alter removePos & need to restore it
	wxASSERT(removePos != NULL);
	int nActiveSequNum = pApp->m_nActiveSequNum; // save, so we can restore later on, 
					// since the call to RecalcLayout will clobber some pointers

    // we may be removing the m_pActivePile, so get parameters useful for setting up a
    // temporary active pile for the RecalcLayout() call below
	int nRemovedPileIndex = pRemoveLocPile->GetSrcPhrase()->m_nSequNumber;

    // get the preceding source phrase, if it exists, whether null or not - we may have to
    // transfer punctuation to it
	CSourcePhrase* pPrevSrcPhrase = NULL;
	if (nStartingSequNum > 0)
	{
		// there is a preceding one, so get it
		CPile* pPile = GetPrevPile(pRemoveLocPile);
		wxASSERT(pPile != NULL);
		pPrevSrcPhrase = pPile->GetSrcPhrase();
		wxASSERT(pPrevSrcPhrase != NULL);
	}

	// ensure that there are nCount null source phrases which can be removed from this location
	int count = 0;
	CSourcePhrase* pFirstOne = NULL; // whm initialized to NULL
	CSourcePhrase* pLastOne = NULL; // whm initialized to NULL
	while( removePos != 0 && count < nCount)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)removePos->GetData();
		removePos = removePos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		if (count == 0)
			pFirstOne = pSrcPhrase;
		pLastOne = pSrcPhrase;
		count++;
		if (!pSrcPhrase->m_bNullSourcePhrase)
		{
			//IDS_TOO_MANY_NULL_SRCPHRASES
			wxMessageBox(_T(
"Warning: you are trying to remove more empty source phrases than exist at that location: the command will be ignored."),
			_T(""),wxICON_EXCLAMATION);
			if (pApp->m_selectionLine != -1)
				RemoveSelection();
			Invalidate();
			GetLayout()->PlaceBox();
			return;
		}
	}

    // a null source phrase can (as of version 1.3.0) be last in the list, so we can no
    // longer assume there will be a non-null one following, if we are at the end we must
    // restore the active location to an earlier sourcephrase, otherwise, to a following
    // one
	bool bNoneFollows = FALSE;
	CSourcePhrase* pSrcPhraseFollowing = 0;
	if (nStartingSequNum + nCount > pApp->GetMaxIndex())
	{
		// we are at the very end, or wanting to remove more at the end than is possible
		bNoneFollows = TRUE; // flag this condition
	}

	if (bNoneFollows)
		pSrcPhraseFollowing = 0;
	else
	{
		pSrcPhraseFollowing = (CSourcePhrase*)removePos->GetData();
		removePos = removePos->GetNext();
		wxASSERT(pSrcPhraseFollowing != NULL);
	}

	wxASSERT(pFirstOne != NULL); // whm added; note: if pFirstOne can ever be NULL there
								 // should be more code added here to deal with it
    // if the null source phrase(s) carry any punctuation or markers, then these have to be
    // first transferred to the appropriate normal source phrase in the context, whether
    // forwards or backwards, depending on what is stored.
	if (!pFirstOne->m_markers.IsEmpty() && !bNoneFollows)
	{
        // BEW comment 25Jul05, if a TextType == none endmarker was initial in m_markers,
        // it will have been moved to the placeholder; so the next line handles other
        // situations as well as moving an endmarker back on to the following sourcephrase
        // which formerly owned it
		pSrcPhraseFollowing->m_markers = pFirstOne->m_markers; // don't clear original

		// now all the other things which depend on markers
		pSrcPhraseFollowing->m_inform = pFirstOne->m_inform;
		pSrcPhraseFollowing->m_chapterVerse = pFirstOne->m_chapterVerse;
		pSrcPhraseFollowing->m_bVerse = pFirstOne->m_bVerse;
		pSrcPhraseFollowing->m_bParagraph = pFirstOne->m_bParagraph;
		pSrcPhraseFollowing->m_bChapter = pFirstOne->m_bChapter;
		pSrcPhraseFollowing->m_bSpecialText = pFirstOne->m_bSpecialText;
		pSrcPhraseFollowing->m_bFootnote = pFirstOne->m_bFootnote;
		pSrcPhraseFollowing->m_bFirstOfType = pFirstOne->m_bFirstOfType;
		pSrcPhraseFollowing->m_curTextType = pFirstOne->m_curTextType;

		// BEW 05Jan06 if there was a moved note we must ensure that the following
		// sourcephrase gets the note flag set (it might already be TRUE anyway)
		pSrcPhraseFollowing->m_bHasNote = pFirstOne->m_bHasNote;
	}
	// block ammended by BEW 25Jul05
	if (!pFirstOne->m_precPunct.IsEmpty() && !bNoneFollows)
	{
		pSrcPhraseFollowing->m_precPunct = pFirstOne->m_precPunct;

		// fix the m_targetStr member (we are just fixing punctuation, so no store needed)
		MakeLineFourString(pSrcPhraseFollowing,pSrcPhraseFollowing->m_targetStr);

		// anything else
		pSrcPhraseFollowing->m_bFirstOfType = pFirstOne->m_bFirstOfType;
	}
	// BEW added 25Jul05
    // a m_bHasFreeTrans = TRUE value can be ignored provided m_bStartFreeTrans value is
    // FALSE, if the latter is TRUE, then we must move the value to the following
    // sourcephrase
	if (pFirstOne->m_bStartFreeTrans && !bNoneFollows)
	{
		pSrcPhraseFollowing->m_bStartFreeTrans = TRUE;
		pSrcPhraseFollowing->m_bHasFreeTrans = TRUE;
	}
	wxASSERT(pLastOne != NULL); // whm added; note: if pLastOne can ever be NULL there
								// should be more code added here to deal with it
	if (!pLastOne->m_follPunct.IsEmpty() && nStartingSequNum > 0)
	{
		pPrevSrcPhrase->m_follPunct = pLastOne->m_follPunct;

		// now the other stuff
		pPrevSrcPhrase->m_bFootnoteEnd = pLastOne->m_bFootnoteEnd;
		pPrevSrcPhrase->m_bBoundary = pLastOne->m_bBoundary;

		// fix the m_targetStr member (we are just fixing punctuation, so no store needed)
		MakeLineFourString(pPrevSrcPhrase,pPrevSrcPhrase->m_targetStr);
	}
	// BEW added 25Jul05...
    // a m_bHasFreeTrans = TRUE value can be ignored provided m_bEndFreeTrans value is
    // FALSE, if the latter is TRUE, then we must move the value to the preceding
    // sourcephrase
	if (pLastOne->m_bEndFreeTrans && nStartingSequNum > 0)
	{
		pPrevSrcPhrase->m_bEndFreeTrans = TRUE;
		pPrevSrcPhrase->m_bHasFreeTrans = TRUE;
	}

	// remove the null source phrases from the list, after removing their 
	// translations from the KB
	CRefString* pRefString = NULL;
	removePos = savePos;
	count = 0;
	while (removePos != NULL && count < nCount)
	{
		SPList::Node* pos2 = removePos; // save current position for RemoveAt call
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)removePos->GetData();

		// BEW added 13Mar09 for refactored layout
		GetDocument()->DeletePartnerPile(pSrcPhrase);
		removePos = removePos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
									pSrcPhrase->m_key,pSrcPhrase->m_adaption);
		count++;
		if (pRefString != NULL)
			// don't need to worry about m_bHasKBEntry flag, since pSrcPhrase
			// will be deleted next
			RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);
		delete pSrcPhrase;
		pList->DeleteNode(pos2); 
	}

    // calculate the new active sequ number - it could be anywhere, but all we need to know
    // is whether or not the last removal of the sequence was done preceding the former
    // active sequ number's location
	if (nStartingSequNum + nCount < nActiveSequNum)
		pApp->m_nActiveSequNum = nActiveSequNum - nCount;
	else
	{
		if (bNoneFollows)
			pApp->m_nActiveSequNum = nStartingSequNum - 1;
		else
			pApp->m_nActiveSequNum = nStartingSequNum;
	}

    // update the sequence numbers, starting from the location of the first one removed;
    // but if we removed at the end, no update is needed
	if (!bNoneFollows)
		UpdateSequNumbers(nStartingSequNum);

	// for getting over the hump of the call below to RecalcLayout() we only need a temporary
	// reasonably accurate active pile pointer set, and only if the removal was done at the
	// active location - if it wasn't, then RecalcLayout() will set things up correctly
	// without a failure
	if (nRemovedPileIndex == nActiveSequNum)
	{
		// set a temporary one, we'll use the pile which is now at nRemovedPileIndex
		// location, which typically is the one immediately following the placeholder's
		// old location; but if deleted from the doc's end, we'll use the last valid
		// document location
		int nMaxDocIndex = pApp->GetMaxIndex();
		if (nRemovedPileIndex > nMaxDocIndex)
			pApp->m_pActivePile = GetPile(nMaxDocIndex);
		else
			pApp->m_pActivePile = GetPile(nRemovedPileIndex);
	}
	
    // in case the active location is going to be a retranslation, check and if so, advance
    // past it; but if at the end, then back up to a valid preceding location
	CSourcePhrase* pSP = GetSrcPhrase(pApp->m_nActiveSequNum);
	CPile* pNewPile;
	if (pSP->m_bRetranslation)
	{
		CPile* pPile = GetPile(pApp->m_nActiveSequNum);
		do {
				pNewPile = GetNextPile(pPile);
				if (pNewPile == NULL)
				{
					// move backwards instead, and find a suitable location
					pPile = GetPile(pApp->m_nActiveSequNum);
					do {
						pNewPile = GetPrevPile(pPile);
						pPile = pNewPile;
					} while (pNewPile->GetSrcPhrase()->m_bRetranslation);
					goto b;
				}
				pPile = pNewPile;
		} while (pNewPile->GetSrcPhrase()->m_bRetranslation);
b:		pApp->m_pActivePile = pNewPile;
		pApp->m_nActiveSequNum = pNewPile->GetSrcPhrase()->m_nSequNumber;
	}

    // we need to set m_targetPhrase to what it will be at the new active location, else if
    // the old string was real long, the CalcPileWidth() call will compute enormous and
    // wrong box width at the new location
	pSP = GetSrcPhrase(pApp->m_nActiveSequNum);
	if (!pApp->m_bHidePunctuation) // BEW 8Aug09, removed deprecated m_bSuppressLast from test
		pApp->m_targetPhrase = pSP->m_targetStr;
	else
		pApp->m_targetPhrase = pSP->m_adaption;

	// recalculate the layout
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif

	// get a new (valid) active pile pointer, now that the layout is recalculated
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	wxASSERT(pApp->m_pActivePile);

	// create the phraseBox at the active pile, do it using PlacePhraseBox()...
	CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
	wxASSERT(pSrcPhrase != NULL);

    // renumber its sequ number, as its now in a new location because of the deletion (else
    // the PlacePhraseBox call below will get the wrong number when it reads its
    // m_nSequNumber attribute)
	pSrcPhrase->m_nSequNumber = pApp->m_nActiveSequNum;
	UpdateSequNumbers(pApp->m_nActiveSequNum);

	// set m_targetPhrase to the appropriate string
	if (!pSrcPhrase->m_adaption.IsEmpty())
	{
		if (!pApp->m_bHidePunctuation) // BEW 8Aug09, removed deprecated m_bSuppressLast from test
			pApp->m_targetPhrase = pSrcPhrase->m_targetStr;
		else
			pApp->m_targetPhrase = pSrcPhrase->m_adaption;
	}
	else
	{
		pApp->m_targetPhrase.Empty(); // empty string will have to do
	}

    // we must remove the source phrase's translation from the KB as if we
    // had clicked here (otherwise PlacePhraseBox will assert)
	pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
									pSrcPhrase->m_key,pSrcPhrase->m_adaption);

    // it is okay to do the following call with pRefString == NULL, in fact, it must be
    // done whether NULL or not; since if it is NULL, RemoveRefString will clear
    // pSrcPhrase's m_bHasKBEntry to FALSE, which if not done, would result in a crash if
    // the user clicked on a source phrase which had its reference string manually removed
    // from the KB and then clicked on another source phrase. (The StoreAdaption call in
    // the second click would trip the first line's ASSERT.)
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

    // save old sequ number in case required for toolbar's Back button - but since it
    // probably has been lost (being the null source phrase location), to be safe we must
    // set it to the current active location
	gnOldSequNum = pApp->m_nActiveSequNum;

	// scroll into view, just in case a lot were inserted
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);
	Invalidate();
	// now place the box
	GetLayout()->PlaceBox();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Do A Retranslation"
/// toolbar item and returns immediately: The application is in glossing mode, the target
/// text only is showing in the main window, the m_pActivePile pointer is NULL, or if there
/// is a selection in which at least one source phrase already is part of a retranslation.
/// Otherwise, it enables the toolbar button if there is a selection whose source phrases
/// are not part of an existing retranslation.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRetranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
        // if there is at least one srcPhrase with m_bRetranslation == TRUE, then disable
        // the button
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData();
			CPile* pPile = pCell->GetPile();
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
			if (pSrcPhrase->m_bRetranslation)
			{
				event.Enable(FALSE);
				return;
			}
		}
		event.Enable(TRUE);
		return;
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::SetNotInKBFlag(SPList* pList,bool bValue)
{
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	while (pos != 0)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		pSrcPhrase->m_bNotInKB = bValue;
	}
}

void CAdapt_ItView::SetRetranslationFlag(SPList* pList,bool bValue)
{
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	while (pos != 0)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		pSrcPhrase->m_bRetranslation = bValue;
	}
}

// gets the preceding & following contexts for a 'retranslation' section of source text.
// We cannot rely on the layout pointers being valid, because if there was an unmerge done,
// they will have been clobbered prior to GetContext being called rather than use GetPile().
// We accumulate 40 words of preceding context and 30 words of following context, and we
// omit any m_markers content from the accumulations - we are just interested in the text.
void CAdapt_ItView::GetContext(const int nStartSequNum,const int nEndSequNum,wxString& strPre,
							   wxString& strFoll,wxString& strPreTgt, wxString& strFollTgt)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// get the preceding context first
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	SPList::Node* pos = pSrcPhrases->Item(nStartSequNum);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetPrevious();
	TextType textType = pSrcPhrase->m_curTextType;
	wxString str; // temporary buffers
	str.Empty();
	wxString strTgt;
	strTgt.Empty();

	int count = 0;
	while (count < NUM_PREWORDS && pos != NULL)
	{
		TextType type;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetPrevious();
		count++;
		type = pSrcPhrase->m_curTextType;
		if (type != textType)
			break;
		str = pSrcPhrase->m_srcPhrase;
		strTgt = pSrcPhrase->m_targetStr;
		strPre = str + _T(" ") + strPre;
		strPreTgt = strTgt + _T(" ") + strPreTgt;
	}

	// now get the following context
	pos = pSrcPhrases->Item(nEndSequNum);
	pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext();
	count = 0;
	str.Empty();
	strTgt.Empty();

	while (count < NUM_FOLLWORDS && pos != NULL)
	{
		TextType type;
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		count++;
		type = pSrcPhrase->m_curTextType;
		if (type != textType)
			break;
		str = pSrcPhrase->m_srcPhrase;
		strTgt = pSrcPhrase->m_targetStr;
		if (strFoll.IsEmpty())
		{
			strFoll = str;
			strFollTgt = strTgt;
		}
		else
		{
			strFoll += _T(" ") + str;
			strFollTgt += _T(" ") + strTgt;
		}
	}
}

bool CAdapt_ItView::IsConstantType(SPList* pList)
{
	SPList::Node* pos = pList->GetFirst(); 
	if (pos == NULL)
	{
		wxMessageBox(_T(
		"Error accessing sublist in IsConstantType function\n"),
		_T(""), wxICON_EXCLAMATION);
		wxASSERT(FALSE);
		return FALSE;
	}
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext();
	TextType firstType = pSrcPhrase->m_curTextType;
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		TextType type = pSrcPhrase->m_curTextType;
		if (type != firstType)
			return FALSE;
	}

    // if we get here, it's all one type; so if that type is also the footnote textType
    // then set the gbInsertingWithinFootnote flag (we want to propragate a footnote type
    // into any padding with null source phrases, in case the user wants to get interlinear
    // RTF output with footnote text suppressed)
	if (pSrcPhrase->m_curTextType == footnote)
		gbInsertingWithinFootnote = TRUE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Remove A
/// Retranslation" toolbar item and returns immediately: The application is in glossing
/// mode, the target text only is showing in the main window, the m_pActivePile pointer is
/// NULL, or if the head or tail of the selection do not lie within the retranslation.
/// Otherwise, it enables the toolbar button if there is a selection whose head and tail
/// are part of an existing retranslation.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateRemoveRetranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
		// we require both head and tail of the selection to lie within the retranslation
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = (CCell*)cpos->GetData();
		if (pCell != NULL)
		{
			CPile* pPile = pCell->GetPile();
			CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
			if (!pSrcPhrase->m_bRetranslation)
			{
				event.Enable(FALSE);
				return;
			}
			cpos = pApp->m_selection.GetLast();
			pCell = (CCell*)cpos->GetData();
			if (pCell != NULL)
			{
				pPile = pCell->GetPile();
				pSrcPhrase = pPile->GetSrcPhrase();
				if (!pSrcPhrase->m_bRetranslation)
				{
					event.Enable(FALSE);
					return;
				}
				else
				{
					event.Enable(TRUE);
					return;
				}
			}
			else
			{
				event.Enable(FALSE);
				return;
			}
		}
		else
		{
			event.Enable(FALSE);
			return;
		}
	}
	else
	{
        // I'll leave the following block here, but it will never be entered because I
        // changed the behaviour to prohibit the phrase box from being placed within a
        // retranslation
		if (pApp->m_pTargetBox != NULL)
		{
			if (pApp->m_pTargetBox->IsShown())
			{
				CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
				if (pSrcPhrase->m_bRetranslation)
				{
					event.Enable(TRUE);
					return;
				}
			}
		}
	}
	event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Edit A Retranslation"
/// toolbar item and returns immediately: The application is in glossing mode, the target
/// text only is showing in the main window, the m_pActivePile pointer is NULL, or if the
/// head or tail of the selection do not lie within the retranslation. Otherwise, it
/// enables the toolbar button if there is a selection whose head and tail are part of an
/// existing retranslation.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonEditRetranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (!gbIsGlossing && pApp->m_selectionLine != -1)
	{
		// we require both head and tail of the selection to lie within the retranslation
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = (CCell*)cpos->GetData();
		if (pCell != NULL)
		{
			CPile* pPile = pCell->GetPile();
			CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
			if (!pSrcPhrase->m_bRetranslation)
			{
				event.Enable(FALSE);
				return;
			}
			cpos = pApp->m_selection.GetLast();
			pCell = (CCell*)cpos->GetData();
			if (pCell != NULL)
			{
				pPile = pCell->GetPile();
				pSrcPhrase = pPile->GetSrcPhrase();
				if (!pSrcPhrase->m_bRetranslation)
				{
					event.Enable(FALSE);
					return;
				}
				else
				{
					event.Enable(TRUE);
					return;
				}
			}
			else
			{
				event.Enable(FALSE);
				return;
			}
		}
		else
		{
			event.Enable(FALSE);
			return;
		}
	}
	else
	{
		// I'll leave the following block here, but it will never be entered because
		// I changed the behaviour to prohibit the phrase box from being placed within
		// a retranslation
		if (pApp->m_pTargetBox != NULL)
		{
			if (pApp->m_pTargetBox->IsShown())
			{
				CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
				if (pSrcPhrase->m_bRetranslation)
				{
					event.Enable(TRUE);
					return;
				}
			}
		}
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::DoRetranslation()
{
	wxCommandEvent dummyevent;
	// IDS_TOO_MANY_SRC_WORDS
	wxMessageBox(_(
"Warning: there are too many source language words in this phrase for this adaptation to be stored in the knowledge base."),
	_T(""), wxICON_INFORMATION);

	OnButtonRetranslation(dummyevent);
}

void CAdapt_ItView::DoRetranslationByUpArrow()
{
	wxCommandEvent dummyevent;
	OnButtonRetranslation(dummyevent);
}


int CAdapt_ItView::GetSelectionWordCount()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_selectionLine == -1)
		return 0; // no selection
	int nCount = 0;
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		CCell* pCell = (CCell*)pos->GetData();
		nCount += pCell->GetPile()->GetSrcPhrase()->m_nSrcWords;
		pos = pos->GetNext();
	}
	return nCount;
}

// looks up the knowledge base to find if there is an entry in the map with index
// nSrcWords-1, for the key keyStr and then searches the list in the CTargetUnit for the
// CRefString with m_translation member identical to adaptation, and returns a pointer to
// that CRefString instance. If it fails, it returns a null pointer. 
// (Note: Jan 27 2001 changed so that returns the pRefString for a <Not In KB> entry). For
// version 2.0 and later, pKB will point to the glossing KB when gbIsGlossing is TRUE.
// Ammended, July 2003, to support auto capitalization
CRefString* CAdapt_ItView::GetRefString(CKB *pKB, int nSrcWords, wxString keyStr,
											wxString adaptation)
{
	MapKeyStringToTgtUnit* pMap = pKB->m_pMap[nSrcWords-1];
	wxASSERT(pMap != NULL);
	CTargetUnit* pTgtUnit;	// wx version changed 2nd param of AutoCapsLookup() below to
							// directly use CTargetUnit* pTgtUnit
	CRefString* pRefStr;
	bool bOK = AutoCapsLookup(pMap,pTgtUnit,keyStr);
	if (bOK)
	{
		return pRefStr = AutoCapsFindRefString(pTgtUnit,adaptation);
	}
	// lookup failed, so the KB state is different than data in the document suggests,
	// a Consistency Check operation should be done on the file(s)
	return (CRefString*)NULL;
}

// looks up the knowledge base to find if there is an entry in the map with index
// nSrcWords-1, for the key keyStr and returns the CTargetUnit pointer it finds. If it
// fails, it returns a null pointer.
// version 2.0 and onwards supports glossing, so pKB could point to the glossing KB or the
// adapting one, as set by the caller; and for glossing it is the caller's responsibility
// to ensure that nSrcWords has the value 1 only.
CTargetUnit* CAdapt_ItView::GetTargetUnit(CKB *pKB, int nSrcWords, wxString keyStr)
{
	MapKeyStringToTgtUnit* pMap = pKB->m_pMap[nSrcWords-1];
	wxASSERT(pMap != NULL);
	CTargetUnit* pTgtUnit;
	bool bOK = AutoCapsLookup(pMap, pTgtUnit, keyStr);
	if (bOK)
	{
		wxASSERT(pTgtUnit);
		return pTgtUnit; // we found it
	}
    // lookup failed, so the KB state is different than data in the document suggests, a
    // Verify operation should be done on the file(s)
	return (CTargetUnit*)NULL;
}

CKB* CAdapt_ItView::GetKB()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

	if (gbIsGlossing)
		return pApp->m_pGlossingKB;
	else
		return pApp->m_pKB;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing a copy of the m_key member (which has punctuation 
///             stripped off) of pSrcPhrase after m_key has been modified by Consistent Changes
///             (if m_bUseConsistentChanges is TRUE) or by SIL Converters (if m_bUseSilConverter
///             if TRUE)
/// \param      pSrcPhrase              -> the source phrase from which the m_key is copied
/// \param      bUseConsistentChanges   -> flag indicating if Consistent Changes is required
/// \remarks
/// Called from: The CopySourceKey() function is called from the View's PlacePhraseBox(),
/// OnButtonToEnd(), OnButtonToStart(), OnButtonStepDown(), OnButtonStepUp(),
/// OnButtonMerge(), OnButtonRestore(), RestoreTargetBoxText(),
/// JumpForwardToNote_CoreCode(), and JumpBackwardToNote_CoreCode(); and CSourcePhrase's
/// MoveToNextPile(), MoveToPrevPile() and MoveToImmedNextPile().
/// CopySourceKey() is generally only called when the m_bCopySource flag is TRUE and when
/// the m_targetPhrase is empty, because there is no matching translation available from
/// the KB or no previous target phrase has been entered. CopySourceKey() returns the
/// source word or phrase (possibly merged) in a pre-processed form which constitutes a
/// first guess for what might be wanted as a target text in the phrase box. This guess
/// starts as the m_key member of the CSourcePhrase object (which is the form without any
/// punctuation). CopySourceKey() applies any necessary modifications as the result of
/// Consistent Changes (if m_bUseConsistentChanges is TRUE) or any modifications made by
/// SIL Converters (if m_bUseSilConverter if TRUE) before returning the final string to the
/// caller. Thus, CopySourceKey() is the primary place where Consistent Changes and SIL
/// Converter changes is done within the Adapt It application.
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::CopySourceKey(CSourcePhrase *pSrcPhrase, bool bUseConsistentChanges)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxString str = pSrcPhrase->m_key;
	if (str.IsEmpty())
		return _T("");

	if (!gbLegacySourceTextCopy)
	{
		// the user wants smart copying done to the phrase box when the active location
		// landed on does not have any existing adaptation (in adapting mode), or, gloss
		// (in glossing mode). In the former case, it tries to copy a gloss to the box
		// if a gloss is available, otherwise source text used instead; in the latter case
		// it tries to copy an adaptation as the default gloss, if an adaptation is
		// available, otherwise source text is used instead
		if (gbIsGlossing)
		{
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				str = pSrcPhrase->m_adaption;
			}
		}
		else
		{
			if (!pSrcPhrase->m_gloss.IsEmpty())
			{
				str = pSrcPhrase->m_gloss;
			}
		}
	}

	gbByCopyOnly = TRUE;
	if (bUseConsistentChanges)
	{
		// these added spaces are automatically stripped before storage takes place, after cc
		// has had its chance to apply, so no harm is done by these additions
		str = _T(" ") + str;
		str += _T(" ");

		// apply to the merged string (ie. merged with whatever is returned here)
		wxString str2 = DoConsistentChanges(str);

		// strip the added spaces back off
		// whm comment: the following GetChar() operations assume that str2 can never be an 
		// empty string when it returns from DoConsistentChanges; for safety sake, I'm just
		// going to use the Trim() function instead.
		//if (str2.GetChar(0) == _T(' '))
		//	str2 = str2.Mid(1); // remove initial space
		//int len = str2.Length();
		//if (str2.GetChar(len-1) == _T(' '))
		//	str2 = str2.Left(len-1); // remove final space
		str2.Trim(FALSE); // trim the left end
		str2.Trim(TRUE); // trim the right end

		return str2;
	}
	else if( pApp->m_bUseSilConverter )
	{
		return DoSilConvert(str);
	}
	else
		return str;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing text after any Consistent Changes have been performed
///             on the text
/// \param      str    -> the incoming string on which Consistent Changes is to be performed
/// \remarks
/// Called from: the View's CopySourceKey() and DoTargetBoxPaste().
/// If str is not empty, DoConsistentChanges passes str through up to four successive Consistent
/// Changes processes, once for each of up to four loaded changes tables. DoConsistentChanges()
/// handles the initialization of an input and an output buffer for processing of changes by
/// calling of up to four m_consistentChager instances on the buffers, employing the 
/// utf8ProcessBuffer() method of CConsistentChanger. See the CConsistentChanger and CCModule 
/// classes.
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::DoConsistentChanges(wxString& str)
{
	if (str.IsEmpty())
		return _T("");

	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);

#ifndef _UNICODE
	// new ANSI version, uses buffers, and based on the _UNICODE code...
	// for the ANSI version, str will be a byte-oriented wxString. No conversions needed.
	// the strings stored in the buffers will be null delimited
	int nIn = 0;  // index for current input buffer
	int nOut = 1; // index for current output buffer
	char byteBuff[2][1024]; // two 1k byte buffers which will alternate as input and output iteratively
	int nInLength = 0;
	int nOutLength = 1024;
	int nTableIndex = -1;

	nInLength = str.Length(); // in bytes
	nInLength += 1; // allow for the null byte at the end (note: for 2.2.1 and previous
					// I did not realize that CC will strip off this final null byte
					// reducing the length by one, so I got final character chopped off
					// the changed string - I fixed this for 2.3.0 (the next after 2.2.1)
	const wxChar* pbuffer = str.GetData();

	// whm added pEnd and null char below
	wxChar* pEnd;
	pEnd = (wxChar*)pbuffer + nInLength -1; // -1 to compensate for += 1 increment on nInLength above
	wxASSERT(*pEnd == _T('\0')); // insure there's a null at end of buffer

	// populate the first of the buffers
	wxStrcpy(byteBuff[nIn],pbuffer);

	// apply the tables
	int iResult = 0;
	bool bPreviouslyUsedTable = FALSE; // TRUE after a table has been used
	for (int i = 0; i < 4; i++)
	{
		nTableIndex++; // keep track of which table, in case we get an error

		// do the next table, if present
		if (pApp->m_bCCTableLoaded[i])
		{
			if (bPreviouslyUsedTable)
			{
				// prepare for this next table
				nIn = nIn == 0 ? 1 : 0;
				nOut = nOut == 0 ? 1 : 0;
				nInLength = nOutLength;
				nOutLength = 1024;
				memset(byteBuff[nOut],0,1024); // clear the string in the new output buffer
											   // (CC does not retain the null bytes, but
											   // fills the unused part with -52 bytes,
											   // and input '\0' is lost)
			}
			bPreviouslyUsedTable = TRUE;

			iResult = pApp->m_pConsistentChanger[i]->utf8ProcessBuffer(byteBuff[nIn],nInLength,
																byteBuff[nOut],&nOutLength);

			// if there was an error, just return the unaltered original string & warn user
			if (iResult)
			{
				ccErrorStr = ccErrorStr.Format(
				_(" Processing a CC table failed. Got error code %d with table having index %d."),
									iResult,nTableIndex);
				wxMessageBox(ccErrorStr, _T(""), wxICON_EXCLAMATION);
				return str; // if there was a table procesing error then return the
							// original string, ie. no tables used
			}
			else
			{
				// no errors
				if (i == 3)
					break; // at the end, so go convert the output string back to UTF-16
			}
		}
		else
		{
			// that table was not loaded, so try the next one
			continue;
		}
	}

	byteBuff[nOut][nOutLength] = '\0';    // ensure it is null terminated at the correct
										  // location (it will overwrite the first (byte)-52)
	// wx version note: here we need a writable buffer
	wxChar* pStr = str.GetWriteBuf(nOutLength + 1);  // nOutLength is 1024
	wxStrcpy(pStr,byteBuff[nOut]);            // but I ran into some problems, so I've done it the safety first way
	//wxChar* pEnd;
	pEnd = pStr + nOutLength; // whm added 18Jun06
	wxASSERT(*pEnd == _T('\0')); // whm added 18Jun06
	str.UngetWriteBuf(); 
	return str;

#else // Unicode version

	// for the unicode version, str will be a UTF-16 wxString. We have to convert to UTF8, run the
	// resulting string through the CCProcessBuffer() function with a minimum of string copying
	// to maximize speed, and then convert back to UTF-16 and return it to the caller as an LPTSTR;
	// the strings stored in the buffers will be null delimited

	// BEW changed 8Apr06 to accomodate the buffer-safe new conversion macros in VS 2003, which
	// use malloc for buffer allocation of long string to be converted, etc.

	int nIn = 0;  // index for current input buffer
	int nOut = 1; // index for current output buffer
	char byteBuff[2][1024]; // two 1k byte buffers which will alternate as input and output iteratively
	int nInLength = 0;
	int nOutLength = 1024;
	int nTableIndex = -1;
	
	// wx version note:
	// The wxString::mb_str() method returns a wxCharBuffer. The wxConvUTF8 is a predefined
	// instance of the wxMBConvUTF8 class which converts between Unicode (UTF-16) and UTF-8.
	wxCharBuffer tempBuf = str.mb_str(wxConvUTF8);
	CBString psz(tempBuf);

	nInLength = strlen(psz) + 1; // + 1 for the null byte at the end
	strcpy(byteBuff[nIn],psz);

	// apply the tables
	int iResult = 0;
	bool bPreviouslyUsedTable = FALSE; // TRUE after a table has been used
	for (int i = 0; i < 4; i++)
	{
		nTableIndex++; // keep track of which table, in case we get an error

		// do the next table, if present
		if (pApp->m_bCCTableLoaded[i])
		{
			if (bPreviouslyUsedTable)
			{
				// prepare for this next table
				nIn = nIn == 0 ? 1 : 0;
				nOut = nOut == 0 ? 1 : 0;
				nInLength = nOutLength;
				nOutLength = 1024;
				memset(byteBuff[nOut],0,1024); // clear the string in the new output buffer

			}
			bPreviouslyUsedTable = TRUE;

			// whm note: the following line is where consistent changes does its work
			iResult = pApp->m_pConsistentChanger[i]->utf8ProcessBuffer(byteBuff[nIn],nInLength,
															byteBuff[nOut],&nOutLength);

			// if there was an error, just return the unaltered original string & warn user
			if (iResult)
			{
				ccErrorStr.Format(
				_(" Processing a CC table failed. Got error code %d with table having index %d."),
				iResult,nTableIndex);
				wxMessageBox(ccErrorStr, _T(""), wxICON_EXCLAMATION);
				return str; // if there was a table procesing error then return the original
							// string, ie. no tables used
			}
			else
			{
				// no errors
				if (i == 3)
					break; // at the end, so go convert the output string back to UTF-16
			}
		}
		else
		{
			// that table was not loaded, so try the next one
			continue;
		}
	}

	// convert back to UTF-16 and return the converted string
	byteBuff[nOut][nOutLength] = '\0';	// ensure it is null terminated at the correct
										// location	
	CBString tempBuff(byteBuff[nOut]);
	return pApp->Convert8to16(tempBuff);

#endif // for _UNICODE
}

void CAdapt_ItView::ChooseTranslation()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	if (pApp->m_pTargetBox == NULL || !pApp->m_pTargetBox->IsShown())
	{
		// whm Note: the m_pTargetBox is never NULL in the wx version, but
		// sometimes it is not shown, so if we are getting a bell sound at
		// wrong times, this may be the cause.
		// TODO: check the logic during Find operations and any other cases
		// where the MFC version assumes that the target box might be NULL
		::wxBell();
	}
	else
	{
		if (pApp->m_pActivePile != NULL && !pApp->m_pActivePile->GetSrcPhrase()->m_bNotInKB)
			OnButtonChooseTranslation(dummyevent);
		else
			::wxBell();
	}
}

void CAdapt_ItView::OnButtonChooseTranslation(wxCommandEvent& WXUNUSED(event))
// Modified for support of glossing.
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// ensure blank variables
	translation.Empty();
	curKey.Empty();
	nWordsInPhrase = 0;
	pCurTargetUnit = NULL;

	CKB* pKB;
	int nCurLongest;
	if (gbIsGlossing)
	{
		pKB = pApp->m_pGlossingKB;
		nCurLongest = 1; // only one map in the glossing KB, so treat as
						 // "one word" case whether or not src words or
						 // phrases are put into this one map
	}
	else
	{
		pKB = pApp->m_pKB;
		nCurLongest = pKB->m_nMaxWords; // no matches are possible for phrases
										// longer than nCurLongest
	}
	// check we are within bounds
	CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
	if (gbIsGlossing)
		nWordsInPhrase = 1;
	else
		nWordsInPhrase = pSrcPhrase->m_nSrcWords;

	if (nWordsInPhrase > nCurLongest)
	{
		// something is really wrong, this should not be possible
		wxString str =
		_T(
"Error: longest phrase in KB is shorter than current source phrase's number of words!\n");
		str += _T("So this command will be ignored.\n");
		wxMessageBox(str, _T(""), wxICON_EXCLAMATION);
		nWordsInPhrase = 0;
		pApp->m_pTargetBox->SetFocus();
		return;
	}

    // restore the current phrase box's text in the KB, so that potential singly referenced
    // adaptations not yet in the KB will still show in the dialog; but don't do so if the
    // phrasebox is empty (since we want <no adaptation> to show only when the button of
    // that name has been pressed)
	wxString temp;
	bool bOK = TRUE;
	bool bEmptyBox = FALSE;
	if (pApp->m_targetPhrase.IsEmpty())
	{
		bEmptyBox = TRUE;
		goto jp;
	}
	temp = pApp->m_targetPhrase;
	if (!gbIsGlossing || gbRemovePunctuationFromGlosses)
		RemovePunctuation(GetDocument(),&temp,from_target_text);
	bOK = StoreText(pKB, pSrcPhrase, temp, TRUE); // TRUE means we can store an empty 
												  // adaptation or gloss
	wxASSERT(bOK);

	// get a pointer to the target unit for the current key
jp:	pCurTargetUnit = GetTargetUnit(GetKB(), nWordsInPhrase, pSrcPhrase->m_key);
	if (pCurTargetUnit == NULL)
	{
		// IDS_NO_KB_ENTRY
		wxMessageBox(_(
"Sorry, the knowledge base does not yet have an entry matching this source text, so the Choose Translation dialog cannot be shown."),
		_T(""), wxICON_EXCLAMATION);
		nWordsInPhrase = 0;
		pApp->m_pTargetBox->SetFocus();
		return;
	}
	else
	{
		curKey = pSrcPhrase->m_key;
		CChooseTranslation dlg(pApp->GetMainFrame());
		dlg.Centre();
		// initialize m_chosenTranslation, other initialization is in OnInitDialog()
		dlg.m_chosenTranslation.Empty();

		// put up the dialog
		bool bCancelled = FALSE;
		gbInspectTranslations = TRUE; // use TRUE value to hide the "Cancel and Select" button
		if(dlg.ShowModal() == wxID_OK)
		{
			// set the translation static var from the member m_chosenText
			translation = dlg.m_chosenTranslation;
			if (dlg.m_bEmptyAdaptationChosen)
				gbEmptyAdaptationChosen = TRUE; // enable PlacePhraseBox to use the null string
												// chosen
		}
		else
		{
			// must have hit Cancel button
			bCancelled = TRUE;
			gbEmptyAdaptationChosen = FALSE;
		}
		gbInspectTranslations = FALSE;

		// remove the refString again, to restore the phrase box and KB to the proper state
		// for having landed there - if the user removed the refString in the dialog, pRefString
		// will be NULL and no damage will be done as RemoveRefString checks for this condition
		CRefString* pRefString;
		if (bEmptyBox)
			goto ed;
		if (gbIsGlossing)
			pRefString = GetRefString(GetKB(), 1, pSrcPhrase->m_key, pSrcPhrase->m_gloss);
		else
			pRefString = GetRefString(GetKB(), nWordsInPhrase, pSrcPhrase->m_key, 
										pSrcPhrase->m_adaption);

		if (pRefString != NULL)
		{
			// remove the translation from the KB, in case user wants to edit it before its
			// stored again (RemoveRefString also clears the m_bHasKBEntry flag on the source
			// phrase)
			if (gbIsGlossing)
			{
				RemoveRefString(pRefString,pSrcPhrase,from_target_text);
				// we must make sure the m_bHasGlossingKBEntry flag is false, otherwise a
				// subsequent StoreText() call will assert
				pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
			}
			else
			{
				RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);
				// we must make sure the m_bHasKBEntry flag is false, otherwise a
				// subsequent StoreText() call will assert
				pSrcPhrase->m_bHasKBEntry = FALSE;
			}
		}

		// if user hit the cancell button, we can return immediately
ed:		if (bCancelled)
		{
			nWordsInPhrase = 0;
			pCurTargetUnit = NULL;
			curKey.Empty();
			pApp->m_pTargetBox->SetFocus();
			return;
		}

		// use the translation global variable to set the phrase box to the chosen adaptation
		pApp->m_targetPhrase = translation;
		pApp->m_pTargetBox->ChangeValue(translation);
		PlacePhraseBox(pApp->m_pActivePile->GetCell(1), 1); // selector = 1 inhibits the 
							// saving to KB since there was no click to a new location
		gbEmptyAdaptationChosen = FALSE; // ensure its safely defused!

		// get a new (valid) active pile pointer, now that the layout is recalculated (again!)
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pApp->m_pActivePile);
		int len = pApp->m_pTargetBox->GetLineLength(0);
		pApp->m_nStartChar = len;
		pApp->m_nEndChar = len; // cursor at end of text in the box
		pApp->m_pTargetBox->SetModify(TRUE);

		// scroll into view, just in case a lot were inserted
		pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

		pApp->m_pTargetBox->SetFocus();
		translation.Empty(); // clear the globals
		curKey.Empty();
		Invalidate();
		GetLayout()->PlaceBox();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Show the Choose
/// Translation Dialog" toolbar item and returns immediately: The application is in Free
/// Translation mode, the targetBox is NULL or is not shown, or the application is in
/// glossing mode. Otherwise, it enables the toolbar button if the active pile is valid and
/// the source phrase at that point does not have the m_bNotInKB flag set.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonChooseTranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pTargetBox == NULL || !pApp->m_pTargetBox->IsShown())
	{
		// whm 12Aug08 Note: the m_pTargetBox is never NULL in the wx version, but
		// sometimes it is not shown, so if the ChooseTranslation button is
		// not enabled when it should be, this may be the cause.
		// TODO: check the logic during Find operations and any other cases
		// where the MFC version assumes that the target box might be NULL
		event.Enable(FALSE);
		return;
	}
	else
	{
		if (!gbIsGlossing && pApp->m_pActivePile != NULL && 
			!pApp->m_pActivePile->GetSrcPhrase()->m_bNotInKB)
		{
			event.Enable(TRUE);
		}
		else
		{
			if (gbIsGlossing)
				event.Enable(TRUE);
			else
				event.Enable(FALSE);
		}
	}
}

void CAdapt_ItView::StatusBarMessage(wxString &message)
{
	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
 	wxStatusBar* pStatusBar = pFrame->GetStatusBar();
	if (pStatusBar != NULL)
	{
		pStatusBar->SetStatusText(message,0); // use first field 0
	}
}

// called by DoStartupWizardOnLaunch
void CAdapt_ItView::OnFileStartupWizard(wxCommandEvent& event) 
{
    // Since the Startup Wizard menu item has an accelerator table hot key (CTRL-W see
    // CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even when
    // they are disabled, we must check for a disabled button and return if disabled.
    // On Windows, the accelerator key doesn't appear to call the handler for a disabled
    // menu item, but I'll leave the following code here in case it works differently on
    // other platforms.
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_FILE_STARTUP_WIZARD))
	{
		::wxBell();
		return;
	}

	pApp->m_bStartViaWizard = TRUE; // allows the OnIdle handler to force 
									// phrase box text to be selected
	bool bSuppress = pApp->m_bSuppressWelcome;

	if (pApp->m_pSourcePhrases->GetCount() > 0)
		goto a;
	if (pApp->m_pKB != NULL)
		goto a;
	if (gbJustClosedProject)
		goto a;

	if (!bSuppress)
	{
		CWelcome wdlg(pApp->GetMainFrame()); // make the view the parent
		wdlg.Centre();
		wdlg.ShowModal();
		pApp->m_bSuppressWelcome = wdlg.m_bSuppressWelcome; // update flag
	}

a:	if (pApp->m_bJustLaunched && !pApp->m_bUseStartupWizardOnLaunch)
		return; // suppress its use if user wants, but only for the program launch
	else
	{
		bool bSuccess = pApp->DoStartWorkingWizard(event);
		if (!bSuccess)
		{
			wxMessageBox(_T(
"The Startup Wizard failed. Try using Start Here... and either the New...\nor Open... items on the File... menu instead."),
			_T(""), wxICON_EXCLAMATION);
		}
	}
}

void CAdapt_ItView::DoStartupWizardOnLaunch()
{
	wxCommandEvent dummyevent;
	OnFileStartupWizard(dummyevent);
}

// Modified for support of glossing KB as well as adapting KB. The caller must send the
// correct KB pointer in the first parameter.
// whm modified 27Apr09 to report errors of punctuation existing in documents discovered 
// during KB Restore
void CAdapt_ItView::RedoStorage(CKB* pKB, CSourcePhrase* pSrcPhrase, wxString& errorStr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	wxASSERT(pApp != NULL);
	pApp->m_bForceAsk = FALSE;
	bool bOK;
	if (gbIsGlossing)
	{
		if (!pSrcPhrase->m_bHasGlossingKBEntry)
		{
			return; // nothing to be done
		}
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE; // has to be false on input to StoreText()
		bOK = StoreText(pKB,pSrcPhrase,pSrcPhrase->m_gloss,TRUE); // TRUE = support storing empty gloss
		if (!bOK)
		{
			// I don't expect any error here, but just in case ...
			wxBell();
			wxASSERT(FALSE);
		}
	}
	else // adapting
	{
		if (!pSrcPhrase->m_bRetranslation)
		{
				if (pSrcPhrase->m_bNotInKB)
				{
                    // BEW changed 2Sep09, as there may have been some adaptations
                    // "restored" before coming to this location where m_bNotInKB is set
                    // true, we must ensure any normal adaptations for the relevant
                    // CTargetUnit are removed, and <Not In KB>
                    // put in their place - the easy way to do this is to call DoNotInKB()
                    // with its last parameter set TRUE (that function is elsewhere called
                    // in the handler for the Save to KB checkbox, namely,
                    // OnCheckKBSave()); and once this <Not In KB> entry is set up, any
                    // later identical source text encountered in the span will, when
                    // StoreText() tries to add it to the KB, will reject it because of the
                    // <Not In KB> entry already in the KB
					DoNotInKB(pSrcPhrase, TRUE);
					return;
				}
			if (!pSrcPhrase->m_bHasKBEntry)
			{
				return; // nothing to be done
			}
            // BEW added 24Apr09, for a while a bug allowed m_key to have following
            // punctuation treated as part of the word, allowing punctuation to get into
            // the adaptation KB's source text, and a different bug allowed punctuation to
            // get into the KB in some m_adaption members where punctuation was not
            // stripped out beforehand. This next code block is a "heal it" block which
            // detects when punctuation has wrongly got into m_key or m_adaption members,
            // removes it, and presents puncutation-less strings for storage instead; it
            // also has two tracking booleans, each of which is TRUE whenever the
            // associated string has been found to have had punctuation removed herein
			bool bKeyHasPunct = FALSE;
			bool bAdaptionHasPunct = FALSE;
			wxString strCurKey = pSrcPhrase->m_key;
			wxString strCurAdaption = pSrcPhrase->m_adaption;
			wxString strKey(strCurKey);
			wxString strAdaption(strCurAdaption);
			if (!pSrcPhrase->m_bNullSourcePhrase)
			{
				// Don't remove "..." (in source phrase only) which represents a 
				// null source phrase (placeholder)
				RemovePunctuation(pDoc,&strKey,from_source_text);
			}
			if (!pSrcPhrase->m_bNotInKB)
			{
				// Don't remove "<Not In KB>" (in target text only)
				RemovePunctuation(pDoc,&strAdaption,from_target_text);
			}
			if (strKey != strCurKey)
				bKeyHasPunct = TRUE;
			if (strAdaption != strCurAdaption)
				bAdaptionHasPunct = TRUE;
            // Construct an errorStr for a log file, to report where fixes were made. This
            // errorStr is passed back to the caller DoKBRestore() where log file is
            // written out to disk.
			if (bKeyHasPunct || bAdaptionHasPunct)
			{
                // initialize the log file's entry here whm note: For each given document
                // used in the KB Restore where a correction was made, the following string
                // is added (in the caller) to introduce the change in the log file:
				//errorStr = _T("During the KB Restore, a correction involving punctuation was made to the KB and the following document:\n   %s\n   Punctuation was removed (see below) which had been wrongly stored by a previous version of Adapt It.");
				if (bKeyHasPunct)
				{
					// compose a substring for log file
					errorStr += _T("\n      ");
					errorStr += _T("\"");
					errorStr += strCurKey;
					errorStr += _T("\"");
					errorStr += _T(" was changed to ");
					errorStr += _T("\"");
					errorStr += strKey;
					errorStr += _T("\"");
				}
				if (bAdaptionHasPunct)
				{
					// extend or begin a substring for log file
					errorStr += _T("\n      ");
					errorStr += _T("\"");
					errorStr += strCurAdaption;
					errorStr += _T("\"");
					errorStr += _T(" was changed to ");
					errorStr += _T("\"");
					errorStr += strAdaption;
					errorStr += _T("\"");
				}
				// finalize the entry here, and add it to the log file
				;
			}
			// ensure a punctuation-less m_key in the CSourcePhrase instance
			pSrcPhrase->m_key = strKey;
			// ensure a punctuation-less m_adaption in the CSourcePhrase instance
			pSrcPhrase->m_adaption = strAdaption;

			// legacy code follows
			pSrcPhrase->m_bHasKBEntry = FALSE; // has to be false on input to StoreText()
			gbInhibitLine4StrCall = TRUE; // prevent any punctuation placement 
										  // dialogs from showing
			bool bOK = StoreText(pKB,pSrcPhrase,pSrcPhrase->m_adaption,
									TRUE); // TRUE = support storing empty adaptation
			gbInhibitLine4StrCall = FALSE;
			if (!bOK)
			{
				// I don't expect any error here, but just in case ...
				::wxBell();
				wxASSERT(FALSE);
			}
		}
	}
}

void CAdapt_ItView::OnCheckKBSave(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbIsGlossing)
	{
		// if glossing is ON, keep the box checked at all times since
		// we won't allow <Not In KB> option when gbIsGlossing is TRUE
		pApp->m_bSaveToKB = TRUE;
		return;
	}
	// glossing is OFF, so box can be toggled on or off
	if (pApp->m_pActivePile == NULL)
		return;
	CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
	if (pSrcPhrase == NULL)
		return;

	// call DoNotInKB & then toggle the m_bSaveToKB flag
	if (pApp->m_bSaveToKB)
	{
		// user does not want it to be in the KB
		// we must do the call with m_bSaveToKB TRUE, otherwise the store
		// of "<Not In KB>" will not happen
		DoNotInKB(pSrcPhrase,TRUE);
		pApp->m_bSaveToKB = FALSE;
	}
	else
	{
		// user wants it in the KB
		pApp->m_bSaveToKB = TRUE;
		DoNotInKB(pSrcPhrase,FALSE);
	}

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();

	// BEW added 20May09, next line required in order to get * shown
	GetLayout()->Redraw();
	GetLayout()->PlaceBox(); // this call probably unneeded but no harm done
}

void CAdapt_ItView::DoNotInKB(CSourcePhrase* pSrcPhrase, bool bChoice)
{
	if (bChoice)
	{
        // user wants it to not be in the KB, so set it up accordingly... first thing to do
        // is to remove all existing translations from this source phrase's entry in the KB
		CTargetUnit* pTgtUnit = GetTargetUnit(GetKB(),pSrcPhrase->m_nSrcWords,pSrcPhrase->m_key);
		if (pTgtUnit != NULL)
		{
			TranslationsList* pList = pTgtUnit->m_pTranslations;
			if (!pList->IsEmpty())
			{
				TranslationsList::Node* pos = pList->GetFirst();
				while (pos != NULL)
				{
					CRefString* pRefString = (CRefString*)pos->GetData();
					pos = pos->GetNext();
					if (pRefString != NULL)
					{
						delete pRefString;
						pRefString = (CRefString*)NULL;
					}
				}
				pList->Clear();

				// have to get rid of the pTgtUnit too, as its m_translation list 
				// must not be empty
				TUList::Node* tupos = GetKB()->m_pTargetUnits->Find(pTgtUnit); // find 
										// position of the bad targetUnit in the list
				// get the targetUnit in the list
				CTargetUnit* pTU = (CTargetUnit*)tupos->GetData(); 
				wxASSERT(pTU != NULL && pTU->m_pTranslations->IsEmpty()); // have we found it?
				GetKB()->m_pTargetUnits->DeleteNode(tupos); // remove it from the list
				delete pTU; // delete it from the heap
				pTU = (CTargetUnit*)NULL;

				MapKeyStringToTgtUnit* pMap = GetKB()->m_pMap[pSrcPhrase->m_nSrcWords - 1];
				// handle auto-caps tweaking, if it is on
				wxString temp = pSrcPhrase->m_key;
				if (gbAutoCaps && !gbNoSourceCaseEquivalents)
				{
                    // auto caps is on and there are case equivalences defined, so check if
                    // we must convert the key to lower case for the removal operation (so
                    // that it succeeds, since the KB would have a lower case key stored,
                    // not upper case
					bool bNoError = SetCaseParameters(temp); // TRUE for default 
															 // parameter = src text
					if (bNoError && gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
					{
						temp.SetChar(0,gcharSrcLC); // make first char lower case
					}
				}
				int bRemoved;
				bRemoved = pMap->erase(temp); // also remove it from the map 
				wxASSERT(bRemoved != 0);
			}
		}

		// we make it's KB translation be a unique "<Not In KB>" - 
		// Adapt It will use this as a flag
		pSrcPhrase->m_bNotInKB = FALSE; // temporarily set FALSE to allow 
										// the string to go into KB
		wxString str = _T("<Not In KB>");
		bool bOK;
		bOK = StoreText(GetKB(),pSrcPhrase,str);

		// make the flags the correct values & save them on the source phrase
		pSrcPhrase->m_bNotInKB = TRUE;
		pSrcPhrase->m_bHasKBEntry = FALSE;

        // user can set pSrcPhrase->m_adaption to whatever he likes via phrase box, it
        // won't go into KB, and it now (no longer) will get clobbered, since we now follow
        // Susanna Imrie's recommendation that this feature should still allow a non-null
        // translation to remain in the document
	}
	else
	{
		// make translations storable from now on
		pSrcPhrase->m_bNotInKB = FALSE; // also permits finding of KB entry
		pSrcPhrase->m_bHasKBEntry = FALSE; // make sure

		wxString str = _T("<Not In KB>");
		CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
												pSrcPhrase->m_key,str);
		if (pRefString == NULL)
		{
            // user must have already deleted the <Not In KB> while in the KB editor, so
            // our work is done
			return;
		}
		wxASSERT(pRefString);
		if (pRefString != NULL)
		{
			CTargetUnit* pTgtUnit = pRefString->m_pTgtUnit;
			wxASSERT(pTgtUnit);
			TranslationsList* pList = pTgtUnit->m_pTranslations;
			wxASSERT(!pList->IsEmpty() && pList->GetCount() == 1);
			TranslationsList::Node* pos = pList->GetFirst();
			delete pRefString; // deletes the CRefString having the text "<Not In KB>"
			pRefString = (CRefString*)NULL;
			pList->DeleteNode(pos);

            // we must also delete the target unit, since we are setting up a situation
            // where in effect the current matched item was never previously matched, ie.
            // it's a big error to have a target unit with no reference string in it.
			int index = pSrcPhrase->m_nSrcWords - 1;
			MapKeyStringToTgtUnit* pMap = GetKB()->m_pMap[index];
			int bRemoved;
			// handle auto-caps tweaking, if it is on
			wxString temp = pSrcPhrase->m_key;
			if (gbAutoCaps && !gbNoSourceCaseEquivalents)
			{
                // auto caps is on and there are case equivalences defined, so check if we
                // must convert the key to lower case for the removal operation (so that it
                // succeeds, since the KB would have a lower case key stored, not upper
                // case
				bool bNoError = SetCaseParameters(temp); // TRUE for default 
														 // parameter = src text
				if (bNoError && gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
				{
					temp.SetChar(0,gcharSrcLC); // make first char lower case
				}
			}
			bRemoved = pMap->erase(temp); // remove it from the map

			// now remove the CTargetUnit instance too
			TUList::Node* tupos;
			tupos = GetKB()->m_pTargetUnits->Find(pTgtUnit); // find position of 
												// pRefString's owning targetUnit
			pTgtUnit = (CTargetUnit*)tupos->GetData(); // get the targetUnit
														  // in the list
			wxASSERT(pTgtUnit != NULL);
			GetKB()->m_pTargetUnits->DeleteNode(tupos); // remove it from the list
			delete pTgtUnit; // delete it from the heap
			pTgtUnit = (CTargetUnit*)NULL;
		}
	}
}

void CAdapt_ItView::ClobberDocument()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = (CAdapt_ItDoc*)GetDocument();
	wxASSERT(pDoc != NULL);
	CLayout* pLayout = GetLayout();

    // BEW added 21Apr08; clean out the global struct gEditRecord & clear its deletion
    // lists, because each document, on opening it, it must start with a truly empty
    // EditRecord; and on doc closure and app closure, it likewise must be cleaned out
    // entirely (the deletion lists in it have content which persists only for the life of
    // the document currently open)
	InitializeEditRecord(gEditRecord); // clears all except the deletion list
	gEditRecord.deletedAdaptationsList.Clear(); // remove any stored deleted adaptations
	gEditRecord.deletedGlossesList.Clear(); // remove any stored deleted gloss strings
	gEditRecord.deletedFreeTranslationsList.Clear(); // remove stored deleted free translns

	// save settings for restoration from config file
	if (pApp->m_nActiveSequNum == -1)
		pApp->m_nActiveSequNum = 0;
	pApp->m_lastDocPath = pApp->m_curOutputPath;
	pApp->nLastActiveSequNum = pApp->m_nActiveSequNum;

    // now clobber it all the view stuff associated with the document, leaving an empty
    // document object
	pDoc->Modify(FALSE); // MFC has SetModifiedFlag(FALSE)
	pDoc->DeleteSourcePhrases();
	pLayout->GetInvalidStripArray()->Clear();
	pLayout->DestroyStrips();
	pLayout->DestroyPiles(); // restored, DestroySourcePhrases() no longer destorys 
							 // the partner piles
	pApp->m_pActivePile = (CPile*)NULL;
	pApp->m_pTargetBox->ChangeValue(_T("")); //pApp->m_targetBox.Destroy();
	pApp->m_nActiveSequNum = -1;
	pApp->m_selectionLine = -1;
	Invalidate(); // our own
	GetLayout()->PlaceBox();

	gbDoingInitialSetup = TRUE; // MFC note: Needed because the phrase box will not 
        //exist after the close is done, so if a <New Document> command is issued, then
        //OnButtonMerge() would otherwise fail if a LookAhead() merge was required on the
        //first words of the new document. I put it here because this is called for a doc
        //close by any method
    // NOTE: we don't change he values of the four flags associated with glossing, because
    // this function will be called for processes which serially open and close each
    // document of a project, and the flags will have to maintain their values across the
    // calls to ClobberDocument()

	// hide and disable the target box until input is expected
	pApp->m_pTargetBox->Hide(); // whm note: ChangeValue(_T("")) is called above
	pApp->m_pTargetBox->Enable(FALSE);
}

void CAdapt_ItView::CloseProject()
{
	wxCommandEvent dummyevent;
	OnFileCloseProject(dummyevent);
}

// targetStr will normally be the contents of the Phrase Box; it could have initial
// punctuation, it may not have, and/or final punctuation, or even in the case of a merger
// it may have medial punctuation, and it could have text starting with lower case and
// needing to become upper. BEW added 20 Apr 2005 checking of the app's flag
// m_bCopySourcePunctuation - which typically is TRUE, but for version 3 we wish to be able
// to temporarily suppress punctuation copy if the user clicks the No Punctuation Copy
// button on the command bar - so this flag was added to support this new functionality.
// The flag is automatically reset TRUE once the phrase box moves to a different location
// by any method.
void CAdapt_ItView::MakeLineFourString(CSourcePhrase *pSrcPhrase, wxString targetStr)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	pApp->m_nPlacePunctDlgCallNumber++;
	int theSequNum = pSrcPhrase->m_nSequNumber;
    // BEW added 1Jul09, don't do the code in this function if the function has been called
    // once before at this current active location
	if ( !(theSequNum == pApp->m_nCurSequNum_ForPlacementDialog &&
		  pApp->m_nPlacePunctDlgCallNumber > 1) )
	{

        // BEW added 19Dec07: bleed out the case when Reviewing mode is on and the box is
        // about to leave a hole which may or may not have had punctuation there; the
        // former m_targetStr is preserved in the global gStrSaveLineFourInReviewingMode,
        // and the test for needing to do this restoration is that the global flag
        // gbSavedLineFourInReviewingMode is TRUE, and we must clear the flag before
        // returning
		if (gbSavedLineFourInReviewingMode)
		{
            // the flag will only be true when the location was a hole when the box landed
            // there, so we can rely on m_targetPhrase being empty provided the user has
            // not decided to edit the document by typing something. So we check for a
            // still empty m_targetPhrase, and if so we restore m_targetStr to what it was
            // before and return; but if the use has typed something then we abandon what
            // we saved and we do a normal pass through the rest of this function
			if (pApp->m_targetPhrase.IsEmpty())
			{
				// it is still empty, so do the restoration etc.
				pSrcPhrase->m_targetStr = gStrSaveLineFourInReviewingMode;
				gStrSaveLineFourInReviewingMode.Empty();
				gbSavedLineFourInReviewingMode = FALSE; // restore default value
				return;
			}
			// user must have typed something, so clean up and control can fall thru 
			// to the rest
			gStrSaveLineFourInReviewingMode.Empty();
			gbSavedLineFourInReviewingMode = FALSE; // restore default value
		}

		wxString str = targetStr; // make a copy
		wxArrayString remainderList;
		wxString strCorresp;	// where we build target punctuation strings (from the 
			// punctuation correspondences pairs) before inserting them into m_targetStr
		strCorresp.Empty();

        // for auto-capitalization we will attempt to do any needed change to upper case,
        // no matter what the punctuation behaviour is. If a lookup was done earlier, and a
        // store not yet done, then the value of the gbMatchedKB_UCentry flag will also be
        // valid here (if it is TRUE then we don't want a change to upper case done because
        // the lookup was done with upper case source data - so we take the adaptation or
        // gloss 'as is')

		// first find out what the key's case status is
		bool bNoError = TRUE;
		bool bWantChangeToUC = FALSE; // if TRUE, we want the change to upper case 
									  // done if possible
		if (gbAutoCaps)
		{
			bNoError = SetCaseParameters(pSrcPhrase->m_key);
			if (bNoError && gbSourceIsUpperCase && !gbMatchedKB_UCentry)
			{
				bWantChangeToUC = TRUE;
			}
		}

        // if it is <Not In KB> then suppress punctuation insertion - there is nothing
        // supposed to be "there" anyway -- from version 1.4.0 and onwards, by Susanna
        // Imrie's suggestion, we will allow a non-null adaptation for a <not in kb> entry;
        // we just won't store it in the kb -- so just go on...

		// we don't worry about internal punctuation in the target if the target is empty
		// in fact, we don't want any punctuation if the target is empty
		bool bEmptyTarget = FALSE;
		if (!str.IsEmpty() && pApp->m_bCopySourcePunctuation)
		{
			// check for any medial punctuation, if there is any, see if it is all in
			// the targetStr already; if not, ask user for whatever is missing (if he wants
			// he can then place the extra stuff, or ignore it). We assume that the
			// phrase is not so long that the same punctuation will occur medially twice, if
			// it does, our algorithm will not ensure each instance is there; so to be sure, the
			// user should type what he wants in the Phrase Box in the first place.
			if (pSrcPhrase->m_bHasInternalPunct)
			{
				wxString punct;
				bool bFoundAll = TRUE;
				wxArrayString* pList = pSrcPhrase->m_pMedialPuncts; // the CSourcePhrase might
																  // contain a phrase or a word
				int count = pList->GetCount();

				for ( int n = 0; n < count; n++ )
				{
					punct = pList->Item(n); // can be several punct characters in the
												 // stored string
					wxASSERT(!punct.IsEmpty());
					strCorresp = GetConvertedPunct(punct); // uses PUNCTPAIRS and TWOPUNCTPAIRS
														   // for converting

					// the new syntax no longer checks if some are already typed, it just assumes
					// none are
					remainderList.Add(strCorresp);//remainderList.AddTail(strCorresp);
					bFoundAll = FALSE;
				}

				if (!bFoundAll)
				{
                    // put them all in interactively using a dialog (formerly, the dialog
                    // showed only the ones not typed)
					gpRemainderList = &remainderList; // set the global so dialog can 
													  // access it
					CPlaceInternalPunct dlg(wxGetApp().GetMainFrame());
					dlg.Centre();
					dlg.m_pSrcPhrase = pSrcPhrase; // set the dialog's local member
					dlg.ShowModal(); // display the dialog

					// get the result, and fix the source phrase accordingly
					str = dlg.m_tgtPhrase; // remember str could be a phrase, and so 
										   //contain one or more spaces
					// anything left in the list can be thrown away now
					gpRemainderList->Clear();
					gpRemainderList = (wxArrayString*)NULL; // the remainderList will be
											// destroyed when it goes out of scope
					strCorresp.Empty();
				}
			}
		}
		else
		{
			bEmptyTarget = TRUE;
		}

        // BEW addition 23March05, to allow detached punctuation to be reconstructed in the
        // target text I do it here and not for the internal punctuation case above because
        // it would make no sense to do the block of code above when the target is empty
		bool bWantPrevCopy;
		//int len; // unused
		int punctLen;
		if (bEmptyTarget) bEmptyTarget = FALSE;

		// BEW added 20 April 2005 to support the use of the new No Punctuation Copy button
		if (!pApp->m_bCopySourcePunctuation)
			goto a; // don't restore the TRUE value for this flag at the end of this
                // function because the function can be called more than once while the
                // phrase box is unmoved. Do the flag restoration to TRUE in code which
                // moves the phrase box elsewhere

        // preceding punctuation can be handled silently. If the user typed different
        // punctuation, then the user's must override the original punctuation. The target
        // text string might be a phrase and hence contain spaces, but space is a delimiter
        // in m_punctSet from version 1.3.6 onwards, so we must be careful in the next code
        // blocks - SpanIncluding() can still be used safely, because there will be
        // nonpunctuation and nonspace characters prior to any spaces in the phrase; and
        // similarly when reversed
		bWantPrevCopy = FALSE;
		punctLen = 0; // for auto caps support
		if (!bEmptyTarget)
		{
			if (!pSrcPhrase->m_precPunct.IsEmpty())
			{
				// span using target lang's punctuation - wxWidgets version 
				// SpanIncluding() in helpers.h
				wxString strInitialPunct = SpanIncluding(str, pApp->m_punctuation[1]);
				if (strInitialPunct.IsEmpty())
				{
                    // there was no initial punctuation typed, so silently copy original's
                    // to the target later on (not here, in case it mucks up the check for
                    // following punct)
					bWantPrevCopy = TRUE;
				}
				else
				{
                    // let the punctuation typed by the user stand unchanged, but for auto
                    // caps ON get the case change done if it is required
					punctLen = strInitialPunct.Length();
				}

				if (bWantChangeToUC)
				{
					// check first that the change to upper case is possible
					wxString noInitialPunctStr = str.Mid(punctLen);
					bNoError = SetCaseParameters(noInitialPunctStr,FALSE);
					if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
					{
						// do the change to upper case
						str.SetChar(punctLen,gcharNonSrcUC);
					}
				}
			}
            // if the word or phrase in the source had no preceding punctuation, then
            // MakeLineFourString will do nothing, so that if the user elects to explicitly
            // type some preceding punctuation, it will be accepted unconditionally

			// ditto, for following punctuation
			if (!pSrcPhrase->m_follPunct.IsEmpty())
			{
				wxString reverse = str;
				reverse = MakeReverse(reverse); // my version of MakeReverse() in helpers.h

				wxString strFollPunct = SpanIncluding(reverse,pApp->m_punctuation[1]);
				if (strFollPunct.IsEmpty())
				{
					// there was no final punctuation typed, so silently copy original's 
					// to the target
					wxString tgtFollPunct;
					tgtFollPunct.Empty();
					tgtFollPunct = GetConvertedPunct(pSrcPhrase->m_follPunct);

                    // references in the text like 10:27 give this algorithm problems; the
                    // first time the phrasebox is accessed, :27 gets appended to 10,
                    // resulting in 10:27 as the target text - correctly; but if the user
                    // backtracks to that CSourcePhrase instance later on (by any means),
                    // then MakeLineFourString will be called at least two more times, and
                    // the next time round the passed in text would be 10:27 to which a
                    // further :27 gets added, producing 10:27:27 and then the caller would
                    // call RemovePunctuation( ) which is coded in such a way that this
                    // "word" would result in 1027 being saved to the KB and the final :27
                    // retained as following punctuation, and that gets added producing
                    // 1027:27 - and so it goes on, next we'd get 102727:27, and so on ad
                    // infinitum. To break this sequence of errors, we need to do a test
                    // for "following punctuation" strings which have already been added to
                    // the word, such as "10". So we use the reversed string and also
                    // reverse tgtFollPunct and check if the latter is the initial string
                    // already - if so, we assume nothing more needs to be done.
					wxString reverseFollPunct = tgtFollPunct;
					reverseFollPunct = MakeReverse(reverseFollPunct);
					int nFind = reverse.Find(reverseFollPunct);
					if (nFind == 0)
					{
                        // we have a situation where it looks like the 'following
                        // punctuation' has already been added so we'll do nothing
						;
					}
					else
					{
						// looks like it has not been added yet, so do so
						str += tgtFollPunct;
					}
				}
				else
				{
					; // do nothing, let the punctuation typed by the user stand unchanged
				}
			}
            // if the word or phrase in the source had no following punctuation, then
            // MakeLineFourString will do nothing, so that if the user elects to explicitly
            // type some following punctuation, it will be accepted unconditionally

			// add the preceding punctuation, if any
			if (bWantPrevCopy)
			{
				wxString tgtPrecPunct;
				tgtPrecPunct.Empty();
				tgtPrecPunct = GetConvertedPunct(pSrcPhrase->m_precPunct);
				str = tgtPrecPunct + str;
			}
		}

		// now add the final form of the target string to the source phrase
a:		pSrcPhrase->m_targetStr = str;
	}
    // store the sequence number on the app class, so that if we reenter while at the same
    // sequence number, the test at the top of the function can detect this and if the
    // m_nPlacePunctDlgCallNumber value has just been incremented to be 2 or higher, we
    // will skip the code contained in this function; the m_nPlacePunctDlgCallNumber value
    // is reset to 0 at the end of CLayout::Draw(), and at the same place the
    // m_nCurSequNum_ForPlacementDialog is reset to default -1
	pApp->m_nCurSequNum_ForPlacementDialog = theSequNum;
}

// return the target punctuation string corresponding to input rStr parameter which is a
// source punctuation string this function should work fine without modification, for ANSI
// or UNICODE (UTF-16) builds
wxString CAdapt_ItView::GetConvertedPunct(const wxString& rStr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxString s;
	s.Empty();

	if (rStr.IsEmpty())
	{
		return s;
	}

	wxChar ch;
	wxChar doubleCh[2];
	int len = rStr.Length();
	int l;
	bool bFoundDouble;
	int k;
	int i;
	bool bFound;

	for (int j = 0; j < len; j++)
	{
		// first try two-character source punctuation, if no match, 
		// then try single-char matching
		bool bMatchedTwo = FALSE;
		k = j;
		++k;
		if (k >= len)
			goto a; // no room for a 2-char match
		doubleCh[0] = rStr.GetChar(j);
		doubleCh[1] = rStr.GetChar(k);
		bFoundDouble = FALSE;
		for (l = 0; l < MAXTWOPUNCTPAIRS; l++)
		{
			wxChar srcChar[2];
			srcChar[0] = pApp->m_twopunctPairs[l].twocharSrc[0];
			if (srcChar[0] == _T('\0'))
				goto a; // this is a null entry, so there is nothing to search for
			srcChar[1] = pApp->m_twopunctPairs[l].twocharSrc[1];
			if (srcChar[1] == _T('\0'))
			{
				if (srcChar[0] == doubleCh[0])
				{
					// we have matched, but the user only specified a single src punct
					bMatchedTwo = TRUE;
					break;
				}
			}
			else
			{
				if (srcChar[0] == doubleCh[0] && srcChar[1] == doubleCh[1])
				{
					// we have matched a 2-char punct pair
					bMatchedTwo = TRUE;
					break;
				}
			}
		}

		if (bMatchedTwo)
		{
			wxChar chMatched[2];
			chMatched[0] = pApp->m_twopunctPairs[l].twocharTgt[0];
			if (chMatched[0] == _T('\0'))
				goto b; // user must want this pair converted to nothing
			chMatched[1] = pApp->m_twopunctPairs[l].twocharTgt[1];
			if (chMatched[1] == _T('\0'))
			{
				// target punct pair is just a single char, so append it
				s += chMatched[0];
			}
			else
			{
				// target punct pair is a pair, so append them both
				s += chMatched[0];
				s += chMatched[1];
			}
			goto b;
		}

		// try match a single char source punctuation
a:		ch = rStr.GetChar(j);

		bFound = FALSE;
		for (i = 0; i < MAXPUNCTPAIRS; i++)
		{
			wxChar srcChar = pApp->m_punctPairs[i].charSrc;
			if (srcChar == ch)
			{
				// matched source char, so get its corresponding target char
				bFound = TRUE;
				break;
			}
		}

		if (!bFound)
		{
			// if not found, copy original character to the converted punct string
			s += ch;
		}
		else
		{
			wxChar chMatched = pApp->m_punctPairs[i].charTgt;
			if (chMatched != (wxChar)0)
			{
				s += chMatched;
			}
		}

b:		if (bMatchedTwo)
			j += 1;
	}

	return s; // if we get here, we got no match, which is an error
}

// whm Modified 9Feb2004, to enable consistency checking of currently open document or,
// alternatively, select multiple documents from the project to check for consistency. If a
// document is open when call is made to this routine, the consistency check is completed
// and the user can continue working from the same position in the open document.
void CAdapt_ItView::OnEditConsistencyCheck(wxCommandEvent& WXUNUSED(event))
{
	// the 'accepted' list holds the document filenames to be used
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	pApp->m_acceptedFilesList.Clear();
	CAdapt_ItDoc* pDoc = GetDocument();
	if (pDoc == NULL)
	{
		wxMessageBox(_T(
"GetDocument() call returned a null pointer in OnEditConsistencyCheck(), so command was aborted."),
		_T(""), wxICON_EXCLAMATION);
		return;
	}

    // BEW added 01Aug06 Support for Book Mode was absent in 3.2.1 and earlier, but it is
    // now added here & below. For Book Mode, not all Bible book folders will be scanned,
    // instead, the check is done on the current doc, or on all the docs in the single
    // current book folder. To check other book folders, the user must first change to one,
    // and then the same two options will be available there.
	wxString dirPath;
	if (pApp->m_bBookMode && !pApp->m_bDisableBookMode)
		dirPath = pApp->m_bibleBooksFolderPath;
	else
		dirPath = pApp->m_curAdaptionsPath;
	bool bOK = ::wxSetWorkingDirectory(dirPath); // ignore failures

	// BEW added 05Jan07 to enable work folder on input to be restored when done
	wxString strSaveCurrentDirectoryFullPath = dirPath;

	// Determine if a document is currently open with data to check
	if (!pApp->m_pSourcePhrases->GetCount() == 0)
	{
		// A document is open with data to check, therefore see if
		// user wants to only check the open document or to select
		// from a list of all documents in the current project to be
		// checked.
		// Save current path and doc name for use in re-opening below
		wxString pathName = pApp->m_curOutputPath;
		wxString docName = pApp->m_curOutputFilename;

		// Save the phrase box's current position in the file
		int currentPosition = pApp->m_nActiveSequNum;

		// Put up the Choose Consistency Check Type dialog
		CChooseConsistencyCheckTypeDlg ccDlg(pApp->GetMainFrame());
		if (ccDlg.ShowModal() == wxID_OK) 
		{
			// handle user's choice of consistency check type
			if (ccDlg.m_bCheckOpenDocOnly)
			{
				// user want's to check only the currently open doc...

                // Save the Doc (and DoFileSave() also automatically saves, without backup,
                // both the glossing and adapting KBs)
				bool fsOK = pDoc->DoFileSave(TRUE); // TRUE - show the wait/progress dialog
				if (!fsOK)
				{
					// something's real wrong!
					wxMessageBox(_(
					"Could not save the current document. Consistency Check Command aborted."),
					_T(""), wxICON_EXCLAMATION);
                    // whm note 5Dec06: Since EnumerateDocFiles has not yet been called the
                    // current working directory has not changed, so no need here to reset
                    // it before return.
					return;
				}

                // BEW added 01Aug06, ensure the current document's contents are removed,
                // otherwise we will get a doubling of the doc data when OnOpenDocument()
                // is called because the latter will append to whatever is in
                // m_pSourcePhrases, so the latter list must be cleared to avoid the data
                // doubling bug
				ClobberDocument();

				// Ensure that our current document is the only doc in the accepted files list
				pApp->m_acceptedFilesList.Clear();
				pApp->m_acceptedFilesList.Add(docName);

				// do the consistency check on the doc
				DoConsistencyCheck(pApp,pDoc);
				pApp->m_acceptedFilesList.Clear();
			}
			else
			{
				// User wants to check a selection of docs in current project.
				// This is like the multi-document type consistency check, except
				// that, in this case, there is a currenly open document.

                // BEW changed 01Aug06 Save the current doc and then clear out its contents
                // -- see block above for explanation of why this is necessary
				bool fsOK = pDoc->DoFileSave(TRUE); // TRUE - show wait/progress dialog
				if (!fsOK)
				{
					// something's real wrong!
					wxMessageBox(_(
					"Could not save the current document. Consistency Check Command aborted."),
					_T(""), wxICON_EXCLAMATION);
                    // whm note 5Dec06: Since EnumerateDocFiles has not yet been called the
                    // current working directory has not changed, so no need here to reset
                    // it before return.
					return;
				}
				ClobberDocument();

                // Enumerate the doc files and do the consistency check 
                // whm note: EnumerateDocFiles() has the side effect of changing the current
                // work directory to the passed in dirPath.
				bOK = pApp->EnumerateDocFiles(pDoc, dirPath);
				if (bOK)
				{
					if (pApp->m_acceptedFilesList.GetCount() == 0)
					{
						// nothing to work on, so abort the operation
						// IDS_NO_DOCUMENTS_YET
						wxMessageBox(_(
"Sorry, there are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."),
						_T(""),wxICON_EXCLAMATION);
                        // whm note 5Dec06: EnumerateDocFiles above changes the current
                        // work directory, so to be safe I'll reset it here before the
                        // consistency check returns to what it was on entry (the line
                        // below was not added in MFC version).
						bool bOK;
						bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
						return;
					}
					DoConsistencyCheck(pApp,pDoc);
				}
				pApp->m_acceptedFilesList.Clear();
			}
		}
		else
		{
			// user cancelled
            // whm note 5Dec06: Since EnumerateDocFiles has not yet been called the current
            // working directory has not changed, so no need here to reset it before
            // return.
			return;
		}

		// BEW added 05Jan07 to restore the former current working directory
		// to what it was on entry
		bool bOK;
		bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);

		// Re-Open the CurrentDocName to continue editing at the point where
		// the phrase box was at closure
		bool bOpenOK;
		bOpenOK = pDoc->OnOpenDocument(pathName);
		pDoc->SetFilename(pathName,TRUE);
		// Return the phrase box to the active sequence number; but if the box is not
		// in existence because the user got to the end of the document and invoked the
		// test from there, then reset to the initial position
		if (currentPosition == -1)
			currentPosition = 0;
		CPile* pPile = GetPile(currentPosition);
		Jump(pApp,pPile->GetSrcPhrase());

	}// end of if document is open with data to check
	else
	{
		// No document open. User selected Consistency Check intending to check
		// a selection of documents in the current project
        // whm note: EnumerateDocFiles() has the side effect of changing the current work
        // directory to the passed in dirPath.
		bOK = pApp->EnumerateDocFiles(pDoc, dirPath);
		if (bOK)
		{
			if (pApp->m_acceptedFilesList.GetCount() == 0)
			{
				// nothing to work on, so abort the operation
				//IDS_NO_DOCUMENTS_YET
				wxMessageBox(_(
"Sorry, there are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."),
				_T(""),wxICON_EXCLAMATION);
                // whm note 5Dec06: EnumerateDocFiles above changes the current work
                // directory, so to be safe I'll reset it here before the consistency check
                // returns to what it was on entry (the line below was not added in MFC
                // version).
				bool bOK;
				bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
				return;
			}
			DoConsistencyCheck(pApp,pDoc);
		}
		pApp->m_acceptedFilesList.Clear();
		
		// BEW added 05Jan07 to restore the former current working directory
		// to what it was on entry
		bool bOK;
		bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
	}
}

// this function assumes that the current directory will have already been set correctly
// before being called. Modified, July 2003, for support of Auto Capitalization
void CAdapt_ItView::DoConsistencyCheck(CAdapt_ItApp* pApp, CAdapt_ItDoc* pDoc)
{
	gbConsistencyCheckCurrent = TRUE; // turn on Flag to inhibit placement of phrase box
									  // initially when OnOpenDocument() is called
	CLayout* pLayout = GetLayout();
	wxASSERT(pApp != NULL);
	wxASSERT(pDoc != NULL);
	CKB* pKB;
	wxArrayString* pList = &pApp->m_acceptedFilesList;
	if (gbIsGlossing)
		pKB = pApp->m_pGlossingKB;
	else
		pKB = pApp->m_pKB;
	wxASSERT(pKB != NULL);
	int nCount = pList->GetCount();
	if (nCount <= 0)
	{
		// something is real wrong, but this should never happen so an English message will suffice
		wxString error;
		error = error.Format(_T(
		"Error, the file count was found to be %d, so the command was aborted."),nCount);
		wxMessageBox(error,_T(""), wxICON_WARNING);
		gbConsistencyCheckCurrent = FALSE;
		return;
	}
	wxASSERT(nCount > 0);
	if (pDoc == NULL)
	{
		wxMessageBox(_T(
"GetDocument() call returned a null pointer in DoConsistencyCheck(), so command was aborted."),
		_T(""), wxICON_EXCLAMATION);
		gbConsistencyCheckCurrent = FALSE;
		return;
	}
	int nTotal = 0;
	int nCumulativeTotal = 0;

	// create a list to hold pointers to auto-fix records, if user checks the auto fix checkbox
	// in the dlg
	AFList afList;

	// create a copy of the KB, we check the copy for inconsistencies, but do updating within
	// the current KB pointed to by the app's m_pKB pointer, or m_pGlossingKB when glossing
	CKB* pKBCopy = new CKB(); // can't use a copy constructor, due to C++ bug
	pKBCopy->Copy(*pKB);  // this is a work-around for the C++ bug - see KB.h for an explanation

	// iterate over the document files
	bool bUserCancelled = FALSE; // whm note: Caution: This bUserCancelled overrides the scope 
								 // of the extern global of the same name
	int i;
	for (i=0; i < nCount; i++)
	{
		wxString newName = pList->Item(i);
		wxASSERT(!newName.IsEmpty());

        // for debugging- check pile count before & after (failure to close doc before
        // calling this function resulted in the following OnOpenDocument() call appending
        // a copy of the document's contents to itself -- the fix is to ensure
        // OnFileClose() is done in the caller before DoConsistencyCheck() is called
		// int piles = pApp->m_pSourcePhrases->GetCount();

		bool bOK;
		bOK = pDoc->OnOpenDocument(newName);
		pDoc->SetFilename(newName,TRUE);

		nTotal = pApp->m_pSourcePhrases->GetCount();
		if (nTotal == 0)
		{
			wxString str;
			str = str.Format(_T("Bad file:  %s"),newName.c_str());
			wxMessageBox(str,_T(""),wxICON_WARNING);
		}
		nCumulativeTotal += nTotal;

		// put up a progress indicator
#ifdef __WXMSW__
		wxString progMsg = _("%s  - %d of %d Total words and phrases");
		wxString msgDisplayed = progMsg.Format(progMsg,newName.c_str(),1,nTotal);
		wxProgressDialog progDlg(_("Consistency Checking"),
                        msgDisplayed,
                        nTotal,    // range
                        pApp->GetMainFrame(),   // parent
                        //wxPD_CAN_ABORT |
                        //wxPD_CAN_SKIP |
                        wxPD_APP_MODAL |
                        // wxPD_AUTO_HIDE | -- try this as well
                        wxPD_ELAPSED_TIME |
                        wxPD_ESTIMATED_TIME |
                        wxPD_REMAINING_TIME
                        | wxPD_SMOOTH // - makes indeterminate mode bar on WinXP very small
                        );
#else
	// wxProgressDialog tends to hang on wxGTK so I'll just use the simpler CWaitDlg
	// notification on wxGTK and wxMAC
	// put up a Wait dialog - otherwise nothing visible will happen until the operation is done
	CWaitDlg waitDlg(pApp->GetMainFrame());
	// indicate we want the reading file wait message
	waitDlg.m_nWaitMsgNum = 5;	// 5 hides the static leaving only "Please wait..." in title bar
	waitDlg.Centre();
	waitDlg.Show(TRUE);
	waitDlg.Update();
	// the wait dialog is automatically destroyed when it goes out of scope below.
#endif

		SPList* pPhrases = pApp->m_pSourcePhrases;
		SPList::Node* pos1; 
		pos1 = pPhrases->GetFirst();
		wxASSERT(pos1 != NULL);
		int counter = 0;
		while (pos1 != NULL)
		{
			CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetNext();
			counter++;

			// check the KBCopy has the required association of key with translation
			int nWords;
			if (gbIsGlossing)
				nWords = 1;
			else
				nWords = pSrcPhrase->m_nSrcWords;
			CTargetUnit* pTU = NULL;
			bool bOK = TRUE;
			bool bFoundTgtUnit = TRUE;
			bool bFoundRefString = TRUE;

			// any inconsistency with a <Not In KB> entry can be fixed automatically,
			// and this block must be ignored when glossing is ON
			if (!gbIsGlossing && !pSrcPhrase->m_bRetranslation && 
				pSrcPhrase->m_bNotInKB && !pSrcPhrase->m_bHasKBEntry)
			{
				wxString str = _T("<Not In KB>");
				// do the lookup
				bOK = AutoCapsLookup(pKBCopy->m_pMap[nWords-1], pTU, pSrcPhrase->m_key);
				if (!bOK)
				{
					// fix it silently
					pApp->m_bSaveToKB = TRUE; // ensure it gets stored
					StoreText(pKB,pSrcPhrase,str); // don't want punctuation in the KB
					pSrcPhrase->m_bHasKBEntry = FALSE;
					pSrcPhrase->m_bNotInKB = TRUE;
				}
			}

			bool bTheTest = FALSE;
			// define the test's value
			if (gbIsGlossing)
			{
				if (pSrcPhrase->m_bHasGlossingKBEntry)
				{
					bTheTest = TRUE;
				}
			}
			else // adapting
			{
				if (!pSrcPhrase->m_bRetranslation && !pSrcPhrase->m_bNotInKB &&
					pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_adaption != _T("<Not In KB>"))
				{
					bTheTest = TRUE;
				}
			}
			if (bTheTest)
			{
				// do the lookup
				bOK = AutoCapsLookup(pKBCopy->m_pMap[nWords-1], pTU, pSrcPhrase->m_key);
				if (!bOK)
				{
					// there was no target unit for this key in the map, so this is an
					// inconsistency
					bFoundTgtUnit = FALSE;
					bFoundRefString = FALSE;
				}
				else
				{
					// the target unit is in the map, so check if there is a corresponding
					// refString for the m_adaption, or m_gloss, member of the source phrase
					wxASSERT(pTU);
					bool bMatched = FALSE;
					TranslationsList* pList = pTU->m_pTranslations; 
					wxASSERT(pList != NULL);
					wxASSERT(pList->GetCount() > 0); // a target unit with no refStrings is illegal
					wxString srcPhraseStr;
					if (gbIsGlossing)
					{
						srcPhraseStr = pSrcPhrase->m_gloss;
					}
					else
					{
						srcPhraseStr = pSrcPhrase->m_adaption;
					}
					if (!((gbAutoCaps && gbSourceIsUpperCase && 
						gbMatchedKB_UCentry) || !gbAutoCaps))
					{
                        // do a change to lc only if it is needed - that is, attempt it
                        // when it is not the case that gbMatchedKB_UCentry is TRUE
                        // (because then we want an unmodified string to be used),
                        // otherwise attempt it when auto-caps is ON
						srcPhraseStr = AutoCapsMakeStorageString(srcPhraseStr,FALSE);
					}
					TranslationsList::Node* pos = pList->GetFirst();
					wxASSERT(pos != NULL);
					while (pos != NULL)
					{
						CRefString* pRefString = (CRefString*)pos->GetData();
						pos = pos->GetNext();
						wxASSERT(pRefString != NULL);
						if (pRefString->m_translation == srcPhraseStr)
						{
							// a matching gloss was found
							bMatched = TRUE;
							break;
						}
					}
					if (!bMatched)
					{
						// no match was made, so this is an inconsistency
						bFoundRefString = FALSE;
					}
				}
			}

			// open the dialog if we have an inconsistency
			if (!bFoundTgtUnit || !bFoundRefString)
			{
				// make the source phrase able to have a KB entry added
				if (gbIsGlossing)
					pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
				else
					pSrcPhrase->m_bHasKBEntry = FALSE;

#ifdef __WXMSW__
				// hide the progress window
				progDlg.Hide(); 
#endif

                // work out if this is an auto-fix item, if so, don't show the dialog, but
                // use the stored AutoFixRecord to fix the inconsistency without user
                // intervention (note: any items for which the "Ignore it, I will fix it 
                // later" button was pressed cannot occur as auto-fix records) The next 100
                // lines could be improved - it was "added to" in a rather ad hoc fashion,
                // so its a bit spagetti-like... something to do sometime when there is
                // plenty of time!
				AutoFixRecord* pAFRecord = NULL;
				if (MatchAutoFixItem(&afList, pSrcPhrase, pAFRecord))
				{
					// we matched an auto-fix element, so do the fix automatically...
					// update the original kb (not pKBCopy)
					wxString tempStr = pAFRecord->finalAdaptation; // could have punctuation in it

					// if the adaptation is null, then assume user wants it that way and so store
					// an empty string
					if (tempStr.IsEmpty())
					{
						StoreText(pKB,pSrcPhrase,tempStr,TRUE); // TRUE = allow saving empty adaptation
					}
					else
					{
						if (!gbIsGlossing)
						{
							RemovePunctuation(pDoc,&tempStr,from_target_text); // we don't want
								// punctuation in adaptation KB if autocapitalization is ON, we
								// could have an upper case source, but the user may have typed
								// lower case for fixing the gloss or adaptation, but this is
								// okay - the store will work right, so don't need anything
								// here except the call to store it
							StoreText(pKB,pSrcPhrase,tempStr);
						}
						// do the gbIsGlossing case when no punct is to be removed, in next block
					}
					if (!tempStr.IsEmpty())
					{
                        // here we must be careful; pAFRecord->finalAdaptation may have a
                        // lower case string when the source text has upper case, and the
                        // user is expecting the application to do the fix for him; this
                        // would be easy if we could be sure that the first letter of the
                        // string was at index == 0, but the possible presence of preceding
                        // punctuation makes the assumption dangerous - so we must find
                        // where the actual text starts and do any changes there if needed.
                        // tempStr has punctuation stripped out, pAFRecord->finalAdaptation
                        // doesn't so start by determining if there actually is a problem
                        // to be fixed.
						if (gbAutoCaps)
						{
							bool bNoError = SetCaseParameters(pSrcPhrase->m_key);
							if (bNoError && gbSourceIsUpperCase)
							{
								bNoError = SetCaseParameters(tempStr,FALSE); // FALSE means "it's target text"
								if (bNoError && !gbNonSourceIsUpperCase &&
									(gcharNonSrcUC != _T('\0')))
								{
                                    // source is upper case but nonsource is lower and is a
                                    // character with an upper case equivalent - we have a
                                    // problem; we need to fix the AutoFixRecord's
                                    // finalAdaptation string, and the sourcephrase too. At
                                    // this point we can fix the m_adaption member as
                                    // follows:
									pSrcPhrase->m_adaption.SetChar(0,gcharNonSrcUC);
								}
							}
						}
                        // In the next if/else block, the non-glossing-mode call of
                        // MakeLineFourString() accomplishes the setting of the
                        // pSrcPhrase's m_targetStr member, handling any needed lower case
                        // to upper case conversion (even when typed initial punctuation is
                        // present), and the punctuation override protocol if the passed in
                        // string in the 2nd parameter has initial and/or final
                        // punctuation.
						if (!gbIsGlossing)
						{
							// for auto capitalization support, MakeLineFourString( ) is now
							// able to do any needed change to upper case initial letter even
							// when there is initial punctuation on pAFRecord->finalAdaptation
							MakeLineFourString(pSrcPhrase, pAFRecord->finalAdaptation);
						}
						else
						{
							// store, for the glossing ON case, the gloss text, 
							// with any punctuation
							StoreText(pKB, pSrcPhrase, pAFRecord->finalAdaptation);
							if (gbAutoCaps)
							{
                                 // upper case may be wanted, we have to do it on the first
                                // character past any initial punctuation; glossing mode
                                // doesn't do punctuation stripping and copying, but the
                                // user may have punctuation included in the inconsistency
                                // fixing string, so we have to check etc.
								wxString str = pAFRecord->finalAdaptation;
								// make a copy and remove punctuation from it
								wxString str_nopunct = str;
								RemovePunctuation(pDoc,&str_nopunct,from_target_text);
								// use the punctuation-less string to get the initial charact and
								// its upper case equivalent if it exists
								bool bNoError = SetCaseParameters(str_nopunct,FALSE); // FALSE means
																	// "using target punct list"
								// span punctuation-having str using target lang's punctuation...
								wxString strInitialPunct = SpanIncluding(
												str,pApp->m_punctuation[1]); // use our
														// own SpanIncluding in helpers
								int punctLen = strInitialPunct.Length();

								// work out if there is a case change needed, and set the
								// relevant case globals
								bNoError = SetCaseParameters(tempStr,FALSE); // FALSE 
															// means "it's target text"
								if (bNoError && gbSourceIsUpperCase && !gbNonSourceIsUpperCase
									&& (gcharNonSrcUC != _T('\0')))
								{
									if (strInitialPunct.IsEmpty())
									{
                                        // there is no initial punctuation, so the change
                                        // to upper case can be done at the string's start
										pSrcPhrase->m_gloss.SetChar(0,gcharNonSrcUC);
									}
									else
									{
										// set it at the first character past the initial
										// punctuation
										str.SetChar(punctLen,gcharNonSrcUC);
										pSrcPhrase->m_gloss = str;
									}
								}
							}
							else
							{
								// no auto capitalization, so just use finalAdaptation 
								// string 'as is'
								pSrcPhrase->m_gloss = pAFRecord->finalAdaptation;
							}
						}
					}
					pApp->m_targetPhrase = pAFRecord->finalAdaptation; // any brief glimpse
							// of the box should show the current adaptation, or gloss, string
#ifdef __WXMSW__
					// show the progress window again
					progDlg.Show(TRUE); 
					//prog.Update(); //prog.UpdateWindow(); // needed, otherwise window's
															// stat text items don't show
#endif
				}
				else
				{
					// no match, so this is has to be handled with user intervention via
					// the dialog
					CConsistencyCheckDlg dlg(pApp->GetMainFrame());
					dlg.m_bFoundTgtUnit = bFoundTgtUnit;
					dlg.m_bDoAutoFix = FALSE;
					dlg.m_pApp = pApp;
					dlg.m_pKBCopy = pKBCopy;
					dlg.m_pTgtUnit = pTU; // could be null
					dlg.m_finalAdaptation.Empty(); // initialize final chosen adaptation or gloss
					dlg.m_pSrcPhrase = pSrcPhrase;

                    // update the view to show the location where this source pile is, and
                    // put the phrase box there ready to accept user input indirectly from
                    // the dialog
					int nActiveSequNum = pSrcPhrase->m_nSequNumber;
					wxASSERT(nActiveSequNum >= 0);
					pApp->m_nActiveSequNum = nActiveSequNum; // added 16Apr09, should be okay
					// and is needed because CLayout::RecalcLayout() relies on the
					// m_nActiveSequNum value being correct
#ifdef _NEW_LAYOUT
					pLayout->RecalcLayout(pPhrases, keep_strips_keep_piles);
#else
					pLayout->RecalcLayout(pPhrases, create_strips_keep_piles);
#endif
					pApp->m_pActivePile = GetPile(nActiveSequNum);
					
					pApp->GetMainFrame()->canvas->ScrollIntoView(nActiveSequNum);
					CCell* pCell = pApp->m_pActivePile->GetCell(1); // the cell where
															 // the phraseBox is to be
					if (gbIsGlossing)
						pApp->m_targetPhrase = pSrcPhrase->m_gloss;
					else
						// make it look normal, don't use m_targetStr here
						pApp->m_targetPhrase = pSrcPhrase->m_adaption;

					GetLayout()->m_docEditOperationType = consistency_check_op;
														// sets 0,-1 'select all'
					Invalidate(); // get the layout drawn
					GetLayout()->PlaceBox();

					// get the chapter and verse
					wxString chVerse = GetChapterAndVerse(pSrcPhrase);
					dlg.m_chVerse = chVerse;

                    // provide hooks for the phrase box location so that the dialog can
                    // work out where to display itself so it does not obscure the active
                    // location
					dlg.m_ptBoxTopLeft = pCell->GetTopLeft(); // logical coords
					dlg.m_nTwoLineDepth = 2 * pLayout->GetTgtTextHeight();

					if (gbIsGlossing)
					{
						// really its three lines, but the code works provided the 
						// height is right
						if (gbGlossingUsesNavFont)
							dlg.m_nTwoLineDepth += pLayout->GetNavTextHeight();
					}

					// put up the dialog
					if (dlg.ShowModal() == wxID_OK)
					{
						//bool bNoError;
						wxString finalStr;
						// if the m_bDoAutoFix flag is set, add this 'fix' to a list for
						// subsequent use
						AutoFixRecord* pRec;
						if (dlg.m_bDoAutoFix)
						{
							if (gbIgnoreIt)
								// disallow record creation for a press of the "Ignore it,
								// I will fix it later" button
								goto x;
							pRec = new AutoFixRecord;
							pRec->key = pSrcPhrase->m_key; // case should be as wanted
							if (gbIsGlossing)
							{
								pRec->oldAdaptation = pSrcPhrase->m_gloss; // case as wanted
								pRec->nWords = 1;
							}
							else
							{
								pRec->oldAdaptation = pSrcPhrase->m_adaption; // case as wanted
								pRec->nWords = pSrcPhrase->m_nSrcWords;
							}

                            // BEW changed 16May; we don't want to convert the
                            // m_finalAdaptation member to upper case in ANY circumstances,
                            // so we will comment out the relevant lines here and
                            // unilaterally use the user's final string
							finalStr = dlg.m_finalAdaptation; // can have punctuation
									// in it, or can be null; can also be lower case and user
									// expects the app to switch it to upper case if source is upper
							pRec->finalAdaptation = finalStr;
							afList.Append(pRec);
						} // end of block for setting up a new AutoFixRecord

						// update the original kb (not pKBCopy)
x:						finalStr = dlg.m_finalAdaptation; // could have punctuation in it
                        // if the adaptation is null, then assume user wants it that way
                        // and so store an empty string; but if user wants the
                        // inconsistency ignored, then skip
						wxString tempStr = dlg.m_finalAdaptation;
						RemovePunctuation(pDoc,&tempStr,from_target_text);
						if (gbIgnoreIt)
						{
							// if the user hit the "Ignore it, I will fix it later" button,
							// then just put the existing adaptation or gloss back into the KB,
							// after clearing the flag
							if (gbIsGlossing)
							{
								tempStr = pSrcPhrase->m_gloss;
								StoreText(pKB,pSrcPhrase,tempStr,TRUE);
							}
							else // adapting
							{
								tempStr = pSrcPhrase->m_adaption; // no punctuation on this one
								StoreText(pKB,pSrcPhrase,tempStr,TRUE);
								MakeLineFourString(pSrcPhrase,pSrcPhrase->m_targetStr); 
																// m_targetStr may have punct
							}
							gbIgnoreIt = FALSE;
							goto y;
						}
						else
						{
							// don't ignore, so handle the dialog's contents
							if (tempStr.IsEmpty())
							{
								StoreText(pKB,pSrcPhrase,tempStr,TRUE); 
														// TRUE = allow empty string storage
							}
							else
							{
								if (!gbIsGlossing)
								{
									StoreText(pKB,pSrcPhrase,tempStr);
								}
								// do the gbIsGlossing case in next block
							}
                            // the next stuff is taken from code earlier than the DoModal()
                            // call, so comments will not be repeated here - see above if
                            // the details are wanted
							if (gbAutoCaps)
							{
								bool bNoError = SetCaseParameters(pSrcPhrase->m_key);
								if (bNoError && gbSourceIsUpperCase)
								{
									bNoError = SetCaseParameters(tempStr,FALSE); // FALSE 
															// means "it's target text"
									if (bNoError && !gbNonSourceIsUpperCase && 
										(gcharNonSrcUC != _T('\0')))
									{
										pSrcPhrase->m_adaption.SetChar(0,gcharNonSrcUC); 
															// get m_adaption member done
									}
								}
							}
							if (!gbIsGlossing)
							{
								MakeLineFourString(pSrcPhrase,finalStr); // handles 
													// auto caps, punctuation, etc
							}
							else // we are in glossing mode
							{
								StoreText(pKB,pSrcPhrase,finalStr); // glossing store
														// can have punctuation in it
								if (gbAutoCaps)
								{
									// if Auto Caps is on, gloss text can be auto 
									// capitalized too... check it out
									wxString str_nopunct = finalStr;
									RemovePunctuation(pDoc,&str_nopunct,from_target_text);
									bool bNoError = SetCaseParameters(str_nopunct,FALSE); // FALSE
															// means "using target punct list"
									wxString strInitialPunct = SpanIncluding(
														finalStr,pApp->m_punctuation[1]);
									int punctLen = strInitialPunct.Length();
									bNoError = SetCaseParameters(str_nopunct,FALSE); // FALSE 
															// means "using target punct list"
									if (bNoError && gbSourceIsUpperCase && !gbNonSourceIsUpperCase
										&& (gcharNonSrcUC != _T('\0')))
									{
										if (strInitialPunct.IsEmpty())
										{
											pSrcPhrase->m_gloss.SetChar(0,gcharNonSrcUC);
										}
										else
										{
											finalStr.SetChar(punctLen,gcharNonSrcUC);
											pSrcPhrase->m_gloss = finalStr;
										}
									}
								}
								else
								{
									pSrcPhrase->m_gloss = finalStr;
								}
							} // end of block for glossing mode
						} // end of else block for test: if (gbIgnoreIt)

						// show the progress window again
y:						;
#ifdef __WXMSW__
						progDlg.Show(TRUE);
#endif
					} // end of TRUE block for test of ShowModal() == wxID_OK
					else
					{
						// user cancelled
						bUserCancelled = TRUE;
#ifdef __WXMSW__
						progDlg.Show(TRUE);
						msgDisplayed = progMsg.Format(progMsg,newName.c_str(),counter,nTotal);
						progDlg.Update(counter,msgDisplayed);
#endif
						break;
					}
				} // end of else block for test of presence of an 
				  // AutoFixRecord for this inconsistency
			}
#ifdef __WXMSW_
			// update the progress bar every 20th iteration
			if (counter % 1000 == 0) //if (20 * (counter / 20) == counter)
			{
				//prog.m_progress.SetValue(counter);
				//prog.TransferDataToWindow(); //prog.UpdateData(FALSE);
				msgDisplayed = progMsg.Format(progMsg,newName.c_str(),counter,nTotal);
				progDlg.Update(counter,msgDisplayed);
			}
#endif
		}// end of while (pos1 != NULL)

		// save document and KB
		pApp->m_pTargetBox->Hide(); //MFC calls DestroyWindow(); // this prevents
                // DoFileSave() trying to store to kb with a source phrase with
                // m_bHasKBEntry flag TRUE, which would cause an assert to trip
		pApp->m_pTargetBox->ChangeValue(_T("")); // need to set it to null str
											  // since it won't get recreated
		bool bSavedOK = pDoc->DoFileSave(TRUE); // TRUE - show wait/progress dialog
		if (!bSavedOK)
		{
			wxMessageBox(_("Warning: failure on document save operation."),
			_T(""), wxICON_EXCLAMATION);
		}
		ClobberDocument();

		// delete the buffer containing the filed-in source text
		if (pApp->m_pBuffer != NULL)
		{
			delete pApp->m_pBuffer;
			pApp->m_pBuffer = NULL;
		}
#ifdef __WXMSW__
		// remove the progress indicator window
		progDlg.Destroy();
#endif
		if (bUserCancelled)
			break; // don't do any more saves of the KB if user cancelled
	}// end iteration of document files for (int i=0; i < nCount; i++)

	// erase the copied CKB which is no longer needed
	wxASSERT(pKBCopy != NULL);
	pDoc->EraseKB(pKBCopy); // don't want memory leaks!

	// inform user of success and some statistics
	if (!bUserCancelled)
	{
		// put up final statistics, provided user did not cancel from one
		// of the dialogs
		wxString stats;
		// IDS_CONSCHECK_OK
		stats = stats.Format(_(
"The consistency check was successful. There were %d source words and phrases  in %d  files."),
		nCumulativeTotal,nCount);
		wxMessageBox(stats,_T(""),wxICON_INFORMATION);
	}

	// make sure the global flag is cleared
	gbConsistencyCheckCurrent = FALSE;

	// delete the contents of the pointer list, the list is local 
	// so will go out of scope
	if (!afList.IsEmpty())
	{
		AFList::Node* pos = afList.GetFirst();
		wxASSERT(pos != 0);
		while (pos != 0)
		{
			AutoFixRecord* pRec = (AutoFixRecord*)pos->GetData();
			pos = pos->GetNext();
			delete pRec;
		}
	}
	afList.Clear();
	GetLayout()->m_docEditOperationType = consistency_check_op; // sets 0,-1 'select all'
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu is about
///                         to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the application is in Free Translation mode, or
/// Vertical Editing is in progress, or it is only showing the target language text, or the
/// active KB is not in a ready state, this handler disables the "Consistency Check..."
/// item in the Edit menu, otherwise it enables the "Consistency Check..." item on the Edit
/// menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditConsistencyCheck(wxUpdateUIEvent& event)
{
	CAdapt_ItDoc* pDoc = GetDocument();
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pDoc == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	bool bKBReady = FALSE;
	if (gbIsGlossing)
		bKBReady = pApp->m_bGlossingKBReady;
	else
		bKBReady = pApp->m_bKBReady;
	// Allow Consistency Check... while document is open
	if (bKBReady)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::DoFileSaveKB()
{
	wxCommandEvent dummyevent;
	OnFileSaveKB(dummyevent); // protected, so make it accessible
}

void CAdapt_ItView::NewRetranslation()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxCommandEvent dummyevent;
	if (gbShowTargetOnly)
	{
		::wxBell();
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		::wxBell();
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
        // if there is at least one srcPhrase with m_bRetranslation == TRUE, then disable
        // the button
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CCell* pCell = (CCell*)pos->GetData();
			CPile* pPile = pCell->GetPile();
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
			if (pSrcPhrase->m_bRetranslation)
			{
				::wxBell(); 
				return;
			}
		}
		OnButtonRetranslation(dummyevent);
		return;
	}
	::wxBell();
}

/////////////////////////////////////////////////////////////////////////////////
//
// Begin section for OnButtonRetranslation()
//
// Helper functions used in OnButtonRetranslation(); these are 
// (in the order in which they get called):
//
// GetSelectedSourcePhraseInstances()
// CopySourcePhraseList()
// RemoveNullSourcePhraseFromLists()
// UnmergeMergersInSublist()
// TokenizeTextString()
// BuildRetranslationSourcePhraseInstances()
// DeleteSavedSrcPhraseSublist()
// PadWithNullSourcePhrasesAtEnd()
// SetActivePilePointerSafely()
// ClearSublistKBEntries()
// InsertSublistAfter()
// RemoveUnwantedSourcePhraseInstancesInRestoredList()
// RestoreTargetBoxText()
//
/////////////////////////////////////////////////////////////////////////////////

// pList is the list of selected CSourcePhrase instances; pSrcPhrases is the full list
// maintained on the app; strSource is the accumulated source text, strAdapt is the
// accumulated target text (both with punctuation). The pList will only contain copies of
// the pointers to the CSourcePhrase instances on the heap.
void CAdapt_ItView::GetSelectedSourcePhraseInstances(SPList*& pList,
										 wxString& strSource, wxString& strAdapt)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxString str; str.Empty();
	wxString str2; str2.Empty();
	CCellList::Node* pos = pApp->m_selection.GetFirst(); 
	CCell* pCell = (CCell*)pos->GetData();
	CPile* pPile = pCell->GetPile(); // get the pile first in selection
	pos = pos->GetNext(); // needed for our CCellList list
	CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();

	pList->Append(pSrcPhrase); // add first to the temporary list
	if (pSrcPhrase->m_targetStr.IsEmpty())
	{
		if (pPile == pApp->m_pActivePile)
		{
			str = pApp->m_targetPhrase;
		}
		else
		{
			str.Empty();
		}
	}
	else
	{
		str = pSrcPhrase->m_targetStr;
	}
	strAdapt += str;

	// accumulate the source language key text, provided it is not a null source phrase
	if (!pSrcPhrase->m_bNullSourcePhrase)
		str2 = pSrcPhrase->m_srcPhrase;
	strSource += str2; // accumulate it

    // fill the list, accumulating any translation text already in the selected source
    // phrases and also the original text (with punctuation) which is to be retranslated
	while (pos != NULL)
	{
 		CCell* pCell = (CCell*)pos->GetData();
		pPile = pCell->GetPile();
		pos = pos->GetNext(); // needed for our list
		pSrcPhrase = pPile->GetSrcPhrase();
		wxASSERT(pSrcPhrase);
		pList->Append(pSrcPhrase);

		// accumulate any adaptation
		if (pSrcPhrase->m_targetStr.IsEmpty())
		{
			if (pPile == pApp->m_pActivePile)
			{
				str = pApp->m_targetPhrase;
			}
			else
			{
				str.Empty();
			}
		}
		else
		{
			str = pSrcPhrase->m_targetStr;
		}

		if (strAdapt.IsEmpty())
			strAdapt += str;
		else
		{
			if (!str.IsEmpty())
				strAdapt = strAdapt + _T(" ") + str;
		}

		// accumulate the source language text, 
		// provided it is not a null source phrase
		if (!pSrcPhrase->m_bNullSourcePhrase)
			str2 = pSrcPhrase->m_srcPhrase;
		else
			str2.Empty();
		if (strSource.IsEmpty())
			strSource += str2;
		else
			strSource = strSource + _T(" ") + str2; // space before a 
				// marker will -> CR+LF on Export...
	}
}

// pList is the list to be copied, pCopiedList contains the copies
// Note: the default is a shallow copy; any heap instances of CSourcePhrases which are
// pointed at by elements in the m_pSavedWords list in pList, are also pointed at by
// the copies of elements in the m_pSavedWords list of CSourcePhrase instances in
// pCopiedList. This has implications when destroying such a copied list. For a true
// deep copy of a list of CSourcePhrase instances, the bDoDeepCopy flag must be TRUE. A
// deep copy produces a copied list, pCopiedList, in which everything is a duplicate of
// what was in the original list, and hence every original CSourcePhrase of a merger is
// pointed at by a CSourcePhrase in only one of the pList and pCopiedList lists.
// BEW modified 16Apr08 to enable it to optionally do a deep copy
void CAdapt_ItView::CopySourcePhraseList(SPList*& pList,SPList*& pCopiedList,
										 bool bDoDeepCopy)
{
	SPList::Node* pos = pList->GetFirst(); // original list
	while (pos != NULL)
	{
		CSourcePhrase* pElement = (CSourcePhrase*)pos->GetData(); // original source phrase
		pos = pos->GetNext();// needed for our list
		CSourcePhrase* pNewSrcPhrase = new CSourcePhrase(*pElement); // uses operator=
		wxASSERT(pNewSrcPhrase != NULL);
		if (bDoDeepCopy)
		{
			pNewSrcPhrase->DeepCopy();
		}
		pCopiedList->Append(pNewSrcPhrase); 
	}
}

// BEW added 16Apr08; pList is a passed in list of CSourcePhrase pointers, such as
// m_pSourcePhrases; parameters two and three define which part of the passed in list is
// used for doing the deep copies, and the pCopiedSublist passes the sublist back to the
// caller. Normally pCopiedSublist will be empty when passed in, but it does not have to
// be. Internally AddTail() is used, and so the function can also be used to append deep
// copies to an existing sublist of deep copies (but I've no plans to do the latter, at
// least none yet).
// returns TRUE if there was no error, FALSE if there was an error
bool CAdapt_ItView::DeepCopySourcePhraseSublist(SPList* pList, int nStartingSequNum, 
								int nEndingSequNum, SPList* pCopiedSublist)
{
	wxString errStr;
    // it is the caller's responsibility to ensure that nStartingSequNum and nEndingSequNum
    // are valid indexes into the pList list
	SPList::Node* pos = pList->Item(nStartingSequNum);
	if (pos == NULL)
	{
		// error condition exists
		// whm Note: Leave these error strings untranslated; not for localization
		errStr = _T(
"DeepCopySourcePhraseSublist() returned NULL for POSITION pos on .FindIndex() call. Saving document. ");
		errStr += _T(
		"Edit process abandoned. Document restored to pre-edit state.");
		wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	SPList::Node* endpos = pList->Item(nEndingSequNum);
	if (endpos == NULL)
	{
		// error condition exists
		errStr = _T(
"DeepCopySourcePhraseSublist() returned NULL for POSITION endpos on .FindIndex() call. Saving document. ");
		errStr += _T(
		"Edit process abandoned. Document restored to pre-edit state.");
		wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}
	
	SPList::Node* savePos = NULL; // POSITION savePos = NULL;
	CSourcePhrase* pSrcPhrase = NULL;
	while (pos != NULL)
	{
		savePos = pos;
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
        // whm Checked that the CSourcePhrase(*pSrcPhrase) call below actually does use
        // operator= shallow copy in wx version. Probably wouldn't make any difference in
        // this case since DeepCopy() is called on pNewSP immediately after creation of
        // pNewSP.
		CSourcePhrase* pNewSP = new CSourcePhrase(*pSrcPhrase); // uses operator=, 
																// does shallow copy
		pNewSP->DeepCopy(); // pNewSP is now a deep copy
		pCopiedSublist->Append(pNewSP);
		if (savePos == endpos)
		{
			// we have just added the final deep copy to pCopiedSublist, so break out
			break;
		}
	}
	return TRUE;
}

// pList is the sublist of (formerly) selected source phrase instances, pSrcPhrases is the
// document's list (the whole lot), endIndex upperIndex, maxIndex are references to member
// indices on the view, nCount is the count of elements in pList (it will be reduced as
// each null source phrase is eliminated), bActiveLocAfterSelection is a flag in the
// caller, nSaveActiveSequNum is the caller's saved value for the active sequence number
void CAdapt_ItView::RemoveNullSrcPhraseFromLists(SPList*& pList,SPList*& pSrcPhrases,
							int& nCount,int& nEndSequNum,bool bActiveLocAfterSelection,
							int& nSaveActiveSequNum)
{
	// refactored 16Apr09
	// find the null source phrase in the sublist
	CRefString* pRefString = 0;
	SPList::Node* pos = pList->GetFirst();
	while (pos != NULL)
	{
		SPList::Node* savePos = pos;
		CSourcePhrase* pSrcPhraseCopy = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext(); 
		wxASSERT(pSrcPhraseCopy != NULL);
		if (pSrcPhraseCopy->m_bNullSourcePhrase)
		{
            // we've found a null source phrase in the sublist, so get rid of its KB
            // presence, then delete it from the (temporary) sublist, and its instance from
            // the heap
			pRefString = GetRefString(GetKB(),pSrcPhraseCopy->m_nSrcWords,
										pSrcPhraseCopy->m_key,pSrcPhraseCopy->m_adaption);
			if (pRefString != NULL)
			{
				// don't care about m_bHasKBEntry flag value, since pSrcPhraseCopy will be
				// deleted next
				RemoveRefString(pRefString,pSrcPhraseCopy,pSrcPhraseCopy->m_nSrcWords);
			}
			delete pSrcPhraseCopy;
			pSrcPhraseCopy = (CSourcePhrase*)NULL;
			pList->DeleteNode(savePos); 

            // the main list on the app still stores the (now hanging) pointer, so find
            // where it is and remove it from that list too
			SPList::Node* mainPos = pSrcPhrases->GetFirst();
			wxASSERT(mainPos != 0);
			mainPos = pSrcPhrases->Find(pSrcPhraseCopy); // search from the beginning
			wxASSERT(mainPos != NULL); // it must be there somewhere

			// BEW added 13Mar09 for refactor of layout; delete its partner pile too 
			GetDocument()->DeletePartnerPile(pSrcPhraseCopy);
			pSrcPhrases->DeleteNode(mainPos); 

			nCount -= 1; // since there is one less source phrase in the selection now
			nEndSequNum -= 1;
			if (bActiveLocAfterSelection)
				nSaveActiveSequNum -= 1;

            // now we have to renumber the source phrases' sequence number values - since
            // the temp sublist list has pointer copies, we need only do this in the main
            // list using a call to UpdateSequNumbers, and so the value of nSaveSequNum
            // will still be correct for the first element in the sublist - even if there
            // were deletions at the start of the sublist
			UpdateSequNumbers(0); // start from the very first in the list to be safe
		}
	}
}

// same parameters as for RemoveNullSourcePhraseFromLists(), except the second last boolean
// is added in order to control whether m_bRetranslation gets set or not; for
// retranslations we want it set, for editing the source text we want it cleared; and the
// last boolean controls whether or not we also update the sublist passed as the first
// parameter - for a retranslation we don't update it, because the caller will make no more
// use of it; but for an edit of the source text, the caller needs it updated because it
// will be used later when the transfer of standard format markers, if any, is done.
void CAdapt_ItView::UnmergeMergersInSublist(SPList*& pList, SPList*& pSrcPhrases, 
							int& nCount, int& nEndSequNum, bool bActiveLocAfterSelection, 
							int& nSaveActiveSequNum, bool bWantRetranslationFlagSet, 
							bool bAlsoUpdateSublist)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	int nNumElements = 1;
	CRefString* pRefString = (CRefString*)NULL;
	SPList::Node* pos = pList->GetFirst();
	int nTotalExtras = 0; // accumulate the total number of extras added by unmerging,
						  // this will be used if the updating of the sublist is asked for
	int nInitialSequNum = pos->GetData()->m_nSequNumber; // preserve this
														// for sublist updating
	while (pos != NULL)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		int nStartingSequNum = pSrcPhrase->m_nSequNumber;
		nNumElements = 1;
		if (pSrcPhrase->m_nSrcWords > 1)
		{
            // have to restore to original state (RestoreOriginalMinPhrases also appends
            // any m_translation in the CRefString object to pApp->m_targetPhrase, but we
            // don't care about that here as we will abandon pApp->m_targetPhrase's
            // contents anyway)
			nNumElements = RestoreOriginalMinPhrases(pSrcPhrase,nStartingSequNum);

            // RestoreOriginalMinPhrases accumulates any m_adaptation text into the view's
            // pApp->m_targetPhrase attribute, which is fine when doing an unmerge of a
            // single merged phrase, but it is not fine in preparing a retranslation. The
            // reason is that if there are a lot of merged phrases in the selection and if
            // these have existing translations in them, unmerging them will result in the
            // accumulation of a very long pApp->m_targetPhrase. When we then get to the
            // RecalcLayout call below, it will rebuild the strips and eventually one of
            // the pile's will have a source phrase with sequence number equalling the old
            // active location's sequence number; but in the unmerging process, the
            // m_adaptation field is cleared for each sourcePhrase, and so when
            // CalcPileWidth is called at the point when the old active pile is reached,
            // the "else" block is used for calculating the text extent because
            // m_adaptation is empty. Unfortunately, the else block calculated the extent
            // by looking at the contents of pApp->m_targetPhrase, as set up by the
            // unmerges being done now - the result is a huge pile width, and this would
            // lead to a crash when the endIndex is reached - since no source phrases can
            // be laid out due to the spurious large pileWidth value. The solution is to
            // clean out the contents of pApp->m_targetPhrase after each call of
            // RestoreOriginalMinPhrases above, so that the caluculated pileWidth values
            // will be correct. So we do it now, where it makes sense - though it could
            // instead be done just once before the RecalcLayout call.
            // RestoreOriginalMinPhrases does its own KB clearance of the translations for
            // the phrases being unmerged.
			pApp->m_targetPhrase.Empty();

			// update nCount etc.
			int nExtras = nNumElements - 1;
			nTotalExtras += nExtras;
			nCount += nExtras;
			nEndSequNum += nExtras;
			if (bActiveLocAfterSelection)
				nSaveActiveSequNum += nExtras;

            // set the flags on the restored original min phrases (the pointers to the
            // piles are clobbered, but the sequence in the m_pSourcePhrases list is
            // restored, so access these)
			for (int i = nStartingSequNum; i <= nStartingSequNum + nExtras; i++)
			{
				// here POSITION pos is redefined in a subscope of the one above
				SPList::Node* pos = pSrcPhrases->Item(i);
				wxASSERT(pos != NULL);
				CSourcePhrase* pSPh = (CSourcePhrase*)pos->GetData();
				pSPh->m_bHasKBEntry = FALSE;
				if (bWantRetranslationFlagSet)
				{
					pSPh->m_bRetranslation = TRUE;
					pSPh->m_bNotInKB = TRUE;
				}
				else
				{
					pSPh->m_bRetranslation = FALSE;
					pSPh->m_bNotInKB = FALSE;
				}
				pSPh->m_adaption.Empty();  // ensure its clear for later on
				pSPh->m_targetStr.Empty(); // ditto
			}
		}
		else
		{
			//  remove the refString from the KB, etc.
			pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key,pSrcPhrase->m_adaption);
            // it is okay to do the following call with pRefString == NULL, in fact, it
            // must be done whether NULL or not; since if it is NULL, RemoveRefString will
            // clear pSrcPhrase's m_bHasKBEntry to FALSE, which if not done, would result
            // in a crash if the user clicked on a source phrase which had its reference
            // string manually removed from the KB and then clicked on another source
            // phrase. (The StoreAdaption call in the second click would trip the first
            // line's wxASSERT.)
			RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

			// we must abandon any existing adaptation text
			pSrcPhrase->m_adaption.Empty();
			pSrcPhrase->m_bNotInKB = TRUE;
			if (bWantRetranslationFlagSet)
			{
				pSrcPhrase->m_bRetranslation = TRUE;
				pSrcPhrase->m_bNotInKB = TRUE;
			}
			else
			{
				pSrcPhrase->m_bRetranslation = FALSE;
				pSrcPhrase->m_bNotInKB = FALSE;
			}
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pSrcPhrase->m_targetStr.Empty();
		}
	}

    // do the sublist updating, if required (this just clears the list and then puts copied
    // pointers into the sublist, so no partner pile creation needed here
	if (bAlsoUpdateSublist)
	{
		int nOldCount = pList->GetCount();
		wxASSERT(nOldCount);
		pList->Clear(); // clear the old list of pointer
		// again POSITION pos is redefined in a subscope
		SPList::Node* pos = pSrcPhrases->Item(nInitialSequNum);
		int nNewCount = nOldCount + nTotalExtras;
		CSourcePhrase* pSrcPhrase = 0;
		int index;
		for (index = 0; index < nNewCount; index++)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase);
			pList->Append(pSrcPhrase);
		}
	}
}

void CAdapt_ItView::BuildRetranslationSourcePhraseInstances(SPList* pRetransList,
						int nStartSequNum,int nNewCount,int nCount,int& nFinish)
{
	// BEW refactored 16Apr09
	CAdapt_ItDoc* pDoc = GetDocument();
	int nSequNum = nStartSequNum - 1;
	nFinish = nNewCount < nCount ? nCount : nNewCount;
	for (int j=0; j<nFinish; j++)
	{
		nSequNum++;
		CPile* pPile = GetPile(nSequNum); // needed, because the InsertNullSourcePhrase()
										  // clobbered ptrs and so did a RecalcLayout()
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pPile->GetSrcPhrase(); // update this one

		if (j == 0)
		{
			// mark the first one
			pSrcPhrase->m_bBeginRetranslation = TRUE;
			pSrcPhrase->m_bEndRetranslation = FALSE;
		}
		else if (j == nFinish - 1)
		{
			// mark the last one
			pSrcPhrase->m_bEndRetranslation = TRUE;
			pSrcPhrase->m_bBeginRetranslation = FALSE;
		}
		else
		{
			// play safe, ensure any others have both flags cleared
			pSrcPhrase->m_bBeginRetranslation = FALSE;
			pSrcPhrase->m_bEndRetranslation = FALSE;
		}

		if (j < nNewCount)
		{
			// there will be a retranslation word available only when j < nNewCount
			SPList::Node* pos = pRetransList->Item(j);
			CSourcePhrase* pIncompleteSrcPhrase = (CSourcePhrase*)pos->GetData();
			wxASSERT(pIncompleteSrcPhrase != NULL);

            // copy the text across (these "source phrases" actually contain target text in
            // the attributes which otherwise would hold source text, due to the use of
            // TokenizeText for parsing what the user typed)
			pSrcPhrase->m_targetStr = pIncompleteSrcPhrase->m_srcPhrase; //with punctuation
			RemovePunctuation(pDoc,&pIncompleteSrcPhrase->m_key,from_target_text);
			pSrcPhrase->m_adaption = pIncompleteSrcPhrase->m_key;
			//check that all is well
			wxASSERT(pSrcPhrase->m_nSequNumber == pIncompleteSrcPhrase->m_nSequNumber);

			// BEW added 13Mar09 for refactored layout
			pDoc->ResetPartnerPileWidth(pSrcPhrase); // resets width and marks the
													 // owning strip invalid
		}

        // if nNewCount was less than nCount, we must clear any old punctuation off the
        // unused source phrases at the end of the selection (we will leave markers
        // untouched) so that the typed punctuation effectively overrides that on the
        // source
		if (j >= nNewCount)
		{
			pDoc->ResetPartnerPileWidth(pSrcPhrase);
		}
	}
}

// Tokenize the string str storing the CSourcePhrase instances (only m_strSource &
// m_nSequNumber are set) in pNewList. nInitialSequNum is what will be used for the
// sequence number of the first element tokenized
int CAdapt_ItView::TokenizeTextString(SPList* pNewList, wxString& str, int nInitialSequNum)
{
	CAdapt_ItDoc* pDoc = GetDocument();
	int	length = str.Length();
	if (!str.IsEmpty())
	{
		return pDoc->TokenizeText(nInitialSequNum,pNewList,str,length);
	}
	else
		return 0;
}

void CAdapt_ItView::DeleteSavedSrcPhraseSublist(SPList* pSaveList)
{
	// refactor 13Mar09; these are shallow copies, and have no partner piles, 
	// so nothing to do here
	if (pSaveList->GetCount() > 0)
	{
		SPList::Node* pos = pSaveList->GetFirst(); 
		wxASSERT(pos != 0);
		while (pos != 0)
		{
			CSourcePhrase* pSP = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (pSP != NULL)
			{
				// don't want memory leaks
				delete pSP->m_pMedialMarkers;
				pSP->m_pMedialMarkers = (wxArrayString*)NULL;
				delete pSP->m_pMedialPuncts;
				pSP->m_pMedialPuncts = (wxArrayString*)NULL;
				pSP->m_pSavedWords->Clear(); // remove pointers only
				delete pSP->m_pSavedWords;
				pSP->m_pSavedWords = (SPList*)NULL;
				delete pSP;
				pSP = (CSourcePhrase*)NULL;
			}
		}
		pSaveList->Clear();
	}
	delete pSaveList; // don't leak memory
	pSaveList = (SPList*)NULL;
}

// The padding is done in the main list of source phrases, on the [App]. pSrcPhrases is the
// pointer to this list; nEndSequNumber is the sequence number of the last CSourcePhrase
// instance of the selected source text (and the padding is required when there are more
// words in the target text than the source piles can accomodate). nNewCount is the number
// of target text words - it could be less, more, or the same as the number piles selected
// (we test internally and act accordingly), and nCount is the number of CSourcePhrase
// instances after all nulls removed, and mergers unmerged. We have to be careful if
// nEndSequNumber is equal to GetMaxIndex() value, because insertion of null source phrases
// has to take place before a sourcephrase instance which would not exist, so we must
// detect this and temporarily add an extra CSourcePhrase instance at the end of the main
// list, do the insertions preceding it, then remove it.
void CAdapt_ItView::PadWithNullSourcePhrasesAtEnd(CAdapt_ItDoc* pDoc,CAdapt_ItApp* pApp,
						SPList* pSrcPhrases,int nEndSequNum,int nNewCount,int nCount)
{
	// refactored 16Apr09
	int nEndIndex = 0;
	int nSaveActiveSN = pApp->m_nActiveSequNum;
	if (nNewCount > nCount)
	{
		// null source phrases are needed for padding
		int nExtras = nNewCount - nCount;

        // check we are not at the end of the list of CSourcePhrase instances, if we are we
        // will have to add an extra one so that we can insert before it, then remove it
        // later.
		if (nEndSequNum == pApp->GetMaxIndex())
		{
            // we are at the end, so we must add a dummy sourcephrase; note,
            // m_nActiveSequNum and the caller's nSaveActiveSequNum values will almost
            // certainly be greater than GetMaxIndex() value, and so we must not use these
            // until we adjust them in the caller later on. So we can ignore the active
            // location, and just temporarily treat it as the last pile in the document.
			CSourcePhrase* pDummySrcPhrase = new CSourcePhrase;
			pDummySrcPhrase->m_srcPhrase = _T("dummy"); // something needed, so a pile width
														// can be computed
			pDummySrcPhrase->m_key = pDummySrcPhrase->m_srcPhrase;
			nEndIndex = pApp->GetMaxIndex() + 1;
			pDummySrcPhrase->m_nSequNumber = nEndIndex;
			SPList::Node* posTail;
			posTail = pSrcPhrases->Append(pDummySrcPhrase); 

			// we need a valid layout which includes the new dummy element on its own pile
			pApp->m_nActiveSequNum = nEndIndex; // temporary location only
#ifdef _NEW_LAYOUT
			GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
			GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum); // temporary active location

			// now we can do the insertions, preceding the dummy end pile
			CPile* pPile = GetPile(nEndIndex);
			wxASSERT(pPile != NULL);
			InsertNullSourcePhrase(pDoc,pApp,pPile,nExtras,FALSE,TRUE); // FALSE for restoring
				// the phrase box, TRUE for doing it for a retranslation, and default TRUE for
				// bInsertBefore flag at end

			// now remove the dummy element, and make sure memory is not leaked!
			delete pDummySrcPhrase->m_pSavedWords;
			pDummySrcPhrase->m_pSavedWords = (SPList*)NULL;
			delete pDummySrcPhrase->m_pMedialMarkers;
			pDummySrcPhrase->m_pMedialMarkers = (wxArrayString*)NULL;
			delete pDummySrcPhrase->m_pMedialPuncts;
			pDummySrcPhrase->m_pMedialPuncts = (wxArrayString*)NULL;
			SPList::Node *pLast = pSrcPhrases->GetLast();
			pSrcPhrases->DeleteNode(pLast);
			delete pDummySrcPhrase;

			// get another valid layout
			pApp->m_nActiveSequNum = nSaveActiveSN; // restore original location
		}
		else
		{
            // not at the end, so we can proceed immediately; get the insertion location's
            // pile pointer
			CPile* pPile = GetPile(nEndSequNum + 1); // nEndIndex is out of scope here
			wxASSERT(pPile != NULL);
			InsertNullSourcePhrase(pDoc,pApp,pPile,nExtras,FALSE,TRUE); // FALSE is for 
					// restoring the phrase box, TRUE is for doing it for a retranslation
			pApp->m_nActiveSequNum = nSaveActiveSN;
		}
	}
	else
		; // no padding needed
}

void CAdapt_ItView::ClearSublistKBEntries(SPList* pSublist)
{
	SPList::Node* pos = pSublist->GetFirst();
	while (pos != NULL)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key,pSrcPhrase->m_adaption);
        // it is okay to do the following call with pRefString == NULL, the function will
        // just exit early, having done nothing
		RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);
		pSrcPhrase->m_bRetranslation = FALSE; // make sure its off
		pSrcPhrase->m_bHasKBEntry = FALSE;	  // ditto
	}
}

void CAdapt_ItView::InsertSublistAfter(SPList* pSrcPhrases, SPList* pSublist, int nLocationSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	SPList::Node* pos = pSrcPhrases->Item(nLocationSequNum);
	wxASSERT(pos != 0);
	SPList::Node* pos1 = pSublist->GetLast();
	wxASSERT(pos1 != 0);
	// Get a node called posNextHigher which points to the next node beyond pos
	// in pSrcPhrases and use its position in the Insert() call (which only inserts
	// BEFORE the indicated position). The result should be that the insertions
	// will get placed in the list the same way that MFC's InsertAfter() places them.
	SPList::Node* newInsertBeforePos = pos->GetNext();
	while (pos1 != 0)
	{
		CSourcePhrase* pSPhr = (CSourcePhrase*)pos1->GetData();
		pos1 = pos1->GetPrevious();
		wxASSERT(pSPhr != NULL);
		// wxList has no equivalent to InsertAfter(). The wxList Insert() method
		// inserts the new node BEFORE the current position/node. To emulate what
		// the MFC code does, we insert before using newInsertBeforePos.
		// wx note: If newInsertBeforePos is NULL, it means the insert position is
		// at the end of the list; in this case we just append the item to the end
		// of the list.
		if (newInsertBeforePos == NULL)
			pSrcPhrases->Append(pSPhr);
		else
			pSrcPhrases->Insert(newInsertBeforePos,pSPhr);

		// BEW added 13Mar09 for refactored layout
		GetDocument()->CreatePartnerPile(pSPhr);

		// since we must now insert before the inserted node above, we need to get a
		// previous node (which will actually be the just inserted source phrase)
		newInsertBeforePos = newInsertBeforePos->GetPrevious();

		// If the m_bNotInKB flag is FALSE, we must re-store the translation in
		// the KB. We can get the former translation string from the m_adaption member.
		if (!pSPhr->m_bNotInKB && !pSPhr->m_adaption.IsEmpty())
		{
			bool bOK = StoreText(pApp->m_pKB,pSPhr,pSPhr->m_adaption);
			if (!bOK)
			{
				// never had a problem here, so this message can stay in English
				wxMessageBox(_T(
			"Warning: redoing the StoreText operation failed in OnButtonRetranslation\n"),
				_T(""), wxICON_EXCLAMATION);
			}
		}
	}
}

// pSrcPhrases is the document's list; nCurCount is how many elements are now in the
// 'selection' as modified by removing all nulls and unmerging all mergers,
// nStartingSequNum is where the checking will start for doing the removals of those
// determined to be unwanted, and pSublist is the pointer to the sublist which stores the
// original elements we are in the process of restoring to the main list on the app
void CAdapt_ItView::RemoveUnwantedSourcePhraseInstancesInRestoredList(SPList* pSrcPhrases,
									 int nCurCount, int nStartingSequNum,SPList* pSublist)
{
	SPList::Node* pos = pSrcPhrases->Item(nStartingSequNum); // first one's position
	int count = 0;
	while (pos != NULL && count < nCurCount)
	{
		SPList::Node* savePos = pos;
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);

		// BEW added 13Mar09 for refactor of layout; delete its partner pile too 
		GetDocument()->DeletePartnerPile(pSrcPhrase);

        // before we can delete it, we must check it's not one of those (minimal) source
        // phrases which is in the sublist of a merged source phrase in the saved list - if
        // we deleted it, we'd be deleting something we must retain; but we would want to
        // remove it's pointer from the list (because it's to be accessed only by the
        // m_pSavedWords sublist of whichever merged source phrase was formed from it)
		bool bCanDelete = TRUE;
		SPList::Node* posSaveList = pSublist->GetFirst();
		wxASSERT(posSaveList != 0);
		while (posSaveList != 0)
		{
			CSourcePhrase* pSP = (CSourcePhrase*)posSaveList->GetData();
			posSaveList = posSaveList->GetNext();
			wxASSERT(pSP != 0);
			if (pSP->m_nSrcWords == 1)
				continue; // its a copy without a sublist, so ignore it
			else
			{
                // its a copy with a sublist, so see if any source phrase in the sublist is
                // a match for the one we wish to delete; if it is, don't delete it, just
                // remove its pointer from the m_pSourcePhrases list only
				SPList* pL = pSP->m_pSavedWords;
				wxASSERT(pL->GetCount() > 1);
				SPList::Node* pos4 = pL->GetFirst(); 
				wxASSERT(pos4 != 0);
				while (pos4 != 0)
				{
					CSourcePhrase* pSPhr = (CSourcePhrase*)pos4->GetData();
					pos4 = pos4->GetNext();
					wxASSERT(pSPhr != 0);
					if (pSPhr == pSrcPhrase)
					{
						// we have a match
						bCanDelete = FALSE;
						break;
					}
				}
			}
		}
		if (bCanDelete)
		{
			if (pSrcPhrase->m_pMedialMarkers->GetCount() > 0)
			{
				pSrcPhrase->m_pMedialMarkers->Clear(); // can clear the strings safely
			}
			delete pSrcPhrase->m_pMedialMarkers;
			pSrcPhrase->m_pMedialMarkers = (wxArrayString*)NULL;

			if (pSrcPhrase->m_pMedialPuncts->GetCount() > 0)
			{
				pSrcPhrase->m_pMedialPuncts->Clear(); // can clear the strings safely
			}
			delete pSrcPhrase->m_pMedialPuncts;
			pSrcPhrase->m_pMedialPuncts = (wxArrayString*)NULL;

			// don't delete any saved CSourcePhrase instances forming a phrase (and these
			// will never have medial puctuation nor medial markers nor will they store
			// any saved minimal phrases since they are CSourcePhrase instances for single
			// words only) - just clear the pointers
			if (pSrcPhrase->m_pSavedWords->GetCount() > 0)
			{
				pSrcPhrase->m_pSavedWords->Clear(); // just remove the pointers
			}
			delete pSrcPhrase->m_pSavedWords;		// and delete the list from the heap
			pSrcPhrase->m_pSavedWords = (SPList*)NULL;

			// finally delete the source phrase copy itself
			delete pSrcPhrase;
			pSrcPhrase = (CSourcePhrase*)NULL;

			// remove its pointer from the list
			pSrcPhrases->DeleteNode(savePos); 

			// augment the count of how many have been removed
			count++;
		}
		else
		{
			// this is one we cannot delete, but must just remove its pointer from the list
			pSrcPhrases->DeleteNode(savePos);

			// augment the count of how many have been removed
			count++;
		}
	}
}

// the pSrcPhrase supplied by the caller will be a newly created one, and therefore all its
// flags will have default values, and in particular the m_adaption and m_targetStr
// attributes will both be empty. So we must invoke a lookup of the single source word at
// the box location (which will be at the start of the new source text) in the KB to find a
// suitable adaptation to put in the target box; and this may, if there is more than one
// possible adaptation available, put up the Choose Translation dialog. (We can pinch
// suitable code from OnButtonRestore() and modify it a bit for here.) We set str in this
// function, and the caller then takes that and assigns it to pApp->m_targetPhrase.
// Modified, July 2003, for auto capitalization support
void CAdapt_ItView::RestoreTargetBoxText(CSourcePhrase* pSrcPhrase,wxString& str)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	bool bGotTranslation;
	bool bNoError = TRUE;
	if (gbAutoCaps)
	{
		bNoError = SetCaseParameters(pSrcPhrase->m_key);
	}

    // although this function strictly speaking is not necessarily invoked in the context
    // of an unmerge, the gbUnmergeJustDone flag being TRUE gives us the behaviour we want;
    // ie. we certainly DON'T want OnButtonRestore() called from here!
	gbUnmergeJustDone = TRUE; // prevent second OnButtonRestore() call from within
						// ChooseTranslation() within LookUpSrcWord() if user happens to
						// cancel the Choose Translation dialog (see CPhraseBox code)
	bGotTranslation = pApp->m_pTargetBox->LookUpSrcWord(this,pApp->m_pActivePile);
	gbUnmergeJustDone = FALSE; // clear flag to default value, since it is a global boolean
	wxASSERT(pApp->m_pActivePile); // it was created in the caller just prior to this
								   // function being called 
	if (bGotTranslation)
	{
        // we have to check here, in case the translation it found was a "<Not In KB>" - in
        // which case, we must display m_targetStr and ensure that the pile has an asterisk
        // above it, etc
		if (translation == _T("<Not In KB>"))
		{
			str.Empty(); // phrase box must be shown empty
			pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
			pApp->m_pActivePile->GetSrcPhrase()->m_bNotInKB = TRUE;
			str = pApp->m_pActivePile->GetSrcPhrase()->m_targetStr;
		}
		else
		{
			str = translation; // set using the global var, set in LookUpSrcWord call
		}

		if (gbAutoCaps && gbSourceIsUpperCase)
		{
			bNoError = SetCaseParameters(str,FALSE);
			if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
			{
				// change first letter to upper case
				str.SetChar(0, gcharNonSrcUC);
			}
		}
	}
	else // no translation found
	{
		// do the copy of source instead, or nothing if Copy Source flag is not set
		if (pApp->m_bCopySource)
		{
			// copy source key
			str = CopySourceKey(pApp->m_pActivePile->GetSrcPhrase(),pApp->m_bUseConsistentChanges);
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
		}
		else
		{
			str.Empty();
		}
	}
}

void CAdapt_ItView::OnButtonRetranslation(wxCommandEvent& event)
{
	// refactored 16Apr09
    // Since the Do a Retranslation toolbar button has an accelerator table hot key (CTRL-R
    // see CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even
    // when they are disabled, we must check for a disabled button and return if disabled.
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_RETRANSLATION))
	{
		::wxBell();
		return;
	}

	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_(
		"This particular operation is not available when you are glossing."),
		_T(""), wxICON_INFORMATION);
		return;
	}
	SPList* pList = new SPList; // list of the selected CSourcePhrase objects 
	wxASSERT(pList != NULL);
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile = NULL;

    // determine the active sequ number, so we can determine whether or not the active
    // location lies within the selection (if its not in the selection, we will need to
    // recreate the phrase box at the former active location when done - be careful,
    // because if the active location lies after the selection and the selection contains
    // null src phrases or merged phrases, then the value of nFormerActiveSequNum will need
    // to be updated as we remove null src phrases and / or unmerge merged phrases)
	int nSaveActiveSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;

	CSourcePhrase* pSrcPhrase;
	wxString strAdapt; // accumulates the existing adaptation text for the selection
	strAdapt.Empty();

	wxString str; // a temporary storage string
	str.Empty();
	wxString str2; // second temporary storage string
	str2.Empty();
	wxString strSource; // the source text which is to be retranslated
	strSource.Empty();
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	int nCount = pApp->m_selection.GetCount(); // number of src phrase instances in selection

	if (nCount == (int)pApp->m_pSourcePhrases->GetCount())
	{
		//IDS_RETRANS_NOT_ALL_OF_DOC
		wxMessageBox(_(
"Sorry, for a retranslation your selection must not include all the document contents - otherwise there would be no possible place for the phrase box afterwards. Shorten the selection then try again."),
		_T(""),wxICON_INFORMATION);
		return;
	}

	CCell* pCell = (CCell*)pos->GetData();
	CPile* pPile = pCell->GetPile(); // get the pile first in the selection
	pos = pos->GetNext(); // needed for our CCellList to effect MFC's GetNext()

	pStartingPile = pPile; 
	pSrcPhrase = pPile->GetSrcPhrase();

	int nSaveSequNum = pSrcPhrase->m_nSequNumber; // save its sequ number, everything depends
											// on this - its the first in the sublist list
    // get a list of the selected CSourcePhrase instances (some might not be minimal ones
    // so if this is the case we must later restore them to minimal ones, and some might be
    // placeholders, so these must be later eliminated after their text, if any, is
    // preserved & any punctuation transferred) and also accumulate the words in the source
    // and target text into string variables
	GetSelectedSourcePhraseInstances(pList, strSource, strAdapt);

	// check that the selection is text of a single type - if it isn't, then tell the user and
	// abandon the operation
	bool bConstType = IsConstantType(pList);
	if (!bConstType)
	{
		// IDS_TYPE_CHANGE_ERR
		wxMessageBox(_(
"Sorry, the selection contains text of more than one type. Select only one text type at a time. The operation will be ignored."),
		_T(""), wxICON_EXCLAMATION);
		RemoveSelection();
		delete pList;
		pList = (SPList*)NULL;
		pApp->m_pTargetBox->SetFocus();
		pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

    // check for a retranslation in the selection, and abort the retranslatiaon operation
    // if there is one
	if (IsRetranslationInSelection(pList))
	{
		// IDS_NO_RETRANSLATION_IN_SEL
		wxMessageBox(_(
"Sorry, but this operation is not permitted when the selection contains any part of a retranslation. First remove the retranslation and then try again."),
		_T(""), wxICON_EXCLAMATION);
		pList->Clear();
		delete pList;
		pList = (SPList*)NULL;
		RemoveSelection();
		pApp->m_pTargetBox->SetFocus();
		pApp->m_pTargetBox->SetSelection(pApp->m_nStartChar,pApp->m_nEndChar);
		Invalidate();
		GetLayout()->PlaceBox();
		return;
	}

    // need to clobber the selection here, so the selection globals will be set to -1,
    // otherwise RecalcLayout will fail at its RestoreSelection() call; and any unmergers
    // or other layout changes done immediately below will invalidate layout pointers which
    // RemoveSelection() relies on, and produce a crash.
	RemoveSelection();

    // copy the list to a 2nd list for saving the original state, in case the user hits the
    // Cancel button in the dialog, and save the old sequ num value for the active
    // location; we don't save copies of the pointers, but instead use the copy constructor
    // to make fresh copies of the original selection's source phrases - but note that the
    // copy constructor (and also operator=) only copies pointers for any CSourcePhrases in
    // each source phrase's m_pSavedWords sublist - which has implications for below (in
    // particular, when deleting the copied list, we must not delete in the sublists, but
    // only remove the pointers, otherwise the originals will have hanging pointers)
	SPList* pSaveList = new SPList;
	wxASSERT(pSaveList != NULL);
	CopySourcePhraseList(pList,pSaveList);

	// BEW added 20Mar07: to suppress KB entry removal during a retranslation or edit of same
	gbIsRetranslationCurrent = TRUE;

    // deliberately abandon contents of box at active loc'n - we'll reconstitute it as
    // necessary later, depending on where we want to place the targetBox. But before we
    // abandon it, we must first check if the active location is outside the selection -
    // since there could be a just-edited entry in the phrase box which is not yet entered
    // in the knowledge base, and the active location's source phrase doesn't yet have its
    // m_adaption and m_targetStr members updated, so we must check for this condition and
    // if it obtains then we must first update everything at the active location before we
    // empty pApp->m_targetPhrase, etc. For versions later than 1.2.9, the code below is
    // different. We need an unconditional store, because if outside the selection, we must
    // update as the above explanation explains; but for an active location within the
    // selection, we still must update because (a) there is one refString removal already
    // by virtue of the fact that it is the active location (ie. the box is there), and (b)
    // a further refString removal will be done in the UnmergeMergersInSublist() call, and
    // this means the refString for the active location gets removed twice unless we
    // prevent it (it only should be removed once). So by doing an unconditional store, we
    // bump the refCount at the active loc, and then the UnmergeMergersInSublist() call can
    // decrement it again, keeping the count correct. We need to do this also in
    // OnEditSourceText().
	if (pApp->m_pActivePile != NULL)
	{
		// the active location is not within the retranslation section, so update before
		// throwing it all out
		MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(),pApp->m_targetPhrase);
		RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);
		gbInhibitLine4StrCall = TRUE;
		bool bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->GetSrcPhrase(),pApp->m_targetPhrase);
		gbInhibitLine4StrCall = FALSE;
		if (!bOK)
		{
			gbIsRetranslationCurrent = FALSE;
			return; // can't proceed until a valid adaption (which could be null) is
					// supplied for the former active pile's srcPhrase
		}
		else
		{
            // make the former strip be invalid - new layout code will then tweak the
            // layout from that point on; mark it invalid as well as the current one
			int nFormerStrip = pApp->m_pActivePile->GetStripIndex();
			pDoc->ResetPartnerPileWidth(pApp->m_pActivePile->GetSrcPhrase()); // & mark 
															// the active strip invalid
			int nCurStripIndex = pStartingPile->GetStripIndex();
			if (nCurStripIndex != nFormerStrip)
			{
				CStrip* pFormerStrip = (CStrip*)GetLayout()->GetStripArray()->Item(nFormerStrip);
#ifdef _ALT_LAYOUT_
				CPile* pItsFirstPile = pFormerStrip->GetPileByIndexInStrip(0);
#else
				CPile* pItsFirstPile = (CPile*)pFormerStrip->GetPilesArray()->Item(0);
#endif
				CSourcePhrase* pItsFirstSrcPhrase = pItsFirstPile->GetSrcPhrase();
				pDoc->ResetPartnerPileWidth(pItsFirstSrcPhrase,TRUE); // TRUE is 
													// bNoActiveLocationCalculation
			}
		}
	}
	pApp->m_targetPhrase.Empty();
	if (pApp->m_pTargetBox != NULL)
	{
		pApp->m_pTargetBox->ChangeValue(pApp->m_targetPhrase);
	}

    // determine the value for the active sequ number on exit, so we will know where to
    // place the phrase box on return to the caller; we'll place the phrase box at the
    // first location after the retranslation - provided the active location was within the
    // selection; but if it lay outside the selection, we will need to restore it to
    // wherever it was.
	SPList::Node* lastPos = pList->GetLast();
	int nEndSequNum = lastPos->GetData()->m_nSequNumber;
	bool bActiveLocWithinSelection = FALSE;
	if (nSaveActiveSequNum >= nSaveSequNum && nSaveActiveSequNum <= nEndSequNum)
		bActiveLocWithinSelection = TRUE;
	bool bActiveLocAfterSelection = FALSE;
	if (nSaveActiveSequNum > nEndSequNum)
		bActiveLocAfterSelection = TRUE;

	// check for any null source phrases in the selection, and delete any found from both the
	// temporary list (pList), and from the original source phrases list on the app (see above)
	while (IsNullSrcPhraseInSelection(pList))
	{
		RemoveNullSrcPhraseFromLists(pList, pSrcPhrases, nCount, nEndSequNum,
										bActiveLocAfterSelection, nSaveActiveSequNum);
	}

    // at this point pList does not contain any null source phrases, and we have
    // accumulated any adaptations already typed into strAdapt. However, we might have
    // merged phrases in pList to be unmerged, and we have not yet removed the translation
    // for each pSrcPhrase in pList from the KB, so we must do those things next.
	UnmergeMergersInSublist(pList, pSrcPhrases, nCount, nEndSequNum, bActiveLocAfterSelection,
							nSaveActiveSequNum, TRUE, TRUE); // final 2 flags should take
                // default values (TRUE, and FALSE, respectively), but this leads to a
                // crash when there are unmergers to be done - so using TRUE,TRUE fixes it
                // (ie. the pList sublist needs to be updated here too)

    // now we can work out where to place the phrase box on exit from this function - it is
    // currently the nSaveActiveSequNum value, unless the active location was within the
    // selection, in which case we must make the active location the first pile after the
    // selection...
    // BEW added 8May09; if the active location was far from the retranslation (defined as
    // "more than 80 piles from its end"), it is probably better to make the final active
    // location be the CSourcePhrase instance immediately following the retranslation, and
    // set the global gnOldsequNum to the old sequence number value so the Back button can
    // later jump back to the old active location if the user wants
    gnOldSequNum = nSaveActiveSequNum;
	int nSaveOldSequNum = gnOldSequNum; // need this to avoid calls below clobbering the 
										// value set
	if (bActiveLocWithinSelection || (abs(nEndSequNum - nSaveActiveSequNum) > 80))
		nSaveActiveSequNum = nEndSequNum + 1;

	// the src phrases in the sublist will not be saved to the KB (because we don't save
	// retranslations) so mark them as not being in the KB; similarly, set the
	// m_bRetranslation flag to TRUE
	SetNotInKBFlag(pList,TRUE);
	SetRetranslationFlag(pList,TRUE);

    // we must have a valid layout, so we have to recalculate it before we go any further,
    // because if preceding code unmerged formerly merged phrases, or if null phrases were
    // deleted, then the layout's pointers will be clobbered, and then if we move the
    // dialog about to be put up, accesses to Draw() for the cells, piles & strips will
    // fail.
	pApp->m_nActiveSequNum = nSaveActiveSequNum; // legally can be a wrong location, eg. 
												 // in the retrans, & it won't break
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	// create the CRetranslationDlg dialog
	CRetranslationDlg dlg(pApp->GetMainFrame());
	dlg.Centre();

	// initialize the edit boxes
	dlg.m_sourceText = strSource;
	dlg.m_retranslation = strAdapt;
	wxString preceding;
	preceding.Empty();
	wxString following;
	following.Empty();
	wxString precedingTgt;
	precedingTgt.Empty();
	wxString followingTgt;
	followingTgt.Empty();
	GetContext(nSaveSequNum,nEndSequNum,preceding,following,precedingTgt,followingTgt);
	dlg.m_preContextSrc = preceding;
	dlg.m_preContextTgt = precedingTgt;
	dlg.m_follContextSrc = following;
	dlg.m_follContextTgt = followingTgt;

	// BEW addition 08Sep08 for support of vertical editing
	bool bVerticalEdit_SuppressPhraseBox = FALSE;
	int nVerticalEdit_nExtras = 0;

    // wx version: The wx version was crashing as soon as this CRetranslationDlg was shown.
    // The crashes were in OnUpdateButtonRestore(), an unrelated update handler, because in
    // the code line
	//		CSourcePhrase* pSP = pApp->m_pActivePile->m_pSrcPhrase;
    // m_pActivePile was valid, but the m_pSrcPhrase was uninitialized. It seems the wx
    // version update handlers in wx are more robust than those of MFC, or don't get
    // blocked while a modal dialog is showing, I don't know. At first, to eliminate the
    // crash, I temporarily turned off the update handler before calling ShowModal(), and
    // activating it again after ShowModal returns farther below. Later I decided to
    // incorporate the SetMode() call in the AIModalDialog class upon which all Adapt It
    // modal dialogs are now based. The call is
    // wxIdleEvent::SetMode(wxIDLE_PROCESS_SPECIFIED) which stops all background idle
    // processing, including wxUpdateUIEvent event handling
    //  
    // show the dialog
	if (dlg.ShowModal() == wxID_OK)
	{
		SPList* pRetransList = new SPList;
		wxASSERT(pRetransList);
		wxString retrans = dlg.m_retranslation;
		int nNewCount = 0; // number of CSourcePhrase instances returned from the
						   // tokenization operation

        // tokenize the retranslation into a list of new CSourcePhrase instances on the
        // heap (they are incomplete - only m_key and m_nSequNumber are set); nSaveSequNum
        // is the absolute sequence number for first source phrase in the sublist - it is
        // used to define the starting sequence number to be stored on the first element of
        // the sublist, and higher numbers on succeeding ones
		nNewCount = TokenizeTextString(pRetransList,retrans,nSaveSequNum);

		// augment the active sequ num if it lay after the selection
		if (bActiveLocAfterSelection && nNewCount > nCount)
			nSaveActiveSequNum += nNewCount - nCount;
		else
		{
			// augment it also if the active location lay within the selection
			// and null source phrases were inserted
			if (bActiveLocWithinSelection && nNewCount > nCount)
				nSaveActiveSequNum += nNewCount - nCount;
		}
		pApp->m_nActiveSequNum = nSaveActiveSequNum; // ensure any call to 
									// InsertNullSrcPhrase() will work right

        // we must have a valid layout, so we have to recalculate it before we go any
        // further, because if preceding code unmerged formerly merged phrases, or if null
        // phrases were deleted, then the layout's pointers will be clobbered; but we won't
        // draw it yet because later we must ensure the active location is not within the
        // retranslation and set it safely before a final layout calculation to get it all
        // correct
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

		// get a new valid starting pile pointer
		pStartingPile = GetPile(nSaveSequNum);
		wxASSERT(pStartingPile != NULL);

		// determine if we need extra null source phrases inserted, 
		// and insert them if we do
		PadWithNullSourcePhrasesAtEnd(pDoc,pApp,pSrcPhrases,nEndSequNum,
										nNewCount,nCount);
        // copy the retranslation's words, one per source phrase, to the constituted
        // sequence of source phrases (including any null ones) which are to display it;
        // but ignore any markers and punctuation if they were encountered when the
        // retranslation was parsed, so that the original source text's punctuation
        // settings in the document are preserved. Export will get the possibly new
        // punctuation settings by copying m_targetStr, so we do not need to alter
        // m_precPunct and m_follPunct on the document's CSourcePhrase instances.
		int nFinish = -1; // it gets set to a correct value in the following call
		BuildRetranslationSourcePhraseInstances(pRetransList,nSaveSequNum,nNewCount,
												nCount,nFinish);
        // delete the temporary list and delete the pointers to the CSourcePhrase
        // instances on the heap
		DeleteTempList(pRetransList);

        // remove the unused saved original source phrase copies & their list too this
        // pSaveList list will possibly have copies which contain non-empty sublists,
        // especially in m_pSavedWords, and the source phrases pointed to by that list will
        // only have had their pointers copied, so we must not delete those pointers,
        // otherwise the originals will contain hanging pointers & we'll crash if we were
        // to retry the retranslation on the same data
		DeleteSavedSrcPhraseSublist(pSaveList);

        // set the active pile pointer - do it here (not earlier), after any null source
        // phrases have been inserted, otherwise if we are near the end of file, the
        // pointer could be invalid because no such pile exists yet. Also, since the
        // nSaveActiveSequNum could be greater than the possible max value (if we are
        // making a retranslation at the very end of the file), we must check and if
        // necessary put the active location somewhere before the retranslation
		// BEW addition 08Sep08 for support of vertical editing
		if (!gbVerticalEditInProgress)
		{
			// legacy behaviour
			gbSuppressRemovalOfRefString = TRUE; // suppress RemoveRefString() call within 
												 // PlacePhraseBox()
			bool bSetSafely = SetActivePilePointerSafely(pApp,pSrcPhrases,nSaveActiveSequNum,
															pApp->m_nActiveSequNum,nFinish);
			gbSuppressRemovalOfRefString = FALSE; // permit RemoveRefString() in subsequent 
												  // PlacePhraseBox() calls
			gbIsRetranslationCurrent = FALSE;
			if(!bSetSafely)
			{
				// IDS_ALL_RETRANSLATIONS
				wxMessageBox(_(
"Warning: your document is full up with retranslations. This makes it impossible to place the phrase box anywhere in the document."),
				_T(""), wxICON_EXCLAMATION);
                // BEW changed 19Mar09 for refactored layout, to comment out & so allow the
                // phrase box to be shown at the last pile of the document whether there's
                // a retranslation there or not, if no other safe location is found
				//return;
			}
		}
		else
		{
            // we are in adaptationsStep of vertical editing process, so we want the active
            // pile to be the one immediately following the retranslation; but if that is
            // in the gray text area beyond the end of the editable span, we set a boolean
            // so we can later suppress the reconstruction of the phrase box in the gray
            // area, and just instead immediately cause the dialog asking the user what to
            // do for the next step to be displayed; we also need to deal with the
            // possibility the user's retranslation may make the editable span longer, and
            // update the relevant parameters in gEditRecord
			if (nNewCount > nCount)
			{
				nVerticalEdit_nExtras = nNewCount - nCount;

                // update the relevant parts of the gEditRecord (all spans are affected
                // equally, except the source text edit section is unchanged)
				gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nVerticalEdit_nExtras;
				gEditRecord.nAdaptationStep_NewSpanCount += nVerticalEdit_nExtras;
				gEditRecord.nAdaptationStep_EndingSequNum += nVerticalEdit_nExtras;
			}
			// if the test is equality or less than, then nVerticalEdit_nExtras is 0, and no
			// change to the gEditRecord is required

			// set the potential active location to the CSourcePhrase immediately following
			// the end of the retranslation
			int nPotentialActiveSequNum = nSaveSequNum + nNewCount;

			// determine if this location is within the editable span, if it is, we permit
			// the later restoration of the phrase box there; if not, we suppress the
			// restoration of the phrase box (otherwise it would be in the gray text area)
			if (!(nPotentialActiveSequNum >= gEditRecord.nAdaptationStep_StartingSequNum &&
				nPotentialActiveSequNum <= gEditRecord.nAdaptationStep_EndingSequNum))
			{
				bVerticalEdit_SuppressPhraseBox = TRUE;
			}

			nSaveActiveSequNum = nPotentialActiveSequNum; // we need a value to work with below
										// even if we suppress reconstituting of the phrase box
			gbSuppressRemovalOfRefString = TRUE; // suppress RemoveRefString() call within 
												 // PlacePhraseBox()
			bool bSetSafely;
			bSetSafely = SetActivePilePointerSafely(pApp,pSrcPhrases,nSaveActiveSequNum,
															pApp->m_nActiveSequNum,nFinish);
			gbSuppressRemovalOfRefString = FALSE; // permit RemoveRefString() in subsequent 
												  // PlacePhraseBox() calls
			gbIsRetranslationCurrent = FALSE;
		}
	}
	else
	{
		// user cancelled, so we have to restore the original state
		gbIsRetranslationCurrent = FALSE;
		wxASSERT(pSaveList);
		int nCurCount = nEndSequNum - nSaveSequNum + 1; // what the selection now numbers,
														// after unmerge etc.
		int nOldCount = pSaveList->GetCount();
		wxASSERT(nOldCount >0);
		int nExtras = nCurCount - nOldCount; // needed for adjusting indices
		wxASSERT(nExtras >= 0); // cannot be negative

        // this list's source phrases have not had their KB refString entries removed/count
        // decremented, whichever is required, so we must do so now - otherwise, if they
        // are storing some adaptions, when we try to re-store them in the KB, the
        // StoreAdapation assert at 1st line will trip.
		ClearSublistKBEntries(pSaveList);

		// insert the original (saved) source phrases after the nEndSequNum one
		InsertSublistAfter(pSrcPhrases,pSaveList,nEndSequNum);

		// now remove the unwanted ones - be careful, some of these single-word ones will point
		// to memory that any merged source phrases in the saved list will point to in their
		// m_pSavedWords sublists, so don't delete the memory in the latter sublists,
		// just remove the pointers!
		RemoveUnwantedSourcePhraseInstancesInRestoredList(pSrcPhrases,nCurCount,nSaveSequNum,
															pSaveList);

		// we can assume nExtras is either 0 or positive
		if (nSaveActiveSequNum > nSaveSequNum + nOldCount - 1)
			nSaveActiveSequNum -= nExtras; // decrement only if it lay after the original
										   // selection

		// renumber the sequence numbers
		UpdateSequNumbers(0);

		// remove the pointers in the saved list, and delete the list, but leave the instances
		// undeleted since they are now pointed at by elements in the pSrcPhrases list
		if (pSaveList->GetCount() > 0)
		{
			pSaveList->Clear();
		}
		delete pSaveList; // don't leak memory
		pSaveList = (SPList*)NULL;
	}

	// delete the temporary list after removing its pointer copies (copy constructor was not
	// used on this list, so removal of pointers is sufficient)
	pList->Clear();
	delete pList;
	pList = (SPList*)NULL;

	// recalculate the layout
	pApp->m_nActiveSequNum = nSaveActiveSequNum;
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(nSaveActiveSequNum);

	// get the CSourcePhrase at the active location
	pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
	wxASSERT(pSrcPhrase != NULL);

    // determine the text to be shown, if any, in the target box when it is recreated When
    // placing the phrasebox after doing a retranslation, or edit of a retranslation, or
    // removal of a retranslation. Introduced in version 1.4.2, because in earlier versions
    // if there was more than one translation available at the location where the phrasebox
    // gets put, the earlier code (in RestoreTargetBoxText( )) would put up the Choose
    // Translation dialog, which is a nuisance when the translation there is already
    // correct; so now we do that call only when we cannot ascertain a valid translation
    // from the source phrase at that point.
	// BEW additions 08Sep08 for support of vertical editing mode
	wxString str3;
	// define the operation type, so PlaceBox() can do its job correctly
	GetLayout()->m_docEditOperationType = retranslate_op;
	if (gbVerticalEditInProgress && bVerticalEdit_SuppressPhraseBox)
	{
		// vertical edit mode is in operation, and a recalc of the layout has been done, so
		// it remains just to determine whether or not to suppress the phrase box and if so
		// to transition to the next step, otherwise send control to the legacy code to have
		// the phrase box created at the active location
		
		// the active location is in the gray text area, so don't build the phrase box
		// (in wxWidgets, instead hide the phrase box at this point); and instead transition
		// to the next step
		bool bCommandPosted;
		bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(-1, nextStep, TRUE);
		// no Invalidate() call made in this block, because a later point in the process
		// should draw the layout anew (I'm guessing, but I think it's a safe guess)
	}
	else
	{
		if (pSrcPhrase->m_targetStr.IsEmpty() && !pSrcPhrase->m_bHasKBEntry && !pSrcPhrase->m_bNotInKB)
		{
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			RestoreTargetBoxText(pSrcPhrase,str3); // for getting a suitable m_targetStr contents
		}
		else
		{
			str3 = pSrcPhrase->m_targetStr; // if we have something
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}

        // it is okay to do the Remove call with pRefString == NULL, in fact, it must be
        // done whether NULL or not; since if it is NULL, RemoveRefString will clear
        // pSrcPhrase's m_bHasKBEntry to FALSE, which if not done, would result in a crash
        // if the user clicked on a source phrase which had its reference string manually
        // removed from the KB and then clicked on another source phrase. (The
        // StoreAdaption call in the second click would trip the first line's ASSERT.)
		CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key,pSrcPhrase->m_adaption);
		RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

		pApp->m_targetPhrase = str3; // the Phrase Box can have punctuation as well as text
		pApp->m_pTargetBox->ChangeValue(str3);
		pApp->m_nStartChar = -1;
		pApp->m_nEndChar = -1;

		// layout again, so that the targetBox won't encroach on the next cell's adaption text 
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
				
		// remove selection and update the display
		RemoveSelection();
		Invalidate();
		GetLayout()->PlaceBox();
	}

	// ensure respect for boundaries is turned back on
	if (!pApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(event);
	gbInsertingWithinFootnote = FALSE; // restore default value
	gnOldSequNum = nSaveOldSequNum; // restore the value we set earlier
}

/////////////////////////////////////////////////////////////////////////////////
// End section for  OnButtonRetranslation()
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
//
// Begin section for  OnButtonEditRetranslation()
//
// Helper functions:
// IsEndInCurrentSelection()
// AccumulateText()
// ReplaceMatchedSubstring()
//
/////////////////////////////////////////////////////////////////////////////////

bool CAdapt_ItView::IsEndInCurrentSelection()
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CCellList::Node* pos = pApp->m_selection.GetLast(); 
	CCell* pCell = (CCell*)pos->GetData();
	pos = pos->GetPrevious();
	bool bCurrentSection = TRUE;
	while( pos != NULL)
	{
		pCell = (CCell*)pos->GetData();
		pos = pos->GetPrevious();
		CPile* pPile2 = pCell->GetPile();
		if (pPile2->GetSrcPhrase()->m_bEndRetranslation)
		{
			bCurrentSection = FALSE;
			break;
		}
	}
	return bCurrentSection;
}

void CAdapt_ItView::GetRetranslationSourcePhrasesStartingAnywhere(
						CPile* pStartingPile, CPile*& pFirstPile, SPList* pList)
{
	// refactored 16Apr09 (removed goto statement also & adjusted syntax accordingly)
	pFirstPile = pStartingPile; // first pile in the retranslation section, initialize to
								// the one clicked or selected, in case the first was clicked
								// or selected; in which case the first loop below will not be
								// entered and we'd otherwise not set pFirstPile at all

	CSourcePhrase* pSrcPhrase = pStartingPile->GetSrcPhrase();
	// wx Note: wxList::Insert() Inserts object at front of list, equiv to CObList's AddHead()
	pList->Insert(pSrcPhrase); // add the one we've found already
	CPile* pPile = pStartingPile;
	if (!pFirstPile->GetSrcPhrase()->m_bBeginRetranslation)
	{
		// do this block if we are not at beginning of the retranslation as
		// previously constituted
		while ((pPile = GetPrevPile(pPile)) != NULL && pPile->GetSrcPhrase()->m_bRetranslation)
		{
			pList->Insert(pPile->GetSrcPhrase());
			pFirstPile = pPile; // last time thru this loop leaves this variable with the value
								// we want

			// go back only to the source phrase with m_bBeginRetranslation set TRUE, but if none
			// such is found, then continue until the loop test gives an exit
			if (pPile->GetSrcPhrase()->m_bBeginRetranslation)
				break; // we are at the start of the retranslation section as earlier constituted
		}
	}
	pPile = pStartingPile;
	if (pStartingPile->GetSrcPhrase()->m_bEndRetranslation)
		return; // skip next block if we are at the end of the retranslation as previously
				// constituted

	while ((pPile = GetNextPile(pPile)) != NULL && pPile->GetSrcPhrase()->m_bRetranslation)
	{
		pList->Append(pPile->GetSrcPhrase()); 

		// break when we come to one with m_bEndRetranslation flag set TRUE
		if (pPile->GetSrcPhrase()->m_bEndRetranslation)
			break;
	}
}

void CAdapt_ItView::AccumulateText(SPList* pList,wxString& strSource,wxString& strAdapt)
{
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	wxString str;
	wxString str2;

	while (pos != NULL)
	{
		// accumulate the old retranslation's text
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		str = pSrcPhrase->m_targetStr;
		if (strAdapt.IsEmpty())
		{
			strAdapt += str;
		}
		else
		{
			if (!str.IsEmpty())
				strAdapt += _T(" ") + str;
		}

		// also accumulate the source language text (line 1), provided it is not a null
		// source phrase
		if (!pSrcPhrase->m_bNullSourcePhrase)
		{
			str2 = pSrcPhrase->m_srcPhrase;
			if (strSource.IsEmpty())
			{
				strSource = str2;
			}
			else
			{
				strSource += _T(" ") + str2;
			}
		}
	}
}

// finds the strSearch in strAdapt, and replaces it with strReplace, 
// updating strAdapt in the caller
void CAdapt_ItView::ReplaceMatchedSubstring(wxString strSearch, wxString& strReplace,
											wxString& strAdapt)
{
		int nFound = -1;
		int lenAdaptStr = 0;
		int lenTgt = 0;
		int nRight;
		wxString left;
		left.Empty();
		wxString right;
		right.Empty();
		lenTgt = strSearch.Length(); // the search string's length
		lenAdaptStr = strAdapt.Length(); // length of the string in which the search is done
		nFound = strAdapt.Find(strSearch);
		wxASSERT(nFound != -1); // must not have failed, since this was the match done in caller
		left = strAdapt.Left(nFound);
		nRight = nFound + lenTgt;
		wxASSERT(nRight <= lenAdaptStr);
		nRight = lenAdaptStr - nRight;
		right = strAdapt.Right(nRight);

		// put the final string into the strAdapt alias string in caller
		strAdapt = left + strReplace + right;
}

void CAdapt_ItView::OnButtonEditRetranslation(wxCommandEvent& event)
{
    // Since the Edit Retranslation toolbar button has an accelerator table hot key (CTRL-E
    // see CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even
    // when they are disabled, we must check for a disabled button and return if disabled.
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument(); 
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);
	if (!pToolBar->GetToolEnabled(ID_BUTTON_EDIT_RETRANSLATION))
	{
		::wxBell();
		return;
	}

	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_(
		"This particular operation is not available when you are glossing."),
		_T(""), wxICON_INFORMATION);
		return;
	}
	SPList* pList = new SPList; // list of the CSourcePhrase objects in the retranslation section
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile = NULL;
	CSourcePhrase* pSrcPhrase;
	int nSaveActiveSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;

    // get the source phrases which comprise the section which is retranslated; but first
    // check if we have a selection, and if so start from the first pile in the selection;
    // otherwise, we have an error condition.
	CCell* pCell;
	CCellList::Node* cpos;
	if (pApp->m_selectionLine != -1)
	{
		// there is a selection current
		cpos = pApp->m_selection.GetFirst();
		pCell = (CCell*)cpos->GetData();
		if (pCell != NULL)
		{
			pStartingPile = pCell->GetPile(); // since the selection might be any single
							// srcPhrase, not necessarily the first in the  retranslation,
							// we must reset this later to the true first one
			pSrcPhrase = pStartingPile->GetSrcPhrase();
			if (!pSrcPhrase->m_bRetranslation)
			{
				// an error state
				//IDS_NO_REMOVE_RETRANS
h:				wxMessageBox(_(
"Sorry, the whole of the selection was not within a section of retranslated text, so the command has been ignored."),
				_T(""), wxICON_EXCLAMATION);
				RemoveSelection();
				delete pList;
				Invalidate();
				GetLayout()->PlaceBox();
				return;
			}
		}
	}

	// also check that the end of the selection is also part of the retranslation,
	// if not, return
	cpos = pApp->m_selection.GetLast();
	pCell = (CCell*)cpos->GetData();
	CPile* pPile2 = pCell->GetPile();
	if (!pPile2->GetSrcPhrase()->m_bRetranslation)
	{
		// an error state
		goto h;
	}
	else
	{
        // must also check that there is no preceding pile which has a sourcephrase with
        // its m_bEndRetranslation flag set TRUE, if so, the selection lies in a following
        // retranslation section, and so the selection is invalid for delineating one
        // retranslation
		bool bCurrentSection = IsEndInCurrentSelection();
		if (!bCurrentSection)
			goto h;
	}

	// we are in a single retranslation section, so get the source phrases into pList
	RemoveSelection();
	CPile* pFirstPile = 0;
	GetRetranslationSourcePhrasesStartingAnywhere(pStartingPile,pFirstPile,pList);

	int nSaveSequNum = pFirstPile->GetSrcPhrase()->m_nSequNumber; // save its sequ number,
							// everything depends on this - its the first in the sublist

    // copy the list to a 2nd list for saving the original state, in case the user hits the
    // Cancel button in the dialog, and save the old sequ num value for the active
    // location; we don't save copies of the pointers, but instead use the copy constructor
    // to make fresh copies of the original selection's source phrases - but note, in the
    // m_pSavedWords sublists, if they have something, the copy constructor only copies the
    // pointers, & doesn't make new copies, so beware that some source phrases might be
    // pointed at from more than one place - which affects how we delete
	SPList* pSaveList = new SPList;
	CopySourcePhraseList(pList,pSaveList);

    // deliberately abandon contents of box at active loc'n - we'll reconstitute it as
    // necessary later, depending on where we want to place the targetBox. But before we
    // abandon it, we must first check if the active location is outside the selection -
    // since there could be a just-edited entry in the phrase box which is not yet entered
    // in the knowledge base, and the active location's source phrase doesn't yet have its
    // m_adaption and m_targetStr members updated, so we must check for this condition and
    // if it obtains then we must first update everything at the active location before we
    // empty m_targetPhrase, etc.
	SPList::Node* pos = 0;
	if (pApp->m_pActivePile != NULL)
	{
		CSourcePhrase* pActiveSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		pos = pList->GetFirst();
		bool bInSelection = FALSE;
		while (pos != NULL)
		{
			CSourcePhrase* pSP = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (pSP == pActiveSrcPhrase)
			{
				bInSelection = TRUE;
				break;
			}
		}

		// BEW added 20Mar07: to suppress removing of KB entries during edit
		// of the retranslation
		gbIsRetranslationCurrent = TRUE;

		if (!bInSelection)
		{
            // the active location is not within the retranslation section, so update
            // before throwing it all out
			MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(),pApp->m_targetPhrase);
			RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);
			if (!pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
			{
				gbInhibitLine4StrCall = TRUE;
				bool bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
				if (!bOK)
				{
					gbIsRetranslationCurrent = FALSE;
					return; // can't proceed until a valid adaption (which could be null) 
							// is supplied for the former active pile's srcPhrase
				}
				else
				{
					// make the pile at start of former strip have a new pointer - new layout
					// code will then tweak the layout from that point on (see also
					// OnButtonRestore() at lines 14,014 to 14,026)
					int nFormerStrip = pApp->m_pActivePile->GetStripIndex();
					pDoc->ResetPartnerPileWidth(pApp->m_pActivePile->GetSrcPhrase()); // mark 
																// the owning  strip invalid
					int nCurStripIndex = pStartingPile->GetStripIndex();
					if (nCurStripIndex != nFormerStrip)
					{
						CStrip* pFormerStrip = (CStrip*)GetLayout()->GetStripArray()->Item(nFormerStrip);
#ifdef _ALT_LAYOUT_
						CPile* pItsFirstPile = pFormerStrip->GetPileByIndexInStrip(0);
#else
						CPile* pItsFirstPile = (CPile*)pFormerStrip->GetPilesArray()->Item(0);
#endif
						CSourcePhrase* pItsFirstSrcPhrase = pItsFirstPile->GetSrcPhrase();
						// mark this strip invalid too (a little extra insurance)
						pDoc->ResetPartnerPileWidth(pItsFirstSrcPhrase, TRUE); // TRUE
														// is bNoActiveLocationCalculation
					}
				}
			}
		}
	}
	pApp->m_targetPhrase.Empty();
	if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
	{
		pApp->m_pTargetBox->ChangeValue(pApp->m_targetPhrase); // clear it
	}

    // we have to accumulate now the text comprising the current retranslation, since we
    // won't be able to recover it fully after we throw away any null source phrases which
    // may be present.
	wxString strAdapt; // accumulates the existing adaptation text for the selection
	strAdapt.Empty();
	wxString str; // a temporary storage string
	str.Empty();
	wxString str2; // second temporary storage
	str2.Empty();
	wxString strSource; // the source text which is to be retranslated (now line 1, not line 2)
	strSource.Empty();
	AccumulateText(pList,strSource,strAdapt);


    // if we are invoking this function because of a Find & Replace match within the
    // retranslation, then replace the portion of the strAdapt string which was matched
    // with the replacement string found in the global gReplStr
	if (gbReplaceInRetranslation)
	{
		ReplaceMatchedSubstring(gSrchStr,gReplStr,strAdapt);

		// clear the globals for next time
		gbReplaceInRetranslation = FALSE;
		gSrchStr.Empty();
		gReplStr.Empty();
	}

    // determine the value for the active sequ number on exit, so we will know where to
    // place the phrase box on return to the caller; we'll place the phrase box at the
    // first location after the retranslation - provided the active location was within the
    // selection; but if it lay outside the selection, we will need to restore it to
    // wherever it was. 
    // int nEndSequNum = ((CSourcePhrase*)pList->GetTail())->m_nSequNumber; 
    // break the above down into parts
	SPList::Node* spos = pList->GetLast();
	int nEndSequNum = spos->GetData()->m_nSequNumber;
	bool bActiveLocWithinSelection = FALSE;
	if (nSaveActiveSequNum >= nSaveSequNum && nSaveActiveSequNum <= nEndSequNum)
		bActiveLocWithinSelection = TRUE;
	bool bActiveLocAfterSelection = FALSE;
	if (nSaveActiveSequNum > nEndSequNum)
		bActiveLocAfterSelection = TRUE;

	// we can now clear the m_bEndRetranslation flag on the last entry of the list
	spos = pList->GetLast();
	pSrcPhrase = (CSourcePhrase*)spos->GetData();
	wxASSERT(pSrcPhrase);
	pSrcPhrase->m_bEndRetranslation = FALSE;

    // any null source phrases have to be thrown away, and the layout recalculated after
    // updating the sequence numbers of the source phrases remaining
	pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	int nCount = pList->GetCount();

	// BEW addition 08Sep08 for support of vertical editing
	bool bVerticalEdit_SuppressPhraseBox = FALSE;
	int nVerticalEdit_nExtras = 0;
	int nOriginalCount = nCount;

    // BEW added 01Aug05, to support free translations -- removing null source phrases also
    // removes m_bHasFreeTrans == TRUE instances as well, so the only thing we need check
    // for is whether or not there is m_bEndFreeTrans == TRUE on the last null source
    // phrase removed -- if so, we must set the same bool value to TRUE on the last
    // pSrcPhrase remaining in the list after all the null ones have been deleted. We do
    // this by setting a flag in the block below, and then using the set flag value in the
    // block which follows it
	bool bEndIsAlsoFreeTransEnd = FALSE;
	while (pos != NULL)
	{
		SPList::Node* savePos = pos; 
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_bNullSourcePhrase)
		{
            // it suffices to test each one, since the m_bEndFreeTrans value will be FALSE
            // on every one, or if not so, then only the last will have a TRUE value
			if (pSrcPhrase->m_bEndFreeTrans)
				bEndIsAlsoFreeTransEnd = TRUE;

            // null source phrases in a retranslation are never stored in the KB, so we
            // need only remove their pointers from the lists and delete them from the heap
			SPList::Node* pos1 = pSrcPhrases->Find(pSrcPhrase);
			wxASSERT(pos1 != NULL); // it has to be there
			pSrcPhrases->DeleteNode(pos1);	// remove its pointer from m_pSourcePhrases list
											// on the doc
			// BEW added 13Mar09 for refactor of layout; delete its partner pile too 
			GetDocument()->DeletePartnerPile(pSrcPhrase);

			delete pSrcPhrase; // delete the null source phrase itself
			pList->DeleteNode(savePos); // also remove its pointer from the local sublist

			nCount -= 1; // since there is one less source phrase in the selection now
			nEndSequNum -= 1;
			if (bActiveLocAfterSelection)
				nSaveActiveSequNum -= 1;
		}
		else
		{
			// of those source phrases which remain, throw away the contents of their
			// m_adaption and m_targetStr members
			pSrcPhrase->m_adaption.Empty();
			pSrcPhrase->m_targetStr.Empty();
			pSrcPhrase->m_bBeginRetranslation = FALSE;
			pSrcPhrase->m_bEndRetranslation = FALSE;
		}
	}

	// handle transferring the indication of the end of a free translation
	if (bEndIsAlsoFreeTransEnd)
	{
		SPList::Node* tpos = pList->GetLast();
		CSourcePhrase* pSPend = (CSourcePhrase*)tpos->GetData();
		pSPend->m_bEndFreeTrans = TRUE;
	}

    // update the sequence number in the whole source phrase list on the app & update
    // indices for bounds
	UpdateSequNumbers(0);

    // now we can work out where to place the phrase box on exit from this function - it is
    // currently the nSaveActiveSequNum value, unless the active location was within the
    // selection, in which case we must make the active location the first pile after the
    // selection
	if (bActiveLocWithinSelection)
		nSaveActiveSequNum = nEndSequNum + 1;

    // clear the selection, else RecalcLayout() call will fail at the RestoreSelection()
    // call within it
	RemoveSelection();

	// we must have a valid layout, so we have to recalculate it before we go any further,
	// because if preceding code deleted null phrases, the layout's pointers would be clobbered
	// and moving the dialog window would crash the app when Draw messages use the dud pointers
	pApp->m_nActiveSequNum = nSaveActiveSequNum; // legally can be a wrong location eg.
												 // in the retrans, & nothing will break
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	bool bConstType;
	bConstType = IsConstantType(pList); // need this only in case gbInsertingWithinFootnote
										// needs to be set

	// put up the CRetranslationDlg dialog
	CRetranslationDlg dlg(pApp->GetMainFrame());

	// initialize the edit boxes
	dlg.m_sourceText = strSource;
	dlg.m_retranslation = strAdapt;
	wxString preceding;
	preceding.Empty();
	wxString following;
	following.Empty();
	wxString precedingTgt;
	precedingTgt.Empty();
	wxString followingTgt;
	followingTgt.Empty();
	GetContext(nSaveSequNum,nEndSequNum,preceding,following,precedingTgt,followingTgt);
	dlg.m_preContextSrc = preceding;
	dlg.m_preContextTgt = precedingTgt;
	dlg.m_follContextSrc = following;
	dlg.m_follContextTgt = followingTgt;

	if (dlg.ShowModal() == wxID_OK)
	{
		SPList* pRetransList = new SPList;
		wxASSERT(pRetransList);
		wxString retrans = dlg.m_retranslation;
		int nNewCount = 0; // number of CSourcePhrase instances returned from the
						   // tokenization operation

        // tokenize the retranslation into a list of new CSourcePhrase instances on the
        // heap (they are incomplete - only m_key and m_nSequNumber are set)
		nNewCount = TokenizeTextString(pRetransList,retrans,nSaveSequNum);

        // ensure any call to InsertNullSrcPhrase() will work right - that function saves
        // the pApp->m_nActiveSequNum value, and increments it by how many null source
        // phrases were inserted; so we have to present it with the decremented value
        // agreeing with the present state of the layout (which now lacks the deleted null
        // src phrases - if any)
		if (bActiveLocAfterSelection && nNewCount > nCount)
			nSaveActiveSequNum += nNewCount - nCount;
		else
		{
			// augment it also if the active location lay within the selection
			// and null source phrases were inserted
			if (bActiveLocWithinSelection && nNewCount > nCount)
				nSaveActiveSequNum += nNewCount - nCount;
		}
		pApp->m_nActiveSequNum = nSaveActiveSequNum;

        // we must have a valid layout, so we have to recalculate it before we go any
        // further, because if preceding code deleted null phrases, then the layout's
        // pointers will be clobbered
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

		// get a new valid starting pile pointer
		pStartingPile = GetPile(nSaveSequNum);
		wxASSERT(pStartingPile != NULL);

		// determine if we need extra null source phrases inserted, and insert them if we do
		PadWithNullSourcePhrasesAtEnd(pDoc,pApp,pSrcPhrases,nEndSequNum,nNewCount,nCount);

		// copy the retranslation's words, one per source phrase, to the constituted sequence of
		// source phrases (including any null ones) which are to display it
		int nFinish = -1; // it gets set to a correct value in the following call
		BuildRetranslationSourcePhraseInstances(pRetransList,nSaveSequNum,nNewCount,
												nCount,nFinish);
        // delete the temporary list and delete the pointers to the CSourcePhrase instances
        // on the heap
		DeleteTempList(pRetransList);

        // remove the unused saved original source phrase copies & their list too this
        // pSaveList list will possibly have copies which contain non-empty sublists,
        // especially in m_pSavedWords, and the source phrases pointed to by that list will
        // only have had their pointers copied, so we must not delete those pointers,
        // otherwise the originals will contain hanging pointers & we'll crash if we were
        // to retry the retranslation on the same data
		DeleteSavedSrcPhraseSublist(pSaveList);

        // set the active pile pointer - do it here (not earlier), after any null source
        // phrases have been inserted, otherwise if we are near the end of file, the
        // pointer could be invalid because no such pile exists yet
		// BEW addition 08Sep08 for support of vertical editing
		if (!gbVerticalEditInProgress)
		{
			// legacy behaviour
			bool bSetSafely = SetActivePilePointerSafely(pApp,pSrcPhrases,nSaveActiveSequNum,
															pApp->m_nActiveSequNum,nFinish);
			gbSuppressRemovalOfRefString = FALSE; // permit RemoveRefString() in subsequent 
												  // PlacePhraseBox() calls
			gbIsRetranslationCurrent = FALSE;
			if(!bSetSafely)
			{
				// IDS_ALL_RETRANSLATIONS
				wxMessageBox(_(
"Warning: your document is full up with retranslations. This makes it impossible to place the phrase box anywhere in the document."),
				_T(""), wxICON_EXCLAMATION);
                // BEW changed 19Mar09 for refactored layout, to comment out & so allow the
                // phrase box to be shown at the last pile of the document whether there's
                // a retranslation there or not
				//return; // we have to return with no phrase box, since we couldn't find
						  // anywhere it could be put
			}
		}
		else
		{
            // we are in adaptationsStep of vertical editing process, so we want the active
            // pile to be the one immediately following the retranslation; but if that is
            // in the gray text area beyond the end of the editable span, we set a boolean
            // so we can later suppress the reconstruction of the phrase box in the gray
            // area, and just instead immediately cause the dialog asking the user what to
            // do for the next step to be displayed; we also need to deal with the
            // possibility the user's retranslation may make the editable span longer, and
            // update the relevant parameters in gEditRecord
			nVerticalEdit_nExtras = nNewCount - nOriginalCount; // can be -ve, 0 or +ve

			// update the relevant parts of the gEditRecord
			gEditRecord.nAdaptationStep_ExtrasFromUserEdits += nVerticalEdit_nExtras;
			gEditRecord.nAdaptationStep_NewSpanCount += nVerticalEdit_nExtras;
			gEditRecord.nAdaptationStep_EndingSequNum += nVerticalEdit_nExtras;
			
            // set the potential active location to the CSourcePhrase immediately following
            // the end of the retranslation
			int nPotentialActiveSequNum = nSaveSequNum + nNewCount;

            // determine if this location is within the editable span, if it is, we permit
            // the later restoration of the phrase box there; if not, we suppress the
            // restoration of the phrase box (otherwise it would be in the gray text area)
			if (!(nPotentialActiveSequNum >= gEditRecord.nAdaptationStep_StartingSequNum &&
				nPotentialActiveSequNum <= gEditRecord.nAdaptationStep_EndingSequNum))
			{
				bVerticalEdit_SuppressPhraseBox = TRUE;
			}
			nSaveActiveSequNum = nPotentialActiveSequNum; // we need a value to work with below
										// even if we suppress reconstituting of the phrase box
			gbSuppressRemovalOfRefString = TRUE; // suppress RemoveRefString() call within 
												 // PlacePhraseBox()
			bool bSetSafely;
			bSetSafely = SetActivePilePointerSafely(pApp,pSrcPhrases,nSaveActiveSequNum,
														pApp->m_nActiveSequNum,nFinish);
			gbSuppressRemovalOfRefString = FALSE; // permit RemoveRefString() in subsequent 
												  // PlacePhraseBox() calls
			gbIsRetranslationCurrent = FALSE;
		}
	}
	else
	{
		// user cancelled, so we have to restore the original retranslation
		wxASSERT(pSaveList);
		int nCurCount = nEndSequNum - nSaveSequNum + 1; // what the retranslation section
														// now numbers
		int nOldCount = pSaveList->GetCount();
		wxASSERT(nOldCount >0);
        // nOldCount >= nCurCount, because the only thing that could have happened is null
        // source phrases were removed; (and cancellation does not result in parsing what
        // may be in the dialog)
		int nExtras = nOldCount - nCurCount; // needed for adjusting indices
		wxASSERT(nExtras >= 0); // cannot be negative
		gbIsRetranslationCurrent = FALSE;

        // insert the original (saved) source phrases after the nEndSequNum one (the layout
        // may be different than at start, ie. null ones were removed) - nEndSequNum was
        // reduced however so it has the correct value at this point
		SPList::Node* pos = pSrcPhrases->Item(nEndSequNum);
		wxASSERT(pos != 0);
		SPList::Node* pos1 = pSaveList->GetLast();
		wxASSERT(pos1 != 0);

		// Get a node called newInsertBeforePos which points to the next node beyond pos
		// in pSrcPhrases and use its position in the Insert() call (which only inserts
		// BEFORE the indicated position). The result should be that the insertions
		// will get placed in the list the same way that MFC's InsertAfter() places them.
		SPList::Node* newInsertBeforePos = pos->GetNext();
		while (pos1 != 0)
		{
			// these will be minimal ones, so no restoring in KB is required, as these are
			// effectively not 'encountered' yet
			CSourcePhrase* pSPhr = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetPrevious();
			wxASSERT(pSPhr != NULL);

			// wxList has no equivalent to InsertAfter(). The wxList Insert() method
			// inserts the new node BEFORE the current position/node. To emulate what
			// the MFC code does, we insert before using newInsertBeforePos.
			// wx note: If newInsertBeforePos is NULL, it means the insert position is
			// at the end of the list; in this case we just append the item to the end
			// of the list.
			if (newInsertBeforePos == NULL)
				pSrcPhrases->Append(pSPhr);
			else
				pSrcPhrases->Insert(newInsertBeforePos,pSPhr);

			// BEW added 13Mar09 for refactored layout
			GetDocument()->CreatePartnerPile(pSPhr);

			// since we must now insert before the inserted node above, we need to get a
			// previous node (which will actually be the just inserted source phrase)
			newInsertBeforePos = newInsertBeforePos->GetPrevious();
		}

        // now remove the unwanted ones - be careful, some of these single-word ones will
        // point to memory that any merged source phrases in the saved list will point to
        // in their m_pSavedWords sublists, so don't delete the memory in the latter
        // sublists, just remove the pointers!
		RemoveUnwantedSourcePhraseInstancesInRestoredList(pSrcPhrases, nCurCount, 
															nSaveSequNum, pSaveList);
		// set the active sequ number - it must not be in the retranslation
		int nSequNumImmedAfter = nSaveSequNum + nOldCount;
		if (nSaveActiveSequNum < nSaveSequNum)
		{
			// it earlier than retranslation, so leave it unchanged
			;
		}
		else if (nSaveActiveSequNum < nSequNumImmedAfter)
		{
			// it's still within the retranslation, which is illegal, 
			// so put it immed after
			nSaveActiveSequNum = nSequNumImmedAfter;
		}
		else
		{
			// add nExtras to it, to preserve it's former value
			nSaveActiveSequNum += nExtras; // we can assume nExtras is positive
		}

		// renumber the sequence numbers
		UpdateSequNumbers(0);

        // remove the pointers in the saved list, and delete the list, but leave the
        // instances undeleted since they are now pointed at by elements in the pSrcPhrases
        // list
		if (pSaveList->GetCount() > 0)
		{
			pSaveList->Clear();
		}
		delete pSaveList; // don't leak memory
	}

	// delete the temporary list after removing its pointer copies
	pList->Clear();
	delete pList;

    // recalculate the layout from the first strip in the selection, 
    // to force the text to change color
	pApp->m_nActiveSequNum = nSaveActiveSequNum;
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(nSaveActiveSequNum);

	// get the CSourcePhrase at the active location
	pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
	wxASSERT(pSrcPhrase != NULL);

	// determine the text to be shown, if any, in the target box when it is recreated
	// BEW additions 08Sep08 for support of vertical editing mode
	wxString str3; // use this one for m_targetStr contents
	// define the operation type, so PlacePhraseBoxInLayout() can do its job correctly
	GetLayout()->m_docEditOperationType = edit_retranslation_op;
	if (gbVerticalEditInProgress && bVerticalEdit_SuppressPhraseBox)
	{
        // vertical edit mode is in operation, and a recalc of the layout has been done, so
        // it remains just to determine whether or not to suppress the phrase box and if so
        // to transition to the next step, otherwise send control to the legacy code to
        // have the phrase box created at the active location
        
        // the active location is in the gray text area, so don't build the phrase box
        // (in wxWidgets, instead hide the phrase box at this point); and instead
        // transition to the next step
		bool bCommandPosted;
		bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(-1, nextStep, TRUE);
		// no Invalidate() call made in this block, because a later point in the process
		// should draw the layout anew (I'm guessing, but I think it's a safe guess)
	}
	else
	{
		str3.Empty();

		// we want text with punctuation, for the 4-line version
		if (!pSrcPhrase->m_targetStr.IsEmpty() && 
			(pSrcPhrase->m_bHasKBEntry || pSrcPhrase->m_bNotInKB))
		{
			str3 = pSrcPhrase->m_targetStr;
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
            // the Jump( ) call embedded in the PlacePhraseBox( ) which is in turn within
            // SetActivePilePointerSafely( ) will clear the adaptation (or reduce its ref
            // count,) if it exists at the active location; which will cause the above test
            // to land control in this block; so we don't want to do a lookup (it would not
            // find anything if the jump removed the adaptation, and then the source would
            // be copied) because we could then lose the phrasebox contents when in fact
            // they are still good - so if the sourcephrase at the active location has a
            // nonempty target string, we'll use that. Otherwise, get it by a lookup.
			if (pSrcPhrase->m_targetStr.IsEmpty())
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				RestoreTargetBoxText(pSrcPhrase,str3); // for getting a suitable 
													   // m_targetStr contents
			}
			else
			{
				str3 = pSrcPhrase->m_targetStr;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
		}

        // it is okay to do the Remove call with pRefString == NULL, in fact, it must be
        // done whether NULL or not; since if it is NULL, RemoveRefString will clear
        // pSrcPhrase's m_bHasKBEntry to FALSE, which if not done, would result in a crash
        // if the user clicked on a source phrase which had its reference string manually
        // removed from the KB and then clicked on another source phrase. (The
        // StoreAdaption call in the second click would trip the first line's ASSERT.)
		CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
											pSrcPhrase->m_key,pSrcPhrase->m_adaption);
		RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

		pApp->m_targetPhrase = str3;
		if (pApp->m_pTargetBox != NULL)
		{
			pApp->m_pTargetBox->ChangeValue(str3);
		}

        // layout again, so that the targetBox won't encroach on the next cell's adaption
        // text (can't just layout the strip, because if the text is long then source
        // phrases get pushed off into limbo and we get access violation & null pointer
        // returned in the GetPile call)
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		
		// get a new valid active pile pointer
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

		pApp->m_nStartChar = -1;
		pApp->m_nEndChar = -1;

		// remove selection and update the display
		RemoveSelection();
		Invalidate();
		GetLayout()->PlaceBox();
	}

	// ensure respect for boundaries is turned back on
	if (!pApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(event);
	gbInsertingWithinFootnote = FALSE; // restore default value
}

// Invalid function when glossing is ON, so it just returns.
void CAdapt_ItView::OnRemoveRetranslation(wxCommandEvent& event)
{
	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_("This particular operation is not available when you are glossing."),
		_T(""), wxICON_INFORMATION);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	SPList* pList = new SPList; // list of the CSourcePhrase objects in the retranslation section
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile = NULL;
	CSourcePhrase* pSrcPhrase = NULL;
	CCell* pCell = NULL;

    // get the source phrases which comprise the section which is retranslated; first check
    // if we have a selection, and if so start from the first pile in the selection;
    // otherwise, the location to start from must be the target box's location (ie. the
    // active pile); if it's neither of those then we have an error condition
	CCellList::Node* cpos;
	if (pApp->m_selectionLine != -1)
	{
		// there is a selection current
		cpos = pApp->m_selection.GetFirst();
		pCell = (CCell*)cpos->GetData();
		if (pCell != NULL)
		{
			pStartingPile = pCell->GetPile();
			pSrcPhrase = pStartingPile->GetSrcPhrase();
			if (!pSrcPhrase->m_bRetranslation)
			{
				// an error state
				// IDS_NO_REMOVE_RETRANS
h:				wxMessageBox(_(
"Sorry, the whole of the selection was not within a section of retranslated text, so the command has been ignored."), 
				_T(""), wxICON_EXCLAMATION);
				RemoveSelection();
				delete pList;
				Invalidate();
				GetLayout()->PlaceBox();
				return;
			}
		}
	}

	// also check that the end of the selection is also part of the 
	// retranslation, if not, return
	cpos = pApp->m_selection.GetLast();
	pCell = (CCell*)cpos->GetData();
	CPile* pPile2 = pCell->GetPile();
	if (!pPile2->GetSrcPhrase()->m_bRetranslation)
	{
		// an error state
		goto h;
	}
	else
	{
        // must also check that there is no preceding pile which has a sourcephrase with
        // its m_bEndRetranslation flag set TRUE, if so, the selection lies in a following
        // retranslation section, and so the selection is invalid for delineating one
        // retranslation
		bool bCurrentSection = IsEndInCurrentSelection();
		if (!bCurrentSection)
			goto h;
	}

	// we are in a retranslation section, so get the source phrases into pList
	RemoveSelection();
	CPile* pFirstPile = 0;
	GetRetranslationSourcePhrasesStartingAnywhere(pStartingPile,pFirstPile,pList);

	int nStartingSequNum = pFirstPile->GetSrcPhrase()->m_nSequNumber;

    // We must first check if the active location is outside the selection - since there
    // could be a just-edited entry in the phrase box which is not yet entered in the
    // knowledge base, and the active location's source phrase doesn't yet have its
    // m_adaption and m_targetStr members updated, so we must check for this condition and
    // if it obtains then we must first update everything at the active location before we
    // proceed
	if (pApp->m_pActivePile != NULL)
	{
		CSourcePhrase* pActiveSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
		pDoc->ResetPartnerPileWidth(pActiveSrcPhrase); // mark its strip as invalid
		SPList::Node* pos = pList->GetFirst();
		bool bInSelection = FALSE;
		while (pos != NULL)
		{
			CSourcePhrase* pSP = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (pSP == pActiveSrcPhrase)
			{
				bInSelection = TRUE;
				break;
			}
		}
		if (!bInSelection)
		{
            // the active location is not within the retranslation section, so update
            // before throwing it all out
			MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(),pApp->m_targetPhrase);
			RemovePunctuation(pDoc, &pApp->m_targetPhrase, from_target_text);
			if (pApp->m_targetPhrase != pApp->m_pActivePile->GetSrcPhrase()->m_adaption)
			{
				gbInhibitLine4StrCall = TRUE;
				bool bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->GetSrcPhrase(),
										pApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
				if (!bOK)
					return; // can't proceed until a valid adaption (which could be null)
							// is supplied for the former active pile's srcPhrase
				else
				{
					// make the former strip be marked invalid - new layout
					// code will then tweak the layout from that point on
					int nFormerStrip = pApp->m_pActivePile->GetStripIndex();
					int nCurStripIndex = pStartingPile->GetStripIndex();
					if (nCurStripIndex != nFormerStrip)
					{
						CStrip* pFormerStrip = (CStrip*)
							GetLayout()->GetStripArray()->Item(nFormerStrip);
#ifdef _ALT_LAYOUT_
						CPile* pItsFirstPile = pFormerStrip->GetPileByIndexInStrip(0);
#else
						CPile* pItsFirstPile = (CPile*)
							pFormerStrip->GetPilesArray()->Item(0);
#endif
						CSourcePhrase* pItsFirstSrcPhrase = 
												pItsFirstPile->GetSrcPhrase();
						// mark this strip as invalid too (some extra insurance)
						pDoc->ResetPartnerPileWidth(pItsFirstSrcPhrase,TRUE); // TRUE 
													// is bNoActiveLocationCalculation
					}
				}
			}
		}
	}

    // accumulate the translation text of the old retranslation, so that we can put it in
    // the compose bar's CEdit, in case user wants it preserved
	wxString strAdapt; // accumulates the existing adaptation text for the retranslation
	strAdapt.Empty();
	wxString str2; // a temporary storage string
	str2.Empty();
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		// accumulate the old retranslation's text
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		str2 = pSrcPhrase->m_targetStr;
		if (strAdapt.IsEmpty())
		{
			strAdapt += str2;
		}
		else
		{
			if (!str2.IsEmpty())
				strAdapt += _T(" ") + str2;
		}
	}

	// put the text in the compose bar
	CMainFrame* pMainFrm = pApp->GetMainFrame();
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	if(pBar != NULL)
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			pEdit->ChangeValue(strAdapt);
		}
	}

    // any null source phrases have to be thrown away, and the layout recalculated after
    // updating the sequence numbers of the source phrases remaining
	pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	int nCount = pList->GetCount();
	int nDeletions = 0; // number of null source phrases to be deleted
    // BEW added 01Aug05, to support free translations -- removing null source phrases also
    // removes m_bHasFreeTrans == TRUE instances as well, so the only thing we need check
    // for is whether or not there is m_bEndFreeTrans == TRUE on the last null source
    // phrase removed -- if so, we must set the same bool value to TRUE on the last
    // pSrcPhrase remaining in the list after all the null ones have been deleted. We do
    // this by setting a flag in the block below, and then using the set flag value in the
    // block which follows it
	bool bEndIsAlsoFreeTransEnd = FALSE;
	while (pos != NULL)
	{
		SPList::Node* savePos = pos;
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_bNullSourcePhrase)
		{
            // it suffices to test each one, since the m_bEndFreeTrans value will be FALSE
            // on every one, or if not so, then only the last will have a TRUE value
			if (pSrcPhrase->m_bEndFreeTrans)
				bEndIsAlsoFreeTransEnd = TRUE;

            // null source phrases in a retranslation are never stored in the KB, so we
            // need only remove their pointers from the lists and delete them from the heap
			nDeletions++; // count it
			SPList::Node* pos1 = pSrcPhrases->Find(pSrcPhrase); 
			wxASSERT(pos1 != NULL); // it has to be there
			pSrcPhrases->DeleteNode(pos1); // remove its pointer from m_pSourcePhrases
										 // list on the doc

			// BEW added 13Mar09 for refactor of layout; delete its partner pile too 
			GetDocument()->DeletePartnerPile(pSrcPhrase);

			delete pSrcPhrase->m_pMedialPuncts;
			delete pSrcPhrase->m_pMedialMarkers;
			pSrcPhrase->m_pSavedWords->Clear();
			delete pSrcPhrase->m_pSavedWords;
			delete pSrcPhrase; // delete the null source phrase itself
			pList->DeleteNode(savePos); // also remove its pointer from the local sublist
		}
		else
		{
            // of those source phrases which remain, throw away the contents of their
            // m_adaption member, and also the m_targetStr member, and clear the flags for
            // start and end, and clear the flags which designate them as retranslations
            // and not in the KB
			pSrcPhrase->m_adaption.Empty();
			pSrcPhrase->m_targetStr.Empty();
			pSrcPhrase->m_bRetranslation = FALSE;
			if (IsItNotInKB(pSrcPhrase))
				pSrcPhrase->m_bNotInKB = TRUE;
			else
				pSrcPhrase->m_bNotInKB = FALSE;
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pSrcPhrase->m_bBeginRetranslation = FALSE;
			pSrcPhrase->m_bEndRetranslation = FALSE;

			// we have to restore the original punctuation too
			RestoreOriginalPunctuation(pSrcPhrase);

			// these pSrcPhrase instances have to have their partner piles' 
			// widths recalculated
			GetDocument()->ResetPartnerPileWidth(pSrcPhrase);
		}
	}

	if ((int)pList->GetCount() < nCount)
	{
		// handle transferring the indication of the end of a free translation
		if (bEndIsAlsoFreeTransEnd)
		{
			SPList::Node* spos = pList->GetLast();
			CSourcePhrase* pSPend = (CSourcePhrase*)spos->GetData();
			pSPend->m_bEndFreeTrans = TRUE;
		}

		// update the sequence numbers to be consecutive across the deletion location
		UpdateSequNumbers(nStartingSequNum);
	}

	// BEW added 09Sep08 in support of vertical editing mode
	if (gbVerticalEditInProgress && nDeletions != 0)
	{
		gEditRecord.nAdaptationStep_EndingSequNum -= nDeletions;
		gEditRecord.nAdaptationStep_ExtrasFromUserEdits -= nDeletions;
		gEditRecord.nAdaptationStep_NewSpanCount -= nDeletions;
	}

    // we must allow the user the chance to adapt the section of source text which is now
    // no longer a retranslation, so the targetBox must be placed at the first pile of the
    // section - but first we must recalculate the layout
	pApp->m_nActiveSequNum = nStartingSequNum;

	// define the operation type, so PlaceBox() // can do its job correctly
	GetLayout()->m_docEditOperationType = remove_retranslation_op;

	// now do the recalculation of the layout & update the active pile pointer
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum); // need this up-to-date so that
				// RestoreTargetBoxText( ) call will not fail in the code which is below
	// get the text to be displayed in the target box, if any
	SPList::Node* spos = pList->GetFirst();
	pSrcPhrase = (CSourcePhrase*)spos->GetData();
	wxString str3;
	if (pSrcPhrase->m_targetStr.IsEmpty() && !pSrcPhrase->m_bHasKBEntry && 
		!pSrcPhrase->m_bNotInKB)
	{
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
		RestoreTargetBoxText(pSrcPhrase,str3); // for getting a suitable 
											   // m_targetStr contents
	}
	else
	{
		str3 = pSrcPhrase->m_targetStr; // if we have something
		pApp->m_pTargetBox->m_bAbandonable = FALSE;
	}
	pApp->m_targetPhrase = str3; // update what is to be shown in the phrase box

	// ensure the selection is removed
	RemoveSelection();

	// scroll if necessary
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	pList->Clear();
	delete pList;

	Invalidate();
	GetLayout()->PlaceBox();

	// ensure respect for boundaries is turned back on
	if (!pApp->m_bRespectBoundaries)
		OnButtonFromIgnoringBdryToRespectingBdry(event);
	gbInsertingWithinFootnote = FALSE; // restore default value
}

// old code was based on code in TokenizeText in doc file; new code is based on code in
// RemovePunctuation() which is much smarter & handles word-building punctuation properly
void CAdapt_ItView::RestoreOriginalPunctuation(CSourcePhrase *pSrcPhrase)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxString src = pSrcPhrase->m_srcPhrase;

	// first, clear any punctuation resulting from the retranslation
	pSrcPhrase->m_precPunct.Empty();
	pSrcPhrase->m_follPunct.Empty();
	pSrcPhrase->m_pMedialPuncts->Clear();
	pSrcPhrase->m_bHasInternalPunct = FALSE;

	wxString punctSet = pApp->m_punctuation[0]; // from version 1.3.6, contains spaces 
												// as well as punct chars
	// ensure there is at least one space, so "<< <" and similar sequences 
	// get spanned properly
	if (punctSet.Find(_T(' ')) == -1)
	{
		// no space in it yet, so put one there (done on the local variable only,
		// so m_punctSet[0] unchanged)
		punctSet += _T(' ');
	}

	if (FindOneOf(src,punctSet) == -1)
		return; // there are no punctuation chars in the string (except possibly
				// word-building ones) and no spaces either

	// get the preceding punctuation
	wxString precStr;
	precStr.Empty();
	int len = 0;
	wxString tempStr;
	tempStr.Empty();
	int totalLength = src.Length();
	precStr = SpanIncluding(src,punctSet);
	len = precStr.Length();
	if (len > 0)
	{
		// has initial punctuation, so strip it off and store it
		pSrcPhrase->m_precPunct = precStr;
		tempStr = pSrcPhrase->m_srcPhrase.Mid(len); // tempStr holds the rest after the punct.
		totalLength -= len; // reduce by size of punctuation chars in set
	}
	else
	{
		// no initial punctuation, so copy the lot to tempStr
		tempStr = pSrcPhrase->m_srcPhrase;
	}

	// now handle any following punctuation
	wxString key = tempStr;
	key = MakeReverse(key);
	wxString follStr;
	follStr.Empty();
	totalLength = key.Length();
	follStr = SpanIncluding(key,punctSet);
	len = follStr.Length();
	if (len > 0)
	{
		// has following punctuation so strip it off, store it (after reversing it again)
		follStr = MakeReverse(follStr);
		pSrcPhrase->m_follPunct = follStr;
		key = key.Mid(len);
		key = MakeReverse(key);
		pSrcPhrase->m_key = key;
	}
	else
	{
		// no following punctuation
		pSrcPhrase->m_key = tempStr;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. This handler disables the "Knowledge Base Editor..."
/// item in the Tools menu if the appropriate KB is not in a ready state, otherwise it
/// enables the "Knowledge Base Editor..." item on the Tools menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateToolsKbEditor(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT( pApp != NULL );

	if ((!gbIsGlossing && pApp->m_bKBReady && pApp->m_pKB != NULL) ||
		(gbIsGlossing && pApp->m_bGlossingKBReady && pApp->m_pGlossingKB != NULL))
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::OnToolsKbEditor(wxCommandEvent& WXUNUSED(event))
{
 	CAdapt_ItApp* pApp = &wxGetApp();
    // whm 23Jan09 Refactored the CKBEditor class and this handler. Changes to this handler
    // involved moving most of the intitializations of CKBEditor members to the CKBEditor
    // class itself, and eliminating several global variables that were only used in this
    // handler and in CKBEditor.
    // 
    // wx version: Since the Tools KB Edit menu item has an accelerator table hot key
    // (CTRL-K see CMainFrame) and wxWidgets accelerator keys call menu and toolbar
    // handlers even when they are disabled, we must check for a disabled button and return
    // if disabled. On Windows, the accelerator key doesn't appear to call the handler for
    // a disabled menu item, but I'll leave the following code here in case it works
    // differently on other platforms.
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_TOOLS_KB_EDITOR))
	{
		::wxBell();
		return;
	}

	CKBEditor editorPage(pApp->GetMainFrame());
	editorPage.Centre();

	if (editorPage.ShowModal() == wxID_OK) 
	{
		// make the user's changes to the KB persistent (FALSE = no Auto backup)
		// whm TODO: Saving of KBs should only be done if a change was made in the KB Editor
		if (gbIsGlossing)
			pApp->SaveGlossingKB(FALSE);
		else
			pApp->SaveKB(FALSE);
	}

	// restore focus to the targetBox
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_pTargetBox->IsShown())
		{
			int len = pApp->m_targetPhrase.Length();
			pApp->m_nStartChar = len;
			pApp->m_nEndChar = len;
			pApp->m_pTargetBox->SetSelection(len,len);
			pApp->m_pTargetBox->SetFocus();
		}
	}

	// BEW added 20May09, next line required in order to remove the selection
	// Note, this function can be called after having done a Restore Knowledge Base
	// command and the latter requires no document be open, and in that case a call to
	// Redraw() will fail, so we have to wrap the Redraw() and PlaceBox() calls with a
	// test to ensure the box exists and a layout is available for redrawing - but the
	// latter is sufficient, because if the layout is available, so will the phrase box be
	if (GetLayout()->GetPileList()->GetCount() > 0 && GetLayout()->GetStripArray()->GetCount() > 0)
	{
		// a layout exists
		GetLayout()->Redraw();
		GetLayout()->PlaceBox(); // this call probably unneeded but no harm done
	}
}

// the rpRec value will be undefined if FALSE is returned, if TRUE is returned, rpRec will
// be the matched auto-fix item in the list. For version 2.0 and later which supports
// glossing, rpRec could contain glossing or adapting information, depending on the setting
// for the gbIsGlossing flag. Also, in support of auto capitalization; since these strings
// are coming from the sourcephrase instances in the documents, they will have upper or
// lower case as appropriate; but we will need to allow the user to just type lower case
// strings when correcting in the context of AutoCaps being turned ON, so be careful!
bool CAdapt_ItView::MatchAutoFixItem(AFList* pList,CSourcePhrase *pSrcPhrase,
									 AutoFixRecord*& rpRec)
{
	wxASSERT(pList != NULL);
	wxASSERT(pSrcPhrase != NULL);
	if (pList->IsEmpty())
		return FALSE;
	AFList::Node* pos = pList->GetFirst(); 
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		AutoFixRecord* pRec = (AutoFixRecord*)pos->GetData();
		pos = pos->GetNext();
		bool bTest = FALSE;
		if (gbIsGlossing)
		{
			if (pRec->key == pSrcPhrase->m_key && 
				pRec->oldAdaptation == pSrcPhrase->m_gloss)
				bTest = TRUE;
		}
		else
		{
			if (pRec->key == pSrcPhrase->m_key && 
				pRec->oldAdaptation == pSrcPhrase->m_adaption)
				bTest = TRUE;
		}
		if (bTest)
		{
            // we can autofix with this one, so pass its values (including any upper case)
            // to the caller (ie. to DoConsistencyCheck( )) for processing - remember, it
            // may have an old gloss or adaptation which is upper case, and the user may
            // have typed a lower case string for the finalAdaptation member, so this will
            // need to be tested for
			rpRec = pRec;
			return TRUE;
		}
	}
	// if we get to here, no match was made
	rpRec = NULL;
	return FALSE;
}

void CAdapt_ItView::OnGoTo(wxCommandEvent& WXUNUSED(event))
{
	// refactored 17Apr09
    // Since the Edit Go To... menu item has an accelerator table hot key (CTRL-G see
    // CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even when
    // they are disabled, we must check for a disabled button and return if disabled. On
    // Windows, the accelerator key doesn't appear to call the handler for a disabled menu
    // item, but I'll leave the following code here in case it works differently on other
    // platforms.
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_GO_TO))
	{
		::wxBell();
		return;
	}

	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos;
	if (pList->IsEmpty())
	{
		::wxBell();
		return;
	}

    // BEW added 28Sep05, to fix the following bug. It the globals below are not here
    // reset, and especially to the same value, then when we've been doing autoinseting at
    // a location somewhere and we go to a very different location far away in the
    // document, any call to ScrollIntoView() will invoke its "smart" code -- that takes
    // the two globals below and if they are different, it will ask for a recalculation of
    // the pile pointers for the beginning and end of the last inserted set of adaptations
    // -- and these require GetPile() calls which, because that old location was miles away
    // further away in the document, a bundle advance and layout recalculation get done in
    // order to get valid pointers - and on return from ScrollIntoView() the layout is no
    // longer where expected and the active pointer has probably become invalid. Setting
    // both globals to zero avoids all and causes the legacy scrolling block to be used in
    // ScrollIntoView(), as wanted. (may not need this in refactored layout, but leave it)
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, & make both be same

    // provided the phrase box exists, unconditionally enter the old phrase box's text into
    // the KB - we assume it is complete, if not, too bad - it can be fixed later if it's
    // wrong. Oct 2004, Wolfgang Stradner requested that nothing be put in KB when Go To...
    // is being used to move around. So we look at the srcphrase and if it's m_adaption
    // member is null and the m_bAbandonable flag on the box is TRUE, then the m_targetBox
    // contents can be assumed to be unwanted and so not stored. (The step up/down buttons
    // make this kind of check already.)
	bool bOK;
	CRefString* pRefStr;
	if (pApp->m_nActiveSequNum != -1)
	{
		gnOldSequNum = pApp->m_nActiveSequNum; // preserve old location
		if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
			// abandon storage when not wanted (test added Oct 2004 - see above comment)
			bool bSkipStorage = FALSE;
			if (!pApp->m_pActivePile->GetSrcPhrase()->m_adaption.IsEmpty())
			{
				pApp->m_targetPhrase = pApp->m_pActivePile->GetSrcPhrase()->m_adaption;
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
			else
			{
				pApp->m_pTargetBox->m_bAbandonable = TRUE;
				pApp->m_targetPhrase.Empty();
				bSkipStorage = TRUE;
			}

			if (!bSkipStorage && gbIsGlossing)
			{
                // the store will fail if the user edited the entry out of the glossing KB,
                // the latter cannot know which srcPhrases will be affected, so these will
                // still have their m_bHasGlossingKBEntry set true. We have to test for
                // this, ie. a null pRefString but the m_bHasGlossing KBEntry set TRUE is a
                // sufficient test, and if so, set the flag to FALSE
				pRefStr = GetRefString(pApp->m_pGlossingKB,1,
						pApp->m_pActivePile->GetSrcPhrase()->m_key,pApp->m_targetPhrase);
				if (pRefStr == NULL && 
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
				bOK = StoreText(pApp->m_pGlossingKB,pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_targetPhrase);
			}
			else if (!bSkipStorage && !gbIsGlossing)
			{
				MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(),pApp->m_targetPhrase);
				RemovePunctuation(pDoc, &pApp->m_targetPhrase, from_target_text);

                // the store will fail if the user edited the entry out of the KB, as the
                // latter cannot know which srcPhrases will be affected, so these will
                // still have their m_bHasKBEntry set true. We have to test for this, ie. a
                // null pRefString but the m_bHasKBEntry set TRUE is a sufficient test, and
                // if so, set the flag to FALSE
				pRefStr = GetRefString(pApp->m_pKB,
								pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
								pApp->m_pActivePile->GetSrcPhrase()->m_key,
								pApp->m_targetPhrase);
				if (pRefStr == NULL && pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
				gbInhibitLine4StrCall = TRUE;
				bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
			}
		}
	}
	else
	{
		gnOldSequNum = -1; // if we were at the eof, need -1 
						   // to signal no earlier valid location
	}

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	wxString str;
	int nWantedChapter = 1;
	int nWantedVerse = 1;
	CGoToDlg dlg(pApp->GetMainFrame());
	if (dlg.ShowModal() == wxID_OK)
	{
		nWantedChapter = dlg.m_nChapter;
		nWantedVerse = dlg.m_nVerse; // from Oct 2004 extended version, this can be 0
						// which means "ignore the verse number, use chapter number only"

		// find the nominated chapter and verse, if possible, using the CString for chapt:verse;
		// if it fails, assume a range & try again with integers; but if verse is 0, then go straight
		// to the range block
		if (dlg.m_nVerse == 0)
			goto v;
		if (dlg.m_nChapter == 0)
		{
			// special case, either its non-scripture, or a chapterless book like 2John
			pos = pList->GetFirst();
			wxASSERT(pos != NULL);

			// first, assume it's a chapterless book like 2 John, try find the verse
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL); 
				if (pSrcPhrase->m_chapterVerse == dlg.m_verse)
				{
					if (!gbIsGlossing)
					{
						// when adapting, we must prevent placing the phrasebox within a
						// retranslation, but when glossing this does not matter
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									//IDS_GOTO_FAILED
									wxMessageBox(_(
"Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"),
									_T(""), wxICON_EXCLAMATION);
									pApp->m_pTargetBox->SetFocus();
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation,
					// as close to wanted loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}
					return;
				}
			}

			// didn't find the verse, so instead put the phrase box at the first sourcephrase
			// with TextType of 'verse'
			pos = pList->GetFirst();
			wxASSERT(pos != NULL);
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_curTextType == verse)
				{
					if (!gbIsGlossing)
					{
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									// IDS_GOTO_FAILED
									wxMessageBox(_(
"Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"),
									_T(""),wxICON_EXCLAMATION);
									pApp->m_pTargetBox->SetFocus();
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}

					return;
				}
			}
		} // end chapter number == zero block
		else
		{
			// look for chapter & verse in the form  n:m
			pos = pList->GetFirst();
			wxASSERT(pos != NULL);
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_chapterVerse == dlg.m_chapterVerse)
				{
					if (!gbIsGlossing)
					{
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									// IDS_GOTO_FAILED
									wxMessageBox(_(
"Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"),
									_T(""), wxICON_EXCLAMATION);
									pApp->m_pTargetBox->SetFocus();
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}

					return;
				}
			}

			// not found, so try again, this time assuming we may have the wanted ch & verse
			// within a range in the text, such as 3-7, or 3,4 etc; or the verse may have been
			// set to zero so that only chapter numbers are to be considered
v:			pos = pList->GetFirst();
			wxASSERT(pos != NULL);
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSrcPhrase != NULL);

				int chapter;
				int firstVerse;
				int lastVerse;
                // BW, Oct 04, extended the signature to take the nWantedVerse as an extra
                // parameter, so that when it is zero in value we can force a return once a
                // chapter beginning has been located; this extra parameter has no other
                // internal function in the AnalyseReference function, and since this
                // function is called in nearly a dozen other places, those places just
                // need an arbitrary non-zero number passed in for the nWantedVerse number
                // so as to retain the previous functionality unchanged
				bool bOK =
					AnalyseReference(pSrcPhrase->m_chapterVerse,chapter,firstVerse,
									lastVerse,nWantedVerse);

				// if we've already passed the chapter, return
				if (bOK && chapter > nWantedChapter)
					goto a;

				if (bOK && chapter == nWantedChapter && nWantedVerse == 0)
					goto f;

				if (bOK && chapter == nWantedChapter && (nWantedVerse >= firstVerse
					&& nWantedVerse <= lastVerse))
				{
f:					if (!gbIsGlossing)
					{
						if (pSrcPhrase->m_bRetranslation)
						{
							CSourcePhrase* pSaveSP = pSrcPhrase;
							pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);

							if (pSrcPhrase == NULL)
							{
								pSrcPhrase = GetFollSafeSrcPhrase(pSaveSP);

								if (pSrcPhrase == NULL)
								{
									// nowhere is a safe location! (Is the user retranslating
									// everything? !!!)
									// IDS_GOTO_FAILED
									wxMessageBox(_(
"Sorry, the Go To command failed. No valid location for the phrase box could be found before or after your chosen chapter and verse. (Are all your adaptations in the form of retranslations?)"),
									_T(""), wxICON_EXCLAMATION);
									pApp->m_pTargetBox->SetFocus();
									goto b; // don't jump anywhere
								}
							}
						}
					}

					// jump to whatever pile is not in a retranslation, as close to wanted
					// loc'n as possible
					Jump(pApp,pSrcPhrase);

					// if the user has turned on the sending of synchronized scrolling
					// messages, send the relevant message
					if (!gbIgnoreScriptureReference_Send)
					{
						SendScriptureReferenceFocusMessage(pApp->m_pSourcePhrases,pSrcPhrase);
					}

					return;
				}

				if (bOK && chapter == nWantedChapter &&  nWantedVerse != 0
						&& lastVerse > nWantedVerse) // if passed the wanted verse
					goto a;
			}

			// not found, so tell the user
			//IDS_NO_SUCH_CHAPTER
a:			str = str.Format(_(
"Sorry, but the chapter and verse combination  %s  does not exist in this document. The command will be ignored."),
			dlg.m_chapterVerse.c_str());
			wxMessageBox(str,_T(""), wxICON_EXCLAMATION);
			pApp->m_pTargetBox->SetFocus();
			goto b;
		}
	}
	else
	{
		// user cancelled, so do nothing except remove the ref string that we stored above
		// (and most importantly, this will clear the m_bHasKBEntry on the source phrase too)
b:		CRefString* pRefStr = NULL;
		if (gbIsGlossing)
		{
			pRefStr = GetRefString(pApp->m_pGlossingKB, 1,
							pApp->m_pActivePile->GetSrcPhrase()->m_key,pApp->m_targetPhrase);
			if (pRefStr == NULL && pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
				pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
			if (pRefStr != NULL)
			{
				// remove the translation from the glossing KB, in case user wants to edit it
				// before it is stored again
				RemoveRefString(pRefStr, pApp->m_pActivePile->GetSrcPhrase(), 
									from_target_text);
			}
		}
		else
		{
			pRefStr = GetRefString(pApp->m_pKB,
				pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
				pApp->m_pActivePile->GetSrcPhrase()->m_key,pApp->m_targetPhrase);
			if (pRefStr == NULL && pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
				pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
			if (pRefStr != NULL)
			{
                // remove the translation from the KB, in case user wants to edit it before
                // it is stored again
				RemoveRefString(pRefStr,pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords);
			}
		}
	}
}

bool CAdapt_ItView::AnalyseReference(wxString& chVerse,int& chapter,int& vFirst,
									 int& vLast,int nWantedVerse)
{
	int chap = -1;
	int firstVerse = -1;
	int lastVerse = -1;
	if (chVerse.IsEmpty())
		return FALSE; // premature exit, no chapter or verse on this srcPhrase
	wxString range;
	range.Empty();

	// first determine if there is a chapter number present
	int nFound = chVerse.Find(_T(':'));
	if (nFound < 0)
	{
		// no chapter number, so  set chapter to zero
		range = chVerse;
		chap = 0;
	}
	else
	{
		// chapter number exists, extract it and put the remainder after the colon into range
		wxString strChapter = SpanExcluding(chVerse,_T(":"));
#ifdef __WXMAC__
// Kludge because the atoi() function in the MacOS X standard library can't handle Arabic digits
		for (size_t imak=0; imak < strChapter.Len(); imak++)
		{
			wxChar imaCh = strChapter.GetChar(imak);
			if (imaCh >= (wchar_t)0x6f0 && imaCh <= (wchar_t)0x6f9)
				strChapter.SetChar(imak, imaCh & (wchar_t)0x3f);	// zero out the higher bits of these Arabic digits
		}
#endif /* __WXMAC__ */
		chap = wxAtoi(strChapter); 

		nFound++; // index the first char after the colon
		range = chVerse.Mid(nFound);

		// if wanted verse is zero, then exit now since we have a chapter located
		if (nWantedVerse == 0)
		{
			chapter = chap;
			return TRUE;
		}
	}

	// potentially we have a range, so first see if it is a range specified by a hyphen separator
	nFound = range.Find(_T('-'));
	if (nFound >= 0)
	{
		// it is a range, find first & last verse numbers
		wxASSERT(nFound != 0); // must be an initial verse number
		wxString verseFirst = SpanExcluding(range,_T("-"));
		firstVerse = wxAtoi(verseFirst);
		nFound++;
		wxString verseLast = range.Mid(nFound);
		lastVerse = wxAtoi(verseLast);
	}
	else
	{
		// no hyphenated range, so try a comma-delimited range
		nFound = range.Find(_T(','));
		if (nFound < 0)
		{
			// its neither, so it's something unknown, so assume its just a single verse number
			firstVerse = lastVerse = wxAtoi(range);
			// from version 2.0.5 and onwards we allow verse numbers to have unlimited maximum
			// value
			chapter = chap;
			vFirst = firstVerse;
			vLast = lastVerse;
			return TRUE;
		}
		else
		{
            // it's a comma-delimited range, so get first and last verse numbers (assume
            // n,m structure) note: printing code will allow comma delimited ranges of form
            // n,m,o,p,q etc (see ExtractChapterAndVerse in ..view.cpp), so if the fact
            // that AnalyseReference permits only n,m ever becomes an issue for someone,
            // the copy the extra bit of code needed into the block below (actually, it may
            // be possible to get rid of the latter function and just use the Extract....
            // one.)
			wxASSERT(nFound != 0); // must be an initial verse number
			wxString verseFirst = SpanExcluding(range,_T(","));
			firstVerse = wxAtoi(verseFirst);
			nFound++;
			wxString verseLast = range.Mid(nFound);
			lastVerse = wxAtoi(verseLast);
		}
	}

	// return the values found
	chapter = chap;
	vFirst = firstVerse;
	vLast = lastVerse;
	return TRUE;
}

// while this appears to be coded for a forward jump only, actually it works equally well
// for arbitrary distance forward or backwards jumps
void CAdapt_ItView::Jump(CAdapt_ItApp* pApp, CSourcePhrase* pNewSrcPhrase)
{
	wxASSERT(pNewSrcPhrase);

	// jump to here
	int nNewSequNum = pNewSrcPhrase->m_nSequNumber;
	pApp->m_pActivePile = GetPile(nNewSequNum);
	CCell* pCell = pApp->m_pActivePile->GetCell(1); // the cell where the phraseBox is to be
	pApp->m_targetPhrase = pNewSrcPhrase->m_adaption; // make it look normal, 
													  // don't use m_targetStr here
	PlacePhraseBox(pCell,2);
	pApp->GetMainFrame()->canvas->ScrollIntoView(nNewSequNum);

	// update status bar with project name
	pApp->RefreshStatusBarInfo();
	Invalidate();
	GetLayout()->PlaceBox();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If Vertical Editing is in progress, or the pointers
/// to the KBs are NULL or the bundle's m_nStripCount is not greater than zero, this
/// handler disables the "Go To..." item in the Edit menu, otherwise it enables the "Go
/// To..." item on the Edit menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateGoTo(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pKB != NULL && pApp->m_pGlossingKB != NULL &&
		GetLayout()->GetStripArray()->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// nNewSequNum is the index of the first srcPhrase in the new selection, nCount is how many
// srcPhrases are to be selected, and nSelectionLine is the 0-based line index to put the
// selection it - it can be any of the first two line indices in a strip (ie. 0 or 1)
// Called from CAdapt_ItView::DoFindNext() and CPhraseBox::DoCancelAndSelect().
// CPhraseBox::DoCancelAndSelect() requires that a RecalcLayout() call, and resetting of
// the active sequence number and active pile be done internally, but DoFindNext() doesn't
// require these calls because they are done further up in the call hierarchy - and in
// fact if done when a match is made for text in a retranslation, the active location
// would be set wrongly if done here. So we use the bDoRecalcLayoutInternally flag to
// suppress the unwanted code when used in the context of a Find operation.
// BEW added 2Aug09, the bDoRecalcLayoutInternally flag
void CAdapt_ItView::MakeSelectionForFind(int nNewSequNum, int nCount, int nSelectionLine, 
														bool bDoRecalcLayoutInternally)
{
	// refactored 17Apr09
	wxASSERT(nSelectionLine == 0 || nSelectionLine == 1);
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();
	wxASSERT(pApp != NULL);
	if (!gbUserWantsSelection && bDoRecalcLayoutInternally)
	{
        // the above flag is never TRUE when this function is being called in association
        // with a Find Next operation; but since this function is also used for making a
        // selection when user hits the "Cancel And Select" button in CChooseTranslation
        // dialog when called from LookAhead(), the flag will be TRUE when that happens
        // BEW added 19Dec08: we will use this function to create the needed
        // selection within the RecreateCollectedBackTranslationsInVerticalEdit() function,
        // and likewise will set gbUserWantsSelection to TRUE in that function
        // BEW comment 17Apr09 for refactored view layout: since the bundle concept is gone
        // now, no advance is possible and all piles are accessible, so just reset the
        // active location, recalculate the layout and scroll into view
		pApp->m_nActiveSequNum = nNewSequNum;
#ifdef _NEW_LAYOUT
		pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
		pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		pApp->GetMainFrame()->canvas->ScrollIntoView(nNewSequNum);
	}
	// get the cell which will show the selection
	CCell* pCell;
	if (pApp->m_bMatchedRetranslation)
	{
		// active pile is outside the retranslation, so the cell must be the first in the
		// retranslation 
		CPile* pFirstPileInRetrans = GetPile(nNewSequNum);
		pCell = pFirstPileInRetrans->GetCell(nSelectionLine);
	}
	else
	{
		// it's okay to use the active pile as the first to select
		pCell = pApp->m_pActivePile->GetCell(nSelectionLine);
	}


    // make the selection (remember, this code can make a selection in line index 1 as well
    // as in 0; so if we click on the view, we will have to transform it to a legal
    // selection for the view - so we would want to make it an index 0 selection in that
    // event, for max flexibility) first, get rid of any old selection
	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context
	if (pApp->m_selection.GetCount() != 0)
	{
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		CCell* pOldSel;
		while (pos != NULL)
		{
			pOldSel = (CCell*)pos->GetData();
			pos = pos->GetNext();
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			pOldSel->SetSelected(FALSE);
			pOldSel->DrawCell(&aDC,pOldSel->GetColor());
		}
		pApp->m_selection.Clear();
		pApp->m_selectionLine = -1; // no selection
		pApp->m_pAnchor = (CCell*)NULL;
	}

	// then do the new selection
	aDC.SetBackgroundMode(pApp->m_backgroundMode);
	aDC.SetTextBackground(wxColour(255,255,0));// yellow
	pApp->m_bSelectByArrowKey = FALSE;
	pCell->SetSelected(TRUE);
	pCell->DrawCell(&aDC, pCell->GetColor());

	// preserve record of the selection
	pApp->m_selection.Append(pCell);
	pApp->m_selectionLine = nSelectionLine;
	pApp->m_pAnchor = pCell;

	if (nCount > 1)
	{
		// extend the selection
		ExtendSelectionForFind(pCell,nCount);
	}
	else
	{
		// if not extending, we still need a Redraw() in order to get the highlighted
		// single cell shown selected
		GetLayout()->Redraw();
	}

	gbUserWantsSelection = FALSE; // appropriate place to turn it back off
	Invalidate();
	GetLayout()->PlaceBox();
}

// pAchorCell is pointer to the first cell in the selection, nCount is the number cells in
// the selection (there is always one in existence, the first, when this function is
// entered) Because the caller supports selections in src and phrase box line (either tgt
// or gloss), the pAnchorCell's m_nCell index value may be 0 or 1)
void CAdapt_ItView::ExtendSelectionForFind(CCell* pAnchorCell, int nCount)
{
	// refactored 17Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context

	// local variables to use in the loops below
	CPile*	pCurPile; // the one we use in the loop
	CStrip* pCurStrip; // the strip the starting pile is in
	CCell*	pCurCell; // the current cell in the current pile (used in loop)
	int nCurPileCount; // how many piles in current strip
	int nCurPile; // index of current pile (in loop)
	int nCurStrip; // index of current strip in which the current pile is located
	CSourcePhrase* pCurSrcPhrase; // the current pile's source phrase pointer (in loop)

	// set the above local variables from pAnchorCell
	pCurPile = pAnchorCell->GetPile();
	pCurStrip = pCurPile->GetStrip();
#ifdef _ALT_LAYOUT_
	nCurPileCount = pCurStrip->GetPileIndicesCount();
#else
	nCurPileCount = pCurStrip->GetPileCount();
#endif
	nCurPile = pCurPile->GetPileIndex();
	nCurStrip = pCurStrip->GetStripIndex();

	int nAnchorSequNum = pCurPile->GetSrcPhrase()->m_nSequNumber;
	int nEndSequNum = nAnchorSequNum + nCount - 1;
	wxASSERT(nEndSequNum > 0 && nEndSequNum <= pApp->GetMaxIndex());
	int sequ = nAnchorSequNum;
	while (sequ < nEndSequNum)
	{
		sequ++; // next one

		// get the next cell
		pCurPile = GetPile(sequ);
		wxASSERT(pCurPile != NULL);
		pCurSrcPhrase = pCurPile->GetSrcPhrase();
		wxASSERT(pCurSrcPhrase->m_nSequNumber == sequ); // must match
		pCurCell = pCurPile->GetCell(pApp->m_selectionLine); // get the cell...
					// Note: pApp->m_selectionLine might be 0 or 1, not just 0
		
		// if it is already selected then iterate to do next one, else select it
		if (!pCurCell->IsSelected())
		{
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,0)); // yellow
			pCurCell->DrawCell(&aDC, pCurCell->GetColor());
			pCurCell->SetSelected(TRUE);

			// keep a record of it
			pApp->m_selection.Append(pCurCell);
		}
	}
}

void CAdapt_ItView::OnFind(wxCommandEvent& event)
{
	// refactored 17Apr09
 	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
   // check that a Find & Replace dialog is not currently open, if it is, delete it
    // preserving contents of the src & tgt edit boxes
	wxString saveSrc;
	saveSrc.Empty();
	wxString saveTgt;
	saveTgt.Empty();

	if (pApp->m_pFindDlg != NULL)
	{
		if (gbFind == FALSE)
		{
			pApp->m_pFindDlg->TransferDataFromWindow(); 
			saveSrc = pApp->m_pFindDlg->m_srcStr;
			saveTgt = pApp->m_pFindDlg->m_tgtStr;
			pApp->m_pFindDlg->Destroy();
			pApp->m_pFindDlg = NULL;
		}
	}
	gbFind = TRUE;
	gbJustReplaced = FALSE;

	// we must not be in 'show target only' mode, 
	// so if so, switch back to normal view mode
	if (gbShowTargetOnly)
	{
		OnFromShowingTargetOnlyToShowingAll(event);
	}
	if (pApp->m_pFindDlg == NULL)
	{
		pApp->m_pFindDlg = new CFindDlg(pApp->GetMainFrame());

		// set default parameter values
		pApp->m_pFindDlg->m_srcStr = saveSrc;
		pApp->m_pFindDlg->m_tgtStr = saveTgt;
		pApp->m_pFindDlg->m_replaceStr.Empty();
		pApp->m_pFindDlg->m_marker = 0;
		pApp->m_pFindDlg->m_markerStr.Empty();
		pApp->m_pFindDlg->m_sfm.Empty();
		pApp->m_pFindDlg->m_bFindRetranslation = FALSE;
		pApp->m_pFindDlg->m_bFindNullSrcPhrase = FALSE;
		pApp->m_pFindDlg->m_bFindSFM = FALSE;
		pApp->m_pFindDlg->m_bSrcOnly = TRUE;
		pApp->m_pFindDlg->m_bTgtOnly = FALSE;
		pApp->m_pFindDlg->m_bSrcAndTgt = FALSE;
		pApp->m_pFindDlg->m_bSpecialSearch = FALSE;
		pApp->m_pFindDlg->m_bFindDlg = TRUE;
		pApp->m_pFindDlg->m_bSpanSrcPhrases = FALSE;
		pApp->m_pFindDlg->m_bIncludePunct = FALSE;
		pApp->m_pFindDlg->m_bIgnoreCase = FALSE;
		pApp->m_pFindDlg->TransferDataToWindow();

		pApp->m_pFindDlg->Centre(); // this sets the horizontal pos, 
				// AdjustDialogPosition below overrides the vertical one
		AdjustDialogPosition(pApp->m_pFindDlg);
		pApp->m_pFindDlg->Show(TRUE);
		gbFindOrReplaceCurrent = TRUE;
	}
	else
	{
		// set default parameter values
		pApp->m_pFindDlg->m_srcStr = saveSrc;
		pApp->m_pFindDlg->m_tgtStr = saveTgt;
		pApp->m_pFindDlg->m_replaceStr.Empty();
		pApp->m_pFindDlg->m_marker = 0;
		pApp->m_pFindDlg->m_markerStr.Empty();
		pApp->m_pFindDlg->m_sfm.Empty();
		pApp->m_pFindDlg->m_bFindRetranslation = FALSE;
		pApp->m_pFindDlg->m_bFindNullSrcPhrase = FALSE;
		pApp->m_pFindDlg->m_bFindSFM = FALSE;
		pApp->m_pFindDlg->m_bSrcOnly = TRUE;
		pApp->m_pFindDlg->m_bTgtOnly = FALSE;
		pApp->m_pFindDlg->m_bSrcAndTgt = FALSE;
		pApp->m_pFindDlg->m_bSpecialSearch = FALSE;
		pApp->m_pFindDlg->m_bFindDlg = TRUE;
		pApp->m_pFindDlg->m_bSpanSrcPhrases = FALSE;
		pApp->m_pFindDlg->m_bIncludePunct = FALSE;
		pApp->m_pFindDlg->m_bIgnoreCase = FALSE;
		pApp->m_pFindDlg->TransferDataToWindow();

		pApp->m_pFindDlg->Centre(); // this sets the horizontal pos, 
				// AdjustDialogPosition below overrides the vertical one
		AdjustDialogPosition(pApp->m_pFindDlg);
		pApp->m_pFindDlg->Show(TRUE);
		gbFindOrReplaceCurrent = TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// This handler disables the "Find..." item in the Tools menu if Vertical Editing is in
/// progress, or if the application is in Free Translation mode, or if there are no source 
/// phrases in the App's m_pSourcePhrases list. Otherwise it enables the "Find..." item on
/// the Tools menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFind(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::AdjustDialogPosition(wxDialog* pDlg)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();
	wxASSERT(pApp != NULL);
	// place the dialog window so as not to obscure things
	// work out where to place the dialog window
	int nTwoLineDepth = 2 * pLayout->GetTgtTextHeight();
	wxPoint ptBoxTopLeft = pApp->m_pActivePile->GetCell(1)->GetTopLeft();
	wxRect rectScreen;

    // The wxWidgets docs say, "::wxClientDisplayRect() method returns the dimensions of
    // the work area on the display. On Windows this means the area not covered by the
    // taskbar, etc. Other platforms are currently defaulting to the whole display until a
    // way is found to provide this info for all window managers, etc."
    // Note: All calls that have no wxDC as a parameter deal in display device/pixels, and
    // MM_TEXT mapping mode, never in logical coordinates (or other mapping modes).
	int displayX;
	int displayY;
	int displayWidth;
	int displayHeight;
	::wxClientDisplayRect(&displayX,&displayY,&displayWidth,&displayHeight);
	// units for returned values from next call are in screen/device coords (pixels)
	rectScreen = wxRect(displayX,displayY,displayWidth,displayHeight); 
	wxClientDC dc(pApp->GetMainFrame()->canvas);
	canvas->DoPrepareDC(dc); //OnPrepareDC(&dc); // adjust origin

	// CalcScrolledPosition translates logical coordinates to device ones
	int newXPos, newYPos;
	pApp->GetMainFrame()->canvas->CalcScrolledPosition(ptBoxTopLeft.x,
										ptBoxTopLeft.y,&newXPos,&newYPos);
	ptBoxTopLeft.x = newXPos;
	ptBoxTopLeft.y = newYPos;

    // In the ClientToScreen call below the x and y coords are adjusted; in wxRect the
    // width and height remain unchanged, i.e., the rectangle retains the same size
    // dimensions, but the x and y coords change from (0,0) to a new (x,y) position for
    // the rectangle in relation to screen coords.
	pApp->GetMainFrame()->canvas->ClientToScreen(&ptBoxTopLeft.x,&ptBoxTopLeft.y);

	int height = nTwoLineDepth;
	int dlgWidth;
	int dlgHeight;
	wxASSERT(pDlg != NULL);
    // whm - for the dialog we should use GetSize, rather than GetClientSize as we want to
    // include the whole window
	pDlg->Centre(); // start with centered as default (for horizontal position especially)
	pDlg->GetSize(&dlgWidth,&dlgHeight); // dialog's window; gets the width and height in pixels
	wxASSERT(dlgHeight > 0);
    // wx note: displayWidth determined above (takes place of rectScreen.right -
    // rectScreen.left) below: because the actual width (before items are hidden) is much
    // greater than the displayed width, the following calculations place the dialog much
    // left of center. We won't bother setting the horizontal position.
	if (ptBoxTopLeft.y + height < rectScreen.GetBottom() - 50 - dlgHeight)
	{
        // put dlg near the bottom of screen, or 30 pixels under the box's strip Roland
        // Fumey is reporting the Choose Translation dialog being shown above the client
        // area and so invisible, so my fix for 2.4.1f did not work, so try do something
        // here and send to Roland for evaluation (BEW changed, 12Jul05)
		int topAdjusted = wxMin(ptBoxTopLeft.y + height + 30,
								rectScreen.GetBottom()-dlgHeight-80);
		if (topAdjusted < rectScreen.GetTop())
			topAdjusted = rectScreen.GetBottom() - dlgHeight - 80;
		// WX Note: We'll use the wxWindow::SetSize() method
		pDlg->SetSize( // set size in device/screen pixels
			-1, //left,
			topAdjusted,
			300, // width, dummy value overridden by wxSIZE_USE_EXISTING below
			200, // height, ditto
			wxSIZE_USE_EXISTING);
	}
	else
	{
        // put dlg near the top of the screen, or if possible, 60 pixels above the strip
        // (version 2.4.0 altered this below from max(ptBoxTopLeft.y - dlgHeight - height -
        // 60, rectScreen.top+40) so that now we put the box 2 pixels down from the top of
        // the screen, to minimize the need to scroll or move the box because it may be
        // obscuring some of the automatically inserted text); BEW altered 09Sep05 for it
        // to be 100 pixels down from the screen top - even if it sometimes obscures some
        // inserted text, it is better to have a reasonable chance of not obscuring the
        // command bar buttons
		pDlg->SetSize(
			-1, //left,
			rectScreen.GetTop()+100,
			300, // width, dummy value overridden by wxSIZE_USE_EXISTING below
			200, // height, ditto
			wxSIZE_USE_EXISTING);
	}
	pDlg->Update();
}

void CAdapt_ItView::SetWhichBookPosition(wxDialog* pDlg)
{
	// WX NOTE: This is used only in WhichBook.cpp's InitDialog()
	int xPos,yPos;
	pDlg->GetPosition(&xPos,&yPos); // whatever position the OS assigns to it by default
	pDlg->Move(xPos,200); // use the xPos but move it down 200 pixels from top

	pDlg->Update();
}

void CAdapt_ItView::AdjustDialogPositionByClick(wxDialog* pDlg,wxPoint ptClick)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CLayout* pLayout = GetLayout();

    // place the dialog window so as not to obscure things work out where to place the
    // dialog window; the passed in ptClick value comes from the saved point value for the
    // user's click in the client area of the view, and the coords for that point will be
    // device coords (ie. relative to top left of the client area of the view)

	// first calculate the height of two target text lines
	int height = 2 * pLayout->GetTgtTextHeight();

	// get the size of the screen - use screen coords
	wxRect rectScreen;
    // wx note: According to wx docs, wxGetClientDisplayRect() "returns the dimensions of
    // the work area on the display. On Windows this means the area not covered by the
    // taskbar, etc. Other platforms are currently defaulting to the whole display until a
    // way is found to provide this info for all window managers, etc."
	rectScreen = wxGetClientDisplayRect();

	// we need to know where the view's client rect is located, in screen coords
	wxRect rectView;
    // wx note: calling GetClientSize on the canvas produced different results in wxGTK and
    // wxMSW, so I'll use my own GetCanvasClientSize() which calculates it from the main
    // frame's client size.
	wxSize canvasSize;
	canvasSize = pApp->GetMainFrame()->GetCanvasClientSize();
	rectView.width = canvasSize.x;
	rectView.height = canvasSize.y;
	
    // In the ClientToScreen call below the x and y coords are adjusted; in wxRect the
    // width and height remain unchanged, i.e., the rectangle retains the same size
    // dimensions, but the x and y coords change from (0,0) to a new (x,y) position for
    // the rectangle in relation to screen coords.
	pApp->GetMainFrame()->canvas->ClientToScreen(&rectView.x,&rectView.y);

	// we need to know the location and size of the dialog which is to have 
	// its location adjusted
	wxRect rectDlg;
	pDlg->GetClientSize(&rectDlg.width,&rectDlg.height); // dialog's window
	rectDlg = NormalizeRect(rectDlg); // use our own from helpers.h
	int dlgHeight = rectDlg.GetHeight();
	int dlgWidth = rectDlg.GetWidth();
	wxASSERT(dlgHeight > 0);

    // determine how far from the left of the screen we will make the left side of the
    // dialog be so it is centered
	int left = (rectScreen.GetWidth() - dlgWidth)/2;

    // put it above the click if there is enough screen real estate to fit it between the
    // command bar and a 1.5 linepair height values above the click's y coordinate; else
    // put it near the screen bottom, making sure it clears the status bar
	if (dlgHeight + ((height * 3) / 2) < ptClick.y)
	{
		pDlg->SetSize(left,rectView.GetTop() + 5,300,200,wxSIZE_USE_EXISTING); 
	}
	else
	{
		pDlg->SetSize(left,rectScreen.GetBottom() - dlgHeight - 80,300,200,wxSIZE_USE_EXISTING);
	}
	pDlg->Update();
}

void CAdapt_ItView::OnReplace(wxCommandEvent& event)
{
	// refactored 17Apr09
	CAdapt_ItApp* pApp = &wxGetApp();
	//CLayout* pLayout = GetLayout();
	// check that a Find dialog is not currently open, if it is, delete it
	// preserving contents of the src & tgt edit boxes
	wxString saveSrc;
	saveSrc.Empty();
	wxString saveTgt;
	saveTgt.Empty();

	if (pApp->m_pReplaceDlg != NULL)
	{
		if (gbFind == TRUE)
		{
			pApp->m_pReplaceDlg->TransferDataFromWindow();
			saveSrc = pApp->m_pReplaceDlg->m_srcStr;
			saveTgt = pApp->m_pReplaceDlg->m_tgtStr;
			pApp->m_pReplaceDlg->Destroy();
			pApp->m_pReplaceDlg = NULL;
		}
	}

	gbFind = FALSE; // make dialog appearance be for Find & Replace
	gbJustReplaced = FALSE;

	// we must not be in 'show target only' mode, so if so, switch back to normal view mode
	if (gbShowTargetOnly)
	{
		OnFromShowingTargetOnlyToShowingAll(event);
	}

	if (pApp->m_pReplaceDlg == NULL)
	{
		pApp->m_pReplaceDlg = new CReplaceDlg(pApp->GetMainFrame());

		gbJustReplaced = FALSE;

		// set default parameter values
		pApp->m_pReplaceDlg->m_srcStr = saveSrc;
		pApp->m_pReplaceDlg->m_tgtStr = saveTgt;
		pApp->m_pReplaceDlg->m_replaceStr.Empty();
		pApp->m_pReplaceDlg->m_markerStr.Empty();
		pApp->m_pReplaceDlg->m_sfm.Empty();
		pApp->m_pReplaceDlg->m_bSrcOnly = FALSE;
		pApp->m_pReplaceDlg->m_bTgtOnly = TRUE;
		pApp->m_pReplaceDlg->m_bSrcAndTgt = FALSE;
		pApp->m_pReplaceDlg->m_bFindDlg = FALSE;
		pApp->m_pReplaceDlg->m_bSpanSrcPhrases = FALSE;
		pApp->m_pReplaceDlg->m_bIncludePunct = FALSE;
		pApp->m_pReplaceDlg->m_bIgnoreCase = FALSE;
		pApp->m_pReplaceDlg->TransferDataToWindow();

		pApp->m_pReplaceDlg->Centre(); // this sets the horizontal pos, 
				// AdjustDialogPosition below overrides the vertical one
		AdjustDialogPosition(pApp->m_pReplaceDlg);
		pApp->m_pReplaceDlg->Show(TRUE);
		gbFindOrReplaceCurrent = TRUE;
	}
	else
	{
		if (pApp->m_pReplaceDlg != NULL)
		{
			AdjustDialogPosition(pApp->m_pReplaceDlg);
			pApp->m_pReplaceDlg->Show(TRUE);
			gbFindOrReplaceCurrent = TRUE;
		}
		else
		{
			// wx doesn't need to call Create
			gbJustReplaced = FALSE;

			// set default parameter values
			pApp->m_pReplaceDlg->m_srcStr = saveSrc;
			pApp->m_pReplaceDlg->m_tgtStr = saveTgt;
			pApp->m_pReplaceDlg->m_replaceStr.Empty();
			pApp->m_pReplaceDlg->m_markerStr.Empty();
			pApp->m_pReplaceDlg->m_sfm.Empty();
			pApp->m_pReplaceDlg->m_bSrcOnly = FALSE;
			pApp->m_pReplaceDlg->m_bTgtOnly = TRUE;
			pApp->m_pReplaceDlg->m_bSrcAndTgt = FALSE;
			pApp->m_pReplaceDlg->m_bFindDlg = FALSE;
			pApp->m_pReplaceDlg->m_bSpanSrcPhrases = FALSE;
			pApp->m_pReplaceDlg->m_bIncludePunct = FALSE;
			pApp->m_pReplaceDlg->m_bIgnoreCase = FALSE;
			pApp->m_pReplaceDlg->TransferDataToWindow();

			pApp->m_pReplaceDlg->Centre(); // this sets the horizontal position, 
						// AdjustDialogPosition() below sets vertical position
			AdjustDialogPosition(pApp->m_pReplaceDlg);
			pApp->m_pReplaceDlg->Show(TRUE);
			gbFindOrReplaceCurrent = TRUE;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. This handler disables the "Find And Replace..." item
/// in the Tools menu if Vertical Editing is in progress, or if the application is in Free
/// Translation mode, or if there are no source phrases in the App's m_pSourcePhrases list.
/// Otherwise it enables the "Find And Replace..." item on the Tools menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateReplace(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}
// Called in DoFindNext() of view class, and DoCancelAndSelect() of CPhraseBox class
void CAdapt_ItView::SelectFoundSrcPhrases(int nNewSequNum, int nCount,
		bool bIncludePunct, bool bSearchedInSrc, bool bDoRecalcLayout)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbIsGlossing)
	{
		wxASSERT(nCount == 1);;
	}

	bIncludePunct = TRUE; // set it, rather than ignore, to avoid compiler warning
	int nSelLineIndex;

	// BEW changed 3Aug09 to always have the selection line for Find Next be the source
	// text line - this makes the interface more consistent
	nSelLineIndex = 0;
	bSearchedInSrc = bSearchedInSrc; // prevent compiler warning
	//if (bSearchedInSrc)
	//{
	//	nSelLineIndex = 0;
	//}
	//else
	//{
	//	nSelLineIndex = 1;
	//}

	// set up bundle, recalc layout, etc, and make the appropriate selection...
    // BEW changed 2Aug09, internally it tests (!gbUserWantsSelection &&
    // bDoRecalcLayoutInternally) and so it will do the RecalcLayout, resetting of active
    // sequ num, and the active pile to that location, only if gbUserWantsSelection is
    // FALSE, and bDoRecalcLayoutInternally is TRUE. 
    // ** TODO ** check sometime, do we need both flags??
    // (well, we do at present, but could we do a Find with first flag TRUE and not get
    // negative effects - the issue here is to prevent wrong active location setting if the
    // match in a Find is within a retranslation - it can get set wrongly to first
    // srcphrase in the retranslation instead of the one before the retranslation
	MakeSelectionForFind(nNewSequNum,nCount,nSelLineIndex, bDoRecalcLayout);

	// update the active sequ number, if the MakeSelectionForFind did an internal
	// RecalcLayout() call, etc.
	if (bDoRecalcLayout)
		pApp->m_nActiveSequNum = nNewSequNum;
}

// All parameters relevant when glossing is OFF. When glossing is ON, the following
// applies: bIncludePunct and bSpanSrcPhrases will be FALSE, since the checkboxes 
// for those flags are hidden; tgt parameter will hold, if relevant, text to be searched
// for in the m_gloss line; and nCount should never be anything except 1 when glossing.
bool CAdapt_ItView::DoFindNext(int nCurSequNum, bool bIncludePunct, bool bSpanSrcPhrases,
						bool bSpecialSearch,bool bSrcOnly, bool bTgtOnly,
						bool bSrcAndTgt, bool bFindRetranslation, bool bFindNullSrcPhrase,
						bool bFindSFM, wxString& src, wxString& tgt, wxString& sfm,
						bool bIgnoreCase, int& nSequNum, int& nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbIsGlossing)
	{
		wxASSERT(nCount == 1);;
	}
	wxASSERT(!(nCurSequNum > pApp->GetMaxIndex()));
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);

    // if the targetBox is visible, store the contents in KB since we will advance the
    // active location to the pile having the text matched in the source phrase; and even
    // if there is no match, we want to do the save to KB before any bundle advances,
    // otherwise the old active location's pointer will be garbage & we'll crash if we try
    // to use it
	if (pApp->m_pTargetBox != NULL)
	{
		if (pApp->m_pTargetBox->IsShown())
		{
			if (!gbIsGlossing)
				MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(),pApp->m_targetPhrase);
			if (!gbIsGlossing)
				RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);

			// the store will fail if the user edited the entry out of the KB, as the latter
			// cannot know which srcPhrases will be affected, so these will still have their
			// m_bHasKBEntry set true. We have to test for this, ie. a null pRefString but
			// the above flag TRUE is a sufficient test, and if so, set the flag to FALSE
			CRefString* pRefStr;
			bool bOK;
			if (gbIsGlossing)
			{
				pRefStr = GetRefString(pApp->m_pGlossingKB, 1,
							pApp->m_pActivePile->GetSrcPhrase()->m_key,
							pApp->m_targetPhrase);
				if (pRefStr == NULL || 
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
				// now do the store
				bOK = StoreText(pApp->m_pGlossingKB,pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_targetPhrase);
			}
			else
			{
				pRefStr = GetRefString(pApp->m_pKB,
							pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
									pApp->m_pActivePile->GetSrcPhrase()->m_key,
									pApp->m_targetPhrase);
				if (pRefStr == NULL || 
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry) // be safe
					pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
				// now do the store
				gbInhibitLine4StrCall = TRUE;
				bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_targetPhrase);
				gbInhibitLine4StrCall = FALSE;
			}

			// now get rid of the phrase box, until we need it again
			pApp->m_pTargetBox->Hide();
			pApp->m_pTargetBox->ChangeValue(_T("")); // need to set it to null str 
													 // since it won't get recreated
			pApp->m_targetPhrase.Empty(); // the box will move on, so this old 
										  // location is now invalid
		}
	}

	if (nCurSequNum == pApp->GetMaxIndex() || nCurSequNum == -1)
		return FALSE; // we are at the end, so cannot search further 
					  // (we won't wrap the search)
	if (bSpecialSearch)
	{
		bool bFound;

		// a special search is wanted
		if (bFindRetranslation)
		{
			bFound = DoFindRetranslation(nCurSequNum+1,nSequNum,nCount);
		}
		else if (bFindNullSrcPhrase)
		{
			bFound = DoFindNullSrcPhrase(nCurSequNum+1,nSequNum,nCount);
		}
		else
		{
			// must want to find a standard format marker
			if (bFindSFM != TRUE)
			{
				::wxBell(); 
				wxASSERT(FALSE);
			}
			bFound = DoFindSFM(sfm,nCurSequNum+1,nSequNum,nCount);
		}
		if (!bFound)
		{
			// clear the globals
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			::wxBell(); // alert user there was no match
			Invalidate();
			GetLayout()->PlaceBox();
			return FALSE;
		}
		else
		{
			// found a matching string, in the srcPhrase with sequ num nSequNum
			// BEW 9Aug09 added last parameter bDoRecalcLayoutInternally = FALSE
			// to suppress unhelpful RecalcLayout, resetting of active sequ num etc in the
			// internal function MakeSelectionForFind()
			SelectFoundSrcPhrases(nSequNum,nCount,TRUE,TRUE,FALSE);
			return TRUE;
		}
	}
	else
	{
		// not a special search, just a normal one
		bool bFound;
		bool bInSrc = TRUE;

        // if we previously matched a retranslation, we have to advance to its end before
        // we can continue searching for a new match; but if glossing is ON, retranslations
        // are irrelevant, so we would skip the block in that case
		if (!gbIsGlossing && pApp->m_bMatchedRetranslation)
		{
			wxASSERT(gnRetransEndSequNum >= 0);
			nCurSequNum = gnRetransEndSequNum;
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
		}

		// a normal type of search is wanted & the following functions search in
		// m_pSourcePhrases list
		if (bSrcOnly)
		{
			// search only in m_srcPhrase field or m_key field, depending on bIncludePunct
			// flag value
			bFound = DoSrcOnlyFind(nCurSequNum+1,bIncludePunct,bSpanSrcPhrases,src,
									bIgnoreCase,nSequNum,nCount);
		}
		else if (bTgtOnly)
		{
			// search only in m_targetStr field or m_adaption field
			bFound = DoTgtOnlyFind(nCurSequNum+1,bIncludePunct,bSpanSrcPhrases,tgt,
									bIgnoreCase,nSequNum,nCount);
			bInSrc = FALSE;
		}
		else
		{
			// search both m_srcPhrase and m_targetStr fields, trying to match both
			if (bSrcAndTgt != TRUE)
			{
				::wxBell(); 
				wxASSERT(FALSE);
			}
			bFound = DoSrcAndTgtFind(nCurSequNum+1,bIncludePunct,bSpanSrcPhrases,src,tgt,
									bIgnoreCase,nSequNum,nCount);
			bInSrc = FALSE;
		}
		if (!bFound)
		{
			// clear the globals
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			::wxBell(); // alert user there was no match
			Invalidate();
			GetLayout()->PlaceBox();
			return FALSE;
		}
		else
		{
			// found a matching string, in the srcPhrase with sequ num nSequNum
			FindNextHasLanded(nSequNum); // bSuppressSelectionExtention is default TRUE
										 // because SelectFoundSrcPhrases() will do it

 			// BEW 2Aug09 added last parameter bDoRecalcLayoutInternally = FALSE
			// to suppress unhelpful RecalcLayout, resetting of active sequ num etc in the
			// internal function MakeSelectionForFind()
           // BEW changed 3Aug09, SelectFoundSrcPhrases() conditionally does a
            // RecalcLayout() & if it does it resets the active sequence number to the
            // nSequNum value passed in. A test of two flags prevents this leading to an
            // error in the circumstance where the phrase box needs to be not at the
            // matched location within a retranslation. It also sets the selection of the
            // source text to show what was matched. For a match within a retranslation,
            // the whole retranslation is shown selected.
			SelectFoundSrcPhrases(nSequNum,nCount,bIncludePunct,bInSrc,FALSE);
			return TRUE;
		}
	}
}

// we allow this search whether glossing is on or not; as it might be a useful search when
// glossing is ON
bool CAdapt_ItView::DoFindRetranslation(int nStartSequNum, int& nSequNum, int& nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* savePos = pos;

	// get past the current retranslation, if we are in one
	pSrcPhrase = (CSourcePhrase*)pos->GetData();
	if (pSrcPhrase->m_bBeginRetranslation)
	{
		// we are at the start of a retranslation, so must access the next srcPhrase
		// before we have a possibility of being out of it, or into the next retranslation
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
	}
	if (pSrcPhrase->m_bRetranslation)
	{
		while (pos != NULL)
		{
			savePos = pos;
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (!pSrcPhrase->m_bRetranslation || pSrcPhrase->m_bBeginRetranslation)
				break; // break if we are out, or at the beginning of a consecutive one
		}
	}

	// do the search, confining attempts within a single CSourcePhrase instance
	if (pos == NULL)
	{
		// we are at the end of the document
		nSequNum = -1; // undefined
		return FALSE;
	}

	pos = savePos;
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bRetranslation || pSrcPhrase->m_bBeginRetranslation)
		{
			// we found a retranslation
			nSequNum = pSrcPhrase->m_nSequNumber;
			nCount = 1;
			return TRUE;
		}
	}

	// if we get here, we didn't find a match
	nSequNum = -1;
	return FALSE;
}

// finds only those null src phases (ie. placeholders) which are not within a retranslation
// for padding purposes; the search is also allowed when glossing is ON
bool CAdapt_ItView::DoFindNullSrcPhrase(int nStartSequNum, int& nSequNum, int& nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;

	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bNullSourcePhrase && !pSrcPhrase->m_bRetranslation)
		{
			// we found a null source phrase (exclude those which may be in a retranslation)
			nSequNum = sn;
			nCount = 1;
			return TRUE;
		}
		else
		{
			sn++; // index for next CSourcePhrase instance to be searched
		}
	}

	// if we get here, we didn't find a match
	return FALSE;
}

bool CAdapt_ItView::IsSameMarker(int str1Len, int nFirstChar, const wxString& str1,
								 const wxString& testStr)
{
	wxASSERT(str1.Length() > 1);
	wxString extracted = testStr.Mid(nFirstChar,str1Len);

    // if the testStr has a marker which has the str1 marker in it as a substring, we have
    // to extend the "extracted" string, otherwise we will end up returning a TRUE value
    // incorrectly
	int nNext = nFirstChar + str1Len;
	int totalLen = testStr.Length();

	wxChar c;
    // while we are not beyond the textStr bounds, and the character at the nNext offset is
    // not a space character, add the next character to the extracted marker stub, and
    // iterate until the whole marker is built
	while ( nNext < totalLen && (c = testStr.GetChar(nNext)) != _T(' '))
	{
		extracted += c;
		nNext++;
	}

	if ((int)extracted.Length() < str1Len)
		return FALSE; // can't be the same, since it's shorter
	return (extracted == str1);
}

// we allow this search when glossing or when adapting
bool CAdapt_ItView::DoFindSFM(wxString& sfm, int nStartSequNum, int& nSequNum, int& nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int len = sfm.Length();

	int nFound = -1; // assume not found
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL);

		nFound = pSrcPhrase->m_markers.Find(sfm); // nFound is index of first 
												  // char of matched str
		if (nFound >= 0)
		{
            // we can assume m_markers does not have two markers one of which is a
            // substring of the other (if that was the case, and the longer was first and
            // we were looking for the shorter, we'd never find the shorter one with the
            // following code)
			bool bSame = IsSameMarker(len,nFound,sfm,pSrcPhrase->m_markers);
			if (!bSame)
			{
				nFound = -1;
				goto b;
			}
		}
		else
		{
b:			if (pSrcPhrase->m_nSrcWords > 1)
			{
				// there could be medial markers in the phrase, so check it out
				if (!pSrcPhrase->m_pMedialMarkers->IsEmpty())
				{
					wxArrayString* pSL = pSrcPhrase->m_pMedialMarkers;
					int ct;
					for (ct = 0; ct < (int)pSL->GetCount(); ct++) 
					{
						wxString markers = pSL->Item(ct);
						nFound = markers.Find(sfm);
						if (nFound >= 0)
						{
							bool bSame = IsSameMarker(len,nFound,sfm,markers);
							if (bSame)
							{
								break;
							}
							else
							{
								nFound = -1;
							}
						}
					}
				}
			}
		}
		if (nFound >= 0)
		{
			// we found a matching standard format marker
			nSequNum = sn;
			nCount = 1;
			return TRUE;
		}
		else
		{
			sn++; // index for next CSourcePhrase instance to be searched
		}
	}

	// if we get here, we didn't find a match
	return FALSE;
}

void CAdapt_ItView::DeleteTempList(SPList* pList)
{
	// BEW refactor 13Mar09, do nothing here, these are temporary incomplete ones, 
	// no partner piles
	SPList::Node* p;
	if (pList->IsEmpty())
	{
		delete pList;
		pList = (SPList*)NULL;
		return;
	}
	p = pList->GetFirst();
	while (p != 0)
	{
		CSourcePhrase* pSP = (CSourcePhrase*)p->GetData();
		p = p->GetNext();
		delete pSP->m_pMedialMarkers;
		pSP->m_pMedialMarkers = (wxArrayString*)NULL;
		delete pSP->m_pMedialPuncts;
		pSP->m_pMedialPuncts = (wxArrayString*)NULL;
		delete pSP->m_pSavedWords;
		pSP->m_pSavedWords = (SPList*)NULL;
		delete pSP;
		pSP = (CSourcePhrase*)NULL;
	}
	pList->Clear();
	delete pList;
	pList = (SPList*)NULL;
}

// when IsMatchedToEnd is called, it will be the case that we are trying to match less than
// the whole of the user's typed search string, and we will be doing the test for the match
// only in the text supplied from the first source phrase of a potential multi-sourcePhrase
// match. In the first srcPhrse, we have no way of knowing how many of the user's first
// typed words will be able to match, so we have to test all possibilities - in the caller,
// an nIteration variable keeps track of which attempt we are making, each iteration tests
// a string one word shorter than the one tested earlier in the last call to
// IsMatchedToEnd(). However, any match within IsMatchedToEnd is not valid unless the last
// matched character is also the very last character of the strTarget string. The reason
// for this is that since there is more to be matched in a later sourcePhrase, we cannot
// allow a discontinuity between what is matched in the current one, and any potential
// match in the next one. So IsMatchedToEnd looks specifically for a match which is
// coextensive with the end of the strTarget string; returns the offset to the first
// matched character if it finds such a match, or -1 otherwise (mimicking CString's Find()
// function)
int CAdapt_ItView::IsMatchedToEnd(wxString& strSearch, wxString& strTarget)
{
	int nTargetLen = strTarget.Length();
	int nSearchLen = strSearch.Length();
	int nFirstChar = -1;
	int nStart = 0;
a:	nFirstChar = FindFromPos(strTarget,strSearch,nStart);
	if (nFirstChar == -1)
	{
		// no match
		return -1;
	}
	else
	{
		// got a match, check it out
		if (nFirstChar + nSearchLen == nTargetLen)
		{
			// it matches up to the end, so we have a successful match
			return nFirstChar;
		}
		else
		{
			// not coextensive with the end, so see if we can get a match 
			// later in the string
			nStart = ++nFirstChar;
			goto a;
		}
	}
}

// selector = 0 means, a src only search
// selector = 1 means, a tgt only search
// pList is a pointer to the list of CSourcePhrase instances in the document's
// m_pSourcePhrases member, pTempList holds a temporary list created in the caller, of
// pSrcPhrase instances which are the result of parsing src string using TokenizeText()
// function - we use these to construct search strings which we wish to match within the
// appropriate members of each pSrcPhrase in the pList, starting from the location pos
// If glossing is ON, this should never get called.
// 
/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if an extended match was made, FALSE if not
/// \param      selector    ->  0 means, a src search, 1 means a tgt search
/// \param      pos         ->  iterator through the list of CSourcePhrase instances in 
///                             the application's m_pSourcePhrases member; if selector is
///                             0, the tests for matches will be done in the m_key or
///                             m_srcPhrase members of CSourcePhrase instances from that
///                             list; if selector = 1, the tests for matches will be done
///                             in the m_adaption or m_targetStr members, depending on the
///                             bIncludePunct value passed in
/// \param      pDoc        ->  pointer to CAdapt_ItDoc class, needed for accessing
///                             TokenizeText() function
/// \param      pTempList   ->  pointer to a temporary list created in the caller, of
///                             pSrcPhrase instances which are the result of parsing src
///                             string using TokenizeText() function - we use these to
///                             construct search strings which we wish to match within the
///                             appropriate members of each pSrcPhrase in the pList,
///                             starting from the location pos
/// \param      nElements   ->  the number of elements in pTempList. If matching across
///                             multiple piles, nElements will be greater than 1; or if
///                             matching even a single word but the "unit" to be searched
///                             is a retranslation's target text (since we treat
///                             retranslations as a whole), nElements can be 1 but still
///                             require extended matching by this function because there
///                             may be more than one pile in the retranslation
/// \param      bIncludePunct -> if TRUE, uses m_srcPhrase for tests in src, m_targetStr
///                             for tests in tgt. Otherwise, m_key & m_adaption, respectively                            
/// \param      bIgnoreCase ->  Default is FALSE in caller, if TRUE passed in, strings are
///                             reset to lower case before testing for a match
/// \param      nCount      ->  a count of how many words are to be matched (note, the
///                             function is required event when nCount is 1 if the source
///                             text matched within a retranslation)                         
/// \remarks
/// Used for matching several words across more than one pile, or matching within a
/// retranslation. In the case of a retranslation, the matching, if source and target text
/// matches are required, does not have to be for piles vertically aligned; so for
/// retranslations a single source text word may match at one point in the retranslation
/// but the target text line might match at a different pile within the retranslation,
/// because we consider retranslations a textual "unit", and so when that is the case, a
/// TRUE value would be returned.
/// This is a complex function, BEWARE.
/// If glossing is ON, this function should never get called.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::DoExtendedSearch(int			selector, 
									 SPList::Node*&	pos, 
									 CAdapt_ItDoc*	pDoc, 
									 SPList*		pTempList, 
									 int			nElements, 
									 bool			bIncludePunct,
                                     bool			bIgnoreCase, 
									 int&			nCount)
{
	wxASSERT(!gbIsGlossing);
	SPList::Node* pos1 = pos;  // local copy to use in iterations
	SPList::Node* pos2 = NULL; // position within the pTempList
	bool bFirstOnly = TRUE; // true when we are dealing with the first of a 
			// possible string of srcPhrases in the m_pSourcePhrases list of pDoc
	int nTotal = nElements; // number of words (ie. elements in pTempList) 
							// in search string
	wxString strConstruct;	// we construct strings in this, in which to search 
							// for a match using src
	strConstruct.Empty();
	nCount = 0; // count of how many m_pSourcePhrases elements were used in 
				// making the match, garbage if no match
	int bFirstAttempt = TRUE; // used when making first attempt at a match - the 
                // first matching character does not have to be at the start of the string
                // being searched in this instance, but subsequent matches must match
                // exactly from the start
	wxString strSearchTarget; // we search in this string for a match
	strSearchTarget.Empty();
	CSourcePhrase* pSrcPhrase = NULL; // a source phase in doc's m_pSourcePhrases list
	CSourcePhrase* pSP = NULL; // a source phrase in the tokenized pTempList, 
							   // from which we build search strings
	int nTargetLength = 0;
	int nSearchLength = 0;
	int nAddParts= 0;
	int nFound = -1;
	int nWordCount = 0;
	int count = 0;
	int nIteration = 0; // iteration number for the try in first source phrase, 
                        // starting with longest & decreasing by one word per iteration
	int nLimit = 0; // max number of search words which can be constructed in strConstruct for
					// matching in the strSearchTarget string built from the current pSrcPhrase
					// in the loop
	if (pos == 0)
		return FALSE;
	switch (selector)
	{
	case 0: // source only
		while (pos1 != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetNext();
			wxASSERT(pSrcPhrase != NULL);
			nWordCount = pSrcPhrase->m_nSrcWords;
			nLimit = wxMin(nTotal,nWordCount);
			nCount++; // count this source phrase (it could have more than 
					  // one word in its m_key or m_srcPhrase)
			if (bFirstOnly)
			{
				bFirstOnly = FALSE;
				pos = pos1; // we need to return only this one, because the caller 
                            // needs to know when the end of pList has been reached, so
                            // that the caller's loop can be exited cleanly
			}
			else
			{
				nIteration = 0; // no iterations allowed for src phrases 
								// other than the first
			}
			if(pSrcPhrase->m_bNullSourcePhrase)
			{
				if (nCount == 1)
					return FALSE; // if first is a null source phrase, 
								  // cause progression to next
				else
				{
					// not the first srcPhrase, so just skip it 
					continue;
				}
			}

			// compute strSearchTarget
			if (bIncludePunct)
			{
				strSearchTarget = pSrcPhrase->m_srcPhrase;
			}
			else
			{
				strSearchTarget = pSrcPhrase->m_key;
			}
			if (bIgnoreCase)
				strSearchTarget.MakeLower();

			// how many iterations left to be tried, for the first phrase
a:			if (nCount == 1)
			{
				nTotal = nElements; // reset, for each iteration
				nIteration++;  // which iteration within the nCount == 1 loop are we on
				nLimit = wxMin(nTotal,nWordCount) - nIteration + 1;
			}
			else
				nLimit = wxMin(nTotal,nWordCount);

			if (nIteration > wxMin(nTotal,nWordCount))
				return FALSE; // couldn't make a match in the first source phrase,
							  // and the rest match also

            // we use nWordCount together with pTempList data in order to build a
            // strConstruct which has nWordCount words in it - either with or without
            // punctuation depending on the bIncludePunct value, (or there can be less than
            // nWordCount words, if the search string is short enough); then for each
            // nIterations decrement, try building one word less each time (provided no
            // earlier iteration produced a match)
			if (nCount == 1)
			{
				// go back to the start of the user's typed string,
				// for every iteration while nCount == 1
				pos2 = pTempList->GetFirst(); 
			}
			count = 0; // count of words from user's typed string which
					   // are to be used for this test
			while (pos2 != NULL)
			{
				pSP = (CSourcePhrase*)pos2->GetData();
				pos2 = pos2->GetNext();
				wxASSERT(pSP != NULL);
				if (bIncludePunct)
				{
					if (count == 0)
					{
						strConstruct = pSP->m_srcPhrase;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_srcPhrase;
					}
				}
				else
				{
					if (count == 0)
					{
						strConstruct = pSP->m_key;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_key;
					}
				}
				count++; // count the word represented by this source phrase
				if (count == nLimit)
				{
					break;
				}
			}
			if (bIgnoreCase)
				strConstruct.MakeLower();

            // we exit either because nTotal is less than nLimit (in which case pos2 became
            // null before count was able to become equal to nLimit), or because count
            // equals nLimit. So now we must update the value of nTotal, so that it equals
            // the number of remaining words (ie. srcPhrases) in the pTempList list.
			nTotal -= count;
			wxASSERT(nTotal >= 0);

            // now we must check for a match. If nTotal is zero, the match can be a
            // substring, and if bFirstAttempt is TRUE, that substring can be not at the
            // start of the search string, etc. The test is different if we are on an
            // iteration other than 1st, for nCount == 1
			if (nCount == 1 && nIteration > 1)
			{
				nFound = IsMatchedToEnd(strConstruct,strSearchTarget);
			}
			else
			{
				nFound = strSearchTarget.Find(strConstruct);
			}
			if (nFound == -1)
			{
                // no match, so goto a: to try next iteration, provided nCount is still 1;
                // if nCount is greater than 1 we are not in the first SrcPhrase, and so a
                // non-match means we must return FALSE
				if (nCount == 1)
				{
					// try next iteration (with a shorter search string)
					goto a;
				}
				else
				{
					return FALSE;
				}
			}

			// we have a match, so check out whether it is exact, or a substring, etc.
			nTargetLength = strSearchTarget.Length();
			nSearchLength = strConstruct.Length();
			nAddParts = 0;
			if (nTotal > 0)
			{
                // there is more in the search string yet to be matched, so we are not at
                // the last source phrase to be tested when in this nTotal > 0 == TRUE code
                // block
				if (bFirstAttempt)
				{
                    // nFound can be non-zero, but the matching must be done up to the end
                    // of the strSearchTarget string, else we have a discontinuity and so
                    // return FALSE or iterate
					nAddParts = nFound + nSearchLength;
					if (nAddParts < nTargetLength)
					{
						if (nCount == 1 && nIteration < nLimit)
						{
                            // no match: we can try with a shorter search string, so
                            // iterate
							goto a;
						}
						else
						{
							// nCount > 1, can't possibly match because of discontinuity,
							// so return FALSE
							return FALSE;
						}
					}
					wxASSERT(nAddParts == nTargetLength); // we can continue, 
														  // valid matching so far
				}
				else
				{
                    // there was a previous match or matches, so this matched string must
                    // be coextensive with strSearchTarget itself, to avoid a discontinuity
                    // in the matching, since there is yet more waiting to be tested for a
                    // match in a later srcPhrase; if there is a discontinuity, check for
                    // the possibility of an iteration and do so if the conditions are
                    // right, else return FALSE
					if (nSearchLength != nTargetLength)
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto a; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
					wxASSERT(nSearchLength == nTargetLength); // okay so far, so continue
				}
			}
			else
			{
                // nTotal must be zero, and so this current match is the last - but it must
                // match from the beginning of strSearchTarget, unless bFirstAttempt is
                // also TRUE
				wxASSERT(nTotal == 0);
				if (bFirstAttempt)
				{
                    // we have just made our first match, ie, we are at the start of the
                    // search string, so nFind can be non-zero legitimately, so we can
                    // return TRUE, since we are done
					return TRUE;
				}
				else
				{
                    // we are at the end of the search string, and there were previous
                    // matches, so the offset to the first matched character must be zero,
                    // if not, we do not have continuity in the matching, hence not a
                    // legitimate match
					if (nFound == 0)
					{
						return TRUE;
					}
					else
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto a; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
				}
			}

            // we have finished our first attempt (ie. trying to match in first srcPhrase),
            // so make bFirstAttempt FALSE for subsequent traverses through the loop
			bFirstAttempt = FALSE;
		}
		return FALSE;
		break;

	case 1: // target only
	default:
		while (pos1 != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos1->GetData();
			pos1 = pos1->GetNext();
			wxASSERT(pSrcPhrase != NULL); 

            // count the words in the m_adaption member, using TokenizeText, which is more
            // sophisticated than just counting white space etc.
			wxString aString = pSrcPhrase->m_adaption;
			SPList* pAList = new SPList;
			int	length = aString.Length();
			int numElements = 0;
			if (!aString.IsEmpty())
			{
				numElements = pDoc->TokenizeText(0,pAList,aString,length);
				DeleteTempList(pAList);
			}
			else
			{
				// if aString is empty, we've nothing to search in on this srcPhrase,
				// so cause progression
				delete pAList; // don't leak memory
				if (bFirstOnly)
					pos = pos1;
				return FALSE;
			}
			nWordCount = numElements;

			nLimit = wxMin(nTotal,nWordCount);
			nCount++; // count this source phrase (it could have more than one word in its
					  // m_key or m_srcPhrase)
			if (bFirstOnly)
			{
				bFirstOnly = FALSE;
				pos = pos1; // we need to return only this one, because the caller needs to
							// know when the end of pList has been reached, so that the
							// caller's loop can be exited cleanly
			}
			else
			{
				nIteration = 0; // no iterations allowed for src phrases other than the first
			}

			// compute strSearchTarget
			if (bIncludePunct)
			{
				strSearchTarget = pSrcPhrase->m_targetStr;
			}
			else
			{
				strSearchTarget = pSrcPhrase->m_adaption;
			}
			if (bIgnoreCase)
				strSearchTarget.MakeLower();

			// how many iterations left to be tried, for the first phrase
b:			if (nCount == 1)
			{
				nTotal = nElements; // reset, for each iteration
				nIteration++;  // which iteration within the nCount == 1 loop are we on
				nLimit = wxMin(nTotal,nWordCount) - nIteration + 1;
			}
			else
				nLimit = wxMin(nTotal,nWordCount);

			if (nIteration > wxMin(nTotal,nWordCount))
				return FALSE; // couldn't make a match in the first source phrase,
							  // and the rest match also

            // we use nWordCount together with pTempList data in order to build a
            // strConstruct which has nWordCount words in it - either with or without
            // punctuation depending on the bIncludePunct value, (or there can be less than
            // nWordCount words, if the search string is short enough); then for each
            // nIterations decrement, try building one word less each time (provided no
            // earlier iteration produced a match)
			if (nCount == 1)
			{
				// go back to the start of the user's typed string, for every
				// iteration while nCount == 1
				pos2 = pTempList->GetFirst();
			}
			count = 0; // count of words from user's typed string which are
					   // to be used for this test
			while (pos2 != NULL)
			{
				pSP = (CSourcePhrase*)pos2->GetData();
				pos2 = pos2->GetNext();
				wxASSERT(pSP != NULL);
				if (bIncludePunct)
				{
					if (count == 0)
					{
						strConstruct = pSP->m_srcPhrase;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_srcPhrase;
					}
				}
				else
				{
					if (count == 0)
					{
						strConstruct = pSP->m_key;
					}
					else
					{
						strConstruct += _T(" ") + pSP->m_key;
					}
				}
				count++; // count the word represented by this source phrase
				if (count == nLimit)
				{
					break;
				}
			}
			if (bIgnoreCase)
				strConstruct.MakeLower();

            // we exit either because nTotal is less than nLimit (in which case pos2 became
            // null before count was able to become equal to nLimit), or because count
            // equals nLimit. So now we must update the value of nTotal, so that it equals
            // the number of remaining words (ie. srcPhrases) in the pTempList list.
			nTotal -= count;
			wxASSERT(nTotal >= 0);

            // now we must check for a match. If nTotal is zero, the match can be a
            // substring, and if bFirstAttempt is TRUE, that substring can be not at the
            // start of the search string, etc. The test is different if we are on an
            // iteration other than 1st, for nCount == 1
			if (nCount == 1 && nIteration > 1)
			{
				nFound = IsMatchedToEnd(strConstruct,strSearchTarget);
			}
			else
			{
				nFound = strSearchTarget.Find(strConstruct);
			}
			if (nFound == -1)
			{
                // no match, so goto a: to try next iteration, provided nCount is still 1;
                // if nCount is greater than 1 we are not in the first SrcPhrase, and so a
                // non-match means we must return FALSE
				if (nCount == 1)
				{
					// try next iteration (with a shorter search string)
					goto b;
				}
				else
				{
					return FALSE;
				}
			}

			// we have a match, so check out whether it is exact, or a substring, etc.
			nTargetLength = strSearchTarget.Length();
			nSearchLength = strConstruct.Length();
			nAddParts = 0;
			if (nTotal > 0)
			{
                // there is more in the search string yet to be matched, so we are not at
                // the last source phrase to be tested when in this nTotal > 0 == TRUE code
                // block
				if (bFirstAttempt)
				{
                    // nFound can be non-zero, but the matching must be done up to the end
                    // of the strSearchTarget string, else we have a discontinuity and so
                    // return FALSE or iterate
					nAddParts = nFound + nSearchLength;
					if (nAddParts < nTargetLength)
					{
						if (nCount == 1 && nIteration < nLimit)
						{
							// no match: we can try with a shorter search string,
							// so iterate
							goto b;
						}
						else
						{
							// nCount > 1, can't possibly match because of discontinuity,
							// so return FALSE
							return FALSE;
						}
					}
					wxASSERT(nAddParts == nTargetLength); // we can continue, 
														  // valid matching so far
				}
				else
				{
                    // there was a previous match or matches, so this matched string must
                    // be coextensive with strSearchTarget itself, to avoid a discontinuity
                    // in the matching, since there is yet more waiting to be tested for a
                    // match in a later srcPhrase; if there is a discontinuity, check for
                    // the possibility of an iteration and do so if the conditions are
                    // right, else return FALSE
					if (nSearchLength != nTargetLength)
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto b; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
					wxASSERT(nSearchLength == nTargetLength); // okay so far, so continue
				}
			}
			else
			{
                // nTotal must be zero, and so this current match is the last - but it must
                // match from the beginning of strSearchTarget, unless bFirstAttempt is
                // also TRUE
				wxASSERT(nTotal == 0);
				if (bFirstAttempt)
				{
                    // we have just made our first match, ie, we are at the start of the
                    // search string, so nFind can be non-zero legitimately, so we can
                    // return TRUE, since we are done
					return TRUE;
				}
				else
				{
                    // we are at the end of the search string, and there were previous
                    // matches, so the offset to the first matched character must be zero,
                    // if not, we do not have continuity in the matching, hence not a
                    // legitimate match
					if (nFound == 0)
					{
						return TRUE;
					}
					else
					{
						// discontinuity, check for iteration possibility
						if (nCount == 1 && nIteration < nLimit)
						{
							goto b; // have another try with a shorter search string
						}
						else
						{
							return FALSE;
						}
					}
				}
			}

            // we have finished our first attempt (ie. trying to match in first srcPhrase),
            // so make bFirstAttempt FALSE for subsequent traverses through the loop
			bFirstAttempt = FALSE;
		}
		return FALSE;
		break;
	}
#ifndef __VISUALC__
	return FALSE; // unreachable according to VC7.1, but gcc says it is needed!!!
#endif
}

// searches in the list of source phrases for a match, ignores the view; if glossing is ON
// then bIncludePunct and bSpanSrcPhrases will be obligatorily FALSE; and nCount should not
// get set to anything except 1 (when glossing is ON)
// ALSO NOTE: for simplicity I had a test of gbIsGlossing set the bIncludePunct flag to FALSE,
// which strictly speaking is too strong a condition when the search is done only in the
// source text; however, since few people use the Find... command, and fewer still are likely
// to use it with glossing ON and at the same time want a punctuated search in the source text,
// I figure I can get this past muster without anyone ever discovering it! In other words, when
// glossing is ON, the search will be in source text where punctuation has been excluded.
bool CAdapt_ItView::DoSrcOnlyFind(int nStartSequNum, bool bIncludePunct, bool bSpanSrcPhrases,
								  wxString& src,bool bIgnoreCase, int& nSequNum, int& nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbIsGlossing)
	{
		wxASSERT(!bIncludePunct && !bSpanSrcPhrases);
	}
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int nRetransFirst = -1;
	int nRetransLast = -1;
	bool bInRetrans = FALSE;
	int nFound;
	wxString srcCopy; // for caseless matching
	wxString searchCopy; // for caseless searching in it
	wxString srcNoPunct; // for making a copy from which we can remove punctuation

	if (bSpanSrcPhrases)
	{
		// must never enter here when glossing is ON
		bool bFound = FALSE;

        // parse a copy of the src text string, storing the results in temporary
        // CSourcePhrase instances so that the m_key members hold the punctuation-less
        // words, and the m_srcPhrase members the punctuated words
		SPList* pTempList = new SPList; // a temporary list
		wxASSERT(pTempList != NULL);

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		wxString theString = src;
		int	length = theString.Length();
		int nElements = 0;
		if (!theString.IsEmpty())
		{
			nElements = pDoc->TokenizeText(0,pTempList,theString,length);
		}
		else
		{
			// if theString is empty, we've nothing to search for, so return FALSE
			delete pTempList; // don't leak memory
			return FALSE;
		}

		// do the search, and permit matching text across discrete CSourcePhrase instances
		SPList::Node* savePos;
e:		while (pos != NULL)
		{
			wxString tgt;
			tgt.Empty();
			savePos = pos; // test for initial matched srcPhrase in a retranslation
			bFound = DoExtendedSearch(0,pos,pDoc,pTempList,nElements,
										bIncludePunct,bIgnoreCase,nCount);
			if (bFound)
			{
				nSequNum = sn;
				goto d;
			}
			else
			{
				sn++;
			}
		}
		// if we get here, pos is null, and so we have no match possible
		DeleteTempList(pTempList);
		return FALSE;

		// we found a match, check if it is in a retranslation & adjust nCount & 
		// nSequNum if it is contained within the retranslation
d:		pSrcPhrase = (CSourcePhrase*)savePos->GetData();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bRetranslation)
		{
			bInRetrans = IsContainedByRetranslation(nSequNum,nCount,
													nRetransFirst,nRetransLast);
			if (bInRetrans)
			{
				// adjust values, so that the match is the whole retranslation
				CPile* pP = GetPile(nRetransFirst);
				wxASSERT(pP != NULL);
				CSourcePhrase* pSP = pP->GetSrcPhrase();
				wxASSERT(pSP != NULL);
				nSequNum = pSP->m_nSequNumber;
				nCount = nRetransLast - nRetransFirst + 1;

				// set the globals
				pApp->m_bMatchedRetranslation = TRUE;
				gnRetransEndSequNum = nRetransLast;
				DeleteTempList(pTempList);
				return TRUE;
			}
			else
			{
				// clear the globals
				pApp->m_bMatchedRetranslation = FALSE;
				gnRetransEndSequNum = -1;
				goto e; // continue iterating, looking for a match
			}
		}
		// clear the globals
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		DeleteTempList(pTempList);
		return TRUE; // return with unchanged nSequNum and nCount values
	}
	else // could be glossing or adapting
	{
		// do the search, confining attempts to match the text within
		// a single CSourcePhrase instance
		nFound = -1; // assume not found
		srcCopy = src; // for caseless matching
		srcNoPunct = src; // make a copy from which we can remove punctuation
		RemovePunctuation(pDoc,&srcNoPunct,from_source_text);
		if (bIgnoreCase)
		{
			srcCopy.MakeLower();
			srcNoPunct.MakeLower();
		}
f:		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

			// do the searching either in m_srcPhrase or m_key, depending on
			// whether punctuation is to be included in the search or not
			if (bIncludePunct)
			{
				// use the m_srcPhrase attribute if adapting; don't enter this block
				// if glossing is ON
				if (pSrcPhrase->m_srcPhrase.IsEmpty() || pSrcPhrase->m_bNullSourcePhrase)
				{
					goto b;
				}
				searchCopy = pSrcPhrase->m_srcPhrase;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				nFound = searchCopy.Find(srcCopy);
b:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto c;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
			else // bIncludePunct is FALSE, so if glossing is ON it too will use this block
			{
				// use the m_key attribute
				if (pSrcPhrase->m_key.IsEmpty() || pSrcPhrase->m_bNullSourcePhrase)
				{
					goto a;
				}
				searchCopy = pSrcPhrase->m_key;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				nFound = searchCopy.Find(srcNoPunct);
a:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto c;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
		}
	}

	// if we get here, we didn't find a match
	return FALSE;

    // we found a match, check if it is in a retranslation & adjust nCount & nSequNum if it
    // is contained within the retranslation; but we don't want to test this if glossing is
    // ON because matching can be within a translation in that circumstance
c: if (gbIsGlossing)
   {
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
   }
   // when not glossing we have to consider the possibility that we may be in, out, or
   // partially within a retranslation
	if (pSrcPhrase->m_bRetranslation)
	{
		bInRetrans = IsContainedByRetranslation(nSequNum,nCount,
												nRetransFirst,nRetransLast);
		if (bInRetrans)
		{
			// adjust values, so that the match is the whole retranslation
			CPile* pP = GetPile(nRetransFirst);
			wxASSERT(pP != NULL);
			CSourcePhrase* pSP = pP->GetSrcPhrase();
			wxASSERT(pSP != NULL);
			nSequNum = pSP->m_nSequNumber;
			nCount = nRetransLast - nRetransFirst + 1;

			// set the globals
			pApp->m_bMatchedRetranslation = TRUE;
			gnRetransEndSequNum = nRetransLast;
			return TRUE;
		}
		else
		{
			// clear the globals
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			goto f; // continue iterating, looking for a match
		}
	}
	// clear the globals
	pApp->m_bMatchedRetranslation = FALSE;
	gnRetransEndSequNum = -1;
	return TRUE; // return with unchanged nSequNum and nCount values
}

// searches in the list of source phrases for a match, ignores the view; when glossing is
// ON the 'tgt' will be the glossing line; and the 2nd and 3rd parameters will be FALSE,
// and nCount must only return 1 (when glossing is ON). Glossing text by default allows any
// typed punctuation to be stored; so bIncludePunct == FALSE does nothing to affect whether
// gloss text has punctuation, it just stops certain blocks of code being entered.
bool CAdapt_ItView::DoTgtOnlyFind(int		nStartSequNum, 
								  bool		bIncludePunct, 
								  bool		bSpanSrcPhrases,
								  wxString& tgt, 
								  bool		bIgnoreCase, 
								  int&		nSequNum, 
								  int&		nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL); 
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL); 
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int nRetransFirst = -1;
	int nRetransLast = -1;
	bool bInRetrans = FALSE;
	int nFound; // -1 = assume not found
	wxString tgtCopy; // for caseless matching
	wxString searchCopy; // for caseless searching in it
	wxString tgtNoPunct; // for making a copy from which we can remove punctuation

    // if bSpanSrcPhrases is TRUE,but the tgt string is empty, then it makes no sense to
    // span source phrases, so this case reduces to a normal search within a single
    // srcPhrase
	if (bSpanSrcPhrases && tgt.IsEmpty())
		goto c;

	if (bSpanSrcPhrases)
	{
		wxASSERT(!gbIsGlossing); // must not be glossing if we enter this block
		// do the search, and permit matching text across discrete 
		// CSourcePhrase instances
		bool bFound = FALSE;

        // parse a copy of the tgt text string, storing the results in temporary
        // CSourcePhrase instances so that the m_key members hold the punctuation-less
        // words, and the m_srcPhrase members the punctuated words
		SPList* pTempList = new SPList; // a temporary list
		wxASSERT(pTempList != NULL); 

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		wxString theString = tgt;
		int	length = theString.Length();
		int nElements = 0;
		if (!theString.IsEmpty())
		{
			nElements = pDoc->TokenizeText(0,pTempList,theString,length);
		}
		else
		{
			// if theString is empty, we've nothing to search for, so return FALSE
			delete pTempList; // don't leak memory
			return FALSE;
		}

		// do the search, and permit matching text across discrete CSourcePhrase instances
		SPList::Node* savePos; 
h:		while (pos != NULL)
		{
			wxString src;
			src.Empty();
			savePos = pos;
			bFound = DoExtendedSearch(1,pos,pDoc,pTempList,nElements,
									bIncludePunct,bIgnoreCase,nCount);
			if (bFound)
			{
				nSequNum = sn;
				goto d;
			}
			else
			{
				sn++;
			}
		}
		// if we get here, pos is null, and so we have no match possible
		DeleteTempList(pTempList);
		return FALSE;

		// we found a match, check if it is in a retranslation & adjust nCount &
		// nSequNum if it is contained within the retranslation
d:		pSrcPhrase = (CSourcePhrase*)savePos->GetData();
		wxASSERT(pSrcPhrase != NULL); 
		if (pSrcPhrase->m_bRetranslation)
		{
			bInRetrans = IsContainedByRetranslation(nSequNum,nCount,
												nRetransFirst,nRetransLast);
			if (bInRetrans)
			{
				// adjust values, so that the match is the whole retranslation
				CPile* pP = GetPile(nRetransFirst);
				wxASSERT(pP != NULL);
				CSourcePhrase* pSP = pP->GetSrcPhrase();
				wxASSERT(pSP != NULL);
				nSequNum = pSP->m_nSequNumber;
				nCount = nRetransLast - nRetransFirst + 1;

				// set the globals
				pApp->m_bMatchedRetranslation = TRUE;
				gnRetransEndSequNum = nRetransLast;
				DeleteTempList(pTempList);
				return TRUE;
			}
			else
			{
				// clear the globals
				pApp->m_bMatchedRetranslation = FALSE;
				gnRetransEndSequNum = -1;
				goto h; // continue iterating, looking for a match
			}
		}
		// clear the globals
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		DeleteTempList(pTempList);
		return TRUE; // return with unchanged nSequNum and nCount values
	}
	else // bSpanSrcPhrases == FALSE branch; glossing ON uses this branch always
	{
		// do the search, confining attempts to match the text within
		// a single CSourcePhrase instance
c:		nFound = -1; // assume not found
		tgtCopy = tgt; // for caseless matching (tgt would contain search string
					   // for finding within glosses if glossing is ON)
		tgtNoPunct = tgt; // make a copy from which we can remove punctuation
		if (!gbIsGlossing)
			RemovePunctuation(pDoc,&tgtNoPunct,from_target_text);
		if (bIgnoreCase)
		{
			tgtCopy.MakeLower();
			tgtNoPunct.MakeLower();
		}
i:		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

            // do the searching either in m_targetStr or m_adaption, depending on whether
            // punctuation is to be included in the search or not
			if (bIncludePunct) // glossing ON forces this boolean FALSE in the caller,
				// so glossing does not use this block, but only the ELSE block
			{
				// use the m_targetStr attribute
				if (pSrcPhrase->m_targetStr.IsEmpty())
				{
					// since we allow null matches, check for this
					if (tgt.IsEmpty())
					{
						// we have a null match, so success
						nSequNum = sn;
						nCount = 1;
						goto e;
					}
					else
						goto b;
				}
				else
				{
					if (tgt.IsEmpty())
						goto b; // can't allow a Find with a null phrase, 
								// it would match anything
				}
				searchCopy = pSrcPhrase->m_targetStr;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				nFound = searchCopy.Find(tgtCopy);
b:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto e;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
			else // bIncludePunct == FALSE branch; glossing ON also uses this branch
			{
				// use the m_adaption attribute when adapting, m_gloss when glossing
				bool bTest;
				if (gbIsGlossing)
					bTest = pSrcPhrase->m_gloss.IsEmpty();
				else
					bTest = pSrcPhrase->m_adaption.IsEmpty();
				if (bTest)
				{
					// no text, since we allow null matches check for a null match
					if (tgt.IsEmpty())
					{
						// we have a null match, so success
						nSequNum = sn;
						nCount = 1;
						goto e;
					}
					else
						goto a;
				}
				else // there is some adaptation, or gloss, text
				{
					if (tgt.IsEmpty())
						goto a; // can't allow a Find with a null phrase,
							// (except for a null match) because it would match anything
				}
				if (gbIsGlossing)
					searchCopy = pSrcPhrase->m_gloss;
				else
					searchCopy = pSrcPhrase->m_adaption;
				if (bIgnoreCase)
					searchCopy.MakeLower();
				if (gbIsGlossing)
				{
					nFound = pSrcPhrase->m_gloss.Find(tgt); // possibly 
										// a punctuation-containing search
				}
				else // not glossing
				{
					nFound = pSrcPhrase->m_adaption.Find(tgtNoPunct);
				}
a:				if (nFound >= 0)
				{
					// we found a matching (sub)string
					nSequNum = sn;
					nCount = 1;
					goto e;
				}
				else
				{
					sn++; // index for next CSourcePhrase instance to be searched
				}
			}
		}
	}

	// if we get here, we didn't find a match
	return FALSE;

	// we found a match, check if it is in a retranslation & adjust nCount & 
	// nSequNum if it is contained within the retranslation
e:	if (gbIsGlossing)
	{
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
	}
	// if not glossing, we have to check out if we landed in, or partly in, or out of
	// a retranslation - and fix things accordingly.
	if (pSrcPhrase->m_bRetranslation)
	{
		bInRetrans = IsContainedByRetranslation(nSequNum,nCount,
												nRetransFirst,nRetransLast);
		if (bInRetrans)
		{
			// adjust values, so that the match is the whole retranslation
			CPile* pP = GetPile(nRetransFirst);
			wxASSERT(pP != NULL);
			CSourcePhrase* pSP = pP->GetSrcPhrase();
			wxASSERT(pSP != NULL);
			nSequNum = pSP->m_nSequNumber;
			nCount = nRetransLast - nRetransFirst + 1;

			// set the globals
			pApp->m_bMatchedRetranslation = TRUE;
			gnRetransEndSequNum = nRetransLast;
			return TRUE;
		}
		else
		{

			// clear the globals
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			goto i; // continue iterating, looking for a match
		}
	}
	// clear the globals
	pApp->m_bMatchedRetranslation = FALSE;
	gnRetransEndSequNum = -1;
	return TRUE; // return with unchanged nSequNum and nCount values
}

// see the comments at the start of the DoSrcOnlyFind( ) and DoTgtOnlyFind( ) - same stuff
// applies here; and tgt could be text to check in adaptations, or glosses, depending on
// gbIsGlossing value
bool CAdapt_ItView::DoSrcAndTgtFind(int			nStartSequNum, 
									bool		bIncludePunct, 
									bool		bSpanSrcPhrases,
									wxString&	src, 
									wxString&	tgt, 
									bool		bIgnoreCase, 
									int&		nSequNum,
									int&		nCount)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL); 
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	SPList::Node* pos = pList->Item(nStartSequNum); // starting POSITION
	wxASSERT(pos != NULL);
	int sn = nStartSequNum;
	CSourcePhrase* pSrcPhrase = NULL;
	int nSaveSrcSequNum = -1;
	int nCount1 = 0;
	int nCount2 = 0;
	int nRetransFirst = -1;
	int nRetransLast = -1;
	bool bInRetrans = FALSE;
	bool bSrcMatchIsRetrans = FALSE;
	bool bFound = FALSE;
	SPList* pTempList = NULL;
	int length = 0;
	int nElements = 0;
	int nElements2 = 0;
	wxString theString;
	theString.Empty();
	SPList::Node* savePos = NULL;
	int nFound; // -1 = assume not found
	wxString srcCopy;
	wxString tgtCopy;
	wxString searchStr;
	wxString srcNoPunct; // for making a copy from which we can remove punctuation

	if (bSpanSrcPhrases)
	{
		wxASSERT(!gbIsGlossing); // cannot enter this block when glossing is ON
		// do the search, and permit matching text across discrete 
		// CSourcePhrase instances
		bFound = FALSE;

        // parse a copy of the src text string, storing the results in temporary
        // CSourcePhrase instances so that the m_key members hold the punctuation-less
        // words, and the m_srcPhrase members the punctuated words
		pTempList = new SPList; // a temporary list
		wxASSERT(pTempList != NULL);

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		theString = src;
		length = theString.Length();
		nElements = 0;
		if (!theString.IsEmpty())
		{
			nElements = pDoc->TokenizeText(0,pTempList,theString,length);
		}
		else
		{
			// if theString is empty, we've nothing to search for, so return FALSE
			delete pTempList; // don't leak memory
			return FALSE;
		}

		// do the search, and permit matching text across discrete 
		// CSourcePhrase instances
		SPList::Node* savePos = NULL; // whm initialized to NULL 
e:		while (pos != NULL)
		{
			wxString tgt;
			tgt.Empty();
			savePos = pos;
			bFound = DoExtendedSearch(0,pos,pDoc,pTempList,nElements,
									bIncludePunct,bIgnoreCase,nCount1);
			if (bFound)
			{
				nSaveSrcSequNum = sn;
				break;
			}
			else
			{
				sn++;
			}
		}
		// if we get here, pos is null, or we have a src match, if the latter,
		// do the target search
		if (pos == NULL || nSaveSrcSequNum == -1 || savePos == NULL)
		{
			// we didn't get a src match, so return
			DeleteTempList(pTempList);
			return FALSE;
		}

		// we found a match, check if it is in a retranslation & adjust nCount1 &
		// nSequNum if it is contained within the retranslation
		pSrcPhrase = (CSourcePhrase*)savePos->GetData();
		wxASSERT(pSrcPhrase != NULL);
		if (pSrcPhrase->m_bRetranslation)
		{
			bInRetrans = IsContainedByRetranslation(nSaveSrcSequNum,nCount1,
													nRetransFirst,nRetransLast);
			if (bInRetrans)
			{
                 // adjust values, so that the match is the whole retranslation
				CPile* pP = GetPile(nRetransFirst);
				wxASSERT(pP != NULL);
				CSourcePhrase* pSP = pP->GetSrcPhrase();
				wxASSERT(pSP != NULL);
				nSaveSrcSequNum = pSP->m_nSequNumber;
				nCount1 = nRetransLast - nRetransFirst + 1;
				bSrcMatchIsRetrans = TRUE;
			}
			else
			{
				// clear the globals
				bSrcMatchIsRetrans = FALSE;
				pApp->m_bMatchedRetranslation = FALSE;
				gnRetransEndSequNum = -1;
				sn++;
				nSaveSrcSequNum = -1;
				goto e; // continue iterating, looking for a match
			}
		}
		else
		{
			bSrcMatchIsRetrans = FALSE;
		}

        // before doing the target search, we must check for an empty tgt string. If it is
        // empty, then the only meaningful "match" is that nCount1 source phrases matched
        // so far must each have an empty string in their m_adaption member. So if that is
        // so, we have a null match and can exit TRUE. So do the check next.
		if (tgt.IsEmpty())
		{
			SPList::Node* pos3 = pList->Item(nSaveSrcSequNum); 
			wxASSERT(pos3 != 0);
			for (int j=0; j < nCount1; j++)
			{
				CSourcePhrase* pSP = (CSourcePhrase*)pos3->GetData();
				pos3 = pos3->GetNext();
				wxASSERT(pos3 != 0);
				if (!pSP->m_adaption.IsEmpty())
				{
					bSrcMatchIsRetrans = FALSE;
					pApp->m_bMatchedRetranslation = FALSE;
					gnRetransEndSequNum = -1;
					sn++;
					nSaveSrcSequNum = -1;
					goto e; // continue iterating, looking for a match
				}
			}

			// if we get here, we have a valid match, so return
			nSequNum = nSaveSrcSequNum;
			nCount = nCount1;
			DeleteTempList(pTempList);
			return TRUE;
		}

		// now try the target search - (use code copied from 
		// DoTgtFindOnly() & modified a bit)
		bFound = FALSE;

		// start at the sequ number just defined
		SPList::Node* pos2 = pList->Item(nSaveSrcSequNum);
		sn = nSaveSrcSequNum;

        // parse a copy of the tgt text string, storing the results in temporary
        // CSourcePhrase instances so that the m_key members hold the punctuation-less
        // words, and the m_srcPhrase members the punctuated words
		SPList* pTempList2 = new SPList; // a temporary list for the tgt ones
		wxASSERT(pTempList2 != NULL); 

		// tokenize the string into a list of new CSourcePhrase instances on the heap
		// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
		theString = tgt;
		length = theString.Length();
		nElements2 = 0;
		if (!theString.IsEmpty())
		{
			nElements2 = pDoc->TokenizeText(0,pTempList2,theString,length);
		}
		// note, we will permit "matching" an empty string in the target text

        // if the target's nElements2 > nElements, no match is possible (the target must
        // match within the scope of the source match), though it may be possible if the
        // source match was in a retranslation
		if (nElements2 > nElements && !bSrcMatchIsRetrans)
		{
			pApp->m_bMatchedRetranslation = FALSE;
			gnRetransEndSequNum = -1;
			sn = nSaveSrcSequNum; // prepare for outer loop
			sn++;
			nSaveSrcSequNum = -1;
			goto e;
		}

		// do the search, and permit matching text across discrete 
		// CSourcePhrase instances
		while (pos2 != NULL)
		{
			wxString src;
			src.Empty();
			savePos = pos2; // DoExtendedSearch returns pos value at next
							// location to the input parameter pos2 value,
							// so to preserve the input one, we need savePos as well
			bFound = DoExtendedSearch(1,pos2,pDoc,pTempList2,nElements2,
									bIncludePunct,bIgnoreCase,nCount2);
			if (bFound)
			{
				nSequNum = sn;
				DeleteTempList(pTempList2);

                // we have a double match only if the sequence number for the first
                // srcPhrase of each match is the same and the target selection is no
                // longer than the source one; or if not the same, then both nSequNum and
                // the end of the target match lie within the source text selection, which
                // amounts to conditions on nCount1 and nCount2 values

				// we found a match, check if it is in same retranslation if the
				// first match was in one
				pSrcPhrase = (CSourcePhrase*)savePos->GetData();
				wxASSERT(pSrcPhrase != NULL);
				if (pSrcPhrase->m_bRetranslation && bSrcMatchIsRetrans)
				{
					bInRetrans = IsContainedByRetranslation(nSequNum,nCount2,
															nRetransFirst,nRetransLast);
					if (bInRetrans)
					{
						// the match is the whole retranslation
						nSequNum = nSaveSrcSequNum;
						nCount = nCount1;

						// set the globals
						pApp->m_bMatchedRetranslation = TRUE;
						gnRetransEndSequNum = nRetransLast;
						if (pTempList != NULL) DeleteTempList(pTempList);
						return TRUE;
					}
					else
					{
                        // continue iterating the source loop, since the src string matched
                        // the retranslation but the tgt string matched at best only part
                        // of the retranslation which makes it a non-match for the src/tgt
                        // string pair (caller clears the globals)
						bSrcMatchIsRetrans = FALSE;
						pApp->m_bMatchedRetranslation = FALSE;
						gnRetransEndSequNum = -1;
						sn = nSaveSrcSequNum; // prepare for outer loop
						sn++;
						nSaveSrcSequNum = -1;
						goto e;
					}
				}
				else
				{
					// not a retranslation match
					if (nSaveSrcSequNum == nSequNum)
					{
						if (nCount2 <= nCount1)
						{
							// we have a valid match, but not to a retranslation
							pApp->m_bMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							nCount = nCount1;
							if (pTempList != NULL) DeleteTempList(pTempList);
							return TRUE;
						}
						else
						{
							// match is not valid
							bSrcMatchIsRetrans = FALSE;
							pApp->m_bMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							sn = nSaveSrcSequNum; // prepare for outer loop
							sn++;
							nSaveSrcSequNum = -1;
							goto e;
						}
					}
					else if (nSequNum < nSaveSrcSequNum + nCount1)
					{
						if (nSequNum + nCount2 <= nSaveSrcSequNum + nCount1)
						{
							// we have a valid match
							pApp->m_bMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							nSequNum = nSaveSrcSequNum;
							nCount = nCount1;
							if (pTempList != NULL) DeleteTempList(pTempList);
							return TRUE;
						}
						else
						{
							// match is not valid
							bSrcMatchIsRetrans = FALSE;
							pApp->m_bMatchedRetranslation = FALSE;
							gnRetransEndSequNum = -1;
							sn = nSaveSrcSequNum; // prepare for outer loop
							sn++;
							nSaveSrcSequNum = -1;
							goto e;
						}
					}
					else
					{
						bSrcMatchIsRetrans = FALSE;
						pApp->m_bMatchedRetranslation = FALSE;
						gnRetransEndSequNum = -1;
						sn = nSaveSrcSequNum; // prepare for outer loop
						sn++;
						nSaveSrcSequNum = -1;
						goto e;
					}
				}
			}
			else // no match, so continue at next sequ number 
				 // in the inner pos2 loop, until invalid
			{
				sn++;

				// discontinue tgt search & continue src search if sn gets
				// beyond range for the src match
				if (sn >= nSaveSrcSequNum + nCount1)
				{
					bSrcMatchIsRetrans = FALSE;
					pApp->m_bMatchedRetranslation = FALSE;
					gnRetransEndSequNum = -1;
					sn = nSaveSrcSequNum; // prepare for outer loop
					sn++;
					nSaveSrcSequNum = -1;
					goto e;
				}
			}
		}
        // if we get here, pos2 is null, and so we have no later target match possible, so
        // there is no point to trying further source matches
		DeleteTempList(pTempList2);
		if (pTempList != NULL) DeleteTempList(pTempList);
		return FALSE;
	}
	else // bSpanSrcPhrases == FALSE block; also glossing ON always uses this block
	{
		// do the search, confining attempts to match the text within a single
		// CSourcePhrase instance
		nFound = -1; // assume not found
		srcCopy = src;
		tgtCopy = tgt;
		srcNoPunct = src; // make a copy from which we can remove punctuation
		RemovePunctuation(pDoc,&srcNoPunct,from_source_text); // independent of gbIsGlossing
		wxString tgtNoPunct = tgt; // make a copy from which we can remove punctuation
		if (!gbIsGlossing)
			RemovePunctuation(pDoc,&tgtNoPunct,from_target_text);
		if (bIgnoreCase)
		{
			srcCopy.MakeLower();
			tgtCopy.MakeLower();
			srcNoPunct.MakeLower();
			tgtNoPunct.MakeLower();
		}

		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);

			// do the searching either in the pair m_srcPhrase &m_targetStr, or in the pair
			// m_key and m_adaption, depending on whether punctuation is to be included in the
			// search or not
			if (bIncludePunct) // if glossing is ON, this flag will be FALSE
			{
				// use the m_srcPhrase attribute
				if (pSrcPhrase->m_targetStr.IsEmpty())
				{
					if (pSrcPhrase->m_srcPhrase.IsEmpty())
					{
						goto b; // no match
					}
					// we allow a null match in the target, check for this, by continuing
				}
				searchStr = pSrcPhrase->m_srcPhrase;
				if (bIgnoreCase)
					searchStr.MakeLower();
				nFound = searchStr.Find(srcCopy);
			}
			else
			{
				// use the m_adaption attribute
				if (pSrcPhrase->m_adaption.IsEmpty())
				{
					if (pSrcPhrase->m_key.IsEmpty())
					{
						goto b; // no match
					}
					// we allow a null match in the target, check for this, by continuing
				}
				searchStr = pSrcPhrase->m_key;
				if (bIgnoreCase)
					searchStr.MakeLower();
				nFound = searchStr.Find(srcCopy);
			}
			if (nFound == -1)
				goto b;
			nFound = -1; // prepare for attempt to match in target text

			// we matched in the source text, check if the match was in a retranslation.
			// If it is, then we must make the whole retranslation be "matched", in which
			// case we cannot arbitrarily pick one of the target language m_targetStr or
			// m_adaption members as a corresponding since srcPhrase location in which to
			// search for the target, instead, we have to treat the target match as a
			// bSpanSrcPhrases == TRUE case, and try make the match anywhere within the
			// appropriate target text of the retranslation

            // check if the match is in a retranslation & adjust nCount & nSequNum if it is
            // contained within a retranslation; if glossing is ON we don't enter next
            // block
			if (!gbIsGlossing && pSrcPhrase->m_bRetranslation)
			{
				bInRetrans = IsContainedByRetranslation(sn,1,nRetransFirst,nRetransLast);
				if (bInRetrans)
				{
					// adjust values, so that the match is the whole retranslation
					CPile* pP = GetPile(nRetransFirst);
					wxASSERT(pP != NULL); 
					CSourcePhrase* pSP = pP->GetSrcPhrase();
					wxASSERT(pSP != NULL); 
					nSaveSrcSequNum = pSP->m_nSequNumber;
					nCount1 = nRetransLast - nRetransFirst + 1;

					// do a multi-element search for the target text, because retranslations
					// typically are longer than one sourcePhrase in length
					bSrcMatchIsRetrans = TRUE;

					// this block is copied code from above, & changed a bit
					bFound = FALSE;

					// start at the sequ number just defined
					SPList::Node* pos2 = pList->Item(nSaveSrcSequNum); 
					sn = nSaveSrcSequNum;

					// parse a copy of the tgt text string, storing the results in temporary
					// CSourcePhrase instances so that the m_key members hold the
					// punctuation-less words, and the m_srcPhrase members the punctuated words
					SPList* pTempList2 = new SPList; // a temporary list for the tgt ones
					wxASSERT(pTempList2 != NULL);

					// tokenize the string into a list of new CSourcePhrase instances on the heap
					// (they are incomplete - only m_key, m_srcPhrase and m_nSequNumber are set)
					theString = tgt;
					length = theString.Length();
					nElements = 0;
					if (!theString.IsEmpty())
					{
						nElements = pDoc->TokenizeText(0,pTempList2,theString,length);
					}
					// note, we will permit "matching" an empty string in the target text

					// do the search, and permit matching text across discrete 
					// CSourcePhrase instances
					while (pos2 != NULL)
					{
						wxString src;
						src.Empty();
						savePos = pos2; // DoExtendedSearch returns pos value at next location
										// to the input parameter pos2 value, so to preserve the
										// input one, we need savePos as well
						bFound = DoExtendedSearch(1,pos2,pDoc,pTempList2,
												nElements,bIncludePunct,bIgnoreCase,nCount2);
						if (bFound)
						{
							nSequNum = sn;
							DeleteTempList(pTempList2);

							// we have a double match only if the sequence number for the first
							// srcPhrase of each match is the same and the target selection is
							// no longer than the source one; or if not the same, then both
							// nSequNum and the end of the target  match lie within the source
							// text selection, which amounts to conditions on nCount1 and nCount2
							// values

							// we found a match, check if it is in same retranslation if the
							// first match was in one
							pSrcPhrase = (CSourcePhrase*)savePos->GetData(); 
							wxASSERT(pSrcPhrase != NULL);
							if (pSrcPhrase->m_bRetranslation && bSrcMatchIsRetrans)
							{
								bInRetrans = IsContainedByRetranslation(nSequNum,nCount2,
															nRetransFirst,nRetransLast);
								if (bInRetrans)
								{
									// the match is the whole retranslation
									nSequNum = nSaveSrcSequNum;
									nCount = nCount1;

									// set the globals
									pApp->m_bMatchedRetranslation = TRUE;
									gnRetransEndSequNum = nRetransLast;
									if (pTempList != NULL) DeleteTempList(pTempList);
									return TRUE;
								}
								else
								{
                                    // continue iterating the source loop, since the src
                                    // string matched the retranslation but the tgt string
                                    // matched at best only part of the retranslation which
                                    // makes it a non-match for the src/tgt string pair
                                    // (caller clears the globals)
									bSrcMatchIsRetrans = FALSE;
									pApp->m_bMatchedRetranslation = FALSE;
									gnRetransEndSequNum = -1;
									sn = nSaveSrcSequNum; // prepare to continue in outer loop
									goto g;
								}
							}
							else
							{
								// not a retranslation match
								if (nSaveSrcSequNum == nSequNum)
								{
									if (nCount2 <= nCount1)
									{
										// we have a valid match, but not to a retranslation
										pApp->m_bMatchedRetranslation = FALSE;
										gnRetransEndSequNum = -1;
										nCount = nCount1;
										if (pTempList != NULL) DeleteTempList(pTempList);
										return TRUE;
									}
									else
									{
										// match is not valid
										bSrcMatchIsRetrans = FALSE;
										sn = nSaveSrcSequNum; // prepare for outer loop
										goto g;
									}
								}
								else if (nSequNum < nSaveSrcSequNum + nCount1)
								{
									if (nSequNum + nCount2 <= nSaveSrcSequNum + nCount1)
									{
										// we have a valid match
										pApp->m_bMatchedRetranslation = FALSE;
										gnRetransEndSequNum = -1;
										nSequNum = nSaveSrcSequNum;
										nCount = nCount1;
										if (pTempList != NULL) DeleteTempList(pTempList);
										return TRUE;
									}
									else
									{
										// match is not valid
										bSrcMatchIsRetrans = FALSE;
										sn = nSaveSrcSequNum; // prepare for outer loop
										goto g;
									}
								}
								else
								{
									bSrcMatchIsRetrans = FALSE;
									sn = nSaveSrcSequNum; // prepare for outer loop
									goto g; // the match in tgt was to the right
											// of end of src match
								}
							}
						}
						else // no match, so continue at next sequ number, 
							 // in the pos2 loop for tgt
						{
							sn++;

							if (sn >= nSaveSrcSequNum + nCount1)
							{
								bSrcMatchIsRetrans = FALSE;
								sn = nSaveSrcSequNum;
								goto g;
							}
						}
					}
					// if we get here, pos2 is null, and so we have no later target match
					// possible, so there is no point to trying further source matches
					DeleteTempList(pTempList2);
					if (pTempList != NULL) DeleteTempList(pTempList);
					return FALSE;
					// end of the copied & modified code block
				}
				else
				{
					// clear the globals
					bSrcMatchIsRetrans = FALSE;
					pApp->m_bMatchedRetranslation = FALSE;
					gnRetransEndSequNum = -1;
					sn++;
					nSaveSrcSequNum = -1;
					continue; // continue iterating, looking for a match
				}
			} // end of block for testing if the srcPhrase is in a retranslation

			// we are now back in the outer pos loop:
			// continue searching in the single srcPhrase's target text for a match
			if (bIncludePunct)
				searchStr = pSrcPhrase->m_targetStr;
			else
			{
				if (gbIsGlossing)
				{
						searchStr = pSrcPhrase->m_gloss; // do it 'as is'
				}
				else
				{
					searchStr = pSrcPhrase->m_adaption;
				}
			}
			if (bIgnoreCase)
				searchStr.MakeLower();
			if (searchStr.IsEmpty())
			{
				// check for a null match
				if (tgt.IsEmpty())
				{
					// we have a null match, so success
					nSequNum = sn;
					nCount = 1;
					return TRUE;
				}
				else
				{
					// can't match, so try at a later source match if we can find one
					bSrcMatchIsRetrans = FALSE;
					sn++;
					nSaveSrcSequNum = -1;
					continue;
				}
			}
			else
			{
				if (tgt.IsEmpty())
				{
					bSrcMatchIsRetrans = FALSE;
					sn++;
					nSaveSrcSequNum = -1;
					continue; // can't allow a Find with a null string, it would
							  // match anything so try for a new source match
				}
			}
			nFound = searchStr.Find(tgtCopy);
b:			if (nFound >= 0)
			{
				// we found matching (sub)strings
				nSequNum = sn;
				nCount = 1;
				return TRUE;
			}
			else
			{
g:					sn++; // index for next CSourcePhrase instance to be searched
					nSaveSrcSequNum = -1;
			}
		}
	}

	// if we get here, we didn't find a match
	return FALSE;
}

bool CAdapt_ItView::DoReplace(int		nActiveSequNum, 
							  bool		bIncludePunct, 
							  wxString& tgt,						
							  wxString& replStr, 
							  int		nCount)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pDoc != NULL);

	wxASSERT(nCount >= 1);
	wxASSERT(nActiveSequNum >= 0 && nActiveSequNum <= pApp->GetMaxIndex());
	wxASSERT(nActiveSequNum == pApp->m_nActiveSequNum);
	// both or either of the strings can be empty

	wxString tgtNoPunct = tgt;
	if (!gbIsGlossing)
		RemovePunctuation(pDoc,&tgtNoPunct,from_target_text);
	wxString oldTgtNoPunct;
	oldTgtNoPunct.Empty();
	wxString oldTgt;
	oldTgt.Empty();
	wxString finalStr;
	finalStr.Empty();

	CPile* pPile = GetPile(nActiveSequNum);
	wxASSERT(pPile != NULL); 
	CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
	wxASSERT(pSrcPhrase != NULL);

    // if it's a retranslation, the whole will be selected, so nCount will not be 1, even
    // if we didn't choose the multi-srcphrase match option, so check this case out first;
    // if glossing is ON, we ignore the fact that we matched within a retranslation
	if (!gbIsGlossing && pSrcPhrase->m_bRetranslation)
	{
        // we have matched something in a retranslation, so this has to invoke the
        // retranslation editor's dialog which will show the replacement done already when
        // the dialog is shown, user can edit it before dismissing the dialog, or just
        // accept what was done; initialize the globals that OnButtonEditRetranslation()
        // will use
		gbReplaceInRetranslation = TRUE;
		gSrchStr = tgt;
		gReplStr = replStr;

		// allow user to edit result
		wxCommandEvent event;
		OnButtonEditRetranslation(event);

		// clear the globals
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
	}

	// we have to merge first, if nCount is greater than one
	// if glossing is ON, nCount being greater than 1 should not be possible since in
	// that circumstance we don't permit matching across piles
	if (nCount == 1)
	{
		// get the m_adaption member's contents, & m_targetStr;
		// if glossing is ON, then use m_gloss instead
		if (gbIsGlossing)
		{
			oldTgtNoPunct = pSrcPhrase->m_gloss;
			oldTgt = pSrcPhrase->m_gloss;
		}
		else
		{
			oldTgtNoPunct = pSrcPhrase->m_adaption;
			oldTgt = pSrcPhrase->m_targetStr;
		}

        // if we are at a <Not In KB> entry, clear this state because we are going to store
        // something for this entry now (and be sure its not in a retranslation - that is
        // handled differently below
		if (!gbIsGlossing && !pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB && 
			!pSrcPhrase->m_bRetranslation)
		{
			wxString str = _T("<Not In KB>");
			CRefString* pRefString = GetRefString(pApp->m_pKB,
									pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
									pApp->m_pActivePile->GetSrcPhrase()->m_key,str);
			if (pRefString != NULL)
			{
				// we must remove the KB entry
				CTargetUnit* pTgtUnit = pRefString->m_pTgtUnit;
				wxASSERT(pTgtUnit != NULL);
				TranslationsList* pList = pTgtUnit->m_pTranslations;
				wxASSERT(!pList->IsEmpty() && pList->GetCount() == 1);
				TranslationsList::Node* pos = pList->GetFirst();
				delete pRefString; // deletes the CRefString having the text "<Not In KB>"
				pList->DeleteNode(pos);

				// we must also delete the target unit, since we are setting up a situation
				// where in effect the current matched item was never previously matched, ie.
				// it's a big error to have a target unit with no reference string in it.
				int index = pSrcPhrase->m_nSrcWords - 1;
				MapKeyStringToTgtUnit* pMap = GetKB()->m_pMap[index];
				pMap->erase(pSrcPhrase->m_key); // remove it from the map

				// now remove the CTargetUnit instance too
				TUList::Node* tpos;
				tpos = GetKB()->m_pTargetUnits->Find(pTgtUnit); // find position of
														// pRefString's owning targetUnit
				pTgtUnit = (CTargetUnit*)tpos->GetData(); // get the
														  // targetUnit in the list
				wxASSERT(pTgtUnit != NULL);
				GetKB()->m_pTargetUnits->DeleteNode(tpos); // remove it from the list
				delete pTgtUnit; // delete it from the heap
			}

			// fix the flags that will make a save to KB possible
			pSrcPhrase->m_bNotInKB = FALSE;
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pApp->m_bSaveToKB = TRUE;

            // put the replacement string into the global translation variable, which with
            // selector value of 1 in the PlacePhraseBox call, will ensure it goes into
            // m_targetPhrase member, and ends up in the created phrase box
			translation = replStr;

			// prepare for phrase box creation
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = pPile;
			CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

			// place the phrase box
			PlacePhraseBox(pCell,1);

			translation.Empty(); // clear it, no longer needed

			// get a new active pile pointer, the PlacePhraseBox call 
			// did a recalc of the layout
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile != NULL);
			pSrcPhrase->m_bHasKBEntry = FALSE; // ensure StoreText won't
											   // crash when later called

            // save old sequ number in case required for toolbar's Back button - after a
            // Replace, the only safe location is the now current active location
			gnOldSequNum = pApp->m_nActiveSequNum;

			Invalidate();
			GetLayout()->PlaceBox();
			return TRUE;
		}
		else if (!gbIsGlossing &&
			pSrcPhrase->m_bNullSourcePhrase && !pSrcPhrase->m_bRetranslation)
		{
			// we are changing tgt text in a null src phrase which is not in a retranslation
			int nFound = -1;
			int lenOldTgt = 0;
			int lenTgt = 0;
			int nRight;
			wxString left;
			left.Empty();
			wxString right;
			right.Empty();
			if (bIncludePunct)
			{
				lenTgt = tgt.Length(); // the search string's length
				lenOldTgt = oldTgt.Length(); // length of the string in 
											 // which the search is done
				nFound = oldTgt.Find(tgt);
				wxASSERT(nFound != -1); // must not have failed, since this
									    // was the match done in caller
				left = oldTgt.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgt.Right(nRight);
			}
			else
			{
				lenTgt = tgtNoPunct.Length(); // the search string's length
				lenOldTgt = oldTgtNoPunct.Length(); // length of the string in
													// which the search is done
				nFound = oldTgtNoPunct.Find(tgtNoPunct);
				wxASSERT(nFound != -1); // must not have failed, since this was
									    // the match done in caller
				left = oldTgtNoPunct.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgtNoPunct.Right(nRight);
			}

            // put the final string into the global translation variable, which with
            // selector value of 1 in the PlacePhraseBox call, will ensure it goes into
            // m_targetPhrase member, and ends up in the created phrase box
			translation = left + replStr + right;

			// prepare for phrase box creation
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = pPile;
			CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

            // update pSrcPhrase so it shows the new stuff (we can do this because no KB
            // storage is involved)
			wxString adaptionStr = translation;
			RemovePunctuation(pDoc,&adaptionStr,from_target_text);
			pSrcPhrase->m_adaption = adaptionStr;
			pApp->m_targetPhrase = translation;
			MakeLineFourString(pSrcPhrase,pApp->m_targetPhrase);

			// place the phrase box
			PlacePhraseBox(pCell,1); // selector == 1 inhibits both the 
									 // internal restore code blocks
			translation.Empty(); // clear it, no longer needed

			// get a new active pile pointer, the PlacePhraseBox call did a 
			// recalc of the layout
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile != NULL);
			pSrcPhrase->m_bHasKBEntry = FALSE;  // ensure its FALSE, 
												// since it's a null src phrase
            // save old sequ number in case required for toolbar's Back button - use
            // current location
			gnOldSequNum = pApp->m_nActiveSequNum;

			Invalidate();
			GetLayout()->PlaceBox();
			return TRUE;
		}
		else // normal srcPhrase, or if glossing it could be a null one or
			 // retranslation as well as possibly being just a normal one
		{
			// it's a normal srcPhrase, so go ahead and do the replacement
			int nFound = -1;
			int lenOldTgt = 0;
			int lenTgt = 0;
			int nRight;
			wxString left;
			left.Empty();
			wxString right;
			right.Empty();
			if (bIncludePunct)
			{
				// bIncludePunct is always FALSE for glossing, so this block
				// can never be entered when glossing is ON
				wxASSERT(!gbIsGlossing);
				lenTgt = tgt.Length(); // the search string's length
				lenOldTgt = oldTgt.Length(); // length of the string in 
											 // which the search is done
				nFound = oldTgt.Find(tgt);
				wxASSERT(nFound != -1); // must not have failed, since this
									    // was the match done in caller
				left = oldTgt.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgt.Right(nRight);
			}
			else
			{
                // no punctuation case; but can be punctuated string if glossing is ON
                // since glossing being ON will always cause this block to be done
				lenTgt = tgtNoPunct.Length(); // the search string's length
				lenOldTgt = oldTgtNoPunct.Length(); // length of the string in
													// which the search is done
				nFound = oldTgtNoPunct.Find(tgtNoPunct);
				wxASSERT(nFound != -1); // must not have failed, since this was
									    // the match done in caller
				left = oldTgtNoPunct.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgtNoPunct.Right(nRight);
			}

			// put the final string into the temporary store
			finalStr = left + replStr + right;

			// prepare for phrase box creation
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = pPile;
			CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

			// *** TODO *** fix the next bit, we don't want two RecalcLayout()
			// calls - same in 2 blocks above
			
			// place the phrase box
			PlacePhraseBox(pCell,2); // selector == 2 means location's KB entry will
									 // be removed or ref count decremented if > 1

			// now put the new content in the box
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			pCell = pApp->m_pActivePile->GetCell(1); // we want the 2nd line, for phrase box
			pApp->m_targetPhrase = finalStr;
			RemoveSelection();

#ifdef _NEW_LAYOUT
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			GetLayout()->m_docEditOperationType = default_op; // sets 0,-1 'select all'

			// get a new active pile pointer, the PlacePhraseBox call did a 
			// recalc of the layout
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile != NULL);

			// save old sequ number in case required for toolbar's Back button
			// - use current location
			gnOldSequNum = pApp->m_nActiveSequNum;

			Invalidate();
			GetLayout()->PlaceBox();
			return TRUE;
		}
	}
	else // nCount > 1
	{
		// more than one srcPhrase involved, so merge first
		wxASSERT(!gbIsGlossing); // should never get here when glossing is ON
		wxCommandEvent event;
		OnButtonMerge(event);

		if (gbMergeSucceeded)
		{
			// restore the clobbered pointers
			pPile = GetPile(pApp->m_nActiveSequNum);
			pApp->m_pActivePile = pPile;

			// set up the strings in which searching is done, using
			// the globals defined by OnButtonMerge()
			oldTgtNoPunct = gOldConcatStrNoPunct;
			oldTgt = gOldConcatStr;

			// it's now a normal single srcPhrase replacement, so go ahead and do it
			int nFound = -1;
			int lenOldTgt = 0;
			int lenTgt = 0;
			int nRight;
			wxString left;
			left.Empty();
			wxString right;
			right.Empty();
			if (bIncludePunct)
			{
				lenTgt = tgt.Length(); // the search string's length
				lenOldTgt = oldTgt.Length(); // length of the string in 
											 // which the search is done
				nFound = oldTgt.Find(tgt);
				wxASSERT(nFound != -1); // must not have failed, since this
									    // was the match done in caller
				left = oldTgt.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgt.Right(nRight);
			}
			else
			{
				lenTgt = tgtNoPunct.Length(); // the search string's length
				lenOldTgt = oldTgtNoPunct.Length(); // length of the string in
													// which the search is done
				nFound = oldTgtNoPunct.Find(tgtNoPunct);
				wxASSERT(nFound != -1); // must not have failed, since this was
									    // the match done in caller
				left = oldTgtNoPunct.Left(nFound);
				nRight = nFound + lenTgt;
				wxASSERT(nRight <= lenOldTgt);
				nRight = lenOldTgt - nRight;
				right = oldTgtNoPunct.Right(nRight);
			}

			// put the final string into the temporary store
			finalStr = left + replStr + right;

			// prepare for phrase box creation
			pApp->m_nActiveSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = pPile;
			CCell* pCell = pPile->GetCell(1); // we want the 2nd line, for phrase box

			// *** TODO *** fix the next bit, we don't want two RecalcLayout()
			//  calls & same above

			// place the phrase box
			PlacePhraseBox(pCell,2); // selector == 2 means location's KB entry
									 // will be removed or ref count decremented if > 1

			// now put the new content in the box
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			pCell = pApp->m_pActivePile->GetCell(1); // we want the 2nd line, 
													 // for phrase box
			pApp->m_targetPhrase = finalStr;
			RemoveSelection();

#ifdef _NEW_LAYOUT
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			GetLayout()->m_docEditOperationType = default_op; // sets 0,-1 'select all'

			// get a new active pile pointer, the PlacePhraseBox call did a 
			// recalc of the layout
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile != NULL);

            // update pSrcPhrase here, rather than waiting for another Find Next button
            // click, so than in the event of the latter, the view reflects the changed
            // m_adaption, etc. members
			wxString adaptionStr = finalStr;
			RemovePunctuation(pDoc,&adaptionStr,from_target_text);
			pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
			wxASSERT(pSrcPhrase != NULL);
			pSrcPhrase->m_adaption = adaptionStr;

			// save old sequ number in case required for toolbar's Back button
			// - use current location
			gnOldSequNum = pApp->m_nActiveSequNum;

		}
		else
		{
			RemoveSelection();
			::wxBell();
		}

		Invalidate();
		GetLayout()->PlaceBox();

		// clear the globals
		pApp->m_bMatchedRetranslation = FALSE;
		gnRetransEndSequNum = -1;
		return TRUE;
	}
}

// determines if nFirstSequNum up to nFirstSequNum + nCount - 1 all lie within a
// retranslation; if TRUE, then also returns the first and last sequence numbers for the
// retranslation in the last 2 parameters; these parameters are not defined if FALSE is
// returned
bool CAdapt_ItView::IsContainedByRetranslation(int	nFirstSequNum, 
											   int	nCount,
											   int& nSequNumFirst,
											   int& nSequNumLast)
{
	wxASSERT(!gbIsGlossing); // when glossing this should never be called
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	SPList* pList = pApp->m_pSourcePhrases;
	wxASSERT(pList != NULL);
	CSourcePhrase* pSrcPhrase;

	SPList::Node* pos = pList->Item(nFirstSequNum);
	wxASSERT(pos != NULL);
	int count = 0;
	bool bFoundEnd = FALSE;
	while(pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != NULL); 
		count++;
		if (pSrcPhrase->m_bEndRetranslation)
			bFoundEnd = TRUE; // next iteration will go out of retranslation,
							  // or into a following one
		if (!pSrcPhrase->m_bRetranslation || 
			(pSrcPhrase->m_bBeginRetranslation && bFoundEnd))
		{
			return FALSE;
		}
		if (count >= nCount)
			break;
	}

	// lies within the retranslation, so get the bounds
	nSequNumFirst = nFirstSequNum;
	int nFirst = nFirstSequNum+1;
	pos = pList->Item(nFirstSequNum);
a:	pSrcPhrase = (CSourcePhrase*)pos->GetData(); 
	pos = pos->GetPrevious();
	if (pSrcPhrase->m_bRetranslation && !pSrcPhrase->m_bEndRetranslation)
	{
		nSequNumFirst = --nFirst;
		goto a;
	}
	nSequNumLast = nFirstSequNum + count - 1;
	int nLast = nFirstSequNum + count - 1;
b:	nLast += 1;
	pos = pList->Item(nLast); 
	pSrcPhrase = (CSourcePhrase*)pos->GetData();
	pos = pos->GetNext();
	if (pSrcPhrase->m_bRetranslation && !pSrcPhrase->m_bBeginRetranslation)
	{
		nSequNumLast = nLast;
		goto b;
	}

	return TRUE;
}

void CAdapt_ItView::OnRetransReport(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	// BEW added 05Jan07 to enable work folder on input to be restored when done
	wxString strSaveCurrentDirectoryFullPath = GetDocument()->GetCurrentDirectory();

	if (gbIsGlossing)
	{
		// IDS_NOT_WHEN_GLOSSING
		wxMessageBox(_(
"This particular operation is not available when you are glossing."),
		_T(""),wxICON_INFORMATION);
		return;
	}
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc;
	CPhraseBox* pBox;
	CAdapt_ItView* pView;
	pApp->GetBasePointers(pDoc,pView,pBox); // this is 'safe' when no doc is open
	wxString name; // name for the document, to be used in the report

	pApp->m_acceptedFilesList.Clear();
	int answer;

    // only put up the message box if a document is open (and the update handler also
    // disables the command if glossing is on)
	if (GetLayout()->GetStripArray()->GetCount() > 0)
	{
		// IDS_RETRANS_REPORT_ADVICE
		answer = wxMessageBox(_(
"The retranslation report will be based on this open document only.\nTo get a report based on many or all documents,\nclose the document and select this command again.\nDo you want a report only for this document?"),
		_T(""),wxYES_NO);
		if (!(answer == wxYES))
		{
			// a "Yes" answer is a choice for reporting only for the current document,
			// a "No" answer exits to allow the user to close the document and then
			// the report can be chosen again and it will do all documents
			return;
		}
	}

	// can proceed, so get output filename and put up file dialog
	// make the working directory the "<Project Name>" one
	bool bOK;
	bOK = ::wxSetWorkingDirectory(pApp->m_curProjectPath); // ignore failures
	int len;
	wxString reportFilename,defaultDir;
	if (GetLayout()->GetStripArray()->GetCount() > 0)
	{
		wxASSERT(pDoc != NULL);
		reportFilename = pApp->m_curOutputFilename;

		// make a suitable default output filename for the export function
		len = reportFilename.Length();
		reportFilename.Remove(len-4,4); // remove the .adt or .xml extension
		name = reportFilename; // use for the document name in the report
		reportFilename += _(" report.txt"); // make it a *.txt file type // localization?
	}
	else
	{
		// construct a general default filename, and "name" will be defined in
		// DoRetranslationReport()
		reportFilename = _("retranslation report.txt"); // localization?
		name.Empty();
	}
	// set the default folder to be shown in the dialog 
	if (pApp->m_retransReportPath.IsEmpty())
	{
		defaultDir = pApp->m_curProjectPath;
	}
	else
	{
		defaultDir = pApp->m_retransReportPath;
	}

	// get a file dialog
	wxString filter;
	filter = _("Adapt It Reports (*.txt)|*.txt||"); //IDS_REPORT_FILTER
	wxFileDialog fileDlg(
		(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
		_("Filename For Retranslation Report"),
		defaultDir,
		reportFilename,
		filter,
		wxFD_SAVE | wxFD_OVERWRITE_PROMPT); 
			// | wxHIDE_READONLY); wxHIDE_READONLY deprecated in 2.6 - the checkbox is never shown
			// GDLC wxSAVE & wxOVERWRITE_PROMPT deprecated in 2.8
	fileDlg.Centre();

	if (fileDlg.ShowModal() != wxID_OK)
	{
		int length = pApp->m_targetPhrase.Length();
		pApp->m_nStartChar = length;
		pApp->m_nEndChar = length;
		pApp->m_pTargetBox->SetSelection(length,length);
		pApp->m_pTargetBox->SetFocus();
        // whm added 05Jan07 to restore the former current working directory for safety
        // sake to what it was on entry, since there was a wxSetWorkingDirectory call made
        // above
		bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
		return; // user cancelled
	}

	// update m_retransReportPath
	wxString exportPath = fileDlg.GetPath();
	wxString fname = fileDlg.GetFilename(); 
	int nameLen = fname.Length();
	int pathLen = exportPath.Length();
	wxASSERT(nameLen > 0 && pathLen > 0);
	pApp->m_retransReportPath = exportPath.Left(pathLen - nameLen - 1);

	// get the user's desired path
	wxString reportPath = fileDlg.GetPath();

	wxFile f; //CStdioFile f;
	if( !f.Open( reportPath, wxFile::write)) 
	{
	   #ifdef __WXDEBUG__
		  wxLogError(_("Unable to open report file.\n")); 
		  wxMessageBox(_("Unable to open report file."),_T(""), wxICON_WARNING);
	   #endif
        // whm added 05Jan07 to restore the former current working directory for safety
        // sake to what it was on entry, since there was a wxSetWorkingDirectory call made
        // above
		bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
	   return; // just return since it is not a fatal error
	}

	// write a file heading
	wxString header1,header2;
	header1.Empty();
	header2.Empty();
	// header.Format(IDS_RETRANS_HEADER, reportPath);
	// wx note: Since we supply the cross-platform eol chars separately, 
	// break header into two parts
	header1 = _("Retranslation Report");
	header2 = header2.Format(_("File Path: %s"), reportPath.c_str());

#ifndef _UNICODE
	f.Write(header1);
	f.Write(pApp->m_eolStr);
	f.Write(header2);
	f.Write(pApp->m_eolStr);
	f.Write(pApp->m_eolStr);
#else
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,header1); // use UTF-8 encoding
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,pApp->m_eolStr); // use UTF-8 encoding
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,header2); // use UTF-8 encoding
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,pApp->m_eolStr); // use UTF-8 encoding
	pApp->ConvertAndWrite(wxFONTENCODING_UTF8,&f,pApp->m_eolStr); // use UTF-8 encoding
#endif

	// save entry state (only necessary if entry state had book mode on)
	BookNamePair* pSave_BookNamePair = pApp->m_pCurrBookNamePair;
	int nSave_BookIndex = pApp->m_nBookIndex;
	wxString save_bibleBooksFolderPath = pApp->m_bibleBooksFolderPath;

	// output report data
	wxArrayString* pFileList = &pApp->m_acceptedFilesList;
	if (GetLayout()->GetStripArray()->GetCount() > 0)
	{
		// a document is open, so only do the report for this current document
		wxASSERT(pFileList->IsEmpty()); // must be empty, 
								// DoRetranslationReport() uses this as a flag

		DoRetranslationReport(pApp,pDoc,name,pFileList,pApp->m_pSourcePhrases,&f);
	}
	else
	{
        // no document is open, so enumerate all the doc files, and do a report based on
        // those the user chooses (remember that in our version of this SDI app, when no
        // document is open, in fact we have an open unnamed empty document, so pDoc is
        // still valid)
		// BEW modified 06Sept05 for support of Bible book folders in the Adaptations
		// folder 
		wxASSERT(pDoc != NULL);

		// determine whether or not there are book folders present
        // whm note: AreBookFoldersCreated() has the side effect of changing the current
        // work directory to the passed in pApp->m_curAdaptionsPath.
		gbHasBookFolders = pApp->AreBookFoldersCreated(pApp->m_curAdaptionsPath);

		// do the Adaptations folder's files first
        // whm note: EnumerateDocFiles() has the side effect of changing the current work
        // directory to the passed in pApp->m_curAdaptionsPath.
		bool bOK = pApp->EnumerateDocFiles(pDoc, pApp->m_curAdaptionsPath);
		if (bOK)
		{
			// bale out if there are no files to process, and no book folders too
			if (pApp->m_acceptedFilesList.GetCount() == 0 && !gbHasBookFolders)
			{
				// nothing to work on, so abort the operation
				// IDS_NO_DOCUMENTS_YET
				wxMessageBox(_(
"Sorry, there are no saved document files yet for this project. At least one document file is required for the operation you chose to be successful. The command will be ignored."),
				_T(""),wxICON_EXCLAMATION);
                // whm added 05Jan07 to restore the former current working directory for
                // safety sake to what it was on entry, since the EnumerateDocFiles call
                // made above changes the current working dir to the Adaptations folder
                // (MFC version did not add the line below)
				bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
				return;
			}
			// because of prior EnumerateDocFiles call, pFileList will have
			// document filenames in it
			DoRetranslationReport(pApp,pDoc,name,pFileList,pApp->m_pSourcePhrases,&f);
		}

		// now do the book folders, if there are any
		if (gbHasBookFolders)
		{
            // process this block only if the project's Adaptations folder contains the set
            // of Bible book folders - these could contain documents, and some or all could
            // be empty; NOTE: the code below is smart enough to ignore any user-created
            // folders which are sisters of the Bible book folders for which the
            // Adaptations folder is the common parent folder
			int nCount;
			wxDir finder;
			// wxDir must call .Open() before enumerating files!
			bool bOK = (::wxSetWorkingDirectory(pApp->m_curAdaptionsPath) && 
												finder.Open(pApp->m_curAdaptionsPath));
			if (!bOK)
			{
				// highly unlikely, so English will do
				wxString s1, s2, s3;
				s1 = _T(
"Failed to set the current directory to the Adaptations folder in OnRetransReport function, ");
				s2 = _T(
"processing book folders, so the book folder document files contribute nothing.");
				s3 = s3.Format(_T("%s%s"),s1.c_str(),s2.c_str());
				wxMessageBox(s3,_T(""), wxICON_EXCLAMATION);
                // whm added 05Jan07 to restore the former current working directory for
                // safety sake to what it was on entry, since the wxSetWorkingDirectory
                // call made above changes the current working dir to the Adaptations
                // folder (MFC version did not add the line below)
				bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
				return;
			}
			else
			{
				// whm note: in GetFirst below, wxDIR_FILES | wxDIR_DIRS flag finds files
				// or directories, but not . or .. or hidden files
				wxString str = _T("");
				bool bWorking = finder.GetFirst(&str,wxEmptyString,wxDIR_FILES | wxDIR_DIRS);
				while (bWorking)
				{
					bWorking = finder.GetNext(&str);

                    // whm note: in the MFC version's "if (finder.IsDirectory())" test
                    // below, the finder continues to use the directory path that was
                    // current when the inital finder.FindFile call was made above, even
                    // though the EnumerateDocFiles() call below changes the current
                    // working dir for each of the book folder directories it processes. In
                    // the wx version the finder.Exists(str) call uses whatever the current
                    // working directory is and checks for a sub-directory "str" below that
                    // - a difference we must account for here in the wx version. whm Note:
                    // The Exists() method of wxDIR used below returns TRUE if the passed
                    // name IS a directory.
					if (finder.Exists(pApp->m_curAdaptionsPath + pApp->PathSeparator + str))
					{
                        // User-defined folders can be in the Adaptations folder without
                        // making the app confused as to whether or not Bible Book folders
                        // are present or not

						// we have found a folder, check if it matches one of those in
						// the array of BookNamePair structs (using the seeName member)
						if (pApp->IsDirectoryWithin(str,pApp->m_pBibleBooks))
						{
							// we have found a folder name which belongs to the set of
							// Bible book folders, so construct the required path to the
							// folder and enumerate is documents then call
							// DoTransformationsToGlosses() to process any documents within
							wxString folderPath = pApp->m_curAdaptionsPath;
							folderPath += pApp->PathSeparator + str; 

                            // clear the string list of directory names & then enumerate
                            // the directory's file contents; the EnumerateDocFiles() call
                            // sets the current directory to the one given by folderPath
                            // (ie. to a book folder) so after the DoKBRestore() call,
                            // which relies on that directory being current, we must call
                            // ::SetCurrentDirectory(m_curAdaptionsPath) again so that this
                            // outer look which iterates over directories continues
                            // correctly
							pFileList->Clear();
                            // whm note: EnumerateDocFiles() has the side effect of
                            // changing the current work directory to the passed in
                            // folderPath.
							bOK = pApp->EnumerateDocFiles(pDoc, folderPath, TRUE); // TRUE 
																	// == suppress dialog
							if (!bOK)
							{
                                // don't process any directory which gives an error, but
                                // continue looping -- this is a highly unlikely error, so
                                // an English message will do
								wxString errStr;
								errStr = errStr.Format(_T(
		"Error returned by EnumerateDocFiles in Book Folder loop, directory %s skipped."),
								folderPath.c_str());
								wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
								continue;
							}
							nCount = pFileList->GetCount();
							if (nCount == 0)
							{
								// no documents to work on in this folder, so iterate
								continue;
							}

							// There are files to be processed. TRUE parameter suppresses 
							// the statistics dialog.
							DoRetranslationReport(pApp,pDoc,name,pFileList,
													pApp->m_pSourcePhrases,&f);
							// restore parent folder as current
							bOK = ::wxSetWorkingDirectory(pApp->m_curAdaptionsPath); 
							wxASSERT(bOK);
						}
						else
						{
							continue;
						}
					}
					else
					{
						// its a file, so ignore it
						continue;
					}
				} // end loop for FindFile() scanning all possible files in folder
			}  // end block for bOK == TRUE
		} // end block for test for gbHasBookFolders yielding TRUE

		// clean up the list before returning
		pApp->m_acceptedFilesList.Clear();
	}

	// close the file
	f.Close();

	// restore the former book mode parameters (even if book mode was not on on entry)
	pApp->m_pCurrBookNamePair = pSave_BookNamePair;
	pApp->m_nBookIndex = nSave_BookIndex;
	pApp->m_bibleBooksFolderPath = save_bibleBooksFolderPath;
	// now, if the user opens the Document tab of the Start Working wizard, and book
	// mode is on, then at least the path and index and book name are all consistent

    // make sure that book mode is off if there is no valid folder path (if there are docs
    // in book folders, they will store a T (ie. TRUE) for the book mode saved value and so
    // when opened they will turn book mode back on, but if we started with book mode off,
    // then m_bibleBooksFolderPath would be empty, and if we attempt to open the Document
    // tab of the wizard after finishing the report, then we'd get a crash - book mode
    // would be on, but the folder path undefined, -> crash when OnSetActive() of the
    // wizard is called - so the code below ensures this can't happen)
	if (pApp->m_bBookMode)
	{
		if (pApp->m_bibleBooksFolderPath.IsEmpty())
		{
			// set safe defaults for when mode is off
			pApp->m_bBookMode = FALSE;
			pApp->m_nBookIndex = -1;
			pApp->m_nDefaultBookIndex = 39;
			pApp->m_nLastBookIndex = 39;
		}
	}

	int length = pApp->m_targetPhrase.Length();
	pApp->m_nStartChar = length;
	pApp->m_nEndChar = length;
	if (pApp->m_pTargetBox != NULL && pApp->m_pTargetBox->IsShown())
	{
		pApp->m_pTargetBox->SetSelection(length,length);
		pApp->m_pTargetBox->SetFocus();
	}
	// BEW added 05Jan07 to restore the former current working directory
	// to what it was on entry
	bOK = ::wxSetWorkingDirectory(strSaveCurrentDirectoryFullPath);
}

void CAdapt_ItView::DoRetranslationReport(CAdapt_ItApp* pApp, CAdapt_ItDoc* pDoc, 
									wxString& name, wxArrayString* pFileList, 
									SPList* pList, wxFile* pFile)
{
	if (pFileList->IsEmpty())
	{

		// use the open document's pList of srcPhrase pointers
		DoOneDocReport(name,pList,pFile); 
	}
	else
	{
		// no document is open, so pList will be empty, so we have
		// to iterate over files in pFileList
		wxASSERT(pList->IsEmpty());
		wxASSERT(!pFileList->IsEmpty());

		// iterate over the files (borrow code from DoConsistencyCheck)
		int nCount = pFileList->GetCount();
		if (nCount <= 0)
		{
			// something is real wrong, but this should never happen so
			// an English message will suffice
			wxString error;
			error = error.Format(_T(
			"Error, the file count was found to be %d, so the command was aborted.")
			,nCount);
			wxMessageBox(error);
			return;
		}

		// lock view window updates till done
		pApp->GetMainFrame()->canvas->Freeze();

		// iterate over the document files
		SPList* pPhrases;
		for (int i=0; i < nCount; i++)
		{
			wxString newName = pFileList->Item(i);
			wxASSERT(!newName.IsEmpty());

			// make a suitable name for the document, for the report
			wxString indexingName = newName;
			int len = indexingName.Length();
			indexingName.Remove(len-4,4); // remove the .adt or .xml extension

			// open the document
			bool bOK;
			bOK = pDoc->OnOpenDocument(newName);
			pDoc->SetFilename(newName,TRUE);

			int nTotal = pApp->m_pSourcePhrases->GetCount();
			if (nTotal == 0)
			{
				wxString str;
				str = str.Format(_T("Bad file:  %s"),newName.c_str());
				wxMessageBox(str,_T(""),wxICON_WARNING);
				wxExit(); //AfxAbort();
			}

			// get a local pointer to the list of source phrases
			pPhrases = pApp->m_pSourcePhrases;

			// use the now open document's pList of srcPhrase pointers, build
			// the part of the report which pertains to this document
			DoOneDocReport(indexingName,pPhrases,pFile); 

			// remove the document
			if (!pPhrases->IsEmpty())
			{
				ClobberDocument();

				// delete the buffer containing the filed-in source text
				if (pApp->m_pBuffer != NULL)
				{
					delete pApp->m_pBuffer;
					pApp->m_pBuffer = NULL;
				}
			}
		}

		// allow the view to respond again to updates
		pApp->GetMainFrame()->canvas->Thaw();
	}
}

void CAdapt_ItView::DoOneDocReport(wxString& name, SPList* pList, wxFile* pFile)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(!pList->IsEmpty());
	wxString oldText;
	oldText.Empty();
	wxString newText;
	newText.Empty();
	wxString endText = wxTextFile::GetEOL();
	wxString chAndVerse;
	chAndVerse.Empty();
	wxString indexText;
	indexText.Empty();
	wxString prevIndexText;
	prevIndexText.Empty();
	CSourcePhrase* pSrcPhrase = NULL;
	int count = 0;

	// initialize the progress indicator window
	int nTotal;
	nTotal = pList->GetCount();
	wxASSERT(nTotal > 0);

#ifdef __WXMSW__
	wxString progMsg = _("%s  - %d of %d Total words and phrases");
	wxString msgDisplayed = progMsg.Format(progMsg,name.c_str(),1,nTotal);
	wxProgressDialog progDlg(_("Retranslation Report"),
                    msgDisplayed,
                    nTotal,    // range
                    pApp->GetMainFrame(),   // parent
                    //wxPD_CAN_ABORT |
                    //wxPD_CAN_SKIP |
                    wxPD_APP_MODAL |
                    // wxPD_AUTO_HIDE | -- try this as well
                    wxPD_ELAPSED_TIME |
                    wxPD_ESTIMATED_TIME |
                    wxPD_REMAINING_TIME
                    | wxPD_SMOOTH // - makes indeterminate mode bar on WinXP very small
                    );
#else
	// wxProgressDialog tends to hang on wxGTK so I'll just use the simpler CWaitDlg
	// notification on wxGTK and wxMAC
	// put up a Wait dialog - otherwise nothing visible will happen until 
	// the operation is done
	CWaitDlg waitDlg(pApp->GetMainFrame());
	// indicate we want the reading file wait message
	waitDlg.m_nWaitMsgNum = 5;	// 5 hides the static leaving only 
								// "Please wait..." in title bar
	waitDlg.Centre();
	waitDlg.Show(TRUE);
	waitDlg.Update();
	// the wait dialog is automatically destroyed when it goes out of scope below.
#endif

	// compose the output data & write it out, phrase by phrase
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	bool bStartRetrans = TRUE;
	bool bJustEnded = FALSE;
	bool bStartOver = FALSE;
	int counter = 0; // for progress indicator
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase != 0);
		counter++;

		if (!pSrcPhrase->m_chapterVerse.IsEmpty())
		{
			prevIndexText = indexText; // keep old ch & verse, in case a retrans
									   // is at previous verse's end
			indexText = name + _T(" ") + pSrcPhrase->m_chapterVerse + endText;
		}

b:		bStartOver = FALSE;
		if (pSrcPhrase->m_bRetranslation)
		{
			if (bStartRetrans || pSrcPhrase->m_bBeginRetranslation)
			{
				if (oldText.IsEmpty())
				{
					// we've just written out an entry, so we are ready 
					// to begin a new one
					oldText = pSrcPhrase->m_srcPhrase;
					newText = pSrcPhrase->m_targetStr;
					bStartRetrans = FALSE;
					count++;
				}
				else
				{
                    // the current entry is not yet written out, (probably m_bBeginRe... is
                    // TRUE) because we are at start of a consecutive retranslation
					bJustEnded = TRUE;
					bStartOver = TRUE; // so we can start a new entry 
									   // without iterating the loop
					goto a;
				}
			}
			else
			{
				if (!pSrcPhrase->m_bNullSourcePhrase)
				{
					oldText += _T(" ") + pSrcPhrase->m_srcPhrase;
				}
				if (!pSrcPhrase->m_targetStr.IsEmpty())
				{
					newText += _T(" ") + pSrcPhrase->m_targetStr;
				}
			}
			bJustEnded = TRUE;

			// if we are at the end of the file, we have to force the
			// writing of the current one before we exit the loop
			if (counter == (int)pList->GetCount())
				goto a;
		}
		else
		{
			if (bJustEnded)
			{
a:				oldText += endText;
				newText += endText + endText; // we want a blank line

				// write out the entry to the file
				if (pSrcPhrase->m_chapterVerse.IsEmpty())
				{
					// within a verse, use current indexText
#ifndef _UNICODE
					pFile->Write(indexText);
#else
					pApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,indexText); // use UTF-8
#endif
				}
				else
				{
					// retranslation goes to end of last verse, use previous indexText
#ifndef _UNICODE
					pFile->Write(prevIndexText); 
#else
					pApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,prevIndexText); // use UTF-8
#endif
				}
#ifndef _UNICODE
				pFile->Write(oldText);

#else // _UNICODE version
				// use UTF-8 encoding
				pApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,oldText);
#endif
			}
			oldText.Empty();
			newText.Empty();
			bJustEnded = FALSE;
			bStartRetrans = TRUE; // get ready for start of next one encountered
		}

		// whm note: Yield operations tend to hang in wxGTK, so I'm going to just use the
		// wxBusyInfo message and not worry about the message being repainted if covered
		// and uncovered by another window.
#ifdef __WXMSW__
		// update the progress bar
		if (counter % 1000 == 0) 
		{
			msgDisplayed = progMsg.Format(progMsg,name.c_str(),counter,nTotal);
			progDlg.Update(counter,msgDisplayed);
		}
#endif

		if (bStartOver)
			goto b;
	}

	if (count == 0)
	{
		oldText.Empty();
		// IDS_NO_RETRANS_IN_DOC
		oldText = oldText.Format(_(
		"***  There were no retranslations in the %s document. ***"),
		name.c_str());
		oldText += endText + endText;
#ifndef _UNICODE
		pFile->Write(oldText); //pFile->WriteString(oldText);
#else
		pApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,oldText); // use UTF-8
#endif
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. This handler disables the "Retranslation Report..."
/// item in the Tools menu if Vertical Editing is in progress, or if the application is in
/// glossing mode, or if the regular KB is not in a ready state. Otherwise it enables the
/// "Retranslation Report..." item on the Tools menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateRetransReport(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT( pApp != NULL);

	if (!gbIsGlossing && pApp->m_bKBReady && pApp->m_pKB != NULL)
	{
		if (gbIsGlossing)
			event.Enable(FALSE); // disable if glossing is ON
		else
			event.Enable(TRUE); // enable, whether doc open or not; glossing OFF
	}
	else
	{
		event.Enable(FALSE); // disable if not got an open project
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Layout Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. This handler always enables the "Layout Window Right
/// To Left" (or "Layout Window Left To Right") item in the Layout menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAlignment(wxUpdateUIEvent& event)
{
	event.Enable(TRUE); // always enabled
}

void CAdapt_ItView::OnAlignment(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

	// don't permit a CTRL + 1 accidental keycombo press to flip the layout
	// if we are running the regular app
	if (sizeof(wxChar) == 1)
	{
		// we are running in the regular app, so bale out without doing anything
		return;
	}

	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pLayoutMenuAlignment = pMenuBar->FindItem(ID_ALIGNMENT);
	wxASSERT(pLayoutMenuAlignment != NULL);

	// toggle the setting & update the display accordingly
	wxString menuItem;
	if (pApp->m_bRTL_Layout)
	{
		// we have an RTL layout and user has just chosen LTR layout
		pApp->m_bRTL_Layout = FALSE; // toggle
		gbRTL_Layout = FALSE; // do the global too

		// change text of the menu item
		//IDS_RTL_LAYOUT
#ifdef __WXMAC__
		pLayoutMenuAlignment->SetText(_("Layout Window Right To Left\tCtrl-Shift-1"));
#else
		pLayoutMenuAlignment->SetText(_("Layout Window Right To Left\tCtrl-1"));
#endif
	}
	else
	{
		// we have an LTR layout and user has just chosen RTL layout
		pApp->m_bRTL_Layout = TRUE; // toggle
		gbRTL_Layout = TRUE; // do the global too

		// change text of the menu item
		//IDS_LTR_LAYOUT
#ifdef __WXMAC__
		pLayoutMenuAlignment->SetText(_("Layout Window Left To Right\tCtrl-Shift-1"));
#else
		pLayoutMenuAlignment->SetText(_("Layout Window Left To Right\tCtrl-1"));
#endif
	}
	Invalidate();
	GetLayout()->Redraw(); // yep, works nicely
	GetLayout()->PlaceBox();
}

// use this function when user changes, or potentially changes, the RTL checkboxes in
// either the wizard, or the preferences fonts page; if both source and target checkboxes
// are off then we silently ensure the layout is switched to LTR, and if both are on, then
// we silently ensure the layout will appear as RTL. The user can subsequently override the
// auto setting with the Layout menu if he chooses.
void CAdapt_ItView::AdjustAlignmentMenu(bool bRTL,bool bLTR)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxMenuItem * pLayoutMenuAlignment = pMenuBar->FindItem(ID_ALIGNMENT);
	wxASSERT(pLayoutMenuAlignment != NULL);

	// adjust the menu item to fit with the flag values
	wxString menuItem;
	if (bRTL == TRUE && bLTR == FALSE)
	{
		// we should have an RTL layout so set up accordingly
		pApp->m_bRTL_Layout = TRUE;
		gbRTL_Layout = TRUE; // do the global too

		// change text of the menu item ready for next time user accesses it
#ifdef __WXMAC__
		menuItem = _("Layout Window Left To Right\tCtrl-Shift-1"); //menuItem.Format(IDS_LTR_LAYOUT);
#else
		menuItem = _("Layout Window Left To Right\tCtrl-1"); //menuItem.Format(IDS_LTR_LAYOUT);
#endif
		pLayoutMenuAlignment->SetText(menuItem);
	}
	else
	{
		if (bRTL == FALSE && bLTR == TRUE)
		{
			// we should have an LTR layout so do it
			pApp->m_bRTL_Layout = FALSE;
			gbRTL_Layout = FALSE; // do the global too

			// change text of the menu item ready for next time user accesses it
#ifdef __WXMAC__
			menuItem = _("Layout Window Right To Left\tCtrl-Shift-1"); //IDS_RTL_LAYOUT
#else
			menuItem = _("Layout Window Right To Left\tCtrl-1"); //IDS_RTL_LAYOUT
#endif
			pLayoutMenuAlignment->SetText(menuItem);
		}
		else
		{
			// do nothing if we have a mixed reading direction situation
			;
		}
	}
}

bool CAdapt_ItView::IsUnstructuredData(SPList* pList)
{
	// the markers below can just have terminating space, because we call the
	// function on marker strings which have been normalized (ie. newlines
	// replaced by spaces)
	wxString s1 = gSFescapechar;
	wxString verseMkr = s1 + _T("v ");
	wxString verseNumberMkr = s1 + _T("vn ");
	wxString verseTextMkr = s1 + _T("vt ");
	wxString idMkr = s1 + _T("id ");
	wxString chapterMkr = s1 + _T("c ");

	if (pList->GetCount() == 0)
		return TRUE; // certainly data is unstructured, in fact it doesn't exist!
	SPList::Node* posx = pList->GetFirst();
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)posx->GetData();
	wxASSERT(pSrcPhrase);
	wxString markers = pSrcPhrase->m_markers;
	int nFound = -1;
	nFound = markers.Find(idMkr);
	if (nFound >= 0)
		return FALSE; // it's structured data because it has an \id line; 
            // that would only be there if the \v and other markers were too
            // - at least that's what we will assume
	SPList::Node* pos = pList->GetFirst(); 
	wxASSERT(pos);
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase);
		markers = pSrcPhrase->m_markers;
		if (!markers.IsEmpty())
		{
			nFound = -1;
			nFound = markers.Find(verseMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(verseNumberMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(verseTextMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(chapterMkr);
			if (nFound >= 0)
				return FALSE; // it's structured data

            // BEW added 10Apr06 to agree with similar changes in IsUnstructuredPlainText()
            // in the Adapt_ItDoc.cpp file (BEW 18April06, don't include \p here, since it
            // gets temporarily inserted into a non-SFM file, so detecting it would give
            // wrong result!)
			nFound = -1;
			nFound = markers.Find(s1 + _T("s "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("f "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q1 "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q2 "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("q3 "));
			if (nFound >= 0)
				return FALSE; // it's structured data
			nFound = -1;
			nFound = markers.Find(s1 + _T("x "));
			if (nFound >= 0)
				return FALSE; // it's structured data
		}
	}
	return TRUE; // it's unstructured data
}

void CAdapt_ItView::OnSize(wxSizeEvent& event)
{
 	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();

    // wx note: event.Skip() must be called here in order to pass the size event
    // on to be handled by the CMainFrame::OnSize() method.
	event.Skip();

    // BEW added 05Mar06: Bill Martin reported (email 3 March) that if user is in free
    // translation mode, and uses either the Shorten of Lengthen buttons (these set
    // gbSuppressSetup to TRUE in the beginning of their handlers, to suppress resetting up
    // of the section for the change in the layout), and then he resizes the window, the
    // app will crash (invalid pile pointer usually). The easiest solution is just to allow
    // the section to be reset - this loses the effect of the shortening or lengthening,
    // but that can easily be done again by hitting the relevant button(s) after the
    // resized layout is redrawn.
	if (pApp->m_bFreeTranslationMode)
	{
		gbSuppressSetup = FALSE;
	}

	// need to initiate a recalc of the layout with new m_docSize value, 
	// since strip-wrap is on
	CLayout* pLayout = GetLayout();

    // BEW added this test 6May09, because in the refactored design, an size event was
    // posted from (I think, somewhere in a CreatePiles() call within a RecalcLayout()
    // call, and the event was posted after the list of piles was deleted and before it
    // was recreated - and unfortunately in the legacy OnSize() function there was the
    // following RecalcLayout() call, which then crashes because the pile pointers
    // point at freed memory. The original call of RecalcLayout() was from within
    // OnInitialUpdate(), and that from end of OnNewDocument() and all this re-calling
    // of RecalcLayout() is bad design. Let's see if this safety first test gets us
    // past the crash, and maybe later we can tidy up the design to be less redundant
    // on the layout calls. *** TODO *** Appears to have worked!
	if (!pLayout->GetPileList()->IsEmpty())
	{
		// BEW added 1Aug09, to prevent a crash as follows. If a RecalcLayout() is done
		// with parameter keep_strips_keep_piles when there are piles in the m_pileList
		// but no strips in m_stripArray, then we'll get a (spectacular) crash. This
		// scenario can happen in the following scenario:
		// 1. Run the app, load a document, 
		// 2. do File command and chose a different document from the MRU list (same or 
		// different project doesn't matter). 
        // 3. All proceeds nicely, but during the view's OnInitialUpdate() call, a SetSize
        // is done on the canvas. 
        // 4. wxWidgets then posts a size event, and then 
        // 5. the view's OnSize() handler is called, and so 
        // 6. we get here with a populated pile list, but an empty (or destroyed - not sure 
		// which) strip list. So we'll get a crash now unless we do the RecalcLayout()
		// call which takes the parameter create_strips_keep_piles. Hence the following
		// test and the two RecalcLayout() blocks.
		if (pLayout->GetStripArray()->IsEmpty())
		{
			// we've come here probably from an MRU document opening, strips need building
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
		}
		else
		{
			// we've come here for some other reason, but not a window frame resize
			// because that will use CMainFrame::OnSize() which contains a call to
			// RecalcLayout() using the parameter create_strips_keep_piles; other situations
			// which result in this CAdapt_ItView::OnSize() being called will enter this
			// block and work acceptably without having to change the strip lengths and so 
			// keep_strips_keep_piles can be used here (I believe Bill has used the view's
			// OnSize() function to force a frame update in situations where no view
			// resizing is required  **TODO** remove those misused OnSize() calls someday)
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
		}
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		Invalidate();
		GetLayout()->PlaceBox();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Stop Selection At
/// Boundaries" toolbar item and returns immediately: The application is in Free
/// Translation mode, in glossing mode, is showing only the target language text, the
/// active pile is NULL, or there are no source phrases in the m_pSourcePhrases list.
/// Otherwise, it enables the toolbar button if the m_curIndex represents a valid location.
/// Note: The "Stop Selection At Boundaries" toolbar button is the opposite state toggle of
/// the "Ignore Boundaries" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonRespectBdry(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Ignore Boundaries"
/// toolbar item and returns immediately: The application is in Free Translation mode, in
/// glossing mode, is showing only the target language text, the active pile is NULL, or
/// there are no source phrases in the m_pSourcePhrases list. Otherwise, it enables the
/// toolbar button if the m_curIndex represents a valid location. Note: The "Ignore
/// Boundaries" toolbar button is the opposite state toggle of the "Stop Selection At
/// Boundaries" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonIgnoreBdry(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbIsGlossing || gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_RESPECTING_BDRY bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_RESPECTING_BDRY bitmap image (road with fence across it).
/// Note: The Button image depicts what the current state of boundary respecting/ignoring
/// is, but the tooltip and help text describe what clicking the button will accomplish. If
/// m_bRespectBoundaries is TRUE, this handler insures that the ID_BUTTON_IGNORING_BDRY
/// bitmap image is displayed in the Toolbar, and changes m_bRespectBoundaries to FALSE.
/// The "Ignoring Boundaries" button (witn ID_BUTTON_IGNORING_BDRY image having a road
/// ahead with no fence across it) is displayed on the toolBar after this handler finishes
/// because it shows the user what state the respect/ignore boundaries functionality would
/// be if the user were to press that toolbar button, i.e., the opposite of the current
/// state. Note: The "Respecting Boundaries" toolbar button (having a fence across the
/// road) is the opposite state toggle of the "Ignoring Boundaries" toolbar button . See
/// also OnButtonFromIgnoringBdryToRespectingBdry().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromRespectingBdryToIgnoringBdry(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnButtonRespectBdry() in the MFC version. Since it is a
    // toggle button which changes its appearance I've changed the name of the handler and
    // its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_IGNORING_BDRY); // toolPos should be 18
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_RESPECTING_BDRY);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (pApp->m_bRespectBoundaries)
	{
        // The app is currently respecting boundaries. The user wants to switch from
        // respecting to ignoring them. This is effected by setting m_bRespectBoundaries to
        // FALSE.
		pApp->m_bRespectBoundaries = FALSE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the respecting image to the ignoring image. We do
        // this by inserting the ID_BUTTON_IGNORING_BDRY button into position on the
        // toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_IGNORING_BDRY, _T(""),
					AIToolBarBitmapsToggled32x30Func( 0 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Stop Selection At Boundaries"),
					_("Respect boundaries when selecting"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_IGNORING_BDRY, _T(""),
					AIToolBarBitmapsToggledFunc( 0 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Stop Selection At Boundaries"),
					_("Respect boundaries when selecting"));
			}
            // whm Note: Now, the ignoring bdry button is showing on the toolbar. Remember:
            // The tooltip and help text tell what clicking on this hiding button would do,
            // i.e., Respect Boundaries. must call Realize() after adding a new button
			pToolBar->Realize();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_IGNORING_BDRY bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_IGNORING_BDRY bitmap image (road with no fence across
/// it). Note: The Button image depicts what the current state of boundary
/// respecting/ignoring is, but the tooltip and help text describe what clicking the button
/// will accomplish. If m_bRespectBoundaries is FALSE, this handler insures that the
/// ID_BUTTON_RESPECTING_BDRY bitmap image is displayed in the Toolbar, and changes
/// m_bRespectBoundaries to TRUE. The "Respecting Boundaries" button (witn
/// ID_BUTTON_RESPECTING_BDRY image having a fence across the road) is displayed on the
/// toolBar after this handler finishes because it shows the user what state the
/// respect/ignore boundaries functionality would be if the user were to press that toolbar
/// button, i.e., the opposite of the current state. Note: The "Ignoring Boundaries"
/// toolbar button (road ahead with no fence across it) is the opposite state toggle of the
/// "Respecting Boundaries" toolbar button . See also
/// OnButtonFromRespectingBdryToIgnoringBdry().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromIgnoringBdryToRespectingBdry(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnButtonIgnoreBdry() in the MFC version. Since it is a
    // toggle button which changes its appearance I've changed the name of the handler and
    // its ID symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// user or the app wants to restore respect for boundarires, fix accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_IGNORING_BDRY); // toolPos should be 18
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_RESPECTING_BDRY);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (!pApp->m_bRespectBoundaries)
	{
		// The app is currently ingoring boundaries. The user wants to switch from ignoring
		// to respecting them. This is effected by setting m_bRespectBoundaries to TRUE. 
		pApp->m_bRespectBoundaries = TRUE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the ignoring image to the respecting image. We do
        // this by inserting the ID_BUTTON_RESPECTING_BDRY button into position on the
        // toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if(tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_RESPECTING_BDRY, _T(""),
					AIToolBarBitmapsUnToggled32x30Func( 9 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Ignore Boundaries"),
					_("Ignore boundaries when making selections"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_RESPECTING_BDRY, _T(""),
					AIToolBarBitmapsUnToggledFunc( 9 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Ignore Boundaries"),
					_("Ignore boundaries when making selections"));
			}
            // whm Note: Now, the respecting bdry button is showing on the toolbar.
            // Remember: The tooltip and help text tell what clicking on this hiding button
            // would do, i.e., Ignore Boundaries. must call Realize() after adding a new
            // button
			pToolBar->Realize();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Show Punctuation"
/// toolbar item and returns immediately: The application is in Free Translation mode, in
/// glossing mode, the active pile is NULL, or there are no source phrases in the
/// m_pSourcePhrases list. Otherwise, it enables the toolbar button if the m_curIndex
/// represents a valid location. Note: The "Show Punctuation" toolbar button is the
/// opposite state toggle of the "Hide Punctuation" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonShowPunct(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
    if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
		pApp->m_nActiveSequNum >= 0)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_SHOWING_PUNCT bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_SHOWING_PUNCT bitmap image. Note: The Button image
/// depicts what the current state of punctuation showing/hiding is, but the tooltip and
/// help text describe what clicking the button will accomplish. If m_bHidePunctuation is
/// FALSE, this handler insures that the ID_BUTTON_HIDING_PUNCT bitmap image is displayed
/// in the Toolbar, and changes m_bHidePunctuation to TRUE. The "Hiding Punctuation" button
/// (witn ID_BUTTON_HIDING_PUNCT image having curtains closed on stage) is displayed on the
/// toolBar after this handler finishes because it shows the user what state the show/hide
/// punctuation functionality would be if the user were to press that toolbar button, i.e.,
/// the opposite of the current state. Note: The "Showing Punctuation" toolbar button
/// (curtains drawn back revealing an exclamation point) is the opposite state toggle of
/// the "Hiding Punctuation" toolbar button . See also OnButtonFromHidingToShowingPunct().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromShowingToHidingPunct(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnButtonShowPunct() in the MFC version. Since it is a toggle
    // button which changes its appearance I've changed the name of the handler and its ID
    // symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_HIDING_PUNCT); // toolPos should be 19
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_SHOWING_PUNCT); // toolPos should be 19
	wxASSERT(toolPos != wxNOT_FOUND);
	if (!pApp->m_bHidePunctuation)
	{
        // The app is currently showing (not hiding) punctuation. The user wants to switch
        // from showing to hiding. This is effected by setting m_bHidePunctuation to TRUE.
		pApp->m_bHidePunctuation = TRUE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the showing image to the hiding image. We do this
        // by inserting the ID_BUTTON_HIDING_PUNCT button into position on the toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_HIDING_PUNCT, _T(""),
					AIToolBarBitmapsToggled32x30Func( 1 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show Punctuation"),
					_("Show text with punctuation"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_HIDING_PUNCT, _T(""),
					AIToolBarBitmapsToggledFunc( 1 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show Punctuation"),
					_("Show text with punctuation"));
			}
            // whm Note: Now, the hiding punct button is showing on the toolbar. Remember:
            // The tooltip and help text tell what clicking on this hiding button would do,
            // i.e., Show Punctuation. must call Realize() after adding a new button
			pToolBar->Realize();

			if (pApp->m_nActiveSequNum != -1)
			{
				CPile* pPile = GetPile(pApp->m_nActiveSequNum);
				wxASSERT(pPile);
				CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();

				// reset the pApp->m_targetPhrase to hold the source phrase's other member
				pApp->m_targetPhrase = pSrcPhrase->m_adaption;
			}
			CLayout* pLayout = GetLayout();
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			Invalidate();
			GetLayout()->PlaceBox();
		}
	}
	else
	{
		// oops, the boolean was out of sync with the state shown by the view's icon, so
		// have this else block to fix the value; next click of the same button will then work
		// right - but we need to do a Redraw() here, to get punctuation shown - in
		// agreement with this fix of the flag value
		pApp->m_bHidePunctuation = FALSE;

		CLayout* pLayout = GetLayout();
		pLayout->Redraw();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Enable Punctuation
/// Copy" toolbar item (black punctuation characters on a green background) and returns
/// immediately: The application is in Free Translation mode, in glossing mode, the active
/// pile is NULL, or there are no source phrases in the m_pSourcePhrases list. Otherwise,
/// it enables the toolbar button if the m_curIndex represents a valid location. Note: The
/// "Enable Punctuation Copy" toolbar button is the opposite state toggle of the "No
/// Punctuation Copy" toolbar button (black punctuation with yellow background and a red
/// circle and red diagonal bar).
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonEnablePunctCopy(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
 	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
   if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_ENABLE_PUNCT_COPY bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_ENABLE_PUNCT_COPY bitmap image. The
/// OnButtonEnablePunctCopy() handler is also called directly from the View's
/// OnInitialUpdate(), OnButtonToEnd(), OnButtonToStart(), OnButtonStepDown(),
/// OnButtonStepUp(), JumpForwardToNote_CoreCode(), JumpBackwardToNote_CoreCode(), and from
/// CPhraseBox's MoveToNextPile(), MoveToPrevPile(), MoveToImmedNextPile().
/// If m_bCopySourcePunctuation is FALSE, this handler insures that the
/// ID_BUTTON_NO_PUNCT_COPY bitmap image is displayed in the Toolbar, and changes
/// m_bCopySourcePunctuation to TRUE. The "No Punctuation Copy" button (witn
/// ID_BUTTON_NO_PUNCT_COPY image having black punctuation with yellow background and a red
/// circle and red diagonal bar) is displayed on the toolBar after this handler finishes
/// because it shows the user what state the punctuation copy functionality would be if the
/// user were to press that toolbar button, i.e., the opposite of the current state. Note:
/// The "Enable Punctuation Copy" toolbar button is the opposite state toggle of the "No
/// Punctuation Copy" toolbar button (black punctuation with yellow background and a red
/// circle and red diagonal bar). See also OnButtonNoPunctCopy().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonEnablePunctCopy(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
    // whm Note: The MFC version starts with both toggle state images in the toolbar images
    // and simply hides one and shows the other as appropriate. The wxToolBar class does
    // not have a HideButton() method, so we Delete the unwanted image from the toolBar,
    // and Insert the image we want into the toolBar. The MFC version also used this
    // OnButtonEnablePunctCopy() handler to set the initial state of the punctuation copy
    // function to TRUE in OnInitialUpdate() and other places, so to be safe we will get
    // the toolPos from either the ID_BUTTON_NO_PUNCT_COPY image or the
    // ID_BUTTON_ENABLE_PUNCT_COPY image, delete whatever image was there, but then
    // unilaterally we insert the ID_BUTTON_NO_PUNCT_COPY into the position of the deleted
    // image. The image names reflect the toggle state that would ensue if the button were
    // pressed, rather than the present state as indicated by the value of
    // m_bCopySourcePunctuation as set at the end of this handler.
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_NO_PUNCT_COPY); // toolPos should be 40
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_ENABLE_PUNCT_COPY);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (!pApp->m_bCopySourcePunctuation)
	{
		// In WX we delete the unwanted button and insert the wanted button to create 
		// the toggle effect
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_NO_PUNCT_COPY, _T(""),
					AIToolBarBitmapsUnToggled32x30Func( 27 ), wxNullBitmap,
					wxITEM_CHECK,
					_("No Punctuation Copy"),
					_("Suppress the copying of source text punctuation temporarily"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_NO_PUNCT_COPY, _T(""),
					AIToolBarBitmapsUnToggledFunc( 27 ), wxNullBitmap,
					wxITEM_CHECK,
					_("No Punctuation Copy"),
					_("Suppress the copying of source text punctuation temporarily"));
			}
			// must call Realize() after adding a new button
			pToolBar->Realize();
		}
		// toggle the setting
		pApp->m_bCopySourcePunctuation = TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "No Punctuation Copy"
/// toolbar item (black punctuation with yellow background and a red circle and red
/// diagonal bar) and returns immediately: The application is in Free Translation mode, in
/// glossing mode, the active pile is NULL, or there are no source phrases in the
/// m_pSourcePhrases list. Otherwise, it enables the toolbar button if the m_curIndex
/// represents a valid location. Note: The "No Punctuation Copy" toolbar button is the
/// opposite state toggle of the "Enable Punctuation Copy" toolbar button (black
/// punctuation characters on a green background).
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonNoPunctCopy(wxUpdateUIEvent& event)
{
 	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
   if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_NO_PUNCT_COP bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_NO_PUNCT_COPY bitmap image. If m_bCopySourcePunctuation
/// is TRUE, this handler insures that the ID_BUTTON_ENABLE_PUNCT_COPY bitmap image is
/// displayed in the Toolbar, and changes m_bCopySourcePunctuation to FALSE. The "Enable
/// Punctuation Copy" button (witn ID_BUTTON_ENABLE_PUNCT_COPY image having black
/// punctuation with green background) is displayed on the toolBar after this handler
/// finishes because it shows the user what state the punctuation copy functionality would
/// be if the user were to press that toolbar button, i.e., the opposite of the current
/// state. Note: The "No Punctuation Copy" toolbar button (black punctuation with yellow
/// background and a red circle and red diagonal bar) is the opposite state toggle of the
/// "Enable Punctuation Copy" toolbar button . See also OnUpdateButtonEnablePunctCopy().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonNoPunctCopy(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame); 
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_NO_PUNCT_COPY); // toolPos should be 40
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_ENABLE_PUNCT_COPY);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (pApp->m_bCopySourcePunctuation)
	{
		// In WX we delete the unwanted button and insert the wanted button to 
		// create the toggle effect
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_ENABLE_PUNCT_COPY, _T(""),
					AIToolBarBitmapsToggled32x30Func( 3 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Enable Punctuation Copy"),
					_("Re-enable automatic copying of source text punctuation"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_ENABLE_PUNCT_COPY, _T(""),
					AIToolBarBitmapsToggledFunc( 3 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Enable Punctuation Copy"),
					_("Re-enable automatic copying of source text punctuation"));
			}
			// must call Realize() after adding a new button
			pToolBar->Realize();
		}
		// toggle the setting
		pApp->m_bCopySourcePunctuation = FALSE;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Hide Punctuation"
/// toolbar item and returns immediately: The application is in Free Translation mode, in
/// glossing mode, the active pile is NULL, or there are no source phrases in the
/// m_pSourcePhrases list. Otherwise, it enables the toolbar button if the m_curIndex
/// represents a valid location. Note: The "Hide Punctuation" toolbar button is the
/// opposite state toggle of the "Show Punctuation" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonHidePunct(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
  	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
   if (gbIsGlossing)
    {
            event.Enable(FALSE);
            return;
    }
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the
///                         ID_BUTTON_HIDING_PUNCT bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_BUTTON_HIDING_PUNCT bitmap image (image with curtains closed).
/// Note: The Button image depicts what the current state of punctuation showing/hiding is,
/// but the tooltip and help text describe what clicking the button will accomplish. If
/// m_bHidePunctuation is TRUE, this handler insures that the ID_BUTTON_SHOWING_PUNCT
/// bitmap image is displayed in the Toolbar, and changes m_bHidePunctuation to FALSE. The
/// "Showing Punctuation" button (witn ID_BUTTON_SHOWING_PUNCT image having curtains drawn
/// back revealing an exclamation point) is displayed on the toolBar after this handler
/// finishes because it shows the user what state the show/hide punctuation functionality
/// would be if the user were to press that toolbar button, i.e., the opposite of the
/// current state. Note: The "Hiding Punctuation" toolbar button (curtains closed on stage)
/// is the opposite state toggle of the "Showing Punctuation" toolbar button . See also
/// OnButtonFromShowingToHidingPunct().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnButtonFromHidingToShowingPunct(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnButtonHidePunct() in the MFC version. Since it is a toggle
    // button which changes its appearance I've changed the name of the handler and its ID
    // symbol names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_BUTTON_HIDING_PUNCT); // toolPos should be 19
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_BUTTON_SHOWING_PUNCT);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (pApp->m_bHidePunctuation)
	{
        // The app is currently hiding punctuation. The user wants to switch from hiding
        // to showing. This is effected by setting m_bHidePunctuation to FALSE.
		pApp->m_bHidePunctuation = FALSE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the hiding image to the showing image. We do this
        // by inserting the ID_BUTTON_SHOWING_PUNCT button into position on the toolbar.
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_SHOWING_PUNCT, _T(""),
					AIToolBarBitmapsUnToggled32x30Func( 10 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Hide Punctuation"),
					_("Don't show punctuation with the text"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_BUTTON_SHOWING_PUNCT, _T(""),
					AIToolBarBitmapsUnToggledFunc( 10 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Hide Punctuation"),
					_("Don't show punctuation with the text"));
			}
            // whm Note: Now, the showing punct button is showing on the toolbar. Remember:
            // The tooltip and help text tell what clicking on this hiding button would do,
            // i.e., Hide Punctuation. must call Realize() after adding a new button
			pToolBar->Realize();
			CLayout* pLayout = GetLayout();
			if (pApp->m_nActiveSequNum != -1 && !pLayout->GetPileList()->IsEmpty())
			{
				CPile* pPile = GetPile(pApp->m_nActiveSequNum);
				wxASSERT(pPile);
				CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();

				// reset the pApp->m_targetPhrase to hold the source phrase's other member
				pApp->m_targetPhrase = pSrcPhrase->m_targetStr;
			}
			if (pApp->m_pSourcePhrases != NULL)
			{
				if (!pApp->m_pSourcePhrases->IsEmpty())
				{
#ifdef _NEW_LAYOUT
					pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
					pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
					pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
					Invalidate();
					GetLayout()->PlaceBox();
				}
			}
		}
	}
	else
	{
		// oops, the boolean was out of sync with the state shown by the view's icon, so
		// have this else block to fix the value; next click of the same button will then work
		// right - but we need to do a Redraw() here, to get punctuation hidden - in
		// agreement with this fix of the flag value
		pApp->m_bHidePunctuation = TRUE;

		CLayout* pLayout = GetLayout();
		pLayout->Redraw();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE, this handler disables the "Show Target Text Only"
/// toolbar item and returns immediately: Vertical Editing is in progress, the active pile
/// is NULL, or there are no source phrases in the m_pSourcePhrases list. Otherwise, it
/// enables the toolbar button if m_endIndex is within a valid range. Note: The "Show
/// Target Text Only" toolbar button is the opposite state toggle of the "Show Source And
/// Target Text" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateShowTgt(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_SHOWING_ALL
///                        bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_SHOWING_ALL bitmap image. Note: The Button image depicts what
/// the current state of showing-all/showing-target-only is, but the tooltip and help text
/// describe what clicking the button will accomplish. If gbShowTargetOnly is FALSE, this
/// handler insures that the ID_SHOWING_TGT bitmap image is displayed in the Toolbar, and
/// changes gbShowTargetOnly to TRUE. The "Showing Source And Target Text" button (witn
/// ID_SHOWING_ALL image having pairs of lines representing strips of source and target
/// together) is displayed on the toolBar after this handler finishes because it shows the
/// user what state the target text only functionality would be if the user were to press
/// that toolbar button, i.e., the opposite of the current state. Note: The "Show Source
/// And Target Text" toolbar button is the opposite state toggle of the "Show Target Text
/// Only" toolbar button. See also OnFromShowingAllToShowingTargetOnly().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnFromShowingAllToShowingTargetOnly(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnShowTgt() in the MFC version. Since it is a toggle button
    // which changes its appearance I've changed the name of the handler and its ID symbol
    // names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar();
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_SHOWING_TGT); // toolPos should be 38
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_SHOWING_ALL);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (!gbShowTargetOnly)
	{
		// The app is currently showing all. The user wants to switch from showing all
		// to showing only TGT text. This is effected by setting gbShowTargetOnly to TRUE. 
		
		// must remove any selection first
		RemoveSelection();

		// user wants to show only the target lines, so fix accordingly
		gbShowTargetOnly = TRUE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the showing all image to the showing only target
        // text image. We do this by inserting the ID_SHOWING_TGT button into position on
        // the toolbar.
		gnSaveLeading = pApp->m_curLeading;
		gnSaveGap = pApp->m_curGapWidth;
		pApp->m_curLeading = pApp->m_nTgtHeight / 4;
		int newGapWidth = pApp->m_curGapWidth / 3;
		pApp->m_curGapWidth = wxMax(newGapWidth,10);
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if (tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_SHOWING_TGT, _T(""),
					AIToolBarBitmapsToggled32x30Func( 2 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show normal view"),
					_("Show Source And Target Text"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_SHOWING_TGT, _T(""),
					AIToolBarBitmapsToggledFunc( 2 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show normal view"),
					_("Show Source And Target Text"));
			}
            // whm Note: Now, the showing tgt only button is showing on the toolbar.
            // Remember: The tooltip and help text tell what clicking on this hiding button
            // would do, i.e., Show Source and Target Text. Must call Realize() after
            // adding a new button
			pToolBar->Realize();
			CLayout* pLayout = GetLayout();
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			Invalidate();
			GetLayout()->PlaceBox();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled.
/// If any of the following conditions are TRUE, this handler disables the "Show Source And
/// Target Text" toolbar item (pairs of lines representing strips) and returns immediately:
/// Vertical Editing is in progress, the active pile is NULL, or there are no source
/// phrases in the m_pSourcePhrases list. Otherwise, it enables the toolbar button if
/// m_endIndex is within a valid range.
/// Note: The "Show Source And Target Text" toolbar button is the opposite state toggle of
/// the "Show Target Text Only" toolbar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateShowAll(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
		pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxCommandEvent that is associated with the ID_SHOWING_TGT
///                        bitmap image on the toolBar
/// \remarks
/// Called from: The wxCommandEvent mechanism when the user clicks on the toolBar button
/// associated with the ID_SHOWING_TGT bitmap image. The
/// OnFromShowingTargetOnlyToShowingAll() handler is also called directly from the View's
/// OnInitialUpdate(), OnFind(), and OnReplace(). Note: The Button image depicts what the
/// current state of showing-all/showing-target-only is, but the tooltip and help text
/// describe what clicking the button will accomplish. If gbShowTargetOnly is TRUE, this
/// handler insures that the ID_SHOWING_ALL bitmap image is displayed in the Toolbar, and
/// changes gbShowTargetOnly to FALSE. The "Showing ALL" button (witn ID_SHOWING_ALL image
/// having pairs of lines representing strips of source and target together) is displayed
/// on the toolBar after this handler finishes because it shows the user what state the
/// showing-all/showing-target-text-only functionality would be if the user were to press
/// that toolbar button, i.e., the opposite of the current state. Note: The "Showing Target
/// Text Only" toolbar button is the opposite state toggle of the "Showing All" toolbar
/// button. See also OnFromShowingAllToShowingTargetOnly().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnFromShowingTargetOnlyToShowingAll(wxCommandEvent& WXUNUSED(event))
{
    // This handler was called OnShowAll() in the MFC version. Since it is a toggle button
    // which changes its appearance I've changed the name of the handler and its ID symbol
    // names.
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxToolBarBase* pToolBar = pFrame->GetToolBar(); 
	wxASSERT(pToolBar != NULL);

	// toggle the setting and adjust the button image accordingly
	int toolPos;
	toolPos = pToolBar->GetToolPos(ID_SHOWING_TGT); // toolPos should be 38
	if (toolPos == wxNOT_FOUND)
		toolPos = pToolBar->GetToolPos(ID_SHOWING_ALL);
	wxASSERT(toolPos != wxNOT_FOUND);
	if (gbShowTargetOnly)
	{
        // The app is currently showing only target lines. The user wants to switch from
        // showing only the target text to showing all. This is effected by setting
        // gbShowTargetOnly to FALSE.
		gbShowTargetOnly = FALSE;
        // Now we must change the appearance of the toggle button in the toolbar so that
        // its appearance switches from the showing target only image to the showing all
        // image. We do this by inserting the ID_SHOWING_ALL button into position on the
        // toolbar.
		pApp->m_curLeading = gnSaveLeading;
		pApp->m_curGapWidth = gnSaveGap;
		gnSaveLeading = 4;
		gnSaveGap = 8;
		bool tbDeleted = FALSE;
		tbDeleted = pToolBar->DeleteToolByPos(toolPos);
		if(tbDeleted)
		{
            // Note: In InsertTool, 1st parameter is position of button, zero based, count
            // includes spacers In AIToolBarBitmapsUnToggledFunc parameter is index of
            // bitmap, zero based (no spacers in count)
			if (pApp->m_bExecutingOnXO) //if (pFrame->m_bUsingHighResDPIScreen)
			{
				pToolBar->InsertTool(toolPos, ID_SHOWING_ALL, _T(""),
					AIToolBarBitmapsUnToggled32x30Func( 24 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show Target Text Only"),
					_("Show target text only"));
			}
			else
			{
				pToolBar->InsertTool(toolPos, ID_SHOWING_ALL, _T(""),
					AIToolBarBitmapsUnToggledFunc( 24 ), wxNullBitmap,
					wxITEM_CHECK,
					_("Show Target Text Only"),
					_("Show target text only"));
			}
            // whm Note: Now, the showing all button is showing on the toolbar. Remember:
            // The tooltip and help text tell what clicking on this hiding button would do,
            // i.e., Show Target Text Only. Must call Realize() after adding a new button
			pToolBar->Realize();
			CLayout* pLayout = GetLayout();
			if (pApp->m_pSourcePhrases != NULL)
			{
				if (!pApp->m_pSourcePhrases->IsEmpty())
				{
#ifdef _NEW_LAYOUT
					pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
					pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
					pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
					Invalidate();
					GetLayout()->PlaceBox();
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the View Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the KB is in a ready state the "Wrap At Standard
/// Format Markers" item on the View menu is enabled, otherwise the menu item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateMarkerWrapsStrip(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT( pApp != NULL);

	// testing one kb is enough
	if (pApp->m_bKBReady && pApp->m_pKB != NULL)
	{
		event.Enable(TRUE); // enable, whether doc open or not
	}
	else
	{
		event.Enable(FALSE); // disable if not got an open project
	}
}

void CAdapt_ItView::OnMarkerWrapsStrip(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pViewMarkerWrapsStrip = pMenuBar->FindItem(ID_MARKER_WRAPS_STRIP);
	wxASSERT(pViewMarkerWrapsStrip != NULL);

	// toggle the setting & update the display accordingly
	if (pApp->m_bMarkerWrapsStrip)
	{
		// toggle the checkmark to OFF & recalc the layout with wrap caused by 
		// markers turned off
		pViewMarkerWrapsStrip->Check(FALSE);
		pApp->m_bMarkerWrapsStrip = FALSE;
	}
	else
	{
		// toggle the checkmark to ON, and recalc the layout with wrap caused by 
		// markers turned on
		pViewMarkerWrapsStrip->Check(TRUE);
		pApp->m_bMarkerWrapsStrip = TRUE;
	}

	// redraw everything -- CreateStrip() in RecalcLayout uses the
	// m_bMarkerWrapsStrip flag to do the wanted wraps
	CLayout* pLayout = GetLayout();
	if (pApp->m_pSourcePhrases != NULL)
	{
		if (!pApp->m_pSourcePhrases->IsEmpty())
		{
#ifdef _NEW_LAYOUT
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			Invalidate();
			GetLayout()->PlaceBox();
		}
	}
}

void CAdapt_ItView::ReDoMerge(int nSequNum,SPList* pNewList,SPList::Node* posNext,
							  CSourcePhrase* pFirstSrcPhrase, int nCount)
{
	SPList::Node* pos = posNext; // since posNext comes from the caller,
								 // it is already the 'next' position
	// starting from the next minimal srcPhrase, Merge each succeeding one to
	// pFirstSrcPhrase 
	for (int i = 1; i < nCount; i++)
	{
		CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pSrcPhrase);
		// no phrases allowed
		wxASSERT(pSrcPhrase->m_nSrcWords == 1 || pSrcPhrase->m_nSrcWords == 0);

		pFirstSrcPhrase->Merge(this,pSrcPhrase);
	}

	// count how many have to be removed from the m_pSourcePhrases list on the app
	int nRemoveCount = nCount - 1; // that is, all but the first

	// remove from the list the ones which have been merged to the first
	pos = pNewList->Item(nSequNum + 1); // position of first to be removed
	SPList::Node* savePos;
	wxASSERT(pos != NULL);
	int j = 0;
	while (pos != NULL && j < nRemoveCount)
	{
		savePos = pos;
		CSourcePhrase* pSrcPhrase;
		pSrcPhrase = (CSourcePhrase*)pos->GetData(); // not really used
		pos = pos->GetNext();
		pNewList->DeleteNode(savePos); // remove pointer, but leave srcPhrase
		j++;						   // on the heap, because it is pointed at 
									   // from within pFirstSrcPhrase now
	}

	// update the sequence numbers which follow the first src phrase
	UpdateSequNumbers(nSequNum);

	// set up the m_inform attribute, if there are medial markers
	if (pFirstSrcPhrase->m_bHasInternalMarkers)
	{
		wxString s = _(" Medial markers: ");
		if (!pFirstSrcPhrase->m_pMedialMarkers->IsEmpty())
		{
			// We'll iterate through the array with a for loop
			for (int i = 0; i < (int)pFirstSrcPhrase->m_pMedialMarkers->GetCount(); i++)
			{
				s += pFirstSrcPhrase->m_pMedialMarkers->Item(i);
			}
			pFirstSrcPhrase->m_inform += s;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the appropriate KB is not in a ready state this
/// handler disables the "Export Knowledge Base..." item in the File menu, otherwise it
/// enables the "Export Knowledge Base..." item on the File menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExportKb(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if ((!gbIsGlossing && pApp->m_pKB != NULL) || 
		(gbIsGlossing && pApp->m_pGlossingKB != NULL))
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnFileExportKb(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);
	CAdapt_ItDoc* pDoc;
	CPhraseBox* pBox;
	CAdapt_ItView* pView;
	pApp->GetBasePointers(pDoc,pView,pBox); // this is 'safe' when no doc is open

	// get a pointer to either the glossing KB or the adaptation one
	CKB* pKB;
	if (gbIsGlossing)
		pKB = pApp->m_pGlossingKB;
	else
		pKB = pApp->m_pKB;
	wxASSERT(pKB != NULL);

    // get an output filename and put up file dialog make the working directory the
    // "<Project Name>" one if no previous export path was defined, else make it the stored
    // last export path for the kb
	bool bOK = TRUE;
	if (pApp->m_kbExportPath.IsEmpty())
		bOK = ::wxSetWorkingDirectory(pApp->m_curProjectPath);
	else
		bOK = ::wxSetWorkingDirectory(pApp->m_kbExportPath);

	// the above may have failed, so if so use m_curProjectPath as the folder
	// so we can proceed to the file dialog safely
	if (!bOK)
	{
		pApp->m_kbExportPath = pApp->m_curProjectPath;
		bOK = ::wxSetWorkingDirectory(pApp->m_kbExportPath); // this should work, since
												// m_curProjectPath can hardly be wrong!
		if (!bOK)
		{
			bOK = ::wxSetWorkingDirectory(pApp->m_kbExportPath = _T("C:"));
			if (!bOK)
			{
				// we should never get a failure for the above, 
				// so just an English message will do
				wxMessageBox(_T(
				"OnFileExportKb() failed, the export has been aborted"),
				_T(""),wxICON_WARNING);
				return;
			}
		}
	}

	wxString dicFilename;
	dicFilename = pApp->m_curProjectName;
	dicFilename = MakeReverse(dicFilename);
	int offset = dicFilename.Find(_T(" "));
	dicFilename = dicFilename.Mid(offset); // remove "Adaptations" or Tok Pisin equivalent
	dicFilename = MakeReverse(dicFilename);
	wxString glossStr;
	if (gbIsGlossing)
	{
		//IDS_GLOSSING
		glossStr = _("Glossing");
		glossStr += _T(" ");
		dicFilename += glossStr; // ensure the glossing KB export has its own filename
	}
	wxString str;
	// IDS_DIC_REC_TXT
	str = str.Format(_("dictionary records.txt"));
	dicFilename += str;

	wxString defaultDir;
	if (pApp->m_kbExportPath.IsEmpty())
	{
		defaultDir = pApp->m_curProjectPath;
	}
	else
	{
		defaultDir = pApp->m_kbExportPath;
	}

	// get a file dialog
	wxString filter;
	//MFC app IDS_KB_EXPORT_FILTER
	filter = _("Adapt It knowledge base export (*.txt)|*.txt|All Files (*.*)|*.*||"); 
	wxFileDialog fileDlg(
		(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
		_("Filename For KB Export"),
		defaultDir,	// empty string causes it to use the current working directory (set above)
		dicFilename,	// default filename
		filter,
		wxFD_SAVE | wxFD_OVERWRITE_PROMPT); 
		// | wxHIDE_READONLY); wxHIDE_READONLY deprecated in 2.6 - the checkbox is never shown
		// GDLC wxSAVE & wxOVERWRITE_PROMPT deprecated in 2.8
	fileDlg.Centre();

	// make the dialog visible
	if (fileDlg.ShowModal() != wxID_OK)
		return; // user cancelled

	// update m_kbExportPath
	wxString exportPath = fileDlg.GetPath();
	wxString name = fileDlg.GetFilename();
	int nameLen = name.Length();
	int pathLen = exportPath.Length();
	wxASSERT(nameLen > 0 && pathLen > 0);
	pApp->m_kbExportPath = exportPath.Left(pathLen - nameLen - 1);

	// get the user's desired path
	wxString dicPath = fileDlg.GetPath(); 

	wxFile f; //CStdioFile f;
	if( !f.Open( dicPath, wxFile::write))
	{
	   #ifdef __WXDEBUG__
		  wxLogError(_("Unable to open knowledge base export file.\n"));
		  wxMessageBox(_("Unable to open knowledge base export file."),
		  _T(""), wxICON_WARNING);
	   #endif
	   return; // return since it is not a fatal error
	}

	DoKBExport(pKB,&f);

	// close the file
	f.Close();
}


// BEW modified 1Sep09 to remove a logic error, & to remove a goto command, and get rid 
// of a bDelayed boolean flag & simplify the logic
void CAdapt_ItView::DoKBExport(CKB* pKB, wxFile* pFile)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pKB != NULL);
	wxASSERT(pFile != NULL);
	wxString s1 = gSFescapechar;
	wxString lexSFM = s1 + _T("lx ");
	wxString geSFM = s1 + _T("ge ");
	wxString key;
	key.Empty();
	wxString gloss;
	wxString baseKey;
	wxString outputStr; // accumulate a whole "record" here, but abandon if it contains
						// a <Not In KB> string, we don't export those
	wxString strNotInKB = _T("<Not In KB>");
	gloss.Empty(); // this name used for the "adaptation" when adapting,
				   // or the "gloss" when glossing

    // MFC's WriteString() function automatically converts any \n embedded within the
    // buffer to the \r\n pair on output. The wxWidgets wxFile::Write() function, however,
    // does not do this so we need to here create the proper EOL sequences in the buffer.
    // The wxWidgets' wxTextFile::GetEOL() static function returns the appropriate
    // end-of-line sequence for the current platform. It would be hex sequence pair 0d 0a
    // for Windows, the single hex char 0a for Unix/Linux, and the single hex char 0d for
    // Macintosh. The GetEOL function provides the correct line termination character(s).
    // wxString eolStr = wxTextFile::GetEOL(); done in the App's OnInit()
	wxASSERT(pApp->m_eolStr.Find(_T('\n')) != -1 || pApp->m_eolStr.Find(_T('\r')) != -1);

	int numWords;
	MapKeyStringToTgtUnit::iterator iter;
	CTargetUnit* pTU = 0;
	CRefString* pRefStr;
	for (numWords = 1; numWords <= MAX_WORDS; numWords++)
	{
		if (gbIsGlossing && numWords > 1)
			continue; // when glossing we want to consider only the first map, the others
					  // are all empty
		if (pKB->m_pMap[numWords-1]->size() == 0) 
			continue;
		else
		{
			iter = pKB->m_pMap[numWords-1]->begin();
			do {
				outputStr.Empty(); // clean it out ready for next "record"
				key = iter->first; 
				pTU = (CTargetUnit*)iter->second; 
				wxASSERT(pTU != NULL); 
				baseKey = key;
				key = lexSFM + key; // we put the proper eol char(s) below when writing

				// get the reference strings
				TranslationsList::Node* posRef = 0; 

				// if the data somehow got corrupted by a CTargetUnit being retained in the
				// list but which has an empty list of reference strings, this illegal
				// instance would cause a crash - so test for it and if such occurs, then
				// remove it from the list and then just continue looping
				if (pTU->m_pTranslations->IsEmpty())
				{
					pKB->m_pMap[numWords-1]->erase(baseKey); // the map now lacks this 
															 // invalid association
					TUList::Node* pos = pKB->m_pTargetUnits->Find(pTU); 
					wxASSERT(pos != NULL);
					pKB->m_pTargetUnits->DeleteNode(pos); // its CTargetUnit ptr is now 
														  // gone from list
					delete pTU; // and its memory chunk is freed
					continue;
				}
				else
					posRef = pTU->m_pTranslations->GetFirst(); 
				wxASSERT(posRef != 0);

				// if control gets here, there will be at least one non-null posRef and so
				// we can now unilaterally write out the key's line as a \lx source text field,
				// followed by the adaptation or gloss we've already found associated with it
				outputStr = key + pApp->m_eolStr;
				pRefStr = (CRefString*)posRef->GetData();
				posRef = posRef->GetNext(); // prepare for possibility of another CRefString
				wxASSERT(pRefStr != NULL); 
				gloss = pRefStr->m_translation;
				gloss = geSFM + gloss; // we put the proper eol char(s) below when writing
				outputStr += gloss + pApp->m_eolStr;

				// now deal with any additional CRefString instances within the same
				// CTargetUnit instance
				while (posRef != 0)
				{
					pRefStr = (CRefString*)posRef->GetData();
					wxASSERT(pRefStr != NULL); 
					posRef = posRef->GetNext(); // prepare for possibility of yet another
					gloss = pRefStr->m_translation;
					gloss = geSFM + gloss; // we put the proper eol char(s) below when writing
					outputStr += gloss + pApp->m_eolStr;
				}

				// add a blank line
				outputStr += pApp->m_eolStr;

				// reject any outputStr which contains "<Not In KB>"
				if (outputStr.Find(strNotInKB) == wxNOT_FOUND)
				{
					// the entry is good, so output it
					#ifndef _UNICODE // ANSI version
						pFile->Write(outputStr); 
					#else // Unicode version
						pApp->ConvertAndWrite(wxFONTENCODING_UTF8,pFile,outputStr);
					#endif
				}

				// point at the next CTargetUnit instance, or at end() (which is NULL) if
				// completeness has been obtained in traversing the map 
				iter++;
			} while (iter != pKB->m_pMap[numWords-1]->end());
		} // end of normal situation block ...
	} // end of numWords outer loop
}

void CAdapt_ItView::SelectDragRange(CCell* pAnchor,CCell* pCurrent)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pCurrent != NULL);
	if (pAnchor == NULL)
		return;

	// are boundaries to be ignored?
    // if m_bRespectBoundaries is FALSE because user clicked the button, for a SHIFT
    // select, SelectDragRange sometimes gets called, and if we unilaterally start with
    // bIgnoreBoundaries as FALSE then it can result in a long selection being wrongly
	// shortened to the loc'n of the first bounding srcPhrase when what would be wanted is
	// the long selection should be honoured. So we test for either the control key down,
	// or the Ignore Boundaries button having been clicked - if either or both is true,
	// then we ignore boundaries
	bool bIgnoreBoundaries = FALSE;
	if (!pApp->m_bRespectBoundaries || wxGetKeyState(WXK_CONTROL))
		bIgnoreBoundaries = TRUE;

	if (pAnchor->GetCellIndex() != pCurrent->GetCellIndex())
	{
		// cells are on different line, so cannot make a valid selection
		SelectAnchorOnly(); // just sets the selection to the anchor pile's cell
		return;
	}

	// set the direction
	if (pAnchor->GetPile()->GetSrcPhrase()->m_nSequNumber < 
					pCurrent->GetPile()->GetSrcPhrase()->m_nSequNumber)
		pApp->m_curDirection = right;
	else if (pAnchor->GetPile()->GetSrcPhrase()->m_nSequNumber > 
					pCurrent->GetPile()->GetSrcPhrase()->m_nSequNumber)
		pApp->m_curDirection = left;
	else
		return; // since we must be at the anchor which is already selected,
				// so nothing to be done yet

	SelectAnchorOnly(); // reduce to just the anchor, before we rebuild the selection
	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context
	canvas->DoPrepareDC(aDC); // get origin adjusted
	aDC.SetBackgroundMode(pApp->m_backgroundMode);
	aDC.SetTextBackground(wxColour(255,255,0)); // yellow

	int cellIndex = pAnchor->GetCellIndex();
	CCell* pCell = pAnchor;
	bool bAtEnd = FALSE;
	bool bAtBoundary = FALSE;
	if (pApp->m_curDirection == right)
	{
a:		pCell = GetNextCell(pCell,cellIndex);

		if (IsTypeDifferent(pApp->m_pAnchor,pCell))
		{
			CMainFrame *pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame != NULL);
			if (pFrame->canvas->HasCapture())
			{
				pFrame->canvas->ReleaseMouse(); // assume no failure
			}
			// IDS_DIFF_TEXT_TYPE
			wxMessageBox(_(
"Sorry, you are trying to select text of different types, such as a heading and verse text, or some other illegal combination. Combining verse text with poetry is acceptable, other combinations are not."),
			_T(""), wxICON_INFORMATION);
			RemoveSelection();
			pApp->m_mouse.x = pApp->m_mouse.y = -1;
			pApp->m_pAnchor = NULL;
			Invalidate();  // UpdateWindow() doesn't work, need the delayed update
			GetLayout()->PlaceBox();
			gbHaltedAtBoundary = FALSE;
			return;
		}

		if (pCell == pCurrent)
			bAtEnd = TRUE; // use this in our break out test later
		if (!bIgnoreBoundaries && pCell->GetPile()->GetSrcPhrase()->m_bBoundary)
		{
			bAtBoundary = TRUE; // can't go further, must respect this boundary
								// because CTRL key not down
			gbHaltedAtBoundary = TRUE; // for use by OnLButtonUp()
		}
		if (cellIndex == 0)
		{
			pCell->DrawCell(&aDC, GetLayout()->GetSrcColor()); // draw it 
							// selected (background is set yellow already)
		}
		else
		{
			pCell->DrawCell(&aDC, GetLayout()->GetTgtColor()); // draw it 
							// selected (background is set yellow already)
		}
		pCell->SetSelected(TRUE); // ensure updates continue to show it selected
		pApp->m_selection.Append(pCell); // store pointer in the selection list
		if (!(bAtEnd || bAtBoundary))
			goto a;
	}
	else
	{
b:		pCell = GetPrevCell(pCell,cellIndex);

		if (IsTypeDifferent(pApp->m_pAnchor,pCell))
		{
			CMainFrame *pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame != NULL);
			if (pFrame->canvas->HasCapture())
			{
				pFrame->canvas->ReleaseMouse(); // assume no failure
			}
			// IDS_DIFF_TEXT_TYPE
			wxMessageBox(_(
"Sorry, you are trying to select text of different types, such as a heading and verse text, or some other illegal combination. Combining verse text with poetry is acceptable, other combinations are not."),
			_T(""), wxICON_INFORMATION);
			RemoveSelection();
			pApp->m_mouse.x = pApp->m_mouse.y = -1;
			pApp->m_pAnchor = NULL;
			Invalidate();
			GetLayout()->PlaceBox();
			gbHaltedAtBoundary = FALSE;
			return;
		}

		if (pCell == pCurrent)
			bAtEnd = TRUE; // use this in our break out test later
		if (!bIgnoreBoundaries && pCell->GetPile()->GetSrcPhrase()->m_bBoundary)
		{
			bAtBoundary = TRUE; // can't go further, must respect this
								// boundary because CTRL key not down
			gbHaltedAtBoundary = TRUE; // for use by OnLButtonUp()
		}
		if (!bAtBoundary)
		{
			if (cellIndex == 0)
			{
				pCell->DrawCell(&aDC, GetLayout()->GetSrcColor()); // draw it 
								// selected (background is set yellow already)
			}
			else
			{
				pCell->DrawCell(&aDC, GetLayout()->GetTgtColor()); // draw it 
								// selected (background is set yellow already)
			}
			pCell->SetSelected(TRUE); // ensure updates continue to show it selected
			pApp->m_selection.Insert(pCell); // store pointer in the selection list
		}
		if (!bAtEnd)
			goto b;
	}
	CMainFrame *pFrame = pApp->GetMainFrame();
#ifdef __WXMAC__
	// Mac needs this to eliminate shadow printing of values displaced on lower part
	// of screen - due to double buffering?
	pFrame->SendSizeEvent(); // whm added 21Feb09 This causes more flicker during drag
#else
	// Windows and Linux seem to only require Update()
	pFrame->canvas->Update(); 
#endif
}

// shortens the selection so that it is just the anchor cell
void CAdapt_ItView::SelectAnchorOnly()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxASSERT(pApp->m_pAnchor != NULL);
	CCell* pAnchor = pApp->m_pAnchor;
	wxASSERT(pAnchor); 
	int cellIndex = pAnchor->GetCellIndex();

	wxClientDC aDC(pApp->GetMainFrame()->canvas); // make a device context
	canvas->DoPrepareDC(aDC); // get origin adjusted

	CCellList* pList = &pApp->m_selection; 
	wxASSERT(pList);
	CCellList::Node* pos = pList->GetFirst(); 
	wxASSERT(pos != NULL);
	while (pos != NULL)
	{
		CCell* pCell = (CCell*)pos->GetData();
		pos = pos->GetNext();
		if (pCell == pAnchor)
			continue;
		else
		{
			aDC.SetBackgroundMode(pApp->m_backgroundMode);
			aDC.SetTextBackground(wxColour(255,255,255)); // white
			if (cellIndex == 0)
			{
				pCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
			}
			else
			{
				pCell->DrawCell(&aDC, GetLayout()->GetTgtColor());
			}
			pCell->SetSelected(FALSE);
		}
	}
	// now remove from the selection list the cells which were deselected
	pList->Clear(); //pList->RemoveAll();
	pList->Insert(pAnchor);
	wxASSERT(pList->GetCount() == 1); // should only be one left in the list
	CMainFrame *pFrame = pApp->GetMainFrame();
#ifdef __WXMAC__
	// Mac needs this to eliminate shadow printing of values displaced on
	// lower part of screen - due to double buffering?
	pFrame->SendSizeEvent(); // whm added 21Feb09 This causes more flicker during drag
#else
	// Windows and Linux seem to only require Update()
	pFrame->canvas->Update(); 
#endif
}

// poetry is not treated as different than verse, but any other mismatch
// is considered to be a real mismatch
bool CAdapt_ItView::IsTypeDifferent(CCell* pAnchor, CCell* pCurrent)
{
	TextType aType = pAnchor->GetPile()->GetSrcPhrase()->m_curTextType;
	TextType curType = pCurrent->GetPile()->GetSrcPhrase()->m_curTextType;
	if (curType == aType)
		return FALSE;
	if (aType == verse)
	{
		if (curType == poetry)
			return FALSE;
		else
			return TRUE;
	}
	else if (aType == poetry)
	{
		if (curType == verse)
			return FALSE;
		else
			return TRUE;
	}
	else
		return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the TargetBox is in focus this handler enables the
/// Edit Undo menu item, otherwise it disables the menu item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditUndo(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxWindow* pWnd = wxWindow::FindFocus(); 
	if (pWnd == (wxWindow*)pApp->m_pTargetBox) 
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::OnEditUndo(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	wxWindow* pWnd = wxWindow::FindFocus();
	if (pWnd == (wxWindow*)pApp->m_pTargetBox)
	{
		if (pApp->m_pTargetBox->m_backspaceUndoStr.IsEmpty())
		{
			pApp->m_pTargetBox->Undo();
		}
		else
		{
			pApp->m_pTargetBox->OnEditUndo(event);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If the KBs are in a ready state this handler enables
/// the "Import to Knowledge Base..." item on the File menu, otherwise it disables the menu
/// item.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateImportToKb(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	event.Enable(pApp->m_bKBReady && pApp->m_bGlossingKBReady);
}

// no changes needed for support of glossing, however, calls DoKBImport( ) and the latter
// has modifications for glossing versus adapting support
void CAdapt_ItView::OnImportToKb(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxString message;
	message = _(
	"Extend the knowledge base by importing dictionary records"); //IDS_IMPORT_DICT_RECORDS
	wxString filter;
	filter = _(
	"Adapt It knowledge base import (*.txt)|*.txt|All Files (*.*)|*.*||"); //IDS_KB_IMPORT_FILTER
	wxString exportFilename = _T(""); // empty string
	wxString defaultDir;
	if (pApp->m_kbExportPath.IsEmpty())
	{
		defaultDir = pApp->m_curProjectPath;
	}
	else
	{
		defaultDir = pApp->m_kbExportPath;
	}

	wxFileDialog fileDlg(
		(wxWindow*)wxGetApp().GetMainFrame(), // MainFrame is parent window for file dialog
		message,
		defaultDir,	// empty string causes it to use the 
					// current working directory (set above)
		exportFilename,	// default filename
		filter,
		wxFD_OPEN); 
		// | wxHIDE_READONLY); wxHIDE_READONLY deprecated in 2.6 - the checkbox is never shown
		// GDLC wxOPEN deprecated in 2.8
	fileDlg.Centre();

	// open as modal dialog
	int returnValue = fileDlg.ShowModal();
	if (returnValue == wxID_CANCEL)
	{
		return; // user Cancelled, or closed the dialog box
	}
	else // must be wxID_OK
	{
		wxString pathName;
		pathName = fileDlg.GetPath();

		// update m_kbExportPath
		wxString exportPath = fileDlg.GetPath();
		wxString name = fileDlg.GetFilename();
		int nameLen = name.Length();
		int pathLen = exportPath.Length();
		wxASSERT(nameLen > 0 && pathLen > 0);
		pApp->m_kbExportPath = exportPath.Left(pathLen - nameLen - 1);

		wxTextFile file;
        // Under wxWidgets wxTextFile actually reads the entire file into memory at the
        // Open() call. It is set up so we can treat it as a line oriented text file while
        // in memory, modifying it, then if not just reading it, we can write it back out
        // to persistent storage with a single call to Write().

		// open the config file for reading
        // wxWidgets version we use appropriate version of Open() for ANSI or Unicode build
        // Note: Need to check if file exists, otherwise if Open fails wxWidgets'
        // wxTextFile conjures up its own error message to that fact which it issues in
        // Idle time just after it's no longer busy.
		bool bSuccessful;
		if (!::wxFileExists(pathName))
		{
			bSuccessful = FALSE;
		}
		else
		{
	#ifndef _UNICODE
			// ANSI
			bSuccessful = file.Open(pathName); // read ANSI file into memory
	#else
			// UNICODE
			bSuccessful = file.Open(pathName, wxConvUTF8); // read UNICODE file into memory
	#endif
		}
		if (!bSuccessful)
		{
			// assume there was no configuration file in existence yet, 
			// so nothing needs to be fixed
			wxMessageBox(_("Unable to open import file for reading."));
			return;
		}

		DoKBImport(pApp,&file);
	}
	return;
}

// Modified to work for either glossing or adapting KBs
bool CAdapt_ItView::IsAlreadyInKB(int nWords,wxString key,wxString adaptation)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CTargetUnit* pTgtUnit = 0;

	// is there a targetunit for this key in the KB?
	bool bFound;
	if (gbIsGlossing)
		// only check first map
		bFound = pApp->m_pTargetBox->FindMatchInKB(GetKB(),1,key,pTgtUnit); 
	else // is adapting
		bFound = pApp->m_pTargetBox->FindMatchInKB(GetKB(),nWords,key,pTgtUnit);
	if (!bFound)
		return FALSE;

	// check if there is a matching adaptation
	TranslationsList::Node* pos = pTgtUnit->m_pTranslations->GetFirst(); 
	while (pos != 0)
	{
		CRefString* pRefStr = (CRefString*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pRefStr);
		if (adaptation == pRefStr->m_translation)
			return TRUE; // adaptation, or gloss, matches this entry
	}
	return FALSE; // did not find a match
}

void CAdapt_ItView::DoKBImport(CAdapt_ItApp* pApp, wxTextFile* pFile)
{
	CKB* pKB;
	if (gbIsGlossing)
		pKB = pApp->m_pGlossingKB;
	else
		pKB = pApp->m_pKB;
	wxASSERT(pKB != NULL);
	CSourcePhrase* pSrcPhrase = new CSourcePhrase;
	// guarantee safe value for storage of contents to KB, or glossing KB
	if (gbIsGlossing)
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
	else
		pSrcPhrase->m_bHasKBEntry = FALSE;
	wxString key;
	key.Empty();
	wxString adaption; // use for actual adaptation, or gloss when glossing is ON
	adaption.Empty();
	wxString line;
	line.Empty();
	wxString ss1 = gSFescapechar;
	wxString keyMarker = ss1 + _T("lx");
	wxString adaptionMarker = ss1 + _T("ge");
	bool bKeyDefined = FALSE;
	int nOffset = -1;
	pApp->m_bSaveToKB = TRUE;

    // wx version: We are using wxTextFile which has already loaded its entire contents
    // into memory with the Open call in OnImportToKb() above. wxTextFile knows how to
    // handle Unicode data and the different end-of-line characters of the different
    // platforms.
    // Since the entire basic config file is now in memory we can read the information by
    // scanning its virtual lines. In this routine we use the "direct access" method of
    // retrieving the lines from storage in memory, using GetLine(ct).
	int lineCount = pFile->GetLineCount();

	int ct;
	for (ct = 0; ct < lineCount; ct++)
	{
		line = pFile->GetLine(ct);
		// the data for each line is now in lineStr
		// is the line a m_key member?
		if (IsMember(line,keyMarker,nOffset) || nOffset >= 0)
		{
			// it is a valid key
			pSrcPhrase->m_key.Empty();
			if (gbIsGlossing)
			{
				pSrcPhrase->m_gloss.Empty();
				pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
				pSrcPhrase->m_nSrcWords = 1;
			}
			else
			{
				pSrcPhrase->m_adaption.Empty();
				pSrcPhrase->m_bHasKBEntry = FALSE;
				pSrcPhrase->m_nSrcWords = 1; // temp default value
			}
			bKeyDefined = TRUE;

			// extract the actual srcPhrase's m_key from the read in string,
			// to set the key variable
			int keyLen = line.Length();
			keyLen -= (4 + nOffset); // \lx followed by a space = 4 characters,
									 // nOffset takes care of any leading spaces
			if (keyLen > 0)
			{
				key = line.Right(keyLen);
				int nWordCount;
				if (gbIsGlossing)
					nWordCount = 1;
				else
					nWordCount = CountSourceWords(key);
				if (nWordCount == 0 || nWordCount > MAX_WORDS)
				{
					// error condition
					pSrcPhrase->m_nSrcWords = 1;
					key.Empty();
					bKeyDefined = FALSE;
				}
				else
				{
					// we have an acceptable key
					pSrcPhrase->m_nSrcWords = nWordCount;
					pSrcPhrase->m_key = key; // CountSourceWords will strip off
											 // leading or trailing spaces in key
				}
			}
			else
			{
				key.Empty();
				bKeyDefined = FALSE;
				pSrcPhrase->m_nSrcWords = 1;
			}
		}
		else
		{
			if (IsMember(line,adaptionMarker,nOffset) || nOffset >= 0)
			{
				// an adaptation member exists for this key, so get the KB updated
				// with this association provided a valid key was constructed
				if (bKeyDefined)
				{
					int adaptionLen = line.Length();
					adaptionLen -= (4 + nOffset); // \ge followed by a space = 4 characters,
												  // nOffset takes care of any leading spaces
					if (adaptionLen > 0)
					{
						adaption = line.Right(adaptionLen);
					}
					else
					{
						adaption.Empty();
					}

					// store the association in the KB, provided it is not already there
					if (gbIsGlossing)
					{
						if (!IsAlreadyInKB(1,key,adaption))
							// adaption parameter is assumed to be a gloss if glossing is ON
							StoreText(pKB,pSrcPhrase,adaption,TRUE); // BEW 27Jan09, 
													// TRUE means "allow empty string save"
					}
					else
					{
						if (!IsAlreadyInKB(pSrcPhrase->m_nSrcWords,key,adaption))
							StoreText(pKB,pSrcPhrase,adaption,TRUE); // BEW 27Jan09, 
													// TRUE means "allow empty string save"
					}

					// prepare for another adaptation (or gloss) for this key
					pSrcPhrase->m_adaption.Empty();
					adaption.Empty();
				}
			}
			else
			{
				// it's neither a key nor an adaption (or gloss),
				// so probably a blank line - just ignore it
				;
			}
		}
	}
	// process the last line here ???
	delete pSrcPhrase;
}

int CAdapt_ItView::CountSourceWords(wxString& rStr)
{
	int len = rStr.Length();
	if (len == 0)
		return 0;

	// remove any final spaces
	wxString reverse = rStr;
	reverse = MakeReverse(reverse);
	wxChar ch = _T(' ');
a:	int nFound = reverse.Find(ch);
	if (nFound == 0)
	{
		// found one, so remove it and iterate
		reverse = reverse.Right(len-1);
		len = reverse.Length();
		goto a;
	}
	else
	{
		// restore correct order
		reverse = MakeReverse(reverse);
	}

	// remove initial spaces, if any
	len = reverse.Length();
b:	nFound = reverse.Find(ch);
	if (nFound == 0)
	{
		// found one, so remove it and iterate
		reverse = reverse.Right(len-1);
		len = reverse.Length();
		goto b;
	}

	rStr = reverse; // updates string in the caller, so it has 
					// no trailing nor leading spaces

	if (rStr.IsEmpty())
	{
		// if it was only spaces, we have no valid string
		return 0;
	}

	// now parse words
	int count = 1;
	len = reverse.Length();
c:	nFound = reverse.Find(ch);
	if (nFound > 0)
	{
		// found a space, so must be an additional word
		count++; // count it

		// reduce reverse by one word
		reverse = reverse.Right(len-nFound-1);

		// there might be a sequence of spaces, so skip any 
		// leading spaces on the reduced string
d:		nFound = reverse.Find(ch);
		if (nFound == 0)
		{
			reverse = reverse.Right(len-1);
			len = reverse.Length();
			goto d;
		}
		len = reverse.Length();
		goto c;
	}
	else
		return count;
}

bool CAdapt_ItView::IsMember(wxString& rLine, wxString& rMarker, int& rOffset)
{
	if (rLine.IsEmpty())
	{
		rOffset = -1;
		return FALSE;
	}
	int nFound = rLine.Find(rMarker);
	rOffset = nFound;
	if (nFound == 0)
		return TRUE;
	else
		return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If
/// Vertical editing is in progress this handler disables the Back button and returns
/// immediately. Otherwise, if there are source phrases in the App's m_pSourcePhrases list,
/// if the App's m_endIndex is within a valid range, and if the global gnOldSequNum does
/// not equal -1, this handler enables the toolBar's "Jump Back" button, otherwise it
/// disables the toolBar button.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonBack(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
		pApp->m_nActiveSequNum >= 0)
	{
		if (gnOldSequNum == -1)
			event.Enable(FALSE);
		else
			event.Enable(TRUE);
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonBack(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	if (gnOldSequNum == -1)
	{
		::wxBell();
		return;
	}

    // BEW added 28Sep05, to fix the following bug. It the globals below are not here
    // reset, and especially to the same value, then when we've been doing autoinseting at
    // a location somewhere and we click the back button to go to a very different location
    // far away in the document, any call to ScrollIntoView() will invoke its "smart" code
    // -- that takes the two globals below and if they are different, it will ask for a
    // recalculation of the pile pointers for the beginning and end of the last inserted
    // set of adaptations -- and these require GetPile() calls which, because that old
    // location was miles away further away in the document, a bundle advance and layout
    // recalculation get done in order to get valid pointers - and on return from
    // ScrollIntoView() the layout is no longer where expected and the active pointer has
    // probably become invalid. Setting both globals to zero avoids all and causes the
    // legacy scrolling block to be used in ScrollIntoView(), as wanted.
	gnBeginInsertionsSequNum = gnEndInsertionsSequNum = 0; // clear, and make both be same value

	// there must be a valid earlier active location, so jump to there
	int nOldSequNum;
	if (pApp->m_nActiveSequNum == -1)
	{
		// current location is at eof, so gnOldSequNum will need to be set to -1
		nOldSequNum = -1;
	}
	else
	{
		nOldSequNum = pApp->m_nActiveSequNum; // location we are about to leave 
											  // becomes new old one
	}
	CPile* pPile = GetPile(gnOldSequNum);
	if (pPile != NULL)
	{
		// define the new active location & jump there
		pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber; 
		Jump(pApp,pPile->GetSrcPhrase());
	}
	// update its value from the saved one in the local variable
	gnOldSequNum = nOldSequNum;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If the
/// active pile pointer is NULL or there are no source phrases in the App's
/// m_pSourcePhrases list, or the App's m_endIndex is not within a valid range, the
/// toolBar's "View Translation or Glosses Elsewhere In The Document" button is disabled,
/// otherwise it is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonEarlierTranslation(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && pApp->m_nActiveSequNum >= 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonEarlierTranslation(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// check that the dialog is not currently open, if it is, delete it
	wxString saveSrc;
	saveSrc.Empty();
	wxString saveTgt; // for version 2.0 and onwards, this can double
					 // for either adaptation text or glossing text, 
					 // depending on the gbIsGlossing flag
	saveTgt.Empty();
	if (pApp->m_pEarlierTransDlg != NULL)
	{
		pApp->m_pEarlierTransDlg->Destroy();
		pApp->m_pEarlierTransDlg = NULL;
	}

	if (pApp->m_pEarlierTransDlg == NULL)
	{
		pApp->m_pEarlierTransDlg = new CEarlierTranslationDlg(pApp->GetMainFrame());
		// don't use Create in wx dialogs

		// set default parameter values
		pApp->m_pEarlierTransDlg->m_srcText = _T("");
		pApp->m_pEarlierTransDlg->m_tgtText = _T("");
		pApp->m_pEarlierTransDlg->m_strBeginChVerse = _T("");
		pApp->m_pEarlierTransDlg->m_strEndChVerse = _T("");
		pApp->m_pEarlierTransDlg->m_bIsVerseRange = FALSE;
		pApp->m_pEarlierTransDlg->m_nChapter = 0;
		pApp->m_pEarlierTransDlg->m_nVerse = 0;
		pApp->m_pEarlierTransDlg->m_nVerseRangeEnd = 0;

		AdjustDialogPosition(pApp->m_pEarlierTransDlg);
		pApp->m_pEarlierTransDlg->Show(TRUE);
	}
	else
	{
		AdjustDialogPosition(pApp->m_pEarlierTransDlg);
		pApp->m_pEarlierTransDlg->Show(TRUE);
	}
}

void CAdapt_ItView::OnButtonNoAdapt(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	pApp->m_bForceAsk = FALSE; // ensure it's off
	CPile* pCurPile = pApp->m_pActivePile;

    // make sure the store will succeed, and if the pApp->m_targetPhrase has a gloss or
    // adaptation in the appropriate KB then remove it or reduce its reference count before
    // we clear out the contents of m_targetPhrase; but if a selection is current, then
    // don't do the above, but instead assume a merge is wanted first - so do the merge,
    // and then make the <no adaptation> button click apply to the merged phrase thereby
    // produced. (Feature change requested by Wolfgang Stradner, Oct 28 04)
	CRefString* pRefStr;
	if (pApp->m_selectionLine != -1 && pApp->m_selection.GetCount() > 1 && !gbIsGlossing)
	{
		// move the active location for restoration of the view to first 
		// cell of the selection, if not there already
		CCellList::Node* cpos = pApp->m_selection.GetFirst();
		CCell* pCell = cpos->GetData();
		int saveSequNum = pCell->GetPile()->GetSrcPhrase()->m_nSequNumber;
		pApp->m_nActiveSequNum = saveSequNum; // BEW added 18Apr09
		OnButtonMerge(event);
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
		pApp->m_pActivePile = GetPile(saveSequNum);
		pCurPile = pApp->m_pActivePile;
	}
	else
	{
		if (gbIsGlossing)
		{
			pRefStr = GetRefString(pApp->m_pGlossingKB, 1,
						pApp->m_pActivePile->GetSrcPhrase()->m_key,pApp->m_targetPhrase);
			if (pRefStr == NULL && pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
				pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
			if (pRefStr != NULL)
				RemoveRefString(pRefStr, pApp->m_pActivePile->GetSrcPhrase(), 1);
		}
		else
		{
			pRefStr = GetRefString(pApp->m_pKB,
						pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
						pApp->m_pActivePile->GetSrcPhrase()->m_key,pApp->m_targetPhrase);
			if (pRefStr == NULL && pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
				pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
			if (pRefStr != NULL)
				RemoveRefString(pRefStr, pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords);
		}
	}

	pApp->m_targetPhrase.Empty(); // clear out the attribute on the view
	pApp->m_pTargetBox->ChangeValue(_T("")); // clear out the box too
	if (gbIsGlossing)
		pApp->m_pActivePile->GetSrcPhrase()->m_gloss.Empty();
	else
	{
		pApp->m_pActivePile->GetSrcPhrase()->m_adaption.Empty();
		pApp->m_pActivePile->GetSrcPhrase()->m_targetStr.Empty();
	}

    // the TRUE flag is required, since it leads to the store being automatically
    // done - otherwise, no store would be done for the empty adaptation 
	bool bOK;
	if (gbIsGlossing)
		bOK = StoreText(pApp->m_pGlossingKB,pCurPile->GetSrcPhrase(),
						pApp->m_targetPhrase,TRUE);
	else
		bOK = StoreText(pApp->m_pKB,pCurPile->GetSrcPhrase(),
						pApp->m_targetPhrase,TRUE);

	// layout the strips
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	
    // remove any selection, but don't redraw, so need to do it without calling
    // RemoveSelection() because the layout's pointers are now not matched by those in
    // m_selection.
	gnSelectionLine = -1;
	gnSelectionStartSequNum = -1;
	gnSelectionEndSequNum = -1;
	pApp->m_selectionLine = -1;
	pApp->m_pAnchor = NULL;
	if (pApp->m_selection.GetCount() > 0)
		pApp->m_selection.Clear();

	GetLayout()->m_docEditOperationType = on_button_no_adaptation_op;
	Invalidate();
	GetLayout()->PlaceBox();
}

// whm added 14Aug06 as a temporary measure to prevent editing of source text when
// the selection contains any filtered information (BEW 15 Aug 06: it will probably be
// a permanent measure as source editing when there is filtered info would be hard to
// control since the editing could do anything and the filtered info be anything!)
bool CAdapt_ItView::IsFilteredInfoInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // let the caller have the burden of 
					  // aborting the edit it the list is empty
	
	// BEW added next (two) lines 27Dec07 to only reject the attempt when 
	// filtered info is on non-first
	pSrcPhrase = (CSourcePhrase*)pos->GetData(); // allow filtered info 
												 // on first in the list
	pos = pos->GetNext();

	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_markers.Find(filterMkr) != -1)
			return TRUE;
	}
	return FALSE;
}

bool CAdapt_ItView::IsFreeTranslationInSelection(SPList* pList)
{
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = pList->GetFirst();
	if (pos == NULL)
		return FALSE; // let the caller have the burden of aborting 
					  // the edit it the list is empty
	
    // BEW added next (two) lines 27Dec07 to only reject the attempt when starting of a
    // free trans is not on the first CSourcePhrase instance in the selection
	pSrcPhrase = (CSourcePhrase*)pos->GetData(); // allow filtered info 
												 // on first in the list
	pos = pos->GetNext();

	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		// BEW changed 27Dec07, see above: if (pSrcPhrase->m_bHasFreeTrans)
		if (pSrcPhrase->m_bStartFreeTrans)
			return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Edit Source Text..." item on the Edit menu is
/// disabled if any of the following conditions is TRUE: Vertical Editing is in progress,
/// the m_pActivePile is NULL, the application is in Free Translation mode. Otherwise it is
/// enabled only if some source text selected.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditSourceText(wxUpdateUIEvent& event) 
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// BEW updated, 11Apr08, to remove the "not when in free translation mode" modality
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
    // added test for no phrase box currently defined (this can happen when user has
    // advanced the box past the last pile within the document) -- we'll not allow editing
    // of the source when the app is in this state, as there is no valid current sequence
    // number (formerly, this test was in the edit source text command handler, but is more
    // appropriate here)
	if (pApp->m_pActivePile == NULL)
	{
		// The phrase box must first must be placed at 
		// one of the piles before the edit is enabled
		event.Enable(FALSE);
		return;
	}

	// currently, we won't allow it when free translation mode is turned on; but when vertical
	// editing as a multi-step process is implemented, we can remove this constraint
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there were no internal errors; FALSE if something went belly up 
///             requiring the edit to be aborted (but the app continues, the document 
///             isn't changed)
/// \param      pSrcPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		<->	(input)reference to the sequence number for the first pile 
///                                 in the user's selection; (output) the sequence number value 
///                                 for the first pile after any extension leftwards was done
/// \param      nEndingSN		<->	(input)reference to the sequence number for the last pile 
///                                 in the user's selection; (output) the sequence number value 
///                                 for the last pile after any extension rightwards was done
/// \param      bIsExtended		<-	reference to BOOL indicating whether extension was required 
///                                 and done (TRUE) or not required and not done (FALSE)
/// \remarks
/// Called from: The View's OnEditSourceText().
/// Automatically extends the user's selection of the source text to be edited where
/// necessary to include source text material (and filtered/hidden material) that should be
/// dealt with when editing the source text. We save processing time by not bothering to
/// actually use the m_selection list; extension only is required if we have a
/// retranslation in or partly in the span of the user's manual selection, and we can
/// easily test for that by looking at flag values on CSourcePhrase instances. The caller
/// only needs to know what the final sequence numbers of the span for editing are.
/// "Leftwards" in this function is to be interpretted as "to lower sequence numbers", & so
/// if we are dealing with a right-to-left language data, it would be rightwards to the
/// user.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ExtendEditSourceTextSelection(SPList* pSrcPhrases, int& nStartingSN,
												  int& nEndingSN, bool& bIsExtended)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// 12Apr08, BEW added this function
	bIsExtended = FALSE;
	int nIteratorSN = 0; // use when scanning forwards or backwards
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		// whm Note: The following error message does not need to be available for localization
		wxMessageBox(_T(
"FindIndex() failed in ExtendEditSourceTextSelection(), pos value is NULL. Saving document & cancelling this editing attempt..."),
		 _T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* savePos = pos; // keep for when we later scan forwards
	pSrcPhrase = pos->GetData();
	pos = pos->GetPrevious();
	if (pSrcPhrase->m_bRetranslation)
	{
		// the user's first selected pile is within a retranslation, 
		// so possibly extension left is required
		if (!pSrcPhrase->m_bBeginRetranslation)
		{
			// the first pile of the user's selection is not the first pile in
			// the retranslation, so extension leftwards is needed
			while (TRUE)
			{
				if (pos == NULL)
				{
					// we have come to the start of the document, so extending
					// further left is not possible
					break;
				}
				// get the previous CSourcePhrase at the new POSITION
				pSrcPhrase = pos->GetData();
				pos = pos->GetPrevious();
				nStartingSN = pSrcPhrase->m_nSequNumber;
				bIsExtended = TRUE;
				if (pSrcPhrase->m_bBeginRetranslation)
				{
					// we are at the start of the retranslation, so break out
					break;
				}
			}
		}
		// We have established the nStartingSN value, now we need to work out
		// where this particular retranslation ends - it may end before, at, or
		// after the user's selection's end (in fact, there may be more than one
		// retranslation in his selection). So now we must here scan across the
		// current retranslation to its end, then work out if it contains the
		// end of the user's selection - if so, we are done, if not, we must
		// proceed to the outer block to continue scanning to higher sequence numbers
		pos = savePos; // restore starting POSITION; we must start from here because the
					   // user may have selected only a single word
		while (pos != NULL)
		{
			savePos = pos; // save the POSITION
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			nIteratorSN = pSrcPhrase->m_nSequNumber;

			// if we get to a higher sequence number than the end of the user's
			// selection, the selection is being extended and we must register
			// that fact using the next test
			if (nIteratorSN > nEndingSN)
			{
				bIsExtended = TRUE;
			}
			if (pSrcPhrase->m_bEndRetranslation)
			{
				// we are at the end of the retranslation, so break out
				break;
			}
		}
		// return if we have inclusion or are at the doc end
		if (nIteratorSN >= nEndingSN || pos == NULL)
		{
			// the end of the user's original selection is earlier than the
			// end of the retranslation, or coincides with it, or we
			// are at the end of the document; hence we are done
			nEndingSN = nIteratorSN; // update the value being returned to the caller
			return TRUE; // no errors
		}
		
	}
	// If control gets to here, then either the starting pile of the user's selection
	// was not in a retranslation (in which case no exending leftwards was needed) and
	// the POSITION value is still at the start of the user's selection; or we have just
	// iterated across a retranslation but have not yet reached the final pile of the
	// user's selection. In either case, we must continue iterating rightwards until we
	// get to the user's selection end - then, once there, if that is within a(nother)
	// retranslation, we must extend further rightwards to the end of that one, but 
	// if not, we are done
	pos = savePos; // initialize iterator
	pSrcPhrase = pos->GetData(); // get the next pos value
	pos = pos->GetNext(); 
	nIteratorSN = pSrcPhrase->m_nSequNumber; // initialize sequence number iterator
	while (pos != NULL && nIteratorSN < nEndingSN)
	{
		// iterate forwards to the end of the user's selection
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nIteratorSN = pSrcPhrase->m_nSequNumber;
	}
	if (pos == NULL)
	{
		// we reached the end of the document
		nEndingSN = nIteratorSN; // pass back the last CSourcePhrase instance's sequ num
		return TRUE; // if we return here, we've not done any rightwards extension
	}

    // If control gets to here, then we are not at the document's end, but have reached the
    // last pile of the user's selection. This may be as far as we need go, but we must
    // test for this pile being within a(nother) retranslation, and if it is, we must
    // extend rightwards to the end of that retranslation & end there; otherwise, we are
    // done
	if (!pSrcPhrase->m_bRetranslation)
	{
		// no extending is needed, so return
		nEndingSN = nIteratorSN;
		return TRUE; // no errors
	}
	else
	{
		// extending rightwards is needed
		bIsExtended = TRUE;
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			nIteratorSN = pSrcPhrase->m_nSequNumber; // update the sequ num iterator
			if (pSrcPhrase->m_bEndRetranslation)
			{
				// we don't extend any further, the whole retranslation is in 
				// the span we've now identified
				nEndingSN = nIteratorSN;
				return TRUE; // no errors
			}
		}
	}
	// if we get here, we've reached the document end, so set nEndingSN and return
	nEndingSN = nIteratorSN;
	return TRUE; // no errors
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error, FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	index into the pSrcPhrases list at which the span to
///                                 be investigated starts
/// \param      nEndingSN		->	index at which the span ends
/// \param      pbHasAdaptations <-	pointer to bool, returns TRUE if there is at least one
///                                 adaptation in the span, FALSE if there were none
/// \remarks
/// Called from: The View's OnEditSourceText(). Determines if there is at least one
/// adaptation in the span of text determined by nStartingSN and nEndingSN. We check only
/// as far as the end of the span, or till we find the first adaptation, whichever comes
/// first. Used to set or clear the bEditSpanHasAdaptations flag in the global struct
/// gEditRecord.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsAdaptationInformationInThisSpan(SPList* pSrcPhrases, int& nStartingSN, 
													 int& nEndingSN, bool* pbHasAdaptations)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	(*pbHasAdaptations) = FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	int nThisSN;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		// An English message would be ok here.
		wxMessageBox(_T(
"FindIndex() failed in IsAdaptationInformationInThisSpan(), pos value is NULL. Saving the document. Exiting the edit process."),
		_T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}

	// scan over the editable span looking for any m_adaption non-empty strings in the 
	// CSourcePhrase instances; exit TRUE when the first such is found, we don't need
	// to know how many there are
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;
		if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			// there is at least one non-empty adaptation string in this span
			(*pbHasAdaptations) = TRUE;
			return TRUE;
		}
		if (nThisSN >= nEndingSN)
		{
			// we are at the end of the span which is to be tested, so break out
			break;
		}
	}
	(*pbHasAdaptations) = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error, FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	index into the pSrcPhrases list at which the span to
///                                 be investigated starts
/// \param      nEndingSN		->	index at which the span ends
/// \param      pbHasGlosses    <-	pointer to bool, returns TRUE if there is at least
///                                 one gloss in the span, FALSE if there were none
/// \remarks
/// Called from: The View's OnEditSourceText(). Determines if there is at least one gloss
/// in the span of text determined by nStartingSN and nEndingSN. We check only as far as
/// the end of the span, or till we find the first gloss, whichever comes first. Used to
/// set or clear the bEditSpanHasGlosses flag in the global struct gEditRecord.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsGlossInformationInThisSpan(SPList* pSrcPhrases, int& nStartingSN, 
												 int& nEndingSN, bool* pbHasGlosses)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	(*pbHasGlosses) = FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	int nThisSN;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in IsGlossInformationInThisSpan(), pos value is NULL. Saving the document. Exiting the edit process."),
		_T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}

	// scan over the editable span looking for any m_gloss non-empty strings in the 
	// CSourcePhrase instances; exit TRUE when the first such is found, we don't need
	// to know how many there are
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;
		if (!pSrcPhrase->m_gloss.IsEmpty())
		{
			// there is at least one non-empty gloss string in this span
			(*pbHasGlosses) = TRUE;
			return TRUE;
		}
		if (nThisSN >= nEndingSN)
		{
			// we are at the end of the span which is to be tested, so break out
			break;
		}
	}
	(*pbHasGlosses) = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if it appears likely the free translation section was created with
///             the "Define Sections By"radio button "Verse" turned ON, FALSE if the other
///             radio button "Punctuation" was the one more likely to have been ON
/// \param      pSrcPhrases				->	pointer to m_pSrcPhrases defined on 
///                                             CAdapt_ItDoc class
/// \param      nStartingFreeTransSequNum	->	start of the free translation found at the
///                                             start of the free translation span, or if 
///                                             there was no free translation there, then
///                                             it is the same as the nStartingSN value 
///                                             of gEditRecord
/// \param      nEndingFreeTransSequNum	->	bounding sequence number beyond which we 
///                                             don't scan further (it is not necessarily 
///                                             the end of a free translation section, as 
///                                             the end of the first free translation 
///                                             section, if one exists here, may occur
///                                             earlier, because this value may just be 
///                                             the nEndingSN value of gEditRecord
/// \param      bFreeTransPresent			->	TRUE if there is at least one free 
///                                             translation section within the span defined
///                                             by the first two parameters (caller
///                                             determines this), FALSE if not - and if
///                                             FALSE, then control immediately exits and
///                                             no scan is done and default FALSE is
///                                             returned.
/// \remarks
/// Called from: The View's OnEditSourceText().
/// When a free translation section is set up by the SetupCurrentFreeTranslationSection()
/// call at the end of the RecalcLayout() call, the user will have had one of the radio
/// buttons "Punctuation" or "Verse" turned on - the latter defines, usually, a longer
/// section than the former. However which one it was is not recorded, and so in vertical
/// edit mode, we want to get a "best guess" for what that setting was, (it is the
/// application class's BOOL flag, m_bDefineFreeTransByPunctuation, default is TRUE),
/// because we wish to restore that setting before entering the freeTranslationsStep of the
/// vertical edit process. (Otherwise, the user would be annoyed that his earlier
/// sectioning choice is not in effect. However, even if our algorithm gets it wrong, he
/// can just click the relevant radio button after freeTranslationsStep is entered, and
/// before he does any updating of his free translation, and the current section would then
/// be resized) Unfortunately, we cannot reliably determine what the former setting was. We
/// know 5 piles will be traversed and then the sectioning code starts looking for a
/// terminating condition - punctuation, or significant SFM, or start of a new verse. If
/// after 5 piles we come to a following punctuation character, and the section does not
/// end there, we can be certain that m_bDefineFreeTransByPunctuation was originaly FALSE;
/// if we come to the end of the section and the next pile contains pSrcPhrase with
/// m_bVerse set TRUE, then it is likely that m_bDefineFreeTransByPunctuation was FALSE -
/// but we can't be certain; or if there are lots of piles in the section (we mean "more
/// than 15") we'll assume the flag was FALSE. Otherwise, we'll assume it was TRUE. (The
/// value we return is the inverse of m_bDefineFreeTransByPunctuation value; i.e. if the
/// latter was FALSE, meaning a verse-length section, then we return TRUE; and vise versa)
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetLikelyValueOfFreeTranslationSectioningFlag(SPList* pSrcPhrases,
	int nStartingFreeTransSequNum, int nEndingFreeTransSequNum, bool bFreeTransPresent)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// 01Oct08, BEW added this function 
	if (!bFreeTransPresent)
		return FALSE; // do nothing if we know there is no free translation in the span

	wxString spacelessTgtPunctuation = pApp->m_punctuation[1]; // use target set, 
															// with delimiting spaces
	spacelessTgtPunctuation.Replace(_T(" "),_T("")); // get rid of the spaces

	int nThreshhold = NUM_WORDS_IMPLYING_VERSE_SECTIONING; // #defined as 15 near top of file
	int nWordCount = 0;
	int nPunctuationsNotHaltedAt = 0;
	CSourcePhrase* pSrcPhrase = NULL;

	// find the first pSrcPhrase in the span which has m_bStartFreeTrans TRUE
	bool bFoundStart = FALSE;
	SPList::Node* pos = pSrcPhrases->Item(nStartingFreeTransSequNum);
	SPList::Node* posBoundary = pSrcPhrases->Item(nEndingFreeTransSequNum);
	wxASSERT(pos != NULL);
	bool bHasWordFinalPunct = FALSE;
	while (pos != NULL)
	{
		if (pos == posBoundary)
		{
			// we have tested the last one in the span, so must exit this loop having
			// not found an instance where a free translation starts; and so we exit the 
			// whole function as there can be no free translation to be dealt with
			return FALSE;
		}
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_bStartFreeTrans)
		{
			bFoundStart = TRUE;
			break;
		}
	}
	if (bFoundStart)
	{
        // scan over this free translation, collecting information about it; but if the
        // first pSrcPhrase is the end of the free translation section, then assume
        // "Punctuation" radio button was ON and return a FALSE value accordingly
		if (pSrcPhrase->m_bEndFreeTrans)
			return FALSE;
		// otherwise, check out this pSrcPhrase more closely
		nWordCount += pSrcPhrase->m_nSrcWords; // could be a merger, so may already 
											   // exceed 5, so check
		if (nWordCount >= MIN_FREE_TRANS_WORDS)
		{
            // test for potential halt location (following punctuation at end of
            // m_targetStr, or end of source text word or phrase if there is no target text
            // here)
			bHasWordFinalPunct = HasWordFinalPunctuation(pSrcPhrase,pSrcPhrase->m_targetStr,
															spacelessTgtPunctuation);
			if (bHasWordFinalPunct)
			{
				// does the free translation section end here?
				if (pSrcPhrase->m_bEndFreeTrans)
				{
                    // it does end here, and it's just a single pile, so without doubt this
                    // section was delineated earlier with "Punctuation" radio button ON
					return FALSE; // no need to go further
				}
				else if (pSrcPhrase->m_bHasFreeTrans)
				{
                    // we are still in the free translation section, but it does not end at
                    // this punctuation, so count this location
					nPunctuationsNotHaltedAt++; // its starting to look like "Verse" radio
												// button was ON, but check some more
				}
				else
				{
					// the free translation is not defined here! This is unexpected,
					// so return with a default value
					return FALSE;
				}
			} // end block for test (bHasWordFinalPunct))
		} // end block for test (nWordCount >= MIN_FREE_TRANS_WORDS)

        // if control gets here, then we've not found the end of the free translation
        // section yet, but we may or may not have exceeded MIN_FREE_TRANS_WORDS, anyway,
        // we soldier on to later CSourcePhrase instances and test those
		bool bReachedBoundary = FALSE;
		while (pos != NULL)
		{
            // if we are at the boundary for scanning, record the fact but then do the
            // tests below and use the boolean to exit the loop when those test are
            // finished
			if (pos == posBoundary)
			{
				bReachedBoundary = TRUE;
			}
			// get next CSourcePhrase, and increment the word count
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			nWordCount += pSrcPhrase->m_nSrcWords;

            // if we've not exceeded the minimum words, the only thing we need check for is
            // whether or not this is an unusualy short free translation section, if it is
            // then return FALSE immediately, otherwise, loop; but if we've exceed the
            // minimum words now, then we have to do more checks
			if (nWordCount <= MIN_FREE_TRANS_WORDS)
			{
				if (pSrcPhrase->m_bEndFreeTrans)
				{
					// the section ends here, so it must be a short section
					return FALSE;
				}
			}
			else
			{
				// word count exceeds minimum, so more extensive testing required

                // test for potential halt location (following punctuation at end of
                // m_targetStr, or end of source text word or phrase if there is no target
                // text here)
				bHasWordFinalPunct = HasWordFinalPunctuation(pSrcPhrase,
										pSrcPhrase->m_targetStr,spacelessTgtPunctuation);
				if (bHasWordFinalPunct)
				{
					// does the free translation section end here?
					if (pSrcPhrase->m_bEndFreeTrans)
					{
						// it does end here, so break out to check if next 
						// CSourcePhrase has m_bVerse == TRUE
						break;
					}
					else if (pSrcPhrase->m_bHasFreeTrans)
					{
                        // we are still in the free translation section, but it does not
                        // end at this punctuation, so count this location & iterate loop
						nPunctuationsNotHaltedAt++;
					}
					else
					{
                        // the free translation is not defined here! This is unexpected, so
                        // decrement nWordCount and break out for final check
						nWordCount -= pSrcPhrase->m_nSrcWords;
						break;
					}
				} // end of block for test (bHasWordFinalPunct)
				else
				{
                    // no word final punctuation at this CSourcePhrase instance, so just
                    // check if the free translation section ends here - if it does, break
                    // out to check if the next CSourcePhrase has m_bVerse == TRUE
					if (pSrcPhrase->m_bEndFreeTrans)
					{
						// it ends here
						break;
					}
				} // end of else block for test (bHasWordFinalPunct)
			} // end of else block for test (nWordCount <= MIN_FREE_TRANS_WORDS)

			if (bReachedBoundary)
			{
                // if we get here, the m_bEndFreeTrans TRUE has not been encountered - this
                // should not happen because the caller sets the ending boundary to the
                // place where that flag is TRUE, unless there is no free translation
                // defined here, in which case we should have come to the section end
                // earlier - so all we can do is the best we can
				if (nWordCount > nThreshhold)
					return TRUE;
				else
					return FALSE;
			}
		} // end of loop for test (pos != NULL)

		bool bEndsAtVerse = FALSE;
		if (pos != NULL && pos != posBoundary)
		{
            // test the CSourcePhrase following the end of the free translation section,
            // for m_bVerse == TRUE, if it is, then probaby the radio button that was ON
            // was "Verse"
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			bEndsAtVerse = pSrcPhrase->m_bVerse;
		}

		// now, make out final assessment; the most reliable ones first, 
		// less reliable ones later
		if (nPunctuationsNotHaltedAt >= 1)
			return TRUE; // "Verse" button was ON
		if (bEndsAtVerse)
			return TRUE; // "Verse" button may have been ON
		if (nWordCount > nThreshhold)
			return TRUE; // we don't really know, but "Verse" assumption
						 // will give best chance of a long section
	}
	return FALSE; // we didn't get a starting location, or we fell though from the preceding
				  // block because no test was conclusive, so return default;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error; FALSE if there was an error
/// \param      pScrPhrases	->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN	->	reference to the sequence number for the first pile 
///                                 in the span which is to have its source text shown to 
///                                 the user (this could be more than the user's original 
///                                 selection, if extension was done because of the presence
///                                 of a retranslation or even more than one retranslation)
/// \param      nEndingSN		->	reference to the sequence number for the last pile in
///                                 the span referred to by the preceding parameter's comment
/// \param      nStartingFreeTransSequNum	<- ref to the start of any free translation found
///                                             at the start of the above span, or if there
///                                             were no free translation there, then it is
///                                             the same as the nStartingSN value
/// \param      nEndingFreeTransSequNum	<- ref to the end of any free translation found at 
///                                             the end of the above span, or if there were
///                                             no free translation there, then it is the
///                                             same as the nEndingSN value
/// \param      bFreeTransPresent			<-	return TRUE if at least one free translation
///                                             section is in or partly overlaps the passed
///                                             in span; FALSE if none were detected (a
///                                             \free .... \free* section with no content
///                                             would be regarded as a free translation
///                                             section and would cause TRUE to be
///                                             returned)
/// \remarks
/// Called from: The View's OnEditSourceText(). Gets the starting and ending sequence
/// numbers of any free translation within the span. "Leftwards" in this function is to be
/// interpretted as "to lower sequence numbers", & so if we are dealing with a
/// right-to-left language data, it would be rightwards to the user. Free translations are
/// defined over document 'sections', and there is no reason why we could assume that the
/// boundaries of the user's selection for edit purposes would coincide with the start of a
/// free translation section and the end of that or another free translation section. In
/// general, if free translations are present then there is a real possibility that the one
/// or more whole free translations defined over the user's selection will start earlier
/// than his selection, and end later; but we can't be sure of that because the free
/// translations might happen to end partway through the user's selection simply because
/// he's not yet managed to free translation past that point yet. So this function works
/// out the span of CSourcePhrase instances which have retranslations defined over them,
/// and makes sure the span starts at the start of the free translation or the passed in
/// nStartingSN value, whichever is lesser, and ends at the end of a whole free translation
/// section at higher sequence number than nEndingSN, or at nEndingSN if there was no free
/// translation at the end of the passed in span, whichever is the case.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetEditSourceTextFreeTranslationSpan(SPList* pSrcPhrases, 
						int& nStartingSN, int& nEndingSN,int& nStartingFreeTransSequNum, 
						int& nEndingFreeTransSequNum, bool& bFreeTransPresent)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// 22Apr08, BEW added this function 
	bFreeTransPresent = FALSE;
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nStartingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in GetEditSourceTextFreeTranslationSpan(), pos value is NULL. Saving document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* savePos = pos; // we may need this if we need to verify 
            // there are no editable span internal free translation sections (which don't
            // reach either end)

	// initialize the nStartingFreeTransSequNum value to the passed in nStartingSN value
	nStartingFreeTransSequNum = nStartingSN;

	pSrcPhrase = pos->GetData();
	pos = pos->GetPrevious();
	gEditRecord.bSpecialText = pSrcPhrase->m_bSpecialText; // store the special text
													// value in the global EditRecord
	if (pSrcPhrase->m_bHasFreeTrans)
	{
        // the first pile's word or phrase which is to be shown to the user as editable,
        // has a free translation defined on it; so scan back to the start of that free
        // translation if the current pile is not the beginning of the free translation
        // section
		bFreeTransPresent = TRUE;
		if (!pSrcPhrase->m_bStartFreeTrans)
		{
			// the current pile is not the beginning of the section, 
			// so scan to lower sequ numbers
			while (pos != NULL)
			{
				// get the previous CSourcePhrase at the new POSITION
				pSrcPhrase = pos->GetData();
				pos = pos->GetPrevious();
				nStartingFreeTransSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bStartFreeTrans)
				{
					// we are at the start of the free translation section, so break out
					break;
				}
			}
		}
	} // end of block for test pSrcPhrase->m_bHasFreeTrans == TRUE

    // We have established the nStartingSN value, now we need to work out if at the
    // CSourcePhrase instance indexed by the nEndingSN value (the last one whose source
    // text data will be made visible to the user for editing purposes) also has a free
    // translation defined on it, and if it has, then whether or not the free translation
    // ends there - if so, we are done, or if there is no free translation there we are
    // done; but if either is not the case, we must continue scanning to higher sequence
    // numbers until we find the end of that particular free translation section

	// initialize the nEndingFreeTransSequNum value to the passed in nEndingSN value
	nEndingFreeTransSequNum = nEndingSN;

	pos = pSrcPhrases->Item(nEndingSN);
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in GetEditSourceTextFreeTranslationSpan(), pos value is NULL, for index nEndingSN. Saving document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	pSrcPhrase = pos->GetData();
	pos = pos->GetNext();
	if (pSrcPhrase->m_bHasFreeTrans)
	{
        // the last pile's word or phrase which is to be shown to the user as editable, has
        // a free translation defined on it; so scan forward to the end of that free
        // translation if the current pile is not the end location of that free translation
        // section
		bFreeTransPresent = TRUE;
		if (!pSrcPhrase->m_bEndFreeTrans)
		{
			// the current pile is not the end of the section, 
			// so scan to higher sequ numbers
			while (pos != NULL)
			{
				// get the CSourcePhrase at the new POSITION
				pSrcPhrase = pos->GetData();
				pos = pos->GetNext();
				nEndingFreeTransSequNum = pSrcPhrase->m_nSequNumber;
				if (pSrcPhrase->m_bEndFreeTrans)
				{
					// we are at the end of the free translation section, so break out
					break;
				}
			}
		}
	} // end of block for test pSrcPhrase->m_bHasFreeTrans == TRUE

	if (!bFreeTransPresent)
	{
		// we found no free translation at the start or end of the editable span, but
		// that does not mean that there is no free translation defined within the span,
		// so scan across the span to verify that there really is none defined on it
		pos = savePos; // restore editable span's beginning POSITION
		int width = nEndingSN - nStartingSN + 1;
		int index;
		for (index = 0; index < width; index++)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			if (pSrcPhrase->m_bHasFreeTrans)
				bFreeTransPresent = TRUE;
		}
	}

    // set the flag in the EditRecord which later, entering freeTranslationsStep,
    // allows us to get the original value of the app class's BOOL member,
    // m_bDefineFreeTransByPunctuation set back to its earlier value (mostly that should
    // happen), so the user most of the time will not have to manually resize the section
	gEditRecord.bVerseBasedSection = GetLikelyValueOfFreeTranslationSectioningFlag(
										pSrcPhrases,nStartingFreeTransSequNum,
										nEndingFreeTransSequNum,bFreeTransPresent);
	return TRUE; // there was no error
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error; FALSE if there was an error
/// \param      pScrPhrases		->	pointer to m_pSrcPhrases list defined on the App
/// \param      nStartingSN		->	reference to the sequence number for the first 
///                                 pile in the span which is to have its source text shown
///                                 to the user (this could be more than the user's
///                                 original selection, if extension was done because of
///                                 the presence of a retranslation or even more than one
///                                 retranslation)
/// \param nEndingSN            -> reference to the sequence number for the last pile in 
///                                the span referred to by the preceding parameter's
///                                comment 
/// \param      nStartingFreeTransSequNum	-> 	ref to the start of any free translation 
///                                             found at the start of the above span, or if
///                                             there were no free translation there, then
///                                             it is -1
/// \param      nEndingFreeTransSequNum		-> 	ref to the end of any free translation 
///                                             found at the end of the above span, or if
///                                             there were no free translation there, then
///                                             it is -1
/// \param      nStartingBackTransSequNum	<- 	ref to the first back translation deemed to 
///                                             overlap or be within the passed in
///                                             nStartingSequNum to nEndingSequNum span;
///                                             return -1 if no back translation span was
///                                             able to be defined for the passed in
///                                             editable span
/// \param      nEndingBackTransSequNum		<- 	ref to the last CSourcePhrase location in 
///                                             the final (or only) back translation
///                                             section deemed to overlap the end of the
///                                             passed in editable span given by
///                                             nStartingSequNum to nEndingSequNum; return
///                                             -1 if no back translation span was able to
///                                             be defined for the passed in editable span
/// \param      bHasBackTranslations		<- 	ref to BOOL to inform caller that the span 
///                                             has at least one collected back translation
///                                             defined on it (even if the collected \bt
///                                             marker's content was empty)
/// \param	bCollectedFromTargetText	    <-	ref to BOOL to inform caller which line the 
///                                             original collection was done from, return
///                                             TRUE if from the target text line, FALSE if
///                                             from the glossing line
/// \remarks
/// Called from: The View's OnEditSourceText(). Gets the starting and ending sequence
/// numbers of any back translation within the span. Note: parameters 2 to 7 reference
/// members in the struct gEditRecord, and of those 2 to 5 should have been set already, or
/// set to -1 if inapplicable, by previous function calls). "Leftwards" in this function is
/// to be interpretted as "to lower sequence numbers", & so if we are dealing with a
/// right-to-left language data, it would be rightwards to the user. The intent of this
/// function is to define the start and end of a span in which there is one or more
/// collected back translations overlapping any or all of the editable span defined by
/// nStartingSN to nEndingSN values. This is tricky to do, because collection does not
/// occur from CSourcePhrase instances which have certain TextTypes (footnote -- used for
/// true footnotes and also for endnotes, crossReference, and markers with TextType of
/// none), but such material could be selected wholely or in part by the user. These
/// possibilities complicate the algorithm. Back translation markers (\bt or any marker
/// starting with \bt) have to eventually be removed, and their contents thrown away, by
/// another function which the caller calls. Members of gEditRecord are set by being passed
/// in directly. In the algorithm described below, we speak of "halt locations" - these are
/// the CSourcePhrase instances where the view class's HaltCurrentCollection() function
/// returns; the function returns TRUE if a SF marker has been found which is of the kind
/// deemed able to halt the collecting operation, FALSE if collecting should continue, and
/// the function also returns, via its parameter list, whether or not the marker which
/// halted collection was a \bt type of marker. Because HaltCurrentCollection() has all the
/// smarts we need for the present function, we'll use it in the algorithms described below
/// - so that the collection halting criteria are the same over all code for collecting
/// back translations within the application. (Back translation sections don't have a
/// terminating endmarker, and so it is not a simple matter to work out what the span of
/// any \bt marker happens to be, and the CSourcePhrase instances in any such span have no
/// flag indicating they belong to a \bt section, except that the first of them stores, in
/// m_markers the filtered back translation itself.)
/// 
/// Note 1: nStartingBackTransSequNum value is not necessarily the same as the starting
/// value of either the editable span nor any free translation span that was earlier
/// defined. (The design also does not require the back translation span subsume the free
/// translation span or the editable span - the ends of all these can be different.)
/// 
/// Note 2. gEditRecord preserves the span involved in back translation deletions, so if
/// the user elects to have recollection done, we can then use the stored locations and the
/// new length of the edited source text to work out the span over which the collection
/// operation has to be automatically done.
/// 
/// To understand the algorithm used in GetEditSourceTextBackTranslationSpan(), it is best
/// to break it up into 5 sequential sub-algorithms as follows:
/// 
/// 1. Determine the starting location (a sequence number) for the first \bt marker
/// destined for removal
/// 
/// 2. Determine where to scan forward from - it will be the location found in 1. if a back
/// translation was actually found by 1.'s algorithm, but if none was found, we start
/// scanning at the start of the editable span
/// 
/// 3. Halt locations are examined wherever the back translation collect operation would
/// have halted during the collection operation which defined the back translation spans
/// found in the current document. At these halt locations nothing is done if no \bt or
/// \bt-derived marker has yet been found, but if one has been found, then we check for
/// presence of another \bt and remove it if we find one there and we are not at that point
/// past the end of the editable span. Also we maintain a boolean flag,
/// bHasBackTranslations which we set only if we find a \bt or \bt-derived marker at some
/// point in all this, and its span does not halt before the start of the editable span,
/// and that marker is not stored at some location after the editable span (because if it
/// was, its back translation would remain valid no matter what editing the user did within
/// the text shown to him for editing).
/// 
/// 4. Eventually scanning will come to the last CSourcePhrase instance in the editable
/// span, here we must test whether the bHasBackTranslations flag has been set yet, and
/// whether or not it is a halt location, and if it is a halt location, whether or not
/// another \bt marker (or the first such marker if none was found up to that point) is
/// stored there. Depending on the results of these tests, we either declare there is no
/// collected backtranslation defined on any part of the editable span, or the span we are
/// defining ends there, or it ends at a halt location further along which has to now be
/// found.
/// 
/// 5. Find the final halt location if within 4. it could not be determined.
/// 
/// The appropriate value of bHasBackTranslations is then returned to the caller, where it
/// is used to set or clear the gEditRecord member bEditSpanHasBackTranslations, and if the
/// the latter is cleared, the caller will also reset the struct's
/// nStartingBackTransSequNum and nEndingBackTransSequNum values to -1.
///
/// History:
/// 23Apr08, BEW added this function
/// 26Oct08, BEW added code to return the correct bCollectedFromTargetText BOOL value
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetEditSourceTextBackTranslationSpan(
                                    SPList*	pSrcPhrases, 
									int&	nStartingSN, 
									int&	nEndingSN,
                                    int&	WXUNUSED(nStartingFreeTransSequNum), 
									int&	WXUNUSED(nEndingFreeTransSequNum),
									int&	nStartingBackTransSequNum, 
									int&	nEndingBackTransSequNum, 
									bool&	bHasBackTranslations, 
									bool&	bCollectedFromTargetText)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// 23Apr08, BEW added this function 
    // use BOOL CAdapt_ItView::HaltCurrentCollection(CSourcePhrase* pSrcPhrase, BOOL&
    // bFound_bt_mkr) as the way, when scanning forward, to determine halt locations - and
    // remember that the last CSourcePhrase instance within the span thus delineated is the
    // one which precedes the halt location (the halt location is actually the kick off
    // location for a new collection span, as it stores the marker which lead to the halt,
    // and is the place where the next filtered collected back translation would be stored)
	bHasBackTranslations = FALSE;
	bool bFound_bt_mkr = FALSE;
	bool bIsHaltLocation = FALSE;
	bool bItsHereAnyway = FALSE;
	//EditRecord* pRec = &gEditRecord; // get a local pointer to the  // unused
									// EditRecord global struct
	wxString markers;
	nStartingBackTransSequNum = -1; // initialize to 'no value set'
	nEndingBackTransSequNum = -1; // ditto
	bool bCollectionLineTestCompleted = FALSE; // set TRUE when 
        // IsCollectionDoneFromTargetTextLine() has been called once, so that we can
        // suppress later calls which might destroy the returned value already obtained by
        // the first call

	int nIteratorSN = nStartingSN; // start from the commencement of the editable span
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nIteratorSN);
    // no error is expected, but we'll check and abort the edit with an English message if
    // a valid pos was not found, but do a save to retain user's work; the document
    // structures are still unchanged
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in GetEditSourceTextBackTranslationSpan(), pos value is NULL. Saving document. Abandoning edit."),
		 _T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* savePos = pos; // keep for when we later scan forwards
	pSrcPhrase = pos->GetData();
	pos = pos->GetPrevious();

    // The collection operation for back translations does no collecting of filtered
    // information which is inLine, & has a TextType of footnote, or crossReference; these
    // are for things such as footnotes, endnotes, cross references, and we don't allow
    // Adapt It notes' text to be collected. The user could do a selection in things like
    // visible footnotes, endnotes or cross references, but not AI Notes. But the AI
    // interface will not accept selection attempts across a TextType boundary (except for
    // verse and poetry) and so we can be sure than any selection made will be wholely
    // within the one text type. Since there won't be any \bt marker defined on such spans,
    // we must make the function check for a selection within these information types
    // (checking the first CSourcePhrase instance of the user's selection suffices) and if
    // that is where the selection was done, we exit without setting up any bt span
	TextType aType = pSrcPhrase->m_curTextType;
	if (aType == footnote || aType == crossReference)
		return TRUE;

    // check if this first CSourcePhrase in the editable span is a halt location, and if it
    // is, whether or not a \bt marker is stored there; even if not a halt location, we
    // still must check for the presence of a \bt marker there because using a selection
    // the user is able to force any CSourcePhrase instance to be the start of a back
    // translation collection span and hence the place where the back translation text for
    // that span would be stored, so use ContainsBtMarker() to check for that possibility
    // as well
	bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
	if (bIsHaltLocation)
	{
        // its a halt location, so any bt span will either start here (if bFound_bt_mkr is
        // TRUE) or will start at a later location, or not at all; whichever is the case we
        // don't have to scan back (to lower sequence numbers) to get the start of any
        // potential bt span because any prior one will have terminated its collection at
        // the CSourcePhrase instance preceding this current location, and so that one's
        // back translation cannot be affected by the user's editing of the text shown to
        // him
		if (bFound_bt_mkr)
		{
			// the \bt deletion subspan starts here
			nStartingBackTransSequNum = nIteratorSN;
			bHasBackTranslations = TRUE;
		}
	}
	else
	{
        // it's not a halt location, but nevertheless a collection could have been manually
        // forced here in some earlier session, so we must check for that; otherwise, we
        // must scan back to the first previous halt location to see if there is a \bt
        // stored there - if so, that would be the start of the bt deletion span we are
        // trying to delimit
		bItsHereAnyway = ContainsBtMarker(pSrcPhrase);
		if (bItsHereAnyway)
		{
			// the \bt deletion subspan starts here
			nStartingBackTransSequNum = nIteratorSN;
			bHasBackTranslations = TRUE;
		}
		else
		{
			// scan back to see if there is a \bt at the previous halt location, 
			// it would start the subspan
			while (pos != NULL)
			{
				pSrcPhrase = pos->GetData();
				pos = pos->GetPrevious();
				nIteratorSN = pSrcPhrase->m_nSequNumber;
				bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
				if (bIsHaltLocation)
				{
					if (bFound_bt_mkr)
					{
						// we have found the location where the \bt deletion span starts
						nStartingBackTransSequNum = nIteratorSN;
						bHasBackTranslations = TRUE;
						break;
					}
					else
					{
                        // there is no \bt marker at this halt location, so we can assume
                        // that in this part of the document there is no back translation
                        // data collected here - just prior to the start of the editable
                        // span
						break;
					}
				} // end of block for test:  bIsHaltLocation == TRUE
				else
				{
                    // it's not a halt location, but still check for storage of \bt
                    // manually forced to be here; otherwise do next iteration of the loop
					bItsHereAnyway = ContainsBtMarker(pSrcPhrase);
					if (bItsHereAnyway)
					{
						// the bt deletion span starts here
						nStartingBackTransSequNum = nIteratorSN;
						bHasBackTranslations = TRUE;
						break;
					}
				}
			} // end of while loop with pos != NULL test
		} // end of else block for test: bItsHereAnyway == TRUE
	} // end of else block for bIsHaltLocation == TRUE test

    // that finishes the first stage of the overall algorithm; when control gets here,
    // either nStartingBackTransSequNum has been set to a non-negative sequence number
    // value for the start of the back translation deletion span; or it is still -1 because
    // no beginning for such a span has been detected at or prior to the start of the
    // editable span. Now we commence the subalgorithm number 2, which is to determine the
    // location for scanning forward
	if (bHasBackTranslations)
	{
		nIteratorSN = nStartingBackTransSequNum;
		pos = pSrcPhrases->Item(nIteratorSN);
		wxASSERT(pos != NULL); // we'll assume FindIndex() won't fail, 
							   // so just ASSERT for a debug mode check
		pSrcPhrase = pos->GetData();// get the pos for next POSITION
		pos = pos->GetNext();

		// BEW added 26Oct08
		bCollectedFromTargetText = IsCollectionDoneFromTargetTextLine(pSrcPhrases,
														nStartingBackTransSequNum);
		bCollectionLineTestCompleted = TRUE; // use TRUE value to suppress subsequent 
											 // calls of above function
	}
	else
	{
		// no \bt found yet, so start scanning forward 
		// from the start of the editable span
		nIteratorSN = nStartingSN;
		pos = savePos;
		wxASSERT(pos);
	}
    // that finishes subalgorithm number 2, commence subalgorithm number 3 in which we scan
    // forward looking for halt locations and manually assigned \bt storage locations prior
    // to coming to the end of the editable span
	bool bBtMarkerFoundAtEndOfEditableSpan = FALSE;
	bool bEndOfEditableSpanIsAHaltLocation = FALSE;
	while (pos != NULL)
	{
		// get the CSourcePhrase data for the current pos
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nIteratorSN = pSrcPhrase->m_nSequNumber;
		bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
		if (bIsHaltLocation)
		{
			// it's a halt location, so check out whether \bt is there, etc
			if (bFound_bt_mkr)
			{
                // a \bt marker was found here, so either the bt deletion span starts here,
                // or this is another collection storage point for back translations which
                // happens to be located within the editable span of source text shown to
                // the user
				bHasBackTranslations = TRUE;
				if (nIteratorSN == nEndingSN)
				{
					// this \bt marker was stored at the very end of the editable span,
					// we need to know this when the loop is exitted
					bBtMarkerFoundAtEndOfEditableSpan = TRUE;
					bEndOfEditableSpanIsAHaltLocation = TRUE;
				}
				if (nStartingBackTransSequNum == -1)
				{
					// the bt deletion span has not been commenced yet, so start it here
					nStartingBackTransSequNum = nIteratorSN;
				}

				// BEW added 26Oct08
				if (!bCollectionLineTestCompleted)
				{
					bCollectedFromTargetText = IsCollectionDoneFromTargetTextLine(
															pSrcPhrases,nIteratorSN);
					bCollectionLineTestCompleted = TRUE; // use TRUE value to suppress 
												// subsequent calls of above function
				}
			}
			// if no \bt marker was found, we continue looping
		}
		else
		{
            // not a halt location, but there may be a \bt marker nevertheless because the
            // user at some earlier time manually forced a collection to be stored here
			bItsHereAnyway = ContainsBtMarker(pSrcPhrase);
			if (bItsHereAnyway)
			{
                // a \bt marker was found here, so either the \bt deletion span starts
                // here, or this is another collection storage point for back translations
                // which happens to be located within the editable span of source text
                // shown to the user
				bHasBackTranslations = TRUE;
				if (nIteratorSN == nEndingSN)
				{
					// this \bt marker was stored at the very end of the editable span,
					// we need to know this when the loop is exitted
					bBtMarkerFoundAtEndOfEditableSpan = TRUE;
				}
				if (nStartingBackTransSequNum == -1)
				{
					// the bt deletion span has not been commenced yet, so start it here
					nStartingBackTransSequNum = nIteratorSN;
				}

				// BEW added 26Oct08
				if (!bCollectionLineTestCompleted)
				{
					bCollectedFromTargetText = IsCollectionDoneFromTargetTextLine(
																pSrcPhrases,nIteratorSN);
					bCollectionLineTestCompleted = TRUE; // use TRUE value to suppress 
												// subsequent calls of above function
				}
			}
		}
		// if we are at the end of the editable span then exit this loop
		if (nIteratorSN == nEndingSN)
		{
			break;
		}
	} // end of while loop with test pos != NULL

    // We are now about to start subalgorithm 4; the loop will have been exitted either
    // because pos is NULL (we've reached the end of the document), or because we've landed
    // at the end CSourcePhrase instance in the editable span. Now we use the booleans
    // defined preceding the last loop, and the other flags and sequence numbers to work
    // out whether we have a bt deletion span being defined, and if so then where to
    // terminate its span, but if not, we return to the caller with appropriate EditRecord
    // values indicating there were no back translations defined over any part of the
    // editable span of text which the user sees for editing purposes
	if (pos == NULL)
	{
		// iterating came to the document's end, the \bt subspan, 
		// if it exists, must end here
		if (!bHasBackTranslations || nStartingBackTransSequNum == -1)
		{
            // the span was never started, so there are no back translations defined over
            // any part of the editable text span
			nStartingBackTransSequNum = -1;
			nEndingBackTransSequNum = -1;
			bHasBackTranslations = FALSE;
			return TRUE;
		}
		else
		{
			// a span is being delineated, so it must end here
			nEndingBackTransSequNum = nIteratorSN;
			bHasBackTranslations = TRUE;
			return TRUE;
		}
	}
	else
	{
        // control is not at the end of the document on exit of the loop, so work out what
        // has to be done (this stuff is subalgorithm 5 of the description above)
		if (!bHasBackTranslations || nStartingBackTransSequNum == -1)
		{
            // the span delineation was never started, so there are no back translations
            // defined over any part of the editable text span
			nStartingBackTransSequNum = -1;
			nEndingBackTransSequNum = -1;
			bHasBackTranslations = FALSE;
			return TRUE;
		}
		else
		{
			// a span is being delineated, so work out where it ends
			if (!bBtMarkerFoundAtEndOfEditableSpan && bEndOfEditableSpanIsAHaltLocation)
			{
                // the end CSourcePhrase of the editable span is a halt location and there
                // was no \bt marker stored there, so the end of the current bt span must
                // originally have been at the penultimate instance in the editable span;
                // and there is no collection previously done starting from the end of the
                // editable span
				nEndingBackTransSequNum = nIteratorSN - 1;
			}
			else
			{
                // either there was a \bt marker stored at the very end of the editable
                // span (which implies its collected text was drawn from CSourcePhrase
                // instances lying beyond the end of the editable span - as far as the next
                // halt location), or the current bt collection span doesn't end at the end
                // of the editable span because the latter is not a halt location. In the
                // former case, the \bt subspan will end at the CSourcePhrase instance
                // which is immediately preceding wherever the next halt location is; so we
                // must try to find it. In the latter case, we can't assume we'll find a
                // halt location because we may be editing source text close to or at the
                // end of the document - in this case the best we can do is make the end of
                // the editable span be the end of the back translation span, when the loop
                // below exits
				wxASSERT(pos != NULL);
				while (pos != NULL)
				{
					pSrcPhrase = pos->GetData();
					pos = pos->GetNext();
					nIteratorSN = pSrcPhrase->m_nSequNumber;

					// BEW added 26Oct08
					if (!bCollectionLineTestCompleted)
					{
						bCollectedFromTargetText = IsCollectionDoneFromTargetTextLine(
																pSrcPhrases,nIteratorSN);
						bCollectionLineTestCompleted = TRUE; // use TRUE value to suppress 
													// subsequent calls of above function
					}
					bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
					if (bIsHaltLocation)
					{
						nEndingBackTransSequNum = nIteratorSN - 1; // the location 
														// preceding the halt location
						return TRUE;
					}
				}
                // if control gets to here, then we have no clear idea where to end, so end
                // at end of the editable span
				nEndingBackTransSequNum = nEndingSN;
			}
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      editRec  <- an enum of type EditRecord
/// \remarks
/// Called from: The Doc's OnNewDocument(), OnCloseDocument(), OnOpenDocument(),
/// the View's ClobberDocument(), BailOutFromEditProcess(), OnEditSourceText(), and
/// OnCustomEventEndVerticalEdit().
/// Initializes the gEditRecord global struct's members. The struct members must be
/// initialized when the document is created or reopened for work, and also when closing
/// down the document either using ClobberDocument()(which is called by the document
/// class's OnFileClose() function) or the document class's OnCloseDocument() function; and
/// when closing or opening or creating we also remove the constents of the three deletion
/// lists in the caller after calling InitializeEditRecord(). Note: the
/// deletedAdaptationsList, deletedGlossesList, and DeletedFreeTranslationsList members'
/// contents persist for the life of the current document's RAM presence, and so those
/// lists must empty when the doc is just created or launched and will generally be added
/// to by the user's work, and will only lose their contents when the user or the
/// application at exit time closes the document. Default values are FALSE for booleans,
/// except for one which is better with TRUE as the default, and -1 for integers (meaning
/// "unset"), for TextType the default is verse, and empty for lists (except the deletion
/// lists, which are empty only at the point that the document has just been created or
/// reopened, and emptied again when it is closed).
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::InitializeEditRecord(EditRecord& editRec)
{
	// BEW added 17Apr08
	// first clear the global boolean which tracks whether or not
	// vertical editing is currently happening
	gbVerticalEditInProgress = FALSE;
	// and reset the entry point indicator to the non-edit value
	gEntryPoint = noEntryPoint;

	// now clear EditRecord members which should be cleared once any one
	// instance of vertical editing is completed, or cancelled, or abandoned
	CAdapt_ItDoc* pDoc = (CAdapt_ItDoc*)GetDocument();
	editRec.bGlossingModeOnEntry = FALSE; // default is adaptations mode is 
            // currently ON, even even when it isn't; this is safe because the flag is only
            // looked at when vertical editing is currently in progress, and it's only then
            // that its value is taken seriously
	editRec.bSeeGlossesEnabledOnEntry = FALSE; // default is FALSE, whether on or off, 
										// same reasons apply as for bGlossingModeOnEntry
	editRec.bEditSpanHasAdaptations = FALSE;
	editRec.bEditSpanHasGlosses = FALSE;
	editRec.bEditSpanHasFreeTranslations = FALSE;
	editRec.bEditSpanHasBackTranslations = FALSE;
	editRec.bCollectedFromTargetText = TRUE;
	editRec.nSaveActiveSequNum = -1;
	editRec.nStartingTextType = verse;
	editRec.nEndingTextType = verse;
	editRec.storedNotesList.Clear();
	editRec.nStartingSequNum = -1;
	editRec.nEndingSequNum = -1;
	editRec.nFreeTrans_StartingSequNum = -1;
	editRec.nFreeTrans_EndingSequNum = -1;
	editRec.nBackTrans_StartingSequNum = -1;
	editRec.nBackTrans_EndingSequNum = -1;
	editRec.nCancelSpan_StartingSequNum = -1;
	editRec.nCancelSpan_EndingSequNum = -1;
	pDoc->DeleteSourcePhrases(&editRec.cancelSpan_SrcPhraseList);
	pDoc->DeleteSourcePhrases(&editRec.modificationsSpan_SrcPhraseList);
	pDoc->DeleteSourcePhrases(&editRec.propagationSpan_SrcPhraseList);
    // the editableSpan_NewSrcPhraseList's pointers are not taken over and managed by a
    // section of the document's m_pSourcePhrase list, because the replacement process
    // inserts deep copies into the document list, leaving editableSpan_NewSrcPhraseList
    // unchanged, so we must delete those too
	pDoc->DeleteSourcePhrases(&editRec.editableSpan_NewSrcPhraseList);
	editRec.nPropagationSpan_StartingSequNum = -1;
	editRec.nPropagationSpan_EndingSequNum = -1;
	editRec.arrNotesSequNumbers.Clear();
	editRec.nOldSpanCount = -1;
	editRec.nNewSpanCount = -1;
	editRec.strInitialEndmarkers.Empty();
	editRec.strFinalEndmarkers.Empty();
	editRec.strNewFinalEndmarkers.Empty();
	editRec.bSpecialText = FALSE;
	pDoc->DeleteSourcePhrases(&editRec.follNotesMoveSpanList);
	pDoc->DeleteSourcePhrases(&editRec.precNotesMoveSpanList);
	editRec.bTransferredFilterStuffFromCarrierSrcPhrase = FALSE;
	editRec.bDocEndPreventedTransfer = FALSE;
	editRec.bExtendedForFiltering = FALSE;

	// now the ones unique to the adaptations step
	editRec.bAdaptationStepEntered = FALSE;
	pDoc->DeleteSourcePhrases(&editRec.adaptationStep_SrcPhraseList);
	editRec.nAdaptationStep_StartingSequNum = -1;
	editRec.nAdaptationStep_EndingSequNum = -1;
	editRec.nAdaptationStep_OldSpanCount = -1;
	editRec.nAdaptationStep_NewSpanCount = -1;
	editRec.nAdaptationStep_ExtrasFromUserEdits = 0;

	// now the ones unique to the glosses step
	editRec.bGlossStepEntered = FALSE;
	pDoc->DeleteSourcePhrases(&editRec.glossStep_SrcPhraseList);
	editRec.nGlossStep_StartingSequNum = -1;
	editRec.nGlossStep_EndingSequNum = -1;
	editRec.nGlossStep_SpanCount = -1;

	// now the ones unique to the freeTranslations step
	editRec.bFreeTranslationStepEntered = FALSE;
	editRec.bVerseBasedSection =  FALSE;
	pDoc->DeleteSourcePhrases(&editRec.freeTranslationStep_SrcPhraseList);
	editRec.nFreeTranslationStep_StartingSequNum = -1;
	editRec.nFreeTranslationStep_EndingSequNum = -1;
	editRec.nFreeTranslationStep_SpanCount = -1;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if there was no error, FALSE if something went wrong
/// \param      pSublist	->	pointer to a temporary ordered list of CString instances, 
///                             added in the caller by successive .Append() calls as a 
///                             scan is done from left to right over a span of CSourcePhrase 
///                             instances (typically, in the m_pSourcePhrases list in the 
///                             App class)
/// \param      whichList	->	an enum which specifies the list to store in
/// \param      pRec    	->	pointer to the global EditRecord struct, gEditRecord, which 
///                             contains amongst its members the various wxArrayString 
///                             instances into which the passed in string is inserted
/// \remarks
/// Called from: The View's RestoreNotesAfterSourceTextEdit(), and OnEditSourceText(). This
/// is a helper function for storage of a passed in sublist (either removed adaptations,
/// glosses, free translations, or notes) in the appropriate CStringList within
/// gEditRecord. The sublist is inserted at the head, so that the first removal will be at
/// the top of the final list, the second will be next, and so forth. The final list (the
/// one in gEditRecord, a pointer to which is passed in as the last parameter) is kept to a
/// maximum of DELETIONS_LIST_MAX_ENTRIES which is #defined to be 100 entries, adding extra
/// ones which cause the limit to be exceeded causes the oldest extra entries to drop off
/// the end of the list and be lost. Entries can persist, however, only for the life of the
/// session.
/// 29Apr08 function created as part of refactoring the Edit Source Text functionality
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::InsertSublistAtHeadOfList(wxArrayString* pSublist, ListEnum whichList, EditRecord* pRec)
{
	int numElements = 0;
	wxArrayString* pList = NULL;
	switch (whichList)
	{
	case adaptationsList:
		pList = &pRec->deletedAdaptationsList;
		break;
	case glossesList:
		pList = &pRec->deletedGlossesList;
		break;
	case freeTranslationsList:
		pList = &pRec->deletedFreeTranslationsList;
		break;
	case notesList:
		pList = &pRec->storedNotesList;
		break;
	default:
		return FALSE; // unknown list, must be a bad enum value passed in
	}
    // In wx we don't have an equivalent of AddHead() where one array is being inserted at
    // the head of another array. Wx has Insert() which by default inserts a single item
    // into the arrau at a position n in the array. In this case we want to preserve the
    // original order of the array we're inserting, so we can use Insert() as long as we
    // insert items of the sublist array in reverse order, inserting them at position 0 in
    // the base array. We do the insertions manually.
	int ct;
	for (ct = (int)pSublist->GetCount()-1; ct >= 0; ct--)
	{
		pList->Insert(pSublist->Item(ct),0);
	}
	numElements = pList->GetCount();
	if (numElements > (int)DELETIONS_LIST_MAX_ENTRIES)
	{
		// inserting a sublist can result in several more than the limit being present, so
		// we must find out how many overlong we are and remove the bottommost excess ones
		int extras = numElements - (int)DELETIONS_LIST_MAX_ENTRIES;
		int i;
		wxString removedStr;
		for (i = 0; i < extras; i++)
		{
			//removedStr = pList->RemoveTail();
			// WX Note: wxStringArray does not have RemoveTail(). To remove the last element
			// of the array, we call RemoveAt using an index value of count - 1.
			int nLast;
			nLast = pList->GetCount();
			pList->RemoveAt(nLast - 1);
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the removals were done successfully, or if there were no removals
///             needing to be done; FALSE if a removal attempt failed, or if no edit operation
///             is currently in effect
/// \param      pSrcPhrase	->	pointer to the CSourcePhrase instance from which information 
///                             is to be removed
/// \param      nSequNum	->	the sequence number in m_pSourcePhrases list in the document 
///                             for the pSrcPhrase passed in as first parameter (but it will 
///                             not be the index of the pointer in the caller's sublist 
///                             (the modifications list); rather the value is obtained from 
///                             the pSrcPhrase->m_nSequNumber member)
/// \param      pRec		<->	pointer to the global EditRecord struct, gEditRecord, which 
///                             records spans, lists of CSourcePhrase instances, lists of 
///                             removed strings, starting and ending TextType values, and 
///                             various booleans reflecting the state of the edit process, etc
/// \param      pAdaptList	<->	list for removed adadptations
/// \param      pGlossList	<->	list for removed glosses
/// \param      pFTList	<->	list for removed free translations
/// \param      pNoteList	<->	list for removed notes
/// \param      remAd		->	BOOL indicating whether to remove or retain adaptation 
///                             information
/// \param      remGl		->	BOOLindicating whether to remove or retain gloss information
/// \param      remNt		->	BOOL indicating whether to remove or retain note information
/// \param      remFT		->	BOOL indicating whether to remove or retain free translation 
///                             information
/// \param      remBT		->	BOOL indicating whether to remove or retain back translation 
///                             information
/// \remarks
/// Called from: the View's ScanSpanDoingRemovals().
/// Information which is potentially large and/or invalidated by the edit process (eg.
/// source text editing invalidates the adaptations, glosses, free translations and
/// collected back translations within the span of the edit, and possibly notes stored in
/// the span as well) is removed - collected back translations are abandoned (because they
/// are easily recollected) but the other information types are preserved in lists - the
/// persistence of the data in these lists depends on what is stored: notes are preserved
/// only until, at the end of the edit, they are reconstituted in the document (at possibly
/// different locations, but unchanged content), while free translations, glosses and
/// adaptations are stored for the session, or until the document is closed, or until
/// further information of the same type inserted in the list causes them to drop off the
/// list's bottom - the max list length being given by #define DELETIONS_LIST_MAX_ENTRIES
/// which has the value 100. What information is to be removed is controlled by a set of
/// enum values, because we want to use this function eventually for all vertical editing,
/// not just source text editing. The main reason for removing large information like
/// notes, free translations and collected backtranslations is that these would otherwise
/// be displayed in line in the span of source text being edited, and that would tend to
/// make the source text difficult to find, and be a source of potential confusion or error
/// to a user not expecting to see all filtered information suddenly made visible.
/// 
/// Note: adaptations glosses and notes are removed only from the editable span, any free
/// translations are removed from a span which potentially is larger than the editable
/// span, and back translations are removed from a span which could be considerably larger
/// than that for back translations. Hence the gEditRecord must be checked, for each
/// removal type, to ensure that the passed in pSrcPhrase has a m_nSequNumber value which
/// lies within the span appropriate for whatever marker type's content is being removed,
/// and if CSourcePhrase instance lies outside the appropriate range of sequence numbers,
/// the marker and content are not removed. That member's value is passed in as the
/// nSequNum parameter, and so that is the value which is tested for inclusion in the
/// various kinds of subspan. (The caller does only a single scan across the modification's
/// list's span, so all the required removals have to be done, per passed in pSrcPhrase, as
/// necessary for each span type, in that one pass through the caller's list.)
/// 27Apr08	function created as part of refactoring the Edit Source Text functionality no 
/// list for removed collected back translations, we throw them away & recollect later
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RemoveInformationDuringEdit(CSourcePhrase*	pSrcPhrase, 
												int				nSequNum, 
												EditRecord*		pRec, 
												wxArrayString*	pAdaptList, 
												wxArrayString*	pGlossList, 
												wxArrayString*	pFTList,
												wxArrayString*	pNoteList, 
												bool			remAd, 
												bool			remGl, 
												bool			remNt,
												bool			remFT, 
												bool			remBT)
{
	
	wxString str; // use as a scratch variable
	wxString errStr;
	int nEditableSpanStart;
	int nEditableSpanEnd;
	int nFreeTranslationSpanStart;
	int nFreeTranslationSpanEnd;
	int nBackTranslationSpanStart;
	int nBackTranslationSpanEnd;

	// If there is no current edit operation in effect, return FALSE immediately
	if (!gbVerticalEditInProgress)
	{
		return FALSE;
	}

    // set the sequence numbers which define each span; any undefined span will have both
    // starting and ending values set to -1, but the editable span never has -1 for its
    // indices; each type of removal is valid within only its own span, but the spans
    // potentially overlap significantly or perhaps are each the same span
	nEditableSpanStart = pRec->nStartingSequNum;
	nEditableSpanEnd = pRec->nEndingSequNum;
	nFreeTranslationSpanStart = pRec->nFreeTrans_StartingSequNum;
	nFreeTranslationSpanEnd = pRec->nFreeTrans_EndingSequNum;
	nBackTranslationSpanStart = pRec->nBackTrans_StartingSequNum;
	nBackTranslationSpanEnd = pRec->nBackTrans_EndingSequNum;

	// Note removal and storage is done unilaterally; in many edit situations the note is
	// restored to the same location and the user won't be aware of the temporary removal
	// and restoration; but when source text is edited, note locations can't be guaranteed
	// to remain fixed
    // handle removal of a Note stored here, preserve the note contents in the appropriate
    // CString list, but only do the removal provided the note lies in the editable span
	int nOffset = -1;
	wxString marker = _T("\\note");
	wxString endmarker = _T("\\note*");
	int nContentStartingOffset = -1; // for the function call below, 
									 // needed for RemoveContentWrappers()
	int nContentStringLength = -1; // needed for the function call below, 
								   // but we make no use of it
	if (nSequNum >= nEditableSpanStart && nSequNum <= nEditableSpanEnd)
	{
		if (remNt)
		{
            // do this only if removal of notes has been requested, and a note is stored on
            // this pSrcPhrase (remove even if the note's contents is itself an empty
            // string, but don't put an empty note into the wxArrayString in gEditRecord --
            // the user would probably not care about the fact that there will later be no
            // reconstruction of the empty note, and certainly Adapt It shouldn't care that
            // it has disappeared)
			nOffset = pSrcPhrase->m_markers.Find(marker);
			if (nOffset != -1)
			{
                // there is a note stored here (beware, its contents may have been cleared
                // out by user action earlier, so we can't be certain there is any content
                // for the note between \note and \note*, but at least the markers are
                // present)
				str = GetExistingMarkerContent(marker,endmarker, pSrcPhrase,
										nContentStartingOffset, nContentStringLength);
				RemoveFinalSpaces(str);
				// remove this note from the passed in CSourcePhrase instance
				RemoveContentWrappers(pSrcPhrase,marker,nContentStartingOffset); 
                // if the content is an empty string, we don't insert it in the list, but
                // if not we must insert it so the end of the source text edit process can
                // reinsert it somewhere appropriate (we can't guarantee the final location
                // will be as meaningful as the original location, but the user can later
                // move it very easily; Adapt It will therefore just do the best it can
                // when it comes to choosing where to relocate it)
				if (!str.IsEmpty())
				{
					size_t Inspos = pNoteList->Add(str);
					if ((int)Inspos == -1)
					{
						// the .AddTail() call failed, so bail out of 
						// this edit process with a message to the user - we expect this
						// never to happen, so it can be an English hard-coded message
						errStr = _T(".Add() for note string, failed. ");
						errStr += _T(
						"Edit process abandoned. Document restored to pre-edit state.");
						wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
						return FALSE;
					}

                    // preserve the Note's former location in the CArray in gEditRecord, to
                    // help us later on restore the Note in a similar location as far as
                    // possible
					pRec->arrNotesSequNumbers.Add(nSequNum);

				} // end block for testing for non-empty str
			} // end block for having tested for a \note marker and found one
		}
	}

	// which actions of the total edit process are to be done depend on what the entry
	// condition was, whether editing source, adaptation, gloss, etc. In the MFC app,
	// we support only the editingSourceText entry point. In the wxWidgets port,
	// the other entry points as in the switch will be supported, and vertical editing
	// supported right across the application's modalities.
	switch (gEntryPoint)
	{
		case sourceTextEntryPoint:
			goto s;
		case adaptationsEntryPoint:
			goto a;
		case glossesEntryPoint:
			goto g;
		case freeTranslationsEntryPoint:
			goto f;
		case noEntryPoint: // not expected and would imply an error occurred
		default:
		{
			errStr = _T(
			"gEntryPoint was undefined in RemoveInformationDuringEdit() function. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			return FALSE; // indicate an error state
		}
	}

	// find the adaptation & if non-empty transfer a copy to the temporary string list
	// for later insertion in the string list wtihin pRec (done in the caller); but only
	// provided this CSourcePhrase instance passed in is within the editable span
s:	if (nSequNum >= nEditableSpanStart && nSequNum <= nEditableSpanEnd)
	{
		// (to save time we don't bother to actually remove, but just save a copy)
		if (remAd)
		{
			// do this only if removal of adaptations has been requested, and the
			// adaptation is not an empty string
			if (!pSrcPhrase->m_adaption.IsEmpty())
			{
				// there is some adaptation text that can be copied, so do so, etc
				str = pSrcPhrase->m_adaption; // copy punctuation-less m_adaption member
				size_t Inspos = pAdaptList->Add(str);
				if ((int)Inspos == -1)
				{
					// the AddTail() call failed, so bail out of 
					// this edit process with a message to the user - we expect this
					// never to happen, so it can be an English hard-coded message
					errStr = _T(".Add() for adaptation string, failed. ");
					errStr += _T(
					"Edit process abandoned. Document restored to pre-edit state.");
					wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
					return FALSE;
				}
			}
		}
	}
    // find the gloss, if it exists, & if non-empty transfer a copy to the temporary string
    // list for later insertion in the string list wtihin pRec (done in the caller); but
    // only provided this CSourcePhrase instance passed in is within the editable span
a:	if (nSequNum >= nEditableSpanStart && nSequNum <= nEditableSpanEnd)
	{
		// (we don't bother to remove, just do the copy)
		if (remGl)
		{
			// do this only if removal of glosses has been requested, and the gloss
			// is not an empty string, and the caller has determined there is at least
			// one gloss somewhere in the span to which this CSourcePhrase belongs
			if (pRec->bEditSpanHasGlosses)
			{
				if (!pSrcPhrase->m_gloss.IsEmpty())
				{
					// there is some gloss text that can be copied, so do so, etc
					str = pSrcPhrase->m_gloss;
					size_t Inspos = pGlossList->Add(str);
					if ((int)Inspos == -1)
					{
						// the .AddTail() call failed, so bail out of 
						// this edit process with a message to the user - we expect this
						// never to happen, so it can be an English hard-coded message
						errStr = _T(".Add() for gloss string, failed. ");
						errStr += _T(
						"Edit process abandoned. Document restored to pre-edit state.");
						wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
						return FALSE;
					}
				}
			}
		}
	}
    // next, do any free translation removal & transfer it to the temporary string list in
    // the caller, but only do it if the CSourcePhrase is within the free translation span;
    // also clear the three free translation-related flags
g:	nOffset = -1;
	marker = _T("\\free");
	endmarker = _T("\\free*");
	nContentStartingOffset = -1; // for the function call below, 
								 // needed for RemoveContentWrappers()
	nContentStringLength = -1; // needed for the function call below, 
							   // but we make no use of it
	if ((nFreeTranslationSpanStart != -1 && nSequNum >= nFreeTranslationSpanStart) && 
		(nFreeTranslationSpanEnd != -1 && nSequNum <= nFreeTranslationSpanEnd))
	{
		if (remFT)
		{
            // do this only if removal of free translations has been requested, and the
            // free translation is actually stored on this pSrcPhrase (remove even if the
            // free translation is itself an empty string, but don't put an empty free
            // translation into the CStringList in gEditRecord)
			if (pRec->bEditSpanHasFreeTranslations)
			{
                // there may be a free translation stored here, if so remove it and insert
                // it at the head of the caller's temporary list for retaining removed free
                // translations for later insertion in the similar list in gEditRecord
				nOffset = pSrcPhrase->m_markers.Find(marker);
				if (nOffset != -1)
				{
                    // there is a free translation section stored here (beware, its
                    // contents may have been cleared out by user action earlier, so we
                    // can't be certain there is a storable free translation between \free
                    // and \free*, but at least the markers are present)
					str = GetExistingMarkerContent(marker,endmarker, pSrcPhrase,
										nContentStartingOffset, nContentStringLength);
					RemoveFinalSpaces(str);
					// remove this free translation from the passed in CSourcePhrase
					// instance
					RemoveContentWrappers(pSrcPhrase,marker,nContentStartingOffset); 
                    // if the content is an empty string, we don't insert it in the list,
                    // but if not we must insert it so the user later has a chance to reuse
                    // it and/or modify it
					if (!str.IsEmpty())
					{
						size_t Inspos = pFTList->Add(str);
						if ((int)Inspos == -1)
						{
                            // the .Add() call failed, so bail out of this edit process
                            // with a message to the user - we expect this never to happen,
                            // so it can be an English hard-coded message
							errStr = _T(".Add() for free translation string, failed. ");
							errStr += _T(
							"Edit process abandoned. Document restored to pre-edit state.");
							wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
							return FALSE;
						}
					} // end block for testing for non-empty str
				} // end block for having tested for a \free marker and found one

                // clear the three flags; this ensures that if the user edits considerably
                // - especially within the adaptations step, then the free translation
                // step's update will do the required resegmenting to comply with the
                // result of those edits
				pSrcPhrase->m_bHasFreeTrans = FALSE;
				pSrcPhrase->m_bStartFreeTrans = FALSE;
				pSrcPhrase->m_bEndFreeTrans = FALSE;

			} // end block for testing for presence of free translations in the editable span
		}
	}
    // handle removal of any collected back translation stored on this CSourcePhrase
    // instance, provided the passed in CSourcePhrase instance lies within the back
    // translation span
f:	nOffset = -1;
	marker = _T("\\bt"); // also handles any \bt-derived marker, such as \btv, \bts, etc
	endmarker.Empty();
	nContentStartingOffset = -1; // for the function call below, 
								 // needed for RemoveContentWrappers()
	nContentStringLength = -1; // needed for the function call below, 
							   // but we make no use of it
	if ((nBackTranslationSpanStart != -1 && nSequNum >= nBackTranslationSpanStart) && 
		(nBackTranslationSpanEnd != -1 && nSequNum <= nBackTranslationSpanEnd))
	{
		if (remBT)
		{
            // do this only if removal of back translations has been requested, and the
            // back translation is present on this pSrcPhrase (remove even if the back
            // translation is itself an empty string, but don't put an empty back
            // translation into the CStringList in gEditRecord)
			if (pRec->bEditSpanHasBackTranslations)
			{
                // there may be a back translation stored here, if so remove it and insert
                // it at the head of the list for retaining removed back translations in
                // gEditRecord
				nOffset = pSrcPhrase->m_markers.Find(marker);
				if (nOffset != -1)
				{
                    // there is a collected back translation section stored here (beware,
                    // its contents may have been cleared out by user action earlier, so we
                    // can't be certain there is a back translation between \bt and the
                    // next \~FILTER* marker, but at least the marker is present)
					str = GetExistingMarkerContent(marker,endmarker,pSrcPhrase,
										nContentStartingOffset, nContentStringLength);
                    // remove this back translation from the passed in CSourcePhrase
                    // instance and throw it away (as we can programmatically recollect as
                    // the last step of the edit process, so no need to store it)
					RemoveContentWrappers(pSrcPhrase,marker,nContentStartingOffset);
					str.Empty();
				} // end block for having tested for a \bt marker and found one, 
				  // or a \bt-derived one
			} // end block for testing for presence of 
			  // back translations in the editable span
		}
	}
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the removals were done successfully, or if there were no removals
///             needing to be done; FALSE if a removal attempt failed, or if no edit 
///             operation is currently in effect
/// \param      pSrcPhrase	->	pointer to the modifications list, a SPList, within 
///                             gEditRecord, where the modifiable deep copied 
///                             CSourcePhrase instances are stored temporarily (there are
///                             potentially many more instances in this list than belong 
///                             within the editable span, because of the possibility of 
///                             span expansion due to the presence of free and/or back 
///                             translations)
/// \param      pRec		<->	pointer to the global EditRecord struct, gEditRecord, 
///                             which records edit spans, lists of CSourcePhrase
///                             instances, lists of removed strings, starting and ending
///                             TextType values, and various booleans reflecting the state
///                             of the edit process
/// \param      pAdaptList	->	an empty list which is to receive any removed adaptations
/// \param      pGlossList	->	an empty list which is to receive any removed glosses
/// \param      pFTList		->	an empty list which is to receive any removed free
///                             translations 
/// \param      pNoteList	->	an empty list which is to receive any removed notes
/// \remarks
/// Called from: the View's OnEditSourceText().
/// Scans a span of Source Phrases and removes adaptations, glosses, free translations and
/// notes storing them in lists for later processing and incorporation into the document
/// after the user edits the source text. Iterating forward it starts from the end of the
/// sublist, but removals are potentially done only from the CSourcePhrase instances which
/// fall within the appropriate span. The internal function call,
/// RemoveInformationDuringEdit(), has all the smarts needed so that it removes each
/// information type only in the subspan appropriate for that type. Information removed is
/// stored in lists, within gEditRecord, except that removed back translations are
/// abandoned because they can be re-collected automatically (once the user indicates which
/// line of the strips to collect from) at the end of the edit process. (While we could
/// remove adaptations and glosses that are within the editable span, there is really no
/// need because their parent CSourcePhrase instances will be recreated from the edited
/// source text and will replace the older ones, so we will leave them in place in order to
/// save processing time, and just put copies in the storage lists for these two types of
/// information.)
/// 
/// Note: this function does nothing to the CSourcePhrase instances stored in the App
/// class's m_pSourcePhrases list, so if there is an error herein, the document is still
/// intact on return.
/// 19May08	function created as part of refactoring the Edit Source Text functionality
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ScanSpanDoingRemovals(SPList* pSrcPhrases, EditRecord* pRec,
							wxArrayString* pAdaptList, wxArrayString* pGlossList,
							wxArrayString* pFTList, wxArrayString* pNoteList)
{
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->GetFirst();
	bool bAllWasOK = TRUE;
	// no error is expected, but we'll check and abort the app with an English message
	// if a valid pos was not found, but do a save to retain user's work
	if (pos == NULL)
	{
		// whm: No need to localize the following error message.
		wxMessageBox(_T(
"GetHeadPosition() failed in ScanSpanDoingRemovals(), pos value is NULL. Saving document, abandoning edit."),
		_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

	// scan over the modifications span
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
        // do the smart information removals for this pSrcPhrase, but for adaptations and
        // glosses, place copies in the respective lists, but don't do any removals; the
        // pRec parameter passes in the knowledge of where the various subspans (editable
        // span, free translation span, collected back translations span) begin and end
		bAllWasOK = RemoveInformationDuringEdit(pSrcPhrase, pSrcPhrase->m_nSequNumber, 
									pRec, pAdaptList, pGlossList, pFTList, pNoteList, 
									TRUE, TRUE, TRUE, TRUE, TRUE);
		if (!bAllWasOK)
		{
			// whm: No need to localize the following error message.
			wxMessageBox(_T(
"RemoveInformationDuringEdit() returned FALSE in loop within ScanSpanDoingRemovals(). Saving document, abandoning edit."),
			_T(""), wxICON_EXCLAMATION);
			return FALSE;
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the reconstruction was done successfully, FALSE if the 
///             reconstruction attempt failed, or if no edit operation is currently 
///             in effect
/// \param      pSrcPhrase	->	pointer to the deep copied sublist of CSourcePhrase
///                             instances found in modifications list, (but only that
///                             subspan of it which is the editable span is actually 
///                             used for the reconstrution)
/// \param      pRec		<->	pointer to the global EditRecord struct, gEditRecord,
///                             which records edit spans, lists of CSourcePhrase
///                             instances, lists of removed strings, starting and ending
///                             TextType values, and various booleans reflecting the state
///                             of the edit process, etc.
/// \param      nStartingSN	->	the sequence number value in pSrcPhrases where the
///                             editable span commences (note: the CSourcePhrase's
///                             m_nSequNumber member has to be examined, not the index for
///                             the list's elements, because the list is a sublist copied
///                             from the document's list)
/// \param      nEndingSN	->	the sequence number value in pSrcPhrases where the
///                             editable span ends, including the CSourcePhrase instance
///                             at this index value (& likewise, the index value we check
///                             is that in the m_nSequNumber member)
/// \param      strSource	<-	returns the accumulated editable source text, minus any 
///                             initial endmarkers and with any following context-initial 
///                             endmarkers appended
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The span used for this scan is the editable span, but the sublist traversed in the scan
/// is potentially wider - depending on whether free translations and / or collected back
/// translations earlier caused the original editable span to be widened when forming the
/// modifications span, and it is the modifications span which is passed in. The editable
/// subspan will coincide with the user's selection, except if/when the user's selection
/// partly overlapped a retranslation - in the latter case, the span will have been
/// extended to include all of the retranslation; the result, whichever is the case, is
/// what we are calling the "editable span", and this is the span of source text which the
/// user will see and which is available for editing.
/// 
/// Special attention must be given to (a) an initial endmarkers, and (b) any endmarkers 
/// which commence the beginning of the following context. For (a) we must remove them from 
/// the accumulated string (because, they do not belong with the editable text) and the 
/// code can later restore them to their proper place once the edit of the source text is 
/// done, but for (b) we must append any final endmarkers to the end of the editable string 
/// which is to be shown to the user, because that is where they logically belong. Hence (a) 
/// and / or (b) when, pertinent will help make the user's experience concordant with what 
/// marker & endmarker delimitations he would expect to obtain. For instance, if he selects 
/// a footnote in order to edit the whole of it, he'd expect to see \f at its start, and 
/// \f* at its end - even though the \f* was stored outside of the editable span as far 
/// as the original selection was concerned.
/// 5May08	function created as part of refactoring the Edit Source Text functionality
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ScanSpanDoingSourceTextReconstruction(SPList* pSrcPhrases, 
									EditRecord* pRec, int nStartingSN, int nEndingSN, 
									wxString& strSource)
{
	CSourcePhrase* pSrcPhrase = NULL;
	int nThisSN;
	SPList::Node* pos = pSrcPhrases->GetFirst();
	//bool bAllWasOK = TRUE; // unused
	bool bLacksInitialEndmarkers = pRec->strInitialEndmarkers.IsEmpty();
	bool bLacksFinalEndmarkers = pRec->strFinalEndmarkers.IsEmpty();
	
	strSource.Empty(); // ensure strSource starts out empty

    // no error is expected, but we'll check and abort the app with an English message
    // if a valid pos was not found, but have the caller do a save to retain user's
    // work & terminate the edit attempt
	if (pos == NULL)
	{
		// whm: no need to localize this type of error message
		wxMessageBox(_T(
"GetHeadPosition() failed in ScanSpanDoingSourceTextReconstruction(), pos value is NULL. Saving document and abandoning edit."),
		_T(""), wxICON_EXCLAMATION);
		return FALSE;
	}

    // scan over the list, and test for pRscPhrase pointers within the editable span; for
    // those, we collect the source text with its punctuation (if any), and precede it with
    // the contents of any non-empty m_markers member. The firt CSourcePhrase instance is
    // given special attention because it may need initial endmarkers removed.
	bool bIsFirst = TRUE;
	while (pos != NULL)
	{
		// get the CSourcePhrase at the the current POSITION, updating pos value
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nThisSN = pSrcPhrase->m_nSequNumber;

		if (nThisSN >= nStartingSN && nThisSN <= nEndingSN)
		{
            // any sequence number meeting that condition lies within the editablel span,
            // so collect from it...

            // do the source text reconstrution; any material in m_markers must come first,
            // and we don't consider m_markers if the CSourcePhrase instance is a
            // placeholder one because inserted placeholders are not going to store marker
            // info except posibly for the information types (notes, free translations,
            // back translations) which have already been removed

            // remove any initial endmarkers which we would prefer the user not see (it is
            // conceivable that there may be initial endmarkers stored in the CSourcePhrase
            // for a placeholder, so don't limit the RemoveInitialEndmarkers() call to only
            // a non-placeholder)
			if (bIsFirst)
			{
				wxString markers = pSrcPhrase->m_markers;
				if (!bLacksInitialEndmarkers)
				{
					// there are initial endmarker(s) to be removed, so do so
					int offset = -1;
					wxString endmkrs = pRec->strInitialEndmarkers; // includes 
																// final space(s)
					int len = endmkrs.Length();
					wxASSERT(len > 0);
					offset = markers.Find(endmkrs);
					wxASSERT(offset == 0);
					markers = markers.Mid(len);
				}
				if (!markers.IsEmpty())
				{
					// there is remaining marker information, so append it
					strSource += markers;
				}
				bIsFirst = FALSE; // make sure this block is never 
								  // entered more than once
			}
			else
			{
				// the CSourcePhrase instances non-inital in the editable span 
				// are checked here
				if (!pSrcPhrase->m_markers.IsEmpty() && 
					!pSrcPhrase->m_bNullSourcePhrase)
				{
					if (strSource.IsEmpty())
					{
						strSource = pSrcPhrase->m_markers;
					}
					else
					{
						strSource += pSrcPhrase->m_markers;
					}
				}
			}

            // always collect the m_srcPhrase member (which has any punctuation), and
            // append a following space each time; but only provided we are not at a
            // placeholder
			if (!pSrcPhrase->m_bNullSourcePhrase)
			{
				if (strSource.IsEmpty())
				{
					strSource = pSrcPhrase->m_srcPhrase;
				}
				else
				{
					strSource = strSource + _T(" ") + pSrcPhrase->m_srcPhrase;
				}
			}
			if (nThisSN >= nEndingSN)
			{
				// we are at the end of the editable span, so break out of the loop
				break;
			}
		}
	}
    // The editable span may end where there may have been endmarkers, in which case they
    // will have been stored at the beginning of the m_markers member of the CSourcePhrase
    // instance immediately following the editable span. We've found this endmarkers
    // substring in the caller already, if it exists, so append the markers now before
    // returning
	if (!bLacksFinalEndmarkers)
	{
		// a non-empty final endmarkers substring is available, so append it
		strSource += pRec->strFinalEndmarkers;
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if one or more endmarkers were transferred, (and if they were then
///             the carrier CSourcePhrase instance will have also been deleted from the end
///             of the pNewSrcPhrases list). The caller will want to pass knowledge of
///             these facts to the function which adjusts the TextType in the new section
///             of source text, so that proper propagation of altered TextType can be done
///             if the user has modified the markup. Or FALSE if no endmarkers were
///             transferred.
/// \param      pNewSrcPhrases	->	pointer to the SPList pointer in the EditRecord which 
///                                 holds the list of CSourcePhrase instances resulting
///                                 from the parse of the new source text as edited by the
///                                 user
/// \param      pFollSrcPhrase	<->	pointer to the first CSourcePhrase instance in the
///                                 context which follows the editable span of instances in
///                                 m_pSourcePhrases list in the app; this is the instance
///                                 whose m_markers member will receive any transferred
///                                 endmarkers to the beginning of that member; pass in
///                                 NULL if there is no following context (because we are
///                                 at the end of the document) - in such a circumstance no
///                                 transfer can be done and the carrier CSourcePhrase in
///                                 pNewSrcPhrases for the endmarkers, or now-filtered
///                                 information, will have to be included in the document
///                                 where it would continue to carry those markers or
///                                 filtered info
/// \param      pRec		    <->	pointer to the global EditRecord struct, gEditRecord,
///                                 which records edit spans, lists of CSourcePhrase
///                                 instances, lists of removed strings, starting and
///                                 ending TextType values, and various booleans reflecting
///                                 the state of the edit process
/// \remarks
/// Called from: the View's OnEditSourceText().
/// This function does several jobs. (1) It detects if the new source text ends with one or
/// more endmarkers, or with filtered information. Either will manifest in the new list of 
/// CSourcePhrase instances as the final one in the list, with m_key empty, m_follPunct 
/// empty, and m_markers containing just the one or more endmarkers and possibly a final 
/// space, or, the \~FILTER and \~FILTER* wrapped filtered content. When there is one or 
/// more such endmarkers, or filtered content, they have to be stored on the CSourcePhrase 
/// which is first in the following context. So that transfer is done here. (2) Moving the 
/// endmarkers leaves a CSourcePhrase instance whose only reason for existing was to carry 
/// the endmarkers; so once they have gone, this carrier instance must be deleted. Same for
/// filtered information. (3) Knowledge of what happened is passed back to the caller by 
/// the returned BOOL parameter. (Note: we check for m_precPunct non-empty, because a 
/// CSourcePhrase instance that results from a parse of endmarker followed by punctuation 
/// will manifest as m_prevPunct carrying the punctuation and m_marker having the endmarker; 
/// in such a circumstance, if we transferred the endmarker to the following CSourcePhrase 
/// then we'd effect a bogus rearrangment of the linear order of the endmarker and the 
/// punctuation. Hence we bleed that case out by testing and returning FALSE if there is 
/// preceding punctuation. Only after that do we look at the m_follPunct and m_markers
/// members.) (4) A fourth task is to store any final endmarkers, because they may be 
/// different than what was there before, or there may have been none before but now there 
/// are some present. In the case of now-filtered information, we don't need to store 
/// that, as any Cancel or bailout operation will recover that information from stored 
/// CSourcePhrase instances within the EditRecord. (5) A fifth task, but only when a 
/// typo marker has been corrected, is to clear the m_bFirstOfType flag and clear 
/// "?\mkr?" from the m_inform member, both done on the gpFollSrcPhrase which is first 
/// in the following context.
/// 7May08	BEW function created as part of refactoring the Edit Source Text functionality
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::TransportWidowedEndmarkersToFollowingContext(SPList* pNewSrcPhrases, 
			CSourcePhrase* pFollSrcPhrase, EditRecord* pRec)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pFollSrcPhrase == NULL)
	{
        // there is no following context, so no marker transfer can be done, so the carrier
        // CSourcePhrase (if there is one) must be retained as it is - so we've nothing to
        // do but tell the caller no transfer was done
		return FALSE;
	}

    // get the final CSourcePhrase in the list; but if the list is empty (ie. the user used
    // the edit source text dialog to remove all the displayed source text) then there will
    // not be any endmarkers to transfer (otherwise the list would have at least one
    // entry), so return FALSE
	int nCount = pNewSrcPhrases->GetCount();
	if (nCount == 0)
	{
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
		pRec->strNewFinalEndmarkers.Empty();
		pRec->bDocEndPreventedTransfer = FALSE; // a TRUE value is pointless if nothing 
												// is there
		return FALSE;
	}
	SPList::Node* lastPos = pNewSrcPhrases->GetLast();
	CSourcePhrase* pLastSrcPhrase = lastPos->GetData();
	wxASSERT(pLastSrcPhrase != NULL);
	if (pLastSrcPhrase->m_markers.IsEmpty())
	{
		// no final endmarkers to transfer, and no now-filtered information to transfer
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
		pRec->strNewFinalEndmarkers.Empty();
		pRec->bDocEndPreventedTransfer = FALSE; // a TRUE value is pointless if 
												// m_markers is empty
		return FALSE; 
	}
	if (!pLastSrcPhrase->m_precPunct.IsEmpty())
	{
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
		pRec->strNewFinalEndmarkers.Empty();
		pRec->bDocEndPreventedTransfer = FALSE; // a TRUE value is misleading if 
                    // the final one was retained for a different reason than being 
                    // at the document's end
		return FALSE; // this punctuation prevents endmarker transfer, see description 
                      // above for why; and the same applies for any now-filtered
                      // information
	}

    // m_markers has some content, check for endmarkers or filtered information. We can't
    // assume USFM endmarkers (these have a final asterisk *) because the SFM set could be
    // the PNG 1998 one, where \fe and \F are endmarkers. So we'll use the
    // RemoveInitialEndmarkers() function from Helpers.cpp, which has the smarts we need
    // here. If the function removes endmarkers, then pLastSrcPhrase is modified. In the
    // case of now-filtered information, RemoveInitialEndmarkers does not handle that, and
    // the SFM set is irrelevant, so we handle that possibility first. There can't be both
    // now-filtered info AND endmarkers to be transferred as well, only one or the other,
    // or neither.
    // BEW added 24Jan09: support for non-endmarker(s) in m_markers of a carrier
    // CSourcePhrase with m_srcPhrase and m_follPunct members empty (this can happen if, in
    // the dialog, after the user's edit, there is only non-endmarkers in the edit box, or,
    // at the end of the edited string he adds final non-endmarkers for some reason) -- we
    // need a bHasNonEndmarkers bool flag, and a block for processing any such
	bool bLacksEndmarkers = FALSE; // default, because of the logic further down
	bool bHasNonEndmarkers = FALSE; // default; BEW added 24Jan09
	wxString endmarkers;
	wxString nonEndmarkers; // BEW added 24Jan09
	wxString filteredInfo;
	bool bFilteredInfoToBeTransferred = FALSE;
	pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // start off assuming there 
															   // is none to be handled
	int aPosition = -1;
	aPosition = pLastSrcPhrase->m_markers.Find(filterMkr); // search for "\\~FILTER" 
														   // literal string (a global)
	if (aPosition != -1)
	{
		// there is now-filtered information present on the last CSourcePhrase instance,
		// so indicate it has to be handled further down in the function -- but don't do
        // it yet because it only needs to be done provided pLastSrcPhrase's m_key and
        // m_follPunct CString members are both empty
		bFilteredInfoToBeTransferred = TRUE;
		filteredInfo = pLastSrcPhrase->m_markers; // note, if non-endmarker(s) followed 
			// the filtered info, this copy transfers them too (we want that to happen)
		pRec->strNewFinalEndmarkers.Empty(); // ensure this member is empty, there can't be 
					// endmarkers if it is now-filtered information that possibly needs to 
					// be transferred
	}
	else
	{
        // there isn't any now-filtered info, but there might be endmarkers, so check and
        // handle the removal of those from pLastSrcPhrase
		pRec->bTransferredFilterStuffFromCarrierSrcPhrase = FALSE; // none to transfer
        // now try for endmarkers instead (final parameter bCopyOnly, default FALSE, is
        // unchanged -- so that if endmarkers are removed, pLastSrcPhrase will be returned
        // without them in its m_marker member)
		endmarkers = RemoveInitialEndmarkers(pLastSrcPhrase, pApp->gCurrentSfmSet, 
												bLacksEndmarkers);
		if (bLacksEndmarkers)
		{
			pRec->strNewFinalEndmarkers.Empty(); // ensure the member is empty
		}
        // BEW change 24Jan09: (see comment above too) since pLastSrcPhrase now has any
        // initial endmarkers removed, or there were none, we must now check if there are
        // still any non-endmarkers present, and if so put them in nonEndmarkers and set
        // the bHasNonEndmarkers flag, because these must be transferred to if the
        // conditions that m_srcPhrase and m_follPunct are both empty are met
		if (!pLastSrcPhrase->m_markers.IsEmpty())
		{
			// something is still there, so we must store it for potential transfer below
			nonEndmarkers = pLastSrcPhrase->m_markers;
			bHasNonEndmarkers = TRUE;
		}
        // we don't do the store of any of the above stuff here, because we only store the
        // endmarkers in pRec provided they get transferred, and we aren't sure we need to
        // yet - until we test for empty key and m_follPunct members below
    }

    // we have some endmarkers or filtered info or non-endmarkers to transfer - do so, but
    // only provided pLastSrcPhrase's m_key and m_follPunct CString members are both empty;
    // do in the order 1. filtered stuff first (if any non-endmarkers are following it,
    // they are carried along for the ride, so this is safe), then any non-endmarkers
    // (because any after filtered stuff are already dealt with, and so we now handle any
    // which are not accompanied by filtered info), and lastly endmarkers - these belong
    // logically to information preceding CSourcePhrases in the document and so must be
    // first in the final m-markers member which stores any or all of this stuff
	if (bFilteredInfoToBeTransferred || !bLacksEndmarkers || bHasNonEndmarkers)
	{
        // only do the transfer provided there is something there to be transferred in the
        // first place; and only if the relevant members are empty (which indicates a
        // CSourcePhrase otherwise unwanted)
		if (pLastSrcPhrase->m_key.IsEmpty() && pLastSrcPhrase->m_follPunct.IsEmpty())
		{
            // if we are transferring something, then transfer a m_bFirstOfType == TRUE
            // value, provided the pFollSrcPhrase member of same name is not itself TRUE
			if (!pFollSrcPhrase->m_bFirstOfType && pLastSrcPhrase->m_bFirstOfType)
			{
				pFollSrcPhrase->m_bFirstOfType = TRUE; // needs to be set to ensure 
													   // nav text gets rewritten
			}

			// in either case, the stuff is transferred to the start of the
			// destination m_markers member 
			if (bFilteredInfoToBeTransferred)
			{
				// it's filtered information we are dealing with (and it might have one or
                // more non-endmarkers following it - if so, they go along for the ride)
				pFollSrcPhrase->m_markers = filteredInfo + pFollSrcPhrase->m_markers;

				// record, in the EditRecord, what we just did
				pRec->bTransferredFilterStuffFromCarrierSrcPhrase = TRUE;

                // because the original bogus marker was incorrect, clear the
                // m_bFirstOfType flag to permit propagation of parameters to be done by
                // the caller after we return (we can't be sure this reset is wanted when
                // what we are transferring is endmarkers only, so we don't do the same in
                // the else block below)
				pFollSrcPhrase->m_bFirstOfType = FALSE;

                // likewise, the bogus marker should now be correct (or filtered), so at
                // least clear the "?\mkr?" string from m_inform. Even if we don't manage
                // to make the navigation text show the corrected marker name, at worse
                // that is benign and does not affect the integrity of the document (and if
                // RetokenizeText() is later called by the caller, which it should be, that
                // should fix up the navigation text to be what it should be - I think
                // Likewise, in the case of transferring just endmarkers, we also can't be
                // sure that this adjustment is needed in the else block, so we don't do so
                // there either.
				int anOffset = -1;
				wxString accumulateStr;
				wxString inform = pFollSrcPhrase->m_inform;
				anOffset = inform.Find(_T('?'));
				if (anOffset != -1)
				{
					// there is a bogus marker name to be removed
					accumulateStr += inform.Left(anOffset);
					anOffset++; // get past the first ? character
					inform = inform.Mid(anOffset); // use the remainder for next test
					anOffset = inform.Find(_T('?'));
					if (anOffset != -1)
					{
						// go through with the rest only provided we have found the
						// matching ? which delimits the end of the "?\mkr?" substring
						anOffset++; // get past the final ? character
						inform = inform.Mid(anOffset); // get whatever remains, 
													   // possibly nothing
						accumulateStr += inform; // add it to the initial material
                        // we have done this just in case there is also the name of one or
                        // more non-bogus markers in the m_inform member; we want to retain
                        // those
						pFollSrcPhrase->m_inform = accumulateStr;
					}
				}
			}
			else
			{
				// its endmarkers we are dealing with, and possibly non-endmarkers too
				// first store non-endmarkers, if any
				if (bHasNonEndmarkers)
				{
					pFollSrcPhrase->m_markers = nonEndmarkers + pFollSrcPhrase->m_markers;

					// these can be expected to have content in m_inform, so transfer that
					// information too
					pFollSrcPhrase->m_inform = pLastSrcPhrase->m_inform + 
																pFollSrcPhrase->m_inform;
				}

				// now transfer the endmarkers - they must be the last transfer
				pFollSrcPhrase->m_markers = endmarkers + pFollSrcPhrase->m_markers;

                // reset the partner pile & its width - not strictly necessary as probably
                // the pile width is unchanged, but no harm in it, and it is a fail-safe
				// thing to do for updating of the view, since it guarantees the strip
				// gets invalidated and its index saved in CLayout::m_invalidStripArray
				pApp->GetDocument()->ResetPartnerPileWidth(pFollSrcPhrase);

                // now store in the EditRecord the endmarkers themselves, in case we later
                // need to restore the original document state
                pRec->strNewFinalEndmarkers = endmarkers;
			}

            // now delete the carrier, pLastSrcPhrase, which is no longer needed & update
            // the count value stored in pRec to comply with this deletion; remove the
            // pointer at the tail of the list too
			pApp->GetDocument()->DeleteSingleSrcPhrase(pLastSrcPhrase);
			pRec->nNewSpanCount -= 1;
			SPList::Node* spLast = pNewSrcPhrases->GetLast();
			pNewSrcPhrases->DeleteNode(spLast);

			pRec->bDocEndPreventedTransfer = FALSE; // make sure we get value correct
			return TRUE;
		}
	}
	// if control gets to here, we've done no transfers, so inform the caller
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrases  -> the document's m_pSourcePhrases list of CSourcePhrase 
///                             instances
/// \param      pRec         -> the EditRecord for the vertical edit process, which
///                             contains the indices for the start and end of the
///                             CSourcePhrase instances in spans we want to check
/// \remarks
/// Called from: the View's OnEditSourceText().
/// Checks the editable text span, and the preceding and following moved notes span, to
/// make sure that the m_bHasNote flag is set TRUE for every CSourcePhrase instance which
/// contains a \note marker in its m_markers member. If the flag is not set and should be,
/// it sets it.
/// 20June08 created by BEW
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::CheckAndFixNoteFlagInSpans(SPList* pSrcPhrases, EditRecord* pRec)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// first check the editable span
	int nStartAt = pRec->nStartingSequNum;
	int nEndAt = nStartAt + pRec->nNewSpanCount - 1;
    // BEW added 19Jun09, (this error is also in Bill's code base, but it will be merged to
    // this code base for next release so I've not informed him) the span may not exist, if
    // at the end of the document we deleted the source text and the phrase box was located
    // within the deleted section, so check and skip this span if it has gone
	int maxIndex = pApp->GetMaxIndex();
	bool bDoEditSpanCheck = TRUE;
    if (nStartAt > maxIndex)
	{
		// old active location is now beyond the end of the document (note: document end
		// and active location have been re-calculated in OnEditSourceText() already prior
		// to CheckAndFixNoteFlagInSpans() having been called - the active location will
		// have been set to the last existing CSourcePhrase in the doc), so we have to
		// skip this edit span check
		bDoEditSpanCheck = FALSE;
	}
	else if (nEndAt >= nStartAt && nEndAt > maxIndex)
	{
		// the span to be checked starts off within the document, but its end is now
		// beyond the document's end, so shorten it to end at the document's end
		nEndAt = maxIndex;
	}
	wxString mkr = _T("\\note");
	CSourcePhrase* pSrcPhrase = NULL;
	int offset = -1;
	SPList::Node* pos = NULL;
	if (bDoEditSpanCheck)
	{
		pos = pSrcPhrases->Item(nStartAt);
		wxASSERT(pos != NULL);
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);
			offset = pSrcPhrase->m_markers.Find(mkr);
			if (offset != -1)
			{
				// there is a note stored here
				pSrcPhrase->m_bHasNote = TRUE; // ensure the note is flagged 
                        // in case the user edited a typo SF resulting
                        // in a Note which got filtered
			}
			// break out of the loop once we've checked the last in the span
			if (pSrcPhrase->m_nSequNumber >= nEndAt)
				break; 
		}
	}
	// next check 5 or as many CSourcePhrase instances there are in the
	// follNotesMoveSpanList and precNotesMoveSpanList (5 because we can't
	// be sure either of those lists has content), doing these checks preceding
	// and following the editable span
	// start with the span following the editable span
	int nNextStartAt = nEndAt + 1;
	int nNextEndAt;
	int delta = 0;
	// don't do it if the following context does not exist
	if (nNextStartAt < maxIndex)
	{
		delta = wxMin(5,pRec->arrNotesSequNumbers.GetCount());
		if (delta < 5) delta = 5;
		nNextEndAt = nNextStartAt + delta - 1;
		if (nNextEndAt > pApp->GetMaxIndex())
			nNextEndAt = pApp->GetMaxIndex();
		// now do the check of these
		SPList::Node* pos = pSrcPhrases->Item(nNextStartAt);
		wxASSERT(pos != NULL);
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);
			offset = pSrcPhrase->m_markers.Find(mkr);
			if (offset != -1)
			{
				// there is a note stored here
				pSrcPhrase->m_bHasNote = TRUE; // ensure the note is flagged 
                        // in case the user edited a typo SF resulting
                        // in a Note which got filtered
			}
			// break out of the loop once we've checked the last in the span
			if (pSrcPhrase->m_nSequNumber >= nNextEndAt)
				break; 
		}
	}
	// finally, do the same check and fix for the preceding context, at least 5, etc
	nNextEndAt = nStartAt - 1;
	delta = 0;
	// don't do it if the preceding context does not exist
	if (nNextEndAt > 0)
	{
		delta = wxMin(5,pRec->arrNotesSequNumbers.GetCount());
		if (delta < 5) delta = 5;
		nNextStartAt = nNextEndAt - delta + 1;
		if (nNextStartAt < 0)
			nNextStartAt = 0;
		// now do the check of these
		SPList::Node* pos = pSrcPhrases->Item(nNextStartAt);
		wxASSERT(pos != NULL);
		while (pos != NULL)
		{
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			wxASSERT(pSrcPhrase != NULL);
			offset = pSrcPhrase->m_markers.Find(mkr);
			if (offset != -1)
			{
				// there is a note stored here
				pSrcPhrase->m_bHasNote = TRUE; // ensure the note is flagged 
						// in case the user edited a typo SF resulting in a Note
						// which got filtered
			}
			// break out of the loop once we've checked the last in the span
			if (pSrcPhrase->m_nSequNumber >= nNextEndAt)
				break; 
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error
/// \param      pOriginalList        ->	 pointer to an CObList (short) list containing 
///                                      deep copies of a subspan of CSourcePhrase 
///                                      instances from the m_pSourcePhrases list in 
///                                      the app
/// \param      pDestinationList     <-> pointer to the list which is potentially to 
///                                      have CSourcePhrase instances (their pointers,
///                                      actually) inserted in it at the start, and
///                                      possibly at the end as well, in order to extend
///                                      the original pDestinationList to comply with a
///                                      desired wider span
/// \param      nOldList_StartingSN  ->	the sequence number index which determines the 
///                                     starting sequence number value for the instances 
///                                     already in pDestination list at the time that
///                                     that list is passed in
/// \param      nOldList_EndingSN    ->	the sequence number index which determines the 
///                                     ending (inclusive) sequence number value for the 
///                                     instances already in pDestination list at the 
///                                     time that that list is passed in
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The algorith is as follows. The pOriginalList (which is potentially wider than
/// pDestinationList) is scanned from its beginning, and each pSrcPhrase's m_nSequNumber
/// value is tested against the nOldList_StartingSN value; if the former is less than the
/// latter, then that particular pSrcPhrase also needs to be put in the pDestinationList -
/// so we make a deep copy and insert it; we iterate this until the m_nSequNumber value
/// reaches nOldList_StartingSN and break out, because that pSrcPhrase instance is already
/// in pDestinationList. Then we skip to the nOldList_EndingSN location, and when we find
/// it, we test to see if any pSrcPhrase instances from the end of the pOriginalList follow
/// that location -- that is, if their m_nSequNumber values are greater than
/// nOldList_EndingSN. Any that are deep copied and appended to the pDestinationList.
/// (Copies are inserted or appended, and so the caller must delete the deep copies in the
/// pOriginalList, if appropriate, on return.)
/// BEW 13May08	function created as part of refactoring the Edit Source Text functionality
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::CopyCSourcePhrasesToExtendSpan(SPList* pOriginalList, 
							SPList* pDestinationList, int nOldList_StartingSN, 
							int nOldList_EndingSN)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList::Node* posOrig = pOriginalList->GetFirst();
	if (posOrig == NULL)
	{
		// whm Note: no translation for localization need be done 
		// for this type of error message
		wxMessageBox(_T(
"FindIndex() failed in MoveCSourcePhrasesToExtendSpan(), posOrig value is NULL. Saving document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION);
		BailOutFromEditProcess(pApp->m_pSourcePhrases, &gEditRecord); // restore 
														// original document state
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	SPList::Node* posInsert = pDestinationList->GetFirst();
	if (posInsert == NULL)
	{
		// whm Note: no translation for localization need be done 
		// for this type of error message
		wxMessageBox(_T(
"FindIndex() failed in MoveCSourcePhrasesToExtendSpan(), posInsert value is NULL. Saving document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION);
		BailOutFromEditProcess(pApp->m_pSourcePhrases, &gEditRecord); // restore 
														// original document state
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	int nSequNum = -1;
	bool bIsFirst = TRUE;
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pNewOne = NULL;
	while (posOrig != NULL)
	{
		pSrcPhrase = posOrig->GetData();
		posOrig = posOrig->GetNext();
		wxASSERT(pSrcPhrase);
		nSequNum = pSrcPhrase->m_nSequNumber;
		if (nSequNum < nOldList_StartingSN)
		{
            // a deep copy of this CSourcePhrase instance needs to be inserted following
            // earlier insertions into the pDestinationList, or if this is the first to be
            // inserted, then at the start of that list
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			if (bIsFirst)
			{
				// whm: In wxList Insert inserts by default at the head/beginning of the list
				posInsert = pDestinationList->Insert(pNewOne);
				bIsFirst = FALSE;
			}
			else
			{
                // wxList has no equivalent to InsertAfter(). The wxList Insert() method
                // inserts the new node BEFORE the current position/node. To emulate what
                // the MFC code does, we can advance one node before calling Insert()
                // geting a node called posNextHigher which points to the next node beyond
                // the current position, and use its position in the Insert() call (which
                // only inserts BEFORE the indicated position). The result should be that
                // the insertions will get placed in the list the same way that MFC's
                // InsertAfter() places them. wx additional note: If the item is to be
                // inserted after the last item in the list posNextHigher will return NULL,
                // in that case, just append the new item to the list.
				SPList::Node* posNextHigher = posInsert->GetNext();
				if (posNextHigher == NULL)
					posInsert = pDestinationList->Append(pNewOne);
				else
					posInsert = pDestinationList->Insert(posNextHigher,pNewOne);
			}
		}
		if (nSequNum >= nOldList_StartingSN && nSequNum <= nOldList_EndingSN)
			continue;
		if (nSequNum > nOldList_EndingSN)
		{
			// Any which remain have to be appended to the destination list
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			posInsert = pDestinationList->Append(pNewOne);
		}
	}
#ifdef _DEBUG
		SPList::Node* testpos = pOriginalList->GetFirst();
		int ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			testpos = testpos->GetNext();
			//wxLogDebug(_T("CopyCSourcePhrasesToExtendSpan() pOriginalList item %d at %x = %s"),
			//ct++,pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
		testpos = pDestinationList->GetFirst();
		ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			testpos = testpos->GetNext();
			//wxLogDebug(_T("CopyCSourcePhrasesToExtendSpan() pDestinationList item %d at %x = %s"),
			//ct++,pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
#endif
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrases  ->	pointer to the m_pSourcePhrases list in the app 
/// \param      pRec         ->	pointer to the EditRecord for the vertical edit process
/// \remarks
/// Called from: the View's BailOutFromEditProcess().
/// This function restores the contents of pSrcPhrases list to what it was prior to
/// the source text edit being attempted.
/// 
/// The passed in EditRecord, pRec, contains the information about the source text edit
/// which has just been completed, and in particular it includes the CSourcePhrase
/// instances in the cancel span, and the potentially overlapping (at the large sequence
/// numbers end) propagation span. It also has the starting and ending sequence number
/// values for each relevant span, and so it just requires some arithmetic, deletions and
/// insertions in order to reconstitute the original document state, now that the
/// document's underlying native structures have been modified.
/// 
/// There are four possible circumstances in which this function may be called. 
/// 
/// (1) After the edit source text dialog is dismissed by an OK button click, and the
/// document has undergone modifications subsequent to that according to how the used
/// edited the source text, but somewhere along the way in doing those modifications an
/// exception was encountered.
/// 
/// (2) The user has progressed down somewhat in the vertical edit process, past the source
/// text edit step, and has decided to backtrack all the way to the original document
/// state. (This is unlikely, but must be allowed for. He's more likely though to just
/// Cancel the whole process in order to get back to the original doc state.) For this to
/// work, any changes to the number of source phrases made during the adaptations update
/// step must be removed (eg. mergers, placeholder insertions, retranslations), so that the
/// entry point for RestoreDocAfterSrcTextEditModifiedIt() is exactly as it was at the
/// earlier end of the source text edit step. (Other restoration functions will have been
/// called prior to this function being entered, for whatever other steps were completed
/// before the backtrack was initiated.)
/// 
/// (3) As in (2) the user has progessed down somewhere in the vertical edit process, then
/// decides to cancel out of the whole process. Same caveat applies as in (2) about what
/// the initial conditions must be prior to RestoreDocAfterSrcTextEditModifiedIt() being
/// entered, and any completed lower steps having their restoration functions called first
/// before RestoreDocAfterSrcTextEditModifiedIt() is entered.
/// 
/// (4) As in (2) or (3), but an exception in one of the processing steps lower than source
/// text editing was encountered, so that the whole vertical edit must be abandoned - same
/// caveats as for (2) and (3) apply here also.
/// BEW 26May08	function created as part of refactoring the Edit Source Text functionality
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RestoreDocAfterSrcTextEditModifiedIt(SPList* pSrcPhrases, EditRecord* pRec)
{
	int nCount = 0;
	int nReplaceCount = 0;
	bool bReplacedOK = TRUE;
	wxString error;
    // since replacement of temporarily removed Notes is done last, the bailout must first
    // replace any subspans involved in potential Note moves in the preceding or following
    // context; the array storing removed Notes' sequence numbers can be used as a flag, if
    // there were none removed, the array will be empty, and then no such context
    // restoration is required
	int nStartingAtSN;
	if (pRec->arrNotesSequNumbers.GetCount() > 0)
	{
		// do the restorations, if there are sublists to restore; 
		// first do the following context
		nCount = pRec->follNotesMoveSpanList.GetCount();
		if (nCount > 0)
		{
            // if the user deleted all the source text, start at the first CSourcePhrase
            // of the following context -- which will have become the same index as
            // nStartingSequNum; otherwise work out the first CSourcePhrase of the
            // following context using the nNewSpanCount value
			if (pRec->nNewSpanCount == 0)
			{
				nStartingAtSN = pRec->nStartingSequNum;
			}
			else
			{
				nStartingAtSN = pRec->nStartingSequNum + pRec->nNewSpanCount;
				// the above index will definitely lie within the document's list
				// because follNotesMoveSpanList is not empty
			}
			nReplaceCount = nCount;
			bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartingAtSN,
				nCount, &pRec->follNotesMoveSpanList, 0, nReplaceCount);
			if (!bReplacedOK)
			{
                // if we have an error while restoring the original document, then we can't
                // get back the document as it was, so it is best to abort the app and lose
                // recent changes than to continue and risk a malformed document or with
                // content lacking somewhere within
				error = _T(
				"Restoration following context potential moved notes span failed, ");
				error += _T(
				" so rather than save a bad document, we abort the ");
				error += _T(
				"application now, losing the work done since the last save.");
				wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
				wxExit();
			}
		}
		// now the preceding context's subspan
		nCount = pRec->precNotesMoveSpanList.GetCount();
		if (nCount > 0)
		{
			nStartingAtSN = pRec->nStartingSequNum - 1; // the instance just 
														// prior to the edit span
			nStartingAtSN = nStartingAtSN - nCount + 1; // allow for the sublist's
                    // content; the above index will definitely lie within the
                    // document's list because precNotesMoveSpanList is not empty
			nReplaceCount = nCount;
			bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartingAtSN,
				nCount, &pRec->precNotesMoveSpanList, 0, nReplaceCount);
			if (!bReplacedOK)
			{
                // if we have an error while restoring the original document, then we can't
                // get back the document as it was, so it is best to abort the app and lose
                // recent changes than to continue and risk a malformed document or with
                // content lacking somewhere within
				error = _T(
				"Restoration preceding context potential moved notes span failed, ");
				error += _T(" so rather than save a bad document, we abort the ");
				error += _T("application now, losing the work done since the last save.");
				wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
				wxExit();
			}
		}
	}

    // if the cancel span has instances to the left of the nStartingSequNum value for the
    // commencement of the former editable span, then replace the m_pSourcePhrases
    // instances in that range with the deep copies from the same subrange in the cancel
    // list; the consecutive values of the sequence numbers stored on the instances are
    // still correct after this next block is done
	if (pRec->nCancelSpan_StartingSequNum < pRec->nStartingSequNum)
	{
		nCount = pRec->nStartingSequNum - pRec->nCancelSpan_StartingSequNum;
		nReplaceCount = nCount;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, 
							pRec->nCancelSpan_StartingSequNum, nCount, 
							&pRec->cancelSpan_SrcPhraseList, 0, nReplaceCount);
		if (!bReplacedOK)
		{
            // if we have an error while restoring the original document, then we can't get
            // back the document as it was, so it is best to abort the app and lose recent
            // changes than to continue and risk a malformed document or with content
            // lacking somewhere within
			error = _T(
			"Restoration of the document failed in the initial replacements from the ");
			error += _T("cancel span, so rather than save a bad document, we abort the ");
			error += _T("application now, losing the work done since the last save.");
			wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
			wxExit();
		}
	}
    // now we must replace the CSourcePhrase instances which were the result of the user's
    // edit, with those which were in the original (possibly extended by a retranslation)
    // editable span
	bReplacedOK = ReplaceCSourcePhrasesInSpan(
		pSrcPhrases,
		pRec->nStartingSequNum, // could be beyond doc end if the edit 
								// removed data from doc end
		pRec->nNewSpanCount, // could be zero, or small, or large
		&pRec->cancelSpan_SrcPhraseList, // where the replacements are to be taken from
		pRec->nStartingSequNum - pRec->nCancelSpan_StartingSequNum, // offset in cancel
							// span where the insertions are to be done from (inclusive)
		pRec->nOldSpanCount // how many old instances were in the editable span
	);
	if (!bReplacedOK)
	{
        // if we have an error while restoring the original document, then we can't get
        // back the document as it was, so it is best to abort the app and lose recent
        // changes than to continue and risk a malformed document or with content lacking
        // somewhere within
		error = _T("Restoration of the document failed in the replacements from the ");
		error += _T(
		"editable span within the cancel span, so rather than save a bad document, ");
		error += _T(
		"we abort the application now, losing the work done since the last save.");
		wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
		wxExit();
	}
	// update the sequence numbers, starting from the start of the cancel span
	UpdateSequNumbers(pRec->nCancelSpan_StartingSequNum);

    // now replace any CSourcePhrase instances at the end of the cancel span, provided they
    // lie beyond the end of the just replaced editable span
	if (pRec->nCancelSpan_EndingSequNum > pRec->nEndingSequNum)
	{
		// there are are some instances in the cancel span not yet replaced, so do so
		int nStartAt_InCancelSpan = pRec->nEndingSequNum - 
										pRec->nCancelSpan_StartingSequNum + 1;
		int nHowMany_InCancelSpan = pRec->nCancelSpan_EndingSequNum - 
										pRec->nEndingSequNum;
		int nStartAt_InDocList = pRec->nEndingSequNum + 1;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartAt_InDocList, 
								nHowMany_InCancelSpan, &pRec->cancelSpan_SrcPhraseList, 
								nStartAt_InCancelSpan, nHowMany_InCancelSpan);
		if (!bReplacedOK)
		{
            // if we have an error while restoring the original document, then we can't get
            // back the document as it was, so it is best to abort the app and lose recent
            // changes than to continue and risk a malformed document or with content
            // lacking somewhere within
			error = _T(
			"Restoration of the document failed in the final replacements from the ");
			error += _T("cancel span, so rather than save a bad document, we abort the ");
			error += _T("application now, losing the work done since the last save.");
			wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
			wxExit();
		}
	}

    // The attempt to do source text editing could, if the SF markup was altered, result in
    // a new TextType having to be propagated forward into the following context. The
    // propagation would continue until a marker was encountered which changed the
    // TextType, and so such a propagation conceivably may sometimes go beyond the end of
    // the cancel span. The text type would be different on those CSourcePhrase instances,
    // and also possibly the special text boolean, and m_inform member. So the final task
    // is to work out now if are any CSourcePhrase instances in the propagation span (in
    // the EditRecord) which lie beyond the end of the cancel span; if so, we must replace
    // that subspan of the document's list with the relevant deep copies from the
    // propagation span list in the EditRecord.
	if (pRec->nPropagationSpan_EndingSequNum > pRec->nCancelSpan_EndingSequNum)
	{
		// there are are some instances in the propagation span not yet replaced, so do so
		int nStartAt_InPropSpan = pRec->nCancelSpan_EndingSequNum - 
									pRec->nPropagationSpan_StartingSequNum + 1;
		int nHowMany_InPropSpan = pRec->nPropagationSpan_EndingSequNum - 
									pRec->nCancelSpan_EndingSequNum;
		int nStartAt_InDocList = pRec->nCancelSpan_EndingSequNum + 1;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, nStartAt_InDocList, 
							nHowMany_InPropSpan, &pRec->propagationSpan_SrcPhraseList, 
							nStartAt_InPropSpan, nHowMany_InPropSpan);
		if (!bReplacedOK)
		{
            // if we have an error while restoring the original document, then we can't get
            // back the document as it was, so it is best to abort the app and lose recent
            // changes than to continue and risk a malformed document or with content
            // lacking somewhere within
			error = _T("Restoration of the document failed in the replacements from the ");
			error += _T(
			"propagation span, so rather than save a bad document, we abort the ");
			error += _T("application now, losing the work done since the last save.");
			wxMessageBox(error, _T(""), wxICON_EXCLAMATION);
			wxExit();
		}
	}
	// if we haven't aborted, then the original document state prior to
	// the source text edit has now been successfully restored
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error
/// \param      pSrcPhrases ->  pointer to the document's m_pSourcePhrases list (the
///                             Note(s) will be restored to instances of CSourcePhrase in
///                             this list)
/// \param      pRec        ->  pointer to the EditRecord for the vertical edit process
/// \remarks
/// Called from: the View's OnEditSourceText().
/// Restores notes to the source text after having been removed during source text editing.
/// The passed in EditRecord contains the information about the source text edit which has
/// just been completed, and it includes an array, arrNotesSequNumbers, which stores in
/// normal order the sequence number indices for each Note that was removed from the
/// original editable span (this span will have been extended beyond the user's selection
/// to include all of any retranslation(s) it overlaps, but if there were no such overlaps
/// then it was the same as the user's selection). The array is used to assist in
/// relocating the removed notes. This is a difficult process because the user may have
/// done a minor edit, or a major one, or removed his entire selection from the document.
/// The best the function can do is to try relocate the notes in approximately the same
/// locations as much as possible; without reordering any, and within the bounds formed by
/// unremoved notes in the preceding and following contexts, or the document's start or
/// end. For an edit which results in the same number of CSourcePhrase instances in the
/// final edit span, or more, this is easy to do; when fewer instances result, some
/// squeezing of note locations may be required, and possibly even relocating some notes,
/// or all, in the following context - and if there is insufficient following context for
/// that, left-shifting some or all in order to create empty locations for the
/// unreplaceable ones to be replaced. The whole of this process is encapsulated in this
/// function; unfortunately it isn't trivial to do, and if there are too many Notes to be
/// replaced near the end of the document so that not all can be replaced, then the
/// unreplaceable ones are simply lost - but the user is given a message saying so.
/// BEW 26May08	function created as part of refactoring the Edit Source Text functionality
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RestoreNotesAfterSourceTextEdit(SPList* pSrcPhrases, EditRecord* pRec)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxArrayInt arrUnsqueezedLocations; // for those locations for which the old sequence
					// numbers are still valid, and in the edit span (in its final form)
	wxArrayInt arrSqueezedLocations; // for those locations for which the old sequence
					// numbers are not valid and therefore are squeezed leftwards

	// notes were removed, but this happens only for those in the editable span, and in
	// left to right order; so get the removals' minimum and maximum sequence numbers
	int nNumRemoved = pRec->arrNotesSequNumbers.GetCount();
	int nNumUnsqueezedLocations = -1;
	int nEditSpanStartingSN = pRec->nStartingSequNum; // this could be the start of the
                    // 'following context' if the user's edit was to remove everything in
                    // the edit span
	int nEditSpanEndingSN; // for the same reason this once can also be at the start
						   // of the former following context
	if (pRec->nNewSpanCount == 0)
	{
		nEditSpanEndingSN = pRec->nStartingSequNum;
	}
	else
	{
		nEditSpanEndingSN = pRec->nStartingSequNum + pRec->nNewSpanCount - 1;
	}

    // find where there are existing unremoved notes, earlier and later than the edit span,
    // which will act as bounds for our note relocations - we can't transgress these bounds
    // without causing a reordering of at least a couple of notes, and reordering is
    // forbidden
	int nLeftBound;
	int nRightBound;
	bool bNoError;
	if (nEditSpanStartingSN - 1 < 0)
	{
		// the edit span commenced at the start of the document, so the edit span's start
		// has to be the left bound
		nLeftBound = 0;
	}
	else
	{
		// FALSE in the last parameter of the next call means 'seach backwards'
		// (when searching backwards, the initial location is ignored; but not when
		// searching forward, so pass in the edit span's starting SN value)
		bNoError = FindNote(pSrcPhrases, nEditSpanStartingSN, nLeftBound, FALSE);
		if (!bNoError)
		{
			// an error message has been seen already, so return FALSE to the
			// caller to make the vertical edit process BailOut() function be called
			return FALSE;
		}
		if (nLeftBound == -1)
		{
			// no leftwards note was found, so the left bound is the start of the
			// document (otherwise, it is the value returned in nLeftBound)
			nLeftBound = 0;
		}
	}
	// Now nRightBound, no final BOOL parameter in the next call means 'seach forwards'
	bNoError = FindNote(pSrcPhrases, nEditSpanEndingSN, nRightBound); 
	if (!bNoError)
	{
        // an error message has been seen already, so return FALSE to the caller to make
        // the vertical edit process BailOut() function be called
		return FALSE;
	}
	if (nRightBound == -1)
	{
		// no forwards note was found, so the right bound is the end of the document
		// (otherwise, it is the value returned in nRightBound)
		nRightBound = pApp->GetMaxIndex();
	}

    // loop to handle the cases where note replacement can occur without location changes
    // (but there is no guarantee that any one note will be on the same word as formerly,
    // nor even that the notes' contents are appropriate for the new meaning at the places
    // where they will be put); these locations we will store in the unsqueezed array;
    // we'll put the remainders in the squeezed array; but we'll put all in the squeezed
    // array if the user's edit was to delete the entire editable source text string
	int index;
	int aNoteSN;
	int nCurrentSN = nEditSpanStartingSN; // potential storage location's index
	if (pRec->nNewSpanCount == 0)
	{
        // the user deleted all the source text shown him in the dialog, so notes removed
        // have nowhere to go, so we'll just bunch them up in consecutive CSourcePhrase
        // instances in the old following context; but moving them left to create gaps if
        // necessary
		bool bShiftingRightWorked;
		for (index = 0; index < nNumRemoved; index++)
		{
			if (!IsNoteStoredHere(pSrcPhrases, nCurrentSN))
			{
				// no note at this location, so we can restore a note at this location
				if (index+1 > (int)arrSqueezedLocations.GetCount())
					arrSqueezedLocations.SetCount(index+1); // any added elements to the 
												// array are assigned int(0) by default
				arrSqueezedLocations[index] = nCurrentSN;
				nCurrentSN++; // get the next potential storage location's index
			}
			else
			{
                // we've come to a bound, that is, a note already existing at this location
                // so we'll move it, and as many consecutive following ones as there are,
                // one place to the right, to create a gap for restoring the present one.
                // If we don't succeed in creating a gap this way (the only way to prevent
                // it would be to have come to the end of the document with a series of
                // consecutive notes), we'll next try left-shifting the already stored
                // locations (remember, these are locations without notes by definition, so
                // we are just decrementing stored index values) to create a gap that way -
                // this will work so long as we don't go bump into the nLeftBound value,
                // but if that unthinkable thing should happen, the only recourse is to
                // insert the remaining Notes' text into the removed free translations
                // list, and tell the user he can get it/them from there by entering Free
                // Translation Mode and using the combobox there to have any visible Note
                // in the list sent to the Clipboard - after which he can create an empty
                // note (it can be done in Free Translation Mode) somewhere and paste the
                // old Note text into it.
				bShiftingRightWorked = 
					ShiftASeriesOfConsecutiveNotesRightwardsOnce(pSrcPhrases, nCurrentSN);
				if (bShiftingRightWorked)
				{
					// exploit the gap we created by the above call
					if (index+1 > (int)arrSqueezedLocations.GetCount())
						arrSqueezedLocations.SetCount(index+1); // any added elements to 
												// the array are assigned int(0) by default
					arrSqueezedLocations[index] = nCurrentSN;
					nCurrentSN++; // get the next potential storage location's index
				}
				else
				{
                    // there are more to replace, but no more document space at the end on
                    // which to store them, so now try leftshifting as explained above
					bool bLeftwardsOK = MoveNoteLocationsLeftwardsOnce(
													&arrSqueezedLocations, nLeftBound);
					if (bLeftwardsOK)
					{
						// exploit the gap we created by the above call
						nCurrentSN--; // the gap is at the end of the valid locations 
                                // in the array, but we above had incremented nCurrentSN to
                                // point past that location, so we must decrement it so it
                                // indexes the gap we created
						if (index+1 > (int)arrSqueezedLocations.GetCount())
							arrSqueezedLocations.SetCount(index+1); // any added elements to 
												// the array are assigned int(0) by default
						arrSqueezedLocations[index] = nCurrentSN;
						nCurrentSN++; // get the next potential storage location's index
					}
					else
					{
                        // left shifting indices bumped up against the left bound - we will
                        // call it quits and just abandon the rest, and tell the user
						//
                        // BEW changed 2Sep08, I want user's click on an item in the
                        // Removed list to send the clicked string to the phrase box or
                        // free translation Compose box, directly. If I let potentially
                        // huge Notes be stored in the free translations list, this could
                        // result in unwieldly large strings having to be dealt with in the
                        // Compose bar's edit box. Since an unreplaceable Note is, in
                        // practical terms, almost an impossibility, I'll just instead
                        // delete unreplaceable ones, but still warn the user what has
                        // happened.

						// delete any which remain
						pRec->storedNotesList.Clear();

						// warn the user about what has happened -- it is extremely unlikely
						// that space would be so tight that we'd have to abandon a note
						int nRemainder = nNumRemoved - index;
						wxString aStr; 
						// IDS_UNPLACEABLE_NOTES
						aStr = aStr.Format(_(
"Some temporarily removed Notes could not be restored to the document due to lack of space, so they have been discarded. Number of notes discarded: %d"),
						nRemainder);
						wxString message;
						//message.Format((LPCTSTR)aStr,buff);
						wxMessageBox(message, _T(""), wxICON_INFORMATION);
						break; // break out of the loop and let the rest of the 
                            // function do the replacements of those that were successfully
                            // relocated and stored in arrSqueezedLocations
					}
				}
			}
		}
	}
	else
	{
		// there is some new edited text, so the possibility of reconstituting at least some
		// of the removed notes on CSourcePhrase instances within the new edit span remains
		for (index = 0; index < nNumRemoved; index++)
		{
			aNoteSN = pRec->arrNotesSequNumbers[index]; // get the next note's location
			if (aNoteSN >= nEditSpanStartingSN && aNoteSN <= nEditSpanEndingSN)
			{
				// the note index falls within the edit span, store it unchanged in value
				// in the "unsqueezed" array
				arrUnsqueezedLocations.Add(aNoteSN);
			}
			else
			{
                // the note index falls later than the end of the edit span, so just store
                // it unchanged for the present in the "squeezed" array
				arrSqueezedLocations.Add(aNoteSN);
			}
		}
		if (arrSqueezedLocations.GetCount() == 0)
		{
            // all the removed ones were placed within the edit span, so go to en(d) to
            // have the relocated notes reconstituted in the document
			goto en;
		}
		else
		{
            // some would not fit in the edit span, so try fit the other ones within it at
            // its end, failing that, create gaps by left shifting and try fit at the end
			bool bRelocatedThemAll = BunchUpUnsqueezedLocationsLeftwardsFromEndByOnePlace(
									pRec->nStartingSequNum, pRec->nNewSpanCount,
									&arrUnsqueezedLocations, &arrSqueezedLocations, 
									nRightBound);
			if (!bRelocatedThemAll)
			{
                // not all were successfully re-located, the remainder which are as yet
                // unrelocated are in arrSqueezedLocations; we will locate them in the
                // following context for the edit span, and move existing unremoved notes
                // rightwards to create gaps as far as possible, this will work except when
                // there are a lot of notes yet to be placed and we are at or near the
                // document's end and there can't be a sufficient number of note movements
                // to the right in order to accomodate those that remain in the locations
                // vacated -- if that happens, the last unrelocated ones will just be
                // stored at the top of the removed free translations list, so as to be
                // accessible (though only when in free translation mode) rather than lost
                // entirely
				int nRemainderCount = arrSqueezedLocations.GetCount();
				wxASSERT(nRemainderCount > 0);
				int nStartAt = pRec->nStartingSequNum + pRec->nNewSpanCount; // the first 
													// location following the edit span
				// check this is a valid index within the document's list
				if (nStartAt <= pApp->GetMaxIndex())
				{
                    // the location is within the document; so we check for the presence of
                    // an existing Note, and if there is none, we use the location as a
                    // location for recreating the next Note, and remove the latter's old
                    // SN index from the start of the arrSqueezedLocations array. If we
                    // bump against an already existing Note, we'll move it (and any
                    // consecutive ones following it) a location rightwards, to create the
                    // gap we need, etc.
					nNumUnsqueezedLocations = arrUnsqueezedLocations.GetCount(); // make 
															// sure it's value is current
					for (index = 0; index < nRemainderCount; index++)
					{
						// iterate over all those remaining unrelocated, relocating each...
						aNoteSN = nStartAt + index;
						bool bHasNote = IsNoteStoredHere(pSrcPhrases, aNoteSN);
						if (bHasNote)
						{
                            // we've bumped against an already existing Note still in the
                            // document, so we have to move it righwards (any any
                            // consecutives which follow it) if we can...
							bool bMoveRightWorked = 
								ShiftASeriesOfConsecutiveNotesRightwardsOnce(pSrcPhrases, 
																			 aNoteSN);
							if (bMoveRightWorked)
							{
                                // we've created a gap at aNoteSN location, so set this
                                // location up as one for Note relocation in the code later
                                // below
								arrSqueezedLocations.RemoveAt(0);
                                // whm note: wxArrayInt's Insert method reverses the
                                // parameters! Caution: wx docs also says of
                                // wxArray::Insert() "Insert the given number of copies of
                                // the item into the array before the existing item n. This
                                // resulted in incorrect ordering of source phrases, so we
                                // use array[] = assignment notation instead. Bruce's note
                                // indicates that it is going to "insert at the array's
                                // end", so to be safe we insure that the array has at
                                // least nNumInUnsqueezedArray elements by calling
                                // SetCount()
								if (nNumUnsqueezedLocations + 1 > 
										(int)arrUnsqueezedLocations.GetCount())
									arrUnsqueezedLocations.SetCount(nNumUnsqueezedLocations+1);
								arrUnsqueezedLocations[nNumUnsqueezedLocations] = aNoteSN;
								nNumUnsqueezedLocations = arrUnsqueezedLocations.GetCount();
							}
							else
							{
                                // the move rightwards by one location did not succeed
                                // (probably we got to the end of the document); so the
                                // only recourse we have is to store the remaining stored
                                // Note text strings at the head of the removed free
                                // translations list (to make them accessible in Free
                                // Translation mode)
								int nRemainder = nRemainderCount - index;
								int nNewIndex;
								wxArrayString* pRemList = new wxArrayString;
								wxASSERT(pRemList != NULL);
								wxString aNote;
								int lastIndexPos;
								lastIndexPos = pRec->storedNotesList.GetCount() -1;
								for (nNewIndex = index; nNewIndex < nRemainder; nNewIndex++)
								{
									aNote = pRec->storedNotesList.Item(lastIndexPos);
									lastIndexPos--;
									pRemList->Insert(aNote,0);
									if (lastIndexPos < 0)
										break;
								}
								bool bResult = InsertSublistAtHeadOfList(pRemList, 
															freeTranslationsList, pRec);
								if (!bResult)
								{
									// there was an error (an unknown list was 
									// requested in the switch)
									wxString errStr = _T(
					"InsertSublistAtHeadOfList(), for storing un-restorable ");
									errStr += _T(
					"Notes in the free translations list (just some from tail), failed. ");
									errStr += _T(
					"Edit process abandoned. Document restored to pre-edit state.");
									wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
									pRemList->Clear();
									delete pRemList;
									return FALSE;
								}
								
								delete pRemList; // the free translations list now 
                                    // manages these strings, so don't do any Remove()
                                    // before doing this deletion
								// warn the user about what has happened ?? Nah
								break; // break out of the loop and let the rest of 
                                    // the function do the replacements of those that
                                    // were successfully relocated and stored in
                                    // arrSqueezedLocations
							} // end of else block for test bMoveRightWorked == TRUE
						}
						else
						{
							// the aNoteSN index has no Note at this location, 
							// so we can create one there
							arrSqueezedLocations.RemoveAt(0);
                            // whm note: wxArrayInt's Insert method reverses the
                            // parameters! Caution: wx docs also says of wxArray::Insert()
                            // "Insert the given number of copies of the item into the
                            // array before the existing item n. This resulted in incorrect
                            // ordering of source phrases, so we use array[] = assignment
                            // notation instead. Bruce's note indicates that it is going to
                            // "insert at the array's end", so to be safe we insure that
                            // the array has at least nNumInUnsqueezedArray elements by
                            // calling SetCount()
							if (nNumUnsqueezedLocations + 1 > 
									(int)arrUnsqueezedLocations.GetCount())
								arrUnsqueezedLocations.SetCount(nNumUnsqueezedLocations+1);
							arrUnsqueezedLocations[nNumUnsqueezedLocations] = aNoteSN;
							nNumUnsqueezedLocations = arrUnsqueezedLocations.GetCount();
						}
					} // end of for loop for relocating all those we couldn't fit in 
					  // edit span at the start of the context following the edit span 
					  // - rightshifting notes if necessary
				} // end of TRUE block for test nStartAt <= GetMaxIndex()
				else
				{
                    // we are already at the end of the document, so the remainders have to
                    // be put into the removed free translation list; we'll remove them in
                    // a loop from the tail of the CStringList in pRec, and insert each
                    // such one at the start of a new CStringList which we will then insert
                    // at the start of the removed free translations list
					arrSqueezedLocations.Clear(); // clear these stored SN indices, 
                            // so that the Note creations done below won't wrongly
                            // grab the locations stored in arrSqueezedLocations
					int nNewIndex;
					wxArrayString* pRemList = new wxArrayString;
					wxASSERT(pRemList != NULL);
					wxString aNote;
					int lastIndexPos;
					lastIndexPos = pRec->storedNotesList.GetCount() -1;
					for (nNewIndex = 0; nNewIndex < nRemainderCount; nNewIndex++)
					{
						aNote = pRec->storedNotesList.Item(lastIndexPos);
						lastIndexPos--;
						pRemList->Insert(aNote,0);
					}
					bool bResult = InsertSublistAtHeadOfList(pRemList, freeTranslationsList, pRec);
					if (!bResult)
					{
						// there was an error (an unknown list was 
						// requested in the switch)
						wxString errStr = _T(
			"InsertSublistAtHeadOfList(), for storing un-restorable ");
						errStr += _T(
			"Notes in the free translations list (all the removed ones), failed. ");
						errStr += _T(
			"Edit process abandoned. Document restored to pre-edit state.");
						wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
						pRemList->Clear();
						delete pRemList;
						return FALSE;
					}
					
					delete pRemList; // the free translations list now manages 
                        // these strings, so don't do any Remove() before doing this
                        // deletion
					// warn the user about what has happened ?? No
				}
			}
		}
	}

    // build the notes at the required locations, using the stored new sequence numbers,
    // after making the unsqueezed and squeezed arrays into one; we don't need to keep them
    // separate anymore, because any values stored in the squeezed array will be at higher
    // sequence numbers than any in the unsqueezed array
en:	;
	// In wx we need to add the elements of another array manually
	int arrCt;
	for (arrCt = 0; arrCt < (int)arrSqueezedLocations.GetCount(); arrCt++)
	{
		arrUnsqueezedLocations.Add(arrSqueezedLocations.Item(arrCt));
	}

	//return FALSE; // uncomment out in order to test the document restoration code

	wxString strNoteText;
	int nNumToReplace = arrUnsqueezedLocations.GetCount();
	for (index = 0; index < nNumToReplace; index++)
	{
        // get each Note string and create its Note on the appropriate CSourcePhrase
        // instance, there should not be any Notes already present at these locations, but
        // we'll check and if there is, we've an error state which must cause the vertical
        // edit process to be abandoned and the earlier doc state rebuilt
		// BEW added 19Jun09, if end of doc edited away, including one or more notes,
		// we'll assume they are unwanted and can be abandoned; so test for index values
		// beyond the doc end, and if so, just continue to next iteration without
		// recreating the note
		aNoteSN = arrUnsqueezedLocations[index]; // get the next note's location
		if (aNoteSN > pApp->GetMaxIndex())
			continue;
		strNoteText = pRec->storedNotesList.Item(index); // get the next note's text
		if (IsNoteStoredHere(pSrcPhrases, aNoteSN))
		{
			// error, so cause bailout after showing the user a message
			wxString errStr = _T(
			"Error in RestoreNotesAfterSourceTextEdit(), attempted to restore ");
			errStr += _T(
			"a Note at a location where there was supposed to be no Note already stored. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			return FALSE;
		}
		else
		{
			// these is no note at this location, so create it there now
			bool bAllsWell = CreateNoteAtLocation(pSrcPhrases, aNoteSN, strNoteText);
			if (!bAllsWell)
			{
				// there was an unexpected error - either a bounds error, 
				// or a note already present
				wxString errStr = _T(
				"Error in RestoreNotesAfterSourceTextEdit(), the CreateNoteAtLocation() ");
				errStr += _T(
				"function returned FALSE, either because of a bounds error (past doc end) or ");
				errStr += _T(
				"there really was a Note already stored at this location when all the many ");
				errStr += _T("previous checks said there wasn't!! ");
				errStr += _T(
				"Edit process abandoned. Document restored to pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				return FALSE;
			}
		}
	}

	// Test the error handling code by returning FALSE, comment out next line when
	// the error handling code is working right, and instead return TRUE
	//return FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there were no errors, FALSE if there was an error
/// \param      pSrcPhrases -> pointer to the app's m_pSourcePhrases list, after the
///                            user's edit source text has been made to replace the
///                            original selection and m_nSequNumber values in all
///                            CSourcePhrase instances in pSrcPhrases have been made
///                            sequential from 0 at the list's start
/// \param      pRec        -> pointer to the EditRecord for the vertical edit process
/// \param      context     -> a WhichContextEnum enum value which is either
///                            precedingContext (0) or followingContext (1)
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The passed in EditRecord contains the information about the source text edit which has
/// just been completed, and it includes an array, arrNotesSequNumbers, which stores in
/// normal order the sequence number indices for each Note that was removed from the
/// original editable span (this span will have been extended beyond the user's selection
/// to include all of any retranslation(s) it overlaps, but if there were no such overlaps
/// then it was the same as the user's selection). The array is used to assist in
/// relocating the removed notes. GetMovedNotesSpan is called after the edited source text
/// has been incorporated into the document list, but immediately prior to the attempt to
/// recreate any temporarily removed Notes from the editable span (possibly extended, see
/// previous paragraph). The Note restoration process, if there are many notes, or the user
/// removed source text where Notes were stored, may need to move unremoved notes in the
/// preceding context leftwards, or in the following context rightwards, in order to make
/// gaps for placing the temporarily removed Notes. Any such Note movements would
/// invalidate the Note placements in the cancel span, so that if the user asks for a
/// Cancel, or there is an error requiring the original state of the document to be
/// rebuilt, the Notes could end up duplicated in nearby locations, or worse. The solution
/// to this connundrum is to work out the maximum number of possible moves that the
/// algorithms for Note replacement might request in order to form gaps, at both preceding
/// and following context (with respect to the edit span) and make deep copies of that many
/// CSourcePhrase instances in one or the other context (depending on the passed in context
/// value) prior to the Note restoration being initiated. If a Cancel or bail it is later
/// requested, then the first thing to be done is to restore these preceding and following
/// small contextual sublists, so that the pre-Note-moves state of the pSrcPhrases list is
/// restored, and then the cancel span will be able to be used without error in the rest of
/// the document restoration process. The EditRecord stores these two sublists in its
/// follNotesMoveSpanList and precNotesMoveSpanList members.
/// BEW 26May08	function created as part of refactoring the Edit Source Text functionality
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetMovedNotesSpan(SPList* pSrcPhrases, EditRecord* pRec, 
									  WhichContextEnum context)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxString errStr;
	int nEditSpanStartingSN = pRec->nStartingSequNum;
	int nEditSpanEndingSN;
	if (pRec->nNewSpanCount == 0)
	{
		nEditSpanEndingSN = pRec->nStartingSequNum;
	}
	else
	{
		nEditSpanEndingSN = pRec->nStartingSequNum + pRec->nNewSpanCount - 1;
	}
	int nMaxMoves = pRec->arrNotesSequNumbers.GetCount();
	// if the array has no members, the span does not need to be created
	if (nMaxMoves == 0)
		return TRUE;
    // there is at least one temporarily removed Note, so there is the possibility that a
    // non-removed Note may need to be moved at the Note restoration step; so we need to go
    // ahead and work collect the CSourcePhrase instances which would potentially be
    // involved in any such moves and copy those and store in pRec
	int nGapCount = 0;	// count how many CSourcePhrase instances without a Note 
            // stored there are traversed as we scan across them, leftwards in top block,
            // rightwards in the else block; when nGapCount == nMaxMoves, we've collected
            // enough instances; don't count any CSourcePhrase which has a stored Note in
            // it
	int nStartAt;
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = NULL; //POSITION pos = NULL;
	CSourcePhrase* pNewOne = NULL; // for creation of deep copies on the heap
	if (context == precedingContext)
	{
		// at this invocation, collect from the context preceding the edit span
		nStartAt = nEditSpanStartingSN - 1;
		if (nStartAt < 0)
		{
			// there is no preceding context, so return
			return TRUE;
		}
		pos = pSrcPhrases->Item(nStartAt); // initialize pos
		if (pos == NULL)
		{	
			errStr = _T(
"FindIndex() failed in GetMovedNotesSpan(), preceding context, pos value is NULL.");
			errStr += _T(
" Abandoning the edit process. Will attempt to restore original document state.");
			wxMessageBox( errStr, _T(""), wxICON_EXCLAMATION);
			return FALSE;
		}
		while (pos != NULL)
		{
			// count this CSourcePhrase instance if it has no Note stored in it
			pSrcPhrase = pos->GetData();
			pos = pos->GetPrevious();
			if (!pSrcPhrase->m_bHasNote)
				nGapCount++;
			// make a deep copy, and store it in the EditRecord
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			// In wxList Insert() without a position parameter always adds to the 
			// head of the list
			SPList::Node* posInsert = pRec->precNotesMoveSpanList.Insert(pNewOne);
			posInsert = posInsert; // to avoid warning in release build
			wxASSERT(posInsert != NULL);
			// check if the break out criterion has been met
			if (nGapCount == nMaxMoves)
			{
                // we've gotten sufficient preceding context for a safe restoration of the
                // sublist section which might have one or more moved Notes done within it
				break;
			}
		}
        // NOTE, the sublist in pRec will contain more than nGapCount CSourcePhrase
        // instances if the above while loop scanned across instances which contain a Note
        // already; these are not counted, but must be included in the sublist
	}
	else
	{
		// at this invocation, collect from the context following the edit span
		if (pRec->nNewSpanCount == 0)
			nStartAt = nEditSpanEndingSN;
		else
			nStartAt = nEditSpanEndingSN + 1;
		if (nStartAt > pApp->GetMaxIndex())
		{
			// there is no following context, so return
			return TRUE;
		}
		pos = pSrcPhrases->Item(nStartAt); // initialize pos
		if (pos == NULL)
		{	
			errStr = _T(
"FindIndex() failed in GetMovedNotesSpan(), following context, pos value is NULL.");
			errStr += _T(
" Abandoning the edit process. Will attempt to restore original document state.");
			wxMessageBox( errStr, _T(""), wxICON_EXCLAMATION);
			return FALSE;
		}
		while (pos != NULL)
		{
			// count this CSourcePhrase instance if it has no Note stored in it
			pSrcPhrase = pos->GetData();
			pos = pos->GetNext();
			if (!pSrcPhrase->m_bHasNote)
				nGapCount++;
			// make a deep copy, and store it in the EditRecord
			pNewOne = new CSourcePhrase(*pSrcPhrase);
			pNewOne->DeepCopy();
			SPList::Node* posInsert = pRec->follNotesMoveSpanList.Append(pNewOne);
			posInsert = posInsert; // to avoid warning in release build
			wxASSERT(posInsert != NULL);
			// check if the break out criterion has been met
			if (nGapCount == nMaxMoves)
			{
				// we've gotten sufficient following context for a safe restoration of the
				// sublist section which might have one or more moved Notes done within it
				break;
			}
		}
        // NOTE, the sublist in pRec will contain more than nGapCount CSourcePhrase
        // instances if the above while loop scanned across instances which contain a Note
        // already; these are not counted, but must be included in the sublist
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there was no error, FALSE if some kind of exception or bad value 
///             happened
/// \param      pRec           -> pointer to the EditRecord which has the info about
///                               bounds and spans etc
/// \param      pSrcPhrases    -> pointer to the document's m_pSourcePhrases member
/// \param      strNewSource   -> reference to the current (post-edit) new source text 
///                               which we potentially will be appending additional words
///                               to from the following context to the current editable
///                               span (and also, in parallel, extending the width of the
///                               editable span, etc)
/// \param      pMap           <- pointer to the document's map called m_FilterStatusMap, 
///                               which contains the "to-be-filtered" entries (probably 
///                               never more than one) which specify the particular SFM 
///                               we need to search for in order to determine where its 
///                               filterable content commences
/// \param      bWasExtended   <- returns TRUE to the caller if the function actually 
///                               extended the editable span -- the caller may not need to
///                               know this, but just in case we give it the knowledge of
///                               whether or not pRec had its contents altered; returns
///                               FALSE if the editable span was not extended (and
///                               therefore no changes made to pRec's contents)
/// \remarks
/// Called from: the View's OnEditSourceText().
/// The prototypical situation we have designed this function for is the following. \yy
/// would be an "unknown" marker, because it is not a marker in any known SFM set, not the
/// USFM set, not the 1998 PNG set. The document may contain ?\yy? in the navigation text
/// where there is word1 word2 word3 word4 etc, and the user decides to edit \yy to, say,
/// \r (a reference marker which is filterable by default). He then just selects word1 and
/// does Edit / Edit Source Text, and in the dialog changes \yy to \r and clicks OK. The \r
/// marker's content is, because it is a to-be-filtered marker, all supposed to be filtered
/// out, but his word selection for the editable span was only word1, rather than word1
/// word2 ... down to whatever word is last before the next SFM location (other than a
/// 'none' TextType one which we want to ignore). Adapt It then just filters the \r and
/// word1 as its content, and word2 word3 etc are left in the document as if they were
/// sacred text to be adapted. What the user should have done was to include all the word1
/// word2 word3 ... down to the end of the filterable content, in his original selection -
/// then Adapt It would filter the whole word string out properly. The
/// ExtendEditableSpanForFiltering() function, therefore, permits the user to do the
/// obvious thing (ie. select just word1 where the bad marker is stored under the hood) and
/// nevertheless get the whole of the bad marker's text contents filtered out, as if he'd
/// really selected all of the words of that material. The way the function works is to
/// scan rightwards from the end of the passed in editable span (pRec has that information)
/// until the end of the marker's filterable contents is found, where it will halt. We use
/// the HaltCurrentCollection() function to find the halt location, because it has the
/// smarts about the SFM set currently in operation, and it ignores the markers which have
/// their associated TextType with the value none. Each CSourcePhrase traversed without
/// causing a halt yields a source text word or phrase to be appended to strNewSource, a
/// deep copy of the CSourcePhrase is made and inserted in the appropriate spans - a very
/// tricky process because we throw away any Notes, free translations and/or collected back
/// translations which the user may have erroneously defined on that filterable material
/// (though we'd expect he wouldn't have ever put such things there, and usually the bad
/// marker would be edited long before he'd add such things to his document). Because of
/// the complexity of what is to be done in this function, we'll just make the insertions
/// of deep copied CSourcePhrase instances in the lists, and increment the "Ending"
/// sequence numbers for the various spans to comply with the extension of the editable
/// span. This should suffice, but if bailout of the vertical edit process happens then any
/// notes, free translations or collected back translations defined on this extra material
/// won't be recreated. The chances of that being a problem, however, are miniscule.
/// BEW created 5July08, for support of refactored Source Text Edit functionality
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ExtendEditableSpanForFiltering(
										EditRecord*					pRec, 
										SPList*						pSrcPhrases, 
										wxString&					strNewSource, 
										MapWholeMkrToFilterStatus*	WXUNUSED(pMap), 
										bool&						bWasExtended)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	bWasExtended = FALSE; // default starting value
	bool bFound_bt_mkr = FALSE;
	bool bIsHaltLocation = FALSE;
	//CString markers;
	int nIteratorSN = pRec->nEndingSequNum + 1;
	if (nIteratorSN > pApp->GetMaxIndex())
		return TRUE; // do nothing if the editable span ended at the document end
	CSourcePhrase* pSrcPhrase = NULL;
	SPList::Node* pos = pSrcPhrases->Item(nIteratorSN);
	if (pos == NULL)
	{
		wxMessageBox(_T(
"FindIndex() failed in ExtendEditableSpanForFiltering(), pos value is NULL. Saving and restoring document. Abandoning edit."),
		_T(""), wxICON_EXCLAMATION);
		wxCommandEvent evt;
		pApp->GetDocument()->OnFileSave(evt);
		return FALSE;
	}
	int nCancelSpanEnd = pRec->nCancelSpan_EndingSequNum; // it's also where the 
														  // modificationsSpan ends
	wxString aSpace = _T(' ');
	
    // scan forwards, until at a halt location (the very first CSourcePhrase might be a
    // halt location, so the scan might exit without any extension to the editable span)
	while (pos != NULL)
	{
		pSrcPhrase = pos->GetData();
		pos = pos->GetNext();
		nIteratorSN = pSrcPhrase->m_nSequNumber;
		bIsHaltLocation = HaltCurrentCollection(pSrcPhrase, bFound_bt_mkr);
		if (bIsHaltLocation)
		{
			// no further extension is needed, so exit the loop
			break;
		}
		else
		{
            // we need to add to the new source text, and increment the index for the end
            // of the editable span, and we also must check if we've gone past the end of
            // the cancel span - if the latter is true, then we must extend both the cancel
            // and modifications spans and increment their ending index (they always have
            // the same extent) and append a deep copy to each list
			bWasExtended = TRUE; // tell the caller an extension was done 
								 // (caller will put the value into pRec)
			strNewSource += aSpace + pSrcPhrase->m_srcPhrase;
			pRec->nEndingSequNum = nIteratorSN; // set the new end to the editable span
			pRec->nOldSpanCount += 1; // we are widening the old editable span
			pRec->nNewSpanCount += 1; // and also widening the new source text span
			pRec->nEndingTextType = pSrcPhrase->m_curTextType; // update, in case 
															   // it is different
			if (nIteratorSN > nCancelSpanEnd)
			{
				pRec->nCancelSpan_EndingSequNum = nIteratorSN;
				CSourcePhrase* 	pNewOne = new CSourcePhrase(*pSrcPhrase);
				pNewOne->DeepCopy();
				pRec->cancelSpan_SrcPhraseList.Append(pNewOne); // add a copy to the 
																// cancelSpan's list
				CSourcePhrase* 	pNewTwo = new CSourcePhrase(*pSrcPhrase);
				pNewTwo->DeepCopy();
				pRec->modificationsSpan_SrcPhraseList.Append(pNewTwo); // add a new 
												// copy to the modificationsSpan's list
				nCancelSpanEnd = nIteratorSN; // update; not nessessary, but harmless
			}
		}
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pSrcPhrases -> pointer to the app's m_pSourcePhrases list
/// \param      pRec        -> pointer to the EditRecord for the vertical edit process
/// \remarks
/// Called from: the View's CopyCSourcePhrasesToExtendSpan(), and OnEditSourceText().
/// Cancels out from the source text editing process. It clears the clearable parts of
/// the EditRecord, rolls back through the lists of CSourcePhrases using the user's
/// chosen order and restores the former document state
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::BailOutFromEditProcess(SPList* pSrcPhrases, EditRecord* pRec)
{
    // this must clear the clearable parts of the EditRecord, roll back through the lists
    // of CSourcePhrases using the user's chosen order .. anything else? No.
    
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gEditStep == sourceTextStep && gEntryPoint == sourceTextEntryPoint)
	{
        // What has to be done depends on whether the document's native structures have as
        // yet been modified. If they are as yet unchanged, we only need reinitialize the
        // edit record. If they have been changed, we have to use the cancel span and
        // propagation span and other parameters to get the document restored to what it
        // originally was prior to the commencement of the vertical edit at the source text
        // edit step
		if (!gbEditingSourceAndDocNotYetChanged)
		{
			// doc is modified, so undo what has been done, and then proceed 
			// to the reinitialization
			RestoreDocAfterSrcTextEditModifiedIt(pSrcPhrases, pRec);
		}
	}

	// do the resetting of the globals, so that we are ready for a new 
	// vertical edit process
	gbVerticalEditInProgress = FALSE;	
	gEntryPoint = noEntryPoint;
	gEditStep = noEditStep;
	gbEditingSourceAndDocNotYetChanged = TRUE;

	// get the phrase box restored, and set up the m_targetStr member of 
	// source phrase at that location
	wxString str3;
	if (pRec->nSaveActiveSequNum != -1)
	{
		pApp->m_nActiveSequNum = pRec->nSaveActiveSequNum;
		if (pApp->m_nActiveSequNum > pApp->GetMaxIndex())
			pApp->m_nActiveSequNum = pApp->GetMaxIndex();
	}
	else
	{
		// assume it is -1 because data was chopped off the end of the doc, so set active
		// sn to the last current sequence number, to give RecalcLayout() a chance
		pApp->m_nActiveSequNum = pApp->GetMaxIndex();
	}
	
    // BEW changed 19Jun09, the refactored code may well be able to restore correctly, let
    // it try - all we want to do here is make the old active sequ number and old box
    // contents be reestablished, and set a spurious active pile, even though wrong it
    // should make RecalcLayout() able to succeed
	pApp->m_pActivePile = GetPile(0);
	if (pApp->m_pActivePile != NULL)
	{
		str3 = pRec->oldPhraseBoxText;
		pApp->m_targetPhrase = str3;
		pApp->m_pTargetBox->ChangeValue(str3);
	}
	else
	{
		// layout not valid, shouldn't happen so just give a message & abort
		wxMessageBox(_T(
		"Null active pile pointer in BailOutFromEditProcess(), so will abort..."),
		_T(""), wxICON_EXCLAMATION);
		wxExit();
	}

	// remove selection
	RemoveSelection();

	// layout to ensurer that the targetBox won't encroach on the next cell's 
	// adaption text 
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif

	// get a new valid active pile pointer
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	GetLayout()->m_docEditOperationType = vert_edit_bailout_op;

	// ensure respect for boundaries is turned back on
	if (!pApp->m_bRespectBoundaries)
	{
		wxCommandEvent ev;
		OnButtonFromIgnoringBdryToRespectingBdry(ev);
	}
	gbInsertingWithinFootnote = FALSE; // restore default 
					// (it can be set in IsConstantType( ) )
	
	// scroll into view if necessary
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);
	
	// get the restored layout and phrase box redrawn
	pApp->m_pTargetBox->SetFocus();
	Invalidate();
	GetLayout()->PlaceBox();
	InitializeEditRecord(*pRec);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      bOnlyWithinSpan  -> default TRUE; explicitly set to FALSE to cause a 
///                                 unilateral storage attempt regardless of whether 
///                                 or not the active location is within the span of
///                                 the adaptationsStep or glossesStep
/// \remarks
/// Called from: the View's OnEditSourceText() and OnCustomEventEndVerticalEdit().
/// StoreText() always attempts the store. DoConditionalStore() wraps the StoreText() call
/// in a lot of tests, so that the store is only done when really wanted (eg, when the
/// phrase box contents were not copied). Store is not wanted if contents were copied, &
/// the user has not yet typed something nor clicked in the box, and the CPhraseBox class
/// member m_bAbandonable is still TRUE, and the box text is non-empty). When those things
/// don't obtain, we can be pretty certain the user has done some editing in the box and so
/// we'd expect to save that work if the box contents are about to be cleared. The flags we
/// need to look at are all globals (or, for the wxWidgets versions, they'd all be members
/// of the app class), and so we don't need to pass anything in; nor return anything. The
/// distinction between glossing and adapting modes is also handled internally too. And we
/// make sure that if the user had earlier removed the relevant entry from the KB or
/// glossing KB, whichever applies, then the store won't fail by having flags set on the
/// document at that point which are incompatible with the KB contents after said removal.
/// 
/// BEW created 1Aug08 by BEW, for support of refactored Source Text Edit functionality,
/// but could be used elsewhere if we ever refactor other code - the code here is cloned 
/// from part of PlacePhraseBox() and tweaked a bit
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::DoConditionalStore(bool bOnlyWithinSpan)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	EditRecord* pRec = &gEditRecord;
	wxString strBoxText;
	strBoxText = pApp->m_pTargetBox->GetValue(); // save, in case later failure requires 
												// the box contents be reconstructed

    // what we do depends on where the active pile is when this function is called. If the
    // user has clicked the End Now button while the phrase box is still in an active
    // editing step of Vertical Edit, then it is appropriate to save the box contents to
    // the KB before restoring the phrase box to the original position or suitable placee
    // nearby. On the other hand, if the box has been advanced in the lookup loop and has
    // reached the end of the current span and the dialog asking the user to either click
    // Next Step, Previous Step, End Now or Cancel All Steps is showing and he elects to
    // End Now, then the phrase box will be disengaged from the active pile: the box will
    // be showing at the last pile in the current span, but the active location will have
    // moved forward to the first hole beyond the end of the editing span currently active
    // (it could be adaptationsStep, glossesStep, or freeTranslationsStep) and so doing a
    // store would store garbage in such a situation. So we have to test for which end
    // state we have, and either do a store or restore the active location back to where
    // the phrase box is and not do a store (since it would have been done already at the
    // start of the lookahead loop); and then set up the phrase box at the appropriate
    // place in the document for when vertical editig mode is off. We use the current
    // m_pActivePile to determine where the active location is, and act accordingly.
	CPile* pPile = pApp->m_pActivePile;
	if (pPile == NULL)
	{
		// no active location is defined, so we can't store an adaptation or gloss, so exit
		return;
	}
	wxASSERT(pPile != NULL);
	bool bWithinSpan = FALSE;
	bool bFreeTransStepIsCurrent = FALSE; // storing to KB or glossingKB is needed 
										  // when FALSE, not when TRUE
	bool bUnknownStep = FALSE;
	int nCurSequNum = pPile->GetSrcPhrase()->m_nSequNumber;
	switch (gEditStep) {
		case adaptationsStep:
			if (nCurSequNum >= pRec->nAdaptationStep_StartingSequNum &&
				nCurSequNum <= pRec->nAdaptationStep_EndingSequNum)
			{
				bWithinSpan = TRUE;
			}
			break;
		case glossesStep:
			if (nCurSequNum >= pRec->nGlossStep_StartingSequNum &&
				nCurSequNum <= pRec->nGlossStep_EndingSequNum)
			{
				bWithinSpan = TRUE;
			}
			break;
		case freeTranslationsStep:
			bFreeTransStepIsCurrent = TRUE;
			if (nCurSequNum >= pRec->nFreeTranslationStep_StartingSequNum &&
				nCurSequNum <= pRec->nFreeTranslationStep_EndingSequNum)
			{
				bWithinSpan = TRUE;
			}
			break;
		default:
			bUnknownStep = TRUE;
	}

	if (!bOnlyWithinSpan)
	{
		// cause unilateral store attempt, provided other conditions are met
		bWithinSpan =  TRUE;
	}
	if (!bUnknownStep && bWithinSpan && !bFreeTransStepIsCurrent)
	{
		// any one of the following 3 tests is sufficient cause for attempting to store
		if (pApp->m_bUserTypedSomething || !pApp->m_pTargetBox->m_bAbandonable ||
			!gbByCopyOnly)
		{
			// make sure m_targetPhrase doesn't have any final spaces
			RemoveFinalSpaces(pApp->m_pTargetBox,&pApp->m_targetPhrase);

			// any existing phraseBox text must be saved to the KB or glossingKB, 
			// unless it's empty
			if (!pApp->m_targetPhrase.IsEmpty())
			{
				if (pApp->m_pTargetBox->IsModified()) //MFC uses GetModify()
				{
					// only save if something (eg a click or typing) has set the box's 
					// dirty flag
					if (pApp->m_pTargetBox->m_bAbandonable)
					{
                        // if abandonable, we want to throw away the text in the box, so
                        // clearing it will do the trick -- it makes the store operation do
                        // no store
						pApp->m_targetPhrase.Empty();
						pApp->m_pTargetBox->ChangeValue(_T(""));
					}
				}

				// it has to be saved to the relevant KB now
				if (!pApp->m_pTargetBox->m_bAbandonable || !gbByCopyOnly)
				{
					if (gbIsGlossing)
					{
                        // the store attempt would fail if the user earlier edited the
                        // entry out of the glossing KB, as the glossing KB cannot know
                        // which srcPhrases will be affected by such a change, so these in
                        // the document would still have their m_bHasGlossingKBEntry set
                        // true. We have to test for this, ie. a null pRefString, but that
                        // flag being TRUE is a sufficient test, and if so, set the flag to
                        // FALSE
						CRefString* pRefStr = GetRefString(pApp->m_pGlossingKB, 1,
												pApp->m_pActivePile->GetSrcPhrase()->m_key, 
												pApp->m_targetPhrase);
						if (pRefStr == NULL && 
								pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
							pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
						bool bOK;
						bOK = StoreText(pApp->m_pGlossingKB,
								pApp->m_pActivePile->GetSrcPhrase(),pApp->m_targetPhrase);
					}
					else
					{
						MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(),
											pApp->m_targetPhrase);
						RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);

                        // the store attempt would fail if the user earlier edited the
                        // entry out of the adaptation KB, as the adaptation KB cannot know
                        // which srcPhrases will be affected by such a change, so these in
                        // the document would still have their m_bHasKBEntry set true. We
                        // have to test for this, ie. a null pRefString, but that flag
                        // being TRUE is a sufficient test, and if so, set the flag to
                        // FALSE
						CRefString* pRefStr = GetRefString(pApp->m_pKB,
							pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
							pApp->m_pActivePile->GetSrcPhrase()->m_key,pApp->m_targetPhrase);
						if (pRefStr == NULL && 
								pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
							pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
						gbInhibitLine4StrCall = TRUE;
						bool bOK;
						bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->GetSrcPhrase(),
										pApp->m_targetPhrase);
						gbInhibitLine4StrCall = FALSE;
					}
				}
			} // end block for non-empty box contents
			else
			{
				// m_targetPhrase is empty, so let StoreText handle what needs to happen.
				bool bOK = FALSE;
				if (gbIsGlossing)
				{
					//pApp->m_pActivePile->m_pSrcPhrase->m_gloss = pApp->m_targetPhrase;

					// see above for why we do this
					CRefString* pRefStr = GetRefString(pApp->m_pGlossingKB, 1,
											pApp->m_pActivePile->GetSrcPhrase()->m_key,
											pApp->m_targetPhrase);
					if (pRefStr == NULL && 
							pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry)
						pApp->m_pActivePile->GetSrcPhrase()->m_bHasGlossingKBEntry = FALSE;
					bOK = StoreText(pApp->m_pGlossingKB,pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_targetPhrase);
				}
				else // is adapting
				{
					MakeLineFourString(pApp->m_pActivePile->GetSrcPhrase(),
										pApp->m_targetPhrase);
					RemovePunctuation(pDoc,&pApp->m_targetPhrase,from_target_text);

					// see above for why we do this
					CRefString* pRefStr = GetRefString(pApp->m_pKB,
						pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords,
						pApp->m_pActivePile->GetSrcPhrase()->m_key,pApp->m_targetPhrase);
					if (pRefStr == NULL && 
							pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry)
						pApp->m_pActivePile->GetSrcPhrase()->m_bHasKBEntry = FALSE;
					gbInhibitLine4StrCall = TRUE;
					bOK = StoreText(pApp->m_pKB,pApp->m_pActivePile->GetSrcPhrase(),
									pApp->m_targetPhrase);
					gbInhibitLine4StrCall = FALSE;
				}

				// check for a failure, abandon the function if the store failed? No, we'll
				// just continue processing - the store failure is not a major problem
				if (!bOK)
				{
					// for the present, do nothing
					;
				}
			}
		} // end block for m_bUserTypedSomething == TRUE
	}
}

void CAdapt_ItView::RestoreBoxOnFinishVerticalMode()
{
	EditRecord* pRec = &gEditRecord;
	CAdapt_ItApp* pApp = &wxGetApp();

    // when this function is called, the original pre-Vertical Edit Process mode (either
    // glossing or adapting) will have been restored, but the gEditRecord has not yet been
    // initialized so as to clear it; so use its contents to work out where the active
    // location should be put
	int nSequNum = pRec->nSaveActiveSequNum; // original location
	bool bOriginalLocationWithinSpan = FALSE;
	if (!gbIsGlossing)
	{
		// we are in adapting mode
		if (pRec->nAdaptationStep_NewSpanCount != 0) 
		{
			if (nSequNum >= pRec->nAdaptationStep_StartingSequNum &&
				nSequNum <= pRec->nAdaptationStep_EndingSequNum)
			{
				bOriginalLocationWithinSpan = TRUE;
			}
		}
	}
	else
	{
		// we are in glossing mode
		if (pRec->nAdaptationStep_NewSpanCount != 0) 
		{
			if (nSequNum >= pRec->nGlossStep_StartingSequNum &&
				nSequNum <= pRec->nGlossStep_EndingSequNum)
			{
				bOriginalLocationWithinSpan = TRUE;
			}
		}
	}

    // now we attempt to find a safe final active location; and it can be within a
    // retranslation if we are restoring glossing mode, but not if we are restoring
    // adapting mode; vertical edit in MFC legacy app is only available from a Source Text
    // Edit, and it is not possible to do that from free translations mode, so we know we
    // are not restoring to the latter mode (**** NOT TRUE for wxWidgets *** where
    // eventually vert edit will be available in any mode except when collecting back
    // translations -- in that case extend this function to handle those extra options)
	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pOldSrcPhrase = NULL;
	if (!gbIsGlossing)
	{
		// adapting mode was on when the user first entered the edit process
		// & is now back on 
		if (bOriginalLocationWithinSpan || pRec->nAdaptationStep_NewSpanCount == 0)
		{
            // the original location was either within the (non-empty) span, or the span is
            // now empty because the user deleted all of its CSourcePhrase instances - in
            // which case the old sequence number at entry would now be somewhere in the
            // context or even possibly beyond the end of the document, so we have to look
            // carefully for a suitable place to rebuild the box -- it could be within a
            // retranslation, so find a safe place to put the box
			if (nSequNum > pApp->GetMaxIndex())
			{
				// the old location is beyond the end of the document, so initialize to the
				// last CSourcePhrase instance in the document, and then check it is safe
				nSequNum =  pApp->GetMaxIndex();
			}
			pSrcPhrase = GetSrcPhrase(nSequNum); // won't return NULL because the 
												 // CSourcePhrase at nSequNum we know exists
			pOldSrcPhrase = pSrcPhrase; // in case we want to try again from same initial one
			wxASSERT(pSrcPhrase != NULL);
			if (pSrcPhrase->m_bRetranslation)
			{
                // this location is within a retranslation, and because of the possibility
                // the edit span may be at the end of the document, we'll look for a safe
                // location preceding the retranslation rather than following it
				pSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);
				if (pSrcPhrase == NULL)
				{
                    // we expect this never to happen, but if we can't find such a
                    // location, try following the the retranslation
					pSrcPhrase = pOldSrcPhrase;
					pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);
					if (pSrcPhrase == NULL)
					{
						// unthinkable, but if it happens, violate rule about retranslations 
						// and put the box within it!
						pSrcPhrase = pOldSrcPhrase;
					}
				}
			}
			// get the safe sequence number index
			nSequNum = pSrcPhrase->m_nSequNumber;
		}
		else
		{
            // the original location, being outside the span, must already be a safe
            // location, so do the restoration at nSequNum's location
			;
		}
	}

	// we now have the nSequNum at which we want to restore the box, so do it
	translation.Empty();
	pApp->m_targetPhrase.Empty();

	// now set up the phrase box
	pApp->m_nActiveSequNum = nSequNum; // needed, as a test for m_nActiveSequNum
				// < 0 done internally will have box placement skipped if we get 
				// here and it is -1
	pApp->m_pActivePile = GetPile(nSequNum);
	bool bFoundSomething = FALSE;
	if (!pRec->bGlossingModeOnEntry)
	{
		if (pApp->m_pActivePile->GetSrcPhrase()->m_adaption.IsEmpty())
			bFoundSomething = pApp->m_pTargetBox->LookUpSrcWord(this, pApp->m_pActivePile);
		if (bFoundSomething)
		{
			pApp->m_targetPhrase = translation;
		}
		else
		{
			translation = pApp->m_pActivePile->GetSrcPhrase()->m_adaption;
			pApp->m_targetPhrase = translation;
		}
	}
	else
	{
		if (pApp->m_pActivePile->GetSrcPhrase()->m_gloss.IsEmpty())
			bFoundSomething = pApp->m_pTargetBox->LookUpSrcWord(this, pApp->m_pActivePile);
		if (bFoundSomething)
		{
			pApp->m_targetPhrase = translation;
		}
		else
		{
			translation = pApp->m_pActivePile->GetSrcPhrase()->m_gloss;
			pApp->m_targetPhrase = translation;
		}
	}
	CLayout* pLayout = GetLayout();
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum); // BEW added 12June09

	pLayout->m_docEditOperationType = vert_edit_exit_op;
    // call Invalidate() in the caller, which is OnCustomEventEndVerticalEdit() & that is
    // the only place in the application where RestoreBoxOnFinishVerticalMode() is called
}

// public accessor
void CAdapt_ItView::EditSourceText(wxCommandEvent& event)
{
	OnEditSourceText(event);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      event       ->  (unused)
/// \remarks
/// OnEditSourceText handles the editing of one or more selected source text words or
/// phrases, or editing of the unselected source text word or phrase at the active pile.
/// On completion of the edit, it automatically checks for dependent information
/// (adaptation, gloss, free translation, back translation) at or overlapping the edited
/// region of the document, and if there is any such, it drops into a 'vertical edit' mode
/// at the appropriate entry point - depending on what dependent information is present
/// This function relinguishes responsibility for managing the document at view once
/// vertical edit has been entered; the vertical edit process manages itself until
/// completion or until the user exits it in one of a few prescribed ways.
/// 
/// BEW updated, 11Apr08++ to remove modalities, show filtered info with selected text,
/// extend selection if necessary to accomodate editing within or overlapping a
/// retranslation, handle endmarkers of the USFM standard adequately, and remove the child
/// dialog for marker transfer (This refactored version is part of a staged process, called
/// "vertical editing" which makes use of a global struct, gEditRecord, defined at the top
/// of this file.)
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnEditSourceText(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	EditRecord* pRec = &gEditRecord; // local pointer to the global EditRecord

    // we cannot have any synchronized scrolling messages be received, throwing the active
    // location to any old place during vertical edit mode, we have to keep total control
    // of the active location; so if it is currently on, save the setting, turn it off, and
    // use the saved setting to restore it back to its on state when we are done
	if (gbIgnoreScriptureReference_Receive == FALSE)
	{
		// it is currently ON, so save it and turn off
		gbVerticalEdit_SynchronizedScrollReceiveBooleanWasON = TRUE;
		wxCommandEvent uevent;
		GetDocument()->OnAdvancedReceiveSynchronizedScrollingMessages(uevent); 
													// toggle receiving to OFF
	}

	pRec->bGlossingModeOnEntry = gbIsGlossing; // save, for when original mode 
											   // is to be set up again
	pRec->bSeeGlossesEnabledOnEntry = gbEnableGlossing; // ditto

	gbEditingSourceAndDocNotYetChanged = TRUE;
	bool bUserCancelled = FALSE;
	int nFirstFollContextCSrcPhraseSN;
	int nFinalPrecContextCSrcPhraseSN;
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	CPile* pStartingPile;	// will change if the selection is programmatically 
							//extended leftwards (see above)
	CPile* pEndingPile;		// will change if the selection is programmatically 
							//extended rightwards
	int nStartingStripIndex; // may decrease if the selection is programmatically
							// extended leftwards
    // int nStartingSequNum, and int nEndingSequNum are in the EditRecord struct; these to
    // track the sequence number for the start of the (possibly extended programmatically)
    // selection (we don't actually extend the selection but just work out the new starting
    // and ending sequence number values)
	gnOldMaxIndex = pApp->GetMaxIndex(); // store the old value 
										 // -- this global may not be needed
	pRec->nNewSpanCount = -1; // -1 means "this value is undefined thus far"
	wxString str; // a temporary storage string
	str.Empty();
	wxString str2; // second temporary storage string
	str2.Empty();
	wxString strSource; // the source text which is to be retranslated 
						// (from m_srcPhrase values)
	strSource.Empty();
	pApp->m_FilterStatusMap.clear(); // BEW added 16Jun05, entries will be \mrkr=0 or 
                // \mkr=1 for \mkr as key, with =0 meaning 'now to be unfiltered' and
                // =1 meaning 'now to be filtered'
    // save the active sequ number, so we can later determine whether or not the active
    // location lies within the selection (if it's not in the selection, we will need to
    // recreate the phrase box at the former active location when done - BE CAREFUL,
    // because if the active location lies after the selection and the selection contains
    // null src phrases or merged phrases, then the value of nFormerActiveSequNum will need
    // to be updated as we remove null src phrases and / or unmerge merged phrases); and
    // (for 11Apr08 code changes) the active location may start out outside the selection
    // but for acceptance of the user's edit, we put it always at the start of the new
    // source text (ready for updating adaptations in next step of the vertical edit
    // process), or if there is no new text, at the start of the following context (or a
    // safe location if that is a retranslation) -- so our refactored code probably won't
    // make use of the saved value much
	pRec->nSaveActiveSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;
	pDoc->ResetPartnerPileWidth(pApp->m_pActivePile->GetSrcPhrase()); // mark its strip 
																	  // as invalid 
	// preserve the active location's phrase box text, in case 
	// the phrase box is recreated there when done
	pRec->oldPhraseBoxText = pApp->m_targetPhrase;

	CSourcePhrase* pSrcPhrase = NULL;
	CSourcePhrase* pEndingSrcPhrase = NULL;
	wxString strAdapt; // accumulates the existing adaptation text for the selection
        // using the m_targetStr member of each CSourcePhrase instance (ie. includes
        // punctuation) but in the refactored code we don't make any use of this nor let
        // the user see it
	strAdapt.Empty();

    // NOTE: for the wxWidgets version, we need to add a CStringList to store the m_key
    // members (not m_srcPhrase members, because punctuation location may get changed in
    // the edit) which will assist us to work out what the former mergers were so we can
    // reconstitute them whenever their source text was unchanged (other than punctuation
    // changes) in the edit; we won't build that functionality yet however --- (may or may
    // not happen, jury still out)
    
	// Jim Henderson requested that CTRL + Q be able to invoke the handler without a
	// selection and just use the active location -- so made the OnUpdateEditSourceText()
	// handler not check for a selection, and need to check here for no selection and
	// provide a one-pile one at the active location
	if (pApp->m_selectionLine == -1 && pApp->m_selection.IsEmpty())
	{
		// there is no selection defined, so set up the active pile's source text as
		// the current selection (but no need to set m_bSelected to TRUE in the CCell
		// because this programmatically defined selection will never become visible
		pApp->m_selectionLine = 0;
		wxASSERT(pApp->m_pActivePile != NULL);
		CCell* pActiveCell = pApp->m_pActivePile->GetCell(0);
		pApp->m_pAnchor = pActiveCell;
		pApp->m_selection.Append(pActiveCell);
	}

	CPile* pPile; // to be used as a scratch variable
	CCellList::Node* pos = pApp->m_selection.GetFirst();
	CCell* pCell = pos->GetData();
	pos = pos->GetNext();
	pPile = pCell->GetPile();
	pStartingPile = pPile; // need this for later when we look up the strip which
						   // first pile is in prior to calling RecalcLayout()
	// store start location for the user's selection
	pRec->nStartingSequNum = pStartingPile->GetSrcPhrase()->m_nSequNumber; 

	// get the pointer to the CSourcePhrase at the start of the user's selection
	pSrcPhrase = pStartingPile->GetSrcPhrase();
	pRec->nStartingTextType = pSrcPhrase->m_curTextType; // so we can set it on
											// any extra inserted sourcephrases
	pos = pApp->m_selection.GetLast();
	pCell = pos->GetData();
	pPile = pCell->GetPile(); // pile at end of unextended selection
	pEndingPile = pPile;
	pEndingSrcPhrase = pEndingPile->GetSrcPhrase();
	wxASSERT(pEndingSrcPhrase != NULL);
	pRec->nEndingSequNum = pEndingSrcPhrase->m_nSequNumber;
	pRec->nEndingTextType = pEndingSrcPhrase->m_curTextType;
    // (if the selection is extended at either or both ends because of a retranslation
    // being present and is not co-terminous with both ends of the selection, then the
    // values of the sequence number and TextType stored in pRec will be changed as a
    // result of code which follows below)

	gbVerticalEditInProgress = TRUE; // as soon as we change the EditRecord, we set 
				// this boolean - even though the user may Cancel the edit later on
	gEntryPoint = sourceTextEntryPoint; // set the global enum variable to the 
				// starting type for this vertical edit
	gEditStep = sourceTextStep; // indicate that editing of source text is the 
				// current step within the vertical edit process

	int nSaveSequNum = pSrcPhrase->m_nSequNumber; // save the sequ number of the 
        // start of user's selection -- though we must update this value to a smaller value
        // if automatic selection extension to earlier sequence numbers happens below (for
        // example, if user selectted some source text words in the middle of a
        // retranslation)... nSaveSequNum is from the legacy code, in this refactored 2008
        // code it is retained as an alias for nStartingSequNum

    // initialize the cancel span from the user's selection span (the modifications span
    // does not need separate indices, as it is always co-extensive with the cancel span,
    // so the same indices apply to both spans)
	pRec->nCancelSpan_StartingSequNum = pRec->nStartingSequNum;
	pRec->nCancelSpan_EndingSequNum = pRec->nEndingSequNum;

    // do any required selection 'extension' (actually only possibly new sequence numbers
    // are returned), returning TRUE if there was no error, FALSE there was an error. The
    // bWasExtended BOOL parameter returns TRUE if extension and either or both ends was
    // done, FALSE if no extension was required
	bool bWasExtended;
	bool bNoErrors = ExtendEditSourceTextSelection(pSrcPhrases, pRec->nStartingSequNum, 
													pRec->nEndingSequNum, bWasExtended);
	if (!bNoErrors)
	{
		// something went wrong, bail out (m_pSourcePhrases list contents have not yet 
		// been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level, 
			// so we can do so here;
exit:		BailOutFromEditProcess(pSrcPhrases, pRec); // clears the 
										// gbVerticalEditInProgress flag when done
			wxCommandEvent evt;
			pApp->GetDocument()->OnFileSave(evt);
		}
		return;
	}
	if (bWasExtended)
	{
        // extension to left or right or in both directions was done, so we have to reset
        // the relevant parameters above to new values (check later, I'm doing it
        // differently so we may not need all these parameters)
		pStartingPile = GetPile(pRec->nStartingSequNum); // returns NULL if it couldn't get it
		wxASSERT(pStartingPile != NULL);
		nStartingStripIndex = pStartingPile->GetStrip()->GetStripIndex();
		pSrcPhrase = pStartingPile->GetSrcPhrase();
		pRec->nStartingTextType = pSrcPhrase->m_curTextType; // the TextType value at the 
															// start of the new span
		pRec->bSpecialText = pSrcPhrase->m_bSpecialText;	// update the initial special 
															// text boolean value
		nSaveSequNum = pSrcPhrase->m_nSequNumber; // update the alias
		pEndingPile = GetPile(pRec->nEndingSequNum); // returns NULL if it couldn't get it
		wxASSERT(pEndingPile != NULL);
		pEndingSrcPhrase = pEndingPile->GetSrcPhrase();
		pRec->nEndingTextType = pEndingSrcPhrase->m_curTextType;

		// update the cancel span indices to comply with the extension just done
		pRec->nCancelSpan_StartingSequNum = pRec->nStartingSequNum;
		pRec->nCancelSpan_EndingSequNum = pRec->nEndingSequNum;
	}
	// set the EditRecord's value for the nOldSpanCount member
	pRec->nOldSpanCount = pRec->nCancelSpan_EndingSequNum - 
									pRec->nCancelSpan_StartingSequNum + 1;

	// make the required deep copy and store in the CObList for this
	// in the EditRecord as the cancel span's list
	bool bAllWasOK;
	bAllWasOK = DeepCopySourcePhraseSublist(pSrcPhrases, pRec->nCancelSpan_StartingSequNum, 
					pRec->nCancelSpan_EndingSequNum, &pRec->cancelSpan_SrcPhraseList);
	if (!bAllWasOK)
	{
        // something went wrong, bail out (m_pSourcePhrases list contents
        // have not yet been modified)
        if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level, 
			// so we can do so here;
			goto exit;
		}
	}
    // the cancelSpan_SrcPhraseList is always co-extensive with the modifications span, so
    // deep copy the one just delineated; we don't ever expect this to fail, so internally
    // just use try and catch blocks to check for any memory exceptions
	DeepCopySublist2Sublist(&pRec->cancelSpan_SrcPhraseList, 
							&pRec->modificationsSpan_SrcPhraseList);

    // now that we have the editable span delineated, (this is the material the user will
    // see), we need to determine if there are any glosses in this span and set the
    // gEditRecord's flag accordingly; and likewise for adaptations
	bool bHasGlosses = FALSE;
	bool bHasAdaptations = FALSE;
	bAllWasOK = IsGlossInformationInThisSpan(pSrcPhrases,pRec->nStartingSequNum, 
													pRec->nEndingSequNum,&bHasGlosses);
	if (!bAllWasOK)
	{
		// something went belly up, so restore original document state and 
		// bail out of the process
		goto exit;
	}
	pRec->bEditSpanHasGlosses = bHasGlosses;
	bAllWasOK = IsAdaptationInformationInThisSpan(pSrcPhrases,pRec->nStartingSequNum, 
											pRec->nEndingSequNum,&bHasAdaptations);
	if (!bAllWasOK)
	{
		// something went belly up, so restore original document state and 
		// bail out of the process
		goto exit;
	}
	pRec->bEditSpanHasAdaptations = bHasAdaptations;

    // The next sections of code determine if we need to widen the cancel span, and
    // modifications span, to include free translation whole sections; and then again, do
    // the same for collected back translations. If one or neither of these information
    // types is not present, clear the relevant flag(s) in the EditRecord struct. The way
    // we do this processing is to scan the present cancel span and determine what the
    // starting and ending sequence number bounds are, eg. for free translations
    // overlapping the editable subspan, then make a temporary list of deep copies of the
    // CSourcePhrase instances in the potentially wider span, then test the bounds to see
    // if extension before or after is needed, and if so, copy the relevant CSourcePhrase
    // deep copies to the cancel span's list and the modifications span's list (as both
    // these must contain the same instances). Doing these things, the original
    // m_pSourcePhrases list contents in the document class remains unchanged in any way,
    // so that if any of these processing steps fails, the document remains valid.
	SPList* pTempList = new SPList;

    // First: do any required extra scanning to left and right if the beginning of a free
    // translation section and/or the end of a free translation section, if present, are
    // not coterminous with the start and end of the span (possibly extended earlier)
    // derived from the user's original selection, returning TRUE in the bFreeTransPresent
    // parameter if there was some free translation data defined over the span, FALSE if
    // not; and the function returns TRUE if there was no error, FALSE if there was an
    // error
	bool bFreeTransPresent;
	bAllWasOK = GetEditSourceTextFreeTranslationSpan(pSrcPhrases, pRec->nStartingSequNum,
					pRec->nEndingSequNum, pRec->nFreeTrans_StartingSequNum, 
					pRec->nFreeTrans_EndingSequNum, bFreeTransPresent);
	if (!bAllWasOK)
	{
		// something went wrong, bail out (m_pSourcePhrases list contents have 
		// not yet been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called 
			// from a lower level, so we can do so here;
			goto exit;
		}
		else
			wxExit();
	}
	if (bFreeTransPresent)
	{
        // extension to left or right or in both directions was done if needed, but we
        // don't show any of the extra stuff to the user; we just use the wider span to
        // ensure we remove whole free translation sections because otherwise we'd corrupt
        // the document; so all we need do is do the relevant deep copy for the wider span,
        // and set the EditRecord flag
		pRec->bEditSpanHasFreeTranslations = TRUE;
		bAllWasOK = DeepCopySourcePhraseSublist(pSrcPhrases, pRec->nFreeTrans_StartingSequNum, 
												pRec->nFreeTrans_EndingSequNum, pTempList);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents have not 
			// yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, 
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

        // work out if the subspan for free translations starts earlier, or ends later,
        // than the current bounds for the cancel span; if so, work out the new bounds for
        // the cancel span's indices
		pRec->nCancelSpan_StartingSequNum = wxMin(pRec->nCancelSpan_StartingSequNum,
												pRec->nFreeTrans_StartingSequNum);
		pRec->nCancelSpan_EndingSequNum = wxMax(pRec->nCancelSpan_EndingSequNum,
												pRec->nFreeTrans_EndingSequNum);

        // Do any required extension of the "cancel span" list (extension is not assumed,
        // the function internally works out if it is needed and where, and does whatever
        // extending is required)
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList, 
							&pRec->cancelSpan_SrcPhraseList, 
							pRec->nStartingSequNum, pRec->nEndingSequNum);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents have not 
			// yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, 
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

        // Also do any required extension of the "modifications span" list (an alternative
        // way to do this would be to just do a deep copy of the cancel list using
        // CopyCSourcePhrasesToExtendSpan())
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList, 
										&pRec->modificationsSpan_SrcPhraseList, 
										pRec->nStartingSequNum, pRec->nEndingSequNum);
		
#ifdef _DEBUG
		SPList::Node* testpos = pRec->modificationsSpan_SrcPhraseList.GetFirst();
		int ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			testpos = testpos->GetNext();
			//wxLogDebug(_T("pRec->modificationsSpan_SrcPhraseList item %d at %x = %s"),
			//ct++, pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
#endif
#ifdef _DEBUG
		testpos = pTempList->GetFirst();
		ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			testpos = testpos->GetNext();
			//wxLogDebug(_T("pTempList item %d at %x = %s"),ct++,
			//pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
#endif
		if (!bAllWasOK)
		{
 			pDoc->DeleteSourcePhrases(pTempList);
			delete pTempList;
 			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents
            // have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, 
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

#ifdef _DEBUG
		testpos = pRec->modificationsSpan_SrcPhraseList.GetFirst();
		ct = 0;
		while (testpos)
		{
			CSourcePhrase* pSrcP;
			pSrcP = testpos->GetData();
			testpos = testpos->GetNext();
			//wxLogDebug(_T(
			//"After DeleteSourcePhrases pRec->modificationsSpan_SrcPhraseList item %d at %x = %s"),
			//ct++,pSrcP->m_srcPhrase, pSrcP->m_srcPhrase.c_str());
		}
#endif
	} // end block for test (bFreeTransPresent == TRUE)
	else
	{
        // clear the flag, and don't do a deep copy as we've no free translations
        // to remove later on; & set the stored sequence number values back to -1
        // since this span is undefined
		pRec->bEditSpanHasFreeTranslations = FALSE;
		pRec->nFreeTrans_StartingSequNum = -1;
		pRec->nFreeTrans_EndingSequNum = -1;
	}

    // do a third subspan, if it exists, for the collected back translations; the start of
    // such a span (if it exists) will usually be somewhere preceding the
    // pRec->nStartingSequNum value, and may even be preceding the
    // pRec->nFreeTrans_StartingSequNum value (if free translations are defined on this
    // editing context); but we don't require that the end of any back translation
    // collection span(s) be made to coincide with the end of the free translations span
    // nor with the end of the editable span - though typically if will end somewhere
    // shortly after the pRec->nEndingSequNum value.
	bool bBackTransPresent;
	bool bCollectedFromTargetText = TRUE; // initialize to default value

	bAllWasOK = GetEditSourceTextBackTranslationSpan(pSrcPhrases, pRec->nStartingSequNum, 
			pRec->nEndingSequNum, pRec->nFreeTrans_StartingSequNum, 
			pRec->nFreeTrans_EndingSequNum, pRec->nBackTrans_StartingSequNum,
			pRec->nBackTrans_EndingSequNum, bBackTransPresent, bCollectedFromTargetText);
	if (!bAllWasOK)
	{
		// clear out the contents of the temporary list & delete the list itself
		pDoc->DeleteSourcePhrases(pTempList);
		delete pTempList;
		pTempList = NULL;
		// something went wrong, bail out (m_pSourcePhrases list contents have not yet 
		// been modified)
		if (gbVerticalEditInProgress)
		{
			// the bailout function has not already been called from a lower level, 
			// so we can do so here;
			goto exit;
		}
		else
			wxExit();
	}
	pRec->bCollectedFromTargetText = bCollectedFromTargetText; // store the returned 
            // value for later use in the backTranslationsStep (if there is no
            // collected back translation defined on the editable span, a default value
            // of TRUE is nevertheless stored in gEditRecord, but would not later be
            // used)
	if (bBackTransPresent)
	{
        // set the EditRecord's flag, and get the deep copy done of all the CSourcePhrases
        // in the back translation span (the back translations in this span will be later
        // removed so the user won't have to bother dealing with them while editing the
        // source text; they are abandoned rather than stored, because they can be
        // recollected later easily once this span is delineated
		pRec->bEditSpanHasBackTranslations = TRUE;
		bAllWasOK = DeepCopySourcePhraseSublist(pSrcPhrases,
								pRec->nBackTrans_StartingSequNum, 
								pRec->nBackTrans_EndingSequNum, pTempList);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list 
			// contents have not yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called 
				// from a lower level, so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

        // work out if the subspan for back translations starts earlier, or ends later,
        // than the current bounds for the cancel span; if so, work out the new bounds
        // for the cancel span's indices
		pRec->nCancelSpan_StartingSequNum = wxMin(pRec->nCancelSpan_StartingSequNum,
												pRec->nBackTrans_StartingSequNum);
		pRec->nCancelSpan_EndingSequNum = wxMax(pRec->nCancelSpan_EndingSequNum,
												pRec->nBackTrans_EndingSequNum);

        // Do any required extension of the "cancel span" list; take care, only the
        // instances prior to the minimum index for the start of the editable span and the
        // free translation span (if the latter exists) need be inserted, and only the
        // instances after than the maximim index for the end of the editable span and the
        // free translation span (if the latter exists) need to be appended
		int nEarliestAlreadyPresent = pRec->nStartingSequNum;
		int nLatestAlreadyPresent = pRec->nEndingSequNum;
		if (pRec->bEditSpanHasFreeTranslations)
		{
			nEarliestAlreadyPresent = 
				wxMin(pRec->nStartingSequNum,pRec->nFreeTrans_StartingSequNum);
			nLatestAlreadyPresent = 
				wxMax(pRec->nEndingSequNum,pRec->nFreeTrans_EndingSequNum);
		}
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList, 
						&pRec->cancelSpan_SrcPhraseList, nEarliestAlreadyPresent, 
						nLatestAlreadyPresent);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents have not 
			// yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, 
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}

        // Do any required extension of the "modifications span" list; take care, only the
        // instances prior to the minimum index for the start of the editable span and the
        // free translation span (if the latter exists) need be inserted, and only the
        // instances after than the maximum index for the end of the editable span and the
        // free translation span (if the latter exists) need to be appended
		bAllWasOK = CopyCSourcePhrasesToExtendSpan(pTempList, 
						&pRec->modificationsSpan_SrcPhraseList, nEarliestAlreadyPresent,
						nLatestAlreadyPresent);
		if (!bAllWasOK)
		{
			pDoc->DeleteSourcePhrases(pTempList);
			delete pTempList;
			pTempList = NULL;
			// something went wrong, bail out (m_pSourcePhrases list contents have not 
			// yet been modified)
			if (gbVerticalEditInProgress)
			{
				// the bailout function has not already been called from a lower level, 
				// so we can do so here;
				goto exit;
			}
			else
				wxExit();
		}
	} // end of block for test (bBackTransPresent == TRUE)
	else
	{
        // no back translations were defined on this editable span, so do no deep copy and
        // make sure the edit record has the appropriate values (redundant, but helps
        // understanding if we do it)
		pRec->bEditSpanHasBackTranslations = FALSE;
		pRec->nBackTrans_StartingSequNum = -1;
		pRec->nBackTrans_EndingSequNum = -1;
	}
	/*
	// check we got correct spans
	TRACE2("\n Editable   Span = %d , %d\n",pRec->nStartingSequNum,pRec->nEndingSequNum);
	TRACE2(" Free Trans Span = %d , %d\n",pRec->nFreeTrans_StartingSequNum,
														pRec->nFreeTrans_EndingSequNum);
	TRACE2(" Back Trans Span = %d , %d\n",pRec->nBackTrans_StartingSequNum,
														pRec->nBackTrans_EndingSequNum);
	TRACE2(" Cancel Span = %d , %d\n",pRec->nCancelSpan_StartingSequNum,
														pRec->nCancelSpan_EndingSequNum);
	int ii = 1; // a do-nothing statement for a break point for the TRACE macros	
	*/
	// clear out the contents of the temporary list & delete the list itself
	pDoc->DeleteSourcePhrases(pTempList);
	delete pTempList;
	pTempList = NULL;

    // Up to now, the CAdapt_ItDoc class's m_pSourcePhrases list which defines the document
    // contents has not been altered in any way. We are now about to do modifications of
    // the information in the CSourcePhrase instances in the (deep copied) modifications
    // list, the modifications being to remove potentially large slabs of information which
    // the user would find distracting to see while trying to edit the source text - such
    // info is notes, collected back translations, free translations; also since the source
    // will change, old adaptations and glosses (we'll preserve copies of these for access
    // in the combobox later, but not remove them from the editable span because the
    // editable span will be abandoned and replaced by newly parsed material, so there is
    // no point in removing anything from what is going to be thrown away anyway). The
    // removed information types are preserved in lists which are made accessible in a
    // combobox at each stage of the overall process - except that back translations are
    // unilaterally abandoned, and notes are automatically restored (albeit, probably at
    // different locations, depending on how the user edits the source text). In keeping
    // with out design being not to alter any of the original document until after the user
    // commits to his changes in the dialog by hitting the OK key, the modifications will
    // be done on the deep copies in the modifications list; the cancel list will remain
    // untouched, as it must persist through the total vertical edit process in case the
    // use elects to Cancel out of the whole edit process, in which case the cancel list is
    // needed in order to help restore the original document state.
    //
    // The next major function call will scan across the modification list's CSourcePhrase
    // instances, (smartly, using knowledge stored in gEditRecord) the required information
    // removals and sequestering in lists within gEditRecord. When it completes, various
    // CSourcePhrase instances will be simplified in their m_markers member(we don't bother
    // to unmerger any mergers, as there is no need to do so), and then afterwards we
    // accumulate the source text string from the simplified instances in order to show it
    // to the user for editing. We must also handle movement of initial endmarkers at
    // either end of the editable span; see notes further below for details.

    // To keep removals done left to right in the order top to bottom in lists, we must add
    // the removed information types to temporary lists, using AddTail(), and then insert
    // the sublists at the head of the final storage lists. The strings saved are copies,
    // so later deletion of the old CSourcePhrase edited instances will leave the string
    // copies in the wxArrayString instances intact.
	wxArrayString* pAdaptList = new wxArrayString; // MFC uses CStringList
	wxArrayString* pGlossList = new wxArrayString;
	wxArrayString* pFTList = new wxArrayString;
	wxArrayString* pNoteList = new wxArrayString;

	// a couple of local variables for the start and end of the editable span
	// are convenient here 
	int nStartAt = pRec->nStartingSequNum; // can't be -1
	int nEndAt = pRec->nEndingSequNum; // can't be -1

    // We have to handle any preceding information's endmarkers stored at the start of the
    // editable span (we find out what they are and store them, including their final
    // delimiting white space(s)), and any following information's storage of endmarkers
    // belonging to the end of the editable span also has to be determined, stored in pRec
    // for later appending to the end of the editable string which the user eventually will
    // see -- but nothing is appended if there are no endmarkers at that location in the
    // first place.
	wxString strInitialEndmarkers; // pRec also has a member of this name
	wxString strFinalEndmarkers; // ditto
	strInitialEndmarkers.Empty(); strFinalEndmarkers.Empty();
	
    // The editable span may end where there may have been endmarkers, in which case they
    // will have been stored at the beginning of the m_markers member of the CSourcePhrase
    // instance immediately following the editable span. Check for this, and if found,
    // store a copy of them in a CString in pRec
	nFirstFollContextCSrcPhraseSN = nEndAt + 1;
	if (nFirstFollContextCSrcPhraseSN <= pApp->GetMaxIndex())
	{
        // there is a CSourcePhrase instance following the last one in the editable span,
        // so check for a non-empty m_markers member in it, and if there is such then check
        // for any initial endmarkers in it - any of these must be copied, along with
        // delimiting following space(s), and stored in pRec (note, we do this check on the
        // document's m_pSourcePhrases list, rather than a copied sublist, to be sure that
        // we can access the first CSourcePhrase instance following the editable context
        // where the check is to be done
		CSourcePhrase* pSrcPhrase2 = NULL;
		SPList::Node* pos2 = pSrcPhrases->Item(nFirstFollContextCSrcPhraseSN);
		wxASSERT(pos2); // the above is unlikely to fail
		if (pos2 != NULL)
		{
			bool bLacksFinalEndmarkers = TRUE;
			pSrcPhrase2 = pos2->GetData(); // MFC uses GetAt()
			wxASSERT(pSrcPhrase2 != NULL);
			strFinalEndmarkers = RemoveInitialEndmarkers(pSrcPhrase2, pApp->gCurrentSfmSet,
					bLacksFinalEndmarkers,TRUE); // TRUE means "copy only, don't remove"
			if (!bLacksFinalEndmarkers && !strFinalEndmarkers.IsEmpty())
			{
				// we've got a copy of one or more consecutive endmarkers, 
				// so store it for later on
				pRec->strFinalEndmarkers = strFinalEndmarkers;
			}
		}
		else
		{
			wxMessageBox(_T(
"FindIndex() failed in OnEditSourceText(), pos value is NULL when finding following endmarkers. Saving document, abandoning edit."),
			_T(""), wxICON_EXCLAMATION);
			goto exit;
		}
	}
    // do the same, for any endmarkers stored at the start of the editable span - these
    // later must be removed from the start of the editable string which the user will see,
    // before he sees it
	nFinalPrecContextCSrcPhraseSN = nStartAt;
	CSourcePhrase* pSrcPhrase2 = NULL;
	SPList::Node* pos2 = pSrcPhrases->Item(nFinalPrecContextCSrcPhraseSN);
	wxASSERT(pos2); // the above is unlikely to fail
	if (pos2 != NULL)
	{
		bool bLacksInitialEndmarkers = TRUE;
		pSrcPhrase2 = pos2->GetData();
		wxASSERT(pSrcPhrase2 != NULL);
		strInitialEndmarkers = RemoveInitialEndmarkers(pSrcPhrase2, pApp->gCurrentSfmSet,
				bLacksInitialEndmarkers,TRUE); // TRUE means "copy only, don't remove"
		if (!bLacksInitialEndmarkers && !strInitialEndmarkers.IsEmpty())
		{
			// we've got a copy of one or more consecutive endmarkers, 
			// so store it for later on
			pRec->strInitialEndmarkers = strInitialEndmarkers;
		}
	}
	else
	{
		wxMessageBox(_T(
"FindIndex() failed in OnEditSourceText(), pos value is NULL when finding preceding endmarkers. Saving document, abandoning edit."),
		_T(""), wxICON_EXCLAMATION);
		goto exit;
	}
	
    // Do the scan for removing and sequestering removed information; the CSourcePhrase
    // instances scanned are those in the modifications list - these are deep copies of
    // those on the document, and so we still will not have changed any of the document
    // as yet, only fiddled with copies so far
	bool bAllsWell = ScanSpanDoingRemovals(&pRec->modificationsSpan_SrcPhraseList, pRec,
											pAdaptList, pGlossList, pFTList, pNoteList);
	if (!bAllsWell)
	{
        // something fouled up, the bailout function has not already been called from a
        // lower level, so we can do so here; but first remove the temp string lists and
        // their data, to avoid memory leaks
bailout:	pAdaptList->Clear();
		pGlossList->Clear();
		pFTList->Clear();
		pNoteList->Clear();
		delete pAdaptList;
		delete pGlossList;
		delete pFTList;
		delete pNoteList;
		goto exit;
	}

    // Get the insertions done for the removed information, putting the information into
    // gEditRecord, and then deleting the temporary CStringList instances (but leave their
    // contents unremoved because the gEditRecord will manage those strings instead)
	bool bResult = TRUE;
	wxString errStr;
	if (pAdaptList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pAdaptList, adaptationsList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T(
"InsertSublistAtHeadOfList() for adaptations sublist, failed. Unknown list requested. ");
			errStr += _T(
			"Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			goto bailout;
		}
	}
	if (pGlossList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pGlossList, glossesList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T(
"InsertSublistAtHeadOfList() for glosses sublist, failed. Unknown list requested. ");
			errStr += _T("Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			goto bailout;
		}
	}
	if (pFTList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pFTList, freeTranslationsList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T(
"InsertSublistAtHeadOfList() for free translations sublist, failed. Unknown list requested. ");
			errStr += _T(
			"Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			goto bailout;
		}
	}
	if (pNoteList->GetCount() > 0)
	{
		bResult = InsertSublistAtHeadOfList(pNoteList, notesList, pRec);
		if (!bResult)
		{
			// there was an error (an unknown list was requested in the switch)
			errStr = _T(
"InsertSublistAtHeadOfList() for notes sublist, failed. Unknown list requested. ");
			errStr += _T(
			"Edit process abandoned. Document restored to pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			goto bailout;
		}
	}

	// don't leak memory, delete the local lists now their contents have been inserted at
	// the top of the respective persistent lists
	delete pNoteList;
	delete pFTList;
	delete pGlossList;
	delete pAdaptList;

    // We are now ready to accumulate the editable text from the editable span, and append
    // any endmarkers stored in the document at the first CSourcePhrase instance of the
    // context following the editable span (such endmarkers logically belong with the
    // editable text, at its end). These endmarkers, if present at that location, are
    // stored already in gEditRecord in its strFinalEndmarkers member. Likewise, endmarkers
    // stored in m_markers of the first CSourcePhrase of the editable span do not belong
    // logically with the source text to be edited, but rather with the source text which
    // ends at the end of the context material before the editable span; hence these have
    // to be removed from the accumulated string before it is shown to the user -- and
    // those endmarkers, if present at that location, are stored already in gEditRecord in
    // its strInitialEndmarkers member. The accumulation, however, is not done from the
    // unmodified CSourcePhrase instances in the m_pSourcePhrases list in the document, but 
    // from the modified deep copies in the modifications list.
	bAllsWell = ScanSpanDoingSourceTextReconstruction(&pRec->modificationsSpan_SrcPhraseList, 
					pRec, pRec->nStartingSequNum, pRec->nEndingSequNum, strSource);
	if (!bAllsWell)
	{
        // there was an error (could not obtain a valid pos value within the function, an
        // error message has already been shown, so try safely preserve the document and
        // then abort)
		goto bailout;
	}

    // There could be other filtered information in the reconstructed source text, which is
    // not a note, free translation or back translation, and it does not get removed. It
    // will therefore have \~FILTER and \~FILTER* marker and endmarker pairs wrapping each
    // such filtered marker and its content, eg. cross reference material. We must now
    // remove these filter wrapping markers because the parse of the edited source text
    // will refilter such material, and if we don't remove the \~FILTER and \~FILTER*
    // pairs, we'd end up with extra ones wrapping the ones already present. The global C
    // strings filterMkr and filterMkrEnd store these markers. Search for them and the
    // following space for each, and remove them.
	RemoveFilterWrappersButLeaveContent(strSource);

    // BEW changed 7May08: update to keep the KB properly updated, provided the active
    // location is not in the selection, but if it is, then we don't update because the
    // active location's source word may no longer exist after the user finishes editing
    // the source. The box, and m_targetPhrase, will be reconstituted later appropriately,
    // depending on what the user does in the edit -- if there was some text remaining
    // after his edit, the box will be placed at the CSourcePhrase instance which stores
    // the edited source's first word.
	int nOldSaveActiveSequNum = pRec->nSaveActiveSequNum;
	bool bActiveLocationWithinEditableSpan = 
		(nOldSaveActiveSequNum >= pRec->nStartingSequNum) &&
		(nOldSaveActiveSequNum <= pRec->nEndingSequNum) ? TRUE :  FALSE;
	if (!bActiveLocationWithinEditableSpan  && pApp->m_pActivePile != NULL)
	{
        // the active location is not within the retranslation section, and the layout is
        // still valid, so update KB for this location's phrase box contents (if the user
        // has not finished making it a valid string when he invoked the source text edit,
        // then too bad - it will go 'as is' into the KB, unless internal tests require the
        // store be skipped)
		DoConditionalStore(FALSE); // FALSE is bOnlyWithinSpan, it forces unilateral 
								   // store if other conditions are met
	}
	pApp->m_targetPhrase.Empty();	// empty m_targetPhrase; because the box may be built 
									// elsewhere after editing
	if (pApp->m_pTargetBox != NULL)
	{
		pApp->m_pTargetBox->ChangeValue(pApp->m_targetPhrase);
	}

    // need to clobber the selection now, so the selection globals will be set to -1, etc,
    // otherwise RecalcLayout will fail at its RestoreSelection() call
	RemoveSelection();

	// The document's native structures are as yet still unchanged.

    // create the edit source text dialog; then prepare the preceding and following context
    // strings (we decline to display the SFM markup in the context strings, because we
    // want to make it easy for the user to just follow what the source text meaning
    // actually is
	CEditSourceTextDlg dlg(pApp->GetMainFrame());

	// initialize the edit boxes
	dlg.m_strOldSourceText = strSource;
	dlg.m_strNewSourceText = strSource;
	wxString precedingSrc;
	precedingSrc.Empty();
	wxString followingSrc;
	followingSrc.Empty();
	wxString precedingTgt;
	precedingTgt.Empty();
	wxString followingTgt;
	followingTgt.Empty();
    // the following call needs the target text's CString variables passed in, but the Edit
    // Source Text functionality does not use the values returned in them; these context
    // strings are built up from the meanings in the document's m_pSourcePhrases list,
    // because getting sufficient context may require looking at CSourcePhrase instances
    // preceding and/or following those in any of the sublists thus far populated
	GetContext(pRec->nStartingSequNum,pRec->nEndingSequNum, precedingSrc, followingSrc,
				precedingTgt, followingTgt); 
	dlg.m_preContext = precedingSrc;
	dlg.m_follContext = followingSrc;

	// put up the Edit Source Text dialog's window
	bool bMarkerSetsAreDifferent = FALSE;
	if (dlg.ShowModal() == wxID_OK)
	{
		// the user has committed to the edit changes he has made, so from here on we
		// can now actually modify the document's contents
		wxString strNewSrcText = dlg.m_strNewSourceText;
		int nNewCount = 0; // number of CSourcePhrase instances to be returned from the 
						   // tokenization operation
		bool bFirstIsFirstOfType = FALSE; // BEW added 6Aug08 to help control text type 
						// and colour if the user deletes the whole of the editable span
		CPile* pFirst = GetPile(pRec->nStartingSequNum);
		bFirstIsFirstOfType = pFirst->GetSrcPhrase()->m_bFirstOfType; // use this below

		// treat the doc as dirty, regardeless of the outcome
		pDoc->Modify(TRUE);

        // Before we do anything to the CSourcePhrase instances, we have to set up a
        // correct value for the chapter number used in the Document's member m_curChapter,
        // which is to have a value of the form "n:" where n is the chapter number. We have
        // a legacy function for detecting what chapter we are in given a passed in pointer
        // to a CSourcePhrase, so we use that, passing in the instance which is at the
        // start of the editable span. We need to do this here before TokenizeTextString()
        // is called, because the latter calls TokenizeText(), which in turn uses
        // m_curChapter. Remember, we can't assume there will have been a \c marker within
        // the user's selection, but there may well be a \v, and on that CSourcePhrase
        // instance we need to set a valid m_chapterVerse, of the form "n:m", and
        // TokenizeText() uses the m_curChapter value to set the "n:" part, so now we must
        // make sure the value it is going to use is correct now get the preceding
        // CSourcePhrase's pointer (ie. preceding the editable span), it could be NULL
		CSourcePhrase* pInitialSrcPhrase = NULL;
		int aSequNum = pRec->nStartingSequNum; // location of start of edit span (possibly 
											   // extended)
		SPList::Node* aPos = pSrcPhrases->Item(aSequNum); // returns NULL if out of bounds
		if (aPos != NULL)
		{
			// we are not at the start of the document, so there is preceding context
			pInitialSrcPhrase = aPos->GetData();

            // set the doc's m_curChapter string, because it could have any arbitrary value
            // left in it from some earlier parse (with colon following it), and since our
            // editable span might have a verse number before the chapter number, or no
            // chapter number at all, in either of those cases we would have a wrong n:m
            // value being set
			pApp->m_curChapter = _T("0:"); // default if there are no chapter markers
			if (pInitialSrcPhrase != 0)
			{
				// get chapter and verse
				wxString cv = GetChapterAndVerse(pInitialSrcPhrase);
				if (cv.GetChar(0) == _T('0'))
				{
					// there are no chapter numbers, so leave the default zero at the 
					// start to flag this fact
					;
				}
				else
				{
					// remove verse numbers from n:m until only n: remains
					int offset = cv.Find(_T(':'));
					if (offset != -1)
					{
						// found it
						wxString left = cv.Left(offset + 1);
						pApp->m_curChapter = left;
					}
				}
			}
		}
		 
        // Detect whether or not the user has edited the SF markers - specifically, if
        // there is at least one SF marker in the edited text which is not in the original
        // text, or vise versa. If either is the case, we later want to call
        // DoMarkerHousekeeping() over the whole document to ensure that any typo markers
        // get appropriately handled as far as nav text, text colour and TextType are
        // concerned. The TokenizeTextString() call will do any needed unfiltering or
        // filtering. The AreMarkerSetsDifferent() function below (see Helpers.cpp) also
        // does tests, if the return value is TRUE, to determine if unfiltering, and/or
        // filtering will get done. We need to know about any filtering due to a respelled
        // marker in order to make sure all the filterable content is included in the
        // editable span - so if the user has not done that, we'll do it further below
        // programmatically. The algorithm checking marker status is not foolproof, but it
        // should take care of all or most situations that are reasonably expected to be
        // handleable. We really only need it to handle a filtered marker which the user
        // edits so as to be a marker which should be unfiltered (that original marker may
        // or may not be an unknown one, it doesn't matter either way, and the destination
        // marker can likewise be, or not be, an unknown one); or, an unfiltered marker
        // which the user edits to be a marker which should be filtered (and similarly,
        // either being known or unknown doesn't matter). Marker edits which require no
        // filtering change, whether unfiltered and remain so, or filtered and remain so,
        // don't need any attention here. The application class's string
        // gCurrentFilterMarkers is used internally to determine filterable status
		bool bFilteringRequired = FALSE;	// these two are set or cleared by the
											// following call, but it is the first with
		bool bUnfilteringRequired = FALSE;  // a TRUE value that we are interested in
		bMarkerSetsAreDifferent = 
			AreMarkerSetsDifferent(strSource, strNewSrcText,bUnfilteringRequired,
															bFilteringRequired);

        // Any unfiltering & filtering will be handled by the TokenizeTextString(), but it
        // doesn't necessarily handle required filtering completely because only the user's
        // selected words will get into the filtered content of a now-to-be-filtered marker
        // which has had its spelling changed in the edit source text dialog, and the user
        // may have intended to only edit the marker and so may have just selected the
        // first word (which carries the marker) rather than it and all subsequent words
        // which are to be filtered - in which case unless we do an edit span expansion
        // here, only the single selected word would be filtered and the rest of the
        // filterable content will stay unfiltered in the document. So, we check that
        // filtering of an edited marker has been called for, and if so, we check that the
        // whole of the marker's content (as far as preceding, but not including the first
        // CSourcePhrase instance which stores a marker for which the associated TextType
        // is not 'none' - the latter are things like keyword markup, italic markup, bold
        // markup, etc, and we just want Adapt It to completely ignore SFMs associated with
        // such things) is included in the editable span, and if not, we now extend the
        // editable span rightwards, altering the ending sequence numbers etc, and adding
        // copies of the CSourcePhrase instances thereby added at the end to the spans in
        // the EditRecord, etc, and adding the m_srcPhrase words, space delimited, to the
        // end of the strNewSrcText string, so that these extra words will be included in
        // the TokenizeTextString() call below. Doing these modifications right now gets
        // them done before the editableSpan_NewSrcPhrase List and
        // propagationSpan_SrcPhraseList are populated, and their spans' starting and
        // ending indices evaluated, and similarly for other EditRecord members having to
        // do with the location and properties of the "following context". We are doing
        // here what we'd prefer to have done before the dialog was opened but couldn't,
        // because we had to wait for the user to actually effect the respelling of a
        // marker.
		bool bWasExtended = FALSE;
		if (bFilteringRequired)
		{
			bool bIsOK;
			bIsOK = ExtendEditableSpanForFiltering(pRec, pSrcPhrases, strNewSrcText, 
								&pApp->m_FilterStatusMap, bWasExtended);
			if (!bIsOK)
			{
                // something went wrong and so we have to bail out; the document's
                // m_pSourcePhrases list's contents has not been altered by what happens
                // within ExtendEditableSpanForFiltering(), and so bailout is simple
				errStr = _T(
				"Failure when extending the editable span to handle filterable content. ");
				errStr += _T("Vertical edit process abandoned. "); 
				errStr += _T("Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto exit;
			}
			if (bWasExtended)
				pRec->bExtendedForFiltering = TRUE; // record the fact
		}

        // Tokenize the edited source text into a list of new CSourcePhrase instances on
        // the heap, pRec->nStartingSequNum is the absolute sequence number for first
        // source phrase in the sublist - it is used to define the starting sequence number
        // to be stored on the first element of the sublist, and higher numbers on
        // succeeding ones. Note: if marker status was changed in the edit, then any
        // filtering or unfiltering will be done here and all we need later do is call
        // DoMarkerHousekeeping() over the whole document to clean up the navigation text,
        // text types, colours, etc
		wxString chvStr = pApp->m_curChapter;

		nNewCount = TokenizeTextString(&pRec->editableSpan_NewSrcPhraseList, strNewSrcText,
										pRec->nStartingSequNum);
		pRec->nNewSpanCount = nNewCount; // this value may decrease by one if a 
                                // CSourcePhrase carrier of final endmarkers, but with no
                                // source text, is found to be present and therefore gets
                                // removed in the code below
        // *** from this point on, *** the document itself will be changed, so we indicate
        //     this is the case by setting the following global boolean to FALSE; the
        //     BailOut() function uses this value to work out what needs to be done if
        //     there was a cancel, or a failure after the document has been modified
		gbEditingSourceAndDocNotYetChanged = FALSE;

        // Before going further, we must replace the CSourcePhrase instances in the cancel
        // span with the modified ones in the modifications list. This is to ensure that
        // the changed CSourcePhrase instances resulting from the removed information which
        // was removed prior to displaying the dialog, actually find their way into the
        // document -- the instances we are particularly concerned with are those (if any)
        // preceding the start of the editable span, and those (if any) which follow the
        // end of the editable span, because those are not changed when the editable span's
        // content is replaced by the CSourcePhrase instances resulting from the parse of
        // the user's edited source text; so if we didn't do this substitution now, we'd
        // run the risk of the old free translations, & collected back translations,
        // remaining present (filtered) in those preceding and following contexts, when in
        // actual fact we want them removed so that the vertical edit process can help the
        // user to reconstitute them with appropriate changes.

		// do a while loop for looking at the pSrcPhrase instances of the modifications
		// span in debug mode
		/*
		SPList::Node* posTemp = pRec->modificationsSpan_SrcPhraseList.GetFirst();
		int modsCountFromCancelSpanBounds = 
			pRec->nCancelSpan_EndingSequNum - pRec->nCancelSpan_StartingSequNum + 1;
		int modsCountFromSublist = 
			(int)pRec->modificationsSpan_SrcPhraseList.GetCount();
		while (posTemp != NULL) {
			CSourcePhrase* pSP = posTemp->GetData();
			posTemp = posTemp->GetNext();
			int itsSequNum = pSP->m_nSequNumber;
			wxString itsSrcPhrase = pSP->m_srcPhrase;
			//wxString itsMarkers = pSP->m_markers;
			bool bItsFreeTransFlag = pSP->m_bHasFreeTrans;
			bool bItsStartFTflag = pSP->m_bStartFreeTrans;
			bool bItsEndFTflag = pSP->m_bEndFreeTrans;
		}
		*/
		int nHowMany = pRec->nCancelSpan_EndingSequNum - 
						pRec->nCancelSpan_StartingSequNum + 1;
		int nReplacementCount = nHowMany;

        // replace, in m_pSourcePhrases list, all of the instances in the cancel span, with
        // the parallel list of instances in the modification span -- the latter are
        // identical copies to those in the former, except that any notes, free
        // translations and/or collected back translations have been removed (and because
        // this modifies the doc, partner piles are created too) note: doing this is just
        // to prepare the document for the results of the user's source text editing, the
        // deletions and replacements for that are done about 500 lines below at the
        // TransferCompletedSrcPhrases() call
		bool bReplacedOK;
		bReplacedOK = ReplaceCSourcePhrasesInSpan(pSrcPhrases, 
				pRec->nCancelSpan_StartingSequNum, nHowMany, 
				&pRec->modificationsSpan_SrcPhraseList, 0, nReplacementCount);
		if (!bReplacedOK)
		{
            // if we had an error while replacing the modifications, we have to bail out
            // of the whole edit process, so try to save the document too
			errStr = _T(
			"Replacing with modified CSourcePhrases after dialog dismissal failed. ");
			errStr += _T("Vertical edit process abandoned. "); 
			errStr += _T("Will try now to restore the document to its pre-edit state.");
			wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
			BailOutFromEditProcess(pSrcPhrases,pRec);
			goto exit;
		}

		// do a while loop for looking at the pSrcPhrase instances after the 
		// replacements, in debug mode
		/* this code is MFC...
		int sn = pRec->nCancelSpan_StartingSequNum; // begin from start of cancel span
		POSITION pos2 = pSrcPhrases->FindIndex(sn);
		int modsCount = 0;
		while (pos2 != NULL) {
			CSourcePhrase* pSP = (CSourcePhrase*)pSrcPhrases->GetNext(pos2);
			modsCount++;
			int itsSequNum = pSP->m_nSequNumber;
			CString itsSrcPhrase = pSP->m_srcPhrase;
			//CString itsMarkers = pSP->m_markers;
			BOOL bItsFreeTransFlag = pSP->m_bHasFreeTrans;
			BOOL bItsStartFTflag = pSP->m_bStartFreeTrans;
			BOOL bItsEndFTflag = pSP->m_bEndFreeTrans;
			if (modsCount >= nHowMany)
				break;
		}
		*/

        // Because the user can edit the markup as readily as the source text, we cannot
        // assume that the old source text without any final endmarkers will remain that
        // way, nor the old source text with final endmarkers will remain that way, or even
        // that markers (and therefore TextType) won't change from what was in effect
        // before. The user may also have respelled a mispelled marker, resulting in
        // content being filtered. So we must assume nothing and check to see what is
        // there, and do processing appropriate for what we find. The first task is to
        // check the list of new CSourcePhrase instances to see if the end one is an
        // insertion just to carry widowed endmarkers or filtered info that was at the end
        // of the edited source text string. If either is the case, we need to do: (1) for
        // unfiltered endmarkers, move those endmarkers to the start of the first
        // CSourcePhrase instance in the following context - specifically, to the start of
        // its m_markers member; and then remove that carrier CSourcePhrase instance - we
        // can determine it is a carrier by checking that the m_follPunct and m_key members
        // are both empty strings. For (2), a carrier with now-filtered information, that
        // information will have been put into the m_markers member of the carrier, and the
        // same tests as in (1) apply. In either case we can't remove the carrier if there
        // is no following context (ie. the user's edit was done at the very end of the
        // document). We set up members of the EditRecord to store the pre-edit information
        // (in case the user Cancels, or an exception forces bail out back to the pre-edit
        // document state).

        // BEW additions 24Jan09: we must also handle (1) user's edit leaves just SF
        // markers in the edit box; (2) user's edit leaves SF markers other than endmarkers
        // at the end of the edited string. Situation (1) generates an empty single
        // CSourcePhrase storing the markers in m_markers, so we need to move those
        // contents to the following context's first CSourcePhrase and remove the empty
        // CSourcePhrase if was on. Situation (2) - we just need to ensure that the
        // existing code moves not just endmarkers to the first CSourcePhrase in following
        // context, but any initial markers too (no check is done on the markers if more
        // than one, we just assume the user got them right - he can edit again if he
        // didn't).

		gpFollSrcPhrase = NULL; // a global CSourcePhrase*
		int nFollowingSequNum = pRec->nEndingSequNum + 1; // could be beyond end of doc!
		SPList::Node* posFoll = NULL; // use this value if beyond end of doc
		int maxIndex = pSrcPhrases->GetCount() - 1;
		if (nFollowingSequNum <= maxIndex)
		{
			// we are in range, so a following CSourcePhrase instance exists, else use NULL
			posFoll = pSrcPhrases->Item(nFollowingSequNum);
		}
		if (posFoll != NULL)
		{
			// we are not at the end of the document, so there is following context
			gpFollSrcPhrase = posFoll->GetData();

            // there may be propagation, and we must make a deep copy of the
            // gpFollSrcPhrase as the first in the following context, storing it in pRec's
            // propagationSpan_SrcPhraseList member as the first of any propagation
            // modifications (in case it is modified by having new endmarkers restored
            // there, or filtered info transferred there, and in case propagation of
            // parameters to suceeding instances happens in code further below.
            // pOldFollSrcPhrase has the original endmarkers, if any are relevant at the
            // end of the editable span, stored on it - it therefore makes it simple to
            // restore the original following context in the event that there is a failure
            // later which requires the original document be reconstituted
			CSourcePhrase* pOldFollSrcPhrase = new CSourcePhrase(*gpFollSrcPhrase);
			pOldFollSrcPhrase->DeepCopy(); // fills out any in it's m_pSavedWords member 
										   // with copies
			// wx Note: wxList::Insert() Inserts object at front of list
			//  = CObList's AddHead()
			// save the deep copy
			pRec->propagationSpan_SrcPhraseList.Insert(pOldFollSrcPhrase); 
			 // initialize values
			pRec->nPropagationSpan_StartingSequNum = pOldFollSrcPhrase->m_nSequNumber;
			pRec->nPropagationSpan_EndingSequNum = pOldFollSrcPhrase->m_nSequNumber;
            // NOTE: additional deep copies may be added below to this list, and the
            // pRec->nPropagationSpan_EndingSequNum value incremented, if propagation
            // across some of the following context takes place after the
            // DoMarkerHousekeeping() call below.

			// record the fact that any now-filtered information is transferrable to the 
			// following context
			pRec->bDocEndPreventedTransfer = FALSE;
		}
		else
		{
            // record the fact that there is no following context available for any
            // transfer of information to m_markers in a following CSourcePhrase instance
			pRec->bDocEndPreventedTransfer = TRUE;
		}
		// note, we must set gpFollSrcPhrase because our later DoMarkerHousekeeping() call
		// uses it internally

		// now get the preceding CSourcePhrase's pointer (ie. preceding the editable span),
		// it could be NULL if we edited right at the start of the doc
		gpPrecSrcPhrase = NULL; // a global CSourcePhrase*
		int nPrecedingSequNum = pRec->nStartingSequNum - 1; // could be -ve!
		SPList::Node* posPrec = NULL; // the value if there is no preceding context
		if (nPrecedingSequNum >= 0)
		{
			// there is preceding context, so set the iterator
			posPrec = pSrcPhrases->Item(nPrecedingSequNum);
		}
		if (posPrec != NULL)
		{
			// we are not at the start of the document, and there is preceding context
			gpPrecSrcPhrase = posPrec->GetData();
		}
		// note, we must set gpPrecSrcPhrase because our later DoMarkerHousekeeping() call
		// uses it internally; but it is left NULL if there is no preceding context

        // the first document modification is to remove any final endmarkers from the first
        // CSourcePhrase instance, if any are actually there, of the following context --
        // to make the context following the editable span internally consistent -- because
        // the user's edit may involve removal of information which ended with final
        // endmarkers appended to the editable text in the dialog, and if those endmarkers
        // were thus removed, they must remain removed from the first CSourcePhrase
        // instance in the following context; but if the edit did not remove them, then the
        // code further below will move whatever final endmarkers are present in the new
        // list of CSourcePhrase instances to the first instance of the following context -
        // so for that to work right, the following context must have had them removed
        // beforehand; so either way, they've gotta go and now is a good time to do it.
		wxString strRemoved;
		if (gpFollSrcPhrase != NULL && !pRec->strFinalEndmarkers.IsEmpty())
		{
            // since we just want any removed, we won't make any use of strRemoved, as it
            // should be identical to what was earlier stored in pRec as strFinalEndmarkers
            // anyway
			bool bLacksAny = FALSE;
			strRemoved = RemoveInitialEndmarkers(gpFollSrcPhrase, pApp->gCurrentSfmSet, bLacksAny);
		}

        // In the following call, gpFollSrcPhrase will be NULL if there is no following
        // context; a return value of TRUE means there was endmarker transfer from the new
        // list AND deletion of the last CSourcePhrase instance, to a non-NULL instance
        // which formerly carried the markers; OR, if the edit resulted in material being
        // filtered at the end of the new sublist of CSourcePhrase instances, the transfer
        // of the filter-marker wrapped filtered content will have been done and the
        // carrier CSourcePhrase removed. 
        // (The call below also sets the pRec member strNewFinalEndmarkers to whatever
        // endmarkers are now at the end of the user's edited string, or empty if there are
        // none at that location or the endmarkers 'disappear' because they were filtered
        // out with filterable content which has now become filtered.)
        // In the special case where filtered info is transferred, the former unknown
        // marker will have caused the first CSourcePhrase of the following context to have
        // its m_bFirstOfType flag set TRUE, and the m_inform member will have something
        // like "?\mkr?" where mkr is whatever was the bare (misspelled) marker. The
        // m_bFirstOfType value being TRUE halts propagation of correct parameter values in
        // the block further down, if we left it TRUE; and the fix to the marker should at
        // the very least cause the ?\mkr? navigation text to disappear - so the function
        // will also remedy those things before returning.
		bool bEndmarkersOrFilteredInfoTransferred = 
				TransportWidowedEndmarkersToFollowingContext(
					&pRec->editableSpan_NewSrcPhraseList, gpFollSrcPhrase, pRec);
		if (bEndmarkersOrFilteredInfoTransferred)
		{
            // the list is shorter, so adjust the local count value which we set earlier
            // (note: the list could actually have been made empty -- see below for a
            // discussion of where that matters, before the DoMarkerHousekeeping() call)
			nNewCount = pRec->nNewSpanCount;
		}

        // We now come to the point where we have to possibly possibly propagate the new
        // list's final TextType and m_bSpecialText values forward past the end of the
        // editable span - depending on what the user has done in his editing of markers
        // and / or source text. DoMarkerHousekeeping() fixes this up, and it returns a
        // boolean and TextType value to the caller which we can use to propagate as
        // necessary past the end. There are 3 globals for preserving the values needed for
        // such propagation; we'll set them to some good guesses here, based on what is
        // currently known; DoMarkerHousekeeping() will adjust them as, needed later, or if
        // the sublist is empty, we'll set best-possible-values directly ('verse' and
        // m_bSpecialText = FALSE)and not call DoMarkerHousekeeping()
		gbPropagationNeeded = FALSE; // the most likely scenario 
		gPropagationType = pRec->nStartingTextType; // the TextType at the start of the 
                // editable span, (DoMarkerHousekeeping(), if called, will provide the
                // value stored in the last CSourcePhrase of the passed in new list, but
                // usually these two are the same; but if the passed in list is empty, we
                // can't use DoMarkerHousekeeping's default as it uses gpFollSrcPhrase
                // which could be quite wrong if the user is editing the source to correct
                // a misspelled marker
		gbSpecialText = pRec->bSpecialText;  // the special text boolean which may be 
                // propagated, however (DoMarkerHousekeeping() , if called, will provide
                // the value stored in the last CSourcePhrase of the passed in new list,
                // but usually these two are the same; but if the passed in list is empty,
                // we can't use DoMarkerHousekeeping's default as it uses gpFollSrcPhrase
                // which could be quite wrong if the user is editing the source to correct
                // a misspelled marker

        // get the text type, etc, correct for the list contents. Care is needed here,
        // depending on what happened within the above
        // TransportWidowedEndmarkersToFollowingContext() call. Passing the editable span's
        // new CSourcePhrase list into DoMarkerHousekeeping will cause the latter to fail
        // and crash the app if there was only a single CSourcePhrase in the new list, and
        // it was a carrier either for endmarkers, or for now-filtered information (because
        // the user edited a SF marker and the reparse then filtered out the material shown
        // to the user in the dialog); in either case, if information was tranferred to the
        // following context, the last CSourcePhrase in the new substring will have been
        // deleted by code in TransportWidowedEndmarkersToFollowingContext(), and if that
        // was the only instance, then the sublist is empty. The potential for user's
        // marker correction resulting in all the content being filtered is very real, and
        // if the filtered info is tranferred to the first CSourcePhrase in the following
        // context, then that one will probably need to have a new TextType which must be
        // propagated forward, and other things will need fixing eg. an unknown marker will
        // be in the navigation area shown as ?mkr?, and that needs to be removed, the
        // m_inform member needs resetting, and some flags changing. DoMarkerHousekeeping()
        // does those jobs, but although we can call it on an empty list, it isn't helpful
        // to do so for the following reason:
        // It defaults to TextType of verse (that's okay) but it takes the m_bSpecialText
        // value from the value on the gpFollSrcPhrase (the first in the context following)
        // which is decidely wrong if the user has just edited a wrongly spelled marker
        // (which would have earlier given the text there a type of noType) and it's almost
        // certain that we'd not want to be propagating a noType value into the following
        // context.
        // The solution is to check pRec for the editableSpan_NewSrcPhraseList having
        // become an empty list, and if so, check that bEndmarkersOrFilteredInfoTransferred
        // flag was set TRUE (meaning, in part, that the carrier CSourcePhrase was deleted
        // from new edit span's list of CSourcePhrases, and it was the only one in that
        // list) and in that case set the propagation parameters to default values without
        // making any DoMarkerHousekeeping call, and assume propagation is needed. BEW
        // changed 6Aug08: because Roland Fumey found that if he deleted some words (but
        // the whoe of his selection) within a \s section, which is special text, the the
        // colouring and text type is only correct for the preceding word, and rest of the
        // \s material gets wrongly formatted as verse TextType and the specialText flag is
        // FALSE - so I have to do cleverer code in the TRUE block just below.
		if (pRec->editableSpan_NewSrcPhraseList.IsEmpty())
		{
            // probably a typo marker was edited, and it and its contents were filtered, so
            // assume the type should now revert to verse; on the other hand, we might be
            // editing within special text, etc, so care is needed
			if (bFirstIsFirstOfType)
			{
				// use the type of the last CSourcePhrase in the preceding context
				if (gpPrecSrcPhrase != NULL)
				{
					gPropagationType = gpPrecSrcPhrase->m_curTextType;
					gbSpecialText = gpPrecSrcPhrase->m_bSpecialText;
				}
				else
				{
                    // everything removed from start of document - we can assume it's not
                    // \id information, so probably just a plain text file without SF
                    // markup, so assume the type is verse
					gPropagationType = verse;
					gbSpecialText = FALSE;
				}
			}
			else
			{
				// use the type stored in pRec's nStartingTextType member
				if (pRec->nStartingTextType == verse)
				{
					gPropagationType = verse;
					gbSpecialText = FALSE;
				}
				else if(pRec->nStartingTextType == poetry)
				{
					gPropagationType = poetry;
					gbSpecialText = FALSE;
				}
				else
				{
					// defaut to special text
					gPropagationType = noType;
					gbSpecialText = TRUE;
				}
			}
			gbPropagationNeeded = TRUE;
			
		}
		else
		{
			// a non-empty list means the type and special text values can be 
			// obtained from the list contents
			GetDocument()->DoMarkerHousekeeping(&pRec->editableSpan_NewSrcPhraseList, 
								pRec->nNewSpanCount, gPropagationType, 
								gbPropagationNeeded); // sets gbSpecialText internally
		}
		if (gbPropagationNeeded)
			pRec->bSpecialText = gbSpecialText; // update the EditRecord, 
												// to keep everything straight

        // do any forward propagation, halting at the first CSourcePhrase in the following
        // context which has the member flag m_bFirstOfType set TRUE (Note; so far, nothing
        // has been done to the contents of pSrcPhrases list to invalidate any pointer in
        // it (except possibly to add endmarkers at the start of the first CSourcePhrase's
        // m_markers CString in the following context, and that does not affect the
        // CSourcePhrase pointer itself), so we don't need any layout update yet)
		if (gbPropagationNeeded && gpFollSrcPhrase != NULL)
		{
			SPList::Node* pos = pSrcPhrases->Item(nFollowingSequNum); // won't fail, as we 
																	 // computed this above
			CSourcePhrase* pSP = NULL;
			bool bIsFirst = TRUE;
			while (pos != NULL)
			{
				pSP = pos->GetData();
				pos = pos->GetNext();
				wxASSERT(pSP != NULL);
				if (pSP->m_bFirstOfType)
				{
					break; // propagation ends, don't change this one
				}
				else
				{
                    // the first CSourcePhrase of the following context already has a deep
                    // copy stored at the start of pRec's propagationSpan_SrcPhraseList, so
                    // we only need to store the deep copies of the additional ones (making
                    // the deep copy before it is changed), and then we can do the
                    // propagation on the one in the m_pSourcePhrases list of the document
                    // class
					if (bIsFirst)
					{
						// skip, we've got this one
						bIsFirst = FALSE;
					}
					else
					{
                        // we've not got this one in the propagation list, so do the pRec
                        // changes so as to preserve the old one's contents in case we bail
                        // out later
						CSourcePhrase* pADeepCopiedSrcPhrase = new CSourcePhrase(*pSP);
						pADeepCopiedSrcPhrase->DeepCopy();
						pRec->propagationSpan_SrcPhraseList.Append(pADeepCopiedSrcPhrase);
						pRec->nPropagationSpan_EndingSequNum = 
													pADeepCopiedSrcPhrase->m_nSequNumber;
                        // NOTE: we fill this list, and get the starting and ending
                        // sequence numbers, unilaterally -- without consideration of
                        // whether or not the free translation span, and the back
                        // translation span, have made the cancel span already encompass
                        // the CSourcePhrase instances in the propagation span. When we
                        // need to know whether or not that is the case (ie. if we are
                        // required to do a bail out so as to restore the original document
                        // state), we can compare indices for these spans, and whenever the
                        // propagation span is subsumed by the cancel span, we can just
                        // retore the cancel span and ignore the propagation span; but in
                        // the event that the propagation span extends further than the end
                        // of the cancel span, we use the former's contents to restore
                        // those CSourcePhrase instances which lie beyond the end of the
                        // cancel span -- this saves us having to fiddle with code for
                        // checking whether endmarkers were moved or replaced etc.
					}

					// now we can propagate the special text value, and the TextType
					pSP->m_bSpecialText = pRec->bSpecialText;
					pSP->m_curTextType = gPropagationType;
				}
			}
		}
		gbPropagationNeeded = FALSE; // turn it off, restoring the default value

        // now that TextType and special text value are correct, we need to put back any
        // removed initial endmarkers, putting them at the start of the m_markers member of
        // the firstCSourcePhrase in the new list
		if (!pRec->strInitialEndmarkers.IsEmpty())
		{
			// there are markers to be restored
			CSourcePhrase* pSP = NULL;
			if (pRec->editableSpan_NewSrcPhraseList.GetCount() == 0)
			{
                // the user deleted everything, so add the endmarkers to the following
                // context's first CSourcePhrase instance's m_markers member, at its start
                // -- but we can do so only provided the gpFollSrcPhrase is not NULL (it
                // would be null only at doc end)
				if (gpFollSrcPhrase != NULL)
				{
					gpFollSrcPhrase->m_markers = pRec->strInitialEndmarkers + 
															gpFollSrcPhrase->m_markers;
				}
			}
			else
			{
                // the newSrcPhraseList has one or more members, so add to the first in it
                // pSP = (CSourcePhrase*)pRec->editableSpan_NewSrcPhraseList.GetHead();
				SPList::Node* posSp = pRec->editableSpan_NewSrcPhraseList.GetFirst();
				pSP = posSp->GetData();
				if (pSP != NULL)
				{
					pSP->m_markers = pRec->strInitialEndmarkers + pSP->m_markers;
				}
			}
		}

        // the new CSourcePhrase instances are now ready to be put into the document's
        // m_pSourcePhrases list at the editable span location, replacing the (possibly
        // modified) ones in the editable span due to the replacements done above (about
        // 500 lines up). Beware, the new list might be empty, or shorter, or the same
        // length, or longer than the former editable span. The
        // TransferCompletedSrcPhrases() function also adjusts the active location, and
        // the stored value in the edit record, if the user's edits have made either or
		// both outside the document's bounds. (Partner piles are created as necessary
		// within the TransferCompletedSrcPhrases() function as well.)
		int nBeginAt = pRec->nStartingSequNum;
		int nFinishAt = pRec->nEndingSequNum;
		TransferCompletedSrcPhrases(pRec,&pRec->editableSpan_NewSrcPhraseList,
									pSrcPhrases,nBeginAt,nFinishAt);

        // get a new valid starting pile pointer for the inserted new source text --
        // because for a source text edit, this is where the active location needs to be
        // put
		nSaveSequNum = pRec->nStartingSequNum; // the start of the new material, 
											   // if there was some new material
		if (pRec->nNewSpanCount == 0)
		{
			// there was no new material, so put the location as the previous 
			// CSourcePhrase instance
			nSaveSequNum -= 1;
			// check we didn't go negative, if so, then make the document start 
			// be the location
			if (nSaveSequNum < 0)
				nSaveSequNum = 0;
		}
		pApp->m_nActiveSequNum = nSaveSequNum; // this ensures any later call to 
											   // InsertNullSrcPhrase() won't crash
        // we must have a valid layout, because the last function call will have clobbered
        // some of the original layout's pointers
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pSrcPhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pSrcPhrases, create_strips_keep_piles);
#endif
		pStartingPile = GetPile(nSaveSequNum);
		wxASSERT(pStartingPile != NULL);
		pApp->m_pActivePile = pStartingPile;

		// restore removed Notes, provided there are some to be restored
		//int nNewSrcPhraseCount = -1;
		bool bNotesRestorationWorkedOK = TRUE;
		if (pRec->arrNotesSequNumbers.GetCount() > 0)
		{
            // we must first get preceding and following contexts which may get Notes
            // moved, so that a user Cancel operation will be able to be done successfully
			bool bGotSpanSuccessfully = GetMovedNotesSpan(pSrcPhrases, pRec, 
															precedingContext);
			if (!bGotSpanSuccessfully)
			{
                // remove the contents of the arrNotesSequNumbers array first, before
                // bailout is attempted, and also the follNotesMoveSpanList and prec
                // NotesMoveSpanList need to be cleared, as one or the other may have not
                // yet been cleared; and since Note restoration has not yet been attempted,
                // no Notes in either preceing or final context can possibly have been
                // moved as yet, so Bailout doesn't need these lists if done from before
                // the RestorNotesAfterSourceTextEdit() function is called
				pRec->arrNotesSequNumbers.Clear();
				pDoc->DeleteSourcePhrases(&pRec->follNotesMoveSpanList);
				pDoc->DeleteSourcePhrases(&pRec->precNotesMoveSpanList);
				// create the user message
				errStr = _T("Notes restoration unexpectedly failed when ");
				errStr += _T(
				"getting the potential moved notes (preceding context) span. ");
				errStr += _T("Vertical edit process abandoned. "); 
				errStr += _T(
				"Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto exit;
			}

			bGotSpanSuccessfully = GetMovedNotesSpan(pSrcPhrases, pRec, followingContext);
			if (!bGotSpanSuccessfully)
			{
                // remove the contents of the arrNotesSequNumbers array first, before
                // bailout is attempted, and also the follNotesMoveSpanList and prec
                // NotesMoveSpanList need to be cleared, as one or the other may have not
                // yet been cleared; and since Note restoration has not yet been attempted,
                // no Notes in either preceing or final context can possibly have been
                // moved as yet, so Bailout doesn't need these lists if done from before
                // the RestorNotesAfterSourceTextEdit() function is called
				pRec->arrNotesSequNumbers.Clear();
				pDoc->DeleteSourcePhrases(&pRec->follNotesMoveSpanList);
				pDoc->DeleteSourcePhrases(&pRec->precNotesMoveSpanList);
				// create the user message
				errStr = _T("Notes restoration unexpectedly failed when ");
				errStr += _T(
				"getting the potential moved notes (following context) span. ");
				errStr += _T("Vertical edit process abandoned. "); 
				errStr += _T(
				"Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto exit;
			}

			// do the restoration of the removed Notes
			bNotesRestorationWorkedOK = RestoreNotesAfterSourceTextEdit(pSrcPhrases,pRec);
            // if there was an error, we can't continue with the vertical edit process so
            // call the BailOutFromEditProcess() function, as it knows how to bail out when
            // the document has been modified already - it relies on some globals to give
            // it the smarts it needs
			if (!bNotesRestorationWorkedOK)
			{
                // we don't expect note restoration would ever fail, so a hard coded
                // English message for the developer's benefit will suffice here, then do
                // the bail out
				errStr = _T("Notes restoration unexpectedly failed. ");
				errStr += _T("Vertical edit process abandoned. "); 
				errStr += _T(
				"Will try now to restore the document to its pre-edit state.");
				wxMessageBox(errStr,_T(""), wxICON_EXCLAMATION);
				BailOutFromEditProcess(pSrcPhrases,pRec);
				goto exit;
			}
		}

        // the restoration of markers did not attend to making sure every Note recreated
        // has its parent CSourcePhrase's m_bHasNote boolean set TRUE. We do that check now
        // and fix any in which the flag is still clear. (Do this in the editable span and
        // 5 CSourcePhrase instances or so either side - that should be enough to catch all
        // which neeed this fix.)
		CheckAndFixNoteFlagInSpans(pSrcPhrases, pRec);

		/* uncomment these 6 lines to check document restoration from this point in process
		// test bailout at this point, when editing a typo marker produced automatic filtering
		errStr = _T("Testing only. ");
		errStr += _T("Vertical edit process abandoned. "); 
		errStr += _T("Will try now to restore the document to its pre-edit state.");
		AfxMessageBox(errStr,MB_ICONEXCLAMATION);
		BailOutFromEditProcess(pSrcPhrases,pRec);
		goto exit;
		*/
		// BEW added next block 16Jun05
		// handle any filtering needed because one or more markers
		// were edited to be markers which should be filtered out...
		// if any filtering is needed, we check for it and if so,
		// get it done by the RetokenizeText() call below
		if (bMarkerSetsAreDifferent)
		{
            // There is at least one place (could be more if changed endmarker(s) are
            // involved) where the document's screen appearance would probably now be
            // incorrect - because the user has edited one or more SF markers. The
            // following comment from the code for the document class's RetokenizeText()
            // function explains... "Typically, ..., there will be errors remaining in the
            // document - these are old pSrcPhrase->m_inform strings which are now out of
            // date, TextType values which are set or changed at the wrong places and now
            // inappropriately propagated in the light of the edited SFM change(s) now in
            // effect, and likewise m_bSpecialText will in many places be wrong, or changed
            // when it shouldn't be, shouldn't be. To fix all this stuff we will scan
            // across the whole document with the DoMarkerHousekeeping() function, which
            // duplicates some of TokenizeText()'s code, to get the TextType,
            // m_bSpecialText, and m_inform members of pSrcPhrase correct at each location
            // (doing it over the whole doc is, of course, overkill, but it will catch
            // anything wrong from other operations and fix them too, so worth doing & it
            // is quick/unnoticed)
			int activeSequNum = pApp->m_nActiveSequNum;
			if (pApp->m_nActiveSequNum < 0)
			{
				// must not have data yet, or we are at EOF and so no pile is currently active
				activeSequNum = -1;
			}
			else
			{
				// we are somewhere in the midst of the data, so a pile will be active
				activeSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;

				// remove any current selection, as we can't be sure of any pointers
				// depending on what user may choose to alter
				RemoveSelection();
			}
			TextType aDontCare_PropagationType = verse; // we won't use the returned value
			bool bDontCare_PropagationNeeded = FALSE; // we won't use the returned value
			int docSrcPhraseCount = pSrcPhrases->GetCount(); // current doc size
			GetDocument()->DoMarkerHousekeeping(pSrcPhrases,docSrcPhraseCount,
								aDontCare_PropagationType, bDontCare_PropagationNeeded);

			
			pApp->m_targetPhrase.Empty(); // when editing src text, the box will be 
										  // at the start of the new material hopefully,
										  // so we don't expect any adaptation to be known
			Invalidate();
			GetLayout()->PlaceBox();
		}

		// prepare for next step, eg, combobox etc
	
		// post the custom event for adaptations step of the vertical edit, or for the
		// glossing step, depending on the user's preference (I want return immediately, 
		// so I don't use SendMessage())
		if (gbAdaptBeforeGloss)
		{
            // whm note: MFC docs say of PostMessage, "Places a message in the window's
            // message queue and then returns without waiting for the corresponding window
            // to process the message." For SendMessage, they say, "Sends a message to the
            // window and does not return until the window procedure has processed the
            // message."
			// MFC code:
			//this->PostMessage(CUSTOM_EVENT_ADAPTATIONS_EDIT,0,0);
			
			// wx example code for sending custom event:
			// user code sending the event
			//void MyWindow::SendEvent()
			//{
			//    wxCommandEvent event( wxEVT_MY_EVENT, GetId() );
			//    event.SetEventObject( this );
			//    // Give it some contents
			//    event.SetText( wxT("Hallo") );
			//    // Send it
			//    GetEventHandler()->ProcessEvent( event );
			//}
			// wx code:
			wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
			wxPostEvent(pApp->GetMainFrame(), eventCustom); // the event handlers are 
															// in CMainFrame

		}
		else
		{
			wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
			wxPostEvent(pApp->GetMainFrame(), eventCustom); // the event handlers 
															// are in CMainFrame
		}
	}
	else
	{
		bUserCancelled = TRUE;
	}

	// delay cancel cleanup to here, as the restoration of the view needed 
	// to use the pRec values which are to be initialized here
	if (bUserCancelled)
	{
		// user cancelled, so restore initial state...
		// The document is not modified until after the dialog is dismissed, so a Cancel 
		// button press only requires that that the edit record will have its stored
		// information cleared
		InitializeEditRecord(*pRec); // clears gbVerticalEditInProgress as well
		gEntryPoint = noEntryPoint;
		gEditStep = noEditStep;
		gbEditingSourceAndDocNotYetChanged = TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////////
///	\return        nothing
///
///	\param bSeeGlossesEnabled	->	TRUE of glosses are visible currently in the 
///                                 main window (caller passes in the global bool
///                                 gbEnableGlossing flag), FALSE if not
///	\param bIsGlossing			->	TRUE if glossing mode is currently ON, FALSE if 
///	                                adapting mode is currently ON (caller passes in the 
///	                                global bool gbIsGlossing flag)
///	\param pRec				    ->	pointer to the EditRecord struct which, among 
///	                                other things, stores the value of the passed in 
///	                                global booleans at the time when the vertical edit 
///	                                process was entered
///	\remarks
/// Used to restore the mode to whatever it was when the vertical edit process was
/// initiated, including making glosses visible or hidden if the original mode was
/// adaptations mode and they were visible or hidden, respectively. There are handlers
/// for menu commands for these mode changes, so we just need to provide a set of tests
/// to determine how, if at all, the original state differs from the current state and
/// make the appropriate handler calls to get the state back to what it should be.
///	
///	BEW created 1Aug08, for support of vertical editing in the refactored 
///	Edit Source Text handler
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RestoreMode(bool WXUNUSED(bSeeGlossesEnabled), 
								bool WXUNUSED(bIsGlossing), EditRecord* pRec)
{
    // Protocol: start from the 3 possible current states (1. glossing, 2. adapting &
    // seeing glosses, 3. adapting & hidden glosses), and for each of these three starting
    // points, use pRec to determine what the original state was, and then set up the calls
    // needed to restore to any particular starting state (again, the same 3 possibilities
    // obtain)
	if (gbIsGlossing)
	{
		// glossing mode is currently ON, so gbEnableGlosses must be TRUE as well
		if (pRec->bGlossingModeOnEntry)
		{
            // glossing mode was ON at entry also, so pRec->bSeeGlossesEnabledOnEntry must
            // be TRUE as well so the current flag values are correct - hence nothing to do
			;
		}
		else
		{
            // adapting mode was ON at entry, but gbEnableGlossing could have been ON (ie.
            // glosses visible) or OFF (ie. glosses hidden) on entry, so find out which was
            // the case
			if (pRec->bSeeGlossesEnabledOnEntry)
			{
                // the "See Glosses" menu item was ticked when the vertical edit was
                // entered, glosses were visible in adapting mode
				ToggleGlossingMode();
			}
			else
			{
                // the "See Glosses" menu item was unticked on entry, glosses were hidden,
                // we had a standard 2-line strip on entry
				ToggleSeeGlossesMode();
			}
		} // end of tests for original state
	}
	else
	{
        // adapting mode is currently ON, but gbEnableGlosses could be ON (ie. glosses
        // visible) or OFF (ie. glosses hidden
		if (gbEnableGlossing)
		{
			// the "See Glosses" menu item is ticked, glosses are visible in adapting mode
			if (pRec->bGlossingModeOnEntry)
			{
				// glossing mode was ON at entry, so pRec->bSeeGlossesEnabledOnEntry must 
				// be TRUE as well
				ToggleGlossingMode();
			}
			else
			{
                // adapting mode was ON at entry, but gbEnableGlossing could have been ON
                // (ie. glosses visible) or OFF (ie. glosses hidden) on entry, so find out
                // which was the case
				if (pRec->bSeeGlossesEnabledOnEntry)
				{
                    // the "See Glosses" menu item was ticked when the vertical edit was
                    // entered, glosses were visible in adapting mode so the current flag
                    // values are correct - hence nothing to do
					;
				}
				else
				{
                    // the "See Glosses" menu item was unticked on entry, glosses were
                    // hidden, we had a standard 2-line strip on entry
					ToggleSeeGlossesMode();
				}
			} // end of tests for original state
		}
		else
		{
			// the "See Glosses" menu item is unticked, glosses are hidden, we have 
			// a standard 2-line strip currently 
			if (pRec->bGlossingModeOnEntry)
			{
				// glossing mode was ON at entry, so pRec->bSeeGlossesEnabledOnEntry must 
				// be TRUE as well
				ToggleSeeGlossesMode();
				ToggleGlossingMode();
			}
			else
			{
                // adapting mode was ON at entry, but gbEnableGlossing could have been ON
                // (ie. glosses visible) or OFF (ie. glosses hidden) on entry, so find out
                // which was the case
				if (pRec->bSeeGlossesEnabledOnEntry)
				{
                    // the "See Glosses" menu item was ticked when the vertical edit was
                    // entered, glosses were visible in adapting mode
					ToggleSeeGlossesMode();
				}
				else
				{
                    // the "See Glosses" menu item was unticked on entry, glosses were
                    // hidden, we had a standard 2-line strip on entry so the current flag
                    // values are correct - hence nothing to do
					;
				}
			} // end of tests for original state
		}
	}
}

// return a pointer to a specific vertical edit bar of the frame window, or NULL if there
// is an error when trying to get the pointer
wxPanel* CAdapt_ItView::GetBar(enum VertEditBarType vertEditBarType)
{
	CAdapt_ItApp* pApp = &wxGetApp();

	// whm modified to use enum VertEditBarType defined in Adapt_It.h
	// BEW modified 10Nov08 to include the Compose bar in the enum, so as to get
	// access to the TextBox there, for support of the Undo Last Copy button
	wxPanel* pBar = (wxPanel*)NULL;
	// In the wx version all the vertical edit bars reside as members of CMainFrame
	// and they all are created at the startup of the application, but are hidden
	// until needed by the vertical editing process.
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);

	switch (vertEditBarType)
	{
	case Vert_Edit_RemovalsBar:
		pBar = pFrame->m_pRemovalsBar;
		break;
	case Vert_Edit_Bar:
		pBar = pFrame->m_pVertEditBar;
		break;
	case Vert_Edit_ComposeBar:
		pBar = pFrame->m_pComposeBar;
		break;
	default:
		pBar = (wxPanel*)NULL;
	}
	return pBar;
}

// return a pointer to the CComboBox in the m_wndRemovalsBar of the frame window, 
// or NULL if there is an error when trying to get the pointer
wxComboBox* CAdapt_ItView::GetRemovalsComboBox()
{
	wxComboBox* pCombo = NULL;
	wxPanel* pBar = GetBar(Vert_Edit_RemovalsBar);
	if (pBar == NULL)
		return NULL;
	pCombo = (wxComboBox*)pBar->FindWindowById(IDC_COMBO_REMOVALS);
	wxASSERT(pCombo != NULL);
	if (pCombo == NULL)
	{
		wxMessageBox(_T(
		"Failure to obtain pointer to the ComboBox control in GetRemovalsComboBox()"), 
		_T(""), wxICON_EXCLAMATION);
	}
	return pCombo;
}

// Get a pointer to the CComboBox control in the m_wndRemovalsBar CDialogBar member of the
// frame window (see MainFrm.cpp and .h), and then check which step is passed in, and
// populate the combo box with the removed data strings in gEditRecord's appropriate
// CStringList; there may be no entries to put in the list, in which case a single entry
// which is space is retained so that the comboxbox stays visible, and this is not an
// error. Return TRUE when there was no error, and FALSE if there was an error leading to
// the list not being populated.
// Note, this function can be called when vertical editing is not currently on, to
// repopulate the combobox list with whatever desired data we want, whether adaptations,
// glosses, or free translations - by passing in the appropriate enum value, rather than
// the current value in the global gEditStep
bool CAdapt_ItView::PopulateRemovalsComboBox(enum EditStep step, EditRecord* pRec)
{
	wxComboBox* pCombo = GetRemovalsComboBox();
	if (pCombo == NULL)
		return FALSE; // could not get the required pointer 
					  // (an error warning will have been seen already)
	wxASSERT(pRec);
	wxArrayString* pStrList = NULL;

	wxString aString;
	int index;
	bool bIsEmpty = FALSE;

    // determine which list we are dealing with for this vertical editing step... 
    // Note: this function can be called when no vertical editing is in progress, in
    // which case the caller does not pass in gEditStep's current value (which would be
    // noEditStep) but rather the particular enum value which results in the population
    // being done with the appropriate data (whether adaptations, glosses, of free
    // translations)
	switch (step)
	{
		case glossesStep:
		{
			pStrList = &pRec->deletedGlossesList;
			break;
		}
		case freeTranslationsStep:
		{
			pStrList = &pRec->deletedFreeTranslationsList;
			break;
		}
		default:
		case adaptationsStep:
		{
			pStrList = &pRec->deletedAdaptationsList;
			break;
		}
	}

	// populate the combo's list, etc...

	// don't do anything if pRec's CStringList has no entries in it, except
	// remove whatever is already in the combo's list -- because anything already
	// in it is quite likely data from a different step, and so inappropriate now
	bIsEmpty = pStrList->IsEmpty();
	if (bIsEmpty)
	{
		// no populating to be done, but this is no error; but make sure there is
		// a space there at least, to keep the combobox visible
		pCombo->Clear(); // remove old content, it could be glosses or free translations
		index = pCombo->Append(_T(" "));
		return TRUE;
	}
	// the pRec list has content to be put in the combo box... first remove old content
	pCombo->Clear();
	// and now loop over the stored list, adding its strings to the combo's list --
    // the pRec lists are maintained eternally with a maximum of 100 entries, so we can
    // safely loop over all there are (#define DELETIONS_LIST_MAX_ENTRIES 100 at top of
    // Adapt_ItView.cpp)
	int ct;
	for (ct = 0; ct < (int)pStrList->GetCount(); ct++)
	{
		aString = pStrList->Item(ct);
		// we don't bother having empty strings in the list, 
		// the user can make those himself easily
		if (!aString.IsEmpty())
		{
			index = pCombo->Append(aString);
		}
	}

    // set up the list's visual dimensions and the combo width, visually it must fit within
    // the frame window's vertical extent of the client rectangle
    // whm Note: wxComboBox derives from wxControlWithItems which has a SetSelection()
    // method with a single parameter - this method sets the item in the list. The
    // wxComboBox class itself has another methos called SetSelection() which takes two
    // parameters - this method is used to set the selection highlight of the line showing
    // in the text field of the combo box!
	pCombo->SetSelection(0); // show the first in the list in top position
	pCombo->SetSelection(0,0); // show that top item unselected
	return TRUE;
}

void CAdapt_ItView::SetVerticalEditModeMessage(wxString messageText)
{
	wxPanel* pBar;
	pBar = GetBar(Vert_Edit_Bar);
	wxASSERT(pBar != NULL);
	wxTextCtrl* pMsgBox = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_MSG_TEXT);
	wxASSERT(pMsgBox != NULL);
	pMsgBox->ChangeValue(messageText);
}

// use the following when placing the phrase box in vertical editing moode's steps
void CAdapt_ItView::PutPhraseBoxAtSequNumAndLayout(EditRecord* WXUNUSED(pRec), 
												   int nSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();

    // first make sure any pile's CSourcePhrase instance's source text or
    // translation or gloss is not carried forward or back to a different step
	translation.Empty();
	pApp->m_targetPhrase.Empty();

	// now set up the phrase box
	pApp->m_nActiveSequNum = nSequNum; // needed, as a test for m_nActiveSequNum < 0 
									   // done internally will have box placement 
									   // skipped if we get here and it is -1
	pApp->m_pActivePile = GetPile(nSequNum);
	if (gbIsGlossing)
		translation = pApp->m_pActivePile->GetSrcPhrase()->m_gloss;
	else
		translation = pApp->m_pActivePile->GetSrcPhrase()->m_adaption;
	if (translation.IsEmpty())
	{
		bool bFoundSomething;
		bFoundSomething = pApp->m_pTargetBox->LookUpSrcWord(this, 
															pApp->m_pActivePile);
	}
	pApp->m_targetPhrase = translation; // global CString  translation is set 
        // by whatever is adaptation or gloss if user switched modes, and if there is no
        // such string yet, then do LookUpSrcWord() and if there is an entry in the KB, use
        // that, else leave empty
	CLayout* pLayout = GetLayout();
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	GetLayout()->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum); // BEW added 20Jun09
	Invalidate();
	GetLayout()->PlaceBox();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if there was no error, FALSE if there was an error
/// \param      pRec   ->   pointer to the EditRecord struct which stores the information 
///                         needed for recreating the one or more collected back
///                         translations pertinent to the editable span for the current
///                         vertical edit operation
/// \remarks
/// The last step in the vertical edit process is to restore any collected
/// backtranslations, using the updated adaptation or gloss information resulting from
/// earlier user-interactive steps in the vertical edit process. This restoration is done
/// without intervention from the user being required. All the information pertinent to
/// doing the restoration is passed in within the pRec parameter.
/// 
/// The function checks that a restoration is required. If it is, then information in the
/// pRec parameter is used to set up a programmatically generated selection for the
/// CSourcePhrase instances involved in the (limited) span of the recollection - because
/// without a selection, the collection would be done over the whole document which would
/// be overkill. The work of doing the recollection is then given to the
/// DoCollectBacktranslations() function.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::RecreateCollectedBackTranslationsInVerticalEdit(EditRecord* pRec, 
														enum EntryPoint anEntryPoint)
{
	CAdapt_ItApp* pApp = &wxGetApp();
    // if there were no back translations removed from the edit span, then none need be
    // recollected and if so just return without doing anything
	if (!pRec->bEditSpanHasBackTranslations)
		return TRUE;

	if (pRec->nBackTrans_StartingSequNum == -1)
		return FALSE; // should not be -1 if bEditSpanHasBackTranslations is TRUE

	int nBackTranslationSpanExtent = pRec->nBackTrans_EndingSequNum - 
										pRec->nBackTrans_StartingSequNum + 1;
	wxASSERT(nBackTranslationSpanExtent > 0);

	// remove any selection
	RemoveSelection();

    // save the current active pile's sequ num,, we need to change the active location for
    // the call of MakeSelectionForFind() below, so we must restore the former active
    // location before exitting; then set the active location to be at the location where
    // the first \bt marker was removed
	int nSaveActiveSequNum = pApp->m_nActiveSequNum;
	pApp->m_pActivePile = GetPile(pRec->nBackTrans_StartingSequNum);

    // the extent of the edit span may have been changed in one or two ways - if the entry
    // point was sourceTextEntryPoint, then the source text may have been edited to be
    // longer or shorter, and subsequently, in adaptationsStep of the vertical edit, the
    // user may have used retranslations, inserted placeholders, or mergers, all of which
    // potentially change the extend of the edit span. Which of these applies must now be
    // determined and the appropriate span adjustment made
	switch (anEntryPoint)
	{
	case noEntryPoint:
        // this should never happen, but if it does it means no source text or vertical
        // edit was done -- in which case we just return and no do anything
		return TRUE;
	case sourceTextEntryPoint:
		nBackTranslationSpanExtent += (pRec->nNewSpanCount - pRec->nOldSpanCount);
		nBackTranslationSpanExtent += pRec->nAdaptationStep_ExtrasFromUserEdits;
		break;
	case adaptationsEntryPoint:
        // the only possibility for span extent changes is due to mergers, retranslations,
        // or placeholder insertions
		nBackTranslationSpanExtent += pRec->nAdaptationStep_ExtrasFromUserEdits;
		break;
	// the next two cases involve no change to the span length, so they have no work to do
	case glossesEntryPoint:
	case freeTranslationsEntryPoint:
		;
	}

    // use the final value of nBackTranslationSpanExtent, together with
    // nBackTrans_StartingSequNum to define which CSourcePhrase instances in the
    // m_pSourcePhrases list in the document need to be programmatically set as selected &
    // create the selection; MakeSelectionForFind() can be used to make the selection even
    // though we are not doing a Find command
	gbUserWantsSelection = TRUE; // TODO do we still need this global??  check someday
	int nSelectionLine = 0; // select in the punctuated source text line
    // BEW 2Aug09 added bool bDoRecalcLayoutInternally parameter to end of signature, because it
    // is needed (with FALSE value) for helping Find Next do its job properly when a match
    // is made in a retranslation, but here it just needs to be TRUE
	MakeSelectionForFind(pRec->nBackTrans_StartingSequNum, nBackTranslationSpanExtent, 
							nSelectionLine,TRUE);
	// hand over to the function which does the collecting,
	// using the selection defined above
	DoCollectBacktranslations(pRec->bCollectedFromTargetText);

	// do cleanup housekeeping
	gbUserWantsSelection = FALSE; // restore default value
	RemoveSelection();
	pApp->m_pActivePile = GetPile(nSaveActiveSequNum);
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     TRUE if the end of the vertical edit step has been reached, so that an
///             event for transitioning to the next vertical edit step has been posted (in
///             other words, a PostMessage() has been done); FALSE if the step end has not
///             yet been reached
/// \param      nSequNum          -> the sequence number for the landing location that the 
///                                  phrase box would want to stop at
/// \param      select            -> no matter where it is invoked from it will be one of
///                                  the enum values nextStep, previousStep, endNow, or
///                                  cancelAllSteps
/// \param      bForceTransition  -> default is FALSE; when FALSE the normal tests for
///                                  landing the box in the gray area are done, to see if
///                                  transition to the next step is required; when TRUE,
///                                  the transition is done unilaterally
/// \remarks
/// Called from: the View's OnButtonRetranslation(), OnButtonEditRetranslation(),
/// OnAdvanceButton(), OnNextButton(), OnButtonNextStep(), OnButtonPrevStep(),
/// CPhraseBox::JumpForward(), CPhraseBox::MoveToNextPile().
/// While vertical editing is in progress, this function checks for a landing location
/// (using the passed in nSequNum value) to see if it lies beyond the end bound for the
/// editable span for the current step; it so, then the appropriate custom event is posted
/// to cause transition to the next step.
/// As the user advances through the edit span, doing updates in either adaptationsStep,
/// glossesStep or freeTranslationsStep, control will eventually get to the end of the span
/// and the action for advancing to the next CSourcePhrase appropriate for that step will
/// take the phrase box into the gray text area. When that happens, we want to suppress
/// landing the phrase box in that context, and instead transition vertical edit mode to
/// whatever editing step is logically next. This function therefore checks for a landing
/// location (using the passed in nSequNum value) to see if it lies beyond the end bound
/// for the editable span for the current step; it so, then the appropriate custom event is
/// posted to cause transition to the next step. In some circumstandes it may be necessary
/// or expedient to force the transition, so that can be done by passing in TRUE for the
/// final parameter. Typical scenarios for that would be 
/// 1. that the end of the document was reached without finding a landing location; or 
/// 2. the function is invoked from the Vertical Edit control bar buttons - which force 
///    transition without checking if the active location is beyond the edit span or not; 
/// 3. bundle end has been reached in the search for a "hole" to jump to, in which case
///    this really means we've moved into the gray area, so TRUE would be appropriate.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::VerticalEdit_CheckForEndRequiringTransition(int nSequNum, 
							ActionSelector select, bool bForceTransition)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	EditRecord* pRec = &gEditRecord;
	if (bForceTransition)
	{
		switch (gEditStep)
		{
		case adaptationsStep:
			{
				switch (select)
				{
				case pleaseIgnore:
					return FALSE; // **TODO** eliminate this case, 
								  // the return, and the enum value later on
				case nextStep:
					if (gbAdaptBeforeGloss)
					{
						wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					}
					else
					{
						wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					}
					return TRUE;
				case previousStep:
					if (gbAdaptBeforeGloss)
						::wxBell(); // cannot roll back to the edit source text 
									// dialog, cancel is better
					else
					{
						wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					}
					return TRUE;
				case endNow:
					{
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					return TRUE;
					}
				case cancelAllSteps:
					{
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					return TRUE;
					}
				}
				break;
			}
		case glossesStep:
			{
				switch (select)
				{
				case pleaseIgnore:
					return FALSE; // **TODO** eliminate this case, 
								  // the return, and the enum value later on
				case nextStep:
					if (gbAdaptBeforeGloss)
					{
						wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
										// the event handlers are in CMainFrame
					}
					else
					{
						wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
										// the event handlers are in CMainFrame
					}
					return TRUE;
				case previousStep:
					if (gbAdaptBeforeGloss)
					{
						wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
										// the event handlers are in CMainFrame
					}
					else
						::wxBell(); // cannot roll back to the edit source text 
									// dialog, cancel is better
					return TRUE;
				case endNow:
					{
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					return TRUE;
					}
				case cancelAllSteps:
					{
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					return TRUE;
					}
				}
				break;
			}
		case freeTranslationsStep:
			{
				switch (select)
				{
				case pleaseIgnore:
					return FALSE; // **TODO** eliminate this case, 
								  // the return, and the enum value later on
				case nextStep:
					{
						StoreFreeTranslationOnLeaving();
						wxCommandEvent eventCustom(wxEVT_Back_Translations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					return TRUE;
					}
				case previousStep:
					if (gbAdaptBeforeGloss)
					{
						wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					}
					else
					{
						wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					}
					return TRUE;
				case endNow:
					{
						StoreFreeTranslationOnLeaving();
						wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
					return TRUE;
					}
				case cancelAllSteps:
					{
						wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
						wxPostEvent(pApp->GetMainFrame(), eventCustom); 
									// the event handlers are in CMainFrame
						return TRUE;
					}
				}
				break;
			}
		default:
			{
				// control should never come here, but if it does,
				// make vertical edit mode end immediately 
				wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
				wxPostEvent(pApp->GetMainFrame(), eventCustom); 
							// the event handlers are in CMainFrame
			}
		}
		return TRUE;
	} // end block for test (bForceTransition == TRUE)

    // for the unforced case, make the tests for the landing location being in the gray
    // area; pleaseIgnore is not a valid option if control gets this far
	switch (gEditStep)
	{
	case adaptationsStep:
		if (nSequNum > pRec->nAdaptationStep_EndingSequNum)
		{
			switch (select)
			{
			case pleaseIgnore:
				return FALSE; // **TODO** eliminate this case, 
							  // the return, and the enum value later on
			case nextStep:
				if (gbAdaptBeforeGloss)
				{
					wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
				}
				else
				{
					wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
				}
				return TRUE;
			case previousStep:
				if (gbAdaptBeforeGloss)
					::wxBell(); // cannot roll back to the edit source text 
								// dialog, cancel is better
				else
				{
					// rollback to glossesStep
					wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
				}
				return TRUE;
			case endNow:
				{
					// end vertical edit immediately
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
					return TRUE;
				}
			case cancelAllSteps:
				{
					// cancel vertical edit (restores original state)
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
				return TRUE;
				}
			}
		}
		break;
	case glossesStep:
		if (nSequNum > pRec->nGlossStep_EndingSequNum)
		{
			switch (select)
			{
			case pleaseIgnore:
				return FALSE; // **TODO** eliminate this case, 
							  // the return, and the enum value later on
			case nextStep:
				if (gbAdaptBeforeGloss)
				{
					wxCommandEvent eventCustom(wxEVT_Free_Translations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
				}
				else
				{
					wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
				}
				return TRUE;
			case previousStep:
				if (gbAdaptBeforeGloss)
				{
					// rollback to adaptationsStep
					wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
							// the event handlers are in CMainFrame
				}
				else
					::wxBell(); // cannot roll back to the edit source text 
								// dialog, cancel is better
				return TRUE;
			case endNow:
				{
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
					return TRUE;
				}
			case cancelAllSteps:
				{
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
					return TRUE;
				}
			}
		}
		break;
	case freeTranslationsStep:
		if (nSequNum > pRec->nFreeTranslationStep_EndingSequNum)
		{
			switch (select)
			{
			case pleaseIgnore:
				return FALSE; // **TODO** eliminate this case, 
							  // the return, and the enum value later on
			case nextStep:
				{
					StoreFreeTranslationOnLeaving(); // may result in re-storing an 
										// already stored f.t. but its safety first
					wxCommandEvent eventCustom(wxEVT_Back_Translations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
					return TRUE;
				}
			case previousStep:
				if (gbAdaptBeforeGloss)
				{
					// rollback to glossesStep
					wxCommandEvent eventCustom(wxEVT_Glosses_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
				}
				else
				{
					// rollback to adaptationsStep
					wxCommandEvent eventCustom(wxEVT_Adaptations_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
				}
				return TRUE;
			case endNow:
				{
					StoreFreeTranslationOnLeaving();  // may result in re-storing an 
										// already stored f.t. but its safety first
					wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
					return TRUE;
				}
			case cancelAllSteps:
				{
					wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
					wxPostEvent(pApp->GetMainFrame(), eventCustom); 
								// the event handlers are in CMainFrame
					return TRUE;
				}
			}
		}
		break;
	default:
		{
		// control should never come here, but if it does, 
		// make vertical edit mode end immediately
		wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
		wxPostEvent(pApp->GetMainFrame(), eventCustom); 
					// the event handlers are in CMainFrame
		}
	}
	return FALSE; // no PostMessage() has been done, 
				  // so caller can just continue processing

    // we don't need a case for backTranslationsStep, because that is always the last step
    // and if it is entered, it unilaterally ends the vertical edit process when it
    // finishes and the user is never given a chance to do otherwise
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     nothing
/// \param      pRec				-> pointer to the global EditRecode struct, gEditRecord
/// \param      pNewSrcPhrasesList	-> a list of pointers to CSourcePhrase instances from 
///                                    parsing the user's edited source text
/// \param      pSrcPhrases			-> pointer to the document' m_pSourcePhrases list being 
///                                    edited
/// \param      nBeginAtSN			-> sequence number in m_pSourcePhrases list at which 
///                                    transfer begins (inclusive)
/// \param      nFinishAtSN			-> sequence number in m_pSourcePhrases list at which 
///                                    transfer finishes (inclusive)
/// \remarks
/// Called from: 
/// Remove the now unwanted original edited span of CSourcePhrase instances. Insert their
/// replacements, (possibly zero), and tidy up various document parameters so that a
/// recalculation of the layout can be done in the caller on return. An important step,
/// done last, is to call the document function UpdateSequNumbers(0) to get all these
/// numbers into consecutive order. (If the user has deleted the whole editable span, then
/// nBeginAtSN and nFinishAtSN are the same and index the first CSourcePhrase instance of
/// the context following the editable span.)
/// BEW added 8May08 to support refactored Edit Source Text functionality
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::TransferCompletedSrcPhrases(EditRecord* pRec, 
									SPList* pNewSrcPhrasesList, SPList* pSrcPhrases, 
									int nBeginAtSN, int nFinishAtSN)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	wxASSERT(pNewSrcPhrasesList);
	SPList::Node* posMain;
	SPList::Node* posNew;
	SPList* pMainList = pSrcPhrases;
	wxASSERT(pMainList != NULL);
	int nHowManyToDelete = nFinishAtSN - nBeginAtSN + 1;
	int nHowManyToInsert = pNewSrcPhrasesList->GetCount();
	int nExtras = nHowManyToInsert - nHowManyToDelete; // can be +ve, 0, or -ve

	int nBeginAt = nBeginAtSN; // this is the first one to be deleted and 
							   // pointer removed from list
    // first delete the old instances from the m_pSourcePhrases list in the document
    SPList::Node* posSaved = NULL;
	int index;
	CSourcePhrase* pSP = NULL;
	posMain = pMainList->Item(nBeginAt); // MFC used FindIndex
	wxASSERT(posMain != 0);
	for (index = 0; index < nHowManyToDelete; index++)
	{
		posSaved = posMain;
		wxASSERT(posSaved);
		pSP = posMain->GetData();

		// first delete the partner pile
		pDoc->DeletePartnerPile(pSP); 
		
		// now delete the CSourcePhrase instance
		posMain = posMain->GetNext();
		GetDocument()->DeleteSingleSrcPhrase(pSP);
		pMainList->DeleteNode(posSaved);
        // NOTE: this does **NOT** remove the deep copies which are in the
        // pRec->originalSrcPhraseList because that list must persist until the end of the
        // whole edit process, in case the user wants to Cancel out of the edit -- then
        // that list would be used to restore the original document state.
	}

	// user could have deleted the whole editable span, so allow for this possibility 
	// - check here
	if (nHowManyToInsert == 0)
	{
		// do updates that are relevant, then return (in this block, nExtras will be -ve)
		if (pRec->nSaveActiveSequNum >= pRec->nStartingSequNum + nHowManyToInsert)
		{
			if (pApp->m_nActiveSequNum > pApp->GetMaxIndex())
			{
				// if the old active location is now out of bounds, decrease it
				pApp->m_nActiveSequNum += nExtras;
				pRec->nSaveActiveSequNum = pApp->m_nActiveSequNum;
			}
		}
		pDoc->UpdateSequNumbers(0); // update from the beginning of m_pSourcePhrases
		return;
	}

    // if we get here, there is at least one sourcephrase in the new list now insert the
    // new ones - distinguish doing so at the start of the doc versus somewhere within it
	posNew = pNewSrcPhrasesList->GetLast(); // insert in reverse order, to preserve order
	wxASSERT(posNew != 0);
	SPList::Node* posAt = NULL;
	if (nBeginAt == 0)
	{
		// insert at the document start
		posAt = pMainList->Item(0); // always the start // MFC uses FindIndex
		for (index = 0; index < nHowManyToInsert; index++)
		{
			if (posNew == NULL)
				break;
			pSP = posNew->GetData();
			pSP->m_nSequNumber = 0;

			posNew = posNew->GetPrevious();
			wxASSERT(pSP != NULL);
			posAt = pMainList->Insert(posAt, pSP);

			// create a partner pile for it -- it will be inserted at start of m_pileList
			// note: the pSP pointer has to have been inserted in m_pSourcePhrases list
			// before CreatePartnerPile() is called, to ensure correct final location of
			// the partner pile's pointer in m_pileList
			pDoc->CreatePartnerPile(pSP);
		}
		pDoc->UpdateSequNumbers(0); // update from the beginning of m_pSourcePhrases
	}
	else
	{
		// insert within the document (nBeginAt - 1 will not be negative)
		posAt = pMainList->Item(nBeginAt - 1); // always the start
		wxASSERT(posAt != NULL);
		for (index = 0; index < nHowManyToInsert; index++)
		{
			if (posNew == NULL)
				break;
			pSP = posNew->GetData();
			posNew = posNew->GetPrevious();
			wxASSERT(pSP != NULL);
			SPList::Node* newInsertBeforePos = posAt->GetNext();
			if (newInsertBeforePos == NULL)
				pMainList->Append(pSP);
			else
				pMainList->Insert(newInsertBeforePos,pSP);

            // create a partner pile for it -- it will be inserted before the Node* of
            // m_pileList as for the Node* of same index as in the m_pSourcePhrases list;
            // note: the pSP pointer has to have been inserted in m_pSourcePhrases list
            // before CreatePartnerPile() is called, to ensure correct final location of
            // the partner pile's pointer in m_pileList
			pDoc->CreatePartnerPile(pSP);
		}
	}
	// the main list is managing these pointers now, so RemoveAll on the list in pRec
	pNewSrcPhrasesList->Clear();

	pDoc->UpdateSequNumbers(0); // update from the beginning of m_pSourcePhrases

	// update the relevant parameters
	if (pRec->nSaveActiveSequNum >= pRec->nStartingSequNum + nHowManyToInsert)
	{
		if (pApp->m_nActiveSequNum > pApp->GetMaxIndex())
		{
			pApp->m_nActiveSequNum  = pRec->nStartingSequNum; // this is probably a
															  // better active loc
			pRec->nSaveActiveSequNum = pApp->m_nActiveSequNum;
		}
	}
}

// checks the list of unmerged sourcephrase instances corresponding to the former
// selection, as required for editing some source text, to see if there are any standard
// format markers stored on any of the sourcephase instances. In particular, we want to
// know if there are markers on the first one in the list, and if there are any on any of
// the non-first ones in the list. If TRUE for the former and FALSE for the latter,
// transfer can be done without needing to put up a dialog for user control of the
// transfers. If both flags are FALSE, then no markers and associated marker information
// need be done at all.
void CAdapt_ItView::CheckForMarkers(SPList* pList,bool& bHasInitialMarker,
									bool& bHasNoninitialMarker)
{
	wxASSERT(pList->GetCount() > 0); // there must have been something 
								   // selected for editing by the user!
	CSourcePhrase* pSrcPhrase;
	SPList::Node* pos = 0;
	pos = pList->GetFirst();
	bool bIsFirst = TRUE;
	bHasInitialMarker = FALSE;
	bHasNoninitialMarker = FALSE;
	while (pos != 0)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (!pSrcPhrase->m_markers.IsEmpty())
		{
			if (bIsFirst)
			{
				bIsFirst = FALSE;
				bHasInitialMarker = TRUE;
			}
			else
			{
				bHasNoninitialMarker = TRUE;
			}
		}
		else
		{
			bIsFirst = FALSE;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If there are no source phrases in the App's
/// m_pSourcePhrases list this handler disables the "Export Source Text..." item on the
/// File menu, otherwise it enables the "Export Source Text..." item on the File menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExportSource(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// whm revised Revised 1Aug03; bw revised 15 April 2004 to derive the source data
// from the CSourcePhrase instances
void CAdapt_ItView::OnFileExportSource(wxCommandEvent& WXUNUSED(event))
{
	bool bForceUTF8Conversion = TRUE; // BEW changed 08Dec06, to avoid unreliable encoding check
	DoExportSfmText(sourceTextExport,bForceUTF8Conversion); // BEW changed 6Aug09
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// If Vertical Editing is in progress, or if the application is in glossing mode this
/// handler disables the "Export Translation Text..." item in the File menu, otherwise it
/// enables the "Export Translation Text..." item on the File menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExport(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
	{
		if (gbIsGlossing)
			event.Enable(FALSE); // don't allow target text export when glossing
		else
			event.Enable(TRUE); // not glossing, so allow target text export
	}
	else
		event.Enable(FALSE); // nothing to export since doc is empty
}

void CAdapt_ItView::OnFileExport(wxCommandEvent& WXUNUSED(event))
{
	bool bForceUTF8Conversion = TRUE; // BEW changed 08Dec06, as Bob's encoding 
            // checking code was unreliable, so from now on always force the conversion,
            // and remove the Export....As UTF-8 command
	DoExportSfmText(targetTextExport,bForceUTF8Conversion); // BEW changed 6Aug09
}


/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If there are no source phrases in the App's
/// m_pSourcePhrases list, or glossing mode is not on, this handler disables the "Export
/// Glosses As Text..." item on the File menu, otherwise it enables the "Export Glosses As
/// Text..." item on the Export-Import menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateExportGlossesAsText(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// whm 14Aug09 modified test below to allow export of glosses whether or not
	// gbIsGlossing is true or false.
	if (pApp->m_pSourcePhrases->GetCount() > 0) // && gbIsGlossing)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// BEW created 6Aug09 to derive the a text formed by accumulating the contents of the
// m_gloss members with an intervening space betwen each, and adding the SF markers where
// appropriate, from the CSourcePhrase instances
void CAdapt_ItView::OnExportGlossesAsText(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	bool bForceUTF8Conversion = TRUE;
	pApp->m_bExportingGlossesAsText = TRUE;   // set TRUE during export of glosses
	DoExportSfmText(glossesTextExport,bForceUTF8Conversion);
	pApp->m_bExportingGlossesAsText = FALSE;   // restore default value
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If there are no source phrases in the App's
/// m_pSourcePhrases list, or free translations mode is on, this handler disables the
/// "Export Free Translation..." item on the File menu, otherwise it enables it
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateExportFreeTranslations(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	// whm 14Aug09 modified test below to allow export of free translations whether or not
	// m_bFreeTranslationMode is true or false.
	if (pApp->m_pSourcePhrases->GetCount() > 0) // && !pApp->m_bFreeTranslationMode)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// BEW created 6Aug09 to derive the a text formed by accumulating the contents of the
// filtered free translation sections with an intervening space betwen each, and adding the
// SF markers where appropriate, from the CSourcePhrase instances
void CAdapt_ItView::OnExportFreeTranslations(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	bool bForceUTF8Conversion = TRUE;
	pApp->m_bExportingFreeTranslation = TRUE; // set TRUE during export of free translations
	DoExportSfmText(freeTransTextExport,bForceUTF8Conversion);
	pApp->m_bExportingFreeTranslation = FALSE; // restore default value
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "See Glossing" item on the Advanced menu is
/// enabled if the KBs are in a ready state, otherwise the menu item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedEnableglossing(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// we'll allow it to be toggled on or off provided a project is open; the two
	// kb flags being TRUE will be a sufficient test.
	if (pApp->m_bKBReady && pApp->m_bGlossingKBReady)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// BEW added 19Sep08 in support of mode changing within the vertical edit process
void CAdapt_ItView::ToggleSeeGlossesMode()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		CMainFrame* pFrame;
		pFrame = pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxMenuBar* pMenuBar = pApp->GetMainFrame()->GetMenuBar();
		wxASSERT(pMenuBar != NULL);
		wxMenuItem * pAdvancedFreeTranslation;
		pAdvancedFreeTranslation = pMenuBar->FindItem(ID_ADVANCED_FREE_TRANSLATION_MODE);
		wxASSERT(pAdvancedFreeTranslation != NULL);

		// get the checkbox pointer from the "Glossing" checkbox on the controlBar
		wxASSERT(pFrame->m_pControlBar != NULL);
		wxCheckBox* pCheckboxIsGlossing = 
			(wxCheckBox*)pFrame->m_pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
		wxASSERT(pCheckboxIsGlossing != NULL);

        // toggle the setting: note; whether going to or from glossing we will not change
        // the current values of gbGlossingUsesNavFont because the user might go back and
        // forwards from having glossing allowed or actually on (in the one session,) and
        // it would be a nuisance to have to manually restore this flag to its former
        // setting each time the user enables glossing again in the one session. (Leaving
        // the flag ON is benign when adapting.)
		wxMenuItem * pAdvancedSeeGlosses = pMenuBar->FindItem(ID_ADVANCED_ENABLEGLOSSING);
		if (gbEnableGlossing)
		{
			// toggle the checkmark to OFF
			pAdvancedSeeGlosses->Check(FALSE);
			gbEnableGlossing = FALSE;
			gbIsGlossing = FALSE; // must be off whenever the other flag is off

			// hide the mode bar checkbox when glossing is not allowed to be visible
			// and when not visible it obligatorily must be adapting
			pCheckboxIsGlossing->SetValue(FALSE); // not glossing, ie. is adapting
			pCheckboxIsGlossing->Hide();
		}
		else
		{
			// toggle the checkmark to ON
			pAdvancedSeeGlosses->Check(TRUE);
			gbEnableGlossing = TRUE;

            // show the mode bar checkbox when glossing is allowed to be visible
            // - user can then choose either to do glossing, or to do adapting
			pCheckboxIsGlossing->Show(TRUE);
		}
	}
	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	CLayout* pLayout = GetLayout();
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}
}

void CAdapt_ItView::OnAdvancedEnableglossing(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CRefString* pRefStr;
	CSourcePhrase* pSrcPhrase;
	bool bOK;
	CSourcePhrase* pSaveSrcPhrase;
	//CPile* pPile;
	int nSequNum;

	// save the current sequence number
	int nSaveSequNum = pApp->m_nActiveSequNum;

	// won't allow a selection to be preserved, this is too major a modality change
	if (pApp->m_selectionLine != -1)
		RemoveSelection();

    // before we redraw the layout and phrasebox, we have to save what is in the box
    // (provided it's contents are not abandonable or null text) in the appropriate KB,
    // then ready the pApp->m_targetPhrase member to have the correct text before
    // the layout is recalculated
	pApp->m_bSaveToKB = TRUE;

	if (pApp->m_pActivePile == NULL)
		goto a; // the phrase box does not exist (we must be at the document's end)
	pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
	if (gbIsGlossing) // flag has not been toggled yet
	{
        // we are changing from glossing to adapting, so we must store to the glossing
        // KB and then ready the pApp->m_targetPhrase member with the sourcephrase's
        // m_adaption contents and remove its refString from the adapting KB
		if (!(pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
		{
			// we can assume no errors for StoreTest call
			bOK = StoreText(pApp->m_pGlossingKB,pSrcPhrase,pApp->m_targetPhrase);
		}

		// if the active location is within a retranslation, we can't leave the box there
		// when we are in adapting mode, so if that is the case then find a safe location
		if (pSrcPhrase->m_bRetranslation)
		{
			pSaveSrcPhrase = pSrcPhrase;
			pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase); // try first for a location
														   // after retranslation section
			if (pSrcPhrase == NULL)
			{
				pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSrcPhrase);
			}
			// we assume (we won't test) one of the above Get... calls will succeed
			nSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_nActiveSequNum = nSaveSequNum = nSequNum;
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		}

		// now the adaptation stuff
		pApp->m_targetPhrase = pSrcPhrase->m_adaption; // get the adaptation text
		pRefStr = GetRefString(pApp->m_pKB, pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key, pApp->m_targetPhrase);
		gbIsGlossing = FALSE; // so RemoveRefString will get the adaptation KB
							  // but it also gives us the toggle we need too
		RemoveRefString(pRefStr, pSrcPhrase, pSrcPhrase->m_nSrcWords);
		gbIsGlossing = TRUE; // restore it
	}

	// get the Enable Glossing menu pointer
a:	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedMenu = pMenuBar->FindItem(ID_ADVANCED_ENABLEGLOSSING);
	wxASSERT(pAdvancedMenu != NULL);

	// get the checkbox pointer
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxCheckBox* pCheckboxIsGlossing = 
				(wxCheckBox*)pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
	wxASSERT(pCheckboxIsGlossing != NULL);

    // toggle the setting: note; whether going to or from glossing we will not change the
    // current values of gbGlossingUsesNavFont because the user might go back and forwards
    // from having glossing allowed or actually on (in the one session,) and it would be a
    // nuisance to have to manually restore this flag to its former setting each time the
    // user enables glossing again in the one session. (Leaving the flag ON is benign when
    // adapting.)
	if (gbEnableGlossing)
	{
		// toggle the checkmark to OFF
		pAdvancedMenu->Check(FALSE);
		gbEnableGlossing = FALSE;
		gbIsGlossing = FALSE; // must be off whenever the other flag is off

		// hide the mode bar checkbox when glossing is not allowed to be visible
		// and when not visible it obligatorily must be adapting
		pCheckboxIsGlossing->SetValue(FALSE); // not glossing, ie. is adapting
		pCheckboxIsGlossing->Show(FALSE);
	}
	else
	{
		// toggle the checkmark to ON
		pAdvancedMenu->Check(TRUE);
		gbEnableGlossing = TRUE;

		// show the mode bar checkbox when glossing is allowed to be visible - user can
		// then choose either to do glossing, or to do adapting
		pCheckboxIsGlossing->Show(TRUE);
	}

	// redraw the layout etc.
	CLayout* pLayout = GetLayout();

	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}
#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_and_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);

	pApp->m_pTargetBox->m_bAbandonable = FALSE; // we assume the new contents are wanted

	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown()) 
			pApp->m_pTargetBox->SetFocus();
	Invalidate();
	GetLayout()->PlaceBox();
}

// BEW added 19Sep08, for support of mode transitions within vertical edit mode
void CAdapt_ItView::ToggleGlossingMode() 
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		if (gbIsGlossing) // flag has not been toggled yet
		{
			// we are changing from glossing to adapting

			// get any removed adaptations in gEditRecord into the GUI list; but if the
			// mode current on is free translations mode, don't do so
			bool bAllsWell;
			if (!pApp->m_bFreeTranslationMode)
				bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);
		}
		else
		{
			// we are changing from adapting to glossing

			// get any removed glosses in gEditRecord into the GUI list; but if the
			// mode current on is free translations mode, don't do so
			bool bAllsWell;
			if (!pApp->m_bFreeTranslationMode)
				bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
		}

		// set the tick or clear the tick on the menu command
		CMainFrame* pFrame;
		pFrame = pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxASSERT(pFrame->m_pControlBar != NULL);
		wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)
						pFrame->m_pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
		if (gbIsGlossing)
		{
			pCheckboxIsGlossing->SetValue(FALSE);
			gbIsGlossing = FALSE;
		}
		else
		{
			pCheckboxIsGlossing->SetValue(TRUE);
			gbIsGlossing = TRUE;
		}
	}
}

void CAdapt_ItView::OnCheckIsGlossing(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CRefString* pRefStr;
	CSourcePhrase* pSrcPhrase;
	bool bOK;
	CSourcePhrase* pSaveSrcPhrase;
	//CPile* pPile;
	int nSequNum;
	wxString str;

	// save the current sequence number
	int nSaveSequNum = pApp->m_nActiveSequNum;

	// won't allow a selection to be preserved, this is too major a modality change
	if (pApp->m_selectionLine != -1)
		RemoveSelection();

    // before we redraw the layout and phrasebox, we have to save what is in the box
    // (provided it's contents are not abandonable or null text) in the appropriate KB,
    // then ready the pApp->m_targetPhrase member to have the correct text before
    // RedrawEverything is called
	pApp->m_bSaveToKB = TRUE;

	if (pApp->m_pActivePile == NULL)
	{
        // the phrase box is not in existence - because we must be at the end of the
        // document do nothing to be done with the phrasebox here, so just switch the
        // environment
		gbIsGlossing = gbIsGlossing == TRUE ? FALSE : TRUE;
		goto a;
	}
	pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

	if (gbIsGlossing) // flag has not been toggled yet
	{
        // we are changing from glossing to adapting, so we must store to the glossing KB
        // and then ready the pApp->m_targetPhrase member with the sourcephrase's
        // m_adaption contents and remove its refString from the adapting KB; and if the
        // box is within a retranslation then we need to find a safe location for it as
        // close as possible
		if (!(pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
		{
			if (gbRemovePunctuationFromGlosses)
				RemovePunctuation(GetDocument(),&pApp->m_targetPhrase,from_target_text);
			// assume no errors
			bOK = StoreText(pApp->m_pGlossingKB,pSrcPhrase,pApp->m_targetPhrase);
		}

		// now the adaptation stuff
		gbIsGlossing = FALSE; // so RemoveRefString will get the adaptation KB
								// but it also gives us the toggle we need too

		// if the active location is within a retranslation, we can't leave the box there
		// when we are in adapting mode, so if that is the case then find a safe location
		if (pSrcPhrase->m_bRetranslation)
		{
			pSaveSrcPhrase = pSrcPhrase;
			pSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase); // try first for a 
														   // location after retrans
			if (pSrcPhrase == NULL)
			{
				pSrcPhrase = GetPrevSafeSrcPhrase(pSaveSrcPhrase);
			}
			// we assume (we won't test) one of the above Get... calls will succeed
			nSequNum = pSrcPhrase->m_nSequNumber;
			pApp->m_nActiveSequNum = nSaveSequNum = nSequNum;
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		}

		pApp->m_targetPhrase = pSrcPhrase->m_adaption; // get the adaptation text
		if (pSrcPhrase->m_bNotInKB)
		{
			pApp->m_bSaveToKB = FALSE;
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pApp->m_bForceAsk = FALSE;
		}
		else // it's a normal type of entry, so can be in the KB
		{
			pRefStr = GetRefString(pApp->m_pKB, pSrcPhrase->m_nSrcWords,
										pSrcPhrase->m_key, pApp->m_targetPhrase);
			RemoveRefString(pRefStr,pSrcPhrase,pSrcPhrase->m_nSrcWords);
		}

		// get any removed adaptations in gEditRecord into the GUI list; but if the
		// mode current on is free translations mode, don't do so
		bool bAllsWell;
		if (!pApp->m_bFreeTranslationMode)
			bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);
	}
	else
	{
        // we are changing from adapting to glossing, so we must store to the adaptation
        // KB and then ready the pApp->m_targetPhrase member with the sourcephrase's
        // m_gloss contents and remove its refString from the glossing KB; but if it is
        // a "not in kb" entry, then don't store, but just set up pApp->m_targetPhrase
		if (pSrcPhrase->m_bNotInKB)
		{
			str = pApp->m_targetPhrase;
			RemovePunctuation(GetDocument(),&str,from_target_text);
			pSrcPhrase->m_adaption = str;
			MakeLineFourString(pSrcPhrase,pApp->m_targetPhrase);
			pApp->m_bSaveToKB = FALSE;
			pSrcPhrase->m_bHasKBEntry = FALSE;
			pApp->m_bForceAsk = FALSE;
		}
		else
		{
			if (!( pApp->m_pTargetBox->m_bAbandonable || pApp->m_targetPhrase.IsEmpty()))
			{
				str = pApp->m_targetPhrase;
				RemovePunctuation(GetDocument(),&str,from_target_text);
				pSrcPhrase->m_adaption = str;
				MakeLineFourString(pSrcPhrase,pApp->m_targetPhrase);
				bOK = StoreText(pApp->m_pKB,pSrcPhrase,str);
			}
		}
		// now the glossing stuff
		pApp->m_targetPhrase = pSrcPhrase->m_gloss; // get the gloss text
		pRefStr = GetRefString(pApp->m_pGlossingKB,1,pSrcPhrase->m_key,
								pApp->m_targetPhrase);
		gbIsGlossing = TRUE; // so GetRefString( ) will get the glossing KB
							 // but it also gives us the needed toggle too
		RemoveRefString(pRefStr, pSrcPhrase, 1);

		// get any removed glosses in gEditRecord into the GUI list; but if the
		// mode current on is free translations mode, don't do so
		bool bAllsWell;
		if (!pApp->m_bFreeTranslationMode)
			bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
	}

	// set the tick or clear the tick on the menu command
a:	CMainFrame *pFrame = wxGetApp().GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pControlBar;
	pControlBar = pFrame->m_pControlBar;
	wxASSERT(pControlBar != NULL);
	wxCheckBox* pCheckboxIsGlossing = (wxCheckBox*)
						pControlBar->FindWindowById(IDC_CHECK_ISGLOSSING);
	wxASSERT(pCheckboxIsGlossing != NULL);

	if (gbIsGlossing)
		pCheckboxIsGlossing->SetValue(TRUE);
	else
		pCheckboxIsGlossing->SetValue(FALSE);

    // redraw the layout etc. (Must do it after the flag is toggled, otherwise
    // RecalcLayout( ) will think that the untoggled setting is still in effect
    // and lay the pile out wrong) 
	CLayout* pLayout = GetLayout();

	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}

#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);
	pApp->m_pTargetBox->m_bAbandonable = FALSE; // we assume the new 
												// contents are wanted
	// restore focus to the targetBox, if it is visible
	if (pApp->m_pTargetBox != NULL)
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
	Invalidate();
	GetLayout()->PlaceBox();
}

void CAdapt_ItView::OnAdvancedGlossingUsesNavFont(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedGlossingUsesNavFont = 
						pMenuBar->FindItem(ID_ADVANCED_GLOSSING_USES_NAV_FONT);
	wxASSERT(pAdvancedGlossingUsesNavFont != NULL);

	// toggle the setting & update the display accordingly
	if (gbGlossingUsesNavFont)
	{
		// toggle the checkmark to OFF & recalc the layout with glossing using target font
		pAdvancedGlossingUsesNavFont->Check(FALSE);
		gbGlossingUsesNavFont = FALSE;
	}
	else
	{
		// toggle the checkmark to ON, and recalc the layout with glossing using the
		// navText font
		pAdvancedGlossingUsesNavFont->Check(TRUE);
		gbGlossingUsesNavFont = TRUE;
	}

	// redraw everything with the other Font and directionality setting
	CLayout* pLayout = GetLayout();

	// BEW added 10Jun09, support phrase box matching of the text colour chosen
	if (gbIsGlossing && gbGlossingUsesNavFont)
	{
        // set the colour to the navText's colour, and also set its size to that of the
        // target text's font (the user may have navText smaller in the view in order to
        // keep it unobtrusive, but we don't want it unobtrusive in the phrase box!)
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetNavTextColor());
		/*
		// BEW 12Jun09, regretably the next 3 lines are not enough to do the job, because
		// the navText height setting is still unchanged and if I increase that, it will
		// increase it in the navigation text whiteboard area too, and that throws even
		// more stuff out of kilter. 
		//                                     *** TODO *** someday 
        // -- a proper solution would be to define a further dedicated
        // m_pNavTextAtTgtSizeFont wxFont object, and in CLayout have a bool
        // m_bGlossingUsesNavTextFontAtTargetSize member, which is TRUE when glossing and
        // user has chosen the Glossing Uses Nav Text Font menu item, and which is FALSE
        // when that menu item is off; and have the layout code use whichever wxFont member
        // is appropriate given the context
		int pointSize = 12;
		pointSize = pApp->m_pTargetFont->GetPointSize();
		pApp->m_pNavTextFont->SetPointSize(pointSize);
		*/
	}
	else
	{
		pApp->m_pTargetBox->SetOwnForegroundColour(pLayout->GetTgtColor());
	}

#ifdef _NEW_LAYOUT
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_update_pile_widths);
#else
	pLayout->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
	pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);

	Invalidate();
	GetLayout()->PlaceBox(); // this call probably unneeded but no harm done
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Glossing Uses Navigation Text's Font" item on
/// the Advanced menu is enabled if the gbEnableGlossing global is TRUE, otherwise the menu
/// item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedGlossingUsesNavFont(wxUpdateUIEvent& event)
{
	if (gbEnableGlossing)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// called by the application class's DoTransformationsToGlosses( ) function. pSrcPhrase
// points to a source phrase on the heap, and the source phrase belows to the list of
// sourcephrases in the document (from another project) currently being transformed. When
// all such belonging to the current document are transformed, the document is resaved but
// as a document belonging to the current project. The latter fact allows us to simply
// transform each sourcephrase instance that is on the heap, rather than doing the changes
// on copies.
// The transformations ALWAYS take the m_adaption member and transform it, never the
// m_srcPhrase member since the latter may contain unwanted punctuation.
// If the sourcephrase needs to be removed by the caller, return TRUE; null sourcephrases
// are an example of such. The current and next POSITIONs are passed in, in case the
// function needs to access the previous, current or next sourcephrase entry in the list;
// the pointer to the list of the document's sourcephrase instances is pPhrases
// BEW ammended 30Aug05 to bring it into line with version 3; note, m_markers content is
// untouched and so the transformation process preserves filtering, notes, free
// translations, and the like,
// BEW addition 05Jan06 except when m_markers containing a note was moved leftwards by
// right association to a placeholder (pSrcPhrase) in which case we must move it back to
// the sourcephrase which follows the placeholder
bool CAdapt_ItView::TransformSourcePhraseAdaptationsToGlosses(SPList::Node* curPos, 
								SPList::Node* nextPos, CSourcePhrase* pSrcPhrase)
{
    // <Not In KB> instances are changed to normal instances, and if there is an adaptation
    // then make it the gloss, but if not then it is assumed to be not in the glossing KB

    // start with checking for any <Not In KB> entries; since retranslations have the same
    // flag set, we are interested here only in those sourcephrases which are not
    // retranslations
	if (pSrcPhrase->m_bNotInKB && !pSrcPhrase->m_bRetranslation)
	{
		pSrcPhrase->m_bNotInKB = FALSE;
		pSrcPhrase->m_bNullSourcePhrase = FALSE;
		pSrcPhrase->m_bRetranslation = FALSE;
		pSrcPhrase->m_bHasKBEntry = FALSE;
		if (pSrcPhrase->m_adaption.IsEmpty())
		{
			pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
		}
		else
		{
			pSrcPhrase->m_bHasGlossingKBEntry = TRUE;
			pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
			pSrcPhrase->m_adaption.Empty( );
		}
		pSrcPhrase->m_targetStr.Empty(); // play safe
		return FALSE; // we are done with this one, but don't remove it
	}

    // any null sourcephrase instances have to be removed, whether in a retranslation or
    // not, but first we need to check if punctuation was moved from a neighbouring
    // sourcephrase instance, and it so, move it back there
	if (pSrcPhrase->m_bNullSourcePhrase)
	{
        // content can differ depending on whether the null source phrase is part of a
        // retranslation or not. If it is, then no transfers of punctuation will have been
        // done, and we can just throw the null source phrase away; but if it is not then
        // it may be the case that punctuation was moved on to it, so we have to do more
        // tests and move the punctuation back if it was moved, then indicate that the
        // caller must remove the null source phrase
		if (pSrcPhrase->m_bRetranslation)
		{
            // it is part of a retranslation, so we can abandon it (note: boundary flag
            // settings are not moved when a retranslation is padded with nulls, so we
            // don't have to worry about restoring a boundary when we delete the null
            // source phrase in a retranslation) retranslations, when they accept null
            // sourcephrase padding, only fiddle with the m_bRetranslation and m_bNotInKB
            // flag values, nothing else is affected.
            // BEW changed 30Aug05 -- but in version 3 we have to consider the possibility
            // that the last placeholder may be a free translation end (which was moved to
            // the last inserted placeholder) and move it back to where it was originally
			//
            // BEW note 05Jan06: we also assume that the user would not place a note on a
            // placeholder within a retranslation; but if he did then this assumption would
            // result in it being lost in the transform process -- to fix this, add
            // code to what is below
			if (pSrcPhrase->m_bEndFreeTrans)
			{
				// move it back to the last non-placeholder sourcephrase
				SPList::Node* prevPos = curPos;
				CSourcePhrase* pPrevSrcPhrase = (CSourcePhrase*)prevPos->GetData();
				prevPos = prevPos->GetPrevious();
				wxASSERT(pPrevSrcPhrase != NULL);
				pPrevSrcPhrase->m_bEndFreeTrans = TRUE;
			}
			return TRUE; //  remove now
		}
		else
		{
            // it is not part of a retranslation, so do the extra checks related to
            // punctuation... first, get the the previous source phrase, if it exists, in
            // case we need it
			SPList::Node* prevPos = curPos; 
			CSourcePhrase* pPrevSrcPhrase = (CSourcePhrase*)prevPos->GetData();
			prevPos = prevPos->GetPrevious();
			bool bSomethingWasMoved = FALSE;
			if (prevPos != NULL)
			{
				// previous POSITION value is valid, so get its pointer
				pPrevSrcPhrase = (CSourcePhrase*)prevPos->GetData();

				// BEW additions 30Aug05 for version 3
				if (pSrcPhrase->m_bEndFreeTrans)
				{
					// the placeholder was previously left-associated to the end of
					// a free translation section, so move the flag back where it was
					pPrevSrcPhrase->m_bEndFreeTrans = TRUE;
					bSomethingWasMoved = TRUE;
				}
				// end of 30Aug05 additions
				if (!pSrcPhrase->m_follPunct.IsEmpty())
				{
					// punctuation was moved to this source phrase, so move it back
					pPrevSrcPhrase->m_follPunct = pSrcPhrase->m_follPunct;
					bSomethingWasMoved = TRUE;
				}
				if (pSrcPhrase->m_bFootnoteEnd)
				{
					// at a footnote end, so move the end marker to previous srcphrase
					pPrevSrcPhrase->m_bFootnoteEnd = TRUE;
					bSomethingWasMoved = TRUE;
				}
				if (pPrevSrcPhrase->m_bBoundary)
				{
					// boundary was moved, so move it back
					pPrevSrcPhrase->m_bBoundary = TRUE;
					bSomethingWasMoved = TRUE;
				}
				if (bSomethingWasMoved)
					return TRUE; // remove this null src phrase now
			}
			else
			{
                // no previous srcPhrase exists, so nothing could have been moved from it
                // so check out the rightwards association possibilites to see if any
                // previous punctuation was moved leftwards to this null source phrase
				;
			}

			// check for leftwards move of punctuation
			if (nextPos == NULL)
			{
				// at the end of the document, so no possibility of a rightwards
				// association so get rid of this null source phrase now
				return TRUE;
			}
			else
			{
				CSourcePhrase* pNextSrcPhrase = (CSourcePhrase*)nextPos->GetData();
				wxASSERT(pNextSrcPhrase);
                // BEW addition 05Jan06 to handle any note moved to the placeholder by a
                // previous right association - the note (and any other m_markers content)
                // must be moved back the following sourcephrase instance
				if (pSrcPhrase->m_bHasNote)
				{
					pNextSrcPhrase->m_bHasNote = TRUE;
                    // we can concatenate without bothering to add an intervening space
                    // because m_markers always should end in a space
					pNextSrcPhrase->m_markers += pSrcPhrase->m_markers;
                    // the above order change is deliberate; after the earlier left
                    // transfer of m_markers to the placeholder, the user may have put a
                    // note or back translation or free translation on the sourcephrase
                    // instance following the placeholder; the above order will move any
                    // such additions to the front of m_markers, which is a benign order
                    // change as Adapt It won't care; but if the earlier m_markers before
                    // being moved to the left had unfiltered markers, these will be at its
                    // end and they define the subsequent TextType and so need to remain at
                    // the end, so changing the order as above will ensure that any such
                    // remain at the end of the m_markers string
				}
				if (!pSrcPhrase->m_precPunct.IsEmpty())
				{
					// punctuation was moved here, so move it back
					pNextSrcPhrase->m_precPunct = pSrcPhrase->m_precPunct;
				}
				if (!pSrcPhrase->m_markers.IsEmpty())
				{
					// markers were moved, so move them back
					pNextSrcPhrase->m_markers = pSrcPhrase->m_markers;
				}
				if (pSrcPhrase->m_bFootnote)
				{
                    // we are at the start of a footnote, so the src phrase to the right
                    // must be where the footnote marker was copied from and the flag moved
                    // from (markers will be fixed by previous block, just do the flag now)
					pNextSrcPhrase->m_bFootnote = TRUE;
				}
				if (pSrcPhrase->m_bFirstOfType)
				{
					pNextSrcPhrase->m_bFirstOfType = TRUE;
				}
				// BEW additions 30Aug05 for version 3
				if (pSrcPhrase->m_bStartFreeTrans)
				{
					pNextSrcPhrase->m_bStartFreeTrans = TRUE;
				}
				if (!pSrcPhrase->m_inform.IsEmpty())
				{
					pNextSrcPhrase->m_inform = pSrcPhrase->m_inform;
				}
				if (!pSrcPhrase->m_chapterVerse.IsEmpty())
				{
					pNextSrcPhrase->m_chapterVerse = pSrcPhrase->m_chapterVerse;
				}
				if (pSrcPhrase->m_bVerse)
				{
					pNextSrcPhrase->m_bVerse = pSrcPhrase->m_bVerse;
				}
				if (pSrcPhrase->m_bChapter)
				{
					pNextSrcPhrase->m_bChapter = pSrcPhrase->m_bChapter;
				}
				if (pSrcPhrase->m_bVerse)
				{
					pNextSrcPhrase->m_bVerse = pSrcPhrase->m_bVerse;
				}
				if (pSrcPhrase->m_bParagraph)
				{
					pNextSrcPhrase->m_bParagraph = pSrcPhrase->m_bParagraph;
				}
				if (pSrcPhrase->m_bSpecialText)
				{
					pNextSrcPhrase->m_bSpecialText = pSrcPhrase->m_bSpecialText;
				}
				// end 30Aug05 additions
			}
			return TRUE; // needs to be removed
		} // end block for null source phrase not a part of a retranslation
	} // end block for null source phrases

	// now we have to check for retranslation sourcephrases which are not placeholders
	// - these have no KB presence, so all we can do is leave the m_gloss member empty
	// under the transform operation
	if (pSrcPhrase->m_bRetranslation)
	{
		pSrcPhrase->m_gloss.Empty();
		pSrcPhrase->m_adaption.Empty();
		pSrcPhrase->m_targetStr.Empty();
		pSrcPhrase->m_bHasKBEntry = FALSE;
		pSrcPhrase->m_bHasGlossingKBEntry = FALSE;
		pSrcPhrase->m_bNotInKB = FALSE;
		pSrcPhrase->m_bRetranslation = FALSE;
		pSrcPhrase->m_bBeginRetranslation = FALSE;
		pSrcPhrase->m_bEndRetranslation = FALSE;
		return FALSE; // don't remove this one
	}

	// anything else is normal srcphrase and just do the transformations required
	pSrcPhrase->m_gloss = pSrcPhrase->m_adaption;
	pSrcPhrase->m_adaption.Empty();
	pSrcPhrase->m_targetStr.Empty();
	pSrcPhrase->m_bHasKBEntry = FALSE;
	pSrcPhrase->m_bHasGlossingKBEntry = TRUE;

	return FALSE; // don't delete this one
}

// added by Bill Martin 1June2003
void CAdapt_ItView::OnFileExportToRtf(wxCommandEvent& WXUNUSED(event))
{
	DoExportInterlinearRTF(); // now located in ExportFunctions.cpp and .h
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the File Menu  
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. If there are no source phrases in the App's
/// m_pSourcePhrases list this handler disables the "Export Interlinear Text..." item on
/// the File menu, otherwise it enables the "Export Interlinear Text..." item on the File
/// menu.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateFileExportToRtf(wxUpdateUIEvent& event)
{
	// added by Bill Martin 1June2003
	// make sure there are some SourcePhrases to work with
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

/////////////////////////////////////////////////
///
/// Functions for support of Auto-Capitalization
///
////////////////////////////////////////////////

inline wxChar CAdapt_ItView::GetFirstChar(wxString& strText)
{
	return strText.GetChar(0);
}

// takes the input character chTest, and attempts to Find() it in the CString theCharSet,
// returning TRUE if it finds it, and setting index to the character index for its position
// in the string buffer; if not found, then index will be set to -1.
bool CAdapt_ItView::IsInCaseCharSet(wxChar chTest, wxString& theCharSet, int& index)
{
	index = theCharSet.Find(chTest);
	if (index > -1)
	{
		// it is in the list
		return TRUE;
	}
	else
	{
		// it is not in the list
		return FALSE;
	}
}

// returns the TCHAR at the passed in offset
wxChar CAdapt_ItView::GetOtherCaseChar(wxString& charSet, int nOffset)
{
	wxASSERT(nOffset < (int)charSet.Length());
	return charSet.GetChar(nOffset);
}

//return TRUE if all was well, FALSE if there was an error; strText is the language word or
//phrase the first character of which this function tests to determine its case, and from
//that to set up storage for the lower or upper case equivalent character, and the relevant
//flags. strText can be source text, target text, or gloss text; for the latter two
//possibilities bIsSrcText needs to be explicitly set to FALSE, otherwise it is TRUE by
//default. This is a diagnostic function used for Auto-Capitalization support.
bool CAdapt_ItView::SetCaseParameters(wxString& strText, bool bIsSrcText)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (strText.IsEmpty())
	{
		return FALSE;
	}
	int nOffset = -1;
	wxChar chFirst = GetFirstChar(strText);

	bool bIsLower;
	bool bIsUpper;
	if (bIsSrcText)
	{
		// exit prematurely if the user has not defined any source case equivalents
		if (gbNoSourceCaseEquivalents)
		{
			gbSourceIsUpperCase = FALSE; // ensures an old style lookup or store
			return FALSE;
		}

		// determine if it is a lower case source character 
		// which has an upper case equivalent
		bIsLower = IsInCaseCharSet(chFirst,pApp->m_srcLowerCaseChars,nOffset);
		if (bIsLower)
		{
			// it's a lower case belonging to the source set,
			// so we don't have to capitalize it
			gbSourceIsUpperCase = FALSE;
			gcharSrcLC = chFirst;
			wxASSERT(nOffset >= 0);
			gcharSrcUC = GetOtherCaseChar(pApp->m_srcUpperCaseChars,nOffset);
		}
		else
		{
            // chFirst is not a lower case source character which has an upper case
            // equivalent, so it might be an upper case source character (having a lower
            // case equivalent), or it is of indeterminate case - in which case we treat
            // it as lower case
			bIsUpper = IsInCaseCharSet(chFirst,pApp->m_srcUpperCaseChars,nOffset);
			if (bIsUpper)
			{
				// it is an upper case source char for which there is a lower case 
				// equivalent
				gbSourceIsUpperCase = TRUE;
				gcharSrcUC = chFirst;
				wxASSERT(nOffset >= 0);
				gcharSrcLC = GetOtherCaseChar(pApp->m_srcLowerCaseChars,nOffset);
			}
			else
			{
				// it has indeterminate case, so treat as lower case with zero as its 
				// upper case equiv
				gbSourceIsUpperCase = FALSE;
				gcharSrcLC = chFirst;
				wxASSERT(nOffset == -1);
				gcharSrcUC = _T('\0');
			}
		}
	}
	else
	{
        // it is either gloss or adaptation data: use gbIsGlossing to determine which...
        // determine if it is a lower case character which has an upper case equivalent
		if (gbIsGlossing)
		{
			// it's gloss data
			// exit prematurely if the user has not specified any gloss case equivalents
			if (gbNoGlossCaseEquivalents)
			{
				gbNonSourceIsUpperCase = FALSE; // ensures an old style lookup or store
				gcharNonSrcUC = _T('\0'); // use the value as a test indicating failure here
				return FALSE;
			}
			bIsLower = IsInCaseCharSet(chFirst,pApp->m_glossLowerCaseChars,nOffset);
		}
		else
		{
			// it's adaptation data
			// exit prematurely if the user has not specified any target case equivalents
			if (gbNoTargetCaseEquivalents)
			{
				gbNonSourceIsUpperCase = FALSE; // ensures an old style lookup or store
				gcharNonSrcUC = _T('\0'); // use the value as a test indicating failure
				return FALSE;
			}
			bIsLower = IsInCaseCharSet(chFirst,pApp->m_tgtLowerCaseChars,nOffset);
		}
		if (bIsLower)
		{
			// it's a lower case belonging to the gloss or adaptation set,
			// so we don't have to capitalize it
			gbNonSourceIsUpperCase = FALSE;
			gcharNonSrcLC = chFirst;
			wxASSERT(nOffset >= 0);
			if (gbIsGlossing)
			{
				gcharNonSrcUC = GetOtherCaseChar(pApp->m_glossUpperCaseChars,nOffset);
			}
			else
			{
				gcharNonSrcUC = GetOtherCaseChar(pApp->m_tgtUpperCaseChars,nOffset);
			}
		}
		else // it's not lower case...
		{
            // chFirst is not a lower case adaptation or gloss character which has an upper
            // case equivalent, so it might be an upper case adaptation or gloss character
            // (having a lower case equivalent), or it is of indeterminate case - in which
            // case we treat it as lower case
			if (gbIsGlossing)
			{
				bIsUpper = IsInCaseCharSet(chFirst,pApp->m_glossUpperCaseChars,nOffset);
			}
			else
			{
				bIsUpper = IsInCaseCharSet(chFirst,pApp->m_tgtUpperCaseChars,nOffset);
			}
			if (bIsUpper)
			{
				// it is an upper case gloss or adaptation char for which there is a lower
				// case equivalent
				gbNonSourceIsUpperCase = TRUE;
				gcharNonSrcUC = chFirst;
				wxASSERT(nOffset >= 0);
				if (gbIsGlossing)
				{
					gcharNonSrcLC = GetOtherCaseChar(pApp->m_glossLowerCaseChars,nOffset);
				}
				else
				{
					gcharNonSrcLC = GetOtherCaseChar(pApp->m_tgtLowerCaseChars,nOffset);
				}
			}
			else
			{
				// it has indeterminate case, so treat as lower case with zero as 
				// its upper case equiv
				gbNonSourceIsUpperCase = FALSE;
				gcharNonSrcLC = chFirst;
				wxASSERT(nOffset == -1);
				gcharNonSrcUC = _T('\0');
			}
		}
	}
	return TRUE;
}

// in this function, the keyStr parameter will always be a source string; the caller must
// determine which particular map is to be looked up and provide it's pointer as the first
// parameter; and if the lookup succeeds, pTU is the associated CTargetUnit instance's
// poiner. This function, as the name suggests, has the smarts for AutoCapitalization being
// On or Off.
// WX Note: Changed second parameter to CTargetUnit*& pTU.
bool CAdapt_ItView::AutoCapsLookup(MapKeyStringToTgtUnit* pMap, CTargetUnit*& pTU,
								   wxString keyStr)
{
	wxString saveKey;
	gbMatchedKB_UCentry = FALSE; // ensure it has default value 
								 // before every first lookup
	MapKeyStringToTgtUnit::iterator iter;

    // the test of gbCallerIsRemoveButton is to prevent a wrong change to lower case if
    // autocapitalization is on and the user clicked in the KB editor, or in Choose
    // Translation dlg, the Remove button; otherwise the wrong entry could get deleted
    // and the data made invalid
	if (gbAutoCaps && !gbCallerIsRemoveButton)
	{
		if (gbNoSourceCaseEquivalents)
			// this is equivalent to gbAutoCaps being off, so just do a normal lookup
			goto a;

		// auto capitalization is ON, so determine the relevant parameters etc.
		bool bNoError = SetCaseParameters(keyStr); // extra param is TRUE since
												   // it is source text
		if (!bNoError)
			goto a; // keyStr must have been empty (impossible) or the user
					// did not define any source language case correspondences
		if (gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
		{
			// we will have to change the case for the first lookup attempt
			saveKey = keyStr; // save for an upper case lookup 
							  // if the first lookup fails
			// make the first character of keyStr be the appropriate lower case one
			keyStr.SetChar(0,gcharSrcLC); // gcharSrcLC is set within the 
										  // SetCaseParameters() call
			// do the lower case lookup
			iter = pMap->find(keyStr);
			if (iter != pMap->end())
			{
				pTU = iter->second; // we have a match, pTU now points 
									// to a CTargetUnit instance
				wxASSERT(pTU != NULL);
				return TRUE;
			}
            // if we get here, then the match failed, so just in case there is an upper
            // case entry in the knowledge base (from when autocapitalization was OFF),
            // look it up; if there, then set the gbMatchedKB_UCentry to TRUE so the caller
            // will know that no restoration of upper case will be required for the gloss
            // or adaptation that it returns
			iter = pMap->find(saveKey);
			if (iter != pMap->end())
			{
				pTU = iter->second; // we have a match, pTU now points 
									// to a CTargetUnit instance
				wxASSERT(pTU != NULL);
                // found a match, so we can assume its refStrings contain upper case
                // initial strings already
				gbMatchedKB_UCentry = TRUE;
				return TRUE;
			}
			else
			{
				pTU = (CTargetUnit*)NULL;
				return FALSE;
			}
		}
		else
		{
			// first letter of source word or phrase is lower case, so do a normal lookup
			goto a;
		}
	}
	else
	{
		// auto capitalization is OFF, so just do a lookup with the keyStr as supplied
a:		iter = pMap->find(keyStr);
		if (iter != pMap->end())
		{
			pTU = iter->second;
			wxASSERT(pTU != NULL);
			return TRUE;
		}
		else
		{
			pTU = (CTargetUnit*)NULL;
			return FALSE;
		}
	}
#ifndef __VISUALC__
	return FALSE; // unreachable according to VC7.1, but gcc says it is needed!!!
#endif
}

// the "adaptation" parameter will contain an adaptation if gbIsGlossing is FALSE, or if
// TRUE if will contain a gloss; and also depending on the same flag, the pTgtUnit will have
// come from either the adaptation KB or the glossing KB.
CRefString* CAdapt_ItView::AutoCapsFindRefString(CTargetUnit* pTgtUnit,wxString adaptation)
{
	CRefString* pRefStr = (CRefString*)NULL;
	TranslationsList* pList = pTgtUnit->m_pTranslations;
	wxASSERT(pList);
	bool bNoError;
	if (gbAutoCaps && gbSourceIsUpperCase && !gbMatchedKB_UCentry && !adaptation.IsEmpty())
	{
		// possibly we may need to change the case of first character of 'adaptation'
		bNoError = SetCaseParameters(adaptation, FALSE); // FALSE means it is an
														 // adaptation or a gloss
		if (bNoError && gbNonSourceIsUpperCase && (gcharNonSrcLC != _T('\0')))
		{
			// a change to lower case is called for; 
			// otherwise leave 'adaptation' unchanged
			adaptation.SetChar(0,gcharNonSrcLC);
		}
	}
	else
	{
        // either autocapitalization is OFF, or the source text starts with a lower case
        // letter, or the first lookup for the key failed but an upper case lookup
        // succeeded (in which case we assume its a old style entry in the KB) or the
        // adaptation string is empty - any of these conditions require that no change of
        // case be done
		;
	}

	TranslationsList::Node *pos = pList->GetFirst();
	while(pos != NULL)
	{
		pRefStr = (CRefString*)pos->GetData();
		pos = pos->GetNext();
		wxASSERT(pRefStr != NULL);
		if (pRefStr->m_translation == adaptation)
			return pRefStr; // we found it
		else
		{
			if (adaptation.IsEmpty())
			{
				// it might be a <Not In KB> source phrase, check it out
				if (pRefStr->m_translation == _T("<Not In KB>"))
					return pRefStr; // we return the pointer to this too
			}
		}
	}
	// finding it failed so return NULL
	return (CRefString*)NULL;
}

// pass in a source string, to be converted to initial lower case;
// or a gloss or adaptation string which is to be saved to a KB, and internally
// have all the smarts for determining if a change of case for first character
// is needed, and return the string, the same or suitably ammended, back to the
// caller. bIsSrc parameter is TRUE by default.
wxString CAdapt_ItView::AutoCapsMakeStorageString(wxString str, bool bIsSrc)
{
	bool bNoError = TRUE;
	if (str.IsEmpty())
		return str;

	// gbMatchedKB_UCentry is never relevant to storing when gbAutoCaps is on,
	// even if the former is TRUE, we'll still want to convert the source string
	// to have initial lower case when storing
	if (bIsSrc)
	{
		// SetCaseParameters( ) will already have been called, 
		// so convert if required to do so
		if (gbAutoCaps && gbSourceIsUpperCase && (gcharSrcLC != _T('\0')))
		{
			str.SetChar(0,gcharSrcLC);
		}
	}
	else
	{
		// must be a gloss or adaptation string
		if (gbAutoCaps && gbSourceIsUpperCase)
		{
			bNoError = SetCaseParameters(str,FALSE);
			if (!bNoError)
				goto a;
			if (gbNonSourceIsUpperCase && (gcharNonSrcLC != _T('\0')))
			{
				// we need to make it start with lower case for storage in the KB
				str.SetChar(0,gcharNonSrcLC);
			}
		}
	}
a:	return str;
}

void CAdapt_ItView::OnAdvancedDelay(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	/*
	// test SyncScrollReceive() code here (delay is unrelated, just use its button)
	wxString strValue = _T("1JN 2:19");
	wxString strThreeLetterBook;
	wxString strChapVerse;
	int nChapter;
	int nVerse;
	ExtractScriptureReferenceParticulars(strValue,strThreeLetterBook,
										strChapVerse,nChapter,nVerse);
	bool bSuccess;
	bSuccess = SyncScrollReceive(strThreeLetterBook, nChapter, 
								nVerse, strChapVerse);
	// end of code test
	*/
	CSetDelay dlg(pApp->GetMainFrame());

	dlg.m_nDelay = pApp->m_nCurDelay;

	if (dlg.ShowModal() == wxID_OK)
	{
		pApp->m_nCurDelay = dlg.m_nDelay;

		// update the copy shown on mode bar (it's read only there)
		CMainFrame* pMainFrame = pApp->GetMainFrame();
		wxASSERT(pMainFrame);
		wxPanel* pControlBar = pMainFrame->m_pControlBar;
		wxASSERT(pControlBar); 
		wxTextCtrl* pDelayBox = (wxTextCtrl*)pControlBar->FindWindowById(IDC_EDIT_DELAY);
		wxASSERT(pDelayBox);
		wxString s;
		s.Empty();
		s << dlg.m_nDelay; //s = buf;
		pDelayBox->SetValue(s);
		pControlBar->Refresh();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Delay..." item on the Advanced menu is disabled
/// if the application is in Free Translation mode, but enabled if the KB is in a ready
/// state.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedDelay(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bKBReady)
	{
		event.Enable(TRUE); // always enabled if a project is active
	}
}

///////////////////// FREE TRANSLATION MODE SUPPORT /////////////////////////////
///
/// BEW addition 21Jun05, handlers for free translation supporting buttons in Compose Bar
///
/////////////////////////////////////////////////////////////////////////////////

void CAdapt_ItView::OnAdvancedFreeTranslationMode(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pAdvancedMenuFTMode = 
						pMenuBar->FindItem(ID_ADVANCED_FREE_TRANSLATION_MODE);
	wxASSERT(pAdvancedMenuFTMode != NULL);
	gbSuppressSetup = FALSE; // setdefault value
	CLayout* pLayout = GetLayout();

    // determine if the document is unstructured or not -- we'll need this set or cleared
    // as appropriate because in free translation mode the user may elect to end sections
    // at verse breaks - and we can't do that for unstructured data (in the latter case,
    // we'll just end when there is following punctuation on a word or phrase)
	SPList* pSrcPhrases = pApp->m_pSourcePhrases;
	gbIsUnstructuredData = IsUnstructuredData(pSrcPhrases);

	// toggle the setting
	if (pApp->m_bFreeTranslationMode)
	{
		// toggle the checkmark to OFF
		pAdvancedMenuFTMode->Check(FALSE);
		pApp->m_bFreeTranslationMode = FALSE;

        // free translation mode is being turned off, so "fix" the current free translation
        // before the gpCurFreeTransSectionPileArray contents are invalidated by the
        // RecalcLayout() call within ComposeBarGuts() below
		StoreFreeTranslationOnLeaving();
	}
	else
	{
		// toggle the checkmark to ON
		pAdvancedMenuFTMode->Check(TRUE);
		pApp->m_bFreeTranslationMode = TRUE;
	}
	if (pApp->m_bFreeTranslationMode)
	{
        // put the target punctuation character set into gSpacelessTgtPunctuation to be
        // used in the HasWordFinalPunctuation() function to work out when to end a span of
        // free translation (can't put this after the ComposeBarGuts() call because the
        // latter calls SetupCurrentFreeTransSection(), and it needs
        // gSpacelessTgtPunctuation set up beforehand)
		gSpacelessTgtPunctuation = pApp->m_punctuation[1]; // target set, with 
														   // delimiting spaces
		gSpacelessTgtPunctuation.Remove(gSpacelessTgtPunctuation.Find(_T(' ')),1); // get 
																	// rid of the spaces
	}

	// restore focus to the targetBox, if free translation mode was just turned off,
	// else to the CEdit in the Compose Bar because it has just been turned on
	// -- providing the box or bar is visible and its handle exists
	pFrame->ComposeBarGuts(); // open or close the Compose Bar -- it does a 
            // RecalcLayout() call, so if turning off free translation mode, the
            // gpCurFreeTransSectionPileArray array will store hanging pointers,
            // so don't use it below

	if (pApp->m_bFreeTranslationMode)
	{
        // free translation mode was just turned on. The phrase box might happen to be
        // located within a previously composed section of free translation, but not at
        // that section's anchor point, so we must check for this and if so, iterate back
        // over the piles until we get to the anchor point - but we may come to the start
        // of the bundle before we get there, so we have to do a bundle retreat in that
        // event - all this is handled in the block below (comments will be minimal because
        // this code is taken from the fully commented code for doing the same, in
        // OnLButtonDown())
		CPile* pPile = pApp->m_pActivePile; // current box location
		CSourcePhrase* pSP = pPile->GetSrcPhrase();
		CKB* pKB;
		if (gbIsGlossing)
			pKB = pApp->m_pGlossingKB;
		else
			pKB = pApp->m_pKB;
		if (pSP->m_bHasFreeTrans && !pSP->m_bStartFreeTrans)
		{
			// save the phrase box text to the KB
			// left it here -- may need to ensure m_targetPhrase has no punct before 
			// passing to StoreTextGoingBack()
			bool bOK;
			bOK = StoreTextGoingBack(pKB,pSP,pApp->m_targetPhrase); // store, so we can 
																// forget this location
		}
		while (pSP->m_bHasFreeTrans && !pSP->m_bStartFreeTrans)
		{
			// iterate backwards to the anchor pile
			CPile* pPrevPile = GetPrevPile(pPile);
			if (pPrevPile == NULL)
			{
				// got to doc start without detecting the start - should never happen
				// so just shove it at start of doc, with no lookup and a beep
				int sn = 0;
				pApp->m_targetPhrase.Empty();
				pPile = GetPile(sn);
				pApp->GetMainFrame()->canvas->ScrollIntoView(sn);
				::wxBell();
				break;
			}
			else
			{
				pPile = pPrevPile;
			}
			pSP = pPile->GetSrcPhrase();
		}
		// we are at the anchor location
		pApp->m_pActivePile = pPile;
		pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber;

        // BEW changed 15Oct05; since if we have an adaptation there different than the
        // source text we want to preserve it, rather than unilaterally just use m_key; and
        // if the member is empty, then leave the box empty rather than have the source
        // copied in free translation mode
		if (gbIsGlossing)
		{
			if (pSP->m_gloss.IsEmpty())
			{
				pApp->m_targetPhrase.Empty();
			}
			else
			{
				pApp->m_targetPhrase = pSP->m_gloss;
			}
		}
		else
		{
			if (pSP->m_adaption.IsEmpty())
			{
				pApp->m_targetPhrase.Empty();
			}
			else
			{
				pApp->m_targetPhrase = pSP->m_adaption;
			}
		}
		translation = pApp->m_targetPhrase; // in case we just unmerged, since a 
                        //PlacePhraseBox() call with selector == 1 or 3 will set
                        //m_targetPhrase to whatever is currently in the global string
                        //translation when it jumps the block of code for removing the new
                        //location's entry from the KB
		CCell* pCell = pPile->GetCell(1); // need this for the PlacePhraseBox() call
		PlacePhraseBox(pCell,1); // 1 = inhibit saving at old location, as we did it above
				// instead, and also don't remove the new location's KB entry (as the 
				// phrase box is disabled)

		// prevent clicks and editing being done in phrase box (do also in ResizeBox())
		if (pApp->m_pTargetBox->IsShown() && pApp->m_pTargetBox->GetHandle() != NULL)
			pApp->m_pTargetBox->SetEditable(FALSE);
		pLayout->m_pCanvas->ScrollIntoView(
								pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber);

          // whm 4Apr09 moved this SetFocus below ScrollIntoView since ScrollIntoView seems
          // to remove the focus on the Compose Bar's edit box if it follows the SetFocus
          // call. now put the focus in the Compose Bar's edit box, and disable the phrase
          // box for clicks & editing, and make it able to right justify and render RTL if
          // we are in the Unicode app
		if (pFrame->m_pComposeBar->GetHandle() != NULL)
			if (pFrame->m_pComposeBar->IsShown())
			{
				#ifdef _RTL_FLAGS
					// enable complex rendering
					if (pApp->m_bTgtRTL)
					{
						pFrame->m_pComposeBarEditBox->SetLayoutDirection(
							wxLayout_RightToLeft);
					}
					else
					{
						pFrame->m_pComposeBarEditBox->SetLayoutDirection(
							wxLayout_LeftToRight);
					}
				#endif
				pFrame->m_pComposeBarEditBox->SetFocus();

			}

		// get any removed free translations in gEditRecord into the GUI list
		bool bAllsWell;
		bAllsWell = PopulateRemovalsComboBox(freeTranslationsStep, &gEditRecord);
	}
	else
	{
        // if the user exits the mode while the phrase box is within a retranslation, we
        // don't want the box left there (though the app would handle it just fine, no
        // crash or other problem), so check for this and if so, move the active location
        // to a safe place nearby
		int numSrcPhrases;
		int nCountForwards = 0;
		int nCountBackwards = 0;
		int nSaveActiveSequNum;
		if (pApp->m_pActivePile->GetSrcPhrase()->m_bRetranslation)
		{
			// we have to move the box
			CSourcePhrase* pSrcPhr = pApp->m_pActivePile->GetSrcPhrase();
			SPList::Node* pos = pSrcPhrases->Find(pSrcPhr);
			wxASSERT(pos);
			SPList::Node* savePos = pos;
			if (pSrcPhr->m_bBeginRetranslation)
			{
				// we are at the start of the section
				nCountForwards = 1;
				pSrcPhr = (CSourcePhrase*)pos->GetData(); // counted this one
				pos = pos->GetNext();
				while (pos != NULL)
				{
					pSrcPhr = (CSourcePhrase*)pos->GetData();
					pos = pos->GetNext();
					nCountForwards++;
					if (pSrcPhr->m_bEndRetranslation)
						break;
				}
				nSaveActiveSequNum = pSrcPhr->m_nSequNumber + 1;
				numSrcPhrases = nCountForwards;
			}
			else if (pSrcPhr->m_bEndRetranslation)
			{
				nSaveActiveSequNum = pSrcPhr->m_nSequNumber + 1;
				nCountBackwards = 1;
				pSrcPhr = (CSourcePhrase*)pos->GetData(); // counted this one
				pos = pos->GetPrevious();
				while (pos != NULL)
				{
					pSrcPhr = (CSourcePhrase*)pos->GetData();
					pos = pos->GetPrevious();
					nCountBackwards++;
					if (pSrcPhr->m_bBeginRetranslation)
						break;
				}
				numSrcPhrases = nCountBackwards;
			}
			else
			{
				// somewhere in the middle of the retranslation span
				nCountForwards = 1;
				pSrcPhr = (CSourcePhrase*)pos->GetData(); // counted this one
				pos = pos->GetNext();
				while (pos != NULL)
				{
					pSrcPhr = (CSourcePhrase*)pos->GetData();
					pos = pos->GetNext();
					nCountForwards++;
					if (pSrcPhr->m_bEndRetranslation)
						break;
				}
				nSaveActiveSequNum = pSrcPhr->m_nSequNumber + 1;
				pos = savePos; // restore original position
				nCountBackwards = 0;
				pSrcPhr = (CSourcePhrase*)pos->GetData(); // already counted
				pos = pos->GetPrevious();
				while (pos != NULL)
				{
					pSrcPhr = (CSourcePhrase*)pos->GetData();
					pos = pos->GetPrevious();
					nCountBackwards++;
					if (pSrcPhr->m_bBeginRetranslation)
						break;
				}
				numSrcPhrases = nCountForwards + nCountBackwards;
			}
			bool bOK;
			bOK = SetActivePilePointerSafely(pApp,pSrcPhrases,nSaveActiveSequNum,
											pApp->m_nActiveSequNum,numSrcPhrases);
		}

		translation.Empty(); // don't preserve anything from a former adaptation state
		if (pApp->m_pTargetBox->GetHandle() != NULL)
			if (pApp->m_pTargetBox->IsShown())
				pApp->m_pTargetBox->SetFocus();

		// allow clicks and editing to be done in phrase box (do also in ResizeBox())
		if (pApp->m_pTargetBox->IsShown() && pApp->m_pTargetBox->GetHandle() != NULL)
			pApp->m_pTargetBox->SetEditable(TRUE);

        // get any removed adaptations in gEditRecord into the GUI list, if the restored
        // state is adapting mode; if glossing mode, get the removed glosses into the GUI
        // list
		bool bAllsWell;
		if (gbIsGlossing)
			bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
		else
			bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);

        // BEW added 10Jun09; do a recalc of the layout, set active pile pointer, and
        // scroll into view - otherwise these are not done and box can be off-window
		pLayout->RecalcLayout(pApp->m_pSourcePhrases,keep_strips_keep_piles);
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		pLayout->m_pCanvas->ScrollIntoView(pApp->m_nActiveSequNum);
		Invalidate();
		GetLayout()->PlaceBox();
	}
}

void CAdapt_ItView::ToggleFreeTranslationMode()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{

		CMainFrame* pFrame = pApp->GetMainFrame();
		wxASSERT(pFrame != NULL);
		wxMenuBar* pMenuBar = pApp->GetMainFrame()->GetMenuBar();
		wxASSERT(pMenuBar != NULL);
		wxMenuItem * pAdvancedFreeTranslation = 
							pMenuBar->FindItem(ID_ADVANCED_FREE_TRANSLATION_MODE);
		wxASSERT(pAdvancedFreeTranslation != NULL);
		gbSuppressSetup = FALSE; // setdefault value

        // determine if the document is unstructured or not -- we'll need this set or
        // cleared as appropriate because in free translation mode the user may elect to
        // end sections at verse breaks - and we can't do that for unstructured data (in
        // the latter case, we'll just end when there is following punctuation on a word or
        // phrase)
		SPList* pSrcPhrases = pApp->m_pSourcePhrases;
		gbIsUnstructuredData = IsUnstructuredData(pSrcPhrases);

		// toggle the setting
		if (pApp->m_bFreeTranslationMode)
		{
			// toggle the checkmark to OFF
			pAdvancedFreeTranslation->Check(FALSE);
			pApp->m_bFreeTranslationMode = FALSE;
		}
		else
		{
			// toggle the checkmark to ON
			pAdvancedFreeTranslation->Check(TRUE);
			pApp->m_bFreeTranslationMode = TRUE;
		}
		if (pApp->m_bFreeTranslationMode)
		{
            // put the target punctuation character set into gSpacelessTgtPunctuation to be
            // used in the HasWordFinalPunctuation() function to work out when to end a
            // span of free translation (can't put this after the ComposeBarGuts() call
            // because the latter calls SetupCurrentFreeTransSection(), and it needs
            // gSpacelessTgtPunctuation set up beforehand)
			gSpacelessTgtPunctuation = pApp->m_punctuation[1]; // target set, with 
															   // delimiting spaces
			gSpacelessTgtPunctuation.Replace(_T(" "),_T("")); // get rid of the spaces
		}	

        // restore focus to the targetBox, if free translation mode was just turned off,
        // else to the CEdit in the Compose Bar because it has just been turned on --
        // providing the box or bar is visible and its handle exists
		pFrame->ComposeBarGuts(); // open or close the Compose Bar

		if (pApp->m_bFreeTranslationMode)
		{
			// free translation mode was just turned on.

            // put the focus in the Compose Bar's edit box, and disable the phrase box for
            // clicks & editing, and make it able to right justify and render RTL if we are
            // in the Unicode app
			if (pFrame->m_pComposeBar != NULL)
				if (pFrame->m_pComposeBar->IsShown())
				{
					#ifdef _RTL_FLAGS
						// enable complex rendering
						if (pApp->m_bTgtRTL)
						{
							pFrame->m_pComposeBar->SetLayoutDirection(wxLayout_RightToLeft);
						}
						else
						{
							pFrame->m_pComposeBar->SetLayoutDirection(wxLayout_LeftToRight);
						}
					#endif
					pFrame->m_pComposeBar->SetFocus();
				}

			// prevent clicks and editing being done in phrase box (do also in CreateBox())
			if (pApp->m_pTargetBox->IsShown())
				pApp->m_pTargetBox->Enable(FALSE);
			pApp->GetMainFrame()->canvas->ScrollIntoView(
									pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber);

			// get any removed free translations in gEditRecord into the GUI list
			bool bAllsWell;
			bAllsWell = PopulateRemovalsComboBox(freeTranslationsStep, &gEditRecord);
		}
		else
		{
			// free translation mode was just turned off

			translation.Empty(); // don't preserve anything from a former adaptation state
			if (pApp->m_pTargetBox->IsShown())
			{
				pApp->m_pTargetBox->Enable(TRUE);
				pApp->m_pTargetBox->SetFocus();
			}

            // get any removed adaptations in gEditRecord into the GUI list,
            // if the restored state is adapting mode; if glossing mode, get
            // the removed glosses into the GUI list
			bool bAllsWell;
			if (gbIsGlossing)
				bAllsWell = PopulateRemovalsComboBox(glossesStep, &gEditRecord);
			else
				bAllsWell = PopulateRemovalsComboBox(adaptationsStep, &gEditRecord);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Free Translation Mode" item on the Advanced menu
/// is disabled if the active pile pointer is NULL, or the application is only showing the
/// target text, or there are no source phrases in the App's m_pSourcePhrases list. But, if
/// m_curIndex is within a valid range and the composeBar was not already opened for
/// another purpose (called from the View), the menu item is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedFreeTranslationMode(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
    // the !pApp->m_bComposeBarWasAskedForFromViewMenu test makes sure we don't try to
    // invoke free translation mode while the user already has the Compose Bar open for
    // another purpose
    if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && pApp->m_nActiveSequNum >= 0
		&& !pApp->m_bComposeBarWasAskedForFromViewMenu)
	{
		event.Enable(TRUE);
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::OnAdvancedTargetTextIsDefault(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem* pAdvancedMenuTTextDft = 
							pMenuBar->FindItem(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT);
	wxMenuItem* pAdvancedMenuGTextDft = 
							pMenuBar->FindItem(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT);
	wxASSERT(pAdvancedMenuTTextDft != NULL);
	wxASSERT(pAdvancedMenuGTextDft != NULL);

	// toggle the setting
	if (pApp->m_bTargetIsDefaultFreeTrans)
	{
		// toggle the checkmark to OFF
		pAdvancedMenuTTextDft->Check(FALSE);
		pApp->m_bTargetIsDefaultFreeTrans = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pAdvancedMenuTTextDft->Check(TRUE);
		pApp->m_bTargetIsDefaultFreeTrans = TRUE;

		// and ensure the glossing text command is off, and its flag cleared
		pAdvancedMenuGTextDft->Check(FALSE);
		pApp->m_bGlossIsDefaultFreeTrans = FALSE;
	}

	// restore focus to the Compose Bar
	if (pFrame->m_pComposeBar->GetHandle() != NULL)
		if (pFrame->m_pComposeBar->IsShown())
			pFrame->m_pComposeBarEditBox->SetFocus();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Use Target Text As Default Free Translation"
/// item on the Advanced menu is disabled if the application is not in Free Translation
/// mode, or if the active pile pointer is NULL, or if there are no source phrases in the
/// App's m_pSourcePhrases list. But, if m_curIndex is within a valid range and the
/// composeBar was not already opened for another purpose (called from the View), the menu
/// item is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedTargetTextIsDefault(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (!pApp->m_bFreeTranslationMode) // whm added 23Jan07 to wx version
	{
		// The Advanced menu item "Use Target Text As Default Free Translation"
		// should be disabled when the app is not in Free Translation Mode.
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
			pApp->m_nActiveSequNum >= 0 &&
			!pApp->m_bComposeBarWasAskedForFromViewMenu)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAdvancedGlossTextIsDefault(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem* pAdvancedMenuTTextDft = 
							pMenuBar->FindItem(ID_ADVANCED_TARGET_TEXT_IS_DEFAULT);
	wxMenuItem* pAdvancedMenuGTextDft = 
							pMenuBar->FindItem(ID_ADVANCED_GLOSS_TEXT_IS_DEFAULT);
	wxASSERT(pAdvancedMenuTTextDft != NULL);
	wxASSERT(pAdvancedMenuGTextDft != NULL);

	// toggle the setting
	if (pApp->m_bGlossIsDefaultFreeTrans)
	{
		// toggle the checkmark to OFF
		pAdvancedMenuGTextDft->Check(FALSE);
		pApp->m_bGlossIsDefaultFreeTrans = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pAdvancedMenuGTextDft->Check(TRUE);
		pApp->m_bGlossIsDefaultFreeTrans = TRUE;

		// ensure the target text command is toggled off (if it was on), and its flag
		pAdvancedMenuTTextDft->Check(FALSE);
		pApp->m_bTargetIsDefaultFreeTrans = FALSE;

	}

	// restore focus to the Compose Bar
	if (pFrame->m_pComposeBar->GetHandle() != NULL)
		if (pFrame->m_pComposeBar->IsShown())
			pFrame->m_pComposeBarEditBox->SetFocus();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Use Gloss Text As Default Free Translation" item
/// on the Advanced menu is disabled if the application is not in Free Translation mode, or
/// if the active pile pointer is NULL, or if there are no source phrases in the App's
/// m_pSourcePhrases list. But, if m_curIndex is within a valid range and the composeBar
/// was not already opened for another purpose (called from the View), the menu item is
/// enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedGlossTextIsDefault(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pSourcePhrases->GetCount() == 0)
	{
		event.Enable(FALSE);
		return;
	}
	if (!pApp->m_bFreeTranslationMode) // whm added 23Jan07 to wx version
	{
		// The Advanced menu item "Use Gloss Text As Default Free Translation"
		// should be disabled when the app is not in Free Translation Mode.
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum <= (int)pApp->GetMaxIndex() && 
			pApp->m_nActiveSequNum >= 0 &&
			!pApp->m_bComposeBarWasAskedForFromViewMenu)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnRadioDefineByPunctuation(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxPanel* pBar = pFrame->m_pComposeBar;
	wxASSERT(pBar != NULL);
	if(pBar != NULL && pBar->IsShown())
	{
		// FindWindow() finds a child of the current window
		wxRadioButton* pRPSButton = (wxRadioButton*)
								pBar->FindWindow(IDC_RADIO_PUNCT_SECTION);
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pRPSButton != 0)
		{
			// set the radio button's BOOL to be TRUE
			pApp->m_bDefineFreeTransByPunctuation = TRUE;
						
			// BEW added 1Oct08: to have the butten click remove the
			// current section and reconstitute it as a Verse-based section
			gbSuppressSetup = FALSE;
			wxCommandEvent evt;
			OnRemoveFreeTranslationButton(evt); // remove current section and 
                // any Compose bar edit box test;
                // the OnRemoveFreeTranslationButton() call calls Invalidate()
			
            // To get SetupCurrenetFreeTranslationSection() called, we must call
            // RecalcLayout() with gbSuppressSetup == FALSE, then the section will be
            // resized smaller
#ifdef _NEW_LAYOUT
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

			// restore focus to the edit box
			pEdit->SetFocus();
		}
	}
}

void CAdapt_ItView::OnRadioDefineByVerse(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pMainFrm = pApp->GetMainFrame();
	wxASSERT(pMainFrm != NULL);
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	wxASSERT(pBar != NULL);
	if(pBar != NULL && pBar->IsShown())
	{
		wxRadioButton* pRVSButton = (wxRadioButton*)
								pBar->FindWindow(IDC_RADIO_VERSE_SECTION);
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pRVSButton != 0)
		{
			// set the radio button's BOOL to be TRUE
			pApp->m_bDefineFreeTransByPunctuation = FALSE;
			
			// BEW added 1Oct08: to have the butten click remove the
			// current section and reconstitute it as a Verse-based section
			gbSuppressSetup = FALSE;
			wxCommandEvent evt;
			OnRemoveFreeTranslationButton(evt); // remove current section and 
				// any Compose bar edit box test
				// the OnRemoveFreeTranslationButton() call calls Invalidate()

            // To get SetupCurrentFreeTranslationSection() called, we must call
            // RecalcLayout() with gbSuppressSetup == FALSE, then the section will be
            // resized larger
#ifdef _NEW_LAYOUT
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
			GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

			// restore focus to the edit box
			pEdit->SetFocus();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return         nothing
///
///	\param     pPileArray	     ->	pointer to the array of piles which comprise the 
///                                 current section which is to have its free translation
///                                 stored as a filtered \free ... \free* marker section
///                                 within the m_markers member of the pSrcPhrase at the
///                                 anchor location (ie. at pFirstPile's sourcephrase)
///	\param     pFirstPile	     <-	pointer to the first pile in this free translation
///	                                section 
///	\param     pLastPile	     <-	pointer to the last pile in this free translation 
///	                                section
///	\param     editBoxContents   ->	enum value can be remove_editbox_contents or 
///	                                retain_editbox_contents. When remove_editbox_contents 
///                                 the source phrase's flags are adjusted and pPileArray
///                                 is emptied; otherwise (during mere editing stores) the
///                                 flags and pPileArray are not changed.
///	\param     storeStr		     ->	const ref string containing the free trans string to 
///	                                store in m_markers
/// \remarks
///    Gets the free translation text from the Compose Bar's edit box via the global
///    CString gFreeTranslationStr, constructs the bracketed filtered string and inserts it
///    in the m_markers member of the CSourcePhrase instance at the anchor pile, and
///    returns pointers to the first and last piles in the section so that the buttons
///    <Prev, Next> or Advance can obtain the jumping off place for the movement back or
///    forwards.
///    whm clarification: In the MFC version, StoreFreeTranslation got the free translation
///    text directly from the composebar's edit box, and not via the global CString
///    gFreeTranslationStr. The MFC version originally set the value of gFreeTranslationStr
///    here from what it found in the edit box, but with my revision StoreFreeTranslation()
///    always gets the string to be stored from the input parameter storeStr.
///	whm 23Aug06 added the last two parameters
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::StoreFreeTranslation(wxArrayPtrVoid* pPileArray,CPile*& pFirstPile,
	CPile*& pLastPile,enum EditBoxContents editBoxContents, const wxString& storeStr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pMainFrm = pApp->GetMainFrame();
	wxASSERT(pMainFrm);
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	wxASSERT(pBar);
	if (pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0 && pPileArray->GetCount() > 0) // whm added second condition 
			// 1Apr09 as wxMac gets here on frame size event and pPileArray has 0 items
		{
            // get the box's current contents & remove spaces at end or start (one will
            // be added by the InsertFilteredMaterial() call, at the end of the string,
            // automatically, if there is not already one at the end of the string)
			
            // whm changed 23Aug06. We now get the string to be stored as parameter to
            // StoreFreeTranslation we can probably get rid of the gFreeTranslationStr,
            // gnOffsetInMarkersStr, and gnLengthInMarkersStr globals, but I'll leave the
            // gFreeTranslationStr assignment here until that happens.
			wxString mkr = _T("\\free");
			wxString endMkr = _T("\\free*");
			pFirstPile = (CPile*)pPileArray->Item(0);
			// call GetExistingMarkerContent to get offset and length
			wxString tempStr = GetExistingMarkerContent(mkr,endMkr,
									pFirstPile->GetSrcPhrase(),
									gnOffsetInMarkersStr,gnLengthInMarkersStr);
			tempStr.Trim(FALSE); // trim left end 
			tempStr.Trim(TRUE); // trim right end

			// remove the earlier free translation text from m_markers, if there was any
			CPile* pPile;
			pPile = pFirstPile;
			wxString markers = pPile->GetSrcPhrase()->m_markers;
			if (!markers.IsEmpty())
			{
				// delete only the text, leave the markers there
				if (gnLengthInMarkersStr > 0)
				{
					markers.Remove(gnOffsetInMarkersStr,gnLengthInMarkersStr); 
					gnLengthInMarkersStr = 0;
					gnOffsetInMarkersStr = 0;
				}
			}

            // find the insertion point (this works, regardless of what may have happened
            // above) and update with the new content for the free translation
			int nFreeTransInsertionOffset = FindFilteredInsertionLocation(markers, mkr); 
			pPile->GetSrcPhrase()->m_markers = markers; // update with the prepared string
			wxASSERT(nFreeTransInsertionOffset >= 0); 
			bool bContainsFreeTrans = ContainsFreeTranslation(pPile); // TRUE if m_markers 
                // contains \free already 
                // whm revision: InsertFilteredMaterial now always uses storeStr instead of
                // gFreeTranslationStr. It also uses a local nFreeTransInsertionOffset
                // rather than the otherwise unused gnFreeTransInsertionOffset.
			InsertFilteredMaterial(mkr, endMkr, storeStr, pPile->GetSrcPhrase(),
									nFreeTransInsertionOffset, bContainsFreeTrans);

            // whm added 22Aug06 the test below to remove or retain the contents of the
            // composebar's edit box and the items in pPileArray. The contents of the edit
            // box is cleared if the enum is remove_editbox_contents. The test evaluates to
            // true when StoreFreeTranslation is called from OnNextButton(), OnPrevButton()
            // or OnAdvanceButton(). It is false when called from the ComposeBarEditBox's
            // OnEditBoxChanged() handler where StoreFreeTranslation is merely storing
            // real-time edits of the string.
			if (editBoxContents == remove_editbox_contents)
			{
				// mark this sourcephrase appropriately
				// whm note: The source phrase's flags only need updating when
				// StoreFreeTranslation is called from the view's free translation
				// navigation button handlers.
				pPile->GetSrcPhrase()->m_bHasFreeTrans = TRUE;
				pPile->GetSrcPhrase()->m_bStartFreeTrans = TRUE;
				pPile->GetSrcPhrase()->m_bEndFreeTrans = FALSE;

                // clear the compose bar's edit box too, otherwise default text at the next
                // location can't be composed even if wanted
				wxString tempStr;
				tempStr.Empty(); //FreeTranslationStr.Empty();
				// whm changed 24Aug06 - update edit box with updated string
				pEdit->ChangeValue(tempStr);
				pPileArray->RemoveAt(0); // first is dealt with

                // do a reality check on m_markers - I noticed that the test document had
                // sometimes an m_markers string ending with a SF marker, and no trailing
                // space. The space should be present - so if we detect this, we can do an
                // automatic silent correction now (I also do this when saving a note in OK
                // button's handler)
				int markersLen = pPile->GetSrcPhrase()->m_markers.Length();
				if (markersLen >= 2)
				{
					// at least a backslash and a single character should be present, 
					// otherwise don't bother
					if (pPile->GetSrcPhrase()->m_markers.GetChar(markersLen - 1) != _T(' '))
					{
						pPile->GetSrcPhrase()->m_markers += _T(' ');
					}
				}

                // if we are at the end of the document, our Adavance will not be fruitful,
                // so we'll just want to be able to automatically replace the phrase box
                // here - and beep to alert the user that the Advance failed.
				pFirstPile = pApp->m_pActivePile; // this should remain valid if we are 
												  // at doc end already
				// now handle the rest in the array
				int lastIndex = 0;
				pLastPile = pPile; // default
				int nSize = pPileArray->GetCount(); 

                // if nSize is now 0, then there was only the one pSrcPhrase in the
                // section, and so that one has to be given m_bEndFreeTrans = TRUE value
                // too
				if (nSize == 0)
				{
					pPile->GetSrcPhrase()->m_bEndFreeTrans = TRUE;
					return;
				}
                // if there is more than one pile pointer in the array, then there is at
                // least another one needing to be dealt with
				if (nSize > 0)
				{
					lastIndex = nSize - 1;
					pPile = (CPile*)(*pPileArray)[lastIndex];
					pLastPile = pPile; // we can step ahead from here, the last one, in the caller
					pPile->GetSrcPhrase()->m_bEndFreeTrans = TRUE;
					pPile->GetSrcPhrase()->m_bHasFreeTrans = TRUE;
					pPile->GetSrcPhrase()->m_bStartFreeTrans = FALSE;
					pPileArray->RemoveAt(lastIndex); // dealt with the last one
					nSize--;
				}
                // finally, any other pile pointers which are neither the first or last -
                // set the flags appropriately
				if (nSize > 0)
				{
					int index;
					CPile* ptrPile;
					for (index = 0; index < nSize; index++)
					{
						ptrPile = (CPile*)(*pPileArray)[index];
						ptrPile->GetSrcPhrase()->m_bEndFreeTrans = FALSE;
						ptrPile->GetSrcPhrase()->m_bStartFreeTrans = FALSE;
						ptrPile->GetSrcPhrase()->m_bHasFreeTrans = TRUE;
					}
					pPileArray->Clear();
				}
			} // end of if (editBoxContents == remove_editbox_contents)
		}
	}
}

// the following is based on StoreFreeTranslation() and OnPrevButton() but tweaked for use
// at the point in the vertical edit process where control is about to leave the
// freeTranslationsStep and so the current free translation needs to be made to 'stick'
void CAdapt_ItView::StoreFreeTranslationOnLeaving()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	if (pFrame->m_pComposeBar != NULL)
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)
							pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			CPile* pOldActivePile = pApp->m_pActivePile;

            // do this store unilaterally, as we can make the free translation 'stick' by
            // calling this function also in the OnAdvancedFreeTranslationMode() hander,
            // when leaving free translation mode & not in vertical edit process, as well
            // as when we are

			// do the save & pointer calculation in the StoreFreeTranslation() call
			if (gpCurFreeTransSectionPileArray->GetCount() > 0)
			{
				CPile* saveLastPilePtr = 
					(CPile*)gpCurFreeTransSectionPileArray->Item(
										gpCurFreeTransSectionPileArray->GetCount()-1);
				wxString editedText;
				editedText = pEdit->GetValue();
				StoreFreeTranslation(gpCurFreeTransSectionPileArray,pOldActivePile,
								saveLastPilePtr,remove_editbox_contents, editedText);
			}

			// make sure the kb entry flag is set correctly
			CSourcePhrase* pSrcPhr = pOldActivePile->GetSrcPhrase();
			FixKBEntryFlag(pSrcPhr);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return         nothing
///
///	\param pBundle	->	pointer to the current bundle
///
/// \remarks
///	Resets the m_bIsCurrentFreeTransSection member of CPile instances
///	through the whole bundle to FALSE. Use this prior, followed by
///	MarkFreeTranslationPilesForColoring(), when the current section changes
///	to a new location, so that colouring gets done correctly at the right places
/////////////////////////////////////////////////////////////////////////////////
//void CAdapt_ItView::MakeAllPilesNonCurrent(CSourceBundle* pBundle)
void CAdapt_ItView::MakeAllPilesNonCurrent(CLayout* pLayout)
{
	PileList* pList = pLayout->GetPileList();
	PileList::Node* pos = pList->GetFirst();
	CPile* pPile = NULL;
	while (pos != NULL)
	{
		pPile = pos->GetData();
		pPile->SetIsCurrentFreeTransSection(FALSE);
		pos = pos->GetNext();
	}
	// makes them ALL false
}


// handler for the IDC_APPLY_BUTTON, renamed Advance after first being called Apply
void CAdapt_ItView::OnAdvanceButton(wxCommandEvent& event)
{
    // BEW added 19Oct06; if the ENTER key is pressed when not in Free Translation mode and
    // focus is in the compose bar then it would invoke the OnAdvanceButton() handler even
    // though the button is hidden, so we prevent this by detecting when it happens and
    // exiting without doing anything.
	CAdapt_ItApp* pApp = &wxGetApp();
	if (pApp->m_bComposeBarWasAskedForFromViewMenu)
	{
        // compose bar is open, but not in Free Translation mode, so we must ignore an
        // ENTER keypress, and also return the focus to the compose bar's edit box
		CMainFrame *pFrame;
		pFrame = pApp->GetMainFrame();
		wxTextCtrl* pEdit;
		wxASSERT(pFrame != NULL); 
		wxASSERT(pFrame->m_pComposeBar != NULL);
		pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE); 
		wxASSERT(pEdit != NULL);
		wxString str;
		str = pEdit->GetValue();
		int len = str.Length();
		pEdit->SetFocus();
		pEdit->SetSelection(len,len); 
		return;
	}

    // In FT mode and if also in Review mode, the Advance button should not move the user a
    // long way ahead to an empty section, instead it should act like the phrase box does
    // in this mode, hence it instead invokes the handler for the Next> button, which makes
    // the immediate next section the current one
	if (!pApp->m_bDrafting)
	{
		OnNextButton(event);
		return;
	}

	// only do the following code when in Drafting mode
	gbSuppressSetup = FALSE; // restore default value, in case Shorten 
							 // or Lengthen buttons were used

	CMainFrame* pMainFrm = pApp->GetMainFrame();
	wxPanel* pBar = pMainFrm->m_pComposeBar; 
	if(pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			CPile* pOldActivePile = pApp->m_pActivePile;
			CPile* saveLastPilePtr = pApp->m_pActivePile; // a safe default

			// The current free translation was not just removed so do the 
			// StoreFreeTranslation() call
			if (gpCurFreeTransSectionPileArray->GetCount() > 0)
			{
                // whm added 24Aug06 passing of current edits to StoreFreeTranslation()
                // via the editedText parameter along with enum remove_editbox_contents
                // to maintain legacy behavior when called from this handler
				saveLastPilePtr =
					(CPile*)gpCurFreeTransSectionPileArray->Item(
										gpCurFreeTransSectionPileArray->GetCount()-1);
				if (!gbFreeTranslationJustRemovedInVFMdialog)
				{
					wxString editedText;
					editedText = pEdit->GetValue();
					StoreFreeTranslation(gpCurFreeTransSectionPileArray,
						pOldActivePile,saveLastPilePtr,remove_editbox_contents, editedText);
				}
			}

            // make sure the active location we are about to leave has the correct value
            // for m_bHasKBEntry (or m_bHasGlossingKBEntry if we are in glossing mode) set
			CSourcePhrase* pSrcPhr = pOldActivePile->GetSrcPhrase();
			FixKBEntryFlag(pSrcPhr);

			// get the next pile which does not have any free translation yet
			CPile* pPile = GetNextPile(saveLastPilePtr);

			if (pPile == NULL)
			{
				// we are probably at the end document so if so then leave this section
				// current, beep to warn the user
                if (saveLastPilePtr->GetSrcPhrase()->m_nSequNumber == pApp->GetMaxIndex())
				{
					::wxBell();

					if (gbVerticalEditInProgress)
					{
						// force transition to next step
						bool bCommandPosted;
						bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(
																	-1, nextStep, TRUE);
						// TRUE is bForceTransition
					}
					// make it 'stick' before returning
					StoreFreeTranslationOnLeaving();
					return;
				}
			}
			else
			{
                // not a null pile pointer, so loop until we come to a section
                // which is not free translated
				while( pPile->GetSrcPhrase()->m_bHasFreeTrans)
				{
					CPile* pLastPile = pPile;
					pPile = GetNextPile(pPile);
					if (gbVerticalEditInProgress && pPile != NULL)
					{
						int sn = pPile->GetSrcPhrase()->m_nSequNumber;
						bool bCommandPosted = 
							VerticalEdit_CheckForEndRequiringTransition(sn, nextStep);
														// FALSE is bForceTransition
						if (bCommandPosted)
							return;
					}
					if (pPile == NULL)
					{
						// we are at the end of the doc
						if (pLastPile->GetSrcPhrase()->m_nSequNumber == 
							pApp->GetMaxIndex())
						{
							// at end of doc
							if (gbVerticalEditInProgress)
							{
								// force transition to next step
								bool bCommandPosted;
								bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(
																		-1, nextStep, TRUE);
																// TRUE is bForceTransition
							}
							// make it 'stick' before returning
							StoreFreeTranslationOnLeaving();
							return;
						}
					}
					else
					{
						// the pile is good, so iterate to test it
						;
					}
				} // end of while loop's block
			} // end of block for a non-NULL pPile
			if (gbVerticalEditInProgress && pPile != NULL)
			{
				int sn = pPile->GetSrcPhrase()->m_nSequNumber;
				bool bCommandPosted = 
					VerticalEdit_CheckForEndRequiringTransition(sn, nextStep);
												// FALSE is bForceTransition
				if (bCommandPosted)
					return;
			}
			pApp->m_pActivePile = pPile;
			pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber;
			gbSuppressSetup = FALSE; // make sure it is off

			// make m_bIsCurrentFreeTransSection FALSE on every pile
			MakeAllPilesNonCurrent(GetLayout());

			// place the phrase box at the next anchor location
			CCell* pCell = pPile->GetCell(1); // whatever is the phrase box's 
											  // line in the strip
			if (gbIsGlossing)
			{
				translation = pCell->GetPile()->GetSrcPhrase()->m_gloss;
			}
			else
			{
				translation = pCell->GetPile()->GetSrcPhrase()->m_adaption;
			}
			int selector = 1; // this selector inhibits both intial and final code
							  // blocks (ie. no save to KB and no removal from KB 
							  // at the new location)
			PlacePhraseBox(pCell,selector);

			// make sure we can see the phrase box
			pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);
			Invalidate();
			GetLayout()->PlaceBox();
			pEdit->SetFocus(); // put focus back into compose bar's text control
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update Idle
///                        mechanism 
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the Free Translation navigation
/// buttons are visible. The "Next >" button used for navigation in free translation mode
/// is disabled if the application is not in Free Translation mode, or if the active pile
/// pointer is NULL, or if the active sequence number is negative (-1), otherwise the
/// button is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateNextButton(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (!pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum < 0 || pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	event.Enable(TRUE);
}

void CAdapt_ItView::OnNextButton(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	gbSuppressSetup = FALSE; // restore default value, in case Shorten or 
							 // Lengthen buttons were used
	// for debugging
	//int ftStartSN = gEditRecord.nFreeTranslationStep_StartingSequNum;
	//int ftEndSN = gEditRecord.nFreeTranslationStep_EndingSequNum;

	CMainFrame* pMainFrm = pApp->GetMainFrame(); 
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	if(pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			CPile* pOldActivePile = pApp->m_pActivePile;
			CPile* saveLastPilePtr = pApp->m_pActivePile; // a safe default initialization

			// The current free translation was not just removed so do the 
			// StoreFreeTranslation() call
			if (gpCurFreeTransSectionPileArray->GetCount() > 0)
			{
                // whm added 24Aug06 passing of current edits to StoreFreeTranslation() via
                // the editedText parameter along with enum remove_editbox_contents to
                // maintain legacy behavior when called from this handler
				saveLastPilePtr = (CPile*)gpCurFreeTransSectionPileArray->Item(
										gpCurFreeTransSectionPileArray->GetCount()-1);
				if (!gbFreeTranslationJustRemovedInVFMdialog)
				{
					wxString editedText;
					editedText = pEdit->GetValue();
					StoreFreeTranslation(gpCurFreeTransSectionPileArray, pOldActivePile,
						saveLastPilePtr, remove_editbox_contents, editedText);
				}
			}
			// make sure the kb entry flag is set correctly
			CSourcePhrase* pSrcPhr = pOldActivePile->GetSrcPhrase();
			FixKBEntryFlag(pSrcPhr);

			// get the next pile
			CPile* pPile = GetNextPile(saveLastPilePtr);

            // check out pPile == NULL, we would then be at the doc end - fix things
            // according; if not null, then the next pile is within the document and we can
            // set it up as the active location & new anchor point - or it will be the
            // start of a predefined free translation section in which case it is already
            // the anchor point for the next free translation section
			if (pPile == NULL)
			{
                // The scroll position is at the end of the document
				if (saveLastPilePtr->GetSrcPhrase()->m_nSequNumber == pApp->GetMaxIndex())
				{
                    // we are at the end of the doc. So leave this section current, and
                    // beep to tell the user
                    ::wxBell();

					// BEW added 11Sep08 for support of vertical editing
					if (gbVerticalEditInProgress)
					{
						// force transition to next step
						bool bCommandPosted;
						bCommandPosted = VerticalEdit_CheckForEndRequiringTransition(
																	-1, nextStep, TRUE);
															// TRUE is bForceTransition
						return;
					}
					// make it 'stick' before returning
					StoreFreeTranslationOnLeaving();
					return;
				}
			}
			// the pPile pointer is not NULL, so continue processing
			if (gbVerticalEditInProgress)
			{
				int sn = pPile->GetSrcPhrase()->m_nSequNumber;
				bool bCommandPosted = 
					VerticalEdit_CheckForEndRequiringTransition(sn, nextStep);
												// FALSE is bForceTransition
				if (bCommandPosted)
					return; // we've reached gray text, so step transition is wanted
			}

			pApp->m_pActivePile = pPile;
			pApp->m_nActiveSequNum = pPile->GetSrcPhrase()->m_nSequNumber;

			// make m_bIsCurrentFreeTransSection FALSE on every pile
			MakeAllPilesNonCurrent(GetLayout());

			// place the phrase box at the next anchor location
			CCell* pCell = pPile->GetCell(1); // whatever is the phrase box's 
											  // line in the strip
			if (gbIsGlossing)
			{
				translation = pCell->GetPile()->GetSrcPhrase()->m_gloss;
			}
			else
			{
				translation = pCell->GetPile()->GetSrcPhrase()->m_adaption;
			}
			int selector = 1; // this selector inhibits both intial and final code blocks 
						// (ie. no save to KB and no removal from KB at the new location)
			PlacePhraseBox(pCell,selector); // forces RecalcLayout(), which gets
											// SetupCurrentFreeTransSection() called

			// make sure we can see the phrase box
			pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);
			Invalidate(); // gets the view redrawn & phrase box shown
			GetLayout()->PlaceBox();
			pEdit->SetFocus(); // put focus back into the compose bar's edit control

			// if there is text in the pEdit box, put the cursor after it
			wxString editedText;
			editedText = pEdit->GetValue();
			int len = editedText.Length(); 
			if (len > 0)
				pEdit->SetSelection(len,len); 
			else
				pEdit->SetSelection(-1,-1); // -1,-1 selects all in wx
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update Idle 
///                        mechanism
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the Free Translation navigation buttons
/// are visible. The "< Prev" button used for navigation in free translation mode is
/// disabled if the application is not in Free Translation mode, or if the active pile
/// pointer is NULL, or if the active sequence number is negative (-1), or if the pile
/// previous to the active pile is NULL, otherwise the button is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdatePrevButton(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (!pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum < 0 || pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	CPile* pPile = GetPrevPile(pApp->m_pActivePile);
	if (pPile == NULL)
	{
		// probably we are at the start of the document
		event.Enable(FALSE);
	}
	else
		event.Enable(TRUE);
}

// whm revised 24Aug06 to allow Prev button to move back to the previous actual or
// potential free translation segment in the text
void CAdapt_ItView::OnPrevButton(wxCommandEvent& WXUNUSED(event))
{
	gbSuppressSetup = FALSE; // restore default value, in case Shorten 
							 // or Lengthen buttons were used
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pMainFrm = pApp->GetMainFrame();
	wxPanel* pBar = pMainFrm->m_pComposeBar; 
	if(pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
			CPile* pOldActivePile = pApp->m_pActivePile;

            // do not do StoreFreeTranslation() call if the current free translation was
            // just deleted by operator pressing on the Delete button (either in View
            // Filtered Material dialog or using the composebar button for that purpose
			if (!gbFreeTranslationJustRemovedInVFMdialog)
			{
				// do the save & pointer calculation in the StoreFreeTranslation() call
				if (gpCurFreeTransSectionPileArray->GetCount() > 0)
				{
                    // whm added 24Aug06 passing of current edits to StoreFreeTranslation()
                    // via the editedText parameter along with enum remove_editbox_contents
                    // to maintain legacy behavior when called from this handler
					CPile* saveLastPilePtr;
					saveLastPilePtr =
						(CPile*)gpCurFreeTransSectionPileArray->Item(
										gpCurFreeTransSectionPileArray->GetCount()-1);
					wxString editedText;
					editedText = pEdit->GetValue();
					StoreFreeTranslation(gpCurFreeTransSectionPileArray,
										pOldActivePile,saveLastPilePtr,
						remove_editbox_contents, editedText);
				}
			}

			// make sure the kb entry flag is set correctly
			CSourcePhrase* pSrcPhr = pOldActivePile->GetSrcPhrase();
			FixKBEntryFlag(pSrcPhr);

			CPile* pPile = pOldActivePile;
            // The Prev button should not be activated if the active pile is already at the
            // beginning of the document. However, for safety sake, I'll check to prevent
            // this handler doing anything if we get called from the beginning of the
            // document.
			if (pPile->GetSrcPhrase()->m_nSequNumber == 0)
			{
                // we are at the beginning of the doc and cannot go to any previous free
                // trans segment, so beep and return;
				::wxBell();
				return;
			}
            // At this point there should be at least one pile before pPile to compose a
            // free translation segment. We call GetPrevPile once to start examining the
            // pile immediately before the current one (i.e., which potentially is the last
            // pile of a free translation segment before the current segment we're
            // leaving). The current pile is always assigned to pPile.
            // Then, as we scan through piles toward the beginning of the document, we
            // examine the attributes of pPile and the attributes of its previous pile
            // pPrevPile looking for a halting point for the beginning of a free
            // translation segment.
			CPile* pPrevPile = NULL;
			pPrevPile = GetPrevPile(pPile);
			wxASSERT(pPrevPile != NULL);
			if (gbVerticalEditInProgress)
			{
				int sn = pPrevPile->GetSrcPhrase()->m_nSequNumber;
				if (sn < gEditRecord.nFreeTranslationStep_StartingSequNum ||
					sn > gEditRecord.nFreeTranslationStep_EndingSequNum)
				{
					// IDS_CLICK_IN_GRAY_ILLEGAL
					wxMessageBox(_(
"Attempting to put the active location within the gray text area while updating information in Vertical Edit mode is illegal. The attempt has been ignored."),
					_T(""), wxICON_WARNING);
					return;
				}
			}


            // If the last pile before the current free trans segment (i.e., now pPrevPile)
            // is the last pile of a previously adjoining free translation segment, we want
            // to scan back to the first pile of that existing segment (regardless of any
            // potential intervening halting points)
			if (pPrevPile->GetSrcPhrase()->m_bEndFreeTrans)
			{
                // the previous pile is already within an existing free translation
                // segment. In this situation we need to scan back to find the beginning
                // pile of that existing segment.
				while (pPrevPile != NULL)
				{
					pPile = GetPrevPile(pPrevPile);
                    // Check out if this pPile == NULL, we could be at the bundle start or
                    // the doc start. Handle things according to whichever is the case.
					if (pPile == NULL)
					{
                        // we are at the start of the doc, leave this section current
                        // (with phrasebox at pPrevPile) and return. The Prev button
                        // gets disabled once we get here, so this block will only get
                        // entered when the Prev button first gets us back to the
                        // beginning of the document. No bell sound is needed here.
						wxASSERT(pPrevPile->GetSrcPhrase()->m_nSequNumber == 0);

						if (gbVerticalEditInProgress)
						{
							// force transition to next step
							bool bCommandPosted;
							bCommandPosted = 
								VerticalEdit_CheckForEndRequiringTransition(
															-1, nextStep, TRUE);
													// TRUE is bForceTransition
							if (bCommandPosted)
							{
								// make it 'stick' before returning
								StoreFreeTranslationOnLeaving();
								return;
							}
						}

						CCell* pCell = pPrevPile->GetCell(1);
						int selector = 1;
						PlacePhraseBox(pCell,selector);
						// make sure we can see the phrasebox at the beginning of the doc
						pApp->GetMainFrame()->canvas->ScrollIntoView(
											pPrevPile->GetSrcPhrase()->m_nSequNumber);
						Invalidate();
						GetLayout()->PlaceBox();
						pEdit->SetFocus(); // put focus back into 
										   // compose bar's edit control
						return;
					}
                    // Criteria for halting scanning and establishing the anchor for a free
                    // translation segment: If the source pharase at pPile is already the
                    // start of a free translation (m_bStartFreeTrans). We can ignore
                    // checking for other halting conditions here.
					if (pPrevPile->GetSrcPhrase()->m_bStartFreeTrans)
					{
						break;
					}
					pPrevPile = pPile;
				} // end of loop for test: while (pPrevPile not NULL)
			}
			else
			{
                // the previous pile is not already within an existing free translation
                // segment (i.e., it is part of a hole). This is a situation in which we
                // need to examine halting criteria to determine the halting point.
				while (pPrevPile != NULL)
				{
					pPile = GetPrevPile(pPrevPile);
                    // if this pPile is NULL, we are at the doc's start.
					if (pPile == NULL)
					{
                        // we are at the start of the doc, leave this section current
                        // (with phrasebox at pPrevPile) and return. The Prev button
                        // gets disabled once we get here, so this block will only get
                        // entered when the Prev button first gets us back to the
                        // beginning of the document. No bell sound is needed here.
						wxASSERT(pPrevPile->GetSrcPhrase()->m_nSequNumber == 0);

						if (gbVerticalEditInProgress)
						{
							// force transition to next step
							bool bCommandPosted;
							bCommandPosted = 
								VerticalEdit_CheckForEndRequiringTransition(
															-1, nextStep, TRUE);
													// TRUE is bForceTransition
							if (bCommandPosted)
							{
								// make it 'stick' before returning
								StoreFreeTranslationOnLeaving();
								return;
							}
						}

						CCell* pCell = pPrevPile->GetCell(1);
						int selector = 1;
						PlacePhraseBox(pCell,selector);
						// make sure we can see the phrasebox at the beginning of the doc
						pApp->GetMainFrame()->canvas->ScrollIntoView(
											pPrevPile->GetSrcPhrase()->m_nSequNumber);
						Invalidate();
						GetLayout()->PlaceBox();
						pEdit->SetFocus(); // put focus back into the 
										   // compose bar's edit control
						return;
					}
					// Criteria for halting scanning and establishing the anchor for a 
					// free translation segment:
                    // (Note: These are the same criteria used by
                    // SetupCurrentFreeTransSection()) 
                    // Unconditionally halt scanning, if we
                    // encounter:
					//   1. An SF marker significant enough for us to consider that a 
					//     logical break in content starts at pPrevPile 
					//     (IsFreeTranslationEndDueToMarker also returns TRUE if a 
					//     filtered section starts there);
					//   2. If the source phrase at pPile is already the start of a 
					//     free translation (m_bStartFreeTrans).
                    // The additional conditions for halting scanning depend if we
                    // encounter the following halting criteria within a pile already
                    // marked for free translation or not already marked for free
                    // translation.
					// If we have unstructured data or if m_bDefineFreeTransByPunctuation, 
					//      halt scanning back if HasWordFinalPunctuation() returns TRUE, 
					//      unless the pile is within an existing free translation 
					//      segment, and that pile is not the first pile of the existing
					//      free translation (in which case we want to continue scanning 
					//      back until we reach the first pile of the existing segment).
					// If m_bDefineFreeTransByPunctuation is FALSE, we halt scanning if 
                    //     the source phrase at pPrevPile marks the beginning of a new
                    //     verse (m_bVerse), unless the pile is within an existing free
                    //     translation segment, and that pile is not the first pile of the
                    //     existing free translation (here also we want to continue
                    //     scanning back until we reach the first pile of the existing
                    //     segment - this might not happen often but some verses begin in
                    //     strange places!).
					// or, if the source phrase at pPrevPile marks a change of text type 
                    //     (m_bFirstOfType), unless, like the other criteria above, an
                    //     existing free translation somehow managed to span a text type
                    //     boundary, in which case we would continue scanning back until we
                    //     found the first pile of that existing free translation.
					
					if (IsFreeTranslationEndDueToMarker(pPrevPile))
					{
						break;
					}
					if (pPrevPile->GetSrcPhrase()->m_bStartFreeTrans)
					{
						break;
					}
					// Check if pPile is the (potential) last pile of a previous free 
					// trans section according to user's choice of verse or punctuation 
					// criteria.
					CSourcePhrase* pPrevSrcPhrase = pPile->GetSrcPhrase();
					wxASSERT(pPrevSrcPhrase != NULL);
					if (gbIsUnstructuredData || pApp->m_bDefineFreeTransByPunctuation)
					{
						// the verse option is not available if the data has no SF markers
						if (HasWordFinalPunctuation(pPrevSrcPhrase,
									pPrevSrcPhrase->m_targetStr,gSpacelessTgtPunctuation))
						{
                            // there is word-final punctuation on the previous pile's
                            // source phrase, so the current pile is a suitable place to
                            // begin this section
							break;
						}
					}
					else if (pPrevPile->GetSrcPhrase()->m_bVerse || 
												pPrevPile->GetSrcPhrase()->m_bFirstOfType)
					{
						break;
					}
                    // If we get here, we've not found an actual or potential anchor point
                    // based on inspecting the current pile nor the last pile
                    // (pOldActivePile), so save the current pile in pPrevPile, and get
                    // another preceding pile and examine it to see if it has criteria for
                    // establishing the beginning of a free translation segment.
					pPrevPile = pPile;
				}
			}

			wxASSERT(pPrevPile != NULL);
			if (gbVerticalEditInProgress)
			{
				// possibly force transition to next step
				bool bCommandPosted;
				bCommandPosted = 
					VerticalEdit_CheckForEndRequiringTransition(
												-1, nextStep, TRUE);
				// TRUE is bForceTransition
				if (bCommandPosted)
				{
					// make it 'stick' before returning
					StoreFreeTranslationOnLeaving();
					return;
				}
			}

			pApp->m_pActivePile = pPrevPile;
			pApp->m_nActiveSequNum = pPrevPile->GetSrcPhrase()->m_nSequNumber;

			// make m_bIsCurrentFreeTransSection FALSE on every pile
			MakeAllPilesNonCurrent(GetLayout());

			// place the phrase box at the next anchor location
			CCell* pCell = pPrevPile->GetCell(1);
			if (gbIsGlossing)
			{
				translation = pCell->GetPile()->GetSrcPhrase()->m_gloss;
			}
			else 
			{
				translation = pCell->GetPile()->GetSrcPhrase()->m_adaption;
			}
			int selector = 1; // this selector inhibits both intial and final code blocks
                              // (ie. no save to KB and no removal from KB at the new
                              // location)
			PlacePhraseBox(pCell,selector); // forces a a RecalcLayout(), which gets 
											// SetupCurrentFreeTransSection() called
			// make sure we can see the phrase box
			pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

			Invalidate(); // gets the view redrawn
			GetLayout()->PlaceBox();
			pEdit->SetFocus(); // put focus back into compose bar's edit control

			// if there is text in the pEdit box, put the cursor after it
			wxString editStr;
			editStr = pEdit->GetValue();
			int len = editStr.Length();
			if (len > 0)
				pEdit->SetSelection(len,len);
			else
				pEdit->SetSelection(-1,-1); // -1,-1 selection entire text;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return	nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update 
///                        Idle mechanism
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the Free Translation navigation buttons
/// are visible. The "Remove" button used in free translation mode is disabled if the
/// application is not in Free Translation mode, or if the active pile pointer is NULL, or
/// if the active sequence number is negative (-1), or if the active pile does not own the
/// free translation, otherwise the button is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateRemoveFreeTranslationButton(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	bool bOwnsFreeTranslation;
	if (!pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum < 0 || pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	bOwnsFreeTranslation = IsFreeTranslationSrcPhrase(pApp->m_pActivePile);
	if (!bOwnsFreeTranslation)
	{
		event.Enable(FALSE);
	}
	else
	{
		event.Enable(TRUE); // it's a defined section, so we can remove it
	}
}

void CAdapt_ItView::OnRemoveFreeTranslationButton(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pMainFrm = pApp->GetMainFrame(); 
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	if (pBar != NULL && pBar->IsShown())
	{
		wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
		if (pEdit != 0)
		{
            // BEW added 29Apr06, to inform a subsequent <Prev, Next> or Advance button
            // click that the free translation at the current section has been removed, so
            // that those buttons will not insert a filtered pair of \free \free* markers
            // with no content at the current location when the one of those three buttons'
            // handler is invoked
			gbFreeTranslationJustRemovedInVFMdialog = TRUE;

			// get the anchor pSrcPhrase
			CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();

			// make sure the kb entry flag is set correctly
			FixKBEntryFlag(pSrcPhrase);

			// the next part of the code aims to remove the
			// "\~FILTER \free <free trans text> \free* \~FILTER* " string from m_markers
			wxString theMkr = _T("\\free");
			wxString theEndMkr = _T("\\free*");
			// whm 24Aug06 modified below
			wxString tempStr = GetExistingMarkerContent(theMkr, theEndMkr, pSrcPhrase,
											gnOffsetInMarkersStr, gnLengthInMarkersStr);
            // BEW added 1Oct08; for supporting the use of this function to clear the
            // current free translation section when the user changes the section extent by
            // clicking Punctuation or Verse radio button (typically there may not yet by
            // any filtered free translation in pSrcPhrase yet, so we check for that and
            // skip the stuff below which assumes a free translation is present
			if (!(gnOffsetInMarkersStr == 0 && gnLengthInMarkersStr == 0 && 
				tempStr.IsEmpty()))
			{
                // the above call gives us gnOffsetInMarkersStr (start of the free trans
                // text) and gnLengthInMarkersStr (its length, including the trailing
                // space), so we have to get pointers, starting from these locations, to
                // the preceding and following filter bracket markers
				wxString markersStr = pSrcPhrase->m_markers;
				int totalLen = markersStr.Length();
                // start by looking for the preceding \~FILTER marker, we'll iterate a
                // pointer backwards until we find \~FILTER
				wxString fltrMkr = filterMkr;
				int fmkrLen = fltrMkr.Length();
                // wx version note: Since we require a read-only buffer we use GetData
                // which just returns a const wxChar* to the data in the string.
				const wxChar* pBuff = markersStr.GetData();
				wxChar* pBufStart = (wxChar*)pBuff;
				wxChar* pEnd;
				pEnd = pBufStart + totalLen;
				wxASSERT(*pEnd == _T('\0'));
				wxChar* ptr = pBufStart + gnOffsetInMarkersStr; // point to start of the 
														// free translation text itself
				--ptr;
				while ((wxStrncmp(ptr,filterMkr,fmkrLen) != 0) && ptr > pBufStart)
				{
					--ptr;
				}
				int nStartingOffset = (int)(ptr - pBufStart);
				wxASSERT(nStartingOffset >= 0);
				wxASSERT( gnOffsetInMarkersStr + gnLengthInMarkersStr < totalLen);
				int nFound = FindFromPos(markersStr,filterMkrEnd,
										gnOffsetInMarkersStr + gnLengthInMarkersStr);
				// it must be present further along, after the \free* endmarker of 
				// length 6 & trailing space
				wxASSERT(nFound > gnOffsetInMarkersStr + gnLengthInMarkersStr + 6);
				// the final offset is nFound plus the length of \~FILTER* plus 1 for 
				// its trailing space
				nFound += fmkrLen + 2; // 2 because we are counting the * and then 
									   // the following space

				// delete this text material from the m_markers string
				markersStr.Remove(nStartingOffset,nFound - nStartingOffset); 
				pSrcPhrase->m_markers = markersStr;
			}
			// update the navigation text
			pSrcPhrase->m_inform = GetDocument()->RedoNavigationText(pSrcPhrase);

			// clear the Compose Bar's edit box
			// whm 24Aug06 modified below
			tempStr.Empty();
			pEdit->ChangeValue(tempStr);

            // clear the bool members on the source phrases in the array, but leave the
            // array elements themselves since they correctly define this section's extent
            // at the time the button was pressed
			int nSize = (int)gpCurFreeTransSectionPileArray->GetCount();
			CPile* pPile;
			int index;
			for (index = 0; index < nSize; index++)
			{
				pPile = (CPile*)gpCurFreeTransSectionPileArray->Item(index);
				wxASSERT(pPile);
				pPile->GetSrcPhrase()->m_bStartFreeTrans = FALSE;
				pPile->GetSrcPhrase()->m_bHasFreeTrans = FALSE;
				pPile->GetSrcPhrase()->m_bEndFreeTrans = FALSE;
			}
			Invalidate(); // cause redraw, and so a call to SetupCurrentFreeTransSection()
			GetLayout()->PlaceBox();
			pEdit->SetFocus(); // put focus in compose bar's edit control
			pEdit->SetSelection(-1,-1); // -1,-1 selects all in wx
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update Idle 
///                        mechanism
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the free translation navigation buttons
/// are visible. The "Lengthen" button used in free translation mode is disabled if the
/// application is not in Free Translation mode, or if the active pile pointer is NULL, or
/// if the active sequence number is negative (-1). But the button is enabled if it won't
/// extend the next free translation segment past the end of a bundle or the doc, and if it
/// won't extend beyond some significant marker, or encroach on an already defined free
/// translation.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateLengthenButton(wxUpdateUIEvent& event)
{
	//bool bOwnsFreeTranslation;
	CAdapt_ItApp* pApp = &wxGetApp();
	if (!pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum < 0 || pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
    // BEW addition 11Sep08; in vertical editing mode, this is called when
    // freeTranslationStep is initialized at a former free translation section which
    // has been cleared, and so the pile array is empty; GetAt() calls then fail and
    // crash the app, so we won't allow lengthening if there is no array defined yet
	if (gpCurFreeTransSectionPileArray->IsEmpty()) // && !IsFreeTranslationSrcPhrase(m_pActivePile))
	{
		event.Enable(FALSE);
		return;
	}
	int end = (int)gpCurFreeTransSectionPileArray->GetCount() - 1;
	CPile* pPile = (CPile*)gpCurFreeTransSectionPileArray->Item(end);
	wxASSERT(pPile);
	pPile = GetNextPile(pPile); // get the pile immediately after the current end
	if (pPile == NULL)
	{
		// if at the end of bundle or doc, disable the button
		event.Enable(FALSE);
		return;
	}
	else
	{
        // whm observation: Here we only restrict the lengthening of the free trans
        // segment if the next pile contains a significant sfm; but, if it contains
        // punctuation that initially established the length of the segment, we allow
        // the user to lengthen beyond that punctuation, but we never allow lengthening
        // past the start of an existing free translation.
		if (IsFreeTranslationEndDueToMarker(pPile))
		{
            // markers or filtered stuff must end the section (for example, we can't
            // allow the possibility of unfiltering producing new content within a free
            // translation section)
			event.Enable(FALSE);
			return;
		}
		// also, we can't lengthen if there is a defined section following
		if (pPile->GetSrcPhrase()->m_bStartFreeTrans)
			event.Enable(FALSE);
		else
			event.Enable(TRUE); // but we can lengthen provided it is extending the 
                            // section into an undefined free translation area and none
                            // of the above end-conditions applies
	}
}

void CAdapt_ItView::OnLengthenButton(wxCommandEvent& WXUNUSED(event))
{
	gbSuppressSetup = TRUE; // prevent SetupCurrentFreeTransSection() from wiping
            // out the action done below at the time that the view is updated (which
            // otherwise would call that function)
	bool bEditBoxHasText = FALSE; // default
	// whm 24Aug06 reordered and modified below
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pMainFrm = pApp->GetMainFrame(); 
	wxPanel* pBar = pMainFrm->m_pComposeBar; 
	wxASSERT(pBar != NULL);
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
	wxASSERT(pEdit != NULL);
	wxString tempStr;
	tempStr = pEdit->GetValue();

	if (!tempStr.IsEmpty()) 
		bEditBoxHasText = TRUE;
	// & we can rely on m_nActiveSequNum having being set correctly, 
	// and also pApp->m_pActivePile;

	if(pBar != NULL && pBar->IsShown())
	{
		if (pEdit != 0)
		{
			CPile* pPile;
			int end = (int)gpCurFreeTransSectionPileArray->GetCount() - 1;
			pPile = (CPile*)gpCurFreeTransSectionPileArray->Item(end); // pile at end 
                // of current section the OnUpdateLengthenButton() handler will have
                // already disabled the button if there is no next pile in the bundle, so
                // we can procede with confidence
			pPile = GetNextPile(pPile);
			wxASSERT(pPile != NULL);
			pPile->SetIsCurrentFreeTransSection(TRUE); // this will make it's background 
													   // go light pink
			gpCurFreeTransSectionPileArray->Add(pPile); // add it to the array

            // if there is text in the Compose Bar's edit box (ie. gFreeTranslationStr is
            // not empty) then we'll lengthen without making any change to it; but if there
            // is no text, then will either leave the box empty or put in default text
            // contructed from the new current (shorter) section, according to whatever the
            // relevant flag setting currently is
			if (!bEditBoxHasText)
			{
				if (pApp->m_bTargetIsDefaultFreeTrans || pApp->m_bGlossIsDefaultFreeTrans)
				{
					// do the composition from the section's target text
					tempStr = ComposeDefaultFreeTranslation(
														gpCurFreeTransSectionPileArray);
					pEdit->ChangeValue(tempStr); // show it in the ComposeBar's edit box
				}
			}

			// colour the current section & select the text
			MarkFreeTranslationPilesForColoring(gpCurFreeTransSectionPileArray);
			pEdit->SetFocus();
			pEdit->SetSelection(-1,-1); //-1,-1 selects all in wx

			// get the window updated
			Invalidate();
			GetLayout()->PlaceBox();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the Update Idle
///                        mechanism 
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the free translation navigation buttons
/// are visible. The "Shorten" button used in free translation mode is disabled if the
/// application is not in Free Translation mode, or if the active pile pointer is NULL, or
/// if the active sequence number is negative (-1). But the button is enabled as long as
/// there is at least one pile left.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateShortenButton(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (!pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_nActiveSequNum < 0 || pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	// BEW changed 06Mar06, so user can shorten to a single pile
	int nSize = (int)gpCurFreeTransSectionPileArray->GetCount();
    // BEW changed 15Oct05, because we want to allow the user to shorten to less than 5
    // piles when he really wants too - such as when there are 4 piles, each a merger, and
    // so the automatic sectioning gets lots of extra piles too - in such a circumstance
    // the user may want to shorten to just get the first four piles.
	if (nSize <= 1)
		event.Enable(FALSE);
	else
		event.Enable(TRUE);
}

void CAdapt_ItView::OnShortenButton(wxCommandEvent& WXUNUSED(event))
{
	gbSuppressSetup = TRUE; // prevent SetupCurrentFreeTransSection() from 
            // wiping out the action done below at the time that the view is
            // updated (which otherwise would call that function)
	bool bEditBoxHasText = FALSE; // default
	CAdapt_ItApp* pApp = &wxGetApp();
	// whm 24Aug06 reordered and modified below
	CMainFrame* pMainFrm = pApp->GetMainFrame();
	wxPanel* pBar = pMainFrm->m_pComposeBar;
	wxASSERT(pBar != NULL);
	wxTextCtrl* pEdit = (wxTextCtrl*)pBar->FindWindow(IDC_EDIT_COMPOSE);
	wxASSERT(pEdit != NULL);
	wxString tempStr;
	tempStr = pEdit->GetValue();

	if (!tempStr.IsEmpty())
		bEditBoxHasText = TRUE;
    // & we can rely on m_nActiveSequNum having being set correctly, and also
    // pApp->m_pActivePile; and the button will only be enabled if this is a section not
    // previously defined ( we want to make it hard for the user to open up an un-free
    // tranlated section gap in the sequence of free translations)

	if (pBar != NULL && pBar->IsShown())
	{
		if (pEdit != 0)
		{
			int end = (int)gpCurFreeTransSectionPileArray->GetCount() - 1;
			if (end >= 1) // BEW changed 06Mar06 to allow user 
						  // to shorten to one pile only
			{
				// remove the last pile from the array after making sure
				// it is no longer regarded as within the current section
				CPile* pPile = (CPile*)gpCurFreeTransSectionPileArray->Item(end);
				pPile->SetIsCurrentFreeTransSection(FALSE); // this will mean 
										// the cell background will go white
                // whm corrected by addition 20Sep06: When shortening an existing free
                // trans segment, the cell did not go white, but stayed green, because the
                // source phrase associated with the end pile had not yet had its
                // m_bHasFreeTrans reset to FALSE; so, the following lines update the flags
                // to correct the situation.
				pPile->GetSrcPhrase()->m_bHasFreeTrans = FALSE;
				pPile->GetSrcPhrase()->m_bEndFreeTrans = FALSE;
				// the pile previous to pPile becomes the new 
				// end pile of the active segment
				CPile* pPrevPile = GetPrevPile(pPile);
				if (pPrevPile != NULL)
					pPrevPile->GetSrcPhrase()->m_bEndFreeTrans = TRUE;

				gpCurFreeTransSectionPileArray->RemoveAt(end);
			}
			else
			{
				// can't remove index 0
				return;
			}

            // if there is text in the Compose Bar's edit box (ie. gFreeTranslationStr is
            // not empty) then we'll shorten without making any change; but if there is no
            // text, then will either leave the box empty or put in default text contructed
            // from the new current (shorter) section, according to whatever the relevant
            // flag setting currently is
			if (!bEditBoxHasText)
			{
				if (pApp->m_bTargetIsDefaultFreeTrans || pApp->m_bGlossIsDefaultFreeTrans)
				{
					// do the composition from the section's target text or glossing text
					tempStr = ComposeDefaultFreeTranslation(gpCurFreeTransSectionPileArray);
					pEdit->ChangeValue(tempStr); // show it in the ComposeBar's edit box
				}
			}

			// colour the current section & select the text
			MarkFreeTranslationPilesForColoring(gpCurFreeTransSectionPileArray);
			pEdit->SetFocus();
			pEdit->SetSelection(-1,-1); // -1,-1 selects all in wx

			// get the window updated
			Invalidate();
			GetLayout()->PlaceBox();
		}
	}
}

wxString CAdapt_ItView::ComposeDefaultFreeTranslation(wxArrayPtrVoid* arr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxString str;
	str.Empty();
	int nCount = arr->GetCount();
	if (nCount == 0)
		return str;
	int index;
	wxString theText;
	theText.Empty();
	for (index = 0; index < nCount; index++)
	{
		if (pApp->m_bTargetIsDefaultFreeTrans)
		{
			// get the text from the adaptation line's contents (exclude punctuation)
			theText = ((CPile*)arr->Item(index))->GetSrcPhrase()->m_adaption;
		}
		else if (pApp->m_bGlossIsDefaultFreeTrans)
		{
			// get the text from the glossing line's contents
			theText = ((CPile*)arr->Item(index))->GetSrcPhrase()->m_gloss; 
		}
		str += theText;
		str += _T(" "); // delimit with a single space
	}
	str = MakeReverse(str);
	str = str.Mid(1); // remove trailing space
	str = MakeReverse(str);
	return str; // if neither flag was on, an empty string is returned
}

/////////////////////////////////////////////////////////////////////////////////
/// \return         nothing
///
///	\param pileArray	->	pointer to the array of piles which are to have their
///	                        m_bIsCurrentFreeTransSection BOOL member set to TRUE
/// \remarks
///	This will turn on light pastel pink colouring of the phrase box line's
///	rectangles which lie within the current free translation section, when
///	Draw() is called on the CCell instances) -- use after making a call to
///	MakeAllPilesNonCurrent() when the current section moves to a new location
///	or is changed in size
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::MarkFreeTranslationPilesForColoring(wxArrayPtrVoid* pileArray)
{
	int nCount = pileArray->GetCount(); 
	int index;
	CPile* pile;
	for (index = 0; index < nCount; index++)
	{
		pile = (CPile*)pileArray->Item(index); 
		wxASSERT(pile); 
		pile->SetIsCurrentFreeTransSection(TRUE);
	}
    // we now have to bother with clearing this bool member because not every
    // RecalcLayout() call builds CPile instances from scratch, and when that is
    // the case the default value is not reset FALSE for each unless we explicitly
    // do so (but we don't need to do it here)
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             TRUE if the sourcephrase's m_bStartFreeTrans BOOL is TRUE, 
///                     FALSE otherwise
///	\param pPile	->	pointer to the pile which stores the pSrcPhrase pointer being 
///	                    examined
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsFreeTranslationSrcPhrase(CPile* pPile)
{
	return pPile->GetSrcPhrase()->m_bStartFreeTrans == TRUE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             TRUE if the sourcephrase's m_markers member contains a \free 
///                     marker FALSE otherwise
/// \param	pPile	->	pointer to the pile which stores the pSrcPhrase pointer being 
///                     examined
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::ContainsFreeTranslation(CPile* pPile)
{
	wxString markers = pPile->GetSrcPhrase()->m_markers;
	if (markers.IsEmpty())
		return FALSE;
	int curPos = markers.Find(_T("\\free"));
	return curPos > 0;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             nothing
///
///	\param  activeSequNum	->	the sequence number value at the phrase box location
/// \remarks
///	Called at the end of the RecalcLayout() function, provided the app flag
///	m_bFreeTranslationMode is TRUE. The function is responsible for determining
///	how many of the piles, starting at the active location, are to be deemed as
///	constituting the 'current' free translation section - the piles will be
///	shown with light pink background, and the user, after the function exits,
///	will be able to use buttons in the compose bar to alter the section - either
///	lengthening or shortening it, or recomposing it elsewhere, but these operations
///	are not handled by this function.
///	Note: any call made in this function which results in a RecalcLayout() call
///	being done, will recursively cause SetupCurrentFreeTransSection() to be entered
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::SetupCurrentFreeTransSection(int activeSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	gbFreeTranslationJustRemovedInVFMdialog = FALSE; // restore to default 
           // value, in case a removed was just done in the View Filtered 
           // Material dialog

	if (activeSequNum < 0)
		// phrase box is not defined, no active location is valid, so return
		return;

	pApp->m_pActivePile = GetPile(activeSequNum); // has to be set here, because at
							// end of RecalcLayout's legacy code it is still undefined
	bool bEditBoxHasText = FALSE; // to help with initializing the ComposeBar's contents,
                            // because we may be returning from normal mode after an
                            // editing operation and want the box text to still be there
	CMainFrame* pFrame;
	pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxASSERT(pFrame->m_pComposeBar != NULL);
	wxTextCtrl* pEdit = (wxTextCtrl*)
							pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE); 
	// whm 24Aug06 removed gFreeTranslationStr global here and below
	wxString tempStr;
	tempStr = pEdit->GetValue(); // set tempStr to whatever is in the box

	gpCurFreeTransSectionPileArray->Clear(); // start with an empty array

	bool bOwnsFreeTranslation = IsFreeTranslationSrcPhrase(pApp->m_pActivePile);
	CPile* pile;
	if (bOwnsFreeTranslation)
	{
		// it already has a free translation stored in the sourcephrase
		pile = pApp->m_pActivePile;

        // before moving on from this pile, get the free translation text, and set the
        // globals for its offset and length so we can later easily update the filtered
        // free translation with any user edits done on it in the edit box of the
        // Compose Bar
		wxString theMkr = _T("\\free");
		wxString theEndMkr = _T("\\free*");
		tempStr = GetExistingMarkerContent(theMkr, theEndMkr, 
										pApp->m_pActivePile->GetSrcPhrase(),
										gnOffsetInMarkersStr, gnLengthInMarkersStr);
		pEdit->ChangeValue(tempStr);	// show it in the ComposeBar's edit box, but
				// don't have it selected - too easy for user to mistakenly lose it

        // now collect the array of piles in this section - since it's a predefined
        // section, we can use the bool values on each pSrcPhrase to determine the
        // section's extent
		CPile* pNextPile;
		while (pile != NULL)
		{
			// store this pile in the global array
			gpCurFreeTransSectionPileArray->Add(pile);

            // there might be only one pile in the section, if so, this one would also
            // have the m_bEndFreeTrans flag set TRUE, so check for this and if so,
            // break out here
			if (pile->GetSrcPhrase()->m_bEndFreeTrans)
				break;

			// get the next pile - beware, it will be NULL if we are at doc end
			pNextPile = GetNextPile(pile);
			if (pNextPile == NULL)
			{
                // we are at the doc end
				break;
			}
			else
			{
                // pNextPile is not null, so check out if this pile is the end of the
                // section
				wxASSERT(pNextPile != NULL);
				pile = pNextPile;
				wxASSERT(pile->GetSrcPhrase()->m_bHasFreeTrans); // must be TRUE 
																 // for a defined section
				if (pile->GetSrcPhrase()->m_bEndFreeTrans)
				{
					// we've found the ending pile
					gpCurFreeTransSectionPileArray->Add(pile); // store this one too
					break; // exit the loop
				}
			}
		} // end of loop

		// attempt to set the appropriate radio button, "Punctuation" or "Verse" based
		// section choice, by analysis of the section determined by the above loop
		if (gpCurFreeTransSectionPileArray->GetCount() > 0)
		{
			SPList* pSrcPhrases = pApp->m_pSourcePhrases;
			CSourcePhrase* pFirstSPhr = ((CPile*)
							gpCurFreeTransSectionPileArray->Item(0))->GetSrcPhrase();
			CSourcePhrase* pLastSPhr = ((CPile*)
							gpCurFreeTransSectionPileArray->Last())->GetSrcPhrase();
			bool bFreeTransPresent = TRUE;		
			bool bProbablyVerse = 
							GetLikelyValueOfFreeTranslationSectioningFlag(pSrcPhrases,
								pFirstSPhr->m_nSequNumber, pLastSPhr->m_nSequNumber, 
								bFreeTransPresent);
			pApp->m_bDefineFreeTransByPunctuation = !bProbablyVerse;

			// now set the radio buttons
			wxRadioButton* pRadioButton = (wxRadioButton*)
				pApp->GetMainFrame()->m_pComposeBar->FindWindowById(
															IDC_RADIO_PUNCT_SECTION);
			// set the value
			if (pApp->m_bDefineFreeTransByPunctuation)
				pRadioButton->SetValue(TRUE);
			else
				pRadioButton->SetValue(FALSE);
			pRadioButton = (wxRadioButton*)
				pApp->GetMainFrame()->m_pComposeBar->FindWindowById(
															IDC_RADIO_VERSE_SECTION);
			// set the value
			if (!pApp->m_bDefineFreeTransByPunctuation)
				pRadioButton->SetValue(TRUE);
			else
				pRadioButton->SetValue(FALSE);
			}
	}
	else
	{
		// it does not yet have a free translation stored in this sourcephrase,
		// so work out the first guess for what the current section is to be
		pile = GetPile(activeSequNum);
		if (pile == NULL)
			return; // something's very wrong - how can the phrase box be at 
					// a null pile?
		if (!tempStr.IsEmpty())
			bEditBoxHasText = TRUE;

        // at the current section we collect the layout information in globals, so that we
        // can delay committal to the section's extent until the user has made whatever
        // manual adjustments (with Compose Bar butons or clicking the phrase box elsewhere
        // or selecting or combinations of any of those) and the clicks Advance or Next>
        // of <Prev -- since it is at that point that the globals in the affected
        // pSrcPhrase instances will get set - (free translations not at the current
        // location will use those globals to set up for writing the free translation text
        // to the main window)
		int wordcount = 0;
		CPile* pNextPile;
		while (pile != NULL)
		{
			CSourcePhrase* pSrcPhrase;
			// store this pile in the global array
			gpCurFreeTransSectionPileArray->Add(pile);

			// count the pile's words (BEW changed 28Apr06)
			wordcount += pile->GetSrcPhrase()->m_nSrcWords;

			// test first for a following free translation section 
			// - if there is one it must halt scanning immediately
			pNextPile = GetNextPile(pile);
			if (pNextPile == NULL)
			{
				// we are at the doc end
				break;
			}
			else
			{
				if (pNextPile->GetSrcPhrase()->m_bStartFreeTrans)
					break; // halt scanning, we've bumped into a pre-existing 
						   // free trans section, else continue the battery of tests
			}
			if (IsFreeTranslationEndDueToMarker(pNextPile))
				break; // halt scanning, we've bumped into a SF marker which is 
                       // significant enough for us to consider that something quite
                       // different follows, or a filtered section starts at pNextPile
                       // - and that too indicates potential major change in the text
                       // at the next pile
			// determine if we can start testing for the end of the section
			// BEW 28Apr06, we are now counting words, so use to MIN_FREE_TRANS_WORDS, 
			// & still = 5 (See AdaptitConstants.h)
			if (wordcount >= MIN_FREE_TRANS_WORDS)
			{
				// test for final pile in this section
				pSrcPhrase = pile->GetSrcPhrase();
				wxASSERT(pSrcPhrase != NULL);
				if (gbIsUnstructuredData || pApp->m_bDefineFreeTransByPunctuation)
				{
					// the verse option is not available if the data has no SF markers
					if (HasWordFinalPunctuation(pSrcPhrase,pSrcPhrase->m_targetStr,
												gSpacelessTgtPunctuation))
					{
						// there is word-final punctuation, so this is a suitable place
						// to close off this section
						break;
					}
				}
				else
				{
					// we can assume the user wants the criterion to be the start of a
					// following verse (or end of document) or a text type change
					if (pNextPile == NULL)
					{
                        // we are at the end of the document
						break;
					}
					else if (pNextPile->GetSrcPhrase()->m_bVerse || 
								pNextPile->GetSrcPhrase()->m_bFirstOfType)
					{
						// this "next pile" is the start of a new verse, so we must 
						// break out here
						break;
					}
					// otherwise, continue iterating across successive piles
				}
			}

			// not enough piles to permit section to end, or end criteria not yet
			// satisfied, so keep iterating
			pile = GetNextPile(pile);
		}

        // Other calculations re strip and rects and composing default ft text -- all based
        // on the array as filled out by the above loop - these calculations should be done
        // as function calls with the array as parameter, since these calcs will be needed
        // in other places too

		// compose default free translation text, if appropriate...
        // this is a new location, so use the box contents if there is already something
        // there, otherwise check the app's flags m_bTargetIsDefaultFreeTrans and
        // m_bGlossIsDefaultFreeTrans and if one is true (both can't be true at the same
        // time) then compose a default free translation string from the target text, or
        // glossing text, in the section as currently defined
		if (bEditBoxHasText)
		{
			// Compose Bar's edit box has text, so leave that as the default
			;
		}
		else
		{
			// no text there, so check the app flag
			if (pApp->m_bTargetIsDefaultFreeTrans || pApp->m_bGlossIsDefaultFreeTrans)
			{
				// do the composition from the section's target text, or glossing text
				tempStr = ComposeDefaultFreeTranslation(gpCurFreeTransSectionPileArray);
				pEdit->ChangeValue(tempStr); // show it in the ComposeBar's edit box
			}
		}
	}
	// colour the current section
	MarkFreeTranslationPilesForColoring(gpCurFreeTransSectionPileArray);
	pEdit->SetFocus();
	pEdit->SetSelection(-1,-1); // -1,-1 selects all
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             the text of the filtered content (such as a free translation) 
///                     which is in the m_markers member
///
/// \param	mkr			->	reference to the SF marker string (including backslash) 
///                         defining the content we are after
///	\param	endMkr		->	reference to the matching endmarker string, including backslash 
///	                        (could be empty)
///	\param	pSrcPhrase	->	pointer to the CSourcePhrase instance whose m_markers member
///					        contains a substring such as:
///	   "\~FILTER \free <text of free translation> \free* \~FILTER* " for free translation, or
///	   "\~FILTER \note <text of note> \note* \~FILTER* " for a note, or
///	   "\~FILTER \bt <text of backtranslation> \~FILTER* " or ...\btv ... or other \bt-derived 
///	                        marker
///	\param	offset		<-	character offset to the first word of the content string, 
///	                        relative to the start of m_markers
///	\param	length		<-	character length of the content string, including any final
///	                        space 
///
/// Remarks:
///    Used to extract the <text of free translation> part of the above substring, or <text
///    of note>, or <text of backtranslation> as the case may be; and to return the offset
///    to the character location at which this text starts, and its length including the
///    final space before the end marker, if any -- it should be present always for a free
///    translation or a note, and never present for a backtranslation marker. In the latter
///    case, the endMkr parameter will be empty (backtranslation markers do not have
///    endmarkers), and so the protocol we follow for determining the end of the content
///    string is the following
///	1. ends at the next backslash (typically, at a \~FILTER* marker, but may not be), 
///	   otherwise
///	2. ends at the end of m_markers string.
///    This function is a generalization of an earlier GetExistingFreeTranslation()
///    function, so that we can get not just free translation content, but notes or
///    backtranslations. We can also use it for other filtered (or even non-filtered) SF
///    marker content we wish to extract, by just passing in the relevant SF marker in the
///    mkr parameter.
///
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::GetExistingMarkerContent(wxString& mkr, wxString& endMkr,
							CSourcePhrase* pSrcPhrase, int& offset, int & length)
{
	int len = mkr.Length();
	wxString contentStr;
	wxString markers = pSrcPhrase->m_markers;
	if (markers.IsEmpty())
	{
a:		offset = 0;
		length = 0;
		return wxString(_T(""));
	}
	int nFound = markers.Find(mkr);
	if (nFound == -1)
		goto a; // shouldn't happen, but play safe
	offset = nFound + len + 1; // plus 1 for the following space
	if (endMkr.IsEmpty())
	{
		// it's content which does not have an endmarker, so implement the
		// protocol described above
		len = markers.Length();
		nFound = FindFromPos(markers,_T("\\"),offset);
		if (nFound == -1)
		{
			// no subsequent SF marker, so length is the remainder of the string
			length = len - offset;
		}
		else
		{
			// found a marker, so up to the start of it defines the content string
			length = nFound - offset;
		}
	}
	else
	{
		// there should be an endmarker, so it's location 
		// determines where the content ends
		nFound = markers.Find(endMkr);
		wxASSERT(nFound >= 0);
		length = nFound - offset;
	}
	contentStr = markers.Mid(offset,length);
	return contentStr;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return         the offset from the beginning of m_markers where the filtered 
///                 string is to be inserted (it could be a free translation, or
///                 note, or backtranslation)
///
///	\param rStr		->	reference to the CString (typically m_markers) which is to 
///                     have the insertion done on it at the returned offset's
///                     character location
///	\param	mkr		->	reference to the actual marker which is being filtered
///	                    (see Remarks below)
///
/// Remarks:
///    This function can be used for inserting a filtered free translation string, or a
///    filtered note string, or a filtered backtranslation string (or a derivative of the
///    latter, such as \btv etc) into m_markers. The passed in marker is used to select
///    which particular code block is used, (and if there are derivative \bt markers in the
///    doc, just pass in whichever it is, such as \btv), because we wish to ensure that in
///    m_markers where all three kinds of marker are present, the relative order will be
///    guaranteed to be \note then \bt then \free. Nothing at all hangs on this being the
///    chosen order, and all our application's functionalities should work fine if there
///    was some other order, but we try to keep a fixed relative order for the sake of
///    orderliness and thereby we may help keep the whole more robust. Determining the
///    insertion offset implements the following protocol: - assuming we are dealing with a
///    free translation...
///	1. if m_markers is empty, insert at location 0
///	2. else if m_markers lacks \~FILTER, then check for m_markers commencing with an
///    endmarker, or endmarker sequence, if it does then the insertion location is after
///    the last such endmarker, of if one or more spaces follow it, then after those,
///    otherwise it is at 0
///	3. else if m_markers contains filtered material already (the rules below are ORDERED
///    rules): 
///    3.1 if \free already occurs (caller should have removed its content already) the 
///        location is immediately after the \free marker and its following space, (and the
///        caller should use InsertFilteredMaterial() with the bContentOnly flag set TRUE),
///        else
///	   3.2 if \bt or a derivative marker occurs, the free translation, after bracketing with
///           filterMrk and filterMkrEnd) goes after its closing \~FILTER* plus space, else
///	   3.3 if \note occurs, the free translation goes after its closing \~FILTER* plus space,
///	       else
///	   3.4 if neither, then insert directly after the last \~FILTER* plus space.
///    For a note or a backtranslation, just vary the above protocol accordingly. For
///    example, at 3. for a note, we would have 3.1 if \note already occurs, insert after
///    \note plus space, else 3.2 if \bt or derivative occurs, insert before its opening
///    \~FILTER marker, else if \free occurs, then insert before its opening \~FILTER
///    marker, if neither, then insert directly after the last \~FILTER* plus space. Etc.
///    With these protocols, then the note and/or backtranslation and/or free translation
///    filtered stuff will be tucked towards the right end of m_markers before any
///    unfiltered stuff like \c or \v etc, and because of that whenever we have
///    user-filterable stuff, or obligatorily filtered stuff added to m_markers, such stuff
///    is going to occur to the left of the note or backtrans or free trans material -
///    which is nice, though not essential. One benefit is that we don't have to test for
///    the case where an endmarker is followed by filtered material in m_markers; if we
///    allowed the above three kinds of marker to just be placed willynilly, we'd have to
///    test for that as well, as it's a legal configuration.
/////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItView::FindFilteredInsertionLocation(wxString& rStr, wxString& mkr)
{
	CAdapt_ItDoc* pDoc = GetDocument();
	int loc = 0;
	if (rStr.IsEmpty())
		return loc;
	int nFound = rStr.Find(filterMkr); // look for \~FILTER
	const wxChar* pBuff;
	int bufLen = rStr.Length();
	wxChar* pEnd;
	wxChar* pBufStart;
	wxChar* pStart; // BEW added 26May06 to get start location when there may be an
				   // initial sequence of endmarkers that must be traversed
	if (nFound == -1)
	{
		// there is no \~FILTER marker in rStr
		pBuff = rStr.GetData(); //GetWriteBuf(bufLen + 1);
		pBufStart = (wxChar*)pBuff;
		pEnd = pBufStart + bufLen;
		wxASSERT(*pEnd == _T('\0')); // whm added
s:		pStart = pBufStart + loc;
		if (*pStart == gSFescapechar)
		{
			// rStr starts with a marker, or another marker is after the first
			int itemLen = pDoc->ParseMarker(pStart);
			wxString initialMkr(pStart, itemLen);

			// find out if it an endmarker
			initialMkr = MakeReverse(initialMkr);
			if (initialMkr[0] == _T('*'))
			{
				// yes, it's an endmarker
				initialMkr = MakeReverse(initialMkr);
				loc += itemLen;

				// if another marker follows hard on its heals, repeat the test for that one
				if (*(pBuff + loc) == gSFescapechar)
						goto s;

                // when instead there are one or more spaces after the marker just scanned
                // over, traverse the spaces until either we are at the end, or we reach
                // the start of other marker and jump back to s in order to check that one
                // out too
				while (*(pBuff + loc) == _T(' ') && (pBuff + loc < pEnd))
				{
					loc++; // want the location to be after the trailing space(s), 
						   // if there were any

                    // if we come upon another marker, jump out and start out from this
                    // current location - it may be the case that we have nested markers,
                    // so we could be scanning over a pair of endmarkers, such as \fq*\f*
					if (*(pBuff + loc) == gSFescapechar)
						goto s;
				}
				return loc;
			}

			// it's some other marker, eg \c or \v or \p which isn't filtered
			// so the correct location is before it
			return loc; // loc is still zero here
		}
		// we should not have rStr starting with anything other than a marker
		// of some description, but to make fail-safe code, we allow for the
		// possibility
		return loc; // loc may still be zero here
	}

    // the above implements 1. and 2. for all passed in markers - whether \free,
    // \note, or \bt or derivative of \bt. Now what we do will depend on which of
    // the above was passed in.
	wxString freeStr = _T("\\free");
	wxString btStr = _T("\\bt"); // we need different tests for this one, 
								 // to handle \btv, \bts, etc
	wxString noteStr = _T("\\note");

	int curPos;
	if (mkr == freeStr)
	{
		// we want to know where to insert a \free and its free translation text
		if ((curPos = rStr.Find(freeStr)) > 0)
		{
            // the \free marker is present (and it must be preceded by \~FILTER plus
            // space) so the insertion location will be after the space following \free
			loc = curPos + freeStr.Length() + 1;
			return loc; // 3.1 is implemented
		}
		else
		{
			// there is no filtered free translation substring in rStr yet,
			// so implement protocols 3.2 to 3.4
			if ((curPos = rStr.Find(btStr)) > 0)
			{
				// note, rStr might have \bt marker, or some derivative marker 
				// such as \btv, \bts1, etc
				int pos2 = FindFromPos(rStr,filterMkrEnd,curPos); 
				wxASSERT(pos2 > 0); // there must be an ending filter marker 
									// for a backtranslation section
				int filtLen = wxStrlen_(filterMkrEnd); // length of \~FILTER*
				loc = pos2 + filtLen + 1;
				return loc; // implements 3.2
			}
			else
			{
				// there is no \bt marker, or other marker starting with \bt in rStr
				if ((curPos = rStr.Find(noteStr)) > 0)
				{
					// rStr contains a filtered \note marker and its content
					int pos2 = FindFromPos(rStr,filterMkrEnd,curPos);
					wxASSERT(pos2 > 0); // there must be an ending filter marker 
										// for a note section
					int filtLen = wxStrlen_(filterMkrEnd); // length of \~FILTER*
					loc = pos2 + filtLen + 1;
					return loc; // implements 3.3
				}
				else
				{
					// no backtrans, note, or free translation section, 
					// so insert after the lastmost \~FILTER* marker
					goto a;
				}
			}
		}
	}
	else if (mkr == noteStr)
	{
		// we want to know where to insert a \note and its note text
		if ((curPos = rStr.Find(noteStr)) > 0)
		{
            // the \note marker is present (and it must be preceded by \~FILTER plus space
            // so curPos == 0 is not a possibility) & the insertion location will be after
            // the space following \note
			loc = curPos + noteStr.Length() + 1;
			return loc; // 3.1 is implemented
		}
		else
		{
            // there is no filtered \note plus note substring in rStr yet, so implement
            // protocols 3.2 to 3.4; it there is a backtranslation, the note will be
            // inserted preceding its opening \~FILTER marker
			if ((curPos = rStr.Find(btStr)) > 0)
			{
				// note, rStr might have \bt marker, or instead some derivative 
				// such as \btv, \bts1, etc
				pBuff = rStr.GetData();
				pBufStart = (wxChar*)pBuff;
				pEnd = pBufStart + bufLen; // whm added
				wxASSERT(*pEnd == _T('\0')); // whm added
				wxChar* ptr = pBufStart + curPos;
				--ptr;
				while (*ptr != gSFescapechar)
				{
					--ptr;
				}
				// we should exit the above while loop with ptr pointing at \~FILTER
				wxASSERT(wxStrncmp(ptr,filterMkr,8) == 0); // assert that the comment 
														   // above is true
				loc = (int)(ptr - pBufStart); // insertion location immediately 
											  // before the \~FILTER marker
				return loc; // implements 3.2
			}
			else
			{
                // there is no \bt marker, or other marker starting with \bt in rStr, so
                // check out the possibility of a filtered free translation stored there
				if ((curPos = rStr.Find(freeStr)) > 0)
				{
                    // a filtered free translation is present, so the insertion location
                    // must be immediately preceding its opening \~FILTER marker
					pBuff = rStr.GetData(); 
					pBufStart = (wxChar*)pBuff;
					pEnd = pBufStart + bufLen; // whm added
					wxASSERT(*pEnd == _T('\0')); // whm added
					wxChar* ptr = pBufStart + curPos;
					--ptr;
					while (*ptr != gSFescapechar)
					{
						--ptr;
					}
					// we should exit the above while loop with ptr pointing at \~FILTER
					wxASSERT(wxStrncmp(ptr,filterMkr,8) == 0); // assert that the comment 
															   // above is true
					loc = (int)(ptr - pBufStart); // insertion location immediately 
												  // before the \~FILTER marker
					return loc; // implements 3.3
				}
				else
				{
                    // no backtrans, note, or free translation section,
                    // so insert after the lastmost \~FILTER* marker
					goto a;
				}
			}
		}
	}
	else if ((nFound = mkr.Find(btStr)) == 0)
	{
		// mkr is either \bt, or something which begins with \bt; so we want to know
		// where to insert whatever kind of backtranslation is here being considered
		if ((curPos = rStr.Find(btStr)) > 0) // we could be finding \bt, or the 
											 // first 3 chars of \btv, \bts1, etc
		{
			// a \bt or derivative marker is present (and it must be preceded by 
			// \~FILTER plus space so curPos == 0 is not a possibility) & the insertion
			// location will be after the space following \bt or whatever other marker 
			// happens to occur in this filtered section of backtranslation
			int nEnd = FindFromPos(rStr,filterMkrEnd,curPos); // get offset to terminating
													// \~FILTER* marker for this section
			int mkrLen = 3;
			pBuff = rStr.GetData();
			pBufStart = (wxChar*)pBuff;
			wxChar* pActualEnd = pBufStart + bufLen; // whm added
			*pActualEnd = (wxChar)0; // whm added - shouldn't matter but just to be safe
			pEnd = pBufStart + nEnd;
			wxChar* ptr = pBufStart + curPos; // point to the \bt or 
											  // whatever marker it is
			ptr += 3; // point to the first character following \bt
			wxASSERT (pEnd > ptr && (pEnd < pBufStart + bufLen)); // the section end 
											// lies within the buffer, ptr precedes it
			while (*ptr != _T(' '))
			{
				// span and count the extra marker characters until we come 
				// to a space or the end
				ptr++;
				mkrLen++;
				if (ptr == pEnd)
					break;
			}
			loc = curPos + mkrLen + 1;
			return loc; // 3.1 is implemented
		}
		else
		{
            // there is no filtered \bt or derivative of \bt in rStr yet, so implement
            // protocols 3.2 to 3.4; if there is a free translation filtered, then the
            // insertion point will be to the immediately left of its opening \~FILTER
            // marker
			if ((curPos = rStr.Find(freeStr)) > 0)
			{
				// there is a \free marker present, in a filtered section
				pBuff = rStr.GetData();
				pBufStart = (wxChar*)pBuff;
				pEnd = pBufStart + bufLen; // whm added
				wxASSERT(*pEnd == _T('\0')); // whm added
				wxChar* ptr = pBufStart + curPos;
				--ptr;
				while (*ptr != gSFescapechar)
				{
					--ptr;
				}
				// we should exit the above while loop with ptr pointing at 
				// the \~FILTER preceding \free
				wxASSERT(wxStrncmp(ptr,filterMkr,8) == 0); // assert that the 
														   // comment above is true
				loc = (int)(ptr - pBufStart); // insertion location immediately 
											  // before the \~FILTER marker
				return loc; // implements 3.2
			}
			else
			{
                // there is no \free marker in rStr, so check out the possibility of there
                // being a filtered \note section - if so, the insertion location is
                // immediately following the space which follows its closing \~FILTER*
                // marker
				if ((curPos = rStr.Find(noteStr)) > 0)
				{
					// a filtered note is present, so the insertion location must
					// be immediately after its closing \~FILTER* plus space
					int pos2 = FindFromPos(rStr,filterMkrEnd,curPos);
					wxASSERT(pos2 > 0); // there must be an ending filter marker 
										// for a note section
					int filtLen = wxStrlen_(filterMkrEnd); // length of \~FILTER*
					loc = pos2 + filtLen + 1;
					return loc; // implements 3.3
				}
				else
				{
					// no backtrans, note, or free translation section,
					// so insert after the lastmost \~FILTER* marker
a:					wxString filtEnd = filterMkrEnd;
					filtEnd = MakeReverse(filtEnd);
					wxString markers = rStr;
					markers = MakeReverse(markers);
					curPos = markers.Find(filtEnd);
					wxASSERT(curPos >= 0); // there must be a \~FILTER ... \~FILTER*
										   // section in rStr
					loc = bufLen - curPos + 1;
					return loc; // implements 3.4
				}
			}
		}
	}
	return loc = 0; // if none of the above, then return the 0th character position 
            // because in our Adapt It design we are not considering creation from nothing
            // of any other filtered material other than notes, backtranslations or free
            // translations
}

/////////////////////////////////////////////////////////////////////////////////
/// \return                     nothing
///	\param rMkr			->	reference to the marker (either \free, or \note, or \bt  
///	                        or a bt-prefixed marker)
///	\param rEndMkr		->	reference to the matching endmarker (either \free* or \note*),
///	                        empty string if none
///	\param contentStr	->	the string content (it should end in a space) which is to be 
///                         inserted, if there is no content for insertion, contentStr
///                         should be empty. (ContentStr must be a free translation,
///                         backtranslation, or a note, depending on what rMkr happens to
///                         be.) Any earlier content must have been cleared out by the
///                         caller first.
///	\param pSrcPhrase	->	pointer to the CSourcePhrase instance whose m_markers member is 
///	                        to have the insertion done at offsetForInsert
///	\param offsetForInsert ->	character offset where insertion is to take place - what 
///	                        actually gets put there depends on the next parameter
///	\param bContentOnly	->	TRUE if only contentStr is to be inserted
///
/// Remarks:
///    Used to insert either free translation, or backtranslation, or a note, into
///    m_markers - and these markers are always filtered, so we have to be clever. If
///    bContentOnly is TRUE, only the content for a marker gets inserted, because the
///    marker, any endmarker, and bracketing filter markers will already be present and so
///    not need to be inserted again. If bContentOnly is FALSE, none of the required stuff
///    is already present, and so filter markers, marker, endmarker (if needed) and
///    content, with a space between each, will need to be inserted at offsetForInsert, and
///    a final space added too.
///    Note: if the marker is already present, then its content should have been removed
///    before calling InsertFilteredMaterial() -- a good way to do this is to use the
///    function GetExistingMarkerContent() which also returns offsets to the beginning and
///    end of the content string, and then CString's Delete() function can be used to get
///    rid of the content.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::InsertFilteredMaterial(wxString& rMkr, wxString& rEndMkr, 
						wxString contentStr, CSourcePhrase* pSrcPhrase, 
						int offsetForInsert, bool bContentOnly)
{
	int len = contentStr.Length();
	if (bContentOnly)
	{
		// everything is already present, we only need the content updated
		if (contentStr.IsEmpty())
			return;
		if (contentStr[len - 1] != _T(' '))
			contentStr += _T(' '); // add a space if contentStr does not already 
								   // end with one
		// wxString doesn't have an Insert method, so we'll do it with a helper function
		pSrcPhrase->m_markers = 
						InsertInString(pSrcPhrase->m_markers,offsetForInsert,contentStr);
	}
	else
	{
		// none of what is needed is present, so insert it all, including the new content
		wxString accumStr;
		accumStr.Empty();
		accumStr += filterMkr; // add \~FILTER
		accumStr += _T(' '); // add a space
		accumStr += rMkr; // add whatever marker rMkr is, either \free, or \note, or 
						  // \bt (or a derivative thereof)
		accumStr += _T(' '); // add a space
		if (contentStr.IsEmpty())
		{
			; // add nothing
		}
		else
		{
			if (contentStr[len - 1] != _T(' '))
				contentStr += _T(' '); // add a space if contentStr does not 
									   // already end with one
		}
		accumStr += contentStr;
		if (!rEndMkr.IsEmpty())
		{
			accumStr += rEndMkr;
			accumStr += _T(' '); // add a space
		}
		accumStr += filterMkrEnd;
		accumStr += _T(' '); // add a space
		pSrcPhrase->m_markers = 
					InsertInString(pSrcPhrase->m_markers,offsetForInsert,accumStr); 
														// ignore returned length
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             TRUE if the 'next' sourcephrase pointed at by the passed in 
///                     pile pointer contains in its m_markers member a SF marker which
///                     should halt forward scanning for determining the end of the current
///                     section to be free translated; FALSE otherwise
///
///	\param pNextPile	->	pointer to the pile which is one position further along in the 
///                         list than where control happens to be in the caller (so if TRUE
///                         is returned, that passed in pile will be excluded from the
///                         current free translation section being delimited, and scanning
///                         will stop)
/// \remarks
/// We don't want a situation, such as in introductory material at the start of a book
/// where there are no verses defined, and perhaps limited or no punctuation as well, for
/// scanning to find an endpoint for the current section to fail to find some criterion for
/// termination of the section - which would easily happen if we ignored SF markers - and
/// we'd get overrun of the section into quite different kinds of information. So we'll
/// halt scanning when there is a marker, but not when the marker is an endmarker for a
/// marker with TextType none, nor when it is a beginning marker which has a TextType of
/// none - the latter we want Adapt It to treat as if they are 'not there' for most
/// purposes. And we'll not halt at embedded markers within a footnote (\f) or cross
/// reference (\x) section either, but certainly halt when there is \f* or (PNG set's \fe
/// or \F) or \x* on the 'next' sourcephrase passed in. BEW changed 22Dec07: a filtered
/// Note can be anywhere, and we don't want these to needlessly halt section delineation,
/// so we'll ignore \note and \note* as well.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsFreeTranslationEndDueToMarker(CPile* pNextPile)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxString noteMkr = _T("\\note"); // BEW added 22Dec07
	USFMAnalysis* pAnalysis = NULL;
	wxString bareMkr;
	CAdapt_ItDoc* pDoc = GetDocument();
	wxString markers = pNextPile->GetSrcPhrase()->m_markers;
	if (markers.IsEmpty())
		return FALSE;

	// anything filtered must halt scanning, exept for a \note & its content
	wxString fltr = filterMkr; // \~FILTER
	int fltrPos = FindFromPos(markers,fltr,0);
	if (fltrPos != -1)
	{
        // since \~FILTER has been found, it could be for a Note; but it might be something
        // else which is filtered, or there might be a Note present plus other filtered
        // information (in which case the presence of the other filtered stuff must halt
        // the section delineation). So only when there is a single bit of filtered info
        // and it is a Note do we let processing continue, otherwise halt. It is sufficient
        // to test for \note, then branch according to whether or not there are least 3
        // instances of \~FILTER, in markers.
		if (FindFromPos(markers,noteMkr,0) != -1)
		{
            // there is a note filtered here; check for other filtered information too,
            // there needs to be more than two instances of \~FILTER (first is the
            // beginning marker, the second is its endmarker \~FILTER*) for that to be TRUE
			fltrPos = FindFromPos(markers,fltr,++fltrPos);
			if (fltrPos == -1)
			{
				// could happen, eg. a filtered \bt has no matching endmarker, 
				// & it halts progress
				return TRUE;
			}
			else
			{
				// matched two instances of \~FILTER, try for a third
				fltrPos = FindFromPos(markers,fltr,++fltrPos);
				if (fltrPos != -1)
				{
					return TRUE; // there is other filtered info present
				}
				else
				{
					// there were only two, so they were the 
					// beginning marker and its endmarker
					return FALSE;
				}
			}
		}
		else
			// no \note marker is in markers, so the filtered material
			// is something else and so we must halt here
			return TRUE;
	}

	const wxChar* pBuff;
	int bufLen = markers.Length();
	wxChar* pBufStart;
	wxChar* ptr;
	int itemLen;
	int curPos = -1;
	wxString ftnoteMkr = _T("\\f");
	wxString xrefMkr = _T("\\x");
	wxString endnoteMkr = _T("\\fe"); // BEW added 16Jan06
	int mkrLen = 0;

	// get rid of any initial spaces
	while (markers.GetChar(0) == _T(' '))
	{
		markers.Remove(0,1);
	}

	// handle any initial endmarker - it causes a halt unless it has TextType
	// of none, or is an endmarker for embedded markers in a footnote or cross
	// reference section, (BEW added:) or is \note*
	if (markers.GetChar(0) == gSFescapechar)
	{
		pBuff = markers.GetData();
		pBufStart = (wxChar*)pBuff;
		wxChar* pEnd;
		pEnd = pBufStart + bufLen; // whm added
		wxASSERT(*pEnd == _T('\0')); // whm added
		itemLen = pDoc->ParseMarker(pBufStart);
		wxString mkr(pBufStart,itemLen);
		mkr = MakeReverse(mkr);
		bool bIsEndMkr = FALSE;
		if (mkr.GetChar(0) == _T('*'))
		{
			// markers begins with an endmarker, determine
			// whether it is one which halts scanning or not
			itemLen++; // increment to encompass the following space
			bIsEndMkr = TRUE;
		}
		mkr = MakeReverse(mkr);
		if (bIsEndMkr)
		{
			// is it \f* or \x* ? (or if PngOnly is current, \F or \fe ?)
			if (mkr == ftnoteMkr + _T('*'))
				return TRUE; // halt scanning
			if (mkr == xrefMkr + _T('*'))
				return TRUE;
			if (pApp->gCurrentSfmSet == UsfmOnly && 
					(mkr == endnoteMkr + _T('*')))
				return TRUE;
			if (pApp->gCurrentSfmSet == PngOnly && (mkr == _T("\\fe") || 
					mkr == _T("\\F")))
				return TRUE;

			// find out if it is an embedded marker with TextType of none
			// - we don't halt for these nor for a \note*
			if (mkr == noteMkr + _T('*'))
				return FALSE; // don't halt scanning for this
			mkrLen = mkr.Length();
			bareMkr = mkr;
			bareMkr = bareMkr.Left(mkrLen - 1);
			bareMkr = bareMkr.Mid(1);
			pAnalysis = pDoc->LookupSFM(bareMkr);
			if (pAnalysis == NULL)
				return TRUE; // halt for an unknown endmarker 
							 // (never should be such a thing anyway)
			if (pAnalysis->textType == none)
				return FALSE; // don't halt scanning for these

			// we don't halt for embedded endmarkers in footnotes or cross references 
			// (USFM set only) either
			int nFound = mkr.Find(ftnoteMkr); // if true, \f is contained within mkr
			if (nFound >= 0 && mkrLen > 2)
				return FALSE; // must be \fr*, \fk*, etc - so don't halt
			nFound = mkr.Find(xrefMkr); // if true, \x is contained within mkr
			if (nFound >= 0 && mkrLen > 2)
				return FALSE; // must be \xr*, \xt*, \xo*, etc - so don't halt

			// halt for any other endmarker
			return TRUE;
		}
	}

	// something else is present, so check it out
	curPos = markers.Find(gSFescapechar);
	if (curPos == -1)
		// there are no SF markes left in the string
		return FALSE; // don't halt scanning

    // we've a marker to deal with, and its not a filtered one 
    // - so we'll halt now unless the marker is one like \k , or 
    // \it , or \sc , or \bd etc - these have TextType none
	bufLen = markers.Length();
	pBuff = markers.GetData(); //GetWriteBuf(bufLen + 1);
	pBufStart = (wxChar*)pBuff;
	wxChar* pEnd;
	pEnd = pBufStart + bufLen; // whm added
	wxASSERT(*pEnd == _T('\0')); // whm added
	ptr = pBufStart + curPos;
	bareMkr = pDoc->GetBareMarkerForLookup(ptr);
	//markers.ReleaseBuffer();
	pAnalysis = pDoc->LookupSFM(bareMkr);
	if (pAnalysis == NULL)
		// an unknown marker should halt scanning
		return TRUE;
	if (pAnalysis->textType == none)
		return FALSE; // don't halt scanning for these

	// if it's an embedded marker in a footnote or cross reference section,
	// then these don't halt scanning
	wxString mkr = _T("\\") + bareMkr; // this is genuine backslash not PathSeparator
	mkrLen = mkr.Length();
	int nFound = mkr.Find(ftnoteMkr); // if true, \f is contained within mkr
	if (nFound >= 0 && mkrLen > 2)
		return FALSE; // must be \fr, \fk, etc - so don't halt
	nFound = mkr.Find(xrefMkr); // if true, \x is contained within mkr
	if (nFound >= 0 && mkrLen > 2)
		return FALSE; // must be \xr*, \xt*, \xo*, etc - so don't halt

	return TRUE; // anything else should halt scanning
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             nothing
///
///	\param pArr	   ->  pointer to the global gpFreeTransArray which contains FreeTrElement 
///                    structs - each of which contains the information relevant to
///                    writing a subpart of the free translation in a single rectangle
///                    under a single strip
/// Remarks:
///    The global structures and variables are used over and over while writing out the
///    free translation text in the client area, and so we need this function to clear out
///    the array each time we come to the next section of the free translation. 
///    Used by DrawFreeTranslations().
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::DestroyElements(wxArrayPtrVoid* pArr)
{
	int size = pArr->GetCount();
	if (size == 0)
		return;
	FreeTrElement* pElem;
	int i;
	for (i = 0; i < size; i++)
	{
		pElem = (FreeTrElement*)pArr->Item(i);
		delete pElem;
	}
	pArr->Clear();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             TRUE if the passed in word or phrase has word-final punctuation 
///                     at its end, else FALSE
///
///	\param pSP		->	pointer to the CSourcePhrase instance which stores the phrase 
///	                    parameter as a member
///	\param phrase	->	the word or phrase being considered (actually, pSP->m_targetStr)
///	\param punctSet ->	reference to a string of target language punctuation characters 
///	                    containing no spaces
/// \remarks
/// We can't simply search for a non-empty m_follPunct member of pSrcPhrase in order to end
/// a free translation section, because if we have a lot of typing in a retranslation, then
/// there will be several final placeholders in the source text line, and these will have
/// their m_follPunct members empty; so we must check for final punctuation in the target
/// text line instead, and the only way to do this is to look for final punctuation in the
/// m_targetStr member of pSrcPhrase - this will have content, even throughout a
/// retranslation
/// BEW modified 25Nov05; the above algorithm breaks down in document sections which have
/// not yet been adapted, because then there is no target text to examine! So when the
/// m_targetStr member is empty, we will indeed instead check for a non-empty m_follPunct
/// member!
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::HasWordFinalPunctuation(CSourcePhrase* pSP, wxString phrase, 
											wxString& punctSet)
{
	// beware, phrase can sometimes have a final space following punctuation - so first
	// remove trailing spaces
	phrase = MakeReverse(phrase);
	while (phrase.GetChar(0) == _T(' ')) // remove (now initial) spaces, if any
		phrase.Remove(0,1); // need second param of 1 otherwise will truncate
	wxString endingPuncts;
	if (phrase.IsEmpty())
	{
		if (!pSP->m_follPunct.IsEmpty())
			return TRUE;
		else
			return FALSE;
	}
	else
	{
		endingPuncts = SpanIncluding(phrase, punctSet); 
		return !endingPuncts.IsEmpty();
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             a CString which is the truncated text with an ellipsis (...) 
///                     at the end
///
///	\param pDC			->	pointer to the device context used for drawing the view
///	\param str			->	the string which is to be elided to fit the available drawing 
///	                        rectangle
///	\param ellipsis		->	the ellipsis text (three dots)
///	\param totalHExtent	->	the total horizontal extent (pixels) available in the drawing 
///                         rectangle to be used for drawing the elided text. It is the
///                         caller's responsibility to work out when this function needs
///                         to be called.
/// \remarks
///	Called in DrawFreeTranslations() when there is a need to shorten a text substring to fit
///	within the available drawing space in the layout
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::TruncateToFit(wxDC* pDC,wxString& str,wxString& ellipsis,
									  int totalHExtent)
{
	wxSize extent;
	wxString text = str;
	wxString textPlus;
a:	text.Remove(text.Length() - 1,1); 
	textPlus = text + ellipsis;
	pDC->GetTextExtent(textPlus,&extent.x,&extent.y); 
	if (extent.x <= totalHExtent) 
		return textPlus; // return truncated text with ellipsis 
						 // at the end, as soon as it fits
	else
	{
		if (text.Length() > 0)
			goto a;
		else
		{
			text.Empty();
			return text;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             a CString which is the segmented input text (integral number of 
///                     whole words) that will fit within the passed in extent
///
///	\param pDC				->	pointer to the device context used for drawing the view
///	\param str				->	the string which is to be segmented to fit the available 
///	                            drawing rectangle
///	\param ellipsis		    ->	the ellipsis text (three dots)
///	\param horizRectExtent	->	the horizontal extent (pixels) available in the drawing 
///	                            rectangle to be used for drawing the segmented text
///	\param fScale			->	scaling factor to be used if the text is smaller than 
///                             the available total space (ie. all rectangles), we use
///                             fScale if bUseScale is TRUE, and with it we scale the
///                             horizontal extent (horizExtent) to be a lesser number of
///                             whole pixels when the text is comparatively short, so that
///                             we get a better distribution of words between the available
///                             drawing rectangles. (bUseScale is passed in as FALSE if we
///                             know in the caller that the total text is too long for the
///                             sum of the available drawing rectangles for it all to fit)
///	\param offset			<-	pass back to the caller the offset of the first character 
///                             in str which is not included in the returned CString - the
///                             caller will use this offset to do a .Mid(offset) call on
///                             the passed in string, to shorten it for the next
///                             iteration's call of SegmentToFit()
///	\param nIteration		->	the iteration count for this particular rectangle
///	\param nIterBound		->	the highest value that nIteration can take (equal to the 
///                             total number of drawing rectangles for this free
///                             translation section, less one)
///	\param bTryAgain		<->	passing in FALSE allows fScale to be used, passing in TRUE 
///	                            prevents it being used
///	\param bUseScale		->	whether or not to do scaling of the rectangle extents to 
///                             give a better segmentation results - ie. distributing words
///                             more evenly than would be the case if unscaled rectangle
///                             extents were used for the calculations
/// \remarks
///    Called in DrawFreeTranslations() when there is a need to work out what the suitable
///    substring should be for the drawing rectangle with the passed in horizExtent value.
///    Note: bUseScale will be ignored on the last iteration (ie.for the last drawing
///    rectangle) because the function must try to get all of the remaining string text
///    drawn within this last rectangle if possible, so for the last rectangle we try fit
///    what remains and if it won't go, then we truncate the text. The bTryAgain parameter
///    enables a TRUE value to be sent back to the caller (SegmentFreeTranslation()) so
///    that the caller can request a complete recalculation without any rectangle scaling
///    by fScale being done - we want to do this when scaling has cut a free translation
///    string too early and the last rectangle's text got truncated - so we want a second
///    run with no scaling so that we minimize the possibility of truncation being needed
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::SegmentToFit(wxDC*		pDC,
									 wxString&	str,
									 wxString&	ellipsis,
									 int		horizRectExtent,
									 float		fScale,
									 int&		offset,
									 int		nIteration,
									 int		nIterBound,
									 bool&		bTryAgain,
									 bool		bUseScale)
{
	wxString subStr;
	wxSize extent;
	pDC->GetTextExtent(str,&extent.x,&extent.y); 
	int nStrExtent = extent.x; // the passed in substring str's text extent (horiz)
	int len = str.Length();
	int nHExtent = horizRectExtent;
	int ncount;
	int nShortenBy;
	if (bUseScale && !bTryAgain)
	{
        // don't use the scaling factor if bTryAgain is TRUE, but if FALSE it can be used
        // provided bUseScale is TRUE (and the latter will be the case if the caller knows
        // the text is shorter than the total rectangle horizontal extents)
		nHExtent = (int)(horizRectExtent * fScale); // this is a lesser number of pixels 
                        // than horizRectExtent the scaling effectively gives us shorter
                        // rectangles for our segmenting calculations
	}

	// work out how much will fit - start at 5 characters, 
	// since we can be sure that much is fittable
	if (nIteration < nIterBound)
	{
		ncount = 5;
		subStr = str.Left(ncount);
		pDC->GetTextExtent(subStr,&extent.x,&extent.y); 
		while (extent.x < nHExtent && ncount < len) 
		{
			ncount++;
			subStr = str.Left(ncount);
			pDC->GetTextExtent(subStr,&extent.x,&extent.y); 
		}

		// did we get to the end of the str and it all fits?
		if (extent.x < nHExtent)
		{
			offset = len;
			return subStr;
		}

		// we didn't get to the str's end, so work backwards 
		// until we come to a space
		subStr = MakeReverse(subStr);
		int nFind = (int)subStr.Find(_T(' '));
		if (nFind == -1)
		{
            // there was no space character found, so this rectangle can't have anything
            // drawn in it - that is, we can't make a whole word fit within it
			subStr.Empty();
			offset = 0;
		}
		else
		{
			nShortenBy = nFind;
			wxASSERT( nShortenBy >= 0);
			ncount -= nShortenBy;
			subStr = str.Left(ncount); // this includes a trailing space, 
									   // even if nShortenBy was 0
			offset = ncount; // return the offset value that ensures the caller's 
                        //.Mid() call will remove the trailing space as well (beware, the
                        //resulting shortened string may still begin with a space, because
                        //the user may have typed more than one space between words, so the
                        //caller must do a Trim() anyway
			// remove the final space, so we are sure it will fit
			subStr.Trim(FALSE); // trim left end
			subStr.Trim(TRUE); // trim right end
		}
		return subStr;
	}
	else
	{
		// we are at the last rectangle, so do the best we can and ignore scaling
		offset = len;
		subStr = str;
		subStr.Trim(FALSE); // trim left end
		subStr.Trim(TRUE); // trim right end
		// recalculate, in case lopping off a trailing space 
		// has now made it able to fit
		pDC->GetTextExtent(subStr,&extent.x,&extent.y);
		nStrExtent = extent.x; 
		if (nStrExtent < horizRectExtent)
		{
			// it's all gunna fit, so just return it
			;
		}
		else
		{
			// it ain't gunna fit, so truncate
			subStr = TruncateToFit(pDC,str,ellipsis,horizRectExtent);

			// here is where we can set bTryAgain to force a recalculation 
			// without the scaling factor
			if (!bTryAgain && bUseScale)
			{
				bTryAgain = TRUE; // tell the caller to initiate a recalculation
			}
		}
		return subStr;
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             the CPile instance, safely earlier than where we are interested in
///                     and where the caller will start scanning ahead from to get the
///                     'real' starting location we want
///	\param activeSequNum	->	index of the current active location where the free 
///	                            translation's current section commences (ie. the 
///	                            anchor CPile instance)
/// \remarks
/// Called early in the view's DrawFreeTranslations() function, to return an arbitrary but
/// off-screen CPile instance guaranteed to lie somewhere within the document and preceding
/// the start of the current free translation section being drawn. This pile is used as the
/// kick off point for scanning forward to determine which CPile instance is actually to be
/// the start (ie. anchor) for the current free translation section. In the legacy
/// application where we segmented the document into "bundles" and only laid out a bundle
/// at a time, it was easy to start the forward scan from the start of the current bundle.
/// But in the refactored application, it would be a waste of time to start the scan from
/// the beginning of the document. So we work out a suitable location given the current
/// active location (& its anchor pile) - that works right even if the user has scrolled
/// the active location off screen. Since we need to dynamically work this out for each
/// call of DrawFreeTranslations(), there is no need to store this starting pile's pointer
/// in a global for use at a later time
/// Note: in July 09 (about 12th?) BEW changed the forward scanning in
/// DrawFreeTranslations() to not scan forward more than as many strips as fit in the
/// visible window, otherwise we were getting whole-document scans over thousands of strips
/// which tied up the app for a minute or more. Therefore, the kick off point for scanning
/// forward has to be able to find its target location within a window height's amount of
/// strips from the kick off location, so care must be exercised in coding the free
/// translation functionality to ensure this constraint is never violated. (see change of
/// 14July below, for example)
/////////////////////////////////////////////////////////////////////////////////
CPile* CAdapt_ItView::GetStartingPileForScan(int activeSequNum)
{
	CLayout* pLayout = GetLayout();
	CPile* pStartPile = NULL;
	if (activeSequNum < 0)
	{
		pStartPile = GetPile(0);
		return pStartPile;
	}
	pStartPile = GetPile(activeSequNum);
	wxASSERT(pStartPile);
	int numVisibleStrips = pLayout->GetNumVisibleStrips();
	if (numVisibleStrips < 1)
		numVisibleStrips = 2; // we don't want to use 0 or 1, not a big enough jump
	int nCurStripIndex = pStartPile->GetStripIndex();
    // BEW changed 14Jul09, we want to start the off-window scan no more than a strip or
    // two from the start of the visible area, otherwise our caller, DrawFreeTranslations()
    // may exit early without drawing anything - so from the active strip we go back a
    // half-window and then two more strips for good measure
	nCurStripIndex = nCurStripIndex - (numVisibleStrips / 2 + 2);
	if (nCurStripIndex < 0)
		nCurStripIndex = 0;
	CStrip* pStrip = (CStrip*)pLayout->GetStripArray()->Item(nCurStripIndex);
#ifdef _ALT_LAYOUT_
	pStartPile = pStrip->GetPileByIndexInStrip(0);
#else
	pStartPile = (CPile*)pStrip->GetPilesArray()->Item(0); // ptr of 1st pile in strip
#endif
	wxASSERT(pStartPile);
	return pStartPile;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return                 nothing
///
/// Parameters:
///	\param pDC		       ->	pointer to the device context used for drawing the view
///	\param pLayout	       ->	pointer to the CLayout instance, which manages all the 
///	                            strips, and piles.
///	\param drawFTCaller    ->   enum value either call_from_ondraw, or call_from_edit - 
///                             when call_from_ondraw all free translations within the view
///                             are drawn; when call_from_edit, only the free translation
///                             being edited is redrawn as editing is being done
/// \remarks
/// Called in the view's OnDraw() function, which gets invoked whenever a paint message has
/// been received, but DrawFreeTranslations is only done when free translation mode is
/// turned on, otherwise it is skipped. Internally, it intersects each rectangle, and the
/// whole of each free translation section (which may span several strips), with the client
/// rectangle for the view - and when the intersection is null, it skips further
/// calculations at that point and draws nothing; furthermore, then the function determines
/// that all further drawing will be done below the bottom of the client rect, it exits.
/// The data structures and variables the function requires are, for the most part, within
///	the CLayout instance, but there are also some globals defined at the start of the view 
///	class's file Adapt_ItView.cpp.
///	It does either one or two passes. A second pass is tried, with tighter fitting of data
///	to available space, if the first pass does not fit it all in.
///
/// whm: With its six jump labels, and thirteen gotos, the logic of this function is very
/// convoluted and difficult to follow - BEWARE!
///   TODO: Rewrite with simpler logic!
/// whm added additional parameters on 24Aug06 and later on 31May07
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::DrawFreeTranslations(wxDC* pDC, CLayout* pLayout, 
										 enum DrawFTCaller drawFTCaller)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItView* pView = pApp->GetView();
	wxASSERT(pView != NULL);
	DestroyElements(gpFreeTransArray);
	CPile*  pPile; // a scratch pile pointer
	CStrip* pStrip; // a scratch strip pointer
	wxRect rect; // a scratch rectangle variable
	int curStripIndex;
	int curPileIndex;
	int curPileCount;
	int nTotalHorizExtent; // the sum of the horizonal extents of the subrectangles 
                           // which make up the laid out possible writable areas
                           // for the current free trans section
	wxPoint topLeft;
	wxPoint botRight;
	CSourcePhrase* pSrcPhrase;
	FreeTrElement* pElement;
	wxSize extent;
	bool bSectionIntersects = FALSE;
	// get an offscreen pile from which to scan forwards for the anchor pile
	pPile = GetStartingPileForScan(pApp->m_nActiveSequNum);
	// get it's CSourcePhrase instance
	pSrcPhrase = pPile->GetSrcPhrase(); // its pointed at sourcephrase
	wxString ellipsis = _T("...");
	wxString ftStr;
	wxArrayString subStrings;
	wxRect testRect = grectViewClient; // need a local, because an intersect test
									  // changes the calling rectangle
	wxString theMkr = _T("\\free");
	wxString theEndMkr = _T("\\free*");

    // ready the drawing context - we must handle ANSI & Unicode, and for the former we use
    // TextOut() and for the latter we use DrawText() and the Unicode app can be LTR or RTL
    // script (we use same text rending directionality as the target text line) - code from
    // CCell.cpp and CText.cpp can be reused here
	// wx version note: wx version always uses DrawText
	wxRect rectBounding;
	bool bRTLLayout = FALSE;
	#ifdef _RTL_FLAGS
	if (pApp->m_bTgtRTL)
	{
		ellipsis = _T('\u2026'); // use a unicode ellipsis for RTL
		// free translation has to be RTL & aligned RIGHT
		bRTLLayout = TRUE; //nFormat = gnRTLFormat;
	}
	else
	{
		// free translation has to be LTR & aligned LEFT
		bRTLLayout = FALSE; //nFormat = gnLTRFormat;
	}
	#endif

	// set up a new colour - make it a purple, 
	// hard coded in app as m_freetransTextColor
	wxFont pSaveFont;
	wxFont* pFreeTransFont = pApp->m_pTargetFont;
	pSaveFont = pDC->GetFont();
	pDC->SetFont(*pFreeTransFont);
	wxColour color(pApp->m_freeTransTextColor);
	if (!color.IsOk())
	{
		::wxBell(); 
		wxASSERT(FALSE);
	}
	pDC->SetTextForeground(color); 

	// the logicalViewClientBottom is the scrolled value for the top of the view
	// window, after the device context has been adjusted; this value is constant for any
	// one call of DrawFreeTranslations(); we need to use this value in some tests,
	// because grectViewClient.GetBottom() only gives what we want when the view is
	// unscrolled
	int logicalViewClientBottom = (int)pDC->DeviceToLogicalY(grectViewClient.GetBottom());
	// use the thumb position to adjust the Y coordinate of testRect, so it has the
	// correct logical coordinates value given the amount that the view is currently
	// scrolled 
	int nThumbPosition_InPixels = pDC->DeviceToLogicalY(0);


    // for wx testing we make the background yellow in order to verify the extent of each
    // DrawText and clearing of remaining free translation's rect segment
	//pDC->SetBackgroundMode(pApp->m_backgroundMode);
	//pDC->SetTextBackground(wxColour(255,255,0));
	// wx testing above

	// THE LOOP FOR ITERATING OVER ALL FREE TRANSLATION SECTIONS IN THE DOC,
	//  STARTING FROM A PRECEDING OFFSCREEN CPile INSTANCE, BEGINS HERE

	#ifdef _Trace_DrawFreeTrans
	TRACE0("\n\n BEGIN - Loop About To Start in DrawFreeTranslations()\n\n");
	#endif

	// whm: I moved the following declarations and initializations here
	// from way below to avoid compiler warnings:
	bool bTextIsTooLong = FALSE;
	int totalRects = 0;
	int offset = 0;
	int length = 0;

    // whm added 25Aug06 if we are being called from the OnEnChangeEditBox handler we can
    // assume that the screen display has been drawn with any existing free translations,
    // including the one we may be editing. Since we are editing a single free translation,
    // we can just update the free translation associated with the first pile in
    // gpCurFreeTransSectionPileArray. So, we can go directly there without having to worry
    // about drawing any other free translations.
	if (drawFTCaller == call_from_edit)
	{
        // if we are not presently at the pile where the phrase box currently is, keep
        // scanning piles until we are (or encounter the end of the doc - an error)
		while (pPile != NULL && !pPile->GetIsCurrentFreeTransSection())
		{
			pPile = GetNextPile(pPile);
		}
        // when DrawFreeTranslations is called from the composebar's editbox, there should
        // certainly be a valid pPile to be found
		wxASSERT(pPile != NULL && pPile->GetIsCurrentFreeTransSection());
        // if this is a new free translation which has not been entered at this location
        // before, and the user just typed the first character, the free trans flags on the
        // source phrases will not have been set, but they must be set for the code below
        // to properly define this free translation element
		CPile* pCurrentPile;
		int j;
		for (j = 0; j < (int)gpCurFreeTransSectionPileArray->GetCount(); j++)
		{
			// set the common flags
			pCurrentPile = (CPile*)gpCurFreeTransSectionPileArray->Item(j);
			pCurrentPile->GetSrcPhrase()->m_bHasFreeTrans = TRUE;
			pCurrentPile->GetSrcPhrase()->m_bEndFreeTrans = FALSE;
			pCurrentPile->GetSrcPhrase()->m_bStartFreeTrans = FALSE;
		}
		// set the beginning one
		pCurrentPile = (CPile*)gpCurFreeTransSectionPileArray->Item(0);
		pCurrentPile->GetSrcPhrase()->m_bStartFreeTrans = TRUE;
		// set the ending one
		pCurrentPile = (CPile*)gpCurFreeTransSectionPileArray->Item(
									gpCurFreeTransSectionPileArray->GetCount()-1);
		pCurrentPile->GetSrcPhrase()->m_bEndFreeTrans = TRUE;
		goto ed;
	}

    // The a: labeled while loop below is skipped whenever drawFTCaller == call_from_edit
	// find the next free translation section, scanning forward 
    // (BEW added additional code on 13Jul09, to prevent scanning beyond the visible extent
    // of the view window - for big documents that wasted huge slabs of time)
a:	while ((pPile != NULL) && (!pPile->GetSrcPhrase()->m_bStartFreeTrans))
	{
		pPile = GetNextPile(pPile);

		#ifdef _Trace_DrawFreeTrans
		#ifdef __WXDEBUG__
		if (pPile)
		{
			TRACE2("while     sn = %d  ,  word =  %s\n", 
						pPile->GetSrcPhrase()->m_nSequNumber,
						pPile->GetSrcPhrase()->m_srcPhrase.c_str());
			TRACE2("  Has?   %d   ,   Start?   %d\n",
								pPile->GetSrcPhrase()->m_bHasFreeTrans,
								pPile->GetSrcPhrase()->m_bStartFreeTrans);
		}
		#endif
		#endif

		// BEW added 13Jul09, a test to determine when pPile's strip's top is greater than
		// the bottom coord (in logical coord space) of the view window - when it is TRUE,
		// we break out of the loop. Otherwise, if the document has no free translations
		// ahead, the scan goes to the end of the document - and for documents with
		// 30,000+ piles, this can take a minute or more!
		if (pPile == NULL)
		{
			// at doc end, so destroy the elements and we are done, so return
			DestroyElements(gpFreeTransArray); // don't leak memory
			return;
		}
		CStrip* pStrip = pPile->GetStrip();
		int nStripTop = pStrip->Top();

#ifdef DrawFT_Bug
	wxLogDebug(_T(" a: scan in visible part: srcPhrase %s , sequ num %d, strip index %d , nStripTop (logical) %d , grectViewClient bottom %d"),
		pPile->GetSrcPhrase()->m_srcPhrase, pPile->GetSrcPhrase()->m_nSequNumber, pPile->GetStripIndex(),
		nStripTop,logicalViewClientBottom);
#endif

		// when scrolled, grecViewClient is unchanged as it is device coords, so we have
		// to convert the Top coord (ie. y value) to logical coords for the tests
		if (nStripTop > logicalViewClientBottom)
		{
			// the strip is below the bottom of the view rectangle, stop searching forward
			DestroyElements(gpFreeTransArray); // don't leak memory
			
#ifdef DrawFT_Bug
			wxLogDebug(_T(" a: RETURNING;  nStripTop  %d ,  logicalViewClientBottom  %d"),
				nStripTop, logicalViewClientBottom);
#endif
			return;
		}
	}

	// did we find a free translation section?
ed:	if (pPile == NULL)
	{
		#ifdef _Trace_DrawFreeTrans
		TRACE0("** exiting due to null pile while scanning ahead **\n");
		#endif

		// there are as yet no free translations in this doc, or we've come to its end
		DestroyElements(gpFreeTransArray); // don't leak memory
		return;
	}
	pSrcPhrase = pPile->GetSrcPhrase();

#ifdef DrawFT_Bug
	wxLogDebug(_T(" ed: scan ahead: srcPhrase %s , sequ num %d, active sn %d  nThumbPosition_InPixels = %d"),
		pSrcPhrase->m_srcPhrase, pSrcPhrase->m_nSequNumber, pApp->m_nActiveSequNum, nThumbPosition_InPixels);
#endif

    // if we get here, we've found the next one's start - save the pile for later on (we
    // won't use it until we are sure it's free translation data is to be written within
    // the client rectangle of the view)
	gpFirstPile = pPile;

    // create the elements (each a struct containing int horizExtent and wxRect subRect)
    // which define the places where the free translation substrings are to be written out,
    // and initialize the strip and pile parameters for the loop
	pStrip = pPile->GetStrip();
	curStripIndex = pStrip->GetStripIndex();
	curPileIndex = pPile->GetPileIndex();

#ifdef _ALT_LAYOUT_
	curPileCount = pStrip->GetPileIndicesCount();
#else
	curPileCount = pStrip->GetPileCount();
#endif
	pElement = new FreeTrElement; // this struct is defined in CAdapt_ItView.h
	rect = pStrip->GetFreeTransRect(); // start with the full rectangle, 
									   // and reduce as required below
	nTotalHorizExtent = 0;
	bSectionIntersects = FALSE; // TRUE when the section being laid out intersects 
								// the window's client area
	#ifdef _Trace_DrawFreeTrans
	TRACE3("curPileIndex  %d  , curStripIndex  %d   , curPileCount %d  \n",
				curPileIndex,curStripIndex,curPileCount);
	#endif

	if (gbRTL_Layout)
	{
        // source is to be laid out right-to-left, so free translation rectangles will be
        // altered in location from what would be the case for a LTR layout
		rect.SetRight(pPile->GetPileRect().GetRight()); // this fixes where the writable 
														// area starts
        //  is this pile the ending pile for the free translation section?
e:		if (pSrcPhrase->m_bEndFreeTrans)
		{
            // whether we make the left boundary of rect be the left of the pile's
            // rectangle, or let it be the leftmost remainder of the strip's free
            // translation rectangle, depends on whether or not this pile is the last in
            // the strip - found out, and set the .left parameter accordingly
			if (curPileIndex == curPileCount - 1)
			{
				// last pile in the strip, so use the full width (so no change to rect
				// is needed)
				;
			}
			else
			{
                // more piles to the left, so terminate the rectangle at the pile's left
                // boundary REMEMBER!! When an upper left coordinate of an existing wxRect
                // is set to a different value (with intent to change the rect's size as
                // well as its position), we must also explicitly change the width/height
                // by the same amount. Here the correct width of rect is critical because
                // in RTL we want to use the upper right coord of rect, and transform its
                // value to the mirrored coordinates of the underlying canvas.
				rect.SetLeft(pPile->GetPileRect().GetLeft()); // this only moves the rect
				rect.SetWidth(abs(pStrip->GetFreeTransRect().GetRight() - 
								                       pPile->GetPileRect().GetLeft()));
																// used abs to make sure
			}
            // store in the pElement's subRect member (don't compute the substring yet, to
            // save time since the rect may not be visible), add the element to the pointer
            // array
			pElement->subRect = rect;
			pElement->horizExtent = rect.GetWidth(); 
			nTotalHorizExtent += pElement->horizExtent;
			gpFreeTransArray->Add(pElement);

            // determine whether or not this free translation section is going to have to
            // be written out in whole or part
			testRect = grectViewClient; // need a scratch testRect, since its values are 
                            // changed in the following test for intersection, so can't use
                            // grectViewClient 
			// BEW added 13Jul09 convert the top (ie. y) to logical coords; x, width and
			// height need no conversion as they are unchanged by scrolling
            testRect.SetY(nThumbPosition_InPixels);
            
			// The intersection is the largest rectangle contained in both existing
			// rectangles. Hence, when IntersectRect(&r,&rectTest) returns TRUE, it
			// indicates that there is some client area to draw on.
			if (testRect.Intersects(rect)) //if (bIntersects)
				bSectionIntersects = TRUE; // we'll have to write out at least this much
										   // of this section
			goto b; // exit the loop for constructing the drawing rectangles
		}
		else
		{
            // the current pile is not the ending one, so check the next - also check out
            // when a strip changes, and restart there with a new rectangle calculation
            // after saving the earlier element
			if (curPileIndex == curPileCount - 1)
			{
				// we are at the end of the strip, so we have to close off the current 
				// rectangle and store it
				pElement->subRect = rect;
				pElement->horizExtent = rect.GetWidth(); 
				nTotalHorizExtent += pElement->horizExtent;
				gpFreeTransArray->Add(pElement);

				// will we have to draw this rectangle's content?
				testRect = grectViewClient;
				testRect.SetY(nThumbPosition_InPixels); // correct if scrolled
				if (testRect.Intersects(rect)) 
					bSectionIntersects = TRUE;

                // are there more strips? (we may have come to the end of the doc) (for
                // a partial section at doc end, we just show as much of it as we
                // possibly can)
				//if (curStripIndex == pBundle->m_nStripCount - 1)
				if (curStripIndex == pLayout->GetStripCount() - 1)
				{
                    // there are no more strips, so this free translation section will be
                    // truncated to whatever rectangles we've set up so far
					goto b;
				}
				else
				{
                    // we are not yet at the end of the strips, so we can be sure there is
                    // a next pile so get it, and its sourcephrase pointer
					wxASSERT(curStripIndex < pLayout->GetStripCount() - 1);
					pPile = GetNextPile(pPile);
					wxASSERT(pPile);
					pSrcPhrase = pPile->GetSrcPhrase();

					// initialize rect to the new strip's free translation rectangle, and
					// reinitialize the strip and pile parameters for this new strip
					pStrip = pPile->GetStrip();
					curStripIndex = pStrip->GetStripIndex();
#ifdef _ALT_LAYOUT_
					curPileCount = pStrip->GetPileIndicesCount();
#else
					curPileCount = pStrip->GetPileCount();
#endif
					curPileIndex = pPile->GetPileIndex();
					// get a new element
					pElement = new FreeTrElement;
					//rect = pStrip->m_rectFreeTrans; 
					rect = pStrip->GetFreeTransRect(); // rect.right is already correct,
													   // since this is pile[0]
                    // this new pile might be the one for the end of the free translation
                    // section, so check it out
					goto e;
				}
			}
			else
			{
				// there is at least one more pile in this strip, so check it out
				pPile = GetNextPile(pPile);
				wxASSERT(pPile);
				pSrcPhrase = pPile->GetSrcPhrase();
				//curPileIndex = pPile->m_nPileIndex;
				curPileIndex = pPile->GetPileIndex();
				goto e;
			}
		}
	} // end RTL layout block
	else
	{
        // LTR layout, and this is the only option for the non-unicode application
        // REMEMBER!! When an upper left coordinate of an existing wxRect is set to a
        // different value (with intent to change the rect's size as well as its position,
        // we must also explicitly change the width/height by the same amount. The ending
        // width of the rect here has no apparent affect on the resulting text being
        // displayed because only the upper left coordinates in LTR are significant in
        // DrawText operations below
		rect.SetLeft(pPile->GetPileRect().GetLeft()); // fixes where the writable area starts
		rect.SetWidth(abs(pStrip->GetFreeTransRect().GetRight() - 
												pPile->GetPileRect().GetLeft())); 
        // used abs to make sure is this pile the ending pile for the free translation
        // section?

#ifdef DrawFT_Bug
		wxLogDebug(_T(" LTR block: RECT: Left %d , TOP %d, WIDTH %d , Height %d  (logical coords)"),
			rect.x, rect.y, rect.width, rect.height);
#endif

d:		if (pSrcPhrase->m_bEndFreeTrans)
		{

 #ifdef DrawFT_Bug
			wxLogDebug(_T(" after d:  At end of section, so test for intersection follows:"));
#endif
            // whether we make the right boundary of rect be the end of the pile's
            // rectangle, or let it be the remainder of the strip's free translation
            // rectangle, depends on whether or not this pile is the last in the strip -
            // found out, and set the .right parameter accordingly
			if (curPileIndex == curPileCount - 1)
			{
				// last pile in the strip, so use the full width (so no change to 
				// rect is needed)
				;
			}
			else
			{
				// more piles to the right, so terminate the rectangle at the pile's 
				// right boundary
				rect.SetRight(pPile->GetPileRect().GetRight());
			}
            // store in the pElement's subRect member (don't compute the substring yet, to
            // save time since the rect may not be visible), add the element to the pointer
            // array
			pElement->subRect = rect;
			pElement->horizExtent = rect.GetWidth(); 
			nTotalHorizExtent += pElement->horizExtent;
			gpFreeTransArray->Add(pElement);

            // determine whether or not this free translation section is going to have to
            // be written out in whole or part
			testRect = grectViewClient;

			// BEW added 13Jul09 convert the top (ie. y) to logical coords
			testRect.SetY(nThumbPosition_InPixels);

#ifdef DrawFT_Bug
		wxLogDebug(_T(" LTR block: grectViewClient at test: L %d , T %d, W %d , H %d  (logical coords)"),
			testRect.x, testRect.y, testRect.width, testRect.height);
#endif

			if (testRect.Intersects(rect))
			{
				bSectionIntersects = TRUE; // we'll have to write out at least this much 
										   // of this section
			}

#ifdef DrawFT_Bug
			if (bSectionIntersects)
				wxLogDebug(_T(" Intersects?  TRUE  and goto b:"));
			else
				wxLogDebug(_T(" Intersects?  FALSE  and goto b:"));
#endif
			goto b; // exit the loop for constructing the drawing rectangles
		}
		else
		{
            // the current pile is not the ending one, so check the next - also check out
            // when a strip changes, and restart there with a new rectangle calculation
            // after saving the earlier element
			if (curPileIndex == curPileCount - 1)
			{
				// we are at the end of the strip, so we have to close off the current 
				// rectangle and store it
				pElement->subRect = rect;
				pElement->horizExtent = rect.GetWidth();
				nTotalHorizExtent += pElement->horizExtent;
				gpFreeTransArray->Add(pElement);

				// will we have to draw this rectangle's content?
				testRect = grectViewClient;
				testRect.SetY(nThumbPosition_InPixels);
				if (testRect.Intersects(rect))
					bSectionIntersects = TRUE;

                // are there more strips? (we may have come to the end of the doc) (for a
                // partial section at doc end, we just show as much of it as we possibly
                // can)
				if (curStripIndex == pLayout->GetStripCount() - 1)
				{
                    // there are no more strips, so this free translation section will be
                    // truncated to whatever rectangles we've set up so far
					goto b;
				}
				else
				{
                    // we are not yet at the end of the strips, so we can be sure there is
                    // a next pile so get it, and its sourcephrase pointer
					wxASSERT(curStripIndex < pLayout->GetStripCount() - 1);
					pPile = GetNextPile(pPile);
					wxASSERT(pPile != NULL); 
					pSrcPhrase = pPile->GetSrcPhrase();

					// initialize rect to the new strip's free translation rectangle, and
					// reinitialize the strip and pile parameters for this new strip
					pStrip = pPile->GetStrip();
					curStripIndex = pStrip->GetStripIndex();
#ifdef _ALT_LAYOUT_
					curPileCount = pStrip->GetPileIndicesCount();
#else
					curPileCount = pStrip->GetPileCount();
#endif
					curPileIndex = pPile->GetPileIndex();
					// get a new element
					pElement = new FreeTrElement;
					rect = pStrip->GetFreeTransRect(); // rect.left is already correct, 
													   // since this is pile[0]
                    // this new pile might be the one for the end of the free translation
                    // section, so check it out
					goto d;
				}
			}
			else
			{
				// there is at least one more pile in this strip, so check it out
				pPile = GetNextPile(pPile);
				wxASSERT(pPile != NULL); 
				pSrcPhrase = pPile->GetSrcPhrase();
				curPileIndex = pPile->GetPileIndex();

#ifdef DrawFT_Bug
				wxLogDebug(_T(" iterating in strips:  another pile is there, with index = %d, srcPhrase = %s , and now going to d:"),
					pPile->GetPileIndex(), pPile->GetSrcPhrase()->m_srcPhrase);
#endif
				goto d;
			}
		}
	} // end LTR layout block

	// rectangle calculations are finished, and stored in 
	// FreeTrElement structs in gpFreeTransArray
b:	if (!bSectionIntersects)
	{
        // nothing in this current section of free translation is visible in the view's
        // client rectangle so if we are not below the bottom of the latter, iterate to
        // handle the next section, but if we are below it, then we don't need to bother
        // with futher calculations & can return immediately
		pElement = (FreeTrElement*)gpFreeTransArray->Item(0);
		// for next line... view only, MM_TEXT mode, y-axis positive downwards
		
#ifdef DrawFT_Bug
				wxLogDebug(_T(" NO INTERSECTION block:  Testing, is  top %d still above window bottom %d ?"),
					pElement->subRect.GetTop(), logicalViewClientBottom);
#endif

		if (pElement->subRect.GetTop() > logicalViewClientBottom) 
		{
			#ifdef _Trace_DrawFreeTrans
			TRACE0("No intersection, *** and below bottom of client rect, so return ***\n");
			#endif
			DestroyElements(gpFreeTransArray); // don't leak memory

#ifdef DrawFT_Bug
			wxLogDebug(_T(" NO INTERSECTION block:  Returning, as top is below grectViewClient's bottom"));
#endif
			return; // we are done
		}
		else
		{
			#ifdef _Trace_DrawFreeTrans
			TRACE0("No intersection, so iterating loop...\n");
			#endif

			DestroyElements(gpFreeTransArray); // don't leak memory

#ifdef DrawFT_Bug
			wxLogDebug(_T(" NO INTERSECTION block:  top is still above grectViewClient's bottom, so goto c: then to a: and iterate"));
#endif
			goto c;
		}
	}

    // the whole or part of this section must be drawn, so do the
    // calculations now; first, get the free translation text
	pSrcPhrase = gpFirstPile->GetSrcPhrase();
	offset = 0;
	length = 0;
	ftStr = GetExistingMarkerContent(theMkr, theEndMkr, pSrcPhrase, offset, length);

#ifdef DrawFT_Bug
	wxLogDebug(_T(" Drawing ftSstr =  %s ; for srcPhrase  %s  at sequ num  %d"), ftStr,
		pSrcPhrase->m_srcPhrase, pSrcPhrase->m_nSequNumber);
#endif
	
	// whm note: length is the length of the free trans string within the m_markers member.
    // Since Bruce has globals tracking these, and since under certain circumstances (i.e.,
    // when an editing change is made by typing over and replacing a selection in which
    // case it is two successive edit operations - first delete of the selection and second
    // addition of the replacement) there can be two calls to our OnEditBoxChanged for a
    // single editing action, we need to keep the globals in sync here The length needs to
    // be the length BEFORE padding with spaces (done below)
	gnLengthInMarkersStr = length;
	// offset is the position of the free trans string within the m_markers member
	gnOffsetInMarkersStr = offset;

	#ifdef _Trace_DrawFreeTrans
	TRACE2("Sequ Num  %d  ,  Free Trans:  %s \n", pSrcPhrase->m_nSequNumber, ftStr.c_str());
	#endif

    // whm changed 24Aug06 when called from OnEnChangedEditBox, we need to be able to allow
    // user to delete the contents of the edit box, and draw nothing, so we'll not jump out
    // early here because the new length is zero.
	if (drawFTCaller == call_from_ondraw)
	{
		if (length == 0)
		{
			// there is no text to be written to the screen, 
			// so continue with the next free translation section
			goto c;
		}

		// trim off any leading or trailing spaces
		ftStr.Trim(FALSE); // trim left end
		ftStr.Trim(TRUE); // trim right end
		if (ftStr.IsEmpty())
		{
			// nothing to write, so move on
			goto c;
		}
	}
    // get text's extent (a wxSize object) and compare to the total horizontal extent of
    // the rectangles. also determine the number of rectangles we are to write this section
    // into, and initialize other needed data
	pDC->GetTextExtent(ftStr,&extent.x,&extent.y);
	bTextIsTooLong = extent.x > nTotalHorizExtent ? TRUE : FALSE;
	totalRects = gpFreeTransArray->GetCount();

	if (totalRects == 1)
	{
		// the easiest case, the whole free translation section is contained within a 
		// single strip
		pElement = (FreeTrElement*)gpFreeTransArray->Item(0);
		if (bTextIsTooLong)
		{
			ftStr = TruncateToFit(pDC,ftStr,ellipsis,nTotalHorizExtent);
		}

		// next section:   Draw Single Strip Free Translation Text
		
        // clear only the subRect; this effectively allows for the erasing from the display
        // of any deleted text from the free translation string; even though this clearing
        // of the subRect is only technically needed before deletion edits, it doesn't hurt
        // to do it before every edit/keystroke. It works for either RTL or LTR text
        // displays.
		pDC->DestroyClippingRegion();
		pDC->SetClippingRegion(pElement->subRect);
		pDC->Clear();
		pDC->DestroyClippingRegion();
		if (bRTLLayout)
		{
//#ifdef _DEBUG
//			wxSize trueSz;
//			pDC->GetTextExtent(ftStr,&trueSz.x,&trueSz.y);
//			wxLogDebug(_T("RTL DrawText sub.l=%d + sub.w=%d - 
//			                                     ftStrExt.x=%d, x=%d, y=%d of %s"),
//				pElement->subRect.GetLeft(),pElement->subRect.GetWidth(),trueSz.x,
//				pElement->subRect.GetLeft()+pElement->subRect.GetWidth()-trueSz.x,
//				pElement->subRect.GetTop(),ftStr.c_str());
//#endif
			pView->DrawTextRTL(pDC,ftStr,pElement->subRect);
		}
		else
		{

#ifdef DrawFT_Bug
			wxLogDebug(_T(" *** Drawing ftSstr at:  Left  %d   Top  %d  These are logical coords."),
				pElement->subRect.GetLeft(), pElement->subRect.GetTop());
			wxLogDebug(_T(" *** Drawing ftSstr: gpFirstPile's Logical Rect x= %d  y= %d  width= %d  height= %d   PileHeight + 2: %d"),
				gpFirstPile->Left(), gpFirstPile->Top(), gpFirstPile->Width(), gpFirstPile->Height(), gpFirstPile->Height() + 2);
#endif

			pDC->DrawText(ftStr,pElement->subRect.GetLeft(),pElement->subRect.GetTop());
		}
	}
	else
	{
        // the free translation is spread over at least 2 strips - so we've more work to do
        // - call SegmentFreeTranslation() to get a string array returned which has the
        // passed in frStr cut up into appropriately sized segments (whole words in each
        // segment), truncating the last segment if not all the ftStr data can be fitted
        // into the available drawing rectangles
		SegmentFreeTranslation(pDC,ftStr,ellipsis,extent.GetWidth(),nTotalHorizExtent,
								gpFreeTransArray,&subStrings,totalRects);

#ifdef DrawFT_Bug
			wxLogDebug(_T(" Drawing ftSstr *** MultiStrip Draw ***"));
#endif

		// draw the substrings in their respective rectangles
		int index;
		for (index = 0; index < totalRects; index++)
		{
			// get the next element
			pElement = (FreeTrElement*)gpFreeTransArray->Item(index);
			// get the string to be drawn in its rectangle
			wxString s = subStrings.Item(index);

			// draw this substring
			// this section:  Draw Multiple Strip Free Translation Text
			
            // clear only the subRect; this effectively allows for the erasing from the
            // display of any deleted text from the free translation string; even though
            // this clearing of the subRect is only technically needed before deletion
            // edits, it doesn't hurt to do it before every edit/keystroke. It works for
            // either RTL or LTR text displays.
			pDC->DestroyClippingRegion();
			pDC->SetClippingRegion(pElement->subRect);
			pDC->Clear();
			pDC->DestroyClippingRegion();
			if (bRTLLayout)
			{
//#ifdef _DEBUG
//				wxSize trueSz;
//				pDC->GetTextExtent(s,&trueSz.x,&trueSz.y);
//				wxLogDebug(_T("RTL DrawText sub.l=%d + sub.w=%d - sExt.x=%d, x=%d, y=%d of %s"),
//					pElement->subRect.GetLeft(),pElement->subRect.GetWidth(),trueSz.x,
//					pElement->subRect.GetLeft()+pElement->subRect.GetWidth()-trueSz.x,
//					pElement->subRect.GetTop(),s.c_str());
//#endif
				pView->DrawTextRTL(pDC,s,pElement->subRect);
			}
			else
			{
				pDC->DrawText(s,pElement->subRect.GetLeft(),pElement->subRect.GetTop());
			}
			// Cannot call Invalidate() or SendSizeEvent from within DrawFreeTranslations
			// because it triggers a paint event which results in a Draw() which results
			// in DrawFreeTranslations() being reentered... hence a run-on condition 
			// endlessly calling the View's OnDraw.
		}

		subStrings.Clear(); // clear the array ready for the next iteration
	}

	if (drawFTCaller == call_from_edit)
	{
		// drawing of the one free translation being edited is done so return
		DestroyElements(gpFreeTransArray); // don't leak memory
		return;
	}

	// the section has been dealt with, get the next pile and iterate
c:	pPile = GetNextPile(pPile);
	if (pPile != NULL)
		pSrcPhrase = pPile->GetSrcPhrase();
	DestroyElements(gpFreeTransArray);

#ifdef DrawFT_Bug
	wxLogDebug(_T(" At c: next pPile is --  srcphrase %s, sn = %d, going now to a:"),
		pSrcPhrase->m_srcPhrase, pSrcPhrase->m_nSequNumber);
#endif

	goto a;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             nothing
///
///	\param pDC				->	pointer to the device context used for drawing the view
///	\param str				->	the string which is to be segmented to fit the available 
///	                            drawing rectangles
///	\param ellipsis		    ->	the ellipsis text (three dots)
///	\param textHExtent		->	horizontal extent of the section's free translation text 
///	                            (unsegmented)
///	\param totalHExtent	    ->  the total horizontal extent (pixels) available - calculated 
///                             by summing the horizontal extents of all the drawing
///                             rectangles to be used for drawing the subtext strings.
///	\param pElementsArray	->	array of FreeTrElement structs, one per drawing rectangle 
///	                            for this section
///	\param pSubstrings		<-	array of substrings formed by segmenting str into substrings 
///                             which will fit, one per rectangle, in the rectangles stored
///                             in pElementsArray (the caller will do the drawing of these
///                             substrings in the appropriate rectangles)
///	\param totalRects		->	the total number of drawing rectangles available for this 
///                             section (equals pElementsArray->GetSize() - which is how
///                             it was calculated in the caller)
/// \remarks
/// Called in DrawFreeTranslations() when there is a need distribute the typed free
/// translation string passed in in the str parameter over a number of drawing rectangles
/// in two or more consecutive strips - hence the size of the pSubstrings array must be the
/// same as or less than totalRects.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::SegmentFreeTranslation(wxDC*			pDC,
										   wxString&		str, 
										   wxString&		ellipsis, 
										   int				textHExtent, 
										   int				totalHExtent, 
										   wxArrayPtrVoid*	pElementsArray, 
										   wxArrayString*	pSubstrings, 
										   int				totalRects)
{
	float fScale = (float)(textHExtent / totalHExtent); // calculate the scale factor

    // adjustments are needed -- if the text is much shorter than the allowed space
    // (considering the two or more rectangles it has to be distributed over) then it isn't
    // any good to split short text across wide rectangles - instead it looks better to
    // bunch it to the left, if necessary drawing it all in the one rectangle. So for
    // smaller and smaller values of fScale, we need to bump up fScale by bigger and bigger
    // increments; the particular values below have been determined by experimentation and
    // appear to give optimal results in terms of appearance and synchonizing meaning
    // chunks with the layout parts to which they pertain
	if (fScale > (float)0.95)
		; // make no change
	else if (fScale > (float)0.9)
		fScale = (float)0.95;
	else if (fScale > (float)0.8)
		fScale = (float)0.9;
	else if (fScale > (float)0.7)
		fScale = (float)0.87;
	else if (fScale > (float)0.6)
		fScale = (float)0.83;
	else
		fScale = (float)0.8;

	wxString remainderStr = str; // we shorten this for each iteration
	wxString subStr; // what we work out as the first part of remainderStr 
					 // which will fit the current rect
	wxASSERT(pSubstrings->GetCount() == 0);
	FreeTrElement* pElement;
	int offset;
	int nIteration;
	int nIterBound = totalRects - 1;
	bool bTryAgain = FALSE; // if we use the scaling factor and we get truncation in 
            // the last rectangle then we'll use a TRUE value for this flag to force a
            // second segmentation which does not use the scaling factor

a:	if (bTryAgain || textHExtent > totalHExtent)
	{
        // the text is longer than the available space for drawing it, so there is
        // no point to doing any scaling -- instead, get as much as will fit into
        // each each rectange, and the last rectangle will have to have its text
        // elided using TruncateToFit()
		for (nIteration = 0; nIteration <= nIterBound; nIteration++)
		{
			pElement = (FreeTrElement*)pElementsArray->Item(nIteration);

			// do the calculation, ignoring fScale (hence, last parameter is FALSE)
			subStr = SegmentToFit(pDC,remainderStr,ellipsis,pElement->horizExtent,
							fScale,offset,nIteration,nIterBound,bTryAgain,FALSE);
			pSubstrings->Add(subStr);
			remainderStr = remainderStr.Mid(offset); // shorten, 
													 // for next segmentation
		}
	}
	else
	{
        // we should be able to make the text fit (though this can't be guaranteed because
        // some space is wasted in each rectangle if we print whole words (which we do)) -
        // and we'll need to do scaling to ensure the best segmentation results
		for (nIteration = 0; nIteration <= nIterBound; nIteration++)
		{
			pElement = (FreeTrElement*)pElementsArray->Item(nIteration);

			// do the calculation, using fScale (hence, last parameter is TRUE)
			subStr = SegmentToFit(pDC,remainderStr,ellipsis,pElement->horizExtent,
								fScale,offset,nIteration,nIterBound,bTryAgain,TRUE);
			pSubstrings->Add(subStr);
			remainderStr = remainderStr.Mid(offset); // shorten, for next segmentation
		}

		if (bTryAgain)
		{
			pSubstrings->Clear();
			remainderStr = str;
			goto a;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Remove Filtered Back Translations" item on the
/// Advanced menu is disabled if there are no source phrases in the App's m_pSourcePhrases
/// list, or the active KB pointer is NULL, otherwise the menu item is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedRemoveFilteredBacktranslations(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pKB != NULL && (int)pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAdvancedRemoveFilteredFreeTranslations(wxCommandEvent& WXUNUSED(event))
{
    // whm added 23Jan07 check below to determine if the doc has any free translations. If
    // not an information message is displayed saying there are no free translations; then
    // returns. Note: This check could be made in the OnIdle handler which could then
    // disable the menu item rather than issuing the info message. However, if the user
    // clicked the menu item, it may be because he/she though there might be one or more
    // free translations in the document. The message below confirms to the user the actual
    // state of affairs concerning any free translations in the current document.
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	bool bFTfound = FALSE;
	if (pDoc)
	{
		SPList* pList = pApp->m_pSourcePhrases;
		if (pList->GetCount() > 0)
		{
			SPList::Node* pos = pList->GetFirst();
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				if (pSrcPhrase->m_bHasFreeTrans)
				{
					// set the flag on the app
					bFTfound = TRUE; 
					break; // don't need to check further
				}
			}
		}
	}
	if (!bFTfound)
	{
		// there are no free translations in the document, 
		// so tell the user and return
		wxMessageBox(_(
		"The document does not contain any free translations."),
		_T(""),wxICON_INFORMATION);
		return;
	}

	// IDS_DELETE_ALL_FT_ASK
	int nResult = wxMessageBox(_(
"You are about to delete all the free translations in the document. Is this what you want to do?"),
	_T(""), wxYES_NO);
	if (nResult == wxNO)
	{
		// user clicked the command by mistake, so exit the handler
		return;
	}

	// initialize variables needed for the scan over the document's 
	// sourcephrase instances
	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* pos = pList->GetFirst();
	CSourcePhrase* pSrcPhrase;

	wxString mkr = _T("\\free"); // enough for standard or derived 
								 // backtranslation markers

    // do the loop, removing the free translations, their filter marker wrappers also, and
    // clearing the document's free translation flags on the CSourcePhrase instances
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();

		// clear the flags
		pSrcPhrase->m_bHasFreeTrans = FALSE;
		pSrcPhrase->m_bStartFreeTrans = FALSE;
		pSrcPhrase->m_bEndFreeTrans = FALSE;

		// handle removal from m_markers member
		if (pSrcPhrase->m_markers.IsEmpty())
		{
			continue;
		}
		else
		{
			int nFound = pSrcPhrase->m_markers.Find(mkr);
			if (nFound > 0)
			{
				// there is a filtered free translation section to be deleted
				RemoveContentWrappers(pSrcPhrase,mkr,nFound + 5); // + 5 to ensure 
															// pointing past \free
			}
		} // end block for non-empty m_markers
	} // end while loop
	Invalidate();
	GetLayout()->PlaceBox();

	// mark the doc as dirty, so that Save command becomes enabled
	pDoc->Modify(TRUE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Remove Filtered Free Translations" item on the
/// Advanced menu is disabled if there are no source phrases in the App's m_pSourcePhrases
/// list, or the active KB pointer is NULL, otherwise the menu item is enabled. 
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedRemoveFilteredFreeTranslations(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pKB != NULL && (int)pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

// when the phrase box lands at the anchor location, it may clear the m_bHasKBEntry flag,
// or the m_bHasGlossingKBEntry flag when glossing mode is on, and if there is an
// adaptation (or gloss) there when the phrase box is subsequently moved, we must make sure
// the flag has the appropriate value
void CAdapt_ItView::FixKBEntryFlag(CSourcePhrase* pSrcPhr)
{
	if (gbIsGlossing)
	{
		if (pSrcPhr->m_bHasGlossingKBEntry == FALSE)
		{
			// might be wrong value, so check and set it if necessary
			if (!pSrcPhr->m_gloss.IsEmpty())
			{
				// we need to reset it
				pSrcPhr->m_bHasGlossingKBEntry = TRUE;
			}
		}
	}
	else // we are in adapting mode
	{
		if (pSrcPhr->m_bHasKBEntry == FALSE)
		{
			// might be wrong value, so check and set it if necessary
			if (!pSrcPhr->m_targetStr.IsEmpty() && !pSrcPhr->m_bNotInKB)
			{
				// we need to reset it
				pSrcPhr->m_bHasKBEntry = TRUE;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
///
///		Functions for Notes support
///
/////////////////////////////////////////////////////////////////////////////////

void CAdapt_ItView::OnButtonCreateNote(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CPile* pPile = NULL;
	CSourcePhrase* pSrcPhrase = NULL;
	gnOldSequNum = pApp->m_nActiveSequNum; // save it, to be safe

    // create the note attached to the first sourcephrase of a selection if there is one,
    // else do it at the active location
	int nSequNum = -1;
	CCellList* pCellList;
	if (pApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of 
		// the selection list's first element
		pCellList = &pApp->m_selection;
		CCellList::Node* fpos = pCellList->GetFirst();
		pPile = fpos->GetData()->GetPile();
		if (pPile == NULL)
		{
			// unlikely, so an English message will do
			wxMessageBox(_T(
			"A zero pile pointer was returned, the note dialog cannot be put up."),
			_T(""), wxICON_EXCLAMATION);
			return;
		}
		wxASSERT(pPile != NULL);
		RemoveSelection(); // need Invalidate() to be called later on
	}
	else
	{
        // no selection, so just attach the note to whatever pile the caller sets up,
        // usually wherever the phraseBox currently is located; but in the case of free
        // translation mode being current, or a note in a retranslation, the caller may
        // calculate a different pile than the active one
		pPile = pApp->m_pActivePile;
		if (pPile == NULL)
		{
			// unlikely, so an English message will do
			wxMessageBox(_T(
			"A zero pile pointer was returned, the note dialog cannot be put up."),
			_T(""), wxICON_EXCLAMATION);
			return;
		}
	}
	pSrcPhrase = pPile->GetSrcPhrase(); // get the sourcephrase
	nSequNum = pSrcPhrase->m_nSequNumber; // get its sequence number
	wxASSERT(nSequNum >= 0);

    // set m_nSequNumBeingViewed, as the note dialog also uses it, not just the View
    // Filtered Material dialog (both dialogs cannot be open at the one time and so we can
    // safely use the one variable for the same purpose in the two functionalities)
	pApp->m_nSequNumBeingViewed = nSequNum;
	Invalidate();
	GetLayout()->PlaceBox();

	// open the dialog so the user can type in a note
	wxASSERT(pApp->m_pNoteDlg == NULL);
	pApp->m_pNoteDlg = new CNoteDlg(pApp->GetMainFrame()); 
    // whm using the ...ByClick form of the function here doesn't make sense to me unless
    // the user purposely clicks near the phrase box location of the note and avoids
    // scrolling afterwards positioning the phrasebox. AdjustDialogPositionByClick doesn't
    // appear to avoid the phrasebox location very well which I think is more important, so
    // I'm changing the call below to use AdjustDialogPosition() which better avoids the
    // phrasebox even with scrolling. (Bill didn't do what he said. I'll leave it.)
	AdjustDialogPositionByClick(pApp->m_pNoteDlg,gptLastClick); // avoid click location
	pApp->m_pNoteDlg->Show(TRUE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE this handler disables the "Open A Note dialog"
/// toolBar button: The application is only showing the target text, the active pile
/// pointer is NULL, a Note dialog is already open (the m_pNoteDlg is not NULL), if there
/// already is a note on the first source phrase of any selection, or if the targetBox is
/// not shown. Otherwise the toolbar button is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonCreateNote(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pNoteDlg != NULL)
	{
		// there already is a note dialog open, 
		// so we can't open another until it is closed
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
        // if the first sourcephrase in the selection does not have a note,
        // enable the button, but if it does then disable the button
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CPile* pPile = pos->GetData()->GetPile();
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
			if (pSrcPhrase->m_bHasNote)
			{
                // has a note already, so clicking this button is not the way
                // to open it - do it with the note icon in the layout instead
				event.Enable(FALSE);
				return;
			}
			else
			{
				// it's enabled only if the sourcephrase does not already have a note
				event.Enable(TRUE);
				return;
			}
		}
		event.Enable(TRUE);
		return;
	}
	if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
	{
		// if the phrase box is visible, then enable
		event.Enable(TRUE);
		return;
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonPrevNote(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();

    // is the note dialog open, if so - close it (and invoke the OK button's handler) it's
    // location defines the starting sequence number from which we look forward for the
    // next one -- but if the dialog is not open, then the phrase box's location is where
    // we start looking from
	int nJumpOffSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;
	if (pApp->m_pNoteDlg != NULL)
	{
        // the note dialog is still open, so save the note and close the dialog and reset
        // the jump off value to the pSrcPhase where the note was attached
		nJumpOffSequNum = pApp->m_nSequNumBeingViewed;
		wxCommandEvent oevent(wxID_OK);
		pApp->m_pNoteDlg->OnOK(oevent);
		pApp->m_pNoteDlg = NULL;
	}

	// find the previous note
	if (nJumpOffSequNum == 0)
		return; // can't go back if already at the start of the doc
	nJumpOffSequNum--; // jump origin
	JumpBackwardToNote_CoreCode(nJumpOffSequNum);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle 
///                        handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE this handler disables the "Jump To The Previous
/// Note" toolBar button: The App's m_bNotesExist flag is FALSE (there are no Notes to jump
/// to), The application is only showing the target text, the application is in free
/// translation mode, there is a selection current, or the targetBox is not being shown.
/// Otherwise the toolbar button is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonPrevNote(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (!pApp->m_bNotesExist)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
        // if there is a selection, then disable the button (doing the jump
        // and ignoring a selection might be confusing to some users)
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pNoteDlg != NULL)
	{
		// there is a note dialog open, but the button handler 
		// will close it before jumping
		event.Enable(TRUE);
	}
	if (pApp->m_pTargetBox != NULL && pApp->m_pTargetBox->IsShown()
		&& pApp->m_bNotesExist)
	{
		// if the phrase box is visible and there are notes 
		// in the document, then enable
		event.Enable(TRUE);
		return;
	}
	// otherwise disable
	event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonNextNote(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();

    // is the note dialog open, if so - close it (and invoke the OK button's handler) it's
    // location defines the starting sequence number from which we look forward for the
    // next one -- but if the dialog is not open, then the phrase box's location is where
    // we start looking from
	int nJumpOffSequNum = pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber;
	if (pApp->m_pNoteDlg != NULL)
	{
		// the note dialog is still open, so save the note and close the dialog
		// and reset the jump off value to the pSrcPhase where the note was attached
		nJumpOffSequNum = pApp->m_nSequNumBeingViewed;
		wxCommandEvent oevent(wxID_OK);
		pApp->m_pNoteDlg->OnOK(oevent);
		pApp->m_pNoteDlg = NULL;
	}

	// find the next note
	nJumpOffSequNum++;
	JumpForwardToNote_CoreCode(nJumpOffSequNum);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE this handler disables the "Jump To The Next Note"
/// toolBar button: The App's m_bNotesExist flag is FALSE (there are no Notes to jump to),
/// The application is only showing the target text, the application is in free translation
/// mode, there is a selection current, or the targetBox is not being shown. Otherwise the
/// toolbar button is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonNextNote(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (!pApp->m_bNotesExist)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_bFreeTranslationMode)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
		// if there is a selection, then disable the button (doing the jump
		// and ignoring a selection might be confusing to some users)
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pNoteDlg != NULL)
	{
		// there is a note dialog open, but the button handler 
		// will close it before jumping
		event.Enable(TRUE);
	}
	if (pApp->m_pTargetBox != NULL && pApp->m_pTargetBox->IsShown()
		&& pApp->m_bNotesExist)
	{
		// if the phrase box is visible and there are notes 
		// in the document, then enable
		event.Enable(TRUE);
		return;
	}
	// otherwise disable
	event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonDeleteAllNotes(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// IDS_ABOUT_TO_DELETE_NOTES
	if(wxMessageBox(_(
"You are about to cause all the notes in this document to be irreversibly deleted. Are you sure you want to do this?"),
	_T(""),wxYES_NO | wxICON_EXCLAMATION) == wxID_YES )
	{
		RemoveSelection();

		// close any open note
		if (pApp->m_pNoteDlg)
		{
			wxCommandEvent cevent(wxID_CANCEL);
			pApp->m_pNoteDlg->OnCancel(cevent);
			pApp->m_pNoteDlg = NULL;
		}

		// delete them all
		DeleteAllNotes(); // calls Invalidate() and PlaceBox() internally
		GetDocument()->Modify(TRUE);
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated by the app's Idle handler
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism whenever idle processing is enabled. If any
/// of the following conditions are TRUE this handler disables the "Delete All Notes"
/// toolBar button: The App's m_bNotesExist flag is FALSE (there are no Notes to jump to),
/// The application is only showing the target text, the active pile pointer is NULL.
/// Otherwise, if the targetBox is showing the toolbar button is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateButtonDeleteAllNotes(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (!pApp->m_bNotesExist)
	{
		event.Enable(FALSE);
		return;
	}
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown()
		&& pApp->m_bNotesExist)
	{
		// if the phrase box is visible and there are notes 
		// in the document, then enable
		event.Enable(TRUE);
		return;
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::MoveToAndOpenFirstNote()
{
    // is a note dialog open, if so - close it (and invoke the OK button's handler) it's
    // location defines the starting sequence number from which we look forward for the
    // next one -- but if the dialog is not open, then the phrase box's location is where
    // we start looking from
	CAdapt_ItApp* pApp = &wxGetApp();
	int nJumpOffSequNum = 0;
	if (pApp->m_pNoteDlg != NULL)
	{
		// the note dialog is still open, so save the note and close the dialog
		wxCommandEvent oevent(wxID_OK);
		pApp->m_pNoteDlg->OnOK(oevent);
		pApp->m_pNoteDlg = NULL;
	}
	JumpForwardToNote_CoreCode(nJumpOffSequNum);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return	        the sequence number of the pSrcPhase which has a note containing 
///                 the whole string (though white space between words may be different 
///                 in the matching up of the search string with the matched string), 
///                 or -1 if there was no matching string found
///
///	nCurrentlyOpenNote_SequNum	->	sequ num of the note dialog from which the search 
///	                                was initiated
///	searchStr					->	reference to the string the user typed in to be 
///	                                searched for
/// Remarks:
///	If it finds a matching string in a subsequent note, that location's sequence 
///	number is returned to the caller
/////////////////////////////////////////////////////////////////////////////////
int CAdapt_ItView::FindNoteSubstring(int nCurrentlyOpenNote_SequNum, 
							WordList*& pSearchList,int numWords, int& nStartOffset, 
							int& nEndOffset)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	int sn = nCurrentlyOpenNote_SequNum;
	sn++; // start looking from the next pSrcPhrase in the list

	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* pos;
	CSourcePhrase* pSrcPhrase;
	wxString noteContentStr;
	wxString noteMkr = _T("\\note");
	wxString noteEndMkr = noteMkr + _T('*');
	int curPos = -1;
	int curEndPos = -1;
	int nFoundSequNum = -1;

	// get the starting POSITION from which to commence the scan
	pos = pList->Item(sn); 
	wxASSERT(pos != NULL);

	// loop forward over the pSrcPhrase instances till once containing a note is found
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		sn = pSrcPhrase->m_nSequNumber; // update sn
		if ( (curPos = pSrcPhrase->m_markers.Find(noteMkr)) == -1)
		{
			// this sourcephrase instance contains no filtered note
			continue;
		}
		else
		{
			// this source phrase contains a note, so get the \note* endmarker
			// and remove the intervening content into noteContentStr
			curPos += 6; // point the offset to the first character 
						 // after the space after \note
			curEndPos = curPos;
			curEndPos = FindFromPos(pSrcPhrase->m_markers,noteEndMkr,curEndPos);
			if ( curEndPos == -1)
			{
				// no matching endmarker, so an ill-formed note - so ignore it
				continue;
			}
			else
			{
                // curEndPos is the offset pointing to \note*, which defines the end of the
                // content string and its trailing space - so we can now extract the
                // content
				noteContentStr = pSrcPhrase->m_markers.Mid(curPos, curEndPos - curPos);
				if (noteContentStr.IsEmpty())
				{
					// no content, so continue
					continue;
				}
				else
				{
					// Check out whether the search string is contained in the 
					// content string
					wxString aWord;
					WordList::Node* fpos = pSearchList->GetFirst();
					aWord = *fpos->GetData(); // get the first word in the passed in 
											  // search word list

                    // How we proceed depends on the number of words to be searched for.
                    // When searching just for a single word, a match anywhere in
                    // noteContentStr constitutes a successful Find(); but when searching
                    // for two or more words, the first word must match all the way up to
                    // the end of a content string's word, and then subsequent non-final
                    // search words must match whole words exactly, and the final search
                    // word must match the next content word from its beginning (but does
                    // not necessarily have to match all the character in the word) --
                    // since the multi-word match is complex, we will do it in a function
                    // which will return the offsets to the matched substring as well when
                    // the match succeeded
					int nFound;
					if (numWords == 1)
					{
						// do a simple Find() for the word
						nFound = noteContentStr.Find(aWord);
						if (nFound == -1)
						{
							// no match, so continue iterating the pSrcPhrase loop
							continue;
						}
						else
						{
							// it matched, so set the offsets to start and end locations
							int len = aWord.Length();
							nStartOffset = nFound;
							nEndOffset = nStartOffset + len;

							// get the sequ number for this pSrcPhrase which we need to 
							// return to the caller
							nFoundSequNum = sn;
							break;
						}
					}
					else
					{
                        // we have a multiword match requested... find matches for the
                        // first of the search word - (there could be more than one
                        // matching location)
						nFound = 0;
						while ( (nFound = FindFromPos(noteContentStr,aWord,nFound)) != -1)
						{
							// we found a match for the first word
							nStartOffset = nFound;

							// find out if the rest of the search string matches at 
							// this location
							bool bItMatches = DoesTheRestMatch(pSearchList,aWord,
												noteContentStr,nStartOffset,nEndOffset);
							if (!bItMatches)
							{
								// keep iterating when the whole search string was not
								// matched
								nFound++; // start from next character after 
										  // start of last match
								nStartOffset = -1;
								nEndOffset = -1;
								continue; // iterate within this inner loop, to find
                                          // another  matching location for the first
                                          // word of the search string
							}
							else
							{
                                // the whole lot matches, so we can break out after
                                // determining the sequence number for this location
								nFoundSequNum = sn;
								return nFoundSequNum;
							}
						}

						// there was no match for the whole search string
						nFoundSequNum = -1;
						continue; // iterate the outer loop which 
								  // scans pSrcPhrase instances
					} // end block for testing for a multi-word match
				} // end block for processing a non-empty noteContentStr
			} // end block for having found a matching \note* endmarker
		} // end block for pSrcPhrase contains a note
	} // end loop for scanning over the pSrcPhrase instances in m_pSourcePhrases
	return nFoundSequNum;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             TRUE if the user's typed string matches, FALSE if not
///
///	pSearchList		->	pointer to the list of words in the user's typed string, 
///                     as returned by repeated calls to Tokenize(), using whitespace
///                     characters for delimiters
///	firstWord		->	the first word in pSearchList - the caller will already have 
///	                    matched this one
///	noteStr			->	the full content of the note, as stored on the pSrcPhrase 
///	                    currently being examined and typically this string will end in 
///	                    a space (if the filtering was done right)
///	nStartOffset	<->	starting offset in noteStr for the already matched part 
///	                    (ie. firstWord)
///	nEndOffset		<-	ending offset (ie. the character immediately after the matched 
///	                    search string) for the match -- used  in conjunction with 
///	                    nStartOffset to enable the CNoteDlg code to later determine how 
///	                    much of noteStr to hightlight
/// \remarks
///    Uses some of the document's text parsing code. For multiword matches, only the first
///    and last of the passed in search words can be other than full-word matchups, the
///    first must at least match suffixally, and the last must at least match prefixally.
///    We don't care if the user has typed white space characters such as newline, carriage
///    return or tabs in noteStr, and only spaces in the search string - such white space
///    differences are ignored (which we expect is what the user would always want). The
///    returned offsets are used by the caller (ie. CNoteDlg) for highlighting purposes
///    when there was a successful match.
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::DoesTheRestMatch(WordList* pSearchList, wxString& firstWord, 
								wxString& noteStr, int& nStartOffset, int& nEndOffset)
{
	// get a str variable containing the rest, beginning at the start 
	// of the matched first word
	wxString str = noteStr.Mid(nStartOffset);
	int len = firstWord.Length();

    // if the first word match was just a prefix in a larger word, then we won't be able to
    // match any of the other search words, in which case return FALSE to the caller
	if ( (str[len] != _T(' ')) && (str[len] != _T('\n')) && 
		(str[len] != _T('\r')) && (str[len] != _T('\t')) )
	{
        // there is an alphabetic or numeric character at the next location, so we've just
        // matched a subpart of the word and that subpart does not extend to the word's
        // end, so we cannot match any of the other search words; this constitutes a
        // failure to match the whole search string
		return FALSE;
	}

	// we are okay so far, so now try to match the rest
	int buflen = noteStr.Length();
	const wxChar* pBuff = str.GetData();
	wxChar* pBufStart = (wxChar*)pBuff;
	wxChar* ptr = pBufStart + len; // start from where we've matched to so far 
								   // (it will be pointing at whitespace)
	wxChar* pEnd = pBufStart + buflen; // get the bound past which we must not go
	wxASSERT(*pEnd == _T('\0')); // whm added
	CAdapt_ItDoc* pDoc = GetDocument(); // we'll use the doc's functions 
										// IsWhiteSpace() and ParseWhiteSpace()
	WordList::Node* pos = pSearchList->GetFirst(); 
	wxString nextWord = *pos->GetData(); // we've already matched this one, 
										 // so the loop handles the rest
	pos = pos->GetNext();
	int nHowManyChars;
	int nWordNum = 1;
	int nLastWord = pSearchList->GetCount();
	int nTotalChars = len; // count the total characters spanned in getting the match
	while (pos != NULL)
	{
		// get the next search word, and its length
		nextWord = *pos->GetData();
		pos = pos->GetNext();
		len = nextWord.Length();
		nWordNum++; // count it

		// jump over any whitespace
		if (pDoc->IsWhiteSpace(ptr))
		{
			nHowManyChars = pDoc->ParseWhiteSpace(ptr);
			ptr += nHowManyChars;
			nTotalChars += nHowManyChars;
		}

        // are we at the end? If so, since we've not yet matched the search word, then we
        // would have failed to get a match and must return, otherwise, continue processing
		if (ptr == pEnd)
		{
			// MFC released noteStr which was error
			return FALSE;
		}

		// do we have a match for the contents of nextWord, starting at the ptr location?
		if (wxStrncmp(nextWord,ptr,len) == 0)
		{
			// the strings matched...
			// count what we just matched
			nTotalChars += len;
			ptr += len; // point to the character which 
						// immediately follows the matched word

            // if we are not dealing with the last word in the search list, then the match
            // must be a whole word match -- and if it isn't, we have failed & must return
            // FALSE, but if we *are* dealing with the last word, then a prefixal match is
            // sufficient for success
			if (nWordNum < nLastWord)
			{
				// this is not the last word needing to be matched, so check out it is a
				// whole-word match
				if (ptr == pEnd)
				{
					// we've an unmatched word or more to go, so this constitutes a failure
					// MFC released noteStr which was error
					return FALSE;
				}
				else if (!pDoc->IsWhiteSpace(ptr))
				{
                    // there is more of a word at the ptr location, so we only matched an
                    // initial substring, and so no further match is possible
					return FALSE;
				}
				else
				{
					// we had a whole-word match, hence so far so good, 
					// & we iterate the loop
					continue;
				}
			}
			else
			{
				// we are dealing with the last word, so we don't require a whole-word match
				// -- in fact, we are done & we have matched the whole search string typed
				// by the user (except there could be differences in whitespaces)
				break;
			}
		}
		else
		{
			// no match, so the total matchup has failed
			// MFC released noteStr which was error
			return FALSE;
		}
	} // end of word-matching loop

	// if we get here, then the whole search string has been matched
	nEndOffset = nStartOffset + nTotalChars; // set nEndOffset which is to be 
											 // returned to the caller
	return TRUE;
}

void CAdapt_ItView::MoveToAndOpenLastNote()
{
    // is a note dialog open, if so - close it (and invoke the OK button's handler) it's
    // location defines the starting sequence number from which we look backward for the
    // last one -- but if the dialog is not open, then the phrase box's location is where
    // we start looking from
	CAdapt_ItApp* pApp = &wxGetApp();
	int nJumpOffSequNum = pApp->GetMaxIndex();
	if (pApp->m_pNoteDlg != NULL)
	{
		// the note dialog is still open, so save the note and close the dialog
		wxCommandEvent event(wxID_OK);
		pApp->m_pNoteDlg->OnOK(event);
		pApp->m_pNoteDlg = NULL;
	}
	JumpBackwardToNote_CoreCode(nJumpOffSequNum);
}

void CAdapt_ItView::JumpForwardToNote_CoreCode(int nJumpOffSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame;
	wxTextCtrl* pEdit;

	// find the first note
	SPList::Node* pos; 
	SPList* pList = pApp->m_pSourcePhrases;
	pos = pList->Item(nJumpOffSequNum); 
	CSourcePhrase* pSrcPhrase = NULL;
	int nNoteSequNum = nJumpOffSequNum; // for iterating forward from the jump origin
	int nBoxSequNum;

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	// jump only if there is a possibility of a note being ahead
	if (nNoteSequNum <= pApp->GetMaxIndex())
	{
		// loop until the next note's pSrcPhrase is found
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetNext();
			if (pSrcPhrase->m_bHasNote)
				break;
			// return if at doc end without finding a note
			if (pos == NULL)
				return;
		}

		// store the adaptation in the KB before moving the phrase box
		wxASSERT(pApp->m_pActivePile); // the old value is still valid, and it's 
									   // pile has the old sourcephrase
		bool bOK;
		bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());

        // Otherwise, we have found one, so it can be opened. However, we have to exercise
        // care with the phrase box - if the note is in a retranslation while adaptation
        // mode is turned on, then we can't place the phrase box at the note location - the
        // best we can do is place it at a safe location outside the retranslation. We
        // implement these protocols below.

		// get the new value of nNoteSequNum from the located sourcephrase
		nNoteSequNum = pSrcPhrase->m_nSequNumber;
		nBoxSequNum = nNoteSequNum; // default, at least until we know it is not safe 
									// and adjust it
		if (pApp->m_bFreeTranslationMode)
		{
            // free translation mode is on, which limits the phrase box locations so
            // disallow the jump
			pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame);
			wxASSERT(&pFrame->m_pComposeBar);
			pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);

            // NOTE: the Update handler will prevent OnButtonNextNote() being entered when
            // in Free Translation mode, so control should never get here. But in case
            // someone changes things, moving to the next (or previous) note when in Fr.
            // Trans mode is bad news - because in that mode the phrase box location is
            // limited to the start of existing free trans sections, and in the part of the
            // doc which does not have free trans sections yet, to jump to a note location
            // would result in a free trans section being defined there - which is unlikely
            // to be what is wanted because notes can be anywhere and are unlikely to just
            // be at locations where we'd want a free translation to start. BEW comment
            // 18Oct06; actually control WILL get to here when the Find Next button is used
            // when in Free Trans mode, so here we trap it and prevent any mess from
            // happening

			// since we are in free translation mode, we want the focus to be in the
			// Compose Bar's edit box
			if (pApp->m_bFreeTranslationMode)
			{
				pEdit->SetFocus();
			}
			return; // do nothing else
		}
		else if (pSrcPhrase->m_bRetranslation && !gbIsGlossing)
		{
            // we are in adapting mode and the sourcephrase with the note lies within a
            // retranslation so the box location will end up different than the note
            // location, so set the note location (ie. its sequence number) since we
            // already know it
			pApp->m_nSequNumBeingViewed = nBoxSequNum; // the note dialog needs this 
													   // value to be correct
            // now work out where the active location (ie. phrase box) should be
			pApp->m_nActiveSequNum = nNoteSequNum;
			pApp->m_pActivePile = GetPile(nNoteSequNum);
			wxASSERT(pApp->m_pActivePile);

            // this 'active' location is invalid, because the phrase box can't be put in a
            // retranslation, so we'll try put the box before the retranslation, if not,
            // then after it
			CSourcePhrase* pSafeSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);
			if (pSafeSrcPhrase == NULL)
			{
				// not a safe place, so try after the retranslation
				pSafeSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);
				if (pSafeSrcPhrase == NULL)
				{
					// horrors! nowhere is safe - if so, just open it within 
					// the retranslation
					goto a;
				}
			}
			pSrcPhrase = pSafeSrcPhrase;
			pApp->m_nActiveSequNum = pSafeSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile);

			// now do the stuff common to all three of these possibilities
			goto a;
		}
		else
		{
            // there should be no restraint against us placing the box at the same location
            // as the note
			pApp->m_nActiveSequNum = nNoteSequNum;
			pApp->m_pActivePile = GetPile(nNoteSequNum);
			wxASSERT(pApp->m_pActivePile);
			pApp->m_nSequNumBeingViewed = pApp->m_nActiveSequNum; // note dialog needs this
																  // value be to correct
			// now do the stuff common to each of these above three possibilities
		} // end of block for not in a retranslation and not in free translation mode
	} // end of block for testing that a jump is possible

    // get the phrase box contents appropriate for the new location & handle the
    // possibility that the new active location might be a "<Not In KB>" one
a:	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
        // this ensures user has to explicitly type into the box and explicitly check the
        // checkbox if he wants to override the "not in kb" earlier setting at this
        // location
		pApp->m_bSaveToKB = FALSE;
		pApp->m_targetPhrase.Empty();
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
	}
	else
	{
		if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			pApp->m_targetPhrase = pSrcPhrase->m_adaption;
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			if (pApp->m_bCopySource)
			{
				pApp->m_targetPhrase = 
					CopySourceKey(pSrcPhrase,pApp->m_bUseConsistentChanges);
			}
			else
			{
				pApp->m_targetPhrase.Empty();
			}
		}
	}

	// remove the text from the KB, if refString is not null
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
								pSrcPhrase->m_key,pSrcPhrase->m_adaption);
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// recalculate the layout
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif

	// recalculate the active pile
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	// scroll the active location into view, if necessary
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	GetLayout()->m_docEditOperationType = default_op;

	// restore default button image, and m_bCopySourcePunctuation to TRUE
	wxCommandEvent event;
	OnButtonEnablePunctCopy(event);

	Invalidate(); // get Draw() done & phrase box shown
	GetLayout()->PlaceBox();

	// now put up the note dialog at the m_nSequNumBeingViewed location
	wxASSERT(pApp->m_pNoteDlg == NULL);
	pApp->m_pNoteDlg = new CNoteDlg(pApp->GetMainFrame());
	// wx version: we don't need the Create() call for modeless notes dialog
	AdjustDialogPosition(pApp->m_pNoteDlg); // show it lower, not at top left
	pApp->m_pNoteDlg->Show(TRUE);
}

void CAdapt_ItView::JumpBackwardToNote_CoreCode(int nJumpOffSequNum)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame;
	wxTextCtrl* pEdit;

	SPList::Node* pos;
	SPList* pList = pApp->m_pSourcePhrases;
	pos = pList->Item(nJumpOffSequNum);
	CSourcePhrase* pSrcPhrase = NULL;
	int nNoteSequNum = nJumpOffSequNum; // for iterating back from the jump origin
	int nBoxSequNum;

	// remove any selection to be safe from unwanted selection-related side effects
	RemoveSelection();

	// jump only if there is a possibility of a note being earlier
	if (nNoteSequNum > 0)
	{
		// loop until the previous note's pSrcPhrase is found
		while (pos != NULL)
		{
			pSrcPhrase = (CSourcePhrase*)pos->GetData();
			pos = pos->GetPrevious();
			if (pSrcPhrase->m_bHasNote)
				break;
			// if pos is NULL, no earlier one was found
			if (pos == NULL)
				return;
		}

		// store the adaptation in the KB before moving the phrase box
		wxASSERT(pApp->m_pActivePile); // the old value is still valid, and 
									   // it's pile has the old sourcephrase
		bool bOK;
		bOK = StoreBeforeProceeding(pApp->m_pActivePile->GetSrcPhrase());

        // Otherwise, we have found one, so it can be opened. However, we have to exercise
        // care with the phrase box - if the note is in a retranslation while adaptation
        // mode is turned on, then we can't place the phrase box at the note location -
        // the best we can do is place it at a safe location outside the retranslation.
        // We implement these protocols below.

		// get the new value of nNoteSequNum from the located sourcephrase
		nNoteSequNum = pSrcPhrase->m_nSequNumber;
		nBoxSequNum = nNoteSequNum; // default, at least until we know it is not safe 
									// and adjust it
		if (pApp->m_bFreeTranslationMode)
		{
            // free translation mode is on, which limits the phrase box locations so
            // disallow the jump
			pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame);
			wxASSERT(&pFrame->m_pComposeBar);
			pEdit = (wxTextCtrl*)pFrame->m_pComposeBar->FindWindowById(IDC_EDIT_COMPOSE);

            // NOTE: the Update handler will prevent OnButtonNextNote() being entered when
            // in Free Translation mode, so control should never get here. But in case
            // someone changes things, moving to the next (or previous) note when in Fr.
            // Trans mode is bad news - because in that mode the phrase box location is
            // limited to the start of existing free trans sections, and in the part of the
            // doc which does not have free trans sections yet, to jump to a note location
            // would result in a free trans section being defined there - which is unlikely
            // to be what is wanted because notes can be anywhere and are unlikely to just
            // be at locations where we'd want a free translation to start.

			// since we are in free translation mode, we want the focus to be in the
			// Compose Bar's edit box
			if (pApp->m_bFreeTranslationMode)
			{
				pEdit->SetFocus();
			}
			return; // do nothing else
		}
		else if (pSrcPhrase->m_bRetranslation && !gbIsGlossing)
		{
            // we are in adapting mode and the sourcephrase with the note lies within a
            // retranslation so the box location will end up different than the note
            // location, so set the note location (ie. its sequence number) since we
            // already know it
			pApp->m_nSequNumBeingViewed = nBoxSequNum; // the note dialog needs 
													   // this value to be correct
            // now work out where the active location (ie. phrase box location) should
            // be
			pApp->m_nActiveSequNum = nNoteSequNum;
			pApp->m_pActivePile = GetPile(nNoteSequNum);
			wxASSERT(pApp->m_pActivePile);

            // this 'active' location is invalid, because the phrase box can't be put in
            // a retranslation, so we'll try put the box after the retranslation, if not,
            // then before it
			CSourcePhrase* pSafeSrcPhrase = GetFollSafeSrcPhrase(pSrcPhrase);
			if (pSafeSrcPhrase == NULL)
			{
				// not a safe place, so try earlier than the retranslation
				pSafeSrcPhrase = GetPrevSafeSrcPhrase(pSrcPhrase);
				if (pSafeSrcPhrase == NULL)
				{
					// horrors! nowhere is safe - if so, just open it 
					// within the retranslation
					goto a;
				}
			}
			pSrcPhrase = pSafeSrcPhrase;
			pApp->m_nActiveSequNum = pSafeSrcPhrase->m_nSequNumber;
			pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
			wxASSERT(pApp->m_pActivePile);

			// now do the stuff common to all three of these possibilities
			goto a;
		}
		else
		{
            // there should be no restraint against us placing the box
            // at the same location as the note
			pApp->m_nActiveSequNum = nNoteSequNum;
			pApp->m_pActivePile = GetPile(nNoteSequNum);
			wxASSERT(pApp->m_pActivePile);
			pApp->m_nSequNumBeingViewed = pApp->m_nActiveSequNum; // the note
										// dialog needs this value to be correct
			// now do the stuff common to each of these above three possibilities
		} // end of block for not in a retranslation and not in 
		  // free translation mode
	} // end of block for testing that a jump is possible

    // get the phrase box contents appropriate for the new location & handle the
    // possibility that the new active location might be a "<Not In KB>" one
a:	if (!pSrcPhrase->m_bHasKBEntry && pSrcPhrase->m_bNotInKB)
	{
        // this ensures user has to explicitly type into the box and explicitly check
        // the checkbox if he wants to override the "not in kb" earlier setting at this
        // location
		pApp->m_bSaveToKB = FALSE;
		pApp->m_targetPhrase.Empty();
		pApp->m_pTargetBox->m_bAbandonable = TRUE;
	}
	else
	{
		if (!pSrcPhrase->m_adaption.IsEmpty())
		{
			pApp->m_targetPhrase = pSrcPhrase->m_adaption;
			pApp->m_pTargetBox->m_bAbandonable = FALSE;
		}
		else
		{
			pApp->m_pTargetBox->m_bAbandonable = TRUE;
			if (pApp->m_bCopySource)
			{
				pApp->m_targetPhrase = CopySourceKey(pSrcPhrase,
										pApp->m_bUseConsistentChanges);
			}
			else
			{
				pApp->m_targetPhrase.Empty();
			}
		}
	}
	// remove the text from the KB, if refString is not null
	CRefString* pRefString = GetRefString(GetKB(),pSrcPhrase->m_nSrcWords,
								pSrcPhrase->m_key,pSrcPhrase->m_adaption);
	RemoveRefString(pRefString,pSrcPhrase,pSrcPhrase->m_nSrcWords);

	// recalculate the layout
#ifdef _NEW_LAYOUT
	GetLayout()->RecalcLayout(pList, keep_strips_keep_piles);
#else
	GetLayout()->RecalcLayout(pList, create_strips_keep_piles);
#endif

	// recalculate the active pile
	pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);

	// scroll the active location into view, if necessary
	pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

	GetLayout()->m_docEditOperationType = default_op;

	// restore default button image, and m_bCopySourcePunctuation to TRUE
	wxCommandEvent event;
	OnButtonEnablePunctCopy(event);
	Invalidate();
	GetLayout()->PlaceBox();

	// now put up the note dialog at the m_nSequNumBeingViewed location
	wxASSERT(pApp->m_pNoteDlg == NULL);
	pApp->m_pNoteDlg = new CNoteDlg(pApp->GetMainFrame());
	// wx version: we don't need the Create() call for modeless notes dialog
	AdjustDialogPosition(pApp->m_pNoteDlg); // show it lower, not at top left
	pApp->m_pNoteDlg->Show(TRUE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return             nothing
///
/// Parameters:
///	pSrcPhrase		->	ref to pointer to the sourcephrase containing the filtered 
///	                    content
///	mkr				->	SF marker for the filtered material remnants to be removed
///	offset			->	offset, in the m_markers member string of the passed in 
///                     pSrcPhrase, to any character following the backslash of mkr, and
///                     preceding the backslash of any matching endmarker, or if there is
///                     no endmarker, then preceding the backslash of the closing \~FILTER*
///                     marker
/// Remarks:
///    Removes mkr, and matching endmarker, and their wrapping \~FILTER and \~FILTER*
///    markers, and any intervening content for this particular SF marker - which might be
///    nothing Used for removing \note remnants so far, but no doubt could be used
///    elsewhere -- yes, now used for removing free translations and / or back translations
///    too, and / or notes.
///
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::RemoveContentWrappers(CSourcePhrase*& pSrcPhrase, wxString mkr, 
										  int offset)
{
    // remove the marker remnants altogether, ie. markers and filter markers (the content
    // may, or may not, have already been removed
	wxString markers = pSrcPhrase->m_markers;

	// return if we have an invalid or bad offset to start from
	if (offset <= 0)
		return;

	int nStart = offset; // move back from this location to get to the start
	int nEnd = offset; // move forward from this location to get to the end
	int nFound;
	wxASSERT(nStart > 11);
	nStart--; // point at whatever precedes the mkr marker
	while (markers.GetChar(nStart) != _T('\\'))
	{
		nStart--;
	}
	// exits with nStart pointing at \ of the mkr
	nStart--; // point at whatever precedes it
	while (markers.GetChar(nStart) != _T('\\'))
	{
		nStart--;
	}
	// exits with nStart pointing at the preceding \~FILTER marker 
	// (which may be at buffer start)

	// now scan in the opposite direction, to get the end of what is to be removed
	nFound = FindFromPos(markers,_T('\\'),nEnd); // get the first backslash following 
												 // the passed in offset location
	wxASSERT(nFound >= 0); // there must be one
	nEnd = nFound; // put the nEnd offset there
	nEnd++; // point past the backslash of the marker - it could be an end marker, 
			// or if there is no endmarker it could be a \~FILTER* endmarker - so 
			// test for the latter
	if (markers.GetChar(nEnd) == _T('~'))
	{
		// there was no endmarker, we instead found \~FILTER*, so just scan over 
		// the end filter marker
		--nEnd; // put the offset back to precede the backslash

	}
	else
	{
		// there is an endmarker, so scan over it and the subsequent end filter marker
		while (markers.GetChar(nEnd) != _T('\\'))
		{
			nEnd++;
		}
		// exits with nEnd pointing at the following \~FILTER* marker
	}
	// now handle the \~FILTER* marker and trailing space
	wxString fltrEnd = filterMkrEnd;
	int lenFilterEnd = fltrEnd.Length();
	nEnd += lenFilterEnd + 1; // add one to count the trailing space after \~FILTER* 
							  // (it's always there)

	// remove the remnants and update m_markers
	markers.Remove(nStart, nEnd - nStart); //markers.Delete(nStart, nEnd - nStart);
	pSrcPhrase->m_markers = markers;

	// if pSrcPhrase has a flag for the marker being present, 
	// the caller should clear it
}

void CAdapt_ItView::DeleteAllNotes()
{
	CAdapt_ItApp* pApp = &wxGetApp();
	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* pos = pList->GetFirst();
	wxASSERT(pos != NULL);
	CSourcePhrase* pSrcPhrase;
	wxString noteMkr = _T("\\note");
	wxString noteEndMkr = noteMkr + _T('*');
	int curPos = -1;

	// do the deleting
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if ( (curPos = pSrcPhrase->m_markers.Find(noteEndMkr)) == -1)
		{
			// this sourcephrase instance contains no filtered note
			pSrcPhrase->m_bHasNote = FALSE; // ensure the flag agrees
			continue;
		}
		else
		{
            // this source phrase contains a note, or the wrappers for a note if the
            // content happens to have been removed; RemoveContentWrappers also removes
            // the content if it has not already been removed, as well as removing the
            // content's wrapping markers and filter markers
			RemoveContentWrappers(pSrcPhrase, noteMkr, curPos);
			pSrcPhrase->m_bHasNote = FALSE; // ensure the flag agrees
		}
	}
	Invalidate(); // get the view redrawn, so the note icons disappear too
	GetLayout()->PlaceBox();
}

void CAdapt_ItView::OnEditMoveNoteForward(wxCommandEvent& WXUNUSED(event))
{
    // Since the Move Note Forward menu item has an accelerator table hot key (CTRL-3 see
    // CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even when
    // they are disabled, we must check for a disabled button and return if disabled.
    // On Windows, the accelerator key doesn't appear to call the handler for a disabled
    // menu item, but I'll leave the following code here in case it works differently on
    // other platforms.
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_EDIT_MOVE_NOTE_FORWARD))
	{
		::wxBell();
		return;
	}

	CPile* pPile = NULL;
	SPList* pList = pApp->m_pSourcePhrases;
	CSourcePhrase* pSrcPhrase = NULL;

	// determine which pSrcPhrase has the note - if unable, return, doing nothing
	int nSequNum = -1;
	CCellList* pCellList;
	CCellList::Node* cpos;
	CCell* pCell;
	if (pApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of 
		// the selection list's first element
		pCellList = &pApp->m_selection;
		cpos = pCellList->GetFirst();
		pCell = cpos->GetData();
		pPile = pCell->GetPile();
		if (pPile == NULL)
		{
			// unlikely, so an English message will do
a:			wxMessageBox(_T(
"A zero pile pointer was returned, the sourcephrase with the note is indeterminate."),
			_T(""), wxICON_EXCLAMATION);
			return;
		}
		wxASSERT(pPile != NULL);
		RemoveSelection(); // need Invalidate() to be called later on
	}
	else
	{
		// no selection, so just assume the note is on the sourcephrase where 
		// the phrase box is
		pPile = pApp->m_pActivePile;
		if (pPile == NULL)
		{
			goto a;
		}
	}
	pSrcPhrase = pPile->GetSrcPhrase(); // get the sourcephrase
	nSequNum = pSrcPhrase->m_nSequNumber; // get its sequence number
	wxASSERT(nSequNum >= 0);

    // the update handler will enable the menu item only if there was an unopen note stored
    // on the first of any selected sourcephrases, or if no selection, then at the active
    // location, so we can here assume pSrcPhrase has a note - so next we need to remove it
    // (after storing its content), determine what the target sourcephrase is, then
    // re-establish the note there. We do this using a function call, because there may be
    // other situations where we'd want to reestablish the note at some other location
    // other than the immediate next sourcephrase, doing so under program control (eg.
    // moving the note several sourcephrases forward or back, so that a merger could be
    // done at what would otherwise have been a place where filtered material would be
    // merger-internal which is illegal).
	SPList::Node* tgtPos = pList->Item(nSequNum);
	wxASSERT(tgtPos != NULL);
	CSourcePhrase* pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
	tgtPos = tgtPos->GetNext();
	if (tgtPos == NULL)
	{
        // the update handler should disable the button to prevent this possibility, but
        // just in case we'll check for it and return silently if we can't move it forward
		return;
	}
	else
	{
        // the next sourcephrase exists, so put the note there - provided there is not
        // already a note there -- and if there is, then return without doing anything as
        // the update handler will have disabled the command anyway so we shouldn't ever
        // get into this handler in that case
		pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData();
		tgtPos = tgtPos->GetNext();
		wxASSERT(pTgtSrcPhrase != NULL); 
		if (!pTgtSrcPhrase->m_bHasNote)
		{
			// there is no note there yet
			MoveNote(pSrcPhrase,pTgtSrcPhrase);
			Invalidate();
			GetLayout()->PlaceBox();

            // BEW added 19Dec07: establish a selection at the new location in case the
            // user wishes to use accelerator key combination in order to move the note
            // further forward
			if (!gbShowTargetOnly)
			{
                // can do it only if showing source text and nav text whiteboard, (but
                // update handler blocks otherwise, but having this test documents things
                // better so we'll use it, though unnecessary)
				wxASSERT(pApp->m_selection.IsEmpty());
				int nNewSequNum = nSequNum + 1;
				CPile* pNewPile = GetPile(nNewSequNum);
				if (pNewPile == NULL)
				{
                    // this should not happen, but just in case, we will exit and not
                    // bother with trying to make a selection, as presumably the move has
                    // succeeded, so we'll let the user try again manually
					return;
				}
				else
				{
                    // the pile pointer is known, we can assume it is valid; we'll create
                    // the selection in the cell with index = 0
					pApp->m_selectionLine = gnSelectionLine = 0;
					CCell* pCell = pNewPile->GetCell(0);
					pApp->m_selection.Insert(pCell);
					pApp->m_pAnchor = pCell;
					pApp->m_curDirection = right;
					pApp->m_bSelectByArrowKey = FALSE;

					// draw the background yellow for the CCell we want shown selected
					wxClientDC aDC(pApp->GetMainFrame()->canvas); // get a temporary 
										// client device context for this view window
					aDC.SetBackgroundMode(pApp->m_backgroundMode);
					aDC.SetTextBackground(wxColour(255,255,0)); // yellow
					pCell->DrawCell(&aDC, GetLayout()->GetSrcColor());
					pCell->SetSelected(TRUE);
				}
			}
		}
		else
		{
			// shouldn't happen because update handler should disable
			// the command if there is already a note on pSrcPhrase
			;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed. The "Move Note Forward" item on the Edit menu is
/// disabled if any of the following conditions is TRUE: the application is showing only
/// the target text, the active pile pointer is NULL, a Note dialog is currently open (must
/// be closed first), the first source phrase of any selection already has a Note.
/// Otherwise, if there is a Note at the active location and there is an eligible source
/// phrase ahead to move to, the menu item is enabled, otherwise the menu item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditMoveNoteForward(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* tgtPos; 
	CSourcePhrase* pTgtSrcPhrase;
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pNoteDlg != NULL)
	{
		// there already is a note dialog open, 
		// so we can't move one until it is closed
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
        // if the first sourcephrase in the selection does not have a note,
        // enable the button, but if it does then disable the button
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CPile* pPile = ((CCell*)pos->GetData())->GetPile();
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
			if (pSrcPhrase->m_bHasNote)
			{
                // has a note, so it can be moved forward, provided there is something
                // forward to receive it and it does not already contain a note
				if (pSrcPhrase->m_nSequNumber < pApp->GetMaxIndex())
				{
					tgtPos = pList->Item(pSrcPhrase->m_nSequNumber); 
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
					tgtPos = tgtPos->GetNext();
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // this is the next
					tgtPos = tgtPos->GetNext();
					if (pTgtSrcPhrase->m_bHasNote)
					{
						// the next one already has a note, so disable the button
						event.Enable(FALSE);
					}
					else
					{
						// there is no note on the next one, so it can be a target instance
						event.Enable(TRUE); // more of the doc is ahead
					}
				}
				else
					event.Enable(FALSE); // at the end of the doc, so nothing is ahead
				return;
			}
			else
			{
				// doesn't have a note, so no move is possible here
				event.Enable(FALSE);
				return;
			}
		}
	}
	else
	{
		// check out if there is a note at the active location

		if (pApp->m_pTargetBox != NULL && pApp->m_pTargetBox->IsShown())
		{
            // enable the button only if there is a note at the active location and there
            // is at least one sourcephrase ahead to form the target one for the move
			CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
			if (pSrcPhrase->m_bHasNote)
			{
				if (pSrcPhrase->m_nSequNumber < pApp->GetMaxIndex())
				{
					// there is an instance ahead
					tgtPos = pList->Item(pSrcPhrase->m_nSequNumber); 
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
					tgtPos = tgtPos->GetNext();
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // this is the next
					tgtPos = tgtPos->GetNext();
					if (pTgtSrcPhrase->m_bHasNote)
					{
						// the next one already has a note, so disable the button
						event.Enable(FALSE);
					}
					else
					{
						// there is no note on the next one, so it can be a target instance
						event.Enable(TRUE); // more of the doc is ahead
					}
				}
				else
					event.Enable(FALSE); // at the end of the doc, so nothing is ahead
				return;
			}
			else
			{
				event.Enable(FALSE);
				return;
			}
		}
	}
	event.Enable(FALSE);
}

void CAdapt_ItView::OnEditMoveNoteBackward(wxCommandEvent& WXUNUSED(event))
{
    // Since the Move Note Backward menu item has an accelerator table hot key (CTRL-2 see
    // CMainFrame) and wxWidgets accelerator keys call menu and toolbar handlers even when
    // they are disabled, we must check for a disabled button and return if disabled.
    // On Windows, the accelerator key doesn't appear to call the handler for a disabled
    // menu item, but I'll leave the following code here in case it works differently on
    // other platforms.
	CAdapt_ItApp* pApp = &wxGetApp();
	CMainFrame* pFrame = pApp->GetMainFrame();
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	if (!pMenuBar->IsEnabled(ID_EDIT_MOVE_NOTE_BACKWARD))
	{
		::wxBell();
		return;
	}

	CPile* pPile = NULL;
	SPList* pList = pApp->m_pSourcePhrases;
	CSourcePhrase* pSrcPhrase = NULL;

	// determine which pSrcPhrase has the note - if unable, return, doing nothing
	int nSequNum = -1;
	CCellList* pCellList;
	CCellList::Node* cpos;
	if (pApp->m_selectionLine != -1)
	{
		// we have a selection, the pile we want is that of the selection list's 
		// first element
		pCellList = &pApp->m_selection;
		cpos = pCellList->GetFirst();
		pPile = ((CCell*)cpos->GetData())->GetPile();
		if (pPile == NULL)
		{
			// unlikely, so an English message will do
a:			wxMessageBox(_T(
"A zero pile pointer was returned, the sourcephrase with the note is indeterminate."),
			_T(""), wxICON_EXCLAMATION);
			return;
		}
		wxASSERT(pPile != NULL);
		RemoveSelection(); // need Invalidate() to be called later on
	}
	else
	{
		// no selection, so just assume the note is on the sourcephrase
		// where the phrase box is
		pPile = pApp->m_pActivePile;
		if (pPile == NULL)
		{
			goto a;
		}
	}
	pSrcPhrase = pPile->GetSrcPhrase(); // get the sourcephrase
	nSequNum = pSrcPhrase->m_nSequNumber; // get its sequence number
	wxASSERT(nSequNum >= 0);

    // the update handler will enable the menu item only if there was an unopen note stored
    // on the first of any selected sourcephrases, or if no selection, then at the active
    // location, so we can here assume pSrcPhrase has a note - so next we need to remove it
    // (after storing its content), determine what the target sourcephrase is, then
    // re-establish the note there. We do this using a function call, because there may be
    // other situations where we'd want to reestablish the note at some other location
    // other than the immediate previous sourcephrase, doing so under program control (eg.
    // moving the note several sourcephrases back, so that a merger could be done at what
    // would otherwise have been a place where filtered material would be merger-internal
    // which is illegal).
	SPList::Node* tgtPos = pList->Item(nSequNum); 
	wxASSERT(tgtPos != NULL);
	CSourcePhrase* pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
	tgtPos = tgtPos->GetPrevious();
	if (tgtPos == NULL)
	{
        // the update handler should disable the button to prevent this possibility, but
        // just in case we'll check for it and return silently if we can't move it backward
		return;
	}
	else
	{
        // the next sourcephrase exists, so put the note there - provided there is not
        // already a note there -- and if there is, then tell the user to first move that
        // note & return without doing anything
		pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData();
		tgtPos = tgtPos->GetPrevious();
		wxASSERT(pTgtSrcPhrase);
		if (!pTgtSrcPhrase->m_bHasNote)
		{
			// there is no note there yet
			MoveNote(pSrcPhrase,pTgtSrcPhrase);
			Invalidate();
			GetLayout()->PlaceBox();

            // BEW added 19Dec07: establish a selection at the new location in case the
            // user wishes to use accelerator key combination in order to move the note
            // further backward
			if (!gbShowTargetOnly)
			{
                // can do it only if showing source text and nav text whiteboard, (but
                // update handler blocks otherwise, but having this test documents things
                // better so we'll use it, though unnecessary)
				wxASSERT(pApp->m_selection.IsEmpty());
				int nNewSequNum = nSequNum - 1;
				CPile* pNewPile = GetPile(nNewSequNum);
				if (pNewPile == NULL)
				{
                    // this should not happen, but just in case, we will exit and not
                    // bother with trying to make a selection, as presumably the move has
                    // succeeded, so we'll let the user try again manually
					return;
				}
				else
				{
                    // the pile pointer is known, we can assume it is valid; we'll create
                    // the selection in the cell with index = 0 
					pApp->m_selectionLine = gnSelectionLine = 0;
					CCell* pCell = pNewPile->GetCell(0);
					pApp->m_selection.Insert(pCell);
					pApp->m_pAnchor = pCell;
					pApp->m_curDirection = left;
					pApp->m_bSelectByArrowKey = FALSE;

					// draw the background yellow for the CCell we want shown selected
					wxClientDC aDC(pApp->GetMainFrame()->canvas); // get a temporary client 
													// device context for this view window
					aDC.SetBackgroundMode(pApp->m_backgroundMode);
					aDC.SetTextBackground(wxColour(255,255,0)); // yellow
					pCell->DrawCell(&aDC, GetLayout()->GetTgtColor());
					pCell->SetSelected(TRUE);
				}
			}
		}
		else
		{
            // shouldn't happen because update handler should disable
            // the command if there is already a note on pSrcPhrase
			;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Edit Menu
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// The "Move Note Backward" item on the Edit menu is disabled if any of the following
/// conditions is TRUE: the application is showing only the target text, the active pile
/// pointer is NULL, a Note dialog is currently open (must be closed first), the first
/// source phrase of any selection already has a Note. Otherwise, if there is a Note at the
/// active location and there is an eligible source phrase previous to the current location
/// to move to, the menu item is enabled, otherwise the menu item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateEditMoveNoteBackward(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* tgtPos;
	CSourcePhrase* pTgtSrcPhrase;
	if (gbShowTargetOnly)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pActivePile == NULL)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pNoteDlg != NULL)
	{
		// there already is a note dialog open, so we can't move one until it is closed
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_selectionLine != -1)
	{
        // if the first sourcephrase in the selection does not have a note, enable the
        // button, but if it does then disable the button
		CCellList::Node* pos = pApp->m_selection.GetFirst();
		while (pos != NULL)
		{
			CPile* pPile = ((CCell*)pos->GetData())->GetPile();
			pos = pos->GetNext();
			CSourcePhrase* pSrcPhrase = pPile->GetSrcPhrase();
			if (pSrcPhrase->m_bHasNote)
			{
                // has a note, so it can be moved backwards, provided there is a
                // sourcephrase earlier to receive it and it does not already contain a
                // note
				if (pSrcPhrase->m_nSequNumber > 0)
				{
					tgtPos = pList->Item(pSrcPhrase->m_nSequNumber); 
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
					tgtPos = tgtPos->GetPrevious();
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // the previous one
					tgtPos = tgtPos->GetPrevious();
					if (pTgtSrcPhrase->m_bHasNote)
					{
						// the previous one already has a note, so disable the button
						event.Enable(FALSE);
					}
					else
					{
						// there is no note on the previous one, so it can be a 
						// target instance
						event.Enable(TRUE); // some of the doc is earlier
					}
				}
				else
					event.Enable(FALSE); // at the start of the doc, so nothing is earlier
				return;
			}
			else
			{
				// doesn't have a note, so no move is possible here
				event.Enable(FALSE);
				return;
			}
		}
	}
	else
	{
		// check out if there is a note at the active location

		if (pApp->m_pTargetBox->GetHandle() != NULL && pApp->m_pTargetBox->IsShown())
		{
            // enable the button only if there is a note at the active location and there
            // is at least one sourcephrase earlier to form the target one for the move
			CSourcePhrase* pSrcPhrase = pApp->m_pActivePile->GetSrcPhrase();
			if (pSrcPhrase->m_bHasNote)
			{
				if (pSrcPhrase->m_nSequNumber > 0)
				{
					// there is an instance backwards
					tgtPos = pList->Item(pSrcPhrase->m_nSequNumber);
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // abandon this one
					tgtPos = tgtPos->GetPrevious();
					pTgtSrcPhrase = (CSourcePhrase*)tgtPos->GetData(); // the earlier one
					tgtPos = tgtPos->GetPrevious();
					if (pTgtSrcPhrase->m_bHasNote)
					{
						// the previous one already has a note, so disable the button
						event.Enable(FALSE);
					}
					else
					{
						// there is no note on the previous one, so it can be a 
						// target instance
						event.Enable(TRUE); // some of the doc is earlier
					}
				}
				else
					event.Enable(FALSE); // at the start of the doc, 
										 // so nothing is earlier
				return;
			}
			else
			{
				event.Enable(FALSE);
				return;
			}
		}
	}
	event.Enable(FALSE);
}

// it is the caller's responsibility to determine which sourcephrase is to receive the
// note, and it must exist, and the sourcephrase passed in as pFromSrcPhrase must have a
// note (caller must bleed out any situations where this is not the case)
void CAdapt_ItView::MoveNote(CSourcePhrase* pFromSrcPhrase,CSourcePhrase* pToSrcPhrase)
{
	wxString noteMkr = _T("\\note");
	wxString noteEndMkr = noteMkr + _T('*');
	wxString noteStr;
	int noteOffset = 0;
	int noteLen = 0;
	int curPos = -1;
	if ( (curPos = pFromSrcPhrase->m_markers.Find(noteEndMkr)) == -1)
	{
		// this sourcephrase instance contains no filtered note, so just return
		return;
	}
	else
	{
		// this source phrase contains a note, or the wrappers for a note...
		// first determine that the target sourcephrase has no note,
		// since it is invalid to move note to such a one
		int nFound = pToSrcPhrase->m_markers.Find(_T("\\note*"));
		if (nFound > 0)
		{
            // it has a note, so do nothing (no message here, the GUI button's
            // handler has a test for this and disables the command if necessary,
            // but for programatic use of MoveNote, we want a silent return)
			return;
		}

		// get the note's content
		noteStr = GetExistingMarkerContent(noteMkr,noteEndMkr,pFromSrcPhrase,
											noteOffset,noteLen);

		// remove it and its wrappers
		RemoveContentWrappers(pFromSrcPhrase,noteMkr,curPos - 1); // -1 is not needed, 
																  // just ensures safety
		pFromSrcPhrase->m_bHasNote = FALSE; // ensure the flag is cleared 
											// on the old location

		// now create the note on the pToSrcPhrase instance
		int nInsertionOffset = 
			FindFilteredInsertionLocation(pToSrcPhrase->m_markers,noteMkr);
		bool bInsertContentOnly = FALSE; // need the whole lot done, 
										 // including wrapping filter markers
		InsertFilteredMaterial(noteMkr,noteEndMkr,noteStr,pToSrcPhrase,
								nInsertionOffset,bInsertContentOnly);
		pToSrcPhrase->m_bHasNote = TRUE;
	}
}

/////////////////////////////////////////////////////////////////////////////////
///
///	   Backtranslation Support
///
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// The "Collect Back Translations..." item on the Edit menu is enabled if the applicable
/// KB is not NULL and there are source phrases in the App's m_pSourcePhrases list,
/// otherwise the menu item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedCollectBacktranslations(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
	if (pApp->m_pKB != NULL && (int)pApp->m_pSourcePhrases->GetCount() > 0)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnAdvancedCollectBacktranslations(wxCommandEvent& WXUNUSED(event))
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CCollectBacktranslations dlg(pApp->GetMainFrame());
	dlg.Centre();
	if (dlg.ShowModal() == wxID_OK)
	{
		// user clicked the OK button
		DoCollectBacktranslations(dlg.m_bUseAdaptations);

		// mark the doc as dirty, so that Save command becomes enabled
		CAdapt_ItDoc* pDoc = GetDocument();
		pDoc->Modify(TRUE);
	}
	else
	{
		// user clicked the Cancel button, so do nothing
		;
	}
	Invalidate(); // get the view updated (so new icons (green wedges) get drawn)
	GetLayout()->PlaceBox();
}

/////////////////////////////////////////////////////////////////////////////////
///  GetPrevMarker
///
/// Returns:        TRUE if ptr scanned back to the backslash of an SF marker, 
///                 FALSE otherwise
///
/// Parameters:
///	pBuff		->	pointer to the start of the pSrcPhrase->m_markers buffer
///	ptr			<->	iterator, a reference to a pointer to TCHAR at which scanning 
///	                is to commence
///	mkrLen		<-	the length, in characters and including the backslash, of the
///					marker scanned (this parameter has no meaning if FALSE is returned)
/// Remarks:
///    When looking for a marker which is to halt collection of adaptations or glosses as
///    backtranslations, the markers we are interested in lie at or near the end of
///    pSrcPhrase->m_markers, except for endmarkers which (provided they are not filtered)
///    lie at the beginning of the string. So we want to start processing at the end of
///    m_markers, and iterate backwards to find the last marker; but in some circumstances
///    we may need to find the penultimate marker (eg. if the string ends with, say, \f \fr
///    or maybe \x \xr ). So this function may need to be called more than once on the one
///    m_markers string. We also return a count of consecutive non-space characters
///    traversed, so the caller can construct the marker just traversed over. The marker
///    may or may not be an endmarker, it's the caller's job to distinguish such
///    differences. The way GetPrevMarker is coded means that any numbers are ignored,
///    because when it exits TRUE, ptr will be pointing at the backslash of a marker, and
///    mkrLen will have its length (a space will follow).
///
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::GetPrevMarker(wxChar* pBuff,wxChar*& ptr,int& mkrLen)
{
	int nCount = 0;
	if (ptr > pBuff)
		ptr--;
	else
	{
		mkrLen = 0;
		return FALSE;
	}
	while (*ptr != _T('\\'))
	{
		if (*ptr == _T(' '))
			nCount = 0; // initialize the count when pointing at a space
		else
			nCount++; // count any non-space characters

		// is there room in the buffer to go back further?
		if (ptr > pBuff)
			ptr--;
		else
		{
			// we are at the start of the buffer, but we didn't find a marker
			// so return FALSE
			mkrLen = 0;
			return FALSE;
		}
	}

	// if we get here, we have not counted the backslash yet, so do so
	nCount++;
	mkrLen = nCount;
	return TRUE;
}

// a utility to return TRUE if pSrcPhrase contains a \bt or \bt-prefixed marker
bool CAdapt_ItView::ContainsBtMarker(CSourcePhrase* pSrcPhrase)
{
	wxString btMkr = _T("\\bt");
	int nFound = pSrcPhrase->m_markers.Find(btMkr);
	if (nFound >= 0)
	{
		// there is a marker which commences with the 
		// 3 characters \bt, so return TRUE
		return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
///  HaltCurrentCollection
///
/// Returns: TRUE if the passed in pSrcPhrase->m_markers string contains an unfiltered
///          marker which should halt collecting of the backtranslation text at the current
///          pSrcPhrase; FALSE if collecting should continue BEW modified 21Nov05 to
///          support collecting within the range of a selection by explicitly checking for
///          \bt and immediately returning TRUE if it is in m_markers
///
/// Parameters:
///	markers			->	the m_markers member of the current pSrcPhrase being examined
///	bFound_bt_mkr	<-	TRUE if the reason we halt is because \bt or derivative was 
///	                    encountered
///
/// Remarks:
///	Where the halt happens is also where the collection starts for the next subsection,
///	and the caller maintains a pointer to an earlier sourcephrase (pLastSrcPhrase) which
///	is where the just-finished collected backtranslation text is to be stored filtered in
///	its m_markers member.
///
///    We do the scanning for a marker to test by scanning backwards in m_markers. It is
///    done backwards because (a) filtered material, if present, will be earlier in
///    m_markers than at the end (and filtered material doesn't itself halt collecting -
///    except for a \bt or derived \bt marker, which must halt collection because a new
///    section commences at this CSourcePhrase instance), and (b) unfiltered markers define
///    the text type which is visible in the main window and the marker which does that
///    will typically be the last (unfiltered) one in m_markers.
///
///    Also, since from 02Nov06 we ignore footnotes, endnotes and cross references of any
///    kind, we can ignore any unfiltered endmarker in m_markers (that is, such markers
///    don't halt the collection process) - these markers would normally occur first in
///    initial position in m_markers, and could be such things as \f*, \fe (for PNG SF
///    set), \F (ditto), \x* -- all of which we want to ignore; but also endmarkers for
///    which the TextType is 'none' such as \k* etc (see AI_USFM.xml for others)
///
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::HaltCurrentCollection(CSourcePhrase* pSrcPhrase, 
										  bool& bFound_bt_mkr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// initialize
	bFound_bt_mkr = FALSE;
	int mkrLen = 0;
	wxString markers = pSrcPhrase->m_markers;
	int bufLen = markers.Length();

	// coming to an already existing \bt or derived \bt marker must immediately
	// halt collection, so that we don't encroach on the next collected section
	if (ContainsBtMarker(pSrcPhrase))
	{
		bFound_bt_mkr = TRUE;
		return TRUE;
	}

	CAdapt_ItDoc* pDoc = GetDocument();
	const wxChar* pBuff = markers.GetData();
	wxChar* pBufStart = (wxChar*)pBuff;
	wxChar* pEnd;
	pEnd = pBufStart + bufLen; // whm added
	wxASSERT(*pEnd == _T('\0')); // whm added
	wxChar* ptr = pBufStart;
	ptr += bufLen; // ptr starts at the end and scans backwards

	ptr = pBufStart + bufLen; // ptr starts at the end and scans backwards
	bool bGotMarkerOK = GetPrevMarker(pBufStart,ptr,mkrLen);
	if (!bGotMarkerOK)
	{
		return FALSE; // keep collecting
	}
	wxString mkr(ptr,mkrLen);
	wxASSERT(!mkr.IsEmpty());

	// return FALSE if it's an endmarker
	if ( mkr.Find(_T('*')) >= 0)
	{
		return FALSE; // keep collecting
	}

	// if it is an unknown marker, then it must halt collecting
	wxString mkrPlusEqual = mkr + _T('=');
	if (pApp->m_currentUnknownMarkersStr.Find(mkrPlusEqual) >= 0)
	{
		return TRUE; // halt
	}

	wxString bareMkr = pDoc->GetBareMarkerForLookup(ptr);
	wxASSERT(!bareMkr.IsEmpty());
	USFMAnalysis* pAnalysis = pDoc->LookupSFM(bareMkr);
	if (pAnalysis)
	{
		if (pAnalysis->textType == none || pAnalysis->inLine)
		{
			return FALSE; // keep collecting
		}
		else
		{
			// all other markers, whether filtered or not, should halt collecting
			return TRUE; // it halts collecting
		}
	}

	// we get here only if pAnalysis was not valid, so assume it should halt
	// -- this is the safest default for an unrecognized marker which is also
	// not listed as an unknown marker
	return TRUE;

}

/////////////////////////////////////////////////////////////////////////////////
///  InsertCollectedBacktranslation
///
/// Returns: nothing
///
/// Parameters:
///	pSrcPhrase	->	pointer to the sourcephrase instance which is to receive the
///					collected backtranslation string (filtered)
///	btStr		->	the just-collected backtranslation content which is to be stored
///                 filtered in the m_markers member of the passed in pSrcPhrase; if there
///                 is no backtranslation there already, it is wrapped with the appropriate
///                 markers first and then inserted, otherwise it replaces the content
///                 already there from an earlier collection operation
/// Remarks:
///	The comments above should suffice.
///
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::InsertCollectedBacktranslation(CSourcePhrase*& pSrcPhrase, 
												   wxString& btStr)
{
	wxString markers = pSrcPhrase->m_markers;
	wxString mkr = _T("\\bt");
	wxString endMkr = _T(""); // there are no backtranslation endmarkers
	wxString derivMkr; // to store derivative \bt markers, like \btv, etc, 
                // when checking which kind of backtranslation marker is
                // actually present on pSrcPhase

    // we first must find out whether there is an existing backtranslation in markers, and
    // if there is, is it just a \bt one (ie. standard), or is it a derived \bt marker such
    // as \btv or \bts1 etc. (Adapt It does not automatically insert derived ones, but if
    // they are already present due to (a) manual editing of the XML document, or (b)
    // imported from adaptation exported from another project, then Adapt It will try to
    // preserve them unchanged. Whenever it cannot be done, \bt will be used.
	int nFound = markers.Find(mkr);
	bool bInsertContentOnly;
	int nInsertionOffset;
	if (nFound == -1)
	{
        // there is no \bt marker, nor a derived one, in the markers string as yet - so we
        // will be inserting standard \bt marker plus its content and filter marker
        // wrappers

		// we may have other content in m_markers, so we have to first find the proper
		// insertion location
		nInsertionOffset = FindFilteredInsertionLocation(markers,mkr);

        // now build the total string and insert it all (final BOOL being FALSE
        // accomplishes the build of \~FILTER \bt <contents of btStr> \~FILTER* followed by
        // a single space, which is done internally (and it ensures that btStr ends in a
        // space too)
		bInsertContentOnly = FALSE;
		InsertFilteredMaterial(mkr,endMkr,btStr,pSrcPhrase,
								nInsertionOffset,bInsertContentOnly);
	}
	else
	{
		// there is either a standard \bt marker, or a derivative, present 
		// -- find out which it is
		derivMkr = WhichMarker(markers, nFound);

		// remove the existing content - it could be already empty though
		wxString oldBTStr;
		int nContentLen;
		oldBTStr = GetExistingMarkerContent(derivMkr,endMkr,pSrcPhrase,
											nInsertionOffset,nContentLen);
		pSrcPhrase->m_markers.Remove(nInsertionOffset,nContentLen);

		// now put in the new content at nInsertionOffset -- and note that the function
		// internally ensures that btStr ends in a space before it is inserted
		bInsertContentOnly = TRUE;
		InsertFilteredMaterial(derivMkr,endMkr,btStr,pSrcPhrase,
								nInsertionOffset,bInsertContentOnly);
	}
}

/////////////////////////////////////////////////////////////////////////////////
/// \return                 nothing
///
///	\param bUseAdaptationsLine	->	TRUE if m_targetStr is used for the collection, 
///	                                FALSE if m_gloss is used
///
/// \remarks
///    This function changes nothing in the GUI, so a message is put up to ask the user to
///    wait for the function to finish. It then scans all the pSrcPhrase instances in the
///    document's m_pSourcePhrases list, collecting the adaptation or gloss string from
///    each, until it comes to a halt location. Halt locations are determined by calling
///    HaltCurrentCollection() which looks at the passed in m_markers string to see if the
///    string ends in a marker which should halt collection, or begin with an endmarker
///    which should halt collection (such as \f* or \x*).
///
///    On 02Jan06 BEW changed the handling of footnotes and cross references to ignore
///    their CSourcePhrase instances in the collection process (by checking for footnote or
///    crossReference TextType); because these embedded information types should not be
///    part of any backtranslation collection.
///
///    At each halt location, the collected backtranslation string is wrapped with a \bt
///    marker and filter markers if there is no collected backtranslation already there,
///    and inserted; but if there is a prexisting filtered backtranslation there, then its
///    content is removed and just the newly collected backtranslation is inserted in its
///    place.
///    On 21Nov05 this algorithm was enhanced to optionally work with a selection. The
///    collection operation is confined to the selection range - and works as follows.
///	1.	If the first sourcephrase instance already has a filtered \bt (or derivative) marker,
///     the collection erases the content of this already-collected section, and the
///     collection replaces that section with the new content - which goes up to either the
///     end of the selection, or until a sourcephrase with a new \bt marker (or derivative)
///     is encountered. (Note, if the selection is not long enough, the collection may then
///     not include all that should be there - but that is the user's responsibility to
///     fix. He can check in the View Filtered Material dialog, and manually add the extra
///     words if he wishes.) (Also note, if the selection is long enough, more than one
///     back translation section may be defined before either the selection end is
///     encountered, or another \bt marker is reached.)
///	2.	If the first sourcephrase does not have a filtered \bt (or derivative) marker, then
///     a new back translation section is commenced at that location - and ends according
///     to the same criteria as in 1. above.
///     (Note, if the first source phrase follows shortly after one on which a back
///     translation is stored but occurs before the former one's extent ends, it is quite
///     possible for the one currently being collected to have overlapping content with the
///     former one. Again, this is the user's responsibility to check for and rectify if he
///     wishes, and the View Filtered material dialog is again the way to do it.)
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::DoCollectBacktranslations(bool bUseAdaptationsLine)
{
    // whm note: The process of collecting back translations is done so quickly that there
    // is probably no need for a wait or progress dialog. The user gets feedback by the
    // appearance of wedges appearing on the screen.
	CAdapt_ItApp* pApp = &wxGetApp();
	bool bSelectionExists = FALSE;
	SPList aList;	// list of selected CSourcePhrase objects, if any; else an alias for
					// the document's m_pSourcePhrases list
	SPList* pList = &aList;

	SPList* pDocPhrases = pApp->m_pSourcePhrases; // the document's list

	// determine if there is a selection, and get a list of the sourcephrase instances
	// in it if it exists
	if (pApp->m_selection.GetCount() > 0)
	{
        // collection only within a selection is wanted (and it doesn't matter if the
        // selection has text of different types, because the collection mechanism handles
        // that automatically)
		wxString unwantedSrcText; // need this because the following call returns
								  // strings we are not interested in
		wxString unwantedOtherText; // need this because the following call returns
								    // strings we are not interested in
		GetSelectedSourcePhraseInstances(pList, unwantedSrcText, unwantedOtherText);
		// pList is now populated with pointers to the selected sourcephrase instances

		bSelectionExists = TRUE;
	}
	else
	{
		// collection over the whole document is wanted, 
		// so set pList to the whole list
		pList = pDocPhrases;
	}

	// initialize variables needed for the scan over the document's 
	// sourcephrase instances
	wxString strCollect;
	wxString abit; // BEW added 26Nov05 because from gloss lines we can 
				   // collect copied ellipses, so exclude these
	SPList::Node* iteratorPos = pList->GetFirst(); 
	CSourcePhrase* pSrcPhrase;
	SPList::Node* savePos = iteratorPos; 
	bool bHalt;
	CSourcePhrase* pLastSrcPhrase = (CSourcePhrase*)iteratorPos->GetData();

	bool bHalted_at_bt_mkr = FALSE;
    // BEW addition 02Jan06: collecting ignores footnotes, endnotes & cross references of
    // any kind, so we must check if pLastSrcPhrase (which is where the collection is to be
    // stored) actually has either kind of TextType value. If so, we must advance
    // pLastSrcPhrase until it points to the first CSourcePhrase instance beyond the
    // footnote, endnote or cross reference. In the case of a selection, this potentially
    // might not be possible (if the user selects only footnote text for instance), so we
    // must allow for such a possibility. (Note, the footnote endmarker, or cross reference
    // endmarker, will be in m_markers on a CSourcePhrase instance which is not a footnote
    // or endmarker, but that won't be a problem because our halt conditions will not cause
    // a halt at any endmarker)
	if (pLastSrcPhrase->m_curTextType == footnote || 
		pLastSrcPhrase->m_curTextType == crossReference)
	{
		// we need to skip this material
		while (iteratorPos != NULL)
		{
			savePos = iteratorPos; // needed for next loop after this one
			pLastSrcPhrase = (CSourcePhrase*)iteratorPos->GetData();
			iteratorPos = iteratorPos->GetNext();
			if (pLastSrcPhrase->m_curTextType == footnote || 
				pLastSrcPhrase->m_curTextType == crossReference)
			{
				pLastSrcPhrase = NULL;
				continue; // skip it, try next one
			}
			else
			{
				// we have found one which we don't need to skip over
				break;
			}
		}
		if (pLastSrcPhrase == NULL)
		{
            // we got to the end of the list without finding one which was not a footnote,
            // endnote or free translation, so don't do any collection, just remove the
            // selection (if there is one) and return
			goto b;
		}
	}

    // do the loop, halting each collection at appropriate (unfiltered) SF markers (such as
    // the start of the next verse if no other marker was encountered beforehand) and store
    // the resulting collection at the starting place for this particular part of the
    // collection (ie. at pLastSrcPhrase instance).
	// BEW changed 02Jan06 to have the code ignore instances with TextType of footnote or 
	// crossReference
	bHalted_at_bt_mkr = FALSE;
	iteratorPos = savePos; // restore POSITION for the pLastSrcPhrase instance, 
						   // which is to start the loop
	while (iteratorPos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)iteratorPos->GetData();
		iteratorPos = iteratorPos->GetNext();

		// skip any footnote or cross reference instances
		if (pSrcPhrase->m_curTextType == footnote || 
			pSrcPhrase->m_curTextType == crossReference)
			continue;

		if (pSrcPhrase == pLastSrcPhrase)
		{
			// we are just starting the next section, so don't try to halt, 
			// just start collecting
			abit = bUseAdaptationsLine ? pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
			if (abit == _T("..."))
				abit.Empty();
			strCollect = abit;
		}
		else
		{
            // pSrcPhrase has advanced past pLastSrcPhrase, so we must check for halt
            // condition as we do the collecting
			if (pSrcPhrase->m_markers.IsEmpty())
			{
				// an empty m_markers means no halt is possible at this pSrcPhrase, so
				// do the collection and then iterate
				if (strCollect.IsEmpty())
				{
					abit = bUseAdaptationsLine ? 
									pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
					if (abit == _T("..."))
						abit.Empty();
					strCollect = abit;
				}
				else
				{
					abit = bUseAdaptationsLine ? 
									pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
					if (abit == _T("..."))
					{
						abit.Empty();
					}
					else
					{
						strCollect += _T(' ');
						strCollect += abit;
					}
				}
			}
			else
			{
				bHalt = HaltCurrentCollection(pSrcPhrase,bHalted_at_bt_mkr);
				if (bHalt)
				{
					// do the insertion
					InsertCollectedBacktranslation(pLastSrcPhrase, strCollect);

					// prepare for collection in the next document section
					pLastSrcPhrase = pSrcPhrase;
					strCollect.Empty();

                    // collect this one's content before iterating, because
                    // iteratorPos is already pointing at the next POSITION
					strCollect = bUseAdaptationsLine ? 
										pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;

					if (bSelectionExists && bHalted_at_bt_mkr)
					{
						// we don't collect any further within the selection, 
						// even if not at its end
						goto b;
					}
				}
				else
				{
					// collect here
					if (strCollect.IsEmpty())
					{
						abit = bUseAdaptationsLine ? 	
										pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
						if (abit == _T("..."))
							abit.Empty();
						strCollect = abit;
					}
					else
					{
						abit = bUseAdaptationsLine ? 
										pSrcPhrase->m_targetStr : pSrcPhrase->m_gloss;
						if (abit == _T("..."))
						{
							abit.Empty();
						}
						else
						{
							strCollect += _T(' ');
							strCollect += abit;
						}
					}
				}
			} // end block for non-empty m_markers
		} // end block for pSrcPhrase advanced past pLastSrcPhrase
	} // end while loop

	// do the final insertion
	wxASSERT(pLastSrcPhrase);
	InsertCollectedBacktranslation(pLastSrcPhrase, strCollect);

	// remove the selection, if there is one
b:	if (bSelectionExists)
		RemoveSelection();
}

/////////////////////////////////////////////////////////////////////////////////
///  WhichMarker
///
/// Returns: the full marker (including backslash) which is at the passed in location
///
/// Parameters:
///	markers		->	the pSrcPhrase->m_markers string being checked for which kind 
///					of backtranslation marker was found by the caller
///	nAtPos		->	character offset to the backslash at the beginning of the marker, 
///					the marker might be a standard \bt one, or a derived one like \btv etc; 
///					but the function will return whatever marker is there - so it is not 
///                 limited to backtranslation support
/// Remarks:
///	Comments above say it all. The function assumes and relies on there being a space
/// following whatever marker it is
///
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::WhichMarker(wxString& markers, int nAtPos)
{
	wxString mkr;
	int curPos = nAtPos;
	wxChar ch;
	ch = markers.GetChar(curPos);
	wxASSERT(ch == _T('\\'));
	mkr += ch;
	curPos++;
	while ((ch = markers.GetChar(curPos)) != _T(' '))
	{
		mkr += ch;
		curPos++;
	}
	return mkr;
}

void CAdapt_ItView::OnAdvancedRemoveFilteredBacktranslations(wxCommandEvent& WXUNUSED(event))
{
    // whm added 23Jan07 check below to determine if the doc has any back translations. If
    // not an information message is displayed saying there are no back translations; then
    // returns. Note: This check could be made in the OnIdle handler which could then
    // disable the menu item rather than issuing the info message. However, if the user
    // clicked the menu item, it may be because he/she though there might be one or more
    // back translations in the document. The message below confirms to the user the actual
    // state of affairs concerning any back translations in the current document.
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = GetDocument();
	bool bBTfound = FALSE;
	if (pDoc)
	{
		SPList* pList = pApp->m_pSourcePhrases;
		if (pList->GetCount() > 0)
		{
			SPList::Node* pos = pList->GetFirst();
			while (pos != NULL)
			{
				CSourcePhrase* pSrcPhrase = (CSourcePhrase*)pos->GetData();
				pos = pos->GetNext();
				if (!pSrcPhrase->m_markers.IsEmpty())
				{
					if (pSrcPhrase->m_markers.Find(_T("\\bt")) != -1)
					bBTfound = TRUE; 
					break; // don't need to check further
				}
			}
		}
	}
	if (!bBTfound)
	{
		// there are no free translations in the document, so tell the user and return
		wxMessageBox(_(
		"The document does not contain any back translations."),
		_T(""),wxICON_INFORMATION);
		return;
	}

	// IDS_DELETE_ALL_BT_ASK
	if( wxMessageBox(_(
"You are about to delete all the back translations in the document. Is this what you want to do?"),
	_T(""), wxYES_NO|wxICON_INFORMATION) == wxNO)
	{
		// user clicked the command by mistake, so exit the handler
		return;
	}

	// initialize variables needed for the scan over the document's 
	// sourcephrase instances
	SPList* pList = pApp->m_pSourcePhrases;
	SPList::Node* pos = pList->GetFirst(); 
	CSourcePhrase* pSrcPhrase;
	wxString mkr = _T("\\bt"); // enough for standard or derived 
							   // backtranslation markers
	// do the loop, halting to store each collection at appropriate (unfiltered) 
	// SF markers
	while (pos != NULL)
	{
		pSrcPhrase = (CSourcePhrase*)pos->GetData();
		pos = pos->GetNext();
		if (pSrcPhrase->m_markers.IsEmpty())
		{
			continue;
		}
		else
		{
			int nFound = pSrcPhrase->m_markers.Find(mkr);
			if (nFound > 0)
			{
				// there is a filtered backtranslation section to be deleted
				RemoveContentWrappers(pSrcPhrase,mkr,nFound + 3); // + 3 to 
													// ensure pointing past \bt
			}
		} // end block for non-empty m_markers
	} // end while loop
	Invalidate();
	GetLayout()->PlaceBox();

	// mark the doc as dirty, so that Save command becomes enabled
	pDoc->Modify(TRUE);
}

/////////////////////////////////////////////////////////////////////////////////
/// \return         TRUE if there is a \free marker in m_markers of pSrcPhrase, but with 
///			        no content; else returns FALSE (and it also returns FALSE if there  
///                 is no \free marker present)
///
///	\param pSrcPhrase	->	pointer to the CSourcePhrase instance whose m_markers 
///					        member may or may not contain a free translation (filtered)
/// \remarks
///    Used by the CCell.cpp Draw() function to control the colouring of the "green" wedge;
///    if a free translation field is empty, the wedge will display khaki, if a
///    backtranslation field is empty it will display a pastel blue, if both are empty it
///    will display red -- the alternate colouring idea was suggested by John Nystrom in
///    order to give the user visual feedback about when a \free or \bt field has no
///    content, so he can enter it manually or by other means; a companion function to this
///    present one is IsBackTranslationContentEmpty(), which works similarly but for a \bt
///    or \bt derived marker's field.
///
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsFreeTranslationContentEmpty(CSourcePhrase* pSrcPhrase)
{
	int offset;
	int length;
	wxString mkr = _T("\\free");
	wxString endMkr = _T("\\free*");

	// determine there is a free translation there first
	// - exit FALSE if there is none
	int curPos = pSrcPhrase->m_markers.Find(mkr);
	if (curPos == -1)
		return FALSE; // no \free is present, so we cannot claim 
					  // it is empty of content

	// there is a \free marker present, so determine its content
	wxString contentStr = GetExistingMarkerContent(mkr,endMkr,pSrcPhrase,
													offset,length);

	// trim any spaces - since these are included in what the 
	// GetExistingMarkerContent call returns
	contentStr.Trim(FALSE); // trim left end
	contentStr.Trim(TRUE); // trim right end

	// if there were only spaces, then the field is contentless 
	// & so return TRUE, else FALSE
	return contentStr.IsEmpty();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return         TRUE if there is a \bt or \bt derivative marker in m_markers of 
///			        pSrcPhrase, but with no content, else returns FALSE (and it also 
///			        returns FALSE if there is no \bt or \bt derivative marker present)
///
/// Parameters:
///	pSrcPhrase	->	pointer to the CSourcePhrase instance whose m_markers member
///					may or may not contain a back translation (filtered)
///
/// Remarks:
///    Used by the CCell.cpp Draw() function to control the colouring of the "green" wedge;
///    if a free translation field is empty, the wedge will display khaki, if a
///    backtranslation field is empty it will display a pastel blue, if both are empty it
///    will display red -- the alternate colouring idea was suggested by John Nystrom in
///    order to give the user visual feedback about when a \free or \bt field has no
///    content, so he can enter it manually or by other means; a companion function to this
///    present one is IsFreeTranslationContentEmpty(), which works similarly but for a
///    \free field.
///
/////////////////////////////////////////////////////////////////////////////////
bool CAdapt_ItView::IsBackTranslationContentEmpty(CSourcePhrase* pSrcPhrase)
{
	int offset;
	int length;
	wxString mkr = _T("\\bt");
	wxString endMkr = _T(""); // back translations do not have endmarkers

	// determine there is a free translation there first 
	// - exit FALSE if there is none
	int curPos = pSrcPhrase->m_markers.Find(mkr);
	if (curPos == -1)
		return FALSE; // no \bt or \bt derived marker is present, so we 
					  // cannot claim it is empty of content

	// there is a \bt or a marker which is a derivative of \bt present, 
	// so determine its content
	wxString contentStr = GetExistingMarkerContent(mkr,endMkr,pSrcPhrase,
													offset,length);

	// trim any spaces - since these are included in what the 
	// GetExistingMarkerContent call returns
	contentStr.Trim(FALSE); // trim left end
	contentStr.Trim(TRUE); // trim right end

	// if there were only spaces, then the field is contentless 
	// & so return TRUE, else FALSE
	return contentStr.IsEmpty();
}

//////////////////////////// End backtranslation support /////////////////////////////

bool CAdapt_ItView::PrecedingWhitespaceHadNewLine(wxChar* pChar, wxChar* pBuffStart)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	wxASSERT(pDoc != NULL);
	wxChar* ptr = pChar;
	ptr--; // back up one char in buffer
	while (ptr >= pBuffStart && pDoc->IsWhiteSpace(ptr))
	{
		if (*ptr == _T('\n'))
		{
			return TRUE;
		}
		ptr--;
	}
	return FALSE;
}

void CAdapt_ItView::GetMarkerInventoryFromCurrentDoc()
{
	// Scans all the doc's source phrase m_markers members and inventories
	// all the markers used in the current document, storing all unique
	// markers in m_exportBareMarkers, the full markers and their descriptions
	// in the CStringArray called m_exportMarkerAndDescriptions, and their
	// corresponding include/exclude states (boolean flags) in the
	// CUIntArray called m_exportFilterFlagsBeforeEdit. A given marker may occur
	// more than once in a given document, but is only stored once in these
	// inventory arrays.
	// All the boolean flags in the m_exportFilterFlagsBeforeEdit array
	// are initially set to FALSE indicating that no markers are to be
	// filtered out of the export by default. If the user accesses and/or
	// changes the export options via the "Export/Filter Options" dialog
	// and thereby filters one or markers from export, then their
	// corresponding flags in the CUIntArray called m_exportFilterFlags
	// will be set to TRUE.

	// Any sfms that are currently filtered are listed with [FILTERED] prefixed
	// to the description. Unknown markers are listed with [UNKNOWN MARKER] as
	// their description. We list all markers that are used in the document, and
	// if the user excludes things illogically, then the output will reflect
	// that.
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	SPList* pList = pApp->m_pSourcePhrases;
	wxArrayString MarkerList;	// gets filled with all the currently
							    // used markers including filtered ones
	wxArrayString* pMarkerList = &MarkerList;
	SPList::Node* posn;
	USFMAnalysis* pSfm;
	wxString key;
	wxString lbStr;

	MapSfmToUSFMAnalysisStruct* pSfmMap;
	pSfmMap = pApp->GetCurSfmMap(pApp->gCurrentSfmSet);

	// Gather markers from all source phrase m_markers strings
	posn = pList->GetFirst();
	wxASSERT(posn != NULL);
	CSourcePhrase* pSrcPhrase = (CSourcePhrase*)posn->GetData();
	//posn = posn->GetNext();
	// whm 27Nov07 modification: The above GetNext() line causes the
	// function to skip the first pSrcPhrase - there is the possibility 
	// that a \note, \bt and \free markers could reside in the first 
	// source phrase position, so I've commented out the extra GetNext
	// line from GetMarkerInventoryFromCurrentDoc() so that it now
	// includes the first source phrase in the inventory.
	wxASSERT(pSrcPhrase);
	while (posn != 0)
	{
		pSrcPhrase = (CSourcePhrase*)posn->GetData();
		posn = posn->GetNext();
		wxASSERT(pSrcPhrase);
		// retrieve sfms used from pSrcPhrase->m_markers
		if (!pSrcPhrase->m_markers.IsEmpty())
		{
            // GetMarkersAndTextFromString() retrieves each marker and its associated
            // string and places them in the CStringList. Any Filtered markers are stored
            // as a list item bracketed by \~FILTER ... \~FILTER* markers.
			// To avoid a large CStringList developing we'll process the markers in each
			// m_markers string individually, so empty the list.
			pMarkerList->Clear();
			pDoc->GetMarkersAndTextFromString(pMarkerList, pSrcPhrase->m_markers);

			wxString resultStr;
			resultStr.Empty();
			wxString displayStr;
			wxString bareMarker;
			wxString temp;
			int ct;
			for (ct = 0; ct < (int)pMarkerList->GetCount(); ct++)
			{
				resultStr = pMarkerList->Item(ct);
				bool markerIsFiltered;
				if (resultStr.Find(filterMkr) != -1)
				{
					resultStr = pDoc->RemoveAnyFilterBracketsFromString(resultStr);
					markerIsFiltered = TRUE;
				}
				else
				{
					markerIsFiltered = FALSE;
				}
				resultStr.Trim(FALSE); // trim left end
				resultStr.Trim(TRUE); // trim right end
				wxASSERT(resultStr.Find(gSFescapechar) == 0);
				int strLen = resultStr.Length();
				int posm = 1; // skip initial backslash
				bareMarker.Empty();
				displayStr.Empty();
				while (posm < strLen && resultStr[posm] != _T(' ') && 
						resultStr[posm] != gSFescapechar)
				{
					bareMarker += resultStr[posm];
					posm++;
				}
				bareMarker.Trim(FALSE); // trim left end
				bareMarker.Trim(TRUE); // trim right end

				// do not include end markers in this inventory
				int aPos = bareMarker.Find(_T('*'));
				if (aPos == (int)bareMarker.Length() -1)
					bareMarker.Remove(aPos,1);
				wxASSERT(bareMarker.Length() > 0);
				// lookup the marker in the active USFMAnalysis struct map
                // whm ammended 11Jul05 Here we want to use the LookupSFM() routine which
                // treats all \bt... initial back-translation markers as known markers all
                // under the \bt marker with its description "Back-translation"
                // whm revised again 14Nov05. For output filtering purposes, we need to
                // treat all \bt... initial forms the same as simple \bt, in order to give
                // the user the placement options (boxed paragraphs or footnote format for
                // sfm RTF output; new table row or footnote format for interlinear RTF
                // output). Handling all backtranslation the same for the sake of these
                // placement options I think is preferable to not having the placement
                // options and being able to filter from output the possible different
                // kinds of backtranslation \bt... markers. Therefore here we will make all
                // \bt... be just simple \bt and hence only have \bt in the export options
                // list box. I've also renamed the \bt marker's description in AI_USFM.xml
                // file to read: "Back Translation (and all \bt... initial forms)".
				if (bareMarker.Find(_T("bt")) == 0)
				{
					bareMarker = _T("bt"); // make any \bt... initial forms be just 
										   // \bt in the listbox
				}
				pSfm = pDoc->LookupSFM(bareMarker); // use LookupSFM which properly 
													// handles \bt... forms as \bt
				bool bFound = pSfm != NULL;
				lbStr = _T(' '); // prefix one initial space - looks better 
								 // in a CCheckListBox
				lbStr += gSFescapechar; // add backslash
				// Since LookupSFM will find any back-translation marker of the form
				// bt... we'll use the actual bareMarker to build the list box string
				lbStr += bareMarker;
                // We don't worry about adjusting for text extent here - that is done below
                // in FormatMarkerAndDescriptionsStringArray(). Here we will just add a
                // single space as delimiter between the whole marker and its description
				lbStr += _T(' ');
				if (!bFound)
				{
					// unknown marker so make the description [UNKNOWN MARKER]
					// IDS_UNKNOWN_MARKER
					temp = _("[UNKNOWN MARKER]"); // prefix description 
												  // with "[UNKNOWN MARKER]"
					lbStr = lbStr + temp;
				}
				else
				{
					if (markerIsFiltered)
					{
						// IDS_FILTERED
						temp = _("[FILTERED]"); // prefix description 
												// with "[FILTERED] ..."
						lbStr += temp;
						lbStr += _T(' ');
						lbStr += pSfm->description;
					}
					else
					{
						lbStr += pSfm->description;
					}
				}
				// Have we already stored this marker?
				bool mkrAlreadyExists = FALSE;
				for (int ct = 0; ct < (int)m_exportMarkerAndDescriptions.GetCount(); ct++)
				{
					if (lbStr == m_exportMarkerAndDescriptions[ct])
					{
						mkrAlreadyExists = TRUE;
						break;
					}
				}
				if (!mkrAlreadyExists)
				{
					// BEW addition 16Aug09, to exclude \note, \bt and/or \free markers
					// when exporting either free translations or glosses as text
					if (pApp->m_bExportingFreeTranslation || pApp->m_bExportingGlossesAsText)
					{
						if (bareMarker == _T("note") || 
							bareMarker == _T("free") ||
							bareMarker == _T("bt"))
						{
							continue; // ignore any of these marker types
						}
						else
						{
							// anything else gets added to the inventory
							m_exportBareMarkers.Add(bareMarker);
							m_exportMarkerAndDescriptions.Add(lbStr);
							m_exportFilterFlags.Add(FALSE);
							m_exportFilterFlagsBeforeEdit.Add(FALSE); 
						}
					}
					else
					{
						m_exportBareMarkers.Add(bareMarker);
						m_exportMarkerAndDescriptions.Add(lbStr);
						m_exportFilterFlags.Add(FALSE); // export defaults to nothing 
														// filtered out
						m_exportFilterFlagsBeforeEdit.Add(FALSE); // export defaults to 
																  // nothing filtered out
					}
				}
			}
		}
	}
	wxClientDC dC(pApp->GetMainFrame()->canvas);
	pApp->FormatMarkerAndDescriptionsStringArray(&dC,
							&m_exportMarkerAndDescriptions, 2, NULL);
	// last parameter in call above is 2 spaces min 
	// between whole marker and its description
}

wxString CAdapt_ItView::GetWholeMarkerFromString(wxString mkrStr, int nBeginPos)
{
	// expects mkrStr to have a backslash prefixed marker at 
	// nBeginPos in the string
	wxString tempStr = mkrStr;
	int pos = FindFromPos(tempStr,_T(' '),nBeginPos);
	tempStr = tempStr.Mid(nBeginPos,pos - nBeginPos);
	return tempStr;
}

wxString CAdapt_ItView::GetAssocTextWithoutMarkers(wxString mkrStr)
{
	// expects mkrStr to have a backslash prefixed marker at the beginning
	// of the string and possibly a corresponding end marker
	wxString tempStr = mkrStr;
	// remove whitespace at beginning or end
	wxString wholeMkr = GetWholeMarkerFromString(tempStr,0);
	wxString endMarker = wholeMkr + _T('*');
	// remove initial marker
	tempStr = tempStr.Mid(wholeMkr.Length()); // get the part after 
											  // initial marker and space
#ifndef _USE_OLD_CALLS
	tempStr.Trim();
#else
	tempStr = pApp->Trim(tempStr);
#endif
	// remove any end marker
	int endPos = tempStr.Find(endMarker);
	if (endPos != -1)
	{
		// mkrStr has a corresponding end marker
		tempStr = tempStr.Left(endPos);
	}
	return tempStr;
}

bool CAdapt_ItView::MarkerTakesAnEndMarker(wxString bareMarkerForLookup, 
										   wxString& wantedEndMkr)
{
	CAdapt_ItApp* pApp = &wxGetApp();
	CAdapt_ItDoc* pDoc = pApp->GetDocument();
	USFMAnalysis* pSfm;
	MapSfmToUSFMAnalysisStruct* pSfmMap;
	pSfmMap = pApp->GetCurSfmMap(pApp->gCurrentSfmSet);
	pSfm = pDoc->LookupSFM(bareMarkerForLookup); // use LookupSFM which 
								// properly handles \bt... forms as \bt
	wantedEndMkr.Empty();
	if (pSfm != NULL && !pSfm->endMarker.IsEmpty())
	{
		wantedEndMkr = pSfm->endMarker;
		return TRUE;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Tools Menu 
///                        is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// The "SIL Converters..." item on the Edit menu is enabled on a Windows port if the
/// ECDriver.dll is loaded and SIL Converters is installed on the local machine,
/// otherwise the menu item is disabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateSelectSilConverters(wxUpdateUIEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
    // Only enable the SILConverters menu item if we're building for SIL Converters
    // and SIL Converters is installed on the local machine.
	if (!pApp->bECDriverDLLLoaded)
	{
		event.Enable(FALSE);
		return;
	}
#ifdef USE_SIL_CONVERTERS
	// whm added 30Dec08 for SIL Converters support
	typedef int (wxSTDCALL *wxECIsInstalledType)();
	wxECIsInstalledType pfnECisInstalled = (wxECIsInstalledType)NULL;
    // whm Note: The IsEcInstalled() function in ECDriver.dll does not have
    // A and W forms so we must call GetSymbol() instead of GetSymbolAorW() here.
	pfnECisInstalled = (wxECIsInstalledType)
					ecDriverDynamicLibrary.GetSymbol(FUNC_NAME_EC_IS_INSTALLED);
	
	event.Enable(pfnECisInstalled != NULL && pfnECisInstalled() == TRUE);
#else
	event.Enable(FALSE); // don't enable the menu item if we're not using SIL Converters
#endif
}

void CAdapt_ItView::OnSelectSilConverters(wxCommandEvent& event)
{
	CAdapt_ItApp* pApp = &wxGetApp();
    // bring up the SilConverter select dialog to allow 
    // the user to pick a converter
    CSilConverterSelectDlg dlg
    (
    pApp->m_strSilEncConverterName,
    pApp->m_bSilConverterDirForward,
    pApp->m_eSilConverterNormalizeOutput,
    pApp->GetMainFrame()
    );

    if( dlg.ShowModal() == wxID_OK )
    {
        // save these values in the app, so they get written to the 
        //project settings file (i.e. to be retentive across program launches)
        pApp->m_strSilEncConverterName = dlg.ConverterName;
		if (dlg.DirectionForward == 0)
			pApp->m_bSilConverterDirForward = FALSE;
		else
			pApp->m_bSilConverterDirForward = TRUE;
        pApp->m_eSilConverterNormalizeOutput = dlg.NormalizeOutput;

        // if no converter configured, then turn off the 'use' if it was on
        // (NOTE: this is the equivalent of "Unload")
        if( dlg.ConverterName.IsEmpty() )
        {
	        CMainFrame *pFrame = pApp->GetMainFrame();
			wxASSERT(pFrame != NULL);
			wxMenuBar* pMenuBar = pFrame->GetMenuBar();
			wxASSERT(pMenuBar != NULL);
			wxMenuItem * pToolsMenuUseSilConverter = 
									pMenuBar->FindItem(ID_USE_SILCONVERTER);
			wxASSERT(pToolsMenuUseSilConverter != NULL);

		    // toggle the checkmark to OFF
		    pToolsMenuUseSilConverter->Check(FALSE);
		    pApp->m_bUseSilConverter = FALSE;
            return;
        }
        else if( pApp->m_bUseSilConverter )
        {
            // otherwise, if it *was* being used before, then reset it now 
            // (to trigger the not-in-use check below (which in turn triggers 
            // the reevaluation of the source word))
            OnUseSilConverter(event);
        }

        // if it isn't on, then make it on. This causes the current word to 
        // be re-run thru the converter
        if( !pApp->m_bUseSilConverter )
        {
            OnUseSilConverter(event);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////
/// \return     a wxString representing the input str after it is modified by the  
///             action of the SIL Converter; or a null/empty str if str was initially  
///             empty or if the SILConverter could not be found
/// \param      str     -> the wxString to be processed by an SIL Converter
/// \remarks
/// Called from: the View's CopySourceKey() and DoTargetBoxPaste() functions.
/// Calls the configured SilConverter to pre-process the data and return the result to 
/// the caller. First, DoSilConvert() sets up a function pointer to use in accessing the
/// appropriate form of the EncConverterInitializeConverter() function in the external
/// ECDriver.dll. It calls that function and returns an empty string if the converter
/// initialization fails, otherwise the function proceeds to set up a function pointer to
/// use in accessing the appropriate form of the EncConverterConvertString() function in
/// ECDriver.dll. If calls that function to process the input string str by the external
/// SIL Converter; then returns the result. If the str input string was originally a null
/// string, DoSilConvert() simply returns a null string.
/////////////////////////////////////////////////////////////////////////////////
wxString CAdapt_ItView::DoSilConvert(const wxString& str)
{
#ifdef USE_SIL_CONVERTERS
	CAdapt_ItApp* pApp = &wxGetApp();
	// whm added 30Dec08 for SIL Converters support
	typedef int (wxSTDCALL *wxECInitConverterType)(const wxChar*,int,int);
	wxECInitConverterType pfnECInitializeConverterAorW = (wxECInitConverterType)NULL;
	// whm Note: The EncConverterInitializeConverter() function in ECDriver.dll only 
	// has A and W forms so we must call GetSymbolAorW() instead of GetSymbol() here.
	pfnECInitializeConverterAorW = (wxECInitConverterType)
		ecDriverDynamicLibrary.GetSymbolAorW(FUNC_NAME_EC_INITIALIZE_CONVERTER_AW);
    
	if (!pApp->m_bECConnected && pfnECInitializeConverterAorW != NULL)
        pApp->m_bECConnected = (pfnECInitializeConverterAorW(pApp->m_strSilEncConverterName, 
			pApp->m_bSilConverterDirForward, pApp->m_eSilConverterNormalizeOutput) == S_OK);
    
	if (!pApp->m_bECConnected)
		return _T("");

    // whm Note: I assume Bob's EncConverterConvertString() function is internally limited
    // to a 1000 TCHAR length. Therefore I've made a local copy of the incoming string
    // "str" and check its length, and truncate if at 1000 char if it happens to exceed
    // that length - to avoid any buffer overrun problems.
	wxString tempStr = str;
	if (tempStr.Length() > 1000)
		tempStr.Mid(0,1000);
	
	// whm added 30Dec08 for SIL Converters support
	typedef int (wxSTDCALL *wxECConvertStringType)(const wxChar*,const wxChar*,
													wxChar*,int);
	wxECConvertStringType pfnECConvertStringAorW = (wxECConvertStringType)NULL;
	// whm Note: The EncConverterConvertString() function in ECDriver.dll only has 
	// A and W forms so we must call GetSymbolAorW() instead of GetSymbol() here.
	pfnECConvertStringAorW = (wxECConvertStringType)
		ecDriverDynamicLibrary.GetSymbolAorW(FUNC_NAME_EC_CONVERT_STRING_AW);

	TCHAR szOutput[1001];
	szOutput[0] = NULL; // whm added
	if (pfnECConvertStringAorW != NULL)
		pfnECConvertStringAorW(pApp->m_strSilEncConverterName, tempStr, szOutput, 1000);
	return szOutput;
#else
	int strlen;
	strlen = str.Length(); // to avoid "unreferenced formal parameter" warning
	return _T("");
#endif // end of if USE_SIL_CONVERTERS
}

void CAdapt_ItView::OnAdvancedUseTransliterationMode(wxCommandEvent& WXUNUSED(event))
{
	// toggle the mode on or off
	CAdapt_ItApp* pApp = (CAdapt_ItApp*)&wxGetApp();
	wxASSERT(pApp != NULL);

	CMainFrame *pFrame = pApp->GetMainFrame();
	wxASSERT(pFrame != NULL);
	wxMenuBar* pMenuBar = pFrame->GetMenuBar();
	wxASSERT(pMenuBar != NULL);
	wxMenuItem * pToolsMenuUseUseTransLMode = 
						pMenuBar->FindItem(ID_ADVANCED_USETRANSLITERATIONMODE);
	wxASSERT(pToolsMenuUseUseTransLMode != NULL);

	if (pApp->m_bTransliterationMode)
	{
		// toggle the checkmark to OFF
		pToolsMenuUseUseTransLMode->Check(FALSE);
		pApp->m_bTransliterationMode  = FALSE;
	}
	else
	{
		// toggle the checkmark to ON
		pToolsMenuUseUseTransLMode->Check(TRUE);
		pApp->m_bTransliterationMode = TRUE;
	}

	// update status bar information
	pApp->RefreshStatusBarInfo();

	// restore focus to the phrase box (free translations cannot be on for this mode)
	if (pApp->m_pTargetBox != NULL)	
		if (pApp->m_pTargetBox->IsShown())
			pApp->m_pTargetBox->SetFocus();
}

/////////////////////////////////////////////////////////////////////////////////
/// \return		nothing
/// \param      event   -> the wxUpdateUIEvent that is generated when the Advanced  
///                        Menu is about to be displayed
/// \remarks
/// Called from: The wxUpdateUIEvent mechanism when the associated menu item is selected,
/// and before the menu is displayed.
/// The "Use Transliteration Mode" item on the Advanced menu is disabled if any of the
/// following conditions are TRUE: the build/port does not support SIL Converters, the KB
/// is not ready, there are no source phrases in the App's m_pSourcePhrases list, the
/// application is in free translation mode or glossing mode. Otherwise, if the
/// m_strSilEncConverterName string has a name loaded, the menu item is enabled.
/////////////////////////////////////////////////////////////////////////////////
void CAdapt_ItView::OnUpdateAdvancedUseTransliterationMode(wxUpdateUIEvent& event)
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(FALSE);
		return;
	}
#ifdef USE_SIL_CONVERTERS
	CAdapt_ItApp* pApp = &wxGetApp();
	// toggle the mode on or off
    // whm 15Aug06 added && !pApp->m_strSilEncConverterName.IsEmpty() condition
    // to disable the menu item unless a SIL converter is loaded
	if (pApp->m_bKBReady && pApp->m_pSourcePhrases->GetCount() > 0 && 
		!pApp->m_bFreeTranslationMode && !gbIsGlossing && 
		!pApp->m_strSilEncConverterName.IsEmpty()) // whm 15Aug06 added 
						// the !pApp->m_strSilEncConverterName.IsEmpty() condition
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
#else
	event.Enable(FALSE); // don't enable the menu item if 
						 // we're not using SIL Converters
#endif
}

void CAdapt_ItView::OnUpdateButtonNextStep(wxUpdateUIEvent& event) 
{
	if (gbVerticalEditInProgress)
	{
		event.Enable(TRUE);
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonNextStep(wxCommandEvent& WXUNUSED(event)) 
{
	int sequNum = -1; // value not needed
	bool bCustomMessageSent;
	bCustomMessageSent = VerticalEdit_CheckForEndRequiringTransition(
												sequNum,nextStep,TRUE);
	// no need to use returned BOOL value; TRUE means "force transition"
}

void CAdapt_ItView::OnUpdateButtonPrevStep(wxUpdateUIEvent& event) 
{
	if (gbVerticalEditInProgress)
	{
		if (gEditStep == adaptationsStep && gbAdaptBeforeGloss)
		{
			event.Enable(FALSE); // don't permit rollback to the 
                    // edit source text dialog, instead the user should cancel the whole
                    // process and reselect & do Edit Source Text command again
			return;
		}
		else if (gEditStep == glossesStep && !gbAdaptBeforeGloss)
		{
			event.Enable(FALSE); // don't permit rollback to the 
                    // edit source text dialog, instead the user should cancel the whole
                    // process and reselect & do Edit Source Text command again
			return;
		}
		else if (gEditRecord.nNewSpanCount == 0)
		{
			event.Enable(FALSE); // don't permit rollback at all 
                    // if the user deleted all the CSourcePhrase instances he 
                    // selected for editing using the Edit Source Text dialog
			return;
		}
		else
		{
			event.Enable(TRUE);
			return;
		}
	}
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonPrevStep(wxCommandEvent& WXUNUSED(event)) 
{
	int sequNum = -1; // value not needed
	bool bCustomMessageSent;
	bCustomMessageSent = VerticalEdit_CheckForEndRequiringTransition(sequNum,
														previousStep,TRUE);
	// no need to use returned BOOL value; TRUE means "force transition"
}

void CAdapt_ItView::OnUpdateButtonEndNow(wxUpdateUIEvent& event) 
{
	if (gbVerticalEditInProgress)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonEndNow(wxCommandEvent& WXUNUSED(event)) 
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// instead of calling VerticalEdit_CheckForEndRequiringTransition(),
	// just post the required message immediately
	wxCommandEvent eventCustom(wxEVT_End_Vertical_Edit);
	wxPostEvent(pApp->GetMainFrame(), eventCustom); // the event handlers 
													// are in CMainFrame
}

void CAdapt_ItView::OnUpdateButtonCancelAllSteps(wxUpdateUIEvent& event) 
{
	if (gbVerticalEditInProgress)
		event.Enable(TRUE);
	else
		event.Enable(FALSE);
}

void CAdapt_ItView::OnButtonCancelAllSteps(wxCommandEvent& WXUNUSED(event)) 
{
	CAdapt_ItApp* pApp = &wxGetApp();
	// instead of calling VerticalEdit_CheckForEndRequiringTransition(),
	// just post the required message immediately
	wxCommandEvent eventCustom(wxEVT_Cancel_Vertical_Edit);
	wxPostEvent(pApp->GetMainFrame(), eventCustom); // the event handlers 
													// are in CMainFrame
}

void CAdapt_ItView::OnUpdateButtonUndoLastCopy(wxUpdateUIEvent& event) 
{
	// in the next test we don't require that gOldEditBoxTextStr be non-empty,
	// so that the button can replace with an empty string too 
	CAdapt_ItApp* pApp = &wxGetApp();
	if (gbVerticalEditInProgress)
	{
		if (pApp->m_pActivePile->GetSrcPhrase()->m_nSequNumber == gnWasSequNum &&
			pApp->m_pActivePile->GetSrcPhrase()->m_nSrcWords == gnWasNumWordsInSourcePhrase
			&& gbWasFreeTranslationMode == pApp->m_bFreeTranslationMode &&
			gbIsGlossing == gbWasGlossingMode)
		{
			event.Enable(TRUE);
		}
		else
		{
			event.Enable(FALSE);
		}
	}
	else
	{
		event.Enable(FALSE);
	}
}

void CAdapt_ItView::OnButtonUndoLastCopy(wxCommandEvent& WXUNUSED(event)) 
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxPanel* pBar;
	pBar = GetBar(Vert_Edit_ComposeBar);
	wxASSERT(pBar != NULL);
	wxTextCtrl* pTextBox;
	pTextBox = (wxTextCtrl*)pBar->FindWindowById(IDC_EDIT_COMPOSE);
	wxASSERT(pTextBox != NULL);

    // if free translation mode is current, then copy the contents of the
    // gOldEditBoxTextStr CString to the CEdit in the ComposeBar; otherwise,
    // copy it to the phrase box, because the update handler has already
    // determined the needed conditions are satisfied
	wxString theText = gOldEditBoxTextStr;
	gOldEditBoxTextStr.Empty();
	if (pApp->m_bFreeTranslationMode)
	{
		if (pTextBox == NULL)
		{
			wxMessageBox(_T(
"OnButtonUndoLastCopy error, compose bar's wxTextCtrl pointer is null; copy not done."),
			_T(""), wxICON_EXCLAMATION);
			gnWasSequNum = -1;
			gnWasNumWordsInSourcePhrase = 0;
			gbWasGlossingMode = FALSE;
			gbWasFreeTranslationMode = FALSE;
			return;
		}
		pTextBox->ChangeValue(theText); // change the string in the 
										// wxTextCtrl in the compose bar
		long len = theText.Len();
		pTextBox->SetSelection(len,len);
		pTextBox->SetFocus();
		pApp->GetMainFrame()->SendSizeEvent(); // forces the CMainFrame::SetSize() handler
											   // to run and do the needed redraw
		// **TODO** have the free translation text displayed under the active section
		// updated to comply with the change of free translation that has just happened
	}
	else
	{
		pApp->m_pTargetBox->ChangeValue(_T("")); // clear current box contents

		// if auto capitalization is on, determine the source text's 
		// case properties
		bool bNoError = TRUE;
		if (gbAutoCaps)
		{
			bNoError = SetCaseParameters(
				pApp->m_pActivePile->GetSrcPhrase()->m_key); // bIsSrcText is TRUE
			if (bNoError && gbSourceIsUpperCase && !gbMatchedKB_UCentry)
			{
				bNoError = SetCaseParameters(theText,FALSE); // testing the non-source text
				if (bNoError && !gbNonSourceIsUpperCase && (gcharNonSrcUC != _T('\0')))
				{
					// a change to upper case is called for
					theText.SetChar((long)0,gcharNonSrcUC);
				}
			}
		}
		pApp->m_targetPhrase = theText;

		// the box may be bigger because of the text, so do a recalc of the layout
#ifdef _NEW_LAYOUT
		GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, keep_strips_keep_piles);
#else
		GetLayout()->RecalcLayout(pApp->m_pSourcePhrases, create_strips_keep_piles);
#endif
        // recalculate the active pile pointer
		pApp->m_pActivePile = GetPile(pApp->m_nActiveSequNum);
		wxASSERT(pApp->m_pActivePile != NULL);

		// do a scroll if needed
		pApp->GetMainFrame()->canvas->ScrollIntoView(pApp->m_nActiveSequNum);

		// place cursor at end of the inserted text
		long length = theText.Len();
		pApp->m_nEndChar = length;
		pApp->m_nStartChar = length;

		// restore focus to the targetBox, if it is visible, 
		// and make non-abandonable
		if (pApp->m_pTargetBox != NULL)
		{
			if (pApp->m_pTargetBox->IsShown())
			{
				pApp->m_pTargetBox->SetFocus();
				pApp->m_pTargetBox->m_bAbandonable = FALSE;
			}
		}
		Invalidate();
		GetLayout()->PlaceBox();
	}

	// give bad values to the state-recording variables to ensure the 
	// Undo Last Copy button will be disabled after the Undo is completed
	gnWasSequNum = -1;
	gnWasNumWordsInSourcePhrase = 0;
	gbWasGlossingMode = FALSE;
	gbWasFreeTranslationMode = FALSE;
}

/////////////////////////////////////////////////////////////////////////////////
// Some material used by wxWidgets version below
/////////////////////////////////////////////////////////////////////////////////

// Clean up windows used for displaying the view. - from docview sample
bool CAdapt_ItView::OnClose(bool deleteWindow)
{
	deleteWindow = deleteWindow; // avoids "unreferenced formal parameter" warning

	// Clear the canvas in  case we're in single-window mode,
	// and the canvas stays.
	canvas->ClearBackground();

	canvas->pView = (CAdapt_ItView *) NULL;
	canvas = (CAdapt_ItCanvas *) NULL;

	wxString s(wxTheApp->GetAppName());
	if (pCanvasFrame)
		pCanvasFrame->SetTitle(s);

	SetFrame((wxFrame*)NULL);
	Activate(FALSE);

	return TRUE;
}

void CAdapt_ItView::Invalidate() // for MFC compatibility & flicker suppression
{
	CAdapt_ItApp* pApp = &wxGetApp();
	wxASSERT(pApp != NULL);
	// wxWidgets' wxView class does not itself have an Invalidate() method like MFC
	// The wxWindow class has Refresh(), so we'll get the window associated with
	// the current View and refresh it.

#ifdef Do_Clipping
	CLayout* pLayout = GetLayout();
    // if scrolling, or the phrase box is beyond the document's end, or a full window draw
    // was requested by RecalcLayout() or Redraw(), then do it; otherise assume the user is
    // typing or deleting in the phrase box and clip to the active pile's rectangle
	bool bCurrentlyScrolling =  pLayout->GetScrollingFlag();
	bool bDoFullWindowDraw = pLayout->GetFullWindowDrawFlag();

	if (bCurrentlyScrolling || bDoFullWindowDraw || 
		(pApp->m_nActiveSequNum == -1 || pApp->m_pActivePile == NULL) ||
		pApp->m_bFreeTranslationMode)
	{
		// no clipping this time, either scrolling or full window draw wanted
		pApp->GetMainFrame()->canvas->Refresh();
	}
	else
	{
		if (pApp->m_pActivePile != NULL)
		{
			/* BEW changed 3Jul09, see comment below, a zero rectangle suffices for clipping
			//pLayout->SetClipRectangle(pApp->m_pActivePile);
			//wxRect r = pLayout->GetClipRect();

            // debug test: halve the height, it appears to be too deep a rectangle because
            // there is drawing (because we see flicker there) under the phrase box's width
            // for two strips below the box -- test if this can be stopped? Yes, the strip
            // below had no content, but the second did, and halving the height stopped the
            // blink. However, it appears that the phrase box typing goes in and is visible
            // regardless of how big the view's clip rectangle is, is that so? Yes indeed,
            // so there is no point in wasting time on calculating the clip rectangle to be
            // just the box's rectangle or the pile's rectangle, just make it a zero
            // rectange so the Draw() of the view draws nothing, to save time.
			//int height = r.GetHeight();
			//r.SetHeight(height / 2);
			*/
			wxRect r;
			r.SetTop(0); r.SetLeft(0); r.SetWidth(0); r.SetHeight(0);

			// we clip to update only the innards of the phrase box control
			pLayout->m_pMainFrame->canvas->Refresh(TRUE,&r);
		}
		else
		{
			// no clipping this time, refresh whole client area (control should never
			// enter this block)
			pApp->GetMainFrame()->canvas->Refresh();
		}
	}
#else
	// no clipping support, refresh whole client area every time 
	// RecalcLayout() is called
	pApp->GetMainFrame()->canvas->Refresh();
#endif
}

// whm added 12Jun07
void CAdapt_ItView::DrawTextRTL(wxDC* pDC, wxString& str, wxRect& rect)
{
    // This function attempts to alieviate the limitations of wxDC::DrawText() which does
    // not have an nFormat parameter as does the MFC function CDC::DrawText() and which
    // currently (as of wxWidgets 2.8.4) has different behaviors on wxMSW, wxGTK and wxMAC.
    // 
    // The challenge here is due in part to the fact that the wxDC::SetLayoutDirection()
    // method applies to the whole DC and, on wxMSW (but not the other ports)
    // SetLayoutDirection() effectively mirrors the underlying coordinate system (requiring
    // coordinate values input to DrawText and other drawing methods be reversed on the
    // x-axis while SetLayoutDirection() is set to RTL. Hence, for wxMSW, we must transform
    // the coordinates in such a way that, while mirroring is in effect, the logical 0,0
    // coordinate for drawing text is located at the upper right corner of the logical
    // document and x coordinate values increase toward the left rather than toward the
    // right. The wxGTK and wxMac ports do not require the use of SetLayoutDirection() to
    // render punctuation correctly for RTL text, but drawing RTL text in those cases
    // requires that we must adjust the drawing coordinates of RTL text to start drawing at
    // the left end of the resulting RTL text, rather than at the right end (as MFC does).
    // I've also used a wxRect as parameter rather than wxCoord x and wxCoord y coordinate
    // parameters to make the upper right corner of the wxRect more readily available to
    // the function.
	//
	// TODO: Since the wxWidgets RTL rendering behaviors are obviously still somewhat in an 
	// immature state of development (and may change in future library releases to become 
	// more uniform across platforms) this issue needs to be visited again upon any
	// anticipated upgrade to newer versions of wxWidgets beyond version 2.8.4.
	//
	// For wxMSW we must transform the coordinates of rect's upper right corner to 
	// account for the mirroring of the underlying coordinate system on Windows 
	// (the wxGTK and wxMac do not seem to do the mirroring of the underlying 
	// coordinates).
	// first get the upper right coords of the drawing rect
	wxPoint urPt(rect.GetRight(),rect.GetTop());
	// transform this point to have mirrored x-axis coordinates. grectViewClient should
	// indicate the current client view's total width, so if we subtract the urPt.x value
	// from grectViewClient.GetWidth(), we should have the "mirrored" x-axis coordinate
	// value for RTL layout.
	
	// wxGTK and wxMac need to start drawing text at the point urPt less the width/extent
	// of the text to be drawn
	wxSize sizeOfPhrase = pDC->GetTextExtent(str);
	pDC->DrawText(str,urPt.x - sizeOfPhrase.x,urPt.y);


#ifdef __WXMSW__
	// turning off RTL layout of the DC after calling DrawText() seems to be necessary 
	// to best emulate what MFC's DrawText() does with its nFormat parameter
	pDC->SetLayoutDirection(wxLayout_LeftToRight); // need this???
#endif
}
