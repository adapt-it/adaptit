/////////////////////////////////////////////////////////////////////////////
/// \project		adaptit
/// \file			ReadOnlyProtection.cpp
/// \author			Bruce Waters
/// \date_created	10 November 2009
/// \date_revised	
/// \copyright		2009 Bruce Waters, Bill Martin, SIL International
/// \license		The Common Public License or The GNU Lesser General Public 
///                 License (see license directory)
/// \description	Implementation file for read-only protection of a user
///					working in a project folder, and someone accesses that
///					folder remotely (such as an Administrator using the
///					Custom Work Folder Location command), and tries to do somee
///					work there which would, if there were no protection, potentially
///					lead to the user unknowingly losing data from either a document
///					or the KB, or both.
/// \derivation		The ReadOnlyProtection class is derived from wxObject.
/////////////////////////////////////////////////////////////////////////////

// the following improves GCC compilation performance
#if defined(__GNUG__) && !defined(__APPLE__)
    #pragma implementation "ReadOnlyProtection.h"
#endif

// For compilers that support precompilation, includes "wx.h".
#include <wx/wxprec.h>

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
// Include your minimal set of headers here, or wx.h
#include <wx/wx.h>
#endif

// other includes
#include <wx/docview.h> // needed for classes that reference wxView or wxDocument
#include <wx/dir.h>

#include "Adapt_It.h"
#include "ReadOnlyProtection.h"

// Define type safe pointer lists
//#include "wx/listimpl.cpp"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC_CLASS(ReadOnlyProtection, wxObject)

ReadOnlyProtection::ReadOnlyProtection()
{
	m_pApp = &wxGetApp();
}

ReadOnlyProtection::ReadOnlyProtection(CAdapt_ItApp* pApp)  // use this one, it sets m_pLayout
{
	m_pApp = pApp;
}


ReadOnlyProtection::~ReadOnlyProtection()
{

}

// implementation

void ReadOnlyProtection::Initialize()
{
	m_strAIROP_Prefix = _T("~AIROP"); // first part of the filename
	m_strLock_Suffix = _T(".lock"); // the suffix to add to the filename's end

	// obtain the host machine's name, and the current user's id (ie. the name used
	// in path specifications);  set defaults if either or both can't be determined
	m_strLocalUsername = GetLocalUsername();
	if (m_strLocalUsername.IsEmpty())
	{
		m_strLocalUsername = _T("UnknownUser"); // not localizable, just need 'something'
	}
	m_strLocalMachinename = GetLocalMachinename();
	if (m_strLocalMachinename.IsEmpty())
	{
		m_strLocalMachinename = _T("UnknownMachine"); // ditto
	}
	m_strLocalProcessID = GetLocalProcessID();
	// set up the filename for read only protection, which is for this particular user
	// and host machine and process ID; it remains unchanged for the session
	m_strReadOnlyProtectionFilename = MakeReadOnlyProtectionFilename(m_strAIROP_Prefix,
		m_strLock_Suffix, m_strLocalMachinename, m_strLocalUsername, m_strLocalProcessID);

	// at launch, this one should be empty
	m_strOwningReadOnlyProtectionFilename.Empty();

	// make the file descriptor integer default to stderr for a safe useless value
	//ropFD = wxFile::fd_stderr;
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		the current user id, or an empty string if it cannot be determined
/// \remarks	Obtain from wxWidgets "Network, user and OS functions" calls; if empty string
///				returned, the caller should set up a default string such as "UnknownUser"
///////////////////////////////////////////////////////////////////////////////////////////
wxString ReadOnlyProtection::GetLocalUsername()
{
	wxString theName = ::wxGetUserId(); // returns empty string if not found
	return theName;
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		the host machine's name, or an empty string if it cannot be determined
/// \remarks	Obtain from wxWidgets "Network, user and OS functions" calls; if empty string
///				returned, the caller should set up a default string such as "UnknownMachine"
///////////////////////////////////////////////////////////////////////////////////////////
wxString ReadOnlyProtection::GetLocalMachinename()
{
	// get's the host machine's name (ignores domain name)
	wxString theMachine = ::wxGetHostName(); // returns empty string if not found
	return theMachine;
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		the host machine's process ID for the running instance of Adapt It, or 
///             the string generated by converting 0xFFFF if there was an error
/// \remarks	Obtain from wxWidgets "Process control functions" calls
///////////////////////////////////////////////////////////////////////////////////////////
wxString ReadOnlyProtection::GetLocalProcessID()
{
	unsigned long pid = ::wxGetProcessId();
	if (pid == 0)
	{
		pid = 0xFFFF;
	}
	wxString pidValueStr = wxString::Format(_T("%i"),pid);
	return pidValueStr;
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		the username part of "~AIROP-machinename-username.lock"
///	\param		strFilename		->	the read-only protect filename that was found
/// \remarks	extract the username string from the filename; pass filename by value so
///				we can play with the string internally with impunity
///				Internally accesses the CAdapt_ItApp class's wxString member m_strLock_Suffix
///////////////////////////////////////////////////////////////////////////////////////////
wxString ReadOnlyProtection::ExtractUsername(wxString strFilename)
{
	wxString theName = _T(""); // not localizable
	int offset = strFilename.Find(_T("-")); // first hyphen, machinename follows it
	wxASSERT(offset > 5);
	theName = strFilename.Mid(offset + 1);
	offset = theName.Find(_T("-")); // second hyphen, username follows it
	wxASSERT(offset > 0);
	theName = theName.Mid(offset + 1); // theName now starts with username
	offset = theName.Find(_T("-")); // finds the next hyphen
	wxASSERT(offset > 0);
	theName = theName.Left(offset);
	return theName;
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		the processID part of "~AIROP-machinename-username-processID.lock"
///	\param		strFilename		->	the read-only protect filename that was found
/// \remarks	extract the process ID string from the filename; pass filename by value so
///				we can play with the string internally with impunity
///				Internally accesses the CAdapt_ItApp class's wxString member m_strLock_Suffix
///////////////////////////////////////////////////////////////////////////////////////////
wxString ReadOnlyProtection::ExtractProcessID(wxString strFilename)
{
	wxString theID = _T(""); // not localizable
	int offset = strFilename.Find(_T("-")); // first hyphen, machinename follows it
	wxASSERT(offset > 5);
	theID = strFilename.Mid(offset + 1);
	offset = theID.Find(_T("-")); // second hyphen, username follows it
	wxASSERT(offset > 0);
	theID = theID.Mid(offset + 1); // theID now starts with username
	offset = theID.Find(_T("-")); // third hyphen, processID follows it
	wxASSERT(offset > 0);
	theID = theID.Mid(offset + 1); // theID now starts with processID string
	offset = theID.Find(m_strLock_Suffix); // finds the ".lock" string at end of theName
	wxASSERT(offset > 0);
	theID = theID.Left(offset);
	return theID;
}
///////////////////////////////////////////////////////////////////////////////////////////
/// \return		the machinename part of "~AIROP-machinename-username.lock"
///	\param		strFilename		->	the read-only protect filename that was found
/// \remarks	extract the machinename string from the filename; pass filename by value so
///				we can play with the string internally with impunity
///////////////////////////////////////////////////////////////////////////////////////////
wxString ReadOnlyProtection::ExtractMachinename(wxString strFilename)
{
	wxString theMachine = _T(""); // not localizable
	int offset = strFilename.Find(_T("-")); // first hyphen, machinename follows it
	wxASSERT(offset > 5);
	theMachine = strFilename.Mid(offset + 1);
	offset = theMachine.Find(_T("-")); // second hyphen, username follows it
	wxASSERT(offset > 0);
	theMachine = theMachine.Left(offset);
	return theMachine;
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		the composed filename, of form "~AIROP-machinename-username.lock"
///	\param		prefix		->	"~AIROP" always
/// \param		suffix		->	".lock" always
///	\param		machinename	->	local computer's name
/// \param		username	->	local user's name
/// \remarks	compose the read-only protection filename, for the local machine & user
///////////////////////////////////////////////////////////////////////////////////////////
wxString ReadOnlyProtection::MakeReadOnlyProtectionFilename(
					const wxString prefix, // pass in m_strAIROP_Prefix
					const wxString suffix, // pass in m_strLock_Suffix
					const wxString machinename,
					const wxString username,
					const wxString processID)
{
	wxString str = prefix;
	str += _T("-") + machinename;
	str += _T("-") + username;
	str += _T("-") + processID;
	return str += suffix;
}


///////////////////////////////////////////////////////////////////////////////////////////
/// \return		return TRUE if users or machines or both don't match; return FALSE when both
///				users and machines are the same (that is, FALSE means the running instance
///				making the test has ownership of the project folder already, and so writing of
///				KB and documents should not be prevented, also return FALSE if noone currently
///				owns the folder being checked
///	\param		localMachine	->	local computer's name
/// \param		localUser		->	local user's name
///	\param		theOtherMachine	->	target folder's computer's name (can be local machine)
/// \param		theOtherUser	->	target folder's user's name (can be the local user)
/// \remarks	Test to determine whether or not the target folder is owned currently, and if
///				it is, then who owns it - whether myself, or someone else. Returning a FALSe
///				value tells the caller that I can safely take possession of the target folder
///				for writing
///////////////////////////////////////////////////////////////////////////////////////////
bool ReadOnlyProtection::IsDifferentUserOrMachineOrProcess(wxString& localMachine,
					wxString& localUser, wxString& localProcessID, wxString& theOwningMachine,
					wxString& theOwningUser, wxString& theOwningProcessID)
{
	// first check for nobody currently owning the folder - if that is the case
	// then return FALSE so that I can become its owner
	if (theOwningMachine.IsEmpty() || theOwningUser.IsEmpty() || theOwningProcessID.IsEmpty())
		return FALSE;
	// if we get here, someone is the owner of the target folder, so find out who
	if (localMachine != theOwningMachine)
		return TRUE;
	if (localUser != theOwningUser)
		return TRUE;
	if (localProcessID != theOwningProcessID)
		return TRUE;
    // if we get here, each is a match for the other, so I & my process already am the
    // owner of the target folder, so return FALSE
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		the absolute path to the read-only protection file in the passed in folder,
///				if it exists in the folder; otherwise, an empty string
///	\param		projectFolderPath ->	absolute path to the project folder being checked
/// \remarks	Search for a matching file in the project folder. wxRegEx class is not safe
///				to use because regular expression support for Unicode may not work - one system
///				does not support matching across character block boundaries, another (eg. VIM)
///				allows this but limits matches to 128 (enough for our purposes but the wx 
///				documentation doesn't indicate if this is supported). So we don't use regular
///				expressions to obtain a match; instead, we search for the prefix "~AIROP" and
///				the suffix ".lock" and the presence of two hyphens. That much extremely unlikely
///				to occur by accident in an arbitrary filename from another unrelated source.
///////////////////////////////////////////////////////////////////////////////////////////
wxString ReadOnlyProtection::GetReadOnlyProtectionFileInProjectFolder(wxString& projectFolderPath)
{
	wxString theFilename = _T("");
	// test to make sure we are not trying to look at a file rather than a folder

	bool bIsReallyAFile = ::wxFileExists(projectFolderPath);
	if (bIsReallyAFile)
	{
		// this message should be localizable; we allow processing to continue, returning an 
		// empty string (the user should then retry to access a directory)
        // NOTE: if .Format is used, it has to be embedded within wxMessageBox(), otherwise
        // the box doesn't see the message and has very narrow width and no title
		wxString mssg;
		wxMessageBox(mssg.Format(
_("The project folder being tested, %s, is really a file. Adapt It will continue running, but you should next try to properly locate a project folder."),
				projectFolderPath),_("Warning: Not a folder!"), wxICON_WARNING);
		return theFilename;
	}
	bool bDirectoryExists = wxDir::Exists(projectFolderPath); // a static function
	if (bDirectoryExists)
	{
		wxDir dir(projectFolderPath);
		bool bIsOpened = dir.IsOpened();
		if (!bIsOpened)
		{
			// it didn't open, this is unexpected and probably is something for the developer
			// to fix, so warn and abort
            // NOTE: if .Format is used, it has to be embedded within wxMessageBox(),
            // otherwise the box doesn't see the message and has very narrow width and no
            // title
			wxString mssg;
			wxMessageBox(mssg.Format(
_T("GetReadOnlyProtectionFileInProjectFolder(): the directory %s failed to open for enumeration. Now aborting."),
			projectFolderPath),_T("wxDir() Err: directory not opened"), wxICON_ERROR);
			wxExit();
			return theFilename;
		}
		else
		{
			// it was opened okay; so return an empty string if there are no files within,
			// otherwise find (using wildcard *) the one and only read-only projection
			// file - if it exists; if found, return it to caller, it none is found, return
			// the empty string
			bool bHasFiles = FALSE;
			// make the wildcarded file spec
			wxString theFileSpec = m_strAIROP_Prefix;
			theFileSpec += _T("-*");
			theFileSpec += m_strLock_Suffix;
			bHasFiles = dir.HasFiles(theFileSpec); // try match "~AIROP-*.lock"
			if (bHasFiles)
			{
				// a file matching the specification is present, so get it & return its
				// filename to the caller
				bool bGotIt = dir.GetFirst(&theFilename, theFileSpec, wxDIR_FILES);
				if (!bGotIt)
				{
					// unexpectedly failed to get it, so tell developer and then abort
                    // NOTE: if .Format is used, it has to be embedded within
                    // wxMessageBox(), otherwise the box doesn't see the message and has
                    // very narrow width and no title
					wxString mssg;
					wxMessageBox(mssg.Format(
_T("GetReadOnlyProtectionFileInProjectFolder(): the directory %s has the protection file of form ~AIROP-*.lock, but GetFirst() failed to get it. Now aborting."),
					projectFolderPath),_T("wxDir() Err: GetFirst() failed"), wxICON_ERROR);
					wxExit();
					return theFilename;
				}
			}
			else
			{
				// no match, so tell the caller so (return an empty string)
				return theFilename; // it's still the empty string
			}
		}
	}
	else
	{
		// the directory should exist - warn user and call OnExit() to abort; only the 
		// developers should ever get to see this error so don't make it localizable
		// NOTE: if .Format is used, it has to be embedded within wxMessageBox(),
		// otherwise the box doesn't see the message and has very narrow width and
		// no title
		wxString mssg;
		wxMessageBox(mssg.Format(
_T("GetReadOnlyProtectionFileInProjectFolder(): the path, %s, to the passed in project folder was tested and found to not exist! Now aborting."),
		projectFolderPath),_T("wxDir Err: dir not exist"), wxICON_ERROR);
		wxExit();
	}
	// populate the "owning" private members before returning
	m_strOwningMachinename = ExtractMachinename(theFilename);
	m_strOwningUsername = ExtractUsername(theFilename);
	m_strOwningProcessID = ExtractProcessID(theFilename);
	return theFilename;
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the protection file (with form ~AIROP-*.lock, where * is
///             machinename-username-processID) is not open for writing. This would only
///             be the case if it is a zombie left over when the app died or power was lost.
///             Return FALSE if it is open for writing.
///	\param		projectFolderPath  ->  absolute path to the project folder being checked
///	\param      ropFile            ->  the read-only protection filename (see above)
/// \remarks	Builds the path to the protection filename and attempts to remove the file.
///             This will succeed only if the file is not open for writing. A side-effect
///             therefore is the successful removal of the file if in fact it was a zombie.
///////////////////////////////////////////////////////////////////////////////////////////
bool ReadOnlyProtection::IsZombie(wxString& folderPath, wxString& ropFile)
{
	wxString pathToFile = folderPath + m_pApp->PathSeparator + ropFile;
	wxASSERT(::wxFileExists(pathToFile));
    // The file can be removed only if it is a (closed) one, that is, a zombie left over
    // from a crash or power loss (regardless of whoever was the former owner for writing)
	bool bRemoved = ::wxRemoveFile(pathToFile);
	if (bRemoved)
	{
		// we were able to remove it, so it's a zombie
		return TRUE;
	}
	else
	{
        // we could not remove it, so it is already opened by someone else's process, (even
        // the original one I initiated myself)
		return FALSE;
	}
}

bool ReadOnlyProtection::RemoveROPFile(wxString& projectFolderPath, wxString& ropFile)
{
	wxString pathToFile = projectFolderPath + m_pApp->PathSeparator + ropFile;
	wxASSERT(::wxFileExists(pathToFile));

	// removal will only be possible if I on the localMachine in the process having
	// the localProcessID, became the owner in the first place; so we must test
	// that all the ducks line up for this running instance to be able to remove it,
	// and report back to the caller what the outcome was
	bool bRemoved = TRUE;
	bool bItsNotMe = IsItNotMe(projectFolderPath);
	if (bItsNotMe)
	{
		// not me, or not same process, so the file cannot be removed
		return FALSE;
	}
	else
	{
		// it's an opened protection file, and my process qualifies for closing it and
		// then deleting it; do so
		m_pApp->m_pROPwxFile->Close(); // ignore returned boolean, this shouldn't fail
		bRemoved = ::wxRemoveFile(pathToFile); // may fail
	}
	return bRemoved;
}

///////////////////////////////////////////////////////////////////////////////////////////
/// \return		TRUE if the owning username, or owning machine, or owning process which owns
///             write permission, is different from my (local) username, machinename, and/or
///             running process; if FALSE is returned, then my process on my machine is the
///             owner of write permission
/// \remarks	Encapsulates the test for whether or not I and my process & machine is the
///             one that originally gained ownership of the project folder for writing
///////////////////////////////////////////////////////////////////////////////////////////
bool ReadOnlyProtection::IsItNotMe(wxString& projectFolderPath)
{
	m_strOwningReadOnlyProtectionFilename = 
							GetReadOnlyProtectionFileInProjectFolder(projectFolderPath);
	m_strOwningMachinename = ExtractMachinename(m_strOwningReadOnlyProtectionFilename);
	m_strOwningUsername = ExtractUsername(m_strOwningReadOnlyProtectionFilename);
	m_strOwningProcessID = ExtractProcessID(m_strOwningReadOnlyProtectionFilename);
	bool bItsNotMe = IsDifferentUserOrMachineOrProcess(m_strLocalMachinename,
						m_strLocalUsername, m_strLocalProcessID, m_strOwningMachinename, 
						m_strOwningUsername, m_strOwningProcessID);
	return bItsNotMe;
}

bool ReadOnlyProtection::IsTheProjectFolderOwnedForWriting(wxString& projectFolderPath)
{
	m_strOwningReadOnlyProtectionFilename.Empty();
	m_strOwningUsername.Empty();
	m_strOwningMachinename.Empty();
	// get the file, if one exists in the folder, else get an empty string
	// (this call also populates the m_strOwningMachinename, m_strOwningUsername and
	// m_strOwningProcessID private strings based on the info in the protection filename)
	m_strOwningReadOnlyProtectionFilename = 
							GetReadOnlyProtectionFileInProjectFolder(projectFolderPath);
	if (m_strOwningReadOnlyProtectionFilename.IsEmpty())
	{
		// there is no read-only protection file in this project folder
		return FALSE; // tell caller I now have qualified to own it for writing
	}
	else
	{
		// there is a read-only protection file in this project, and so there
		// are two possibilities:
		// (1) it's a zombie left over after a crash or power loss - in which case we
		// can delete it because the project folder is not then owned by anyone, or
		// (2) someone else's process (or another one which I initiated) has the 
		//     ownership of write permission - and so we must return TRUE
		bool bIsZombie = IsZombie(projectFolderPath, m_strOwningReadOnlyProtectionFilename);
		if(bIsZombie)
		{
            // it was a zombie, and the test had the side effect of removing it...
            // so I can now become the owner for writing
			return FALSE;
		}
	}
	// write permission is currently owned by someone (it could be me though)
	return TRUE;
}

// the return value sets or clears pApp->m_bReadOnlyAccess
// call when entering project or opening or creating a document
bool ReadOnlyProtection::SetReadOnlyProtection(wxString& projectFolderPath) 
{
	bool bIsOwned = IsTheProjectFolderOwnedForWriting(projectFolderPath);
	if (bIsOwned)
	{
		// we need to distinguish me on my machine in my running process, from
		// another user/machine/or process (even if the process is a second one
		// which I initiated on this machine and am trying to access the same
		// project folder that my earlier process succeeded in getting access to)
		bool bItsNotMe = IsItNotMe(projectFolderPath);
		if (bItsNotMe)
		{
			// I don't qualify to own this project folder, I can only have read-only
			// access (this message is localizable)
			wxMessageBox(
_("You have READ-ONLY access to this project folder."),_("Another process owns write permission"),
			wxICON_INFORMATION);
			return TRUE; // return TRUE to app member m_bReadOnlyAccess
		}
		else
		{
            // it's me, in the same process which originally got ownership so just return
            // FALSE as I have full write permission already, and FALSE maintains that
			return FALSE;  // return FALSE to app member m_bReadOnlyAccess
		}
	}
	else
	{
		// the project folder is not owned for writing - this covers the the zombie
		// case, and also when no running Adapt It instance has as yet entered this
		// project folder... so set my process up as its owner
		wxASSERT(!m_strReadOnlyProtectionFilename.IsEmpty()); // m_pROP->Initialize() 
            // should have made it already; likewise the members m_strLocalUsername &
            // m_strLocalMachinename and m_strLocalProcessID
		wxASSERT(!m_strLocalMachinename.IsEmpty());
		wxASSERT(!m_strLocalUsername.IsEmpty());
		wxASSERT(!m_strLocalProcessID.IsEmpty());

		m_strOwningMachinename = m_strLocalMachinename;
		m_strOwningUsername = m_strLocalUsername;
		m_strOwningProcessID = m_strLocalProcessID;
		m_strOwningReadOnlyProtectionFilename = m_strReadOnlyProtectionFilename;
		wxString readOnlyProtectionFilePath = projectFolderPath + m_pApp->PathSeparator + 
												m_strReadOnlyProtectionFilename;
		m_pApp->m_pROPwxFile->Open(readOnlyProtectionFilePath,wxFile::write);
		wxASSERT(m_pApp->m_pROPwxFile->IsOpened()); // check it got opened
	}
	return FALSE; // return FALSE to app member m_bReadOnlyAccess
}

// Removal can only be done by the process which currently has ownership of write
// permission for the passed in project folder; a second process coming along later cannot
// force the owner to relinquish ownership. The return value always be used for setting
// or clearing pApp->m_bReadOnlyAccess; TRUE is returned if Removal was successful, FALSE
// is returned if ownership is retained be someone else because this process does not qualify
// for removing of protection.
// Call this function when the running instance relinguishes the project
bool ReadOnlyProtection::RemoveReadOnlyProtection(wxString& projectFolderPath) 
{
	// get the current protection file, if there is one (this call tests for a zombie
	// as well, and if it finds one it deletes it & returns FALSE)
	bool bRemoved = FALSE;
	bool bOwned = IsTheProjectFolderOwnedForWriting(projectFolderPath);
	if (bOwned)
	{
		//  the following line effects the removal only if the protection file, when
		//  tested, turns out to be for me on my machine in the process which originally
		//  was successful in getting ownership of write privileges for this project folder
		bRemoved = RemoveROPFile(projectFolderPath, m_strOwningReadOnlyProtectionFilename);
		if (bRemoved)
		{
			m_strOwningMachinename.Empty();
			m_strOwningUsername.Empty();
			m_strOwningProcessID.Empty();
			m_strOwningReadOnlyProtectionFilename.Empty();
		}
	}
	else
	{
		// it's not owned, and this covers the zombie case too; return TRUE as these
		// circumstances is equivalent to having succeeded in removing ownership
		m_strOwningMachinename.Empty();
		m_strOwningUsername.Empty();
		m_strOwningProcessID.Empty();
		m_strOwningReadOnlyProtectionFilename.Empty();
		bRemoved = TRUE;
	}
	return bRemoved; 
}
